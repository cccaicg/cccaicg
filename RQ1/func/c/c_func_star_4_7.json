{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start, \n                            swig_module_info *end, \n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1; \n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\t    \n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Get a Ruby number to reference an object */\n", "func_signal": "SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object)", "code": "{\n  /* We cast the object to an unsigned long\n     and then store a reference to it using\n     a Ruby number object. */\n\n  /* Convert the Object to a Ruby number */\n  unsigned long value = (unsigned long) object;\n  return LONG2NUM(value);\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Define custom exceptions for errors that do not map to existing Ruby\n   exceptions.  Note this only works for C++ since a global cannot be\n   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/\n", "func_signal": "SWIGINTERN VALUE \ngetNullReferenceError(void)", "code": "{\n  static int init = 0;\n  static VALUE rb_eNullReferenceError ;\n  if (!init) {\n    init = 1;\n    rb_eNullReferenceError = rb_define_class(\"NullReferenceError\", rb_eRuntimeError);\n  }\n  return rb_eNullReferenceError;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)", "code": "{\n  char *c;\n  swig_cast_info *tc;\n  void *vptr = 0;\n\n  /* Grab the pointer */\n  if (NIL_P(obj)) {\n    *ptr = 0;\n    return SWIG_OK;\n  } else {\n    if (TYPE(obj) != T_DATA) {\n      return SWIG_ERROR;\n    }\n    Data_Get_Struct(obj, void, vptr);\n  }\n  \n  if (own) *own = RDATA(obj)->dfree;\n    \n  /* Check to see if the input object is giving up ownership\n     of the underlying C struct or C++ object.  If so then we\n     need to reset the destructor since the Ruby object no \n     longer owns the underlying C++ object.*/ \n  if (flags & SWIG_POINTER_DISOWN) {\n    /* Is tracking on for this class? */\n    int track = 0;\n    if (ty && ty->clientdata) {\n      swig_class *sklass = (swig_class *) ty->clientdata;\n      track = sklass->trackObjects;\n    }\n\t\t\n    if (track) {\n      /* We are tracking objects for this class.  Thus we change the destructor\n       * to SWIG_RubyRemoveTracking.  This allows us to\n       * remove the mapping from the C++ to Ruby object\n       * when the Ruby object is garbage collected.  If we don't\n       * do this, then it is possible we will return a reference \n       * to a Ruby object that no longer exists thereby crashing Ruby. */\n      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;\n    } else {    \n      RDATA(obj)->dfree = 0;\n    }\n  }\n\n  /* Do type-checking if type info was provided */\n  if (ty) {\n    if (ty->clientdata) {\n      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {\n        if (vptr == 0) {\n          /* The object has already been deleted */\n          return SWIG_ObjectPreviouslyDeletedError;\n        }\n        *ptr = vptr;\n        return SWIG_OK;\n      }\n    }\n    if ((c = SWIG_MangleStr(obj)) == NULL) {\n      return SWIG_ERROR;\n    }\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) {\n      return SWIG_ERROR;\n    }\n    *ptr = SWIG_TypeCast(tc, vptr);\n  } else {\n    *ptr = vptr;\n  }\n  \n  return SWIG_OK;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Define Ruby class for C type */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_define_class(swig_type_info *type)", "code": "{\n  VALUE klass;\n  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n  sprintf(klass_name, \"TYPE%s\", type->name);\n  if (NIL_P(_cSWIG_Pointer)) {\n    _cSWIG_Pointer = rb_define_class_under(_mSWIG, \"Pointer\", rb_cObject);\n    rb_undef_method(CLASS_OF(_cSWIG_Pointer), \"new\");\n  }\n  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);\n  free((void *) klass_name);\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* \n   Set the clientdata field for a type\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata)", "code": "{\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n  \n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n\tSWIG_TypeClientData(tc, clientdata);\n      }\n    }    \n    cast = cast->next;\n  }\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start, \n                     swig_module_info *end, \n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n  \n  /* neither found a match */\n  return 0;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeCompare(const char *nb, const char *tb)", "code": "{\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Get a Ruby number to reference a pointer */\n", "func_signal": "SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr)", "code": "{\n  /* We cast the pointer to an unsigned long\n     and then store a reference to it using\n     a Ruby number object. */\n\n  /* Convert the pointer to a Ruby number */\n  unsigned long value = (unsigned long) ptr;\n  return LONG2NUM(value);\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* \n  Compare two type names skipping the space characters, therefore\n  \"char*\" == \"char *\" and \"Class<int>\" == \"Class<int >\", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping ' '.\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n\t\t  const char *f2, const char *l2)", "code": "{\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == ' ') && (f1 != l1)) ++f1;\n    while ((*f2 == ' ') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (l1 - f1) - (l2 - f2);\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if not equal, 1 if equal\n*/\n", "func_signal": "SWIGRUNTIME int\nSWIG_TypeEquiv(const char *nb, const char *tb)", "code": "{\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == '|') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Get a Ruby object from a previously stored reference */\n", "func_signal": "SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference)", "code": "{\n  /* The provided Ruby number object is a reference\n     to the Ruby object we want.*/\n\n  /* First convert the Ruby number to a C number */\n  unsigned long value = NUM2LONG(reference);\n  return (VALUE) value;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)", "code": "{\n  int own =  flags & SWIG_POINTER_OWN; \n  \n  char *klass_name;\n  swig_class *sklass;\n  VALUE klass;\n  VALUE obj;\n  \n  if (!ptr)\n    return Qnil;\n  \n  if (type->clientdata) {\n    sklass = (swig_class *) type->clientdata;\n\t\t\n    /* Are we tracking this class and have we already returned this Ruby object? */\n    if (sklass->trackObjects) {\n      obj = SWIG_RubyInstanceFor(ptr);\n      \n      /* Check the object's type and make sure it has the correct type.\n        It might not in cases where methods do things like \n        downcast methods. */\n      if (obj != Qnil) {\n        VALUE value = rb_iv_get(obj, \"__swigtype__\");\n        char* type_name = RSTRING_PTR(value);\n\t\t\t\t\n        if (strcmp(type->name, type_name) == 0) {\n          return obj;\n        }\n      }\n    }\n\n    /* Create a new Ruby object */\n    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);\n\n    /* If tracking is on for this class then track this object. */\n    if (sklass->trackObjects) {\n      SWIG_RubyAddTracking(ptr, obj);\n    }\n  } else {\n    klass_name = (char *) malloc(4 + strlen(type->name) + 1);\n    sprintf(klass_name, \"TYPE%s\", type->name);\n    klass = rb_const_get(_mSWIG, rb_intern(klass_name));\n    free((void *) klass_name);\n    obj = Data_Wrap_Struct(klass, 0, 0, ptr);\n  }\n  rb_iv_set(obj, \"__swigtype__\", rb_str_new2(type->name));\n  \n  return obj;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* \n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = ((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = ((d - ('a'-10)) << 4);\n    else \n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (d - ('a'-10));\n    else \n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* This code checks to see if the Ruby object being raised as part\n   of an exception inherits from the Ruby class Exception.  If so,\n   the object is simply returned.  If not, then a new Ruby exception\n   object is created and that will be returned to Ruby.*/\n", "func_signal": "SWIGRUNTIME VALUE\nSWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj)", "code": "{\n  VALUE exceptionClass = getExceptionClass();\n  if (rb_obj_is_kind_of(obj, exceptionClass)) {\n    return obj;\n  }  else {\n    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));\n  }\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*@SWIG@*/\n", "func_signal": "SWIGINTERN int\nSWIG_AsVal_double (VALUE obj, double *val)", "code": "{\n  VALUE type = TYPE(obj);\n  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {\n    double v;\n    VALUE a[2];\n    a[0] = obj;\n    a[1] = (VALUE)(&v);\n    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {\n      if (val) *val = v;\n      return SWIG_OK;\n    }\n  }\n  return SWIG_TypeError;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Initialize Ruby runtime support */\n", "func_signal": "SWIGRUNTIME void\nSWIG_Ruby_InitRuntime(void)", "code": "{\n  if (_mSWIG == Qnil) {\n    _mSWIG = rb_define_module(\"SWIG\");\n  }\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*@SWIG@*/\n", "func_signal": "SWIGINTERN int\nSWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val)", "code": "{\n  VALUE type = TYPE(obj);\n  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {\n    unsigned long v;\n    VALUE a[2];\n    a[0] = obj;\n    a[1] = (VALUE)(&v);\n    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {\n      if (val) *val = v;\n      return SWIG_OK;\n    }\n  }\n  return SWIG_TypeError;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty)", "code": "{\n  swig_cast_info *tc;\n  const char  *c;\n\n  if (TYPE(obj) != T_STRING) goto type_error;\n  c = StringValuePtr(obj);\n  /* Pointer values must start with leading underscore */\n  if (*c != '_') goto type_error;\n  c++;\n  c = SWIG_UnpackData(c, ptr, sz);\n  if (ty) {\n    tc = SWIG_TypeCheck(c, ty);\n    if (!tc) goto type_error;\n  }\n  return SWIG_OK;\n\n type_error:\n  return SWIG_ERROR;\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n\n  if (init_run) return;\n  init_run = 1;\n\n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "ext\\mpg123_api_wrap.c", "repo_name": "slowjud/mpg123-ruby", "stars": 5, "license": "None", "language": "c", "size": 134}
{"docstring": "/*\n * Speech_Encode_Frame_init\n *\n *\n * Parameters:\n *    state             O: state structure\n *    dtx               I: dtx mode used\n *\n * Function:\n *    Allocates state memory and initializes state memory\n *\n * Returns:\n *    succeed = 0\n */\n", "func_signal": "void * Speech_Encode_Frame_init( int dtx )", "code": "{\n   Speech_Encode_FrameState * s;\n\n   /* allocate memory */\n   if ( ( s = ( Speech_Encode_FrameState * ) malloc( sizeof(\n         Speech_Encode_FrameState ) ) ) == NULL ) {\n      fprintf( stderr, \"Speech_Encode_Frame_init: can not malloc state \"\n            \"structure\\n\" );\n      return NULL;\n   }\n   s->pre_state = NULL;\n   s->cod_amr_state = NULL;\n   s->dtx = dtx;\n\n   if ( Pre_Process_init( &s->pre_state ) || cod_amr_init( &s->cod_amr_state,\n         dtx ) ) {\n      Speech_Encode_Frame_exit( ( void ** )( &s ) );\n      return NULL;\n   }\n   return s;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * dtx_buffer\n *\n *\n * Parameters:\n *    hist_ptr       B: Circular buffer pointer\n *    lsp_hist       O: LSP history\n *    lsp_new        I: LSP vector\n *    speech         I: input speech\n *    log_en_hist    O: frame energy\n *\n * Function:\n *    Handles the DTX buffer\n *\n *    The frame energy is computed for each frame marked with VAD=0\n *    according to the equation:\n *\n *                                       N-1\n *    en_log(i) = 0.5 * log2 ( (1 / N) * SUM[ s(n) * s(n) ] )\n *                                       N=0\n *\n *    where s(n) is the HP-filtered input speech signal of\n *    the current frame i.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void dtx_buffer( Word16 *hist_ptr, Float32 *lsp_hist, Float32 lsp_new[],\n      Float32 speech[], Float32 *log_en_hist )", "code": "{\n   Float64 frame_en;\n\n\n   /* update pointer to circular buffer */\n   *hist_ptr += 1;\n\n   if ( *hist_ptr == DTX_HIST_SIZE ) {\n      *hist_ptr = 0;\n   }\n\n   /* copy lsp vector into buffer */\n   memcpy( &lsp_hist[ * hist_ptr * M], lsp_new, sizeof( Float32 )*M );\n\n   /* compute log energy based on frame energy */\n   frame_en = Dotproduct40( speech, speech );\n   frame_en += Dotproduct40( &speech[40], &speech[40] );\n   frame_en += Dotproduct40( &speech[80], &speech[80] );\n   frame_en += Dotproduct40( &speech[120], &speech[120] );\n\n   if ( frame_en > 1 ) {\n      log_en_hist[ * hist_ptr] = ( Float32 )( log10( frame_en * 0.00625F )*\n            1.660964F );\n   }\n   else {\n      log_en_hist[ * hist_ptr] = -3.660965F;\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * q_p\n *\n *\n * Parameters:\n *    ind               B: Pulse position\n *    n                 I: Pulse number\n *\n * Function:\n *    Gray coding\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void q_p( Word16 *ind, Word32 n )", "code": "{\n   Word16 tmp;\n\n\n   tmp = *ind;\n\n   if ( n < 5 ) {\n      *ind = ( Word16 )( ( tmp & 0x8 ) | gray[tmp & 0x7] );\n   }\n   else {\n      *ind = gray[tmp & 0x7];\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Pre_Process_reset\n *\n *\n * Parameters:\n *    state                O: state structure\n *\n * Function:\n *    Initializes state memory to zero\n *\n * Returns:\n *\n */\n", "func_signal": "static Word32 Pre_Process_reset( Pre_ProcessState *state )", "code": "{\n   if ( state == ( Pre_ProcessState * )NULL ) {\n      fprintf( stderr, \"Pre_Process_reset: invalid parameter\\n\" );\n      return-1;\n   }\n   state->y2 = 0;\n   state->y1 = 0;\n   state->x0 = 0;\n   state->x1 = 0;\n   return 0;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Reorder_lsf\n *\n *\n * Parameters:\n *    lsf               B: vector of LSFs\n *    min_dist          I: minimum required distance\n *\n * Function:\n *    Make sure that the LSFs are properly ordered and to keep a certain minimum\n *    distance between adjacent LSFs. LPC order = M.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void Reorder_lsf( Float32 *lsf, Float32 min_dist )", "code": "{\n   Float32 lsf_min;\n   Word32 i;\n\n\n   lsf_min = min_dist;\n\n   for ( i = 0; i < M; i++ ) {\n      if ( lsf[i] < lsf_min ) {\n         lsf[i] = lsf_min;\n      }\n      lsf_min = lsf[i] + min_dist;\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * EncoderMMS\n *\n *\n * Parameters:\n *    mode                 I: AMR mode\n *    param                I: Encoder output parameters\n *    stream               O: packed speech frame\n *    frame_type           I: frame type (DTX)\n *    speech_mode          I: speech mode (DTX)\n *\n * Function:\n *    Pack encoder output parameters to octet structure according\n *    importance table and AMR file storage format according to\n *    RFC 3267.\n * Returns:\n *    number of octets\n */\n", "func_signal": "static int EncoderMMS( enum Mode mode, Word16 *param, UWord8 *stream, enum\n      TXFrameType frame_type, enum Mode speech_mode )", "code": "{\n   Word32 j = 0, k;\n   Word16 *mask;\n\n   memset(stream, 0, block_size[mode]);\n\n   *stream = toc_byte[mode];\n   stream++;\n\n   if ( mode == 15 ) {\n      return 1;\n   }\n   else if ( mode == MRDTX ) {\n      mask = order_MRDTX;\n\n      for ( j = 1; j < 36; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n\n      /* add SID type information */\n      if ( frame_type == TX_SID_UPDATE )\n         *stream += 0x01;\n      *stream <<= 3;\n\n      /* speech mode indication */\n      *stream += ( unsigned char )(((speech_mode & 0x0001) << 2) | (speech_mode & 0x0002) | ((speech_mode & 0x0004) >> 2));\n\n\t  *stream <<= 1;\n\n      /* don't shift at the end of the function */\n      return 6;\n   }\n   else if ( mode == MR475 ) {\n      mask = order_MR475;\n\n      for ( j = 1; j < 96; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR515 ) {\n      mask = order_MR515;\n\n      for ( j = 1; j < 104; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR59 ) {\n      mask = order_MR59;\n\n      for ( j = 1; j < 119; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR67 ) {\n      mask = order_MR67;\n\n      for ( j = 1; j < 135; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR74 ) {\n      mask = order_MR74;\n\n      for ( j = 1; j < 149; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR795 ) {\n      mask = order_MR795;\n\n      for ( j = 1; j < 160; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR102 ) {\n      mask = order_MR102;\n\n      for ( j = 1; j < 205; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n   else if ( mode == MR122 ) {\n      mask = order_MR122;\n\n      for ( j = 1; j < 245; j++ ) {\n         if ( param[ * mask] & *( mask + 1 ) )\n            *stream += 0x01;\n         mask += 2;\n\n         if ( j % 8 )\n            *stream <<= 1;\n         else\n            stream++;\n      }\n   }\n\n   /* shift remaining bits */\n   if (( k = j % 8 ))\t*stream <<= ( 8 - k );\n   return( (int)block_size[mode] );\n}", "path": "interf_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * check_gp_clipping\n *\n *\n * Parameters:\n *    gp          I: old pitch gains\n *    g_pitch     I: pitch gain\n *\n * Function:\n *    Verify that the sum of the last (N_FRAME+1) pitch gains is under\n *    a certain threshold.\n *\n * Returns:\n *    True or false\n */\n", "func_signal": "static Word16 check_gp_clipping( Float32 *gp, Float32 g_pitch )", "code": "{\n   Float32 sum;\n   Word32 i;\n\n\n   sum = g_pitch;\n\n   for ( i = 0; i < N_FRAME; i++ ) {\n      sum += gp[i];\n   }\n\n   if ( sum > 7.6F /*FGP_CLIP*/ ) {\n      return 1;\n   }\n   else {\n      return 0;\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/***************************************************************************\n *\n *   FUNCTION NAME: LTP_flag_update\n *\n *   PURPOSE:\n *     Set LTP_flag if the LTP gain > LTP_THRESHOLD, where the value of\n *     LTP_THRESHOLD depends on the LTP analysis window length.\n *\n *   INPUTS:\n *\n *     mode\n *                     AMR mode\n *     vadState->R0\n *                     LTP energy\n *     vadState->Rmax\n *                     LTP maximum autocorrelation\n *   OUTPUTS:\n *\n *     vadState->LTP_flag\n *                     Set if LTP gain > LTP_THRESHOLD\n *\n *   RETURN VALUE:\n *\n *     none\n *\n *************************************************************************/\n", "func_signal": "void LTP_flag_update (vadState * st, Word16 mode)", "code": "{\n  Float32 thresh;\n\n  if ((mode == MR475) || (mode == MR515))\n    thresh = 0.55;\n  else if (mode == MR102)\n    thresh = 0.60;\n  else\n    thresh = 0.65;\n\n  if (st->Rmax  > thresh*st->R0)\n    st->LTP_flag = TRUE;\n  else\n    st->LTP_flag = FALSE;\n\n  return;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Log2_norm\n *\n *\n * Parameters:\n *    x                 I: input value\n *    exp               I: exponent\n *    exponent          O: Integer part of Log2. (range: 0<=val<=30)\n *    fraction          O: Fractional part of Log2. (range: 0<=val<1)\n *\n * Function:\n *    Computes log2\n *\n *    Computes log2(L_x, exp),  where   L_x is positive and\n *    normalized, and exp is the normalisation exponent\n *    If L_x is negative or zero, the result is 0.\n *\n *    The function Log2(L_x) is approximated by a table and linear\n *    interpolation. The following steps are used to compute Log2(L_x)\n *\n *    exponent = 30-normExponent\n *    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).\n *    a = bit10-b24\n *    i -=32\n *    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void Log2_norm( Word32 x, Word32 exp, Word32 *exponent, Word32 *\n      fraction )", "code": "{\n   Word32 y, i, a;\n\n   if ( x <= 0 ) {\n      *exponent = 0;\n      *fraction = 0;\n      return;\n   }\n\n   /* Extract b25-b31 */\n   i = x >> 25;\n   i = i - 32;\n\n   /* Extract b10-b24 of fraction */\n   a = x >> 9;\n   a = a & 0xFFFE;   /* 2a */\n\n   /* fraction */\n   y = ( log2_table[i] << 16 ) - a * ( log2_table[i] - log2_table[i + 1] );\n   *fraction = y >> 16;\n   *exponent = 30 - exp;\n   return;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Log2\n *\n *\n * Parameters:\n *    x                 I: input value\n *    exponent          O: Integer part of Log2. (range: 0<=val<=30)\n *    fraction          O: Fractional part of Log2. (range: 0<=val<1)\n *\n * Function:\n *    Computes log2(L_x)\n *    If x is negative or zero, the result is 0.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void Log2( Word32 x, Word32 *exponent, Word32 *fraction )", "code": "{\n   int exp;\n\n\n   frexp( ( Float64 )x, &exp );\n   exp = 31 - exp;\n   Log2_norm( x <<exp, exp, exponent, fraction );\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Lag_max_wght\n *\n *\n * Parameters:\n *    vadSt          B: vad structure\n *    corr           I: correlation vector\n *    signal         I: signal\n *    L_frame        I: length of frame to compute pitch\n *    old_lag        I: old open-loop lag\n *    cor_max        O: maximum correlation\n *    wght_flg       I: weighting function flag\n *    gain_flg       O: open-loop flag\n *    dtx            I: dtx on/off\n *\n * Function:\n *    Find the lag that has maximum correlation of signal in a given delay range.\n *    maximum lag = 143\n *    minimum lag = 20\n *\n * Returns:\n *    p_max             lag found\n */\n", "func_signal": "static Word32 Lag_max_wght( vadState *vadSt, Float32 corr[], Float32 signal[],\n      Word32 old_lag, Word32 *cor_max, Word32 wght_flg, Float32 *gain_flg,\n      Word32 dtx )", "code": "{\n   Float32 t0, t1, max;\n   Float32 *psignal, *p1signal;\n   const Float32 *ww, *we;\n   Word32 i, j, p_max;\n\n\n   ww = &corrweight[250];\n   we = &corrweight[266 - old_lag];\n   max = -FLT_MAX;\n   p_max = PIT_MAX;\n\n   /* see if the neigbouring emphasis is used */\n   if ( wght_flg > 0 ) {\n      /* find maximum correlation with weighting */\n      for ( i = PIT_MAX; i >= PIT_MIN; i-- ) {\n         /* Weighting of the correlation function. */\n         t0 = corr[ - i] * *ww--;\n          /* Weight the neighbourhood of the old lag. */\n         t0 *= *we--;\n\n         if ( t0 >= max ) {\n            max = t0;\n            p_max = i;\n         }\n      }\n\n   }\n   else {\n      /* find maximum correlation with weighting */\n      for ( i = PIT_MAX; i >= PIT_MIN; i-- ) {\n         /* Weighting of the correlation function. */\n         t0 = corr[ - i] * *ww--;\n\n         if ( t0 >= max ) {\n            max = t0;\n            p_max = i;\n         }\n      }\n\n   }\n   psignal = &signal[0];\n   p1signal = &signal[ - p_max];\n   t0 = 0;\n   t1 = 0;\n\n   /* Compute energy */\n   for ( j = 0; j < L_FRAME_BY2; j++, psignal++, p1signal++ ) {\n      t0 += *psignal * *p1signal;\n      t1 += *p1signal * *p1signal;\n   }\n\n   if ( dtx ) {\n#ifdef VAD2\n       vadSt->Rmax += t0;   /* Save max correlation */\n       vadSt->R0   += t1;   /* Save max energy */\n#else\n      /* update and detect tone */\n      vad_tone_detection_update( vadSt, 0 );\n      vad_tone_detection( vadSt, t0, t1 );\n#endif\n   }\n\n   /*\n    * gain flag is set according to the open_loop gain\n    * is t2/t1 > 0.4 ?\n    */\n   *gain_flg = t0 - ( t1 * 0.4F );\n   *cor_max = 0;\n   return( p_max );\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Int_lpc_1to3\n *\n *\n * Parameters:\n *    lsp_old           I: LSP vector at the 4th subfr. of past frame      [M]\n *    lsp_new           I: LSP vector at the 4th subframe of present frame [M]\n *    az                O: interpolated LP parameters in all subframes\n *                                                                   [AZ_SIZE]\n *\n * Function:\n *    Interpolates the LSPs and converts to LPC parameters to get a different\n *    LP filter in each subframe.\n *\n *    The 20 ms speech frame is divided into 4 subframes.\n *    The LSPs are quantized and transmitted at the 4th\n *    subframes (once per frame) and interpolated at the\n *    1st, 2nd and 3rd subframe.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void Int_lpc_1to3( Float32 lsp_old[], Float32 lsp_new[], Float32 az[] )", "code": "{\n   Float32 lsp[M];\n   Word32 i;\n\n\n   for ( i = 0; i < M; i++ ) {\n      lsp[i] = lsp_new[i] * 0.25F + lsp_old[i] * 0.75F;\n   }\n\n   /* Subframe 1 */\n   Lsp_Az( lsp, az );\n   az += MP1;\n\n   for ( i = 0; i < M; i++ ) {\n      lsp[i] = ( lsp_old[i] + lsp_new[i] ) * 0.5F;\n   }\n\n   /* Subframe 2 */\n   Lsp_Az( lsp, az );\n   az += MP1;\n\n   for ( i = 0; i < M; i++ ) {\n      lsp[i] = lsp_old[i] * 0.25F + lsp_new[i] * 0.75F;\n   }\n\n   /* Subframe 3 */\n   Lsp_Az( lsp, az );\n   az += MP1;\n\n   /* Subframe 4 */\n   Lsp_Az( lsp_new, az );\n   return;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * DotProduct\n *\n *\n * Parameters:\n *    x                 I: first input\n *    y                 I: second input\n *    len               I: length of product\n *\n * Function:\n *    Computes dot product\n *\n * Returns:\n *    acc               dot product\n */\n", "func_signal": "static Float32 DotProduct( Float32 *x, Float32 *y, Word32 len )", "code": "{\n   Word32 i;\n   Float32 acc;\n\n\n   acc = 0.0F;\n\n   for ( i = 0; i < len; i++ )\n      acc += x[i] * y[i];\n   return( acc );\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * calc_unfilt_energies\n *\n *\n * Parameters:\n *    res               I: LP residual\n *    exc               I: LTP excitation (unfiltered)\n *    code              I: CB innovation (unfiltered)\n *    gain_pit          I: pitch gain\n *    en                O: energy coefficients [4]\n *    ltpg              O: LTP coding gain (log2())\n *\n * Function:\n *    Calculation of several energy coefficients for unfiltered\n *    excitation signals and the LTP coding gain\n *\n *    en[0] = <res res>    LP residual energy\n *    en[1] = <exc exc>    LTP residual energy\n *    en[2] = <exc code>   LTP/CB innovation dot product\n *    en[3] = <lres lres>  LTP residual energy\n *                         (lres = res - gain_pit*exc)\n *    ltpg = log2(LP_res_en / LTP_res_en)\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void calc_unfilt_energies( Float32 res[], Float32 exc[], Float32 code[],\n      Float32 gain_pit, Float32 en[], Float32 *ltpg )", "code": "{\n   Float32 sum, pred_gain;\n   Word32 i;\n\n\n   /* Compute residual energy */\n   en[0] = (Float32)Dotproduct40( res, res );\n\n   /* ResEn := 0 if ResEn < 200.0 */\n   if ( en[0] < 200 ) {\n      en[0] = 0;\n   }\n\n   /* Compute ltp excitation energy */\n   en[1] = (Float32)Dotproduct40( exc, exc );\n\n   /* Compute scalar product <exc[],code[]> */\n   en[2] = (Float32)Dotproduct40( exc, code );\n\n   /* Compute energy of LTP residual */\n   en[3] = 0;\n\n   for ( i = 0; i < L_SUBFR; i++ ) {\n      /* LTP residual */\n      sum = res[i] - ( exc[i] * gain_pit );\n      en[3] += sum * sum;\n   }\n\n   /* calculate LTP coding gain, i.e. energy reduction LP res -> LTP res */\n   if ( en[3] > 0 && en[0] != 0 ) {\n      /* gain = ResEn / LTPResEn */\n      pred_gain = en[0] / en[3];\n      *ltpg = ( Float32 )( log10( pred_gain ) / log10( 2 ) );\n   }\n   else {\n      *ltpg = 0;\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * q_gain_pitch\n *\n *\n * Parameters:\n *    mode              I: codec mode\n *    gp_limit          I: pitch gain limit\n *    gain              B: Pitch gain (unquant/quant)\n *    gain_cand         O: pitch gain candidates (3),   MR795 only\n *    gain_cind         O: pitch gain cand. indices (3),MR795 only\n *\n * Function:\n *    Closed-loop pitch search\n *\n * Returns:\n *    index             index of quantization\n */\n", "func_signal": "static Word16 q_gain_pitch( enum Mode mode, Float32 gp_limit, Float32 *gain,\n      Float32 gain_cand[], Word32 gain_cind[] )", "code": "{\n   Float32 err_min, err;\n   Word32 i, index;\n\n\n   err_min = ( Float32 )fabs( *gain - qua_gain_pitch[0] );\n   index = 0;\n\n   for ( i = 1; i < NB_QUA_PITCH; i++ ) {\n      if ( qua_gain_pitch[i] <= gp_limit ) {\n         err = ( Float32 )fabs( *gain - qua_gain_pitch[i] );\n\n         if ( err < err_min ) {\n            err_min = err;\n            index = i;\n         }\n      }\n   }\n\n   if ( mode == MR795 ) {\n   /*\n    * in MR795 mode, compute three gain_pit candidates around the index\n    * found in the quantization loop: the index found and the two direct\n    * neighbours, except for the extreme cases (i=0 or i=NB_QUA_PITCH-1),\n    * where the direct neighbour and the neighbour to that is used.\n    */\n      Word32 ii;\n\n\n      if ( index == 0 ) {\n         ii = index;\n      }\n      else {\n         ii = index - 1;\n\n         if ( index == ( NB_QUA_PITCH - 1 ) || ( qua_gain_pitch[index + 1] >\n               gp_limit ) ) {\n            ii = index - 2;\n         }\n      }\n\n      /* store candidate indices and values */\n      for ( i = 0; i < 3; i++ ) {\n         gain_cind[i] = ii;\n         gain_cand[i] = qua_gain_pitch[ii];\n         ii++;\n      }\n      *gain = qua_gain_pitch[index];\n   }\n   else {\n      /* return the index and gain pitch found */\n      *gain = qua_gain_pitch_MR122[index];\n   }\n   return( Word16 )index;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Autocorr\n *\n *\n * Parameters:\n *    x                 I: Input signal\n *    r                 O: Autocorrelations\n *    wind              I: Window for LPC analysis\n * Function:\n *    Calculate autocorrelation with window, LPC order = M\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void Autocorr( Float32 x[], Float32 r[], const Float32 wind[] )", "code": "{\n   Word32 i, j;   /* Counters */\n   Float32 y[L_WINDOW + M + 1];   /* Windowed signal */\n   Float64 sum;   /* temp */\n\n\n   /*\n    * Windowing of signal\n    */\n   for ( i = 0; i < L_WINDOW; i++ ) {\n      y[i] = x[i] * wind[i];\n   }\n\n   /*\n    * Zero remaining memory\n    */\n   memset( &y[L_WINDOW], 0, 44 );\n\n   /*\n    * Autocorrelation\n    */\n   for ( i = 0; i <= M; i++ ) {\n      sum = 0;\n\n      for ( j = 0; j < L_WINDOW; j += 40 ) {\n         sum += Dotproduct40( &y[j], &y[j + i] );\n      }\n      r[i] = (Float32)sum;\n   }\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * DecoderInterfaceExit\n *\n *\n * Parameters:\n *    state             I: state structure\n *\n * Function:\n *    The memory used for state memory is freed\n *\n * Returns:\n *    Void\n */\n", "func_signal": "void Encoder_Interface_exit( void *state )", "code": "{\n   enc_interface_State * s;\n   s = ( enc_interface_State * )state;\n\n   /* free memory */\n   Speech_Encode_Frame_exit( &s->encoderState );\n   free( s );\n   state = NULL;\n}", "path": "interf_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * search_4i40\n *\n *\n * Parameters:\n *    dn                I: correlation between target and h[]\n *    dn2               I: maximum of corr. in each track.\n *    rr                I: matrix of autocorrelation\n *    codvec            O: algebraic codebook vector\n *\n * Function:\n *    Search the best codevector; determine positions of the 4 pulses\n *    in the 40-sample frame.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void search_4i40( Float32 dn[], Float32 dn2[], Float32 rr[][L_CODE],\n      Word32 codvec[] )", "code": "{\n   Float64 alpk, alp, alp0, alp1;\n   Float32 ps, psk, ps0, ps1, sq, sq1;\n   Word32 ipos[4];\n   Word32 i0, i1, i2, i3, ix, i, pos, track;\n\n\n   /* Default value */\n   psk = -1;\n   alpk = 1;\n\n   for ( i = 0; i < 4; i++ ) {\n      codvec[i] = i;\n   }\n\n   for ( track = 3; track < 5; track++ ) {\n      /* fix starting position */\n      ipos[0] = 0;\n      ipos[1] = 1;\n      ipos[2] = 2;\n      ipos[3] = track;\n\n      /*\n       * main loop: try 4 tracks.\n       */\n      for ( i = 0; i < 4; i++ ) {\n      /*\n       * i0 loop: try 4 positions (use position with max of corr.).\n       */\n         for ( i0 = ipos[0]; i0 < L_CODE; i0 += STEP ) {\n            if ( dn2[i0] >= 0 ) {\n               ps0 = dn[i0];\n               alp0 = rr[i0][i0] * 0.25F;\n\n               /*\n                * i1 loop: 8 positions.\n                */\n               sq = -1;\n               alp = 1;\n               ps = 0;\n               ix = ipos[1];\n\n               for ( i1 = ipos[1]; i1 < L_CODE; i1 += STEP ) {\n                  ps1 = ps0 + dn[i1];\n\n                  /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */\n                  alp1 = alp0 + rr[i1][i1] * 0.25F;\n                  alp1 = alp1 + rr[i0][i1] * 0.5F;\n                  sq1 = ps1 * ps1;\n\n                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {\n                     sq = sq1;\n                     ps = ps1;\n                     alp = alp1;\n                     ix = i1;\n                  }\n               }\n               i1 = ix;\n\n               /*\n                * i2 loop: 8 positions.\n                */\n               ps0 = ps;\n               alp0 = alp * 0.25F;\n               sq = -1;\n               alp = 1;\n               ps = 0;\n               ix = ipos[2];\n\n               for ( i2 = ipos[2]; i2 < L_CODE; i2 += STEP ) {\n                  ps1 = ps0 + dn[i2];\n\n                  /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */\n                  alp1 = alp0 + rr[i2][i2] * 0.0625F;\n                  alp1 += rr[i1][i2] * 0.125F;\n                  alp1 += rr[i0][i2] * 0.125F;\n                  sq1 = ps1 * ps1;\n\n                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {\n                     sq = sq1;\n                     ps = ps1;\n                     alp = alp1;\n                     ix = i2;\n                  }\n               }\n               i2 = ix;\n\n               /*\n                * i3 loop: 8 positions\n                */\n               ps0 = ps;\n               alp0 = alp;\n               sq = -1;\n               alp = 1;\n               ps = 0;\n               ix = ipos[3];\n\n               for ( i3 = ipos[3]; i3 < L_CODE; i3 += STEP ) {\n                  ps1 = ps0 + dn[i3];\n\n                  /* alp1 = alp0 + rr[i0][i3] + rr[i1][i3] + rr[i2][i3] + 1/2*rr[i3][i3]; */\n                  alp1 = alp0 + rr[i3][i3] * 0.0625F;\n                  alp1 += rr[i2][i3] * 0.125F;\n                  alp1 += rr[i1][i3] * 0.125F;\n                  alp1 += rr[i0][i3] * 0.125F;\n                  sq1 = ps1 * ps1;\n\n                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {\n                     sq = sq1;\n                     ps = ps1;\n                     alp = alp1;\n                     ix = i3;\n                  }\n               }\n\n               /*\n                * memorise codevector if this one is better than the last one.\n                */\n               if ( ( alpk * sq ) > ( psk * alp ) ) {\n                  psk = sq;\n                  alpk = alp;\n                  codvec[0] = i0;\n                  codvec[1] = i1;\n                  codvec[2] = i2;\n                  codvec[3] = ix;\n               }\n            }\n         }\n\n          /*\n           * Cyclic permutation of i0,i1,i2 and i3.\n           */\n         pos = ipos[3];\n         ipos[3] = ipos[2];\n         ipos[2] = ipos[1];\n         ipos[1] = ipos[0];\n         ipos[0] = pos;\n      }\n   }\n   return;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * MR475_update_unq_pred\n *\n *\n * Parameters:\n *    past_qua_en       I: MA predictor memory, 20*log10(qua_err)\n *    gcode0            I: predicted CB gain\n *    cod_gain          I: optimum codebook gain\n *\n * Function:\n *    Use optimum codebook gain and update \"unquantized\"\n *    gain predictor with the (bounded) prediction error\n *\n *    Prediction error is given by:\n *\n *       R(n) = E(n) - E_pred(n) = 20 * log(cf),\n *\n *    where correction factor cf between the gain Gc and\n *    the estimated pne Gc' is given by:\n *\n *       cf = Gc/Gc'.\n *\n * Returns:\n *    void\n */\n", "func_signal": "static void MR475_update_unq_pred( Word32 *past_qua_en, Float32 gcode0, Float32\n      cod_gain )", "code": "{\n   Float32 qua_ener, pred_err_fact;\n   Word32 i, index, energy, max, s;\n\n\n   if ( cod_gain <= 0 ) {\n      /*MIN_QUA_ENER*/\n      qua_ener = -32.0F;\n   }\n   else {\n      if (gcode0 != 0) {\n         pred_err_fact = cod_gain / gcode0;\n      }\n      else {\n         pred_err_fact = 10.0F;\n      }\n\n      if ( pred_err_fact < 0.0251189F ) {\n         /*MIN_QUA_ENER*/\n         qua_ener = -32.0F;\n      }\n      else if ( pred_err_fact > 7.8125F ) {\n         /*MAX_QUA_ENER*/\n         qua_ener = 17.8558F;\n      }\n      else {\n         qua_ener = ( Float32 )( 20.0F*log10( pred_err_fact ) );\n      }\n   }\n   energy = (Word32)(qua_ener * 1024 + 0.5F);\n   max = abs(energy - qua_gain_code[0]);\n   index = 0;\n   /* find match from table */\n   for ( i = 1; i < NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+MR475_VQ_SIZE*2+3; i++ )\n   {\n      s = abs(energy - qua_gain_code[i]);\n      if (s < max){\n         max = s;\n         index = i;\n         if (s == 0) {\n            break;\n         }\n      }\n   }\n   /* update MA predictor memory */\n   for ( i = 3; i > 0; i-- ) {\n      past_qua_en[i] = past_qua_en[i - 1];\n   }\n   past_qua_en[0] = index;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/*\n * Vq_subvec\n *\n *\n * Parameters:\n *    lsf_r1            I: 1st LSF residual vector\n *    lsf_r2            I: 2nd LSF residual vector\n *    dico              I: quantization codebook\n *    wf1               I: 1st LSF weighting factors\n *    wf2               I: 2nd LSF weighting factors\n *    dico_size         I: size of quantization codebook\n * Function:\n *    Quantization of a 4 dimensional subvector\n *\n * Returns:\n *    index             quantization index\n */\n", "func_signal": "static Word16 Vq_subvec( Float32 *lsf_r1, Float32 *lsf_r2, const Float32 *dico,\n      Float32 *wf1, Float32 *wf2, Word16 dico_size )", "code": "{\n   Float64 temp, dist, dist_min;\n   const Float32 *p_dico;\n   Word32 i, index = 0;\n\n\n   dist_min = DBL_MAX;\n   p_dico = dico;\n\n   for ( i = 0; i < dico_size; i++ ) {\n      temp = lsf_r1[0] - *p_dico++;\n      dist = temp * temp * wf1[0];\n      temp = lsf_r1[1] - *p_dico++;\n      dist += temp * temp * wf1[1];\n      temp = lsf_r2[0] - *p_dico++;\n      dist += temp * temp * wf2[0];\n      temp = lsf_r2[1] - *p_dico++;\n      dist += temp * temp * wf2[1];\n\n      if ( dist < dist_min ) {\n         dist_min = dist;\n         index = i;\n      }\n   }\n\n   /* Reading the selected vector */\n   p_dico = &dico[index << 2];\n   lsf_r1[0] = *p_dico++;\n   lsf_r1[1] = *p_dico++;\n   lsf_r2[0] = *p_dico++;\n   lsf_r2[1] = *p_dico++;\n   return( Word16 )index;\n}", "path": "sp_enc.c", "repo_name": "teknoraver/amrenc", "stars": 5, "license": "None", "language": "c", "size": 206}
{"docstring": "/* ns_pg blob_select_file db blob_id filename\n * Write a pseudo-blob to the passed in temp file name.  Some of this\n * shamelessly lifted from ora8.c. \n * DanW - This is just blob_write, except it doesn't send anything out the\n *        connection.\n * .\n * Combined blob_select_file and blob_write:\n * If you want to write to the network connection, set TO_CONN_P to TRUE\n * and pass a null filename.\n *\n * If you want to write the blob to a file, set TO_CONN_P = FALSE, and\n * pass the filename in.\n */\n", "func_signal": "static int\nblob_send_to_stream(Tcl_Interp *interp, Ns_DbHandle *handle, char* lob_id, \n\t\t    int to_conn_p, char* filename)", "code": "{\n  NsPgConn\t*nspgConn = (NsPgConn *) handle->connection;\n  int\t\tsegment;\n  char\t\tquery[100];\n  int\t\tfd;\n  char\t\t*segment_pos;\n  Ns_Conn       *conn;\n\n  if (to_conn_p) \n    {  \n      conn = Ns_TclGetConn(interp);\n      \n      /* this Shouldn't Happen, but spew an error just in case */\n      if (conn == NULL) \n        {\n\t  Ns_Log (Error, \"blob_send_to_stream: No AOLserver conn available\");\n\n\t  Tcl_AppendResult (interp, \"No AOLserver conn available\", NULL);\n\t  goto bailout;\n        }\n    } else {\n      if (filename == NULL) \n\t{\n\t  Tcl_AppendResult (interp, \"could not create temporary file to spool \"\n\t\t\t    \"BLOB/CLOB result\", NULL);\n\t  return TCL_ERROR;\n\t}\n\n\n      fd = open (filename, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n\n      if (fd < 0) \n\t{\n\t  Ns_Log (Error, \"Can't open %s for writing. error %d(%s)\",\n\t\t  filename, errno, strerror(errno));\n\t  Tcl_AppendResult (interp, \"can't open file \", filename,\n\t\t\t    \" for writing. \",\n\t\t\t    \"received error \", strerror(errno), NULL);\n\t  return TCL_ERROR;\n\t}\n    }\n\n  segment = 1;\n\n  strcpy(query, \"SELECT BYTE_LEN, DATA FROM LOB_DATA WHERE LOB_ID = \");\n  strcat(query, lob_id);\n  strcat(query, \" AND SEGMENT = \");\n\n  segment_pos = query + strlen(query);\n\n  for (;;) {\n    char\t*data_column;\n    char\t*byte_len_column;\n    int\t\ti, j, n, byte_len;\n    char\tbuf[6000];\n\n    sprintf(segment_pos, \"%d\", segment);\n    if (Ns_PgExec(handle, query) != NS_ROWS) {\n      Tcl_DString errString;\n      Tcl_DStringInit(&errString);\n      \n      Tcl_DStringAppend\n\t(&errString, \"Error selecting data from BLOB\\n\", -1);\n      \n      if(handle->verbose)\n\t{\n\t  append_PQresultStatus(&errString, nspgConn->res);\n\t  \n\t  Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t  Tcl_DStringAppend(&errString, query, -1);\n\t}\n      \n      Tcl_AppendResult(interp, Tcl_DStringValue(&errString), NULL);\n      \n      Tcl_DStringFree(&errString);\n      \n      return TCL_ERROR;\n    }\n\n    if (PQntuples(nspgConn->res) == 0) break;\n\n    byte_len_column = PQgetvalue(nspgConn->res, 0, 0);\n    data_column = PQgetvalue(nspgConn->res, 0, 1);\n    sscanf(byte_len_column, \"%d\", &byte_len);\n    n = byte_len;\n    for (i=0, j=0; n > 0; i += 4, j += 3, n -= 3) {\n      decode3(&data_column[i], &buf[j], n);\n    }\n\n    stream_actually_write (fd, conn, buf, byte_len, to_conn_p);\n    segment++;\n  }\n\n bailout:\n  if (!to_conn_p)\n    {\n      close (fd);\n    }\n\n  PQclear(nspgConn->res);\n  nspgConn->res = NULL;\n\n  return TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* string_list_elt_new */\n", "func_signal": "static int \nstring_list_len (string_list_elt_t *head)", "code": "{\n  int i = 0;\n\n  while (head != NULL) {\n    i++;\n    head = head->next;\n  }\n\n  return i; \n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Ns_PgInterpInit - Add the \"ns_pg\" command to a single Tcl interpreter.\n */\n", "func_signal": "static int\nNs_PgInterpInit(Tcl_Interp *interp, void *ignored)", "code": "{\n    Tcl_CreateCommand(interp, \"ns_pg\", PgCmd, NULL, NULL);\n#ifdef FOR_ACS_USE\n    Tcl_CreateCommand(interp, \"ns_pg_bind\", PgBindCmd, NULL, NULL);\n#endif\n#ifdef NS_AOLSERVER_3_PLUS\n#ifdef FOR_ACS_USE\n    Tcl_CreateCommand (interp, \"ns_column\", pg_column_command, NULL, NULL);\n    Tcl_CreateCommand (interp, \"ns_table\", pg_table_command, NULL, NULL);\n\n#endif /* FOR_ACS_USE */\n#endif /* NS_AOLSERVER_3_PLUS */\n\n    return NS_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* end Ns_PgExec */\n", "func_signal": "static int\nNs_PgResetHandle(Ns_DbHandle *handle)", "code": "{\n    static char *asfuncname = \"Ns_PgResetHandle\";\n    NsPgConn       *nsConn;\n\n    if (handle == NULL || handle->connection == NULL) {\n        Ns_Log(Error, \"%s: Invalid connection.\", asfuncname);\n        return NS_ERROR;\n    } \n\n    nsConn = handle->connection;\n\n    if (nsConn->in_transaction) {\n        if (handle->verbose) {\n            Ns_Log(Notice, \"%s: Rolling back transaction\", asfuncname);\n        }\n        if (Ns_PgExec(handle, \"rollback\") != PGRES_COMMAND_OK) {\n            Ns_Log(Error, \"%s: Rollback failed\", asfuncname);\n        }\n        return NS_ERROR;\n    }\n    return NS_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* ns_pg blob_get db blob_id\n * returns the value of the blob to the Tcl caller.\n */\n", "func_signal": "static int\nblob_get(Tcl_Interp *interp, Ns_DbHandle *handle, char* lob_id)", "code": "{\n    NsPgConn\t*nspgConn = (NsPgConn *) handle->connection;\n\tint\t\t\tsegment;\n\tchar\t\tquery[100];\n\tchar\t\t*segment_pos;\n\tint\t\t\tnbytes = 0;\n\n\tsegment = 1;\n\n\tstrcpy(query, \"SELECT BYTE_LEN, DATA FROM LOB_DATA WHERE LOB_ID = \");\n\tstrcat(query, lob_id);\n\tstrcat(query, \" AND SEGMENT = \");\n\n\tsegment_pos = query + strlen(query);\n\n\tfor (;;) {\n\t\tchar\t*data_column;\n\t\tchar\t*byte_len_column;\n\t\tint\t\ti, j, n, byte_len;\n\t\tchar\tbuf[6001];\n\n\t\tsprintf(segment_pos, \"%d\", segment);\n\n\t\tif (Ns_PgExec(handle, query) != NS_ROWS) {\n\t\t  Tcl_DString errString;\n\t\t  Tcl_DStringInit(&errString);\n\t\t  \n\t\t  Tcl_DStringAppend\n\t\t    (&errString, \"Error selecting data from BLOB\\n\", -1);\n\t\t  \n\t\t  if(handle->verbose)\n\t\t    {\n\t\t      append_PQresultStatus(&errString, nspgConn->res);\n\t\t      \n\t\t      Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t\t      Tcl_DStringAppend(&errString, query, -1);\n\t\t    }\n\n\t\t  Tcl_AppendResult(interp, Tcl_DStringValue(&errString), NULL);\n\t\t  \n\t\t  Tcl_DStringFree(&errString);\n\t\t  \n\t\t  return TCL_ERROR;\n\t\t}\n\n\t\tif (PQntuples(nspgConn->res) == 0) break;\n\n\t\tbyte_len_column = PQgetvalue(nspgConn->res, 0, 0);\n\t\tdata_column = PQgetvalue(nspgConn->res, 0, 1);\n\t\tsscanf(byte_len_column, \"%d\", &byte_len);\n\t\tnbytes += byte_len;\n\t\tn = byte_len;\n\t\tfor (i=0, j=0; n > 0; i += 4, j += 3, n -= 3) {\n\t\t\tdecode3(&data_column[i], &buf[j], n);\n\t\t}\n        buf[byte_len] = '\\0';\n\t\tTcl_AppendResult(interp, buf, NULL);\n\t\tsegment++;\n    }\n\n\tPQclear(nspgConn->res);\n\tnspgConn->res = NULL;\n\n\treturn TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Ns_DbNewTableInfo */\n", "func_signal": "static void\nNs_DbAddColumnInfo (Ns_DbTableInfo *tinfo, Ns_Set *column_info)", "code": "{\n    tinfo->ncolumns++;\n\n    if (tinfo->ncolumns > tinfo->size) \n      {\n\ttinfo->size *= 2;\n\ttinfo->columns = Ns_Realloc (tinfo->columns,\n\t\t\t\t     tinfo->size * sizeof(Ns_Set *));\n      }\n    tinfo->columns[tinfo->ncolumns - 1] = column_info;\n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Set the current transaction state based on the query pointed to by\n * \"sql\".  Should be called only after the query has successfully been\n * executed.\n*/\n", "func_signal": "static void\nset_transaction_state(Ns_DbHandle *handle, char *sql, char *asfuncname)", "code": "{\n    NsPgConn *nsConn = handle->connection;\n    while (*sql == ' ') sql++;\n    if (!strncasecmp(sql, \"begin\", 5)) {\n        if (handle->verbose) {\n            Ns_Log(Notice, \"%s: Entering transaction\", asfuncname);\n        }\n        nsConn->in_transaction = TRUE;\n    } else if (!strncasecmp(sql, \"end\", 3) ||\n               !strncasecmp(sql, \"commit\", 6)) {\n        if (handle->verbose) {\n            Ns_Log(Notice, \"%s: Committing transaction\", asfuncname);\n        }\n        nsConn->in_transaction = FALSE;\n    } else if (!strncasecmp(sql, \"abort\", 5) ||\n               !strncasecmp(sql, \"rollback\", 8)) {\n        if (handle->verbose) {\n            Ns_Log(Notice, \"%s: Rolling back transaction\", asfuncname);\n        }\n        nsConn->in_transaction = FALSE;\n    }\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * PgBindCmd - This function implements the \"ns_pg_bind\" Tcl command \n * installed into each interpreter of each virtual server.  It provides \n * for the parsing and substitution of bind variables into the original \n * sql query.  This is an emulation only. Postgresql doesn't currently \n * support true bind variables yet.\n */\n", "func_signal": "static int\nPgBindCmd(ClientData dummy, Tcl_Interp *interp, int argc, char **argv)", "code": "{\n\n  string_list_elt_t *bind_variables;\n  string_list_elt_t *var_p;\n  string_list_elt_t *sql_fragments;\n  string_list_elt_t *frag_p;\n  Ns_DString         ds;\n  Ns_DbHandle       *handle;\n  Ns_Set            *rowPtr;\n  Ns_Set            *set   = NULL; \n  char              *cmd;\n  char              *sql;\n  char              *value = NULL;\n  char              *p;\n  int               value_frag_len = 0;\n\n  if (argc < 4 || (!STREQ(\"-bind\", argv[3]) && (argc != 4)) || \n       (STREQ(\"-bind\", argv[3]) && (argc != 6))) {\n    return BadArgs(interp, argv, \"dbId sql\");\n  }\n\n  if (Ns_TclDbGetHandle(interp, argv[2], &handle) != TCL_OK) {\n    return TCL_ERROR;\n  }\n\n  Ns_DStringFree(&handle->dsExceptionMsg);\n  handle->cExceptionCode[0] = '\\0';\n\n  /*\n   * Make sure this is a PostgreSQL handle before accessing\n   * handle->connection as an NsPgConn.\n   */\n\n  if (Ns_DbDriverName(handle) != pgName) {\n    Tcl_AppendResult(interp, \"handle \\\"\", argv[1], \"\\\" is not of type \\\"\",\n                     pgName, \"\\\"\", NULL);\n    return TCL_ERROR;\n  }\n\n  cmd = argv[1];\n\n  if (STREQ(\"-bind\", argv[3])) {\n    set = Ns_TclGetSet(interp, argv[4]);\n    if (set == NULL) {\n      Tcl_AppendResult (interp, \"invalid set id `\", argv[4], \"'\", NULL);\n      return TCL_ERROR;\t      \n    }\n    sql = Ns_StrDup(argv[5]);\n  } else {\n    sql = Ns_StrDup(argv[3]);\n  }\n\n  /*\n   * Parse the query string and find the bind variables.  Return\n   * the sql fragments so that the query can be rebuilt with the \n   * bind variable values interpolated into the original query.\n   */\n\n  parse_bind_variables(sql, &bind_variables, &sql_fragments);  \n\n  if (string_list_len(bind_variables) > 0) {\n\n    Ns_DStringInit(&ds);\n\n    /*\n     * Rebuild the query and substitute the actual tcl variable values\n     * for the bind variables.\n     */\n\n    for (var_p = bind_variables, frag_p = sql_fragments; \n         var_p != NULL || frag_p != NULL;) {\n    \n      if (frag_p != NULL) {\n        Ns_DStringAppend(&ds, frag_p->string);\n        frag_p = frag_p->next;\n      }\n   \n      if (var_p != NULL) {\n        if (set == NULL) {\n          value = Tcl_GetVar(interp, var_p->string, 0);\n        } else {\n          value = Ns_SetGet(set, var_p->string);\n        }\n        if (value == NULL) {\n          Tcl_AppendResult (interp, \"undefined variable `\", var_p->string,\n                            \"'\", NULL);\n          Ns_DStringFree(&ds);\n          string_list_free_list(bind_variables);\n          string_list_free_list(sql_fragments);\n          Ns_Free(sql);\n          return TCL_ERROR;\n        }\n\n        if ( strlen(value) == 0 ) {\n            /*\n             * DRB: If the Tcl variable contains the empty string, pass a NULL\n             * as the value.\n             */\n            Ns_DStringAppend(&ds, \"NULL\");\n        } else {\n            /*\n             * DRB: We really only need to quote strings, but there is one benefit\n             * to quoting numeric values as well.  A value like '35 union select...'\n             * substituted for a legitimate value in a URL to \"smuggle\" SQL into a\n             * script will cause a string-to-integer conversion error within Postgres.\n             * This conversion is done before optimization of the query, so indices are\n             * still used when appropriate.\n             */\n            Ns_DStringAppend(&ds, \"'\");       \n\n            /*\n             * DRB: Unfortunately, we need to double-quote quotes as well ... and\n             * escape backslashes\n             */ \n            for (p = value; *p; p++) {\n                if (*p == '\\'') {\n                    if (p > value) {\n                        Ns_DStringNAppend(&ds, value, p-value);\n                    }\n                    value = p;\n                    Ns_DStringAppend(&ds, \"'\");\n                } else if (*p == '\\\\') {\n                    if (p > value) {\n                        Ns_DStringNAppend(&ds, value, p-value);\n                    }\n                    value = p;\n                    Ns_DStringAppend(&ds, \"\\\\\");\n                }\n            }\n\n            if (p > value) {\n                Ns_DStringAppend(&ds, value);\n            }\n\n            Ns_DStringAppend(&ds, \"'\");       \n        }\n        var_p = var_p->next;\n      }\n    }\n  \n    Ns_Free(sql);\n    sql = Ns_DStringExport(&ds);\n    Ns_DStringFree(&ds);\n  }\n\n  string_list_free_list(bind_variables);\n  string_list_free_list(sql_fragments);\n\n  if (STREQ(cmd, \"dml\")) {\n    if (Ns_DbDML(handle, sql) != NS_OK) {\n      return DbFail(interp, handle, cmd, sql);\n    }\n  } else if (STREQ(cmd, \"1row\")) {\n    rowPtr = Ns_Db1Row(handle, sql);\n    if (rowPtr == NULL) {\n      return DbFail(interp, handle, cmd, sql);\n    }\n    Ns_TclEnterSet(interp, rowPtr, 1);\n\n  } else if (STREQ(cmd, \"0or1row\")) {\n    int nrows;\n\n    rowPtr = Ns_Db0or1Row(handle, sql, &nrows);\n    if (rowPtr == NULL) {\n      return DbFail(interp, handle, cmd, sql);\n    }\n    if (nrows == 0) {\n      Ns_SetFree(rowPtr);\n    } else {\n      Ns_TclEnterSet(interp, rowPtr, 1);\n    }\n\n  } else if (STREQ(cmd, \"select\")) {\n    rowPtr = Ns_DbSelect(handle, sql);\n    if (rowPtr == NULL) {\n      return DbFail(interp, handle, cmd, sql);\n    }\n    Ns_TclEnterSet(interp, rowPtr, 0);\n\n  } else if (STREQ(cmd, \"exec\")) {\n    switch (Ns_DbExec(handle, sql)) {\n    case NS_DML:\n      Tcl_SetResult(interp, \"NS_DML\", TCL_STATIC);\n      break;\n    case NS_ROWS:\n      Tcl_SetResult(interp, \"NS_ROWS\", TCL_STATIC);\n      break;\n    default:\n      return DbFail(interp, handle, cmd, sql);\n      break;\n    }\n\n  } else {\n    return DbFail(interp, handle, cmd, sql);    \n  } \n  Ns_Free(sql);\n\n  return TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/** \n * Write the contents of BUFP to a file descriptor or to\n * the network connection directly.\n *\n * Lifted from Oracle driver.\n */\n", "func_signal": "static int\nstream_actually_write (int fd, Ns_Conn *conn, void *bufp, int length, int to_conn_p)", "code": "{\n  int bytes_written = 0;\n\n  if (to_conn_p)\n    {\n      if (Ns_WriteConn (conn, bufp, length) == NS_OK) \n        {\n\t  bytes_written = length;\n        } \n      else \n        {\n\t  bytes_written = 0;\n        }\n    }\n  else\n    {\n      bytes_written = write (fd, bufp, length);\n    }\n\n  return bytes_written;\n  \n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Ns_DbAddColumnInfo */\n", "func_signal": "static void\nNs_DbFreeTableInfo (Ns_DbTableInfo *tinfo)", "code": "{\n    int i;\n\n    if (tinfo != NULL) \n      {\n\tfor (i = 0; i < tinfo->ncolumns; i++) \n\t  {\n\t    Ns_SetFree (tinfo->columns[i]);\n\t  }\n\n\tNs_SetFree (tinfo->table);\n\tNs_Free (tinfo->columns);\n\tNs_Free (tinfo);\n      }\n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Ns_PgOpenDb - Open an PostgreSQL connection on an nsdb handle. The\n * datasource for PostgreSQL is in the form \"host:port:database\".\n */\n", "func_signal": "static int\nNs_PgOpenDb(Ns_DbHandle *handle)", "code": "{\n\n    static char *asfuncname = \"Ns_PgOpenDb\";\n    NsPgConn       *nsConn;\n    PGconn         *pgConn;\n    char           *host;\n    char           *port;\n    char           *db;\n    char            datasource[STRING_BUF_LEN];\n\n    if (handle == NULL || handle->datasource == NULL ||\n        strlen(handle->datasource) > STRING_BUF_LEN) {\n        Ns_Log(Error, \"%s: Invalid handle.\", asfuncname);\n        return NS_ERROR;\n    }\n\n    strcpy(datasource, handle->datasource);\n    host = datasource;\n    port = strchr(datasource, ':');\n    if (port == NULL || ((db = strchr(port + 1, ':')) == NULL)) {\n        Ns_Log(Error, \"Ns_PgOpenDb(%s):  Malformed datasource:  %s.  Proper form is: (host:port:database).\",\n               handle->driver, handle->datasource);\n        return NS_ERROR;\n    } else {\n        *port++ = '\\0';\n        *db++ = '\\0';\n\tif (!strcmp(host, \"localhost\")) {\n\t    Ns_Log(Notice, \"Opening %s on %s\", db, host);\n\t    pgConn = PQsetdbLogin(NULL, port, NULL, NULL, db, handle->user,\n                                  handle->password);\n\t} else {\n\t    Ns_Log(Notice, \"Opening %s on %s, port %s\", db, host, port);\n\t    pgConn = PQsetdbLogin(host, port, NULL, NULL, db, handle->user,\n                             handle->password);\n\t}\n\n        if (PQstatus(pgConn) == CONNECTION_OK) {\n            Ns_Log(Notice, \"Ns_PgOpenDb(%s):  Openned connection to %s.\",\n\t\t\t    handle->driver, handle->datasource);\n            nsConn = ns_malloc(sizeof(NsPgConn));\n            if (!nsConn) {\n                Ns_Log(Error, \"ns_malloc() failed allocating nsConn\");\n                return NS_ERROR;\n            }\n            nsConn->in_transaction = FALSE;\n            nsConn->cNum = pgCNum++;\n            nsConn->conn = pgConn;\n            nsConn->res = NULL;\n            nsConn->nCols = nsConn->nTuples = nsConn->curTuple = 0;\n            handle->connection = nsConn;\n\n            if (strlen(datestyle)) { \n                return Ns_PgExec(handle, datestyle) == NS_DML ?\n                  NS_OK : NS_ERROR;\n            }\n            return NS_OK;\n        } else {\n            Ns_Log(Error, \"Ns_PgOpenDb(%s):  Could not connect to %s:  %s\", handle->driver,\n\t\t\t    handle->datasource, PQerrorMessage(pgConn));\n            PQfinish(pgConn);\n            return NS_ERROR;\n        }\n    }\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* ora_table_command */\n", "func_signal": "static Ns_DbTableInfo *\nNs_DbNewTableInfo (char *table)", "code": "{\n    Ns_DbTableInfo *tinfo;\n\n    tinfo = Ns_Malloc (sizeof(Ns_DbTableInfo));\n\n    tinfo->table = Ns_SetCreate (table);\n    tinfo->ncolumns = 0;\n    tinfo->size = 5;\n    tinfo->columns = Ns_Malloc (sizeof(Ns_Set *) * tinfo->size);\n\n    return (tinfo);\n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* ns_pg blob_dml_file blob_id file_name\n * Stuff the contents of file_name into the pseudo-blob blob_id\n */\n", "func_signal": "static int\nblob_dml_file(Tcl_Interp *interp, Ns_DbHandle *handle, char* blob_id,\n\t\t\tchar* filename)", "code": "{\n    NsPgConn\t*nspgConn = (NsPgConn *) handle->connection;\n\tint\t\t\tfd, i, j, segment, readlen;\n\tchar\t\tin_buf[6000], out_buf[8001], query[10000];\n\tchar\t\t*segment_pos;\n\n\tfd = open (filename, O_RDONLY);\n\n\tif (fd == -1) \n\t{\n\t\tNs_Log (Error, \" Error opening file %s: %d(%s)\",\n\t\t\t\tfilename, errno, strerror(errno));\n\t\tTcl_AppendResult (interp, \"can't open file \", filename,\n\t\t\t\t\t\t \" for reading. \", \"received error \",\n\t\t\t\t\t\t strerror(errno), NULL);\n\t}\n  \n\tstrcpy(query, \"INSERT INTO LOB_DATA VALUES(\");\n\tstrcat(query, blob_id);\n\tstrcat(query, \",\");\n\tsegment_pos = query + strlen(query);\n\tsegment = 1;\n\n\treadlen = read (fd, in_buf, 6000);\n\twhile (readlen > 0) {\n\t\tfor (i = 0, j = 0; i < readlen; i += 3, j+=4) {\n\t\t\tencode3(&in_buf[i], &out_buf[j]);\n\t\t}\n\t\tout_buf[j] = '\\0';\n\t\tsprintf(segment_pos, \"%d, %d, '%s')\", segment, readlen, out_buf);\n\t\tif (Ns_PgExec(handle, query) != NS_DML) {\n\t\t  Tcl_DString errString;\n\t\t  Tcl_DStringInit(&errString);\n\t\t  \n\t\t  Tcl_DStringAppend\n\t\t    (&errString, \"Error inserting data into BLOB\\n\", -1);\n\t\t  \n\t\t  if(handle->verbose)\n\t\t    {\n\t\t      append_PQresultStatus(&errString, nspgConn->res);\n\t\t      \n\t\t      Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t\t      Tcl_DStringAppend(&errString, query, -1);\n\t\t    }\n\n\t\t  Tcl_AppendResult(interp, Tcl_DStringValue(&errString), NULL);\n\t\t  \n\t\t  Tcl_DStringFree(&errString);\n\t\t  \n\t\t  return TCL_ERROR;\n\t\t}\n\t\treadlen = read(fd, in_buf, 6000);\n\t\tsegment++;\n\t}\n\tclose(fd);\n\treturn TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Ns_PgGetRow - Fetch rows after an Ns_PgSelect or Ns_PgExec.\n */\n", "func_signal": "static int\nNs_PgGetRow(Ns_DbHandle *handle, Ns_Set *row)", "code": "{\n\n    static char    *asfuncname = \"Ns_PgGetRow\";\n    NsPgConn       *nspgConn;\n    int             i;\n\n    if (handle == NULL || handle->connection == NULL) {\n        Ns_Log(Error, \"%s: Invalid connection.\", asfuncname);\n        return NS_ERROR;\n    } \n\n    if (row == NULL) {\n        Ns_Log(Error, \"%s: Invalid Ns_Set -> row.\", asfuncname);\n        return NS_ERROR;\n    }\n\n    nspgConn = handle->connection;\n\n    if (nspgConn->nCols == 0) {\n        Ns_Log(Error, \"Ns_PgGetRow(%s):  Get row called outside a fetch row loop.\",\n               handle->datasource);\n        return NS_ERROR;\n    } else if (nspgConn->curTuple == nspgConn->nTuples) {\n\n        PQclear(nspgConn->res);\n        nspgConn->res = NULL;\n        nspgConn->nCols = nspgConn->nTuples = nspgConn->curTuple = 0;\n        return NS_END_DATA;\n\n    } else {\n        for (i = 0; i < nspgConn->nCols; i++) {\n            Ns_SetPutValue(row, i, (char *) PQgetvalue(nspgConn->res,\n\t\t\t\t nspgConn->curTuple, i));\n        }\n        nspgConn->curTuple++;\n    }\n\n    return NS_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Ns_PgFlush - Flush any waiting rows not needed after an Ns_DbSelect().\n */\n", "func_signal": "static int\nNs_PgFlush(Ns_DbHandle *handle)", "code": "{\n\n    static char *asfuncname = \"Ns_PgFlush\";\n    NsPgConn   *nspgConn;\n\n    if (handle == NULL || handle->connection == NULL) {\n        Ns_Log(Error, \"%s: Invalid connection.\", asfuncname);\n        return NS_ERROR;\n    } \n\n    nspgConn = handle->connection;\n\n    if (nspgConn->nCols > 0) {\n        PQclear(nspgConn->res);\n        nspgConn->res = NULL;\n        nspgConn->nCols = nspgConn->nTuples = nspgConn->curTuple = 0;\n    }\n    return NS_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * PgCmd - This function implements the \"ns_pg\" Tcl command installed into\n * each interpreter of each virtual server.  It provides access to features\n * specific to the PostgreSQL driver.\n */\n", "func_signal": "static int\nPgCmd(ClientData dummy, Tcl_Interp *interp, int argc, char **argv)", "code": "{\n\n    Ns_DbHandle    *handle;\n    NsPgConn        *nspgConn;\n\n    if (Ns_TclDbGetHandle(interp, argv[2], &handle) != TCL_OK) {\n        return TCL_ERROR;\n    }\n\n \tnspgConn = (NsPgConn *) handle->connection;\n\n    /*\n     * Make sure this is a PostgreSQL handle before accessing\n     * handle->connection as an NsPgConn.\n     */\n    if (Ns_DbDriverName(handle) != pgName) {\n        Tcl_AppendResult(interp, \"handle \\\"\", argv[1], \"\\\" is not of type \\\"\",\n                         pgName, \"\\\"\", NULL);\n        return TCL_ERROR;\n    }\n\n/* BLOBing functions only if FOR_ACS_USE */\n#ifdef FOR_ACS_USE\n\n    if (!strcmp(argv[1], \"blob_write\")) {\n        if (argc != 4) {\n        \tTcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         \targv[0], \" command dbId blobId\\\"\", NULL);\n        \treturn TCL_ERROR;\n\t\t}\n\t\treturn blob_send_to_stream(interp, handle, argv[3], TRUE, NULL);\n\t} else if (!strcmp(argv[1], \"blob_get\")) {\n    \tif (argc != 4) {\n        \tTcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         \targv[0], \" command dbId blobId\\\"\", NULL);\n        \treturn TCL_ERROR;\n    \t}\n\t\treturn blob_get(interp, handle, argv[3]);\n\t} else if (!strcmp(argv[1], \"blob_put\")) {\n    \tif (argc != 5) {\n        \tTcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         \targv[0], \" command dbId blobId value\\\"\", NULL);\n        \treturn TCL_ERROR;\n    \t}\n\t\tif (!nspgConn->in_transaction) {\n        \tTcl_AppendResult(interp,\n\t\t\t\t\t\t\t \"blob_put only allowed in transaction\", NULL);\n        \treturn TCL_ERROR;\n\t\t}\n\t\treturn blob_put(interp, handle, argv[3], argv[4]);\n\t} else if (!strcmp(argv[1], \"blob_dml_file\")) {\n    \tif (argc != 5) {\n        \tTcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         \targv[0], \" command dbId blobId filename\\\"\", NULL);\n        \treturn TCL_ERROR;\n    \t}\n\t\tif (!nspgConn->in_transaction) {\n        \tTcl_AppendResult(interp,\n\t\t\t\t\t\t\t \"blob_dml_file only allowed in transaction\", NULL);\n        \treturn TCL_ERROR;\n\t\t}\n\t\treturn blob_dml_file(interp, handle, argv[3], argv[4]);\n        } else if (!strcmp(argv[1], \"blob_select_file\")) {\n        if (argc != 5) {\n        \tTcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         \targv[0], \" command dbId blobId filename\\\"\", NULL);          \n        \treturn TCL_ERROR;\n        }\n                return blob_send_to_stream(interp, handle, argv[3], FALSE, argv[4]);\n    }\n\n#endif /* FOR_ACS_USE */\n\n    if (argc != 3) {\n        Tcl_AppendResult(interp, \"wrong # args: should be \\\"\",\n                         argv[0], \" command dbId\\\"\", NULL);\n        return TCL_ERROR;\n    }\n\n    if (!strcmp(argv[1], \"db\")) {\n        Tcl_SetResult(interp, (char *) PQdb(nspgConn->conn), TCL_STATIC);\n    } else if (!strcmp(argv[1], \"host\")) {\n        Tcl_SetResult(interp, (char *) PQhost(nspgConn->conn), TCL_STATIC);\n    } else if (!strcmp(argv[1], \"options\")) {\n        Tcl_SetResult(interp, (char *) PQoptions(nspgConn->conn), TCL_STATIC);\n    } else if (!strcmp(argv[1], \"port\")) {\n        Tcl_SetResult(interp, (char *) PQport(nspgConn->conn), TCL_STATIC);\n    } else if (!strcmp(argv[1], \"number\")) {\n        sprintf(interp->result, \"%u\", nspgConn->cNum);\n    } else if (!strcmp(argv[1], \"error\")) {\n        Tcl_SetResult(interp, (char *) PQerrorMessage(nspgConn->conn),\n\t\t\t TCL_STATIC);\n    } else if (!strcmp(argv[1], \"status\")) {\n        if (PQstatus(nspgConn->conn) == CONNECTION_OK) {\n            interp->result = \"ok\";\n        } else {\n            interp->result = \"bad\";\n        }\n    } else if (!strcmp(argv[1], \"ntuples\")) {\n\tchar string[16];\n\tsprintf(string, \"%d\", nspgConn->nTuples);\n\tTcl_SetResult(interp, string, TCL_VOLATILE);\n    } else {\n        Tcl_AppendResult(interp, \"unknown command \\\"\", argv[2],\n                         \"\\\": should be db, host, options, port, error, ntuples, \",\n#ifdef FOR_ACS_USE\n                         \"blob_write, blob_dml_file, blob_select_file, blob_put, \",\n#endif \n                         \"or status.\", NULL);\n        return TCL_ERROR;\n    }\n    return TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* ns_pg blob_put blob_id value\n * Stuff the contents of value into the pseudo-blob blob_id\n */\n", "func_signal": "static int\nblob_put(Tcl_Interp *interp, Ns_DbHandle *handle, char* blob_id,\n\t\t\tchar* value)", "code": "{\n    NsPgConn\t*nspgConn = (NsPgConn *) handle->connection;\n\tint\t\t\ti, j, segment, value_len, segment_len;\n\tchar\t\tout_buf[8001], query[10000];\n\tchar\t\t*segment_pos, *value_ptr;\n\n    value_len = strlen(value);\n    value_ptr = value;\n\n\tstrcpy(query, \"INSERT INTO LOB_DATA VALUES(\");\n\tstrcat(query, blob_id);\n\tstrcat(query, \",\");\n\tsegment_pos = query + strlen(query);\n\tsegment = 1;\n\n\twhile (value_len > 0) {\n\t    segment_len = value_len > 6000 ? 6000 : value_len;\n        value_len -= segment_len;\n\t\tfor (i = 0, j = 0; i < segment_len; i += 3, j+=4) {\n\t\t\tencode3(&value_ptr[i], &out_buf[j]);\n\t\t}\n\t\tout_buf[j] = '\\0';\n\t\tsprintf(segment_pos, \"%d, %d, '%s')\", segment, segment_len, out_buf);\n\n\t\tif (Ns_PgExec(handle, query) != NS_DML) {\n\t\t  Tcl_DString errString;\n\t\t  Tcl_DStringInit(&errString);\n\t\t  \n\t\t  Tcl_DStringAppend\n\t\t    (&errString, \"Error inserting data into BLOB\\n\", -1);\n\t\t  \n\t\t  if(handle->verbose)\n\t\t    {\n\t\t      append_PQresultStatus(&errString, nspgConn->res);\n\t\t      \n\t\t      Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t\t      Tcl_DStringAppend(&errString, query, -1);\n\t\t    }\n\n\t\t  Tcl_AppendResult(interp, Tcl_DStringValue(&errString), NULL);\n\t\t  \n\t\t  Tcl_DStringFree(&errString);\n\t\t  \n\t\t  return TCL_ERROR;\n\t\t}\n        value_ptr += segment_len;\n\t\tsegment++;\n\t}\n    Ns_Log(Notice, \"done\");\n\treturn TCL_OK;\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Ns_DbFreeTableInfo */\n", "func_signal": "static int\nNs_DbColumnIndex (Ns_DbTableInfo *tinfo, char *name)", "code": "{\n    int i;\n    int result = -1;\n\n    for (i = 0; i < tinfo->ncolumns; i++) \n      {\n\tchar *cname = tinfo->columns[i]->name;\n\tif (   (cname == name)\n\t    || ((cname == NULL) && (name == NULL))\n\t    || (strcmp(cname, name) == 0)) \n\t  {\n\t    result = i;\n\t    break;\n\t  }\n      }\n\n    return (result);\n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n * Ns_PgSelect - Send a query which should return rows.\n * \n * DRB: though AOLserver never calls this directly because\n * we've registered Ns_PgExec, the functions to return basic table\n * information to pre-AOLserver3 versions use it. Also, the reimplementation of\n * ns_column and ns_table uses it.\n */\n", "func_signal": "static Ns_Set  *\nNs_PgSelect(Ns_DbHandle *handle, char *sql)", "code": "{\n\n    static char *asfuncname = \"Ns_PgSelect\";\n    Ns_Set         *row = NULL;\n    NsPgConn       *nspgConn;\n    int             i;\n\n    if (handle == NULL || handle->connection == NULL) {\n        Ns_Log(Error, \"%s: Invalid connection.\", asfuncname);\n        goto done;\n    } \n\n    if (sql == NULL) {\n        Ns_Log(Error, \"%s: Invalid SQL query.\", asfuncname);\n        goto done;\n    }\n\n    nspgConn = handle->connection;\n\n    if (Ns_PgExec(handle, sql) != NS_ERROR) {\n\n        if (PQresultStatus(nspgConn->res) == PGRES_TUPLES_OK) {\n            nspgConn->curTuple = 0;\n            nspgConn->nCols = PQnfields(nspgConn->res);\n            nspgConn->nTuples = PQntuples(nspgConn->res);\n            row = handle->row;\n            \n            for (i = 0; i < nspgConn->nCols; i++) {\n                Ns_SetPut(row, (char *)PQfname(nspgConn->res, i), NULL);\n            }\n            \n        } else {\n\t  Tcl_DString errString;\n\t  Tcl_DStringInit(&errString);\n\n\t  Tcl_DStringAppend(&errString, \"\\nNs_PgSelect(\", -1);\n\t  Tcl_DStringAppend(&errString, handle->datasource, -1);\n\t  Tcl_DStringAppend(&errString, \"):  Query did not return rows\\n\", -1);\n\n\t  if(handle->verbose)\n\t    {\n\t      append_PQresultStatus(&errString, nspgConn->res);\n\n\t      Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t      Tcl_DStringAppend(&errString, sql, -1);\n\t    }\n\n\t  Ns_Log(Error, \"%s\", Tcl_DStringValue(&errString));\n\n\t  Tcl_DStringFree(&errString);\n        }\n    } else {\n      // Ns_PgExec returned NS_ERROR\n\n      Tcl_DString errString;\n      Tcl_DStringInit(&errString);\n      \n      Tcl_DStringAppend(&errString, \"\\nNs_PgSelect(\", -1);\n      Tcl_DStringAppend(&errString, handle->datasource, -1);\n      Tcl_DStringAppend(&errString, \"):  Ns_PgExec returned NS_ERROR\\n\", -1);\n      \n      if(handle->verbose)\n\t{\n\t  append_PQresultStatus(&errString, nspgConn->res);\n\t  \n\t  Tcl_DStringAppend(&errString, \"SQL:  \", -1);\n\t  Tcl_DStringAppend(&errString, sql, -1);\n\t}\n      \n      Ns_Log(Error, \"%s\", Tcl_DStringValue(&errString));\n    }\n  done:\n    return (row);\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* Parse a SQL string and return a list of all\n * the bind variables found in it.\n */\n", "func_signal": "static void\nparse_bind_variables(char *input, \n                     string_list_elt_t **bind_variables, \n                     string_list_elt_t **fragments)", "code": "{\n  char *p, lastchar;\n  enum { base, instr, bind } state;\n  char *bindbuf, *bp;\n  char *fragbuf, *fp;\n  string_list_elt_t *elt, *head=0, *tail=0;\n  string_list_elt_t *felt, *fhead=0, *ftail=0;\n  int current_string_length = 0;\n  int first_bind = 0;\n\n  fragbuf = (char*)Ns_Malloc((strlen(input)+1)*sizeof(char));\n  fp = fragbuf;\n  bindbuf = (char*)Ns_Malloc((strlen(input)+1)*sizeof(char));\n  bp = bindbuf;\n\n  for (p = input, state=base, lastchar='\\0'; *p != '\\0'; lastchar = *p, p++) {\n\n    switch (state) {\n    case base:\n      if (*p == '\\'') {\n\tstate = instr;\n        current_string_length = 0;\n        *fp++ = *p;\n      } else if ((*p == ':') && (*(p + 1) != ':') && (lastchar != ':')) {\n\tbp = bindbuf;\n\tstate = bind;\n        *fp = '\\0';\n        felt = string_list_elt_new(Ns_StrDup(fragbuf));\n        if(ftail == 0) {\n          fhead = ftail = felt;\n        } else {\n          ftail->next = felt;\n          ftail = felt;\n        }\n      } else {\n        *fp++ = *p;\n      }\n      break;\n\n    case instr:\n      if (*p == '\\'' && (lastchar != '\\'' || current_string_length == 0)) {\n\tstate = base;\n      }\n      current_string_length++;\n      *fp++ = *p;\n      break;\n\n    case bind:\n      if (*p == '=') {\n        state = base;\n        bp = bindbuf;\n        fp = fragbuf;\n      } else if (!(*p == '_' || *p == '$' || *p == '#' || isalnum((int)*p))) {\n\t*bp = '\\0';\n\telt = string_list_elt_new(Ns_StrDup(bindbuf));\n\tif (tail == 0) {\n\t  head = tail = elt;\n\t} else {\n\t  tail->next = elt;\n\t  tail = elt;\n\t}\n\tstate = base;\n        fp = fragbuf;\n\tp--;\n      } else {\n\t*bp++ = *p;\n      }\n      break;\n    }\n  }\n\n  if (state == bind) {\n    *bp = '\\0';\n    elt = string_list_elt_new(Ns_StrDup(bindbuf));\n    if (tail == 0) {\n      head = tail = elt;\n    } else {\n      tail->next = elt;\n      tail = elt;\n    }\n  } else {\n    *fp = '\\0';\n    felt = string_list_elt_new(Ns_StrDup(fragbuf));\n    if (ftail == 0) {\n      fhead = ftail = felt;\n    } else {\n      ftail->next = felt;\n      ftail = felt;\n    }\n  }\n  \n  Ns_Free(fragbuf);\n  Ns_Free(bindbuf);\n  *bind_variables = head;\n  *fragments      = fhead;  \n\n  return;\n\n}", "path": "nspostgres.c", "repo_name": "aolserver/nspostgres", "stars": 7, "license": "None", "language": "c", "size": 144}
{"docstring": "/* a <- b - c */\n", "func_signal": "subop(projUV *a, projUV *b, projUV *c, int n)", "code": "{\n\twhile (n--) {\n\t\ta->u = b->u - c->u;\n\t\ta++->v = b++->v - c++->v;\n\t}\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                          nad_ctable_init()                           */\n/*                                                                      */\n/*      Read the header portion of a \"ctable\" format grid.              */\n/************************************************************************/\n", "func_signal": "struct CTABLE *nad_ctable_init( FILE * fid )", "code": "{\n    struct CTABLE *ct;\n    int\t\tid_end;\n\n    /* read the table header */\n    ct = (struct CTABLE *) pj_malloc(sizeof(struct CTABLE));\n    if( ct == NULL \n        || fread( ct, sizeof(struct CTABLE), 1, fid ) != 1 )\n    {\n        pj_errno = -38;\n        return NULL;\n    }\n\n    /* do some minimal validation to ensure the structure isn't corrupt */\n    if( ct->lim.lam < 1 || ct->lim.lam > 100000 \n        || ct->lim.phi < 1 || ct->lim.phi > 100000 )\n    {\n        pj_errno = -38;\n        return NULL;\n    }\n    \n    /* trim white space and newlines off id */\n    for( id_end = strlen(ct->id)-1; id_end > 0; id_end-- )\n    {\n        if( ct->id[id_end] == '\\n' || ct->id[id_end] == ' ' )\n            ct->id[id_end] = '\\0';\n        else\n            break;\n    }\n\n    ct->cvs = NULL;\n\n    return ct;\n}", "path": "trunk\\Proj4\\nad_init.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* file processing function */\n", "func_signal": "process(FILE *fid)", "code": "{\n\tchar line[MAX_LINE+3], *s, pline[40];\n\tprojUV data;\n\n\tfor (;;) {\n\t\t++emess_dat.File_line;\n\t\tif (bin_in) {\t/* binary input */\n\t\t\tif (fread(&data, sizeof(projUV), 1, fid) != 1)\n\t\t\t\tbreak;\n\t\t} else {\t/* ascii input */\n\t\t\tif (!(s = fgets(line, MAX_LINE, fid)))\n\t\t\t\tbreak;\n\t\t\tif (!strchr(s, '\\n')) { /* overlong line */\n\t\t\t\tint c;\n\t\t\t\t(void)strcat(s, \"\\n\");\n\t\t\t\t/* gobble up to newline */\n\t\t\t\twhile ((c = fgetc(fid)) != EOF && c != '\\n') ;\n\t\t\t}\n\t\t\tif (*s == tag) {\n\t\t\t\tif (!bin_out)\n\t\t\t\t\t(void)fputs(line, stdout);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (reversein) {\n\t\t\t\tdata.v = (*informat)(s, &s);\n\t\t\t\tdata.u = (*informat)(s, &s);\n\t\t\t} else {\n\t\t\t\tdata.u = (*informat)(s, &s);\n\t\t\t\tdata.v = (*informat)(s, &s);\n\t\t\t}\n\t\t\tif (data.v == HUGE_VAL)\n\t\t\t\tdata.u = HUGE_VAL;\n\t\t\tif (!*s && (s > line)) --s; /* assumed we gobbled \\n */\n\t\t\tif (!bin_out && echoin) {\n\t\t\t\tint t;\n\t\t\t\tt = *s;\n\t\t\t\t*s = '\\0';\n\t\t\t\t(void)fputs(line, stdout);\n\t\t\t\t*s = t;\n\t\t\t\tputchar('\\t');\n\t\t\t}\n\t\t}\n\t\tif (data.u != HUGE_VAL) {\n\t\t\tif (prescale) { data.u *= fscale; data.v *= fscale; }\n\t\t\tif (dofactors && !inverse)\n\t\t\t\tfacs_bad = pj_factors(data, Proj, 0., &facs);\n\t\t\tdata = (*proj)(data, Proj);\n\t\t\tif (dofactors && inverse)\n\t\t\t\tfacs_bad = pj_factors(data, Proj, 0., &facs);\n\t\t\tif (postscale && data.u != HUGE_VAL)\n\t\t\t\t{ data.u *= fscale; data.v *= fscale; }\n\t\t}\n\t\tif (bin_out) { /* binary output */\n\t\t\t(void)fwrite(&data, sizeof(projUV), 1, stdout);\n\t\t\tcontinue;\n\t\t} else if (data.u == HUGE_VAL) /* error output */\n\t\t\t(void)fputs(oterr, stdout);\n\t\telse if (inverse && !oform) {\t/*ascii DMS output */\n\t\t\tif (reverseout) {\n\t\t\t\t(void)fputs(rtodms(pline, data.v, 'N', 'S'), stdout);\n\t\t\t\tputchar('\\t');\n\t\t\t\t(void)fputs(rtodms(pline, data.u, 'E', 'W'), stdout);\n\t\t\t} else {\n\t\t\t\t(void)fputs(rtodms(pline, data.u, 'E', 'W'), stdout);\n\t\t\t\tputchar('\\t');\n\t\t\t\t(void)fputs(rtodms(pline, data.v, 'N', 'S'), stdout);\n\t\t\t}\n\t\t} else {\t/* x-y or decimal degree ascii output */\n\t\t\tif (inverse) {\n\t\t\t\tdata.v *= RAD_TO_DEG;\n\t\t\t\tdata.u *= RAD_TO_DEG;\n\t\t\t}\n\t\t\tif (reverseout) {\n\t\t\t\t(void)printf(oform,data.v); putchar('\\t');\n\t\t\t\t(void)printf(oform,data.u);\n\t\t\t} else {\n\t\t\t\t(void)printf(oform,data.u); putchar('\\t');\n\t\t\t\t(void)printf(oform,data.v);\n\t\t\t}\n\t\t}\n\t\tif (dofactors) /* print scale factor data */\n\t\t\tif (!facs_bad)\n\t\t\t\t(void)printf(\"\\t<%g %g %g %g %g %g>\",\n\t\t\t\t\tfacs.h, facs.k, facs.s,\n\t\t\t\t\tfacs.omega * RAD_TO_DEG, facs.a, facs.b);\n\t\t\telse\n\t\t\t\t(void)fputs(\"\\t<* * * * * *>\", stdout);\n\t\t(void)fputs(bin_in ? \"\\n\" : s, stdout);\n\t}\n}", "path": "tags\\prefactor-24sept08\\Proj4\\proj.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* cartesian scale factor */\n", "func_signal": "static projUV\nint_proj(projUV data)", "code": "{\n\tif (prescale) { data.u *= fscale; data.v *= fscale; }\n\tdata = (*proj)(data, Proj);\n\tif (postscale && data.u != HUGE_VAL)\n\t\t{ data.u *= fscale; data.v *= fscale; }\n\treturn(data);\n}", "path": "tags\\prefactor-24sept08\\Proj4\\proj.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* entry point */\n", "func_signal": "bch2bps(projUV a, projUV b, projUV **c, int nu, int nv)", "code": "{\n\tprojUV **d;\n\tint i;\n\n\tif (nu < 1 || nv < 1 || !(d = (projUV **)vector2(nu, nv, sizeof(projUV))))\n\t\treturn 0;\n\t/* do rows to power series */\n\tfor (i = 0; i < nu; ++i) {\n\t\trows(c[i], d[i], nv);\n\t\trowshft(a.v, b.v, d[i], nv);\n\t}\n\t/* do columns to power series */\n\tcols(d, c, nu, nv);\n\tcolshft(a.u, b.u, c, nu, nv);\n\tfreev2((void **) d, nu);\n\treturn 1;\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                        pj_deallocate_grids()                         */\n/*                                                                      */\n/*      Deallocate all loaded grids.                                    */\n/************************************************************************/\n", "func_signal": "void pj_deallocate_grids()", "code": "{\n    while( grid_list != NULL )\n    {\n        PJ_GRIDINFO *item = grid_list;\n        grid_list = grid_list->next;\n        item->next = NULL;\n\n        pj_gridinfo_free( item );\n    }\n\n    if( last_nadgrids != NULL )\n    {\n        pj_dalloc( last_nadgrids );\n        last_nadgrids = NULL;\n\n        pj_dalloc( last_nadgrids_list );\n        last_nadgrids_list = NULL;\n\n        last_nadgrids_count = 0;\n        last_nadgrids_max = 0;\n    }\n}", "path": "tags\\prefactor-24sept08\\Proj4\\pj_gridlist.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* get common factors for simple conics */\n", "func_signal": "static int\nphi12(PJ *P, double *del)", "code": "{\n\tdouble p1, p2;\n\tint err = 0;\n\n\tif (!pj_param(P->params, \"tlat_1\").i ||\n\t\t!pj_param(P->params, \"tlat_2\").i) {\n\t\terr = -41;\n\t} else {\n\t\tp1 = pj_param(P->params, \"rlat_1\").f;\n\t\tp2 = pj_param(P->params, \"rlat_2\").f;\n\t\t*del = 0.5 * (p2 - p1);\n\t\tP->sig = 0.5 * (p2 + p1);\n\t\terr = (fabs(*del) < EPS || fabs(P->sig) < EPS) ? -42 : 0;\n\t\t*del = *del;\n\t}\n\treturn err;\n}", "path": "Proj4\\PJ_sconics.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                              nad_free()                              */\n/*                                                                      */\n/*      Free a CTABLE grid shift structure produced by nad_init().      */\n/************************************************************************/\n", "func_signal": "void nad_free(struct CTABLE *ct)", "code": "{\n    if (ct) {\n        if( ct->cvs != NULL )\n            pj_dalloc(ct->cvs);\n\n        pj_dalloc(ct);\n    }\n}", "path": "trunk\\Proj4\\nad_init.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* convert row to pover series */\n", "func_signal": "rows(projUV *c, projUV *d, int n)", "code": "{\n\tprojUV sv, *dd;\n\tint j, k;\n\n\tdd = (projUV *)vector1(n-1, sizeof(projUV));\n\tsv.u = sv.v = 0.;\n\tfor (j = 0; j < n; ++j) d[j] = dd[j] = sv;\n\td[0] = c[n-1];\n\tfor (j = n-2; j >= 1; --j) {\n\t\tfor (k = n-j; k >= 1; --k) {\n\t\t\tsv = d[k];\n\t\t\td[k].u = 2. * d[k-1].u - dd[k].u;\n\t\t\td[k].v = 2. * d[k-1].v - dd[k].v;\n\t\t\tdd[k] = sv;\n\t\t}\n\t\tsv = d[0];\n\t\td[0].u = -dd[0].u + c[j].u;\n\t\td[0].v = -dd[0].v + c[j].v;\n\t\tdd[0] = sv;\n\t}\n\tfor (j = n-1; j >= 1; --j) {\n\t\td[j].u = d[j-1].u - dd[j].u;\n\t\td[j].v = d[j-1].v - dd[j].v;\n\t}\n\td[0].u = -dd[0].u + .5 * c[0].u;\n\td[0].v = -dd[0].v + .5 * c[0].v;\n\tpj_dalloc(dd);\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                          nad_ctable_load()                           */\n/*                                                                      */\n/*      Load the data portion of a ctable formatted grid.               */\n/************************************************************************/\n", "func_signal": "int nad_ctable_load( struct CTABLE *ct, FILE *fid )", "code": "{\n    int  a_size;\n\n    fseek( fid, sizeof(struct CTABLE), SEEK_SET );\n\n    /* read all the actual shift values */\n    a_size = ct->lim.lam * ct->lim.phi;\n    ct->cvs = (FLP *) pj_malloc(sizeof(FLP) * a_size);\n    if( ct->cvs == NULL \n        || fread(ct->cvs, sizeof(FLP), a_size, fid) != a_size )\n    {\n        pj_dalloc( ct->cvs );\n        ct->cvs = NULL;\n\n        if( getenv(\"PROJ_DEBUG\") != NULL )\n        {\n            fprintf( stderr, \n            \"ctable loading failed on fread() - binary incompatible?\\n\" );\n        }\n\n        pj_errno = -38;\n        return 0;\n    }\n\n    return 1;\n}", "path": "trunk\\Proj4\\nad_init.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* create parameter list entry */\n", "func_signal": "pj_mkparam(char *str)", "code": "{\n\tparalist *newitem;\n\n\tif (newitem = (paralist *)pj_malloc(sizeof(paralist) + strlen(str))) {\n\t\tnewitem->used = 0;\n\t\tnewitem->next = 0;\n\t\tif (*str == '+')\n\t\t\t++str;\n\t\t(void)strcpy(newitem->param, str);\n\t}\n\treturn newitem;\n}", "path": "trunk\\Proj4\\pj_param.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                       pj_gridlist_merge_grid()                       */\n/*                                                                      */\n/*      Find/load the named gridfile and merge it into the              */\n/*      last_nadgrids_list.                                             */\n/************************************************************************/\n", "func_signal": "static int pj_gridlist_merge_gridfile( const char *gridname )", "code": "{\n    int i, got_match=0;\n    PJ_GRIDINFO *this_grid, *tail = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Try to find in the existing list of loaded grids.  Add all      */\n/*      matching grids as with NTv2 we can get many grids from one      */\n/*      file (one shared gridname).                                     */\n/* -------------------------------------------------------------------- */\n    for( this_grid = grid_list; this_grid != NULL; this_grid = this_grid->next)\n    {\n        if( strcmp(this_grid->gridname,gridname) == 0 )\n        {\n            got_match = 1;\n\n            /* dont add to the list if it is invalid. */\n            if( this_grid->ct == NULL )\n                return 0;\n\n            /* do we need to grow the list? */\n            if( last_nadgrids_count >= last_nadgrids_max - 2 )\n            {\n                PJ_GRIDINFO **new_list;\n                int new_max = last_nadgrids_max + 20;\n\n                new_list = (PJ_GRIDINFO **) pj_malloc(sizeof(void*) * new_max);\n                if( last_nadgrids_list != NULL )\n                {\n                    memcpy( new_list, last_nadgrids_list, \n                            sizeof(void*) * last_nadgrids_max );\n                    pj_dalloc( last_nadgrids_list );\n                }\n\n                last_nadgrids_list = new_list;\n                last_nadgrids_max = new_max;\n            }\n\n            /* add to the list */\n            last_nadgrids_list[last_nadgrids_count++] = this_grid;\n            last_nadgrids_list[last_nadgrids_count] = NULL;\n        }\n\n        tail = this_grid;\n    }\n\n    if( got_match )\n        return 1;\n\n/* -------------------------------------------------------------------- */\n/*      Try to load the named grid.                                     */\n/* -------------------------------------------------------------------- */\n    this_grid = pj_gridinfo_init( gridname );\n\n    if( this_grid == NULL )\n    {\n        /* we should get at least a stub grid with a missing \"ct\" member */\n        assert( FALSE );\n        return 0;\n    }\n    \n    if( tail != NULL )\n        tail->next = this_grid;\n    else\n        grid_list = this_grid;\n\n/* -------------------------------------------------------------------- */\n/*      Recurse to add the grid now that it is loaded.                  */\n/* -------------------------------------------------------------------- */\n    return pj_gridlist_merge_gridfile( gridname );\n}", "path": "tags\\prefactor-24sept08\\Proj4\\pj_gridlist.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* row adjust for range -1 to 1 to a to b */\n", "func_signal": "rowshft(double a, double b, projUV *d, int n)", "code": "{\n\tint k, j;\n\tdouble fac, cnst;\n\n\tcnst = 2. / (b - a);\n\tfac = cnst;\n\tfor (j = 1; j < n; ++j) {\n\t\td[j].u *= fac;\n\t\td[j].v *= fac;\n\t\tfac *= cnst;\n\t}\n\tcnst = .5 * (a + b);\n\tfor (j = 0; j <= n-2; ++j)\n\t\tfor (k = n - 2; k >= j; --k) {\n\t\t\td[k].u -= cnst * d[k+1].u;\n\t\t\td[k].v -= cnst * d[k+1].v;\n\t\t}\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* column adjust for range -1 to 1 to a to b */\n", "func_signal": "colshft(double a, double b, projUV **d, int n, int m)", "code": "{\n\tint k, j;\n\tdouble fac, cnst;\n\n\tcnst = 2. / (b - a);\n\tfac = cnst;\n\tfor (j = 1; j < n; ++j) {\n\t\tdmult(d[j], fac, m);\n\t\tfac *= cnst;\n\t}\n\tcnst = .5 * (a + b);\n\tfor (j = 0; j <= n-2; ++j)\n\t\tfor (k = n - 2; k >= j; --k)\n\t\t\tdadd(d[k], d[k+1], cnst, m);\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* test for presence or get parameter value */\n", "func_signal": "pj_param(paralist *pl, char *opt)", "code": "{\n\tint type;\n\tunsigned l;\n\tPVALUE value;\n\n\ttype = *opt++;\n\t/* simple linear lookup */\n\tl = strlen(opt);\n\twhile (pl && !(!strncmp(pl->param, opt, l) &&\n\t  (!pl->param[l] || pl->param[l] == '=')))\n\t\tpl = pl->next;\n\tif (type == 't')\n\t\tvalue.i = pl != 0;\n\telse if (pl) {\n\t\tpl->used |= 1;\n\t\topt = pl->param + l;\n\t\tif (*opt == '=')\n\t\t\t++opt;\n\t\tswitch (type) {\n\t\tcase 'i':\t/* integer input */\n\t\t\tvalue.i = atoi(opt);\n\t\t\tbreak;\n\t\tcase 'd':\t/* simple real input */\n\t\t\tvalue.f = atof(opt);\n\t\t\tbreak;\n\t\tcase 'r':\t/* degrees input */\n\t\t\tvalue.f = dmstor(opt, 0);\n\t\t\tbreak;\n\t\tcase 's':\t/* char string */\n\t\t\tvalue.s = opt;\n\t\t\tbreak;\n\t\tcase 'b':\t/* boolean */\n\t\t\tswitch (*opt) {\n\t\t\tcase 'F': case 'f':\n\t\t\t\tvalue.i = 0;\n\t\t\t\tbreak;\n\t\t\tcase '\\0': case 'T': case 't':\n\t\t\t\tvalue.i = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpj_errno = -8;\n\t\t\t\tvalue.i = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\nbum_type:\t/* note: this is an error in parameter, not a user error */\n\t\t\tfprintf(stderr, \"invalid request to pj_param, fatal\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else /* not given */\n\t\tswitch (type) {\n\t\tcase 'b':\n\t\tcase 'i':\n\t\t\tvalue.i = 0;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'r':\n\t\t\tvalue.f = 0.;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tvalue.s = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bum_type;\n\t\t}\n\treturn value;\n}", "path": "trunk\\Proj4\\pj_param.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* clear vector to zero */\n", "func_signal": "clear(projUV *p, int n)", "code": "{ static const projUV c = {0., 0.}; while (n--) *p++ = c; }\n\tstatic void /* clear matrix rows to zero */\nbclear(projUV **p, int n, int m) { while (n--) clear(*p++, m); }\n\tstatic void /* move vector */\nbmove(projUV *a, projUV *b, int n) { while (n--) *a++ = *b++; }\n\tstatic void /* a <- m * b - c */\nsubmop(projUV *a, double m, projUV *b, projUV *c, int n) {\n\twhile (n--) {\n\t\ta->u = m * b->u - c->u;\n\t\ta++->v = m * b++->v - c++->v;\n\t}\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* convert columns to power series */\n", "func_signal": "cols(projUV **c, projUV **d, int nu, int nv)", "code": "{\n\tprojUV *sv, **dd;\n\tint j, k;\n\n\tdd = (projUV **)vector2(nu, nv, sizeof(projUV));\n\tsv = (projUV *)vector1(nv, sizeof(projUV));\n\tbclear(d, nu, nv);\n\tbclear(dd, nu, nv);\n\tbmove(d[0], c[nu-1], nv);\n\tfor (j = nu-2; j >= 1; --j) {\n\t\tfor (k = nu-j; k >= 1; --k) {\n\t\t\tbmove(sv, d[k], nv);\n\t\t\tsubmop(d[k], 2., d[k-1], dd[k], nv);\n\t\t\tbmove(dd[k], sv, nv);\n\t\t}\n\t\tbmove(sv, d[0], nv);\n\t\tsubop(d[0], c[j], dd[0], nv);\n\t\tbmove(dd[0], sv, nv);\n\t}\n\tfor (j = nu-1; j >= 1; --j)\n\t\tsubop(d[j], d[j-1], dd[j], nv);\n\tsubmop(d[0], .5, c[0], dd[0], nv);\n\tfreev2((void **) dd, nu);\n\tpj_dalloc(sv);\n}", "path": "trunk\\Proj4\\bch2bps.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/* file processing function --- verbosely */\n", "func_signal": "vprocess(FILE *fid)", "code": "{\n\tchar line[MAX_LINE+3], *s, pline[40];\n\tprojUV dat_ll, dat_xy;\n\tint linvers;\n\n\tif (!oform)\n\t\toform = \"%.3f\";\n\tif (bin_in || bin_out)\n\t\temess(1,\"binary I/O not available in -V option\");\t\n\tfor (;;) {\n\t\t++emess_dat.File_line;\n\t\tif (!(s = fgets(line, MAX_LINE, fid)))\n\t\t\tbreak;\n\t\tif (!strchr(s, '\\n')) { /* overlong line */\n\t\t\tint c;\n\t\t\t(void)strcat(s, \"\\n\");\n\t\t\t/* gobble up to newline */\n\t\t\twhile ((c = fgetc(fid)) != EOF && c != '\\n') ;\n\t\t}\n\t\tif (*s == tag) { /* pass on data */\n\t\t\t(void)fputs(s, stdout);\n\t\t\tcontinue;\n\t\t}\n\t\t/* check to override default input mode */\n\t\tif (*s == 'I' || *s == 'i') {\n\t\t\tlinvers = 1;\n\t\t\t++s;\n\t\t} else if (*s == 'I' || *s == 'i') {\n\t\t\tlinvers = 0;\n\t\t\t++s;\n\t\t} else\n\t\t\tlinvers = inverse;\n\t\tif (linvers) {\n\t\t\tif (!PJ_INVERS(Proj)) {\n\t\t\t\temess(-1,\"inverse for this projection not avail.\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdat_xy.u = strtod(s, &s);\n\t\t\tdat_xy.v = strtod(s, &s);\n\t\t\tif (dat_xy.u == HUGE_VAL || dat_xy.v == HUGE_VAL) {\n\t\t\t\temess(-1,\"lon-lat input conversion failure\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prescale) { dat_xy.u *= fscale; dat_xy.v *= fscale; }\n\t\t\tdat_ll = pj_inv(dat_xy, Proj);\n\t\t} else {\n\t\t\tdat_ll.u = dmstor(s, &s);\n\t\t\tdat_ll.v = dmstor(s, &s);\n\t\t\tif (dat_ll.u == HUGE_VAL || dat_ll.v == HUGE_VAL) {\n\t\t\t\temess(-1,\"lon-lat input conversion failure\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdat_xy = pj_fwd(dat_ll, Proj);\n\t\t\tif (postscale) { dat_xy.u *= fscale; dat_xy.v *= fscale; }\n\t\t}\n\t\tif (pj_errno) {\n\t\t\temess(-1, pj_strerrno(pj_errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!*s && (s > line)) --s; /* assumed we gobbled \\n */\n\t\tif (pj_factors(dat_ll, Proj, 0., &facs)) {\n\t\t\temess(-1,\"failed to conpute factors\\n\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (*s != '\\n')\n\t\t\t(void)fputs(s, stdout);\n\t\t(void)fputs(\"Longitude: \", stdout);\n\t\t(void)fputs(rtodms(pline, dat_ll.u, 'E', 'W'), stdout);\n\t\t(void)printf(\" [ %.11g ]\\n\", dat_ll.u * RAD_TO_DEG);\n\t\t(void)fputs(\"Latitude:  \", stdout);\n\t\t(void)fputs(rtodms(pline, dat_ll.v, 'N', 'S'), stdout);\n\t\t(void)printf(\" [ %.11g ]\\n\", dat_ll.v * RAD_TO_DEG);\n\t\t(void)fputs(\"Easting (x):   \", stdout);\n\t\t(void)printf(oform, dat_xy.u); putchar('\\n');\n\t\t(void)fputs(\"Northing (y):  \", stdout);\n\t\t(void)printf(oform, dat_xy.v); putchar('\\n');\n\t\t(void)printf(\"Meridian scale (h)%c: %.8f  ( %.4g %% error )\\n\",\n\t\t\tfacs.code & IS_ANAL_HK ? '*' : ' ', facs.h, (facs.h-1.)*100.);\n\t\t(void)printf(\"Parallel scale (k)%c: %.8f  ( %.4g %% error )\\n\",\n\t\t\tfacs.code & IS_ANAL_HK ? '*' : ' ', facs.k, (facs.k-1.)*100.);\n\t\t(void)printf(\"Areal scale (s):     %.8f  ( %.4g %% error )\\n\",\n\t\t\tfacs.s, (facs.s-1.)*100.);\n\t\t(void)printf(\"Angular distortion (w): %.3f\\n\", facs.omega *\n\t\t\tRAD_TO_DEG);\n\t\t(void)printf(\"Meridian/Parallel angle: %.5f\\n\",\n\t\t\tfacs.thetap * RAD_TO_DEG);\n\t\t(void)printf(\"Convergence%c: \",facs.code & IS_ANAL_CONV ? '*' : ' ');\n\t\t(void)fputs(rtodms(pline, facs.conv, 0, 0), stdout);\n\t\t(void)printf(\" [ %.8f ]\\n\", facs.conv * RAD_TO_DEG);\n\t\t(void)printf(\"Max-min (Tissot axis a-b) scale error: %.5f %.5f\\n\\n\",\n\t\t\tfacs.a, facs.b);\n\t}\n}", "path": "tags\\prefactor-24sept08\\Proj4\\proj.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                     pj_gridlist_from_nadgrids()                      */\n/*                                                                      */\n/*      This functions loads the list of grids corresponding to a       */\n/*      particular nadgrids string into a list, and returns it.  The    */\n/*      list is kept around till a request is made with a different     */\n/*      string in order to cut down on the string parsing cost, and     */\n/*      the cost of building the list of tables each time.              */\n/************************************************************************/\n", "func_signal": "PJ_GRIDINFO **pj_gridlist_from_nadgrids( const char *nadgrids, int *grid_count)", "code": "{\n    const char *s;\n\n    pj_errno = 0;\n    *grid_count = 0;\n\n    if( last_nadgrids != NULL \n        && strcmp(nadgrids,last_nadgrids) == 0 )\n    {\n        *grid_count = last_nadgrids_count;\n        if( *grid_count == 0 )\n            pj_errno = -38;\n\n        return last_nadgrids_list;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Free old one, if any, and make space for new list.              */\n/* -------------------------------------------------------------------- */\n    if( last_nadgrids != NULL )\n    {\n        pj_dalloc(last_nadgrids);\n    }\n    \n    last_nadgrids = (char *) pj_malloc(strlen(nadgrids)+1);\n    strcpy( last_nadgrids, nadgrids );\n\n    last_nadgrids_count = 0;\n\n/* -------------------------------------------------------------------- */\n/*      Loop processing names out of nadgrids one at a time.            */\n/* -------------------------------------------------------------------- */\n    for( s = nadgrids; *s != '\\0'; )\n    {\n        int   end_char;\n        int   required = 1;\n        char  name[128];\n\n        if( *s == '@' )\n        {\n            required = 0;\n            s++;\n        }\n\n        for( end_char = 0; \n             s[end_char] != '\\0' && s[end_char] != ','; \n             end_char++ ) {}\n\n        if( end_char > sizeof(name) )\n        {\n            pj_errno = -38;\n            return NULL;\n        }\n        \n        strncpy( name, s, end_char );\n        name[end_char] = '\\0';\n\n        s += end_char;\n        if( *s == ',' )\n            s++;\n\n        if( !pj_gridlist_merge_gridfile( name ) && required )\n        {\n            pj_errno = -38;\n            return NULL;\n        }\n        else\n            pj_errno = 0;\n    }\n\n    if( last_nadgrids_count > 0 )\n    {\n        *grid_count = last_nadgrids_count;\n        return last_nadgrids_list;\n    }\n    else\n        return NULL;\n}", "path": "tags\\prefactor-24sept08\\Proj4\\pj_gridlist.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/************************************************************************/\n/*                            pj_open_lib()                             */\n/************************************************************************/\n", "func_signal": "FILE *\npj_open_lib(char *name, char *mode)", "code": "{\n    char fname[MAX_PATH_FILENAME+1];\n    const char *sysname;\n    FILE *fid;\n    int n = 0;\n    int i;\n#ifdef WIN32\n    static const char dir_chars[] = \"/\\\\\";\n#else\n    static const char dir_chars[] = \"/\";\n#endif\n\n#ifndef _WIN32_WCE\n\n    /* check if ~/name */\n    if (*name == '~' && strchr(dir_chars,name[1]) )\n        if (sysname = getenv(\"HOME\")) {\n            (void)strcpy(fname, sysname);\n            fname[n = strlen(fname)] = DIR_CHAR;\n            fname[++n] = '\\0';\n            (void)strcpy(fname+n, name + 1);\n            sysname = fname;\n        } else\n            return NULL;\n\n    /* or fixed path: /name, ./name or ../name */\n    else if (strchr(dir_chars,*name)\n             || (*name == '.' && strchr(dir_chars,name[1])) \n             || (!strncmp(name, \"..\", 2) && strchr(dir_chars,name[2]))\n             || (name[1] == ':' && strchr(dir_chars,name[2])) )\n        sysname = name;\n\n    /* or try to use application provided file finder */\n    else if( pj_finder != NULL && pj_finder( name ) != NULL )\n        sysname = pj_finder( name );\n\n    /* or is environment PROJ_LIB defined */\n    else if ((sysname = getenv(\"PROJ_LIB\")) || (sysname = proj_lib_name)) {\n        (void)strcpy(fname, sysname);\n        fname[n = strlen(fname)] = DIR_CHAR;\n        fname[++n] = '\\0';\n        (void)strcpy(fname+n, name);\n        sysname = fname;\n    } else /* just try it bare bones */\n        sysname = name;\n\n    if (fid = fopen(sysname, mode))\n        errno = 0;\n\n    /* If none of those work and we have a search path, try it */\n    if (!fid && path_count > 0)\n    {\n        for (i = 0; fid == NULL && i < path_count; i++)\n        {\n            sprintf(fname, \"%s%c%s\", search_path[i], DIR_CHAR, name);\n            sysname = fname;\n            fid = fopen (sysname, mode);\n        }\n        if (fid)\n            errno = 0;\n    }\n\n    if( getenv( \"PROJ_DEBUG\" ) != NULL )\n        fprintf( stderr, \"pj_open_lib(%s): call fopen(%s) - %s\\n\",\n                 name, sysname,\n                 fid == NULL ? \"failed\" : \"succeeded\" );\n\n    return(fid);\n#else\n    return NULL;\n#endif /* _WIN32_WCE */\n}", "path": "tags\\prefactor-24sept08\\Proj4\\pj_open_lib.c", "repo_name": "jamesdaniels/route-me", "stars": 4, "license": "None", "language": "c", "size": 1924}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * GetStaticUids --\n *\n *\tThis procedure is invoked to return a structure filled with\n *\tthe Uids used when doing tag searching. If it was never before\n *\tcalled in the current thread, it initializes the structure for\n *\tthat thread (uids are only ever local to one thread [Bug\n *\t1114977]).\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static SearchUids *\nGetStaticUids()", "code": "{\n    SearchUids *searchUids = (SearchUids *)\n\t    Tcl_GetThreadData(&searchUidTDK, sizeof(SearchUids));\n\n    if (searchUids->andUid == NULL) {\n\tsearchUids->andUid       = Tk_GetUid(\"&&\");\n\tsearchUids->orUid        = Tk_GetUid(\"||\");\n\tsearchUids->xorUid       = Tk_GetUid(\"^\");\n\tsearchUids->parenUid     = Tk_GetUid(\"(\");\n\tsearchUids->endparenUid  = Tk_GetUid(\")\");\n\tsearchUids->negparenUid  = Tk_GetUid(\"!(\");\n\tsearchUids->tagvalUid    = Tk_GetUid(\"!!\");\n\tsearchUids->negtagvalUid = Tk_GetUid(\"!\");\n    }\n    return searchUids;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*****/\n", "func_signal": "int TreeStateFromObj(TreeCtrl *tree, Tcl_Obj *obj, int *stateOff, int *stateOn)", "code": "{\n    int states[3];\n\n    states[STATE_OP_ON] = states[STATE_OP_OFF] = states[STATE_OP_TOGGLE] = 0;\n    if (Tree_StateFromObj(tree, obj, states, NULL, SFO_NOT_TOGGLE) != TCL_OK)\n\treturn TCL_ERROR;\n\n    (*stateOn) |= states[STATE_OP_ON];\n    (*stateOff) |= states[STATE_OP_OFF];\n    return TCL_OK;\n}", "path": "generic\\tkTreeElem.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * Tree_FindOptionSpec --\n *\n *\tReturn a pointer to a name Tk_OptionSpec in a table.\n *\n * Results:\n *\tReturns a pointer or panics.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "Tk_OptionSpec *\nTree_FindOptionSpec(\n    Tk_OptionSpec *optionTable,\n    CONST char *optionName\n    )", "code": "{\n    while (optionTable->type != TK_OPTION_END) {\n\tif (strcmp(optionTable->optionName, optionName) == 0)\n\t    return optionTable;\n\toptionTable++;\n    }\n    panic(\"Tree_FindOptionSpec: can't find %s\", optionName);\n    return NULL;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/* TEXTVAR */\n", "func_signal": "static void DeleteProcText(TreeElementArgs *args)", "code": "{\n    TreeCtrl *tree = args->tree;\n    TreeElement elem = args->elem;\n    ElementText *elemX = (ElementText *) elem;\n    ElementTextLayout2 *etl2;\n\n    if ((elemX->textCfg == NULL) && (elemX->text != NULL)) {\n\tckfree(elemX->text);\n\telemX->text = NULL;\n    }\n    etl2 = DynamicOption_FindData(elem->options, 1007);\n    if (etl2 != NULL && etl2->layout != NULL)\n\tTextLayout_Free(etl2->layout);\n    DynamicOption_Free1(tree, &elem->options, 1007, sizeof(ElementTextLayout2));\n#ifdef TEXTVAR\n    TextTraceUnset(tree->interp, elemX);\n#endif\n}", "path": "generic\\tkTreeElem.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * PixelsCO_Set --\n * PixelsCO_Get --\n * PixelsCO_Restore --\n *\n *\tThese procedures implement a TK_OPTION_CUSTOM where the custom\n *\toption is exactly the same as a TK_OPTION_PIXELS. This is used\n *\twhen storage for the option is dynamically allocated.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static int\nPixelsCO_Set(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **valuePtr,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags\n    )", "code": "{\n    int objEmpty;\n    int *internalPtr, new;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (int *) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    objEmpty = ObjectIsEmpty((*valuePtr));\n\n    if ((flags & TK_OPTION_NULL_OK) && objEmpty) {\n\t(*valuePtr) = NULL;\n\tnew = 0;\n    } else {\n\tif (Tk_GetPixelsFromObj(interp, tkwin, *valuePtr, &new) != TCL_OK)\n\t    return TCL_ERROR;\n    }\n\n    if (internalPtr != NULL) {\n\t*((int *) saveInternalPtr) = *internalPtr;\n\t*internalPtr = new;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * TreeAlloc_Init --\n *\n *\tAllocate and initialize a new memory-manager record.\n *\n * Results:\n *\tPointer to memory-manager record.\n *\n * Side effects:\n *\tMemory is allocated.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "ClientData\nTreeAlloc_Init(void)", "code": "{\n    AllocData *data = (AllocData *) ckalloc(sizeof(AllocData));\n    data->freeLists = NULL;\n#ifdef ALLOC_STATS\n    data->stats = NULL;\n#endif\n    return data;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * PerStateCO_Init --\n *\n *\tInitializes a Tk_OptionSpec.clientData for a custom option.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "int\nPerStateCO_Init(\n    Tk_OptionSpec *optionTable,\n    CONST char *optionName,\n    PerStateType *typePtr,\n    StateFromObjProc proc\n    )", "code": "{\n    Tk_OptionSpec *specPtr;\n\n    specPtr = Tree_FindOptionSpec(optionTable, optionName);\n    if (specPtr->type != TK_OPTION_CUSTOM)\n\tpanic(\"PerStateCO_Init: %s is not TK_OPTION_CUSTOM\", optionName);\n    if (specPtr->clientData != NULL)\n\treturn TCL_OK;\n\n    specPtr->clientData = PerStateCO_Alloc(optionName, typePtr, proc);\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * PerStateCO_Alloc --\n *\n *\tAllocates a Tk_ObjCustomOption record and clientData.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "Tk_ObjCustomOption *\nPerStateCO_Alloc(\n    CONST char *optionName,\n    PerStateType *typePtr,\n    StateFromObjProc proc\n    )", "code": "{\n    PerStateCOClientData *cd;\n    Tk_ObjCustomOption *co;\n\n    /* ClientData for the Tk custom option record */\n    cd = (PerStateCOClientData *) ckalloc(sizeof(PerStateCOClientData));\n    cd->typePtr = typePtr;\n    cd->proc = proc;\n\n    /* The Tk custom option record */\n    co = (Tk_ObjCustomOption *) ckalloc(sizeof(Tk_ObjCustomOption));\n    co->name = (char *) optionName + 1;\n    co->setProc = PerStateCO_Set;\n    co->getProc = PerStateCO_Get;\n    co->restoreProc = PerStateCO_Restore;\n    co->freeProc = PerStateCO_Free;\n    co->clientData = (ClientData) cd;\n\n    return co;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/* Called by the dynamic-option code when an ElementTextData is allocated. */\n", "func_signal": "static void\nElementTextStyleInit(\n    void *data\n    )", "code": "{\n    ElementTextStyle *ets = data;\n\n#define TEXT_UNDERLINE_EMPTYVAL -100000\n    ets->underline = TEXT_UNDERLINE_EMPTYVAL;\n}", "path": "generic\\tkTreeElem.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * TagExpr_Free --\n *\n *\tThis procedure frees the given struct.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void\nTagExpr_Free(\n    TagExpr *expr\n    )", "code": "{\n    if (expr->rewritebuffer != expr->staticRWB)\n\tckfree(expr->rewritebuffer);\n    if (expr->uids != expr->staticUids)\n\tckfree((char *) expr->uids);\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * DynamicOption_Free --\n *\n *\tFree a linked list of dynamic-option records. This gets called\n *\tafter Tk_FreeConfigOptions.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tMemory may be freed.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void\nDynamicOption_Free(\n    TreeCtrl *tree,\n    DynamicOption *first,\n    Tk_OptionSpec *optionTable\n    )", "code": "{\n    DynamicOption *opt = first;\n    DynamicCOClientData *cd;\n    Tk_ObjCustomOption *co;\n    int i;\n\n    while (opt != NULL) {\n\tDynamicOption *next = opt->next;\n\tfor (i = 0; optionTable[i].type != TK_OPTION_END; i++) {\n\n\t    if (optionTable[i].type != TK_OPTION_CUSTOM)\n\t\tcontinue;\n\n\t    co = (Tk_ObjCustomOption *) optionTable[i].clientData;\n\t    if (co->setProc != DynamicCO_Set)\n\t\tcontinue;\n\n\t    cd = (DynamicCOClientData *) co->clientData;\n\t    if (cd->id != opt->id)\n\t\tcontinue;\n\n#ifdef ALLOC_HAX\n\t    TreeAlloc_Free(tree->allocData, DynamicOptionUid, (char *) opt,\n\t\t    Tk_Offset(DynamicOption, data) + cd->size);\n#else\n\t    ckfree((char *) opt);\n#endif\n\t    break;\n\t}\n\topt = next;\n    }\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * TagInfoCO_Set --\n * TagInfoCO_Get --\n * TagInfoCO_Restore --\n * TagInfoCO_Free --\n *\n *\tThese procedures implement a TK_OPTION_CUSTOM where the custom\n *\toption is a TagInfo record.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static int\nTagInfoCO_Set(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **value,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags\n    )", "code": "{\n    TreeCtrl *tree = (TreeCtrl *) ((TkWindow *) tkwin)->instanceData;\n    int objEmpty;\n    TagInfo *new, **internalPtr;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (TagInfo **) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    objEmpty = ObjectIsEmpty((*value));\n\n    if ((flags & TK_OPTION_NULL_OK) && objEmpty)\n\t(*value) = NULL;\n    else {\n\tif (TagInfo_FromObj(tree, (*value), &new) != TCL_OK)\n\t    return TCL_ERROR;\n    }\n    if (internalPtr != NULL) {\n\tif ((*value) == NULL)\n\t    new = NULL;\n\t*((TagInfo **) saveInternalPtr) = *internalPtr;\n\t*internalPtr = new;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * StringCO_Set --\n * StringCO_Get --\n * StringCO_Restore --\n * StringCO_Free --\n *\n *\tThese procedures implement a TK_OPTION_CUSTOM where the custom\n *\toption is exactly the same as a TK_OPTION_STRING. This is used\n *\twhen storage for the option is dynamically allocated.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static int\nStringCO_Set(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **valuePtr,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags\n    )", "code": "{\n    int objEmpty;\n    char *internalPtr, *new, *value;\n    int length;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (char *) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    objEmpty = ObjectIsEmpty((*valuePtr));\n\n    if ((flags & TK_OPTION_NULL_OK) && objEmpty)\n\t(*valuePtr) = NULL;\n\n    if (internalPtr != NULL) {\n\tif (*valuePtr != NULL) {\n\t    value = Tcl_GetStringFromObj(*valuePtr, &length);\n\t    new = ckalloc((unsigned) (length + 1));\n\t    strcpy(new, value);\n\t} else {\n\t    new = NULL;\n\t}\n\t*((char **) saveInternalPtr) = *((char **) internalPtr);\n\t*((char **) internalPtr) = new;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/* Just like TK_OPTION_BOOLEAN but supports TK_OPTION_NULL_OK */\n/* Internal value is -1 for no-such-value */\n", "func_signal": "static int BooleanSet(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **value,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags)", "code": "{\n    int objEmpty;\n    int new, *internalPtr;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (int *) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    objEmpty = ObjectIsEmpty((*value));\n\n    if ((flags & TK_OPTION_NULL_OK) && objEmpty)\n\t(*value) = NULL;\n    else {\n\tif (Tcl_GetBooleanFromObj(interp, (*value), &new) != TCL_OK)\n\t    return TCL_ERROR;\n    }\n    if (internalPtr != NULL) {\n\tif ((*value) == NULL)\n\t    new = -1;\n\t*((int *) saveInternalPtr) = *internalPtr;\n\t*internalPtr = new;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeElem.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * StyleCO_Set --\n * StyleCO_Get --\n * StyleCO_Restore --\n *\n *\tThese procedures implement a TK_OPTION_CUSTOM where the custom\n *\toption is a TreeStyle.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static int\nStyleCO_Set(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **valuePtr,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags\n    )", "code": "{\n    TreeCtrl *tree = (TreeCtrl *) ((TkWindow *) tkwin)->instanceData;\n    int objEmpty;\n    TreeStyle *internalPtr, new;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (TreeStyle *) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    objEmpty = ObjectIsEmpty((*valuePtr));\n\n    if ((flags & TK_OPTION_NULL_OK) && objEmpty) {\n\t(*valuePtr) = NULL;\n\tnew = NULL;\n    } else {\n\tif (TreeStyle_FromObj(tree, *valuePtr, &new) != TCL_OK)\n\t    return TCL_ERROR;\n    }\n\n    if (internalPtr != NULL) {\n\t*((TreeStyle *) saveInternalPtr) = *internalPtr;\n\t*internalPtr = new;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*****/\n", "func_signal": "GC\nTree_GetGC(\n    TreeCtrl *tree,\n    unsigned long mask,\n    XGCValues *gcValues)", "code": "{\n    GCCache *pGC;\n    unsigned long valid = GCFont | GCForeground | GCFunction | GCBackground\n\t    | GCGraphicsExposures;\n\n    if ((mask | valid) != valid)\n\tpanic(\"GCCache_Get: unsupported mask\");\n\n    for (pGC = tree->gcCache; pGC != NULL; pGC = pGC->next) {\n\tif (mask != pGC->mask)\n\t    continue;\n\tif ((mask & GCFont) &&\n\t\t(pGC->gcValues.font != gcValues->font))\n\t    continue;\n\tif ((mask & GCForeground) &&\n\t\t(pGC->gcValues.foreground != gcValues->foreground))\n\t    continue;\n\tif ((mask & GCFunction) &&\n\t\t(pGC->gcValues.function != gcValues->function))\n\t    continue;\n\tif ((mask & GCBackground) &&\n\t\t(pGC->gcValues.background != gcValues->background))\n\t    continue;\n\tif ((mask & GCGraphicsExposures) &&\n\t\t(pGC->gcValues.graphics_exposures != gcValues->graphics_exposures))\n\t    continue;\n\treturn pGC->gc;\n    }\n\n    pGC = (GCCache *) ckalloc(sizeof(*pGC));\n    pGC->gcValues = (*gcValues);\n    pGC->mask = mask;\n    pGC->gc = Tk_GetGC(tree->tkwin, mask, gcValues);\n    pGC->next = tree->gcCache;\n    tree->gcCache = pGC;\n\n    return pGC->gc;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * OptionHax_Remember --\n * OptionHax_Forget --\n *\n *\tThese procedures are used to work around a limitation in\n *\tthe Tk_SavedOption structure: the internal form of a configuration\n *\toption cannot be larger than a double.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static void\nOptionHax_Remember(\n    TreeCtrl *tree,\n    char *ptr\n    )", "code": "{\n#ifdef TREECTRL_DEBUG\n    int i;\n    for (i = 0; i < tree->optionHaxCnt; i++) {\n\tif (ptr == tree->optionHax[i]) {\n\t    panic(\"OptionHax_Remember: ptr is not new\");\n\t}\n    }\n    if (tree->optionHaxCnt == sizeof(tree->optionHax) / sizeof(tree->optionHax[0]))\n\tpanic(\"OptionHax_Remember: too many options\");\n#endif\n    tree->optionHax[tree->optionHaxCnt++] = ptr;\n/*dbwin(\"OptionHax_Remember %p\\n\", ptr);*/\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * TreeDragImage_Draw --\n *\n *\tDraw (or erase) the elements that make up the drag image.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tStuff is drawn (or erased, since this is XOR drawing).\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void TreeDragImage_Draw(TreeDragImage dragImage, Drawable drawable, int x, int y)", "code": "{\n    TreeCtrl *tree = dragImage->tree;\n    DragElem *elem = dragImage->elem;\n    DotState dotState;\n\n/*\tif (!dragImage->visible)\n\treturn; */\n    if (elem == NULL)\n\treturn;\n\n    TreeDotRect_Setup(tree, drawable, &dotState);\n\n    while (elem != NULL) {\n\tTreeDotRect_Draw(&dotState,\n\t    x + dragImage->x + elem->x,\n\t    y + dragImage->y + elem->y,\n\t    elem->width, elem->height);\n\telem = elem->next;\n    }\n\n    TreeDotRect_Restore(&dotState);\n}", "path": "generic\\tkTreeDrag.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * DynamicOption_Free1 --\n *\n *\tFree a single dynamic-option record. This is a big hack so that\n *\tdynamic-option records that aren't associated with a Tk_OptionSpec\n *\tarray can be used.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tMemory may be freed.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "void\nDynamicOption_Free1(\n    TreeCtrl *tree,\n    DynamicOption **firstPtr,\n    int id,\n    int size\n    )", "code": "{\n    DynamicOption *opt = *firstPtr, *prev = NULL;\n\n    while (opt != NULL) {\n\tif (opt->id == id) {\n\t    if (prev == NULL)\n\t\t*firstPtr = opt->next;\n\t    else\n\t\tprev->next = opt->next;\n#ifdef ALLOC_HAX\n\t    TreeAlloc_Free(tree->allocData, DynamicOptionUid, (char *) opt,\n\t\t    Tk_Offset(DynamicOption, data) + size);\n#else\n\t    ckfree((char *) opt);\n#endif\n\t    return;\n\t}\n\tprev = opt;\n\topt = opt->next;\n    }\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n *----------------------------------------------------------------------\n *\n * BooleanFlagCO_Set --\n * BooleanFlagCO_Get --\n * BooleanFlagCO_Restore --\n *\n *\tThese procedures implement a TK_OPTION_CUSTOM where the custom\n *\toption is a boolean value whose internal rep is a single bit of\n *\tan int rather than the entire int.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n", "func_signal": "static int\nBooleanFlagCO_Set(\n    ClientData clientData,\n    Tcl_Interp *interp,\n    Tk_Window tkwin,\n    Tcl_Obj **value,\n    char *recordPtr,\n    int internalOffset,\n    char *saveInternalPtr,\n    int flags\n    )", "code": "{\n    int theFlag = (int) clientData;\n    int new, *internalPtr;\n\n    if (internalOffset >= 0)\n\tinternalPtr = (int *) (recordPtr + internalOffset);\n    else\n\tinternalPtr = NULL;\n\n    if (Tcl_GetBooleanFromObj(interp, (*value), &new) != TCL_OK)\n\treturn TCL_ERROR;\n\n    if (internalPtr != NULL) {\n\t*((int *) saveInternalPtr) = *internalPtr;\n\tif (new)\n\t    *internalPtr |= theFlag;\n\telse\n\t    *internalPtr &= ~theFlag;\n    }\n\n    return TCL_OK;\n}", "path": "generic\\tkTreeUtils.c", "repo_name": "davidw/tktreectrl", "stars": 5, "license": "other", "language": "c", "size": 1972}
{"docstring": "/*\n * Set up a single device.\n */\n", "func_signal": "static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)", "code": "{\n\tstruct scull_dev *dev = devinfo->sculldev;\n\tint err;\n\n\t/* Initialize the device structure */\n\tdev->quantum = scull_quantum;\n\tdev->qset = scull_qset;\n\tinit_MUTEX(&dev->sem);\n\n\t/* Do the cdev stuff. */\n\tcdev_init(&dev->cdev, devinfo->fops);\n\tkobject_set_name(&dev->cdev.kobj, devinfo->name);\n\tdev->cdev.owner = THIS_MODULE;\n\terr = cdev_add (&dev->cdev, devno, 1);\n        /* Fail gracefully if need be */\n\tif (err) {\n\t\tprintk(KERN_NOTICE \"Error %d adding %s\\n\", err, devinfo->name);\n\t\tkobject_put(&dev->cdev.kobj);\n\t} else\n\t\tprintk(KERN_NOTICE \"%s registered at %x\\n\", devinfo->name, devno);\n}", "path": "scull\\access.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* don't waste space if unused */\n/*\n * The proc filesystem: function to read and entry\n */\n", "func_signal": "void scullv_proc_offset(char *buf, char **start, off_t *offset, int *len)", "code": "{\n\tif (*offset == 0)\n\t\treturn;\n\tif (*offset >= *len) {\n\t\t/* Not there yet */\n\t\t*offset -= *len;\n\t\t*len = 0;\n\t} else {\n\t\t/* We're into the interesting stuff now */\n\t\t*start = buf + *offset;\n\t\t*offset = 0;\n\t}\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* FIXME: Do we need this here??  It be ugly  */\n", "func_signal": "int scullv_read_procmem(char *buf, char **start, off_t offset,\n                   int count, int *eof, void *data)", "code": "{\n\tint i, j, order, qset, len = 0;\n\tint limit = count - 80; /* Don't print more than this */\n\tstruct scullv_dev *d;\n\n\t*start = buf;\n\tfor(i = 0; i < scullv_devs; i++) {\n\t\td = &scullv_devices[i];\n\t\tif (down_interruptible (&d->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tqset = d->qset;  /* retrieve the features of each device */\n\t\torder = d->order;\n\t\tlen += sprintf(buf+len,\"\\nDevice %i: qset %i, order %i, sz %li\\n\",\n\t\t\t\ti, qset, order, (long)(d->size));\n\t\tfor (; d; d = d->next) { /* scan the list */\n\t\t\tlen += sprintf(buf+len,\"  item at %p, qset at %p\\n\",d,d->data);\n\t\t\tscullv_proc_offset (buf, start, &offset, &len);\n\t\t\tif (len > limit)\n\t\t\t\tgoto out;\n\t\t\tif (d->data && !d->next) /* dump only the last item - save space */\n\t\t\t\tfor (j = 0; j < qset; j++) {\n\t\t\t\t\tif (d->data[j])\n\t\t\t\t\t\tlen += sprintf(buf+len,\"    % 4i:%8p\\n\",j,d->data[j]);\n\t\t\t\t\tscullv_proc_offset (buf, start, &offset, &len);\n\t\t\t\t\tif (len > limit)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t  out:\n\t\tup (&scullv_devices[i].sem);\n\t\tif (len > limit)\n\t\t\tbreak;\n\t}\n\t*eof = 1;\n\treturn len;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Data management: read and write\n */\n", "func_signal": "ssize_t scullv_read (struct file *filp, char __user *buf, size_t count,\n                loff_t *f_pos)", "code": "{\n\tstruct scullv_dev *dev = filp->private_data; /* the first listitem */\n\tstruct scullv_dev *dptr;\n\tint quantum = PAGE_SIZE << dev->order;\n\tint qset = dev->qset;\n\tint itemsize = quantum * qset; /* how many bytes in the listitem */\n\tint item, s_pos, q_pos, rest;\n\tssize_t retval = 0;\n\n\tif (down_interruptible (&dev->sem))\n\t\treturn -ERESTARTSYS;\n\tif (*f_pos > dev->size) \n\t\tgoto nothing;\n\tif (*f_pos + count > dev->size)\n\t\tcount = dev->size - *f_pos;\n\t/* find listitem, qset index, and offset in the quantum */\n\titem = ((long) *f_pos) / itemsize;\n\trest = ((long) *f_pos) % itemsize;\n\ts_pos = rest / quantum; q_pos = rest % quantum;\n\n    \t/* follow the list up to the right position (defined elsewhere) */\n\tdptr = scullv_follow(dev, item);\n\n\tif (!dptr->data)\n\t\tgoto nothing; /* don't fill holes */\n\tif (!dptr->data[s_pos])\n\t\tgoto nothing;\n\tif (count > quantum - q_pos)\n\t\tcount = quantum - q_pos; /* read only up to the end of this quantum */\n\n\tif (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {\n\t\tretval = -EFAULT;\n\t\tgoto nothing;\n\t}\n\tup (&dev->sem);\n\n\t*f_pos += count;\n\treturn count;\n\n  nothing:\n\tup (&dev->sem);\n\treturn retval;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* Wait for space for writing; caller must hold device semaphore.  On\n * error the semaphore will be released before returning. */\n", "func_signal": "static int scull_getwritespace(struct scull_pipe *dev, struct file *filp)", "code": "{\n\twhile (spacefree(dev) == 0) { /* full */\n\t\tDEFINE_WAIT(wait);\n\t\t\n\t\tup(&dev->sem);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tPDEBUG(\"\\\"%s\\\" writing: going to sleep\\n\",current->comm);\n\t\tprepare_to_wait(&dev->outq, &wait, TASK_INTERRUPTIBLE);\n\t\tif (spacefree(dev) == 0)\n\t\t\tschedule();\n\t\tfinish_wait(&dev->outq, &wait);\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS; /* signal: tell the fs layer to handle it */\n\t\tif (down_interruptible(&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\treturn 0;\n}", "path": "scull\\pipe.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Finally, the module stuff\n */\n", "func_signal": "int scullv_init(void)", "code": "{\n\tint result, i;\n\tdev_t dev = MKDEV(scullv_major, 0);\n\t\n\t/*\n\t * Register your major, and accept a dynamic number.\n\t */\n\tif (scullv_major)\n\t\tresult = register_chrdev_region(dev, scullv_devs, \"scullv\");\n\telse {\n\t\tresult = alloc_chrdev_region(&dev, 0, scullv_devs, \"scullv\");\n\t\tscullv_major = MAJOR(dev);\n\t}\n\tif (result < 0)\n\t\treturn result;\n\n\t\n\t/* \n\t * allocate the devices -- we can't have them static, as the number\n\t * can be specified at load time\n\t */\n\tscullv_devices = kmalloc(scullv_devs*sizeof (struct scullv_dev), GFP_KERNEL);\n\tif (!scullv_devices) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_malloc;\n\t}\n\tmemset(scullv_devices, 0, scullv_devs*sizeof (struct scullv_dev));\n\tfor (i = 0; i < scullv_devs; i++) {\n\t\tscullv_devices[i].order = scullv_order;\n\t\tscullv_devices[i].qset = scullv_qset;\n\t\tsema_init (&scullv_devices[i].sem, 1);\n\t\tscullv_setup_cdev(scullv_devices + i, i);\n\t}\n\n\n#ifdef SCULLV_USE_PROC /* only when available */\n\tcreate_proc_read_entry(\"scullvmem\", 0, NULL, scullv_read_procmem, NULL);\n#endif\n\treturn 0; /* succeed */\n\n  fail_malloc:\n\tunregister_chrdev_region(dev, scullv_devs);\n\treturn result;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * The \"extended\" operations\n */\n", "func_signal": "loff_t scullv_llseek (struct file *filp, loff_t off, int whence)", "code": "{\n\tstruct scullv_dev *dev = filp->private_data;\n\tlong newpos;\n\n\tswitch(whence) {\n\tcase 0: /* SEEK_SET */\n\t\tnewpos = off;\n\t\tbreak;\n\n\tcase 1: /* SEEK_CUR */\n\t\tnewpos = filp->f_pos + off;\n\t\tbreak;\n\n\tcase 2: /* SEEK_END */\n\t\tnewpos = dev->size + off;\n\t\tbreak;\n\n\tdefault: /* can't happen */\n\t\treturn -EINVAL;\n\t}\n\tif (newpos<0) return -EINVAL;\n\tfilp->f_pos = newpos;\n\treturn newpos;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * open and close: just keep track of how many times the device is\n * mapped, to avoid releasing it.\n */\n", "func_signal": "void scullc_vma_open(struct vm_area_struct *vma)", "code": "{\n\tstruct scullc_dev *dev = vma->vm_private_data;\n\n\tdev->vmas++;\n}", "path": "scullc\\mmap.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* the /proc function: allocate everything to allow concurrency */\n", "func_signal": "int jit_tasklet(char *buf, char **start, off_t offset,\n\t      int len, int *eof, void *arg)", "code": "{\n\tstruct jit_data *data;\n\tchar *buf2 = buf;\n\tunsigned long j = jiffies;\n\tlong hi = (long)arg;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head (&data->wait);\n\n\t/* write the first lines in the buffer */\n\tbuf2 += sprintf(buf2, \"   time   delta  inirq    pid   cpu command\\n\");\n\tbuf2 += sprintf(buf2, \"%9li  %3li     %i    %6i   %i   %s\\n\",\n\t\t\tj, 0L, in_interrupt() ? 1 : 0,\n\t\t\tcurrent->pid, smp_processor_id(), current->comm);\n\n\t/* fill the data for our tasklet function */\n\tdata->prevjiffies = j;\n\tdata->buf = buf2;\n\tdata->loops = JIT_ASYNC_LOOPS;\n\t\n\t/* register the tasklet */\n\ttasklet_init(&data->tlet, jit_tasklet_fn, (unsigned long)data);\n\tdata->hi = hi;\n\n\tif (hi)\n\t\ttasklet_hi_schedule(&data->tlet);\n\telse\n\t\ttasklet_schedule(&data->tlet);\n\n\t/* wait for the buffer to fill */\n\twait_event_interruptible(data->wait, !data->loops);\n\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tbuf2 = data->buf;\n\tkfree(data);\n\t*eof = 1;\n\treturn buf2 - buf;\n}", "path": "misc-modules\\jit.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* How much space is free? */\n", "func_signal": "static int spacefree(struct scull_pipe *dev)", "code": "{\n\tif (dev->rp == dev->wp)\n\t\treturn dev->buffersize - 1;\n\treturn ((dev->rp + dev->buffersize - dev->wp) % dev->buffersize) - 1;\n}", "path": "scull\\pipe.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * This file, on the other hand, returns the current time forever\n */\n", "func_signal": "int jit_currentime(char *buf, char **start, off_t offset,\n                   int len, int *eof, void *data)", "code": "{\n\tstruct timeval tv1;\n\tstruct timespec tv2;\n\tunsigned long j1;\n\tu64 j2;\n\n\t/* get them four */\n\tj1 = jiffies;\n\tj2 = get_jiffies_64();\n\tdo_gettimeofday(&tv1);\n\ttv2 = current_kernel_time();\n\n\t/* print */\n\tlen=0;\n\tlen += sprintf(buf,\"0x%08lx 0x%016Lx %10i.%06i\\n\"\n\t\t       \"%40i.%09i\\n\",\n\t\t       j1, j2,\n\t\t       (int) tv1.tv_sec, (int) tv1.tv_usec,\n\t\t       (int) tv2.tv_sec, (int) tv2.tv_nsec);\n\t*start = buf;\n\treturn len;\n}", "path": "misc-modules\\jit.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Open and close\n */\n", "func_signal": "int scullv_open (struct inode *inode, struct file *filp)", "code": "{\n\tstruct scullv_dev *dev; /* device information */\n\n\t/*  Find the device */\n\tdev = container_of(inode->i_cdev, struct scullv_dev, cdev);\n\n    \t/* now trim to 0 the length of the device if open was write-only */\n\tif ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (down_interruptible (&dev->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tscullv_trim(dev); /* ignore errors */\n\t\tup (&dev->sem);\n\t}\n\n\t/* and use filp->private_data to point to the device data */\n\tfilp->private_data = dev;\n\n\treturn 0;          /* success */\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * The ioctl() implementation\n */\n", "func_signal": "int scullv_ioctl (struct inode *inode, struct file *filp,\n                 unsigned int cmd, unsigned long arg)", "code": "{\n\n\tint err = 0, ret = 0, tmp;\n\n\t/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */\n\tif (_IOC_TYPE(cmd) != SCULLV_IOC_MAGIC) return -ENOTTY;\n\tif (_IOC_NR(cmd) > SCULLV_IOC_MAXNR) return -ENOTTY;\n\n\t/*\n\t * the type is a bitmask, and VERIFY_WRITE catches R/W\n\t * transfers. Note that the type is user-oriented, while\n\t * verify_area is kernel-oriented, so the concept of \"read\" and\n\t * \"write\" is reversed\n\t */\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\terr = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\terr =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));\n\tif (err)\n\t\treturn -EFAULT;\n\n\tswitch(cmd) {\n\n\tcase SCULLV_IOCRESET:\n\t\tscullv_qset = SCULLV_QSET;\n\t\tscullv_order = SCULLV_ORDER;\n\t\tbreak;\n\n\tcase SCULLV_IOCSORDER: /* Set: arg points to the value */\n\t\tret = __get_user(scullv_order, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCTORDER: /* Tell: arg is the value */\n\t\tscullv_order = arg;\n\t\tbreak;\n\n\tcase SCULLV_IOCGORDER: /* Get: arg is pointer to result */\n\t\tret = __put_user (scullv_order, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCQORDER: /* Query: return it (it's positive) */\n\t\treturn scullv_order;\n\n\tcase SCULLV_IOCXORDER: /* eXchange: use arg as pointer */\n\t\ttmp = scullv_order;\n\t\tret = __get_user(scullv_order, (int __user *) arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCHORDER: /* sHift: like Tell + Query */\n\t\ttmp = scullv_order;\n\t\tscullv_order = arg;\n\t\treturn tmp;\n\n\tcase SCULLV_IOCSQSET:\n\t\tret = __get_user(scullv_qset, (int __user *) arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCTQSET:\n\t\tscullv_qset = arg;\n\t\tbreak;\n\n\tcase SCULLV_IOCGQSET:\n\t\tret = __put_user(scullv_qset, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCQQSET:\n\t\treturn scullv_qset;\n\n\tcase SCULLV_IOCXQSET:\n\t\ttmp = scullv_qset;\n\t\tret = __get_user(scullv_qset, (int __user *)arg);\n\t\tif (ret == 0)\n\t\t\tret = __put_user(tmp, (int __user *)arg);\n\t\tbreak;\n\n\tcase SCULLV_IOCHQSET:\n\t\ttmp = scullv_qset;\n\t\tscullv_qset = arg;\n\t\treturn tmp;\n\n\tdefault:  /* redundant, as cmd was checked against MAXNR */\n\t\treturn -ENOTTY;\n\t}\n\n\treturn ret;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* the /proc function: allocate everything to allow concurrency */\n", "func_signal": "int jit_timer(char *buf, char **start, off_t offset,\n\t      int len, int *eof, void *unused_data)", "code": "{\n\tstruct jit_data *data;\n\tchar *buf2 = buf;\n\tunsigned long j = jiffies;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinit_timer(&data->timer);\n\tinit_waitqueue_head (&data->wait);\n\n\t/* write the first lines in the buffer */\n\tbuf2 += sprintf(buf2, \"   time   delta  inirq    pid   cpu command\\n\");\n\tbuf2 += sprintf(buf2, \"%9li  %3li     %i    %6i   %i   %s\\n\",\n\t\t\tj, 0L, in_interrupt() ? 1 : 0,\n\t\t\tcurrent->pid, smp_processor_id(), current->comm);\n\n\t/* fill the data for our timer function */\n\tdata->prevjiffies = j;\n\tdata->buf = buf2;\n\tdata->loops = JIT_ASYNC_LOOPS;\n\t\n\t/* register the timer */\n\tdata->timer.data = (unsigned long)data;\n\tdata->timer.function = jit_timer_fn;\n\tdata->timer.expires = j + tdelay; /* parameter */\n\tadd_timer(&data->timer);\n\n\t/* wait for the buffer to fill */\n\twait_event_interruptible(data->wait, !data->loops);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tbuf2 = data->buf;\n\tkfree(data);\n\t*eof = 1;\n\treturn buf2 - buf;\n}", "path": "misc-modules\\jit.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * This is called by cleanup_module or on failure.\n * It is required to never fail, even if nothing was initialized first\n */\n", "func_signal": "void scull_access_cleanup(void)", "code": "{\n\tstruct scull_listitem *lptr, *next;\n\tint i;\n\n\t/* Clean up the static devs */\n\tfor (i = 0; i < SCULL_N_ADEVS; i++) {\n\t\tstruct scull_dev *dev = scull_access_devs[i].sculldev;\n\t\tcdev_del(&dev->cdev);\n\t\tscull_trim(scull_access_devs[i].sculldev);\n\t}\n\n    \t/* And all the cloned devices */\n\tlist_for_each_entry_safe(lptr, next, &scull_c_list, list) {\n\t\tlist_del(&lptr->list);\n\t\tscull_trim(&(lptr->device));\n\t\tkfree(lptr);\n\t}\n\n\t/* Free up our number space */\n\tunregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);\n\treturn;\n}", "path": "scull\\access.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * This function prints one line of data, after sleeping one second.\n * It can sleep in different ways, according to the data pointer\n */\n", "func_signal": "int jit_fn(char *buf, char **start, off_t offset,\n\t      int len, int *eof, void *data)", "code": "{\n\tunsigned long j0, j1; /* jiffies */\n\twait_queue_head_t wait;\n\n\tinit_waitqueue_head (&wait);\n\tj0 = jiffies;\n\tj1 = j0 + delay;\n\t\n\tswitch((long)data) {\n\t\tcase JIT_BUSY:\n\t\t\twhile (time_before(jiffies, j1))\n\t\t\t\tcpu_relax();\n\t\t\tbreak;\n\t\tcase JIT_SCHED:\n\t\t\twhile (time_before(jiffies, j1)) {\n\t\t\t\tschedule();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JIT_QUEUE:\n\t\t\twait_event_interruptible_timeout(wait, 0, delay);\n\t\t\tbreak;\n\t\tcase JIT_SCHEDTO:\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout (delay);\n\t\t\tbreak;\n\t}\n\tj1 = jiffies; /* actual value after we delayed */\n\n\tlen = sprintf(buf, \"%9li %9li\\n\", j0, j1);\n\t*start = buf;\n\treturn len;\n}", "path": "misc-modules\\jit.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Follow the list \n */\n", "func_signal": "struct scullv_dev *scullv_follow(struct scullv_dev *dev, int n)", "code": "{\n\twhile (n--) {\n\t\tif (!dev->next) {\n\t\t\tdev->next = kmalloc(sizeof(struct scullv_dev), GFP_KERNEL);\n\t\t\tmemset(dev->next, 0, sizeof(struct scullv_dev));\n\t\t}\n\t\tdev = dev->next;\n\t\tcontinue;\n\t}\n\treturn dev;\n}", "path": "scullv\\main.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Set up a cdev entry.\n */\n", "func_signal": "static void scull_p_setup_cdev(struct scull_pipe *dev, int index)", "code": "{\n\tint err, devno = scull_p_devno + index;\n    \n\tcdev_init(&dev->cdev, &scull_pipe_fops);\n\tdev->cdev.owner = THIS_MODULE;\n\terr = cdev_add (&dev->cdev, devno, 1);\n\t/* Fail gracefully if need be */\n\tif (err)\n\t\tprintk(KERN_NOTICE \"Error %d adding scullpipe%d\", err, index);\n}", "path": "scull\\pipe.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * Initialize the pipe devs; return how many we did.\n */\n", "func_signal": "int scull_p_init(dev_t firstdev)", "code": "{\n\tint i, result;\n\n\tresult = register_chrdev_region(firstdev, scull_p_nr_devs, \"scullp\");\n\tif (result < 0) {\n\t\tprintk(KERN_NOTICE \"Unable to get scullp region, error %d\\n\", result);\n\t\treturn 0;\n\t}\n\tscull_p_devno = firstdev;\n\tscull_p_devices = kmalloc(scull_p_nr_devs * sizeof(struct scull_pipe), GFP_KERNEL);\n\tif (scull_p_devices == NULL) {\n\t\tunregister_chrdev_region(firstdev, scull_p_nr_devs);\n\t\treturn 0;\n\t}\n\tmemset(scull_p_devices, 0, scull_p_nr_devs * sizeof(struct scull_pipe));\n\tfor (i = 0; i < scull_p_nr_devs; i++) {\n\t\tinit_waitqueue_head(&(scull_p_devices[i].inq));\n\t\tinit_waitqueue_head(&(scull_p_devices[i].outq));\n\t\tinit_MUTEX(&scull_p_devices[i].sem);\n\t\tscull_p_setup_cdev(scull_p_devices + i, i);\n\t}\n#ifdef SCULL_DEBUG\n\tcreate_proc_read_entry(\"scullpipe\", 0, NULL, scull_read_p_mem, NULL);\n#endif\n\treturn scull_p_nr_devs;\n}", "path": "scull\\pipe.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/*\n * The nopage method: the core of the file. It retrieves the\n * page required from the scullc device and returns it to the\n * user. The count for the page must be incremented, because\n * it is automatically decremented at page unmap.\n *\n * For this reason, \"order\" must be zero. Otherwise, only the first\n * page has its count incremented, and the allocating module must\n * release it as a whole block. Therefore, it isn't possible to map\n * pages from a multipage block: when they are unmapped, their count\n * is individually decreased, and would drop to 0.\n */\n", "func_signal": "struct page *scullc_vma_nopage(struct vm_area_struct *vma,\n                                unsigned long address, int *type)", "code": "{\n\tunsigned long offset;\n\tstruct scullc_dev *ptr, *dev = vma->vm_private_data;\n\tstruct page *page = NOPAGE_SIGBUS;\n\tvoid *pageptr = NULL; /* default to \"missing\" */\n\n\tdown(&dev->sem);\n\toffset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);\n\tif (offset >= dev->size) goto out; /* out of range */\n\n\t/*\n\t * Now retrieve the scullc device from the list,then the page.\n\t * If the device has holes, the process receives a SIGBUS when\n\t * accessing the hole.\n\t */\n\toffset >>= PAGE_SHIFT; /* offset is a number of pages */\n\tfor (ptr = dev; ptr && offset >= dev->qset;) {\n\t\tptr = ptr->next;\n\t\toffset -= dev->qset;\n\t}\n\tif (ptr && ptr->data) pageptr = ptr->data[offset];\n\tif (!pageptr) goto out; /* hole or end-of-file */\n\n\t/* got it, now increment the count */\n\tget_page(page);\n\tif (type)\n\t\t*type = VM_FAULT_MINOR;\n  out:\n\tup(&dev->sem);\n\treturn page;\n}", "path": "scullc\\mmap.c", "repo_name": "csl/lld3-example", "stars": 6, "license": "other", "language": "c", "size": 244}
{"docstring": "/* Remove the file system object specified by ENT.  IS_DIR specifies\n   whether it is expected to be a directory or non-directory.\n   Return RM_OK upon success, else RM_ERROR.  */\n", "func_signal": "static enum RM_status\nexcise (FTS *fts, FTSENT *ent, struct rm_options const *x, bool is_dir)", "code": "{\n  int flag = is_dir ? AT_REMOVEDIR : 0;\n  if (unlinkat (fts->fts_cwd_fd, ent->fts_accpath, flag) == 0)\n    {\n      if (x->verbose)\n        {\n          printf ((is_dir\n                   ? _(\"removed directory: %s\\n\")\n                   : _(\"removed %s\\n\")), quote (ent->fts_path));\n        }\n      return RM_OK;\n    }\n\n  /* The unlinkat from kernels like linux-2.6.32 reports EROFS even for\n     nonexistent files.  When the file is indeed missing, map that to ENOENT,\n     so that rm -f ignores it, as required.  Even without -f, this is useful\n     because it makes rm print the more precise diagnostic.  */\n  if (errno == EROFS)\n    {\n      struct stat st;\n      if ( ! (lstatat (fts->fts_cwd_fd, ent->fts_accpath, &st)\n                       && errno == ENOENT))\n        errno = EROFS;\n    }\n\n  if (ignorable_missing (x, errno))\n    return RM_OK;\n\n  /* When failing to rmdir an unreadable directory, the typical\n     errno value is EISDIR, but that is not as useful to the user\n     as the errno value from the failed open (probably EPERM).\n     Use the earlier, more descriptive errno value.  */\n  if (ent->fts_info == FTS_DNR)\n    errno = ent->fts_errno;\n  error (0, errno, _(\"cannot remove %s\"), quote (ent->fts_path));\n  mark_ancestor_dirs (ent);\n  return RM_ERROR;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Upon unlink failure, or when the user declines to remove ENT, mark\n   each of its ancestor directories, so that we know not to prompt for\n   its removal.  */\n", "func_signal": "static void\nmark_ancestor_dirs (FTSENT *ent)", "code": "{\n  FTSENT *p;\n  for (p = ent->fts_parent; FTS_ROOTLEVEL <= p->fts_level; p = p->fts_parent)\n    {\n      if (p->fts_number)\n        break;\n      p->fts_number = 1;\n    }\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Remove FILEs, honoring options specified via X.\n   Return RM_OK if successful.  */\n", "func_signal": "enum RM_status\nrm (char *const *file, struct rm_options const *x)", "code": "{\n  enum RM_status rm_status = RM_OK;\n\n  if (*file)\n    {\n      int bit_flags = (FTS_CWDFD\n                       | FTS_NOSTAT\n                       | FTS_PHYSICAL);\n\n      if (x->one_file_system)\n        bit_flags |= FTS_XDEV;\n\n      FTS *fts = xfts_open (file, bit_flags, NULL);\n\n      while (1)\n        {\n          FTSENT *ent;\n\n          ent = fts_read (fts);\n          if (ent == NULL)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"fts_read failed\"));\n                  rm_status = RM_ERROR;\n                }\n              break;\n            }\n\n          enum RM_status s = rm_fts (fts, ent, x);\n\n          assert (VALID_STATUS (s));\n          UPDATE_STATUS (rm_status, s);\n        }\n\n      if (fts_close (fts) != 0)\n        {\n          error (0, errno, _(\"fts_close failed\"));\n          rm_status = RM_ERROR;\n        }\n    }\n\n  return rm_status;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Call lstat to get the device and inode numbers for `/'.\n   Upon failure, return NULL.  Otherwise, set the members of\n   *ROOT_D_I accordingly and return ROOT_D_I.  */\n", "func_signal": "struct dev_ino *\nget_root_dev_ino (struct dev_ino *root_d_i)", "code": "{\n  struct stat statbuf;\n  if (lstat (\"/\", &statbuf))\n    return NULL;\n  root_d_i->st_ino = statbuf.st_ino;\n  root_d_i->st_dev = statbuf.st_dev;\n  return root_d_i;\n}", "path": "lib\\root-dev-ino.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Return 1 if FILE is an unwritable non-symlink,\n   0 if it is writable or some other type of file,\n   -1 and set errno if there is some problem in determining the answer.\n   Use FULL_NAME only if necessary.\n   Set *BUF to the file status.\n   This is to avoid calling euidaccess when FILE is a symlink.  */\n", "func_signal": "static int\nwrite_protected_non_symlink (int fd_cwd,\n                             char const *file,\n                             char const *full_name,\n                             struct stat *buf)", "code": "{\n  if (can_write_any_file ())\n    return 0;\n  if (cache_fstatat (fd_cwd, file, buf, AT_SYMLINK_NOFOLLOW) != 0)\n    return -1;\n  if (S_ISLNK (buf->st_mode))\n    return 0;\n  /* Here, we know FILE is not a symbolic link.  */\n\n  /* In order to be reentrant -- i.e., to avoid changing the working\n     directory, and at the same time to be able to deal with alternate\n     access control mechanisms (ACLs, xattr-style attributes) and\n     arbitrarily deep trees -- we need a function like eaccessat, i.e.,\n     like Solaris' eaccess, but fd-relative, in the spirit of openat.  */\n\n  /* In the absence of a native eaccessat function, here are some of\n     the implementation choices [#4 and #5 were suggested by Paul Eggert]:\n     1) call openat with O_WRONLY|O_NOCTTY\n        Disadvantage: may create the file and doesn't work for directory,\n        may mistakenly report `unwritable' for EROFS or ACLs even though\n        perm bits say the file is writable.\n\n     2) fake eaccessat (save_cwd, fchdir, call euidaccess, restore_cwd)\n        Disadvantage: changes working directory (not reentrant) and can't\n        work if save_cwd fails.\n\n     3) if (euidaccess (full_name, W_OK) == 0)\n        Disadvantage: doesn't work if full_name is too long.\n        Inefficient for very deep trees (O(Depth^2)).\n\n     4) If the full pathname is sufficiently short (say, less than\n        PATH_MAX or 8192 bytes, whichever is shorter):\n        use method (3) (i.e., euidaccess (full_name, W_OK));\n        Otherwise: vfork, fchdir in the child, run euidaccess in the\n        child, then the child exits with a status that tells the parent\n        whether euidaccess succeeded.\n\n        This avoids the O(N**2) algorithm of method (3), and it also avoids\n        the failure-due-to-too-long-file-names of method (3), but it's fast\n        in the normal shallow case.  It also avoids the lack-of-reentrancy\n        and the save_cwd problems.\n        Disadvantage; it uses a process slot for very-long file names,\n        and would be very slow for hierarchies with many such files.\n\n     5) If the full file name is sufficiently short (say, less than\n        PATH_MAX or 8192 bytes, whichever is shorter):\n        use method (3) (i.e., euidaccess (full_name, W_OK));\n        Otherwise: look just at the file bits.  Perhaps issue a warning\n        the first time this occurs.\n\n        This is like (4), except for the \"Otherwise\" case where it isn't as\n        \"perfect\" as (4) but is considerably faster.  It conforms to current\n        POSIX, and is uniformly better than what Solaris and FreeBSD do (they\n        mess up with long file names). */\n\n  {\n    /* This implements #1: on decent systems, either faccessat is\n       native or /proc/self/fd allows us to skip a chdir.  */\n    if (!openat_needs_fchdir ())\n      {\n        if (faccessat (fd_cwd, file, W_OK, AT_EACCESS) == 0)\n          return 0;\n\n        return errno == EACCES ? 1 : -1;\n      }\n\n    /* This implements #5: */\n    size_t file_name_len = strlen (full_name);\n\n    if (MIN (PATH_MAX, 8192) <= file_name_len)\n      return ! euidaccess_stat (buf, W_OK);\n    if (euidaccess (full_name, W_OK) == 0)\n      return 0;\n    if (errno == EACCES)\n      {\n        errno = 0;\n        return 1;\n      }\n\n    /* Perhaps some other process has removed the file, or perhaps this\n       is a buggy NFS client.  */\n    return -1;\n  }\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* /bar\" (without the space), \"f*oo/bar\", names that would\n   have multiple globs in them, or dot files.  This seems to cover the\n   majority of mistakes.\n\n   To do this we group arguments that could come from the same glob\n   and for each of those groups check to see if the containing\n   directory is in X->warnings_table, and every file of the directory\n   is in the arguments list.  Prompt the user if the above conditions\n   are met, and return true only if the user permits us to continue,\n   or we didn't prompt.  */\n", "func_signal": "bool\ncheck_globs (char *const *file, struct rm_options const *x)", "code": "{\n  /* There tends to be very few distinct directory prefixes on the\n     command line, at least when used by a human.  Hence we use a\n     resizable array rather than a hash table for performance.  */\n  size_t n_prefixes = 0, prefixes_alloced = 16;\n  struct dir_prefix *prefixes = xmalloc (prefixes_alloced * sizeof *prefixes);\n  struct dir_prefix *pfix;\n  size_t i;\n  bool check_ok = true;\n\n  /* Store each argument basename in a table under its directory\n     prefix.  I.e., for argument \"foo/bar/baz\", store \"baz\" in the\n     table under prefix \"foo/bar\".  */\n  for ( ; *file; ++file)\n    {\n      size_t len = dir_len (*file);\n      for (i = 0; i < n_prefixes; ++i)\n        {\n          pfix = &prefixes[i];\n          if (len == pfix->len && 0 == strncmp (*file, pfix->dirname, len))\n            break;\n        }\n      if (i == n_prefixes)\n        {\n          if (n_prefixes == prefixes_alloced)\n            {\n              prefixes_alloced *= 2;\n              prefixes = xrealloc (prefixes,\n                                   prefixes_alloced * sizeof *prefixes);\n            }\n          pfix = &prefixes[n_prefixes++];\n          pfix->dirname = *file;\n          pfix->len = len;\n          pfix->filenames = hash_initialize (17, NULL, hash_pjw, streq, NULL);\n          if (! pfix->filenames)\n            xalloc_die ();\n        }\n      char const *filename = *file + len;\n      while (ISSLASH (*filename))\n        ++filename;\n      if (! hash_insert (pfix->filenames, filename))\n        xalloc_die ();\n    }\n\n  /* For each directory prefix in the argument list, check if it's in\n     the warnings table, and if so, read the directory and see if\n     every non-dot file in the directory is listed in the arguments.\n     This will catch a glob in that directory, sans race conditions,\n     which is better than nothing.  */\n  for (i = 0; check_ok && i < n_prefixes; ++i)\n    {\n      struct stat st;\n      char const *dirname;\n      pfix = &prefixes[i];\n      if (pfix->len == 0)\n        dirname = \".\";\n      else\n        {\n          assert (ISSLASH (pfix->dirname[pfix->len]));\n          pfix->dirname[pfix->len] = '\\0';\n          dirname = pfix->dirname;\n        }\n\n      if (-1 == stat (dirname, &st))\n        {\n          if (! ignorable_missing (x, errno))\n            error (EXIT_FAILURE, errno, _(\"cannot stat %s\"), quote (dirname));\n        }\n      else\n        {\n          /* Check if the directory is in the warnings table and if so\n             check the contents.  */\n          struct warnings_entry *found =\n            warnings_table_lookup (x->warnings_table, &st);\n          if (found)\n            {\n              DIR *dir = opendir (dirname);\n              if (! dir)\n                error (EXIT_FAILURE, errno, _(\"cannot open directory %s\"),\n                       quote (dirname));\n\n              struct dirent *dirent;\n              size_t n_files = 0;\n\n              /* readdir sets errno on failure but not on success.  */\n              errno = 0;\n              while ((dirent = readdir (dir)))\n                {\n                  if (dirent->d_name[0] == '.')\n                    continue;\n                  if (! hash_lookup (pfix->filenames, dirent->d_name))\n                    break;\n                  n_files++;\n                }\n              if (dirent == NULL)\n                {\n                  if (errno)\n                    error (EXIT_FAILURE, errno,\n                           _(\"error reading directory %s\"), quote (dirname));\n\n                  if (n_files)\n                    {\n                      char *glob =\n                        xconcatenated_filename (found->given_path, \"*\", NULL);\n                      char const *s = (n_files == 1) ? \"\" : \"s\";\n                      issue_warning(_(\"you are about to remove\"\n                                      \" %zd file%s via %s; continue? \"),\n                                    n_files, s, quote (glob));\n                      free (glob);\n                      /* If they want to remove the glob contents,\n                         don't bother them later about whether they\n                         want to remove the directory.  */\n                      found->response = yesno () ? T_YES : T_NO;\n\n                      if (found->response == T_NO)\n                        check_ok = false;\n                    }\n                } /* end if (dirent == NULL) */\n\n              if (-1 == closedir (dir))\n                error (EXIT_FAILURE, errno, _(\"cannot close directory %s\"),\n                       quote (dirname));\n\n            } /* end if (found) */\n\n        } /* end if (-1 != stat (dirname, &st)) */\n\n      if (pfix->len)\n        pfix->dirname[pfix->len] = DIRECTORY_SEPARATOR;\n\n    } /* end for (check_ok && i < n_prefixes) */\n\n  while (0 < n_prefixes)\n    hash_free (prefixes[--n_prefixes].filenames);\n  free (prefixes);\n\n  return check_ok;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Look up the file referenced by ENT->fts_accpath.  Follow symlinks\n   if the target is a directory and we are in recursive mode.  Warn\n   and propmt the user if the object given by the device and inode\n   numbers are found in the warnings table.  Return WARN_NOT_FOUND if\n   the file was not in the warnings table and so the default prompt,\n   if any, should be given.  If the user allows removal, return\n   WARN_OK.  If they decline return WARN_USER_DECLINED.  If an error\n   occurs return WARN_ERROR.  Any value except WARN_NOT_FOUND has the\n   same value as its corresponding RM_status.\n\n   Use FD_CWD and CACHED_LSTAT for cache_fstatat calls.  */\n", "func_signal": "static enum warn_status\nwarn (FTSENT const *ent, int fd_cwd, struct stat *cached_lstat,\n      struct rm_options const *x)", "code": "{\n  if (-1 == cache_fstatat (fd_cwd, ent->fts_accpath, cached_lstat,\n                           AT_SYMLINK_NOFOLLOW))\n    return ignorable_missing (x, errno) ? WARN_NOT_FOUND : WARN_ERROR;\n\n  struct warnings_entry *found =\n    warnings_table_lookup (x->warnings_table, cached_lstat);\n  if (found)\n    {\n      if (found->response == T_UNKNOWN)\n        {\n          issue_warning(_(\"you are about to remove %s; continue? \"),\n                        quote (found->given_path));\n\n          found->response = yesno () ? T_YES : T_NO;\n        }\n      return (found->response == T_YES) ? WARN_OK : WARN_USER_DECLINED;\n    }\n\n  if (! S_ISLNK (cached_lstat->st_mode) || ! x->recursive)\n    return WARN_NOT_FOUND;\n\n  struct stat st;\n  if (-1 == stat (ent->fts_accpath, &st))\n    return ignorable_missing (x, errno) ? WARN_NOT_FOUND : WARN_ERROR;\n\n  if (! S_ISDIR (st.st_mode))\n    return WARN_NOT_FOUND;\n\n  found = warnings_table_lookup (x->warnings_table, &st);\n  if (! found)\n    return WARN_NOT_FOUND;\n\n  if (found->response == T_UNKNOWN)\n    {\n      issue_warning(_(\"you are about to recursively remove\"\n                      \" the contents of %s \"),\n                    quote (found->given_path));\n      fprintf (stderr, _(\"through symbolic link %s; continue? \"),\n               quote (ent->fts_path));\n\n      found->response = yesno () ? T_YES : T_NO;\n    }\n\n  return (found->response == T_YES) ? WARN_OK : WARN_USER_DECLINED;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Return true if FILENAME is a non-directory.\n   Otherwise, including the case in which lstat fails, return false.\n   *ST is FILENAME's tstatus.\n   Do not modify errno.  */\n", "func_signal": "static inline bool\nis_nondir_lstat (int fd_cwd, char const *filename, struct stat *st)", "code": "{\n  int saved_errno = errno;\n  bool is_non_dir =\n    (cache_fstatat (fd_cwd, filename, st, AT_SYMLINK_NOFOLLOW) == 0\n     && !S_ISDIR (st->st_mode));\n  errno = saved_errno;\n  return is_non_dir;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Return true if the current user has permission of type MODE\n   on the file from which stat buffer *ST was obtained, ignoring\n   ACLs, attributes, `read-only'ness, etc...\n   Otherwise, return false.\n\n   Like the reentrant version of euidaccess, but starting with\n   a stat buffer rather than a file name.  Hence, this function\n   never calls access or accessx, and doesn't take into account\n   whether the file has ACLs or other attributes, or resides on\n   a read-only file system.  */\n", "func_signal": "bool\neuidaccess_stat (struct stat const *st, int mode)", "code": "{\n  uid_t euid;\n  unsigned int granted;\n\n  /* Convert the mode to traditional form, clearing any bogus bits.  */\n  if (R_OK == 4 && W_OK == 2 && X_OK == 1 && F_OK == 0)\n    mode &= 7;\n  else\n    mode = ((mode & R_OK ? 4 : 0)\n            + (mode & W_OK ? 2 : 0)\n            + (mode & X_OK ? 1 : 0));\n\n  if (mode == 0)\n    return true;\t\t/* The file exists.  */\n\n  euid = geteuid ();\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute.  */\n  if (euid == 0 && ((mode & X_OK) == 0\n                    || (st->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return true;\n\n  /* Convert the file's permission bits to traditional form.  */\n  if (   S_IRUSR == (4 << 6)\n      && S_IWUSR == (2 << 6)\n      && S_IXUSR == (1 << 6)\n      && S_IRGRP == (4 << 3)\n      && S_IWGRP == (2 << 3)\n      && S_IXGRP == (1 << 3)\n      && S_IROTH == (4 << 0)\n      && S_IWOTH == (2 << 0)\n      && S_IXOTH == (1 << 0))\n    granted = st->st_mode;\n  else\n    granted = (  (st->st_mode & S_IRUSR ? 4 << 6 : 0)\n               + (st->st_mode & S_IWUSR ? 2 << 6 : 0)\n               + (st->st_mode & S_IXUSR ? 1 << 6 : 0)\n               + (st->st_mode & S_IRGRP ? 4 << 3 : 0)\n               + (st->st_mode & S_IWGRP ? 2 << 3 : 0)\n               + (st->st_mode & S_IXGRP ? 1 << 3 : 0)\n               + (st->st_mode & S_IROTH ? 4 << 0 : 0)\n               + (st->st_mode & S_IWOTH ? 2 << 0 : 0)\n               + (st->st_mode & S_IXOTH ? 1 << 0 : 0));\n\n  if (euid == st->st_uid)\n    granted >>= 6;\n  else\n    {\n      gid_t egid = getegid ();\n      if (egid == st->st_gid || group_member (st->st_gid))\n        granted >>= 3;\n    }\n\n  if ((mode & ~granted) == 0)\n    return true;\n\n  return false;\n}", "path": "lib\\euidaccess-stat.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* When fts_read returns FTS_DC to indicate a directory cycle,\n   it may or may not indicate a real problem.  When a program like\n   chgrp performs a recursive traversal that requires traversing\n   symbolic links, it is *not* a problem.  However, when invoked\n   with \"-P -R\", it deserves a warning.  The fts_options member\n   records the options that control this aspect of fts's behavior,\n   so test that.  */\n", "func_signal": "bool\ncycle_warning_required (FTS const *fts, FTSENT const *ent)", "code": "{\n#define ISSET(Fts,Opt) ((Fts)->fts_options & (Opt))\n  /* When dereferencing no symlinks, or when dereferencing only\n     those listed on the command line and we're not processing\n     a command-line argument, then a cycle is a serious problem. */\n  return ((ISSET (fts, FTS_PHYSICAL) && !ISSET (fts, FTS_COMFOLLOW))\n          || (ISSET (fts, FTS_PHYSICAL) && ISSET (fts, FTS_COMFOLLOW)\n              && ent->fts_level != FTS_ROOTLEVEL));\n}", "path": "lib\\xfts.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Return true if FILENAME is a directory (and not a symlink to a directory).\n   Otherwise, including the case in which lstat fails, return false.\n   *ST is FILENAME's tstatus.\n   Do not modify errno.  */\n", "func_signal": "static inline bool\nis_dir_lstat (int fd_cwd, char const *filename, struct stat *st)", "code": "{\n  int saved_errno = errno;\n  bool is_dir =\n    (cache_fstatat (fd_cwd, filename, st, AT_SYMLINK_NOFOLLOW) == 0\n     && S_ISDIR (st->st_mode));\n  errno = saved_errno;\n  return is_dir;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Prompt whether to remove FILENAME (ent->, if required via a combination of\n   the options specified by X and/or file attributes.  If the file may\n   be removed, return RM_OK.  If the user declines to remove the file,\n   return RM_USER_DECLINED.  If not ignoring missing files and we\n   cannot lstat FILENAME, then return RM_ERROR.\n\n   IS_DIR is true if ENT designates a directory, false otherwise.\n\n   Depending on MODE, ask whether to `descend into' or to `remove' the\n   directory FILENAME.  MODE is ignored when FILENAME is not a directory.\n   Set *IS_EMPTY_P to T_YES if FILENAME is an empty directory, and it is\n   appropriate to try to remove it with rmdir (e.g. recursive mode).\n   Don't even try to set *IS_EMPTY_P when MODE == PA_REMOVE_DIR.  */\n", "func_signal": "static enum RM_status\nprompt (FTS const *fts, FTSENT const *ent, bool is_dir,\n        struct rm_options const *x, enum Prompt_action mode,\n        Ternary *is_empty_p)", "code": "{\n  int fd_cwd = fts->fts_cwd_fd;\n  char const *full_name = ent->fts_path;\n  char const *filename = ent->fts_accpath;\n  if (is_empty_p)\n    *is_empty_p = T_UNKNOWN;\n\n  struct stat st;\n  struct stat *sbuf = &st;\n  cache_stat_init (sbuf);\n\n  if (x->warnings_table)\n    {\n      enum warn_status ws = warn (ent, fd_cwd, sbuf, x);\n      if (ws != WARN_NOT_FOUND)\n        return (enum RM_status) ws;\n    }\n\n  int dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;\n  int write_protected = 0;\n\n  /* When nonzero, this indicates that we failed to remove a child entry,\n     either because the user declined an interactive prompt, or due to\n     some other failure, like permissions.  */\n  if (ent->fts_number)\n    return RM_USER_DECLINED;\n\n  if (x->interactive == RMI_NEVER)\n    return RM_OK;\n\n  int wp_errno = 0;\n  if (!x->ignore_missing_files\n      && ((x->interactive == RMI_ALWAYS) || x->stdin_tty)\n      && dirent_type != DT_LNK)\n    {\n      write_protected = write_protected_non_symlink (fd_cwd, filename,\n                                                     full_name, sbuf);\n      wp_errno = errno;\n    }\n\n  if (write_protected || x->interactive == RMI_ALWAYS)\n    {\n      if (0 <= write_protected && dirent_type == DT_UNKNOWN)\n        {\n          if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) == 0)\n            {\n              if (S_ISLNK (sbuf->st_mode))\n                dirent_type = DT_LNK;\n              else if (S_ISDIR (sbuf->st_mode))\n                dirent_type = DT_DIR;\n              /* Otherwise it doesn't matter, so leave it DT_UNKNOWN.  */\n            }\n          else\n            {\n              /* This happens, e.g., with `rm '''.  */\n              write_protected = -1;\n              wp_errno = errno;\n            }\n        }\n\n      if (0 <= write_protected)\n        switch (dirent_type)\n          {\n          case DT_LNK:\n            /* Using permissions doesn't make sense for symlinks.  */\n            if (x->interactive != RMI_ALWAYS)\n              return RM_OK;\n            break;\n\n          case DT_DIR:\n            if (!x->recursive)\n              {\n                write_protected = -1;\n                wp_errno = EISDIR;\n              }\n            break;\n          }\n\n      char const *quoted_name = quote (full_name);\n\n      if (write_protected < 0)\n        {\n          error (0, wp_errno, _(\"cannot remove %s\"), quoted_name);\n          return RM_ERROR;\n        }\n\n      bool is_empty;\n      if (is_empty_p)\n        {\n          is_empty = is_empty_dir (fd_cwd, filename);\n          *is_empty_p = is_empty ? T_YES : T_NO;\n        }\n      else\n        is_empty = false;\n\n      /* Issue the prompt.  */\n      if (dirent_type == DT_DIR\n          && mode == PA_DESCEND_INTO_DIR\n          && !is_empty)\n        fprintf (stderr,\n                 (write_protected\n                  ? _(\"%s: descend into write-protected directory %s? \")\n                  : _(\"%s: descend into directory %s? \")),\n                 program_name, quoted_name);\n      else\n        {\n          if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) != 0)\n            {\n              error (0, errno, _(\"cannot remove %s\"), quoted_name);\n              return RM_ERROR;\n            }\n\n          fprintf (stderr,\n                   (write_protected\n                    /* TRANSLATORS: You may find it more convenient to\n                       translate \"%s: remove %s (write-protected) %s? \"\n                       instead.  It should avoid grammatical problems\n                       with the output of file_type.  */\n                    ? _(\"%s: remove write-protected %s %s? \")\n                    : _(\"%s: remove %s %s? \")),\n                   program_name, file_type (sbuf), quoted_name);\n        }\n\n      if (!yesno ())\n        return RM_USER_DECLINED;\n    }\n  return RM_OK;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Check for ENT->fts_accpath in the warnings table and prompt the user if\n   found.  Return false if the user declines to continue.  Responses are\n   cached so if we see the file again while removing we won't prompt.  */\n", "func_signal": "bool\ncheck_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)", "code": "{\n  switch (ent->fts_info)\n    {\n    case FTS_D:\t\t\t/* preorder directory */\n      if (! x->recursive)\n        {\n          fts_skip_tree (fts, ent);\n          return true;\n        }\n\n      /* Fall through.  */\n\n    case FTS_F:\t\t\t/* regular file */\n    case FTS_NS:\t\t/* stat(2) failed */\n    case FTS_SL:\t\t/* symbolic link */\n    case FTS_SLNONE:\t\t/* symbolic link without target */\n    case FTS_DNR:\t\t/* unreadable directory */\n    case FTS_NSOK:\t\t/* e.g., dangling symlink */\n    case FTS_DEFAULT:\t\t/* none of the above */\n      {\n        struct stat st;\n        cache_stat_init (&st);\n\n        enum warn_status status = warn (ent, fts->fts_cwd_fd, &st, x);\n        return (status == WARN_OK) | (status == WARN_NOT_FOUND);\n      }\n\n    case FTS_DC:\n    case FTS_ERR:\n      fts_skip_tree (fts, ent);\n      return true;\n\n    case FTS_DP:\n      return true;\n    }\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* When a function like unlink, rmdir, or fstatat fails with an errno\n   value of ERRNUM, return true if the specified file system object\n   is guaranteed not to exist;  otherwise, return false.  */\n", "func_signal": "static inline bool\nnonexistent_file_errno (int errnum)", "code": "{\n  /* Do not include ELOOP here, since the specified file may indeed\n     exist, but be (in)accessible only via too long a symlink chain.\n     Likewise for ENAMETOOLONG, since rm -f ./././.../foo may fail\n     if the \"...\" part expands to a long enough sequence of \"./\"s,\n     even though ./foo does indeed exist.  */\n\n  switch (errnum)\n    {\n    case ENOENT:\n    case ENOTDIR:\n      return true;\n    default:\n      return false;\n    }\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Tell fts not to traverse into the hierarchy at ENT.  */\n", "func_signal": "static void\nfts_skip_tree (FTS *fts, FTSENT *ent)", "code": "{\n  fts_set (fts, ent, FTS_SKIP);\n  /* Ensure that we do not process ENT a second time.  */\n  ent = fts_read (fts);\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Check for any FILEs in the warnings table that will be removed and give the\n   user a chance for early exit.  Return true if it is OK to proceed, false if\n   rm should be skipped.  */\n", "func_signal": "bool\ncheck (char *const *file, struct rm_options const *x)", "code": "{\n  bool status = true;\n\n  if (*file)\n    {\n      int bit_flags = (FTS_CWDFD | FTS_NOSTAT | FTS_PHYSICAL);\n\n      if (x->one_file_system)\n        bit_flags |= FTS_XDEV;\n\n      FTS *fts = xfts_open (file, bit_flags, NULL);\n\n      while (1)\n        {\n          FTSENT *ent = fts_read (fts);\n          if (ent == NULL)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"fts_read failed\"));\n                  status = false;\n                }\n              break;\n            }\n\n          if (! check_fts (fts, ent, x))\n            {\n              status = false;\n              break;\n            }\n        }\n\n      if (fts_close (fts) != 0)\n        {\n          error (0, errno, _(\"fts_close failed\"));\n          status = false;\n        }\n    }\n\n  return status;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Advise the user about invalid usages like \"rm -foo\" if the file\n   \"-foo\" exists, assuming ARGC and ARGV are as with `main'.  */\n", "func_signal": "static void\ndiagnose_leading_hyphen (int argc, char **argv)", "code": "{\n  /* OPTIND is unreliable, so iterate through the arguments looking\n     for a file name that looks like an option.  */\n  int i;\n\n  for (i = 1; i < argc; i++)\n    {\n      char const *arg = argv[i];\n      struct stat st;\n\n      if (arg[0] == '-' && arg[1] && lstat (arg, &st) == 0)\n        {\n          fprintf (stderr,\n                   _(\"Try `%s ./%s' to remove the file %s.\\n\"),\n                   argv[0],\n                   quotearg_n_style (1, shell_quoting_style, arg),\n                   quote (arg));\n          break;\n        }\n    }\n}", "path": "src\\rm.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Create a hash table of device and inode number pairs by reading the\n   file list ~/.rmfd/warn.list.  If we can't read that file return\n   NULL.  */\n", "func_signal": "static Hash_table *\ncreate_warnings_table (void)", "code": "{\n  char const *home_dir = getenv (\"HOME\");\n  if (! home_dir)\n    return NULL;\n\n  char *path = xconcatenated_filename (home_dir, \".rmfd/warn.list\", NULL);\n  FILE *fp = fopen (path, \"r\");\n  if (! fp)\n    {\n      free (path);\n      return NULL;\n    }\n\n  Hash_table *table = hash_initialize (41, NULL, warnings_table_hash,\n                                       warnings_table_comparator, NULL);\n  if (! table)\n    xalloc_die ();\n\n  char *line = NULL;\n  size_t length;\n  ssize_t read;\n  while (-1 != (read = getline (&line, &length, fp)))\n    {\n      if (line[read - 1] == '\\n')\n        line[--read] = '\\0';\n      if (line[0] != '/')\n        error (1, 0, \"warn.list: %s: must be an absolute path\", quote (line));\n\n      struct stat st;\n\n      if (0 == lstat (line, &st))\n        add_warnings_entry (table, &st, line, read);\n\n      if (S_ISLNK (st.st_mode) && 0 == stat (line, &st))\n        add_warnings_entry (table, &st, line, read);\n    }\n\n  free (line);\n  fclose (fp);\n  free (path);\n\n  return table;\n}", "path": "src\\rm.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* This function is called once for every file system object that fts\n   encounters.  fts performs a depth-first traversal.\n   A directory is usually processed twice, first with fts_info == FTS_D,\n   and later, after all of its entries have been processed, with FTS_DP.\n   Return RM_ERROR upon error, RM_USER_DECLINED for a negative response\n   to an interactive prompt, and otherwise, RM_OK.  */\n", "func_signal": "static enum RM_status\nrm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)", "code": "{\n  switch (ent->fts_info)\n    {\n    case FTS_D:\t\t\t/* preorder directory */\n      if (! x->recursive)\n        {\n          /* This is the first (pre-order) encounter with a directory.\n             Not recursive, so arrange to skip contents.  */\n          error (0, EISDIR, _(\"cannot remove %s\"), quote (ent->fts_path));\n          mark_ancestor_dirs (ent);\n          fts_skip_tree (fts, ent);\n          return RM_ERROR;\n        }\n\n      /* Perform checks that can apply only for command-line arguments.  */\n      if (ent->fts_level == FTS_ROOTLEVEL)\n        {\n          if (strip_trailing_slashes (ent->fts_path))\n            ent->fts_pathlen = strlen (ent->fts_path);\n\n          /* If the basename of a command line argument is \".\" or \"..\",\n             diagnose it and do nothing more with that argument.  */\n          if (dot_or_dotdot (last_component (ent->fts_accpath)))\n            {\n              error (0, 0, _(\"cannot remove directory: %s\"),\n                     quote (ent->fts_path));\n              fts_skip_tree (fts, ent);\n              return RM_ERROR;\n            }\n\n          /* If a command line argument resolves to \"/\" (and --preserve-root\n             is in effect -- default) diagnose and skip it.  */\n          if (ROOT_DEV_INO_CHECK (x->root_dev_ino, ent->fts_statp))\n            {\n              ROOT_DEV_INO_WARN (ent->fts_path);\n              fts_skip_tree (fts, ent);\n              return RM_ERROR;\n            }\n        }\n\n      {\n        Ternary is_empty_directory;\n        enum RM_status s = prompt (fts, ent, true /*is_dir*/, x,\n                                   PA_DESCEND_INTO_DIR, &is_empty_directory);\n\n        if (s == RM_OK && is_empty_directory == T_YES)\n          {\n            /* When we know (from prompt when in interactive mode)\n               that this is an empty directory, don't prompt twice.  */\n            s = excise (fts, ent, x, true);\n            fts_skip_tree (fts, ent);\n          }\n\n        if (s != RM_OK)\n          {\n            mark_ancestor_dirs (ent);\n            fts_skip_tree (fts, ent);\n          }\n\n        return s;\n      }\n\n    case FTS_F:\t\t\t/* regular file */\n    case FTS_NS:\t\t/* stat(2) failed */\n    case FTS_SL:\t\t/* symbolic link */\n    case FTS_SLNONE:\t\t/* symbolic link without target */\n    case FTS_DP:\t\t/* postorder directory */\n    case FTS_DNR:\t\t/* unreadable directory */\n    case FTS_NSOK:\t\t/* e.g., dangling symlink */\n    case FTS_DEFAULT:\t\t/* none of the above */\n      {\n        /* With --one-file-system, do not attempt to remove a mount point.\n           fts' FTS_XDEV ensures that we don't process any entries under\n           the mount point.  */\n        if (ent->fts_info == FTS_DP\n            && x->one_file_system\n            && FTS_ROOTLEVEL < ent->fts_level\n            && ent->fts_statp->st_dev != fts->fts_dev)\n          {\n            mark_ancestor_dirs (ent);\n            error (0, 0, _(\"skipping %s, since it's on a different device\"),\n                   quote (ent->fts_path));\n            return RM_ERROR;\n          }\n\n        bool is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;\n        enum RM_status s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR, NULL);\n        if (s != RM_OK)\n          return s;\n        return excise (fts, ent, x, is_dir);\n      }\n\n    case FTS_DC:\t\t/* directory that causes cycles */\n      emit_cycle_warning (ent->fts_path);\n      fts_skip_tree (fts, ent);\n      return RM_ERROR;\n\n    case FTS_ERR:\n      /* Various failures, from opendir to ENOMEM, to failure to \"return\"\n         to preceding directory, can provoke this.  */\n      error (0, ent->fts_errno, _(\"traversal failed: %s\"),\n             quote (ent->fts_path));\n      fts_skip_tree (fts, ent);\n      return RM_ERROR;\n\n    default:\n      error (0, 0, _(\"unexpected failure: fts_info=%d: %s\\n\"\n                     \"please report to %s\"),\n             ent->fts_info,\n             quote (ent->fts_path),\n             PACKAGE_BUGREPORT);\n      abort ();\n    }\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/* Initialize a fstatat cache *ST.  Return ST for convenience.  */\n", "func_signal": "static inline struct stat *\ncache_stat_init (struct stat *st)", "code": "{\n  st->st_size = -1;\n  return st;\n}", "path": "src\\remove.c", "repo_name": "d5h/rmfd", "stars": 7, "license": "gpl-3.0", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ncclearxy(unsigned char x, unsigned char y, unsigned char length)", "code": "{\n  gotoxy(x, y);\n  cclear(length);\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nconsole_init(void)", "code": "{\n  CONSOLE_SCREEN_BUFFER_INFO consoleinfo;\n  CONSOLE_CURSOR_INFO cursorinfo = {1, FALSE};\n  static unsigned char done;\n\n  if(done) {\n    return;\n  }\n  done = 1;\n\n  stdinhandle  = GetStdHandle(STD_INPUT_HANDLE);\n  stdouthandle = GetStdHandle(STD_OUTPUT_HANDLE);\n\n  GetConsoleMode(stdinhandle, &saved_inputmode);\n  SetConsoleMode(stdinhandle, ENABLE_MOUSE_INPUT | ENABLE_PROCESSED_INPUT);\n\n  GetConsoleMode(stdouthandle, &saved_outputmode);\n  SetConsoleMode(stdouthandle, ENABLE_PROCESSED_OUTPUT);\n\n  screensize(&width, &height);\n\n  GetConsoleScreenBufferInfo(stdouthandle, &consoleinfo);\n  saved_color = (unsigned char)consoleinfo.wAttributes;\n\n  GetConsoleTitle(saved_title, sizeof(saved_title));\n  SetConsoleTitle(\"Contiki\");\n\n  GetConsoleCursorInfo(stdouthandle, &saved_cursorinfo);\n  SetConsoleCursorInfo(stdouthandle, &cursorinfo);\n\n  SetConsoleCtrlHandler(ctrlhandler, TRUE);\n  atexit(console_exit);\n\n  memset(blank, ' ',  sizeof(blank));\n  memset(hline, 0xC4, sizeof(hline));\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nsetcolor(void)", "code": "{\n  SetConsoleTextAttribute(stdouthandle, (WORD)(reversed? (color & 0x0F) << 4 |\n\t\t\t\t\t\t\t (color & 0xF0) >> 4\n\t\t\t\t\t\t       : color));\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nconsole_readmouse(MOUSE_EVENT_RECORD mouserecord)", "code": "{\n  xpos = mouserecord.dwMousePosition.X;\n  ypos = mouserecord.dwMousePosition.Y;\n\n  button = (unsigned char)mouserecord.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED;\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "unsigned char\nconsole_resize(void)", "code": "{\n  unsigned char new_width;\n  unsigned char new_height;\n\n  screensize(&new_width, &new_height);\n\n  if(new_width  != width ||\n     new_height != height) {\n    width  = new_width;\n    height = new_height;\n    return 1;\n  }\n\n  return 0;\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/**\n    @brief This will enable the VCP_TRX_END LED for a period\n*/\n", "func_signal": "void vcptx_end_led(void)", "code": "{\n    Led3_on();\n    led3_timer = 10;\n}", "path": "third_party\\contiki-2.4\\cpu\\avr\\dev\\usb\\serial\\cdc_task.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntextcolor(unsigned char c)", "code": "{\n  color = c;\n  setcolor();\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nchlinexy(unsigned char x, unsigned char y, unsigned char length)", "code": "{\n  gotoxy(x, y);\n  chline(length);\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*---------------------------------------------------------------------------*/\n/**\n * RF error interrupt service routine.\n *\n */\n", "func_signal": "void\ncc2430_rf_error_ISR( void ) __interrupt (RFERR_VECTOR)", "code": "{\n  EA = 0;\n  TCON_RFERRIF = 0;\n#ifdef HAVE_RF_ERROR\n  rf_error = 254;\n#endif\n  cc2430_rf_command(ISRFOFF);\n  cc2430_rf_command(ISFLUSHRX);\n  cc2430_rf_command(ISFLUSHRX);\n  cc2430_rf_command(ISRXON);\n  RF_RX_LED_OFF();\n  RF_TX_LED_OFF();\n  EA = 1;\n}", "path": "third_party\\contiki-2.4\\cpu\\cc2430\\dev\\cc2430_rf_intr.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nconsole_cputc(char c)", "code": "{\n  DWORD dummy;\n\n  WriteConsole(stdouthandle, &c, 1, &dummy, NULL);\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL\nJava_se_sics_cooja_corecomm_[CLASS_NAME]_setMemory(JNIEnv *env, jobject obj, jint rel_addr, jint length, jbyteArray mem_arr)", "code": "{\n  jbyte *mem = (*env)->GetByteArrayElements(env, mem_arr, 0);\n  memcpy(\n      (char*) (((long)rel_addr) + ref_var),\n      mem,\n      length);\n  (*env)->ReleaseByteArrayElements(env, mem_arr, mem, 0);\n}", "path": "third_party\\contiki-2.4\\tools\\cooja\\config\\test_template.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nclrscr(void)", "code": "{\n  unsigned char i, width, height;\n\n  screensize(&width, &height);\n  for(i = 0; i < height; ++i) {\n    cclearxy(0, i, width);\n  }\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "char\nctk_arch_getkey(void)", "code": "{\n  console_read();\n  return keys[--available];\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ncvlinexy(unsigned char x, unsigned char y, unsigned char length)", "code": "{\n  gotoxy(x, y);\n  cvline(length);\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\ndelay(void)", "code": "{\n  unsigned char i;\n  for(i = 0; i < 1; ++i) {\n    Delay_10ms(1);\n  }\n}", "path": "third_party\\contiki-2.4\\cpu\\avr\\dev\\debug.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ngotoxy(unsigned char x, unsigned char y)", "code": "{\n  COORD coord = {x, y};\n\n  SetConsoleCursorPosition(stdouthandle, coord);\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*---------------------------------------------------------------------------*/\n/* Write one byte over the UART. */\n", "func_signal": "void\nuart0_writeb(uint8_t byte)", "code": "{\n  IRCON2_UTX0IF = 0;\n  U0BUF = byte;\n  while(!IRCON2_UTX0IF); /* Wait until byte has been transmitted. */\n  IRCON2_UTX0IF = 0;\n}", "path": "third_party\\contiki-2.4\\cpu\\cc2430\\dev\\uart.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "unsigned char\nwherey(void)", "code": "{\n  CONSOLE_SCREEN_BUFFER_INFO consoleinfo;\n\n  GetConsoleScreenBufferInfo(stdouthandle, &consoleinfo);\n  return (unsigned char)consoleinfo.dwCursorPosition.Y;\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "unsigned char\nwherex(void)", "code": "{\n  CONSOLE_SCREEN_BUFFER_INFO consoleinfo;\n\n  GetConsoleScreenBufferInfo(stdouthandle, &consoleinfo);\n  return (unsigned char)consoleinfo.dwCursorPosition.X;\n}", "path": "third_party\\contiki-2.4\\platform\\win32\\ctk\\ctk-console.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/**\n \\brief Print debug menu\n */\n", "func_signal": "void menu_print(void)", "code": "{\n\t\tPRINTF_P(PSTR(\"\\n\\n\\r********** Jackdaw Menu ******************\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*                                        *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"* Main Menu:                             *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  h,?             Print this menu       *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  m               Print current mode    *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  s               Set to sniffer mode   *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  n               Set to network mode   *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  c               Set RF channel        *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  6               Toggle 6lowpan        *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  r               Toggle raw mode       *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*  u               Switch to mass-storage*\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"*                                        *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"* Make selection at any time by pressing *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"* your choice on keyboard.               *\\n\\r\"));\n\t\tPRINTF_P(PSTR(\"******************************************\\n\\r\"));\n}", "path": "third_party\\contiki-2.4\\cpu\\avr\\dev\\usb\\serial\\cdc_task.c", "repo_name": "jkamp/Build-an-indoor-sensor-network", "stars": 5, "license": "None", "language": "c", "size": 21512}
{"docstring": "/* Menu-bar callback functions */\n", "func_signal": "void _toggle_terminal(GtkCheckMenuItem *checkmenuitem,\n  gpointer user_data)", "code": "{\n   if (checkmenuitem->active)\n       display_ascii = TRUE;\n   else\n       display_ascii = FALSE;\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_print_operation_preview_is_selected:\n * @preview: a #GtkPrintOperationPreview\n * @page_nr: a page number\n *\n * Returns whether the given page is included in the set of pages that\n * have been selected for printing.\n * \n * Returns: %TRUE if the page has been selected for printing\n *\n * Since: 2.10\n */\n", "func_signal": "gboolean\ngtk_print_operation_preview_is_selected (GtkPrintOperationPreview *preview,\n\t\t\t\t\t gint                      page_nr)", "code": "{\n  g_return_val_if_fail (GTK_IS_PRINT_OPERATION_PREVIEW (preview), FALSE);\n\n  return GTK_PRINT_OPERATION_PREVIEW_GET_IFACE (preview)->is_selected (preview, page_nr);\n}", "path": "gtk\\gtkprintoperationpreview.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_table_get_default_col_spacing:\n * @table: a #GtkTable\n *\n * Gets the default column spacing for the table. This is\n * the spacing that will be used for newly added columns.\n * (See gtk_table_set_col_spacings())\n *\n * Return value: the default column spacing\n **/\n", "func_signal": "guint\ngtk_table_get_default_col_spacing (GtkTable *table)", "code": "{\n  g_return_val_if_fail (GTK_IS_TABLE (table), 0);\n\n  return table->column_spacing;\n}", "path": "gtk\\gtktable.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Object signals */\n", "func_signal": "static void\n_notify_object_child_added (GObject *obj, gint index,\n  AtkObject *child)", "code": "{\n    gchar *output_str = g_strdup_printf(\"index %d\", index);\n    _print_signal(ATK_OBJECT(obj), FERRET_SIGNAL_OBJECT,\n      \"Child Added\", output_str);\n    g_free(output_str);\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_print_operation_preview_end_preview:\n * @preview: a #GtkPrintOperationPreview\n *\n * Ends a preview. \n *\n * This function must be called to finish a custom print preview.\n *\n * Since: 2.10\n */\n", "func_signal": "void\ngtk_print_operation_preview_end_preview (GtkPrintOperationPreview *preview)", "code": "{\n  g_return_if_fail (GTK_IS_PRINT_OPERATION_PREVIEW (preview));\n\n  GTK_PRINT_OPERATION_PREVIEW_GET_IFACE (preview)->end_preview (preview);\n}", "path": "gtk\\gtkprintoperationpreview.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gdk_display_list_devices:\n * @display: a #GdkDisplay\n *\n * Returns the list of available input devices attached to @display.\n * The list is statically allocated and should not be freed.\n * \n * Return value: a list of #GdkDevice\n *\n * Since: 2.2\n **/\n", "func_signal": "GList * \ngdk_display_list_devices (GdkDisplay *display)", "code": "{\n  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);\n  \n  return GDK_DISPLAY_X11 (display)->input_devices;\n}", "path": "gdk\\x11\\gdkinput.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Action button callback function */\n", "func_signal": "void _action_cb(GtkWidget *widget, gpointer  *userdata)", "code": "{\n   NameValue *nv = (NameValue *)userdata;\n   atk_action_do_action(ATK_ACTION(nv->atkobj), nv->action_num);\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_table_get_default_row_spacing:\n * @table: a #GtkTable\n *\n * Gets the default row spacing for the table. This is\n * the spacing that will be used for newly added rows.\n * (See gtk_table_set_row_spacings())\n *\n * Return value: the default row spacing\n **/\n", "func_signal": "guint\ngtk_table_get_default_row_spacing (GtkTable *table)", "code": "{\n  g_return_val_if_fail (GTK_IS_TABLE (table), 0);\n\n  return table->row_spacing;\n}", "path": "gtk\\gtktable.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Destination side */\n", "func_signal": "void\ngdk_drag_status (GdkDragContext   *context,\n\t\t GdkDragAction     action,\n\t\t guint32           time)", "code": "{\n  GdkDragContextPrivate *private;\n  GdkDragContext        *src_context;\n  GdkEvent event;\n\n  g_return_if_fail (context != NULL);\n\n  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);\n\n  src_context = gdk_drag_context_find (TRUE,\n\t\t\t\t       context->source_window,\n\t\t\t\t       context->dest_window);\n\n  if (src_context)\n    {\n      GdkDragContextPrivate *private;\n\n      private = GDK_DRAG_CONTEXT_PRIVATE_DATA (src_context);\n\n      if (private->drag_status == GDK_DRAG_STATUS_MOTION_WAIT)\n\tprivate->drag_status = GDK_DRAG_STATUS_DRAG;\n\n      event.dnd.type       = GDK_DRAG_STATUS;\n      event.dnd.window     = src_context->source_window;\n      event.dnd.send_event = FALSE;\n      event.dnd.context    = src_context;\n      event.dnd.time       = time;\n\n      src_context->action = action;\n\n      gdk_event_put (&event);\n    }\n}", "path": "gdk\\directfb\\gdkdnd-directfb.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_table_get_col_spacing:\n * @table: a #GtkTable\n * @column: a column in the table, 0 indicates the first column\n *\n * Gets the amount of space between column @col, and\n * column @col + 1. See gtk_table_set_col_spacing().\n *\n * Return value: the column spacing\n **/\n", "func_signal": "guint\ngtk_table_get_col_spacing (GtkTable *table,\n\t\t\t   guint     column)", "code": "{\n  g_return_val_if_fail (GTK_IS_TABLE (table), 0);\n  g_return_val_if_fail (column < table->ncols, 0);\n\n  return table->cols[column].spacing;\n}", "path": "gtk\\gtktable.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Update functions */\n", "func_signal": "static void\n_update (TabNumber top_tab, AtkObject *aobject)", "code": "{\n    gint group_num;\n\n    if (top_tab >= OBJECT && top_tab < END_TABS)\n    {\n       _clear_tab(top_tab);\n    }\n\n    if (top_tab == OBJECT && ATK_IS_OBJECT(aobject))\n      {\n        group_num = _print_object(aobject);\n        _finished_group(OBJECT, group_num);\n        group_num = _print_relation(aobject);\n        _finished_group(OBJECT, group_num);\n        group_num = _print_state(aobject);\n        _finished_group(OBJECT, group_num);\n      }\n    if (top_tab == TEXT && ATK_IS_TEXT(aobject))\n      {\n        group_num = _print_text(ATK_TEXT (aobject));\n        _finished_group(TEXT, group_num);\n        group_num = _print_text_attributes(ATK_TEXT (aobject));\n        _finished_group(TEXT, group_num);\n      }\n    if (top_tab == SELECTION && ATK_IS_SELECTION(aobject))\n      {\n        group_num = _print_selection(ATK_SELECTION (aobject));\n        _finished_group(SELECTION, group_num);\n      }\n    if (top_tab == TABLE && ATK_IS_TABLE(aobject))\n      {\n        group_num = _print_table(ATK_TABLE (aobject));\n        _finished_group(TABLE, group_num);\n      }\n    if (top_tab == ACTION && ATK_IS_ACTION(aobject))\n      {\n        group_num = _print_action(ATK_ACTION (aobject));\n        _finished_group(ACTION, group_num);\n      }\n    if (top_tab == COMPONENT && ATK_IS_COMPONENT(aobject))\n      {\n        group_num = _print_component(ATK_COMPONENT(aobject));\n        _finished_group(COMPONENT, group_num);\n      }\n    if (top_tab == IMAGE && ATK_IS_IMAGE(aobject))\n      {\n        group_num = _print_image(ATK_IMAGE (aobject));\n        _finished_group(IMAGE, group_num);\n      }\n    if (top_tab == VALUE && ATK_IS_VALUE(aobject))\n      {\n        group_num = _print_value(ATK_VALUE(aobject));\n        _finished_group(VALUE, group_num);\n      }\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* --- test functions --- */\n", "func_signal": "static void\ntest_button_clicks (void)", "code": "{\n  int a = 0, b = 0, c = 0;\n  GtkWidget *window = gtk_test_display_button_window (\"Test Window\",\n                                                      \"Test: gtk_test_widget_click\",\n                                                      \"IgnoreMe1\", &a,\n                                                      \"ClickMe\", &b,\n                                                      \"IgnoreMe2\", &c,\n                                                      NULL);\n  GtkWidget *button = gtk_test_find_widget (window, \"*Click*\", GTK_TYPE_BUTTON);\n  gboolean simsuccess;\n  g_assert (button != NULL);\n  simsuccess = gtk_test_widget_click (button, 1, 0);\n  g_assert (simsuccess == TRUE);\n  while (gtk_events_pending ())\n    gtk_main_iteration ();\n  g_assert (a == 0 && b > 0 && c == 0);\n}", "path": "gtk\\tests\\testing.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gdk_device_get_axis:\n * @device: a #GdkDevice\n * @axes: pointer to an array of axes\n * @use: the use to look for\n * @value: location to store the found value.\n * \n * Interprets an array of double as axis values for a given device,\n * and locates the value in the array for a given axis use.\n * \n * Return value: %TRUE if the given axis use was found, otherwise %FALSE\n **/\n", "func_signal": "gboolean\ngdk_device_get_axis (GdkDevice  *device,\n\t\t     gdouble    *axes,\n\t\t     GdkAxisUse  use,\n\t\t     gdouble    *value)", "code": "{\n  gint i;\n  \n  g_return_val_if_fail (device != NULL, FALSE);\n\n  if (axes == NULL)\n    return FALSE;\n  \n  for (i=0; i<device->num_axes; i++)\n    if (device->axes[i].use == use)\n      {\n\tif (value)\n\t  *value = axes[i];\n\treturn TRUE;\n      }\n  \n  return FALSE;\n}", "path": "gdk\\x11\\gdkinput.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Table signals */\n", "func_signal": "static void\n_notify_table_row_inserted (GObject *obj, gint start_offset,\n  gint length)", "code": "{\n    gchar *output_str =\n      g_strdup_printf(\"position %d, num of rows inserted %d!\\n\",\n      start_offset, length);\n    _print_signal(ATK_OBJECT(obj), FERRET_SIGNAL_TABLE,\n      \"Table Row Inserted\", output_str);\n    g_free(output_str);\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_print_operation_preview_render_page:\n * @preview: a #GtkPrintOperationPreview\n * @page_nr: the page to render\n *\n * Renders a page to the preview, using the print context that\n * was passed to the #GtkPrintOperation::preview handler together\n * with @preview.\n *\n * A custom iprint preview should use this function in its ::expose\n * handler to render the currently selected page.\n * \n * Note that this function requires a suitable cairo context to \n * be associated with the print context. \n *\n * Since: 2.10 \n */\n", "func_signal": "void    \ngtk_print_operation_preview_render_page (GtkPrintOperationPreview *preview,\n\t\t\t\t\t gint\t\t\t   page_nr)", "code": "{\n  g_return_if_fail (GTK_IS_PRINT_OPERATION_PREVIEW (preview));\n\n  GTK_PRINT_OPERATION_PREVIEW_GET_IFACE (preview)->render_page (preview,\n\t\t\t\t\t\t\t\tpage_nr);\n}", "path": "gtk\\gtkprintoperationpreview.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Property listeners */\n", "func_signal": "static void _property_change_handler (AtkObject *obj,\n  AtkPropertyValues *values)", "code": "{\n    TabNumber top_tab = gtk_notebook_get_current_page (notebook) + OBJECT;\n\n    if (no_signals)\n      return;\n\n   /*\n    * Only process if the property change corrisponds to the current\n    * object\n    */\n    if (obj != last_object)\n      {\n        if (display_ascii)\n          {\n            g_print(\"\\nProperty change event <%s> for object not in focus\\n\",\n                values->property_name);\n          }\n\n        return;\n      }\n\n    if (display_ascii)\n      {\n        g_print(\"\\nProperty change event <%s> occurred.\\n\",\n          values->property_name);\n      }\n\n   /*\n    * Update the top tab if a property changes.\n    *\n    * We may be able to ignore some property changes if they do not\n    * change anything in ferret.\n    */\n\n    if (top_tab == OBJECT &&\n       ((strcmp (values->property_name, \"accessible-name\") == 0) ||\n        (strcmp (values->property_name, \"accessible-description\") == 0) ||\n        (strcmp (values->property_name, \"accessible-parent\") == 0) ||\n        (strcmp (values->property_name, \"accessible-value\") == 0) ||\n        (strcmp (values->property_name, \"accessible-role\") == 0) ||\n        (strcmp (values->property_name, \"accessible-component-layout\") == 0) ||\n        (strcmp (values->property_name, \"accessible-component-mdi-zorder\") == 0) ||\n        (strcmp (values->property_name, \"accessible-table-caption\") == 0) ||\n        (strcmp (values->property_name,\n                 \"accessible-table-column-description\") == 0) ||\n        (strcmp (values->property_name,\n                 \"accessible-table-column-header\") == 0) ||\n        (strcmp (values->property_name,\n                 \"accessible-table-row-description\") == 0) ||\n        (strcmp (values->property_name,\n                 \"accessible-table-row-header\") == 0) ||\n        (strcmp (values->property_name, \"accessible-table-summary\") == 0)))\n      {\n        if (display_ascii)\n            g_print(\"Updating tab\\n\");\n\n        _update(top_tab, last_object);\n      }\n    else if (top_tab == VALUE &&\n        (strcmp (values->property_name, \"accessible-value\") == 0))\n      {\n        if (display_ascii)\n            g_print(\"Updating tab\\n\");\n\n        _update(top_tab, last_object);\n      }\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_printer_cups_new:\n *\n * Creates a new #GtkPrinterCups.\n *\n * Return value: a new #GtkPrinterCups\n *\n * Since: 2.10\n **/\n", "func_signal": "GtkPrinterCups *\ngtk_printer_cups_new (const char      *name,\n\t\t      GtkPrintBackend *backend)", "code": "{\n  GObject *result;\n  \n  result = g_object_new (GTK_TYPE_PRINTER_CUPS,\n\t\t\t \"name\", name,\n\t\t\t \"backend\", backend,\n\t\t\t \"is-virtual\", FALSE,\n                         NULL);\n\n  return (GtkPrinterCups *) result;\n}", "path": "modules\\printbackends\\cups\\gtkprintercups.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Source side */\n", "func_signal": "static void\nlocal_send_leave (GdkDragContext  *context,\n\t\t  guint32          time)", "code": "{\n  GdkEvent event;\n\n  if ((current_dest_drag != NULL) &&\n      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&\n      (current_dest_drag->source_window == context->source_window))\n    {\n      event.dnd.type       = GDK_DRAG_LEAVE;\n      event.dnd.window     = context->dest_window;\n      /* Pass ownership of context to the event */\n      event.dnd.context    = current_dest_drag;\n      event.dnd.send_event = FALSE;\n      event.dnd.time       = time;\n\n      current_dest_drag = NULL;\n\n      gdk_event_put (&event);\n    }\n}", "path": "gdk\\directfb\\gdkdnd-directfb.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/**\n * gtk_table_get_homogeneous:\n * @table: a #GtkTable\n *\n * Returns whether the table cells are all constrained to the same\n * width and height. (See gtk_table_set_homogenous ())\n *\n * Return value: %TRUE if the cells are all constrained to the same size\n **/\n", "func_signal": "gboolean\ngtk_table_get_homogeneous (GtkTable *table)", "code": "{\n  g_return_val_if_fail (GTK_IS_TABLE (table), FALSE);\n\n  return table->homogeneous;\n}", "path": "gtk\\gtktable.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/* Function to print signals */\n", "func_signal": "static void\n_print_signal(AtkObject *aobject, FerretSignalType type,\n  const char *name, const char *info)", "code": "{\n    TabNumber top_tab = gtk_notebook_get_current_page (notebook) + OBJECT;\n\n    if (no_signals)\n      return;\n\n    if (display_ascii)\n      {\n        if (info != NULL)\n            g_print(\"SIGNAL:\\t%-34s\\t%s\\n\", name, info);\n        else\n            g_print(\"SIGNAL:\\t%-34s\\n\", name);\n      }\n\n    if (use_festival)\n      {\n        if ((type == FERRET_SIGNAL_TEXT) && (!strncmp(name, \"Text Caret\", 10)))\n          {\n            _speak_caret_event (aobject);\n         }\n        else if (type == FERRET_SIGNAL_TEXT)\n          {\n            last_caret_offset = atk_text_get_caret_offset (ATK_TEXT (aobject));\n          }\n      }\n\n    if (use_magnifier && ATK_IS_TEXT (aobject) &&\n        (type == FERRET_SIGNAL_TEXT) && (!strncmp(name, \"Text Caret\", 10)))\n      {\n        gint x, y, w, h;\n        gint caret_offset = atk_text_get_caret_offset (ATK_TEXT (aobject));\n        atk_text_get_character_extents ( ATK_TEXT (aobject), caret_offset, &x, &y, &w, &h, ATK_XY_SCREEN);\n        _send_to_magnifier (x, y, w, h);\n      }\n\n    if ((type == FERRET_SIGNAL_TEXT && top_tab == TEXT) ||\n        (type == FERRET_SIGNAL_TABLE && top_tab == TABLE) ||\n        (type == FERRET_SIGNAL_OBJECT && top_tab == OBJECT))\n      {\n        if (display_ascii)\n            g_print(\"Updating tab\\n\");\n\n        _update(top_tab, aobject);\n      }\n}", "path": "modules\\other\\gail\\tests\\ferret.c", "repo_name": "garnacho/gtk-roles-and-siblings", "stars": 6, "license": "other", "language": "c", "size": 73595}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_AddRef(thisInstance)\n *\n * Purpose:  Implementation of reference counting for this type. Whenever an interface\n *           is requested, bump the refCount for the instance. NOTE: returning the\n *           refcount is a convention but is not required so don't rely on it.\n *\n * Inputs:   thisInstance - pointer to the instance of the plugin\n *\n * Returns:  ULONG - the reference count of the instance of the plugin\n */\n", "func_signal": "static ULONG DimensionizerCMPlugIn_AddRef(void *thisInstance)", "code": "{\n    \n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_AddRef(%p)\\n\",  thisInstance);\n    fflush(stdout);\n#endif\n    \n    ((DimensionizerCMPlugIn_ptr)thisInstance)->refCount += 1;\n    return ((DimensionizerCMPlugIn_ptr)thisInstance)->refCount;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_QueryInterface(thisInstance, iid, ppv)\n *\n * Purpose:  Implementation of the IUnknown QueryInterface function.\n *\n * Inputs:   thisInstance - pointer to the instance of the plugin\n *           iid - REFIID of the interface id being requested\n *           ppv - LPVOID pointer to pass back the instance of the plugin if the iid matches the UUID of our CM plugin.\n *\n * Returns:  HRESULT - the resonse code result of the query\n */\n", "func_signal": "static HRESULT DimensionizerCMPlugIn_QueryInterface(void *thisInstance, REFIID iid, LPVOID *ppv)", "code": "{\n    \n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_QueryInterface(%p, %p, %p)\\n\", thisInstance, &iid, ppv);\n    fflush(stdout);\n#endif\n\t\n    HRESULT result = S_OK;  // assume success\n    \n    // Create a CoreFoundation UUIDRef for the requested interface.\n    CFUUIDRef interfaceID = CFUUIDCreateFromUUIDBytes(NULL, iid);\n\t\n    // Test the requested ID against the valid interfaces.\n    if (CFEqual(interfaceID, kContextualMenuInterfaceID)) {\n        // If our interface was requested, bump the ref count, set the ppv parameter equal to the \n        // instance, and return good status.\n        DimensionizerCMPlugIn_AddRef(thisInstance);\n\t\t\n        *ppv = thisInstance;\n        CFRelease(interfaceID);\n    } else if (CFEqual(interfaceID, IUnknownUUID)) {\n        // If the IUnknown interface was requested, same as above.\n        DimensionizerCMPlugIn_AddRef(thisInstance);\n\t\t\n        *ppv = thisInstance;\n        CFRelease(interfaceID);\n    } else {\n        // Requested interface unknown, bail with result.\n        *ppv = NULL;\n        CFRelease(interfaceID);\n        result = E_NOINTERFACE;\n    }\n    return result;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/* AddStringToPasteboard */\n", "func_signal": "static int OutputFormatPreferenceForKey(const CFStringRef key)", "code": "{\n    int outputType = -1;\n    \n\tLogString(LogLevelDebug, CFSTR(\"OutputFormatPreferenceForKey: Reading output type preference for key: %@ and output type: %d.\\n\"), key, outputType);\n\t\n\t// Force preferences synchronization to make sure we have the latest preference values.\n\tCFPreferencesAppSynchronize(kDimensionizerCMPBundleIdentifier);\n\t\n    // Look for the preference.\n    CFPropertyListRef outputTypePref = CFPreferencesCopyAppValue(key, kDimensionizerCMPBundleIdentifier);\n\t\n    // If the preference exists,  read it.\n    if (outputTypePref) {\n        if (CFGetTypeID(outputTypePref) == CFNumberGetTypeID()) {\n            LogString(LogLevelDebug, CFSTR(\"OutputFormatPreferenceForKey: Output type preference for key: %@ is: %d.\\n\"), key, outputType);\n            \n            if (!CFNumberGetValue(outputTypePref, kCFNumberIntType, &outputType)) {\n                outputType = -1;\n            }\n            \n            CFRelease(outputTypePref);\n        }\n    } else {\n        LogString(LogLevelInfo, CFSTR(\"OutputFormatPreferenceForKey: Could not get output type preference for key: %@.\\n\"), key);\n    }\n    \n    \n    return outputType;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  AddStringToPasteboard(pasteboard, theString)\n *\n * Purpose:  Places the input string onto the pasteboard.\n *\n * Inputs:   pasteboard - PasteboardRef of the pasteboard on which we will place theString\n *           theString - CFStringRef to the string which will be placed on the pasteboard\n *\n * Returns:  OSStatus - the error code\n */\n", "func_signal": "static OSStatus AddStringToPasteboard(PasteboardRef pasteboard, CFStringRef theString)", "code": "{\n\tOSStatus err = noErr;\n\tPasteboardSyncFlags syncFlags;\n\tCFDataRef textData = NULL;\n    \n    LogString(LogLevelDebug, CFSTR(\"AddStringToPasteboard input string: %@\"), theString);\n    if (!theString) {\n        LogString(LogLevelWarn, CFSTR(\"AddStringToPasteboard input string is null.  Cannot add to pasteboard.\"));\n        return 1;\n    }\n\t\n\terr = PasteboardClear(pasteboard);\n\trequire_noerr(err, CantClearPasteboard);\n    \n\tsyncFlags = PasteboardSynchronize(pasteboard);\n\trequire_action(!(syncFlags&kPasteboardModified), PasteboardNotSynchedAfterClear, err = badPasteboardSyncErr);\n\trequire_action((syncFlags&kPasteboardClientIsOwner), ClientNotPasteboardOwner, err = notPasteboardOwnerErr);\n    \n    textData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, kCFStringEncodingUTF16, 0);\n\trequire_action(textData != NULL, CantCreateTextData, err = memFullErr);\n    \n    LogString(LogLevelVerbose, CFSTR(\"Putting data on pasteboard.\\n\"));\n    \n\terr = PasteboardPutItemFlavor(pasteboard, (PasteboardItemID)1, CFSTR(\"public.utf16-plain-text\"), textData, 0);\n\trequire_noerr(err, CantPutTextData);\n    \nCantPutTextData:\nCantCreateTextData:\nCantGetDataFromTextObject:\nCantSetPromiseKeeper:\nClientNotPasteboardOwner:\nPasteboardNotSynchedAfterClear:\nCantClearPasteboard:\n    \n    if (textData) CFRelease(textData);\n    \n\treturn err;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  CreateStringFromImageInfoDictWithOutputFormat(imageInfoDict, format)\n *\n * Purpose:  Creates a CFStringRef in the desired format from the imageInfoDict.\n *\n * Inputs:   imageInfoDict - CFDictionaryRef containing information about an image\n *           format - OutputFormat of the string\n *\n * Returns:  CFStringRef - the formatted CFStringRef in the desired format\n */\n", "func_signal": "static CFStringRef CreateStringFromImageInfoDictWithOutputFormat(CFDictionaryRef imageInfoDict, enum OutputFormat format)", "code": "{\n    CFStringRef resultString = NULL;\n    short height = 0;\n    short width = 0;\n    float resolution = 0.0f;\n    \n    LogString(LogLevelDebug, CFSTR(\"CreateStringFromImageInfoDictWithOutputFormat: creating output string with format: %d\"), format);\n    \n    if (CFNumberGetValue(CFDictionaryGetValue(imageInfoDict, IMAGE_HEIGHT_KEY), kCFNumberShortType, &height) &&\n        CFNumberGetValue(CFDictionaryGetValue(imageInfoDict, IMAGE_WIDTH_KEY), kCFNumberShortType, &width) &&\n        CFNumberGetValue(CFDictionaryGetValue(imageInfoDict, IMAGE_RESOLUTION_KEY), kCFNumberFloatType, &resolution)) {\n        CFStringRef fileName = CFDictionaryGetValue(imageInfoDict, IMAGE_NAME_KEY);\n        \n        switch (format) {\n            case Menu:\n                resultString = CFStringCreateWithFormat(kCFAllocatorDefault, \n                                                        NULL, \n                                                        CFSTR(MENU_FORMAT_STRING), \n                                                        fileName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth,\n                                                        height,\n                                                        resolution);\n                break;\n            case HTML:\n                resultString = CFStringCreateWithFormat(kCFAllocatorDefault, \n                                                        NULL, \n                                                        CFSTR(HTML_FORMAT_STRING), \n                                                        fileName,\n                                                        height,\n                                                        width);\n                break;\n            case CSS:\n                resultString = CFStringCreateWithFormat(kCFAllocatorDefault, \n                                                        NULL, \n                                                        CFSTR(CSS_FORMAT_STRING), \n                                                        fileName,\n                                                        height,\n                                                        width);\n                break;\n        }\n        \n    }\n    \n    return resultString;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  LogString(logLevel, formatString, ...)\n *\n * Purpose:  Prints a CFString and it list of format args to stdout.\n *\n * Inputs:   logLevel - the allowed logging level\n *           formatString - The CFString with the output format.\n *           ... - The argument list for the format string.\n *\n * Returns:  void\n */\n", "func_signal": "static void LogString(const enum LogLevel logLevel, CFStringRef formatString, ...)", "code": "{\n    if (logLevel < gLogLevel) {\n        return;\n    }\n    \n\tCFMutableStringRef resultString = CFStringCreateMutable(kCFAllocatorDefault, 0);\n\tCFDataRef data;\n\tva_list argList;\n    \n    switch(logLevel) {\n        case LogLevelVerbose:\n            CFStringAppend(resultString, CFSTR(\"VERBOSE: \"));\n            break;\n        case LogLevelDebug:\n            CFStringAppend(resultString, CFSTR(\"DEBUG: \"));\n            break;\n        case LogLevelInfo:\n            CFStringAppend(resultString, CFSTR(\"INFO: \"));\n            break;\n        case LogLevelWarn:\n            CFStringAppend(resultString, CFSTR(\"WARNING: \"));\n            break;\n        case LogLevelError:\n            CFStringAppend(resultString, CFSTR(\"ERROR: \"));\n            break;\n    }\n\t\n\tva_start(argList, formatString);\n\tCFStringAppendFormatAndArguments(resultString, NULL, formatString, argList);\n\tva_end(argList);\n\t\n\tdata = CFStringCreateExternalRepresentation(kCFAllocatorDefault, resultString, CFStringGetSystemEncoding(), '?');\n\t\n\tif (data != NULL) {\n        if (logLevel == LogLevelError) {\n            fprintf(stderr, \"%.*s\\n\\n\", (int)CFDataGetLength(data), CFDataGetBytePtr(data));\n        } else {\n            printf(\"%.*s\\n\\n\", (int)CFDataGetLength(data), CFDataGetBytePtr(data)); fflush(stdout);\n        }\n\t\tCFRelease(data);\n\t}\n    \n\tCFRelease(resultString);\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_Dealloc(thisInstance)\n *\n * Purpose:  Utility function that deallocates the instance when the refCount goes to zero.\n *\n * Inputs:   thisInstance - DimensionizerCMPlugIn_ptr to the instance whose refCount we inspect\n *\n * Returns:  void\n */\n", "func_signal": "static void DimensionizerCMPlugIn_Dealloc(DimensionizerCMPlugIn_ptr thisInstance)", "code": "{\n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_Dealloc(%p)\\n\", thisInstance);\n#endif LOG_ENTRY_POINTS\n    CFUUIDRef factoryID = thisInstance->factoryID;\n    \n    free(thisInstance);\n    if (factoryID) {\n        CFPlugInRemoveInstanceForFactory(factoryID);\n        CFRelease(factoryID);\n    }\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  GetCString(cStringToGet, cfString, encoding)\n *\n * Purpose:  Get a C string from a CFString. Caller is responsible for\n *           freeing the C string if the function returns true.\n *\n * Inputs:   cStringToGet - The C string\n *           cfString - The CFString to turn into a C string\n *           encoding - The desired encoding for the C string\n *\n * Returns:  Boolean - true if able to get the C string\n */\n", "func_signal": "static Boolean GetCString(char **cStringToGet, CFStringRef cfString, CFStringEncoding encoding)", "code": "{\n\tUInt32 lenText = (sizeof(UniChar) * CFStringGetLength(cfString)) + 1;\n\t*cStringToGet = malloc(lenText);\n\t\n\tif (*cStringToGet == NULL) {\n\t\treturn false;\n    }\n\t\n\tif (!CFStringGetCString(cfString, *cStringToGet, lenText, encoding)) {\n\t\tfree(*cStringToGet);\n\t\t*cStringToGet = NULL;\n\t\treturn false;\n    }\n    \n\treturn true;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  QTUtil_IsImageFile(fileSpec)\n *\n * Purpose:  Determines whether the file that the fileSpec points to is an image by\n *           testing whether QuickTime can work with it.\n *\n * Inputs:   fileSpec - FSSpecPtr to a file.\n *\n * Returns:  Boolean - true if the fileSpec points to an image\n */\n", "func_signal": "static Boolean QTUtil_IsImageFile(const FSSpecPtr fileSpec)", "code": "{\n\tBoolean isImage = false;    \n\tCanQuickTimeOpenFile(fileSpec,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t &isImage,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 0);\n\treturn isImage;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  QTUtil_GetImageDescription(fileSpec)\n *\n * Purpose:  Gets the image description struct for the file which the fileSpec points to.\n *\n * Inputs:   fileSpec - FSSpecPtr to a file.  It's presumed here that the file has already\n *           been qualified as an image that QuickTime understands.\n *\n * Returns:  ImageDescriptionPtr - pointer to the image description struct\n */\n", "func_signal": "static ImageDescriptionPtr QTUtil_GetImageDescription(const FSSpecPtr fileSpec)", "code": "{\n\tGraphicsImportComponent gi;\n\tGetGraphicsImporterForFile(fileSpec, &gi);\n\t\n\tImageDescriptionHandle imageDesc = (ImageDescriptionHandle)(NewHandle(sizeof(ImageDescription)));\n\tif (GraphicsImportGetImageDescription(gi, &imageDesc) == noErr) {\n\t\treturn (*imageDesc);\n\t}\n\t\n\treturn NULL;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_Factory(thisInstance, iid, ppv)\n *\n * Purpose:  Implementation of the factory function for this type.\n *\n * Inputs:   allocator - CFAllocatorRef that will allocate the memory for the instance of the plugin\n *           typeID - CFUUIDRef of the requested type of plugin\n *\n * Returns:  void * - a pointer to the allocated instance of the CM plugin\n */\n", "func_signal": "void *DimensionizerCMPlugIn_Factory(CFAllocatorRef allocator, CFUUIDRef typeID)", "code": "{\n#pragma unused (allocator)\n    \n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_Factory(%p, %p)\\n\", allocator, typeID); fflush(stdout);\n#endif LOG_ENTRY_POINTS\n\t\n    void *result = NULL;\n\t\n    // If correct type is being requested, allocate an\n    // instance of TestType and return the IUnknown interface.\n    if (CFEqual(typeID, kContextualMenuTypeID)) {\n        result = (void *)DimensionizerCMPlugIn_Alloc(kDimensionizerCMPlugIn_FactoryID);\n    }\n    return result;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  CreateImageInfoDictionaryWithFSRef(theFSRef)\n *\n * Purpose:  Creates a CFDictionaryRef containing information about the image if\n *           theFSRef points to a file in an image format that QuickTime understands.\n *\n * Inputs:   theFSRef - FSRefPtr pointing to an FSRef for which we will try to get\n *                      image information.\n *\n * Returns:  CFDictionaryRef - the formatted CFStringRef in the desired format\n */\n", "func_signal": "static CFDictionaryRef CreateImageInfoDictionaryWithFSRef(FSRefPtr theFSRef)", "code": "{\n    CFMutableDictionaryRef imageDict = NULL;\n    FSSpec fileSpec;\n    \n    if (FSGetCatalogInfo(theFSRef, kFSCatInfoNone, NULL, NULL, &fileSpec, NULL) == noErr) {\n        ImageDescriptionPtr imageDesc = QTUtil_GetImageDescription(&fileSpec);\n        \n        if (imageDesc) {\n            CFURLRef imageURL = CFURLCreateFromFSRef(kCFAllocatorDefault, theFSRef);\n            CFStringRef imageName;\n            \n            if (imageURL) {\n                imageName = CFURLCopyLastPathComponent(imageURL);\n                LogString(LogLevelDebug, CFSTR(\"CreateImageInfoDictionaryWithFSRef: Image name: %@\\n\"), imageName);\n                CFRelease(imageURL);\n            } else {\n                LogString(LogLevelWarn, CFSTR(\"CreateImageInfoDictionaryWithFSRef: Could not get URL for file!!!\\n\"));\n                return NULL;\n            }\n            \n            imageDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n            \n            short height = imageDesc->height;\n            short width = imageDesc->width;\n            float resolution = FixedToFloat(imageDesc->vRes);\n            CFNumberRef imageHeight = CFNumberCreate(kCFAllocatorDefault, kCFNumberShortType, &height);\n            CFNumberRef imageWidth = CFNumberCreate(kCFAllocatorDefault, kCFNumberShortType, &width);\n            CFNumberRef imageResolution = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloatType, &resolution);\n            \n            CFDictionarySetValue (imageDict, IMAGE_NAME_KEY, imageName);\n            CFDictionarySetValue (imageDict, IMAGE_HEIGHT_KEY, imageHeight);\n            CFDictionarySetValue (imageDict, IMAGE_WIDTH_KEY, imageWidth);\n            CFDictionarySetValue (imageDict, IMAGE_RESOLUTION_KEY, imageResolution);\n            \n            CFRelease(imageName);\n            CFRelease(imageHeight);\n            CFRelease(imageWidth);\n            CFRelease(imageResolution);\n        } else {\n            LogString(LogLevelInfo, CFSTR(\"CreateImageInfoDictionaryWithFSRef: Could not get ImageDescription for FSRef!\\n\"));\n        }\n    } else {\n        LogString(LogLevelInfo, CFSTR(\"CreateImageInfoDictionaryWithFSRef: Could not get FileSpec for FSRef!\\n\"));\n    }\n    \n    return imageDict;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DescIsOfTypeOrCanBeCoercedToType(desc, desiredType)\n *\n * Purpose:  Tests if the AEDesc desc is either of the desired type or can succesfully\n *           be coerced to the desired type.\n *\n * Inputs:   desc - pointer to an AEDesc to test against the desired type\n *           desiredType - OSType of the desired type\n *\n * Returns:  Boolean - true if the desc is of or can be coerced to the desired type\n */\n", "func_signal": "static Boolean DescIsOfTypeOrCanBeCoercedToType(const AEDesc *desc, OSType desiredType)", "code": "{\n    AEDesc tempdesc = {typeNull, NULL};\n    if (desc->descriptorType == desiredType) {\n        return true;\n    }\n    \n    if (AECoerceDesc(desc, desiredType, &tempdesc) == noErr) {\n        AEDisposeDesc(&tempdesc);\n        return true;\n    }\n    \n    return false;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_HandleSelection(thisInstance, context, commandID)\n *\n * Purpose:  The implementation of the HandleSelection test interface function.\n *\n * Inputs:   thisInstance - pointer to the instance of the plugin\n *           context - AEDesc event context\n *           commandID -SInt32 menu command ID of the chosen command\n *\n * Returns:  OSStatus - the error code\n */\n", "func_signal": "static OSStatus DimensionizerCMPlugIn_HandleSelection(void *thisInstance, AEDesc *context, SInt32 commandID)", "code": "{\n\t\n#if LOG_ENTRY_POINTS\n    printf(\"\\nDimensionizerCMPlugIn_->DimensionizerCMPlugIn_HandleSelection(instance: %p, context: %p, commandID: 0x%08lX)\\n\",\n\t\t   thisInstance, context, commandID);\n#endif LOG_ENTRY_POINTS\n    \n    if (LogLevelDebug < gLogLevel) {\n        LogContext(context);\n    }\n    LogString(LogLevelDebug, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: commandID: %d\\n\"), commandID);\n    LogString(LogLevelVerbose, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: Raw AEDesc type: '%4.4s'\\n\"), (Ptr)&context->descriptorType);\n\t\n    OSStatus result = noErr;\n\tCFMutableStringRef theOutputString = CFStringCreateMutable(kCFAllocatorDefault, 0);\n\t\n\t// Sequence the command ids\n    gNumCommandIDs = 0;\n    Boolean isPrimaryCommandType = (commandID % 2 != 0);\n\tBoolean isSingleElement = true;\n\tCFIndex numEntries = 1;\n\t\n\tif (commandID == gSubmenuCommandId || commandID == (gSubmenuCommandId + 1)) { // The submenu's parent menu item was selected.\n\t\tnumEntries = CFDictionaryGetCount(gImageFileInfoDict);\n\t\tisSingleElement = false;\n\t}\n\t\n\t// Determine the expected output format.\n\tenum OutputFormat theFormat;\n\tint preferredFormat = -1;\n\t\n\tif (isPrimaryCommandType) {\n\t\tLogString(LogLevelDebug, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: getting primary output type preference.\\n\"));\n\t\tpreferredFormat = OutputFormatPreferenceForKey(PRIMARY_OUTPUT_FORMAT);\n\t\tif (preferredFormat == -1) {\n\t\t\ttheFormat = HTML;\n\t\t} else {\n\t\t\ttheFormat = preferredFormat;\n\t\t}\n\t} else {\n\t\tLogString(LogLevelDebug, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: getting secondary output type preference.\\n\"));\n\t\tpreferredFormat = OutputFormatPreferenceForKey(SECONDARY_OUTPUT_FORMAT);\n\t\tif (preferredFormat == -1) {\n\t\t\ttheFormat = CSS;\n\t\t} else {\n\t\t\ttheFormat = preferredFormat;\n\t\t}\n\t}\n\t\n\tSInt32 realCommandID;\n\tif (isSingleElement) {\n\t\t// The entry is shared between the primary and secondary command IDs for each menu item.  Since the dictionary is keyed\n\t\t// by the command ID of the primary command, we have to compensate when the secondary command is chosen.\n\t\trealCommandID = isPrimaryCommandType ? commandID : commandID - 1;\n\t} else {\n\t\trealCommandID = 1001;\n\t}\n\tLogString(LogLevelDebug, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: real commandID: %d\\n\"), realCommandID);\n\t\n\t// Build the output string.\n\tdo {\n\t\tCFNumberRef menuCommandID = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &realCommandID);\n\t\tif (gImageFileInfoDict && CFDictionaryContainsKey(gImageFileInfoDict, menuCommandID)) {\n\t\t\tLogString(LogLevelVerbose, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: gImageFileInfoDict: %@\\n\"), gImageFileInfoDict);\n\t\t\t\n\t\t\tCFDictionaryRef imageInfoDict = CFDictionaryGetValue(gImageFileInfoDict, menuCommandID);\n\t\t\tif (imageInfoDict) {\n\t\t\t\tif (theFormat == Custom) {\n\t\t\t\t\tCFStringAppend(theOutputString, CreateCustomOutputFormatStringFromImageInfoDictWithOutputType(imageInfoDict, isPrimaryCommandType));\n\t\t\t\t} else {\n\t\t\t\t\tCFStringAppend(theOutputString, CreateStringFromImageInfoDictWithOutputFormat(imageInfoDict, theFormat));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (numEntries > 1) {\n\t\t\t\t\tCFStringAppend(theOutputString, CFSTR(\"\\n\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLogString(LogLevelInfo, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: Could not get dictionary for commandID key.\\n\"));\n\t\t\t}\n\t\t}\n\t\t\n\t\tCFRelease(menuCommandID);\n\t\tif (!isSingleElement) {\n\t\t\trealCommandID++;\n\t\t}\n\t\t\n\t} while (--numEntries > 0);\n\t\n\tLogString(LogLevelDebug, CFSTR(\"DimensionizerCMPlugIn_HandleSelection: theOutputString: %@\\n\"), theOutputString);\n\t\n\t// Place the output onto the pasteboard.\n\tif (theOutputString) {\n\t\tif (CFStringGetLength(theOutputString) > 0) {\n\t\t\tPasteboardRef theClipboard;\n\t\t\tresult = PasteboardCreate(kPasteboardClipboard, &theClipboard);\n\t\t\tif (result == noErr) {\n\t\t\t\tresult = AddStringToPasteboard(theClipboard, theOutputString);\n\t\t\t\tif (result == noErr) {\n\t\t\t\t\tLogString(LogLevelWarn, CFSTR(\"Error adding the output string to the clipboard: %d\\n\"), result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLogString(LogLevelWarn, CFSTR(\"Error accessing the pasteboard: %d\\n\"), result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCFRelease(theOutputString);\n\t}\n\t\n    return noErr;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  CreateMenuWithWithContext(context, commandList)\n *\n * Purpose:  Create a menu with the item(s) in the context and put into the commandList\n *\n * Inputs:   context - AEDesc from the menu event\n *           commandList - AEDescList of commands to which we append our menu command(s)\n *\n * Returns:  OSStatus - error code\n */\n", "func_signal": "static OSStatus CreateMenuWithWithContext(const AEDesc *context, AEDescList *commandList)", "code": "{\n    OSStatus result = noErr;\n    \n#if LOG_ENTRY_POINTS\n    printf(\"CreateMenuWithWithContext(context: %p, commandList: %p)\\n\", context, commandList);\n#endif LOG_ENTRY_POINTS    \n    \n    AEDescList theSubMenuCommands = { typeNull, NULL };\n    \n    // The first thing we should do is create an AEDescList of subcommands.\n    // Set up the AEDescList.\n    result = AECreateList(NULL, 0, false, &theSubMenuCommands);\n    require_noerr(result, CreateMenuWithWithContext_Complete_fail);\n    \n    long numItems;\n    result = AECountItems(context, &numItems);\n    if (noErr == result) {\n        LogString(LogLevelInfo, CFSTR(\"CreateMenuWithWithContext: Received %ld item(s) in the context.\\n\"), numItems);\n        \n        CFArrayRef imageInfoDictsArray = GetImageInfoForQualifiedItems(context);\n        if (imageInfoDictsArray) { CFRetain(imageInfoDictsArray); }\n        \n        CFIndex numImages = CFArrayGetCount(imageInfoDictsArray);\n        LogString(LogLevelInfo, CFSTR(\"CreateMenuWithWithContext: %ld items are images.\\n\"), numImages);\n        \n        if (numImages == 1) {\n            CFDictionaryRef anImageInfoDict = (CFDictionaryRef)CFArrayGetValueAtIndex(imageInfoDictsArray, 0);\n            if (anImageInfoDict) {\n                CFStringRef menuCommandName = CreateStringFromImageInfoDictWithOutputFormat(anImageInfoDict, Menu);\n                LogString(LogLevelDebug, CFSTR(\"CreateMenuWithWithContext: menuCommandName: %@\\n\"), menuCommandName);\n                \n                // Add the menu item to the contextual menu.\n                SInt32 commandIDNumber = ++gNumCommandIDs;\n                result = InsertCommandIntoCommandListWithOptionsSubmenu(menuCommandName, commandIDNumber, commandList, kMenuItemAttrDynamic, kMenuNoModifiers, NULL);\n                \n                // Add alt menu item\n                SInt32 altCommandIDNumber = ++gNumCommandIDs;\n                result = InsertCommandIntoCommandListWithOptionsSubmenu(menuCommandName, altCommandIDNumber, commandList, kMenuItemAttrDynamic, kMenuOptionModifier, NULL);\n                \n                // Add this image info dict to the global image file info dict keyed by the menu item's command id.\n                CFNumberRef menuCommandID = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &commandIDNumber);\n                CFDictionarySetValue(gImageFileInfoDict, menuCommandID, anImageInfoDict);\n                \n                // Clean up.\n                CFRelease(menuCommandID);\n                CFRelease(menuCommandName);\n                \n                LogString(LogLevelVerbose, CFSTR(\"CreateMenuWithWithContext: created menu item.\\n\"));\n            }\n        } else if (numImages > 1) {\n            CFIndex i;\n            for (i = 0; i < numImages; i++) {\n                CFDictionaryRef anImageInfoDict = (CFDictionaryRef)CFArrayGetValueAtIndex(imageInfoDictsArray, i);\n                if (anImageInfoDict) {\n                    CFStringRef menuCommandName = CreateStringFromImageInfoDictWithOutputFormat(anImageInfoDict, Menu);\n                    LogString(LogLevelDebug, CFSTR(\"CreateMenuWithWithContext: menuCommandName: %@\\n\"), menuCommandName);\n\t\t\t\t\t\n                    // Add the menu item to the contextual menu. \n\t\t\t\t\t// We must set the kMenuItemAttrNotPreviousAlternate attribute to signal that this is a new dynamic group.\n                    SInt32 commandIDNumber = 1000 + (++gNumCommandIDs);\n                    result = InsertCommandIntoCommandListWithOptionsSubmenu(menuCommandName, commandIDNumber, &theSubMenuCommands, kMenuItemAttrDynamic | kMenuItemAttrNotPreviousAlternate, kMenuNoModifiers, NULL);\n                    \n                    // Add alt menu item\n                    SInt32 altCommandIDNumber = 1000 + (++gNumCommandIDs);\n                    result = InsertCommandIntoCommandListWithOptionsSubmenu(menuCommandName, altCommandIDNumber, &theSubMenuCommands, kMenuItemAttrDynamic, kMenuOptionModifier, NULL);\n                    \n                    // Add this image info dict to the global image file info dict keyed by the menu item's command id.\n                    CFNumberRef menuCommandID = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &commandIDNumber);\n                    CFDictionarySetValue(gImageFileInfoDict, menuCommandID, anImageInfoDict);\n                    \n                    // Clean up.\n                    CFRelease(menuCommandID);\n                    CFRelease(menuCommandName);\n                    \n                    LogString(LogLevelVerbose, CFSTR(\"CreateMenuWithWithContext: created menu item: %d.\\n\"), i);\n                }\n            }\n            \n            LogString(LogLevelDebug, CFSTR(\"CreateMenuWithWithContext: created %d submenu items.\\n\"), numImages);\n            \n            // Now, we need to create the supercommand which will \"own\" the subcommands.\n            // The supercommand lives in the root command list.\n            CFStringRef superCommandString = CFStringCreateWithFormat(kCFAllocatorDefault, \n                                                                      NULL, \n                                                                      CFSTR(\"%d images selected.\"), \n                                                                      numImages);\n            \n            result = InsertCommandIntoCommandListWithOptionsSubmenu(superCommandString, gSubmenuCommandId, commandList, kMenuItemAttrSubmenuParentChoosable | kMenuItemAttrDynamic, kMenuNoModifiers, &theSubMenuCommands);\n            \n\t\t\t//result = InsertCommandIntoCommandListWithOptionsSubmenu(superCommandString, (gSubmenuCommandId + 1), commandList, kMenuItemAttrSubmenuParentChoosable | kMenuItemAttrDynamic, kMenuOptionModifier, NULL);\n\t\t\t\n\t\t\tCFRelease(superCommandString);\n        }\n        \n        if (imageInfoDictsArray) {\n            CFRelease(imageInfoDictsArray);\n        }\n    }\n    \n\t\n\t// clean up after ourself\nCreateMenuWithWithContext_fail:    ;\n    AEDisposeDesc(&theSubMenuCommands);\n    //AEDisposeDesc(&theSupercommand);\n    \n    \nCreateMenuWithWithContext_Complete_fail:\n\treturn result;\n\t\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_Release(thisInstance)\n *\n * Purpose:  When an interface is released, decrement the refCount.\n *           If the refCount goes to zero, deallocate the instance.\n *\n * Inputs:   thisInstance - pointer to the instance of the plugin\n *\n * Returns:  ULONG - the reference count of the instance of the plugin\n */\n", "func_signal": "static ULONG DimensionizerCMPlugIn_Release(void *thisInstance)", "code": "{\n\t\n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_Release(%p)\\n\", thisInstance);\n    fflush(stdout);\n#endif\n\t\n    ULONG result = 0;\n    \n    ((DimensionizerCMPlugIn_ptr)thisInstance)->refCount -= 1;\n    if (((DimensionizerCMPlugIn_ptr)thisInstance)->refCount == 0) {\n        DimensionizerCMPlugIn_Dealloc((DimensionizerCMPlugIn_ptr)thisInstance);\n    } else {\n        result = ((DimensionizerCMPlugIn_ptr)thisInstance)->refCount;\n    }\n    return result;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  CreateCustomOutputFormatStringFromImageInfoDictWithOutputType(imageInfoDict, isMainType)\n *\n * Purpose:  Creates a CFStringRef in the custom format defined in the preferences from the imageInfoDict.\n *\n * Inputs:   imageInfoDict - CFDictionaryRef containing information about an image\n *           isMainType - indicates whether we should construct the output using the primary or secondary\n *           custom output preference\n *\n * Returns:  CFStringRef - the formatted CFStringRef in the desired format\n */\n", "func_signal": "static CFStringRef CreateCustomOutputFormatStringFromImageInfoDictWithOutputType(CFDictionaryRef imageInfoDict, Boolean isMainType)", "code": "{\n    CFStringRef resultString = NULL;\n    short height = 0;\n    short width = 0;\n    \n    LogString(LogLevelDebug, CFSTR(\"CreateCustomOutputFormatStringFromImageInfoDictWithOutputType: creating custom output string...\\n\"));\n    \n    if (CFNumberGetValue(CFDictionaryGetValue(imageInfoDict, IMAGE_HEIGHT_KEY), kCFNumberShortType, &height) &&\n        CFNumberGetValue(CFDictionaryGetValue(imageInfoDict, IMAGE_WIDTH_KEY), kCFNumberShortType, &width)) {\n        CFStringRef fileName = CFDictionaryGetValue(imageInfoDict, IMAGE_NAME_KEY);\n        \n        // Make sure we always have the latest values.\n        CFPreferencesAppSynchronize(kDimensionizerCMPBundleIdentifier);\n\t\t\n        // Need the array from prefs and need to know if it's primary or secondary in order to get it.\n        CFArrayRef customFormatParts;\n\t\t\n        if (isMainType) {\n            CFPropertyListRef value = CFPreferencesCopyAppValue(PRIMARY_CUSTOM_FORMAT, kDimensionizerCMPBundleIdentifier);\n            if (value && CFGetTypeID(value) == CFArrayGetTypeID()) {\n                customFormatParts = CFArrayCreateCopy(kCFAllocatorDefault, value);\n                CFRelease(value);\n            }\n        } else {\n            CFPropertyListRef value = CFPreferencesCopyAppValue(SECONDARY_CUSTOM_FORMAT, kDimensionizerCMPBundleIdentifier);\n            if (value && CFGetTypeID(value) == CFArrayGetTypeID()) {\n                customFormatParts = CFArrayCreateCopy(kCFAllocatorDefault, value);\n                CFRelease(value);\n            }\n        }\n        \n        if (customFormatParts) {\n            LogString(LogLevelDebug, CFSTR(\"CreateCustomOutputFormatStringFromImageInfoDictWithOutputType: custom format from preferences: %@\\n\"), customFormatParts);\n            \n            // Enumerate through the array adding pieces & substituting the params if they are equal to the tokens.\n            CFMutableStringRef mutableString = CFStringCreateMutable(kCFAllocatorDefault, 0);\n            if (mutableString) {\n                CFIndex count = CFArrayGetCount(customFormatParts);\n                CFIndex i = 0;\n                for (i = 0; i < count; i++) {\n                    CFStringRef part = CFArrayGetValueAtIndex(customFormatParts, i);\n                    if (CFStringCompare(part, WIDTH_TOKEN, 0) == kCFCompareEqualTo) {\n                        CFStringAppendFormat(mutableString, NULL, CFSTR(\"%d\"), width);\n                    } else if (CFStringCompare(part, HEIGHT_TOKEN, 0) == kCFCompareEqualTo) {\n                        CFStringAppendFormat(mutableString, NULL, CFSTR(\"%d\"), height);\n                    } else if (CFStringCompare(part, NAME_TOKEN, 0) == kCFCompareEqualTo) {\n                        CFStringAppend(mutableString, fileName);\n                    } else {\n                        CFStringAppend(mutableString, part);\n                    }\n                }\n                resultString = CFStringCreateCopy(kCFAllocatorDefault, mutableString);\n                CFRelease(mutableString);\n            }\n            CFRelease(customFormatParts);\n        } else {\n            LogString(LogLevelWarn, CFSTR(\"CreateCustomOutputFormatStringFromImageInfoDictWithOutputType: Could not get custom format from preferences.\\n\"));\n        }\n    }\n    \n    return resultString;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "//fss2path takes the FSSpec of a file, folder or volume and returns its path \n", "func_signal": "void fss2path(char *path, FSSpec *fss)", "code": "{\n    int l;             //fss->name contains name of last item in path\n    for(l=0; l<(fss->name[0]); l++) path[l] = fss->name[l + 1]; \n    path[l] = 0;\n    \n    if(fss->parID != fsRtParID) //path is more than just a volume name\n    { \n        int i, len;\n        CInfoPBRec pb;\n        \n        pb.dirInfo.ioNamePtr = fss->name;\n        pb.dirInfo.ioVRefNum = fss->vRefNum;\n        pb.dirInfo.ioDrParID = fss->parID;\n        do\n        {\n            pb.dirInfo.ioFDirIndex = -1;  //get parent directory name\n            pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;   \n            if(PBGetCatInfoSync(&pb) != noErr) break;\n            \n            len = fss->name[0] + 1;\n            for(i=l; i>=0;  i--) path[i + len] = path[i];\n            for(i=1; i<len; i++) path[i - 1] = fss->name[i]; //add to start of path\n            path[i - 1] = ':';\n            l += len;\n        } while(pb.dirInfo.ioDrDirID != fsRtDirID); //while more directory levels\n    }\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  LogContext(context)\n *\n * Purpose:  Prints a description of the context to stdout.\n *\n * Inputs:   context - AEDescList of commands to print out.\n *\n * Returns:  void\n */\n", "func_signal": "static void LogContext(const AEDescList *context)", "code": "{\n    AEDesc tempdesc = {typeNull, NULL};\n    if (AECoerceDesc(context, typeAEList, &tempdesc) == noErr) {\n        Handle strHdl;\n        OSStatus result = AEPrintDescToHandle(&tempdesc, &strHdl);\n        if (noErr == result) {\n            char nul = '\\0';\n            PtrAndHand(&nul, strHdl, 1);\n            printf(\"LogContext: context: \\\"%s\\\".\\n\", *strHdl); fflush(stdout);\n            DisposeHandle(strHdl);\n        }\n        \n        AEDisposeDesc(&tempdesc);\n    }\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*****************************************************\n *\n * Routine:  DimensionizerCMPlugIn_Alloc(factoryID)\n *\n * Purpose:  Utility function that allocates a new instance.\n *\n * Inputs:   factoryID - The CFUUID factory ID of the plugin\n *\n * Returns:  DimensionizerCMPlugIn_ptr - A pointer to the instance we create\n */\n", "func_signal": "static DimensionizerCMPlugIn_ptr DimensionizerCMPlugIn_Alloc(CFUUIDRef factoryID)", "code": "{\n    \n#if LOG_ENTRY_POINTS\n    printf(\"DimensionizerCMPlugIn_Alloc(%p)\\n\", factoryID);\n#endif\n    \n    // Allocate memory for the new instance.\n    DimensionizerCMPlugIn_ptr newInstance = (DimensionizerCMPlugIn_ptr)malloc(sizeof(DimensionizerCMPlugIn_rec));\n    \n    // Point to the function table.\n    newInstance->cmInterface = &gDimensionizerCMInterface;\n    \n    // Retain and keep an open instance refcount for each factory.\n    newInstance->factoryID = CFRetain(factoryID);\n    CFPlugInAddInstanceForFactory(factoryID);\n    \n    // This function returns the IUnknown interface so set the refCount to one.\n    newInstance->refCount = 1;\n    return newInstance;\n}", "path": "Dimensionizer\\Dimensionizer.c", "repo_name": "tcripps/dimensionizer", "stars": 5, "license": "other", "language": "c", "size": 368}
{"docstring": "/*\n * Initialize the input modules to read a scan of compressed data.\n * The first call to this is done by jdmaster.c after initializing\n * the entire decompressor (during jpeg_start_decompress).\n * Subsequent calls come from consume_markers, below.\n */\n", "func_signal": "METHODDEF(void)\nstart_input_pass (j_decompress_ptr cinfo)", "code": "{\n  per_scan_setup(cinfo);\n  latch_quant_tables(cinfo);\n  (*cinfo->entropy->start_pass) (cinfo);\n  (*cinfo->coef->start_input_pass) (cinfo);\n  cinfo->inputctl->consume_input = cinfo->coef->consume_data;\n}", "path": "xbmc\\lib\\cximage-6.0\\jpeg\\jdinput.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// v[ index \u0303OtBbN\u030f\n", "func_signal": "static void wrd_graphic_init ( HDC hdc )", "code": "{\n\tint index;\n\n\twrd_wnd_lock();\n\twrd_graphic_terminate ();\n\tfor ( index = 0; index < W32G_WRDWND_GRAPHIC_PLANE_MAX; index++ ) {\n\t\tw32g_wrd_wnd.graphic_dib[index] = dib_create ( w32g_wrd_wnd.width, w32g_wrd_wnd.height );\n\t\tw32g_wrd_wnd.modified_graphic[index] = TRUE;\n\t}\n\n\tw32g_wrd_wnd.bits_mag_work = (char *) safe_malloc ( MAG_WORK_WIDTH * MAG_WORK_HEIGHT );\n\n\tw32g_wrd_wnd.index_active = 0;\n\tw32g_wrd_wnd.index_display = 0;\n\twrd_wnd_unlock();\n\twrd_graphic_reset_all ();\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/* Encode the string S of length LENGTH to base64 format and place it\n   to STORE.  STORE will be 0-terminated, and must point to a writable\n   buffer of at least 1+BASE64_LENGTH(length) bytes.  */\n", "func_signal": "static void base64_encode (const gchar *s, gchar *store, gint length)", "code": "{\n\t/* Conversion table.  */\n\tstatic gchar tbl[64] = {\n\t\t'A','B','C','D','E','F','G','H',\n\t\t'I','J','K','L','M','N','O','P',\n\t\t'Q','R','S','T','U','V','W','X',\n\t\t'Y','Z','a','b','c','d','e','f',\n\t\t'g','h','i','j','k','l','m','n',\n\t\t'o','p','q','r','s','t','u','v',\n\t\t'w','x','y','z','0','1','2','3',\n\t\t'4','5','6','7','8','9','+','/'\n\t};\n\tgint i;\n\tguchar *p = (guchar *)store;\n\n\t/* Transform the 3x8 bits to 4x6 bits, as required by base64.  */\n\tfor (i = 0; i < length; i += 3)\n\t{\n\t\t*p++ = tbl[s[0] >> 2];\n\t\t*p++ = tbl[((s[0] & 3) << 4) + (s[1] >> 4)];\n\t\t*p++ = tbl[((s[1] & 0xf) << 2) + (s[2] >> 6)];\n\t\t*p++ = tbl[s[2] & 0x3f];\n\t\ts += 3;\n\t}\n\t/* Pad the result if necessary...  */\n\tif (i == length + 1)\n\t\t*(p - 1) = '=';\n\telse if (i == length + 2)\n\t\t*(p - 1) = *(p - 2) = '=';\n\t/* ...and zero-terminate it.  */\n\t*p = '\\0';\n}", "path": "xbmc\\cores\\paplayer\\flac-1.2.1\\src\\plugin_xmms\\http.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// \u0308\u0303eLXgXV\n", "func_signal": "static void wrd_text_update ( int x_from, int y_from, int x_to, int y_to, int lockflag )", "code": "{\n\tRECT rc;\n\n\tif ( w32g_wrd_wnd.draw_skip ) return;\n\n\tif ( x_from < 0 ) x_from = 0;\n\tif ( x_from >= w32g_wrd_wnd.row ) x_from = w32g_wrd_wnd.row - 1;\n\tif ( x_to < 0 ) x_to = 0;\n\tif ( x_to >= w32g_wrd_wnd.row ) x_to = w32g_wrd_wnd.row - 1;\n\tif ( y_from < 0 ) y_from = 0;\n\tif ( y_from >= w32g_wrd_wnd.row ) y_from = w32g_wrd_wnd.col - 1;\n\tif ( y_to < 0 ) y_to = 0;\n\tif ( y_to >= w32g_wrd_wnd.row ) y_to = w32g_wrd_wnd.col - 1;\n\n\tSetRect ( &rc, x_from * w32g_wrd_wnd.font_width, y_from * w32g_wrd_wnd.font_height,\n\t\t(x_to+1) * w32g_wrd_wnd.font_width, (y_to+1) * w32g_wrd_wnd.font_height);\n\n\twrd_wnd_lock();\n\tif ( lockflag ) GDI_LOCK();\n\tif ( w32g_wrd_wnd.flag & WRD_FLAG_TEXT ) {\n\t\tHDC hmdc_tmask;\n\t\tCOLORREF forecolor, backcolor, prevforecolor, prevbackcolor;\n\t\tchar attr;\n\t\tHGDIOBJ hgdiobj;\n\t\tint x, y;\n\t\tforecolor = w32g_wrd_wnd.pals[w32g_wrd_wnd.curforecolor];\n\t\tbackcolor = w32g_wrd_wnd.pals[w32g_wrd_wnd.curbackcolor];\n\t\tprevforecolor = SetTextColor( w32g_wrd_wnd.hmdc, forecolor );\n\t\tprevbackcolor = SetBkColor( w32g_wrd_wnd.hmdc, backcolor );\n\t\thgdiobj = SelectObject( w32g_wrd_wnd.hmdc, w32g_wrd_wnd.hFont );\n\t\thmdc_tmask = CreateCompatibleDC ( w32g_wrd_wnd.hmdc );\n\t\tSelectObject( hmdc_tmask, w32g_wrd_wnd.hbmp_tmask );\n\t\tSelectObject( hmdc_tmask, w32g_wrd_wnd.hFont );\n\t\tSelectObject( hmdc_tmask, w32g_wrd_wnd.hNullBrush );\n\t\tSelectObject( hmdc_tmask, w32g_wrd_wnd.hNullPen );\n\t\tattr = 0;\n\t\tSetTextColor( hmdc_tmask, COLOR_MASK_WHITE );\n\t\tSetBkColor( hmdc_tmask, COLOR_MASK_BLACK );\n\t\tfor( y = y_from; y <= y_to; y++ ) {\n\t\t\tfor( x = x_from; x <= x_to; x++ ) {\n\t\t\t\tchar mbt = _MBC_SINGLE;\n\t\t\t\tRECT rc_part;\n\t\t\t\tif ( forecolor != w32g_wrd_wnd.pals[w32g_wrd_wnd.forecolorbuf[y][x]] ) {\n\t\t\t\t\tforecolor = w32g_wrd_wnd.pals[w32g_wrd_wnd.forecolorbuf[y][x]];\n\t\t\t\t\tSetTextColor( w32g_wrd_wnd.hmdc, forecolor );\n\t\t\t\t}\n\t\t\t\tif ( backcolor != w32g_wrd_wnd.pals[w32g_wrd_wnd.backcolorbuf[y][x]] ) {\n\t\t\t\t\tbackcolor = w32g_wrd_wnd.pals[w32g_wrd_wnd.backcolorbuf[y][x]];\n\t\t\t\t\tSetBkColor( w32g_wrd_wnd.hmdc, backcolor );\n\t\t\t\t}\n\t\t\t\tif ( attr != w32g_wrd_wnd.attrbuf[y][x] ) {\n\t\t\t\t\tif ( ( attr & W32G_WRDWND_ATTR_REVERSE ) != ( w32g_wrd_wnd.attrbuf[y][x] & W32G_WRDWND_ATTR_REVERSE ) ) {\n\t\t\t\t\t\tif ( w32g_wrd_wnd.attrbuf[y][x] & W32G_WRDWND_ATTR_REVERSE ) {\n\t\t\t\t\t\t\tSetTextColor( hmdc_tmask, COLOR_MASK_BLACK );\n\t\t\t\t\t\t\tSetBkColor( hmdc_tmask, COLOR_MASK_WHITE );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSetTextColor( hmdc_tmask, COLOR_MASK_WHITE );\n\t\t\t\t\t\t\tSetBkColor( hmdc_tmask, COLOR_MASK_BLACK );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tattr = w32g_wrd_wnd.attrbuf[y][x];\n\t\t\t\t}\n\t\t\t\tif ( PlayerLanguage == LANGUAGE_JAPANESE && _mbbtype( w32g_wrd_wnd.textbuf[y][x], _MBC_SINGLE ) == _MBC_LEAD ) {\n\t\t\t\t\tSetRect ( &rc_part, x * w32g_wrd_wnd.font_width, y * w32g_wrd_wnd.font_height,\n\t\t\t\t\t\t(x + 2) * w32g_wrd_wnd.font_width, (y + 1) * w32g_wrd_wnd.font_height );\n\t\t\t\t\tif ( w32g_wrd_wnd.flag & WRD_FLAG_TEXT )\n\t\t\t\t\t\tExtTextOut( w32g_wrd_wnd.hmdc, rc_part.left, rc_part.top, ETO_OPAQUE | ETO_CLIPPED, &rc_part, w32g_wrd_wnd.textbuf[y] + x, 2, NULL);\n\t\t\t\t\tExtTextOut( hmdc_tmask, rc_part.left, rc_part.top, ETO_OPAQUE | ETO_CLIPPED, &rc_part, w32g_wrd_wnd.textbuf[y] + x, 2, NULL);\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tSetRect ( &rc_part, x * w32g_wrd_wnd.font_width, y * w32g_wrd_wnd.font_height,\n\t\t\t\t\t\t(x + 1) * w32g_wrd_wnd.font_width, (y + 1) * w32g_wrd_wnd.font_height );\n\t\t\t\t\tif ( w32g_wrd_wnd.flag & WRD_FLAG_TEXT )\n\t\t\t\t\t\tExtTextOut( w32g_wrd_wnd.hmdc, rc_part.left, rc_part.top, ETO_OPAQUE | ETO_CLIPPED, &rc_part, w32g_wrd_wnd.textbuf[y] + x, 1, NULL);\n\t\t\t\t\tExtTextOut( hmdc_tmask, rc_part.left, rc_part.top, ETO_OPAQUE | ETO_CLIPPED, &rc_part, w32g_wrd_wnd.textbuf[y] + x, 1, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSetTextColor( w32g_wrd_wnd.hmdc, prevforecolor);\n\t\tSetBkColor( w32g_wrd_wnd.hmdc, prevbackcolor);\n\t\tSelectObject( w32g_wrd_wnd.hmdc, hgdiobj );\n\t\tDeleteDC ( hmdc_tmask );\n\t}\n\tif ( lockflag ) GDI_UNLOCK();\n\twrd_wnd_unlock();\n\tif ( ! WrdWndInfo.GraphicStop ) {\n\t\twrd_graphic_apply ( &rc, w32g_wrd_wnd.index_display, TRUE );\n\t\twrd_graphic_update ( &rc, 0 );\n\t}\n\tInvalidateRect ( w32g_wrd_wnd.hwnd, &rc, FALSE);\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// left == TRUE : s\u030d\n// left != TRUE : s\u0309E\n", "func_signal": "void WrdWndLineClearFrom(int left, int lockflag)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tif ( lockflag ) wrd_wnd_lock();\n\tif ( left ) {\n\t\tmemset( w32g_wrd_wnd.textbuf[w32g_wrd_wnd.curposy] , 0x20 , w32g_wrd_wnd.curposx + 1 );\n\t\tmemset( w32g_wrd_wnd.forecolorbuf[w32g_wrd_wnd.curposy], W32G_WRDWND_BLACK, w32g_wrd_wnd.curposx + 1 );\n\t\tmemset( w32g_wrd_wnd.backcolorbuf[w32g_wrd_wnd.curposy], W32G_WRDWND_BLACK, w32g_wrd_wnd.curposx + 1 );\n\t\tmemset( w32g_wrd_wnd.attrbuf[w32g_wrd_wnd.curposy], 0, w32g_wrd_wnd.curposx + 1 );\n\t\tif ( lockflag ) wrd_wnd_unlock();\n\t\twrd_text_update ( 0, w32g_wrd_wnd.curposy, \n\t\t\tw32g_wrd_wnd.curposx - 1, w32g_wrd_wnd.curposy, lockflag );\n\t} else {\n\t\tmemset( &w32g_wrd_wnd.textbuf[w32g_wrd_wnd.curposy][w32g_wrd_wnd.curposx],\n\t\t\t0x20 , w32g_wrd_wnd.row - w32g_wrd_wnd.curposx );\n\t\tmemset( &w32g_wrd_wnd.forecolorbuf[w32g_wrd_wnd.curposy][w32g_wrd_wnd.curposx],\n\t\t\tW32G_WRDWND_BLACK, w32g_wrd_wnd.row - w32g_wrd_wnd.curposx );\n\t\tmemset( &w32g_wrd_wnd.backcolorbuf[w32g_wrd_wnd.curposy][w32g_wrd_wnd.curposx],\n\t\t\tW32G_WRDWND_BLACK, w32g_wrd_wnd.row - w32g_wrd_wnd.curposx );\n\t\tmemset( &w32g_wrd_wnd.attrbuf[w32g_wrd_wnd.curposy][w32g_wrd_wnd.curposx],\n\t\t\t0, w32g_wrd_wnd.row - w32g_wrd_wnd.curposx );\n\t\tif ( lockflag ) wrd_wnd_unlock();\n\t\twrd_text_update ( w32g_wrd_wnd.curposx, w32g_wrd_wnd.curposy,\n\t\t\tw32g_wrd_wnd.row - 1, w32g_wrd_wnd.curposy, lockflag );\n\t}\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// from_from s from_to s\u0702\u0142 to_from s\u64ea\u0243Rs[B\n", "func_signal": "void WrdWndCopyLineS ( int from_from, int from_to, int to_from, int lockflag )", "code": "{\n\tint y, to_to;\n\tif ( !w32g_wrd_wnd.active ) return;\n\tif ( to_from >= w32g_wrd_wnd.col ) return;\n\tif ( to_from == from_from ) return;\n\tif ( from_to < from_from ) return;\n\tif ( to_from < 0 ) {\n\t\tfrom_from -= to_from;\n\t\tfrom_to -= to_from;\n\t\tto_from = 0;\n\t}\n\tto_to = to_from + from_to - from_from;\n\tif ( to_to >= w32g_wrd_wnd.col )\n\t\tto_to = w32g_wrd_wnd.col - 1;\n\tif ( lockflag ) wrd_wnd_lock();\n\tif ( to_from < from_from ) {\n\t\tfor ( y = to_from; y <= to_to; y++ ) {\n\t\t\tint y_from = from_from + y - to_from;\n\t\t\tif ( y_from < 0 || y_from >= w32g_wrd_wnd.col ) {\n\t\t\t\tmemset ( w32g_wrd_wnd.textbuf[y], 0x20, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.forecolorbuf[y], W32G_WRDWND_BLACK, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.backcolorbuf[y], W32G_WRDWND_BLACK, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.attrbuf[y], 0, w32g_wrd_wnd.row);\n\t\t\t} else {\n\t\t\t\tmemcpy ( w32g_wrd_wnd.textbuf[y], w32g_wrd_wnd.textbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.forecolorbuf[y], w32g_wrd_wnd.forecolorbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.backcolorbuf[y], w32g_wrd_wnd.backcolorbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.attrbuf[y], w32g_wrd_wnd.attrbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( y = to_to; y >= to_from; y-- ) {\n\t\t\tint y_from = from_from + y - to_from;\n\t\t\tif ( y_from < 0 || y_from >= w32g_wrd_wnd.col ) {\n\t\t\t\tmemset ( w32g_wrd_wnd.textbuf[y], 0x20, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.forecolorbuf[y], W32G_WRDWND_BLACK, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.backcolorbuf[y], W32G_WRDWND_BLACK, w32g_wrd_wnd.row );\n\t\t\t\tmemset ( w32g_wrd_wnd.attrbuf[y], 0, w32g_wrd_wnd.row);\n\t\t\t} else {\n\t\t\t\tmemcpy ( w32g_wrd_wnd.textbuf[y], w32g_wrd_wnd.textbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.forecolorbuf[y], w32g_wrd_wnd.forecolorbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.backcolorbuf[y], w32g_wrd_wnd.backcolorbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t\tmemcpy ( w32g_wrd_wnd.attrbuf[y], w32g_wrd_wnd.attrbuf[y_from], w32g_wrd_wnd.row );\n\t\t\t}\n\t\t}\n\t}\n\tif ( lockflag ) wrd_wnd_unlock();\n\twrd_text_update ( 0, to_from, w32g_wrd_wnd.row - 1, to_to, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// Agr[g\u0303Zbg\n", "func_signal": "void WrdWndSetAttrReset(void)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_WHITE;\n\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\tw32g_wrd_wnd.curattr = 0;\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// SetInvalidateRect()  WM_PAINT \u0102\u0509\u0094\\B\n", "func_signal": "void WrdWndPaintDo(int flag)", "code": "{\n\tRECT rc;\n\tif ( flag ) InvalidateRect( w32g_wrd_wnd.hwnd,NULL, FALSE );\n\tif ( GetUpdateRect(w32g_wrd_wnd.hwnd, &rc, FALSE) ) {\n\t\tPAINTSTRUCT ps;\n\t\tif ( wrd_wnd_lock_ex ( 0 ) == TRUE ) {\n\t\t\tif ( GDI_LOCK_EX(0) == 0 ) {\n\t\t\t\tw32g_wrd_wnd.hdc = BeginPaint(w32g_wrd_wnd.hwnd, &ps);\n\t\t\t\tBitBlt(w32g_wrd_wnd.hdc,rc.left,rc.top,rc.right,rc.bottom,w32g_wrd_wnd.hmdc,rc.left,rc.top,SRCCOPY);\n\t\t\t\tEndPaint(w32g_wrd_wnd.hwnd, &ps);\n\t\t\t\tGDI_UNLOCK(); // gdi_lock\n\t\t\t} else {\n\t\t\t\tInvalidateRect ( w32g_wrd_wnd.hwnd, &rc, FALSE );\n\t\t\t}\n\t\t} else {\n\t\t\t\tInvalidateRect ( w32g_wrd_wnd.hwnd, &rc, FALSE );\n\t\t}\n\t\twrd_wnd_unlock();\n\t}\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void goom_set_str_param_value(PluginParam *p, const char *str)", "code": "{\n    int len = strlen(str);\n    if (SVAL(*p))\n        SVAL(*p) = (char*)realloc(SVAL(*p), len+1);\n    else\n        SVAL(*p) = (char*)malloc(len+1);\n    memcpy(SVAL(*p), str, len+1);\n}", "path": "xbmc\\visualizations\\Goom\\goom2k4-0\\src\\config_param.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// v[ index \u0303OtBbN lprc \u0308 hmdc_graphic \u058dXV\n", "func_signal": "static void wrd_graphic_apply ( RECT *lprc, int index, int lockflag )", "code": "{\n#if 0\n\tif ( WrdWndInfo.GraphicStop ) return;\n//\tif ( !w32g_wrd_wnd.modified_graphic[index] ) return;\n\n\tif ( lockflag ) wrd_wnd_lock();\n\tw32g_wrd_wnd.modified_graphic[index] = FALSE;\n\tif ( lockflag ) wrd_wnd_unlock();\n#endif\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// XN[AbvB\n", "func_signal": "void WrdWndScrollUp(int lockflag)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tWrdWndCopyLineS ( 1, w32g_wrd_wnd.col - 1, 0, lockflag );\n\tWrdWndClearLineFromTo ( w32g_wrd_wnd.col - 1, w32g_wrd_wnd.col - 1, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/* returns the file descriptor of the socket, or -1 on error */\n", "func_signal": "static int http_connect (gchar *url_, gboolean head, guint64 offset)", "code": "{\n\tgchar line[1024], *user, *pass, *host, *filename,\n\t     *status, *url, *temp, *file;\n\tgchar *chost;\n\tgint cnt, error, port, cport;\n\tsocklen_t err_len;\n\tgboolean redirect;\n\tint udp_sock = 0;\n\tfd_set set;\n\tstruct hostent *hp;\n\tstruct sockaddr_in address;\n\tstruct timeval tv;\n\n\turl = g_strdup (url_);\n\n\tdo\n\t{\n\t\tredirect=FALSE;\n\t\n\t\tg_strstrip(url);\n\n\t\tparse_url(url, &user, &pass, &host, &port, &filename);\n\n\t\tif ((!filename || !*filename) && url[strlen(url) - 1] != '/')\n\t\t\ttemp = g_strconcat(url, \"/\", NULL);\n\t\telse\n\t\t\ttemp = g_strdup(url);\n\t\tg_free(url);\n\t\turl = temp;\n\n\t\tchost = flac_cfg.stream.use_proxy ? flac_cfg.stream.proxy_host : host;\n\t\tcport = flac_cfg.stream.use_proxy ? flac_cfg.stream.proxy_port : port;\n\n\t\tsock = socket(AF_INET, SOCK_STREAM, 0);\n\t\tfcntl(sock, F_SETFL, O_NONBLOCK);\n\t\taddress.sin_family = AF_INET;\n\n\t\tstatus = g_strdup_printf(_(\"LOOKING UP %s\"), chost);\n\t\tflac_ip.set_info_text(status);\n\t\tg_free(status);\n\n\t\tif (!(hp = gethostbyname(chost)))\n\t\t{\n\t\t\tstatus = g_strdup_printf(_(\"Couldn't look up host %s\"), chost);\n\t\t\tshow_error_message(status);\n\t\t\tg_free(status);\n\n\t\t\tflac_ip.set_info_text(NULL);\n\t\t\teof = TRUE;\n\t\t}\n\n\t\tif (!eof)\n\t\t{\n\t\t\tmemcpy(&address.sin_addr.s_addr, *(hp->h_addr_list), sizeof (address.sin_addr.s_addr));\n\t\t\taddress.sin_port = (gint) g_htons(cport);\n\n\t\t\tstatus = g_strdup_printf(_(\"CONNECTING TO %s:%d\"), chost, cport);\n\t\t\tflac_ip.set_info_text(status);\n\t\t\tg_free(status);\n\t\t\tif (connect(sock, (struct sockaddr *) &address, sizeof (struct sockaddr_in)) == -1)\n\t\t\t{\n\t\t\t\tif (errno != EINPROGRESS)\n\t\t\t\t{\n\t\t\t\t\tstatus = g_strdup_printf(_(\"Couldn't connect to host %s\"), chost);\n\t\t\t\t\tshow_error_message(status);\n\t\t\t\t\tg_free(status);\n\n\t\t\t\t\tflac_ip.set_info_text(NULL);\n\t\t\t\t\teof = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (going)\n\t\t\t{\n\t\t\t\ttv.tv_sec = 0;\n\t\t\t\ttv.tv_usec = 10000;\n\t\t\t\tFD_ZERO(&set);\n\t\t\t\tFD_SET(sock, &set);\n\t\t\t\tif (select(sock + 1, NULL, &set, NULL, &tv) > 0)\n\t\t\t\t{\n\t\t\t\t\terr_len = sizeof (error);\n\t\t\t\t\tgetsockopt(sock, SOL_SOCKET, SO_ERROR, &error, &err_len);\n\t\t\t\t\tif (error)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = g_strdup_printf(_(\"Couldn't connect to host %s\"),\n\t\t\t\t\t\t\t\t\t chost);\n\t\t\t\t\t\tshow_error_message(status);\n\t\t\t\t\t\tg_free(status);\n\n\t\t\t\t\t\tflac_ip.set_info_text(NULL);\n\t\t\t\t\t\teof = TRUE;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!eof)\n\t\t\t{\n\t\t\t\tgchar *auth = NULL, *proxy_auth = NULL;\n\t\t\t\tgchar udpspace[30];\n\t\t\t\tint udp_port;\n\n\t\t\t\tif (flac_cfg.stream.use_udp_channel)\n\t\t\t\t{\n\t\t\t\t\tudp_port = udp_establish_listener (&udp_sock);\n\t\t\t\t\tif (udp_port > 0) \n\t\t\t\t\t\tsprintf (udpspace, \"x-audiocast-udpport: %d\\r\\n\", udp_port);\n\t\t\t\t\telse\n\t\t\t\t\t\tudp_sock = 0;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(user && pass)\n\t\t\t\t\tauth = basic_authentication_encode(user, pass, \"Authorization\");\n\n\t\t\t\tif (flac_cfg.stream.use_proxy)\n\t\t\t\t{\n\t\t\t\t\tfile = g_strdup(url);\n\t\t\t\t\tif(flac_cfg.stream.proxy_use_auth && flac_cfg.stream.proxy_user && flac_cfg.stream.proxy_pass)\n\t\t\t\t\t{\n\t\t\t\t\t\tproxy_auth = basic_authentication_encode(flac_cfg.stream.proxy_user,\n\t\t\t\t\t\t\t\t\t\t\t flac_cfg.stream.proxy_pass,\n\t\t\t\t\t\t\t\t\t\t\t \"Proxy-Authorization\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfile = g_strconcat(\"/\", filename, NULL);\n\n\t\t\t\ttemp = g_strdup_printf(\"GET %s HTTP/1.0\\r\\n\"\n\t\t\t\t\t\t       \"Host: %s\\r\\n\"\n\t\t\t\t\t\t       \"User-Agent: %s/%s\\r\\n\"\n\t\t\t\t\t\t       \"%s%s%s%s\",\n\t\t\t\t\t\t       file, host, \"Reference FLAC Player\", FLAC__VERSION_STRING, \n\t\t\t\t\t\t       proxy_auth ? proxy_auth : \"\", auth ? auth : \"\",\n\t\t\t\t\t\t       flac_cfg.stream.cast_title_streaming ?  \"Icy-MetaData:1\\r\\n\" : \"\",\n\t\t\t\t\t\t       flac_cfg.stream.use_udp_channel ? udpspace : \"\");\n\t\t\t\tif (offset && !head) {\n\t\t\t\t\tgchar *temp_dead = temp;\n\t\t\t\t\ttemp = g_strdup_printf (\"%sRange: %llu-\\r\\n\", temp, offset);\n\t\t\t\t\tfprintf (stderr, \"%s\", temp);\n\t\t\t\t\tg_free (temp_dead);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tg_free(file);\n\t\t\t\tif(proxy_auth)\n\t\t\t\t\tg_free(proxy_auth);\n\t\t\t\tif(auth)\n\t\t\t\t\tg_free(auth);\n\t\t\t\twrite(sock, temp, strlen(temp));\n\t\t\t\twrite(sock, \"\\r\\n\", 2);\n\t\t\t\tg_free(temp);\n\t\t\t\tflac_ip.set_info_text(_(\"CONNECTED: WAITING FOR REPLY\"));\n\t\t\t\twhile (going && !eof)\n\t\t\t\t  {\n\t\t\t\t\tif (http_check_for_data())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (flac_http_read_line(line, 1024))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstatus = strchr(line, ' ');\n\t\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (status[1] == '2')\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse if(status[1] == '3' && status[2] == '0' && status[3] == '2')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\twhile(going)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(http_check_for_data())\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif((cnt = flac_http_read_line(line, 1024)) != -1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif(!cnt)\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!strncmp(line, \"Location:\", 9))\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg_free(url);\n\t\t\t\t\t\t\t\t\t\t\t\t\turl = g_strdup(line+10);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\teof=TRUE;\n\t\t\t\t\t\t\t\t\t\t\t\tflac_ip.set_info_text(NULL);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t\t\t\t\tredirect=TRUE;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstatus = g_strdup_printf(_(\"Couldn't connect to host %s\\nServer reported: %s\"), chost, status);\n\t\t\t\t\t\t\t\t\tshow_error_message(status);\n\t\t\t\t\t\t\t\t\tg_free(status);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teof = TRUE;\n\t\t\t\t\t\t\tflac_ip.set_info_text(NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (going && !redirect)\n\t\t\t\t{\n\t\t\t\t\tif (http_check_for_data())\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((cnt = flac_http_read_line(line, 1024)) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!cnt)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (!strncmp(line, \"icy-name:\", 9))\n\t\t\t\t\t\t\t\ticy_name = g_strdup(line + 9);\n\t\t\t\t\t\t\telse if (!strncmp(line, \"x-audiocast-name:\", 17))\n\t\t\t\t\t\t\t\ticy_name = g_strdup(line + 17);\n\t\t\t\t\t\t\tif (!strncmp(line, \"icy-metaint:\", 12))\n\t\t\t\t\t\t\t\ticy_metaint = atoi(line + 12);\n\t\t\t\t\t\t\tif (!strncmp(line, \"x-audiocast-udpport:\", 20)) {\n#ifdef DEBUG_UDP\n\t\t\t\t\t\t\t\tfprintf (stderr, \"Server wants udp messages on port %d\\n\", atoi (line + 20));\n#endif\n\t\t\t\t\t\t\t\t/*udp_serverport = atoi (line + 20);*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teof = TRUE;\n\t\t\t\t\t\t\tflac_ip.set_info_text(NULL);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif(redirect)\n\t\t{\n\t\t\tif (output_file)\n\t\t\t{\n\t\t\t\tfclose(output_file);\n\t\t\t\toutput_file = NULL;\n\t\t\t}\n\t\t\tclose(sock);\n\t\t}\n\n\t\tg_free(user);\n\t\tg_free(pass);\n\t\tg_free(host);\n\t\tg_free(filename);\n\t} while(redirect);\n\n\tg_free(url);\n\treturn eof ? -1 : sock;\n}", "path": "xbmc\\cores\\paplayer\\flac-1.2.1\\src\\plugin_xmms\\http.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// froms to s\u0702\u0143NA\n", "func_signal": "void WrdWndClearLineFromTo(int from, int to, int lockflag)", "code": "{\n\tint i;\n\tif ( !w32g_wrd_wnd.active ) return;\n\tif ( from < 0 ) from = 0;\n\tif ( from >= w32g_wrd_wnd.col ) from = w32g_wrd_wnd.col - 1;\n\tif ( to < 0 ) to = 0;\n\tif ( to >= w32g_wrd_wnd.col ) to = w32g_wrd_wnd.col - 1;\n\tif ( to < from ) return;\n\tif ( lockflag ) wrd_wnd_lock();\n\tfor ( i = from; i <= to; i++ ) {\n\t\tmemset(w32g_wrd_wnd.textbuf[i], 0x20, w32g_wrd_wnd.row);\n\t\tmemset(w32g_wrd_wnd.forecolorbuf[i], W32G_WRDWND_BLACK, w32g_wrd_wnd.row);\n\t\tmemset(w32g_wrd_wnd.backcolorbuf[i], W32G_WRDWND_BLACK, w32g_wrd_wnd.row);\n\t\tmemset(w32g_wrd_wnd.attrbuf[i], 0, w32g_wrd_wnd.row);\n\t}\n\tif ( lockflag ) wrd_wnd_unlock();\n\twrd_text_update ( 0, from, w32g_wrd_wnd.row - 1, to, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// from s to s\u0243Rs[B\n", "func_signal": "void WrdWndCopyLine ( int from, int to, int lockflag )", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tWrdWndCopyLineS ( from, from, to, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// PC98 \u0303Agr[g\u0150\u0752\n", "func_signal": "void WrdWndSetAttr98(int attr)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tswitch ( attr ) {\n\tcase 0:\t// Kl\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_WHITE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 1: // nCCg\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 2: // o[eBJC\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 4: // A_[C\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 5: // uN\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 7: // o[X\n\t\t{\n\t\t\tchar tmp = w32g_wrd_wnd.curbackcolor;\n\t\t\tw32g_wrd_wnd.curbackcolor = w32g_wrd_wnd.curforecolor;\n\t\t\tw32g_wrd_wnd.curforecolor = tmp;\n\t\t\tw32g_wrd_wnd.curattr = 0;\n\t\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\t}\n\t\tbreak;\n\tcase 8: // V[Nbg\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 16:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 17:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_RED;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 18:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLUE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 19:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_PURPLE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\t\n\tcase 20:\t\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_GREEN;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 21:\t// F\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_YELLOW;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 22:\t// F\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_LIGHTBLUE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 23: // \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_WHITE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 30:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 31:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_RED;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 32:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_GREEN;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 33:\t// F\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_YELLOW;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 34:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLUE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 35:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_PURPLE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 36:\t// F\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_LIGHTBLUE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 37:\t// \n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_WHITE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\tcase 40:\t// ]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 41:\t// \u0514]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_RED;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 42:\t// \u0394]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_GREEN;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 43:\t// F]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_YELLOW;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 44:\t// \u0094]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLUE;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 45:\t// ]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_PURPLE;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 46:\t// F]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_LIGHTBLUE;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tcase 47:\t// ]\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_WHITE;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tw32g_wrd_wnd.curattr |= W32G_WRDWND_ATTR_REVERSE;\n\t\tbreak;\n\tdefault:\n\t\tw32g_wrd_wnd.curforecolor = W32G_WRDWND_WHITE;\n\t\tw32g_wrd_wnd.curbackcolor = W32G_WRDWND_BLACK;\n\t\tw32g_wrd_wnd.curattr = 0;\n\t\tbreak;\n\t}\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/* Find a good local udp port and bind udp_sock to it, return the port */\n", "func_signal": "static int udp_establish_listener(int *sock)", "code": "{\n\tstruct sockaddr_in sin;\n\tsocklen_t sinlen = sizeof (struct sockaddr_in);\n\t\n#ifdef DEBUG_UDP\n\tfprintf (stderr,\"Establishing udp listener\\n\");\n#endif\n\t\n\tif ((*sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t{\n\t\tg_log(NULL, G_LOG_LEVEL_CRITICAL,\n\t\t      \"udp_establish_listener(): unable to create socket\");\n\t\treturn -1;\n\t}\n\n\tmemset(&sin, 0, sinlen);\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = g_htonl(INADDR_ANY);\n\t\t\t\n\tif (bind(*sock, (struct sockaddr *)&sin, sinlen) < 0)\n\t{\n\t\tg_log(NULL, G_LOG_LEVEL_CRITICAL,\n\t\t      \"udp_establish_listener():  Failed to bind socket to localhost: %s\", strerror(errno));\n\t\tclose(*sock);\n\t\treturn -1;\n\t}\n\tif (fcntl(*sock, F_SETFL, O_NONBLOCK) < 0)\n\t{\n\t\tg_log(NULL, G_LOG_LEVEL_CRITICAL,\n\t\t      \"udp_establish_listener():  Failed to set flags: %s\", strerror(errno));\n\t\tclose(*sock);\n\t\treturn -1;\n\t}\n\n\tmemset(&sin, 0, sinlen);\n\tif (getsockname(*sock, (struct sockaddr *)&sin, &sinlen) < 0)\n\t{\n\t\tg_log(NULL, G_LOG_LEVEL_CRITICAL,\n\t\t      \"udp_establish_listener():  Failed to retrieve socket info: %s\", strerror(errno));\n\t\tclose(*sock);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG_UDP\n\tfprintf (stderr,\"Listening on local %s:%d\\n\", inet_ntoa(sin.sin_addr), g_ntohs(sin.sin_port));\n#endif\n\t\n\treturn g_ntohs(sin.sin_port);\n}", "path": "xbmc\\cores\\paplayer\\flac-1.2.1\\src\\plugin_xmms\\http.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// XN[_EB\n", "func_signal": "void WrdWndScrollDown(int lockflag)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tWrdWndCopyLineS ( 0, w32g_wrd_wnd.col - 1, 1, lockflag );\n\tWrdWndClearLineFromTo ( 0, 0, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// \u028f\n", "func_signal": "void WrdWndClear(int lockflag)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tWrdWndClearLineFromTo ( 0, w32g_wrd_wnd.col - 1, lockflag );\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "// o\n", "func_signal": "void WrdWndPutString(char *str, int lockflag)", "code": "{\n\tif ( !w32g_wrd_wnd.active ) return;\n\tWrdWndPutStringN(str, strlen(str),lockflag);\n}", "path": "xbmc\\cores\\paplayer\\timidity\\interface\\w32g_subwin2.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/* Ok currently the acceleration routine only supports\n   inputs of widths a multiple of 16\n   and heights a multiple 2\n\n   So we just fall back to the C codes for this.\n*/\n", "func_signal": "SwsFunc sws_yuv2rgb_init_altivec (SwsContext *c)", "code": "{\n    if (!(c->flags & SWS_CPU_CAPS_ALTIVEC))\n        return NULL;\n\n    /*\n      and this seems not to matter too much I tried a bunch of\n      videos with abnormal widths and MPlayer crashes elsewhere.\n      mplayer -vo x11 -rawvideo on:w=350:h=240 raw-350x240.eyuv\n      boom with X11 bad match.\n\n    */\n    if ((c->srcW & 0xf) != 0)    return NULL;\n\n    switch (c->srcFormat) {\n    case PIX_FMT_YUV410P:\n    case PIX_FMT_YUV420P:\n    /*case IMGFMT_CLPL:        ??? */\n    case PIX_FMT_GRAY8:\n    case PIX_FMT_NV12:\n    case PIX_FMT_NV21:\n        if ((c->srcH & 0x1) != 0)\n            return NULL;\n\n        switch(c->dstFormat){\n        case PIX_FMT_RGB24:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space RGB24\\n\");\n            return altivec_yuv2_rgb24;\n        case PIX_FMT_BGR24:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space BGR24\\n\");\n            return altivec_yuv2_bgr24;\n        case PIX_FMT_ARGB:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space ARGB\\n\");\n            return altivec_yuv2_argb;\n        case PIX_FMT_ABGR:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space ABGR\\n\");\n            return altivec_yuv2_abgr;\n        case PIX_FMT_RGBA:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space RGBA\\n\");\n            return altivec_yuv2_rgba;\n        case PIX_FMT_BGRA:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space BGRA\\n\");\n            return altivec_yuv2_bgra;\n        default: return NULL;\n        }\n        break;\n\n    case PIX_FMT_UYVY422:\n        switch(c->dstFormat){\n        case PIX_FMT_BGR32:\n            av_log(c, AV_LOG_WARNING, \"ALTIVEC: Color Space UYVY -> RGB32\\n\");\n            return altivec_uyvy_rgb32;\n        default: return NULL;\n        }\n        break;\n\n    }\n    return NULL;\n}", "path": "xbmc\\cores\\dvdplayer\\Codecs\\ffmpeg\\libswscale\\yuv2rgb_altivec.c", "repo_name": "neuros/neuroslink-xbmc", "stars": 5, "license": "other", "language": "c", "size": 115583}
{"docstring": "/* wg_GoLineStart */\n", "func_signal": "static void\nwg_GoLineEnd(void)", "code": "{\n\twg_SetCursorPos(gDst + gBufLen);\n\tgNeedUpdate = 1;\n\tgMoved = 1;\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_HistoryUp */\n", "func_signal": "static void\nwg_HistoryDown(void)", "code": "{\n\tif (gHistory == wg_NoHistory) {\n\t\t/* Not using history. */\n\t\tBEEP(1);\n\t\treturn;\n\t}\n\n\tif (gCurHistLine != NULL) {\n\t\t/* If not null, then the user had already scrolled up and was\n\t\t * editing a line in the history.\n\t\t */\n\t\tgCurHistLine = gCurHistLine->next;\n\t} else {\n\t\t/* Was on original line to edit, but wants to go down one.\n\t\t * We'll wrap around and go to the very first line.\n\t\t */\n\t\tgCurHistLine = gHistory->first;\n\t\tif (gCurHistLine == NULL) {\n\t\t\t/* No lines at all in the history. */\n\t\t\tBEEP(1);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\twg_LineKill();\n\tif (gCurHistLine != NULL) {\n\t\tStrncpy(gDst, gCurHistLine->line, gDstSize);\n\t\tgBufLen = strlen(gDst);\n\t\twg_GoLineEnd();\n\t}\n\t/* Otherwise, was on the last line in the history, but went down from here\n\t * which means we should resume editing a fresh line.\n\t */\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_ForwardKillCh */\n", "func_signal": "static void\nwg_GoLeft(void)", "code": "{\n\tif (gBufPtr > gDst) {\n\t\twg_SetCursorPos(gBufPtr - 1);\t/* Does a --gBufPtr. */\n\t\tgNeedUpdate = 1;\n\t\tgMoved = 1;\n\t} else {\n\t\tBEEP(1);\n\t}\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_LineKill */\n", "func_signal": "static void\nwg_HistoryUp(void)", "code": "{\n\tif (gHistory == wg_NoHistory) {\n\t\t/* Not using history. */\n\t\tBEEP(1);\n\t\treturn;\n\t}\n\n\tif (gCurHistLine != NULL) {\n\t\t/* If not null, then the user had already scrolled up and was\n\t\t * editing a line in the history.\n\t\t */\n\t\tgCurHistLine = gCurHistLine->prev;\n\t} else {\n\t\t/* Was on original line to edit, but wants to go back one. */\n\t\tgCurHistLine = gHistory->last;\n\t\tif (gCurHistLine == NULL) {\n\t\t\t/* No lines at all in the history. */\n\t\t\tBEEP(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twg_LineKill();\n\tif (gCurHistLine != NULL) {\n\t\tStrncpy(gDst, gCurHistLine->line, gDstSize);\n\t\tgBufLen = strlen(gDst);\n\t\twg_GoLineEnd();\n\t}\n\t/* Otherwise, was on the first line in the history, but went \"up\" from here\n\t * which wraps around to the bottom.  This last line is the new line\n\t * to edit.\n\t */\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* ServicePortNumberToName */\n", "func_signal": "void\nInetNtoA(char *dst, struct in_addr *ia, size_t siz)", "code": "{\n#if defined(HAVE_INET_NTOP) && !defined(MACOSX)\n\t/* Mostly to workaround bug in IRIX 6.5's inet_ntoa */\n\t/* For OS X, don't use inet_ntop yet since it was just introduced\n\t * for 10.2.\n\t */\n\tmemset(dst, 0, siz);\n\t(void) inet_ntop(AF_INET, ia, dst, siz - 1);\n#else\n\tchar *cp;\n\tmemset(dst, 0, siz);\n\tcp = inet_ntoa(*ia);\n\tif ((cp != (char *) 0) && (cp != (char *) -1) && (cp[0] != '\\0')) {\n\t\t(void) strncpy(dst, cp, siz - 1);\n\t}\n#endif\n}", "path": "sio\\StrAddr.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/*\n * Copy src to dst, truncating or null-padding to always copy n-1 bytes.\n *\n * This routine differs from strncpy in that it returns a pointer to the end\n * of the buffer, instead of strncat which returns a pointer to the start.\n */\n", "func_signal": "char *\nStrnpcpy(char *const dst, const char *const src, size_t n)", "code": "{\n\tregister char *d;\n\tregister const char *s;\n\tregister char c;\n\tchar *ret;\n\tregister size_t i;\n\n\td = dst;\n\tif (n != 0) {\n\t\ts = src;\n\t\t/* If they specified a maximum of n characters, use n - 1 chars to\n\t\t * hold the copy, and the last character in the array as a NUL.\n\t\t * This is the difference between the regular strncpy routine.\n\t\t * strncpy doesn't guarantee that your new string will have a\n\t\t * NUL terminator, but this routine does.\n\t\t */\n\t\tfor (i=1; i<n; i++) {\n\t\t\tc = *s++;\n\t\t\tif (c == '\\0') {\n\t\t\t\tret = d;\t/* Return ptr to end byte. */\n\t\t\t\t*d++ = c;\n#if (STRNP_ZERO_PAD == 1)\n\t\t\t\t/* Pad with zeros. */\n\t\t\t\tfor (; i<n; i++)\n\t\t\t\t\t*d++ = 0;\n#endif\t/* STRNP_ZERO_PAD */\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*d++ = c;\n\t\t}\n\t\t/* If we get here, then we have a full string, with n - 1 characters,\n\t\t * so now we NUL terminate it and go home.\n\t\t */\n\t\t*d = '\\0';\n\t\treturn (d);\t/* Return ptr to end byte. */\n\t} else {\n\t\t*d = 0;\n\t}\n\treturn (d);\t/* Return ptr to end byte. */\n}", "path": "Strn\\Strnpcpy.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* AddrStrToAddr */\n", "func_signal": "char *\nAddrToAddrStr(char *const dst, size_t dsize, struct sockaddr_in * const saddrp, int dns, const char *fmt)", "code": "{\n\tchar addrName[128];\n\tchar *addrNamePtr;\n\tstruct hostent *hp;\n\tchar str[128];\n\tchar s_name[64];\n\tchar *dlim, *dp;\n\tconst char *cp;\n\n\tif (dsize == 0)\n\t\treturn NULL;\n\tmemset(dst, 0, dsize);\n\n\taddrNamePtr = NULL;\n\tif (dns == 0) {\n\t\tInetNtoA(addrName, &saddrp->sin_addr, sizeof(addrName));\n\t\taddrNamePtr = addrName;\n\t} else {\n#ifdef DNSSEC_LOCAL_VALIDATION\n\t\tval_status_t val_status;\n\t\thp = val_gethostbyaddr(NULL, (const char*)&saddrp->sin_addr, sizeof(struct in_addr), AF_INET, &val_status);\n\t\tif ((hp != NULL) && (!val_istrusted(val_status)))\n\t\t\thp = NULL;\n#else\n\t\thp = gethostbyaddr((gethost_addrptr_t) &saddrp->sin_addr, sizeof(struct in_addr), AF_INET);\n#endif\n\t\tif ((hp != NULL) && (hp->h_name != NULL) && (hp->h_name[0] != '\\0')) {\n\t\t\taddrNamePtr = hp->h_name;\n\t\t} else {\n\t\t\tInetNtoA(addrName, &saddrp->sin_addr, sizeof(addrName));\n\t\t\taddrNamePtr = addrName;\n\t\t}\n\t}\n\tif (fmt == NULL)\n\t\tfmt = \"%h:%p\";\n\tfor (dp = dst, dlim = dp + dsize - 1; ; fmt++) {\n\t\tif (*fmt == '\\0') {\n\t\t\tbreak;\t/* done */\n\t\t} else if (*fmt == '%') {\n\t\t\tfmt++;\n\t\t\tif (*fmt == '%') {\n\t\t\t\tif (dp < dlim)\n\t\t\t\t\t*dp++ = '%';\n\t\t\t} else if (*fmt == 'p') {\n\t\t\t\tsprintf(str, \"%u\", (unsigned int) ntohs(saddrp->sin_port));\n\t\t\t\tfor (cp = str; *cp != '\\0'; cp++)\n\t\t\t\t\tif (dp < dlim)\n\t\t\t\t\t\t*dp++ = *cp;\n\t\t\t\t*dp = '\\0';\n\t\t\t} else if (*fmt == 'h') {\n\t\t\t\tif (addrNamePtr != NULL) {\n\t\t\t\t\tcp = addrNamePtr;\n\t\t\t\t} else {\n\t\t\t\t\tcp = \"unknown\";\n\t\t\t\t}\n\t\t\t\tfor ( ; *cp != '\\0'; cp++)\n\t\t\t\t\tif (dp < dlim)\n\t\t\t\t\t\t*dp++ = *cp;\n\t\t\t\t*dp = '\\0';\n\t\t\t} else if (*fmt == 's') {\n\t\t\t\tcp = s_name;\n\t\t\t\t(void) ServicePortNumberToName(ntohs(saddrp->sin_port), s_name, sizeof(s_name), 0);\n\t\t\t\tfor ( ; *cp != '\\0'; cp++)\n\t\t\t\t\tif (dp < dlim)\n\t\t\t\t\t\t*dp++ = *cp;\n\t\t\t\t/* endservent(); */\n\t\t\t\t*dp = '\\0';\n\t\t\t} else if ((*fmt == 't') || (*fmt == 'u')) {\n\t\t\t\tcp = s_name;\n\t\t\t\t(void) ServicePortNumberToName(ntohs(saddrp->sin_port), s_name, sizeof(s_name), (int) *fmt);\n\t\t\t\tfor ( ; *cp != '\\0'; cp++)\n\t\t\t\t\tif (dp < dlim)\n\t\t\t\t\t\t*dp++ = *cp;\n\t\t\t\t/* endservent(); */\n\t\t\t\t*dp = '\\0';\n\t\t\t} else if (*fmt == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (dp < dlim)\n\t\t\t\t\t*dp++ = *fmt;\n\t\t\t}\n\t\t} else if (dp < dlim) {\n\t\t\t*dp++ = *fmt;\n\t\t}\n\t}\n\t*dp = '\\0';\n\treturn (dst);\n}", "path": "sio\\StrAddr.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_AddCh */\n", "func_signal": "static void\nwg_KillCh(int count)", "code": "{\n\tsize_t n;\n\tchar *limit;\n\n\tif (count > gBufPtr - gDst)\n\t\tcount = (int) (gBufPtr - gDst);\n\tif (count) {\n\t\tlimit = gDst + gBufLen;\n\t\tif (gBufPtr != limit) {\n\t\t\t/* Delete the characters before the character under the\n\t\t\t * cursor, and move everything after it back one.\n\t\t\t */\n\t\t\tn = limit - gBufPtr;\n\t\t\tmemcpy(gBufPtr - count, gBufPtr, n);\n\t\t}\n\t\tgBufLen -= count;\n\t\twg_SetCursorPos(gBufPtr - count);\t/* Does a --gBufPtr. */\n\t\tgNeedUpdate = 1;\n\t\tgChanged = 1;\n\t} else {\n\t\tBEEP(1);\n\t}\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* ServiceNameToPortNumber */\n", "func_signal": "int\nServicePortNumberToName(unsigned short port, char *const dst, const size_t dsize, const int proto)", "code": "{\n#if defined(HAVE_GETSERVBYNAME_R) && (defined(AIX) || defined(TRU64UNIX) || defined(DIGITAL_UNIX))\n\tstruct servent *sp;\n#elif defined(HAVE_GETSERVBYNAME_R) && (defined(LINUX) || defined(SOLARIS) || defined(IRIX) || defined(BSDOS))\n\tstruct servent se, *sp;\n\tchar spbuf[256];\n#else\n\tstruct servent *sp;\n#endif\n\n\tsp = NULL;\n#if defined(HAVE_GETSERVBYPORT_R) && (defined(SOLARIS) || defined(IRIX) || defined(BSDOS))\n\tif ((sp == NULL) && ((proto == 0) || (proto == 't'))) {\n\t\tmemset(spbuf, 0, sizeof(spbuf));\n\t\tsp = getservbyport_r((int) htons(port), \"tcp\", &se, spbuf, sizeof(spbuf));\n\t}\n\tif ((sp == NULL) && ((proto == 0) || (proto == 'u'))) {\n\t\tmemset(spbuf, 0, sizeof(spbuf));\n\t\tsp = getservbyport_r((int) htons(port), \"udp\", &se, spbuf, sizeof(spbuf));\n\t}\n#elif defined(HAVE_GETSERVBYPORT_R) && defined(LINUX)\n\tif ((sp == NULL) && ((proto == 0) || (proto == 't'))) {\n\t\tmemset(spbuf, 0, sizeof(spbuf));\n\t\tif (getservbyport_r((int) htons(port), \"tcp\", &se, spbuf, sizeof(spbuf), &sp) != 0)\n\t\t\tsp = NULL;\n\t}\n\tif ((sp == NULL) && ((proto == 0) || (proto == 'u'))) {\n\t\tmemset(spbuf, 0, sizeof(spbuf));\n\t\tif (getservbyport_r((int) htons(port), \"udp\", &se, spbuf, sizeof(spbuf), &sp) != 0)\n\t\t\tsp = NULL;\n\t}\n#elif defined(HAVE_GETSERVBYPORT_R) && defined(AIX)\n\t{\n\t\tstruct servent_data sed;\n\t\tif ((sp == NULL) && ((proto == 0) || (proto == 't'))) {\n\t\t\tmemset(&sed, 0, sizeof(sed));\n\t\t\tif (getservbyport_r((int) htons(port), \"tcp\", sp, &sed) != 0)\n\t\t\t\tsp = NULL;\n\t\t}\n\t\tif ((sp == NULL) && ((proto == 0) || (proto == 'u'))) {\n\t\t\tmemset(&sed, 0, sizeof(sed));\n\t\t\tif (getservbyport_r((int) htons(port), \"udp\", sp, &sed) != 0)\n\t\t\t\tsp = NULL;\n\t\t}\n\t}\n#else\n\t/* Note: getservbyport is already threadsafe on: HP-UX, Tru64 */\n\tif ((sp == NULL) && ((proto == 0) || (proto == 't'))) {\n\t\tsp = getservbyport((int) htons(port), \"tcp\");\n\t}\n\tif ((sp == NULL) && ((proto == 0) || (proto == 'u'))) {\n\t\tsp = getservbyport((int) htons(port), \"ucp\");\n\t}\n#endif\n\n\tif (sp != NULL) {\n\t\tstrncpy(dst, sp->s_name, dsize);\n\t\tdst[dsize - 1] = '\\0';\n\t\treturn (1);\n\t}\n\n#ifdef HAVE_SNPRINTF\n\tsnprintf(dst, dsize,\n#else\n\tsprintf(dst,\n#endif\n\t\t\"%u\", (unsigned int) port);\n\n\treturn (0);\t/* error */\n}", "path": "sio\\StrAddr.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* HAVE_STRDUP */\n", "func_signal": "void\nStrFree(char **dst)", "code": "{\n\tif (dst != (char **) 0) {\n\t\tif (*dst != NULL) {\n\t\t\tfree((void *) *dst);\n\t\t\t*dst = NULL;\n\t\t}\n\t}\n}", "path": "Strn\\StrFree.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/*\n * Copy src to dst, truncating.\n * Return dst.\n */\n", "func_signal": "char *\nStrncpy_NoZeroPad(char *const dst, const char *const src, const size_t n)", "code": "{\n\tregister char *d;\n\tregister const char *s;\n\tregister size_t i;\n\n\td = dst;\n\t*d = 0;\n\tif (n != 0) {\n\t\ts = src;\n\t\t/* If they specified a maximum of n characters, use n - 1 chars to\n\t\t * hold the copy, and the last character in the array as a NUL.\n\t\t * This is the difference between the regular strncpy routine.\n\t\t * strncpy doesn't guarantee that your new string will have a\n\t\t * NUL terminator, but this routine does.\n\t\t */\n\t\tfor (i=1; i<n; i++) {\n\t\t\tif ((*d++ = *s++) == 0) {\n\t\t\t\treturn dst;\n\t\t\t}\n\t\t}\n\t\t/* If we get here, then we have a full string, with n - 1 characters,\n\t\t * so now we NUL terminate it and go home.\n\t\t */\n\t\t*d = 0;\n\t}\n\treturn (dst);\n}", "path": "Strn\\Strncpy_NoZeroPad.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_SetCursorPos */\n", "func_signal": "static void\nwg_AddCh(int c)", "code": "{\n\tsize_t n;\n\tchar *limit;\n\n\tif (gBufLen < gDstSize) {\n\t\tlimit = gDst + gBufLen;\n\t\tif (gBufPtr == limit) {\n\t\t\t/* Just add a character to the end.  No need to do\n\t\t\t * a memory move for this.\n\t\t\t */\n\t\t\t*gBufPtr = c;\n\t\t\tgBufLen++;\n\t\t\twg_SetCursorPos(gBufPtr + 1);\n\t\t} else {\n\t\t\t/* Have to move characters after the cursor over one\n\t\t\t * position so we can insert a character.\n\t\t\t */\n\t\t\tn = limit - gBufPtr;\n\t\t\tMEMMOVE(gBufPtr + 1, gBufPtr, n);\n\t\t\t*gBufPtr = c;\n\t\t\tgBufLen++;\n\t\t\twg_SetCursorPos(gBufPtr + 1);\n\t\t}\n\t\tgNeedUpdate = 1;\n\t\tgChanged = 1;\n\t} else {\n\t\tBEEP(1);\n\t}\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* GetHomeDir */\n", "func_signal": "void\nGetTmpDir(char *const dst, const size_t size)", "code": "{\n\tstatic const char *envvars[] = {\"TMPDIR\", \"TMP\", \"TEMP\", NULL};\n\tconst char *tdir;\n\tint i;\n\tstruct Stat st;\n\n\tmemset(dst, 0, size);\n\n\tfor (i = 0; envvars[i] != NULL; i++) {\n\t\ttdir = getenv(envvars[i]);\n\t\tif ((tdir == NULL) || (tdir[0] == '\\0'))\n\t\t\tcontinue;\n#if (defined(WIN32) || defined(_WINDOWS)) && !defined(__CYGWIN__)\n#else\n\t\tif (tdir[0] != '/')\n\t\t\tcontinue;\n#endif\n\t\tif ((Stat(tdir, &st) >= 0) && (S_ISDIR(st.st_mode))) {\n\t\t\t(void) Strncpy(dst, tdir, size);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* No suitable environment variable found. */\n#if (defined(WIN32) || defined(_WINDOWS)) && !defined(__CYGWIN__)\n#\tifdef CSIDL_WINDOWS\n\tmemset(dst, 0, size);\n\tGetSpecialDir(dst, size, CSIDL_WINDOWS /* \"C:\\WINDOWS\" */);\n\tif (dst[0] != '\\0') {\n\t\t(void) Strncat(dst, \"\\\\TEMP\", size);\n\t\tif ((Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) {\n\t\t\treturn;\n\t\t}\n\t}\n#\telse\n\t(void) Strncpy(dst, \"C:\\\\WINDOWS\\\\TEMP\", size);\n\tif ((Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) \n\t\treturn;\n\t(void) Strncpy(dst, \"C:\\\\WINNT\\\\TEMP\", size);\n\tif ((Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) \n\t\treturn;\n#\tendif\n\n#\tifdef CSIDL_INTERNET_CACHE\n\tmemset(dst, 0, size);\n\tGetSpecialDir(dst, size, CSIDL_INTERNET_CACHE /* \"Temporary Internet Files\" */);\n\tif ((dst[0] != '\\0') && (Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) \n\t\treturn;\n#\tendif\n\n\t(void) Strncpy(dst, \"\\\\TEMP\", size);\n\tif ((Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) \n\t\treturn;\n#else\n\t(void) Strncpy(dst, \"/tmp\", size);\n\tif ((Stat(dst, &st) >= 0) && (S_ISDIR(st.st_mode))) \n\t\treturn;\n#endif\n\tmemset(dst, 0, size);\t/* return empty string */\n}", "path": "libncftp\\u_gethome.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* InetNtoA */\n", "func_signal": "int\nAddrStrToAddr(const char * const s, struct sockaddr_in * const sa, const int defaultport)", "code": "{\n\tchar portstr[128];\n\tunsigned int ipnum;\n\tunsigned int port;\n\tstruct hostent *hp;\n\tchar *hostcp, *atsign, *colon, *cp, *p2;\n\n\tmemset(sa, 0, sizeof(struct sockaddr_in));\n\tstrncpy(portstr, s, sizeof(portstr));\n\tportstr[sizeof(portstr) - 1] = '\\0';\n\n\tif ((colon = strchr(portstr, ':')) != NULL) {\n\t\t/* Does it look like a URL?  http://host ? */\n\t\tif ((colon[1] == '/') && (colon[2] == '/')) {\n\t\t\t*colon = '\\0';\n\t\t\tport = 0;\n\t\t\thostcp = colon + 3;\n\t\t\tfor (cp = hostcp; *cp != '\\0'; cp++) {\n\t\t\t\tif ((!ISALNUM(*cp)) && (*cp != '.')) {\n\t\t\t\t\t/* http://host:port */\n\t\t\t\t\tif ((*cp == ':') && (isdigit((int) cp[1]))) {\n\t\t\t\t\t\t*cp++ = '\\0';\n\t\t\t\t\t\tp2 = cp;\n\t\t\t\t\t\twhile (isdigit((int) *cp))\n\t\t\t\t\t\t\tcp++;\n\t\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\t\tport = atoi(p2);\n\t\t\t\t\t}\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (port == 0)\n\t\t\t\tport = ServiceNameToPortNumber(portstr, 0);\n\t\t} else {\n\t\t\t/* Look for host.name.domain:port */\n\t\t\t*colon = '\\0';\n\t\t\thostcp = portstr;\n\t\t\tport = (unsigned int) atoi(colon + 1);\n\t\t}\n\t} else if ((atsign = strchr(portstr, '@')) != NULL) {\n\t\t/* Look for port@host.name.domain */\n\t\t*atsign = '\\0';\n\t\thostcp = atsign + 1;\n\t\tport = (unsigned int) atoi(portstr);\n\t} else if (defaultport > 0) {\n\t\t/* Have just host.name.domain, use that w/ default port. */\n\t\tport = (unsigned int) defaultport;\n\t\thostcp = portstr;\n\t} else {\n\t\t/* If defaultport <= 0, they must supply a port number\n\t\t * in the host/port string.\n\t\t */\n\t\terrno = EADDRNOTAVAIL;\n\t\treturn (kAddrStrToAddrMiscErr);\n\t}\n\n\tsa->sin_port = htons((short) port);\n\n\tipnum = inet_addr(hostcp);\n\tif (ipnum != INADDR_NONE) {\n\t\tsa->sin_family = AF_INET;\n\t\tsa->sin_addr.s_addr = ipnum;\n\t} else {\n#ifdef DNSSEC_LOCAL_VALIDATION\n\t\tval_status_t val_status;\n\t\terrno = 0;\n\t\thp = val_gethostbyname(NULL,hostcp,&val_status);\n\t\tif ((hp != NULL) && (!val_istrusted(val_status)))\n\t\t\thp = NULL;\n#else\n\t\terrno = 0;\n\t\thp = gethostbyname(hostcp);\n#endif\n\t\tif (hp == NULL) {\n\t\t\tif (errno == 0)\n\t\t\t\terrno = ENOENT;\n\t\t\treturn (kAddrStrToAddrBadHost);\n\t\t}\n\t\tsa->sin_family = hp->h_addrtype;\n\t\tmemcpy(&sa->sin_addr.s_addr, hp->h_addr_list[0],\n\t\t\t(size_t) hp->h_length);\n\t}\n\treturn (0);\n}", "path": "sio\\StrAddr.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_HistoryDown */\n", "func_signal": "static void\nwg_Update(void)", "code": "{\n\tchar *lastCharPtr;\n\tchar *cp;\n\n\twmove(gW, gSy, gSx);\n\tlastCharPtr = gDst + gBufLen;\n\t*lastCharPtr = '\\0';\n\tif (gEchoMode == wg_RegularEcho) {\n\t\tfor (cp = gWinStartPtr; cp < lastCharPtr; cp++) {\n\t\t\tif (cp > gWinEndPtr)\n\t\t\t\tgoto xx;\n\t\t\twaddch(gW, (unsigned char) *cp);\n\t\t}\n\t} else if (gEchoMode == wg_BulletEcho) {\n\t\tfor (cp = gWinStartPtr; cp < lastCharPtr; cp++) {\n\t\t\tif (cp > gWinEndPtr)\n\t\t\t\tgoto xx;\n\t\t\twaddch(gW, wg_Bullet);\n\t\t}\n\t} else /* if (gEchoMode == wg_NoEcho) */ {\n\t\tfor (cp = gWinStartPtr; cp < lastCharPtr; cp++) {\n\t\t\tif (cp > gWinEndPtr)\n\t\t\t\tgoto xx;\n\t\t\twaddch(gW, ' ');\n\t\t}\n\t}\n\n\t/* Rest of display window is empty, so write out spaces. */\n\tfor ( ; cp <= gWinEndPtr; cp++)\n\t\twaddch(gW, ' ');\nxx:\n\twmove(gW, gSy, gSx + (int) (gBufPtr - gWinStartPtr));\n\twrefresh(gW);\n\tgNeedUpdate = 0;\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* SSendto */\n", "func_signal": "int\nSendtoByName(int sfd, const char *const buf, size_t size, const char *const toAddrStr)", "code": "{\n\tint result;\n\tstruct sockaddr_in toAddr;\n\tDECL_SIGPIPE_VARS\n\t\n\tif ((buf == NULL) || (size == 0) || (toAddrStr == NULL)) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\t\n\n\tif ((result = AddrStrToAddr(toAddrStr, &toAddr, -1)) < 0) {\n\t\treturn (result);\n\t}\n\n\tIGNORE_SIGPIPE\n\tdo {\n\t\tresult = (int) sendto(sfd, buf, (send_size_t) size, 0,\n\t\t\t\t(struct sockaddr *) &toAddr,\n\t\t\t\t(sockaddr_size_t) sizeof(struct sockaddr_in));\n\t} while ((result < 0) && (errno == EINTR));\n\tRESTORE_SIGPIPE\n\n\treturn (result);\n}", "path": "sio\\SSendtoByName.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* AddrToAddrStr */\n", "func_signal": "char *\nAddrStrToIPStr(char *const dst, size_t dsize, const char *const src, const int defaultport)", "code": "{\n\tint rc;\n\tstruct sockaddr_in sa;\n\n\tif (dsize == 0)\n\t\treturn NULL;\n\tmemset(dst, 0, dsize);\n\n\trc = AddrStrToAddr(src, &sa, (defaultport <= 0) ? 21 : defaultport);\n\tif (rc < 0)\n\t\treturn (NULL);\n\n\tAddrToAddrStr(dst, dsize, &sa, 0, (defaultport <= 0) ? \"%h\" : \"%h:%p\");\n\treturn (dst);\n}", "path": "sio\\StrAddr.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_KillWord */\n", "func_signal": "static void\nwg_ForwardKillCh(void)", "code": "{\n\tsize_t n;\n\tchar *limit;\n\n\tif (gBufLen != 0) {\n\t\tlimit = gDst + gBufLen;\n\t\tif (gBufPtr == limit) {\n\t\t\t/* Nothing in front to delete. */\n\t\t\tBEEP(1);\n\t\t} else {\n\t\t\tn = limit - gBufPtr - 1;\n\t\t\tmemcpy(gBufPtr, gBufPtr + 1, n);\n\t\t\t--gBufLen;\n\t\t\tgNeedUpdate = 1;\n\t\t\tgChanged = 1;\n\t\t}\n\t} else {\n\t\tBEEP(1);\n\t}\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_GoRight */\n", "func_signal": "static void\nwg_GoLineStart(void)", "code": "{\n\twg_SetCursorPos(gDst);\n\tgNeedUpdate = 1;\n\tgMoved = 1;\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* wg_GoLineEnd */\n", "func_signal": "static void\nwg_LineKill(void)", "code": "{\n\tgBufPtr = gDst;\n\tgWinStartPtr = gBufPtr;\n\tgWinEndPtr = gWinStartPtr + gWindowWidth - 1;\n\tgBufPtr[gDstSize] = '\\0';\n\tgBufLen = 0;\n\tgNeedUpdate = 1;\n\n\t/* Reset this so it acts as a new line.  We want them to be able to\n\t * hit ^D until they do something with this line.\n\t */\n\tgMoved = 0;\n\n\t/* We now have an empty string.  If we originally had something in the\n\t * buffer, then mark it as changed since we just erased that.\n\t */\n\tgChanged = gHadStartingString;\n}", "path": "vis\\wgets.c", "repo_name": "avances123/ncftp-3.2.4", "stars": 5, "license": "None", "language": "c", "size": 728}
{"docstring": "/* Might be called on another thread */\n", "func_signal": "static void\nasync_call_cancelled_cb (GCancellable *cancellable,\n\t\t\t gpointer _data)", "code": "{\n  AsyncCallCancelData *data = _data;\n  DBusMessage *cancel_message;\n\n  /* Send cancellation message, this just queues it, sending\n   * will happen in mainloop */\n  cancel_message = dbus_message_new_method_call (NULL,\n\t\t\t\t\t\t G_VFS_DBUS_DAEMON_PATH,\n\t\t\t\t\t\t G_VFS_DBUS_DAEMON_INTERFACE,\n\t\t\t\t\t\t G_VFS_DBUS_OP_CANCEL);\n  if (cancel_message != NULL)\n    {\n      if (dbus_message_append_args (cancel_message,\n\t\t\t\t    DBUS_TYPE_UINT32, &data->serial,\n\t\t\t\t    DBUS_TYPE_INVALID))\n\tdbus_connection_send (data->connection,\n\t\t\t      cancel_message, NULL);\n      dbus_message_unref (cancel_message);\n    }\n}", "path": "client\\gvfsdaemondbus.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static void\ng_gdu_drive_drive_iface_init (GDriveIface *iface)", "code": "{\n  iface->get_name = g_gdu_drive_get_name;\n  iface->get_icon = g_gdu_drive_get_icon;\n  iface->has_volumes = g_gdu_drive_has_volumes;\n  iface->get_volumes = g_gdu_drive_get_volumes;\n  iface->is_media_removable = g_gdu_drive_is_media_removable;\n  iface->has_media = g_gdu_drive_has_media;\n  iface->is_media_check_automatic = g_gdu_drive_is_media_check_automatic;\n  iface->can_eject = g_gdu_drive_can_eject;\n  iface->can_poll_for_media = g_gdu_drive_can_poll_for_media;\n  iface->eject = g_gdu_drive_eject;\n  iface->eject_finish = g_gdu_drive_eject_finish;\n  iface->eject_with_operation = g_gdu_drive_eject_with_operation;\n  iface->eject_with_operation_finish = g_gdu_drive_eject_with_operation_finish;\n  iface->poll_for_media = g_gdu_drive_poll_for_media;\n  iface->poll_for_media_finish = g_gdu_drive_poll_for_media_finish;\n  iface->get_identifier = g_gdu_drive_get_identifier;\n  iface->enumerate_identifiers = g_gdu_drive_enumerate_identifiers;\n\n  iface->get_start_stop_type = g_gdu_drive_get_start_stop_type;\n  iface->can_start = g_gdu_drive_can_start;\n  iface->can_start_degraded = g_gdu_drive_can_start_degraded;\n  iface->can_stop = g_gdu_drive_can_stop;\n  iface->start = g_gdu_drive_start;\n  iface->start_finish = g_gdu_drive_start_finish;\n  iface->stop = g_gdu_drive_stop;\n  iface->stop_finish = g_gdu_drive_stop_finish;\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Used to detect broken listings from\n * old Nokia 3650s */\n", "func_signal": "static gboolean\n_is_nokia_3650 (const char *bdaddr)", "code": "{\n  if (!bdaddr)\n    return FALSE;\n\n  /* Don't ask, Nokia seem to use a Bluetooth\n   * HCI from Murata */\n  return g_str_has_prefix(bdaddr, \"00:60:57\");\n}", "path": "daemon\\gvfsbackendobexftp.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static void\nstop_cb (GduDevice *device,\n         GError    *error,\n         gpointer   user_data)", "code": "{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_error_free (error);\n    }\n\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static void\ndetach_after_eject_cb (GduDevice *device,\n                       GError    *error,\n                       gpointer   user_data)", "code": "{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n\n  /* Don't return an error here - this is because some devices, such as\n   * the Kindle, can do Eject() but not Detach() e.g. the STOP UNIT\n   * command or any other part of Detach() may fail.\n   */\n  if (error != NULL)\n    {\n      g_warning (\"Detach() after Eject() failed with: %s\", error->message);\n      g_error_free (error);\n    }\n\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static char *\ng_gdu_drive_get_identifier (GDrive              *_drive,\n                            const char          *kind)", "code": "{\n  GGduDrive *drive = G_GDU_DRIVE (_drive);\n  gchar *id;\n\n  id = NULL;\n\n  if (drive->device_file != NULL)\n    {\n      if (strcmp (kind, G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE) == 0)\n        id = g_strdup (drive->device_file);\n    }\n\n  return id;\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/**\n * _g_simple_async_result_complete_with_cancellable:\n * @result: the result\n * @cancellable: a cancellable to check\n *\n * If @cancellable is cancelled, sets @result into the cancelled error\n * state. Then calls g_simple_async_result_complete().\n * This function is useful to ensure that @result is properly set into\n * an error state on cancellation.\n **/\n", "func_signal": "void\n_g_simple_async_result_complete_with_cancellable (GSimpleAsyncResult *result,\n                                                  GCancellable       *cancellable)", "code": "{\n  if (cancellable &&\n      g_cancellable_is_cancelled (cancellable))\n    g_simple_async_result_set_error (result,\n                                     G_IO_ERROR,\n                                     G_IO_ERROR_CANCELLED,\n                                     \"%s\", _(\"Operation was cancelled\"));\n\n  g_simple_async_result_complete (result);\n}", "path": "client\\gvfsdaemondbus.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Might be called on an i/o thread */\n", "func_signal": "static void\nsend_reply (GVfsJob *job)", "code": "{\n  GVfsJobMount *op_job = G_VFS_JOB_MOUNT (job);\n\n  g_debug (\"send_reply, failed: %d\\n\", job->failed);\n  \n  if (job->failed)\n    mount_failed (op_job, job->error);\n  else\n    g_vfs_backend_register_mount (op_job->backend,\n\t\t\t\t  register_mount_callback,\n\t\t\t\t  job);\n}", "path": "daemon\\gvfsjobmount.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* the callback from dbus -> main thread */\n", "func_signal": "static void\nask_question_reply (DBusMessage *reply,\n\t\t    GError      *error,\n\t\t    gpointer     _data)", "code": "{\n  GSimpleAsyncResult *result;\n  AskQuestionData *data;\n  dbus_bool_t handled, aborted;\n  guint32 choice;\n  DBusMessageIter iter;\n\n  result = G_SIMPLE_ASYNC_RESULT (_data);\n  handled = TRUE;\n  \n  data = g_new0 (AskQuestionData, 1);\n  g_simple_async_result_set_op_res_gpointer (result, data, g_free);\n\n  if (reply == NULL)\n    {\n      data->aborted = TRUE;\n    }\n  else\n    {\n      dbus_message_iter_init (reply, &iter);\n      if (!_g_dbus_message_iter_get_args (&iter, NULL,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &handled,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &aborted,\n\t\t\t\t\t  DBUS_TYPE_UINT32, &choice,\n\t\t\t\t\t  0))\n\tdata->aborted = TRUE;\n      else\n\t{\n\t  data->aborted = aborted;\n\t  data->choice = choice;\n\t}\n    }\n\n  if (handled == FALSE)\n    {\n      g_simple_async_result_set_error (result, G_IO_ERROR, G_IO_ERROR_FAILED, \"Internal Error\");\n    }\n\n  g_simple_async_result_complete (result);\n}", "path": "common\\gmountsource.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/*******************************************************************\n *                Caching of async connections                     *\n *******************************************************************/\n", "func_signal": "static DBusConnection *\nget_connection_for_async (const char *dbus_id)", "code": "{\n  DBusConnection *connection;\n\n  connection = NULL;\n  G_LOCK (async_map);\n  if (async_map != NULL)\n    connection = g_hash_table_lookup (async_map, dbus_id);\n  if (connection)\n    dbus_connection_ref (connection);\n  G_UNLOCK (async_map);\n  \n  return connection;\n}", "path": "client\\gvfsdaemondbus.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* the callback from dbus -> main thread */\n", "func_signal": "static void\nshow_processes_reply (DBusMessage *reply,\n                      GError      *error,\n                      gpointer     _data)", "code": "{\n  GSimpleAsyncResult *result;\n  ShowProcessesData *data;\n  dbus_bool_t handled, aborted;\n  guint32 choice;\n  DBusMessageIter iter;\n\n  result = G_SIMPLE_ASYNC_RESULT (_data);\n  handled = TRUE;\n\n  data = g_new0 (ShowProcessesData, 1);\n  g_simple_async_result_set_op_res_gpointer (result, data, g_free);\n\n  if (reply == NULL)\n    {\n      data->aborted = TRUE;\n    }\n  else\n    {\n      dbus_message_iter_init (reply, &iter);\n      if (!_g_dbus_message_iter_get_args (&iter, NULL,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &handled,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &aborted,\n\t\t\t\t\t  DBUS_TYPE_UINT32, &choice,\n\t\t\t\t\t  0))\n\tdata->aborted = TRUE;\n      else\n\t{\n\t  data->aborted = aborted;\n\t  data->choice = choice;\n\t}\n    }\n\n  if (handled == FALSE)\n    {\n      g_simple_async_result_set_error (result, G_IO_ERROR, G_IO_ERROR_FAILED, \"Internal Error\");\n    }\n\n  g_simple_async_result_complete (result);\n}", "path": "common\\gmountsource.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ==================================================================== */\n", "func_signal": "int ParseFTPList(const char *line, struct list_state *state,\n                 struct list_result *result )", "code": "{\n  unsigned int carry_buf_len; /* copy of state->carry_buf_len */\n  unsigned int linelen, pos;\n  const char *p;\n\n  if (!line || !state || !result)\n    return 0;\n\n  memset( result, 0, sizeof(*result) );\n  if (state->magic != ((void *)ParseFTPList))\n  {\n    memset( state, 0, sizeof(*state) );\n    state->magic = ((void *)ParseFTPList);\n  }\n  state->numlines++;\n\n  /* carry buffer is only valid from one line to the next */\n  carry_buf_len = state->carry_buf_len;\n  state->carry_buf_len = 0;\n\n  linelen = 0;\n\n  /* strip leading whitespace */\n  while (*line == ' ' || *line == '\\t')\n    line++;\n    \n  /* line is terminated at first '\\0' or '\\n' */\n  p = line;\n  while (*p && *p != '\\n')\n    p++;\n  linelen = p - line;\n\n  if (linelen > 0 && *p == '\\n' && *(p-1) == '\\r')\n    linelen--;\n\n  /* DON'T strip trailing whitespace. */\n\n  if (linelen > 0)\n  {\n    static const char *month_names = \"JanFebMarAprMayJunJulAugSepOctNovDec\";\n    const char *tokens[16]; /* 16 is more than enough */\n    unsigned int toklen[(sizeof(tokens)/sizeof(tokens[0]))];\n    unsigned int linelen_sans_wsp;  // line length sans whitespace\n    unsigned int numtoks = 0;\n    unsigned int tokmarker = 0; /* extra info for lstyle handler */\n    unsigned int month_num = 0;\n    char tbuf[4];\n    int lstyle = 0;\n\n    if (carry_buf_len) /* VMS long filename carryover buffer */\n    {\n      tokens[0] = state->carry_buf;\n      toklen[0] = carry_buf_len;\n      numtoks++;\n    }\n\n    pos = 0;\n    while (pos < linelen && numtoks < (sizeof(tokens)/sizeof(tokens[0])) )\n    {\n      while (pos < linelen && \n            (line[pos] == ' ' || line[pos] == '\\t' || line[pos] == '\\r'))\n        pos++;\n      if (pos < linelen)\n      {\n        tokens[numtoks] = &line[pos];\n        while (pos < linelen && \n           (line[pos] != ' ' && line[pos] != '\\t' && line[pos] != '\\r'))\n          pos++;\n        if (tokens[numtoks] != &line[pos])\n        {\n          toklen[numtoks] = (&line[pos] - tokens[numtoks]);\n          numtoks++;  \n        }\n      }\n    }    \n\n    linelen_sans_wsp = &(tokens[numtoks-1][toklen[numtoks-1]]) - tokens[0];\n    if (numtoks == (sizeof(tokens)/sizeof(tokens[0])) )\n    {\n      pos = linelen;\n      while (pos > 0 && (line[pos-1] == ' ' || line[pos-1] == '\\t'))\n        pos--;\n      linelen_sans_wsp = pos;\n    }\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_EPLF)\n    /* EPLF handling must come somewhere before /bin/dls handling. */\n    if (!lstyle && (!state->lstyle || state->lstyle == 'E'))\n    {\n      if (*line == '+' && linelen > 4 && numtoks >= 2)\n      {\n        pos = 1;\n        while (pos < (linelen-1))\n        {\n          p = &line[pos++];\n          if (*p == '/') \n            result->fe_type = 'd'; /* its a dir */\n          else if (*p == 'r')\n            result->fe_type = 'f'; /* its a file */\n          else if (*p == 'm')\n          {\n            if (isdigit(line[pos]))\n            {\n              while (pos < linelen && isdigit(line[pos]))\n                pos++;\n              if (pos < linelen && line[pos] == ',')\n              {\n                guint64 seconds;\n\t\ttime_t t;\n                sscanf(p+1, \"%\"G_GUINT64_FORMAT, &seconds);\n\t\tt = seconds;\n\t\tresult->fe_time = *localtime (&t);\n              }\n            }\n          }\n          else if (*p == 's')\n          {\n            if (isdigit(line[pos]))\n            {\n              while (pos < linelen && isdigit(line[pos]))\n                pos++;\n              if (pos < linelen && line[pos] == ',' &&\n                 ((&line[pos]) - (p+1)) < (int) (sizeof(result->fe_size)-1) )\n              {\n                memcpy( result->fe_size, p+1, (unsigned)(&line[pos] - (p+1)) );\n                result->fe_size[(&line[pos] - (p+1))] = '\\0';\n              }\n            }\n          }\n          else if (isalpha(*p)) /* 'i'/'up' or unknown \"fact\" (property) */\n          {\n            while (pos < linelen && *++p != ',')\n              pos++;\n          }\n          else if (*p != '\\t' || (p+1) != tokens[1])\n          {\n            break; /* its not EPLF after all */\n          }\n          else\n          {\n            state->parsed_one = 1;\n            state->lstyle = lstyle = 'E';\n\n            p = &(line[linelen_sans_wsp]);\n            result->fe_fname = tokens[1];\n            result->fe_fnlen = p - tokens[1];\n\n            if (!result->fe_type) /* access denied */\n            {\n              result->fe_type = 'f'; /* is assuming 'f'ile correct? */\n              return '?';            /* NO! junk it. */\n            }\n            return result->fe_type;\n          }\n          if (pos >= (linelen-1) || line[pos] != ',')\n            break;\n          pos++;\n        } /* while (pos < linelen) */\n        memset( result, 0, sizeof(*result) );\n      } /* if (*line == '+' && linelen > 4 && numtoks >= 2) */\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'E')) */\n#endif /* SUPPORT_EPLF */\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_VMS)\n    if (!lstyle && (!state->lstyle || state->lstyle == 'V'))\n    {                          /* try VMS Multinet/UCX/CMS server */\n      /*\n       * Legal characters in a VMS file/dir spec are [A-Z0-9$.-_~].\n       * '$' cannot begin a filename and `-' cannot be used as the first \n       * or last character. '.' is only valid as a directory separator \n       * and <file>.<type> separator. A canonical filename spec might look \n       * like this: DISK$VOL:[DIR1.DIR2.DIR3]FILE.TYPE;123\n       * All VMS FTP servers LIST in uppercase.\n       *\n       * We need to be picky about this in order to support\n       * multi-line listings correctly.\n      */\n      if (!state->parsed_one &&\n          (numtoks == 1 || (numtoks == 2 && toklen[0] == 9 &&\n                            memcmp(tokens[0], \"Directory\", 9)==0 )))\n      {\n        /* If no dirstyle has been detected yet, and this line is a \n         * VMS list's dirname, then turn on VMS dirstyle.\n         * eg \"ACA:[ANONYMOUS]\", \"DISK$FTP:[ANONYMOUS]\", \"SYS$ANONFTP:\" \n        */\n        p = tokens[0];\n        pos = toklen[0];\n        if (numtoks == 2)\n        {\n          p = tokens[1];\n          pos = toklen[1];\n        }\n        pos--;\n        if (pos >= 3)\n        {\n          while (pos > 0 && p[pos] != '[')\n          {\n            pos--;\n            if (p[pos] == '-' || p[pos] == '$')\n            {\n              if (pos == 0 || p[pos-1] == '[' || p[pos-1] == '.' ||\n                  (p[pos] == '-' && (p[pos+1] == ']' || p[pos+1] == '.')))\n                break;\n            }\n            else if (p[pos] != '.' && p[pos] != '~' && \n                     !isdigit(p[pos]) && !isalpha(p[pos]))\n              break;\n            else if (isalpha(p[pos]) && p[pos] != toupper(p[pos]))\n              break;\n          }\n          if (pos > 0)\n          {\n            pos--;\n            if (p[pos] != ':' || p[pos+1] != '[')\n              pos = 0;\n          }\n        }\n        if (pos > 0 && p[pos] == ':')\n        {\n          while (pos > 0)\n          {\n            pos--;\n            if (p[pos] != '$' && p[pos] != '_' && p[pos] != '-' &&\n                p[pos] != '~' && !isdigit(p[pos]) && !isalpha(p[pos]))\n              break;\n            else if (isalpha(p[pos]) && p[pos] != toupper(p[pos]))\n              break;\n          }\n          if (pos == 0)\n          {  \n            state->lstyle = 'V';\n            return '?'; /* its junk */\n          }\n        }\n        /* fallthrough */ \n      }\n      else if ((tokens[0][toklen[0]-1]) != ';')\n      {\n        if (numtoks == 1 && (state->lstyle == 'V' && !carry_buf_len))\n          lstyle = 'V';\n        else if (numtoks < 4)\n          ;\n        else if (toklen[1] >= 10 && memcmp(tokens[1], \"%RMS-E-PRV\", 10) == 0)\n          lstyle = 'V';\n        else if ((&line[linelen] - tokens[1]) >= 22 &&\n                  memcmp(tokens[1], \"insufficient privilege\", 22) == 0)\n          lstyle = 'V';\n        else if (numtoks != 4 && numtoks != 6)\n          ;\n        else if (numtoks == 6 && (\n                 toklen[5] < 4 || *tokens[5] != '(' ||        /* perms */\n                           (tokens[5][toklen[5]-1]) != ')'  ))\n          ;\n        else if (  (toklen[2] == 10 || toklen[2] == 11) &&      \n                        (tokens[2][toklen[2]-5]) == '-' &&\n                        (tokens[2][toklen[2]-9]) == '-' &&\n        (((toklen[3]==4 || toklen[3]==5 || toklen[3]==7 || toklen[3]==8) &&\n                        (tokens[3][toklen[3]-3]) == ':' ) ||\n         ((toklen[3]==10 || toklen[3]==11 ) &&\n                        (tokens[3][toklen[3]-3]) == '.' )\n        ) &&  /* time in [H]H:MM[:SS[.CC]] format */\n                                    isdigit(*tokens[1]) && /* size */\n                                    isdigit(*tokens[2]) && /* date */\n                                    isdigit(*tokens[3])    /* time */\n                )\n        {\n          lstyle = 'V';\n        }\n        if (lstyle == 'V')\n        {\n          /* \n          * MultiNet FTP:\n          *   LOGIN.COM;2                 1   4-NOV-1994 04:09 [ANONYMOUS] (RWE,RWE,,)\n          *   PUB.DIR;1                   1  27-JAN-1994 14:46 [ANONYMOUS] (RWE,RWE,RE,RWE)\n          *   README.FTP;1        %RMS-E-PRV, insufficient privilege or file protection violation\n          *   ROUSSOS.DIR;1               1  27-JAN-1994 14:48 [CS,ROUSSOS] (RWE,RWE,RE,R)\n          *   S67-50903.JPG;1           328  22-SEP-1998 16:19 [ANONYMOUS] (RWED,RWED,,)\n          * UCX FTP: \n          *   CII-MANUAL.TEX;1  213/216  29-JAN-1996 03:33:12  [ANONYMOU,ANONYMOUS] (RWED,RWED,,)\n          * CMU/VMS-IP FTP\n          *   [VMSSERV.FILES]ALARM.DIR;1 1/3 5-MAR-1993 18:09\n          * TCPware FTP\n          *   FOO.BAR;1 4 5-MAR-1993 18:09:01.12\n          * Long filename example:\n          *   THIS-IS-A-LONG-VMS-FILENAME.AND-THIS-IS-A-LONG-VMS-FILETYPE\\r\\n\n          *                    213[/nnn]  29-JAN-1996 03:33[:nn]  [ANONYMOU,ANONYMOUS] (RWED,RWED,,)\n          */\n          tokmarker = 0;\n          p = tokens[0];\n          pos = 0;\n          if (*p == '[' && toklen[0] >= 4) /* CMU style */\n          {\n            if (p[1] != ']') \n            {\n              p++;\n              pos++;\n            }\n            while (lstyle && pos < toklen[0] && *p != ']')\n            {\n              if (*p != '$' && *p != '.' && *p != '_' && *p != '-' &&\n                  *p != '~' && !isdigit(*p) && !isalpha(*p))              \n                lstyle = 0;\n              pos++;\n              p++;\n            }\n            if (lstyle && pos < (toklen[0]-1) && *p == ']')\n            {\n              pos++;\n              p++;\n              tokmarker = pos; /* length of leading \"[DIR1.DIR2.etc]\" */\n            }\n          }\n          while (lstyle && pos < toklen[0] && *p != ';')\n          {\n            if (*p != '$' && *p != '.' && *p != '_' && *p != '-' &&\n                *p != '~' && !isdigit(*p) && !isalpha(*p))\n              lstyle = 0;\n            else if (isalpha(*p) && *p != toupper(*p))\n              lstyle = 0;\n            p++;\n            pos++;\n          }\n          if (lstyle && *p == ';')\n          {\n            if (pos == 0 || pos == (toklen[0]-1))\n              lstyle = 0;\n            for (pos++;lstyle && pos < toklen[0];pos++)\n            {\n              if (!isdigit(tokens[0][pos]))\n                lstyle = 0;\n            }\n          }\n          pos = (p - tokens[0]); /* => fnlength sans \";####\" */\n          pos -= tokmarker;      /* => fnlength sans \"[DIR1.DIR2.etc]\" */\n          p = &(tokens[0][tokmarker]); /* offset of basename */\n\n          if (!lstyle || pos > 80) /* VMS filenames can't be longer than that */\n          {\n            lstyle = 0;\n          }\n          else if (numtoks == 1)\n          { \n            /* if VMS has been detected and there is only one token and that \n             * token was a VMS filename then this is a multiline VMS LIST entry.\n            */\n            if (pos >= (sizeof(state->carry_buf)-1))\n              pos = (sizeof(state->carry_buf)-1); /* shouldn't happen */\n            memcpy( state->carry_buf, p, pos );\n            state->carry_buf_len = pos;\n            return '?'; /* tell caller to treat as junk */\n          }\n          else if (isdigit(*tokens[1])) /* not no-privs message */\n          {\n            for (pos = 0; lstyle && pos < (toklen[1]); pos++)\n            {\n              if (!isdigit((tokens[1][pos])) && (tokens[1][pos]) != '/')\n                lstyle = 0;\n            }\n            if (lstyle && numtoks > 4) /* Multinet or UCX but not CMU */\n            {\n              for (pos = 1; lstyle && pos < (toklen[5]-1); pos++)\n              {\n                p = &(tokens[5][pos]);\n                if (*p!='R' && *p!='W' && *p!='E' && *p!='D' && *p!=',')\n                  lstyle = 0;\n              }\n            }\n          }\n        } /* passed initial tests */\n      } /* else if ((tokens[0][toklen[0]-1]) != ';') */    \n\n      if (lstyle == 'V')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        if (isdigit(*tokens[1]))  /* not permission denied etc */\n        {\n          /* strip leading directory name */\n          if (*tokens[0] == '[') /* CMU server */\n          {\n            pos = toklen[0]-1;\n            p = tokens[0]+1;\n            while (*p != ']')\n            {\n              p++;\n              pos--;\n            }\n            toklen[0] = --pos;\n            tokens[0] = ++p;\n          }\n          pos = 0;\n          while (pos < toklen[0] && (tokens[0][pos]) != ';')\n            pos++;\n       \n          result->fe_cinfs = 1;\n          result->fe_type = 'f';\n          result->fe_fname = tokens[0];\n          result->fe_fnlen = pos;\n\n          if (pos > 4)\n          {\n            p = &(tokens[0][pos-4]);\n            if (p[0] == '.' && p[1] == 'D' && p[2] == 'I' && p[3] == 'R')\n            {\n              result->fe_fnlen -= 4;\n              result->fe_type = 'd';\n            }\n          }\n\n          if (result->fe_type != 'd')\n          {\n            /* #### or used/allocated form. If used/allocated form, then\n             * 'used' is the size in bytes if and only if 'used'<=allocated.\n             * If 'used' is size in bytes then it can be > 2^32\n             * If 'used' is not size in bytes then it is size in blocks.\n            */\n            pos = 0;\n            while (pos < toklen[1] && (tokens[1][pos]) != '/')\n              pos++;\n            \n/*\n * I've never seen size come back in bytes, its always in blocks, and \n * the following test fails. So, always perform the \"size in blocks\".\n * I'm leaving the \"size in bytes\" code if'd out in case we ever need\n * to re-instate it.\n*/\n#if 0\n            if (pos < toklen[1] && ( (pos<<1) > (toklen[1]-1) ||\n                 (strtoul(tokens[1], (char **)0, 10) > \n                  strtoul(tokens[1]+pos+1, (char **)0, 10))        ))\n            {                                   /* size is in bytes */\n              if (pos > (sizeof(result->fe_size)-1))\n                pos = sizeof(result->fe_size)-1;\n              memcpy( result->fe_size, tokens[1], pos );\n              result->fe_size[pos] = '\\0';\n            }\n            else /* size is in blocks */\n#endif\n            {\n              /* size requires multiplication by blocksize. \n               *\n               * We could assume blocksize is 512 (like Lynx does) and\n               * shift by 9, but that might not be right. Even if it \n               * were, doing that wouldn't reflect what the file's \n               * real size was. The sanest thing to do is not use the\n               * LISTing's filesize, so we won't (like ftpmirror).\n               *\n               * ulltoa(((unsigned long long)fsz)<<9, result->fe_size, 10);\n               *\n               * A block is always 512 bytes on OpenVMS, compute size.\n               * So its rounded up to the next block, so what, its better\n               * than not showing the size at all.\n               * A block is always 512 bytes on OpenVMS, compute size.\n               * So its rounded up to the next block, so what, its better\n               * than not showing the size at all.\n              */\n              guint64 fsz;\n              fsz = g_ascii_strtoull (tokens[1], (char **)0, 10);\n\t      fsz *= 512;\n              g_snprintf(result->fe_size, sizeof(result->fe_size), \n                          \"%\"G_GUINT64_FORMAT, fsz);\n            } \n\n          } /* if (result->fe_type != 'd') */\n\n          p = tokens[2] + 2;\n          if (*p == '-')\n            p++;\n          tbuf[0] = p[0];\n          tbuf[1] = tolower(p[1]);\n          tbuf[2] = tolower(p[2]);\n          month_num = 0;\n          for (pos = 0; pos < (12*3); pos+=3)\n          {\n            if (tbuf[0] == month_names[pos+0] && \n                tbuf[1] == month_names[pos+1] && \n                tbuf[2] == month_names[pos+2])\n              break;\n            month_num++;\n          }\n          if (month_num >= 12)\n            month_num = 0;\n          result->fe_time.tm_mon = month_num;\n          result->fe_time.tm_mday = atoi(tokens[2]);\n          result->fe_time.tm_year = atoi(p+4); // NSPR wants year as XXXX\n\n          p = tokens[3] + 2;\n          if (*p == ':')\n            p++;\n          if (p[2] == ':')\n            result->fe_time.tm_sec = atoi(p+3);\n          result->fe_time.tm_hour = atoi(tokens[3]);\n          result->fe_time.tm_min  = atoi(p);\n      \n          return result->fe_type;\n\n        } /* if (isdigit(*tokens[1])) */\n\n        return '?'; /* junk */\n\n      } /* if (lstyle == 'V') */\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'V')) */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_CMS)\n    /* Virtual Machine/Conversational Monitor System (IBM Mainframe) */\n    if (!lstyle && (!state->lstyle || state->lstyle == 'C'))  /* VM/CMS */\n    {\n      /* LISTing according to mirror.pl\n       * Filename FileType  Fm Format Lrecl  Records Blocks Date      Time\n       * LASTING  GLOBALV   A1 V      41     21     1       9/16/91   15:10:32\n       * J43401   NETLOG    A0 V      77     1      1       9/12/91   12:36:04\n       * PROFILE  EXEC      A1 V      17     3      1       9/12/91   12:39:07\n       * DIRUNIX  SCRIPT    A1 V      77     1216   17      1/04/93   20:30:47\n       * MAIL     PROFILE   A2 F      80     1      1       10/14/92  16:12:27\n       * BADY2K   TEXT      A0 V      1      1      1       1/03/102  10:11:12\n       * AUTHORS            A1 DIR    -      -      -       9/20/99   10:31:11\n       *\n       * LISTing from vm.marist.edu and vm.sc.edu\n       * 220-FTPSERVE IBM VM Level 420 at VM.MARIST.EDU, 04:58:12 EDT WEDNESDAY 2002-07-10\n       * AUTHORS           DIR        -          -          - 1999-09-20 10:31:11 -\n       * HARRINGTON        DIR        -          -          - 1997-02-12 15:33:28 -\n       * PICS              DIR        -          -          - 2000-10-12 15:43:23 -\n       * SYSFILE           DIR        -          -          - 2000-07-20 17:48:01 -\n       * WELCNVT  EXEC     V         72          9          1 1999-09-20 17:16:18 -\n       * WELCOME  EREADME  F         80         21          1 1999-12-27 16:19:00 -\n       * WELCOME  README   V         82         21          1 1999-12-27 16:19:04 -\n       * README   ANONYMOU V         71         26          1 1997-04-02 12:33:20 TCP291\n       * README   ANONYOLD V         71         15          1 1995-08-25 16:04:27 TCP291\n      */\n      if (numtoks >= 7 && (toklen[0]+toklen[1]) <= 16)\n      {\n        for (pos = 1; !lstyle && (pos+5) < numtoks; pos++)\n        {\n          p = tokens[pos];\n          if ((toklen[pos] == 1 && (*p == 'F' || *p == 'V')) ||\n              (toklen[pos] == 3 && *p == 'D' && p[1] == 'I' && p[2] == 'R'))\n          {\n            if (toklen[pos+5] == 8 && (tokens[pos+5][2]) == ':' &&\n                                      (tokens[pos+5][5]) == ':'   )\n            {\n              p = tokens[pos+4];\n              if ((toklen[pos+4] == 10 && p[4] == '-' && p[7] == '-') ||\n                  (toklen[pos+4] >= 7 && toklen[pos+4] <= 9 && \n                            p[((p[1]!='/')?(2):(1))] == '/' && \n                            p[((p[1]!='/')?(5):(4))] == '/'))\n               /* Y2K bugs possible (\"7/06/102\" or \"13/02/101\") */\n              {\n                if ( (*tokens[pos+1] == '-' &&\n                      *tokens[pos+2] == '-' &&\n                      *tokens[pos+3] == '-')  ||\n                      (isdigit(*tokens[pos+1]) &&\n                       isdigit(*tokens[pos+2]) &&\n                       isdigit(*tokens[pos+3])) )\n                {\n                  lstyle = 'C';\n                  tokmarker = pos;\n                }\n              }\n            }\n          }\n        } /* for (pos = 1; !lstyle && (pos+5) < numtoks; pos++) */\n      } /* if (numtoks >= 7) */\n\n      /* extra checking if first pass */\n      if (lstyle && !state->lstyle) \n      {\n        for (pos = 0, p = tokens[0]; lstyle && pos < toklen[0]; pos++, p++)\n        {  \n          if (isalpha(*p) && toupper(*p) != *p)\n            lstyle = 0;\n        } \n        for (pos = tokmarker+1; pos <= tokmarker+3; pos++)\n        {\n          if (!(toklen[pos] == 1 && *tokens[pos] == '-'))\n          {\n            for (p = tokens[pos]; lstyle && p<(tokens[pos]+toklen[pos]); p++)\n            {\n              if (!isdigit(*p))\n                lstyle = 0;\n            }\n          }\n        }\n        for (pos = 0, p = tokens[tokmarker+4]; \n             lstyle && pos < toklen[tokmarker+4]; pos++, p++)\n        {\n          if (*p == '/')\n          { \n            /* There may be Y2K bugs in the date. Don't simplify to\n             * pos != (len-3) && pos != (len-6) like time is done.\n            */             \n            if ((tokens[tokmarker+4][1]) == '/')\n            {\n              if (pos != 1 && pos != 4)\n                lstyle = 0;\n            }\n            else if (pos != 2 && pos != 5)\n              lstyle = 0;\n          }\n          else if (*p != '-' && !isdigit(*p))\n            lstyle = 0;\n          else if (*p == '-' && pos != 4 && pos != 7)\n            lstyle = 0;\n        }\n        for (pos = 0, p = tokens[tokmarker+5]; \n             lstyle && pos < toklen[tokmarker+5]; pos++, p++)\n        {\n          if (*p != ':' && !isdigit(*p))\n            lstyle = 0;\n          else if (*p == ':' && pos != (toklen[tokmarker+5]-3)\n                             && pos != (toklen[tokmarker+5]-6))\n            lstyle = 0;\n        }\n      } /* initial if() */\n\n      if (lstyle == 'C')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        p = tokens[tokmarker+4];\n        if (toklen[tokmarker+4] == 10) /* newstyle: YYYY-MM-DD format */\n        {\n          result->fe_time.tm_year = atoi(p+0) - 1900;\n          result->fe_time.tm_mon  = atoi(p+5) - 1;\n          result->fe_time.tm_mday = atoi(p+8);\n        }\n        else /* oldstyle: [M]M/DD/YY format */\n        {\n          pos = toklen[tokmarker+4];\n          result->fe_time.tm_mon  = atoi(p) - 1;\n          result->fe_time.tm_mday = atoi((p+pos)-5);\n          result->fe_time.tm_year = atoi((p+pos)-2);\n          if (result->fe_time.tm_year < 70)\n            result->fe_time.tm_year += 100;\n        }\n\n        p = tokens[tokmarker+5];\n        pos = toklen[tokmarker+5];\n        result->fe_time.tm_hour  = atoi(p);\n        result->fe_time.tm_min = atoi((p+pos)-5);\n        result->fe_time.tm_sec = atoi((p+pos)-2);\n\n        result->fe_cinfs = 1;\n        result->fe_fname = tokens[0];\n        result->fe_fnlen = toklen[0];\n        result->fe_type  = 'f';\n\n        p = tokens[tokmarker];\n        if (toklen[tokmarker] == 3 && *p=='D' && p[1]=='I' && p[2]=='R')\n          result->fe_type  = 'd';\n\n        if ((/*newstyle*/ toklen[tokmarker+4] == 10 && tokmarker > 1) ||\n            (/*oldstyle*/ toklen[tokmarker+4] != 10 && tokmarker > 2))\n        {                            /* have a filetype column */\n          char *dot;\n          p = &(tokens[0][toklen[0]]);\n          memcpy( &dot, &p, sizeof(dot) ); /* NASTY! */\n          *dot++ = '.';\n          p = tokens[1];\n          for (pos = 0; pos < toklen[1]; pos++)\n            *dot++ = *p++;\n          result->fe_fnlen += 1 + toklen[1];\n        }\n\n        /* oldstyle LISTING: \n         * files/dirs not on the 'A' minidisk are not RETRievable/CHDIRable \n        if (toklen[tokmarker+4] != 10 && *tokens[tokmarker-1] != 'A')\n          return '?';\n        */\n        \n        /* VM/CMS LISTings have no usable filesize field. \n         * Have to use the 'SIZE' command for that.\n        */\n        return result->fe_type;\n\n      } /* if (lstyle == 'C' && (!state->lstyle || state->lstyle == lstyle)) */\n    } /* VM/CMS */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_DOS) /* WinNT DOS dirstyle */\n    if (!lstyle && (!state->lstyle || state->lstyle == 'W'))\n    {\n      /*\n       * \"10-23-00  01:27PM       <DIR>          veronist\"\n       * \"06-15-00  07:37AM       <DIR>          zoe\"\n       * \"07-14-00  01:35PM              2094926 canprankdesk.tif\"\n       * \"07-21-00  01:19PM                95077 Jon Kauffman Enjoys the Good Life.jpg\"\n       * \"07-21-00  01:19PM                52275 Name Plate.jpg\"\n       * \"07-14-00  01:38PM              2250540 Valentineoffprank-HiRes.jpg\"\n      */\n      if ((numtoks >= 4) && toklen[0] == 8 && toklen[1] == 7 && \n          (*tokens[2] == '<' || isdigit(*tokens[2])) )\n      {\n        p = tokens[0];\n        if ( isdigit(p[0]) && isdigit(p[1]) && p[2]=='-' && \n             isdigit(p[3]) && isdigit(p[4]) && p[5]=='-' &&\n             isdigit(p[6]) && isdigit(p[7]) )\n        {\n          p = tokens[1];\n          if ( isdigit(p[0]) && isdigit(p[1]) && p[2]==':' && \n               isdigit(p[3]) && isdigit(p[4]) && \n               (p[5]=='A' || p[5]=='P') && p[6]=='M')\n          {\n            lstyle = 'W';\n            if (!state->lstyle)\n            {            \n              p = tokens[2];\n              /* <DIR> or <JUNCTION> */\n              if (*p != '<' || p[toklen[2]-1] != '>')\n              {\n                for (pos = 1; (lstyle && pos < toklen[2]); pos++)\n                {\n                  if (!isdigit(*++p))\n                    lstyle = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (lstyle == 'W')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        p = &(line[linelen]); /* line end */\n        result->fe_cinfs = 1;\n        result->fe_fname = tokens[3];\n        result->fe_fnlen = p - tokens[3];\n        result->fe_type = 'd';\n\n        if (*tokens[2] != '<') /* not <DIR> or <JUNCTION> */\n        {\n          // try to handle correctly spaces at the beginning of the filename\n          // filesize (token[2]) must end at offset 38\n          if (tokens[2] + toklen[2] - line == 38) {\n            result->fe_fname = &(line[39]);\n            result->fe_fnlen = p - result->fe_fname;\n          }\n          result->fe_type = 'f';\n          pos = toklen[2];\n          while (pos > (sizeof(result->fe_size)-1))\n            pos = (sizeof(result->fe_size)-1);\n          memcpy( result->fe_size, tokens[2], pos );\n          result->fe_size[pos] = '\\0';\n        }\n        else {\n          // try to handle correctly spaces at the beginning of the filename\n          // token[2] must begin at offset 24, the length is 5 or 10\n          // token[3] must begin at offset 39 or higher\n          if (tokens[2] - line == 24 && (toklen[2] == 5 || toklen[2] == 10) &&\n              tokens[3] - line >= 39) {\n            result->fe_fname = &(line[39]);\n            result->fe_fnlen = p - result->fe_fname;\n          }\n\n          if ((tokens[2][1]) != 'D') /* not <DIR> */\n          {\n            result->fe_type = '?'; /* unknown until junc for sure */\n            if (result->fe_fnlen > 4)\n            {\n              p = result->fe_fname;\n              for (pos = result->fe_fnlen - 4; pos > 0; pos--)\n              {\n                if (p[0] == ' ' && p[3] == ' ' && p[2] == '>' &&\n                    (p[1] == '=' || p[1] == '-'))\n                {\n                  result->fe_type = 'l';\n                  result->fe_fnlen = p - result->fe_fname;\n                  result->fe_lname = p + 4;\n                  result->fe_lnlen = &(line[linelen]) \n                                     - result->fe_lname;\n                  break;\n                }\n                p++;\n              }\n            }\n          }\n        }\n\n        result->fe_time.tm_mon = atoi(tokens[0]+0);\n        if (result->fe_time.tm_mon != 0)\n        {\n          result->fe_time.tm_mon--;\n          result->fe_time.tm_mday = atoi(tokens[0]+3);\n          result->fe_time.tm_year = atoi(tokens[0]+6);\n          /* if year has only two digits then assume that\n               00-79 is 2000-2079\n               80-99 is 1980-1999 */\n          if (result->fe_time.tm_year < 80)\n            result->fe_time.tm_year += 2000;\n          else if (result->fe_time.tm_year < 100)\n            result->fe_time.tm_year += 1900;\n        }\n\n        result->fe_time.tm_hour = atoi(tokens[1]+0);\n        result->fe_time.tm_min = atoi(tokens[1]+3);\n        if ((tokens[1][5]) == 'P' && result->fe_time.tm_hour < 12)\n          result->fe_time.tm_hour += 12;\n\n        /* the caller should do this (if dropping \".\" and \"..\" is desired)\n        if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&\n            (result->fe_fnlen == 1 || (result->fe_fnlen == 2 &&\n                                      result->fe_fname[1] == '.')))\n          return '?';\n        */\n\n        return result->fe_type;  \n      } /* if (lstyle == 'W' && (!state->lstyle || state->lstyle == lstyle)) */\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'W')) */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_OS2)\n    if (!lstyle && (!state->lstyle || state->lstyle == 'O')) /* OS/2 test */\n    {\n      /* 220 server IBM TCP/IP for OS/2 - FTP Server ver 23:04:36 on Jan 15 1997 ready.\n      * fixed position, space padded columns. I have only a vague idea \n      * of what the contents between col 18 and 34 might be: All I can infer\n      * is that there may be attribute flags in there and there may be \n      * a \" DIR\" in there.\n      *\n      *          1         2         3         4         5         6\n      *0123456789012345678901234567890123456789012345678901234567890123456789\n      *----- size -------|??????????????? MM-DD-YY|  HH:MM| nnnnnnnnn....\n      *                 0  DIR            04-11-95   16:26  .\n      *                 0  DIR            04-11-95   16:26  ..\n      *                 0  DIR            04-11-95   16:26  ADDRESS\n      *               612  RHSA           07-28-95   16:45  air_tra1.bag\n      *               195  A              08-09-95   10:23  Alfa1.bag\n      *                 0  RHS   DIR      04-11-95   16:26  ATTACH\n      *               372  A              08-09-95   10:26  Aussie_1.bag\n      *            310992                 06-28-94   09:56  INSTALL.EXE\n      *                            1         2         3         4\n      *                  01234567890123456789012345678901234567890123456789\n      * dirlist from the mirror.pl project, col positions from Mozilla.\n      */\n      p = &(line[toklen[0]]);\n      /* \\s(\\d\\d-\\d\\d-\\d\\d)\\s+(\\d\\d:\\d\\d)\\s */\n      if (numtoks >= 4 && toklen[0] <= 18 && isdigit(*tokens[0]) &&\n         (linelen - toklen[0]) >= (53-18)                        &&\n         p[18-18] == ' ' && p[34-18] == ' '                      &&\n         p[37-18] == '-' && p[40-18] == '-' && p[43-18] == ' '   &&\n         p[45-18] == ' ' && p[48-18] == ':' && p[51-18] == ' '   &&\n         isdigit(p[35-18]) && isdigit(p[36-18])                  &&\n         isdigit(p[38-18]) && isdigit(p[39-18])                  &&\n         isdigit(p[41-18]) && isdigit(p[42-18])                  &&\n         isdigit(p[46-18]) && isdigit(p[47-18])                  &&\n         isdigit(p[49-18]) && isdigit(p[50-18])\n      )\n      {\n        lstyle = 'O'; /* OS/2 */\n        if (!state->lstyle)\n        {            \n          for (pos = 1; lstyle && pos < toklen[0]; pos++)\n          {\n            if (!isdigit(tokens[0][pos]))\n              lstyle = 0;\n          }\n        }\n      }\n\n      if (lstyle == 'O')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        p = &(line[toklen[0]]);\n\n        result->fe_cinfs = 1;\n        result->fe_fname = &p[53-18];\n        result->fe_fnlen = (&(line[linelen_sans_wsp]))\n                           - (result->fe_fname);\n        result->fe_type = 'f';\n\n        /* I don't have a real listing to determine exact pos, so scan. */\n        for (pos = (18-18); pos < ((35-18)-4); pos++)\n        {\n          if (p[pos+0] == ' ' && p[pos+1] == 'D' && \n              p[pos+2] == 'I' && p[pos+3] == 'R')\n          {\n            result->fe_type = 'd';\n            break;\n          }\n        }\n    \n        if (result->fe_type != 'd')\n        {\n          pos = toklen[0];\n          if (pos > (sizeof(result->fe_size)-1))\n            pos = (sizeof(result->fe_size)-1);\n          memcpy( result->fe_size, tokens[0], pos );\n          result->fe_size[pos] = '\\0';\n        }  \n    \n        result->fe_time.tm_mon = atoi(&p[35-18]) - 1;\n        result->fe_time.tm_mday = atoi(&p[38-18]);\n        result->fe_time.tm_year = atoi(&p[41-18]);\n        if (result->fe_time.tm_year < 80)\n          result->fe_time.tm_year += 100;\n        result->fe_time.tm_hour = atoi(&p[46-18]);\n        result->fe_time.tm_min = atoi(&p[49-18]);\n   \n        /* the caller should do this (if dropping \".\" and \"..\" is desired)\n        if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&\n            (result->fe_fnlen == 1 || (result->fe_fnlen == 2 &&\n                                      result->fe_fname[1] == '.')))\n          return '?';\n        */\n\n        return result->fe_type;\n      } /* if (lstyle == 'O') */\n\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'O')) */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n    \n#if defined(SUPPORT_LSL)\n    if (!lstyle && (!state->lstyle || state->lstyle == 'U')) /* /bin/ls & co. */\n    {\n      /* UNIX-style listing, without inum and without blocks\n       * \"-rw-r--r--   1 root     other        531 Jan 29 03:26 README\"\n       * \"dr-xr-xr-x   2 root     other        512 Apr  8  1994 etc\"\n       * \"dr-xr-xr-x   2 root     512 Apr  8  1994 etc\"\n       * \"lrwxrwxrwx   1 root     other          7 Jan 25 00:17 bin -> usr/bin\"\n       * Also produced by Microsoft's FTP servers for Windows:\n       * \"----------   1 owner    group         1803128 Jul 10 10:18 ls-lR.Z\"\n       * \"d---------   1 owner    group               0 May  9 19:45 Softlib\"\n       * Also WFTPD for MSDOS:\n       * \"-rwxrwxrwx   1 noone    nogroup      322 Aug 19  1996 message.ftp\"\n       * Hellsoft for NetWare:\n       * \"d[RWCEMFA] supervisor            512       Jan 16 18:53    login\"\n       * \"-[RWCEMFA] rhesus             214059       Oct 20 15:27    cx.exe\"\n       * Newer Hellsoft for NetWare: (netlab2.usu.edu)\n       * - [RWCEAFMS] NFAUUser               192 Apr 27 15:21 HEADER.html\n       * d [RWCEAFMS] jrd                    512 Jul 11 03:01 allupdates\n       * Also NetPresenz for the Mac:\n       * \"-------r--         326  1391972  1392298 Nov 22  1995 MegaPhone.sit\"\n       * \"drwxrwxr-x               folder        2 May 10  1996 network\"\n       * Protected directory:\n       * \"drwx-wx-wt  2 root  wheel  512 Jul  1 02:15 incoming\"\n       * uid/gid instead of username/groupname:\n       * \"drwxr-xr-x  2 0  0  512 May 28 22:17 etc\"\n      */\n    \n      gboolean is_old_Hellsoft = FALSE;\n\n      if (numtoks >= 6)\n      {\n        /* there are two perm formats (Hellsoft/NetWare and *IX strmode(3)).\n         * Scan for size column only if the perm format is one or the other.\n         */\n        if (toklen[0] == 1 || (tokens[0][1]) == '[')\n        {\n          if (*tokens[0] == 'd' || *tokens[0] == '-')\n          {\n            pos = toklen[0]-1;\n            p = tokens[0] + 1;\n            if (pos == 0)\n            {\n              p = tokens[1];\n              pos = toklen[1];\n            }\n            if ((pos == 9 || pos == 10)        && \n                (*p == '[' && p[pos-1] == ']') &&\n                (p[1] == 'R' || p[1] == '-')   &&\n                (p[2] == 'W' || p[2] == '-')   &&\n                (p[3] == 'C' || p[3] == '-')   &&\n                (p[4] == 'E' || p[4] == '-'))\n            {\n              /* rest is FMA[S] or AFM[S] */\n              lstyle = 'U'; /* very likely one of the NetWare servers */\n              if (toklen[0] == 10)\n                is_old_Hellsoft = TRUE;\n            }\n          }\n        }\n        else if ((toklen[0] == 10 || toklen[0] == 11) \n                   && strchr(\"-bcdlpsw?DFam\", *tokens[0]))\n        {\n          p = &(tokens[0][1]);\n          if ((p[0] == 'r' || p[0] == '-') &&\n              (p[1] == 'w' || p[1] == '-') &&\n              (p[3] == 'r' || p[3] == '-') &&\n              (p[4] == 'w' || p[4] == '-') &&\n              (p[6] == 'r' || p[6] == '-') &&\n              (p[7] == 'w' || p[7] == '-'))\n            /* 'x'/p[9] can be S|s|x|-|T|t or implementation specific */\n          {\n            lstyle = 'U'; /* very likely /bin/ls */\n          }\n        }\n      }\n      if (lstyle == 'U') /* first token checks out */\n      {\n        lstyle = 0;\n        for (pos = (numtoks-5); !lstyle && pos > 1; pos--)\n        {\n          /* scan for: (\\d+)\\s+([A-Z][a-z][a-z])\\s+\n           *  (\\d\\d\\d\\d|\\d\\:\\d\\d|\\d\\d\\:\\d\\d|\\d\\:\\d\\d\\:\\d\\d|\\d\\d\\:\\d\\d\\:\\d\\d)\n           *  \\s+(.+)$\n          */\n          if (isdigit(*tokens[pos]) /* size */\n              /* (\\w\\w\\w) */\n           && toklen[pos+1] == 3 && isalpha(*tokens[pos+1]) &&\n              isalpha(tokens[pos+1][1]) && isalpha(tokens[pos+1][2])\n              /* (\\d|\\d\\d) */\n           && isdigit(*tokens[pos+2]) &&\n                (toklen[pos+2] == 1 || \n                  (toklen[pos+2] == 2 && isdigit(tokens[pos+2][1])))\n           && toklen[pos+3] >= 4 && isdigit(*tokens[pos+3]) \n              /* (\\d\\:\\d\\d\\:\\d\\d|\\d\\d\\:\\d\\d\\:\\d\\d) */\n           && (toklen[pos+3] <= 5 || (\n               (toklen[pos+3] == 7 || toklen[pos+3] == 8) &&\n               (tokens[pos+3][toklen[pos+3]-3]) == ':'))\n           && isdigit(tokens[pos+3][toklen[pos+3]-2])\n           && isdigit(tokens[pos+3][toklen[pos+3]-1])\n           && (\n              /* (\\d\\d\\d\\d) */\n                 ((toklen[pos+3] == 4 || toklen[pos+3] == 5) &&\n                  isdigit(tokens[pos+3][1]) &&\n                  isdigit(tokens[pos+3][2])  )\n              /* (\\d\\:\\d\\d|\\d\\:\\d\\d\\:\\d\\d) */\n              || ((toklen[pos+3] == 4 || toklen[pos+3] == 7) && \n                  (tokens[pos+3][1]) == ':' &&\n                  isdigit(tokens[pos+3][2]) && isdigit(tokens[pos+3][3]))\n              /* (\\d\\d\\:\\d\\d|\\d\\d\\:\\d\\d\\:\\d\\d) */\n              || ((toklen[pos+3] == 5 || toklen[pos+3] == 8) && \n                  isdigit(tokens[pos+3][1]) && (tokens[pos+3][2]) == ':' &&\n                  isdigit(tokens[pos+3][3]) && isdigit(tokens[pos+3][4])) \n              )\n           )\n          {\n            unsigned int i;\n            lstyle = 'U'; /* assume /bin/ls or variant format */\n            tokmarker = pos;\n\n            /* check that size is numeric */\n            p = tokens[tokmarker];\n            for (i = 0; i < toklen[tokmarker]; i++)\n            {\n              if (!isdigit(*p++))\n              {\n                lstyle = 0;\n                break;\n              }\n            }\n            if (lstyle)\n            {\n              month_num = 0;\n              p = tokens[tokmarker+1];\n              for (i = 0; i < (12*3); i+=3)\n              {\n                if (p[0] == month_names[i+0] && \n                    p[1] == month_names[i+1] && \n                    p[2] == month_names[i+2])\n                  break;\n                month_num++;\n              }\n              if (month_num >= 12)\n                lstyle = 0;\n            }\n          } /* relative position test */\n        } /* for (pos = (numtoks-5); !lstyle && pos > 1; pos--) */\n      } /* if (lstyle == 'U') */\n\n      if (lstyle == 'U')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n    \n        result->fe_cinfs = 0;\n        result->fe_type = '?';\n        if (*tokens[0] == 'd' || *tokens[0] == 'l')\n          result->fe_type = *tokens[0];\n        else if (*tokens[0] == 'D')\n          result->fe_type = 'd';\n        else if (*tokens[0] == '-' || *tokens[0] == 'F')\n          result->fe_type = 'f'; /* (hopefully a regular file) */\n\n        if (result->fe_type != 'd')\n        {\n          pos = toklen[tokmarker];\n          if (pos > (sizeof(result->fe_size)-1))\n            pos = (sizeof(result->fe_size)-1);\n          memcpy( result->fe_size, tokens[tokmarker], pos );\n          result->fe_size[pos] = '\\0';\n        }\n\n        result->fe_time.tm_mon  = month_num;\n        result->fe_time.tm_mday = atoi(tokens[tokmarker+2]);\n        if (result->fe_time.tm_mday == 0)\n          result->fe_time.tm_mday++;\n\n        p = tokens[tokmarker+3];\n        pos = (unsigned int)atoi(p);\n        if (p[1] == ':') /* one digit hour */\n          p--;\n        if (p[2] != ':') /* year */\n        {\n          result->fe_time.tm_year = pos;\n        }\n        else\n        {\n          result->fe_time.tm_hour = pos;\n          result->fe_time.tm_min  = atoi(p+3);\n          if (p[5] == ':')\n            result->fe_time.tm_sec = atoi(p+6);\n       \n          if (!state->now_time)\n          {\n            state->now_time = time (NULL);\n\t    state->now_tm = *localtime (&state->now_time);\n          }\n\n          result->fe_time.tm_year = state->now_tm.tm_year;\n          if ( (( state->now_tm.tm_mon << 5) + state->now_tm.tm_mday) <\n               ((result->fe_time.tm_mon << 5) + result->fe_time.tm_mday) )\n            result->fe_time.tm_year--;\n       \n        } /* time/year */\n        \n        // there is exacly 1 space between filename and previous token in all\n        // outputs except old Hellsoft\n        if (!is_old_Hellsoft)\n          result->fe_fname = tokens[tokmarker+3] + toklen[tokmarker+3] + 1;\n        else\n          result->fe_fname = tokens[tokmarker+4];\n\n        result->fe_fnlen = (&(line[linelen]))\n                           - (result->fe_fname);\n\n        if (result->fe_type == 'l' && result->fe_fnlen > 4)\n        {\n          /* First try to use result->fe_size to find \" -> \" sequence.\n             This can give proper result for cases like \"aaa -> bbb -> ccc\". */\n          guint32 fe_size = atoi(result->fe_size);\n\n          if (result->fe_fnlen > (fe_size + 4) &&\n              strncmp(result->fe_fname + result->fe_fnlen - fe_size - 4 , \" -> \", 4) == 0)\n          {\n            result->fe_lname = result->fe_fname + (result->fe_fnlen - fe_size);\n            result->fe_lnlen = (&(line[linelen])) - (result->fe_lname);\n            result->fe_fnlen -= fe_size + 4;\n          }\n          else\n          {\n            /* Search for sequence \" -> \" from the end for case when there are\n               more occurrences. F.e. if ftpd returns \"a -> b -> c\" assume\n               \"a -> b\" as a name. Powerusers can remove unnecessary parts\n               manually but there is no way to follow the link when some\n               essential part is missing. */\n            p = result->fe_fname + (result->fe_fnlen - 5);\n            for (pos = (result->fe_fnlen - 5); pos > 0; pos--)\n            {\n              if (p && g_str_has_prefix(p, \" -> \"))\n              {\n                result->fe_lname = p + 4;\n                result->fe_lnlen = (&(line[linelen]))\n                                 - (result->fe_lname);\n                result->fe_fnlen = pos;\n                break;\n              }\n              p--;\n            }\n          }\n        }\n\n#if defined(SUPPORT_LSLF) /* some (very rare) servers return ls -lF */\n        if (result->fe_fnlen > 1)\n        {\n          p = result->fe_fname[result->fe_fnlen-1];\n          pos = result->fe_type;\n          if (pos == 'd') { \n             if (*p == '/') result->fe_fnlen--; /* directory */\n          } else if (pos == 'l') { \n             if (*p == '@') result->fe_fnlen--; /* symlink */\n          } else if (pos == 'f') { \n             if (*p == '*') result->fe_fnlen--; /* executable */\n          } else if (*p == '=' || *p == '%' || *p == '|') {\n            result->fe_fnlen--; /* socket, whiteout, fifo */\n          }\n        }\n#endif\n     \n        /* the caller should do this (if dropping \".\" and \"..\" is desired)\n        if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&\n            (result->fe_fnlen == 1 || (result->fe_fnlen == 2 &&\n                                      result->fe_fname[1] == '.')))\n          return '?';\n        */\n\n        return result->fe_type;  \n\n      } /* if (lstyle == 'U') */\n\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'U')) */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_W16) /* 16bit Windows */\n    if (!lstyle && (!state->lstyle || state->lstyle == 'w'))\n    {       /* old SuperTCP suite FTP server for Win3.1 */\n            /* old NetManage Chameleon TCP/IP suite FTP server for Win3.1 */\n      /*\n      * SuperTCP dirlist from the mirror.pl project\n      * mon/day/year separator may be '/' or '-'.\n      * .               <DIR>           11-16-94        17:16\n      * ..              <DIR>           11-16-94        17:16\n      * INSTALL         <DIR>           11-16-94        17:17\n      * CMT             <DIR>           11-21-94        10:17\n      * DESIGN1.DOC          11264      05-11-95        14:20\n      * README.TXT            1045      05-10-95        11:01\n      * WPKIT1.EXE          960338      06-21-95        17:01\n      * CMT.CSV                  0      07-06-95        14:56\n      *\n      * Chameleon dirlist guessed from lynx\n      * .               <DIR>      Nov 16 1994 17:16   \n      * ..              <DIR>      Nov 16 1994 17:16   \n      * INSTALL         <DIR>      Nov 16 1994 17:17\n      * CMT             <DIR>      Nov 21 1994 10:17\n      * DESIGN1.DOC     11264      May 11 1995 14:20   A\n      * README.TXT       1045      May 10 1995 11:01\n      * WPKIT1.EXE     960338      Jun 21 1995 17:01   R\n      * CMT.CSV             0      Jul 06 1995 14:56   RHA\n      */\n      if (numtoks >= 4 && toklen[0] < 13 && \n          ((toklen[1] == 5 && *tokens[1] == '<') || isdigit(*tokens[1])) )\n      {\n        if (numtoks == 4\n         && (toklen[2] == 8 || toklen[2] == 9)\n         && (((tokens[2][2]) == '/' && (tokens[2][5]) == '/') ||\n             ((tokens[2][2]) == '-' && (tokens[2][5]) == '-'))\n         && (toklen[3] == 4 || toklen[3] == 5)\n         && (tokens[3][toklen[3]-3]) == ':'\n         && isdigit(tokens[2][0]) && isdigit(tokens[2][1])\n         && isdigit(tokens[2][3]) && isdigit(tokens[2][4])\n         && isdigit(tokens[2][6]) && isdigit(tokens[2][7])\n         && (toklen[2] < 9 || isdigit(tokens[2][8]))\n         && isdigit(tokens[3][toklen[3]-1]) && isdigit(tokens[3][toklen[3]-2])\n         && isdigit(tokens[3][toklen[3]-4]) && isdigit(*tokens[3]) \n         )\n        {\n          lstyle = 'w';\n        }\n        else if ((numtoks == 6 || numtoks == 7)\n         && toklen[2] == 3 && toklen[3] == 2\n         && toklen[4] == 4 && toklen[5] == 5\n         && (tokens[5][2]) == ':'\n         && isalpha(tokens[2][0]) && isalpha(tokens[2][1])\n         &&                          isalpha(tokens[2][2])\n         && isdigit(tokens[3][0]) && isdigit(tokens[3][1])\n         && isdigit(tokens[4][0]) && isdigit(tokens[4][1])\n         && isdigit(tokens[4][2]) && isdigit(tokens[4][3])\n         && isdigit(tokens[5][0]) && isdigit(tokens[5][1])\n         && isdigit(tokens[5][3]) && isdigit(tokens[5][4])\n         /* could also check that (&(tokens[5][5]) - tokens[2]) == 17 */\n        )\n        {\n          lstyle = 'w';\n        }\n        if (lstyle && state->lstyle != lstyle) /* first time */\n        {\n          p = tokens[1];   \n          if (toklen[1] != 5 || p[0] != '<' || p[1] != 'D' || \n                 p[2] != 'I' || p[3] != 'R' || p[4] != '>')\n          {\n            for (pos = 0; lstyle && pos < toklen[1]; pos++)\n            {\n              if (!isdigit(*p++))\n                lstyle = 0;\n            }\n          } /* not <DIR> */\n        } /* if (first time) */\n      } /* if (numtoks == ...) */\n\n      if (lstyle == 'w')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        result->fe_cinfs = 1;\n        result->fe_fname = tokens[0];\n        result->fe_fnlen = toklen[0];\n        result->fe_type = 'd';\n\n        p = tokens[1];\n        if (isdigit(*p))\n        {\n          result->fe_type = 'f';\n          pos = toklen[1];\n          if (pos > (sizeof(result->fe_size)-1))\n            pos = sizeof(result->fe_size)-1;\n          memcpy( result->fe_size, p, pos );\n          result->fe_size[pos] = '\\0';\n        }\n\n        p = tokens[2];\n        if (toklen[2] == 3) /* Chameleon */\n        {\n          tbuf[0] = toupper(p[0]);\n          tbuf[1] = tolower(p[1]);\n          tbuf[2] = tolower(p[2]);\n          for (pos = 0; pos < (12*3); pos+=3)\n          {\n            if (tbuf[0] == month_names[pos+0] &&\n                tbuf[1] == month_names[pos+1] && \n                tbuf[2] == month_names[pos+2])\n            {\n              result->fe_time.tm_mon = pos/3;\n              result->fe_time.tm_mday = atoi(tokens[3]);\n              result->fe_time.tm_year = atoi(tokens[4]) - 1900;\n              break;\n            }\n          }          \n          pos = 5; /* Chameleon toknum of date field */\n        }\n        else\n        {\n          result->fe_time.tm_mon = atoi(p+0)-1;\n          result->fe_time.tm_mday = atoi(p+3);\n          result->fe_time.tm_year = atoi(p+6);\n          if (result->fe_time.tm_year < 80) /* SuperTCP */\n            result->fe_time.tm_year += 100;\n\n          pos = 3; /* SuperTCP toknum of date field */\n        }\n\n        result->fe_time.tm_hour = atoi(tokens[pos]);\n        result->fe_time.tm_min = atoi(&(tokens[pos][toklen[pos]-2]));\n\n        /* the caller should do this (if dropping \".\" and \"..\" is desired)\n        if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&\n            (result->fe_fnlen == 1 || (result->fe_fnlen == 2 &&\n                                      result->fe_fname[1] == '.')))\n          return '?';\n        */\n\n        return result->fe_type;\n      } /* (lstyle == 'w') */\n\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'w'))  */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n#if defined(SUPPORT_DLS) /* dls -dtR */\n    if (!lstyle && \n       (state->lstyle == 'D' || (!state->lstyle && state->numlines == 1)))\n       /* /bin/dls lines have to be immediately recognizable (first line) */\n    {\n      /* I haven't seen an FTP server that delivers a /bin/dls listing,\n       * but can infer the format from the lynx and mirror.pl projects.\n       * Both formats are supported.\n       *\n       * Lynx says:\n       * README              763  Information about this server\\0\n       * bin/                  -  \\0\n       * etc/                  =  \\0\n       * ls-lR                 0  \\0\n       * ls-lR.Z               3  \\0\n       * pub/                  =  Public area\\0\n       * usr/                  -  \\0\n       * morgan               14  -> ../real/morgan\\0\n       * TIMIT.mostlikely.Z\\0\n       *                   79215  \\0\n       *\n       * mirror.pl says:\n       * filename:  ^(\\S*)\\s+\n       * size:      (\\-|\\=|\\d+)\\s+\n       * month/day: ((\\w\\w\\w\\s+\\d+|\\d+\\s+\\w\\w\\w)\\s+\n       * time/year: (\\d+:\\d+|\\d\\d\\d\\d))\\s+\n       * rest:      (.+) \n       *\n       * README              763  Jul 11 21:05  Information about this server\n       * bin/                  -  Apr 28  1994\n       * etc/                  =  11 Jul 21:04\n       * ls-lR                 0   6 Aug 17:14\n       * ls-lR.Z               3  05 Sep 1994\n       * pub/                  =  Jul 11 21:04  Public area\n       * usr/                  -  Sep  7 09:39\n       * morgan               14  Apr 18 09:39  -> ../real/morgan\n       * TIMIT.mostlikely.Z\n       *                   79215  Jul 11 21:04\n      */\n      if (!state->lstyle && line[linelen-1] == ':' && \n          linelen >= 2 && toklen[numtoks-1] != 1)\n      { \n        /* code in mirror.pl suggests that a listing may be preceded\n         * by a PWD line in the form \"/some/dir/names/here:\"\n         * but does not necessarily begin with '/'. *sigh*\n        */\n        pos = 0;\n        p = line;\n        while (pos < (linelen-1))\n        {\n          /* illegal (or extremely unusual) chars in a dirspec */\n          if (*p == '<' || *p == '|' || *p == '>' ||\n              *p == '?' || *p == '*' || *p == '\\\\')\n            break;\n          if (*p == '/' && pos < (linelen-2) && p[1] == '/')\n            break;\n          pos++;\n          p++;\n        }\n        if (pos == (linelen-1))\n        {\n          state->lstyle = 'D';\n          return '?';\n        }\n      }\n\n      if (!lstyle && numtoks >= 2)\n      {\n        pos = 22; /* pos of (\\d+|-|=) if this is not part of a multiline */\n        if (state->lstyle && carry_buf_len) /* first is from previous line */\n          pos = toklen[1]-1; /* and is 'as-is' (may contain whitespace) */\n\n        if (linelen > pos)\n        {\n          p = &line[pos];\n          if ((*p == '-' || *p == '=' || isdigit(*p)) &&\n              ((linelen == (pos+1)) || \n               (linelen >= (pos+3) && p[1] == ' ' && p[2] == ' ')) )\n          {\n            tokmarker = 1;\n            if (!carry_buf_len)\n            {\n              pos = 1;\n              while (pos < numtoks && (tokens[pos]+toklen[pos]) < (&line[23]))\n                pos++;\n              tokmarker = 0;\n              if ((tokens[pos]+toklen[pos]) == (&line[23]))\n                tokmarker = pos;\n            }\n            if (tokmarker)  \n            {\n              lstyle = 'D';\n              if (*tokens[tokmarker] == '-' || *tokens[tokmarker] == '=')\n              {\n                if (toklen[tokmarker] != 1 ||\n                   (tokens[tokmarker-1][toklen[tokmarker-1]-1]) != '/')\n                  lstyle = 0;\n              }              \n              else\n              {\n                for (pos = 0; lstyle && pos < toklen[tokmarker]; pos++) \n                {\n                  if (!isdigit(tokens[tokmarker][pos]))\n                    lstyle = 0; \n                }\n              }\n              if (lstyle && !state->lstyle) /* first time */\n              {\n                /* scan for illegal (or incredibly unusual) chars in fname */\n                for (p = tokens[0]; lstyle &&\n                     p < &(tokens[tokmarker-1][toklen[tokmarker-1]]); p++)\n                {\n                  if (*p == '<' || *p == '|' || *p == '>' || \n                      *p == '?' || *p == '*' || *p == '/' || *p == '\\\\')\n                    lstyle = 0;\n                }\n              }\n\n            } /* size token found */\n          } /* expected chars behind expected size token */\n        } /* if (linelen > pos) */\n      } /* if (!lstyle && numtoks >= 2) */\n\n      if (!lstyle && state->lstyle == 'D' && !carry_buf_len)\n      {\n        /* the filename of a multi-line entry can be identified\n         * correctly only if dls format had been previously established.\n         * This should always be true because there should be entries\n         * for '.' and/or '..' and/or CWD that precede the rest of the\n         * listing.\n        */\n        pos = linelen;\n        if (pos > (sizeof(state->carry_buf)-1))\n          pos = sizeof(state->carry_buf)-1;\n        memcpy( state->carry_buf, line, pos );\n        state->carry_buf_len = pos;\n        return '?';\n      }\n\n      if (lstyle == 'D')\n      {\n        state->parsed_one = 1;\n        state->lstyle = lstyle;\n\n        p = &(tokens[tokmarker-1][toklen[tokmarker-1]]);\n        result->fe_fname = tokens[0];\n        result->fe_fnlen = p - tokens[0];\n        result->fe_type  = 'f';\n\n        if (result->fe_fname[result->fe_fnlen-1] == '/')\n        {\n          if (result->fe_lnlen == 1)\n            result->fe_type = '?';\n          else\n          {\n            result->fe_fnlen--;\n            result->fe_type  = 'd';\n          }\n        }\n        else if (isdigit(*tokens[tokmarker]))\n        {\n          pos = toklen[tokmarker];\n          if (pos > (sizeof(result->fe_size)-1))\n            pos = sizeof(result->fe_size)-1;\n          memcpy( result->fe_size, tokens[tokmarker], pos );\n          result->fe_size[pos] = '\\0';\n        }\n\n        if ((tokmarker+3) < numtoks && \n              (&(tokens[numtoks-1][toklen[numtoks-1]]) - \n               tokens[tokmarker+1]) >= (1+1+3+1+4) )\n        {\n          pos = (tokmarker+3);\n          p = tokens[pos];\n          pos = toklen[pos];\n\n          if ((pos == 4 || pos == 5)\n          &&  isdigit(*p) && isdigit(p[pos-1]) && isdigit(p[pos-2])\n          &&  ((pos == 5 && p[2] == ':') ||  \n               (pos == 4 && (isdigit(p[1]) || p[1] == ':')))\n             )\n          {\n            month_num = tokmarker+1; /* assumed position of month field */\n            pos = tokmarker+2;       /* assumed position of mday field */\n            if (isdigit(*tokens[month_num])) /* positions are reversed */\n            {\n              month_num++;\n              pos--;\n            }\n            p = tokens[month_num];\n            if (isdigit(*tokens[pos]) \n            && (toklen[pos] == 1 || \n                  (toklen[pos] == 2 && isdigit(tokens[pos][1])))\n            && toklen[month_num] == 3\n            && isalpha(*p) && isalpha(p[1]) && isalpha(p[2])  )\n            {\n              pos = atoi(tokens[pos]);\n              if (pos > 0 && pos <= 31)\n              {\n                result->fe_time.tm_mday = pos;\n                month_num = 1;\n                for (pos = 0; pos < (12*3); pos+=3)\n                {\n                  if (p[0] == month_names[pos+0] &&\n                      p[1] == month_names[pos+1] &&\n                      p[2] == month_names[pos+2])\n                    break;\n                  month_num++;\n                }\n                if (month_num > 12)\n                  result->fe_time.tm_mday = 0;\n                else\n                  result->fe_time.tm_mon = month_num - 1;\n              }\n            }\n            if (result->fe_time.tm_mday)\n            {\n              tokmarker += 3; /* skip mday/mon/yrtime (to find \" -> \") */\n              p = tokens[tokmarker];\n\n              pos = atoi(p);\n              if (pos > 24)\n                result->fe_time.tm_year = pos-1900;\n              else\n              {\n                if (p[1] == ':')\n                  p--;\n                result->fe_time.tm_hour = pos;\n                result->fe_time.tm_min = atoi(p+3);\n                if (!state->now_time)\n                {\n\t\t  state->now_time = time (NULL);\n\t\t  state->now_tm = *localtime (&state->now_time);\n                }\n                result->fe_time.tm_year = state->now_tm.tm_year;\n                if ( (( state->now_tm.tm_mon  << 4) + state->now_tm.tm_mday) <\n                     ((result->fe_time.tm_mon << 4) + result->fe_time.tm_mday) )\n                  result->fe_time.tm_year--;\n              } /* got year or time */\n            } /* got month/mday */\n          } /* may have year or time */\n        } /* enough remaining to possibly have date/time */\n\n        if (numtoks > (tokmarker+2))\n        {\n          pos = tokmarker+1;\n          p = tokens[pos];\n          if (toklen[pos] == 2 && *p == '-' && p[1] == '>')\n          {\n            p = &(tokens[numtoks-1][toklen[numtoks-1]]);\n            result->fe_type  = 'l';\n            result->fe_lname = tokens[pos+1];\n            result->fe_lnlen = p - result->fe_lname;\n            if (result->fe_lnlen > 1 &&\n                result->fe_lname[result->fe_lnlen-1] == '/')\n              result->fe_lnlen--;\n          }\n        } /* if (numtoks > (tokmarker+2)) */\n\n        /* the caller should do this (if dropping \".\" and \"..\" is desired)\n        if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&\n            (result->fe_fnlen == 1 || (result->fe_fnlen == 2 &&\n                                      result->fe_fname[1] == '.')))\n          return '?';\n        */\n\n        return result->fe_type;\n\n      } /* if (lstyle == 'D') */\n    } /* if (!lstyle && (!state->lstyle || state->lstyle == 'D')) */\n#endif\n\n    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n\n  } /* if (linelen > 0) */\n\n  if (state->parsed_one || state->lstyle) /* junk if we fail to parse */\n    return '?';      /* this time but had previously parsed successfully */\n  return '\"';        /* its part of a comment or error message */\n}", "path": "daemon\\ParseFTPList.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static void\npoll_media_cb (GduDevice *device,\n               GError    *error,\n               gpointer   user_data)", "code": "{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n\n  if (error != NULL)\n    {\n      /* We could handle PolicyKit integration here but this action is allowed by default\n       * and this won't be needed when porting to PolicyKit 1.0 anyway\n       */\n      g_simple_async_result_set_from_error (simple, error);\n      g_error_free (error);\n    }\n\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* the callback from dbus -> main thread */\n", "func_signal": "static void\nask_password_reply (DBusMessage *reply,\n\t\t    GError      *error,\n\t\t    gpointer     _data)", "code": "{\n  GSimpleAsyncResult *result;\n  AskPasswordData *data;\n  dbus_bool_t handled, aborted, anonymous;\n  guint32 password_save;\n  const char *password, *username, *domain;\n  DBusMessageIter iter;\n\n  result = G_SIMPLE_ASYNC_RESULT (_data);\n  handled = TRUE;\n  \n  data = g_new0 (AskPasswordData, 1);\n  g_simple_async_result_set_op_res_gpointer (result, data, ask_password_data_free);\n\n  if (reply == NULL)\n    {\n      data->aborted = TRUE;\n    }\n  else\n    {\n      dbus_message_iter_init (reply, &iter);\n      if (!_g_dbus_message_iter_get_args (&iter, NULL,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &handled,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &aborted,\n\t\t\t\t\t  DBUS_TYPE_STRING, &password,\n\t\t\t\t\t  DBUS_TYPE_STRING, &username,\n\t\t\t\t\t  DBUS_TYPE_STRING, &domain,\n\t\t\t\t\t  DBUS_TYPE_BOOLEAN, &anonymous,\n\t\t\t\t\t  DBUS_TYPE_UINT32, &password_save,\n\t\t\t\t\t  0))\n\tdata->aborted = TRUE;\n      else\n\t{\n\t  data->aborted = aborted;\n\n\t  if (!anonymous)\n\t    {\n\t      data->password = g_strdup (password);\n\t      data->username = *username == 0 ? NULL : g_strdup (username);\n\t      data->domain = *domain == 0 ? NULL : g_strdup (domain);\n\t    }\n\t  data->password_save = (GPasswordSave)password_save;\n\t  data->anonymous = anonymous;\n\n\t  /* TODO: handle more args */\n\t}\n    }\n\n  if (handled == FALSE)\n    {\n      g_simple_async_result_set_error (result, G_IO_ERROR, G_IO_ERROR_FAILED, \"Internal Error\");\n    }\n\n  g_simple_async_result_complete (result);\n}", "path": "common\\gmountsource.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/**************************************************************************\n *                  Synchronous daemon calls                              *\n *************************************************************************/\n", "func_signal": "DBusMessage *\n_g_vfs_daemon_call_sync (DBusMessage *message,\n\t\t\t DBusConnection **connection_out,\n\t\t\t const char *callback_obj_path,\n\t\t\t DBusObjectPathMessageFunction callback,\n\t\t\t gpointer callback_user_data, \n\t\t\t GCancellable *cancellable,\n\t\t\t GError **error)", "code": "{\n  DBusConnection *connection;\n  DBusError derror;\n  DBusMessage *reply;\n  DBusPendingCall *pending;\n  int dbus_fd;\n  int cancel_fd;\n  gboolean sent_cancel;\n  DBusMessage *cancel_message;\n  dbus_uint32_t serial;\n  gboolean handle_callbacks;\n  const char *dbus_id = dbus_message_get_destination (message);\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\t    \n  connection = _g_dbus_connection_get_sync (dbus_id, error);\n  if (connection == NULL)\n    return NULL;\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  handle_callbacks = FALSE;\n  if (callback_obj_path != NULL && callback != NULL)\n    {\n      struct DBusObjectPathVTable vtable = { NULL, callback };\n      handle_callbacks = dbus_connection_register_object_path (connection,\n\t\t\t\t\t\t\t       callback_obj_path,\n\t\t\t\t\t\t\t       &vtable,\n\t\t\t\t\t\t\t       callback_user_data);\n    }\n\n  reply = NULL;\n  cancel_fd = g_cancellable_get_fd (cancellable);\n  if (cancel_fd != -1 || handle_callbacks)\n    {\n      if (!dbus_connection_send_with_reply (connection, message,\n\t\t\t\t\t    &pending,\n\t\t\t\t\t    G_VFS_DBUS_TIMEOUT_MSECS))\n\t_g_dbus_oom ();\n      \n      if (pending == NULL ||\n\t  !dbus_connection_get_is_connected (connection))\n\t{\n\t  if (pending)\n\t    dbus_pending_call_unref (pending);\n\t  invalidate_local_connection (dbus_id, error);\n\t  goto out;\n\t}\n\n      /* Make sure the message is sent */\n      dbus_connection_flush (connection);\n\n      if (!dbus_connection_get_unix_fd (connection, &dbus_fd))\n\t{\n\t  dbus_pending_call_unref (pending);\n\t  g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t       \"Error while getting peer-to-peer dbus connection: %s\",\n\t\t       \"No fd\");\n\t  goto out;\n\t}\n\n      sent_cancel = (cancel_fd == -1);\n      while (!dbus_pending_call_get_completed (pending))\n\t{\n\t  GPollFD poll_fds[2];\n\t  int poll_ret;\n\t  \n\t  do\n\t    {\n\t      poll_fds[0].events = G_IO_IN;\n\t      poll_fds[0].fd = dbus_fd;\n\t      poll_fds[1].events = G_IO_IN;\n\t      poll_fds[1].fd = cancel_fd;\n\t      poll_ret = g_poll (poll_fds, sent_cancel?1:2, -1);\n\t    }\n\t  while (poll_ret == -1 && errno == EINTR);\n\n\t  if (poll_ret == -1)\n\t    {\n\t      dbus_pending_call_unref (pending);\n\t      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t   \"Error while getting peer-to-peer dbus connection: %s\",\n\t\t\t   \"poll error\");\n\t      goto out;\n\t    }\n\t  \n\t  if (!sent_cancel && g_cancellable_is_cancelled (cancellable))\n\t    {\n\t      sent_cancel = TRUE;\n\t      serial = dbus_message_get_serial (message);\n\t      cancel_message =\n\t\tdbus_message_new_method_call (NULL,\n\t\t\t\t\t      G_VFS_DBUS_DAEMON_PATH,\n\t\t\t\t\t      G_VFS_DBUS_DAEMON_INTERFACE,\n\t\t\t\t\t      G_VFS_DBUS_OP_CANCEL);\n\t      if (cancel_message != NULL)\n\t\t{\n\t\t  if (dbus_message_append_args (cancel_message,\n\t\t\t\t\t\tDBUS_TYPE_UINT32, &serial,\n\t\t\t\t\t\tDBUS_TYPE_INVALID))\n\t\t    {\n\t\t      dbus_connection_send (connection, cancel_message, NULL);\n\t\t      dbus_connection_flush (connection);\n\t\t    }\n\t\t\t    \n\t\t  dbus_message_unref (cancel_message);\n\t\t}\n\t    }\n\n\t  if (poll_fds[0].revents != 0)\n\t    {\n\t      dbus_connection_read_write (connection,\n\t\t\t\t\t  G_VFS_DBUS_TIMEOUT_MSECS);\n\n\t      while (dbus_connection_dispatch (connection) == DBUS_DISPATCH_DATA_REMAINS)\n\t\t;\n\t    }\n\t}\n\n      reply = dbus_pending_call_steal_reply (pending);\n      dbus_pending_call_unref (pending);\n    }\n  else\n    {\n      dbus_error_init (&derror);\n      reply = dbus_connection_send_with_reply_and_block (connection, message,\n\t\t\t\t\t\t\t G_VFS_DBUS_TIMEOUT_MSECS,\n\t\t\t\t\t\t\t &derror);\n      if (!reply)\n\t{\n\t  if (dbus_error_has_name (&derror, DBUS_ERROR_NO_REPLY) &&\n\t      !dbus_connection_get_is_connected (connection))\n\t    {\n\t      /* The mount for this connection died, we invalidate\n\t       * the caches, and then caller needs to retry.\n\t       */\n\n\t      invalidate_local_connection (dbus_id, error);\n\t    }\n\t  else\n\t    _g_error_from_dbus (&derror, error);\n\t  dbus_error_free (&derror);\n\t  goto out;\n\t}\n    }\n\n  if (connection_out)\n    *connection_out = connection;\n\n out:  \n  \n  if (handle_callbacks)\n    dbus_connection_unregister_object_path (connection, callback_obj_path);\n\n  if (reply != NULL && _g_error_from_message (reply, error))\n    {\n      dbus_message_unref (reply);\n      return NULL;\n    }\n  \n  return reply;\n}", "path": "client\\gvfsdaemondbus.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* string               id\n * string               name\n * string               gicon_data\n * string               uuid\n * string               root_uri\n * boolean              can-unmount\n * string               volume-id\n * array:string         x-content-types\n */\n", "func_signal": "void\ng_proxy_mount_update (GProxyMount         *mount,\n                      DBusMessageIter     *iter)", "code": "{\n  DBusMessageIter iter_struct;\n  DBusMessageIter iter_x_content_types;\n  const char *id;\n  const char *name;\n  const char *gicon_data;\n  const char *uuid;\n  const char *root_uri;\n  dbus_bool_t can_unmount;\n  const char *volume_id;\n  GPtrArray *x_content_types;\n\n  dbus_message_iter_recurse (iter, &iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &id);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &name);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &gicon_data);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &uuid);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &root_uri);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &can_unmount);\n  dbus_message_iter_next (&iter_struct);\n  dbus_message_iter_get_basic (&iter_struct, &volume_id);\n  dbus_message_iter_next (&iter_struct);\n\n  x_content_types = g_ptr_array_new ();\n  dbus_message_iter_recurse (&iter_struct, &iter_x_content_types);\n  while (dbus_message_iter_get_arg_type (&iter_x_content_types) != DBUS_TYPE_INVALID)\n    {\n      const char *x_content_type;\n      dbus_message_iter_get_basic (&iter_x_content_types, &x_content_type);\n      dbus_message_iter_next (&iter_x_content_types);\n      g_ptr_array_add (x_content_types, (gpointer) x_content_type);\n    }\n  g_ptr_array_add (x_content_types, NULL);\n  dbus_message_iter_next (&iter_struct);\n\n  if (mount->id != NULL && strcmp (mount->id, id) != 0)\n    {\n      g_warning (\"id mismatch during update of mount\");\n      goto out;\n    }\n\n  if (strlen (name) == 0)\n    name = NULL;\n  if (strlen (uuid) == 0)\n    uuid = NULL;\n\n  /* out with the old */\n  g_free (mount->id);\n  g_free (mount->name);\n  g_free (mount->uuid);\n  g_free (mount->volume_id);\n  if (mount->icon != NULL)\n    g_object_unref (mount->icon);\n  g_strfreev (mount->x_content_types);\n  if (mount->root != NULL)\n    g_object_unref (mount->root);\n\n  /* in with the new */\n  mount->id = g_strdup (id);\n  mount->name = g_strdup (name);\n  if (*gicon_data == 0)\n    mount->icon = NULL;\n  else\n    mount->icon = g_icon_new_for_string (gicon_data, NULL);\n  mount->uuid = g_strdup (uuid);\n  mount->root = g_file_new_for_uri (root_uri);\n  mount->can_unmount = can_unmount;\n  mount->volume_id = g_strdup (volume_id);\n  mount->x_content_types = g_strdupv ((char **) x_content_types->pdata);\n\n out:\n  g_ptr_array_free (x_content_types, TRUE);\n}", "path": "monitor\\proxy\\gproxymount.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Might be called on an i/o thread */\n", "func_signal": "static DBusMessage *\ncreate_reply (GVfsJob *job,\n\t      DBusConnection *connection,\n\t      DBusMessage *message)", "code": "{\n  DBusMessage *reply;\n\n  reply = dbus_message_new_method_return (message);\n  \n  return reply;\n}", "path": "daemon\\gvfsjobstopmountable.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Parse USB paths from do_mount(), or obex-data-server */\n", "func_signal": "static gboolean\n_get_numbers_from_usb_path (const char *path, int *usb_bus_num, int *usb_device_num, int *usb_intf_num)", "code": "{\n  char **tokens;\n  char *endp;\n  gboolean has_brackets = FALSE;\n\n  if (path == NULL)\n    return FALSE;\n  if (*path == '[')\n    {\n      path++;\n      has_brackets = TRUE;\n    }\n\n  tokens = g_strsplit (path + 4, \",\", 0);\n  if (g_strv_length (tokens) != 3)\n    {\n      g_strfreev (tokens);\n      return FALSE;\n    }\n\n *usb_bus_num = strtol (tokens[0], &endp, 10);\n  if (*endp != '\\0')\n    {\n      g_strfreev (tokens);\n      return FALSE;\n    }\n\n  *usb_device_num = strtol (tokens[1], &endp, 10);\n  if (*endp != '\\0')\n    {\n      g_strfreev (tokens);\n      return FALSE;\n    }\n\n  *usb_intf_num = strtol (tokens[2], &endp, 10);\n  if ((has_brackets && *endp != ']') || (!has_brackets && *endp != '\\0'))\n    {\n      g_strfreev (tokens);\n      return FALSE;\n    }\n\n  g_strfreev (tokens);\n\n  return TRUE;\n}", "path": "daemon\\gvfsbackendobexftp.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* ---------------------------------------------------------------------------------------------------- */\n", "func_signal": "static void\nstart_cb (GduDrive   *drive,\n          gchar      *assembled_drive_object_path,\n          GError     *error,\n          gpointer    user_data)", "code": "{\n  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);\n\n  if (error != NULL)\n    {\n      g_simple_async_result_set_error (simple,\n                                       G_IO_ERROR,\n                                       G_IO_ERROR_FAILED,\n                                       \"Failed activating drive: %s\",\n                                       error->message);\n      g_error_free (error);\n    }\n  else\n    {\n      g_free (assembled_drive_object_path);\n    }\n  g_simple_async_result_complete (simple);\n}", "path": "monitor\\gdu\\ggdudrive.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Might be called on an i/o thread */\n", "func_signal": "static DBusMessage *\ncreate_reply (GVfsJob *job,\n\t      DBusConnection *connection,\n\t      DBusMessage *message)", "code": "{\n  GVfsJobMountMountable *op_job = G_VFS_JOB_MOUNT_MOUNTABLE (job);\n  DBusMessage *reply;\n  DBusMessageIter iter;\n  dbus_bool_t must_mount, is_uri;\n\n  reply = dbus_message_new_method_return (message);\n\n  must_mount = op_job->must_mount_location;\n  is_uri = op_job->target_uri != NULL;\n  if (is_uri)\n    {\n      _g_dbus_message_append_args (reply,\n\t\t\t\t   DBUS_TYPE_BOOLEAN, &is_uri,\n\t\t\t\t   G_DBUS_TYPE_CSTRING, &op_job->target_uri,\n\t\t\t\t   DBUS_TYPE_BOOLEAN, &must_mount,\n\t\t\t\t   0);\n    }\n  else\n    {\n      _g_dbus_message_append_args (reply,\n\t\t\t\t   DBUS_TYPE_BOOLEAN, &is_uri,\n\t\t\t\t   G_DBUS_TYPE_CSTRING, &op_job->target_filename,\n\t\t\t\t   DBUS_TYPE_BOOLEAN, &must_mount,\n\t\t\t\t   0);\n      dbus_message_iter_init_append (reply, &iter);\n      g_mount_spec_to_dbus (&iter, op_job->mount_spec);\n    }\n  \n  return reply;\n}", "path": "daemon\\gvfsjobmountmountable.c", "repo_name": "thiblahute/gvfs", "stars": 7, "license": "other", "language": "c", "size": 12916}
{"docstring": "/* Real monitord global */\n", "func_signal": "void Monitord()", "code": "{\n    time_t tm;     \n    struct tm *p;       \n\n    int today = 0;\t\t        \n    int thismonth = 0;\n    int thisyear = 0;\n\n    char str[OS_SIZE_1024 +1];\n\n    /* Waiting a few seconds to settle */\n    sleep(10);\n\n    memset(str, '\\0', OS_SIZE_1024 +1);\n    \n    \n    /* Getting currently time before starting */\n    tm = time(NULL);\n    p = localtime(&tm);\t\n    \n    today = p->tm_mday;\n    thismonth = p->tm_mon;\n    thisyear = p->tm_year+1900;\n                \n\n    \n    /* Connecting to the message queue\n     * Exit if it fails.\n     */\n    if((mond.a_queue = StartMQ(DEFAULTQUEUE,WRITE)) < 0)\n    {\n        ErrorExit(QUEUE_FATAL, ARGV0, DEFAULTQUEUE);\n    }\n\n\n    /* Sending startup message */\n    snprintf(str, OS_SIZE_1024 -1, OS_AD_STARTED);\n    if(SendMSG(mond.a_queue, str, ARGV0,\n                       LOCALFILE_MQ) < 0)\n    {\n        merror(QUEUE_SEND, ARGV0);\n    }\n\n    \n    /* Main monitor loop */\n    while(1)\n    {\n        tm = time(NULL);\n        p = localtime(&tm);\n\n\n        /* Checking unavailable agents */\n        if(mond.monitor_agents)\n        {\n            monitor_agents();\n        }\n        \n        /* Day changed, deal with log files */\n        if(today != p->tm_mday)\n        {\n            /* Generate reports. */\n            generate_reports(today, thismonth, thisyear, p);\n\n            manage_files(today, thismonth, thisyear);\n\n            today = p->tm_mday;\n            thismonth = p->tm_mon;\n            thisyear = p->tm_year+1900;\n        }\n\n        /* We only check every two minutes */\n        sleep(120);\n    }\n}", "path": "src\\monitord\\monitord.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Special decoder for Hostinformation\n * Not using the default rendering tools for simplicity\n * and to be less resource intensive.\n */\n", "func_signal": "int DecodeHostinfo(Eventinfo *lf)", "code": "{\n    int changed = 0;\n    int bf_size;\n    \n    char *ip;\n    char *portss;\n    char *tmpstr;\n\n    char buffer[OS_MAXSTR + 1];\n    char opened[OS_MAXSTR + 1];\n    FILE *fp;\n\n    \n    /* Checking maximum number of errors */\n    if(hi_err > 30)\n    {\n        merror(\"%s: Too many errors handling host information db. \"\n               \"Ignoring it.\", ARGV0);\n        return(0);\n    }\n                \n\n    /* Zeroing buffers */\n    buffer[OS_MAXSTR] = '\\0';\n    opened[OS_MAXSTR] = '\\0';\n    fp = HI_File();\n    if(!fp)\n    {\n        merror(\"%s: Error handling host information database.\",ARGV0);\n        hi_err++; /* Increment hi error */\n\n        return(0);\n    }\n\n\n    /* Copying log to buffer */\n    strncpy(buffer,lf->log, OS_MAXSTR);\n    \n    \n    /* Getting ip */\n    tmpstr = __go_after(buffer, HOST_HOST);\n    if(!tmpstr)\n    {\n        merror(\"%s: Error handling host information database.\",ARGV0);\n        hi_err++;\n\n        return(0);\n    }\n\n    \n    /* Setting ip */\n    ip = tmpstr;\n    tmpstr = strchr(tmpstr, ',');\n    if(!tmpstr)\n    {\n        merror(\"%s: Error handling host information database.\",ARGV0);\n        hi_err++;\n\n        return(0);\n    }\n    *tmpstr = '\\0';\n    tmpstr++;\n    portss = tmpstr;\n\n\n    /* Getting ip only information -- to store */\n    tmpstr = strchr(ip, ' ');\n    if(tmpstr)\n    {\n        *tmpstr = '\\0';\n    }\n    bf_size = strlen(ip);\n    \n    \n    /* Reads the file and search for a possible\n     * entry\n     */\n    while(fgets(_hi_buf, OS_MAXSTR -1, fp) != NULL)\n    {\n        /* Ignore blank lines and lines with a comment */\n        if(_hi_buf[0] == '\\n' || _hi_buf[0] == '#')\n        {\n            continue;\n        }\n\n        /* Removing new line */\n        tmpstr = strchr(_hi_buf, '\\n');\n        if(tmpstr)\n            *tmpstr = '\\0';    \n\n\n        /* Checking for ip */\n        if(strncmp(ip, _hi_buf, bf_size) == 0)\n        {\n            /* Cannot use strncmp to avoid errors with crafted files */    \n            if(strcmp(portss, _hi_buf + bf_size) == 0)\n            {\n                return(0);\n            }\n            else\n            {\n                char *tmp_ports;\n\n                tmp_ports = _hi_buf + (bf_size +1);\n                snprintf(opened, OS_MAXSTR, \"%s %s\", PREV_OPEN, tmp_ports);\n                changed = 1;\n            }\n        }\n    }                \n\n    \n    /* Adding the new entry at the end of the file */\n    fseek(fp, 0, SEEK_END);\n    fprintf(fp,\"%s%s\\n\", ip, portss);\n\n\n    /* Setting decoder */\n    lf->decoder_info = hostinfo_dec;\n\n    \n    /* Setting comment */\n    if(changed == 1)\n    {\n        hostinfo_dec->id = id_mod;\n        //lf->generated_rule->last_events[0] = opened;\n    }\n    else\n    {\n        hostinfo_dec->id = id_new;\n    }\n    \n\n    return(1);\n}", "path": "src\\analysisd\\decoders\\hostinfo.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* OS_Exec v0.1 \n */\n", "func_signal": "void OS_Exec(int *execq, int *arq, Eventinfo *lf, active_response *ar)", "code": "{\n    char exec_msg[OS_SIZE_1024 +1];\n    char *ip;\n    char *user;\n\n\n    /* Cleaning the IP */\n    if(lf->srcip && (ar->ar_cmd->expect & SRCIP))\n    {\n        ip = strrchr(lf->srcip, ':');\n        if(ip)\n        {\n            ip++;\n        }\n        else\n        {\n            ip = lf->srcip;\n        }\n\n\n        /* Checking if IP is to ignored */\n        if(Config.white_list)\n        {\n            if(OS_IPFoundList(ip, Config.white_list))\n            {\n                return;\n            }\n        }\n\n        /* Checking if it is a hostname */\n        if(Config.hostname_white_list)\n        {\n            int srcip_size;\n            OSMatch **wl;\n\n            srcip_size = strlen(ip);\n        \n            wl = Config.hostname_white_list;\n            while(*wl)\n            {\n                if(OSMatch_Execute(ip, srcip_size, *wl))\n                    return;\n                wl++;\n            }\n        }\n    }\n    else\n    {\n        ip = \"-\";\n    }\n   \n   \n    /* Getting username */\n    if(lf->dstuser && (ar->ar_cmd->expect & USERNAME))\n    {\n        user = lf->dstuser;\n    }\n    else\n    {\n        user = \"-\";\n    }\n\n\n    /* active response on the server. \n     * The response must be here if the ar->location is set to AS\n     * or the ar->location is set to local (REMOTE_AGENT) and the\n     * event location is from here.\n     */         \n    if((ar->location & AS_ONLY) ||\n      ((ar->location & REMOTE_AGENT) && (lf->location[0] != '(')) )\n    {\n        if(!(Config.ar & LOCAL_AR))\n            return;\n            \n        snprintf(exec_msg, OS_SIZE_1024,\n                \"%s %s %s %d.%ld %d %s\",\n                ar->name,\n                user,\n                ip,\n                lf->time,\n                __crt_ftell,\n                lf->generated_rule->sigid,\n                lf->location);\n\n        if(OS_SendUnix(*execq, exec_msg, 0) < 0)\n        {\n            merror(\"%s: Error communicating with execd.\", ARGV0);\n        }\n    }\n   \n\n    /* Active response to the forwarder */ \n    else if((Config.ar & REMOTE_AR) && (lf->location[0] == '('))\n    {\n        int rc;\n        snprintf(exec_msg, OS_SIZE_1024,\n                \"%s %c%c%c %s %s %s %s %d.%ld %d %s\",\n                lf->location,\n                (ar->location & ALL_AGENTS)?ALL_AGENTS_C:NONE_C,\n                (ar->location & REMOTE_AGENT)?REMOTE_AGENT_C:NONE_C,\n                (ar->location & SPECIFIC_AGENT)?SPECIFIC_AGENT_C:NONE_C,\n                ar->agent_id != NULL? ar->agent_id: \"(null)\",\n                ar->name,\n                user,\n                ip,\n                lf->time,\n                __crt_ftell,\n                lf->generated_rule->sigid,\n                lf->location);\n       \n        if((rc = OS_SendUnix(*arq, exec_msg, 0)) < 0)\n        {\n            if(rc == OS_SOCKBUSY)\n            {\n                merror(\"%s: AR socket busy.\", ARGV0);\n            }\n            else\n            {\n                merror(\"%s: AR socket error (shutdown?).\", ARGV0);   \n            }\n            merror(\"%s: Error communicating with ar queue (%d).\", ARGV0, rc);\n        }\n    }\n    \n    return;\n}", "path": "src\\analysisd\\alerts\\exec.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* ID Search (is valid ID) */\n", "func_signal": "int IDExist(char *id)", "code": "{\n    FILE *fp;\n    char line_read[FILE_SIZE +1];\n    line_read[FILE_SIZE] = '\\0';\n   \n    /* ID must not be null */ \n    if(!id)\n        return(0);\n\n    fp = fopen(AUTH_FILE, \"r\");\n    if(!fp)\n        return(0);\n        \n    fseek(fp, 0, SEEK_SET);\n    fgetpos(fp, &fp_pos);\n    \n    while(fgets(line_read,FILE_SIZE -1, fp) != NULL)\n    {\n        char *name;\n\n        if(line_read[0] == '#')\n        {\n            fgetpos(fp, &fp_pos);\n            continue;\n        }\n        \n        name = strchr(line_read, ' ');\n        if(name)\n        {\n            *name = '\\0';\n            name++;\n\n            if(strcmp(line_read,id) == 0)\n            {\n                fclose(fp);\n                return (1); /*(fp_pos);*/\n            }\n        }\n\n        fgetpos(fp, &fp_pos);\n    }\n\n    fclose(fp);\n    return(0);\n}", "path": "src\\addagent\\validate.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* read_dir v0.1\n *\n */\n", "func_signal": "int read_proc_dir(char *dir_name, char *pid, int position)", "code": "{\n    DIR *dp;\n    \n\tstruct dirent *entry;\n\t\n    \n    if((dir_name == NULL)||(strlen(dir_name) > PATH_MAX))\n    {\n        merror(\"%s: Invalid directory given\",ARGV0);\n        return(-1);\n    }\n    \n    /* Opening the directory given */\n    dp = opendir(dir_name);\n\tif(!dp)\n    {\n        return(0);\n    }\n\n    while((entry = readdir(dp)) != NULL)\n    {\n        char f_name[PATH_MAX +2];\n\n        /* Just ignore . and ..  */\n        if((strcmp(entry->d_name,\".\") == 0) ||\n           (strcmp(entry->d_name,\"..\") == 0))  \n            continue;\n\n        if(position == PROC)\n        {\n            char *tmp_str;\n\n            tmp_str = entry->d_name;\n\n            while(*tmp_str != '\\0')\n            {\n                if(!isdigit((int)*tmp_str))\n                    break;\n                tmp_str++;\n            }\n\n            if(*tmp_str != '\\0')\n                continue;\n           \n            \n            snprintf(f_name, PATH_MAX +1, \"%s/%s\",dir_name, entry->d_name);\n\n            read_proc_file(f_name, pid, position+1);\n        }\n\n        else if(position == PID)\n        {\n            if(strcmp(entry->d_name, \"task\") == 0)\n            {\n                snprintf(f_name, PATH_MAX +1, \"%s/%s\",dir_name, entry->d_name);\n                read_proc_file(f_name, pid, position+1);\n            }\n        }\n\n        else if(position == TASK)\n        {\n            /* checking under proc/pid/task/lwp */\n            if(strcmp(entry->d_name, pid) == 0)\n            {\n                proc_pid_found = 1;\n                break;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    closedir(dp);\n    \n    return(0);\n}", "path": "src\\rootcheck\\check_rc_readproc.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/** void ExecdStart(int q) v0.2\n * Main function on the execd. Does all the data receiving ,etc.\n */\n", "func_signal": "void ExecdStart(int q)", "code": "{\n    int i, childcount = 0;\n    time_t curr_time;\n    \n    char buffer[OS_MAXSTR + 1];\n    char *tmp_msg = NULL;\n    char *name;\n    char *command;\n    char *cmd_args[MAX_ARGS +2];\n\n\n    /* Select */\n    fd_set fdset;\n    struct timeval socket_timeout;\n\n    \n    /* Clearing the buffer */\n    memset(buffer, '\\0', OS_MAXSTR +1);\n    \n    \n    /* Initializing the cmd arguments */\n    for(i = 0; i<= MAX_ARGS +1; i++)\n    {\n        cmd_args[i] = NULL;\n    }\n   \n    \n    /* Creating list for timeout */\n    timeout_list = OSList_Create(); \n    if(!timeout_list)\n    {\n        ErrorExit(LIST_ERROR, ARGV0);\n    }\n    \n   \n    /* Main loop. */\n    while(1)\n    {\n        int timeout_value;\n        int added_before = 0;\n    \n        char **timeout_args;\n        timeout_data *timeout_entry;\n\n\n        /* Cleaning up any child. */\n        while (childcount)\n        {\n            int wp;\n            wp = waitpid((pid_t) -1, NULL, WNOHANG);\n            if (wp < 0)\n            {\n                merror(WAITPID_ERROR, ARGV0);\n            }\n\n            /* if = 0, we still need to wait for the child process */\n            else if (wp == 0)\n            {\n                break;\n            }\n            /* Child completed if wp > 0 */\n            else\n            {\n                childcount--;\n            }\n        }\n\n\n        /* Getting currently time */\n        curr_time = time(0);\n\n\n        /* Checking if there is any timeouted command to execute. */\n        timeout_node = OSList_GetFirstNode(timeout_list);\n        while(timeout_node)\n        {\n            timeout_data *list_entry;\n\n            list_entry = (timeout_data *)timeout_node->data;\n            \n            /* Timeouted */\n            if((curr_time - list_entry->time_of_addition) > \n                    list_entry->time_to_block)\n            {\n                ExecCmd(list_entry->command);\n                \n                /* Deletecurrently node already sets the pointer to next */\n                OSList_DeleteCurrentlyNode(timeout_list);\n                timeout_node = OSList_GetCurrentlyNode(timeout_list);\n\n                /* Clearing the memory */\n                FreeTimeoutEntry(list_entry);\n\n                childcount++;\n            }\n\n            else\n            {\n                timeout_node = OSList_GetNextNode(timeout_list);\n            }\n        }\n\n        \n        /* Setting timeout to EXECD_TIMEOUT */\n        socket_timeout.tv_sec = EXECD_TIMEOUT;\n        socket_timeout.tv_usec= 0;\n\n\n\n        /* Setting FD values */\n        FD_ZERO(&fdset);\n        FD_SET(q, &fdset);\n\n        /* Adding timeout */\n        if(select(q+1, &fdset, NULL, NULL, &socket_timeout) == 0)\n        {\n            /* Timeout .. */\n            continue;\n        }\n\n\n        /* Checking for error */\n        if(!FD_ISSET(q, &fdset))\n        {\n            merror(SELECT_ERROR, ARGV0);\n            continue;\n        }\n\n\n        /* Receiving the message */\n        if(recv(q, buffer, OS_MAXSTR, 0) == -1)\n        {\n            merror(QUEUE_ERROR, ARGV0, EXECQUEUEPATH, strerror(errno));\n            continue;\n        }\n\n\n        /* Currently time */\n        curr_time = time(0);\n\n\n        /* Getting application name */\n        name = buffer;\n        \n        \n        /* Zeroing the name */\n        tmp_msg = strchr(buffer, ' ');\n        if(!tmp_msg)\n        {\n            merror(EXECD_INV_MSG, ARGV0, buffer);\n            continue;\n        }\n        *tmp_msg = '\\0';\n        tmp_msg++;\n\n\n        /* Getting the command to execute (valid name) */\n        command = GetCommandbyName(name, &timeout_value);\n        if(!command)\n        {\n            ReadExecConfig();\n            command = GetCommandbyName(name, &timeout_value);\n            if(!command)\n            {\n                merror(EXEC_INV_NAME, ARGV0, name);\n                continue;\n            }\n        }\n\n\n        /* Command not present. */\n        if(command[0] == '\\0')\n            continue;\n\n\n        /* Allocating memory for the timeout argument */\n        os_calloc(MAX_ARGS+2, sizeof(char *), timeout_args);\n        \n\n        /* Adding initial variables to the cmd_arg and to the timeout cmd */\n        cmd_args[0] = command; \n        cmd_args[1] = ADD_ENTRY;\n        os_strdup(command, timeout_args[0]);\n        os_strdup(DELETE_ENTRY, timeout_args[1]);\n\n        cmd_args[2] = NULL;\n        timeout_args[2] = NULL;\n\n\n        /* Getting the arguments. */\n        i = 2;\n        while(i < (MAX_ARGS -1))\n        {\n            cmd_args[i] = tmp_msg;\n            cmd_args[i+1] = NULL;\n\n            tmp_msg = strchr(tmp_msg, ' ');\n            if(!tmp_msg)\n            {\n                timeout_args[i] = strdup(cmd_args[i]);\n                timeout_args[i+1] = NULL;\n                break;\n            }\n            *tmp_msg = '\\0';\n            tmp_msg++;\n\n            timeout_args[i] = strdup(cmd_args[i]);\n            timeout_args[i+1] = NULL;\n\n            i++;\n        }\n        \n\n        /* Check this command was already executed. */\n        timeout_node = OSList_GetFirstNode(timeout_list);\n        added_before = 0;\n\n\n        /* Checking for the username and ip argument */\n        if(!timeout_args[2] || !timeout_args[3])\n        {\n            added_before = 1;\n            merror(\"%s: Invalid number of arguments.\", ARGV0);\n        }\n        \n        while(timeout_node)\n        {\n            timeout_data *list_entry;\n\n            list_entry = (timeout_data *)timeout_node->data;\n            if((strcmp(list_entry->command[3], timeout_args[3]) == 0) &&\n               (strcmp(list_entry->command[0], timeout_args[0]) == 0)) \n            {\n                /* Means we executed this command before\n                 * and we don't need to add it again.\n                 */\n                added_before = 1;\n\n\n                /* updating the timeout */\n                list_entry->time_of_addition = curr_time;\n                break;\n            }\n\n            /* Continue with the next entry in timeout list*/\n            timeout_node = OSList_GetNextNode(timeout_list);\n        }\n\n\n        /* If it wasn't added before, do it now */\n        if(!added_before)\n        {\n            /* executing command */\n            ExecCmd(cmd_args);\n\n            /* We don't need to add to the list if the timeout_value == 0 */\n            if(timeout_value)\n            {\n                /* Creating the timeout entry */\n                os_calloc(1, sizeof(timeout_data), timeout_entry);\n                timeout_entry->command = timeout_args;\n                timeout_entry->time_of_addition = curr_time;\n                timeout_entry->time_to_block = timeout_value;\n\n\n                /* Adding command to the timeout list */\n                if(!OSList_AddData(timeout_list, timeout_entry))\n                {\n                    merror(LIST_ADD_ERROR, ARGV0);\n                    FreeTimeoutEntry(timeout_entry);\n                } \n            }\n            \n            /* If no timeout, we still need to free it in here */\n            else\n            {\n                char **ss_ta = timeout_args;\n                while(*timeout_args)\n                {\n                    os_free(*timeout_args);\n                    *timeout_args = NULL;\n                    timeout_args++;\n                }\n                os_free(ss_ta);\n            }\n\n            childcount++;\n        }\n        \n        /* We didn't add it to the timeout list */\n        else\n        {\n            char **ss_ta = timeout_args;\n\n            /* Clear the timeout arguments */\n            while(*timeout_args)\n            {\n                os_free(*timeout_args);\n                *timeout_args = NULL;\n                timeout_args++;\n            }\n\n            os_free(ss_ta);\n        }\n\n        /* Some cleanup */\n        while(i > 0)\n        {\n            cmd_args[i] = NULL;\n            i--;\n        }\n    }\n}", "path": "src\\os_execd\\execd.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* print available agents */\n", "func_signal": "int print_agents(int print_status, int active_only, int csv_output)", "code": "{\n    int total = 0;\n    FILE *fp;\n    char line_read[FILE_SIZE +1];\n    line_read[FILE_SIZE] = '\\0';\n\n    fp = fopen(AUTH_FILE, \"r\");\n    if(!fp)\n        return(0);\n\n    fseek(fp, 0, SEEK_SET);\n    \n    memset(line_read,'\\0',FILE_SIZE);\n    \n    while(fgets(line_read, FILE_SIZE -1, fp) != NULL)\n    {\n        char *name;\n\n        if(line_read[0] == '#')\n            continue;\n            \n        name = strchr(line_read, ' ');\n        if(name)\n        {\n            char *ip;\n            *name = '\\0';\n            name++;\n\n\n            /* Removed agent. */\n            if(*name == '#')\n            {\n                continue;\n            }\n            \n            ip = strchr(name, ' ');\n            if(ip)\n            {\n                char *key;\n                *ip = '\\0';\n                ip++;\n                key = strchr(ip, ' ');\n                if(key)\n                {\n                    *key = '\\0';\n                    if(!total && !print_status)\n                        printf(PRINT_AVAILABLE);\n                    total++;\n\n                    \n                    if(print_status)\n                    {\n                        int agt_status = get_agent_status(name, ip);\n                        if(active_only && (agt_status != GA_STATUS_ACTIVE))\n                        {\n                            continue;\n                        }\n            \n                        if(csv_output)\n                        {\n                            printf(\"%s,%s,%s,%s,\\n\", line_read, name, ip, \n                                                  print_agent_status(agt_status));  \n                        }\n                        else\n                        {\n                            printf(PRINT_AGENT_STATUS, line_read, name, ip, \n                                   print_agent_status(agt_status));\n                        }\n                    }\n                    else\n                    {\n                        printf(PRINT_AGENT, line_read, name, ip);\n                    }\n                }\n                \n            }\n        }\n    }\n\n\n    /* Only print agentless for non-active only searches */\n    if(!active_only && print_status)\n    {\n        char *aip = NULL;\n        DIR *dirp;\n        struct dirent *dp;\n        \n        if(!csv_output)\n        {\n            printf(\"\\nList of agentless devices:\\n\");\n        }\n\n        dirp = opendir(AGENTLESS_ENTRYDIR);\n        if(dirp)\n        {\n            while ((dp = readdir(dirp)) != NULL)\n            {\n                if(strncmp(dp->d_name, \".\", 1) == 0)\n                {\n                    continue;\n                }\n\n                aip = strchr(dp->d_name, '@');\n                if(aip)\n                {\n                    aip++;\n                }\n                else\n                {\n                    aip = \"<na>\";\n                }\n\n                if(csv_output)\n                {\n                    printf(\"na,%s,%s,agentless,\\n\", dp->d_name, aip);\n                }\n                else\n                {\n                    printf(\"   ID: na, Name: %s, IP: %s, agentless\\n\",\n                           dp->d_name, aip);\n                }\n            }\n            closedir(dirp);\n        }\n    }\n\n    fclose(fp);\n    if(total)\n        return(1);\n    \n    return(0);    \n}", "path": "src\\addagent\\validate.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Validate agent name.\n */\n", "func_signal": "int OS_IsValidName(char *u_name)", "code": "{\n    int i = 0;\n\n    /* We must have something in the name */\n    if(strlen(u_name) < 2 || strlen(u_name) > 128)\n      return(0);\n\n    /* check if it contains any non-alphanumeric characters */\n    for(i = 0; i < strlen(u_name); i++)\n    {\n      if(!isalnum((int)u_name[i]) && (u_name[i] != '-') && \n         (u_name[i] != '_') && (u_name[i] != '.'))\n        return(0);\n    }\n\n    return(1);\n}", "path": "src\\addagent\\validate.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/** int os_getprime\n * Get the first available prime after the provided value.\n * Returns 0 on error.\n */\n", "func_signal": "int os_getprime(int val)", "code": "{\n    int i;\n    int max_i;\n    \n    /* Value can't be even */\n    if((val % 2) == 0)\n    {\n        val++;\n    }\n   \n   \n    do\n    {\n        /* We just need to check odd numbers up until half\n         * the size of the provided value.\n         */\n        i = 3;\n        max_i = val/2;\n        while(i <= max_i)\n        {\n            /* Not prime */\n            if((val % i) == 0)\n            {\n                break;\n            }\n            i += 2;\n        }\n\n        /* Prime */\n        if(i >= max_i)\n        {\n            return(val);\n        }\n    }while(val += 2);\n\n    return(0);\n}", "path": "src\\shared\\math_op.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* OS_DBD: Monitor the alerts and insert them into the database.\n * Only return in case of error.\n */\n", "func_signal": "void OS_DBD(DBConfig *db_config)", "code": "{\n    time_t tm;     \n    struct tm *p;       \n\n    file_queue *fileq;\n    alert_data *al_data;\n\n\n    /* Getting currently time before starting */\n    tm = time(NULL);\n    p = localtime(&tm);\t\n\n\n    /* Initating file queue - to read the alerts */\n    os_calloc(1, sizeof(file_queue), fileq);\n    Init_FileQueue(fileq, p, 0);\n\n\n    /* Creating location hash */\n    db_config->location_hash = OSHash_Create();\n    if(!db_config->location_hash)\n    {\n        ErrorExit(MEM_ERROR, ARGV0);\n    }\n\n\n    /* Getting maximum ID */\n    db_config->alert_id = OS_SelectMaxID(db_config);\n    db_config->alert_id++;\n\n\n    /* Infinite loop reading the alerts and inserting them. */\n    while(1)\n    {\n        tm = time(NULL);\n        p = localtime(&tm);\n\n\n        /* Get message if available (timeout of 5 seconds) */\n        al_data = Read_FileMon(fileq, p, 5);\n        if(!al_data)\n        {\n            continue;\n        }\n\n\n        /* Inserting into the db */\n        OS_Alert_InsertDB(al_data, db_config);\n\n\n        /* Clearing the memory */\n        FreeAlertData(al_data);\n    }\n}", "path": "src\\os_dbd\\dbd.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* HostinfoInit\n * Initialize the necessary information to process the host information\n */\n", "func_signal": "void HostinfoInit()", "code": "{\n    hi_err = 0;\n\n\n    /* Zeroing decoder */\n    os_calloc(1, sizeof(OSDecoderInfo), hostinfo_dec);\n    hostinfo_dec->id = getDecoderfromlist(HOSTINFO_MOD);\n    hostinfo_dec->type = OSSEC_RL;\n    hostinfo_dec->name = HOSTINFO_MOD;\n    hostinfo_dec->fts = 0;\n    id_new = getDecoderfromlist(HOSTINFO_NEW);\n    id_mod = getDecoderfromlist(HOSTINFO_MOD);\n\n\n\n    /* Opening HOSTINFO_FILE */\n    snprintf(_hi_buf,OS_SIZE_1024, \"%s\", HOSTINFO_FILE);\n    \n\n    /* r+ to read and write. Do not truncate */\n    _hi_fp = fopen(_hi_buf,\"r+\");\n    if(!_hi_fp)\n    {\n        /* try opening with a w flag, file probably does not exist */\n        _hi_fp = fopen(_hi_buf, \"w\");\n        if(_hi_fp)\n        {\n            fclose(_hi_fp);\n            _hi_fp = fopen(_hi_buf, \"r+\");\n        }\n    }\n    if(!_hi_fp)\n    {\n        merror(FOPEN_ERROR, ARGV0, _hi_buf);\n        return;\n    }\n\n    \n    /* clearing the buffer */\n    memset(_hi_buf, '\\0', OS_MAXSTR +1);\n\n    return;\n}", "path": "src\\analysisd\\decoders\\hostinfo.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* HI_File\n * Return the file pointer to be used\n */\n", "func_signal": "FILE *HI_File()", "code": "{\n    if(_hi_fp)\n    {\n        fseek(_hi_fp, 0, SEEK_SET);\n        return(_hi_fp);\n    }\n\n    return(NULL);\n}", "path": "src\\analysisd\\decoders\\hostinfo.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/** void FreeTimeoutEntry(timeout_data *timeout_entry) v0.1\n * Free the timeout entry. Must be called after popping it\n * from the timeout list\n */\n", "func_signal": "void FreeTimeoutEntry(void *timeout_entry_pt)", "code": "{\n    timeout_data *timeout_entry;\n    char **tmp_str;\n\n    timeout_entry = (timeout_data *)timeout_entry_pt;\n\n    if(!timeout_entry)\n    {\n        return;\n    }\n    \n    tmp_str = timeout_entry->command;\n\n    /* Clearing the command arguments */\n    if(tmp_str)\n    {\n        while(*tmp_str)\n        {\n            os_free(*tmp_str);\n            *tmp_str = NULL;\n            tmp_str++;\n        }\n        os_free(timeout_entry->command);\n        timeout_entry->command = NULL;\n    }\n\n    os_free(timeout_entry);\n    timeout_entry = NULL;\n\n    return;\n}", "path": "src\\os_execd\\execd.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Get full agent name (name + ip) of ID.\n */\n", "func_signal": "char *getFullnameById(char *id)", "code": "{\n    FILE *fp;\n    char line_read[FILE_SIZE +1];\n    line_read[FILE_SIZE] = '\\0';\n\n    /* ID must not be null */\n    if(!id)\n        return(NULL);\n\n    fp = fopen(AUTH_FILE, \"r\");\n    if(!fp)\n        return(NULL);\n\n\n    while(fgets(line_read, FILE_SIZE -1, fp) != NULL)\n    {\n        char *name;\n        char *ip;\n        char *tmp_str;\n\n        if(line_read[0] == '#')\n        {\n            continue;\n        }\n\n        name = strchr(line_read, ' ');\n        if(name)\n        {\n            *name = '\\0';\n            /* Didn't match */\n            if(strcmp(line_read,id) != 0)\n            {\n                continue;\n            }\n\n            name++;\n\n            /* Removed entry */\n            if(*name == '#')\n            {\n                continue;\n            }\n            \n            ip = strchr(name, ' ');\n            if(ip)\n            {\n                *ip = '\\0';\n                ip++;\n\n                /* Cleaning up ip */\n                tmp_str = strchr(ip, ' ');\n                if(tmp_str)\n                {\n                    char *final_str;\n                    *tmp_str = '\\0';\n                    tmp_str = strchr(ip, '/');\n                    if(tmp_str)\n                        *tmp_str = '\\0';\n\n                    /* If we reached here, we found the IP and name */\n                    os_calloc(1, FILE_SIZE, final_str);\n                    snprintf(final_str, FILE_SIZE -1, \"%s-%s\", name, ip);\n\n                    fclose(fp);\n                    return(final_str);        \n                }\n            }\n        }\n    }\n\n    fclose(fp);\n    return(NULL);\n}", "path": "src\\addagent\\validate.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Check if the string matches.\n */\n", "func_signal": "static char *__go_after(char *x, char *y)", "code": "{\n    int x_s;\n    int y_s;\n\n    /* X and Y must be not null */\n    if(!x || !y)\n        return(NULL);\n\n    x_s = strlen(x);\n    y_s = strlen(y);\n\n    if(x_s <= y_s)\n    {\n        return(NULL);\n    }\n\n    /* String does not match */\n    if(strncmp(x,y,y_s) != 0)\n    {\n        return(NULL);\n    }\n\n    x+=y_s;\n\n    return(x);\n}", "path": "src\\analysisd\\decoders\\hostinfo.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Is_Name (is valid name) */\n", "func_signal": "int NameExist(char *u_name)", "code": "{\n    FILE *fp;\n    char line_read[FILE_SIZE +1];\n    line_read[FILE_SIZE] = '\\0';\n\n    if((!u_name)||\n       (*u_name == '\\0')||\n       (*u_name == '\\r')||\n       (*u_name == '\\n'))\n        return(0);\n\n    fp = fopen(AUTH_FILE, \"r\");\n    if(!fp)\n        return(0);\n\n\n    fseek(fp, 0, SEEK_SET);\n    fgetpos(fp, &fp_pos);\n\n\n    while(fgets(line_read, FILE_SIZE-1, fp) != NULL)\n    {\n        char *name;\n\n        if(line_read[0] == '#')\n            continue;\n\n        name = strchr(line_read, ' ');\n        if(name)\n        {\n            char *ip;\n            name++;\n\n            if(*name == '#')\n            {\n                continue;\n            }\n            \n            ip = strchr(name, ' ');\n            if(ip)\n            {\n                *ip = '\\0';\n                if(strcmp(u_name, name) == 0)\n                {\n                    fclose(fp);\n                    return(1);\n                }\n            }\n        }\n        fgetpos(fp, &fp_pos);\n    }\n\n    fclose(fp);\n    return(0);\n}", "path": "src\\addagent\\validate.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/** int main(int argc, char **argv) v0.1\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int c;\n    int test_config = 0,run_foreground = 0;\n    int gid = 0,m_queue = 0;\n\n    char *dir  = DEFAULTDIR;\n    char *group = GROUPGLOBAL;\n    char *cfg = DEFAULTARPATH;\n    char *xmlcfg = DEFAULTCPATH;\n\n\n    /* Setting the name */\n    OS_SetName(ARGV0);\n        \n\n    while((c = getopt(argc, argv, \"Vtdhfu:g:D:c:\")) != -1){\n        switch(c){\n            case 'V':\n                print_version();\n                break;\n            case 'h':\n                help(ARGV0);\n                break;\n            case 'd':\n                nowDebug();\n                break;\n            case 'f':\n                run_foreground = 1;\n                break;\n            case 'g':\n                if(!optarg)\n                    ErrorExit(\"%s: -g needs an argument.\",ARGV0);\n                group = optarg;\n                break;\n            case 'D':\n                if(!optarg)\n                    ErrorExit(\"%s: -D needs an argument.\",ARGV0);\n                dir = optarg;\n            case 'c':\n                if(!optarg)\n                    ErrorExit(\"%s: -c needs an argument.\",ARGV0);\n                cfg = optarg;\n                break;\n            case 't':\n                test_config = 1;\n                break;    \n            default:\n                help(ARGV0);\n                break;\n        }\n\n    }\n\n\n\n    /* Check if the group given are valid */\n    gid = Privsep_GetGroup(group);\n    if(gid < 0)\n        ErrorExit(USER_ERROR,ARGV0,\"\",group);\n\n\n    /* Privilege separation */  \n    if(Privsep_SetGroup(gid) < 0)\n        ErrorExit(SETGID_ERROR,ARGV0,group);\n\n\n    /* Reading config */\n    if((c = ExecdConfig(xmlcfg)) < 0)\n    {\n        ErrorExit(CONFIG_ERROR, ARGV0, xmlcfg);\n    }\n\n\n    /* Exit if test_config */\n    if(test_config)\n        exit(0);\n        \n        \n    /* Signal manipulation */\n    StartSIG2(ARGV0, execd_shutdown);\n\n    \n    if (!run_foreground) \n    {\n        /* Going daemon */\n        nowDaemon();\n        goDaemon();\n    } \n\n\n    /* Active response disabled */\n    if(c == 1)\n    {\n        verbose(EXEC_DISABLED, ARGV0);\n        exit(0);\n    }\n    \n    /* Creating the PID file */\n    if(CreatePID(ARGV0, getpid()) < 0)\n        merror(PID_ERROR, ARGV0);\n\n    \n    /* Starting queue (exec queue) */\n    if((m_queue = StartMQ(EXECQUEUEPATH,READ)) < 0)\n        ErrorExit(QUEUE_ERROR, ARGV0, EXECQUEUEPATH, strerror(errno));\n\n\n    /* Start up message */\n    verbose(STARTUP_MSG, ARGV0, (int)getpid());\n        \n\n    /* The real daemon Now */  \n    ExecdStart(m_queue);\n    \n    exit(0);\n}", "path": "src\\os_execd\\execd.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/* Setup windows after install */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    printf(\"%s: Attempting to start ossec.\", argv[0]);\n\n    system(\"net start OssecSvc\");\n    \n    system(\"pause\");\n    return(0);\n}", "path": "src\\win32\\service-start.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/*  int check_rc_readproc(int pid): v0.1\n *  Reads the /proc directory (if present) and checks\n *  if the given pid is there (or as a PID or as a thread).\n */\n", "func_signal": "int check_rc_readproc(int pid)", "code": "{\n    char char_pid[32];\n\n    proc_pid_found = 0;\n   \n    /* NL threads */ \n    snprintf(char_pid, 31, \"/proc/.%d\", pid);\n    if(is_file(char_pid))\n        return(1);\n    \n    \n    snprintf(char_pid, 31, \"%d\", pid);\n    \n    read_proc_dir(\"/proc\", char_pid, PROC);\n    \n    return(proc_pid_found);\n}", "path": "src\\rootcheck\\check_rc_readproc.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "/** \n * Shudowns execd properly.\n */\n", "func_signal": "void execd_shutdown()", "code": "{\n    /* Removing pending active responses. */\n    merror(EXEC_SHUTDOWN, ARGV0);\n    \n    timeout_node = OSList_GetFirstNode(timeout_list);\n    while(timeout_node)\n    {\n        timeout_data *list_entry;\n\n        list_entry = (timeout_data *)timeout_node->data;\n\n        ExecCmd(list_entry->command);\n\n        /* Delete currently node - already sets the pointer to next */\n        OSList_DeleteCurrentlyNode(timeout_list);\n        timeout_node = OSList_GetCurrentlyNode(timeout_list);\n    }\n\n    #ifndef WIN32\n    HandleSIG();\n    #endif\n\n}", "path": "src\\os_execd\\execd.c", "repo_name": "jrossi/ossec-hids-old-unused", "stars": 5, "license": "other", "language": "c", "size": 9555}
{"docstring": "// two processes create and delete different files in same directory\n", "func_signal": "void\ncreatedelete(void)", "code": "{\n  enum { N = 20 };\n  int pid, i, fd;\n  char name[32];\n\n  printf(1, \"createdelete test\\n\");\n  pid = fork();\n  if(pid < 0){\n    printf(1, \"fork failed\\n\");\n    exit();\n  }\n\n  name[0] = pid ? 'p' : 'c';\n  name[2] = '\\0';\n  for(i = 0; i < N; i++){\n    name[1] = '0' + i;\n    fd = open(name, O_CREATE | O_RDWR);\n    if(fd < 0){\n      printf(1, \"create failed\\n\");\n      exit();\n    }\n    close(fd);\n    if(i > 0 && (i % 2 ) == 0){\n      name[1] = '0' + (i / 2);\n      if(unlink(name) < 0){\n        printf(1, \"unlink failed\\n\");\n        exit();\n      }\n    }\n  }\n\n  if(pid==0)\n    exit();\n  else\n    wait();\n\n  for(i = 0; i < N; i++){\n    name[0] = 'p';\n    name[1] = '0' + i;\n    fd = open(name, 0);\n    if((i == 0 || i >= N/2) && fd < 0){\n      printf(1, \"oops createdelete %s didn't exist\\n\", name);\n      exit();\n    } else if((i >= 1 && i < N/2) && fd >= 0){\n      printf(1, \"oops createdelete %s did exist\\n\", name);\n      exit();\n    }\n    if(fd >= 0)\n      close(fd);\n\n    name[0] = 'c';\n    name[1] = '0' + i;\n    fd = open(name, 0);\n    if((i == 0 || i >= N/2) && fd < 0){\n      printf(1, \"oops createdelete %s didn't exist\\n\", name);\n      exit();\n    } else if((i >= 1 && i < N/2) && fd >= 0){\n      printf(1, \"oops createdelete %s did exist\\n\", name);\n      exit();\n    }\n    if(fd >= 0)\n      close(fd);\n  }\n\n  for(i = 0; i < N; i++){\n    name[0] = 'p';\n    name[1] = '0' + i;\n    unlink(name);\n    name[0] = 'c';\n    unlink(name);\n  }\n\n  printf(1, \"createdelete ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Bootstrap processor gets here after setting up the hardware.\n// Additional processors start here.\n", "func_signal": "static void\nmpmain(void)", "code": "{\n  cprintf(\"cpu%d: mpmain\\n\", cpu());\n  idtinit();\n  if(cpu() != mp_bcpu())\n    lapic_init(cpu());\n  setupsegs(0);\n  xchg(&cpus[cpu()].booted, 1);\n\n  cprintf(\"cpu%d: scheduling\\n\");\n  scheduler();\n}", "path": "main.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Is the directory dp empty except for \".\" and \"..\" ?\n", "func_signal": "static int\nisdirempty(struct inode *dp)", "code": "{\n  int off;\n  struct dirent de;\n\n  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){\n    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))\n      panic(\"isdirempty: readi\");\n    if(de.inum != 0)\n      return 0;\n  }\n  return 1;\n}", "path": "sysfile.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Spin for a given number of microseconds.\n// On real hardware would want to tune this dynamically.\n", "func_signal": "static void\nmicrodelay(int us)", "code": "{\n  volatile int j = 0;\n  \n  while(us-- > 0)\n    for(j=0; j<10000; j++);\n}", "path": "lapic.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Bootstrap processor starts running C code here.\n", "func_signal": "int\nmain(void)", "code": "{\n  extern char edata[], end[];\n\n  // clear BSS\n  memset(edata, 0, end - edata);\n\n  mp_init(); // collect info about this machine\n  lapic_init(mp_bcpu());\n  cprintf(\"\\ncpu%d: starting xv6\\n\\n\", cpu());\n\n  pinit();         // process table\n  binit();         // buffer cache\n  pic_init();      // interrupt controller\n  ioapic_init();   // another interrupt controller\n  kinit();         // physical memory allocator\n  tvinit();        // trap vectors\n  fileinit();      // file table\n  iinit();         // inode cache\n  console_init();  // I/O devices & their interrupts\n  ide_init();      // disk\n  if(!ismp)\n    timer_init();  // uniprocessor timer\n  userinit();      // first user process\n  bootothers();    // start other processors\n\n  // Finish setting up this processor in mpmain.\n  mpmain();\n}", "path": "main.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// test concurrent create and unlink of the same file\n", "func_signal": "void\nconcreate(void)", "code": "{\n  char file[3];\n  int i, pid, n, fd;\n  char fa[40];\n  struct {\n    ushort inum;\n    char name[14];\n  } de;\n\n  printf(1, \"concreate test\\n\");\n  file[0] = 'C';\n  file[2] = '\\0';\n  for(i = 0; i < 40; i++){\n    file[1] = '0' + i;\n    unlink(file);\n    pid = fork();\n    if(pid && (i % 3) == 1){\n      link(\"C0\", file);\n    } else if(pid == 0 && (i % 5) == 1){\n      link(\"C0\", file);\n    } else {\n      fd = open(file, O_CREATE | O_RDWR);\n      if(fd < 0){\n        printf(1, \"concreate create %s failed\\n\", file);\n        exit();\n      }\n      close(fd);\n    }\n    if(pid == 0)\n      exit();\n    else\n      wait();\n  }\n\n  memset(fa, 0, sizeof(fa));\n  fd = open(\".\", 0);\n  n = 0;\n  while(read(fd, &de, sizeof(de)) > 0){\n    if(de.inum == 0)\n      continue;\n    if(de.name[0] == 'C' && de.name[2] == '\\0'){\n      i = de.name[1] - '0';\n      if(i < 0 || i >= sizeof(fa)){\n        printf(1, \"concreate weird file %s\\n\", de.name);\n        exit();\n      }\n      if(fa[i]){\n        printf(1, \"concreate duplicate file %s\\n\", de.name);\n        exit();\n      }\n      fa[i] = 1;\n      n++;\n    }\n  }\n  close(fd);\n\n  if(n != 40){\n    printf(1, \"concreate not enough files in directory listing\\n\");\n    exit();\n  }\n\n  for(i = 0; i < 40; i++){\n    file[1] = '0' + i;\n    pid = fork();\n    if(pid < 0){\n      printf(1, \"fork failed\\n\");\n      exit();\n    }\n    if(((i % 3) == 0 && pid == 0) ||\n       ((i % 3) == 1 && pid != 0)){\n      fd = open(file, 0);\n      close(fd);\n    } else {\n      unlink(file);\n    }\n    if(pid == 0)\n      exit();\n    else\n      wait();\n  }\n\n  printf(1, \"concreate ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Allocate a file descriptor for the given file.\n// Takes over file reference from caller on success.\n", "func_signal": "static int\nfdalloc(struct file *f)", "code": "{\n  int fd;\n\n  for(fd = 0; fd < NOFILE; fd++){\n    if(cp->ofile[fd] == 0){\n      cp->ofile[fd] = f;\n      return fd;\n    }\n  }\n  return -1;\n}", "path": "sysfile.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Initialized in mp.c\n", "func_signal": "static void\nlapicw(int index, int value)", "code": "{\n  lapic[index] = value;\n  lapic[ID];  // wait for write to finish, by reading\n}", "path": "lapic.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// test that iput() is called at the end of _namei()\n", "func_signal": "void\niref(void)", "code": "{\n  int i, fd;\n\n  printf(1, \"empty file name\\n\");\n\n  // the 50 is NINODE\n  for(i = 0; i < 50 + 1; i++){\n    if(mkdir(\"irefd\") != 0){\n      printf(1, \"mkdir irefd failed\\n\");\n      exit();\n    }\n    if(chdir(\"irefd\") != 0){\n      printf(1, \"chdir irefd failed\\n\");\n      exit();\n    }\n\n    mkdir(\"\");\n    link(\"README\", \"\");\n    fd = open(\"\", O_CREATE);\n    if(fd >= 0)\n      close(fd);\n    fd = open(\"xx\", O_CREATE);\n    if(fd >= 0)\n      close(fd);\n    unlink(\"xx\");\n  }\n\n  chdir(\"/\");\n  printf(1, \"empty file name OK\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Start additional processor running bootstrap code at addr.\n// See Appendix B of MultiProcessor Specification.\n", "func_signal": "void\nlapic_startap(uchar apicid, uint addr)", "code": "{\n  int i;\n  ushort *wrv;\n  \n  // \"The BSP must initialize CMOS shutdown code to 0AH\n  // and the warm reset vector (DWORD based at 40:67) to point at\n  // the AP startup code prior to the [universal startup algorithm].\"\n  outb(IO_RTC, 0xF);  // offset 0xF is shutdown code\n  outb(IO_RTC+1, 0x0A);\n  wrv = (ushort*)(0x40<<4 | 0x67);  // Warm reset vector\n  wrv[0] = 0;\n  wrv[1] = addr >> 4;\n\n  // \"Universal startup algorithm.\"\n  // Send INIT (level-triggered) interrupt to reset other CPU.\n  lapicw(ICRHI, apicid<<24);\n  lapicw(ICRLO, INIT | LEVEL | ASSERT);\n  microdelay(200);\n  lapicw(ICRLO, INIT | LEVEL);\n  microdelay(100);\t// should be 10ms, but too slow in Bochs!\n  \n  // Send startup IPI (twice!) to enter bootstrap code.\n  // Regular hardware is supposed to only accept a STARTUP\n  // when it is in the halted state due to an INIT.  So the second\n  // should be ignored, but it is part of the official Intel algorithm.\n  // Bochs complains about the second one.  Too bad for Bochs.\n  for(i = 0; i < 2; i++){\n    lapicw(ICRHI, apicid<<24);\n    lapicw(ICRLO, STARTUP | (addr>>12));\n    microdelay(200);\n  }\n}", "path": "lapic.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// directory that uses indirect blocks\n", "func_signal": "void\nbigdir(void)", "code": "{\n  int i, fd;\n  char name[10];\n\n  printf(1, \"bigdir test\\n\");\n  unlink(\"bd\");\n\n  fd = open(\"bd\", O_CREATE);\n  if(fd < 0){\n    printf(1, \"bigdir create failed\\n\");\n    exit();\n  }\n  close(fd);\n\n  for(i = 0; i < 500; i++){\n    name[0] = 'x';\n    name[1] = '0' + (i / 64);\n    name[2] = '0' + (i % 64);\n    name[3] = '\\0';\n    if(link(\"bd\", name) != 0){\n      printf(1, \"bigdir link failed\\n\");\n      exit();\n    }\n  }\n\n  unlink(\"bd\");\n  for(i = 0; i < 500; i++){\n    name[0] = 'x';\n    name[1] = '0' + (i / 64);\n    name[2] = '0' + (i % 64);\n    name[3] = '\\0';\n    if(unlink(name) != 0){\n      printf(1, \"bigdir unlink failed\");\n      exit();\n    }\n  }\n\n  printf(1, \"bigdir ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Fetch the nth word-sized system call argument as a file descriptor\n// and return both the descriptor and the corresponding struct file.\n", "func_signal": "static int\nargfd(int n, int *pfd, struct file **pf)", "code": "{\n  int fd;\n  struct file *f;\n\n  if(argint(n, &fd) < 0)\n    return -1;\n  if(fd < 0 || fd >= NOFILE || (f=cp->ofile[fd]) == 0)\n    return -1;\n  if(pfd)\n    *pfd = fd;\n  if(pf)\n    *pf = f;\n  return 0;\n}", "path": "sysfile.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// Create the path new as a link to the same inode as old.\n", "func_signal": "int\nsys_link(void)", "code": "{\n  char name[DIRSIZ], *new, *old;\n  struct inode *dp, *ip;\n\n  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)\n    return -1;\n  if((ip = namei(old)) == 0)\n    return -1;\n  ilock(ip);\n  if(ip->type == T_DIR){\n    iunlockput(ip);\n    return -1;\n  }\n  ip->nlink++;\n  iupdate(ip);\n  iunlock(ip);\n\n  if((dp = nameiparent(new, name)) == 0)\n    goto  bad;\n  ilock(dp);\n  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0)\n    goto bad;\n  iunlockput(dp);\n  iput(ip);\n  return 0;\n\nbad:\n  if(dp)\n    iunlockput(dp);\n  ilock(ip);\n  ip->nlink--;\n  iupdate(ip);\n  iunlockput(ip);\n  return -1;\n}", "path": "sysfile.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// meant to be run w/ at most two CPUs\n", "func_signal": "void\npreempt(void)", "code": "{\n  int pid1, pid2, pid3;\n  int pfds[2];\n\n  printf(1, \"preempt: \");\n  pid1 = fork();\n  if(pid1 == 0)\n    for(;;)\n      ;\n\n  pid2 = fork();\n  if(pid2 == 0)\n    for(;;)\n      ;\n\n  pipe(pfds);\n  pid3 = fork();\n  if(pid3 == 0){\n    close(pfds[0]);\n    if(write(pfds[1], \"x\", 1) != 1)\n      printf(1, \"preempt write error\");\n    close(pfds[1]);\n    for(;;)\n      ;\n  }\n\n  close(pfds[1]);\n  if(read(pfds[0], buf, sizeof(buf)) != 1){\n    printf(1, \"preempt read error\");\n    return;\n  }\n  close(pfds[0]);\n  printf(1, \"kill... \");\n  kill(pid1);\n  kill(pid2);\n  kill(pid3);\n  printf(1, \"wait... \");\n  wait();\n  wait();\n  wait();\n  printf(1, \"preempt ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// two processes write to the same file descriptor\n// is the offset shared? does inode locking work?\n", "func_signal": "void\nsharedfd(void)", "code": "{\n  int fd, pid, i, n, nc, np;\n  char buf[10];\n\n  unlink(\"sharedfd\");\n  fd = open(\"sharedfd\", O_CREATE|O_RDWR);\n  if(fd < 0){\n    printf(1, \"fstests: cannot open sharedfd for writing\");\n    return;\n  }\n  pid = fork();\n  memset(buf, pid==0?'c':'p', sizeof(buf));\n  for(i = 0; i < 1000; i++){\n    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){\n      printf(1, \"fstests: write sharedfd failed\\n\");\n      break;\n    }\n  }\n  if(pid == 0)\n    exit();\n  else\n    wait();\n  close(fd);\n  fd = open(\"sharedfd\", 0);\n  if(fd < 0){\n    printf(1, \"fstests: cannot open sharedfd for reading\\n\");\n    return;\n  }\n  nc = np = 0;\n  while((n = read(fd, buf, sizeof(buf))) > 0){\n    for(i = 0; i < sizeof(buf); i++){\n      if(buf[i] == 'c')\n        nc++;\n      if(buf[i] == 'p')\n        np++;\n    }\n  }\n  close(fd);\n  unlink(\"sharedfd\");\n  if(nc == 10000 && np == 10000)\n    printf(1, \"sharedfd ok\\n\");\n  else\n    printf(1, \"sharedfd oops %d %d\\n\", nc, np);\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// simple fork and pipe read/write\n", "func_signal": "void\npipe1(void)", "code": "{\n  int fds[2], pid;\n  int seq, i, n, cc, total;\n\n  if(pipe(fds) != 0){\n    printf(1, \"pipe() failed\\n\");\n    exit();\n  }\n  pid = fork();\n  seq = 0;\n  if(pid == 0){\n    close(fds[0]);\n    for(n = 0; n < 5; n++){\n      for(i = 0; i < 1033; i++)\n        buf[i] = seq++;\n      if(write(fds[1], buf, 1033) != 1033){\n        printf(1, \"pipe1 oops 1\\n\");\n        exit();\n      }\n    }\n    exit();\n  } else if(pid > 0){\n    close(fds[1]);\n    total = 0;\n    cc = 1;\n    while((n = read(fds[0], buf, cc)) > 0){\n      for(i = 0; i < n; i++){\n        if((buf[i] & 0xff) != (seq++ & 0xff)){\n          printf(1, \"pipe1 oops 2\\n\");\n          return;\n        }\n      }\n      total += n;\n      cc = cc * 2;\n      if(cc > sizeof(buf))\n        cc = sizeof(buf);\n    }\n    if(total != 5 * 1033)\n      printf(1, \"pipe1 oops 3 total %d\\n\", total);\n    close(fds[0]);\n    wait();\n  } else {\n    printf(1, \"fork() failed\\n\");\n    exit();\n  }\n  printf(1, \"pipe1 ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// test that fork fails gracefully\n// the forktest binary also does this, but it runs out of proc entries first.\n// inside the bigger usertests binary, we run out of memory first.\n", "func_signal": "void\nforktest(void)", "code": "{\n  int n, pid;\n\n  printf(1, \"fork test\\n\");\n\n  for(n=0; n<1000; n++){\n    pid = fork();\n    if(pid < 0)\n      break;\n    if(pid == 0)\n      exit();\n  }\n  \n  if(n == 1000){\n    printf(1, \"fork claimed to work 1000 times!\\n\");\n    exit();\n  }\n  \n  for(; n > 0; n--){\n    if(wait() < 0){\n      printf(1, \"wait stopped early\\n\");\n      exit();\n    }\n  }\n  \n  if(wait() != -1){\n    printf(1, \"wait got too many\\n\");\n    exit();\n  }\n  \n  printf(1, \"fork test OK\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// can I unlink a file and still read it?\n", "func_signal": "void\nunlinkread(void)", "code": "{\n  int fd, fd1;\n\n  printf(1, \"unlinkread test\\n\");\n  fd = open(\"unlinkread\", O_CREATE | O_RDWR);\n  if(fd < 0){\n    printf(1, \"create unlinkread failed\\n\");\n    exit();\n  }\n  write(fd, \"hello\", 5);\n  close(fd);\n\n  fd = open(\"unlinkread\", O_RDWR);\n  if(fd < 0){\n    printf(1, \"open unlinkread failed\\n\");\n    exit();\n  }\n  if(unlink(\"unlinkread\") != 0){\n    printf(1, \"unlink unlinkread failed\\n\");\n    exit();\n  }\n\n  fd1 = open(\"unlinkread\", O_CREATE | O_RDWR);\n  write(fd1, \"yyy\", 3);\n  close(fd1);\n\n  if(read(fd, buf, sizeof(buf)) != 5){\n    printf(1, \"unlinkread read failed\");\n    exit();\n  }\n  if(buf[0] != 'h'){\n    printf(1, \"unlinkread wrong data\\n\");\n    exit();\n  }\n  if(write(fd, buf, 10) != 10){\n    printf(1, \"unlinkread write failed\\n\");\n    exit();\n  }\n  close(fd);\n  unlink(\"unlinkread\");\n  printf(1, \"unlinkread ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// two processes write two different files at the same\n// time, to test block allocation.\n", "func_signal": "void\ntwofiles(void)", "code": "{\n  int fd, pid, i, j, n, total;\n  char *fname;\n\n  printf(1, \"twofiles test\\n\");\n\n  unlink(\"f1\");\n  unlink(\"f2\");\n\n  pid = fork();\n  if(pid < 0){\n    printf(1, \"fork failed\\n\");\n    return;\n  }\n\n  fname = pid ? \"f1\" : \"f2\";\n  fd = open(fname, O_CREATE | O_RDWR);\n  if(fd < 0){\n    printf(1, \"create failed\\n\");\n    exit();\n  }\n\n  memset(buf, pid?'p':'c', 512);\n  for(i = 0; i < 12; i++){\n    if((n = write(fd, buf, 500)) != 500){\n      printf(1, \"write failed %d\\n\", n);\n      exit();\n    }\n  }\n  close(fd);\n  if(pid)\n    wait();\n  else\n    exit();\n\n  for(i = 0; i < 2; i++){\n    fd = open(i?\"f1\":\"f2\", 0);\n    total = 0;\n    while((n = read(fd, buf, sizeof(buf))) > 0){\n      for(j = 0; j < n; j++){\n        if(buf[j] != (i?'p':'c')){\n          printf(1, \"wrong char\\n\");\n          exit();\n        }\n      }\n      total += n;\n    }\n    close(fd);\n    if(total != 12*500){\n      printf(1, \"wrong length %d\\n\", total);\n      exit();\n    }\n  }\n\n  unlink(\"f1\");\n  unlink(\"f2\");\n\n  printf(1, \"twofiles ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "// try to find any races between exit and wait\n", "func_signal": "void\nexitwait(void)", "code": "{\n  int i, pid;\n\n  for(i = 0; i < 100; i++){\n    pid = fork();\n    if(pid < 0){\n      printf(1, \"fork failed\\n\");\n      return;\n    }\n    if(pid){\n      if(wait() != pid){\n        printf(1, \"wait wrong pid\\n\");\n        return;\n      }\n    } else {\n      exit();\n    }\n  }\n  printf(1, \"exitwait ok\\n\");\n}", "path": "usertests.c", "repo_name": "yasulab/hackbench-on-xv6", "stars": 5, "license": "other", "language": "c", "size": 1340}
{"docstring": "/***************** global init etc *****************************/\n", "func_signal": "void init_image_colortable(void)", "code": "{\n   s_array=make_shared_string(\"array\");\n   s_string=make_shared_string(\"string\");\n   s_mapping=make_shared_string(\"mapping\");\n\n   ADD_STORAGE(struct neo_colortable);\n\n   set_init_callback(init_colortable_struct);\n   set_exit_callback(exit_colortable_struct);\n\n   /* function(void:void)|\"\n\t\t\"function(array(array(int)|string|object):void)|\"\n\t\t\"function(object,void|int,mixed ...:void)|\"\n\t\t\"function(int,int,int,void|int ...:void) */\n   ADD_FUNCTION(\"create\",image_colortable_create,tOr4(tFunc(tVoid,tVoid),tFunc(tOr(tArr(tColor),tStr),tVoid),tFuncV(tObj tOr(tVoid,tInt),tMix,tVoid),tFuncV(tInt tInt tInt,tOr(tVoid,tInt),tVoid)),0);\n\n\n   ADD_FUNCTION(\"_encode\", image_colortable__encode,tFunc(tNone,tStr),0);\n   ADD_FUNCTION(\"_decode\", image_colortable__decode,tFunc(tStr,tVoid),0);\n   ADD_FUNCTION(\"_sprintf\", image_colortable__sprintf, \n                tFunc(tInt tMapping, tString ), 0 );\n   /* function(void:void)|\"\n\t\t\"function(array(array(int)|string|object):void)|\"\n\t\t\"function(object,void|int,mixed ...:void)|\"\n\t\t\"function(int,int,int,void|int ...:void) */\n   ADD_FUNCTION(\"add\",image_colortable_add,tOr4(tFunc(tVoid,tVoid),tFunc(tArr(tColor),tVoid),tFuncV(tObj tOr(tVoid,tInt),tMix,tVoid),tFuncV(tInt tInt tInt,tOr(tVoid,tInt),tVoid)),0);\n\n   /* function(int:object) */\n   ADD_FUNCTION(\"reduce\",image_colortable_reduce,tFunc(tInt,tObj),0);\n   ADD_FUNCTION(\"reduce_fs\",image_colortable_reduce_fs,tFunc(tInt,tObj),0);\n\n   /* operators */\n   ADD_FUNCTION(\"`+\",image_colortable_operator_plus,tFunc(tObj,tObj),0);\n   ADD_FUNCTION(\"``+\",image_colortable_operator_plus,tFunc(tObj,tObj),0);\n\n   /* cast to array */\n   ADD_FUNCTION(\"cast\",image_colortable_cast,tFunc(tStr,tArray),0);\n\n   /* info */\n   ADD_FUNCTION(\"_sizeof\",image_colortable__sizeof,tFunc(tNone,tInt),0);\n   ADD_FUNCTION(\"greyp\",image_colortable_greyp,tFunc(tNone,tInt01),0);\n\n   /* lookup modes */\n   ADD_FUNCTION(\"cubicles\",image_colortable_cubicles,tOr(tFunc(tNone,tObj),tFunc(tInt tInt tInt tOr(tVoid,tInt),tObj)),0);\n   ADD_FUNCTION(\"rigid\",image_colortable_rigid,tOr(tFunc(tNone,tObj),tFunc(tInt tInt tInt,tObj)),0);\n   ADD_FUNCTION(\"full\",image_colortable_full,tFunc(tNone,tObj),0);\n\n   /* map image */\n   /* function(object:object)|function(string,int,int) */\n#define map_func_type tOr(tFunc(tObj,tObj),tFunc(tString tInt tInt,tObj))\n   ADD_FUNCTION(\"map\",image_colortable_map,map_func_type,0);\n   ADD_FUNCTION(\"`*\",image_colortable_map,map_func_type,0);\n   ADD_FUNCTION(\"``*\",image_colortable_map,map_func_type,0);\n\n   ADD_FUNCTION(\"index\",image_colortable_index_32bit,tFunc(tObj,tStr),0);\n\n   /* dither */\n   /* function(:object) */\n   ADD_FUNCTION(\"nodither\",image_colortable_nodither,tFunc(tNone,tObj),0);\n   /* function(void|int:object)\"\n      \"|function(int,int|float,int|float,int|float,int|float:object) */\n   ADD_FUNCTION(\"floyd_steinberg\",image_colortable_floyd_steinberg,tOr(tFunc(tOr(tVoid,tInt),tObj),tFunc(tInt tOr(tInt,tFlt) tOr(tInt,tFlt) tOr(tInt,tFlt) tOr(tInt,tFlt),tObj)),0);\n   /* function(:object)|function(int,int,int:object) */\n   ADD_FUNCTION(\"randomcube\",image_colortable_randomcube,tOr(tFunc(tNone,tObj),tFunc(tInt tInt tInt,tObj)),0);\n   /* function(:object)|function(int:object) */\n   ADD_FUNCTION(\"randomgrey\",image_colortable_randomgrey,tOr(tFunc(tNone,tObj),tFunc(tInt,tObj)),0);\n   /* function(:object)\"\n      \"|function(int,int,int:object) */\n   ADD_FUNCTION(\"ordered\",image_colortable_ordered,\n\t\ttOr5(tFunc(tNone,tObj),\n\t\t     tFunc(tInt tInt tInt,tObj),\n\t\t     tFunc(tInt tInt tInt tInt tInt,tObj),\n\t\t     tFunc(tInt tInt tInt tInt tInt tInt tInt,tObj),\n\t\t     tFunc(tInt tInt tInt tInt tInt tInt tInt tInt tInt tInt tInt,tObj)),0);\n\n   /* function(:object) */\n   ADD_FUNCTION(\"image\",image_colortable_image,tFunc(tNone,tObj),0);\n\n   /* tuning image */\n   /* function(int,int,int:object) */\n   ADD_FUNCTION(\"spacefactors\",image_colortable_spacefactors,tFunc(tInt tInt tInt,tObj),0);\n\n   ADD_FUNCTION(\"corners\",image_colortable_corners,tFunc(tNone,tArray),0);\n\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* called by GIF encoder */\n", "func_signal": "void image_colortable_internal_floyd_steinberg(struct neo_colortable *nct)", "code": "{\n   nct->du.floyd_steinberg.forward = DO_NOT_WARN((float)(0.95*(7.0/16)));\n   nct->du.floyd_steinberg.downforward = DO_NOT_WARN((float)(0.95*(1.0/16)));\n   nct->du.floyd_steinberg.down = DO_NOT_WARN((float)(0.95*(5.0/16)));\n   nct->du.floyd_steinberg.downback = DO_NOT_WARN((float)(0.95*(3.0/16)));\n\n   nct->dither_type=NCTD_FLOYD_STEINBERG;\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* Parse a request. This function is somewhat obscure for performance\n * reasons.\n */\n", "func_signal": "static int parse(struct args *arg)", "code": "{\n  int s1=0, s2=0, i;\n  struct cache_entry *ce ;\n  /* get: URL, Protocol, method, headers*/\n  for(i=0;i<arg->res.data_len;i++)\n    if(arg->res.data[i] == ' ') {\n      if(!s1) \n\ts1=i; \n      else\n\ts2=i;\n    } else if(arg->res.data[i]=='\\r')\n      break;\n\n  if(!s1)\n  {\n    failed( arg );\n    return 0;\n  }\n\n  /* GET http://www.roxen.com/foo.html HTTP/1.1\\r\n   * 0  ^s1                           ^s2      ^i\n   */\n\n  if(!s2) \n    arg->res.protocol = s_http_09;\n  else if(!memcmp(\"HTTP/1.\", arg->res.data+s2+1, 7))\n  {\n    if(arg->res.data[s2+8]=='0')\n      arg->res.protocol = s_http_10;\n    else if(arg->res.data[s2+8]=='1')\n      arg->res.protocol = s_http_11;\n  }\n  else\n    arg->res.protocol = 0;\n\n  arg->res.method_len = s1;\n\n  if(arg->res.protocol != s_http_09)\n    arg->res.header_start = i+2;\n  else\n    arg->res.header_start = 0;\n\n\n  /* find content */\n  arg->res.content_len=0;\n  aap_get_header(arg, \"content-length\", H_INT, &arg->res.content_len);\n  if((arg->res.data_len - arg->res.body_start) < arg->res.content_len)\n  {\n    ptrdiff_t nr;\n    /* read the rest of the request.. OBS: This is done without any\n     * timeout right now. It is relatively easy to add one, though.\n     * The only problem is that this might be an upload of a _large_ file,\n     * if so the upload could take an hour or more. So there can be no \n     * sensible default timeout. The only option is to reshedule the timeout\n     * for each and every read.\n     *\n     * This code should probably not allocate infinite amounts of \n     * memory either...\n     * \n     * TODO: rewrite this to use a mmaped file if the size is bigger than\n     * 1Mb or so.\n     * \n     * This could cause trouble with the leftovers code below, so that \n     * would have to be changed as well.\n     */\n    arg->res.data=realloc(arg->res.data,\n\t\t\t  arg->res.body_start+arg->res.content_len);\n    while( arg->res.data_len < arg->res.body_start+arg->res.content_len)\n    {\n      while(((nr = fd_read(arg->fd, arg->res.data+arg->res.data_len, \n\t\t\t   (arg->res.body_start+arg->res.content_len)-\n\t\t\t   arg->res.data_len)) < 0) && errno == EINTR);\n      if(nr <= 0)\n      {\n\tfailed(arg);\n\treturn 0;\n      }\n      arg->res.data_len += nr;\n    }\n  }\n  /* ok.. now we should find the leftovers... This is any extra\n   * data not belonging to this request that has already been read.\n   * Since it is rather hard to unread things in a portable way, we simply\n   * store them in the result structure for the next request.\n   */\n\n  arg->res.leftovers_len=\n    (arg->res.data_len-arg->res.body_start-arg->res.content_len);\n  if(arg->res.leftovers_len)\n    arg->res.leftovers=\n      (arg->res.data+arg->res.body_start+arg->res.content_len);\n\n  arg->res.url = arg->res.data+s1+1;\n  arg->res.url_len = (s2?s2:i)-s1-1;\n  \n  {\n    struct pstring h;\n    h.len=0;\n    h.str=\"\";\n    if(aap_get_header(arg, \"host\", H_STRING, &h))\n    {\n      arg->res.host = h.str;\n      arg->res.host_len = h.len;\n    } else {\n      arg->res.host = arg->res.data;\n      arg->res.host_len = 0;\n    }\n\n    if(arg->cache->max_size && arg->res.data[0]== 'G') /* GET, presumably */\n    {\n      if(!aap_get_header(arg, \"pragma\", H_EXISTS, 0))\n\tif((ce = aap_cache_lookup(arg->res.url, arg->res.url_len, \n\t\t\t      arg->res.host, arg->res.host_len,\n\t\t\t      arg->cache,0, NULL, NULL)) && ce->data)\n\t{\n\t  ptrdiff_t len = WRITE(arg->fd, ce->data->str, ce->data->len);\n\t  LOG(len, arg, atoi(ce->data->str+MINIMUM(ce->data->len, 9)));\n\t  simple_aap_free_cache_entry( arg->cache, ce );\n\t  /* if keepalive... */\n\t  if((arg->res.protocol==s_http_11)\n\t     ||aap_get_header(arg, \"connection\", H_EXISTS, 0))\n\t  {\n\t    return -1; \n\t  }\n#ifdef AAP_DEBUG\n\t  fprintf(stderr, \"Closing connection...\\n\");\n#endif /* AAP_DEBUG */\n          free_args( arg );\n\t  return 0;\n\t}\n    }\n  }\n  return 1;\n}", "path": "src\\modules\\HTTPLoop\\accept_and_parse.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* _REENTRANT */\n", "func_signal": "void f_aap_add_filesystem( INT32 args )", "code": "{\n  INT_TYPE nosyms = 0;\n  struct pike_string *basedir, *mountpoint;\n  struct array *noparse;\n\n  if(args == 4)\n    get_all_args( \"add_filesystem\", args, \n                  \"%s%s%a%i\", &basedir, &mountpoint, &noparse, &nosyms );\n  else\n    get_all_args( \"add_filesystem\", args, \n                  \"%s%s%a\", &basedir, &mountpoint, &noparse );\n}", "path": "src\\modules\\HTTPLoop\\accept_and_parse.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl void set_option( string name, mixed new_value )\n *! @decl void set_option( string name )\n *!    If no value is specified, the option is set to it's default value\n */\n", "func_signal": "static void f_scanner_set_option( INT32 args )", "code": "{\n  char *name;\n  int no;\n  INT_TYPE int_value;\n  FLOAT_TYPE float_value;\n  SANE_Int tmp;\n  const SANE_Option_Descriptor *d;\n  get_all_args( \"set_option\", args, \"%s\", &name );\n\n  no = find_option( name, &d );\n  if( args > 1 )\n  {\n    switch( d->type )\n    {\n     case SANE_TYPE_BOOL:\n     case SANE_TYPE_INT:\n     case SANE_TYPE_BUTTON:\n       sp++;get_all_args( \"set_option\", args, \"%I\", &int_value );sp--;\n       sane_control_option( THIS->h, no, SANE_ACTION_SET_VALUE,\n                            &int_value, &tmp );\n       break;\n     case SANE_TYPE_FIXED:\n       sp++;get_all_args( \"set_option\", args, \"%F\", &float_value );sp--;\n       int_value = SANE_FIX(((double)float_value));\n       sane_control_option( THIS->h, no, SANE_ACTION_SET_VALUE,\n                            &int_value, &tmp );\n       break;\n     case SANE_TYPE_STRING:\n       sp++;get_all_args( \"set_option\", args, \"%s\", &name );sp--;\n       sane_control_option( THIS->h, no, SANE_ACTION_SET_VALUE,\n                            &name, &tmp );\n     case SANE_TYPE_GROUP:\n       break;\n    }\n  } else {\n    int_value = 1;\n    sane_control_option( THIS->h, no, SANE_ACTION_SET_AUTO, &int_value, &tmp );\n  }\n  pop_n_elems( args );\n  push_int( 0 );\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl void create(string name)\n */\n", "func_signal": "static void f_scanner_create( INT32 args )", "code": "{\n  char *name;\n  if(!sane_is_inited) init_sane();\n  get_all_args( \"create\", args, \"%s\", &name );\n\n  if( sane_open( name, &THIS->h ) )\n    Pike_error(\"Failed to open scanner \\\"%s\\\"\\n\", name );\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method array(object) corners()\n**!\tGives the eight corners in rgb colorspace as an array.\n**!\tThe \"black\" and \"white\" corners are the first two.\n**/\n", "func_signal": "void image_colortable_corners(INT32 args)", "code": "{\n   struct nct_flat flat;\n   int i;\n   rgb_group min={COLORMAX,COLORMAX,COLORMAX};\n   rgb_group max={0,0,0};\n\n   pop_n_elems(args);\n   \n   if (THIS->type==NCT_NONE)\n   {\n      f_aggregate(0);\n      return;\n   }\n\n   if (THIS->type==NCT_CUBE)\n      flat=_img_nct_cube_to_flat(THIS->u.cube);\n   else\n      flat=THIS->u.flat;\n\n   /* sort in number order? */\n\n   for (i=0; i<flat.numentries; i++)\n      if (flat.entries[i].no!=-1)\n      {\n\t rgb_group rgb=flat.entries[i].color;\n\t if (rgb.r<min.r) min.r=rgb.r;\n\t if (rgb.g<min.g) min.g=rgb.g;\n\t if (rgb.b<min.b) min.b=rgb.b;\n\t if (rgb.r>max.r) max.r=rgb.r;\n\t if (rgb.g>max.g) max.g=rgb.g;\n\t if (rgb.b>max.b) max.b=rgb.b;\n      }\n\n   _image_make_rgb_color(min.r,min.g,min.b);\n   _image_make_rgb_color(max.r,max.g,max.b);\n\n   _image_make_rgb_color(max.r,min.g,min.b);\n   _image_make_rgb_color(min.r,max.g,min.b);\n   _image_make_rgb_color(max.r,max.g,min.b);\n   _image_make_rgb_color(min.r,min.g,max.b);\n   _image_make_rgb_color(max.r,min.g,max.b);\n   _image_make_rgb_color(min.r,max.g,max.b);\n\n   f_aggregate(8);\n\n   if (THIS->type==NCT_CUBE)\n      free(flat.entries);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object cast(string to)\n**!\tcast the colortable to an array or mapping,\n**!\tthe array consists of <ref>Image.Color</ref> objects\n**!\tand are not in index order. The mapping consists of\n**!\tindex:<ref>Image.Color</ref> pairs, where index is \n**!\tthe index (int) of that color.\n**!\n**!\texample: <tt>(mapping)Image.Colortable(img)</tt>\n**!\n**! arg string to\n**!\tmust be \"string\", \"array\" or \"mapping\".\n**/\n", "func_signal": "void image_colortable_cast(INT32 args)", "code": "{\n   if (!args)\n      SIMPLE_TOO_FEW_ARGS_ERROR(\"Image.Colortable->cast\",1);\n   if (sp[-args].type==T_STRING||sp[-args].u.string->size_shift)\n   {\n      if (!strncmp(sp[-args].u.string->str,\"array\",5))\n      {\n\t pop_n_elems(args);\n\t image_colortable_cast_to_array(THIS);\n\t return;\n      }\n      if (!strncmp(sp[-args].u.string->str,\"string\",6))\n      {\n\t pop_n_elems(args);\n\t image_colortable_cast_to_string(THIS);\n\t return;\n      }\n      if (!strncmp(sp[-args].u.string->str,\"mapping\",7))\n      {\n\t pop_n_elems(args);\n\t image_colortable_cast_to_mapping(THIS);\n\t return;\n      }\n   }\n   SIMPLE_BAD_ARG_ERROR(\"Image.Colortable->cast\",1,\n\t\t\t\"string(\\\"mapping\\\"|\\\"array\\\"|\\\"string\\\")\");\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* HAVE_POLL */\n", "func_signal": "static void low_accept_loop(struct args *arg)", "code": "{\n  struct args *arg2 = new_args();\n  ACCEPT_SIZE_T len = sizeof(arg->from);\n  while(1)\n  {\n    MEMCPY(arg2, arg, sizeof(struct args));\n    arg2->fd = fd_accept(arg->fd, (struct sockaddr *)&arg2->from, &len);\n    if(arg2->fd != -1)\n    {\n      th_farm((void (*)(void *))aap_handle_connection, arg2);\n      arg2 = new_args();\n      arg2->res.leftovers = 0;\n    } else {\n      if(errno == EBADF)\n      {\n\tint i;\n\tstruct cache_entry *e, *t;\n\tstruct cache *c, *p = NULL;\n\tstruct log *l, *n = NULL;\n\t/* oups. */\n\tlow_mt_lock_interpreter(); /* Can run even if threads_disabled. */\n\tfor(i=0; i<CACHE_HTABLE_SIZE; i++)\n\t{\n\t  e = arg->cache->htable[i];\n\t  while(e)\n\t  {\n\t    t = e;\n\t    e = e->next;\n\t    t->next = 0;\n\t    free_string(t->data);\n\t    aap_free(t->url);\n\t    aap_free(t);\n\t  }\n\t}\n\twhile(arg->log->log_head)\n\t{\n\t  struct log_entry *l = arg->log->log_head->next;\n\t  aap_free(arg->log->log_head);\n\t  arg->log->log_head = l;\n\t}\n\n\tc = first_cache;\n\twhile(c && c != arg->cache) {p=c;c = c->next;}\n\tif(c)\n\t{\n\t  if(p) \n\t    p->next = c->next;\n\t  else\n\t    first_cache = c->next;\n\t  c->gone = 1;\n\t  aap_free(c);\n\t}\n\n\n\tl = aap_first_log;\n\twhile(l && l != arg->log) {n=l;l = l->next;}\n\tif(l)\n\t{\n\t  if(n)    n->next = l->next;\n\t  else     aap_first_log = l->next;\n\t  aap_free(l);\n\t}\n\tmt_unlock_interpreter();\n\taap_free(arg2);\n\taap_free(arg);\n\treturn; /* No more accept here.. */\n      }\n    }\n  }\n}", "path": "src\\modules\\HTTPLoop\\accept_and_parse.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl mixed get_option( string name )\n */\n", "func_signal": "static void f_scanner_get_option( INT32 args )", "code": "{\n  char *name;\n  int no;\n  SANE_Int int_value;\n  float f;\n  SANE_Int tmp;\n  const SANE_Option_Descriptor *d;\n  get_all_args( \"get_option\", args, \"%s\", &name );\n\n  no = find_option( name, &d );\n\n  switch( d->type )\n  {\n   case SANE_TYPE_BOOL:\n   case SANE_TYPE_INT:\n   case SANE_TYPE_BUTTON:\n     sane_control_option( THIS->h, no, SANE_ACTION_GET_VALUE,\n                          &int_value, &tmp );\n     pop_n_elems( args );\n     push_int( int_value );\n     return;\n   case SANE_TYPE_FIXED:\n     sane_control_option( THIS->h, no, SANE_ACTION_GET_VALUE,\n                          &int_value, &tmp );\n     pop_n_elems( args );\n     push_float( SANE_UNFIX( int_value ) );\n     break;\n   case SANE_TYPE_STRING:\n     sane_control_option( THIS->h, no, SANE_ACTION_GET_VALUE,\n                          &name, &tmp );\n     pop_n_elems( args );\n     push_text( name );\n   case SANE_TYPE_GROUP:\n     break;\n  }\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object nodither()\n**!\tSet no dithering (default).\n**!\n**! returns the object being called\n**/\n", "func_signal": "void image_colortable_nodither(INT32 args)", "code": "{\n   THIS->dither_type=NCTD_NONE;\n   pop_n_elems(args);\n   ref_push_object(THISOBJ);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object reduce(int colors)\n**! method object reduce_fs(int colors)\n**!\treduces the number of colors\n**!\n**!\tAll needed (see <ref>create</ref>) colors are kept.\n**!\n**!\t<ref>reduce_fs</ref> creates and keeps \n**!\tthe outmost corners of the color space, to \n**!\timprove floyd-steinberg dithering result.\n**!\t(It doesn't work very well, though.)\n**!\n**! returns the new <ref>Colortable</ref> object\n**!\n**! arg int colors\n**!\ttarget number of colors\n**!\n**! note\n**!\tthis algorithm assumes all colors are different to \n**!     begin with (!)\n**!\t\n**!\t<ref>reduce_fs</ref> keeps the \"corners\" as\n**!\t\"needed colors\".\n**!\n**! see also: corners\n**/\n", "func_signal": "void image_colortable_reduce(INT32 args)", "code": "{\n   struct object *o;\n   struct neo_colortable *nct;\n   int numcolors=0;\n\n   if (args) \n     if (sp[-args].type!=T_INT) \n\tSIMPLE_BAD_ARG_ERROR(\"Image.Colortable->reduce\",1,\"int\");\n     else\n\t numcolors=sp[-args].u.integer;\n   else\n      numcolors=1293791; /* a lot */\n   \n   o=clone_object_from_object(THISOBJ,0);\n   nct=(struct neo_colortable*)get_storage(o,image_colortable_program);\n   \n   switch (nct->type = THIS->type)\n   {\n      case NCT_NONE: pop_n_elems(args); push_object(o); return;\n      case NCT_CUBE:\n         nct->type=NCT_FLAT;\n         nct->u.flat=_img_nct_cube_to_flat(THIS->u.cube);\n\t break;\n      case NCT_FLAT:\n         _img_copy_colortable(nct,THIS);\n\t break;\n   }\n\n   if (sp[-args].u.integer<1) sp[-args].u.integer=1;\n\n   nct->u.flat=_img_reduce_number_of_colors(nct->u.flat,numcolors,\n\t\t\t\t\t    nct->spacefactor);\n\n   pop_n_elems(args);\n   push_object(o);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object image()\n**!\tcast the colortable to an image object\n**!\n**!\teach pixel in the image object is an entry in the colortable\n**!\n**! returns the resulting image object\n**/\n", "func_signal": "void image_colortable_image(INT32 args)", "code": "{\n   struct object *o;\n   struct image *img;\n   struct nct_flat flat;\n   int i;\n   rgb_group *dest;\n\n   pop_n_elems(args);\n   push_int64(image_colortable_size(THIS));\n   push_int(1);\n   o=clone_object(image_program,2);\n   push_object(o);\n\n   if (THIS->type==NCT_NONE)\n      return;\n\n   img=(struct image*)get_storage(o,image_program);\n   dest=img->img;\n   \n   if (THIS->type==NCT_CUBE)\n      flat=_img_nct_cube_to_flat(THIS->u.cube);\n   else\n      flat=THIS->u.flat;\n\n   /* sort in number order? */\n\n   for (i=0; i<flat.numentries; i++)\n   {\n      dest->r=flat.entries[i].color.r;\n      dest->g=flat.entries[i].color.g;\n      dest->g=flat.entries[i].color.b;\n      dest++;\n   }\n\n   if (THIS->type==NCT_CUBE)\n      free(flat.entries);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl mapping(string:int) get_parameters()\n *!\n *! @returns\n *!   @mapping\n *!  \t@member int \"format\"\n *!  \t@member int \"last_frame\"\n *!  \t@member int \"lines\"\n *!  \t@member int \"depth\"\n *!  \t@member int \"pixels_per_line\"\n *!  \t@member int \"bytes_per_line\"\n *!   @endmapping\n */\n", "func_signal": "static void f_scanner_get_parameters( INT32 args )", "code": "{\n  SANE_Parameters p;\n  pop_n_elems( args );\n  sane_get_parameters( THIS->h, &p );\n  push_text( \"format\" );          push_int( p.format );\n  push_text( \"last_frame\" );      push_int( p.last_frame );\n  push_text( \"lines\" );           push_int( p.lines );\n  push_text( \"depth\" );           push_int( p.depth );\n  push_text( \"pixels_per_line\" ); push_int( p.pixels_per_line );\n  push_text( \"bytes_per_line\" );  push_int( p.bytes_per_line );\n  f_aggregate_mapping( 12 );\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl Image.Image simple_scan()\n */\n", "func_signal": "static void f_scanner_simple_scan( INT32 args )", "code": "{\n  SANE_Parameters p;\n  SANE_Handle h = THIS->h;\n  struct object *o;\n  rgb_group *r;\n\n\n  assert_image_program();\n\n  pop_n_elems( args );\n  if( sane_start( THIS->h ) )   Pike_error(\"Start failed\\n\");\n  if( sane_get_parameters( THIS->h, &p ) )  Pike_error(\"Get parameters failed\\n\");\n\n  if( p.depth != 8 )\n    Pike_error(\"Sorry, only depth 8 supported right now.\\n\");\n\n  push_int( p.pixels_per_line );\n  push_int( p.lines );\n  o = clone_object( image_program, 2 );\n  r = ((struct image *)o->storage)->img;\n\n  THREADS_ALLOW();\n  do\n  {\n    switch( p.format )\n    {\n     case SANE_FRAME_GRAY:\n       get_grey_frame( h, &p, (char *)r );\n       p.last_frame = 1;\n       break;\n     case SANE_FRAME_RGB:\n       get_rgb_frame(  h, &p, (char *)r );\n       p.last_frame = 1;\n       break;\n     case SANE_FRAME_RED:\n       get_comp_frame( h, &p, ((char *)r) );\n       break;\n     case SANE_FRAME_GREEN:\n       get_comp_frame( h, &p, ((char *)r)+1 );\n       break;\n     case SANE_FRAME_BLUE:\n       get_comp_frame( h, &p, ((char *)r)+2 );\n       break;\n    }\n  }\n  while( !p.last_frame );\n\n  THREADS_DISALLOW();\n  push_object( o );\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object `-(object with, mixed ... more)\n**!\tsubtracts colortables\n**! returns the resulting new <ref>Colortable</ref> object\n**!\n**! arg object(<ref>Colortable</ref>) with\n**!\t<ref>Colortable</ref> object with colors to subtract\n**/\n", "func_signal": "void image_colortable_operator_minus(INT32 args)", "code": "{\n   struct object *o;\n   struct neo_colortable *dest,*src=NULL;\n\n   int i;\n\n   ref_push_object(THISOBJ);\n   o=clone_object_from_object(THISOBJ,1);\n   dest=(struct neo_colortable*)get_storage(o,image_colortable_program);\n\n   for (i=0; i<args; i++)\n      if (sp[i-args].type==T_OBJECT)\n      {\n\t src=(struct neo_colortable*)\n\t    get_storage(sp[i-args].u.object,image_colortable_program);\n\t if (!src) \n\t { \n\t    free_object(o); \n\t    bad_arg_error(\"Image\",sp-args,args,i+2,\"\",sp+i+2-1-args,\n\t\t\"Bad argument %d to Image()\\n\",i+2); \n\t }\n\t _img_sub_colortable(dest,src);\n      }\n      else \n      { \n\t free_object(o); \n\t bad_arg_error(\"Image\",sp-args,args,i+2,\"\",sp+i+2-1-args,\n\t\t\"Bad argument %d to Image()\\n\",i+2); \n      }\n   pop_n_elems(args);\n   push_object(o);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method object `+(object with, mixed ... more)\n**!\tsums colortables\n**! returns the resulting new <ref>Colortable</ref> object\n**!\n**! arg object(<ref>Colortable</ref>) with\n**!\t<ref>Colortable</ref> object with colors to add\n**/\n", "func_signal": "void image_colortable_operator_plus(INT32 args)", "code": "{\n   struct object *o,*tmpo=NULL;\n   struct neo_colortable *dest,*src=NULL;\n\n   int i;\n\n   ref_push_object(THISOBJ);\n   o=clone_object_from_object(THISOBJ,1);\n   dest=(struct neo_colortable*)get_storage(o,image_colortable_program);\n\n   for (i=0; i<args; i++)\n   {\n      if (sp[i-args].type==T_OBJECT &&\n\t  (src=(struct neo_colortable*)\n\t   get_storage(sp[i-args].u.object,image_colortable_program)))\n      {\n\t tmpo=NULL;\n      }\n      else if (sp[i-args].type==T_ARRAY ||\n\t       sp[i-args].type==T_OBJECT)\n      {\n\t struct svalue *sv=sp+i-args;\n\t push_svalue(sv);\n\t tmpo=clone_object(image_colortable_program,1);\n\t src=(struct neo_colortable*)\n\t   get_storage(tmpo,image_colortable_program);\n\t if (!src) abort();\n      }\n      else {\n\tbad_arg_error(\"Image-colortable->`+\",sp-args,args,0,\"\",sp-args,\n\t\t\"Bad arguments to Image-colortable->`+()\\n\");\n\t/* Not reached, but keeps the compiler happy. */\n\tsrc = NULL;\n      }\n    \n      _img_add_colortable(dest,src);\n      \n      if (tmpo) free_object(tmpo);\n   }\n   pop_n_elems(args);\n   push_object(o);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*\n**! method int(0..1) greyp()\n**!\tReturns true if this colortable only contains greyscale.\n**/\n", "func_signal": "static void image_colortable_greyp( INT32 args )", "code": "{\n   struct nct_flat flat;\n   int i, bw=1;\n   \n   if (THIS->type==NCT_NONE) {\n      pop_n_elems(args);\n      /* An empty table does not contain colors that are not grey. */\n      push_int(1);\n      return;\n   }\n\n   if (THIS->type==NCT_CUBE)\n      flat=_img_nct_cube_to_flat(THIS->u.cube);\n   else\n      flat=THIS->u.flat;\n\n   for (i=0; i<flat.numentries; i++)\n   {\n      if( flat.entries[i].color.r != flat.entries[i].color.g ||\n          flat.entries[i].color.r != flat.entries[i].color.b )\n      {\n        bw=0;\n        break;\n      }\n   }\n\n   if (THIS->type==NCT_CUBE)\n      free(flat.entries);\n\n   pop_n_elems(args);\n   push_int(bw);\n}", "path": "src\\modules\\Image\\colortable.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* This should probably be improved to include the reason for the \n * failure. Currently, all failed requests get the same (hardcoded) \n * error message.\n * \n * It is virtually impossible to call a pike function from here, so that\n * is not an option.\n */\n", "func_signal": "static void failed(struct args *arg)", "code": "{\n  WRITE(arg->fd, PARSE_FAILED, strlen(PARSE_FAILED));\n#ifdef AAP_DEBUG\n  fprintf(stderr, \"AAP: Failed\\n\");\n#endif /* AAP_DEBUG */\n  free_args( arg ); \n}", "path": "src\\modules\\HTTPLoop\\accept_and_parse.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/*! @decl void nonblocking_row_scan(function(Image.Image,int,Scanner,int:void) callback)\n */\n", "func_signal": "static void f_scanner_nonblocking_row_scan( INT32 args )", "code": "{\n  SANE_Parameters p;\n  SANE_Handle h = THIS->h;\n  struct svalue *s;\n  int fd;\n  struct row_scan_struct *rsp;\n\n  if( sane_start( THIS->h ) )               Pike_error(\"Start failed\\n\");\n  if( sane_get_parameters( THIS->h, &p ) )  Pike_error(\"Get parameters failed\\n\");\n  if( p.depth != 8 )  Pike_error(\"Sorry, only depth 8 supported right now.\\n\");\n\n  switch( p.format )\n  {\n   case SANE_FRAME_GRAY:\n   case SANE_FRAME_RGB:\n     break;\n   case SANE_FRAME_RED:\n   case SANE_FRAME_GREEN:\n   case SANE_FRAME_BLUE:\n     Pike_error(\"Composite frame mode not supported for row_scan\\n\");\n     break;\n  }\n\n  assert_image_program();\n\n  rsp = malloc( sizeof(struct row_scan_struct) );\n  push_int( p.pixels_per_line );\n  push_int( 1 );\n  rsp->o = clone_object( image_program, 2 );\n  rsp->t = Pike_fp->current_object;\n  add_ref(Pike_fp->current_object);\n  rsp->r = ((struct image *)rsp->o->storage)->img;\n  rsp->h = THIS->h;\n  rsp->p = p;\n  rsp->buffer = malloc( p.bytes_per_line );\n  rsp->current_row = 0;\n  rsp->bufferpos = 0;\n  rsp->callback = sp[-1];\n  rsp->nonblocking = !sane_set_io_mode( THIS->h, 1 );\n  sp--;\n\n  if( sane_get_select_fd( THIS->h, &fd ) )\n  {\n    free_object( rsp->o );\n    free_object( rsp->t );\n    free( rsp->buffer );\n    free( rsp );\n    Pike_error(\"Failed to get select fd for scanning device!\\n\");\n  }\n  set_read_callback( fd, (file_callback)nonblocking_row_scan_callback,\n\t\t     (void*)rsp );\n  push_int( 0 );\n}", "path": "src\\modules\\SANE\\sane.c", "repo_name": "johan/pike", "stars": 7, "license": "other", "language": "c", "size": 49732}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n   png_size_t size;\n   png_voidp struct_ptr;\n\n   if (type == PNG_STRUCT_INFO)\n      size = png_sizeof(png_info);\n   else if (type == PNG_STRUCT_PNG)\n      size = png_sizeof(png_struct);\n   else\n      return (NULL);\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (malloc_fn != NULL)\n   {\n      png_struct dummy_struct;\n      png_structp png_ptr = &dummy_struct;\n      png_ptr->mem_ptr=mem_ptr;\n      struct_ptr = (*(malloc_fn))(png_ptr, size);\n      if (struct_ptr != NULL)\n         png_memset(struct_ptr, 0, size);\n      return (struct_ptr);\n   }\n#endif /* PNG_USER_MEM_SUPPORTED */\n\n#if defined(__TURBOC__) && !defined(__FLAT__)\n   struct_ptr = (png_voidp)farmalloc(size);\n#else\n# if defined(_MSC_VER) && defined(MAXSEG_64K)\n   struct_ptr = (png_voidp)halloc(size, 1);\n# else\n   struct_ptr = (png_voidp)malloc(size);\n# endif\n#endif\n   if (struct_ptr != NULL)\n      png_memset(struct_ptr, 0, size);\n\n   return (struct_ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* Free a pointer allocated by png_malloc().  If ptr is NULL, return\n * without taking any action.\n */\n", "func_signal": "void PNGAPI\npng_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n   {\n      (*(png_ptr->free_fn))(png_ptr, ptr);\n      return;\n   }\n   else\n      png_free_default(png_ptr, ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Finds all the roots of an error-locator polynomial _lambda by evaluating it\n   at successive values of alpha, and returns the positions of the associated\n   errors in _epos.\n  Returns the number of valid roots identified.*/\n", "func_signal": "static int rs_find_roots(const rs_gf256 *_gf,unsigned char *_epos,\n const unsigned char *_lambda,int _nerrors,int _ndata)", "code": "{\n  unsigned alpha;\n  int      nroots;\n  int      i;\n  nroots=0;\n  if(_nerrors<=4){\n    /*Explicit solutions for higher degrees are possible.\n      Chien uses large lookup tables to solve quintics, and Truong et al. give\n       special algorithms for degree up through 11, though they use exhaustive\n       search (with reduced complexity) for some portions.\n      Quartics are good enough for reading CDs, and represent a reasonable code\n       complexity trade-off without requiring any extra tables.\n      Note that _lambda[0] is always 1.*/\n    _nerrors=rs_quartic_solve(_gf,_lambda[1],_lambda[2],_lambda[3],_lambda[4],\n     _epos);\n    for(i=0;i<_nerrors;i++)if(_epos[i]){\n      alpha=_gf->log[_epos[i]];\n      if((int)alpha<_ndata)_epos[nroots++]=alpha;\n    }\n    return nroots;\n  }\n  else for(alpha=0;(int)alpha<_ndata;alpha++){\n    unsigned alphai;\n    unsigned sum;\n    sum=0;\n    alphai=0;\n    for(i=0;i<=_nerrors;i++){\n      sum^=rs_hgmul(_gf,_lambda[_nerrors-i],alphai);\n      alphai=_gf->log[_gf->exp[alphai+alpha]];\n    }\n    if(!sum)_epos[nroots++]=alpha;\n  }\n  return nroots;\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Corrects a codeword with _ndata<256 bytes, of which the last _npar are parity\n   bytes.\n  Known locations of errors can be passed in the _erasures array.\n  Twice as many (up to _npar) errors with a known location can be corrected\n   compared to errors with an unknown location.\n  Returns the number of errors corrected if successful, or a negative number if\n   the message could not be corrected because too many errors were detected.*/\n", "func_signal": "int rs_correct(const rs_gf256 *_gf,int _m0,unsigned char *_data,int _ndata,\n int _npar,const unsigned char *_erasures,int _nerasures)", "code": "{\n  /*lambda must have storage for at least five entries to avoid special cases\n     in the low-degree polynomial solver.*/\n  unsigned char lambda[256];\n  unsigned char omega[256];\n  unsigned char epos[256];\n  unsigned char s[256];\n  int           i;\n  /*If we already have too many erasures, we can't possibly succeed.*/\n  if(_nerasures>_npar)return -1;\n  /*Compute the syndrome values.*/\n  rs_calc_syndrome(_gf,_m0,s,_npar,_data,_ndata);\n  /*Check for a non-zero value.*/\n  for(i=0;i<_npar;i++)if(s[i]){\n    int nerrors;\n    int j;\n    /*Construct the error locator polynomial.*/\n    nerrors=rs_modified_berlekamp_massey(_gf,lambda,s,omega,_npar,\n     _erasures,_nerasures,_ndata);\n    /*If we can't locate any errors, we can't force the syndrome values to\n       zero, and must have a decoding error.\n      Conversely, if we have too many errors, there's no reason to even attempt\n       the root search.*/\n    if(nerrors<=0||nerrors-_nerasures>_npar-_nerasures>>1)return -1;\n    /*Compute the locations of the errors.\n      If they are not all distinct, or some of them were outside the valid\n       range for our block size, we have a decoding error.*/\n    if(rs_find_roots(_gf,epos,lambda,nerrors,_ndata)<nerrors)return -1;\n    /*Now compute the error magnitudes.*/\n    for(i=0;i<nerrors;i++){\n      unsigned a;\n      unsigned b;\n      unsigned alpha;\n      unsigned alphan1;\n      unsigned alphan2;\n      unsigned alphanj;\n      alpha=epos[i];\n      /*Evaluate omega at alpha**-1.*/\n      a=0;\n      alphan1=255-alpha;\n      alphanj=0;\n      for(j=0;j<_npar;j++){\n        a^=rs_hgmul(_gf,omega[j],alphanj);\n        alphanj=_gf->log[_gf->exp[alphanj+alphan1]];\n      }\n      /*Evaluate the derivative of lambda at alpha**-1\n        All the odd powers vanish.*/\n      b=0;\n      alphan2=_gf->log[_gf->exp[alphan1<<1]];\n      alphanj=alphan1+_m0*alpha%255;\n      for(j=1;j<=_npar;j+=2){\n        b^=rs_hgmul(_gf,lambda[j],alphanj);\n        alphanj=_gf->log[_gf->exp[alphanj+alphan2]];\n      }\n      /*Apply the correction.*/\n      _data[_ndata-1-alpha]^=rs_gdiv(_gf,a,b);\n    }\n    return nerrors;\n  }\n  return 0;\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Create an _npar-coefficient generator polynomial for a Reed-Solomon code\n   with _npar<256 parity bytes.*/\n", "func_signal": "void rs_compute_genpoly(const rs_gf256 *_gf,int _m0,\n unsigned char *_genpoly,int _npar)", "code": "{\n  int i;\n  if(_npar<=0)return;\n  rs_poly_zero(_genpoly,_npar);\n  _genpoly[0]=1;\n  /*Multiply by (x+alpha^i) for i = 1 ... _ndata.*/\n  for(i=0;i<_npar;i++){\n    unsigned alphai;\n    int      n;\n    int      j;\n    n=i+1<_npar-1?i+1:_npar-1;\n    alphai=_gf->log[_gf->exp[_m0+i]];\n    for(j=n;j>0;j--)_genpoly[j]=_genpoly[j-1]^rs_hgmul(_gf,_genpoly[j],alphai);\n    _genpoly[0]=rs_hgmul(_gf,_genpoly[0],alphai);\n  }\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* This function returns a pointer to the mem_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\n", "func_signal": "png_voidp PNGAPI\npng_get_mem_ptr(png_structp png_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return (NULL);\n   return ((png_voidp)png_ptr->mem_ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,\n    png_voidp mem_ptr)", "code": "{\n#endif\n   if (struct_ptr != NULL)\n   {\n#ifdef PNG_USER_MEM_SUPPORTED\n      if (free_fn != NULL)\n      {\n         png_struct dummy_struct;\n         png_structp png_ptr = &dummy_struct;\n         png_ptr->mem_ptr=mem_ptr;\n         (*(free_fn))(png_ptr, struct_ptr);\n         return;\n      }\n#endif /* PNG_USER_MEM_SUPPORTED */\n      farfree (struct_ptr);\n   }\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Multiply the polynomial by the free variable, x (shift the coefficients).\n  The number of coefficients, _dp1, must be non-zero.*/\n", "func_signal": "static void rs_poly_mul_x(unsigned char *_p,const unsigned char *_q,int _dp1)", "code": "{\n  memmove(_p+1,_q,(_dp1-1)*sizeof(*_p));\n  _p[0]=0;\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Galois Field arithmetic in GF(2**8).*/\n", "func_signal": "void rs_gf256_init(rs_gf256 *_gf,unsigned _ppoly)", "code": "{\n  unsigned p;\n  int      i;\n  /*Initialize the table of powers of a primtive root, alpha=0x02.*/\n  p=1;\n  for(i=0;i<256;i++){\n    _gf->exp[i]=_gf->exp[i+255]=p;\n    p=((p<<1)^(-(p>>7)&_ppoly))&0xFF;\n  }\n  /*Invert the table to recover the logs.*/\n  for(i=0;i<255;i++)_gf->log[_gf->exp[i]]=i;\n  /*Note that we rely on the fact that _gf->log[0]=0 below.*/\n  _gf->log[0]=0;\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n   png_size_t size;\n   png_voidp struct_ptr;\n\n   if (type == PNG_STRUCT_INFO)\n      size = png_sizeof(png_info);\n   else if (type == PNG_STRUCT_PNG)\n      size = png_sizeof(png_struct);\n   else\n      return (png_get_copyright(NULL));\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (malloc_fn != NULL)\n   {\n      png_struct dummy_struct;\n      png_structp png_ptr = &dummy_struct;\n      png_ptr->mem_ptr=mem_ptr;\n      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);\n   }\n   else\n#endif /* PNG_USER_MEM_SUPPORTED */\n   struct_ptr = (png_voidp)farmalloc(size);\n   if (struct_ptr != NULL)\n      png_memset(struct_ptr, 0, size);\n   return (struct_ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* used by poll interface.  lock is already held */\n", "func_signal": "static int proc_video_handler (zbar_processor_t *proc,\n                               int i)", "code": "{\n    _zbar_mutex_lock(&proc->mutex);\n    _zbar_processor_lock(proc);\n    _zbar_mutex_unlock(&proc->mutex);\n\n    zbar_image_t *img = NULL;\n    if(proc->streaming) {\n        /* not expected to block */\n        img = zbar_video_next_image(proc->video);\n        if(img)\n            _zbar_process_image(proc, img);\n    }\n\n    _zbar_mutex_lock(&proc->mutex);\n    _zbar_processor_unlock(proc, 0);\n    _zbar_mutex_unlock(&proc->mutex);\n    if(img)\n        zbar_image_destroy(img);\n    return(0);\n}", "path": "external\\include\\zbar\\zbar\\processor\\posix.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Divide the polynomial by the free variable, x (shift the coefficients).\n  The number of coefficients, _dp1, must be non-zero.*/\n", "func_signal": "static void rs_poly_div_x(unsigned char *_p,const unsigned char *_q,int _dp1)", "code": "{\n  memmove(_p,_q+1,(_dp1-1)*sizeof(*_p));\n  _p[_dp1-1]=0;\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* Free a pointer allocated by png_malloc().  In the default\n * configuration, png_ptr is not used, but is passed in case it\n * is needed.  If ptr is NULL, return without taking any action.\n */\n", "func_signal": "void PNGAPI\npng_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n   {\n      (*(png_ptr->free_fn))(png_ptr, ptr);\n      return;\n   }\n   else\n      png_free_default(png_ptr, ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* gettimeofday */\n", "func_signal": "zbar_window_t *zbar_window_create ()", "code": "{\n    zbar_window_t *w = calloc(1, sizeof(zbar_window_t));\n    if(!w)\n        return(NULL);\n    err_init(&w->err, ZBAR_MOD_WINDOW);\n    w->overlay = 1;\n    (void)_zbar_mutex_init(&w->imglock);\n    return(w);\n}", "path": "external\\include\\zbar\\zbar\\window.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* This function was added at libpng version 1.2.3.  The png_malloc_warn()\n * function will set up png_malloc() to issue a png_warning and return NULL\n * instead of issuing a png_error, if it fails to allocate the requested\n * memory.\n */\n", "func_signal": "png_voidp PNGAPI\npng_malloc_warn(png_structp png_ptr, png_alloc_size_t size)", "code": "{\n   png_voidp ptr;\n   png_uint_32 save_flags;\n   if (png_ptr == NULL)\n      return (NULL);\n\n   save_flags = png_ptr->flags;\n   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;\n   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);\n   png_ptr->flags=save_flags;\n   return(ptr);\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Square root in GF(2**8) using logarithms.*/\n", "func_signal": "static unsigned rs_gsqrt(const rs_gf256 *_gf,unsigned _a)", "code": "{\n  unsigned loga;\n  if(!_a)return 0;\n  loga=_gf->log[_a];\n  return _gf->exp[loga+(255&-(loga&1))>>1];\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Compute the first (d+1) coefficients of the product of a degree e and a\n   degree f polynomial.*/\n", "func_signal": "static void rs_poly_mult(const rs_gf256 *_gf,unsigned char *_p,int _dp1,\n const unsigned char *_q,int _ep1,const unsigned char *_r,int _fp1)", "code": "{\n  int m;\n  int i;\n  rs_poly_zero(_p,_dp1);\n  m=_ep1<_dp1?_ep1:_dp1;\n  for(i=0;i<m;i++)if(_q[i]!=0){\n    unsigned logqi;\n    int      n;\n    int      j;\n    n=_dp1-i<_fp1?_dp1-i:_fp1;\n    logqi=_gf->log[_q[i]];\n    for(j=0;j<n;j++)_p[i+j]^=rs_hgmul(_gf,_r[j],logqi);\n  }\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct(int type)", "code": "{\n#ifdef PNG_USER_MEM_SUPPORTED\n   return (png_create_struct_2(type, NULL, NULL));\n}", "path": "external\\include\\libpng\\pngmem.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* lock must be held */\n", "func_signal": "void _zbar_event_trigger (zbar_event_t *event)", "code": "{\n    event->state = 1;\n#ifdef HAVE_LIBPTHREAD\n    pthread_cond_broadcast(&event->cond);\n#endif\n    if(event->pollfd >= 0) {\n        unsigned i = 0; /* unused */\n        if(write(event->pollfd, &i, sizeof(unsigned)) < 0)\n            perror(\"\");\n        event->pollfd = -1;\n    }\n}", "path": "external\\include\\zbar\\zbar\\processor\\posix.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/*Solve a cubic equation x**3 + _a*x**2 + _b*x + _c in GF(2**8).\n  Returns the number of distinct roots.*/\n", "func_signal": "static int rs_cubic_solve(const rs_gf256 *_gf,\n unsigned _a,unsigned _b,unsigned _c,unsigned char _x[3])", "code": "{\n  unsigned k;\n  unsigned logd;\n  unsigned d2;\n  unsigned logd2;\n  unsigned logw;\n  int      nroots;\n  /*If _c is zero, factor out the 0 root.*/\n  if(!_c){\n    nroots=rs_quadratic_solve(_gf,_a,_b,_x);\n    if(_b)_x[nroots++]=0;\n    return nroots;\n  }\n  /*Substitute x=_a+y*sqrt(_a**2+_b) to get y**3 + y + k == 0,\n     k = (_a*_b+c)/(_a**2+b)**(3/2).*/\n  k=rs_gmul(_gf,_a,_b)^_c;\n  d2=rs_gmul(_gf,_a,_a)^_b;\n  if(!d2){\n    int logx;\n    if(!k){\n      /*We have a triple root.*/\n      _x[0]=_a;\n      return 1;\n    }\n    logx=_gf->log[k];\n    if(logx%3!=0)return 0;\n    logx/=3;\n    _x[0]=_a^_gf->exp[logx];\n    _x[1]=_a^_gf->exp[logx+255/3];\n    _x[2]=_a^_x[0]^_x[1];\n    return 3;\n  }\n  logd2=_gf->log[d2];\n  logd=logd2+(255&-(logd2&1))>>1;\n  k=rs_gdiv(_gf,k,_gf->exp[logd+logd2]);\n  /*Substitute y=w+1/w and z=w**3 to get z**2 + k*z + 1 == 0.*/\n  nroots=rs_quadratic_solve(_gf,k,1,_x);\n  if(nroots<1){\n    /*The Reed-Solomon code is only valid if we can find 3 distinct roots in\n       GF(2**8), so if we know there's only one, we don't actually need to find\n       it.\n      Note that we're also called by the quartic solver, but if we contain a\n       non-trivial irreducible factor, than so does the original\n       quartic~\\cite{LW72}, and failing to return a root here actually saves us\n       some work there, also.*/\n    return 0;\n  }\n  /*Recover w from z.*/\n  logw=_gf->log[_x[0]];\n  if(logw){\n    if(logw%3!=0)return 0;\n    logw/=3;\n    /*Recover x from w.*/\n    _x[0]=_gf->exp[_gf->log[_gf->exp[logw]^_gf->exp[255-logw]]+logd]^_a;\n    logw+=255/3;\n    _x[1]=_gf->exp[_gf->log[_gf->exp[logw]^_gf->exp[255-logw]]+logd]^_a;\n    _x[2]=_x[0]^_x[1]^_a;\n    return 3;\n  }\n  else{\n    _x[0]=_a;\n    /*In this case _x[1] is a double root, so we know the Reed-Solomon code is\n       invalid.\n      Note that we still have to return at least one root, because if we're\n       being called by the quartic solver, the quartic might still have 4\n       distinct roots.\n      But we don't need more than one root, so we can avoid computing the\n       expensive one.*/\n    /*_x[1]=_gf->exp[_gf->log[_gf->exp[255/3]^_gf->exp[2*(255/3)]]+logd]^_a;*/\n    return 1;\n  }\n}", "path": "external\\include\\zbar\\zbar\\qrcode\\rs.c", "repo_name": "krizsa/node-o3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 11872}
{"docstring": "/* Doesn't belong here */\n", "func_signal": "void\ngrab_button(XWindow w, uint button, ulong mod)", "code": "{\n\t_grab(w, button, mod);\n\tif((mod != AnyModifier) && numlock_mask) {\n\t\t_grab(w, button, mod | numlock_mask);\n\t\t_grab(w, button, mod | numlock_mask | LockMask);\n\t}\n}", "path": "cmd\\wmii\\mouse.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* By Dan Bernstein. Public domain. */\n", "func_signal": "static ulong\nhash(const char *str)", "code": "{\n\tulong h;\n\t\n\th = 5381;\n\twhile (*str != '\\0') {\n\t\th += h << 5; /* h *= 33 */\n\t\th ^= *str++;\n\t}\n\treturn h;\n}", "path": "cmd\\wmii\\map.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n *  save a new match in mp\n */\n", "func_signal": "extern void\n_renewmatch(Resub *mp, int ms, Resublist *sp)", "code": "{\n\tint i;\n\n\tif(mp==0 || ms<=0)\n\t\treturn;\n\tif(mp[0].s.sp==0 || sp->m[0].s.sp<mp[0].s.sp ||\n\t   (sp->m[0].s.sp==mp[0].s.sp && sp->m[0].e.ep>mp[0].e.ep)){\n\t\tfor(i=0; i<ms && i<NSUBEXP; i++)\n\t\t\tmp[i] = sp->m[i];\n\t\tfor(; i<ms; i++)\n\t\t\tmp[i].s.sp = mp[i].e.ep = 0;\n\t}\n}", "path": "libregexp\\regaux.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* Service Functions */\n", "func_signal": "static int\nxwrite(int argc, char *argv[])", "code": "{\n\tIxpCFid *fid;\n\tchar *file;\n\n\tARGBEGIN{\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\n\tfile = EARGF(usage());\n\tfid = ixp_open(client, file, P9_OWRITE);\n\tif(fid == nil)\n\t\tfatal(\"Can't open file '%s': %r\\n\", file);\n\n\twrite_data(fid, file);\n\tixp_close(fid);\n\treturn 0;\n}", "path": "cmd\\wmiir.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n * __fmtlock() must be set\n */\n", "func_signal": "static int\n__fmtinstall(int c, Fmts f)", "code": "{\n\tConvfmt *p, *ep;\n\n\tif(c<=0 || c>=65536)\n\t\treturn -1;\n\tif(!f)\n\t\tf = __badfmt;\n\n\tep = &fmtalloc.fmt[fmtalloc.nfmt];\n\tfor(p=fmtalloc.fmt; p<ep; p++)\n\t\tif(p->c == c)\n\t\t\tbreak;\n\n\tif(p == &fmtalloc.fmt[Maxfmt])\n\t\treturn -1;\n\n\tp->fmt = f;\n\tif(p == ep){\t/* installing a new format character */\n\t\tfmtalloc.nfmt++;\n\t\tp->c = c;\n\t}\n\n\treturn 0;\n}", "path": "libfmt\\fmt.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n * Return pointer to first occurrence of s2 in s1,\n * 0 if none\n */\n", "func_signal": "char*\nutfutf(const char *s1, const char *s2)", "code": "{\n\tconst char *p;\n\tlong f, n1, n2;\n\tRune r;\n\n\tn1 = chartorune(&r, s2);\n\tf = r;\n\tif(f <= Runesync)\t\t/* represents self */\n\t\treturn strstr(s1, s2);\n\n\tn2 = strlen(s2);\n\tfor(p=s1; p=utfrune(p, f); p+=n1)\n\t\tif(strncmp(p, s2, n2) == 0)\n\t\t\treturn (char*)p;\n\treturn 0;\n}", "path": "libutf\\utfutf.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n * Return pointer to first occurrence of s2 in s1,\n * 0 if none\n */\n", "func_signal": "Rune*\nrunestrstr(const Rune *s1, const Rune *s2)", "code": "{\n\tconst Rune *pa, *pb;\n\tRune *p;\n\tint c0, c;\n\n\tc0 = *s2;\n\tif(c0 == 0)\n\t\treturn (Rune*)s1;\n\ts2++;\n\tfor(p=runestrchr(s1, c0); p; p=runestrchr(p+1, c0)) {\n\t\tpa = p;\n\t\tfor(pb=s2;; pb++) {\n\t\t\tc = *pb;\n\t\t\tif(c == 0)\n\t\t\t\treturn p;\n\t\t\tif(c != *++pa)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "libutf\\runestrstr.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* set_wm_hints --- set all the window manager hints */\n", "func_signal": "void\ncreate_window(void)", "code": "{\n\tWinAttr wa = { 0 };\n\tXEvent e;\n\n\twa.override_redirect = true;\n\tmenuwin = createwindow(&scr.root, Rect(-1, -1, 0, 0),\n\t\t\t       scr.depth, InputOutput,\n\t\t\t       &wa, CWOverrideRedirect);\n\tselectinput(menuwin, MenuMask);\n\tmapwin(menuwin);\n\tXMaskEvent(display, StructureNotifyMask, &e);\n\tif(!grabpointer(menuwin, nil, 0, MouseMask))\n\t\tfatal(\"Failed to grab the mouse\\n\");\n\tXSetCommand(display, menuwin->xid, g_argv, g_argc);\n}", "path": "cmd\\wmii9menu.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* Utility Functions */\n", "func_signal": "static void\nwrite_data(IxpCFid *fid, char *name)", "code": "{\n\tvoid *buf;\n\tint len;\n\n\tbuf = emalloc(fid->iounit);;\n\tfor(;;) {\n\t\tlen = read(0, buf, fid->iounit);\n\t\tif(len <= 0)\n\t\t\tbreak;\n\t\tif(ixp_write(fid, buf, len) != len)\n\t\t\tfatal(\"cannot write file %q\\n\", name);\n\t}\n\tfree(buf);\n}", "path": "cmd\\wmiir.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* warpmouse --- bring the mouse to the menu */\n", "func_signal": "void\nwarpmouse(int wide, int high)", "code": "{\n\tPoint p;\n\tint offset;\n\n\t/* move tip of pointer into middle of menu item */\n\toffset = labelh(font) / 2;\n\toffset += 6;\t/* fudge factor */\n\n\tp = Pt(wide / 2, cur*high - high/2 + offset);\n\tp = addpt(p, menuwin->r.min);\n\n\twarppointer(p);\n}", "path": "cmd\\wmii9menu.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* This isn't perfect. If there were motion events in the queue\n * before this was called, then it flushes nothing. If we don't\n * check for them, we might lose a legitamate enter event.\n */\n", "func_signal": "uint\nflushenterevents(void)", "code": "{\n\tXEvent e;\n\tlong l;\n\tint n;\n\n\tl = 0;\n\tn = 0;\n\twhile(XCheckIfEvent(display, &e, findenter, (void*)&l))\n\t\tn++;\n\treturn n;\n}", "path": "cmd\\menu\\event.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n * print into an allocated string buffer\n */\n", "func_signal": "Rune*\nrunevsmprint(const char *fmt, va_list args)", "code": "{\n\tFmt f;\n\tint n;\n\n\tif(runefmtstrinit(&f) < 0)\n\t\treturn nil;\n\tva_copy(f.args,args);\n\tn = dofmt(&f, fmt);\n\tva_end(f.args);\n\tif(f.start == nil)\n\t\treturn nil;\n\tif(n < 0){\n\t\tfree(f.start);\n\t\treturn nil;\n\t}\n\t*(Rune*)f.to = '\\0';\n\treturn (Rune*)f.start;\n}", "path": "libfmt\\runevsmprint.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* usage --- print a usage message and die */\n", "func_signal": "void\nusage(void)", "code": "{\n\tfprintf(stderr, \"usage: %s -v\\n\", argv0);\n\tfprintf(stderr, \"       %s [-a <address>] [-i <arg>] menitem[:command] ...\\n\", argv0);\n\texit(0);\n}", "path": "cmd\\wmii9menu.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* Don't let increment hints take up more than half\n * of the screen, in either direction.\n */\n", "func_signal": "static Rectangle\nfix_rect(Rectangle old, Rectangle new)", "code": "{\n\tdouble r;\n\n\tnew = rect_intersection(new, old);\n\n\tr = (Dy(old) - Dy(new)) / Dy(old);\n\tif(r > .5) {\n\t\tr -= .5;\n\t\tnew.min.y -= r * (new.min.y - old.min.y);\n\t\tnew.max.y += r * (old.max.y - new.max.y);\n\t}\n\tr = (Dx(old) - Dx(new)) / Dx(old);\n\tif(r > .5) {\n\t\tr -= .5;\n\t\tnew.min.x -= r * (new.min.x - old.min.x);\n\t\tnew.max.x += r * (old.max.x - new.max.x);\n\t}\n\treturn new;\n}", "path": "cmd\\wmii\\view.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* XXX: Multihead. */\n", "func_signal": "void\nview_arrange(View *v)", "code": "{\n\tArea *a;\n\tint s;\n\n\tif(!v->firstarea)\n\t\treturn;\n\n\tview_update_rect(v);\n\tfor(s=0; s < nscreens; s++)\n\t\tview_scale(v, s, Dx(v->r[s]) + Dx(v->pad[s]));\n\tforeach_area(v, s, a) {\n\t\tif(a->floating)\n\t\t\tcontinue;\n\t\t/* This is wrong... */\n\t\ta->r.min.y = v->r[s].min.y;\n\t\ta->r.max.y = v->r[s].max.y;\n\t\tcolumn_arrange(a, false);\n\t}\n\tif(v == selview)\n\t\tdiv_update_all();\n}", "path": "cmd\\wmii\\view.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* Stubs. */\n", "func_signal": "void\ndebug(int flag, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tUSED(flag);\n\tva_start(ap, fmt);\n\tvfprint(2, fmt, ap);\n\tva_end(ap);\n}", "path": "cmd\\menu\\main.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* main --- crack arguments, set up X stuff, run the main menu loop */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n\tstatic char *address;\n\tchar *cp;\n\tint i;\n\n\tg_argc = argc;\n\tg_argv = argv;\n\n\tARGBEGIN{\n\tcase 'v':\n\t\tprint(\"%s\\n\", version);\n\t\treturn 0;\n\tcase 'a':\n\t\taddress = EARGF(usage());\n\t\tbreak;\n\tcase 'i':\n\t\tinitial = EARGF(usage());\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND;\n\n\tif(argc == 0)\n\t\tusage();\n\n\tinitdisplay();\n\txext_init();\n\tinit_screens();\n\tcreate_window();\n\n\tnumitems = argc;\n\n\tlabels = emalloc(numitems * sizeof *labels);\n\tcommands = emalloc(numitems * sizeof *labels);\n\n\tfor(i = 0; i < numitems; i++) {\n\t\tlabels[i] = argv[i];\n\t\tif((cp = strchr(labels[i], ':')) != nil) {\n\t\t\t*cp++ = '\\0';\n\t\t\tcommands[i] = cp;\n\t\t} else\n\t\t\tcommands[i] = labels[i];\n\t\tif(strcmp(labels[i], initial) == 0)\n\t\t\tcur = i;\n\t}\n\n\tclient_init(address);\n\n\twborder = strtol(readctl(\"border \"), nil, 10);\n\tloadcolor(&cnorm, readctl(\"normcolors \"));\n\tloadcolor(&csel, readctl(\"focuscolors \"));\n\tfont = loadfont(readctl(\"font \"));\n\tif(!font)\n\t\tfatal(\"Can't load font\");\n\n\trun_menu();\n\n\tXCloseDisplay(display);\n\treturn 0;\n}", "path": "cmd\\wmii9menu.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* Returns a gravity for increment handling. It's normally the\n * opposite of the mask (the directions that we're resizing in),\n * unless a snap occurs, in which case, it's the direction of the\n * snap.\n */\n", "func_signal": "Align\nsnap_rect(const Rectangle *rects, int num, Rectangle *r, Align *mask, int snap)", "code": "{\n\tAlign ret;\n\tPoint d;\n\t\n\td.x = snap+1;\n\td.y = snap+1;\n\n\tif(*mask&North)\n\t\td.y = snap_hline(rects, num, d.y, r, r->min.y);\n\tif(*mask&South)\n\t\td.y = snap_hline(rects, num, d.y, r, r->max.y);\n\n\tif(*mask&East)\n\t\td.x = snap_vline(rects, num, d.x, r, r->max.x);\n\tif(*mask&West)\n\t\td.x = snap_vline(rects, num, d.x, r, r->min.x);\n\n\tret = Center;\n\tif(abs(d.x) <= snap)\n\t\tret ^= East|West;\n\telse\n\t\td.x = 0;\n\n\tif(abs(d.y) <= snap)\n\t\tret ^= North|South;\n\telse\n\t\td.y = 0;\n\n\trect_morph(r, d, mask);\n\treturn ret ^ *mask;\n}", "path": "cmd\\wmii\\mouse.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* redraw --- actually redraw the menu */\n", "func_signal": "void\nredraw(int high, int wide)", "code": "{\n\tRectangle r;\n\tCTuple *c;\n\tint i;\n\n\tr = Rect(0, 0, wide, high);\n\tfor(i = 0; i < numitems; i++) {\n\t\tif(cur == i)\n\t\t\tc = &csel;\n\t\telse\n\t\t\tc = &cnorm;\n\t\tr = rectsetorigin(r, Pt(0, i * high));\n\t\tfill(menuwin, r, c->bg);\n\t\tdrawstring(menuwin, font, r, Center, labels[i], c->fg);\n\t}\n}", "path": "cmd\\wmii9menu.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/*\n * format a string into the output buffer\n * designed for formats which themselves call fmt,\n * but ignore any width flags\n */\n", "func_signal": "int\nfmtvprint(Fmt *f, const char *fmt, va_list args)", "code": "{\n\tva_list va;\n\tint n;\n\n\tf->flags = 0;\n\tf->width = 0;\n\tf->prec = 0;\n\tva_copy(va,f->args);\n\tva_end(f->args);\n\tva_copy(f->args,args);\n\tn = dofmt(f, fmt);\n\tf->flags = 0;\n\tf->width = 0;\n\tf->prec = 0;\n\tva_end(f->args);\n\tva_copy(f->args,va);\n\tva_end(va);\n\tif(n >= 0)\n\t\treturn 0;\n\treturn n;\n}", "path": "libfmt\\fmtvprint.c", "repo_name": "bartman/wmii", "stars": 7, "license": "mit", "language": "c", "size": 6808}
{"docstring": "/* must send to idle the postprocessor tunnel after camera   */\n", "func_signal": "static void\ngoo_ti_camera_pp_set_idle (GooComponent* self)", "code": "{\n\tGooComponent *postproc = goo_ti_camera_get_postproc (self);\n\n\tif (postproc == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tGOO_OBJECT_DEBUG (postproc, \"going to set postproc to idle\");\n\n\tgoo_component_set_state_idle (postproc);\n\n\tGOO_OBJECT_DEBUG (postproc, \"going to wait for next idle state\");\n\n\tgoo_component_wait_for_next_state (postproc);\n\tg_object_unref (postproc);\n\n\tGOO_OBJECT_DEBUG (postproc, \"done\");\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_set_dasf_mode:\n * @self: An #GooTiAudioComponent instance\n * @dasf_mode: a boolean value\n *\n * This method will actividate/deactivate de DASF mode in the specified audio\n * component.\n **/\n", "func_signal": "void\ngoo_ti_audio_component_set_dasf_mode (GooTiAudioComponent* self,\n\t\t\t\t      gboolean dasf_mode)", "code": "{\n\tg_assert (self != NULL);\n\n\tg_object_set (G_OBJECT (self), \"dasf-mode\", dasf_mode, NULL);\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_set_data_path:\n * @self: An #GooTiAudioComponent instance\n * @data_path: a uint value\n *\n * This method will actividate/deactivate de DATA-PATH in the specified audio\n * component.\n **/\n", "func_signal": "void\ngoo_ti_audio_component_set_data_path (GooTiAudioComponent* self,\n\t\t\t\t      guint data_path)", "code": "{\n\tg_assert (self != NULL);\n\n\tg_object_set (G_OBJECT (self), \"data-path\", data_path, NULL);\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* not used right now */\n", "func_signal": "static GooTiCameraZoom\n_goo_ti_camera_get_zoom_height (GooTiCamera* self)", "code": "{\n\tg_assert (self != NULL);\n\tg_assert (GOO_COMPONENT (self)->cur_state != OMX_StateInvalid);\n\n\tOMX_CONFIG_SCALEFACTORTYPE* param;\n\tparam = g_new0 (OMX_CONFIG_SCALEFACTORTYPE, 1);\n\tGOO_INIT_PARAM (param, OMX_CONFIG_SCALEFACTORTYPE);\n\n\tgoo_component_get_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tGooTiCameraZoom retval;\n\tretval = (GooTiCameraZoom) param->xHeight;\n\n\tg_free (param);\n\n\tGOO_OBJECT_DEBUG (self, \"\");\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_set_acoustic_mode:\n * @self: An #GooTiAudioComponent instance\n * @dasf_mode: a boolean value\n *\n * This method will actividate/deactivate the Acoustic mode in the specified audio\n * component.\n **/\n", "func_signal": "void\ngoo_ti_audio_component_set_acoustic_mode (GooTiAudioComponent* self,\n\t\t\t\t      gboolean acoustic_mode)", "code": "{\n\tg_assert (self != NULL);\n\n\tg_object_set (G_OBJECT (self), \"acdn-mode\", acoustic_mode, NULL);\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* not used right now */\n", "func_signal": "static GooTiCameraZoom\n_goo_ti_camera_get_zoom_width (GooTiCamera* self)", "code": "{\n\tg_assert (self != NULL);\n\tg_assert (GOO_COMPONENT (self)->cur_state != OMX_StateInvalid);\n\n\tOMX_CONFIG_SCALEFACTORTYPE* param;\n\tparam = g_new0 (OMX_CONFIG_SCALEFACTORTYPE, 1);\n\tGOO_INIT_PARAM (param, OMX_CONFIG_SCALEFACTORTYPE);\n\n\tgoo_component_get_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tGooTiCameraZoom retval;\n\tretval = (GooTiCameraZoom) param->xWidth;\n\n\tg_free (param);\n\n\tGOO_OBJECT_DEBUG (self, \"\");\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * OpenMAX callback\n **/\n", "func_signal": "static void\ngoo_ti_camera_event_handler (OMX_HANDLETYPE hComponent, OMX_PTR pAppData,\n\t\t\t     OMX_EVENTTYPE eEvent, OMX_U32 nData1,\n\t\t\t     OMX_U32 nData2, OMX_PTR pEventData)", "code": "{\n\tGooComponent* self = GOO_COMPONENT (g_object_ref (pAppData));\n\tGooTiCameraPriv* priv = GOO_TI_CAMERA_GET_PRIVATE (self);\n\tGooTiCameraOmxDataEvent OmxEventData;\n\n\tswitch (eEvent)\n\t{\n\tcase OMX_EventCmdComplete:\n\t{\n\t\tOMX_COMMANDTYPE cmd = (OMX_COMMANDTYPE) nData1;\n\t\tswitch (cmd)\n\t\t{\n\t\tcase OMX_CustomCommandAutofocusComplete:\n\t\t\tGOO_OBJECT_INFO (self, \"AutofocusComplete status = %d\", nData2);\n\t\t\tgoo_semaphore_up (priv->focus_sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGOO_OBJECT_INFO (self,\n\t\t\t\t \"(From goo-ti-camera) EventCmdComplete - command: %s\",\n\t\t\t\t goo_strcommand (cmd));\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tGOO_OBJECT_INFO (self, \"OMX_EVENT: %d\",(guint) eEvent);\n\t\tOmxEventData.eEvent = (guint) eEvent;\n\t\tOmxEventData.nData1 = (gulong) nData1;\n\t\tOmxEventData.nData2 = (gulong) nData2;\n\t\tg_signal_emit (G_OBJECT (self),\n\t\t\t\tgoo_ti_camera_signals[PPM_OMX_EVENT], 0, &OmxEventData);\n\t\tbreak;\n\t}\n\n\tg_object_unref (G_OBJECT (self));\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_get_volume:\n * @self: An #GooTiAudioComponent instance\n *\n * Get the volume value when the component is in DASF mode\n *\n * Return value: if the component is in DASF mode will return a value between\n * 0 and 100;\n **/\n", "func_signal": "guint\ngoo_ti_audio_component_get_volume (GooTiAudioComponent* self)", "code": "{\n\tg_assert (self != NULL);\n\n\tguint retval = 50;\n\tg_object_get (G_OBJECT (self), \"volume\", &retval, NULL);\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_component_factory_get_component:\n * @self: the #GooComponentFactory instance\n * @type: an enum of the object to create\n *\n * Create a new #GooComponent instance. The returned instance must be\n * unreferenced after use.\n *\n * Return value: a #GooComponent instance\n **/\n", "func_signal": "GooComponent*\ngoo_component_factory_get_component (GooComponentFactory *self, guint type)", "code": "{\n        g_assert (GOO_IS_COMPONENT_FACTORY (self));\n        g_assert (GOO_COMPONENT_FACTORY_GET_CLASS (self)->get_component_func);\n\n        GooComponent* retval = NULL;\n        retval = GOO_COMPONENT_FACTORY_GET_CLASS (self)->get_component_func (self, type);\n        g_assert (retval != NULL);\n\n        return retval;\n}", "path": "libgoo\\goo-component-factory.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_set_mute:\n * @self: An #GooTiAudioComponent instance\n * @mute: An boolean value\n *\n * Turn OFF and turn ON the mute when the audio component is in DASF mode\n **/\n", "func_signal": "void\ngoo_ti_audio_component_set_mute (GooTiAudioComponent* self, gboolean mute)", "code": "{\n\tg_assert (self != NULL);\n\n\tg_object_set (G_OBJECT (self), \"mute\", mute, NULL);\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* remember to unref the port after usage */\n", "func_signal": "static GooPort*\ngoo_ti_camera_get_port (GooTiCamera* self, guint index)", "code": "{\n\tg_assert (self != NULL);\n\tg_assert (index >= 0);\n\n\tGOO_OBJECT_DEBUG (self, \"Getting port %d\", index);\n\n\tGooIterator* iter;\n\titer = goo_component_iterate_ports (GOO_COMPONENT (self));\n\tgoo_iterator_nth (iter, index);\n\tGooPort* port = GOO_PORT (goo_iterator_get_current (iter));\n\tg_assert (port != NULL);\n\tg_object_unref (iter);\n\n\treturn port;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_camera_get_videoenc:\n * @self: a #GooTiCamera instance\n *\n * If the camera's capture port is tunneled with the videoenc,\n * this function will return the videoencoder instance. After use you\n * must unref the object.\n *\n * Return value: A #GooComponent referencing the GooTiVideoenc instance\n *               or NULL if the view finding port is not tunneled. You must\n *               unref the object once you don't use it anymore.\n */\n", "func_signal": "static GooComponent*\ngoo_ti_camera_get_enc (GooComponent* self)", "code": "{\n\tGooComponent* retval = NULL;\n\n\tGooPort* port = goo_ti_camera_get_port (GOO_TI_CAMERA (self),\n\t\t\t\t\t\tPORT_CAPTURE);\n\n\tif (goo_port_is_tunneled (port) && goo_port_is_enabled (port))\n\t{\n\t\tGOO_OBJECT_INFO (self, \"capture port is enabled\");\n\n\t\tGooPort *peer_port;\n\t\tpeer_port = goo_port_get_peer (port);\n\n\t\tg_assert (peer_port != NULL);\n\n\t\tretval = GOO_COMPONENT (\n\t\t\tgoo_object_get_owner (GOO_OBJECT (peer_port))\n\t\t\t);\n\t\tg_assert (retval != NULL);\n\n\t\tg_object_unref (peer_port);\n\t}\n\n\tg_object_unref (port);\n\n\tGOO_OBJECT_DEBUG (self, \"\");\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_component_factory_add_component:\n * @self: The #GooComponentFactory instance\n * @component: The #GooComponent instance you want to add to the factory\n *\n * The factory maintains a list of components created by itself. This method\n * add component to this list. This function is intented to be used only by\n * the derived component factories.\n */\n", "func_signal": "void\ngoo_component_factory_add_component (GooComponentFactory* self,\n\t\t\t\t     GooComponent* component)", "code": "{\n\tg_assert (GOO_IS_COMPONENT_FACTORY (self));\n\tg_assert (GOO_IS_COMPONENT (component));\n\n\tgoo_list_append (self->components, GOO_OBJECT (component));\n\tgoo_object_set_owner (GOO_OBJECT (component), GOO_OBJECT (self));\n\n\tGOO_OBJECT_DEBUG (component, \"Refing component %d\",\n\t\t\t  G_OBJECT (component)->ref_count);\n\n\treturn;\n}", "path": "libgoo\\goo-component-factory.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_is_dasf_mode:\n * @self: An #GooTiAudioComponent instance\n *\n * Return if the DASF mode is activated in the audio component\n *\n * Return value: TRUE if the component is in DASF mode; FALSE otherwise\n **/\n", "func_signal": "gboolean\ngoo_ti_audio_component_is_dasf_mode (GooTiAudioComponent* self)", "code": "{\n\tg_assert (self != NULL);\n\n\tgboolean retval = FALSE;\n\tg_object_get (G_OBJECT (self), \"dasf-mode\", &retval, NULL);\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_is_mute:\n * @self: An #GooTiAudioComponent instance\n *\n * Verify the muteness of the component when it is in DASF mode\n *\n * Return value: TRUE if the component is mute; FALSE otherwise\n **/\n", "func_signal": "gboolean\ngoo_ti_audio_component_is_mute (GooTiAudioComponent* self)", "code": "{\n\tg_assert (self != NULL);\n\n\tgboolean retval = FALSE;\n\tg_object_get (G_OBJECT (self), \"mute\", &retval, NULL);\n\n\treturn retval;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/**\n * goo_ti_audio_component_set_frame_mode:\n * @self: An #GooTiAudioComponent instance\n * @dasf_mode: a boolean value\n *\n * This method will actividate/deactivate de Frame mode in the specified audio\n * component.\n **/\n", "func_signal": "void\ngoo_ti_audio_component_set_frame_mode (GooTiAudioComponent* self,\n\t\t\t\t      gboolean frame_mode)", "code": "{\n\tg_assert (self != NULL);\n\n\tg_object_set (G_OBJECT (self), \"frame-mode\", frame_mode, NULL);\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-audio-component.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/*\nSTART_TEST (test_aacenc_24)\n{\n\tprintf (\"test_aacenc_24\\n\");\n\tprocess (NULL, 1, 48000, 128000, OMX_AUDIO_AACObjectHE_PS,\n\t\t OMX_AUDIO_AACStreamFormatADIF, GOO_TI_AACENC_BR_CBR, 30);\n}\nEND_TEST\n*/\n", "func_signal": "START_TEST (test_aacenc_25)", "code": "{\n\tprintf (\"test_aacenc_25\\n\");\n\tprocess (NULL, 1, 60000, 100000, OMX_AUDIO_AACObjectLC,\n\t\t OMX_AUDIO_AACStreamFormatADIF, GOO_TI_AACENC_BR_CBR, 30);\n}", "path": "test\\check-aacenc.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/*\n * Check if output ports are in tunnel mode. If so, send peer components\n * to EXECUTING state recursively\n */\n", "func_signal": "static void\ngoo_ti_camera_propagate_executing (GooComponent* self)", "code": "{\n\tGooComponent* postproc = goo_ti_camera_get_postproc (self);\n\n\tGooComponent* videoenc = goo_ti_camera_get_enc (self);\n\n\tif (videoenc != NULL)\n\t{\n\t\tGOO_OBJECT_INFO (videoenc, \"Sending executing state command\");\n\n\t\tgoo_component_set_state_executing (videoenc);\n\n\t\tgoo_component_wait_for_next_state (videoenc);\n\n\t\tg_object_unref (videoenc);\n\t}\n\n\tGooComponent* jpegenc = goo_ti_camera_get_enc (self);\n\n\tif (jpegenc != NULL)\n\t{\n\t\tGOO_OBJECT_INFO (jpegenc, \"Sending executing state command\");\n\n\t\tgoo_component_set_state_executing (jpegenc);\n\n\t\tgoo_component_wait_for_next_state (jpegenc);\n\n\t\tg_object_unref (jpegenc);\n\t}\n\n\tif (postproc != NULL)\n\t{\n\t\tGOO_OBJECT_INFO (postproc, \"Sending executing state command\");\n\n\t\tgoo_component_set_state_executing (postproc);\n\n\t\tgoo_component_wait_for_next_state (postproc);\n\n\t\tg_object_unref (postproc);\n\t}\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* not used right now */\n", "func_signal": "static void\n_goo_ti_camera_set_zoom_width (GooTiCamera* self, GooTiCameraZoom zoom)", "code": "{\n\tg_assert (self != NULL);\n\tg_assert (GOO_COMPONENT (self)->cur_state != OMX_StateInvalid);\n\n\tOMX_CONFIG_SCALEFACTORTYPE* param;\n\tparam = g_new0 (OMX_CONFIG_SCALEFACTORTYPE, 1);\n\tGOO_INIT_PARAM (param, OMX_CONFIG_SCALEFACTORTYPE);\n\n\tgoo_component_get_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tparam->xWidth = (OMX_S32) zoom;\n\n\tgoo_component_set_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tg_free (param);\n\n\tGOO_OBJECT_DEBUG (self, \"\");\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* not used right now */\n", "func_signal": "static void\n_goo_ti_camera_set_zoom_height (GooTiCamera* self, GooTiCameraZoom zoom)", "code": "{\n\tg_assert (self != NULL);\n\tg_assert (GOO_COMPONENT (self)->cur_state != OMX_StateInvalid);\n\n\tOMX_CONFIG_SCALEFACTORTYPE* param;\n\tparam = g_new0 (OMX_CONFIG_SCALEFACTORTYPE, 1);\n\tGOO_INIT_PARAM (param, OMX_CONFIG_SCALEFACTORTYPE);\n\n\tgoo_component_get_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tparam->xHeight = (OMX_S32) zoom;\n\n\tgoo_component_set_config_by_index (GOO_COMPONENT (self),\n\t\t\t\t\t   OMX_IndexConfigCommonDigitalZoom,\n\t\t\t\t\t   param);\n\n\tg_free (param);\n\n\tGOO_OBJECT_DEBUG (self, \"\");\n\n\treturn;\n}", "path": "libgoo-ti\\goo-ti-camera.c", "repo_name": "mrchapp/libgoo", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 499}
{"docstring": "/* exported\n */\n", "func_signal": "void disasmInitialize(struct disasmContext* DisasmContext)", "code": "{\n  ud_init(&DisasmContext->ud);\n  ud_set_mode(&DisasmContext->ud, 32);\n  ud_set_syntax(&DisasmContext->ud, UD_SYN_INTEL);\n}", "path": "sys\\disasm.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_gpr() - Returns decoded General Purpose Register \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \ndecode_gpr(register struct ud* u, unsigned int s, unsigned char rm)", "code": "{\n  s = resolve_oprsize(u, s);\n\t\t\n  switch (s) {\n\tcase 64:\n\t\treturn UD_R_RAX + rm;\n\tcase SZ_DP:\n\tcase 32:\n\t\treturn UD_R_EAX + rm;\n\tcase SZ_WP:\n\tcase 16:\n\t\treturn UD_R_AX  + rm;\n\tcase  8:\n\t\tif (u->dis_mode == 64 && u->pfx_rex) {\n\t\t\tif (rm >= 4)\n\t\t\t\treturn UD_R_SPL + (rm-4);\n\t\t\treturn UD_R_AL + rm;\n\t\t} else return UD_R_AL + rm;\n\tdefault:\n\t\treturn 0;\n  }\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* =============================================================================\n * ud_decode() - Instruction decoder. Returns the number of bytes decoded.\n * =============================================================================\n */\n", "func_signal": "unsigned int ud_decode( struct ud* u )", "code": "{\n  inp_start(u);\n\n  if ( clear_insn( u ) ) {\n\t; /* error */\n  } else if ( do_prefixes( u ) != 0 ) {\n\t; /* error */\n  } else if ( ud_search_map( u ) != 0 ) {\n\t; /* error */\n  } else if ( do_mode( u ) != 0 ) {\n\t; /* error */\n  } else if ( disasm_operands( u ) != 0 ) {\n\t; /* error */\n  } else if ( resolve_mnemonic( u ) != 0 ) {\n\t; /* error */\n  }\n\n  /* Handle decode error. */\n  if ( u->error ) {\n\t/* clear out the decode data. */\n\tclear_insn( u );\n\t/* mark the sequence of bytes as invalid. */\n\tu->mapen = ud_me_invalid();\n\tu->mnemonic = u->mapen->mnemonic;\n  } \n\n  u->insn_offset = u->pc; /* set offset of instruction */\n  u->insn_fill = 0;\t  /* set translation buffer index to 0 */\n  u->pc += u->inp_ctr;\t  /* move program counter by bytes decoded */\n  gen_hex( u );\t\t  /* generate hex code */\n\n  /* return number of bytes disassembled. */\n  return u->inp_ctr;\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * disasm_operands() - Disassembles Operands.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static int disasm_operands(register struct ud* u)", "code": "{\n\n\n  /* mopXt = map entry, operand X, type; */\n  enum map_operand_type mop1t = u->mapen->operand1.type;\n  enum map_operand_type mop2t = u->mapen->operand2.type;\n  enum map_operand_type mop3t = u->mapen->operand3.type;\n\n  /* mopXs = map entry, operand X, size */\n  unsigned int mop1s = u->mapen->operand1.size;\n  unsigned int mop2s = u->mapen->operand2.size;\n  unsigned int mop3s = u->mapen->operand3.size;\n\n  /* iop = instruction operand */\n  register struct ud_operand* iop = u->operand;\n\t\n  switch(mop1t) {\n\t\n\tcase OP_A :\n\t\tdecode_a(u, &(iop[0]));\n\t\tbreak;\n\t\n\t/* M[b] ... */\n\tcase OP_M :\n\t\tif (MODRM_MOD(inp_peek(u)) == 3)\n\t\t\tu->error= 1;\n\t/* E, G/P/V/I/CL/1/S */\n\tcase OP_E :\n\t\tif (mop2t == OP_G) {\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_GPR);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t\telse if (mop3t == OP_CL) {\n\t\t\t\tiop[2].type = UD_OP_REG;\n\t\t\t\tiop[2].base = UD_R_CL;\n\t\t\t\tiop[2].size = 8;\n\t\t\t}\n\t\t}\n\t\telse if (mop2t == OP_P)\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_MMX);\n\t\telse if (mop2t == OP_V)\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_XMM);\n\t\telse if (mop2t == OP_S)\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_SEG);\n\t\telse {\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, NULL, 0, T_NONE);\n\t\t  if (mop2t == OP_CL) {\n\t\t    iop[1].type = UD_OP_REG;\n\t\t    iop[1].base = UD_R_CL;\n\t\t    iop[1].size = 8;\n\t\t  } else if (mop2t == OP_I1) {\n\t\t    iop[1].type = UD_OP_CONST;\n\t\t    u->operand[1].lval.udword = 1;\n\t\t  } else if (mop2t == OP_I) {\n\t\t    decode_imm(u, (unsigned char)mop2s, &(iop[1]));\n\t\t  }\n\t\t}\n\t\tbreak;\n\n\t/* G, E/PR[,I]/VR */\n\tcase OP_G :\n\n\t\tif (mop2t == OP_M) {\n\t\t  if (MODRM_MOD(inp_peek(u)) == 3)\n\t\t    u->error= 1;\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_GPR);\n\t\t} else if (mop2t == OP_E) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_GPR);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t} else if (mop2t == OP_PR) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), (unsigned char)mop1s, T_GPR);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t} else if (mop2t == OP_VR) {\n\t\t\tif (MODRM_MOD(inp_peek(u)) != 3)\n\t\t\t\tu->error = 1;\n\t\t\tdecode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), (unsigned char)mop1s, T_GPR);\n\t\t} else if (mop2t == OP_W)\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), (unsigned char)mop1s, T_GPR);\n\t\tbreak;\n\n\t/* AL..BH, I/O/DX */\n\tcase OP_AL : case OP_CL : case OP_DL : case OP_BL :\n\tcase OP_AH : case OP_CH : case OP_DH : case OP_BH :\n\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = UD_R_AL + (mop1t - OP_AL);\n\t\tiop[0].size = 8;\n\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\telse if (mop2t == OP_DX) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = UD_R_DX;\n\t\t\tiop[1].size = 16;\n\t\t}\n\t\telse if (mop2t == OP_O)\n\t\t\tdecode_o(u, mop2s, &(iop[1]));\n\t\tbreak;\n\n\t/* rAX[r8]..rDI[r15], I/rAX..rDI/O */\n\tcase OP_rAXr8 : case OP_rCXr9 : case OP_rDXr10 : case OP_rBXr11 :\n\tcase OP_rSPr12: case OP_rBPr13: case OP_rSIr14 : case OP_rDIr15 :\n\tcase OP_rAX : case OP_rCX : case OP_rDX : case OP_rBX :\n\tcase OP_rSP : case OP_rBP : case OP_rSI : case OP_rDI :\n\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = resolve_gpr64(u, mop1t);\n\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\telse if (mop2t >= OP_rAX && mop2t <= OP_rDI) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = resolve_gpr64(u, mop2t);\n\t\t}\n\t\telse if (mop2t == OP_O) {\n\t\t\tdecode_o(u, mop2s, &(iop[1]));\t\n\t\t\tiop[0].size = (uint8_t)resolve_oprsize(u, mop2s);\n\t\t}\n\t\tbreak;\n\n\t/* AL[r8b]..BH[r15b], I */\n\tcase OP_ALr8b : case OP_CLr9b : case OP_DLr10b : case OP_BLr11b :\n\tcase OP_AHr12b: case OP_CHr13b: case OP_DHr14b : case OP_BHr15b :\n\t{\n\t\tud_type_t gpr = (mop1t - OP_ALr8b) + UD_R_AL + \n\t\t\t\t\t\t(P_REX_B(u->pfx_rex) << 3);\n\t\tif (UD_R_AH <= gpr && u->pfx_rex)\n\t\t\tgpr = gpr + 4;\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = gpr;\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\tbreak;\n\t}\n\n\t/* eAX..eDX, DX/I */\n\tcase OP_eAX : case OP_eCX : case OP_eDX : case OP_eBX :\n\tcase OP_eSP : case OP_eBP : case OP_eSI : case OP_eDI :\n\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = resolve_gpr32(u, mop1t);\n\t\tif (mop2t == OP_DX) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = UD_R_DX;\n\t\t\tiop[1].size = 16;\n\t\t} else if (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\tbreak;\n\n\t/* ES..GS */\n\tcase OP_ES : case OP_CS : case OP_DS :\n\tcase OP_SS : case OP_FS : case OP_GS :\n\n\t\t/* in 64bits mode, only fs and gs are allowed */\n\t\tif (u->dis_mode == 64)\n\t\t\tif (mop1t != OP_FS && mop1t != OP_GS)\n\t\t\t\tu->error= 1;\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = (mop1t - OP_ES) + UD_R_ES;\n\t\tiop[0].size = 16;\n\n\t\tbreak;\n\n\t/* J */\n\tcase OP_J :\n\t\tdecode_imm(u, mop1s, &(iop[0]));\t\t\n\t\tiop[0].type = UD_OP_JIMM;\n\t\tbreak ;\n\n\t/* PR, I */\n\tcase OP_PR:\n\t\tif (MODRM_MOD(inp_peek(u)) != 3)\n\t\t\tu->error = 1;\n\t\tdecode_modrm(u, &(iop[0]), mop1s, T_MMX, NULL, 0, T_NONE);\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\tbreak; \n\n\t/* VR, I */\n\tcase OP_VR:\n\t\tif (MODRM_MOD(inp_peek(u)) != 3)\n\t\t\tu->error = 1;\n\t\tdecode_modrm(u, &(iop[0]), mop1s, T_XMM, NULL, 0, T_NONE);\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\tbreak; \n\n\t/* P, Q[,I]/W/E[,I],VR */\n\tcase OP_P :\n\t\tif (mop2t == OP_Q) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), (unsigned char)mop1s, T_MMX);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t} else if (mop2t == OP_W) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), (unsigned char)mop1s, T_MMX);\n\t\t} else if (mop2t == OP_VR) {\n\t\t\tif (MODRM_MOD(inp_peek(u)) != 3)\n\t\t\t\tu->error = 1;\n\t\t\tdecode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), (unsigned char)mop1s, T_MMX);\n\t\t} else if (mop2t == OP_E) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_MMX);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t}\n\t\tbreak;\n\n\t/* R, C/D */\n\tcase OP_R :\n\t\tif (mop2t == OP_C)\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_CRG);\n\t\telse if (mop2t == OP_D)\n\t\t  decode_modrm(u, &(iop[0]), mop1s, T_GPR, &(iop[1]), (unsigned char)mop2s, T_DBG);\n\t\tbreak;\n\n\t/* C, R */\n\tcase OP_C :\n\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_CRG);\n\t\tbreak;\n\n\t/* D, R */\n\tcase OP_D :\n\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_DBG);\n\t\tbreak;\n\n\t/* Q, P */\n\tcase OP_Q :\n\t  decode_modrm(u, &(iop[0]), mop1s, T_MMX, &(iop[1]), (unsigned char)mop2s, T_MMX);\n\t\tbreak;\n\n\t/* S, E */\n\tcase OP_S :\n\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_SEG);\n\t\tbreak;\n\n\t/* W, V */\n\tcase OP_W :\n\t  decode_modrm(u, &(iop[0]), mop1s, T_XMM, &(iop[1]), (unsigned char)mop2s, T_XMM);\n\t\tbreak;\n\n\t/* V, W[,I]/Q/M/E */\n\tcase OP_V :\n\t\tif (mop2t == OP_W) {\n\t\t\t/* special cases for movlps and movhps */\n\t\t\tif (MODRM_MOD(inp_peek(u)) == 3) {\n\t\t\t\tif (u->mnemonic == UD_Imovlps)\n\t\t\t\t\tu->mnemonic = UD_Imovhlps;\n\t\t\t\telse\n\t\t\t\tif (u->mnemonic == UD_Imovhps)\n\t\t\t\t\tu->mnemonic = UD_Imovlhps;\n\t\t\t}\n\t\t\tdecode_modrm(u, &(iop[1]), mop2s, T_XMM, &(iop[0]), (unsigned char)mop1s, T_XMM);\n\t\t\tif (mop3t == OP_I)\n\t\t\t\tdecode_imm(u, mop3s, &(iop[2]));\n\t\t} else if (mop2t == OP_Q)\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), (unsigned char)mop1s, T_XMM);\n\t\telse if (mop2t == OP_M) {\n\t\t\tif (MODRM_MOD(inp_peek(u)) == 3)\n\t\t\t\tu->error= 1;\n\t\t\tdecode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_XMM);\n\t\t} else if (mop2t == OP_E) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_GPR, &(iop[0]), (unsigned char)mop1s, T_XMM);\n\t\t} else if (mop2t == OP_PR) {\n\t\t  decode_modrm(u, &(iop[1]), mop2s, T_MMX, &(iop[0]), (unsigned char)mop1s, T_XMM);\n\t\t}\n\t\tbreak;\n\n\t/* DX, eAX/AL */\n\tcase OP_DX :\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = UD_R_DX;\n\t\tiop[0].size = 16;\n\n\t\tif (mop2t == OP_eAX) {\n\t\t\tiop[1].type = UD_OP_REG;\t\n\t\t\tiop[1].base = resolve_gpr32(u, mop2t);\n\t\t} else if (mop2t == OP_AL) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = UD_R_AL;\n\t\t\tiop[1].size = 8;\n\t\t}\n\n\t\tbreak;\n\n\t/* I, I/AL/eAX */\n\tcase OP_I :\n\t\tdecode_imm(u, mop1s, &(iop[0]));\n\t\tif (mop2t == OP_I)\n\t\t\tdecode_imm(u, mop2s, &(iop[1]));\n\t\telse if (mop2t == OP_AL) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = UD_R_AL;\n\t\t\tiop[1].size = 16;\n\t\t} else if (mop2t == OP_eAX) {\n\t\t\tiop[1].type = UD_OP_REG;\t\n\t\t\tiop[1].base = resolve_gpr32(u, mop2t);\n\t\t}\n\t\tbreak;\n\n\t/* O, AL/eAX */\n\tcase OP_O :\n\t\tdecode_o(u, mop1s, &(iop[0]));\n\t\tiop[1].type = UD_OP_REG;\n\t\tiop[1].size = (uint8_t)resolve_oprsize(u, mop1s);\n\t\tif (mop2t == OP_AL)\n\t\t\tiop[1].base = UD_R_AL;\n\t\telse if (mop2t == OP_eAX)\n\t\t\tiop[1].base = resolve_gpr32(u, mop2t);\n\t\telse if (mop2t == OP_rAX)\n\t\t\tiop[1].base = resolve_gpr64(u, mop2t);\t\t\n\t\tbreak;\n\n\t/* 3 */\n\tcase OP_I3 :\n\t\tiop[0].type = UD_OP_CONST;\n\t\tiop[0].lval.sbyte = 3;\n\t\tbreak;\n\n\t/* ST(n), ST(n) */\n\tcase OP_ST0 : case OP_ST1 : case OP_ST2 : case OP_ST3 :\n\tcase OP_ST4 : case OP_ST5 : case OP_ST6 : case OP_ST7 :\n\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = (mop1t-OP_ST0) + UD_R_ST0;\n\t\tiop[0].size = 0;\n\n\t\tif (mop2t >= OP_ST0 && mop2t <= OP_ST7) {\n\t\t\tiop[1].type = UD_OP_REG;\n\t\t\tiop[1].base = (mop2t-OP_ST0) + UD_R_ST0;\n\t\t\tiop[1].size = 0;\n\t\t}\n\t\tbreak;\n\n\t/* AX */\n\tcase OP_AX:\n\t\tiop[0].type = UD_OP_REG;\n\t\tiop[0].base = UD_R_AX;\n\t\tiop[0].size = 16;\n\t\tbreak;\n\n\t/* none */\n\tdefault :\n\t\tiop[0].type = iop[1].type = iop[2].type = UD_NONE;\n  }\n\n  return 0;\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* 3D Now instructions with suffix */\n", "func_signal": "extern enum ud_mnemonic_code ud_map_get_3dnow(uint8_t suffix)", "code": "{\n  switch ( suffix ) {\n\tcase 0x0C: return UD_Ipi2fw;\n\tcase 0x0D: return UD_Ipi2fd;\n\tcase 0x1C: return UD_Ipf2iw;\n\tcase 0x1D: return UD_Ipf2id;\n\tcase 0x8A: return UD_Ipfnacc;\n\tcase 0x8E: return UD_Ipfpnacc;\n\tcase 0x90: return UD_Ipfcmpge;\n\tcase 0x94: return UD_Ipfmin;\n\tcase 0x96: return UD_Ipfrcp;\n\tcase 0x97: return UD_Ipfrsqrt;\n\tcase 0x9A: return UD_Ipfsub;\n\tcase 0x9E: return UD_Ipfadd;\n\tcase 0xA0: return UD_Ipfcmpgt;\n\tcase 0xA4: return UD_Ipfmax;\n\tcase 0xA6: return UD_Ipfrcpit1;\n\tcase 0xA7: return UD_Ipfrsqit1;\n\tcase 0xAA: return UD_Ipfsubr;\n\tcase 0xAE: return UD_Ipfacc;\n\tcase 0xB0: return UD_Ipfcmpeq;\n\tcase 0xB4: return UD_Ipfmul;\n\tcase 0xB6: return UD_Ipfrcpit2;\n\tcase 0xB7: return UD_Ipmulhrw;\n\tcase 0xBB: return UD_Ipswapd;\n\tcase 0xBF: return UD_Ipavgusb;\n  }\n  return ( 0 );\n}", "path": "sys\\udis86\\src\\opcmap.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_reg() - Resolves the register type \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_reg(struct ud* u, unsigned int type, unsigned char i)", "code": "{\n  switch (type) {\n\tcase T_MMX :\treturn UD_R_MM0  + (i & 7);\n\tcase T_XMM :\treturn UD_R_XMM0 + i;\n\tcase T_CRG :\treturn UD_R_CR0  + i;\n\tcase T_DBG :\treturn UD_R_DR0  + i;\n\tcase T_SEG :\treturn UD_R_ES   + (i & 7);\n\tcase T_NONE:\n\tdefault:\treturn UD_NONE;\n  }\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* =============================================================================\n * ud_set_mode() - Set Disassemly Mode.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_mode(struct ud* u, uint8_t m)", "code": "{\n  switch(m) {\n\tcase 16:\n\tcase 32:\n\tcase 64: u->dis_mode = m ; return;\n\tdefault: u->dis_mode = 16; return;\n  }\n}", "path": "sys\\udis86\\src\\udis86.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_oprsize()- Resolves the size of operand depending on the current\n * disassembly mode, effective operand sizes, etc.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static unsigned int \nresolve_oprsize(register struct ud* u, unsigned int s)", "code": "{\n  switch (s) {\n\tcase SZ_V:\treturn (u->opr_mode);\n\tcase SZ_Z:\treturn (u->opr_mode == 16) ? 16 : 32;\n\tcase SZ_P:\treturn (u->opr_mode == 16) ? SZ_WP : SZ_DP;\n\tcase SZ_MDQ:\treturn (u->opr_mode == 16) ? 32 : u->opr_mode;\n\tcase SZ_RDQ:\treturn (u->dis_mode == 64) ? 64 : 32;\n\tdefault:\treturn s;\n  }\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_imm() - Decodes Immediate values.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_imm(struct ud* u, unsigned int s, struct ud_operand *op)", "code": "{\n  op->size = (uint8_t)resolve_oprsize(u, s);\n  op->type = UD_OP_IMM;\n\n  switch (op->size) {\n\tcase  8: op->lval.sbyte = inp_uint8(u);\t  break;\n\tcase 16: op->lval.uword = inp_uint16(u);  break;\n\tcase 32: op->lval.udword = inp_uint32(u); break;\n\tcase 64: op->lval.uqword = inp_uint64(u); break;\n\tdefault: return;\n  }\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * search_2byte_insn() - Searches for 2-byte instructions.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "int search_2byte_insn( struct ud* u )", "code": "{\n  uint32_t gindex;\n  uint8_t curr ;\n  uint8_t peek;\n\n  /* return if in error state */\n  if ( u->error ) { return 1; }\n  curr = inp_curr( u ); \n\n  /* 2byte opcodes can be modified by 0x66, F3, and F2 */\n  if ( u->pfx_insn == 0x66 ) {\n\tu->mapen = &itab_2byte_prefix66[ curr ];\n\tif ( u->mapen != NULL && u->mapen->mnemonic != UD_Ina ) {\n\t\tu->pfx_opr = 0;\n\t}\n  } else if ( u->pfx_insn == 0xF2 ) {\n\tu->mapen = &itab_2byte_prefixF2[ curr ];\n\tif ( u->mapen != NULL && u->mapen->mnemonic != UD_Ina ) {\n\t\tu->pfx_repne = 0;\n\t}\n  } else if ( u->pfx_insn == 0xF3 ) {\n\tu->mapen = &itab_2byte_prefixF3[ curr ];\n\tif (u->mapen != NULL && u->mapen->mnemonic != UD_Ina) {\n\t\tu->pfx_rep = 0;\n\t}\n  }\n\n  /* If no such prefix, or if those prefixes were not applicable to the\n   * opcode, just get a 2byte opcode instruction from the 2byte table.\n   */\n  if ( u->mapen == NULL || u->mapen->mnemonic == UD_Ina ) {\n\tu->mapen = &itab_2byte[ curr ];\n  }\n\n  /* 3D Now */\n  if ( u->mapen->mnemonic == UD_I3dnow ) {\n\tu->mapen = &itab_3DNow;\n  }\n\n  /* Unless the table entry points to a group entry, we are done. */\n  if ( u->mapen->mnemonic != UD_Igrp ) {\n\treturn 0;\n  }\n\n  /* If instruction is in a Group, get the group index. */\n  gindex = u->mapen->prefix + ( ( u->vendor == UD_VENDOR_INTEL ) ? \n\t\t\t\t\tITAB_GROUPS_START_INTEL : 0 );\n\n  /* Peek ahead for opcode extension. */\n  peek = inp_peek( u ); if ( u->error ) return -1;\n  \n  /* Check for groups with prefixes */\n  if ( u->pfx_insn == 0x66 && itab_groups[ gindex ].me_pfx_66 ) {\n\tu->mapen = &itab_groups[ gindex ].me_pfx_66[ MODRM_REG( peek ) ];\n\tif ( u->mapen != NULL && u->mapen->mnemonic != UD_Ina ) {\n\t\tu->pfx_opr = 0;\n\t\treturn 0;\n\t}\n  } else if ( u->pfx_insn == 0xF2 && itab_groups[ gindex ].me_pfx_f2 ) {\n\tu->mapen = &itab_groups[ gindex ].me_pfx_f2[ MODRM_REG( peek ) ];\n\tif ( u->mapen != NULL && u->mapen->mnemonic != UD_Ina ) {\n\t\tu->pfx_repne = 0;\n\t\treturn 0;\n\t}\n  } else if ( u->pfx_insn == 0xF3 && itab_groups[ gindex ].me_pfx_f3 ) {\n\tu->mapen = &itab_groups[ gindex ].me_pfx_f3[ MODRM_REG( peek ) ];\n\tif ( u->mapen != NULL && u->mapen->mnemonic != UD_Ina ) {\n\t\tu->pfx_rep = 0;\n\t\treturn 0;\n\t}\n  }\n\n  /* Non-prefixed group instructions */\n  if ( !u->pfx_insn || u->mapen->mnemonic == UD_Igrp ) {\n\tu->mapen = &itab_groups[ gindex ].me_pfx_none[ MODRM_REG( peek ) ];\n  }\n\n  /* 0F01 - opcode extensions */\n  if ( curr == 0x01 ) {\n\tuint8_t reg = MODRM_REG( peek );\n\tuint8_t mod = MODRM_MOD( peek );\n\tuint8_t rm  = MODRM_RM( peek );\n\n\tif ( reg == 0 && mod == 3 && u->vendor == UD_VENDOR_INTEL ) {\n\t\tu->mapen = &itab_g7_op0F01_Reg0_intel[ rm ];\n\t\tinp_next( u );\n\t} else if ( reg == 1 && mod == 3 && u->vendor == UD_VENDOR_INTEL ) {\n\t\tu->mapen = &itab_g7_op0F01_Reg1_intel[ rm ];\n\t\tinp_next(u);\n\t} else if ( reg == 3 && mod == 3 && u->vendor != UD_VENDOR_INTEL ) {\n\t\t\tu->mapen = &itab_g7_op0F01_Reg3[ rm ];\n\t\t\tinp_next(u);\n\t} else if ( reg == 7 && mod == 3 && u->vendor == UD_VENDOR_INTEL ) {\n\t\tu->mapen = &itab_g7_op0F01_Reg7_intel[ rm ];\n\t\tinp_next(u);\n\t} else if (reg == 7 && mod == 3) {\n\t\t\tu->mapen = &itab_g7_op0F01_Reg7[ rm ];\n\t\t\tinp_next(u);\n\t} else {\n\t\tu->mapen = &itab_g7_op0F01[ reg ];\n\t}\n  } /* 0FAE - opcode extensions */\n  else if ( curr == 0xAE ) {\n\tuint8_t reg = MODRM_REG( peek );\n\tuint8_t mod = MODRM_MOD( peek );\n\n\tif (reg == 5 && mod == 3) {\n\t\tu->mapen = &itab_gF_op0FAE_Reg5;\n\t\tinp_next(u);\n\t} else if (reg == 6 && mod == 3) {\n\t\tu->mapen = &itab_gF_op0FAE_Reg6;\n\t\tinp_next(u);\n\t} else if (reg == 7 && mod == 3) {\n\t\tu->mapen = &itab_gF_op0FAE_Reg7;\n\t\tinp_next(u);\n\t} else { \n\t\tu->mapen = &itab_gF_op0FAE[ reg ];\n\t}\n  }\n  if ( u->error ) return -1; else return 0;\n}", "path": "sys\\udis86\\src\\opcmap.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* =============================================================================\n * ud_set_vendor() - Set vendor.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_set_vendor(struct ud* u, unsigned v)", "code": "{\n  switch(v) {\n\tcase UD_VENDOR_INTEL:\n\t  u->vendor = (uint8_t)v;\n\t\tbreak;\n\tdefault:\n\t\tu->vendor = UD_VENDOR_AMD;\n  }\n}", "path": "sys\\udis86\\src\\udis86.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_mnemonic()- Resolves the correct mnemonic that depends on the \n * current effective operand or address mode.\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_mnemonic_code resolve_mnemonic_by_mode( struct ud* u )", "code": "{\n  /* operand size == 32 */\n  if ( u->opr_mode == 32 ) {\n\tswitch ( u->mnemonic ) {\n\t\tcase UD_Icbw: \treturn UD_Icwde;\n\t\tcase UD_Icwd: \treturn UD_Icdq;\n\t\tcase UD_Ilodsw: return UD_Ilodsd;\n\t\tcase UD_Imovsw: return UD_Imovsd;\n\t\tcase UD_Icmpsw: return UD_Icmpsd;\n\t\tcase UD_Iinsw: \treturn UD_Iinsd;\n\t\tcase UD_Ioutsw: return UD_Ioutsd;\n\t\tcase UD_Ipushfw:return UD_Ipushfd;\n\t\tcase UD_Ipopfw: return UD_Ipopfd;\n\t\tcase UD_Istosw: return UD_Istosd;\n\t\tcase UD_Iscasw: return UD_Iscasd;\n\t\tcase UD_Iiretw: return UD_Iiretd;\n\t\tcase UD_Ipusha:\treturn UD_Ipushad;\n\t\tcase UD_Ipopa:\treturn UD_Ipopad;\n\t\tdefault: \tbreak;\n\t}\n  } /* operand size == 64*/\n  else if ( u->opr_mode == 64 ) {\n\tswitch( u->mnemonic ) {\n\t\tcase UD_Icbw:\treturn UD_Icdqe;\n\t\tcase UD_Icwd:\treturn UD_Icqo;\n\t\tcase UD_Ilodsw: return UD_Ilodsq;\n\t\tcase UD_Imovsw: return UD_Imovsq;\n\t\tcase UD_Icmpsw: return UD_Icmpsq;\n\t\tcase UD_Iinsw:\treturn UD_Iinsd;\n\t\tcase UD_Ioutsw:\treturn UD_Ioutsd;\n\t\tcase UD_Icmpxchg8b: return UD_Icmpxchg16b;\t\t\n\t\tcase UD_Istosw:\treturn UD_Istosq;\n\t\tcase UD_Iscasw:\treturn UD_Iscasq;\n\t\tcase UD_Iiretw:\treturn UD_Iiretq;\n\t\tcase UD_Ipushfw:return UD_Ipushfq;\n\t\tcase UD_Ipopfw:\treturn UD_Ipopfq;\n\t\tdefault: \tbreak; \n\t} \n  }\n\n  /* address == 32 */\n  if ( u->adr_mode == 32 ) {\n\tswitch( u->mnemonic ) {\n\t\tcase UD_Ijcxz:\treturn UD_Ijecxz;\n\t\tdefault:\tbreak; \n\t} \n  } /* address == 64 */\n  else if ( u->adr_mode == 64 ) {\n\tswitch( u->mnemonic ) {\n\t\tcase UD_Ijcxz:\treturn UD_Ijrcxz;\n\t\tdefault:\tbreak; \n\t} \n  }\n\n  return u->mnemonic;\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* main\n */\n", "func_signal": "int main(int ac, char** av)", "code": "{\n  const char* ifName = \"\\\\\\\\.\\\\{61FA40D4-427F-439E-8414-A2AB4C27A5C3}\";\n  struct ndisDevice ndisDevice;\n  UCHAR macAddress[6];\n\n  if (ac != 2)\n    {\n      printf(\"usage: %s <deviceName>\\n\", *av);\n/*       return -1; */\n    }\n  else\n    {\n      ifName = av[1];\n    }\n\n  if (ndisOpenDevice(&ndisDevice, ifName) == FALSE)\n    return -1;\n\n  if (ndisGetMacAddress(&ndisDevice, macAddress) == FALSE)\n    goto onError;\n\n#define MAC_FORMAT_STRING \"%02x:%02x:%02x:%02x:%02x:%02x\"\n#define EXPAND_MAC(M) (M)[0], (M)[1], (M)[2], (M)[3], (M)[4], (M)[5]\n  printf(MAC_FORMAT_STRING \"\\n\", EXPAND_MAC(macAddress));\n\n#if 0\n\n  ++macAddress[5];\n\n  if (ndisSetMacAddress(&ndisDevice, macAddress) == FALSE)\n    goto onError;\n\n#endif\n\n onError:\n\n  ndisCloseDevice(&ndisDevice);\n\n  return 0;\n}", "path": "ndis\\src\\main.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* exported\n */\n", "func_signal": "NTSTATUS mmioInitialize(void)", "code": "{\n  KeInitializeSpinLock(&mmioRangeLock);\n\n  return STATUS_SUCCESS;\n}", "path": "sys\\mmio.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* =============================================================================\n * ud_init() - Initializes ud_t object.\n * =============================================================================\n */\n", "func_signal": "extern void \nud_init(struct ud* u)", "code": "{\n  memset((void*)u, 0, sizeof(struct ud));\n  ud_set_mode(u, 16);\n  u->mnemonic = UD_Iinvalid;\n  ud_set_pc(u, 0);\n#ifndef __UD_STANDALONE__\n  ud_set_input_file(u, stdin);\n#endif /* __UD_STANDALONE__ */\n}", "path": "sys\\udis86\\src\\udis86.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* =============================================================================\n * ud_lookup_mnemonic() - Looks-up the mnemonic code.\n * =============================================================================\n */\n", "func_signal": "const char* ud_lookup_mnemonic(ud_mnemonic_code_t c)", "code": "{\n  if (c < UD_I3vil) \n\treturn ud_mnemonics[c];\n  return NULL;\n}", "path": "sys\\udis86\\src\\opcmap.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* range parsing\n */\n", "func_signal": "static int strToUlong(const char* s, PULONG n)", "code": "{\n  char* p;\n\n  errno = 0;\n\n  *n = strtoul(s, &p, 16);\n\n  if (errno == ERANGE)\n    return -1;\n\n  if (p != (s + strlen(s)))\n    return -1;\n\n  return 0;\n}", "path": "exe\\src\\main.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* helpers\n */\n", "func_signal": "static unsigned int regIdToDiotReg(enum ud_type RegId)", "code": "{\n  /* todo: redundant with the code below */\n\n  unsigned int diotReg = DIOT_REG_BAD;\n\n  if (RegId >= UD_R_AL && RegId <= UD_R_BL)\n    diotReg = 7 - (RegId - UD_R_AL);\n  else if (RegId >= UD_R_AH && RegId <= UD_R_BH)\n    diotReg = 7 - (RegId - UD_R_AH);\n  else if (RegId >= UD_R_SPL && RegId <= UD_R_DIL)\n    diotReg = 7 - (4 + RegId - UD_R_SPL);\n  else if (RegId >= UD_R_AX && RegId <= UD_R_DI)\n    diotReg = 7 - (RegId - UD_R_AX);\n  else if (RegId >= UD_R_EAX && RegId <= UD_R_EDI)\n    diotReg = 7 - (RegId - UD_R_EAX);\n\n  return diotReg;\n}", "path": "sys\\disasm.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * decode_a()- Decodes operands of the type seg:offset\n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static void \ndecode_a(struct ud* u, struct ud_operand *op)", "code": "{\n  if (u->opr_mode == 16) {\t\n\t/* seg16:off16 */\n\top->type = UD_OP_PTR;\n\top->size = 32;\n\top->lval.ptr.off = inp_uint16(u);\n\top->lval.ptr.seg = inp_uint16(u);\n  } else {\n\t/* seg16:off32 */\n\top->type = UD_OP_PTR;\n\top->size = 48;\n\top->lval.ptr.off = inp_uint32(u);\n\top->lval.ptr.seg = inp_uint16(u);\n  }\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/* -----------------------------------------------------------------------------\n * resolve_gpr32 () - 32bit General Purpose Register-Selection. \n * -----------------------------------------------------------------------------\n */\n", "func_signal": "static enum ud_type \nresolve_gpr32(struct ud* u, enum map_operand_type gpr_op)", "code": "{\n  gpr_op = gpr_op - OP_eAX;\n\n  if (u->opr_mode == 16) \n\treturn gpr_op + UD_R_AX;\n\n  return gpr_op +  UD_R_EAX;\n}", "path": "sys\\udis86\\src\\decode.c", "repo_name": "texane/diot", "stars": 5, "license": "None", "language": "c", "size": 596}
{"docstring": "/*\n * This is called to unpin an inode.  The caller must have the inode locked\n * in at least shared mode so that the buffer cannot be subsequently pinned\n * once someone is waiting for it to be unpinned.\n */\n", "func_signal": "static void\nxfs_iunpin_nowait(\n\tstruct xfs_inode\t*ip)", "code": "{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\n\ttrace_xfs_inode_unpin_nowait(ip, _RET_IP_);\n\n\t/* Give the log a push to start the unpinning I/O */\n\txfs_log_force_lsn(ip->i_mount, ip->i_itemp->ili_last_lsn, 0);\n\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Make sure that the extents in the given memory buffer\n * are valid.\n */\n", "func_signal": "STATIC void\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)", "code": "{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * xfs_iextents_copy()\n *\n * This is called to copy the REAL extents (as opposed to the delayed\n * allocation extents) from the inode into the given buffer.  It\n * returns the number of bytes copied into the buffer.\n *\n * If there are no delayed allocation extents, then we can just\n * memcpy() the extents into the buffer.  Otherwise, we need to\n * examine each extent in turn and skip those which are delayed.\n */\n", "func_signal": "int\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)", "code": "{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned(cpu_to_be64(ep->l0), &dp->l0);\n\t\tput_unaligned(cpu_to_be64(ep->l1), &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Calculate the last possible buffered byte in a file.  This must\n * include data that was buffered beyond the EOF by the write code.\n * This also needs to deal with overflowing the xfs_fsize_t type\n * which can happen for sizes near the limit.\n *\n * We also need to take into account any blocks beyond the EOF.  It\n * may be the case that they were buffered by a write which failed.\n * In that case the pages will still be in memory, but the inode size\n * will never have been updated.\n */\n", "func_signal": "STATIC xfs_fsize_t\nxfs_file_last_byte(\n\txfs_inode_t\t*ip)", "code": "{\n\txfs_mount_t\t*mp;\n\txfs_fsize_t\tlast_byte;\n\txfs_fileoff_t\tlast_block;\n\txfs_fileoff_t\tsize_last_block;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED));\n\n\tmp = ip->i_mount;\n\t/*\n\t * Only check for blocks beyond the EOF if the extents have\n\t * been read in.  This eliminates the need for the inode lock,\n\t * and it also saves us from looking when it really isn't\n\t * necessary.\n\t */\n\tif (ip->i_df.if_flags & XFS_IFEXTENTS) {\n\t\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\t\terror = xfs_bmap_last_offset(NULL, ip, &last_block,\n\t\t\tXFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\t\tif (error) {\n\t\t\tlast_block = 0;\n\t\t}\n\t} else {\n\t\tlast_block = 0;\n\t}\n\tsize_last_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)ip->i_size);\n\tlast_block = XFS_FILEOFF_MAX(last_block, size_last_block);\n\n\tlast_byte = XFS_FSB_TO_B(mp, last_block);\n\tif (last_byte < 0) {\n\t\treturn XFS_MAXIOFFSET(mp);\n\t}\n\tlast_byte += (1 << mp->m_writeio_log);\n\tif (last_byte < 0) {\n\t\treturn XFS_MAXIOFFSET(mp);\n\t}\n\treturn last_byte;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/* LCD Set Mode */\n", "func_signal": "void viafb_lcd_set_mode(struct crt_mode_table *mode_crt_table,\n\t\t  struct lvds_setting_information *plvds_setting_info,\n\t\t  struct lvds_chip_information *plvds_chip_info)", "code": "{\n\tint set_iga = plvds_setting_info->iga_path;\n\tint mode_bpp = plvds_setting_info->bpp;\n\tint set_hres = plvds_setting_info->h_active;\n\tint set_vres = plvds_setting_info->v_active;\n\tint panel_hres = plvds_setting_info->lcd_panel_hres;\n\tint panel_vres = plvds_setting_info->lcd_panel_vres;\n\tu32 pll_D_N;\n\tstruct display_timing mode_crt_reg, panel_crt_reg;\n\tstruct crt_mode_table *panel_crt_table = NULL;\n\tstruct VideoModeTable *vmode_tbl = viafb_get_mode(panel_hres,\n\t\tpanel_vres);\n\n\tDEBUG_MSG(KERN_INFO \"viafb_lcd_set_mode!!\\n\");\n\t/* Get mode table */\n\tmode_crt_reg = mode_crt_table->crtc;\n\t/* Get panel table Pointer */\n\tpanel_crt_table = vmode_tbl->crtc;\n\tpanel_crt_reg = panel_crt_table->crtc;\n\tDEBUG_MSG(KERN_INFO \"bellow viafb_lcd_set_mode!!\\n\");\n\tif (VT1636_LVDS == plvds_chip_info->lvds_chip_name)\n\t\tviafb_init_lvds_vt1636(plvds_setting_info, plvds_chip_info);\n\tplvds_setting_info->vclk = panel_crt_table->clk;\n\tif (set_iga == IGA1) {\n\t\t/* IGA1 doesn't have LCD scaling, so set it as centering. */\n\t\tviafb_load_crtc_timing(lcd_centering_timging\n\t\t\t\t (mode_crt_reg, panel_crt_reg), IGA1);\n\t} else {\n\t\t/* Expansion */\n\t\tif ((plvds_setting_info->display_method ==\n\t\t     LCD_EXPANDSION) & ((set_hres != panel_hres)\n\t\t\t\t\t|| (set_vres != panel_vres))) {\n\t\t\t/* expansion timing IGA2 loaded panel set timing*/\n\t\t\tviafb_load_crtc_timing(panel_crt_reg, IGA2);\n\t\t\tDEBUG_MSG(KERN_INFO \"viafb_load_crtc_timing!!\\n\");\n\t\t\tload_lcd_scaling(set_hres, set_vres, panel_hres,\n\t\t\t\t\t panel_vres);\n\t\t\tDEBUG_MSG(KERN_INFO \"load_lcd_scaling!!\\n\");\n\t\t} else {\t/* Centering */\n\t\t\t/* centering timing IGA2 always loaded panel\n\t\t\t   and mode releative timing */\n\t\t\tviafb_load_crtc_timing(lcd_centering_timging\n\t\t\t\t\t (mode_crt_reg, panel_crt_reg), IGA2);\n\t\t\tviafb_write_reg_mask(CR79, VIACR, 0x00,\n\t\t\t\tBIT0 + BIT1 + BIT2);\n\t\t\t/* LCD scaling disabled */\n\t\t}\n\t}\n\n\t/* Fetch count for IGA2 only */\n\tviafb_load_fetch_count_reg(set_hres, mode_bpp / 8, set_iga);\n\n\tif ((viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266)\n\t\t&& (viaparinfo->chip_info->gfx_chip_name != UNICHROME_K400))\n\t\tviafb_load_FIFO_reg(set_iga, set_hres, set_vres);\n\n\tfill_lcd_format();\n\n\tpll_D_N = viafb_get_clk_value(panel_crt_table[0].clk);\n\tDEBUG_MSG(KERN_INFO \"PLL=0x%x\", pll_D_N);\n\tviafb_set_vclock(pll_D_N, set_iga);\n\n\tviafb_set_output_path(DEVICE_LCD, set_iga,\n\t\tplvds_chip_info->output_interface);\n\tlcd_patch_skew(plvds_setting_info, plvds_chip_info);\n\n\t/* If K8M800, enable LCD Prefetch Mode. */\n\tif ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_K800)\n\t    || (UNICHROME_K8M890 == viaparinfo->chip_info->gfx_chip_name))\n\t\tviafb_write_reg_mask(CR6A, VIACR, 0x01, BIT0);\n\n\t/* Patch for non 32bit alignment mode */\n\tvia_pitch_alignment_patch_lcd(plvds_setting_info, plvds_chip_info);\n}", "path": "drivers\\video\\via\\lcd.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Reallocate the space for if_broot based on the number of records\n * being added or deleted as indicated in rec_diff.  Move the records\n * and pointers in if_broot to fit the new size.  When shrinking this\n * will eliminate holes between the records and pointers created by\n * the caller.  When growing this will create holes to be filled in\n * by the caller.\n *\n * The caller must not request to add more records than would fit in\n * the on-disk inode root.  If the if_broot is currently NULL, then\n * if we adding records one will be allocated.  The caller must also\n * not request that the number of records go below zero, although\n * it can go to zero.\n *\n * ip -- the inode whose if_broot area is changing\n * ext_diff -- the change in the number of records, positive or negative,\n *\t requested for the if_broot array.\n */\n", "func_signal": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)", "code": "{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = (size_t)XFS_BMAP_BROOT_SPACE_CALC(rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = (size_t)XFS_BMAP_BROOT_SPACE_CALC(new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\t(size_t)XFS_BMAP_BROOT_SPACE_CALC(cur_max), /* old size */\n\t\t\t\tKM_SLEEP);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(ifp->if_broot_bytes <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork) + XFS_BROOT_SIZE_ADJ);\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_dfsbno_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = (size_t)XFS_BMAP_BROOT_SPACE_CALC(new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot, XFS_BTREE_LBLOCK_LEN);\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_dfsbno_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tASSERT(ifp->if_broot_bytes <=\n\t\tXFS_IFORK_SIZE(ip, whichfork) + XFS_BROOT_SIZE_ADJ);\n\treturn;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * This is called when the inode's link count goes to 0.\n * We place the on-disk inode on a list in the AGI.  It\n * will be pulled from this list when the inode is freed.\n */\n", "func_signal": "int\nxfs_iunlink(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)", "code": "{\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agino_t\tagino;\n\tshort\t\tbucket_index;\n\tint\t\toffset;\n\tint\t\terror;\n\n\tASSERT(ip->i_d.di_nlink == 0);\n\tASSERT(ip->i_d.di_mode != 0);\n\tASSERT(ip->i_transp == tp);\n\n\tmp = tp->t_mountp;\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, XFS_INO_TO_AGNO(mp, ip->i_ino), &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\tASSERT(be32_to_cpu(agi->agi_unlinked[bucket_index]) != agino);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) != NULLAGINO) {\n\t\t/*\n\t\t * There is already another inode in the bucket we need\n\t\t * to add ourselves to.  Add us at the front of the list.\n\t\t * Here we put the head pointer into our next pointer,\n\t\t * and then we fall through to point the head at us.\n\t\t */\n\t\terror = xfs_itobp(mp, tp, ip, &dip, &ibp, XBF_LOCK);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(be32_to_cpu(dip->di_next_unlinked) == NULLAGINO);\n\t\t/* both on-disk, don't endian flip twice */\n\t\tdip->di_next_unlinked = agi->agi_unlinked[bucket_index];\n\t\toffset = ip->i_imap.im_boffset +\n\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\t\txfs_trans_inode_buf(tp, ibp);\n\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, ibp);\n\t}\n\n\t/*\n\t * Point the bucket head pointer at the inode being inserted.\n\t */\n\tASSERT(agino != 0);\n\tagi->agi_unlinked[bucket_index] = cpu_to_be32(agino);\n\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t(sizeof(xfs_agino_t) * bucket_index);\n\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Move inode type and inode format specific information from the\n * on-disk inode to the in-core inode.  For fifos, devs, and sockets\n * this means set if_rdev to the proper value.  For files, directories,\n * and symlinks this means to bring in the in-line data or extent\n * pointers.  For a file in B-tree format, only the root is immediately\n * brought in-core.  The rest will be in-lined in if_extents when it\n * is first referenced (see xfs_iread_extents()).\n */\n", "func_signal": "STATIC int\nxfs_iformat(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)", "code": "{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror;\n\txfs_fsize_t             di_size;\n\tip->i_df.if_ext_max =\n\t\tXFS_IFORK_DSIZE(ip) / (uint)sizeof(xfs_bmbt_rec_t);\n\terror = 0;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely((be16_to_cpu(dip->di_mode) & S_IFMT) == S_IFREG)) {\n\t\t\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\t\t\"corrupt inode %Lu \"\n\t\t\t\t\t\"(local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\t\t\"corrupt inode %Lu \"\n\t\t\t\t\t\"(bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);\n\tip->i_afp->if_ext_max =\n\t\tXFS_IFORK_ASIZE(ip) / (uint)sizeof(xfs_bmbt_rec_t);\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu \"\n\t\t\t\t\"(bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = XFS_ERROR(EFSCORRUPTED);\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Each of the following cases stores data into the same region\n * of the on-disk inode, so only one of them can be valid at\n * any given time. While it is possible to have conflicting formats\n * and log flags, e.g. having XFS_ILOG_?DATA set when the fork is\n * in EXTENTS format, this can only happen when the fork has\n * changed formats after being modified but before being flushed.\n * In these cases, the format always takes precedence, because the\n * format indicates the current state of the fork.\n */\n/*ARGSUSED*/\n", "func_signal": "STATIC void\nxfs_iflush_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\txfs_inode_log_item_t\t*iip,\n\tint\t\t\twhichfork,\n\txfs_buf_t\t\t*bp)", "code": "{\n\tchar\t\t\t*cp;\n\txfs_ifork_t\t\t*ifp;\n\txfs_mount_t\t\t*mp;\n#ifdef XFS_TRANS_DEBUG\n\tint\t\t\tfirst;\n#endif\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\t/*\n\t * This can happen if we gave up in iformat in an error path,\n\t * for the attribute fork.\n\t */\n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (XFS_IFORK_FORMAT(ip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_format.ilf_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tASSERT((ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_format.ilf_fields & extflag[whichfork]));\n\t\tASSERT((xfs_iext_get_ext(ifp, 0) != NULL) ||\n\t\t\t(ifp->if_bytes == 0));\n\t\tASSERT((xfs_iext_get_ext(ifp, 0) == NULL) ||\n\t\t\t(ifp->if_bytes > 0));\n\t\tif ((iip->ili_format.ilf_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_format.ilf_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(ifp->if_broot_bytes <=\n\t\t\t       (XFS_IFORK_SIZE(ip, whichfork) +\n\t\t\t\tXFS_BROOT_SIZE_ADJ));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_format.ilf_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip, ip->i_df.if_u2.if_rdev);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_UUID:\n\t\tif (iip->ili_format.ilf_fields & XFS_ILOG_UUID) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t\t       &ip->i_df.if_u2.if_uuid,\n\t\t\t       sizeof(uuid_t));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Read in extents from a btree-format inode.\n * Allocate and fill in if_extents.  Real work is done in xfs_bmap.c.\n */\n", "func_signal": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)", "code": "{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\tsize_t\t\tsize;\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tsize = nextents * sizeof(xfs_bmbt_rec_t);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_lastex = NULLEXTNUM;\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Find the buffer associated with the given inode map\n * We do basic validation checks on the buffer once it has been\n * retrieved from disk.\n */\n", "func_signal": "STATIC int\nxfs_imap_to_bp(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\tstruct xfs_imap\t*imap,\n\txfs_buf_t\t**bpp,\n\tuint\t\tbuf_flags,\n\tuint\t\tiget_flags)", "code": "{\n\tint\t\terror;\n\tint\t\ti;\n\tint\t\tni;\n\txfs_buf_t\t*bp;\n\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp);\n\tif (error) {\n\t\tif (error != EAGAIN) {\n\t\t\tcmn_err(CE_WARN,\n\t\t\t\t\"xfs_imap_to_bp: xfs_trans_read_buf()returned \"\n\t\t\t\t\"an error %d on %s.  Returning error.\",\n\t\t\t\terror, mp->m_fsname);\n\t\t} else {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t}\n\t\treturn error;\n\t}\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t * (if DEBUG kernel) or the first inode in the buffer, otherwise.\n\t */\n#ifdef DEBUG\n\tni = BBTOB(imap->im_len) >> mp->m_sb.sb_inodelog;\n#else\t/* usual case */\n\tni = 1;\n#endif\n\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\n\t\tdip = (xfs_dinode_t *)xfs_buf_offset(bp,\n\t\t\t\t\t(i << mp->m_sb.sb_inodelog));\n\t\tdi_ok = be16_to_cpu(dip->di_magic) == XFS_DINODE_MAGIC &&\n\t\t\t    XFS_DINODE_GOOD_VERSION(dip->di_version);\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP,\n\t\t\t\t\t\tXFS_RANDOM_ITOBP_INOTOBP))) {\n\t\t\tif (iget_flags & XFS_IGET_BULKSTAT) {\n\t\t\t\txfs_trans_brelse(tp, bp);\n\t\t\t\treturn XFS_ERROR(EINVAL);\n\t\t\t}\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_imap_to_bp\",\n\t\t\t\t\t\tXFS_ERRLEVEL_HIGH, mp, dip);\n#ifdef DEBUG\n\t\t\tcmn_err(CE_PANIC,\n\t\t\t\t\t\"Device %s - bad inode magic/vsn \"\n\t\t\t\t\t\"daddr %lld #%d (magic=%x)\",\n\t\t\t\tXFS_BUFTARG_NAME(mp->m_ddev_targp),\n\t\t\t\t(unsigned long long)imap->im_blkno, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t}\n\t}\n\n\txfs_inobp_check(mp, bp);\n\n\t/*\n\t * Mark the buffer as an inode buffer now that it looks good\n\t */\n\tXFS_BUF_SET_VTYPE(bp, B_FS_INO);\n\n\t*bpp = bp;\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * This routine is called to map an inode to the buffer containing\n * the on-disk version of the inode.  It returns a pointer to the\n * buffer containing the on-disk inode in the bpp parameter, and in\n * the dip parameter it returns a pointer to the on-disk inode within\n * that buffer.\n *\n * If a non-zero error is returned, then the contents of bpp and\n * dipp are undefined.\n *\n * The inode is expected to already been mapped to its buffer and read\n * in once, thus we can use the mapping information stored in the inode\n * rather than calling xfs_imap().  This allows us to avoid the overhead\n * of looking at the inode btree for small block file systems\n * (see xfs_imap()).\n */\n", "func_signal": "int\nxfs_itobp(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t**dipp,\n\txfs_buf_t\t**bpp,\n\tuint\t\tbuf_flags)", "code": "{\n\txfs_buf_t\t*bp;\n\tint\t\terror;\n\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &bp, buf_flags, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (!bp) {\n\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\tASSERT(tp == NULL);\n\t\t*bpp = NULL;\n\t\treturn EAGAIN;\n\t}\n\n\t*dipp = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\t*bpp = bp;\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * The file has too many extents to fit into\n * the inode, so they are in B-tree format.\n * Allocate a buffer for the root of the B-tree\n * and copy the root into it.  The i_extents\n * field will remain NULL until all of the\n * extents are read in (when they are needed).\n */\n", "func_signal": "STATIC int\nxfs_iformat_btree(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\tint\t\t\twhichfork)", "code": "{\n\txfs_bmdr_block_t\t*dfp;\n\txfs_ifork_t\t\t*ifp;\n\t/* REFERENCED */\n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\n\t/*\n\t * blow out if -- fork has less extents than can fit in\n\t * fork (fork shouldn't be a btree format), root btree\n\t * block has more records than can fit into the fork,\n\t * or the number of extents is greater than the number of\n\t * blocks.\n\t */\n\tif (unlikely(XFS_IFORK_NEXTENTS(ip, whichfork) <= ifp->if_ext_max\n\t    || XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork)\n\t    || XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks)) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt inode %Lu (btree).\",\n\t\t\t(unsigned long long) ip->i_ino);\n\t\tXFS_ERROR_REPORT(\"xfs_iformat_btree\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_SLEEP);\n\tASSERT(ifp->if_broot != NULL);\n\t/*\n\t * Copy and convert from the on-disk structure\n\t * to the in-memory structure.\n\t */\n\txfs_bmdr_to_bmbt(ip->i_mount, dfp,\n\t\t\t XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFBROOT;\n\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * The file is in-lined in the on-disk inode.\n * If it fits into if_inline_data, then copy\n * it there, otherwise allocate a buffer for it\n * and copy the data there.  Either way, set\n * if_data to point at the data.\n * If we allocate a buffer for the data, make\n * sure that its size is a multiple of 4 and\n * record the real size in i_real_bytes.\n */\n", "func_signal": "STATIC int\nxfs_iformat_local(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork,\n\tint\t\tsize)", "code": "{\n\txfs_ifork_t\t*ifp;\n\tint\t\treal_size;\n\n\t/*\n\t * If the size is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt inode %Lu \"\n\t\t\t\"(bad size %d for local fork, size = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_local\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\treal_size = 0;\n\tif (size == 0)\n\t\tifp->if_u1.if_data = NULL;\n\telse if (size <= sizeof(ifp->if_u2.if_inline_data))\n\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\telse {\n\t\treal_size = roundup(size, 4);\n\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP);\n\t}\n\tifp->if_bytes = size;\n\tifp->if_real_bytes = real_size;\n\tif (size)\n\t\tmemcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFINLINE;\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Pull the on-disk inode from the AGI unlinked list.\n */\n", "func_signal": "STATIC int\nxfs_iunlink_remove(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip)", "code": "{\n\txfs_ino_t\tnext_ino;\n\txfs_mount_t\t*mp;\n\txfs_agi_t\t*agi;\n\txfs_dinode_t\t*dip;\n\txfs_buf_t\t*agibp;\n\txfs_buf_t\t*ibp;\n\txfs_agnumber_t\tagno;\n\txfs_agino_t\tagino;\n\txfs_agino_t\tnext_agino;\n\txfs_buf_t\t*last_ibp;\n\txfs_dinode_t\t*last_dip = NULL;\n\tshort\t\tbucket_index;\n\tint\t\toffset, last_offset = 0;\n\tint\t\terror;\n\n\tmp = tp->t_mountp;\n\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\n\t/*\n\t * Get the agi buffer first.  It ensures lock ordering\n\t * on the list.\n\t */\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(agibp);\n\n\t/*\n\t * Get the index into the agi hash table for the\n\t * list this inode will go on.\n\t */\n\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\tASSERT(agino != 0);\n\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tASSERT(be32_to_cpu(agi->agi_unlinked[bucket_index]) != NULLAGINO);\n\tASSERT(agi->agi_unlinked[bucket_index]);\n\n\tif (be32_to_cpu(agi->agi_unlinked[bucket_index]) == agino) {\n\t\t/*\n\t\t * We're at the head of the list.  Get the inode's\n\t\t * on-disk buffer to see if there is anyone after us\n\t\t * on the list.  Only modify our next pointer if it\n\t\t * is not already NULLAGINO.  This saves us the overhead\n\t\t * of dealing with the buffer when there is no need to\n\t\t * change it.\n\t\t */\n\t\terror = xfs_itobp(mp, tp, ip, &dip, &ibp, XBF_LOCK);\n\t\tif (error) {\n\t\t\tcmn_err(CE_WARN,\n\t\t\t\t\"xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error.\",\n\t\t\t\terror, mp->m_fsname);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the bucket head pointer at the next inode.\n\t\t */\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tagi->agi_unlinked[bucket_index] = cpu_to_be32(next_agino);\n\t\toffset = offsetof(xfs_agi_t, agi_unlinked) +\n\t\t\t(sizeof(xfs_agino_t) * bucket_index);\n\t\txfs_trans_log_buf(tp, agibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t} else {\n\t\t/*\n\t\t * We need to search the list for the inode being freed.\n\t\t */\n\t\tnext_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\t\tlast_ibp = NULL;\n\t\twhile (next_agino != agino) {\n\t\t\t/*\n\t\t\t * If the last inode wasn't the one pointing to\n\t\t\t * us, then release its buffer since we're not\n\t\t\t * going to do anything with it.\n\t\t\t */\n\t\t\tif (last_ibp != NULL) {\n\t\t\t\txfs_trans_brelse(tp, last_ibp);\n\t\t\t}\n\t\t\tnext_ino = XFS_AGINO_TO_INO(mp, agno, next_agino);\n\t\t\terror = xfs_inotobp(mp, tp, next_ino, &last_dip,\n\t\t\t\t\t    &last_ibp, &last_offset, 0);\n\t\t\tif (error) {\n\t\t\t\tcmn_err(CE_WARN,\n\t\t\t\"xfs_iunlink_remove: xfs_inotobp()  returned an error %d on %s.  Returning error.\",\n\t\t\t\t\terror, mp->m_fsname);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tnext_agino = be32_to_cpu(last_dip->di_next_unlinked);\n\t\t\tASSERT(next_agino != NULLAGINO);\n\t\t\tASSERT(next_agino != 0);\n\t\t}\n\t\t/*\n\t\t * Now last_ibp points to the buffer previous to us on\n\t\t * the unlinked list.  Pull us from the list.\n\t\t */\n\t\terror = xfs_itobp(mp, tp, ip, &dip, &ibp, XBF_LOCK);\n\t\tif (error) {\n\t\t\tcmn_err(CE_WARN,\n\t\t\t\t\"xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error.\",\n\t\t\t\terror, mp->m_fsname);\n\t\t\treturn error;\n\t\t}\n\t\tnext_agino = be32_to_cpu(dip->di_next_unlinked);\n\t\tASSERT(next_agino != 0);\n\t\tASSERT(next_agino != agino);\n\t\tif (next_agino != NULLAGINO) {\n\t\t\tdip->di_next_unlinked = cpu_to_be32(NULLAGINO);\n\t\t\toffset = ip->i_imap.im_boffset +\n\t\t\t\toffsetof(xfs_dinode_t, di_next_unlinked);\n\t\t\txfs_trans_inode_buf(tp, ibp);\n\t\t\txfs_trans_log_buf(tp, ibp, offset,\n\t\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\t\txfs_inobp_check(mp, ibp);\n\t\t} else {\n\t\t\txfs_trans_brelse(tp, ibp);\n\t\t}\n\t\t/*\n\t\t * Point the previous inode on the list to the next inode.\n\t\t */\n\t\tlast_dip->di_next_unlinked = cpu_to_be32(next_agino);\n\t\tASSERT(next_agino != 0);\n\t\toffset = last_offset + offsetof(xfs_dinode_t, di_next_unlinked);\n\t\txfs_trans_inode_buf(tp, last_ibp);\n\t\txfs_trans_log_buf(tp, last_ibp, offset,\n\t\t\t\t  (offset + sizeof(xfs_agino_t) - 1));\n\t\txfs_inobp_check(mp, last_ibp);\n\t}\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * Read the disk inode attributes into the in-core inode structure.\n */\n", "func_signal": "int\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_daddr_t\tbno,\n\tuint\t\tiget_flags)", "code": "{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\tip->i_imap.im_blkno = bno;\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\tASSERT(bno == 0 || bno == ip->i_imap.im_blkno);\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &bp,\n\t\t\t       XBF_LOCK, iget_flags);\n\tif (error)\n\t\treturn error;\n\tdip = (xfs_dinode_t *)xfs_buf_offset(bp, ip->i_imap.im_boffset);\n\n\t/*\n\t * If we got something that isn't an inode it means someone\n\t * (nfs or dmi) has a stale handle.\n\t */\n\tif (be16_to_cpu(dip->di_magic) != XFS_DINODE_MAGIC) {\n#ifdef DEBUG\n\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_iread: \"\n\t\t\t\t\"dip->di_magic (0x%x) != \"\n\t\t\t\t\"XFS_DINODE_MAGIC (0x%x)\",\n\t\t\t\tbe16_to_cpu(dip->di_magic),\n\t\t\t\tXFS_DINODE_MAGIC);\n#endif /* DEBUG */\n\t\terror = XFS_ERROR(EINVAL);\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_dinode_from_disk(&ip->i_d, dip);\n\t\terror = xfs_iformat(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_iread: \"\n\t\t\t\t\t\"xfs_iformat() returned error %d\",\n\t\t\t\t\terror);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\tip->i_d.di_magic = be16_to_cpu(dip->di_magic);\n\t\tip->i_d.di_version = dip->di_version;\n\t\tip->i_d.di_gen = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tip->i_d.di_mode = 0;\n\t\t/*\n\t\t * Initialize the per-fork minima and maxima for a new\n\t\t * inode here.  xfs_iformat will do it for old inodes.\n\t\t */\n\t\tip->i_df.if_ext_max =\n\t\t\tXFS_IFORK_DSIZE(ip) / (uint)sizeof(xfs_bmbt_rec_t);\n\t}\n\n\t/*\n\t * The inode format changed when we moved the link count and\n\t * made it 32 bits long.  If this is an old format inode,\n\t * convert it in memory to look like a new one.  If it gets\n\t * flushed to disk we will convert back before flushing or\n\t * logging it.  We zero out the new projid field and the old link\n\t * count field.  We'll handle clearing the pad field (the remains\n\t * of the old uuid field) when we actually convert the inode to\n\t * the new format. We don't change the version number so that we\n\t * can distinguish this from a real new format inode.\n\t */\n\tif (ip->i_d.di_version == 1) {\n\t\tip->i_d.di_nlink = ip->i_d.di_onlink;\n\t\tip->i_d.di_onlink = 0;\n\t\tip->i_d.di_projid = 0;\n\t}\n\n\tip->i_delayed_blks = 0;\n\tip->i_size = ip->i_d.di_size;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\tXFS_BUF_SET_REF(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the\n\t * on-disk inode, because it was acquired with xfs_trans_read_buf()\n\t * in xfs_itobp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be\n\t * locking the new in-core inode before putting it in the hash\n\t * table where other processes can find it.  Thus we don't have\n\t * to worry about the inode being changed just because we released\n\t * the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * The file consists of a set of extents all\n * of which fit into the on-disk inode.\n * If there are few enough extents to fit into\n * the if_inline_ext, then copy them there.\n * Otherwise allocate a buffer for them and copy\n * them into it.  Either way, set if_extents\n * to point at the extents.\n */\n", "func_signal": "STATIC int\nxfs_iformat_extents(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork)", "code": "{\n\txfs_bmbt_rec_t\t*dp;\n\txfs_ifork_t\t*ifp;\n\tint\t\tnex;\n\tint\t\tsize;\n\tint\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnex = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tsize = nex * (uint)sizeof(xfs_bmbt_rec_t);\n\n\t/*\n\t * If the number of extents is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_fs_repair_cmn_err(CE_WARN, ip->i_mount,\n\t\t\t\"corrupt inode %Lu ((a)extents = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, nex);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_extents(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t}\n\n\tifp->if_real_bytes = 0;\n\tif (nex == 0)\n\t\tifp->if_u1.if_extents = NULL;\n\telse if (nex <= XFS_INLINE_EXTS)\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\telse\n\t\txfs_iext_add(ifp, 0, nex);\n\n\tifp->if_bytes = size;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\t\txfs_validate_extents(ifp, nex, XFS_EXTFMT_INODE(ip));\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\t\tep->l0 = get_unaligned_be64(&dp->l0);\n\t\t\tep->l1 = get_unaligned_be64(&dp->l1);\n\t\t}\n\t\tXFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);\n\t\tif (whichfork != XFS_DATA_FORK ||\n\t\t\tXFS_EXTFMT_INODE(ip) == XFS_EXTFMT_NOSTATE)\n\t\t\t\tif (unlikely(xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex))) {\n\t\t\t\t\tXFS_ERROR_REPORT(\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t\t ip->i_mount);\n\t\t\t\t\treturn XFS_ERROR(EFSCORRUPTED);\n\t\t\t\t}\n\t}\n\tifp->if_flags |= XFS_IFEXTENTS;\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * xfs_iflush() will write a modified inode's changes out to the\n * inode's on disk home.  The caller must have the inode lock held\n * in at least shared mode and the inode flush completion must be\n * active as well.  The inode lock will still be held upon return from\n * the call and the caller is free to unlock it.\n * The inode flush will be completed when the inode reaches the disk.\n * The flags indicate how the inode's buffer should be written out.\n */\n", "func_signal": "int\nxfs_iflush(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tflags)", "code": "{\n\txfs_inode_log_item_t\t*iip;\n\txfs_buf_t\t\t*bp;\n\txfs_dinode_t\t\t*dip;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_iflush_count);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(!completion_done(&ip->i_flush));\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       ip->i_d.di_nextents > ip->i_df.if_ext_max);\n\n\tiip = ip->i_itemp;\n\tmp = ip->i_mount;\n\n\t/*\n\t * We can't flush the inode until it is unpinned, so wait for it if we\n\t * are allowed to block.  We know noone new can pin it, because we are\n\t * holding the inode lock shared and you need to hold it exclusively to\n\t * pin the inode.\n\t *\n\t * If we are not allowed to block, force the log out asynchronously so\n\t * that when we come back the inode will be unpinned. If other inodes\n\t * in the same cluster are dirty, they will probably write the inode\n\t * out for us if they occur after the log force completes.\n\t */\n\tif (!(flags & SYNC_WAIT) && xfs_ipincount(ip)) {\n\t\txfs_iunpin_nowait(ip);\n\t\txfs_ifunlock(ip);\n\t\treturn EAGAIN;\n\t}\n\txfs_iunpin_wait(ip);\n\n\t/*\n\t * For stale inodes we cannot rely on the backing buffer remaining\n\t * stale in cache for the remaining life of the stale inode and so\n\t * xfs_itobp() below may give us a buffer that no longer contains\n\t * inodes below. We have to check this after ensuring the inode is\n\t * unpinned so that it is safe to reclaim the stale inode after the\n\t * flush call.\n\t */\n\tif (xfs_iflags_test(ip, XFS_ISTALE)) {\n\t\txfs_ifunlock(ip);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this inode\n\t * to disk, because the log record didn't make it to disk!\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tip->i_update_core = 0;\n\t\tif (iip)\n\t\t\tiip->ili_format.ilf_fields = 0;\n\t\txfs_ifunlock(ip);\n\t\treturn XFS_ERROR(EIO);\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk inode.\n\t */\n\terror = xfs_itobp(mp, NULL, ip, &dip, &bp,\n\t\t\t\t(flags & SYNC_WAIT) ? XBF_LOCK : XBF_TRYLOCK);\n\tif (error || !bp) {\n\t\txfs_ifunlock(ip);\n\t\treturn error;\n\t}\n\n\t/*\n\t * First flush out the inode that xfs_iflush was called with.\n\t */\n\terror = xfs_iflush_int(ip, bp);\n\tif (error)\n\t\tgoto corrupt_out;\n\n\t/*\n\t * If the buffer is pinned then push on the log now so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (XFS_BUF_ISPINNED(bp))\n\t\txfs_log_force(mp, 0);\n\n\t/*\n\t * inode clustering:\n\t * see if other inodes can be gathered into this write\n\t */\n\terror = xfs_iflush_cluster(ip, bp);\n\tif (error)\n\t\tgoto cluster_corrupt_out;\n\n\tif (flags & SYNC_WAIT)\n\t\terror = xfs_bwrite(mp, bp);\n\telse\n\t\txfs_bdwrite(mp, bp);\n\treturn error;\n\ncorrupt_out:\n\txfs_buf_relse(bp);\n\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\ncluster_corrupt_out:\n\t/*\n\t * Unlocks the flush lock\n\t */\n\txfs_iflush_abort(ip);\n\treturn XFS_ERROR(EFSCORRUPTED);\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * This is called when the amount of space needed for if_data\n * is increased or decreased.  The change in size is indicated by\n * the number of bytes that need to be added or deleted in the\n * byte_diff parameter.\n *\n * If the amount of space needed has decreased below the size of the\n * inline buffer, then switch to using the inline buffer.  Otherwise,\n * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer\n * to what is needed.\n *\n * ip -- the inode whose if_data area is changing\n * byte_diff -- the change in the number of bytes, positive or negative,\n *\t requested for the if_data array.\n */\n", "func_signal": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)", "code": "{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/*\n * This routine is called to map an inode number within a file\n * system to the buffer containing the on-disk version of the\n * inode.  It returns a pointer to the buffer containing the\n * on-disk inode in the bpp parameter, and in the dip parameter\n * it returns a pointer to the on-disk inode within that buffer.\n *\n * If a non-zero error is returned, then the contents of bpp and\n * dipp are undefined.\n *\n * Use xfs_imap() to determine the size and location of the\n * buffer to read from disk.\n */\n", "func_signal": "int\nxfs_inotobp(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\txfs_dinode_t\t**dipp,\n\txfs_buf_t\t**bpp,\n\tint\t\t*offset,\n\tuint\t\timap_flags)", "code": "{\n\tstruct xfs_imap\timap;\n\txfs_buf_t\t*bp;\n\tint\t\terror;\n\n\timap.im_blkno = 0;\n\terror = xfs_imap(mp, tp, ino, &imap, imap_flags);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_imap_to_bp(mp, tp, &imap, &bp, XBF_LOCK, imap_flags);\n\tif (error)\n\t\treturn error;\n\n\t*dipp = (xfs_dinode_t *)xfs_buf_offset(bp, imap.im_boffset);\n\t*bpp = bp;\n\t*offset = imap.im_boffset;\n\treturn 0;\n}", "path": "fs\\xfs\\xfs_inode.c", "repo_name": "kingklick/kk-nexus-kernel", "stars": 4, "license": "other", "language": "c", "size": 425047}
{"docstring": "/* Copies from the \"scratch\" disk, hdc or hd1:0 to file ARGV[1]\n   in the file system.\n\n   The current sector on the scratch disk must begin with the\n   string \"PUT\\0\" followed by a 32-bit little-endian integer\n   indicating the file size in bytes.  Subsequent sectors hold\n   the file content.\n\n   The first call to this function will read starting at the\n   beginning of the scratch disk.  Later calls advance across the\n   disk.  This disk position is independent of that used for\n   fsutil_get(), so all `put's should precede all `get's. */\n", "func_signal": "void\nfsutil_put (char **argv)", "code": "{\n  static disk_sector_t sector = 0;\n\n  const char *file_name = argv[1];\n  struct disk *src;\n  struct file *dst;\n  off_t size;\n  void *buffer;\n\n  printf (\"Putting '%s' into the file system...\\n\", file_name);\n\n  /* Allocate buffer. */\n  buffer = malloc (DISK_SECTOR_SIZE);\n  if (buffer == NULL)\n    PANIC (\"couldn't allocate buffer\");\n\n  /* Open source disk and read file size. */\n  src = disk_get (1, 0);\n  if (src == NULL)\n    PANIC (\"couldn't open source disk (hdc or hd1:0)\");\n\n  /* Read file size. */\n  disk_read (src, sector++, buffer);\n  if (memcmp (buffer, \"PUT\", 4))\n    PANIC (\"%s: missing PUT signature on scratch disk\", file_name);\n  size = ((int32_t *) buffer)[1];\n  if (size < 0)\n    PANIC (\"%s: invalid file size %d\", file_name, size);\n  \n  /* Create destination file. */\n  if (!filesys_create (file_name, size))\n    PANIC (\"%s: create failed\", file_name);\n  dst = filesys_open (file_name);\n  if (dst == NULL)\n    PANIC (\"%s: open failed\", file_name);\n\n  /* Do copy. */\n  while (size > 0)\n    {\n      int chunk_size = size > DISK_SECTOR_SIZE ? DISK_SECTOR_SIZE : size;\n      disk_read (src, sector++, buffer);\n      if (file_write (dst, buffer, chunk_size) != chunk_size)\n        PANIC (\"%s: write failed with %\"PROTd\" bytes unwritten\",\n               file_name, size);\n      size -= chunk_size;\n    }\n\n  /* Finish up. */\n  file_close (dst);\n  free (buffer);\n}", "path": "filesys\\fsutil.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Copies file FILE_NAME from the file system to the scratch disk.\n\n   The current sector on the scratch disk will receive \"GET\\0\"\n   followed by the file's size in bytes as a 32-bit,\n   little-endian integer.  Subsequent sectors receive the file's\n   data.\n\n   The first call to this function will write starting at the\n   beginning of the scratch disk.  Later calls advance across the\n   disk.  This disk position is independent of that used for\n   fsutil_put(), so all `put's should precede all `get's. */\n", "func_signal": "void\nfsutil_get (char **argv)", "code": "{\n  static disk_sector_t sector = 0;\n\n  const char *file_name = argv[1];\n  void *buffer;\n  struct file *src;\n  struct disk *dst;\n  off_t size;\n\n  printf (\"Getting '%s' from the file system...\\n\", file_name);\n\n  /* Allocate buffer. */\n  buffer = malloc (DISK_SECTOR_SIZE);\n  if (buffer == NULL)\n    PANIC (\"couldn't allocate buffer\");\n\n  /* Open source file. */\n  src = filesys_open (file_name);\n  if (src == NULL)\n    PANIC (\"%s: open failed\", file_name);\n  size = file_length (src);\n\n  /* Open target disk. */\n  dst = disk_get (1, 0);\n  if (dst == NULL)\n    PANIC (\"couldn't open target disk (hdc or hd1:0)\");\n  \n  /* Write size to sector 0. */\n  memset (buffer, 0, DISK_SECTOR_SIZE);\n  memcpy (buffer, \"GET\", 4);\n  ((int32_t *) buffer)[1] = size;\n  disk_write (dst, sector++, buffer);\n  \n  /* Do copy. */\n  while (size > 0) \n    {\n      int chunk_size = size > DISK_SECTOR_SIZE ? DISK_SECTOR_SIZE : size;\n      if (sector >= disk_size (dst))\n        PANIC (\"%s: out of space on scratch disk\", file_name);\n      if (file_read (src, buffer, chunk_size) != chunk_size)\n        PANIC (\"%s: read failed with %\"PROTd\" bytes unread\", file_name, size);\n      memset (buffer + chunk_size, 0, DISK_SECTOR_SIZE - chunk_size);\n      disk_write (dst, sector++, buffer);\n      size -= chunk_size;\n    }\n\n  /* Finish up. */\n  file_close (src);\n  free (buffer);\n}", "path": "filesys\\fsutil.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Returns 1 if *A is greater than *B,\n   0 if *A equals *B,\n   -1 if *A is less than *B. */\n", "func_signal": "static int\ncompare_ints (const void *a_, const void *b_)", "code": "{\n  const int *a = a_;\n  const int *b = b_;\n\n  return *a < *b ? -1 : *a > *b;\n}", "path": "tests\\internal\\stdlib.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Writes SIZE bytes from BUFFER into FILE,\n   starting at the file's current position.\n   Returns the number of bytes actually written,\n   which may be less than SIZE if end of file is reached.\n   (Normally we'd grow the file in that case, but file growth is\n   not yet implemented.)\n   Advances FILE's position by the number of bytes read. */\n", "func_signal": "off_t\nfile_write (struct file *file, const void *buffer, off_t size)", "code": "{\n  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);\n  file->pos += bytes_written;\n  return bytes_written;\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Checks that bsearch() works properly in ARRAY.  ARRAY must\n   contain the values 0...CNT-1. */\n", "func_signal": "static void\nverify_bsearch (const int *array, size_t cnt)", "code": "{\n  int not_in_array[] = {0, -1, INT_MAX, MAX_CNT, MAX_CNT + 1, MAX_CNT * 2};\n  int i;\n\n  /* Check that all the values in the array are found properly. */\n  for (i = 0; (size_t) i < cnt; i++) \n    ASSERT (bsearch (&i, array, cnt, sizeof *array, compare_ints)\n            == array + i);\n\n  /* Check that some values not in the array are not found. */\n  not_in_array[0] = cnt;\n  for (i = 0; (size_t) i < sizeof not_in_array / sizeof *not_in_array; i++) \n    ASSERT (bsearch (&not_in_array[i], array, cnt, sizeof *array, compare_ints)\n            == NULL);\n}", "path": "tests\\internal\\stdlib.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Verifies that ARRAY contains the CNT ints 0...CNT-1. */\n", "func_signal": "static void\nverify_order (const int *array, size_t cnt)", "code": "{\n  int i;\n\n  for (i = 0; (size_t) i < cnt; i++) \n    ASSERT (array[i] == i);\n}", "path": "tests\\internal\\stdlib.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* List files in the root directory. */\n", "func_signal": "void\nfsutil_ls (char **argv UNUSED)", "code": "{\n  struct dir *dir;\n  char name[NAME_MAX + 1];\n  \n  printf (\"Files in the root directory:\\n\");\n  dir = dir_open_root ();\n  if (dir == NULL)\n    PANIC (\"root dir open failed\");\n  while (dir_readdir (dir, name))\n    printf (\"%s\\n\", name);\n  printf (\"End of listing.\\n\");\n}", "path": "filesys\\fsutil.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Shuffles the CNT elements in ARRAY into random order. */\n", "func_signal": "static void\nshuffle (int *array, size_t cnt)", "code": "{\n  size_t i;\n\n  for (i = 0; i < cnt; i++)\n    {\n      size_t j = i + random_ulong () % (cnt - i);\n      int t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n    }\n}", "path": "tests\\internal\\stdlib.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Prints the contents of file ARGV[1] to the system console as\n   hex and ASCII. */\n", "func_signal": "void\nfsutil_cat (char **argv)", "code": "{\n  const char *file_name = argv[1];\n  \n  struct file *file;\n  char *buffer;\n\n  printf (\"Printing '%s' to the console...\\n\", file_name);\n  file = filesys_open (file_name);\n  if (file == NULL)\n    PANIC (\"%s: open failed\", file_name);\n  buffer = palloc_get_page (PAL_ASSERT);\n  for (;;) \n    {\n      off_t pos = file_tell (file);\n      off_t n = file_read (file, buffer, PGSIZE);\n      if (n == 0)\n        break;\n\n      hex_dump (pos, buffer, n, true); \n    }\n  palloc_free_page (buffer);\n  file_close (file);\n}", "path": "filesys\\fsutil.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Prints failure message FORMAT as if with printf(),\n   prefixing the output by the name of the test and FAIL:\n   and following it with a new-line character,\n   and then panics the kernel. */\n", "func_signal": "void\nfail (const char *format, ...)", "code": "{\n  va_list args;\n  \n  printf (\"(%s) FAIL: \", test_name);\n  va_start (args, format);\n  vprintf (format, args);\n  va_end (args);\n  putchar ('\\n');\n\n  PANIC (\"test failed\");\n}", "path": "tests\\threads\\tests.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "//static inline struct special_page_elem *add_lazy_page_unsafe (struct thread *t, struct special_page_elem *page);\n", "func_signal": "static unsigned\npage_hash (const struct hash_elem *element, void *aux UNUSED)", "code": "{\n  struct special_page_elem *page = hash_entry (element, struct special_page_elem, elem);\n  return hash_bytes (&page->virtual_page, sizeof (page->virtual_page));\n}", "path": "vm\\page.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Re-enables write operations on FILE's underlying inode.\n   (Writes might still be denied by some other file that has the\n   same inode open.) */\n", "func_signal": "void\nfile_allow_write (struct file *file)", "code": "{\n  ASSERT (file != NULL);\n  if (file->deny_write) \n    {\n      file->deny_write = false;\n      inode_allow_write (file->inode);\n    }\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Test sorting and searching implementations. */\n", "func_signal": "void\ntest (void)", "code": "{\n  int cnt;\n\n  printf (\"testing various size arrays:\");\n  for (cnt = 0; cnt < MAX_CNT; cnt = cnt * 4 / 3 + 1)\n    {\n      int repeat;\n\n      printf (\" %zu\", cnt);\n      for (repeat = 0; repeat < 10; repeat++) \n        {\n          static int values[MAX_CNT];\n          int i;\n\n          /* Put values 0...CNT in random order in VALUES. */\n          for (i = 0; i < cnt; i++)\n            values[i] = i;\n          shuffle (values, cnt);\n  \n          /* Sort VALUES, then verify ordering. */\n          qsort (values, cnt, sizeof *values, compare_ints);\n          verify_order (values, cnt);\n          verify_bsearch (values, cnt);\n        }\n    }\n  \n  printf (\" done\\n\");\n  printf (\"stdlib: PASS\\n\");\n}", "path": "tests\\internal\\stdlib.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Opens a file for the given INODE, of which it takes ownership,\n   and returns the new file.  Returns a null pointer if an\n   allocation fails or if INODE is null. */\n", "func_signal": "struct file *\nfile_open (struct inode *inode)", "code": "{\n  struct file *file = calloc (1, sizeof *file);\n  if (inode != NULL && file != NULL)\n    {\n      file->inode = inode;\n      file->pos = 0;\n      file->deny_write = false;\n      return file;\n    }\n  else\n    {\n      inode_close (inode);\n      free (file);\n      return NULL; \n    }\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Returns the current position in FILE as a byte offset from the\n   start of the file. */\n", "func_signal": "off_t\nfile_tell (struct file *file)", "code": "{\n  ASSERT (file != NULL);\n  return file->pos;\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Closes FILE. */\n", "func_signal": "void\nfile_close (struct file *file)", "code": "{\n  if (file != NULL)\n    {\n      file_allow_write (file);\n      inode_close (file->inode);\n      free (file); \n    }\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Deletes file ARGV[1]. */\n", "func_signal": "void\nfsutil_rm (char **argv)", "code": "{\n  const char *file_name = argv[1];\n  \n  printf (\"Deleting '%s'...\\n\", file_name);\n  if (!filesys_remove (file_name))\n    PANIC (\"%s: delete failed\\n\", file_name);\n}", "path": "filesys\\fsutil.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Returns the size of FILE in bytes. */\n", "func_signal": "off_t\nfile_length (struct file *file)", "code": "{\n  ASSERT (file != NULL);\n  return inode_length (file->inode);\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Prevents write operations on FILE's underlying inode\n   until file_allow_write() is called or FILE is closed. */\n", "func_signal": "void\nfile_deny_write (struct file *file)", "code": "{\n  ASSERT (file != NULL);\n  if (!file->deny_write) \n    {\n      file->deny_write = true;\n      inode_deny_write (file->inode);\n    }\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Sets the current position in FILE to NEW_POS bytes from the\n   start of the file. */\n", "func_signal": "void\nfile_seek (struct file *file, off_t new_pos)", "code": "{\n  ASSERT (file != NULL);\n  ASSERT (new_pos >= 0);\n  file->pos = new_pos;\n}", "path": "filesys\\file.c", "repo_name": "rictic/tiny-os", "stars": 5, "license": "other", "language": "c", "size": 668}
{"docstring": "/* Copy a string. */\n", "func_signal": "extern struct str * str_copy(struct str * old)", "code": "{\n\n    struct str * newstr = str_new();\n    str_append(newstr, old);\n    return newstr;\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Delete a string. */\n", "func_signal": "extern void str_delete(struct str * str)", "code": "{\n\n    lose_b(str->data);\n    free(str);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* bugs marked <======= fixed 22/7/02. Similar fixes required for Java */\n", "func_signal": "static void generate_slicefrom(struct generator * g, struct node * p)", "code": "{\n\n/*  w(g, \"~Mslice_from_s(z, \");   <============= bug! should be: */\n    wp(g, \"~{int ret = slice_from_~$(z, \", p);\n    generate_data_address(g, p);\n    wp(g, \");~C\", p);\n    wp(g, \"~Mif (ret < 0) return ret;~N\"\n          \"~}\", p);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\generator.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Output routines */\n", "func_signal": "static void output_str(FILE * outfile, struct str * str)", "code": "{\n\n    char * s = b_to_s(str_data(str));\n    fprintf(outfile, \"%s\", s);\n    free(s);\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* dollar sets snowball up to operate on a string variable as if it were the\n * current string */\n", "func_signal": "static void generate_dollar(struct generator * g, struct node * p)", "code": "{\n\n    struct str * savevar = vars_newname(g);\n    write_comment(g, p);\n    g->V[0] = p->name;\n\n    str_assign(g->failure_str, \"copy_from(\");\n    str_append(g->failure_str, savevar);\n    str_append_string(g->failure_str, \");\");\n    g->B[0] = str_data(savevar);\n    writef(g, \"~{~M~n ~B0 = this;~N\"\n             \"~Mcurrent = new StringBuffer(~V0.toString());~N\"\n             \"~Mcursor = 0;~N\"\n             \"~Mlimit = (current.length());~N\", p);\n    generate(g, p->left);\n    if (!g->unreachable) {\n        write_margin(g);\n        write_str(g, g->failure_str);\n        write_newline(g);\n    }\n    w(g, \"~}\");\n    str_delete(savevar);\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/** Display the command line syntax, and then exit.\n *  @param n The value to exit with.\n */\n", "func_signal": "static void\nusage(int n)", "code": "{\n    printf(\"usage: %s [-l <language>] [-i <input file>] [-o <output file>] [-c <character encoding>] [-p[2]] [-h]\\n\"\n\t  \"\\n\"\n\t  \"The input file consists of a list of words to be stemmed, one per\\n\"\n\t  \"line. Words should be in lower case, but (for English) A-Z letters\\n\"\n\t  \"are mapped to their a-z equivalents anyway. If omitted, stdin is\\n\"\n\t  \"used.\\n\"\n\t  \"\\n\"\n\t  \"If -c is given, the argument is the character encoding of the input\\n\"\n          \"and output files.  If it is omitted, the UTF-8 encoding is used.\\n\"\n\t  \"\\n\"\n\t  \"If -p is given the output file consists of each word of the input\\n\"\n\t  \"file followed by \\\"->\\\" followed by its stemmed equivalent.\\n\"\n\t  \"If -p2 is given the output file is a two column layout containing\\n\"\n\t  \"the input words in the first column and the stemmed eqivalents in\\n\"\n\t  \"the second column.\\n\"\n\t  \"Otherwise, the output file consists of the stemmed words, one per\\n\"\n\t  \"line.\\n\"\n\t  \"\\n\"\n\t  \"-h displays this help\\n\",\n\t  progname);\n    exit(n);\n}", "path": "snowball\\examples\\stemwords.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* generate_test() also implements 'reverse' */\n", "func_signal": "static void generate_test(struct generator * g, struct node * p)", "code": "{\n    int keep_c = K_needed(g, p->left);\n    if (keep_c) wp(g, \"~{~K~C\", p);\n           else wp(g, \"~M~C\", p);\n\n    generate(g, p->left);\n\n    if (keep_c) wp(g, \"~M~R~N\"\n                   \"~}\", p);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\generator.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Append an integer to a str. */\n", "func_signal": "extern void str_append_int(struct str * str, int i)", "code": "{\n\n    char s[30];\n    sprintf(s, \"%d\", i);\n    str_append_string(str, s);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Create a new string. */\n", "func_signal": "extern struct str * str_new()", "code": "{\n\n    struct str * output = (struct str *) malloc(sizeof(struct str));\n    output->data = create_b(0);\n    return output;\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Append a str to this str. */\n", "func_signal": "extern void str_append(struct str * str, struct str * add)", "code": "{\n\n    symbol * q = add->data;\n    str->data = add_to_b(str->data, SIZE(q), q);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* K_needed() tests to see if we really need to keep c. Not true when the\n   the command does not touch the cursor. This and repeat_score() could be\n   elaborated almost indefinitely.\n*/\n", "func_signal": "static int K_needed(struct generator * g, struct node * p)", "code": "{\n\n    while (p != 0) {\n        switch (p->type) {\n            case c_dollar:\n            case c_leftslice:\n            case c_rightslice:\n            case c_mathassign:\n            case c_plusassign:\n            case c_minusassign:\n            case c_multiplyassign:\n            case c_divideassign:\n            case c_eq:\n            case c_ne:\n            case c_gr:\n            case c_ge:\n            case c_ls:\n            case c_le:\n            case c_sliceto:\n            case c_booltest:\n            case c_true:\n            case c_false:\n            case c_debug:\n                break;\n\n            case c_call:\n                if (K_needed(g, p->name->definition)) return true;\n                break;\n\n            case c_bra:\n                if (K_needed(g, p->left)) return true;\n                break;\n\n            default: return true;\n        }\n        p = p->right;\n    }\n    return false;\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Write a variable declaration. */\n", "func_signal": "static void write_declare(struct generator * g,\n                          char * declaration,\n                          struct node * p)", "code": "{\n\n    struct str * temp = g->outbuf;\n    g->outbuf = g->declarations;\n    write_string(g, \"            \");\n    writef(g, declaration, p);\n    write_string(g, \";\");\n    write_newline(g);\n    g->outbuf = temp;\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* generate_test() also implements 'reverse' */\n", "func_signal": "static void generate_test(struct generator * g, struct node * p)", "code": "{\n\n    struct str * savevar = vars_newname(g);\n    int keep_c = K_needed(g, p->left);\n\n    write_comment(g, p);\n\n    if (keep_c) {\n        write_savecursor(g, p, savevar);\n    }\n\n    generate(g, p->left);\n\n    if (!g->unreachable) {\n        if (keep_c) {\n            write_restorecursor(g, p, savevar);\n        }\n    }\n    str_delete(savevar);\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Write routines for items from the syntax tree */\n", "func_signal": "static void write_varname(struct generator * g, struct name * p)", "code": "{\n\n    int ch = \"SBIrxg\"[p->type];\n    if (p->type != t_external)\n    {\n        write_char(g, ch);\n        write_char(g, '_');\n    }\n    str_append_b(g->outbuf, p->b);\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Set a string */\n", "func_signal": "extern void str_assign(struct str * str, char * s)", "code": "{\n\n    str_clear(str);\n    str_append_string(str, s);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* if at limit fail */\n", "func_signal": "static void write_check_limit(struct generator * g, struct node * p)", "code": "{\n\n    if (p->mode == m_forward) {\n        write_failure_if(g, \"cursor >= limit\", p);\n    } else {\n        write_failure_if(g, \"cursor <= limit_backward\", p);\n    }\n}", "path": "snowball\\compiler\\generator_java.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* To add a zero terminated string to a block. If p = 0 the\n   block is created. */\n", "func_signal": "extern symbol * add_s_to_b(symbol * p, const char * s)", "code": "{\n    int n = strlen(s);\n    int k;\n    if (p == 0) p = create_b(n);\n    k = SIZE(p);\n    {\n        int x = k + n - CAPACITY(p);\n        if (x > 0) p = increase_capacity(p, x);\n    }\n    {\n        int i;\n        for (i = 0; i < n; i++) p[i + k] = s[i];\n    }\n    SIZE(p) += n;\n    return p;\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* Append a character to this str. */\n", "func_signal": "extern void str_append_ch(struct str * str, char add)", "code": "{\n\n    symbol q[1];\n    q[0] = add;\n    str->data = add_to_b(str->data, 1, q);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\space.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* test code */\n", "func_signal": "void error(const char * err)", "code": "{\n    printf(\"%s\\n\", err);\n    exit(1);\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\libstemmer\\test.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* K_needed() tests to see if we really need to keep c. Not true when the\n   the command does not touch the cursor. This and repeat_score() could be\n   elaborated almost indefinitely.\n*/\n", "func_signal": "static int K_needed(struct generator * g, struct node * p)", "code": "{\n    until (p == 0) {\n        switch (p->type) {\n            case c_dollar:\n            case c_leftslice:\n            case c_rightslice:\n            case c_mathassign:\n            case c_plusassign:\n            case c_minusassign:\n            case c_multiplyassign:\n            case c_divideassign:\n            case c_eq:\n            case c_ne:\n            case c_gr:\n            case c_ge:\n            case c_ls:\n            case c_le:\n            case c_sliceto:\n            case c_true:\n            case c_false:\n            case c_debug:\n                break;\n\n            case c_call:\n                if (K_needed(g, p->name->definition)) return true;\n                break;\n\n            case c_bra:\n                if (K_needed(g, p->left)) return true;\n                break;\n\n            default: return true;\n        }\n        p = p->right;\n    }\n    return false;\n}", "path": "pystemmer\\dist\\PyStemmer-1.1.0\\libstemmer_c\\compiler\\generator.c", "repo_name": "arnaudsj/snowball", "stars": 5, "license": "None", "language": "c", "size": 18340}
{"docstring": "/* ---------------------------------------------------------------------\n   mem* functions\n   ------------------------------------------------------------------ */\n", "func_signal": "void* VG_(memcpy) ( void *dest, const void *src, SizeT sz )", "code": "{\n   const UChar* s  = (const UChar*)src;\n         UChar* d  =       (UChar*)dest;\n   const UInt*  sI = (const UInt*)src;\n         UInt*  dI =       (UInt*)dest;\n\n   if (VG_IS_4_ALIGNED(dI) && VG_IS_4_ALIGNED(sI)) {\n      while (sz >= 16) {\n         dI[0] = sI[0];\n         dI[1] = sI[1];\n         dI[2] = sI[2];\n         dI[3] = sI[3];\n         sz -= 16;\n         dI += 4;\n         sI += 4;\n      }\n      if (sz == 0) \n         return dest;\n      while (sz >= 4) {\n         dI[0] = sI[0];\n         sz -= 4;\n         dI += 1;\n         sI += 1;\n      }\n      if (sz == 0) \n         return dest;\n      s = (const UChar*)sI;\n      d = (UChar*)dI;\n   }\n\n   while (sz--)\n      *d++ = *s++;\n\n   return dest;\n}", "path": "coregrind\\m_libcbase.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Returns the base-2 logarithm of x.  Returns -1 if x is not a power\n   of two. */\n", "func_signal": "Int VG_(log2) ( UInt x )", "code": "{\n   Int i;\n   /* Any more than 32 and we overflow anyway... */\n   for (i = 0; i < 32; i++) {\n      if ((1U << i) == x) return i;\n   }\n   return -1;\n}", "path": "coregrind\\m_libcbase.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Copy bytes, not overrunning the end of dest and always ensuring\n   zero termination. */\n", "func_signal": "void VG_(strncpy_safely) ( Char* dest, const Char* src, SizeT ndest )", "code": "{\n   SizeT i = 0;\n   while (True) {\n      dest[i] = 0;\n      if (src[i] == 0) return;\n      if (i >= ndest-1) return;\n      dest[i] = src[i];\n      i++;\n   }\n}", "path": "coregrind\\m_libcbase.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Note that this is used for both sys_getprocs and sys_getprocs64.  I\n   think that's correct - from the man page, the calling conventions\n   look identical. */\n", "func_signal": "PRE(sys_getprocs)", "code": "{\n   PRINT(\"getprocs ( %#lx, %ld, %#lx, %ld, %#lx, %ld )\",\n         ARG1, ARG2, ARG3, ARG4, ARG5, ARG6 );\n   PRE_REG_READ6(int, \"getprocs\", \n                 void*, processbuffer, long, processize, \n                 void*, filebuffer, long, filesize,\n                 void*, indexpointer, long, count);\n\n   /* (processbuffer, processsize, filebuffer, filesize,\n      indexpointer, count) */\n   PRE_MEM_READ( \"getprocs(IndexPointer)\", ARG5, sizeof(UInt) );\n   if (ARG1)\n      PRE_MEM_WRITE( \"getprocs(ProcessBuffer)\", ARG1, ARG2 * ARG6 );\n   if (ARG3)\n      PRE_MEM_WRITE( \"getprocs(FileBuffer)\", ARG3, ARG4 * ARG6 );\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/**\n * DRD's handler for Valgrind client requests. The code below handles both\n * DRD's public and tool-internal client requests.\n */\n", "func_signal": "static Bool handle_client_request(ThreadId vg_tid, UWord* arg, UWord* ret)", "code": "{\n   UWord result = 0;\n   const DrdThreadId drd_tid = DRD_(thread_get_running_tid)();\n\n   tl_assert(vg_tid == VG_(get_running_tid()));\n   tl_assert(DRD_(VgThreadIdToDrdThreadId)(vg_tid) == drd_tid);\n\n   switch (arg[0])\n   {\n   case VG_USERREQ__MALLOCLIKE_BLOCK:\n      if (arg[1])\n         DRD_(malloclike_block)(vg_tid, arg[1]/*addr*/, arg[2]/*size*/);\n      break;\n\n   case VG_USERREQ__FREELIKE_BLOCK:\n      if (arg[1] && ! DRD_(freelike_block)(vg_tid, arg[1]/*addr*/))\n      {\n         GenericErrInfo GEI = {\n\t    .tid = DRD_(thread_get_running_tid)(),\n\t    .addr = 0,\n\t };\n         VG_(maybe_record_error)(vg_tid,\n                                 GenericErr,\n                                 VG_(get_IP)(vg_tid),\n                                 \"Invalid VG_USERREQ__FREELIKE_BLOCK request\",\n                                 &GEI);\n      }\n      break;\n\n   case VG_USERREQ__DRD_GET_VALGRIND_THREAD_ID:\n      result = vg_tid;\n      break;\n\n   case VG_USERREQ__DRD_GET_DRD_THREAD_ID:\n      result = drd_tid;\n      break;\n\n   case VG_USERREQ__DRD_SET_THREAD_NAME:\n      DRD_(thread_set_name)(drd_tid, (const char*)arg[1]);\n      break;\n\n   case VG_USERREQ__DRD_START_SUPPRESSION:\n      DRD_(start_suppression)(arg[1], arg[1] + arg[2], \"client\");\n      break;\n\n   case VG_USERREQ__DRD_FINISH_SUPPRESSION:\n      DRD_(finish_suppression)(arg[1], arg[1] + arg[2]);\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_HAPPENS_BEFORE:\n      DRD_(hb_happens_before)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_HAPPENS_AFTER:\n      DRD_(hb_happens_after)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_RWLOCK_CREATE:\n      if (arg[1])\n      {\n         struct mutex_info* const mutex_p = DRD_(mutex_get)(arg[1]);\n         if (mutex_p && mutex_p->mutex_type == mutex_type_spinlock)\n            break;\n      }\n      DRD_(rwlock_pre_init)(arg[1], user_rwlock);\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_RWLOCK_DESTROY:\n      if (arg[1])\n      {\n         struct mutex_info* const mutex_p = DRD_(mutex_get)(arg[1]);\n         if (mutex_p && mutex_p->mutex_type == mutex_type_spinlock)\n            break;\n      }\n      DRD_(rwlock_post_destroy)(arg[1], user_rwlock);\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_RWLOCK_ACQUIRED:\n      if (arg[1])\n      {\n         struct mutex_info* const mutex_p = DRD_(mutex_get)(arg[1]);\n         if (mutex_p && mutex_p->mutex_type == mutex_type_spinlock)\n            break;\n      }\n      tl_assert(arg[2] == !! arg[2]);\n      if (arg[2])\n      {\n         DRD_(rwlock_pre_wrlock)(arg[1], user_rwlock);\n         DRD_(rwlock_post_wrlock)(arg[1], user_rwlock, True);\n      }\n      else\n      {\n         DRD_(rwlock_pre_rdlock)(arg[1], user_rwlock);\n         DRD_(rwlock_post_rdlock)(arg[1], user_rwlock, True);\n      }\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATE_RWLOCK_RELEASED:\n      if (arg[1])\n      {\n         struct mutex_info* const mutex_p = DRD_(mutex_get)(arg[1]);\n         if (mutex_p && mutex_p->mutex_type == mutex_type_spinlock)\n            break;\n      }\n      tl_assert(arg[2] == !! arg[2]);\n      DRD_(rwlock_pre_unlock)(arg[1], user_rwlock);\n      break;\n\n   case VG_USERREQ__SET_PTHREAD_COND_INITIALIZER:\n      DRD_(pthread_cond_initializer) = (Addr)arg[1];\n      DRD_(pthread_cond_initializer_size) = arg[2];\n      break;\n\n   case VG_USERREQ__DRD_START_NEW_SEGMENT:\n      DRD_(thread_new_segment)(DRD_(PtThreadIdToDrdThreadId)(arg[1]));\n      break;\n\n   case VG_USERREQ__DRD_START_TRACE_ADDR:\n      DRD_(start_tracing_address_range)(arg[1], arg[1] + arg[2]);\n      break;\n\n   case VG_USERREQ__DRD_STOP_TRACE_ADDR:\n      DRD_(stop_tracing_address_range)(arg[1], arg[1] + arg[2]);\n      break;\n\n   case VG_USERREQ__DRD_RECORD_LOADS:\n      DRD_(thread_set_record_loads)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__DRD_RECORD_STORES:\n      DRD_(thread_set_record_stores)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__SET_PTHREADID:\n      // pthread_self() returns 0 for programs not linked with libpthread.so.\n      if (arg[1] != INVALID_POSIX_THREADID)\n         DRD_(thread_set_pthreadid)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__SET_JOINABLE:\n      DRD_(thread_set_joinable)(DRD_(PtThreadIdToDrdThreadId)(arg[1]),\n                                (Bool)arg[2]);\n      break;\n\n   case VG_USERREQ__ENTERING_PTHREAD_CREATE:\n      DRD_(thread_entering_pthread_create)(drd_tid);\n      break;\n\n   case VG_USERREQ__LEFT_PTHREAD_CREATE:\n      DRD_(thread_left_pthread_create)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_THREAD_JOIN:\n   {\n      const DrdThreadId thread_to_join = DRD_(PtThreadIdToDrdThreadId)(arg[1]);\n      if (thread_to_join == DRD_INVALID_THREADID)\n      {\n         InvalidThreadIdInfo ITI = { DRD_(thread_get_running_tid)(), arg[1] };\n         VG_(maybe_record_error)(vg_tid,\n                                 InvalidThreadId,\n                                 VG_(get_IP)(vg_tid),\n                                 \"pthread_join(): invalid thread ID\",\n                                 &ITI);\n      }\n      else\n      {\n         DRD_(thread_post_join)(drd_tid, thread_to_join);\n      }\n      break;\n   }\n\n   case VG_USERREQ__PRE_THREAD_CANCEL:\n   {\n      const DrdThreadId thread_to_cancel =DRD_(PtThreadIdToDrdThreadId)(arg[1]);\n      if (thread_to_cancel == DRD_INVALID_THREADID)\n      {\n         InvalidThreadIdInfo ITI = { DRD_(thread_get_running_tid)(), arg[1] };\n         VG_(maybe_record_error)(vg_tid,\n                                 InvalidThreadId,\n                                 VG_(get_IP)(vg_tid),\n                                 \"pthread_cancel(): invalid thread ID\",\n                                 &ITI);\n      }\n      else\n      {\n         DRD_(thread_pre_cancel)(thread_to_cancel);\n      }\n      break;\n   }\n\n   case VG_USERREQ__POST_THREAD_CANCEL:\n      break;\n\n   case VG_USERREQ__PRE_MUTEX_INIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(mutex_init)(arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__POST_MUTEX_INIT:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_MUTEX_DESTROY:\n      DRD_(thread_enter_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_MUTEX_DESTROY:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(mutex_post_destroy)(arg[1]);\n      break;\n\n   case VG_USERREQ__PRE_MUTEX_LOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(mutex_pre_lock)(arg[1], arg[2], arg[3]);\n      break;\n\n   case VG_USERREQ__POST_MUTEX_LOCK:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(mutex_post_lock)(arg[1], arg[2], False/*post_cond_wait*/);\n      break;\n\n   case VG_USERREQ__PRE_MUTEX_UNLOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(mutex_unlock)(arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__POST_MUTEX_UNLOCK:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_SPIN_INIT_OR_UNLOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(spinlock_init_or_unlock)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_SPIN_INIT_OR_UNLOCK:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_COND_INIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(cond_pre_init)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_COND_INIT:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_COND_DESTROY:\n      DRD_(thread_enter_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_COND_DESTROY:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(cond_post_destroy)(arg[1]);\n      break;\n\n   case VG_USERREQ__PRE_COND_WAIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n      {\n         const Addr cond = arg[1];\n         const Addr mutex = arg[2];\n         const MutexT mutex_type = arg[3];\n         DRD_(mutex_unlock)(mutex, mutex_type);\n         DRD_(cond_pre_wait)(cond, mutex);\n      }\n      break;\n\n   case VG_USERREQ__POST_COND_WAIT:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n      {\n         const Addr cond = arg[1];\n         const Addr mutex = arg[2];\n         const Bool took_lock = arg[3];\n         DRD_(cond_post_wait)(cond);\n         DRD_(mutex_post_lock)(mutex, took_lock, True);\n      }\n      break;\n\n   case VG_USERREQ__PRE_COND_SIGNAL:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(cond_pre_signal)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_COND_SIGNAL:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_COND_BROADCAST:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(cond_pre_broadcast)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_COND_BROADCAST:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_SEM_INIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(semaphore_init)(arg[1], arg[2], arg[3]);\n      break;\n\n   case VG_USERREQ__POST_SEM_INIT:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_SEM_DESTROY:\n      DRD_(thread_enter_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_SEM_DESTROY:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(semaphore_destroy)(arg[1]);\n      break;\n\n   case VG_USERREQ__PRE_SEM_OPEN:\n      DRD_(thread_enter_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_SEM_OPEN:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(semaphore_open)(arg[1], (Char*)arg[2], arg[3], arg[4], arg[5]);\n      break;\n\n   case VG_USERREQ__PRE_SEM_CLOSE:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(semaphore_close)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_SEM_CLOSE:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_SEM_WAIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(semaphore_pre_wait)(arg[1]);\n      break;\n\n   case VG_USERREQ__POST_SEM_WAIT:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(semaphore_post_wait)(drd_tid, arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__PRE_SEM_POST:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(semaphore_pre_post)(drd_tid, arg[1]);\n      break;\n\n   case VG_USERREQ__POST_SEM_POST:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(semaphore_post_post)(drd_tid, arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__PRE_BARRIER_INIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(barrier_init)(arg[1], arg[2], arg[3], arg[4]);\n      break;\n\n   case VG_USERREQ__POST_BARRIER_INIT:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__PRE_BARRIER_DESTROY:\n      DRD_(thread_enter_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__POST_BARRIER_DESTROY:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(barrier_destroy)(arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__PRE_BARRIER_WAIT:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(barrier_pre_wait)(drd_tid, arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__POST_BARRIER_WAIT:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(barrier_post_wait)(drd_tid, arg[1], arg[2], arg[3], arg[4]);\n      break;\n\n   case VG_USERREQ__PRE_RWLOCK_INIT:\n      DRD_(rwlock_pre_init)(arg[1], pthread_rwlock);\n      break;\n\n   case VG_USERREQ__POST_RWLOCK_DESTROY:\n      DRD_(rwlock_post_destroy)(arg[1], pthread_rwlock);\n      break;\n\n   case VG_USERREQ__PRE_RWLOCK_RDLOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(rwlock_pre_rdlock)(arg[1], pthread_rwlock);\n      break;\n\n   case VG_USERREQ__POST_RWLOCK_RDLOCK:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(rwlock_post_rdlock)(arg[1], pthread_rwlock, arg[2]);\n      break;\n\n   case VG_USERREQ__PRE_RWLOCK_WRLOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(rwlock_pre_wrlock)(arg[1], pthread_rwlock);\n      break;\n\n   case VG_USERREQ__POST_RWLOCK_WRLOCK:\n      if (DRD_(thread_leave_synchr)(drd_tid) == 0)\n         DRD_(rwlock_post_wrlock)(arg[1], pthread_rwlock, arg[2]);\n      break;\n\n   case VG_USERREQ__PRE_RWLOCK_UNLOCK:\n      if (DRD_(thread_enter_synchr)(drd_tid) == 0)\n         DRD_(rwlock_pre_unlock)(arg[1], pthread_rwlock);\n      break;\n\n   case VG_USERREQ__POST_RWLOCK_UNLOCK:\n      DRD_(thread_leave_synchr)(drd_tid);\n      break;\n\n   case VG_USERREQ__DRD_CLEAN_MEMORY:\n      if (arg[2] > 0)\n         DRD_(clean_memory)(arg[1], arg[2]);\n      break;\n\n   case VG_USERREQ__HELGRIND_ANNOTATION_UNIMP:\n      {\n         /* Note: it is assumed below that the text arg[1] points to is never\n          * freed, e.g. because it points to static data.\n          */\n         UnimpClReqInfo UICR =\n            { DRD_(thread_get_running_tid)(), (Char*)arg[1] };\n         VG_(maybe_record_error)(vg_tid,\n                                 UnimpHgClReq,\n                                 VG_(get_IP)(vg_tid),\n                                 \"\",\n                                 &UICR);\n      }\n      break;\n\n   case VG_USERREQ__DRD_ANNOTATION_UNIMP:\n      {\n         /* Note: it is assumed below that the text arg[1] points to is never\n          * freed, e.g. because it points to static data.\n          */\n         UnimpClReqInfo UICR =\n            { DRD_(thread_get_running_tid)(), (Char*)arg[1] };\n         VG_(maybe_record_error)(vg_tid,\n                                 UnimpDrdClReq,\n                                 VG_(get_IP)(vg_tid),\n                                 \"\",\n                                 &UICR);\n      }\n      break;\n\n   default:\n#if 0\n      VG_(message)(Vg_DebugMsg, \"Unrecognized client request 0x%lx 0x%lx\",\n                   arg[0], arg[1]);\n      tl_assert(0);\n#endif\n      return False;\n   }\n\n   *ret = result;\n   return True;\n}", "path": "drd\\drd_clientreq.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* --- !!! --- EXTERNAL HEADERS end --- !!! --- */\n", "func_signal": "HChar* ML_(aix5debugstuff_pc_to_fnname) ( Addr pc )", "code": "{\n   Bool ok;\n   static HChar name[100];\n   ok = VG_(get_fnname_w_offset)(pc, name, 100);\n   if (!ok) VG_(strcpy)(name, \"???\");\n   return &name[0];\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* not significant to libc */\n//  SET_STATUS_from_SysRes( r );\n//  return;\n", "func_signal": "PRE(sys___libc_sbrk)", "code": "{\n   PRINT(\"__libc_sbrk (BOGUS HANDLER)( %#lx )\",ARG1);\n   PRE_REG_READ1(long, \"__libc_sbrk\", long, arg1);\n   /* After a zero sbrk, disallow aspacem from doing sbrk, since libc\n      might rely on the value returned by this syscall. */\n   /* 1 Oct 06: not currently used (aspacemgr-aix5.c ignores it) */\n   VG_(am_aix5_sbrk_allowed) = toBool(ARG1 != 0);\n   /* Disallow libc from moving the brk backwards as that might trash\n      SkPreAlloc sections acquired by aspacem from previous uses of\n      sbrk. */\n   if (ARG1 < 0)\n      ARG1 = 0;\n   /* Do this as a sync syscall, so the sbrk_allowed flag gets turned\n      back on ASAP.  Typically libc does sbrk(0) and then sbrk(x > 0)\n      in quick succession.  Although surely it should hold some kind\n      of lock at that point, else it cannot safely use the result from\n      the first sbrk call to influence the second one? */\n   *flags &= ~SfMayBlock;\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Add a register to a usage table.  Combine incoming read uses with\n   existing write uses into a modify use, and vice versa.  Do not\n   create duplicate entries -- each reg should only be mentioned once.  \n*/\n", "func_signal": "void addHRegUse ( HRegUsage* tab, HRegMode mode, HReg reg )", "code": "{\n   Int i;\n   /* Find it ... */\n   for (i = 0; i < tab->n_used; i++)\n      if (tab->hreg[i] == reg)\n         break;\n   if (i == tab->n_used) {\n      /* Not found, add new entry. */\n      vassert(tab->n_used < N_HREG_USAGE);\n      tab->hreg[tab->n_used] = reg;\n      tab->mode[tab->n_used] = mode;\n      tab->n_used++;\n   } else {\n      /* Found: combine or ignore. */\n      /* This is a greatest-lower-bound operation in the poset:\n\n            R   W\n             \\ /\n              M\n\n         Need to do: tab->mode[i] = GLB(tab->mode, mode).  In this\n         case very simple -- if tab->mode[i] != mode then result must\n         be M.\n      */\n      if (tab->mode[i] == mode) {\n         /* duplicate, ignore */\n      } else {\n         tab->mode[i] = HRmModify;\n      }\n   }\n}", "path": "VEX\\priv\\host_generic_regs.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* ---------------------------------------------------------------------\n   Char functions.\n   ------------------------------------------------------------------ */\n", "func_signal": "Bool VG_(isspace) ( Char c )", "code": "{\n   return (c == ' '  || c == '\\n' || c == '\\t' || \n           c == '\\f' || c == '\\v' || c == '\\r');\n}", "path": "coregrind\\m_libcbase.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Get and immediately print a StackTrace. */\n", "func_signal": "void VG_(get_and_pp_StackTrace) ( ThreadId tid, UInt max_n_ips )", "code": "{\n   Addr ips[max_n_ips];\n   UInt n_ips\n      = VG_(get_StackTrace)(tid, ips, max_n_ips,\n                            NULL/*array to dump SP values in*/,\n                            NULL/*array to dump FP values in*/,\n                            0/*first_ip_delta*/);\n   VG_(pp_StackTrace)(ips, n_ips);\n}", "path": "coregrind\\m_stacktrace.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Print a StackTrace. */\n", "func_signal": "void VG_(pp_StackTrace) ( StackTrace ips, UInt n_ips )", "code": "{\n   vg_assert( n_ips > 0 );\n\n   if (VG_(clo_xml))\n      VG_(printf_xml)(\"  <stack>\\n\");\n\n   VG_(apply_StackTrace)( printIpDesc, NULL, ips, n_ips );\n\n   if (VG_(clo_xml))\n      VG_(printf_xml)(\"  </stack>\\n\");\n}", "path": "coregrind\\m_stacktrace.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Allocate a stack for this thread, if it doesn't already have one.\n   They're allocated lazily, and never freed.  Returns the initial stack\n   pointer value to use, or 0 if allocation failed. */\n", "func_signal": "Addr ML_(allocstack)(ThreadId tid)", "code": "{\n   ThreadState* tst = VG_(get_ThreadState)(tid);\n   VgStack*     stack;\n   Addr         initial_SP;\n\n   /* Either the stack_base and stack_init_SP are both zero (in which\n      case a stack hasn't been allocated) or they are both non-zero,\n      in which case it has. */\n\n   if (tst->os_state.valgrind_stack_base == 0)\n      vg_assert(tst->os_state.valgrind_stack_init_SP == 0);\n\n   if (tst->os_state.valgrind_stack_base != 0)\n      vg_assert(tst->os_state.valgrind_stack_init_SP != 0);\n\n   /* If no stack is present, allocate one. */\n   if (tst->os_state.valgrind_stack_base == 0) {\n      stack = VG_(am_alloc_VgStack)( &initial_SP );\n      if (stack) {\n         /* Leave some space above SP because AIX's ABI stores\n            stuff there. */\n         initial_SP -= 256;\n         vg_assert(initial_SP > (Addr)stack);\n         tst->os_state.valgrind_stack_base    = (Addr)stack;\n         tst->os_state.valgrind_stack_init_SP = initial_SP;\n      } else {\n         return 0; /* allocation of stack failed */\n      }\n   }\n\n   if (0)\n      VG_(printf)( \"stack for tid %d at %p; init_SP=%p\\n\",\n                   tid,\n                   (void*)tst->os_state.valgrind_stack_base,\n                   (void*)tst->os_state.valgrind_stack_init_SP );\n\n   return tst->os_state.valgrind_stack_init_SP;\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/*---------------------------------------------------------*/\n/*--- Abstract instructions                             ---*/\n/*---------------------------------------------------------*/\n", "func_signal": "HInstrArray* newHInstrArray ( void )", "code": "{\n   HInstrArray* ha = LibVEX_Alloc_HInstrArray();\n   ha->arr_size = 4;\n   ha->arr_used = 0;\n   ha->arr      = LibVEX_Alloc_Array_HInstr(ha->arr_size);\n   ha->n_vregs  = 0;\n   return ha;\n}", "path": "VEX\\priv\\host_generic_regs.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Do a printf-style operation on either the XML or normal output\n   channel, depending on the setting of VG_(clo_xml).\n*/\n", "func_signal": "static void emit_WRK ( HChar* format, va_list vargs )", "code": "{\n   if (VG_(clo_xml)) {\n      VG_(vprintf_xml)(format, vargs);\n   } else {\n      VG_(vmessage)(Vg_UserMsg, format, vargs);\n   }\n}", "path": "helgrind\\hg_errors.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/*---------------------------------------------------------*/\n/*--- Indicating register remappings (for reg-alloc)    ---*/\n/*---------------------------------------------------------*/\n", "func_signal": "void ppHRegRemap ( HRegRemap* map )", "code": "{\n   Int   i;\n   vex_printf(\"HRegRemap {\\n\");\n   for (i = 0; i < map->n_used; i++) {\n      vex_printf(\"   \");\n      ppHReg(map->orig[i]);\n      vex_printf(\"  -->  \");\n      ppHReg(map->replacement[i]);\n      vex_printf(\"\\n\");\n   }\n   vex_printf(\"}\\n\");\n}", "path": "VEX\\priv\\host_generic_regs.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* ---------------------------------------------------------------------\n   String functions\n   ------------------------------------------------------------------ */\n", "func_signal": "SizeT VG_(strlen) ( const Char* str )", "code": "{\n   SizeT i = 0;\n   while (str[i] != 0) i++;\n   return i;\n}", "path": "coregrind\\m_libcbase.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* __unload is handled in the platform-specific files. */\n", "func_signal": "PRE(sys__clock_settime)", "code": "{\n   PRINT(\"_clock_settime (UNDOCUMENTED) ( %ld, %#lx )\", ARG1, ARG2);\n   PRE_REG_READ2(int, \"_clock_settime\", int, arg1, int, arg2);\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Announce (that is, print the point-of-creation) of 'thr'.  Only do\n   this once, as we only want to see these announcements once per\n   thread.  Returned Bool indicates whether or not an announcement was\n   made.\n*/\n", "func_signal": "static Bool announce_one_thread ( Thread* thr )", "code": "{\n   tl_assert(HG_(is_sane_Thread)(thr));\n   tl_assert(thr->errmsg_index >= 1);\n   if (thr->announced)\n      return False;\n\n   if (VG_(clo_xml)) {\n\n      VG_(printf_xml)(\"<announcethread>\\n\");\n      VG_(printf_xml)(\"  <hthreadid>%d</hthreadid>\\n\", thr->errmsg_index);\n      if (thr->errmsg_index == 1) {\n         tl_assert(thr->created_at == NULL);\n         VG_(printf_xml)(\"  <isrootthread></isrootthread>\\n\");\n      } else {\n         tl_assert(thr->created_at != NULL);\n         VG_(pp_ExeContext)( thr->created_at );\n      }\n      VG_(printf_xml)(\"</announcethread>\\n\\n\");\n\n   } else {\n\n      if (thr->errmsg_index == 1) {\n         tl_assert(thr->created_at == NULL);\n         VG_(message)(Vg_UserMsg, \n                      \"Thread #%d is the program's root thread\\n\",\n                       thr->errmsg_index);\n      } else {\n         tl_assert(thr->created_at != NULL);\n         VG_(message)(Vg_UserMsg, \"Thread #%d was created\\n\",\n                                  thr->errmsg_index);\n         VG_(pp_ExeContext)( thr->created_at );\n      }\n      VG_(message)(Vg_UserMsg, \"\\n\");\n\n   }\n\n   thr->announced = True;\n   return True;\n}", "path": "helgrind\\hg_errors.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* If we know or believe a module load/unload event has happened, get\n   aspacem to re-read /proc/../map to update its picture of what text\n   and data segments are present.  This also notifies all the usual\n   parties that need to know about address space changes. */\n", "func_signal": "void ML_(aix5_rescan_procmap_after_load_or_unload) ( void )", "code": "{\n   AixCodeSegChange* changes;\n   Int changes_size, changes_used, i;\n\n   /* Find out how many AixCodeSegChange records we will need, and\n      acquire them. */\n   changes_size = VG_(am_aix5_reread_procmap_howmany_directives)(); \n   changes = VG_(arena_malloc)(VG_AR_CORE, \"syswrap-aix5.arpalou.1\",\n                               changes_size * sizeof(AixCodeSegChange));\n   vg_assert(changes);\n\n   /* Now re-read /proc/<pid>/map and acquire a change set */\n   VG_(am_aix5_reread_procmap)( changes, &changes_used );\n   vg_assert(changes_used >= 0 && changes_used <= changes_size);\n\n   /* And notify all parties of the changes. */\n   for (i = 0; i < changes_used; i++) {\n      ULong di_handle = VG_(di_aix5_notify_segchange)(\n                           changes[i].code_start,\n                           changes[i].code_len,\n                           changes[i].data_start,\n                           changes[i].data_len,\n                           changes[i].file_name,\n                           changes[i].mem_name,\n                           changes[i].is_mainexe,\n                           changes[i].acquire\n                        );\n\n      if (changes[i].acquire) {\n         VG_TRACK( new_mem_mmap, \n                   changes[i].code_start, changes[i].code_len, \n                   /*r*/True, /*w*/False, /*x*/True, di_handle );\n         VG_TRACK( new_mem_mmap, \n                   changes[i].data_start, changes[i].data_len, \n                   /*r*/True, /*w*/True, /*x*/False, 0/*or di_handle?*/ );\n      } else {\n         VG_TRACK( die_mem_munmap, \n                   changes[i].code_start, changes[i].code_len );\n         VG_TRACK( die_mem_munmap, \n                   changes[i].data_start, changes[i].data_len );\n         VG_(discard_translations)(\n                   changes[i].code_start, changes[i].code_len,\n                   \"POST(sys___loadx/sys__kload)(code)\" );\n         VG_(discard_translations)(\n                    changes[i].data_start, changes[i].data_len,\n                   \"POST(sys___loadx/sys__kload)(data)\" );\n      }\n   }\n\n   VG_(arena_free)(VG_AR_CORE, changes);\n}", "path": "coregrind\\m_syswrap\\syswrap-aix5.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/* Generic printing for registers. */\n", "func_signal": "void ppHReg ( HReg r )", "code": "{\n   HChar* maybe_v = hregIsVirtual(r) ? \"v\" : \"\";\n   Int    regNo   = hregNumber(r);\n   switch (hregClass(r)) {\n      case HRcInt32:   vex_printf(\"%%%sr%d\", maybe_v, regNo); return;\n      case HRcInt64:   vex_printf(\"%%%sR%d\", maybe_v, regNo); return;\n      case HRcFlt32:   vex_printf(\"%%%sF%d\", maybe_v, regNo); return;\n      case HRcFlt64:   vex_printf(\"%%%sD%d\", maybe_v, regNo); return;\n      case HRcVec64:   vex_printf(\"%%%sv%d\", maybe_v, regNo); return;\n      case HRcVec128:  vex_printf(\"%%%sV%d\", maybe_v, regNo); return;\n      default: vpanic(\"ppHReg\");\n   }\n}", "path": "VEX\\priv\\host_generic_regs.c", "repo_name": "sos22/ppres", "stars": 4, "license": "other", "language": "c", "size": 7828}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_f_4dnet_15__addr_ip4_iter___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  PyObject *__pyx_v_cur = 0;\n  PyObject *__pyx_v_max = 0;\n  int __pyx_r;\n  unsigned long __pyx_1;\n  static char *__pyx_argnames[] = {\"cur\",\"max\",0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"OO\", __pyx_argnames, &__pyx_v_cur, &__pyx_v_max)) return -1;\n  Py_INCREF(__pyx_v_self);\n  Py_INCREF(__pyx_v_cur);\n  Py_INCREF(__pyx_v_max);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":629 */\n  __pyx_1 = PyInt_AsUnsignedLongMask(__pyx_v_cur); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; goto __pyx_L1;}\n  ((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->cur = ntohl(__pyx_1);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":630 */\n  __pyx_1 = PyInt_AsUnsignedLongMask(__pyx_v_max); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 630; goto __pyx_L1;}\n  ((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->max = ntohl(__pyx_1);\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1:;\n  __Pyx_AddTraceback(\"dnet.__addr_ip4_iter.__init__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  Py_DECREF(__pyx_v_cur);\n  Py_DECREF(__pyx_v_max);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_f_4dnet_4intf___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  int __pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return -1;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":977 */\n  ((struct __pyx_obj_4dnet_intf *)__pyx_v_self)->intf = intf_open();\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":978 */\n  __pyx_1 = (!(((struct __pyx_obj_4dnet_intf *)__pyx_v_self)->intf != 0));\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":979 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_OSError); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; goto __pyx_L1;}\n    __pyx_3 = __pyx_f_4dnet___oserror(); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, __pyx_3, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    Py_DECREF(__pyx_3); __pyx_3 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 979; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  __Pyx_AddTraceback(\"dnet.intf.__init__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_f_4dnet_2ip___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  int __pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return -1;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":248 */\n  ((struct __pyx_obj_4dnet_ip *)__pyx_v_self)->ip = ip_open();\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":249 */\n  __pyx_1 = (!(((struct __pyx_obj_4dnet_ip *)__pyx_v_self)->ip != 0));\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":250 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_OSError); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; goto __pyx_L1;}\n    __pyx_3 = __pyx_f_4dnet___oserror(); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, __pyx_3, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    Py_DECREF(__pyx_3); __pyx_3 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  __Pyx_AddTraceback(\"dnet.ip.__init__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_13__rand_xrange___iter__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1436 */\n  ((struct __pyx_obj_4dnet___rand_xrange *)__pyx_v_self)->cur = 0;\n  ((struct __pyx_obj_4dnet___rand_xrange *)__pyx_v_self)->enc = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1438 */\n  Py_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  __Pyx_AddTraceback(\"dnet.__rand_xrange.__iter__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_3tun_4name___get__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r;\n  PyObject *__pyx_1 = 0;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1500 */\n  __pyx_1 = PyString_FromString(tun_name(((struct __pyx_obj_4dnet_tun *)__pyx_v_self)->tun)); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1500; goto __pyx_L1;}\n  __pyx_r = __pyx_1;\n  __pyx_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  __Pyx_AddTraceback(\"dnet.tun.name.__get__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_f_4dnet_4addr_3ip6___set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value)", "code": "{\n  int __pyx_r;\n  PyObject *__pyx_1 = 0;\n  PyObject *__pyx_2 = 0;\n  int __pyx_3;\n  unsigned short __pyx_4;\n  Py_INCREF(__pyx_v_self);\n  Py_INCREF(__pyx_v_value);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":523 */\n  __pyx_1 = PyInt_FromLong(PyString_Size(__pyx_v_value)); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; goto __pyx_L1;}\n  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_IP6_ADDR_LEN); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; goto __pyx_L1;}\n  if (PyObject_Cmp(__pyx_1, __pyx_2, &__pyx_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; goto __pyx_L1;}\n  __pyx_3 = __pyx_3 != 0;\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  if (__pyx_3) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":524 */\n    __pyx_1 = __Pyx_GetName(__pyx_b, __pyx_n_ValueError); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_1, __pyx_k71p, 0);\n    Py_DECREF(__pyx_1); __pyx_1 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":525 */\n  __pyx_2 = __pyx_f_4dnet___memcpy(((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_data8,__pyx_v_value,16); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; goto __pyx_L1;}\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":526 */\n  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_n_ADDR_TYPE_IP6); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 526; goto __pyx_L1;}\n  __pyx_4 = PyInt_AsLong(__pyx_1); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 526; goto __pyx_L1;}\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  ((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_type = __pyx_4;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":527 */\n  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_IP6_ADDR_BITS); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 527; goto __pyx_L1;}\n  __pyx_4 = PyInt_AsLong(__pyx_2); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 527; goto __pyx_L1;}\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  ((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_bits = __pyx_4;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.addr.ip6.__set__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  Py_DECREF(__pyx_v_value);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/* XXX - aliases on IRIX don't show up in SIOCGIFCONF */\n", "func_signal": "static int\n_intf_get_aliases(intf_t *intf, struct intf_entry *entry)", "code": "{\n\tstruct dnet_ifaliasreq ifra;\n\tstruct addr *ap, *lap;\n\t\n\tstrlcpy(ifra.ifra_name, entry->intf_name, sizeof(ifra.ifra_name));\n\taddr_ntos(&entry->intf_addr, &ifra.ifra_addr);\n\taddr_btos(entry->intf_addr.addr_bits, &ifra.ifra_mask);\n\tmemset(&ifra.ifra_brdaddr, 0, sizeof(ifra.ifra_brdaddr));\n\tifra.ifra_cookie = 1;\n\n\tap = entry->intf_alias_addrs;\n\tlap = (struct addr *)((u_char *)entry + entry->intf_len);\n\t\n\twhile (ioctl(intf->fd, SIOCLIFADDR, &ifra) == 0 &&\n\t    ifra.ifra_cookie > 0 && (ap + 1) < lap) {\n\t\tif (addr_ston(&ifra.ifra_addr, ap) < 0)\n\t\t\tbreak;\n\t\tap++, entry->intf_alias_num++;\n\t}\n\tentry->intf_len = (u_char *)ap - (u_char *)entry;\n\t\n\treturn (0);\n}", "path": "src\\intf.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*\n  <op> <dir> on <device> all\n  <op> <dir> on <device> proto <proto> all\n  <op> <dir> on <device> proto <proto> from <src> [ports] to <dst> [ports]\n  <op> <dir> on <device> proto icmp all [icmp-type <type> [code <code>]]\n  <op> <dir> on <device> proto icmp from <src> to <dst> [icmp-type <type> [code <code>]]\n*/\n", "func_signal": "static int\nparse_rule(char *str, struct fw_rule *rule)", "code": "{\n\tchar *p, *q;\n\t\n\tmemset(rule, 0, sizeof(*rule));\n\t\n\t/* action */\n\tp = strsep(&str, \" \");\n\tif (strcmp(p, \"block\") == 0)\n\t\trule->fw_op = FW_OP_BLOCK;\n\telse if (strcmp(p, \"pass\") == 0)\n\t\trule->fw_op = FW_OP_ALLOW;\n\telse return (-1);\n\t\n\t/* direction */\n\tp = strsep(&str, \" \");\n\tif (strcmp(p, \"in\") == 0)\n\t\trule->fw_dir = FW_DIR_IN;\n\telse if (strcmp(p, \"out\") == 0)\n\t\trule->fw_dir = FW_DIR_OUT;\n\telse return (-1);\n\n\t/* device */\n\tif (strcmp(strsep(&str, \" \"), \"on\") != 0)\n\t\treturn (-1);\n\tp = strsep(&str, \" \");\n\t/* XXX - handle bug in pktfltsrv.c */\n\tif ((q = strstr(p, \"proto\")) != NULL)\n\t\t*q = '\\0';\n\tif (strcmp(p, \"all\") != 0)\n\t\tstrlcpy(rule->fw_device, p, sizeof(rule->fw_device));\n\t\n\t/* proto */\n\tp = strsep(&str, \" \");\n\t/* XXX - handle bug in pktfltsrv.c */\n\tif (strcmp(p, \"proto\") == 0)\n\t\tp = strsep(&str, \" \");\n\t/* XXX - handle default rules */\n\tif (strcmp(p, \"all\") == 0)\n\t\treturn (0);\n\tif (strcmp(p, \"icmp\") == 0)\n\t\trule->fw_proto = IP_PROTO_ICMP;\n\telse if (strcmp(p, \"tcp\") == 0)\n\t\trule->fw_proto = IP_PROTO_TCP;\n\telse if (strcmp(p, \"udp\") == 0)\n\t\trule->fw_proto = IP_PROTO_UDP;\n\telse rule->fw_proto = atoi(p);\n\t\n\t/* source */\n\tp = strsep(&str, \" \");\n\tif (strcmp(p, \"all\") == 0)\n\t\treturn (0);\n\tif (strcmp(p, \"from\") != 0)\n\t\tgoto icmp_type_code;\n\tp = strsep(&str, \" \");\n\tif (parse_addr(p, &rule->fw_src) < 0)\n\t\treturn (-1);\n\t\n\t/* source port */\n\tp = strsep(&str, \" \");\n\tif (strcmp(p, \"port\") == 0) {\n\t\tif ((p = strstr(str, \" to \")) == NULL)\n\t\t\treturn (-1);\n\t\t*p++ = '\\0';\n\t\tif (parse_portspec(str, rule->fw_sport) < 0)\n\t\t\treturn (-1);\n\t\tstr = p + 3;\n\t} else if (strcmp(p, \"to\") != 0)\n\t\treturn (-1);\n\t\n\t/* destination */\n\tp = strsep(&str, \" \");\n\tif (parse_addr(p, &rule->fw_dst) < 0)\n\t\treturn (-1);\n\n\t/* destination port */\n\tp = strsep(&str, \" \");\n\tif (strcmp(p, \"port\") == 0)\n\t\treturn (parse_portspec(str, rule->fw_dport));\n\n icmp_type_code:\n\t/* icmp-type, code */\n\tif (strcmp(p, \"icmp-type\") == 0) {\n\t\tif (parse_icmpspec(str, rule->fw_sport, rule->fw_dport) < 0)\n\t\t\treturn (-1);\n\t}\n\treturn (0);\n}", "path": "src\\fw-pktfilter.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4addr_3ip6___get__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r;\n  PyObject *__pyx_1 = 0;\n  PyObject *__pyx_2 = 0;\n  int __pyx_3;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":518 */\n  __pyx_1 = PyInt_FromLong(((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_type); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; goto __pyx_L1;}\n  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_ADDR_TYPE_IP6); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; goto __pyx_L1;}\n  if (PyObject_Cmp(__pyx_1, __pyx_2, &__pyx_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; goto __pyx_L1;}\n  __pyx_3 = __pyx_3 != 0;\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  if (__pyx_3) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":519 */\n    __pyx_1 = __Pyx_GetName(__pyx_b, __pyx_n_ValueError); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_1, __pyx_k70p, 0);\n    Py_DECREF(__pyx_1); __pyx_1 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":520 */\n  __pyx_2 = PyString_FromStringAndSize(((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_data8,16); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 520; goto __pyx_L1;}\n  __pyx_r = __pyx_2;\n  __pyx_2 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.addr.ip6.__get__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static void __pyx_f_4dnet_3arp___dealloc__(PyObject *__pyx_v_self)", "code": "{\n  int __pyx_1;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":757 */\n  __pyx_1 = (((struct __pyx_obj_4dnet_arp *)__pyx_v_self)->arp != 0);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":758 */\n    arp_close(((struct __pyx_obj_4dnet_arp *)__pyx_v_self)->arp);\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  goto __pyx_L0;\n  __pyx_L1:;\n  __Pyx_AddTraceback(\"dnet.arp.__dealloc__\");\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4intf___iter__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_v_l;\n  PyObject *__pyx_r;\n  PyObject *__pyx_1 = 0;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  Py_INCREF(__pyx_v_self);\n  __pyx_v_l = Py_None; Py_INCREF(Py_None);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1052 */\n  __pyx_1 = PyList_New(0); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1052; goto __pyx_L1;}\n  Py_DECREF(__pyx_v_l);\n  __pyx_v_l = __pyx_1;\n  __pyx_1 = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1053 */\n  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_loop); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; goto __pyx_L1;}\n  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n___iter_append); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; goto __pyx_L1;}\n  __pyx_3 = PyTuple_New(2); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; goto __pyx_L1;}\n  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_2);\n  Py_INCREF(__pyx_v_l);\n  PyTuple_SET_ITEM(__pyx_3, 1, __pyx_v_l);\n  __pyx_2 = 0;\n  __pyx_2 = PyObject_Call(__pyx_1, __pyx_3, 0); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1053; goto __pyx_L1;}\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_3); __pyx_3 = 0;\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1054 */\n  __pyx_1 = __Pyx_GetName(__pyx_b, __pyx_n_iter); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1054; goto __pyx_L1;}\n  __pyx_3 = PyTuple_New(1); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1054; goto __pyx_L1;}\n  Py_INCREF(__pyx_v_l);\n  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_l);\n  __pyx_2 = PyObject_Call(__pyx_1, __pyx_3, 0); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1054; goto __pyx_L1;}\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_3); __pyx_3 = 0;\n  __pyx_r = __pyx_2;\n  __pyx_2 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  __Pyx_AddTraceback(\"dnet.intf.__iter__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_l);\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4addr___add__(PyObject *__pyx_v_self, PyObject *__pyx_v_other)", "code": "{\n  PyObject *__pyx_v_x;\n  PyObject *__pyx_v_y;\n  PyObject *__pyx_v_z;\n  PyObject *__pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  PyObject *__pyx_4 = 0;\n  unsigned long __pyx_5;\n  Py_INCREF(__pyx_v_self);\n  Py_INCREF(__pyx_v_other);\n  __pyx_v_x = Py_None; Py_INCREF(Py_None);\n  __pyx_v_y = Py_None; Py_INCREF(Py_None);\n  __pyx_v_z = Py_None; Py_INCREF(Py_None);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":543 */\n  __pyx_1 = PyInt_Check(__pyx_v_self);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":544 */\n    __pyx_2 = __pyx_v_other;\n    Py_INCREF(__pyx_2);\n    __pyx_3 = __pyx_v_self;\n    Py_INCREF(__pyx_3);\n    Py_DECREF(__pyx_v_x);\n    __pyx_v_x = __pyx_2;\n    __pyx_2 = 0;\n    Py_DECREF(__pyx_v_y);\n    __pyx_v_y = __pyx_3;\n    __pyx_3 = 0;\n    goto __pyx_L2;\n  }\n  __pyx_1 = PyInt_Check(__pyx_v_other);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":546 */\n    __pyx_2 = __pyx_v_self;\n    Py_INCREF(__pyx_2);\n    __pyx_3 = __pyx_v_other;\n    Py_INCREF(__pyx_3);\n    Py_DECREF(__pyx_v_x);\n    __pyx_v_x = __pyx_2;\n    __pyx_2 = 0;\n    Py_DECREF(__pyx_v_y);\n    __pyx_v_y = __pyx_3;\n    __pyx_3 = 0;\n    goto __pyx_L2;\n  }\n  /*else*/ {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":548 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_NotImplementedError); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 548; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, 0, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 548; goto __pyx_L1;}\n  }\n  __pyx_L2:;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":549 */\n  __pyx_3 = PyObject_GetAttr(__pyx_v_x, __pyx_n___copy__); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; goto __pyx_L1;}\n  __pyx_2 = PyTuple_New(0); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; goto __pyx_L1;}\n  __pyx_4 = PyObject_Call(__pyx_3, __pyx_2, 0); if (!__pyx_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; goto __pyx_L1;}\n  Py_DECREF(__pyx_3); __pyx_3 = 0;\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  Py_DECREF(__pyx_v_z);\n  __pyx_v_z = __pyx_4;\n  __pyx_4 = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":550 */\n  __pyx_3 = PyLong_FromUnsignedLong(ntohl(((struct __pyx_obj_4dnet_addr *)__pyx_v_x)->_addr.addr_ip)); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; goto __pyx_L1;}\n  __pyx_2 = PyNumber_Add(__pyx_3, __pyx_v_y); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; goto __pyx_L1;}\n  Py_DECREF(__pyx_3); __pyx_3 = 0;\n  __pyx_5 = PyInt_AsUnsignedLongMask(__pyx_2); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 550; goto __pyx_L1;}\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  ((struct __pyx_obj_4dnet_addr *)__pyx_v_z)->_addr.addr_ip = htonl(__pyx_5);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":551 */\n  Py_INCREF(__pyx_v_z);\n  __pyx_r = __pyx_v_z;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  Py_XDECREF(__pyx_4);\n  __Pyx_AddTraceback(\"dnet.addr.__add__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_x);\n  Py_DECREF(__pyx_v_y);\n  Py_DECREF(__pyx_v_z);\n  Py_DECREF(__pyx_v_self);\n  Py_DECREF(__pyx_v_other);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4addr___copy__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  PyObject *__pyx_v_a;\n  PyObject *__pyx_r;\n  PyObject *__pyx_1 = 0;\n  PyObject *__pyx_2 = 0;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return 0;\n  Py_INCREF(__pyx_v_self);\n  __pyx_v_a = Py_None; Py_INCREF(Py_None);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":554 */\n  __pyx_1 = PyTuple_New(0); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 554; goto __pyx_L1;}\n  __pyx_2 = PyObject_Call(((PyObject*)__pyx_ptype_4dnet_addr), __pyx_1, 0); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 554; goto __pyx_L1;}\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_v_a);\n  __pyx_v_a = __pyx_2;\n  __pyx_2 = 0;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":555 */\n  ((struct __pyx_obj_4dnet_addr *)__pyx_v_a)->_addr = ((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":556 */\n  Py_INCREF(__pyx_v_a);\n  __pyx_r = __pyx_v_a;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.addr.__copy__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_a);\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/* !HAVE_LINUX_PROCFS */\n", "func_signal": "intf_t *\nintf_close(intf_t *intf)", "code": "{\n\tif (intf != NULL) {\n\t\tif (intf->fd >= 0)\n\t\t\tclose(intf->fd);\n\t\tif (intf->fd6 >= 0)\n\t\t\tclose(intf->fd6);\n\t\tfree(intf);\n\t}\n\treturn (NULL);\n}", "path": "src\\intf.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_ip_cksum_add(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  PyObject *__pyx_v_buf = 0;\n  int __pyx_v_sum;\n  char (*__pyx_v_p);\n  int __pyx_v_n;\n  PyObject *__pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  static char *__pyx_argnames[] = {\"buf\",\"sum\",0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"Oi\", __pyx_argnames, &__pyx_v_buf, &__pyx_v_sum)) return 0;\n  Py_INCREF(__pyx_v_buf);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":312 */\n  __pyx_1 = (PyObject_AsReadBuffer(__pyx_v_buf,(&__pyx_v_p),(&__pyx_v_n)) == 0);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":313 */\n    __pyx_2 = PyInt_FromLong(ip_cksum_add(__pyx_v_p,__pyx_v_n,__pyx_v_sum)); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; goto __pyx_L1;}\n    __pyx_r = __pyx_2;\n    __pyx_2 = 0;\n    goto __pyx_L0;\n    goto __pyx_L2;\n  }\n  /*else*/ {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":315 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_TypeError); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, 0, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; goto __pyx_L1;}\n  }\n  __pyx_L2:;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.ip_cksum_add\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_buf);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static void __pyx_f_4dnet_2ip___dealloc__(PyObject *__pyx_v_self)", "code": "{\n  int __pyx_1;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":262 */\n  __pyx_1 = (((struct __pyx_obj_4dnet_ip *)__pyx_v_self)->ip != 0);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":263 */\n    ip_close(((struct __pyx_obj_4dnet_ip *)__pyx_v_self)->ip);\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  goto __pyx_L0;\n  __pyx_L1:;\n  __Pyx_AddTraceback(\"dnet.ip.__dealloc__\");\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_15__addr_ip4_iter___next__(PyObject *__pyx_v_self)", "code": "{\n  struct __pyx_obj_4dnet_addr *__pyx_v_next;\n  PyObject *__pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  unsigned short __pyx_4;\n  Py_INCREF(__pyx_v_self);\n  __pyx_v_next = ((struct __pyx_obj_4dnet_addr *)Py_None); Py_INCREF(Py_None);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":634 */\n  __pyx_1 = (((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->cur <= ((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->max);\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":635 */\n    __pyx_2 = PyTuple_New(0); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; goto __pyx_L1;}\n    __pyx_3 = PyObject_Call(((PyObject*)__pyx_ptype_4dnet_addr), __pyx_2, 0); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; goto __pyx_L1;}\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    if (!__Pyx_TypeTest(__pyx_3, __pyx_ptype_4dnet_addr)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; goto __pyx_L1;}\n    Py_DECREF(((PyObject *)__pyx_v_next));\n    __pyx_v_next = ((struct __pyx_obj_4dnet_addr *)__pyx_3);\n    __pyx_3 = 0;\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":636 */\n    __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_ADDR_TYPE_IP); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; goto __pyx_L1;}\n    __pyx_4 = PyInt_AsLong(__pyx_2); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; goto __pyx_L1;}\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    __pyx_v_next->_addr.addr_type = __pyx_4;\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":637 */\n    __pyx_3 = __Pyx_GetName(__pyx_m, __pyx_n_IP_ADDR_BITS); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; goto __pyx_L1;}\n    __pyx_4 = PyInt_AsLong(__pyx_3); if (PyErr_Occurred()) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; goto __pyx_L1;}\n    Py_DECREF(__pyx_3); __pyx_3 = 0;\n    __pyx_v_next->_addr.addr_bits = __pyx_4;\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":638 */\n    __pyx_v_next->_addr.addr_ip = htonl(((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->cur);\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":639 */\n    ((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->cur = (((struct __pyx_obj_4dnet___addr_ip4_iter *)__pyx_v_self)->cur + 1);\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":640 */\n    Py_INCREF(((PyObject *)__pyx_v_next));\n    __pyx_r = ((PyObject *)__pyx_v_next);\n    goto __pyx_L0;\n    goto __pyx_L2;\n  }\n  /*else*/ {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":642 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_StopIteration); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, 0, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; goto __pyx_L1;}\n  }\n  __pyx_L2:;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  __Pyx_AddTraceback(\"dnet.__addr_ip4_iter.__next__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_next);\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4addr___repr__(PyObject *__pyx_v_self)", "code": "{\n  char (*__pyx_v_p);\n  PyObject *__pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":619 */\n  __pyx_v_p = addr_ntoa((&((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr));\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":620 */\n  __pyx_1 = (!(__pyx_v_p != 0));\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":621 */\n    Py_INCREF(__pyx_k72p);\n    __pyx_r = __pyx_k72p;\n    goto __pyx_L0;\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":622 */\n  __pyx_2 = PyString_FromString(__pyx_v_p); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; goto __pyx_L1;}\n  __pyx_r = __pyx_2;\n  __pyx_2 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.addr.__repr__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_f_4dnet_4addr_3eth___get__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r;\n  PyObject *__pyx_1 = 0;\n  PyObject *__pyx_2 = 0;\n  int __pyx_3;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":484 */\n  __pyx_1 = PyInt_FromLong(((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_type); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; goto __pyx_L1;}\n  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_n_ADDR_TYPE_ETH); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; goto __pyx_L1;}\n  if (PyObject_Cmp(__pyx_1, __pyx_2, &__pyx_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; goto __pyx_L1;}\n  __pyx_3 = __pyx_3 != 0;\n  Py_DECREF(__pyx_1); __pyx_1 = 0;\n  Py_DECREF(__pyx_2); __pyx_2 = 0;\n  if (__pyx_3) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":485 */\n    __pyx_1 = __Pyx_GetName(__pyx_b, __pyx_n_ValueError); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_1, __pyx_k66p, 0);\n    Py_DECREF(__pyx_1); __pyx_1 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":486 */\n  __pyx_2 = PyString_FromStringAndSize(((struct __pyx_obj_4dnet_addr *)__pyx_v_self)->_addr.addr_data8,6); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 486; goto __pyx_L1;}\n  __pyx_r = __pyx_2;\n  __pyx_2 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_1);\n  Py_XDECREF(__pyx_2);\n  __Pyx_AddTraceback(\"dnet.addr.eth.__get__\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_f_4dnet_5route___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  int __pyx_r;\n  int __pyx_1;\n  PyObject *__pyx_2 = 0;\n  PyObject *__pyx_3 = 0;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return -1;\n  Py_INCREF(__pyx_v_self);\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1096 */\n  ((struct __pyx_obj_4dnet_route *)__pyx_v_self)->route = route_open();\n\n  /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1097 */\n  __pyx_1 = (!(((struct __pyx_obj_4dnet_route *)__pyx_v_self)->route != 0));\n  if (__pyx_1) {\n\n    /* \"/Users/dugsong/projects/libdnet/python/./dnet.pyx\":1098 */\n    __pyx_2 = __Pyx_GetName(__pyx_b, __pyx_n_OSError); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1098; goto __pyx_L1;}\n    __pyx_3 = __pyx_f_4dnet___oserror(); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1098; goto __pyx_L1;}\n    __Pyx_Raise(__pyx_2, __pyx_3, 0);\n    Py_DECREF(__pyx_2); __pyx_2 = 0;\n    Py_DECREF(__pyx_3); __pyx_3 = 0;\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1098; goto __pyx_L1;}\n    goto __pyx_L2;\n  }\n  __pyx_L2:;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1:;\n  Py_XDECREF(__pyx_2);\n  Py_XDECREF(__pyx_3);\n  __Pyx_AddTraceback(\"dnet.route.__init__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "path": "python\\dnet.c", "repo_name": "archaelus/libdnet", "stars": 4, "license": "other", "language": "c", "size": 1356}
{"docstring": "/*\n * convert the given MPEG I-frame data to an internal format\n * returns NULL on error\n */\n", "func_signal": "MHEGBitmap *\nMHEGDisplay_newMPEGBitmap(MHEGDisplay *d, OctetString *mpeg)", "code": "{\n\tMHEGBitmap *b;\n\tAVCodecContext *codec_ctx;\n\tAVCodec *codec;\n\tAVFrame *yuv_frame;\n\tAVFrame *rgb_frame;\n\tunsigned char *padded;\n\tunsigned char *data;\n\tunsigned int size;\n\tint used;\n\tint got_picture;\n\tunsigned int width;\n\tunsigned int height;\n\tint nbytes;\n\tunsigned char *rgba = NULL;\n\n\t/* nothing to do */\n\tif(mpeg == NULL || mpeg->size == 0)\n\t\treturn NULL;\n\n\t/* use ffmpeg to convert the data into a standard format we can use as an XImage */\n\tif((codec_ctx = avcodec_alloc_context()) == NULL)\n\t\tfatal(\"Out of memory\");\n\n\tif((codec = avcodec_find_decoder(CODEC_ID_MPEG2VIDEO)) == NULL)\n\t\tfatal(\"Unable to initialise MPEG decoder\");\n\n\tif(avcodec_open(codec_ctx, codec) < 0)\n\t\tfatal(\"Unable to open video codec\");\n\n\tif((yuv_frame = avcodec_alloc_frame()) == NULL)\n\t\tfatal(\"Out of memory\");\n\tif((rgb_frame = avcodec_alloc_frame()) == NULL)\n\t\tfatal(\"Out of memory\");\n\n\t/* ffmpeg may read passed the end of the buffer, so pad it out */\n\tpadded = safe_malloc(mpeg->size + FF_INPUT_BUFFER_PADDING_SIZE);\n\tmemcpy(padded, mpeg->data, mpeg->size);\n\tmemset(padded + mpeg->size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\t/* decode the YUV frame */\n\tdata = padded;\n\tsize = mpeg->size;\n\tdo\n\t{\n\t\tused = avcodec_decode_video(codec_ctx, yuv_frame, &got_picture, data, size);\n\t\tdata += used;\n\t\tsize -= used;\n\t}\n\twhile(!got_picture && size > 0);\n\t/* need to call it one final time with size=0, to actually get the frame */\n\tif(!got_picture)\n\t\t(void) avcodec_decode_video(codec_ctx, yuv_frame, &got_picture, data, size);\n\n\tif(!got_picture)\n\t{\n\t\terror(\"Unable to decode MPEG image\");\n\t\tb = NULL;\n\t}\n\telse\n\t{\n\t\t/* convert to RGBA */\n\t\tstruct SwsContext *sws_ctx;\n\t\twidth = codec_ctx->width;\n\t\theight = codec_ctx->height;\n\t\tif((nbytes = avpicture_get_size(PIX_FMT_RGBA32, width, height)) < 0)\n\t\t\tfatal(\"Invalid MPEG image\");\n\t\trgba = safe_malloc(nbytes);\n\t\tavpicture_fill((AVPicture *) rgb_frame, rgba, PIX_FMT_RGBA32, width, height);\n\t\t//img_convert((AVPicture *) rgb_frame, PIX_FMT_RGBA32, (AVPicture*) yuv_frame, codec_ctx->pix_fmt, width, height);\n\t\tif((sws_ctx = sws_getContext(width, height, codec_ctx->pix_fmt,\n\t\t\t\t\t     width, height, PIX_FMT_RGBA32,\n\t\t\t\t\t     SWS_FAST_BILINEAR, NULL, NULL, NULL)) == NULL)\n\t\t\tfatal(\"Out of memory\");\n\t\tsws_scale(sws_ctx, yuv_frame->data, yuv_frame->linesize, 0, height, rgb_frame->data, rgb_frame->linesize);\n\t\tsws_freeContext(sws_ctx);\n\t\t/* convert the PIX_FMT_RGBA32 data to a MHEGBitmap */\n\t\tb = MHEGBitmap_fromRGBA(d, rgba, width, height);\n\t}\n\n\t/* clean up */\n\tsafe_free(padded);\n\tsafe_free(rgba);\n\tav_free(yuv_frame);\n\tav_free(rgb_frame);\n\tavcodec_close(codec_ctx);\n\n\treturn b;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n * width is the line width in pixels\n * style should be LineStyle_solid/dashed/dotted\n */\n", "func_signal": "void\nMHEGDisplay_drawHoriLine(MHEGDisplay *d, XYPosition *pos, unsigned int len, int width, int style, MHEGColour *col)", "code": "{\n\tXRenderColor rcol;\n\tint x, y;\n\tunsigned int w, h;\n\n\t/* if it is transparent or line width is <=0, just bail out */\n\tif(col->t == MHEGCOLOUR_TRANSPARENT || width <= 0)\n\t\treturn;\n\n\t/* convert to internal colour format */\n\tdisplay_colour(&rcol, col);\n\n\t/* scale if fullscreen */\n\tx = MHEGDisplay_scaleX(d, pos->x_position);\n\ty = MHEGDisplay_scaleY(d, pos->y_position);\n\tw = MHEGDisplay_scaleX(d, len);\n\t/* aspect ratio */\n\th = MHEGDisplay_scaleY(d, width);\n\n/* TODO */\nif(style != LineStyle_solid)\nprintf(\"TODO: LineStyle %d\\n\", style);\n\n\t/* draw a rectangle */\n\tXRenderFillRectangle(d->dpy, PictOpOver, d->next_overlay_pic, &rcol, x, y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * copy the contents of next_overlay onto used_overlay\n * ie all drawing done since the last call to this will appear on the screen at the next refresh()\n */\n", "func_signal": "void\nMHEGDisplay_useOverlay(MHEGDisplay *d)", "code": "{\n\t/* avoid any XRender clip mask */\n\tXCopyArea(d->dpy, d->next_overlay, d->used_overlay, d->overlay_gc, 0, 0, d->xres, d->yres, 0, 0);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n * text can include multibyte (UTF8) chars as described in the UK MHEG Profile\n * text can also include tab characters (0x09)\n * if tabs is false, tab characters are just treated as spaces\n * text should *not* include ESC sequences to change colour or \\r for new lines\n */\n", "func_signal": "void\nMHEGDisplay_drawTextElement(MHEGDisplay *d, XYPosition *pos, MHEGFont *font, MHEGTextElement *text, bool tabs)", "code": "{\n\tXRenderColor rcol;\n\tint orig_x;\n\tint x, y;\n\tint scrn_x;\n\tFT_Face face;\n\tFT_GlyphSlot slot;\n\tFT_UInt glyph;\n\tFT_UInt previous;\n\tFT_Vector kern;\n\tFT_Error err;\n\tunsigned char *data;\n\tunsigned int size;\n\tint utf8;\n\tint len;\n\tint ntabs;\n\n\t/* is there any text */\n\tif(text->size == 0)\n\t\treturn;\n\n\t/* convert to internal colour format */\n\tdisplay_colour(&rcol, &text->col);\n\n\t/* scale the x origin if fullscreen */\n\torig_x = MHEGDisplay_scaleX(d, pos->x_position);\n\t/* y coord does not change */\n\ty = MHEGDisplay_scaleY(d, pos->y_position + text->y);\n\n\t/* set the text foreground colour */\n\tXRenderFillRectangle(d->dpy, PictOpSrc, d->textfg_pic, &rcol, 0, 0, 1, 1);\n\n\t/*\n\t * can't just use XftTextRenderUtf8() because:\n\t * - it doesn't do kerning\n\t * - text may include tabs\n\t */\n\t/* we do all layout calculations with the unscaled font metrics */\n\tface = XftLockFace(font->font);\n\tslot = face->glyph;\n\n\t/* no previous glyph yet */\n\tprevious = 0;\n\n\t/* x in font units */\n\tx = text->x * face->units_per_EM;\n\n\tdata = text->data;\n\tsize = text->size;\n\twhile(size > 0)\n\t{\n\t\t/* get the next UTF8 char */\n\t\tutf8 = next_utf8(data, size, &len);\n\t\tdata += len;\n\t\tsize -= len;\n\t\t/* if it's a tab, just advance to the next tab stop */\n\t\tif(utf8 == 0x09 && tabs)\n\t\t{\n\t\t\t/* min amount a tab should advance the text pos */\n\t\t\tx += font->xOffsetLeft * face->units_per_EM;\n\t\t\t/* move to the next tab stop */\n\t\t\tntabs = x / (MHEG_TAB_WIDTH * face->units_per_EM);\n\t\t\tx = ((ntabs + 1) * MHEG_TAB_WIDTH) * face->units_per_EM;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we are treating tabs as spaces */\n\t\tif(utf8 == 0x09)\n\t\t\tutf8 = 0x20;\n\t\t/* get the glyph index for the UTF8 char */\n\t\tglyph = FT_Get_Char_Index(face, utf8);\n\t\t/* do any kerning if necessary */\n\t\tif(previous != 0 && FT_HAS_KERNING(face))\n\t\t{\n\t\t\tFT_Get_Kerning(face, previous, glyph, FT_KERNING_UNSCALED, &kern);\n\t\t\tx += (kern.x * font->size * 45) / 56;\n\t\t}\n\t\t/* remember the glyph for kerning next time */\n\t\tprevious = glyph;\n\t\t/* render it */\n\t\tXftUnlockFace(font->font);\n\t\t/* round up/down the X coord */\n\t\tscrn_x = MHEGDisplay_scaleX(d, x);\n\t\tscrn_x = (scrn_x + (face->units_per_EM / 2)) / face->units_per_EM;\n\t\tXftGlyphRender(d->dpy, PictOpOver, d->textfg_pic, font->font, d->next_overlay_pic,\n\t\t\t       0, 0, orig_x + scrn_x, y,\n\t\t\t       &glyph, 1);\n\t\tface = XftLockFace(font->font);\n\t\tslot = face->glyph;\n\t\t/* advance x */\n\t\terr = FT_Load_Glyph(face, glyph, FT_LOAD_NO_SCALE);\n\t\tif(err)\n\t\t\tcontinue;\n\t\tx += (slot->advance.x * font->size * 45) / 56;\n\t\t/* add on (letter spacing / 256) * units_per_EM */\n\t\tx += (face->units_per_EM * font->letter_spc * 45) / (256 * 56);\n\t}\n\n\tXftUnlockFace(font->font);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n * width is the line width in pixels\n * style should be LineStyle_solid/dashed/dotted\n */\n", "func_signal": "void\nMHEGDisplay_drawVertLine(MHEGDisplay *d, XYPosition *pos, unsigned int len, int width, int style, MHEGColour *col)", "code": "{\n\tXRenderColor rcol;\n\tint x, y;\n\tunsigned int w, h;\n\n\t/* if it is transparent or line width is <=0, just bail out */\n\tif(col->t == MHEGCOLOUR_TRANSPARENT || width <= 0)\n\t\treturn;\n\n\t/* convert to internal colour format */\n\tdisplay_colour(&rcol, col);\n\n\t/* scale if fullscreen */\n\tx = MHEGDisplay_scaleX(d, pos->x_position);\n\ty = MHEGDisplay_scaleY(d, pos->y_position);\n\th = MHEGDisplay_scaleY(d, len);\n\t/* aspect ratio */\n\tw = MHEGDisplay_scaleX(d, width);\n\n/* TODO */\nif(style != LineStyle_solid)\nprintf(\"TODO: LineStyle %d\\n\", style);\n\n\t/* draw a rectangle */\n\tXRenderFillRectangle(d->dpy, PictOpOver, d->next_overlay_pic, &rcol, x, y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * remove the clip rectangle from the overlay\n */\n", "func_signal": "void\nMHEGDisplay_unsetClipRectangle(MHEGDisplay *d)", "code": "{\n\t/*\n\t * this doesn't work...\n\t * XRenderSetPictureClipRectangles(d->dpy, d->next_overlay_pic, 0, 0, NULL, 0);\n\t */\n\n\tXRenderPictureAttributes attr;\n\n\tattr.clip_mask = None;\n\n\tXRenderChangePicture(d->dpy, d->next_overlay_pic, CPClipMask, &attr);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n */\n", "func_signal": "void\nMHEGDisplay_drawBitmap(MHEGDisplay *d, XYPosition *src, OriginalBoxSize *box, MHEGBitmap *bitmap, XYPosition *dst)", "code": "{\n\tint src_x, src_y;\n\tint dst_x, dst_y;\n\tunsigned int w, h;\n\n\t/* in case we don't have any content yet, UK MHEG Profile says make it transparent */\n\tif(bitmap == NULL)\n\t\treturn;\n\n\t/*\n\t * scale up if fullscreen\n\t * the bitmap itself is scaled when it is created in MHEGDisplay_newBitmap()\n\t */\n\tsrc_x = MHEGDisplay_scaleX(d, src->x_position);\n\tsrc_y = MHEGDisplay_scaleY(d, src->y_position);\n\tw = MHEGDisplay_scaleX(d, box->x_length);\n\th = MHEGDisplay_scaleY(d, box->y_length);\n\tdst_x = MHEGDisplay_scaleX(d, dst->x_position);\n\tdst_y = MHEGDisplay_scaleY(d, dst->y_position);\n\n\tXRenderComposite(d->dpy, PictOpOver, bitmap->image_pic, None, d->next_overlay_pic,\n\t\t\t src_x, src_y, src_x, src_y, dst_x, dst_y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * returns true if the two boxes intersect\n * sets out_pos and out_box to the intersection\n */\n", "func_signal": "bool\nintersects(XYPosition *p1, OriginalBoxSize *b1, XYPosition *p2, OriginalBoxSize *b2, XYPosition *out_pos, OriginalBoxSize *out_box)", "code": "{\n\tint x1 = p1->x_position;\n\tint y1 = p1->y_position;\n\tint w1 = b1->x_length;\n\tint h1 = b1->y_length;\n\tint x2 = p2->x_position;\n\tint y2 = p2->y_position;\n\tint w2 = b2->x_length;\n\tint h2 = b2->y_length;\n\tbool hmatch;\n\tbool vmatch;\n\n\t/* intersection */\n\tout_pos->x_position = MAX(x1, x2);\n\tout_pos->y_position = MAX(y1, y2);\n\tout_box->x_length = MIN(x1 + w1, x2 + w2) - out_pos->x_position;\n\tout_box->y_length = MIN(y1 + h1, y2 + h2) - out_pos->y_position;\n\n\t/* does it intersect */\n\thmatch = (x1 < (x2 + w2)) && ((x1 + w1) > x2);\n\tvmatch = (y1 < (y2 + h2)) && ((y1 + h1) > y2);\n\n\treturn hmatch && vmatch;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * construct a MHEGBitmap from an array of ffmpeg's PIX_FMT_RGBA32 pixels\n * ffmpeg always stores PIX_FMT_RGBA32 as\n *  (A << 24) | (R << 16) | (G << 8) | B\n * no matter what byte order our CPU uses. ie,\n * it is stored as BGRA on little endian CPU architectures and ARGB on big endian CPUs\n */\n", "func_signal": "MHEGBitmap *\nMHEGBitmap_fromRGBA(MHEGDisplay *d, unsigned char *rgba, unsigned int width, unsigned int height)", "code": "{\n\tMHEGBitmap *bitmap;\n\tunsigned char *xdata;\n\tuint32_t rgba_pix;\n\tuint32_t xpix;\n\tuint8_t r, g, b, a;\n\tunsigned int i, npixs;\n\tXImage *ximg;\n\tXRenderPictFormat *pic_format;\n\tenum PixelFormat av_format;\n\tGC gc;\n\n\tbitmap = safe_malloc(sizeof(MHEGBitmap));\n\tbzero(bitmap, sizeof(MHEGBitmap));\n\n\t/* find a matching XRender pixel format */\n\tpic_format = XRenderFindStandardFormat(d->dpy, PictStandardARGB32);\n\tav_format = find_av_pix_fmt(32,\n\t\t\t\t    pic_format->direct.redMask << pic_format->direct.red,\n\t\t\t\t    pic_format->direct.greenMask << pic_format->direct.green,\n\t\t\t\t    pic_format->direct.blueMask << pic_format->direct.blue);\n\n\t/* copy the RGBA values into a block we can use as XImage data */\n\tnpixs = width * height;\n\t/* 4 bytes per pixel */\n\txdata = safe_malloc(npixs * 4);\n\t/* are the pixel layouts exactly the same */\n\tif(av_format == PIX_FMT_RGBA32)\n\t{\n\t\tmemcpy(xdata, rgba, npixs * 4);\n\t}\n\telse\n\t{\n\t\t/* swap the RGBA components as needed */\n\t\tfor(i=0; i<npixs; i++)\n\t\t{\n\t\t\trgba_pix = *((uint32_t *) &rgba[i * 4]);\n\t\t\ta = (rgba_pix >> 24) & 0xff;\n\t\t\tr = (rgba_pix >> 16) & 0xff;\n\t\t\tg = (rgba_pix >> 8) & 0xff;\n\t\t\tb = rgba_pix & 0xff;\n\t\t\t/* is it transparent */\n\t\t\tif(a == 0)\n\t\t\t{\n\t\t\t\txpix = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txpix = a << pic_format->direct.alpha;\n\t\t\t\txpix |= r << pic_format->direct.red;\n\t\t\t\txpix |= g << pic_format->direct.green;\n\t\t\t\txpix |= b << pic_format->direct.blue;\n\t\t\t}\n\t\t\t*((uint32_t *) &xdata[i * 4]) = xpix;\n\t\t}\n\t}\n\n\t/* get X to draw the XImage onto a Pixmap */\n\tif((ximg = XCreateImage(d->dpy, NULL, 32, ZPixmap, 0, (char *) xdata, width, height, 32, 0)) == NULL)\n\t\tfatal(\"XCreateImage failed\");\n\t/* passed NULL Visual to XCreateImage, so set the rgb masks now */\n\tximg->red_mask = pic_format->direct.redMask;\n\tximg->green_mask = pic_format->direct.greenMask;\n\tximg->blue_mask = pic_format->direct.blueMask;\n\t/* create the Pixmap */\n\tbitmap->image = XCreatePixmap(d->dpy, d->win, width, height, 32);\n\tgc = XCreateGC(d->dpy, bitmap->image, 0, NULL);\n\tXPutImage(d->dpy, bitmap->image, gc, ximg, 0, 0, 0, 0, width, height);\n\tXFreeGC(d->dpy, gc);\n\n\t/* associate a Picture with it */\n\tbitmap->image_pic = XRenderCreatePicture(d->dpy, bitmap->image, pic_format, 0, NULL);\n\n\t/* if we are using fullscreen mode, scale the image */\n\tif(d->fullscreen)\n\t{\nprintf(\"TODO: MHEGBitmap_fromRGBA: take aspect ratio into account\\n\");\n/* TODO: use swscale here to permenantly scale up the image */\n\t\t/* set up the matrix to scale it */\n\t\tXTransform xform;\n\t\t/* X */\n\t\txform.matrix[0][0] = (MHEG_XRES << 16) / d->xres;\n\t\txform.matrix[0][1] = 0;\n\t\txform.matrix[0][2] = 0;\n\t\t/* Y */\n\t\txform.matrix[1][0] = 0;\n\t\txform.matrix[1][1] = (MHEG_YRES << 16) / d->yres;\n\t\txform.matrix[1][2] = 0;\n\t\t/* Z */\n\t\txform.matrix[2][0] = 0;\n\t\txform.matrix[2][1] = 0;\n\t\txform.matrix[2][2] = 1 << 16;\n\t\t/* scale it */\n\t\tXRenderSetPictureTransform(d->dpy, bitmap->image_pic, &xform);\n\t\t/* set a filter to smooth the edges */\n\t\tXRenderSetPictureFilter(d->dpy, bitmap->image_pic, FilterBilinear, 0, 0);\n\t}\n\n\t/* we alloc'ed the XImage data, make sure XDestroyImage doesn't try to free it */\n\tsafe_free(xdata);\n\tximg->data = NULL;\n\tXDestroyImage(ximg);\n\n\treturn bitmap;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * caller_gid is used to resolve the GenericContentReference\n */\n", "func_signal": "void\nContentRefVariableClass_SetVariable(ContentRefVariableClass *v, NewVariableValue *new_value, OctetString *caller_gid)", "code": "{\n\tContentReference *val;\n\n\tverbose(\"ContentRefVariableClass: %s; SetVariable\", ExternalReference_name(&v->rootClass.inst.ref));\n\n\t/* check the type of the new value */\n\tif(new_value->choice != NewVariableValue_new_generic_content_reference)\n\t{\n\t\terror(\"SetVariable: %s; type mismatch\", ExternalReference_name(&v->rootClass.inst.ref));\n\t\treturn;\n\t}\n\n\tval = GenericContentReference_getContentReference(&new_value->u.new_generic_content_reference, caller_gid);\n\n\tOctetString_copy(&v->inst.Value.u.content_reference, val);\n\n\treturn;\n}", "path": "browser\\ContentRefVariableClass.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * load the given key map config file\n */\n", "func_signal": "static MHEGKeyMapEntry *\nload_keymap(char *filename)", "code": "{\n\tFILE *conf;\n\tMHEGKeyMapEntry *map;\n\tchar symname[64];\n\tsize_t len;\n\n\tif((conf = fopen(filename, \"r\")) == NULL)\n\t\tfatal(\"Unable to open keymap config '%s': %s\", filename, strerror(errno));\n\n\t/* overwrite default_keymap */\n\tmap = default_keymap;\n\twhile(map->mheg_key != 0)\n\t{\n\t\tif(fgets(symname, sizeof(symname), conf) == NULL)\n\t\t\tfatal(\"Keymap config file '%s' ended unexpectedly\", filename);\n\t\t/* chop off any trailing \\n */\n\t\tlen = strlen(symname);\n\t\tif(symname[len-1] == '\\n')\n\t\t\tsymname[len-1] = '\\0';\n\t\tif((map->x_key = XStringToKeysym(symname)) == NoSymbol)\n\t\t\tfatal(\"Key '%s' does not exist\", symname);\n\t\tmap ++;\n\t}\n\n\tfclose(conf);\n\n\treturn default_keymap;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * convert the given PNG data to an internal format\n * returns NULL on error\n */\n", "func_signal": "MHEGBitmap *\nMHEGDisplay_newPNGBitmap(MHEGDisplay *d, OctetString *png)", "code": "{\n\tMHEGBitmap *b;\n\tpng_uint_32 width, height;\n\tunsigned char *rgba;\n\tunsigned int i;\n\n\t/* nothing to do */\n\tif(png == NULL || png->size == 0)\n\t\treturn NULL;\n\n\t/* convert the PNG into a standard format we can use as an XImage */\n\tif((rgba = readpng_get_image(png->data, png->size, &width, &height)) == NULL)\n\t{\n\t\terror(\"Unable to decode PNG file\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * we now have an array of 32-bit RGBA pixels in network byte order\n\t * ie if pix is a char *: pix[0] = R, pix[1] = G, pix[2] = B, pix[3] = A\n\t * we need to convert it to ffmpeg's PIX_FMT_RGBA32 format\n\t * ffmpeg always stores PIX_FMT_RGBA32 as\n\t *  (A << 24) | (R << 16) | (G << 8) | B\n\t * no matter what byte order our CPU uses. ie,\n\t * it is stored as BGRA on little endian CPU architectures and ARGB on big endian CPUs\n\t */\n\tfor(i=0; i<width*height; i++)\n\t{\n\t\tuint8_t a, r, g, b;\n\t\tuint32_t pix;\n\t\t/*\n\t\t * if the pixel is transparent, set the RGB components to 0\n\t\t * otherwise, if we scale up the bitmap in fullscreen mode,\n\t\t * we may end up with a border around the image\n\t\t * this happens, for example, with the BBC's \"Press Red\" image\n\t\t * it has a transparent box around it, but the RGB values are not 0 in the transparent area\n\t\t * when we scale it up we get a pink border around it\n\t\t */\n\t\ta = rgba[(i * 4) + 3];\n\t\tif(a == 0)\n\t\t{\n\t\t\tpix = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = rgba[(i * 4) + 0];\n\t\t\tg = rgba[(i * 4) + 1];\n\t\t\tb = rgba[(i * 4) + 2];\n\t\t\tpix = (a << 24) | (r << 16) | (g << 8) | b;\n\t\t}\n\t\t*((uint32_t *) &rgba[i * 4]) = pix;\n\t}\n\n\t/* convert the PIX_FMT_RGBA32 data to a MHEGBitmap */\n\tb = MHEGBitmap_fromRGBA(d, rgba, width, height);\n\n\t/* clean up */\n\treadpng_free_image(rgba);\n\n\treturn b;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * gets the given area of the Window refreshed\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n */\n", "func_signal": "void\nMHEGDisplay_refresh(MHEGDisplay *d, XYPosition *pos, OriginalBoxSize *box)", "code": "{\n\tint x, y;\n\tunsigned int w, h;\n\n\t/* scale if fullscreen */\n\tx = MHEGDisplay_scaleX(d, pos->x_position);\n\ty = MHEGDisplay_scaleY(d, pos->y_position);\n\tw = MHEGDisplay_scaleX(d, box->x_length);\n\th = MHEGDisplay_scaleY(d, box->y_length);\n\n\t/*\n\t * if video is being displayed, the current frame will already be in d->contents\n\t * (drawn by the video thread)\n\t * overlay the MHEG objects onto the video in d->contents\n\t */\n\tXRenderComposite(d->dpy, PictOpOver, d->used_overlay_pic, None, d->contents_pic, x, y, x, y, x, y, w, h);\n\n\t/* copy the Window contents onto the screen */\n\tXCopyArea(d->dpy, d->contents, d->win, d->win_gc, x, y, w, h, x, y);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * set the clip rectangle for all subsequent drawing on the overlay\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n */\n", "func_signal": "void\nMHEGDisplay_setClipRectangle(MHEGDisplay *d, XYPosition *pos, OriginalBoxSize *box)", "code": "{\n\tXRectangle clip;\n\n\t/* scale if fullscreen */\n\tclip.x = MHEGDisplay_scaleX(d, pos->x_position);\n\tclip.y = MHEGDisplay_scaleY(d, pos->y_position);\n\tclip.width = MHEGDisplay_scaleX(d, box->x_length);\n\tclip.height = MHEGDisplay_scaleY(d, box->y_length);\n\n\tXRenderSetPictureClipRectangles(d->dpy, d->next_overlay_pic, 0, 0, &clip, 1);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * explicitly make a transparent rectangle in the MHEG overlay\n * MHEGDisplay_fillRectangle() uses PictOpOver => it can't create a transparent box in the output\n * this uses PictOpSrc\n */\n", "func_signal": "void\nMHEGDisplay_fillTransparentRectangle(MHEGDisplay *d, XYPosition *pos, OriginalBoxSize *box)", "code": "{\n\tXRenderColor rcol = {0, 0, 0, 0};\n\tint x, y;\n\tunsigned int w, h;\n\n\t/* scale if fullscreen */\n\tx = MHEGDisplay_scaleX(d, pos->x_position);\n\ty = MHEGDisplay_scaleY(d, pos->y_position);\n\tw = MHEGDisplay_scaleX(d, box->x_length);\n\th = MHEGDisplay_scaleY(d, box->y_length);\n\n\tXRenderFillRectangle(d->dpy, PictOpSrc, d->next_overlay_pic, &rcol, x, y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n */\n", "func_signal": "void\nMHEGDisplay_fillRectangle(MHEGDisplay *d, XYPosition *pos, OriginalBoxSize *box, MHEGColour *col)", "code": "{\n\tXRenderColor rcol;\n\tint x, y;\n\tunsigned int w, h;\n\n\t/* if it is transparent, just bail out */\n\tif(col->t == MHEGCOLOUR_TRANSPARENT)\n\t\treturn;\n\n\t/* convert to internal colour format */\n\tdisplay_colour(&rcol, col);\n\n\t/* scale if fullscreen */\n\tx = MHEGDisplay_scaleX(d, pos->x_position);\n\ty = MHEGDisplay_scaleY(d, pos->y_position);\n\tw = MHEGDisplay_scaleX(d, box->x_length);\n\th = MHEGDisplay_scaleY(d, box->y_length);\n\n\tXRenderFillRectangle(d->dpy, PictOpOver, d->next_overlay_pic, &rcol, x, y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * returns 0 if the ObjectReferences refer to the same object\n * if r1 is an internal reference, r1_gid is used as its group id\n * similarly for r2\n */\n", "func_signal": "int\nObjectReference_cmp(ObjectReference *r1, OctetString *r1_gid, ObjectReference *r2, OctetString *r2_gid)", "code": "{\n\tunsigned int num1, num2;\n\tOctetString *gid1, *gid2;\n\tint cmp;\n\n\t/* complicated by the fact that they can be either internal or external references */\n\tswitch(r1->choice)\n\t{\n\tcase ObjectReference_internal_reference:\n\t\tnum1 = r1->u.internal_reference;\n\t\tgid1 = r1_gid;\n\t\tbreak;\n\n\tcase ObjectReference_external_reference:\n\t\tnum1 = r1->u.external_reference.object_number;\n\t\tgid1 = &r1->u.external_reference.group_identifier;\n\t\tbreak;\n\n\tdefault:\n\t\terror(\"Unknown ObjectReference type: %d\", r1->choice);\n\t\treturn -1;\n\t}\n\n\tswitch(r2->choice)\n\t{\n\tcase ObjectReference_internal_reference:\n\t\tnum2 = r2->u.internal_reference;\n\t\tgid2 = r2_gid;\n\t\tbreak;\n\n\tcase ObjectReference_external_reference:\n\t\tnum2 = r2->u.external_reference.object_number;\n\t\tgid2 = &r2->u.external_reference.group_identifier;\n\t\tbreak;\n\n\tdefault:\n\t\terror(\"Unknown ObjectReference type: %d\", r2->choice);\n\t\treturn -1;\n\t}\n\n\tif(num1 == num2)\n\t\tcmp = OctetString_cmp(gid1, gid2);\n\telse\n\t\tcmp = num1 - num2;\n\n\tverbose(\"ObjectReference_cmp(%.*s %d, %.*s %d) = %d\", gid1->size, gid1->data, num1, gid2->size, gid2->data, num2, cmp);\n\n\treturn cmp;\n}", "path": "browser\\ObjectReference.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * coords should be in the range 0-MHEG_XRES, 0-MHEG_YRES\n */\n", "func_signal": "void\nMHEGDisplay_drawCanvas(MHEGDisplay *d, XYPosition *src, OriginalBoxSize *box, MHEGCanvas *canvas, XYPosition *dst)", "code": "{\n\tint src_x, src_y;\n\tint dst_x, dst_y;\n\tunsigned int w, h;\n\n\t/*\n\t * scale up if fullscreen\n\t * the canvas image itself is scaled when it is created\n\t */\n\tsrc_x = MHEGDisplay_scaleX(d, src->x_position);\n\tsrc_y = MHEGDisplay_scaleY(d, src->y_position);\n\tw = MHEGDisplay_scaleX(d, box->x_length);\n\th = MHEGDisplay_scaleY(d, box->y_length);\n\tdst_x = MHEGDisplay_scaleX(d, dst->x_position);\n\tdst_y = MHEGDisplay_scaleY(d, dst->y_position);\n\n\tXRenderComposite(d->dpy, PictOpOver, canvas->contents_pic, None, d->next_overlay_pic,\n\t\t\t src_x, src_y, src_x, src_y, dst_x, dst_y, w, h);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * process the next GUI event\n * if block is false and no events are pending, return immediately\n * if block is true and no events are pending, wait for the next event\n * returns true if the GUI wants us to quit\n */\n", "func_signal": "bool\nMHEGDisplay_processEvents(MHEGDisplay *d, bool block)", "code": "{\n\tbool quit = false;\n\tXEvent event;\n\tXAnyEvent *any;\n\tXKeyEvent *key;\n\tKeySym sym;\n\tMHEGKeyMapEntry *map;\n\tXExposeEvent *exp;\n\tXClientMessageEvent *cm;\n\tstatic Atom wm_protocols = 0;\n\tstatic Atom wm_delete_window = 0;\n\n\t/* dont block if only a Timer is pending */\n\tif(!block\n\t&& (XtAppPending(d->app) & ~XtIMTimer) == 0)\n\t\treturn false;\n\n\t/* this will block if no events are pending */\n\tXtAppNextEvent(d->app, &event);\n\n\t/* is it our window */\n\tany = &event.xany;\n\tif(any->display != d->dpy || any->window != d->win)\n\t{\n\t\t/* pass it on to Xt */\n\t\tXtDispatchEvent(&event);\n\t\treturn false;\n\t}\n\n\tswitch(event.type)\n\t{\n\tcase KeyPress:\n\t\tkey = &event.xkey;\n\t\tsym = XKeycodeToKeysym(d->dpy, key->keycode, 0);\n\t\t/* find the KeySym in the keyboard map */\n\t\tmap = d->keymap;\n\t\twhile(map->mheg_key != 0 && map->x_key != sym)\n\t\t\tmap ++;\n\t\tif(map->mheg_key != 0)\n\t\t{\n\t\t\tverbose(\"KeyPress: %s (%u)\", XKeysymToString(sym), map->mheg_key);\n\t\t\tMHEGEngine_keyPressed(map->mheg_key);\n\t\t}\n\t\tbreak;\n\n\tcase Expose:\n\t\texp = &event.xexpose;\n\t\tXCopyArea(d->dpy, d->contents, d->win, d->win_gc, exp->x, exp->y, exp->width, exp->height, exp->x, exp->y);\n\t\tbreak;\n\n\tcase NoExpose:\n\t\t/* ignore it */\n\t\tbreak;\n\n\tcase ClientMessage:\n\t\tcm = &event.xclient;\n\t\t/* cache these Atoms */\n\t\tif(wm_protocols == 0)\n\t\t{\n\t\t\twm_protocols = XInternAtom(d->dpy, \"WM_PROTOCOLS\", False);\n\t\t\twm_delete_window = XInternAtom(d->dpy, \"WM_DELETE_WINDOW\", False);\n\t\t}\n\t\tif(cm->message_type == wm_protocols\n\t\t&& cm->format == 32\n\t\t&& cm->data.l[0] == wm_delete_window)\n\t\t\tquit = true;\n\t\telse\n\t\t\tverbose(\"Ignoring ClientMessage type %s\", XGetAtomName(d->dpy, cm->message_type));\n\t\tbreak;\n\n\tdefault:\n\t\t/* pass it on to Xt */\n\t\tXtDispatchEvent(&event);\n\t\tbreak;\n\t}\n\n\treturn quit;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/*\n * convert MHEGColour to internal format\n */\n", "func_signal": "static void\ndisplay_colour(XRenderColor *out, MHEGColour *in)", "code": "{\n\t/* expand to 16 bits per channel */\n\tout->red = (in->r << 8) | in->r;\n\tout->green = (in->g << 8) | in->g;\n\tout->blue = (in->b << 8) | in->b;\n\n\t/* XRender has 0 as transparent and 65535 as opaque */\n\tout->alpha = ((255 - in->t) << 8) | (255 - in->t);\n\n\treturn;\n}", "path": "browser\\MHEGDisplay.c", "repo_name": "nexgenta/redbutton", "stars": 5, "license": "None", "language": "c", "size": 620}
{"docstring": "/* a report on the module status */\n", "func_signal": "static void megahal_report(const int idx, const int details)", "code": "{\n  if (details)\n  {\n    unsigned char ctr=0;\n    if (theq)\n    {\n      QUEUE *q=theq;\n      for (ctr=1; q->next; q=q->next) ctr++;\n    }\n    dprintf(idx, \"%d %s in queue taking up %d bytes of memory\\n\", ctr,\n      ((ctr == 1)? \"line\": \"lines\"), mem);\n  }\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n * Next, a hacked attempt at strdup(), since I can't use malloc() anywhere.\n */\n", "func_signal": "static char *mystrdup(const char *s)", "code": "{\n\tchar *mytmp = nmalloc(strlen(s)+1);\n\n\tif (mytmp==NULL) return NULL;\n\telse strcpy(mytmp, s);\n\n\treturn mytmp;\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tSearch_Dictionary\n *\n *\t\tPurpose:\t\tSearch the dictionary for the specified word, returning its\n *\t\t\t\t\t\tposition in the index if found, or the position where it\n *\t\t\t\t\t\tshould be inserted otherwise.\n */\n", "func_signal": "static int search_dictionary(DICTIONARY *dictionary, STRING word, bool *find)", "code": "{\n\tint position;\n\tint min;\n\tint max;\n\tint middle;\n\tint compar;\n\n\t/*\n\t *\t\tIf the dictionary is empty, then obviously the word won't be found\n\t */\n\tif(dictionary->size==0) {\n\t\tposition=0;\n\t\tgoto notfound;\n\t}\n\n\t/*\n\t *\t\tInitialize the lower and upper bounds of the search\n\t */\n\tmin=0;\n\tmax=dictionary->size-1;\n\t/*\n\t *\t\tSearch repeatedly, halving the search space each time, until either\n\t *\t\tthe entry is found, or the search space becomes empty\n\t */\n\twhile(TRUE) {\n\t\t/*\n\t\t *\t\tSee whether the middle element of the search space is greater\n\t\t *\t\tthan, equal to, or less than the element being searched for.\n\t\t */\n\t\tmiddle=(min+max)/2;\n\t\tcompar=wordcmp(word, dictionary->entry[dictionary->index[middle]]);\n\t\t/*\n\t\t *\t\tIf it is equal then we have found the element.  Otherwise we\n\t\t *\t\tcan halve the search space accordingly.\n\t\t */\n\t\tif(compar==0) {\n\t\t\tposition=middle;\n\t\t\tgoto found;\n\t\t} else if(compar>0) {\n\t\t\tif(max==middle) {\n\t\t\t\tposition=middle+1;\n\t\t\t\tgoto notfound;\n\t\t\t}\n\t\t\tmin=middle+1;\n\t\t} else {\n\t\t\tif(min==middle) {\n\t\t\t\tposition=middle;\n\t\t\t\tgoto notfound;\n\t\t\t}\n\t\t\tmax=middle-1;\n\t\t}\n\t}\n\nfound:\n\t*find=TRUE;\n\treturn(position);\n\nnotfound:\n\t*find=FALSE;\n\treturn(position);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tInitialize_Swap\n *\n *\t\tPurpose:\t\tRead a swap structure from a file.\n */\n", "func_signal": "static SWAP *initialize_swap(char *filename)", "code": "{\n\tSWAP *list;\n\tFILE *file=NULL;\n\tchar buffer[1024];\n\tchar *from;\n\tchar *to;\n\n\tlist=new_swap();\n\n\tif(filename==NULL) return(list);\n\n\tfile=fopen(filename, \"r\");\n\tif(file==NULL) return(list);\n\n\twhile(!feof(file)) {\n\n\t\tif(fgets(buffer, 1024, file)==NULL) break;\n\t\tif(buffer[0]=='#') continue;\n\t\tfrom=strtok(buffer, \"\\t \");\n\t\tto=strtok(NULL, \"\\t \\n#\");\n\n\t\tadd_swap(list, from, to);\n\t}\n\n\tfclose(file);\n\treturn(list);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tFind_Word\n *\n *\t\tPurpose:\t\tReturn the symbol corresponding to the word specified.\n *\t\t\t\t\t\tWe assume that the word with index zero is equal to a\n *\t\t\t\t\t\tNULL word, indicating an error condition.\n */\n", "func_signal": "static BYTE2 find_word(DICTIONARY *dictionary, STRING word)", "code": "{\n\tint position;\n\tbool found;\n\n\tposition=search_dictionary(dictionary, word, &found);\n\n\tif(found==TRUE) return(dictionary->index[position]);\n\telse return(0);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tAdd_Aux\n *\n *\t\tPurpose:\t\tAdd an auxilliary keyword to the keyword dictionary.\n */\n", "func_signal": "static void add_aux(MODEL *model, DICTIONARY *keys, STRING word)", "code": "{\n\tint symbol;\n\n\tsymbol=find_word(model->dictionary, word);\n\tif(symbol==0) return;\n\tif(isalnum(word.word[0])==0) return;\n\tsymbol=find_word(aux, word);\n\tif(symbol==0) return;\n\n\tadd_word(keys, word);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tBoundary\n *\n *\t\tPurpose:\t\tReturn whether or not a word boundary exists in a string\n *\t\t\t\t\t\tat the specified location.\n */\n", "func_signal": "static bool boundary(char *string, int position)", "code": "{\n\tif(position==0)\n\t\treturn(FALSE);\n\n\tif(position==(int)strlen(string))\n\t\treturn(TRUE);\n\n\tif(\n\t\t(string[position]=='\\'')&&\n\t\t(isalpha(string[position-1])!=0)&&\n\t\t(isalpha(string[position+1])!=0)\n\t)\n\t\treturn(FALSE);\n\n\tif(\n\t\t(position>1)&&\n\t\t(string[position-1]=='\\'')&&\n\t\t(isalpha(string[position-2])!=0)&&\n\t\t(isalpha(string[position])!=0)\n\t)\n\t\treturn(FALSE);\n\n\tif(\n\t\t(isalpha(string[position])!=0)&&\n\t\t(isalpha(string[position-1])==0)\n\t)\n\t\treturn(TRUE);\n\t\n\tif(\n\t\t(isalpha(string[position])==0)&&\n\t\t(isalpha(string[position-1])!=0)\n\t)\n\t\treturn(TRUE);\n\t\n\tif(isdigit(string[position])!=isdigit(string[position-1]))\n\t\treturn(TRUE);\n\n\treturn(FALSE);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tSeed\n *\n *\t\tPurpose:\t\tSeed the reply by guaranteeing that it contains a\n *\t\t\t\t\t\tkeyword, if one exists.\n */\n", "func_signal": "static int seed(MODEL *model, DICTIONARY *keys)", "code": "{\n\tregister int i;\n\tint symbol;\n\tint stop;\n\n\t/*\n\t *\t\tFix, thanks to Mark Tarrabain\n\t */\n\tif(model->halcontext[0]->branch==0) symbol=0;\n\telse symbol=model->halcontext[0]->tree[rnd(model->halcontext[0]->branch)]->symbol;\n\n\tif(keys->size>0) {\n\t\ti=rnd(keys->size);\n\t\tstop=i;\n\t\twhile(TRUE) {\n\t\t\tif(\n\t\t\t\t(find_word(model->dictionary, keys->entry[i])!=0)&&\n\t\t\t\t(find_word(aux, keys->entry[i])==0)\n\t\t\t) {\n\t\t\t\tsymbol=find_word(model->dictionary, keys->entry[i]);\n\t\t\t\treturn(symbol);\n\t\t\t}\n\t\t\t++i;\n\t\t\tif(i==keys->size) i=0;\n\t\t\tif(i==stop) return(symbol);\n\t\t}\n\t}\n\n\treturn(symbol);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tTrain\n *\n *\t\tPurpose:\t \tInfer a MegaHAL brain from the contents of a text file.\n */\n", "func_signal": "static void train(MODEL *model, char *filename)", "code": "{\n\tFILE *file;\n\tchar buffer[1024];\n\tDICTIONARY *words=NULL;\n\tint length;\n\n\tif(filename==NULL) return;\n\n\tfile=fopen(filename, \"r\");\n\tif(file==NULL) {\n\t\tputlog(LOG_MISC, \"*\", \"Unable to find the personality %s\\n\", filename);\n\t\treturn;\n\t}\n\n\tfseek(file, 0, 2);\n   length=ftell(file);\n   rewind(file);\n\n\twords=new_dictionary();\n\n\twhile(!feof(file)) {\n\n\t\tif(fgets(buffer, 1024, file)==NULL) break;\n\t\tif(buffer[0]=='#') continue;\n\n\t\tbuffer[strlen(buffer)-1]='\\0';\n\n\t\tupper(buffer);\n\t\tmake_words(buffer, words);\n\t\tlearn(model, words);\n\n\n\t}\n\n\tfree_dictionary(words);\n\tfclose(file);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tLearn\n *\n *\t\tPurpose:\t\tLearn from the user's input.\n */\n", "func_signal": "static void learn(MODEL *model, DICTIONARY *words)", "code": "{\n\tregister int i;\n\tBYTE2 symbol;\n\n\t/*\n\t *\t\tWe only learn from inputs which are long enough\n\t */\n\tif(words->size<=(model->order)) return;\n\n\t/*\n\t *\t\tTrain the model in the forwards direction.  Start by initializing\n\t *\t\tthe context of the model.\n\t */\n\tinitialize_context(model);\n\tmodel->halcontext[0]=model->forward;\n\tfor(i=0; i<words->size; ++i) {\n\t\t/*\n\t\t *\t\tAdd the symbol to the model's dictionary if necessary, and then\n\t\t *\t\tupdate the forward model accordingly.\n\t\t */\n\t\tsymbol=add_word(model->dictionary, words->entry[i]);\n\t\tupdate_model(model, symbol);\n\t}\n\t/*\n\t *\t\tAdd the sentence-terminating symbol.\n\t */\n\tupdate_model(model, 1);\n\n\t/*\n\t *\t\tTrain the model in the backwards direction.  Start by initializing\n\t *\t\tthe context of the model.\n\t */\n\tinitialize_context(model);\n\tmodel->halcontext[0]=model->backward;\n\tfor(i=words->size-1; i>=0; --i) {\n\t\t/*\n\t\t *\t\tFind the symbol in the model's dictionary, and then update\n\t\t *\t\tthe backward model accordingly.\n\t\t */\n\t\tsymbol=find_word(model->dictionary, words->entry[i]);\n\t\tupdate_model(model, symbol);\n\t}\n\t/*\n\t *\t\tAdd the sentence-terminating symbol.\n\t */\n\tupdate_model(model, 1);\n\n\treturn;\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tFind_Symbol\n *\n *\t\tPurpose:\t\tReturn a pointer to the child node, if one exists, which\n *\t\t\t\t\t\tcontains the specified symbol.\n */\n", "func_signal": "static TREE *find_symbol(TREE *node, int symbol)", "code": "{\n\tregister int i;\n\tTREE *found=NULL;\n\tbool found_symbol=FALSE;\n\n\t/* \n\t *\t\tPerform a binary search for the symbol.\n\t */\n\ti=search_node(node, symbol, &found_symbol);\n\tif(found_symbol==TRUE) found=node->tree[i];\n\n\treturn(found);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tAdd_Node\n *\n *\t\tPurpose:\t\tAttach a new child node to the sub-tree of the tree\n *\t\t\t\t\t\tspecified.\n */\n", "func_signal": "static void add_node(TREE *tree, TREE *node, int position)", "code": "{\n\tregister int i;\n\n\t/*\n\t *\t\tAllocate room for one more child node, which may mean allocating\n\t *\t\tthe sub-tree from scratch.\n\t */\n\tif(tree->tree==NULL) {\n\t\ttree->tree=(TREE **)nmalloc(sizeof(TREE *)*(tree->branch+1));\n\t} else {\n\t\ttree->tree=(TREE **)realloc((TREE **)(tree->tree),sizeof(TREE *)*\n\t\t(tree->branch+1));\n\t}\n\tif(tree->tree==NULL) {\n\t\terror(\"add_node\", \"Unable to reallocate subtree.\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\t\tShuffle the nodes down so that we can insert the new node at the\n\t *\t\tsubtree index given by position.\n\t */\n\tfor(i=tree->branch; i>position; --i)\n\t\ttree->tree[i]=tree->tree[i-1];\n\n\t/*\n\t *\t\tAdd the new node to the sub-tree.\n\t */\n\ttree->tree[position]=node;\n\ttree->branch+=1;\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tReply\n *\n *\t\tPurpose:\t\tGenerate a dictionary of reply words appropriate to the\n *\t\t\t\t\t\tgiven dictionary of keywords.\n */\n", "func_signal": "static DICTIONARY *reply(MODEL *model, DICTIONARY *keys)", "code": "{\n\tstatic DICTIONARY *replies=NULL;\n\tregister int i;\n\tint symbol;\n\tbool start=TRUE;\n\n\tif(replies==NULL) replies=new_dictionary();\n\tfree_dictionary(replies);\n\n\t/*\n\t *\t\tStart off by making sure that the model's context is empty.\n\t */\n\tinitialize_context(model);\n\tmodel->halcontext[0]=model->forward;\n\tused_key=FALSE;\n\n\t/*\n\t *\t\tGenerate the reply in the forward direction.\n\t */\n\twhile(TRUE) {\n\t\t/*\n\t\t *\t\tGet a random symbol from the current context.\n\t\t */\n\t\tif(start==TRUE) symbol=seed(model, keys);\n\t\telse symbol=babble(model, keys, replies);\n\t\tif((symbol==0)||(symbol==1)) break;\n\t\tstart=FALSE;\n\n\t\t/*\n\t\t *\t\tAppend the symbol to the reply dictionary.\n\t\t */\n\t\tif(replies->entry==NULL)\n\t\t\treplies->entry=(STRING *)nmalloc((replies->size+1)*sizeof(STRING));\n\t\telse\n\t\t\treplies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));\n\t\tif(replies->entry==NULL) {\n\t\t\terror(\"reply\", \"Unable to reallocate dictionary\");\n\t\t\treturn(NULL);\n\t\t}\n\n\t\treplies->entry[replies->size].length=\n\t\t\tmodel->dictionary->entry[symbol].length;\n\t\treplies->entry[replies->size].word=\n\t\t\tmodel->dictionary->entry[symbol].word;\n\t\treplies->size+=1;\n\n\t\t/*\n\t\t *\t\tExtend the current context of the model with the current symbol.\n\t\t */\n\t\tupdate_context(model, symbol);\n\t}\n\n\t/*\n\t *\t\tStart off by making sure that the model's context is empty.\n\t */\n\tinitialize_context(model);\n\tmodel->halcontext[0]=model->backward;\n\n\t/*\n\t *\t\tRe-create the context of the model from the current reply\n\t *\t\tdictionary so that we can generate backwards to reach the\n\t *\t\tbeginning of the string.\n\t */\n\tif(replies->size>0) for(i=MEGA_MIN(replies->size-1, model->order); i>=0; --i) {\n\t\tsymbol=find_word(model->dictionary, replies->entry[i]);\n\t\tupdate_context(model, symbol);\n\t}\n\n\t/*\n\t *\t\tGenerate the reply in the backward direction.\n\t */\n\twhile(TRUE) {\n\t\t/*\n\t\t *\t\tGet a random symbol from the current context.\n\t\t */\n\t\tsymbol=babble(model, keys, replies);\n\t\tif((symbol==0)||(symbol==1)) break;\n\n\t\t/*\n\t\t *\t\tPrepend the symbol to the reply dictionary.\n\t\t */\n\t\tif(replies->entry==NULL)\n\t\t\treplies->entry=(STRING *)nmalloc((replies->size+1)*sizeof(STRING));\n\t\telse\n\t\t\treplies->entry=(STRING *)realloc(replies->entry, (replies->size+1)*sizeof(STRING));\n\t\tif(replies->entry==NULL) {\n\t\t\terror(\"reply\", \"Unable to reallocate dictionary\");\n\t\t\treturn(NULL);\n\t\t}\n\n\t\t/*\n\t\t *\t\tShuffle everything up for the prepend.\n\t\t */\n\t\tfor(i=replies->size; i>0; --i) {\n\t\t\treplies->entry[i].length=replies->entry[i-1].length;\n\t\t\treplies->entry[i].word=replies->entry[i-1].word;\n\t\t}\n\n\t\treplies->entry[0].length=model->dictionary->entry[symbol].length;\n\t\treplies->entry[0].word=model->dictionary->entry[symbol].word;\n\t\treplies->size+=1;\n\n\t\t/*\n\t\t *\t\tExtend the current context of the model with the current symbol.\n\t\t */\n\t\tupdate_context(model, symbol);\n\t}\n\n\treturn(replies);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n * Copied from Eggdrop's src/dcc.c\n * Copyright (C) 1997 Robey Pointer\n * Copyright (C) 1999, 2000, 2001, 2002, 2003 Eggheads Development Team\n */\n", "func_signal": "static void strip_mirc_codes(int flags, char *text)", "code": "{\n  char *dd = text;\n\n  while (*text) {\n    switch (*text) {\n    case 2:                    /* Bold text */\n      if (flags & STRIP_BOLD) {\n        text++;\n        continue;\n      }\n      break;\n    case 3:                    /* mIRC colors? */\n      if (flags & STRIP_COLOR) {\n        if (isdigit(text[1])) { /* Is the first char a number? */\n          text += 2;            /* Skip over the ^C and the first digit */\n          if (isdigit(*text))\n            text++;             /* Is this a double digit number? */\n          if (*text == ',') {   /* Do we have a background color next? */\n            if (isdigit(text[1]))\n              text += 2;        /* Skip over the first background digit */\n            if (isdigit(*text))\n              text++;           /* Is it a double digit? */\n          }\n        } else\n          text++;\n        continue;\n      }\n      break;\n    case 7:\n      if (flags & STRIP_BELLS) {\n        text++;\n        continue;\n      }\n      break;\n    case 0x16:                 /* Reverse video */\n      if (flags & STRIP_REV) {\n        text++;\n        continue;\n      }\n      break;\n    case 0x1f:                 /* Underlined text */\n      if (flags & STRIP_UNDER) {\n        text++;\n        continue;\n      }\n      break;\n    case 033:\n      if (flags & STRIP_ANSI) {\n        text++;\n        if (*text == '[') {\n          text++;\n          while ((*text == ';') || isdigit(*text))\n            text++;\n          if (*text)\n            text++;             /* also kill the following char */\n        }\n        continue;\n      }\n      break;\n    }\n    *dd++ = *text++;            /* Move on to the next char */\n  }\n  *dd = 0;\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *    Function:   Generate_Reply\n *\n *    Purpose:    Take a string of user input and return a string of output\n *                which may vaguely be construed as containing a reply to\n *                whatever is in the input string.\n */\n", "func_signal": "static char *generate_reply(MODEL *model, DICTIONARY *words)", "code": "{\n\tstatic DICTIONARY *dummy=NULL;\n\tDICTIONARY *replywords;\n\tDICTIONARY *keywords;\n\tfloat surprise;\n\tfloat max_surprise;\n\tchar *output;\n\tstatic char *output_none=NULL;\n\tint count;\n\tint basetime;\n\n\t/*\n\t *\t\tCreate an array of keywords from the words in the user's input\n\t */\n\tkeywords=make_keywords(model, words);\n\n\t/*\n\t *\t\tMake sure some sort of reply exists\n\t */\n\tif(output_none==NULL) {\n\t\toutput_none=nmalloc(40);\n\t\tif(output_none!=NULL)\n\t\t\tstrcpy(output_none, \"I don't know enough to answer you yet!\");\n\t}\n\toutput=output_none;\n\tif(dummy==NULL) dummy=new_dictionary();\n\treplywords=reply(model, dummy);\n\tif(dissimilar(words, replywords)==TRUE) output=make_output(replywords);\n\n\t/*\n\t *\t\tLoop for the specified waiting period, generating and evaluating\n\t *\t\treplies\n\t */\n\tmax_surprise=(float)-1.0;\n\tcount=0;\n\tbasetime=time(NULL);\n\tdo {\n\t\treplywords=reply(model, keywords);\n\t\tsurprise=evaluate_reply(model, keywords, replywords);\n\t\t++count;\n\t\tif((surprise>max_surprise)&&(dissimilar(words, replywords)==TRUE)) {\n\t\t\tmax_surprise=surprise;\n\t\t\toutput=make_output(replywords);\n\t\t}\n\t} while((time(NULL)-basetime)<timeout);\n\n\t/*\n\t *\t\tReturn the best answer we generated\n\t */\n\treturn(output);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tFree_Dictionary\n *\n *\t\tPurpose:\t\tRelease the memory consumed by the dictionary.\n */\n", "func_signal": "static void free_dictionary(DICTIONARY *dictionary)", "code": "{\n\tif(dictionary==NULL) return;\n\tif(dictionary->entry!=NULL) {\n\t\tnfree(dictionary->entry);\n\t\tdictionary->entry=NULL;\n\t}\n\tif(dictionary->index!=NULL) {\n\t\tnfree(dictionary->index);\n\t\tdictionary->index=NULL;\n\t}\n\tdictionary->size=0;\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tShow_Dictionary\n *\n *\t\tPurpose:\t\tDisplay the dictionary for training purposes.\n */\n", "func_signal": "static void show_dictionary(DICTIONARY *dictionary)", "code": "{\n\tregister int i;\n\tregister int j;\n\tFILE *file;\n\n\tfile=fopen(\"megahal.dic\", \"w\");\n\tif(file==NULL) {\n\t\twarn(\"show_dictionary\", \"Unable to open file\");\n\t\treturn;\n\t}\n\n\tfor(i=0; i<dictionary->size; ++i) {\n\t\tfor(j=0; j<dictionary->entry[i].length; ++j)\n\t\t\tfprintf(file, \"%c\", dictionary->entry[i].word[j]);\n\t\tfprintf(file, \"\\n\");\n\t}\n\n\tfclose(file);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tLoad_Model\n *\n *\t\tPurpose:\t\tLoad a model into memory.\n */\n", "func_signal": "static bool load_model(char *filename, MODEL *model)", "code": "{\n\tFILE *file;\n\tchar cookie[16];\n\n\tif(filename==NULL) return(FALSE);\n\n\tfile=fopen(filename, \"rb\");\n\tif(file==NULL) {\n\t\twarn(\"load_model\", \"Unable to open file `%s'\", filename);\n\t\treturn(FALSE);\n\t}\n\n\tfread(cookie, sizeof(char), strlen(COOKIE), file);\n\tif(strncmp(cookie, COOKIE, strlen(COOKIE))!=0) {\n\t\twarn(\"load_model\", \"File `%s' is not a MegaHAL brain\", filename);\n\t\tgoto fail;\n\t}\n\n\tfread(&(model->order), sizeof(BYTE1), 1, file);\n\tload_tree(file, model->forward);\n\tload_tree(file, model->backward);\n\tload_dictionary(file, model->dictionary);\n\n\treturn(TRUE);\nfail:\n\tfclose(file);\n\n\treturn(FALSE);\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tCapitalize\n *\n *\t\tPurpose:\t\tConvert a string to look nice.\n */\n", "func_signal": "static void capitalize(char *string)", "code": "{\n\tregister int i,j=-1;\n\tbool start=TRUE;\n\n\tfor(i=0; i<(int)strlen(string); ++i) {\n\t\tif(isalpha(string[i])) {\n\t\t\tif(start==TRUE) { string[i]=(char)toupper((int)string[i]); j=i; }\n\t\t\telse string[i]=(char)tolower((int)string[i]);\n\t\t\tstart=FALSE;\n\t\t} else if(strchr(\" \",string[i])!=NULL) {            \n\t\t\tj=-1;\t\t\t\t\t\n\t\t}\n\t\t// Don't capitalize strings that begin with a irc handle, or http:// links.\n\t\tif(j>=0 && strchr(\":\",string[i])!=NULL)         \n\t\t\tstring[j]=(char)tolower((int)string[j]);\t\n\t\tif((i>2)&&(strchr(\"!.?\", string[i-1])!=NULL)&&(isspace(string[i])))\n\t\t\tstart=TRUE;\n\t}\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "/*\n *\t\tFunction:\tSave_Tree\n *\n *\t\tPurpose:\t\tSave a tree structure to the specified file.\n */\n", "func_signal": "static void save_tree(FILE *file, TREE *node)", "code": "{\n\tstatic int level=0;\n\tregister int i;\n\n\tfwrite(&(node->symbol), sizeof(BYTE2), 1, file);\n\tfwrite(&(node->usage), sizeof(BYTE4), 1, file);\n\tfwrite(&(node->count), sizeof(BYTE2), 1, file);\n\tfwrite(&(node->branch), sizeof(BYTE2), 1, file);\n\n\tfor(i=0; i<node->branch; ++i) {\n\t\t++level;\n\t\tsave_tree(file, node->tree[i]);\n\t\t--level;\n\t}\n}", "path": "megahal.c", "repo_name": "kurtisnelson/EggHal", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 144}
{"docstring": "// end of directory stuff\n", "func_signal": "int yaffs_symlink(const char *oldpath, const char *newpath)", "code": "{\n\tyaffs_Object *parent = NULL;\n\tyaffs_Object *obj;\n\tchar *name;\n\tint retVal= -1;\n\tint mode = 0; // ignore for now\n\t\n\tyaffsfs_Lock();\n\tparent = yaffsfs_FindDirectory(NULL,newpath,&name,0);\n\tobj = yaffs_MknodSymLink(parent,name,mode,0,0,oldpath);\n\tif(obj)\n\t{\n\t\tretVal = 0;\n\t}\n\telse\n\t{\n\t\tyaffsfs_SetError(-ENOSPC); // just assume no space for now\n\t\tretVal = -1;\n\t}\n\t\n\tyaffsfs_Unlock();\n\t\n\treturn retVal;\n\t\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* delete is called when the link count is zero and the inode\n * is put (ie. nobody wants to know about it anymore, time to\n * delete the file).\n * NB Must call clear_inode()\n */\n", "func_signal": "static void yaffs_delete_inode(struct inode *inode)", "code": "{\n\tyaffs_Object *obj = yaffs_InodeToObject(inode);\n\tyaffs_Device *dev;\n\n\tT(YAFFS_TRACE_OS,\n\t  (\"yaffs_delete_inode: ino %d, count %d %s\\n\", (int)inode->i_ino,\n\t   atomic_read(&inode->i_count),\n\t   obj ? \"object exists\" : \"null object\"));\n\n\tif (obj) {\n\t\tdev = obj->myDev;\n\t\tyaffs_GrossLock(dev);\n\t\tyaffs_DeleteFile(obj);\n\t\tyaffs_GrossUnlock(dev);\n\t}\n#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))\n        truncate_inode_pages (&inode->i_data, 0);\n#endif\n\tclear_inode(inode);\n}", "path": "yaffs2\\yaffs_fs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/*\n * Create a link...\n */\n", "func_signal": "static int yaffs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)", "code": "{\n\tstruct inode *inode = old_dentry->d_inode;\n\tyaffs_Object *obj = NULL;\n\tyaffs_Object *link = NULL;\n\tyaffs_Device *dev;\n\n\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_link\\n\"));\n\n\tobj = yaffs_InodeToObject(inode);\n\tdev = obj->myDev;\n\n\tyaffs_GrossLock(dev);\n\n\tif (!S_ISDIR(inode->i_mode))\t/* Don't link directories */\n\t{\n\t\tlink =\n\t\t    yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,\n\t\t\t       obj);\n\t}\n\n\tif (link) {\n\t\told_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);\n\t\td_instantiate(dentry, old_dentry->d_inode);\n\t\tatomic_inc(&old_dentry->d_inode->i_count);\n\t\tT(YAFFS_TRACE_OS,\n\t\t  (KERN_DEBUG \"yaffs_link link count %d i_count %d\\n\",\n\t\t   old_dentry->d_inode->i_nlink,\n\t\t   atomic_read(&old_dentry->d_inode->i_count)));\n\n\t}\n\n\tyaffs_GrossUnlock(dev);\n\n\tif (link) {\n\n\t\treturn 0;\n\t}\n\n\treturn -EPERM;\n}", "path": "yaffs2\\yaffs_fs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/*\n * Functions for robustisizing\n */\n", "func_signal": "static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND)", "code": "{\n\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;\n\n\t/* Mark the block for retirement */\n\tyaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;\n\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,\n\t  (TSTR(\"**>>Block %d marked for retirement\" TENDSTR), blockInNAND));\n\n\t/* TODO:\n\t * Just do a garbage collection on the affected block\n\t * then retire the block\n\t * NB recursion\n\t */\n}", "path": "yaffs2\\yaffs_tagscompat.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// NCB added 10/9/2002\n", "func_signal": "static __u16 yaffs_CalcNameSum(const char *name)", "code": "{\n\t__u16 sum = 0;\n\t__u16 i = 1;\n\t\n\t__u8 *bname = (__u8 *)name;\n\t\n\twhile (*bname)\n\t{\n\t\tsum += (*bname) * i;\n\t\ti++;\n\t\tbname++;\n\t}\n\treturn sum;\n}", "path": "yaffs2\\utils\\mkyaffsimage.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/********** Tags ECC calculations  *********/\n", "func_signal": "void yaffs_CalcECC(const __u8 * data, yaffs_Spare * spare)", "code": "{\n\tyaffs_ECCCalculate(data, spare->ecc1);\n\tyaffs_ECCCalculate(&data[256], spare->ecc2);\n}", "path": "yaffs2\\yaffs_tagscompat.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// yaffsfs_InitHandle\n/// Inilitalise handles on start-up.\n//\n", "func_signal": "static int yaffsfs_InitHandles(void)", "code": "{\n\tint i;\n\tfor(i = 0; i < YAFFSFS_N_HANDLES; i++)\n\t{\n\t\tyaffsfs_handle[i].inUse = 0;\n\t\tyaffsfs_handle[i].obj = NULL;\n\t}\n\treturn 0;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/********** Tags **********/\n", "func_signal": "static void yaffs_LoadTagsIntoSpare(yaffs_Spare * sparePtr,\n\t\t\t\t    yaffs_Tags * tagsPtr)", "code": "{\n\tyaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;\n\n\tyaffs_CalcTagsECC(tagsPtr);\n\n\tsparePtr->tagByte0 = tu->asBytes[0];\n\tsparePtr->tagByte1 = tu->asBytes[1];\n\tsparePtr->tagByte2 = tu->asBytes[2];\n\tsparePtr->tagByte3 = tu->asBytes[3];\n\tsparePtr->tagByte4 = tu->asBytes[4];\n\tsparePtr->tagByte5 = tu->asBytes[5];\n\tsparePtr->tagByte6 = tu->asBytes[6];\n\tsparePtr->tagByte7 = tu->asBytes[7];\n}", "path": "yaffs2\\yaffs_tagscompat.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "//yaffsfs_GetHandle\n// Grab a handle (when opening a file)\n//\n", "func_signal": "static int yaffsfs_GetHandle(void)", "code": "{\n\tint i;\n\tyaffsfs_Handle *h;\n\t\n\tfor(i = 0; i < YAFFSFS_N_HANDLES; i++)\n\t{\n\t\th = yaffsfs_GetHandlePointer(i);\n\t\tif(!h)\n\t\t{\n\t\t\t// todo bug: should never happen\n\t\t}\n\t\tif(!h->inUse)\n\t\t{\n\t\t\tmemset(h,0,sizeof(yaffsfs_Handle));\n\t\t\th->inUse=1;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// yaffsfs_FindObject turns a path for an existing object into the object\n// \n", "func_signal": "static yaffs_Object *yaffsfs_FindObject(yaffs_Object *relativeDirectory, const char *path,int symDepth)", "code": "{\n\tyaffs_Object *dir;\n\tchar *name;\n\t\n\tdir = yaffsfs_FindDirectory(relativeDirectory,path,&name,symDepth);\n\t\n\tif(dir && *name)\n\t{\n\t\treturn yaffs_FindObjectByName(dir,name);\n\t}\n\t\n\treturn dir;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* Calculate the ECC for a 256-byte block of data */\n", "func_signal": "void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)", "code": "{\n\tunsigned int i;\n\n\tunsigned char col_parity = 0;\n\tunsigned char line_parity = 0;\n\tunsigned char line_parity_prime = 0;\n\tunsigned char t;\n\tunsigned char b;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tb = column_parity_table[*data++];\n\t\tcol_parity ^= b;\n\n\t\tif (b & 0x01)\t// odd number of bits in the byte\n\t\t{\n\t\t\tline_parity ^= i;\n\t\t\tline_parity_prime ^= ~i;\n\t\t}\n\n\t}\n\n\tecc[2] = (~col_parity) | 0x03;\n\n\tt = 0;\n\tif (line_parity & 0x80)\n\t\tt |= 0x80;\n\tif (line_parity_prime & 0x80)\n\t\tt |= 0x40;\n\tif (line_parity & 0x40)\n\t\tt |= 0x20;\n\tif (line_parity_prime & 0x40)\n\t\tt |= 0x10;\n\tif (line_parity & 0x20)\n\t\tt |= 0x08;\n\tif (line_parity_prime & 0x20)\n\t\tt |= 0x04;\n\tif (line_parity & 0x10)\n\t\tt |= 0x02;\n\tif (line_parity_prime & 0x10)\n\t\tt |= 0x01;\n\tecc[1] = ~t;\n\n\tt = 0;\n\tif (line_parity & 0x08)\n\t\tt |= 0x80;\n\tif (line_parity_prime & 0x08)\n\t\tt |= 0x40;\n\tif (line_parity & 0x04)\n\t\tt |= 0x20;\n\tif (line_parity_prime & 0x04)\n\t\tt |= 0x10;\n\tif (line_parity & 0x02)\n\t\tt |= 0x08;\n\tif (line_parity_prime & 0x02)\n\t\tt |= 0x04;\n\tif (line_parity & 0x01)\n\t\tt |= 0x02;\n\tif (line_parity_prime & 0x01)\n\t\tt |= 0x01;\n\tecc[0] = ~t;\n\n#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER\n\t// Swap the bytes into the wrong order\n\tt = ecc[0];\n\tecc[0] = ecc[1];\n\tecc[1] = t;\n#endif\n}", "path": "yaffs2\\yaffs_ecc.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// yaffsfs_FindDirectory\n// Parse a path to determine the directory and the name within the directory.\n//\n// eg. \"/data/xx/ff\" --> puts name=\"ff\" and returns the directory \"/data/xx\"\n", "func_signal": "static yaffs_Object *yaffsfs_DoFindDirectory(yaffs_Object *startDir,const char *path,char **name,int symDepth)", "code": "{\n\tyaffs_Object *dir;\n\tchar *restOfPath;\n\tchar str[YAFFS_MAX_NAME_LENGTH+1];\n\tint i;\n\t\n\tif(symDepth > YAFFSFS_MAX_SYMLINK_DEREFERENCES)\n\t{\n\t\treturn NULL;\n\t}\n\t\n\tif(startDir)\n\t{\n\t\tdir = startDir;\n\t\trestOfPath = (char *)path;\n\t}\n\telse\n\t{\n\t\tdir = yaffsfs_FindRoot(path,&restOfPath);\n\t}\n\t\n\twhile(dir)\n\t{\t\n\t\t// parse off /.\n\t\t// curve ball: also throw away surplus '/' \n\t\t// eg. \"/ram/x////ff\" gets treated the same as \"/ram/x/ff\"\n\t\twhile(*restOfPath == '/')\n\t\t{\n\t\t\trestOfPath++; // get rid of '/'\n\t\t}\n\t\t\n\t\t*name = restOfPath;\n\t\ti = 0;\n\t\t\n\t\twhile(*restOfPath && *restOfPath != '/')\n\t\t{\n\t\t\tif (i < YAFFS_MAX_NAME_LENGTH)\n\t\t\t{\n\t\t\t\tstr[i] = *restOfPath;\n\t\t\t\tstr[i+1] = '\\0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\trestOfPath++;\n\t\t}\n\t\t\n\t\tif(!*restOfPath)\n\t\t{\n\t\t\t// got to the end of the string\n\t\t\treturn dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(strcmp(str,\".\") == 0)\n\t\t\t{\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if(strcmp(str,\"..\") == 0)\n\t\t\t{\n\t\t\t\tdir = dir->parent;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdir = yaffs_FindObjectByName(dir,str);\n\t\t\t\t\n\t\t\t\twhile(dir && dir->variantType == YAFFS_OBJECT_TYPE_SYMLINK)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tdir = yaffsfs_FollowLink(dir,symDepth);\n\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dir && dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)\n\t\t\t\t{\n\t\t\t\t\tdir = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// directory did not exist.\n\treturn NULL;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/*\n * ECCxxxOther does ECC calcs on arbitrary n bytes of data\n */\n", "func_signal": "void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,\n\t\t\t     yaffs_ECCOther * eccOther)", "code": "{\n\tunsigned int i;\n\n\tunsigned char col_parity = 0;\n\tunsigned line_parity = 0;\n\tunsigned line_parity_prime = 0;\n\tunsigned char b;\n\n\tfor (i = 0; i < nBytes; i++) {\n\t\tb = column_parity_table[*data++];\n\t\tcol_parity ^= b;\n\n\t\tif (b & 0x01)\t {\n\t\t\t/* odd number of bits in the byte */\n\t\t\tline_parity ^= i;\n\t\t\tline_parity_prime ^= ~i;\n\t\t}\n\n\t}\n\n\teccOther->colParity = (col_parity >> 2) & 0x3f;\n\teccOther->lineParity = line_parity;\n\teccOther->lineParityPrime = line_parity_prime;\n}", "path": "yaffs2\\yaffs_ecc.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* This little function converts a little endian tag to a big endian tag.\n * NOTE: The tag is not usable after this other than calculating the CRC\n * with.\n */\n", "func_signal": "static void little_to_big_endian(yaffs_Tags *tagsPtr)", "code": "{\n    yaffs_TagsUnion * tags = (yaffs_TagsUnion* )tagsPtr; // Work in bytes.\n    yaffs_TagsUnion   temp;\n\n    memset(&temp, 0, sizeof(temp));\n    // Ick, I hate magic numbers.\n    temp.asBytes[0] = ((tags->asBytes[2] & 0x0F) << 4) | ((tags->asBytes[1] & 0xF0) >> 4);\n    temp.asBytes[1] = ((tags->asBytes[1] & 0x0F) << 4) | ((tags->asBytes[0] & 0xF0) >> 4);\n    temp.asBytes[2] = ((tags->asBytes[0] & 0x0F) << 4) | ((tags->asBytes[2] & 0x30) >> 2) | ((tags->asBytes[3] & 0xC0) >> 6);\n    temp.asBytes[3] = ((tags->asBytes[3] & 0x3F) << 2) | ((tags->asBytes[2] & 0xC0) >> 6);\n    temp.asBytes[4] = ((tags->asBytes[6] & 0x03) << 6) | ((tags->asBytes[5] & 0xFC) >> 2);\n    temp.asBytes[5] = ((tags->asBytes[5] & 0x03) << 6) | ((tags->asBytes[4] & 0xFC) >> 2);\n    temp.asBytes[6] = ((tags->asBytes[4] & 0x03) << 6) | (tags->asBytes[7] & 0x3F);\n    temp.asBytes[7] = (tags->asBytes[6] & 0xFC) | ((tags->asBytes[7] & 0xC0) >> 6);\n\n    // Now copy it back.\n    tags->asBytes[0] = temp.asBytes[0];\n    tags->asBytes[1] = temp.asBytes[1];\n    tags->asBytes[2] = temp.asBytes[2];\n    tags->asBytes[3] = temp.asBytes[3];\n    tags->asBytes[4] = temp.asBytes[4];\n    tags->asBytes[5] = temp.asBytes[5];\n    tags->asBytes[6] = temp.asBytes[6];\n    tags->asBytes[7] = temp.asBytes[7];\n}", "path": "yaffs2\\utils\\mkyaffsimage.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// yaffs_PutHandle\n// Let go of a handle (when closing a file)\n//\n", "func_signal": "static int yaffsfs_PutHandle(int handle)", "code": "{\n\tyaffsfs_Handle *h = yaffsfs_GetHandlePointer(handle);\n\t\n\tif(h)\n\t{\n\t\th->inUse = 0;\n\t\th->obj = NULL;\n\t}\n\treturn 0;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* NOTYET */\n", "func_signal": "int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,\n\t\t\t\t\t\t    int chunkInNAND,\n\t\t\t\t\t\t    const __u8 * data,\n\t\t\t\t\t\t    const yaffs_ExtendedTags *\n\t\t\t\t\t\t    eTags)", "code": "{\n\tyaffs_Spare spare;\n\tyaffs_Tags tags;\n\n\tyaffs_SpareInitialise(&spare);\n\n\tif (eTags->chunkDeleted) {\n\t\tspare.pageStatus = 0;\n\t} else {\n\t\ttags.objectId = eTags->objectId;\n\t\ttags.chunkId = eTags->chunkId;\n\t\ttags.byteCount = eTags->byteCount;\n\t\ttags.serialNumber = eTags->serialNumber;\n\n\t\tif (!dev->useNANDECC && data) {\n\t\t\tyaffs_CalcECC(data, &spare);\n\t\t}\n\t\tyaffs_LoadTagsIntoSpare(&spare, &tags);\n\n\t}\n\n\treturn yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);\n}", "path": "yaffs2\\yaffs_tagscompat.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/*\n * The VFS layer already does all the dentry stuff for rename.\n *\n * NB: POSIX says you can rename an object over an old object of the same name\n */\n", "func_signal": "static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)", "code": "{\n\tyaffs_Device *dev;\n\tint retVal = YAFFS_FAIL;\n\tyaffs_Object *target;\n\n        T(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_rename\\n\"));\n\tdev = yaffs_InodeToObject(old_dir)->myDev;\n\n\tyaffs_GrossLock(dev);\n\n\t/* Check if the target is an existing directory that is not empty. */\n\ttarget =\n\t    yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),\n\t\t\t\t   new_dentry->d_name.name);\n\t\n\t\n\n\tif (target &&\n\t    target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&\n\t    !list_empty(&target->variant.directoryVariant.children)) {\n\t    \n\t        T(YAFFS_TRACE_OS, (KERN_DEBUG \"target is non-empty dir\\n\"));\n\n\t\tretVal = YAFFS_FAIL;\n\t} else {\n\n\t\t/* Now does unlinking internally using shadowing mechanism */\n\t        T(YAFFS_TRACE_OS, (KERN_DEBUG \"calling yaffs_RenameObject\\n\"));\n\t\t\n\t\tretVal =\n\t\t    yaffs_RenameObject(yaffs_InodeToObject(old_dir),\n\t\t\t\t       old_dentry->d_name.name,\n\t\t\t\t       yaffs_InodeToObject(new_dir),\n\t\t\t\t       new_dentry->d_name.name);\n\n\t}\n\tyaffs_GrossUnlock(dev);\n\n\tif (retVal == YAFFS_OK) {\n\t\tif(target) {\n\t\t\tnew_dentry->d_inode->i_nlink--;\n\t\t\tmark_inode_dirty(new_dentry->d_inode);\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOTEMPTY;\n\t}\n\n}", "path": "yaffs2\\yaffs_fs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* clear is called to tell the fs to release any per-inode data it holds */\n", "func_signal": "static void yaffs_clear_inode(struct inode *inode)", "code": "{\n\tyaffs_Object *obj;\n\tyaffs_Device *dev;\n\n\tobj = yaffs_InodeToObject(inode);\n\n\tT(YAFFS_TRACE_OS,\n\t  (\"yaffs_clear_inode: ino %d, count %d %s\\n\", (int)inode->i_ino,\n\t   atomic_read(&inode->i_count),\n\t   obj ? \"object exists\" : \"null object\"));\n\n\tif (obj) {\n\t\tdev = obj->myDev;\n\t\tyaffs_GrossLock(dev);\n\n\t\t/* Clear the association between the inode and\n\t\t * the yaffs_Object.\n\t\t */\n\t\tobj->myInode = NULL;\n\t\tinode->u.generic_ip = NULL;\n\n\t\t/* If the object freeing was deferred, then the real\n\t\t * free happens now.\n\t\t * This should fix the inode inconsistency problem.\n\t\t */\n\n\t\tyaffs_HandleDeferedFree(obj);\n\n\t\tyaffs_GrossUnlock(dev);\n\t}\n\n}", "path": "yaffs2\\yaffs_fs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/* For now put inode is just for debugging\n * Put inode is called when the inode **structure** is put.\n */\n", "func_signal": "static void yaffs_put_inode(struct inode *inode)", "code": "{\n\tT(YAFFS_TRACE_OS,\n\t  (\"yaffs_put_inode: ino %d, count %d\\n\", (int)inode->i_ino,\n\t   atomic_read(&inode->i_count)));\n\n}", "path": "yaffs2\\yaffs_fs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "// yaffsfs_FindDevice\n// yaffsfs_FindRoot\n// Scan the configuration list to find the root.\n// Curveballs: Should match paths that end in '/' too\n// Curveball2 Might have \"/x/ and \"/x/y\". Need to return the longest match\n", "func_signal": "static yaffs_Device *yaffsfs_FindDevice(const char *path, char **restOfPath)", "code": "{\n\tyaffsfs_DeviceConfiguration *cfg = yaffsfs_configurationList;\n\tconst char *leftOver;\n\tconst char *p;\n\tyaffs_Device *retval = NULL;\n\tint thisMatchLength;\n\tint longestMatch = -1;\n\t\n\t// Check all configs, choose the one that:\n\t// 1) Actually matches a prefix (ie /a amd /abc will not match\n\t// 2) Matches the longest.\n\twhile(cfg && cfg->prefix && cfg->dev)\n\t{\n\t\tleftOver = path;\n\t\tp = cfg->prefix;\n\t\tthisMatchLength = 0;\n\t\t\n\t\twhile(*p &&  //unmatched part of prefix \n\t\t      strcmp(p,\"/\") && // the rest of the prefix is not / (to catch / at end)\n\t\t      *leftOver && \n\t\t      yaffsfs_Match(*p,*leftOver))\n\t\t{\n\t\t\tp++;\n\t\t\tleftOver++;\n\t\t\tthisMatchLength++;\n\t\t}\n\t\tif((!*p || strcmp(p,\"/\") == 0) &&      // end of prefix\n\t\t   (!*leftOver || *leftOver == '/') && // no more in this path name part\n\t\t   (thisMatchLength > longestMatch))\n\t\t{\n\t\t\t// Matched prefix\n\t\t\t*restOfPath = (char *)leftOver;\n\t\t\tretval = cfg->dev;\n\t\t\tlongestMatch = thisMatchLength;\n\t\t}\n\t\tcfg++;\n\t}\n\treturn retval;\n}", "path": "yaffs2\\direct\\yaffsfs.c", "repo_name": "koush/android_external_yaffs2", "stars": 4, "license": "other", "language": "c", "size": 237}
{"docstring": "/**\n  Initializes a spin lock to the released state and returns the spin lock.\n\n  This function initializes the spin lock specified by SpinLock to the released\n  state, and returns SpinLock. Optimal performance can be achieved by calling\n  GetSpinLockProperties() to determine the size and alignment requirements for\n  SpinLock.\n\n  If SpinLock is NULL, then ASSERT().\n\n  @param  SpinLock  A pointer to the spin lock to initialize to the released\n                    state.\n\n  @return SpinLock\n\n**/\n", "func_signal": "SPIN_LOCK *\nEFIAPI\nInitializeSpinLock (\n  OUT     SPIN_LOCK                 *SpinLock\n  )", "code": "{\n  ASSERT (SpinLock != NULL);\n\n  _ReadWriteBarrier();\n  *SpinLock = SPIN_LOCK_RELEASED;\n  _ReadWriteBarrier();\n\n  return SpinLock;\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Performs an atomic decrement of an 32-bit unsigned integer.\n\n  Performs an atomic decrement of the 32-bit unsigned integer specified by\n  Value and returns the decremented value. The decrement operation must be\n  performed using MP safe mechanisms. The state of the return value is not\n  guaranteed to be MP safe.\n\n  If Value is NULL, then ASSERT().\n\n  @param  Value A pointer to the 32-bit value to decrement.\n\n  @return The decremented value.\n\n**/\n", "func_signal": "UINT32\nEFIAPI\nInterlockedDecrement (\n  IN      UINT32                    *Value\n  )", "code": "{\n  ASSERT (Value != NULL);\n  return InternalSyncDecrement (Value);\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Parse interested dhcp options.\n\n  @param  Buffer     Pointer to the dhcp options packet.\n  @param  Length     The length of the dhcp options.\n  @param  OptTag     The option OpCode.\n\n  @return NULL if the buffer length is 0 and OpCode is not\n          PXEBC_DHCP4_TAG_EOP, or the pointer to the buffer.\n\n**/\n", "func_signal": "EFI_DHCP4_PACKET_OPTION *\nPxeBcParseExtendOptions (\n  IN UINT8                         *Buffer,\n  IN UINT32                        Length,\n  IN UINT8                         OptTag\n  )", "code": "{\n  EFI_DHCP4_PACKET_OPTION *Option;\n  UINT32                  Offset;\n\n  Option  = (EFI_DHCP4_PACKET_OPTION *) Buffer;\n  Offset  = 0;\n\n  while (Offset < Length && Option->OpCode != PXEBC_DHCP4_TAG_EOP) {\n\n    if (Option->OpCode == OptTag) {\n\n      return Option;\n    }\n\n    if (Option->OpCode == PXEBC_DHCP4_TAG_PAD) {\n      Offset++;\n    } else {\n      Offset += Option->Length + 2;\n    }\n\n    Option = (EFI_DHCP4_PACKET_OPTION *) (Buffer + Offset);\n  }\n\n  return NULL;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Performs an atomic increment of an 32-bit unsigned integer.\n\n  Performs an atomic increment of the 32-bit unsigned integer specified by\n  Value and returns the incremented value. The increment operation must be\n  performed using MP safe mechanisms. The state of the return value is not\n  guaranteed to be MP safe.\n\n  If Value is NULL, then ASSERT().\n\n  @param  Value A pointer to the 32-bit value to increment.\n\n  @return The incremented value.\n\n**/\n", "func_signal": "UINT32\nEFIAPI\nInterlockedIncrement (\n  IN      UINT32                    *Value\n  )", "code": "{\n  ASSERT (Value != NULL);\n  return InternalSyncIncrement (Value);\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Performs an atomic compare exchange operation on a 64-bit unsigned integer.\n\n  Performs an atomic compare exchange operation on the 64-bit unsigned integer specified \n  by Value.  If Value is equal to CompareValue, then Value is set to ExchangeValue and \n  CompareValue is returned.  If Value is not equal to CompareValue, then Value is returned. \n  The compare exchange operation must be performed using MP safe mechanisms.\n\n  If Value is NULL, then ASSERT().\n\n  @param  Value         A pointer to the 64-bit value for the compare exchange\n                        operation.\n  @param  CompareValue  64-bit value used in compare operation.\n  @param  ExchangeValue 64-bit value used in exchange operation.\n\n  @return The original *Value before exchange.\n\n**/\n", "func_signal": "UINT64\nEFIAPI\nInterlockedCompareExchange64 (\n  IN OUT  UINT64                    *Value,\n  IN      UINT64                    CompareValue,\n  IN      UINT64                    ExchangeValue\n  )", "code": "{\n  ASSERT (Value != NULL);\n  return InternalSyncCompareExchange64 (Value, CompareValue, ExchangeValue);\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Copy the DCHP4 packet from srouce to destination.\n\n  @param  Dst   Pointer to the EFI_DHCP4_PROTOCOL instance.\n  @param  Src   Pointer to the EFI_DHCP4_PROTOCOL instance.\n\n**/\n", "func_signal": "VOID\nPxeBcCopyEfiDhcp4Packet (\n  IN EFI_DHCP4_PACKET  *Dst,\n  IN EFI_DHCP4_PACKET  *Src\n  )", "code": "{\n  ASSERT (Dst->Size >= Src->Length);\n\n  CopyMem (&Dst->Dhcp4, &Src->Dhcp4, Src->Length);\n  Dst->Length = Src->Length;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Select an interface to send the packet generated in the IP4 driver\n  itself, that is, not by the requests of IP4 child's consumer. Such\n  packets include the ICMP echo replies, and other ICMP error packets.\n\n  @param[in]  IpSb                 The IP4 service that wants to send the packets.\n  @param[in]  Dst                  The destination of the packet\n  @param[in]  Src                  The source of the packet\n\n  @return NULL if no proper interface is found, otherwise the interface that\n          can be used to send the system packet from.\n\n**/\n", "func_signal": "IP4_INTERFACE *\nIp4SelectInterface (\n  IN IP4_SERVICE            *IpSb,\n  IN IP4_ADDR               Dst,\n  IN IP4_ADDR               Src\n  )", "code": "{\n  IP4_INTERFACE             *IpIf;\n  IP4_INTERFACE             *Selected;\n  LIST_ENTRY                *Entry;\n\n  //\n  // Select the interface the Dst is on if one of the connected\n  // network. Some IP instance may be configured with 0.0.0.0/0,\n  // don't select that interface now.\n  //\n  IpIf = Ip4FindNet (IpSb, Dst);\n\n  if ((IpIf != NULL) && (IpIf->Ip != IP4_ALLZERO_ADDRESS)) {\n    return IpIf;\n  }\n\n  //\n  // If source is one of the interface address, select it.\n  //\n  IpIf = Ip4FindInterface (IpSb, Src);\n\n  if ((IpIf != NULL) && (IpIf->Ip != IP4_ALLZERO_ADDRESS)) {\n    return IpIf;\n  }\n\n  //\n  // Select a configured interface as the fall back. Always prefer\n  // an interface with non-zero address.\n  //\n  Selected = NULL;\n\n  NET_LIST_FOR_EACH (Entry, &IpSb->Interfaces) {\n    IpIf = NET_LIST_USER_STRUCT (Entry, IP4_INTERFACE, Link);\n\n    if (IpIf->Configured && ((Selected == NULL) || (Selected->Ip == 0))) {\n      Selected = IpIf;\n    }\n  }\n\n  return Selected;\n}", "path": "MdeModulePkg\\Universal\\Network\\Ip4Dxe\\Ip4Output.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Copy the dhcp4 packet to the PxeBc private data and parse the dhcp4 packet.\n\n  @param  Private       Pointer to PxeBc private data.\n  @param  OfferIndex    Index of cached packets as complements of pxe mode data,\n                        the index is maximum offer number.\n\n**/\n", "func_signal": "VOID\nPxeBcCopyProxyOffer (\n  IN PXEBC_PRIVATE_DATA  *Private,\n  IN UINT32              OfferIndex\n  )", "code": "{\n  EFI_PXE_BASE_CODE_MODE  *Mode;\n  EFI_DHCP4_PACKET        *Offer;\n\n  ASSERT (OfferIndex < Private->NumOffers);\n  ASSERT (OfferIndex < PXEBC_MAX_OFFER_NUM);\n\n  Mode  = Private->PxeBc.Mode;\n  Offer = &Private->Dhcp4Offers[OfferIndex].Packet.Offer;\n\n  PxeBcCopyEfiDhcp4Packet (&Private->ProxyOffer.Packet.Offer, Offer);\n  CopyMem (&Mode->ProxyOffer, &Offer->Dhcp4, Offer->Length);\n  Mode->ProxyOfferReceived = TRUE;\n\n  PxeBcParseCachedDhcpPacket (&Private->ProxyOffer);\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Save the current floating point/SSE/SSE2 context to a buffer.\n\n  Saves the current floating point/SSE/SSE2 state to the buffer specified by\n  Buffer. Buffer must be aligned on a 16-byte boundary. This function is only\n  available on IA-32 and X64.\n\n  If Buffer is NULL, then ASSERT().\n  If Buffer is not aligned on a 16-byte boundary, then ASSERT().\n\n  @param  Buffer  Pointer to a buffer to save the floating point/SSE/SSE2 context.\n\n**/\n", "func_signal": "VOID\nEFIAPI\nAsmFxSave (\n  OUT     IA32_FX_BUFFER            *Buffer\n  )", "code": "{\n  ASSERT (Buffer != NULL);\n  ASSERT (((UINTN)Buffer & 0xf) == 0);\n\n  InternalX86FxSave (Buffer);\n\n  //\n  // Mark one flag at end of Buffer, it will be check by AsmFxRestor()\n  //\n  *(UINT32 *) (&Buffer[sizeof (IA32_FX_BUFFER) - 4]) = 0xAA5555AA;\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\X86FxSave.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Parse the cached dhcp packet.\n\n  @param  CachedPacket  Pointer to cached dhcp packet.\n\n  @retval TRUE          Succeed to parse and validation.\n  @retval FALSE         Fail to parse or validation.\n\n**/\n", "func_signal": "BOOLEAN\nPxeBcParseCachedDhcpPacket (\n  IN PXEBC_CACHED_DHCP4_PACKET  *CachedPacket\n  )", "code": "{\n  EFI_DHCP4_PACKET        *Offer;\n  EFI_DHCP4_PACKET_OPTION **Options;\n  EFI_DHCP4_PACKET_OPTION *Option;\n  UINT8                   OfferType;\n  UINTN                   Index;\n\n  CachedPacket->IsPxeOffer = FALSE;\n  ZeroMem (CachedPacket->Dhcp4Option, sizeof (CachedPacket->Dhcp4Option));\n  ZeroMem (&CachedPacket->PxeVendorOption, sizeof (CachedPacket->PxeVendorOption));\n\n  Offer   = &CachedPacket->Packet.Offer;\n  Options = CachedPacket->Dhcp4Option;\n\n  //\n  // Parse interested dhcp options and store their pointers in CachedPacket->Dhcp4Option.\n  //\n  for (Index = 0; Index < PXEBC_DHCP4_TAG_INDEX_MAX; Index++) {\n    Options[Index] = PxeBcParseExtendOptions (\n                      Offer->Dhcp4.Option,\n                      GET_OPTION_BUFFER_LEN (Offer),\n                      mInterestedDhcp4Tags[Index]\n                      );\n  }\n\n  //\n  // Check whether is an offer with PXEClient or not.\n  //\n  Option = Options[PXEBC_DHCP4_TAG_INDEX_CLASS_ID];\n  if ((Option != NULL) && (Option->Length >= 9) &&\n    (CompareMem (Option->Data, DEFAULT_CLASS_ID_DATA, 9) == 0)) {\n\n    CachedPacket->IsPxeOffer = TRUE;\n  }\n\n  //\n  // Parse pxe vendor options and store their content/pointers in CachedPacket->PxeVendorOption.\n  //\n  Option = Options[PXEBC_DHCP4_TAG_INDEX_VENDOR];\n  if (CachedPacket->IsPxeOffer && (Option != NULL)) {\n\n    if (!PxeBcParseVendorOptions (Option, &CachedPacket->PxeVendorOption)) {\n      return FALSE;\n    }\n  }\n\n  //\n  // Check whether bootfilename/serverhostname overloaded (See details in dhcp spec).\n  // If overloaded, parse this buffer as nested dhcp options, or just parse bootfilename/\n  // serverhostname option.\n  //\n  Option = Options[PXEBC_DHCP4_TAG_INDEX_OVERLOAD];\n  if ((Option != NULL) && ((Option->Data[0] & PXEBC_DHCP4_OVERLOAD_FILE) != 0)) {\n\n    Options[PXEBC_DHCP4_TAG_INDEX_BOOTFILE] = PxeBcParseExtendOptions (\n                                                (UINT8 *) Offer->Dhcp4.Header.BootFileName,\n                                                sizeof (Offer->Dhcp4.Header.BootFileName),\n                                                PXEBC_DHCP4_TAG_BOOTFILE\n                                                );\n\n  } else if ((Options[PXEBC_DHCP4_TAG_INDEX_BOOTFILE] == NULL) &&\n            (Offer->Dhcp4.Header.BootFileName[0] != 0)) {\n    //\n    // If the bootfile is not present and bootfilename is present in dhcp packet, just parse it.\n    // And do not count dhcp option header, or else will destory the serverhostname.\n    //\n    Options[PXEBC_DHCP4_TAG_INDEX_BOOTFILE] = (EFI_DHCP4_PACKET_OPTION *) (&Offer->Dhcp4.Header.BootFileName[0] -\n                                            OFFSET_OF (EFI_DHCP4_PACKET_OPTION, Data[0]));\n\n  }\n\n  //\n  // Determine offer type of the dhcp packet.\n  //\n  Option = Options[PXEBC_DHCP4_TAG_INDEX_MSG_TYPE];\n  if ((Option == NULL) || (Option->Data[0] == 0)) {\n    //\n    // It's a bootp offer\n    //\n    Option = CachedPacket->Dhcp4Option[PXEBC_DHCP4_TAG_INDEX_BOOTFILE];\n    if (Option == NULL) {\n      //\n      // bootp offer without bootfilename, discard it.\n      //\n      return FALSE;\n    }\n\n    OfferType = DHCP4_PACKET_TYPE_BOOTP;\n\n  } else {\n\n    if (IS_VALID_DISCOVER_VENDOR_OPTION (CachedPacket->PxeVendorOption.BitMap)) {\n      //\n      // It's a pxe10 offer with PXEClient and discover vendor option.\n      //\n      OfferType = DHCP4_PACKET_TYPE_PXE10;\n    } else if (IS_VALID_MTFTP_VENDOR_OPTION (CachedPacket->PxeVendorOption.BitMap)) {\n      //\n      // It's a wfm11a offer with PXEClient and mtftp vendor option, and\n      // return false since mtftp not supported currently.\n      //\n      return FALSE;\n    } else {\n      //\n      // If the binl offer with only PXEClient.\n      //\n      OfferType = (UINT8) ((CachedPacket->IsPxeOffer) ? DHCP4_PACKET_TYPE_BINL : DHCP4_PACKET_TYPE_DHCP_ONLY);\n    }\n  }\n\n  CachedPacket->OfferType = OfferType;\n\n  return TRUE;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  This function display boot item detail.\n\n  If the length of the boot item string over 70 Char, just display 70 Char.\n\n  @param  Str     Pointer to a string (boot item string).\n  @param  Len     The length of string.\n\n**/\n", "func_signal": "VOID\nPxeBcDisplayBootItem (\n  IN UINT8                 *Str,\n  IN UINT8                 Len\n  )", "code": "{\n  UINT8 Tmp;\n\n  Len       = (UINT8) MIN (70, Len);\n  Tmp       = Str[Len];\n  Str[Len]  = 0;\n  AsciiPrint (\"%a \\n\", Str);\n  Str[Len] = Tmp;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Choose the boot prompt.\n\n  @param  Private              Pointer to PxeBc private data.\n\n  @retval EFI_SUCCESS          Select boot prompt done.\n  @retval EFI_TIMEOUT          Select boot prompt time out.\n  @retval EFI_NOT_FOUND        The proxy offer is not Pxe10.\n  @retval EFI_ABORTED          User cancel the operation.\n  @retval EFI_NOT_READY        Read the input key from the keybroad has not finish.\n\n**/\n", "func_signal": "EFI_STATUS\nPxeBcSelectBootPrompt (\n  IN PXEBC_PRIVATE_DATA              *Private\n  )", "code": "{\n  PXEBC_CACHED_DHCP4_PACKET  *Packet;\n  PXEBC_VENDOR_OPTION       *VendorOpt;\n  EFI_EVENT                  TimeoutEvent;\n  EFI_EVENT                  DescendEvent;\n  EFI_INPUT_KEY              InputKey;\n  EFI_STATUS                 Status;\n  UINT8                      Timeout;\n  UINT8                      *Prompt;\n  UINT8                      PromptLen;\n  INT32                      SecCol;\n  INT32                      SecRow;\n\n  TimeoutEvent  = NULL;\n  DescendEvent  = NULL;\n\n  if (Private->PxeBc.Mode->ProxyOfferReceived) {\n\n    Packet  = &Private->ProxyOffer;\n  } else {\n\n    Packet  = &Private->Dhcp4Ack;\n  }\n\n  if (Packet->OfferType != DHCP4_PACKET_TYPE_PXE10) {\n    return EFI_NOT_FOUND;\n  }\n\n  VendorOpt = &Packet->PxeVendorOption;\n\n  if (!IS_VALID_BOOT_PROMPT (VendorOpt->BitMap)) {\n    return EFI_SUCCESS;\n  }\n\n  Timeout   = VendorOpt->MenuPrompt->Timeout;\n  Prompt    = VendorOpt->MenuPrompt->Prompt;\n  PromptLen = (UINT8) (VendorOpt->MenuPromptLen - 1);\n\n  if (Timeout == 0) {\n    return EFI_SUCCESS;\n  }\n\n  if (Timeout == 255) {\n    return EFI_TIMEOUT;\n  }\n\n  Status = gBS->CreateEvent (\n                  EVT_TIMER,\n                  TPL_CALLBACK,\n                  NULL,\n                  NULL,\n                  &TimeoutEvent\n                  );\n\n  if (EFI_ERROR (Status)) {\n    return Status;\n  }\n\n  Status = gBS->SetTimer (\n                  TimeoutEvent,\n                  TimerRelative,\n                  Timeout * TICKS_PER_SECOND\n                  );\n\n  if (EFI_ERROR (Status)) {\n    goto ON_EXIT;\n  }\n\n  Status = gBS->CreateEvent (\n                  EVT_TIMER,\n                  TPL_CALLBACK,\n                  NULL,\n                  NULL,\n                  &DescendEvent\n                  );\n\n  if (EFI_ERROR (Status)) {\n    goto ON_EXIT;\n  }\n\n  Status = gBS->SetTimer (\n                  DescendEvent,\n                  TimerPeriodic,\n                  TICKS_PER_SECOND\n                  );\n\n  if (EFI_ERROR (Status)) {\n    goto ON_EXIT;\n  }\n\n  SecCol = gST->ConOut->Mode->CursorColumn;\n  SecRow = gST->ConOut->Mode->CursorRow;\n\n  PxeBcDisplayBootItem (Prompt, PromptLen);\n\n  gST->ConOut->SetCursorPosition (gST->ConOut, SecCol + PromptLen, SecRow);\n  AsciiPrint (\"(%d) \", Timeout--);\n\n  while (EFI_ERROR (gBS->CheckEvent (TimeoutEvent))) {\n\n    if (!EFI_ERROR (gBS->CheckEvent (DescendEvent))) {\n      gST->ConOut->SetCursorPosition (gST->ConOut, SecCol + PromptLen, SecRow);\n      AsciiPrint (\"(%d) \", Timeout--);\n    }\n\n    if (gST->ConIn->ReadKeyStroke (gST->ConIn, &InputKey) == EFI_NOT_READY) {\n\n      gBS->Stall (10 * TICKS_PER_MS);\n      continue;\n    }\n\n    if (InputKey.ScanCode == 0) {\n\n      switch (InputKey.UnicodeChar) {\n      case CTRL ('c'):\n        Status = EFI_ABORTED;\n        break;\n\n      case CTRL ('m'):\n      case 'm':\n      case 'M':\n        Status = EFI_TIMEOUT;\n        break;\n\n      default:\n        continue;\n      }\n    } else {\n\n      switch (InputKey.ScanCode) {\n      case SCAN_F8:\n        Status = EFI_TIMEOUT;\n        break;\n\n      case SCAN_ESC:\n        Status = EFI_ABORTED;\n        break;\n\n      default:\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  gST->ConOut->SetCursorPosition (gST->ConOut, 0 , SecRow + 1);\n\nON_EXIT:\n\n  if (DescendEvent != NULL) {\n    gBS->CloseEvent (DescendEvent);\n  }\n\n  if (TimeoutEvent != NULL) {\n    gBS->CloseEvent (TimeoutEvent);\n  }\n\n  return Status;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Cache the Dhcp4 packet offer, Parse and validate each option of the packet.\n\n  @param  Private    Pointer to PxeBc private data.\n  @param  RcvdOffer  Pointer to the received Dhcp proxy offer packet.\n\n**/\n", "func_signal": "VOID\nPxeBcCacheDhcpOffer (\n  IN PXEBC_PRIVATE_DATA  *Private,\n  IN EFI_DHCP4_PACKET    *RcvdOffer\n  )", "code": "{\n  PXEBC_CACHED_DHCP4_PACKET *CachedOffer;\n  EFI_DHCP4_PACKET          *Offer;\n  UINT8                     OfferType;\n\n  CachedOffer = &Private->Dhcp4Offers[Private->NumOffers];\n  Offer       = &CachedOffer->Packet.Offer;\n\n  //\n  // Cache the orignal dhcp packet\n  //\n  PxeBcCopyEfiDhcp4Packet (Offer, RcvdOffer);\n\n  //\n  // Parse and validate the options (including dhcp option and vendor option)\n  //\n  if (!PxeBcParseCachedDhcpPacket (CachedOffer)) {\n    return ;\n  }\n\n  OfferType = CachedOffer->OfferType;\n  ASSERT (OfferType < DHCP4_PACKET_TYPE_MAX);\n\n  if (OfferType == DHCP4_PACKET_TYPE_BOOTP) {\n\n    if (Private->BootpIndex != 0) {\n      //\n      // Only cache the first bootp offer, discard others.\n      //\n      return ;\n    } else {\n      //\n      // Take as a dhcp only offer, but record index specifically.\n      //\n      Private->BootpIndex = Private->NumOffers + 1;\n    }\n  } else {\n\n    if (IS_PROXY_DHCP_OFFER (Offer)) {\n      //\n      // It's a proxy dhcp offer with no your address, including pxe10, wfm11a or binl offer.\n      //\n      Private->GotProxyOffer = TRUE;\n\n      if (OfferType == DHCP4_PACKET_TYPE_BINL) {\n        //\n        // Cache all binl offers.\n        //\n        Private->BinlIndex[Private->ProxyIndex[DHCP4_PACKET_TYPE_BINL]] = Private->NumOffers;\n        Private->ProxyIndex[DHCP4_PACKET_TYPE_BINL]++;\n      } else if (Private->ProxyIndex[OfferType] != 0) {\n        //\n        // Only cache the first pxe10/wfm11a offers each, discard the others.\n        //\n        return ;\n      } else {\n        //\n        // Record index of the proxy dhcp offer with type other than binl.\n        //\n        Private->ProxyIndex[OfferType] = Private->NumOffers + 1;\n      }\n    } else {\n      //\n      // It's a dhcp offer with your address.\n      //\n      ASSERT (Private->ServerCount[OfferType] < PXEBC_MAX_OFFER_NUM);\n      Private->OfferIndex[OfferType][Private->ServerCount[OfferType]] = Private->NumOffers;\n      Private->ServerCount[OfferType]++;\n    }\n  }\n\n  //\n  // Count the accepted offers.\n  //\n  Private->NumOffers++;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Attempts to place a spin lock in the acquired state.\n\n  This function checks the state of the spin lock specified by SpinLock. If\n  SpinLock is in the released state, then this function places SpinLock in the\n  acquired state and returns TRUE. Otherwise, FALSE is returned. All state\n  transitions of SpinLock must be performed using MP safe mechanisms.\n\n  If SpinLock is NULL, then ASSERT().\n  If SpinLock was not initialized with InitializeSpinLock(), then ASSERT().\n\n  @param  SpinLock  A pointer to the spin lock to place in the acquired state.\n\n  @retval TRUE  SpinLock was placed in the acquired state.\n  @retval FALSE SpinLock could not be acquired.\n\n**/\n", "func_signal": "BOOLEAN\nEFIAPI\nAcquireSpinLockOrFail (\n  IN OUT  SPIN_LOCK                 *SpinLock\n  )", "code": "{\n  SPIN_LOCK   LockValue;\n  VOID        *Result;\n  \n  ASSERT (SpinLock != NULL);\n\n  LockValue = *SpinLock;\n  ASSERT (LockValue == SPIN_LOCK_ACQUIRED || LockValue == SPIN_LOCK_RELEASED);\n\n  _ReadWriteBarrier ();\n  Result = InterlockedCompareExchangePointer (\n             (VOID**)SpinLock,\n             (VOID*)SPIN_LOCK_RELEASED,\n             (VOID*)SPIN_LOCK_ACQUIRED\n           );\n\n  _ReadWriteBarrier ();\n  return (BOOLEAN) (Result == (VOID*) SPIN_LOCK_RELEASED);\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  This function is to check the selected proxy offer (include BINL dhcp offer and\n  DHCP_ONLY offer ) and set the flag and copy the DHCP packets to the Pxe base code\n  mode structure.\n\n  @param  Private          Pointer to PxeBc private data.\n\n  @retval EFI_SUCCESS      Operational successful.\n  @retval EFI_NO_RESPONSE  Offer dhcp service failed.\n\n**/\n", "func_signal": "EFI_STATUS\nPxeBcCheckSelectedOffer (\n  IN PXEBC_PRIVATE_DATA  *Private\n  )", "code": "{\n  PXEBC_CACHED_DHCP4_PACKET *SelectedOffer;\n  EFI_DHCP4_PACKET_OPTION   **Options;\n  UINT32                    Index;\n  EFI_DHCP4_PACKET          *Offer;\n  UINT32                    ProxyOfferIndex;\n  EFI_STATUS                Status;\n  EFI_PXE_BASE_CODE_MODE    *Mode;\n  EFI_DHCP4_PACKET          *Ack;\n\n  ASSERT (Private->SelectedOffer != 0);\n\n  Status        = EFI_SUCCESS;\n  SelectedOffer = &Private->Dhcp4Offers[Private->SelectedOffer - 1];\n  Options       = SelectedOffer->Dhcp4Option;\n\n  if (SelectedOffer->OfferType == DHCP4_PACKET_TYPE_BINL) {\n    //\n    // The addresses are acquired from a BINL dhcp offer, try BINL to get\n    // the bootfile name\n    //\n    if (!PxeBcTryBinl (Private, Private->SelectedOffer - 1)) {\n      Status = EFI_NO_RESPONSE;\n    }\n  } else if (SelectedOffer->OfferType == DHCP4_PACKET_TYPE_DHCP_ONLY) {\n    //\n    // The selected offer to finish the D.O.R.A. is a DHCP only offer, we need\n    // try proxy offers if there are some, othewise the bootfile name must be\n    // set in this DHCP only offer.\n    //\n    if (Private->GotProxyOffer) {\n      //\n      // Get rid of the compiler warning.\n      //\n      ProxyOfferIndex = 0;\n      if (Private->SortOffers) {\n        //\n        // The offers are sorted before selecting, the proxy offer type must be\n        // already determined.\n        //\n        ASSERT (Private->ProxyIndex[Private->ProxyOfferType] > 0);\n\n        if (Private->ProxyOfferType == DHCP4_PACKET_TYPE_BINL) {\n          //\n          // We buffer all received BINL proxy offers, try them all one by one\n          //\n          if (!PxeBcTryBinlProxy (Private, &ProxyOfferIndex)) {\n            Status = EFI_NO_RESPONSE;\n          }\n        } else {\n          //\n          // For other types, only one proxy offer is buffered.\n          //\n          ProxyOfferIndex = Private->ProxyIndex[Private->ProxyOfferType] - 1;\n        }\n      } else {\n        //\n        // The proxy offer type is not determined, choose proxy offer in the\n        // received order.\n        //\n        Status = EFI_NO_RESPONSE;\n\n        for (Index = 0; Index < Private->NumOffers; Index++) {\n\n          Offer = &Private->Dhcp4Offers[Index].Packet.Offer;\n          if (!IS_PROXY_DHCP_OFFER (Offer)) {\n            //\n            // Skip non proxy dhcp offers.\n            //\n            continue;\n          }\n\n          if (Private->Dhcp4Offers[Index].OfferType == DHCP4_PACKET_TYPE_BINL) {\n            //\n            // Try BINL\n            //\n            if (!PxeBcTryBinl (Private, Index)) {\n              //\n              // Failed, skip to the next offer\n              //\n              continue;\n            }\n          }\n\n          Private->ProxyOfferType = Private->Dhcp4Offers[Index].OfferType;\n          ProxyOfferIndex         = Index;\n          Status                  = EFI_SUCCESS;\n          break;\n        }\n      }\n\n      if (!EFI_ERROR (Status) && (Private->ProxyOfferType != DHCP4_PACKET_TYPE_BINL)) {\n        //\n        // Copy the proxy offer to Mode and set the flag\n        //\n        PxeBcCopyProxyOffer (Private, ProxyOfferIndex);\n      }\n    } else {\n      //\n      // No proxy offer is received, the bootfile name MUST be set.\n      //\n      ASSERT (Options[PXEBC_DHCP4_TAG_INDEX_BOOTFILE] != NULL);\n    }\n  }\n\n  if (!EFI_ERROR (Status)) {\n    //\n    // Everything is OK, set the flag and copy the DHCP packets.\n    //\n    Mode  = Private->PxeBc.Mode;\n    Offer = &SelectedOffer->Packet.Offer;\n\n    //\n    // The discover packet is already copied, just set flag here.\n    //\n    Mode->DhcpDiscoverValid = TRUE;\n\n    Ack                     = &Private->Dhcp4Ack.Packet.Ack;\n    if (SelectedOffer->OfferType == DHCP4_PACKET_TYPE_BOOTP) {\n      //\n      // Other type of ACK is already cached. Bootp is special that we should\n      // use the bootp reply as the ACK and put it into the DHCP_ONLY buffer.\n      //\n      PxeBcCopyEfiDhcp4Packet (&Private->Dhcp4Ack.Packet.Ack, Offer);\n    }\n\n    PxeBcParseCachedDhcpPacket (&Private->Dhcp4Ack);\n\n    Mode->DhcpAckReceived = TRUE;\n\n    //\n    // Copy the dhcp ack.\n    //\n    CopyMem (&Mode->DhcpAck, &Ack->Dhcp4, Ack->Length);\n  }\n\n  return Status;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  The filter function to find a packet and all its fragments.\n  The packet's fragments have their Context set to the packet.\n\n  @param[in]  Frame            The frames hold by the low level interface\n  @param[in]  Context          Context to the function, which is the packet.\n\n  @retval TRUE                 This is the packet to cancel or its fragments.\n  @retval FALSE                This is unrelated packet.\n\n**/\n", "func_signal": "BOOLEAN\nIp4CancelPacketFragments (\n  IN IP4_LINK_TX_TOKEN   *Frame,\n  IN VOID                *Context\n  )", "code": "{\n  if ((Frame->Packet == (NET_BUF *) Context) || (Frame->Context == Context)) {\n    return TRUE;\n  }\n\n  return FALSE;\n}", "path": "MdeModulePkg\\Universal\\Network\\Ip4Dxe\\Ip4Output.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Waits until a spin lock can be placed in the acquired state.\n\n  This function checks the state of the spin lock specified by SpinLock. If\n  SpinLock is in the released state, then this function places SpinLock in the\n  acquired state and returns SpinLock. Otherwise, this function waits\n  indefinitely for the spin lock to be released, and then places it in the\n  acquired state and returns SpinLock. All state transitions of SpinLock must\n  be performed using MP safe mechanisms.\n\n  If SpinLock is NULL, then ASSERT().\n  If SpinLock was not initialized with InitializeSpinLock(), then ASSERT().\n  If PcdSpinLockTimeout is not zero, and SpinLock is can not be acquired in\n  PcdSpinLockTimeout microseconds, then ASSERT().\n\n  @param  SpinLock  A pointer to the spin lock to place in the acquired state.\n\n  @return SpinLock\n\n**/\n", "func_signal": "SPIN_LOCK *\nEFIAPI\nAcquireSpinLock (\n  IN OUT  SPIN_LOCK                 *SpinLock\n  )", "code": "{\n  UINT64                            Tick;\n  UINT64                            Start, End;\n  UINT64                            Timeout;\n\n  Tick = 0;\n  Start = 0;\n  End = 0;\n  if (PcdGet32 (PcdSpinLockTimeout) > 0) {\n    Tick = GetPerformanceCounter ();\n    Timeout = DivU64x32 (\n                MultU64x32 (\n                  GetPerformanceCounterProperties (&Start, &End),\n                  PcdGet32 (PcdSpinLockTimeout)\n                  ),\n                1000000\n                );\n    if (Start < End) {\n      Tick += Timeout;\n    } else {\n      Tick -= Timeout;\n    }\n  }\n\n  while (!AcquireSpinLockOrFail (SpinLock)) {\n    CpuPause ();\n    ASSERT ((Start < End) ^ (Tick <= GetPerformanceCounter ()));\n  }\n  return SpinLock;\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Initialize the DHCP options and build the option list.\n\n  @param  Private          Pointer to PxeBc private data.\n  @param  OptList          Pointer to a DHCP option list.\n\n  @param  IsDhcpDiscover   Discover dhcp option or not.\n\n  @return The index item number of the option list.\n\n**/\n", "func_signal": "UINT32\nPxeBcBuildDhcpOptions (\n  IN PXEBC_PRIVATE_DATA            *Private,\n  IN EFI_DHCP4_PACKET_OPTION       **OptList,\n  IN BOOLEAN                       IsDhcpDiscover\n  )", "code": "{\n  UINT32                    Index;\n  PXEBC_DHCP4_OPTION_ENTRY  OptEnt;\n  UINT16                    Value;\n  CHAR8                     *SystemSerialNumber;\n\n  Index       = 0;\n  OptList[0]  = (EFI_DHCP4_PACKET_OPTION *) Private->OptionBuffer;\n\n  if (!IsDhcpDiscover) {\n    //\n    // Append message type.\n    //\n    OptList[Index]->OpCode  = PXEBC_DHCP4_TAG_MSG_TYPE;\n    OptList[Index]->Length  = 1;\n    OptEnt.Mesg             = (PXEBC_DHCP4_OPTION_MESG *) OptList[Index]->Data;\n    OptEnt.Mesg->Type       = PXEBC_DHCP4_MSG_TYPE_REQUEST;\n    Index++;\n    OptList[Index]          = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n\n    //\n    // Append max message size.\n    //\n    OptList[Index]->OpCode  = PXEBC_DHCP4_TAG_MAXMSG;\n    OptList[Index]->Length  = sizeof (PXEBC_DHCP4_OPTION_MAX_MESG_SIZE);\n    OptEnt.MaxMesgSize      = (PXEBC_DHCP4_OPTION_MAX_MESG_SIZE *) OptList[Index]->Data;\n    Value                   = NTOHS (PXEBC_DHCP4_MAX_PACKET_SIZE);\n    CopyMem (&OptEnt.MaxMesgSize->Size, &Value, sizeof (UINT16));\n    Index++;\n    OptList[Index]          = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n  }\n  //\n  // Parameter request list option.\n  //\n  OptList[Index]->OpCode    = PXEBC_DHCP4_TAG_PARA_LIST;\n  OptList[Index]->Length    = 35;\n  OptEnt.Para               = (PXEBC_DHCP4_OPTION_PARA *) OptList[Index]->Data;\n  OptEnt.Para->ParaList[0]  = PXEBC_DHCP4_TAG_NETMASK;\n  OptEnt.Para->ParaList[1]  = PXEBC_DHCP4_TAG_TIME_OFFSET;\n  OptEnt.Para->ParaList[2]  = PXEBC_DHCP4_TAG_ROUTER;\n  OptEnt.Para->ParaList[3]  = PXEBC_DHCP4_TAG_TIME_SERVER;\n  OptEnt.Para->ParaList[4]  = PXEBC_DHCP4_TAG_NAME_SERVER;\n  OptEnt.Para->ParaList[5]  = PXEBC_DHCP4_TAG_DNS_SERVER;\n  OptEnt.Para->ParaList[6]  = PXEBC_DHCP4_TAG_HOSTNAME;\n  OptEnt.Para->ParaList[7]  = PXEBC_DHCP4_TAG_BOOTFILE_LEN;\n  OptEnt.Para->ParaList[8]  = PXEBC_DHCP4_TAG_DOMAINNAME;\n  OptEnt.Para->ParaList[9]  = PXEBC_DHCP4_TAG_ROOTPATH;\n  OptEnt.Para->ParaList[10] = PXEBC_DHCP4_TAG_EXTEND_PATH;\n  OptEnt.Para->ParaList[11] = PXEBC_DHCP4_TAG_EMTU;\n  OptEnt.Para->ParaList[12] = PXEBC_DHCP4_TAG_TTL;\n  OptEnt.Para->ParaList[13] = PXEBC_DHCP4_TAG_BROADCAST;\n  OptEnt.Para->ParaList[14] = PXEBC_DHCP4_TAG_NIS_DOMAIN;\n  OptEnt.Para->ParaList[15] = PXEBC_DHCP4_TAG_NIS_SERVER;\n  OptEnt.Para->ParaList[16] = PXEBC_DHCP4_TAG_NTP_SERVER;\n  OptEnt.Para->ParaList[17] = PXEBC_DHCP4_TAG_VENDOR;\n  OptEnt.Para->ParaList[18] = PXEBC_DHCP4_TAG_REQUEST_IP;\n  OptEnt.Para->ParaList[19] = PXEBC_DHCP4_TAG_LEASE;\n  OptEnt.Para->ParaList[20] = PXEBC_DHCP4_TAG_SERVER_ID;\n  OptEnt.Para->ParaList[21] = PXEBC_DHCP4_TAG_T1;\n  OptEnt.Para->ParaList[22] = PXEBC_DHCP4_TAG_T2;\n  OptEnt.Para->ParaList[23] = PXEBC_DHCP4_TAG_CLASS_ID;\n  OptEnt.Para->ParaList[24] = PXEBC_DHCP4_TAG_TFTP;\n  OptEnt.Para->ParaList[25] = PXEBC_DHCP4_TAG_BOOTFILE;\n  OptEnt.Para->ParaList[26] = PXEBC_PXE_DHCP4_TAG_UUID;\n  OptEnt.Para->ParaList[27] = 0x80;\n  OptEnt.Para->ParaList[28] = 0x81;\n  OptEnt.Para->ParaList[29] = 0x82;\n  OptEnt.Para->ParaList[30] = 0x83;\n  OptEnt.Para->ParaList[31] = 0x84;\n  OptEnt.Para->ParaList[32] = 0x85;\n  OptEnt.Para->ParaList[33] = 0x86;\n  OptEnt.Para->ParaList[34] = 0x87;\n  Index++;\n  OptList[Index]            = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n\n  //\n  // Append UUID/Guid-based client identifier option\n  //\n  OptList[Index]->OpCode  = PXEBC_PXE_DHCP4_TAG_UUID;\n  OptList[Index]->Length  = sizeof (PXEBC_DHCP4_OPTION_UUID);\n  OptEnt.Uuid             = (PXEBC_DHCP4_OPTION_UUID *) OptList[Index]->Data;\n  OptEnt.Uuid->Type       = 0;\n  Index++;\n  OptList[Index]          = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n\n  if (EFI_ERROR (GetSmbiosSystemGuidAndSerialNumber ((EFI_GUID *) OptEnt.Uuid->Guid, &SystemSerialNumber))) {\n    //\n    // GUID not yet set - send all 0xff's to show programable (via SetVariable)\n    // SetMem(DHCPV4_OPTIONS_BUFFER.DhcpPlatformId.Guid, sizeof(EFI_GUID), 0xff);\n    // GUID not yet set - send all 0's to show not programable\n    //\n    ZeroMem (OptEnt.Uuid->Guid, sizeof (EFI_GUID));\n  }\n\n  //\n  // Append client network device interface option\n  //\n  OptList[Index]->OpCode  = PXEBC_PXE_DHCP4_TAG_UNDI;\n  OptList[Index]->Length  = sizeof (PXEBC_DHCP4_OPTION_UNDI);\n  OptEnt.Undi             = (PXEBC_DHCP4_OPTION_UNDI *) OptList[Index]->Data;\n  if (Private->Nii != NULL) {\n    OptEnt.Undi->Type       = Private->Nii->Type;\n    OptEnt.Undi->MajorVer   = Private->Nii->MajorVer;\n    OptEnt.Undi->MinorVer   = Private->Nii->MinorVer;\n  } else {\n    OptEnt.Undi->Type       = DEFAULT_UNDI_TYPE;\n    OptEnt.Undi->MajorVer   = DEFAULT_UNDI_MAJOR;\n    OptEnt.Undi->MinorVer   = DEFAULT_UNDI_MINOR;\n  }\n\n  Index++;\n  OptList[Index] = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n\n  //\n  // Append client system architecture option\n  //\n  OptList[Index]->OpCode  = PXEBC_PXE_DHCP4_TAG_ARCH;\n  OptList[Index]->Length  = sizeof (PXEBC_DHCP4_OPTION_ARCH);\n  OptEnt.Arch             = (PXEBC_DHCP4_OPTION_ARCH *) OptList[Index]->Data;\n  Value                   = HTONS (EFI_PXE_CLIENT_SYSTEM_ARCHITECTURE);\n  CopyMem (&OptEnt.Arch->Type, &Value, sizeof (UINT16));\n  Index++;\n  OptList[Index]          = GET_NEXT_DHCP_OPTION (OptList[Index - 1]);\n\n  //\n  // Append client system architecture option\n  //\n  OptList[Index]->OpCode  = PXEBC_DHCP4_TAG_CLASS_ID;\n  OptList[Index]->Length  = sizeof (PXEBC_DHCP4_OPTION_CLID);\n  OptEnt.Clid             = (PXEBC_DHCP4_OPTION_CLID *) OptList[Index]->Data;\n  CopyMem (OptEnt.Clid, DEFAULT_CLASS_ID_DATA, sizeof (PXEBC_DHCP4_OPTION_CLID));\n  CvtNum (EFI_PXE_CLIENT_SYSTEM_ARCHITECTURE, OptEnt.Clid->ArchitectureType, sizeof (OptEnt.Clid->ArchitectureType));\n\n  if (Private->Nii != NULL) {\n    //\n    // If NII protocol exists, update DHCP option data\n    //\n    CopyMem (OptEnt.Clid->InterfaceName, Private->Nii->StringId, sizeof (OptEnt.Clid->InterfaceName));\n    CvtNum (Private->Nii->MajorVer, OptEnt.Clid->UndiMajor, sizeof (OptEnt.Clid->UndiMajor));\n    CvtNum (Private->Nii->MinorVer, OptEnt.Clid->UndiMinor, sizeof (OptEnt.Clid->UndiMinor));\n  }\n\n  Index++;\n\n  return Index;\n}", "path": "MdeModulePkg\\Universal\\Network\\UefiPxeBcDxe\\PxeBcDhcp.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Releases a spin lock.\n\n  This function places the spin lock specified by SpinLock in the release state\n  and returns SpinLock.\n\n  If SpinLock is NULL, then ASSERT().\n  If SpinLock was not initialized with InitializeSpinLock(), then ASSERT().\n\n  @param  SpinLock  A pointer to the spin lock to release.\n\n  @return SpinLock\n\n**/\n", "func_signal": "SPIN_LOCK *\nEFIAPI\nReleaseSpinLock (\n  IN OUT  SPIN_LOCK                 *SpinLock\n  )", "code": "{\n  SPIN_LOCK    LockValue;\n\n  ASSERT (SpinLock != NULL);\n\n  LockValue = *SpinLock;\n  ASSERT (LockValue == SPIN_LOCK_ACQUIRED || LockValue == SPIN_LOCK_RELEASED);\n\n  _ReadWriteBarrier ();\n  *SpinLock = SPIN_LOCK_RELEASED;\n  _ReadWriteBarrier ();\n\n  return SpinLock;\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseLib\\SynchronizationMsc.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/**\n  Fills a target buffer with a 16-bit value, and returns the target buffer.\n\n  This function fills Length bytes of Buffer with the 16-bit value specified by\n  Value, and returns Buffer. Value is repeated every 16-bits in for Length\n  bytes of Buffer.\n\n  If Length > 0 and Buffer is NULL, then ASSERT().\n  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().\n  If Buffer is not aligned on a 16-bit boundary, then ASSERT().\n  If Length is not aligned on a 16-bit boundary, then ASSERT().\n\n  @param  Buffer  Pointer to the target buffer to fill.\n  @param  Length  Number of bytes in Buffer to fill.\n  @param  Value   Value with which to fill Length bytes of Buffer.\n\n  @return Buffer.\n\n**/\n", "func_signal": "VOID *\nEFIAPI\nSetMem16 (\n  OUT VOID   *Buffer,\n  IN UINTN   Length,\n  IN UINT16  Value\n  )", "code": "{\n  if (Length == 0) {\n    return Buffer;\n  }\n\n  ASSERT (Buffer != NULL);\n  ASSERT ((Length - 1) <= (MAX_ADDRESS - (UINTN)Buffer));\n  ASSERT ((((UINTN)Buffer) & (sizeof (Value) - 1)) == 0);\n  ASSERT ((Length & (sizeof (Value) - 1)) == 0);\n\n  return InternalMemSetMem16 (Buffer, Length / sizeof (Value), Value);\n}", "path": "EdkCompatibilityPkg\\Foundation\\Library\\EdkIIGlueLib\\Library\\BaseMemoryLib\\SetMem16Wrapper.c", "repo_name": "guobamantou/loongson-uefi", "stars": 7, "license": "None", "language": "c", "size": 15160}
{"docstring": "/*\n * This is the original version of the program in the man page.\n * Copy-and-paste whatever you need from it.\n */\n", "func_signal": "int\nmain(int argc, char **argv)", "code": "{\n\tchar *cinput = \"1.5K\", buf[FMT_SCALED_STRSIZE];\n\tlong long ninput = 10483892, result;\n\n\tif (scan_scaled(cinput, &result) == 0)\n\t\tprintf(\"\\\"%s\\\" -> %lld\\n\", cinput, result);\n\telse\n\t\tperror(cinput);\n\n\tif (fmt_scaled(ninput, buf) == 0)\n\t\tprintf(\"%lld -> \\\"%s\\\"\\n\", ninput, buf);\n\telse\n\t\tfprintf(stderr, \"%lld invalid (%s)\\n\", ninput, strerror(errno));\n\n\treturn 0;\n}", "path": "openbsd-compat\\fmt_scaled.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Allocates data from a memory mapped area */\n", "func_signal": "void *\nmm_malloc(struct mm_master *mm, size_t size)", "code": "{\n\tstruct mm_share *mms, *tmp;\n\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_T_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\n\tif (mms == NULL)\n\t\treturn (NULL);\n\n\t/* Debug */\n\tmemset(mms->address, 0xd0, size);\n\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\n\t/* Does not change order in RB tree */\n\tmms->size -= size;\n\tmms->address = (u_char *)mms->address + size;\n\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\txfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\n\treturn (tmp->address);\n}", "path": "monitor_mm.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Format the given \"number\" into human-readable form in \"result\".\n * Result must point to an allocated buffer of length FMT_SCALED_STRSIZE.\n * Return 0 on success, -1 and errno set if error.\n */\n", "func_signal": "int\nfmt_scaled(long long number, char *result)", "code": "{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\tabval = (number < 0LL) ? -number : number;\t/* no long long_abs yet */\n\n\t/* Not every negative long long has a positive representation.\n\t * Also check for numbers that are just too darned big to format\n\t */\n\tif (abval < 0 || abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t/* scale whole part; get unscaled fraction */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t/* if the result would be >= 10, round main number */\n\tif (fract == 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}", "path": "openbsd-compat\\fmt_scaled.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Fatal messages.  This function never returns. */\n", "func_signal": "void\nfatal(const char *fmt,...)", "code": "{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}", "path": "fatal.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Frees either the allocated or the free list */\n", "func_signal": "static void\nmm_freelist(struct mm_master *mmalloc, struct mmtree *head)", "code": "{\n\tstruct mm_share *mms, *next;\n\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\txfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "path": "monitor_mm.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * This is called when the client thinks we've completed authentication.\n * It should only be enabled in the dispatch handler by the function above,\n * which only enables it once the GSSAPI exchange is complete.\n */\n", "func_signal": "static void\ninput_gssapi_exchange_complete(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tGssctxt *gssctxt;\n\tint authenticated;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\n\t/*\n\t * We don't need to check the status, because we're only enabled in\n\t * the dispatcher once the exchange is complete\n\t */\n\n\tpacket_check_eom();\n\n\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\n\tauthctxt->postponed = 0;\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(authctxt, authenticated, \"gssapi-with-mic\");\n}", "path": "auth2-gss.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Export the fingerprint of a key as a DNS resource record\n */\n", "func_signal": "int\nexport_dns_rr(const char *hostname, Key *key, FILE *f, int generic)", "code": "{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_SHA1;\n\tu_char *rdata_digest;\n\tu_int rdata_digest_len;\n\n\tu_int i;\n\tint success = 0;\n\n\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t    &rdata_digest, &rdata_digest_len, key)) {\n\n\t\tif (generic)\n\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %d %02x %02x \", hostname,\n\t\t\t    DNS_RDATATYPE_SSHFP, 2 + rdata_digest_len,\n\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\telse\n\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\n\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\tfprintf(f, \"\\n\");\n\t\txfree(rdata_digest); /* from key_fingerprint_raw() */\n\t\tsuccess = 1;\n\t} else {\n\t\terror(\"export_dns_rr: unsupported algorithm\");\n\t}\n\n\treturn success;\n}", "path": "dns.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * We only support those mechanisms that we know about (ie ones that we know\n * how to check local user kuserok and the like)\n */\n", "func_signal": "static int\nuserauth_gssapi(Authctxt *authctxt)", "code": "{\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint mechs;\n\tgss_OID_set supported;\n\tint present;\n\tOM_uint32 ms;\n\tu_int len;\n\tu_char *doid = NULL;\n\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\n\tmechs = packet_get_int();\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tssh_gssapi_supported_oids(&supported);\n\tdo {\n\t\tmechs--;\n\n\t\tif (doid)\n\t\t\txfree(doid);\n\n\t\tpresent = 0;\n\t\tdoid = packet_get_string(&len);\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tgss_test_oid_set_member(&ms, &goid, supported,\n\t\t\t    &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tgss_release_oid_set(&ms, &supported);\n\n\tif (!present) {\n\t\txfree(doid);\n\t\treturn (0);\n\t}\n\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\txfree(doid);\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\tpacket_start(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE);\n\n\t/* Return the OID that we received */\n\tpacket_put_string(doid, len);\n\n\tpacket_send();\n\txfree(doid);\n\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tdispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}", "path": "auth2-gss.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Read SSHFP parameters from rdata buffer.\n */\n", "func_signal": "static int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, u_int *digest_len, u_char *rdata, int rdata_len)", "code": "{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = (u_char *) xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}", "path": "dns.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Frees memory in a memory mapped area */\n", "func_signal": "void\nmm_free(struct mm_master *mm, void *address)", "code": "{\n\tstruct mm_share *mms, *prev, tmp;\n\n\ttmp.address = address;\n\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n\tif (mms == NULL)\n\t\tfatal(\"mm_free(%p): can not find %p\", mm, address);\n\n\t/* Debug */\n\tmemset(mms->address, 0xd0, mms->size);\n\n\t/* Remove from allocated list and insert in free list */\n\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n\t\tfatal(\"mm_free(%p): double address %p\", mm, address);\n\n\t/* Find previous entry */\n\tprev = mms;\n\tif (RB_LEFT(prev, next)) {\n\t\tprev = RB_LEFT(prev, next);\n\t\twhile (RB_RIGHT(prev, next))\n\t\t\tprev = RB_RIGHT(prev, next);\n\t} else {\n\t\tif (RB_PARENT(prev, next) &&\n\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n\t\t\tprev = RB_PARENT(prev, next);\n\t\telse {\n\t\t\twhile (RB_PARENT(prev, next) &&\n\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n\t\t\t\tprev = RB_PARENT(prev, next);\n\t\t\tprev = RB_PARENT(prev, next);\n\t\t}\n\t}\n\n\t/* Check if range does not overlap */\n\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n\t\tfatal(\"mm_free: memory corruption: %p(%lu) > %p\",\n\t\t    prev->address, (u_long)prev->size, address);\n\n\t/* See if we can merge backwards */\n\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n\t\tprev->size += mms->size;\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\txfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t} else\n\t\tprev = mms;\n\n\tif (prev == NULL)\n\t\treturn;\n\n\t/* Check if we can merge forwards */\n\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n\tif (mms == NULL)\n\t\treturn;\n\n\tif (MM_ADDRESS_END(prev) > mms->address)\n\t\tfatal(\"mm_free: memory corruption: %p < %p(%lu)\",\n\t\t    mms->address, prev->address, (u_long)prev->size);\n\tif (MM_ADDRESS_END(prev) != mms->address)\n\t\treturn;\n\n\tprev->size += mms->size;\n\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\n\tif (mm->mmalloc == NULL)\n\t\txfree(mms);\n\telse\n\t\tmm_free(mm->mmalloc, mms);\n}", "path": "monitor_mm.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Check if hostname is numerical.\n * Returns -1 if hostname is numeric, 0 otherwise\n */\n", "func_signal": "static int\nis_numeric_hostname(const char *hostname)", "code": "{\n\tstruct addrinfo hints, *ai;\n\n\t/*\n\t * We shouldn't ever get a null host but if we do then log an error\n\t * and return -1 which stops DNS key fingerprint processing.\n\t */\n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "dns.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Destroys a memory mapped area */\n", "func_signal": "void\nmm_destroy(struct mm_master *mm)", "code": "{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\n#ifdef HAVE_MMAP\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %lu): %s\", mm->address, (u_long)mm->size,\n\t\t    strerror(errno));\n#else\n\tfatal(\"%s: UsePrivilegeSeparation=yes and Compression=yes not supported\",\n\t    __func__);\n#endif\n\tif (mm->mmalloc == NULL)\n\t\txfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "path": "monitor_mm.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Calculate a uniformly distributed random number less than upper_bound\n * avoiding \"modulo bias\".\n *\n * Uniformity is achieved by generating new random numbers until the one\n * returned is outside the range [0, 2**32 % upper_bound).  This\n * guarantees the selected random number will be inside\n * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)\n * after reduction modulo upper_bound.\n */\n", "func_signal": "u_int32_t\narc4random_uniform(u_int32_t upper_bound)", "code": "{\n\tu_int32_t r, min;\n\n\tif (upper_bound < 2)\n\t\treturn 0;\n\n#if (ULONG_MAX > 0xffffffffUL)\n\tmin = 0x100000000UL % upper_bound;\n#else\n\t/* Calculate (2**32 % upper_bound) avoiding 64-bit math */\n\tif (upper_bound > 0x80000000)\n\t\tmin = 1 + ~upper_bound;\t\t/* 2**32 - upper_bound */\n\telse {\n\t\t/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */\n\t\tmin = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;\n\t}\n#endif\n\n\t/*\n\t * This could theoretically loop forever but each retry has\n\t * p > 0.5 (worst case, usually far better) of selecting a\n\t * number inside the range we need, so it should rarely need\n\t * to re-roll.\n\t */\n\tfor (;;) {\n\t\tr = arc4random();\n\t\tif (r >= min)\n\t\t\tbreak;\n\t}\n\n\treturn r % upper_bound;\n}", "path": "openbsd-compat\\bsd-arc4random.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Read SSHFP parameters from key buffer.\n */\n", "func_signal": "static int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, u_int *digest_len, Key *key)", "code": "{\n\tint success = 0;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm) {\n\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\t*digest = key_fingerprint_raw(key, SSH_FP_SHA1, digest_len);\n\t\tif (*digest == NULL)\n\t\t\tfatal(\"dns_read_key: null from key_fingerprint_raw()\");\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest_type = SSHFP_HASH_RESERVED;\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}", "path": "dns.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* Creates a shared memory area of a certain size */\n", "func_signal": "struct mm_master *\nmm_create(struct mm_master *mmalloc, size_t size)", "code": "{\n\tvoid *address;\n\tstruct mm_master *mm;\n\n\tif (mmalloc == NULL)\n\t\tmm = xmalloc(sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\n\t/*\n\t * If the memory map has a mm_master it can be completely\n\t * shared including authentication between the child\n\t * and the client.\n\t */\n\tmm->mmalloc = mmalloc;\n\n\taddress = xmmap(size);\n\tif (address == (void *)MAP_FAILED)\n\t\tfatal(\"mmap(%lu): %s\", (u_long)size, strerror(errno));\n\n\tmm->address = address;\n\tmm->size = size;\n\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\n\treturn (mm);\n}", "path": "monitor_mm.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Appends src to string dst of size siz (unlike strncat, siz is the\n * full size of dst, not space left).  At most siz-1 characters\n * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).\n * Returns strlen(src) + MIN(siz, strlen(initial dst)).\n * If retval >= siz, truncation occurred.\n */\n", "func_signal": "size_t\nstrlcat(char *dst, const char *src, size_t siz)", "code": "{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}", "path": "openbsd-compat\\strlcat.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/** Convert the given input string \"scaled\" into numeric in \"result\".\n * Return 0 on success, -1 and errno set on error.\n */\n", "func_signal": "int\nscan_scaled(char *scaled, long long *result)", "code": "{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t/* Skip leading whitespace */\n\twhile (isascii(*p) && isspace(*p))\n\t\t++p;\n\n\t/* Then at most one leading + or - */\n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t/* Main loop: Scan digits, find decimal point, if present.\n\t * We don't allow exponentials, so no scientific notation\n\t * (but note that E for Exa might look like e to some!).\n\t * Advance 'p' to end, to get scale factor.\n\t */\n\tfor (; isascii(*p) && (isdigit(*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t/* oops, more than one '.' */\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t/* whew! finally a digit we can use */\n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t/* ignore extra fractional digits */\n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t/* for later scaling */\n\t\t\tfpart *= 10;\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t/* normal digit */\n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign) {\n\t\twhole *= sign;\n\t\tfpart *= sign;\n\t}\n\n\t/* If no scale factor given, we're done. fraction is discarded. */\n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t/* Validate scale factor, and scale whole and fraction by it. */\n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t/** Are we there yet? */\n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower(scale_chars[i])) {\n\n\t\t\t/* If it ends with alphanumerics after the scale char, bad. */\n\t\t\tif (isalnum(*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t/* scale whole part */\n\t\t\twhole *= scale_fact;\n\n\t\t\t/* truncate fpart so it does't overflow.\n\t\t\t * then scale fractional part.\n\t\t\t */\n\t\t\twhile (fpart >= LLONG_MAX / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\terrno = ERANGE;\n\treturn -1;\n}", "path": "openbsd-compat\\fmt_scaled.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Verify the given hostname, address and host key using DNS.\n * Returns 0 if lookup succeeds, -1 otherwise\n */\n", "func_signal": "int\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    Key *hostkey, int *flags)", "code": "{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_int8_t hostkey_digest_type;\n\tu_char *hostkey_digest;\n\tu_int hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tu_int dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\t/* Initialize host key parameters */\n\tif (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,\n\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\terror(\"Error calculating host key fingerprint.\");\n\t\tfreerrset(fingerprints);\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t/*\n\t\t * Extract the key from the answer. Ignore any badly\n\t\t * formatted fingerprints.\n\t\t */\n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if the current key is the same as the given key */\n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_type == dnskey_digest_type) {\n\n\t\t\tif (hostkey_digest_len == dnskey_digest_len &&\n\t\t\t    memcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0) {\n\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t\t}\n\t\t}\n\t\txfree(dnskey_digest);\n\t}\n\n\txfree(hostkey_digest); /* from key_fingerprint_raw() */\n\tfreerrset(fingerprints);\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}", "path": "dns.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\nupdate_progress_meter(int ignore)", "code": "{\n\tint save_errno;\n\n\tsave_errno = errno;\n\n\tif (win_resized) {\n\t\tsetscreensize();\n\t\twin_resized = 0;\n\t}\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\talarm(UPDATE_INTERVAL);\n\terrno = save_errno;\n}", "path": "progressmeter.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/*\n * Caclulate a new key after a reconnect\n */\n", "func_signal": "void\ncalculate_new_key(u_int64_t *key, u_int64_t cookie, u_int64_t challenge)", "code": "{\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX ctx;\n\tchar hash[EVP_MAX_MD_SIZE];\n\tBuffer b;\n\n\tbuffer_init(&b);\n\tbuffer_put_int64(&b, *key);\n\tbuffer_put_int64(&b, cookie);\n\tbuffer_put_int64(&b, challenge);\n\n\tEVP_DigestInit(&ctx, md);\n\tEVP_DigestUpdate(&ctx, buffer_ptr(&b), buffer_len(&b));\n\tEVP_DigestFinal(&ctx, hash, NULL);\n\n\tbuffer_clear(&b);\n\tbuffer_append(&b, hash, EVP_MD_size(md));\n\t*key = buffer_get_int64(&b);\n\tbuffer_free(&b);\n}", "path": "roaming_common.c", "repo_name": "hyc/OpenSSH-LINEMODE", "stars": 6, "license": "other", "language": "c", "size": 8800}
{"docstring": "/* this function handles the link with other elements */\n", "func_signal": "static gboolean\ngst_soma_sync_tracker_set_caps (GstPad * pad, GstCaps * caps)", "code": "{\n  GstSomaSyncTracker *filter;\n  GstPad *otherpad1, *otherpad2;\n  gboolean ret=TRUE;\n  GstStructure *structure=NULL;\n\n  filter = GST_SOMASYNCTRACKER (gst_pad_get_parent (pad));\n  if (pad == filter->videosinkpad) {\n    otherpad1 = filter->videosrcpad;\n    otherpad2 = filter->videobinsrcpad;\n  } else if (pad == filter->videosrcpad) {\n    otherpad1 = filter->videosinkpad;\n    otherpad2 = filter->videobinsrcpad;\n  } else {\n    otherpad1 = filter->videosrcpad;\n    otherpad2 = filter->videosinkpad;\n  }\n\n  if (otherpad1)\n    ret = ret && gst_pad_set_caps(otherpad1, caps);\n\n  if (otherpad2)\n    ret = ret && gst_pad_set_caps(otherpad2, caps);\n\n  structure = gst_caps_get_structure ( caps, 0);\n  gst_structure_get_int (structure, \"width\", &filter->width);\n  gst_structure_get_int (structure, \"height\", &filter->height);\n\n  GST_DEBUG_OBJECT(filter, \"caps set: width=%d, height=%d\",filter->width,filter->height);\n  gst_object_unref (filter);\n\n\n  return ret;\n}", "path": "src\\gstsomasynctracker.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GObject vmethod implementations */\n", "func_signal": "void update_trail( GstSomaPosOverlay *filter,  GstSomaPosition *pos, guint64 ts )", "code": "{\n\n  /* if trail==0, do nothing\n     if trail<0 (infinite trail), add position to trail\n     if trail>0 (timed trail), reduce all positions according to time elapsed and add position to trail */\n\n  double rate;\n  guint8 dy=0;\n  int stride;\n  guint8 *pdata;\n\n  cairo_surface_t *psurf;\n  \n  if (filter->trail==0)\n    return;\n\n  if (pos->diode==0) {\n    psurf = filter->trail1;\n  } else {\n    psurf = filter->trail2;\n  }\n\n  stride = cairo_image_surface_get_stride (psurf);\n  pdata = cairo_image_surface_get_data(psurf);\n\n\n  if (filter->trail>0) {\n    \n    rate = 255.0 / filter->trail;\n    dy = (guint8) (rate * (double) (ts - filter->prev_ts) / GST_SECOND); \n\n    //g_print(\"rate: %f, dt: %f, dy: %d\\n\", rate, (double)(ts - filter->prev_ts) / GST_SECOND, dy );\n\n\n\n    // loop through all points\n\n    int x,y,idx;\n\n    for (y=0; y<480; y++) {\n\n      idx = (480-y)*stride;\n\n      for (x=0; x<640; x++) {\n\n\tif (pdata[idx]>dy) {\n\t  pdata[idx] -= dy ;\n\t} else {\n\t  pdata[idx]=0;\n\t}\n\n\tidx++;\n\n      }\n    }\n\n  }\n\n  if (pos->y>0 && pos->x>0) {\n    //g_print(\"set pix: %d, %d\\n\",pos->x,pos->y);\n    pdata[(481-pos->y)*stride+(pos->x-1)] = 255;\n  }\n\n  filter->prev_ts = ts;\n\n}", "path": "src\\gstsomaposoverlay.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GObject vmethod implementations */\n", "func_signal": "static void\ngst_soma_sync_tracker_base_init (gpointer gclass)", "code": "{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&videosrc_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&videosink_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&videobinsrc_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&diodesink_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&positionsrc_factory));\n\n  gst_element_class_set_details (element_class, &gst_soma_sync_tracker_details);\n\n\n}", "path": "src\\gstsomasynctracker.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the new element\n * instantiate pads and add them to element\n * set pad calback functions\n * initialize instance structure\n */\n", "func_signal": "static void\ngst_soma_pos_overlay_init (GstSomaPosOverlay * filter,\n    GstSomaPosOverlayClass * gclass)", "code": "{\n  filter->videosinkpad = gst_pad_new_from_static_template (&videosink_factory, \"video_sink\");\n  gst_pad_set_setcaps_function (filter->videosinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos_overlay_set_caps));\n  gst_pad_set_getcaps_function (filter->videosinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos_overlay_get_caps));\n\n  filter->videosrcpad = gst_pad_new_from_static_template (&videosrc_factory, \"video_src\");\n  gst_pad_set_getcaps_function (filter->videosrcpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos_overlay_get_caps));\n\n  filter->binsinkpad = gst_pad_new_from_static_template (&binsink_factory, \"bin_sink\");\n  gst_pad_set_getcaps_function (filter->binsinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos_overlay_get_caps));\n\n  filter->possinkpad = gst_pad_new_from_static_template (&possink_factory, \"pos_sink\");\n  gst_pad_set_getcaps_function (filter->possinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos_overlay_get_caps));\n\n  gst_element_add_pad (GST_ELEMENT (filter), filter->videosinkpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->videosrcpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->binsinkpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->possinkpad);\n\n  filter->showvideo = TRUE;\n  filter->showbinary = FALSE;\n  filter->showpos = FALSE;\n\n  filter->diode1col = 0x000000;\n  filter->diode2col = 0x000000;\n\n  filter->trail1 = cairo_image_surface_create(CAIRO_FORMAT_A8 , 640, 480 );\n  filter->trail2 = cairo_image_surface_create(CAIRO_FORMAT_A8 , 640, 480 );\n\n  clean_trail( filter );\n\n  filter->trail = 0;\n  filter->prev_ts = 0;\n\n  filter->collect = gst_collect_pads_new();\n  \n  gst_collect_pads_set_function (filter->collect,\n      GST_DEBUG_FUNCPTR (gst_soma_pos_overlay_collected), filter);\n\n  filter->video_collect_data = gst_collect_pads_add_pad( filter->collect,\n\t\t\t\t\t\t\t filter->videosinkpad, sizeof(GstCollectData) );\n  filter->bin_collect_data = gst_collect_pads_add_pad( filter->collect,\n\t\t\t\t\t\t\t filter->binsinkpad, sizeof(GstCollectData) );\n  filter->pos_collect_data = gst_collect_pads_add_pad( filter->collect,\n\t\t\t\t\t\t\t filter->possinkpad, sizeof(GstCollectData) );\n\n}", "path": "src\\gstsomaposoverlay.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* entry point to initialize the plug-in\n * initialize the plug-in itself\n * register the element factories and other features\n */\n", "func_signal": "static gboolean\nplugin_init (GstPlugin * plugin)", "code": "{\n\n\n  if (!gst_element_register (plugin, \"somasynctracker\", GST_RANK_NONE,\n\t\t\t     GST_TYPE_SOMASYNCTRACKER) ||\n      !gst_element_register (plugin, \"somapos2text\", GST_RANK_NONE,\n\t\t\t     GST_TYPE_SOMAPOS2TEXT) ||\n      !gst_element_register (plugin, \"somacameraevent\", GST_RANK_NONE,\n\t\t\t     GST_TYPE_SOMACAMERAEVENT) ||\n      !gst_element_register (plugin, \"somacmml2text\", GST_RANK_NONE,\n\t\t\t     GST_TYPE_SOMACMML2TEXT)  ||\n      !gst_element_register (plugin, \"somaposoverlay\", GST_RANK_NONE,\n\t\t\t     GST_TYPE_SOMAPOSOVERLAY) )\n    {\n      return FALSE;\n    }\n\n\n  /* debug category for fltering log messages */\n  GST_DEBUG_CATEGORY_INIT (gst_somatracker_debug, \"somatracker\",\n\t\t\t   0, \"Soma tracker elements\");\n\n  return TRUE;\n}", "path": "src\\gstsomatracker.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* chain function\n * this function does the actual processing\n */\n", "func_signal": "static GstFlowReturn\ngst_soma_cmml2text_chain (GstPad * pad, GstBuffer * buf)", "code": "{\n  GstSomaCmml2Text *filter;\n  char *pstr, *pstr2;\n  char timestr[20];\n  guint64 oldtimestamp;\n  guint64 timestamp;\n  guint hh,mm,ss,ms;\n  char txt[256];\n  GstBuffer *txtbuffer;\n  char *ptxt;\n\n  filter = GST_SOMACMML2TEXT (GST_OBJECT_PARENT (pad));\n\n  //change caps from text/cmml (encoded=false) to text/plain\n  gst_buffer_set_caps( buf, GST_PAD_CAPS( filter->srcpad ) );\n\n  //if we don't have a format string, just push the cmml clip\n  if (filter->fmt==NULL)\n    return gst_pad_push(filter->srcpad, buf);\n\n  //FIX ME:\n  //otherwise parse the metadata in the clip\n  //replace tokens in format string with metadata values\n  //create a new buffer\n  //set timestamp of new buffer\n  //unref incoming buffer\n  //push out new buffer\n\n  pstr = strstr( (char*) GST_BUFFER_DATA(buf), \"timestamp\" );\n\n  pstr+=20;\n  pstr2 = strstr( pstr, \"\\\"\" );\n  memcpy( timestr, pstr, pstr2-pstr );\n  timestamp = (guint64) atoll(timestr);\n  oldtimestamp = GST_BUFFER_TIMESTAMP(buf);\n  GST_BUFFER_TIMESTAMP(buf) = timestamp*20000;\n  \n  hh = (guint) (timestamp / (50000 * 60 * 60));\n  mm = (guint) ((timestamp / (50000 * 60)) % 60);\n  ss = (guint) ((timestamp / 50000) % 60);\n  ms = (guint) ((timestamp % 50000) / 50 );\n  \n  g_print(\"cmml buffer timestamp: %llu (old:%llu) %s\\n\", GST_BUFFER_TIMESTAMP(buf), oldtimestamp, timestr);\n  \n  sprintf(txt, \"%02d:%02d:%02d.%03d\", hh,mm,ss,ms);\n  \n  gst_pad_alloc_buffer(filter->srcpad, GST_BUFFER_OFFSET_NONE, strlen(txt), GST_PAD_CAPS(filter->srcpad), &txtbuffer);\n  ptxt = (char*) GST_BUFFER_DATA(txtbuffer);\n  memcpy( ptxt, txt, strlen(txt) );\n  \n  gst_buffer_copy_metadata( txtbuffer, buf, GST_BUFFER_COPY_TIMESTAMPS );  \n  GST_BUFFER_TIMESTAMP(txtbuffer) = timestamp*20000;\n\n  gst_buffer_unref(buf);\n\n  /* just push out the incoming buffer without touching it */\n  return gst_pad_push (filter->srcpad, txtbuffer);\n}", "path": "src\\gstsomacmml2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the new element\n * instantiate pads and add them to element\n * set pad calback functions\n * initialize instance structure\n */\n", "func_signal": "static void\ngst_soma_pos2text_init (GstSomaPos2Text * filter,\n    GstSomaPos2TextClass * gclass)", "code": "{\n  filter->sinkpad = gst_pad_new_from_static_template (&sink_factory, \"sink\");\n  gst_pad_set_getcaps_function (filter->sinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos2text_get_caps));\n  gst_pad_set_chain_function (filter->sinkpad,\n                              GST_DEBUG_FUNCPTR(gst_soma_pos2text_chain));\n\n  filter->srcpad = gst_pad_new_from_static_template (&src_factory, \"src\");\n  gst_pad_set_setcaps_function (filter->srcpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos2text_src_set_caps));\n  gst_pad_set_getcaps_function (filter->srcpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_pos2text_get_caps));\n\n  gst_element_add_pad (GST_ELEMENT (filter), filter->sinkpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->srcpad);\n\n  filter->silent = FALSE;\n  filter->text_format = SOMATEXTINVALID;\n  filter->init = FALSE;\n\n}", "path": "src\\gstsomapos2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GObject vmethod implementations */\n", "func_signal": "static void\ngst_soma_camera_event_base_init (gpointer gclass)", "code": "{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&src_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&sink_factory));\n\n  gst_element_class_set_details (element_class, &gst_soma_camera_event_details);\n\n}", "path": "src\\gstsomacameraevent.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GObject vmethod implementations */\n", "func_signal": "static void\ngst_soma_cmml2text_base_init (gpointer gclass)", "code": "{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&src_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&sink_factory));\n\n  gst_element_class_set_details (element_class, &gst_soma_cmml2text_details);\n\n}", "path": "src\\gstsomacmml2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GObject vmethod implementations */\n", "func_signal": "static void\ngst_soma_pos2text_base_init (gpointer gclass)", "code": "{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&src_factory));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&sink_factory));\n\n  gst_element_class_set_details (element_class, &gst_soma_pos2text_details);\n\n}", "path": "src\\gstsomapos2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* GstElement vmethod implementations */\n", "func_signal": "static gboolean\ngst_soma_pos2text_src_set_caps(GstPad * pad, GstCaps * caps )", "code": "{\n\n  GstSomaPos2Text *filter;\n  GstStructure *structure;\n  gboolean ret=TRUE;\n\n  filter = GST_SOMAPOS2TEXT (GST_OBJECT_PARENT (pad));\n\n  if (!GST_IS_CAPS(caps))\n    return FALSE;\n\n  structure = gst_caps_get_structure (caps, 0);\n\n  if (gst_structure_has_name (structure, \"text/x-cmml\")) {\n    filter->text_format = SOMATEXTCMML;\n  } else if (gst_structure_has_name (structure, \"text/plain\")) {\n    filter->text_format = SOMATEXTPLAIN;\n  } else if (gst_structure_has_name (structure, \"text/x-pango-markup\")) {\n    filter->text_format = SOMATEXTPANGO;\n  } else {\n    filter->text_format = SOMATEXTINVALID;\n    ret = FALSE;\n  }\n\n  GST_DEBUG_OBJECT(filter, \"text format: %d\", filter->text_format);\n\n  return ret;\n}", "path": "src\\gstsomapos2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* chain function\n * this function does the actual processing\n */\n", "func_signal": "static GstFlowReturn\ngst_soma_pos2text_chain (GstPad * pad, GstBuffer * buf)", "code": "{\n  GstSomaPos2Text *filter;\n  GstSomaPosition* pos;\n  GstFlowReturn ret=GST_FLOW_OK;\n  GstBuffer *outbuf = NULL;\n  char txt[512];\n  guint hh,mm,ss,ms;\n  struct timeval now;\n  char *p1;\n  char tmpstr[32];\n  int k;\n  char inittxt[32];\n\n\n  const char *tokens[] = {\"[ts]\", \"[diode]\", \"[x]\", \"[y]\", \"[hh]\", \"[mm]\", \"[ss]\", \"[ms]\"};\n\n  pos = (GstSomaPosition*) GST_BUFFER_DATA(buf);\n  \n  filter = GST_SOMAPOS2TEXT (GST_OBJECT_PARENT (pad));\n\n  //convert timestamp to hh:mm:ss.ms\n  hh = (guint) (pos->timestamp / (50000 * 60 * 60));\n  mm = (guint) ((pos->timestamp / (50000 * 60)) % 60);\n  ss = (guint) ((pos->timestamp / 50000) % 60);\n  ms = (guint) ((pos->timestamp % 50000) / 50 );\n\n  /* Let's get a buffer. Caps are negotiated if needed */\n  ret = get_buffer(filter, &outbuf);\n  if (ret != GST_FLOW_OK)\n    goto beach;\n\n  // handle plain/pango text and cmml separately\n  switch (filter->text_format) {\n  case SOMATEXTPLAIN:\n  case SOMATEXTPANGO:\n\n    //use default text if format text is empty\n    if (filter->fmt==NULL) {\n      sprintf( txt, \"timestamp: %llu, diode: %d, x: %d, y: %d\\n\", (long long unsigned int) pos->timestamp, pos->diode, pos->x, pos->y );\n    } else {\n      //replace special tokens\n      \n      char **values = (char**) g_malloc(sizeof(char*)*8);\n\n      sprintf( tmpstr, \"%llu\", (long long unsigned int) pos->timestamp );\n      values[0] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%d\", pos->diode );\t\n      values[1] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%d\", pos->x );\n      values[2] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%d\", pos->y );\n      values[3] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%02d\", hh );\n      values[4] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%02d\", mm );\n      values[5] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%02d\", ss );\n      values[6] = g_strdup(tmpstr);\n      sprintf( tmpstr, \"%03d\", ms );\n      values[7] = g_strdup(tmpstr);\n\n      p1 = replace_tokens( filter->fmt, tokens, values, 8);\n\n      sprintf( txt, \"%s\", p1);\n\n      g_free(p1);\n\n      for (k=0;k<8;k++)\n\t{\n\t  g_free(values[k]);\n\t}\n      g_free(values);\n\n    }\n\n    break;\n  case SOMATEXTCMML:\n\n    //wall time\n    gettimeofday(&now,NULL);\n    \n    if (filter->init) {\n\n      sprintf( inittxt, \"<cmml><stream basetime=\\\"%02u:%02u:%02u.%03u\\\"/>\\n\\\n<head><title>Testing soma tracker</title></head>\\n\", 0,0,0,0);\n\n      filter->init=FALSE;\n    }\n    \n    sprintf( txt, \"%s\\\n<clip start=\\\"npt:%02u:%02u:%02u.%03u\\\">\\n\\\n<meta name=\\\"walltime\\\" content=\\\"%02llu.%06lu\\\"/>\\\n<meta name=\\\"timestamp\\\" content=\\\"%llu\\\"/>\\\n<meta name=\\\"diode\\\" content=\\\"%d\\\"/>\\\n<meta name=\\\"x\\\" content=\\\"%d\\\"/>\\\n<meta name=\\\"y\\\" content=\\\"%d\\\"/>\\n\\\n</clip>\\n\",\n\t     inittxt,\n\t     hh,mm,ss,ms,\n\t     (long long unsigned int) now.tv_sec, (long unsigned int) now.tv_usec,\n\t     (long long unsigned int) pos->timestamp, pos->diode, pos->x, pos->y );\n\n\n    break;\n  default:\n    sprintf( txt, \"no text\");\n    break;\n  }\n\n  //resize buffer data\n  if (GST_BUFFER_MALLOCDATA(outbuf)!=NULL) {\n    g_free(GST_BUFFER_MALLOCDATA(outbuf));\n    GST_BUFFER_MALLOCDATA(outbuf)=NULL;\n  }\n\n  GST_BUFFER_SIZE(outbuf) = strlen(txt);\n  GST_BUFFER_MALLOCDATA(outbuf) = g_malloc(strlen(txt));\n  GST_BUFFER_DATA(outbuf) = GST_BUFFER_MALLOCDATA(outbuf);\n\n  memcpy( (char*) GST_BUFFER_DATA( outbuf ), txt, strlen(txt) );\n  \n  gst_buffer_copy_metadata( outbuf, buf, GST_BUFFER_COPY_TIMESTAMPS );  \n\n\n  GST_DEBUG_OBJECT( filter, \"pushing out text buffer...\");\n\n  \n\n beach:\n  gst_buffer_unref(buf);\n  //gst_object_unref(filter);\n  //g_free(pos);\n  return gst_pad_push (filter->srcpad, outbuf);\n\n}", "path": "src\\gstsomapos2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the somaposoverlay's class */\n", "func_signal": "static void\ngst_soma_pos_overlay_class_init (GstSomaPosOverlayClass * klass)", "code": "{\n  GObjectClass *gobject_class;\n  GstElementClass *gstelement_class;\n\n  gobject_class = (GObjectClass *) klass;\n  gstelement_class = (GstElementClass *) klass;\n\n  gobject_class->finalize = gst_soma_pos_overlay_finalize;\n\n  gstelement_class->change_state =\n    GST_DEBUG_FUNCPTR (gst_soma_pos_overlay_change_state);\n\n  gobject_class->set_property = gst_soma_pos_overlay_set_property;\n  gobject_class->get_property = gst_soma_pos_overlay_get_property;\n\n  g_object_class_install_property (gobject_class, PROP_SHOWVIDEO,\n      g_param_spec_boolean (\"showvideo\", \"Showvideo\", \"Show video\",\n          TRUE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_SHOWBINARY,\n      g_param_spec_boolean (\"showbinary\", \"Showbinary\", \"Show binarized video\",\n          TRUE, G_PARAM_READWRITE)); \n\n  g_object_class_install_property (gobject_class, PROP_SHOWPOSITION,\n      g_param_spec_boolean (\"showposition\", \"Showposition\", \"Show position\",\n          TRUE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_DIODE1COL,\n      g_param_spec_ulong(\"diode1col\", \"Diode1col\", \"Diode 1 color\",\n\t\t\t 0, 16777215, 0, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_DIODE2COL,\n      g_param_spec_ulong(\"diode2col\", \"Diode2col\", \"Diode 2 color\",\n\t\t\t 0, 16777215, 0, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_TRAIL,\n      g_param_spec_double(\"trail\", \"Trail\", \"Trail\",\n\t\t\t-1, 10000, 0, G_PARAM_READWRITE));\n\n}", "path": "src\\gstsomaposoverlay.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the somacameraevent's class */\n", "func_signal": "static void\ngst_soma_camera_event_class_init (GstSomaCameraEventClass * klass)", "code": "{\n  GObjectClass *gobject_class;\n  GstElementClass *gstelement_class;\n\n  gobject_class = (GObjectClass *) klass;\n  gstelement_class = (GstElementClass *) klass;\n\n  gobject_class->set_property = gst_soma_camera_event_set_property;\n  gobject_class->get_property = gst_soma_camera_event_get_property;\n\n  g_object_class_install_property (gobject_class, PROP_SILENT,\n      g_param_spec_boolean (\"silent\", \"Silent\", \"Produce verbose output ?\",\n          FALSE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_EVTCMD,\n      g_param_spec_int (\"evtcmd\", \"EventCommand\", \"Event command code\",\n\t\t\t  0, 255, 0, G_PARAM_READWRITE));\n\n}", "path": "src\\gstsomacameraevent.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the somasynctracker's class */\n", "func_signal": "static void\ngst_soma_sync_tracker_class_init (GstSomaSyncTrackerClass * klass)", "code": "{\n  GObjectClass *gobject_class;\n  GstElementClass *gstelement_class;\n\n  gobject_class = (GObjectClass *) klass;\n  gstelement_class = (GstElementClass *) klass;\n\n  gobject_class->finalize = gst_soma_sync_tracker_finalize;\n\n  gstelement_class->change_state =\n    GST_DEBUG_FUNCPTR (gst_soma_sync_tracker_change_state);\n\n  gobject_class->set_property = gst_soma_sync_tracker_set_property;\n  gobject_class->get_property = gst_soma_sync_tracker_get_property;\n\n  g_object_class_install_property (gobject_class, PROP_SILENT,\n      g_param_spec_boolean (\"silent\", \"Silent\", \"Produce verbose output ?\",\n          FALSE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_THRESHOLD,\n      g_param_spec_double (\"threshold\", \"Threshold\", \"Threshold for binarize\",\n          MIN_THRESHOLD, MAX_THRESHOLD, DEFAULT_THRESHOLD, G_PARAM_READWRITE));\n\n  gstelement_class->request_new_pad =\n      GST_DEBUG_FUNCPTR (gst_soma_sync_tracker_request_new_pad);\n\n\n}", "path": "src\\gstsomasynctracker.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the somacmml2text's class */\n", "func_signal": "static void\ngst_soma_cmml2text_class_init (GstSomaCmml2TextClass * klass)", "code": "{\n  GObjectClass *gobject_class;\n  GstElementClass *gstelement_class;\n\n  gobject_class = (GObjectClass *) klass;\n  gstelement_class = (GstElementClass *) klass;\n\n  gobject_class->set_property = gst_soma_cmml2text_set_property;\n  gobject_class->get_property = gst_soma_cmml2text_get_property;\n\n  g_object_class_install_property (gobject_class, PROP_SILENT,\n      g_param_spec_boolean (\"silent\", \"Silent\", \"Produce verbose output ?\",\n          FALSE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_FMT,\n      g_param_spec_string (\"format\", \"Format\", \"Text formatting string\",\n          \"\", G_PARAM_READWRITE));\n}", "path": "src\\gstsomacmml2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the somapos2text's class */\n", "func_signal": "static void\ngst_soma_pos2text_class_init (GstSomaPos2TextClass * klass)", "code": "{\n  GObjectClass *gobject_class;\n  GstElementClass *gstelement_class;\n\n  gobject_class = (GObjectClass *) klass;\n  gstelement_class = (GstElementClass *) klass;\n\n  gobject_class->set_property = gst_soma_pos2text_set_property;\n  gobject_class->get_property = gst_soma_pos2text_get_property;\n\n  gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_soma_pos2text_change_state);\n\n  g_object_class_install_property (gobject_class, PROP_SILENT,\n      g_param_spec_boolean (\"silent\", \"Silent\", \"Produce verbose output ?\",\n          FALSE, G_PARAM_READWRITE));\n\n  g_object_class_install_property (gobject_class, PROP_FMT,\n\t\t\t\t   g_param_spec_string (\"format\", \"Format\", \"Text formatting string\",\n\t\t\t\t\t\t\t\"\", G_PARAM_READWRITE ) );\n}", "path": "src\\gstsomapos2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the new element\n * instantiate pads and add them to element\n * set pad calback functions\n * initialize instance structure\n */\n", "func_signal": "static void\ngst_soma_cmml2text_init (GstSomaCmml2Text * filter,\n    GstSomaCmml2TextClass * gclass)", "code": "{\n  filter->sinkpad = gst_pad_new_from_static_template (&sink_factory, \"sink\");\n  //gst_pad_set_setcaps_function (filter->sinkpad,\n  //                              GST_DEBUG_FUNCPTR(gst_soma_cmml2text_set_caps));\n  gst_pad_set_getcaps_function (filter->sinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_cmml2text_get_caps));\n  gst_pad_set_chain_function (filter->sinkpad,\n                              GST_DEBUG_FUNCPTR(gst_soma_cmml2text_chain));\n\n  filter->srcpad = gst_pad_new_from_static_template (&src_factory, \"src\");\n  gst_pad_set_getcaps_function (filter->srcpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_cmml2text_get_caps));\n\n  gst_element_add_pad (GST_ELEMENT (filter), filter->sinkpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->srcpad);\n  filter->silent = FALSE;\n\n}", "path": "src\\gstsomacmml2text.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* chain function\n * this function does the actual processing\n */\n", "func_signal": "static GstFlowReturn\ngst_soma_camera_event_chain (GstPad * pad, GstBuffer * buf)", "code": "{\n  GstSomaCameraEvent *filter;\n  GstFlowReturn ret=GST_FLOW_OK;\n  GstBuffer *outbuf = NULL;\n  GstSomaDiode *diode;\n  struct event_t *events;\n  int nevents=0, i;\n  guint64 timestamp=0;\n  guint16 delta_on, delta_off;\n  //struct timeval now;\n  //int ts;\n\n  filter = GST_SOMACAMERAEVENT (GST_OBJECT_PARENT (pad));\n\n  events = (struct event_t*) GST_BUFFER_DATA(buf);\n  nevents = GST_BUFFER_SIZE(buf) / sizeof(struct event_t);\n\n  GST_DEBUG_OBJECT(filter, \"Received %d soma events\", nevents);\n\n  for (i=0; i<nevents; i++) {\n\n    if (events[i].cmd==filter->evtcmd) {\n\n      delta_on = (~filter->prevstate) & events[i].data[1];\n      delta_off = filter->prevstate & (~events[i].data[1]);\n\n      GST_DEBUG_OBJECT(filter, \"digital out event: %d (was: %d)\", events[i].data[1]);\n\n      filter->prevstate = events[i].data[1];\n\n      if (delta_on & CAMERA) {\n\n\tif (filter->got_camera) {\n\t  //error?\n\t  GST_WARNING(\"received a camera on event, but we haven't pushed out the previous buffer yet\\n\");\n\t}\n\n\t//retrieve timestamp\n\ttimestamp = events[i].data[2];\n\ttimestamp = (timestamp << 16) | events[i].data[3];\n\ttimestamp = (timestamp << 16) | events[i].data[4];\n\n\t//now = time(NULL);\n\n\t//ts = gettimeofday(&now,NULL);\n\n\t//guint64 x=now.tv_sec;\n\t//x=x*1000000;\n\t//x=x+now.tv_usec;\n\n\t//g_print(\"timestamp: %lld, wall clock: %lld\\n\", timestamp, x - filter->prevwallclock);\n\n\t//filter->prevwallclock = x;\n\n\t//save timestamp\n\tfilter->currenttimestamp = timestamp;\n\n\t//\n\tfilter->got_camera = TRUE;\n\n      }\n\n      if (delta_on & DIODE0) {\n\n\tif (filter->got_diode) {\n\t  GST_WARNING(\"received a diode0 on event, but we haven't pushed out the previous buffer yet\\n\");\n\t}\n\n\tif (filter->prevdiode==0) {\n\t  GST_WARNING(\"received two diode0 on events in a row\");\n\t}\n\n\tfilter->currentdiode = 0;\n\tfilter->got_diode = TRUE;\n\n      }\n\n\n      if (delta_on & DIODE1) {\n\n\tif (filter->got_diode) {\n\t  GST_WARNING(\"received a diode1 on event, but we haven't pushed out the previous buffer yet\\n\");\n\t}\n\n\tif (filter->prevdiode==1) {\n\t  GST_WARNING(\"received two diode0 on events in a row\");\n\t}\n\n\tfilter->currentdiode = 1;\n\tfilter->got_diode = TRUE;\n\n      }\n\t\n    }\n\n    if (filter->got_camera && filter->got_diode) {\n      \n      //create output buffer\n      ret = gst_pad_alloc_buffer (filter->srcpad, GST_BUFFER_OFFSET_NONE,\n\t\t\t\t  sizeof(GstSomaDiode), GST_PAD_CAPS (filter->srcpad), &outbuf);\n      \n      \n      diode = (GstSomaDiode*) GST_BUFFER_DATA( outbuf );\n      diode->timestamp = filter->currenttimestamp;\n      diode->diode = filter->currentdiode;\n      \n      filter->got_camera = FALSE;\n      filter->got_diode = FALSE;\n      \n      filter->prevdiode = diode->diode;\n      \n      gst_buffer_copy_metadata( outbuf, buf, GST_BUFFER_COPY_TIMESTAMPS );\n\n      //push out buffer\n      GST_DEBUG_OBJECT(filter, \"pushing diode buffer: timestamp=%llu, diode=%d\", diode->timestamp, diode->diode);\n      ret = gst_pad_push( filter->srcpad, outbuf );\n      \n      \n    }\n    \n  }\n\n  return ret;\n\n}", "path": "src\\gstsomacameraevent.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* initialize the new element\n * instantiate pads and add them to element\n * set pad calback functions\n * initialize instance structure\n */\n", "func_signal": "static void\ngst_soma_camera_event_init (GstSomaCameraEvent * filter,\n    GstSomaCameraEventClass * gclass)", "code": "{\n  filter->sinkpad = gst_pad_new_from_static_template (&sink_factory, \"sink\");\n  //gst_pad_set_setcaps_function (filter->sinkpad,\n  //                              GST_DEBUG_FUNCPTR(gst_soma_camera_event_set_caps));\n  gst_pad_set_getcaps_function (filter->sinkpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_camera_event_get_caps));\n  gst_pad_set_chain_function (filter->sinkpad,\n                              GST_DEBUG_FUNCPTR(gst_soma_camera_event_chain));\n\n  filter->srcpad = gst_pad_new_from_static_template (&src_factory, \"src\");\n  gst_pad_set_getcaps_function (filter->srcpad,\n                                GST_DEBUG_FUNCPTR(gst_soma_camera_event_get_caps));\n\n  //gst_pad_use_fixed_caps( filter->srcpad );\n  //gst_pad_set_caps (filter->srcpad, gst_caps_new_simple (\"soma/diode\",NULL) );\n\n  gst_element_add_pad (GST_ELEMENT (filter), filter->sinkpad);\n  gst_element_add_pad (GST_ELEMENT (filter), filter->srcpad);\n\n  filter->silent = FALSE;\n  filter->evtcmd = 0x30;\n  filter->prevstate = 0;\n  filter->prevdiode = -1;\n  filter->currentdiode = -1;\n  filter->got_camera = FALSE;\n  filter->got_diode = FALSE;\n\n}", "path": "src\\gstsomacameraevent.c", "repo_name": "somaproject/tracker", "stars": 4, "license": "None", "language": "c", "size": 128}
{"docstring": "/* begin relaying via TELNET proxy.\n   Sends string specified by telnet_command (-c option) with\n   replacing host name and port number to the socket.  */\n", "func_signal": "int\nbegin_telnet_relay( SOCKET s )", "code": "{\n    char buf[1024];\n    char *cmd;\n    char *good_phrase = \"connected to\";\n    char *bad_phrase_list[] = {\n\t\" failed\", \" refused\", \" rejected\", \" closed\"\n    };\n    char sep = ' ';\n    int i;\n\n    debug(\"begin_telnet_relay()\\n\");\n\n    /* report phrase */\n    debug(\"good phrase: '%s'\\n\", good_phrase);\n    debug(\"bad phrases\");\n    sep = ':';\n    for (i=0; i< (sizeof(bad_phrase_list) / sizeof(char*)); i++) {\n\tdebug_(\"%c '%s'\", sep, bad_phrase_list[i]);\n\tsep = ',';\n    }\n    debug_(\"\\n\");\n\n    /* make request string with replacing %h by destination hostname\n       and %p by port number, etc. */\n    cmd = expand_host_and_port(telnet_command, dest_host, dest_port);\n    \n    /* Sorry, we send request string now without waiting a prompt. */\n    if (sendf(s, \"%s\\r\\n\", cmd) < 0) {\n\tfree(cmd);\n        return START_ERROR;\n    }\n    free(cmd);\n\n    /* Process answer from proxy until good or bad phrase is detected.  We\n       assume that the good phrase should be appeared only in the final\n       line of proxy responses. Bad keywods in the line causes operation\n       fail. First checks a good phrase, then checks bad phrases.\n       If no match, continue reading line from proxy. */\n    while (!line_input(s, buf, sizeof(buf)) && buf[0] != '\\0') {\n\tdowncase(buf);\n\t/* first, check good phrase */\n        if (strstr(buf, good_phrase)) {\n\t    debug(\"good phrase is detected: '%s'\\n\", good_phrase);\n            return START_OK;\n        }\n\t/* then, check bad phrase */\n\tfor (i=0; i<(sizeof(bad_phrase_list)/sizeof(char*)); i++) {\n\t    if (strstr(buf, bad_phrase_list[i]) != NULL) {\n\t\tdebug(\"bad phrase is detected: '%s'\\n\", bad_phrase_list[i]);\n\t\treturn START_ERROR;\n\t    }\n        }\n    }\n    debug(\"error reading from telnet proxy\\n\");\n\n    return START_ERROR;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Electronic Codebook Mode DES encryption/decryption of data according\n * to 'mode'.\n */\n//Lalee declared this non-static \n//static int\n", "func_signal": "int\ndes_ecb_crypt (struct _des_ctx *ctx, const byte * from, byte * to, int mode)", "code": "{\n  u32 left, right, work;\n  u32 *keys;\n\n  keys = mode ? ctx->decrypt_subkeys : ctx->encrypt_subkeys;\n\n  READ_64BIT_DATA (from, left, right)\n  INITIAL_PERMUTATION (left, work, right)\n\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n\n  FINAL_PERMUTATION (right, work, left)\n  WRITE_64BIT_DATA (to, right, left)\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Check whether the 8 byte key is weak.\n * Dose not check the parity bits of the key but simple ignore them.\n */\n", "func_signal": "static int\nis_weak_key ( const byte *key )", "code": "{\n  byte work[8];\n  int i, left, right, middle, cmp_result;\n\n  /* clear parity bits */\n  for(i=0; i<8; ++i)\n     work[i] = key[i] & 0xfe;\n\n  /* binary search in the weak key table */\n  left = 0;\n  right = 63;\n  while(left <= right)\n    {\n      middle = (left + right) / 2;\n\n      if ( !(cmp_result=working_memcmp(work, weak_keys[middle], 8)) )\n\t  return -1;\n\n      if ( cmp_result > 0 )\n\t  left = middle + 1;\n      else\n\t  right = middle - 1;\n    }\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* relay byte from stdin to socket and fro socket to stdout.\n   returns reason of termination */\n", "func_signal": "int\ndo_repeater( SOCKET local_in, SOCKET local_out, SOCKET remote )", "code": "{\n    /** vars for local input data **/\n    char lbuf[1024];                            /* local input buffer */\n    int lbuf_len;                               /* available data in lbuf */\n    int f_local;                                /* read local input more? */\n    /** vars for remote input data **/\n    char rbuf[1024];                            /* remote input buffer */\n    int rbuf_len;                               /* available data in rbuf */\n    int f_remote;                               /* read remote input more? */\n    int close_reason = REASON_UNK;              /* reason of end repeating */\n    /** other variables **/\n    int nfds, len;\n    fd_set ifds, ofds;\n    struct timeval *tmo;\n#ifdef _WIN32\n    struct timeval win32_tmo;\n#endif /* _WIN32 */\n\n    /* repeater between stdin/out and socket  */\n    nfds = ((local_in<remote)? remote: local_in) +1;\n    f_local = 1;                                /* yes, read from local */\n    f_remote = 1;                               /* yes, read from remote */\n    lbuf_len = 0;\n    rbuf_len = 0;\n\n    while ( f_local || f_remote ) {\n        FD_ZERO(&ifds );\n        FD_ZERO(&ofds );\n        tmo = NULL;\n\n        /** prepare for reading local input **/\n        if ( f_local && (lbuf_len < (int)sizeof(lbuf)) ) {\n#ifdef _WIN32\n            if ( local_type != LOCAL_SOCKET ) {\n                /* select() on Winsock is not accept standard handle.\n                   So use select() with short timeout and checking data\n                   in stdin by another method. */\n                win32_tmo.tv_sec = 0;\n                win32_tmo.tv_usec = 10*1000;    /* 10 ms */\n                tmo = &win32_tmo;\n            } else\n#endif /* !_WIN32 */\n            FD_SET( local_in, &ifds );\n        }\n\n        /** prepare for reading remote input **/\n        if ( f_remote && (rbuf_len < (int)sizeof(rbuf)) ) {\n            FD_SET( remote, &ifds );\n        }\n\n        /* FD_SET( local_out, ofds ); */\n        /* FD_SET( remote, ofds ); */\n\n        if ( select( nfds, &ifds, &ofds, (fd_set*)NULL, tmo ) == -1 ) {\n            /* some error */\n            error( \"select() failed, %d\\n\", socket_errno());\n            return REASON_ERROR;\n        }\n#ifdef _WIN32\n        /* fake ifds if local is stdio handle because\n           select() of Winsock does not accept stdio\n           handle. */\n        if (f_local && (local_type!=LOCAL_SOCKET) && (0<stdindatalen()))\n            FD_SET(0,&ifds);            /* data ready */\n#endif\n\n        /* remote => local */\n        if ( FD_ISSET(remote, &ifds) && (rbuf_len < (int)sizeof(rbuf)) ) {\n            len = recv( remote, rbuf + rbuf_len, sizeof(rbuf)-rbuf_len, 0);\n            if ( len == 0 || (len == -1 && socket_errno() == ECONNRESET)) {\n                debug(\"connection %s by peer\\n\",\n                      (len==0)? \"closed\": \"reset\");\n                close_reason = REASON_CLOSED_BY_REMOTE;\n                f_remote = 0;                   /* no more read from socket */\n                f_local = 0;\n            } else if ( len == -1 ) {\n                /* error */\n                fatal(\"recv() failed, %d\\n\", socket_errno());\n            } else {\n                debug(\"recv %d bytes\\n\", len);\n                if ( 1 < f_debug )              /* more verbose */\n                    report_bytes( \"<<<\", rbuf+rbuf_len, len);\n                rbuf_len += len;\n            }\n        }\n\n        /* local => remote */\n        if ( FD_ISSET(local_in, &ifds) && (lbuf_len < (int)sizeof(lbuf)) ) {\n            if (local_type == LOCAL_SOCKET)\n                len = recv(local_in, lbuf + lbuf_len,\n                           sizeof(lbuf)-lbuf_len, 0);\n            else\n                len = read(local_in, lbuf + lbuf_len, sizeof(lbuf)-lbuf_len);\n            if ( len == 0 ) {\n                /* stdin is EOF */\n                debug(\"local input is EOF\\n\");\n                if (!f_hold_session)\n                    shutdown(remote, 1);        /* no-more writing */\n                f_local = 0;\n                close_reason = REASON_CLOSED_BY_LOCAL;\n            } else if ( len == -1 ) {\n                /* error on reading from stdin */\n                if (f_hold_session) {\n                    debug (\"failed to read from local\\n\");\n                    f_local = 0;\n                    close_reason = REASON_CLOSED_BY_LOCAL;\n                } else\n                    fatal(\"recv() failed, errno = %d\\n\", errno);\n            } else {\n                /* repeat */\n                lbuf_len += len;\n            }\n        }\n\n        /* flush data in buffer to socket */\n        if ( 0 < lbuf_len ) {\n            len = send(remote, lbuf, lbuf_len, 0);\n            if ( len == -1 ) {\n                fatal(\"send() failed, %d\\n\", socket_errno());\n            } else if ( 0 < len ) {\n                if ( 1 < f_debug )              /* more verbose */\n                    report_bytes( \">>>\", lbuf, len);\n                /* move data on to top of buffer */\n                debug(\"sent %d bytes\\n\", len);\n                lbuf_len -= len;\n                if ( 0 < lbuf_len )\n                    memcpy( lbuf, lbuf+len, lbuf_len );\n                assert( 0 <= lbuf_len );\n            }\n        }\n\n        /* flush data in buffer to local output */\n        if ( 0 < rbuf_len ) {\n            if (local_type == LOCAL_SOCKET)\n                len = send( local_out, rbuf, rbuf_len, 0);\n            else\n                len = write( local_out, rbuf, rbuf_len);\n            if ( len == -1 ) {\n                fatal(\"output (local) failed, errno=%d\\n\", errno);\n            }\n            rbuf_len -= len;\n            if ( len < rbuf_len )\n                memcpy( rbuf, rbuf+len, rbuf_len );\n            assert( 0 <= rbuf_len );\n        }\n        if (f_local == 0 && f_hold_session) {\n            debug (\"closing local port without disconnecting from remote\\n\");\n            f_remote = 0;\n            shutdown (local_out, 2);\n            close (local_out);\n            break;\n        }\n    }\n\n    return close_reason;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* check to connect to HOST directyly?\n   return 1 if to be direct, 0 for else. */\n", "func_signal": "int\ncheck_direct(const char *host)", "code": "{\n    struct in_addr addr;\n    addr.s_addr = inet_addr(host);\n    if (addr.s_addr != INADDR_NONE) {\n        /* case of IP address */\n        if (is_direct_address(addr)) {\n            debug(\"%s is for direct.\\n\", host);\n            return 1;                           /* true */\n        }\n    } else {\n        /* case of hostname */\n        if (is_direct_name(host)) {\n            debug(\"%s is for direct.\\n\", host);\n            return 1;                           /* true */\n        }\n    }\n    debug(\"%s is for not direct.\\n\", host);\n    return 0;                                    /* false */\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* error message output */\n", "func_signal": "void\nerror( const char *fmt, ... )", "code": "{\n    va_list args;\n    va_start( args, fmt );\n    fprintf(stderr, \"ERROR: \");\n    vfprintf( stderr, fmt, args );\n    va_end( args );\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * des_key_schedule():\t  Calculate 16 subkeys pairs (even/odd) for\n *\t\t\t  16 encryption rounds.\n *\t\t\t  To calculate subkeys for decryption the caller\n *\t\t\t  have to reorder the generated subkeys.\n *\n *    rawkey:\t    8 Bytes of key data\n *    subkey:\t    Array of at least 32 u32s. Will be filled\n *\t\t    with calculated subkeys.\n *\n */\n", "func_signal": "static void\ndes_key_schedule (const byte * rawkey, u32 * subkey)", "code": "{\n  u32 left, right, work;\n  int round;\n\n  READ_64BIT_DATA (rawkey, left, right)\n\n  DO_PERMUTATION (right, work, left, 4, 0x0f0f0f0f)\n  DO_PERMUTATION (right, work, left, 0, 0x10101010)\n\n  left = (leftkey_swap[(left >> 0) & 0xf] << 3) | (leftkey_swap[(left >> 8) & 0xf] << 2)\n    | (leftkey_swap[(left >> 16) & 0xf] << 1) | (leftkey_swap[(left >> 24) & 0xf])\n    | (leftkey_swap[(left >> 5) & 0xf] << 7) | (leftkey_swap[(left >> 13) & 0xf] << 6)\n    | (leftkey_swap[(left >> 21) & 0xf] << 5) | (leftkey_swap[(left >> 29) & 0xf] << 4);\n\n  left &= 0x0fffffff;\n\n  right = (rightkey_swap[(right >> 1) & 0xf] << 3) | (rightkey_swap[(right >> 9) & 0xf] << 2)\n    | (rightkey_swap[(right >> 17) & 0xf] << 1) | (rightkey_swap[(right >> 25) & 0xf])\n    | (rightkey_swap[(right >> 4) & 0xf] << 7) | (rightkey_swap[(right >> 12) & 0xf] << 6)\n    | (rightkey_swap[(right >> 20) & 0xf] << 5) | (rightkey_swap[(right >> 28) & 0xf] << 4);\n\n  right &= 0x0fffffff;\n\n  for (round = 0; round < 16; ++round)\n    {\n      left = ((left << encrypt_rotate_tab[round]) | (left >> (28 - encrypt_rotate_tab[round]))) & 0x0fffffff;\n      right = ((right << encrypt_rotate_tab[round]) | (right >> (28 - encrypt_rotate_tab[round]))) & 0x0fffffff;\n\n      *subkey++ = ((left << 4) & 0x24000000)\n\t| ((left << 28) & 0x10000000)\n\t| ((left << 14) & 0x08000000)\n\t| ((left << 18) & 0x02080000)\n\t| ((left << 6) & 0x01000000)\n\t| ((left << 9) & 0x00200000)\n\t| ((left >> 1) & 0x00100000)\n\t| ((left << 10) & 0x00040000)\n\t| ((left << 2) & 0x00020000)\n\t| ((left >> 10) & 0x00010000)\n\t| ((right >> 13) & 0x00002000)\n\t| ((right >> 4) & 0x00001000)\n\t| ((right << 6) & 0x00000800)\n\t| ((right >> 1) & 0x00000400)\n\t| ((right >> 14) & 0x00000200)\n\t| (right & 0x00000100)\n\t| ((right >> 5) & 0x00000020)\n\t| ((right >> 10) & 0x00000010)\n\t| ((right >> 3) & 0x00000008)\n\t| ((right >> 18) & 0x00000004)\n\t| ((right >> 26) & 0x00000002)\n\t| ((right >> 24) & 0x00000001);\n\n      *subkey++ = ((left << 15) & 0x20000000)\n\t| ((left << 17) & 0x10000000)\n\t| ((left << 10) & 0x08000000)\n\t| ((left << 22) & 0x04000000)\n\t| ((left >> 2) & 0x02000000)\n\t| ((left << 1) & 0x01000000)\n\t| ((left << 16) & 0x00200000)\n\t| ((left << 11) & 0x00100000)\n\t| ((left << 3) & 0x00080000)\n\t| ((left >> 6) & 0x00040000)\n\t| ((left << 15) & 0x00020000)\n\t| ((left >> 4) & 0x00010000)\n\t| ((right >> 2) & 0x00002000)\n\t| ((right << 8) & 0x00001000)\n\t| ((right >> 14) & 0x00000808)\n\t| ((right >> 9) & 0x00000400)\n\t| ((right) & 0x00000200)\n\t| ((right << 7) & 0x00000100)\n\t| ((right >> 7) & 0x00000020)\n\t| ((right >> 3) & 0x00000011)\n\t| ((right << 2) & 0x00000004)\n\t| ((right >> 21) & 0x00000002);\n    }\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Performs a selftest of this DES/Triple-DES implementation.\n * Returns an string with the error text on failure.\n * Returns NULL if all is ok.\n */\n", "func_signal": "static const char *\nselftest (void)", "code": "{\n  /*\n   * Check if 'u32' is really 32 bits wide. This DES / 3DES implementation\n   * need this.\n   */\n  if (sizeof (u32) != 4)\n       return \"Wrong word size for DES configured.\";\n\n  /*\n   * DES Maintenance Test\n   */\n  {\n    int i;\n    byte key[8] =\n    {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55};\n    byte input[8] =\n    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    byte result[8] =\n    {0x24, 0x6e, 0x9d, 0xb9, 0xc5, 0x50, 0x38, 0x1a};\n    byte temp1[8], temp2[8], temp3[8];\n    des_ctx des;\n\n    for (i = 0; i < 64; ++i)\n      {\n\tdes_setkey (des, key);\n\tdes_ecb_encrypt (des, input, temp1);\n\tdes_ecb_encrypt (des, temp1, temp2);\n\tdes_setkey (des, temp2);\n\tdes_ecb_decrypt (des, temp1, temp3);\n\tmemcpy (key, temp3, 8);\n\tmemcpy (input, temp1, 8);\n      }\n    if (memcmp (temp3, result, 8))\n      return \"DES maintenance test failed.\";\n  }\n\n\n  /*\n   * Self made Triple-DES test\t(Does somebody known an official test?)\n   */\n  {\n    int i;\n    byte input[8] =\n    {0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};\n    byte key1[8] =\n    {0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0};\n    byte key2[8] =\n    {0x11, 0x22, 0x33, 0x44, 0xff, 0xaa, 0xcc, 0xdd};\n    byte result[8] =\n    {0x7b, 0x38, 0x3b, 0x23, 0xa2, 0x7d, 0x26, 0xd3};\n\n    tripledes_ctx des3;\n\n    for (i = 0; i < 16; ++i)\n      {\n\ttripledes_set2keys (des3, key1, key2);\n\ttripledes_ecb_encrypt (des3, input, key1);\n\ttripledes_ecb_decrypt (des3, input, key2);\n\ttripledes_set3keys (des3, key1, input, key2);\n\ttripledes_ecb_encrypt (des3, input, input);\n      }\n    if (memcmp (input, result, 8))\n      return \"Triple-DES test failed.\";\n  }\n\n    /*\n     * More Triple-DES test.  These are testvectors as used by SSLeay,\n     * thanks to Jeroen C. van Gelderen.\n     */\n    {\tstruct { byte key[24]; byte plain[8]; byte cipher[8]; } testdata[] = {\n\t{ { 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01  },\n\t  { 0x95,0xF8,0xA5,0xE5,0xDD,0x31,0xD9,0x00  },\n\t  { 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00  }\n\t},\n\n\t{ { 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01  },\n\t  { 0x9D,0x64,0x55,0x5A,0x9A,0x10,0xB8,0x52, },\n\t  { 0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00  }\n\t},\n\t{ { 0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,\n\t    0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,\n\t    0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E  },\n\t  { 0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A  },\n\t  { 0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A  }\n\t},\n\t{ { 0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,\n\t    0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,\n\t    0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6  },\n\t  { 0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2  },\n\t  { 0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95  }\n\t},\n\t{ { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF  },\n\t  { 0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61  },\n\t  { 0x3D,0x12,0x4F,0xE2,0x19,0x8B,0xA3,0x18  }\n\t},\n\t{ { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t    0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,\n\t    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF  },\n\t  { 0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61  },\n\t  { 0xFB,0xAB,0xA1,0xFF,0x9D,0x05,0xE9,0xB1  }\n\t},\n\t{ { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t    0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,\n\t    0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10  },\n\t  { 0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61  },\n\t  { 0x18,0xd7,0x48,0xe5,0x63,0x62,0x05,0x72  }\n\t},\n\t{ { 0x03,0x52,0x02,0x07,0x67,0x20,0x82,0x17,\n\t    0x86,0x02,0x87,0x66,0x59,0x08,0x21,0x98,\n\t    0x64,0x05,0x6A,0xBD,0xFE,0xA9,0x34,0x57  },\n\t  { 0x73,0x71,0x75,0x69,0x67,0x67,0x6C,0x65  },\n\t  { 0xc0,0x7d,0x2a,0x0f,0xa5,0x66,0xfa,0x30  }\n\t},\n\t{ { 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x80,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n\t    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02  },\n\t  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  },\n\t  { 0xe6,0xe6,0xdd,0x5b,0x7e,0x72,0x29,0x74  }\n\t},\n\t{ { 0x10,0x46,0x10,0x34,0x89,0x98,0x80,0x20,\n\t    0x91,0x07,0xD0,0x15,0x89,0x19,0x01,0x01,\n\t    0x19,0x07,0x92,0x10,0x98,0x1A,0x01,0x01  },\n\t  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  },\n\t  { 0xe1,0xef,0x62,0xc3,0x32,0xfe,0x82,0x5b  }\n\t}\n\t};\n\n\tbyte\t\tresult[8];\n\tint\t\ti;\n\tstatic char\terror[80];\n\ttripledes_ctx\tdes3;\n\n\tfor (i=0; i<sizeof(testdata)/sizeof(*testdata); ++i) {\n\t    tripledes_set3keys (des3, testdata[i].key, testdata[i].key + 8, testdata[i].key + 16);\n\n\t    tripledes_ecb_encrypt (des3, testdata[i].plain, result);\n\t    if (memcmp (testdata[i].cipher, result, 8)) {\n\t\tsprintf (error, \"Triple-DES SSLeay test pattern no. %d failend on encryption.\", i+1);\n\t\treturn error;\n\t    }\n\n\t    tripledes_ecb_decrypt (des3, testdata[i].cipher, result);\n\t    if (memcmp (testdata[i].plain, result, 8)) {\n\t\tsprintf (error, \"Triple-DES SSLeay test pattern no. %d failend on decryption.\", i+1);\n\t\treturn error;\n\t    }\n\t}\n    }\n\n  /*\n   * Check the weak key detection. We simply assume that the table\n   * with weak keys is ok and check every key in the table if it is\n   * detected... (This test is a little bit stupid)\n   */\n  {\n    int i;\n\n    for (i = 0; i < 64; ++i)\n\tif (!is_weak_key(weak_keys[i]))\n\t    return \"DES weak key detection failed\";\n  }\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* set timeout param = seconds, 0 clears */\n", "func_signal": "void\nset_timeout(int timeout)", "code": "{\n    /* This feature is allowed for UNIX or cygwin environments, currently */\n    if ( timeout == 0 ) {\n        debug( \"clearing timeout\\n\" );\n        signal( SIGALRM, SIG_IGN );\n        alarm( 0 );\n    } else {\n        debug( \"setting timeout: %d seconds\\n\", timeout );\n        signal(SIGALRM, (void *)sig_timeout);\n        alarm( timeout );\n    }\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* begin relaying via HTTP proxy\n   Directs CONNECT method to proxy server to connect to\n   destination host (and port). It may not be allowed on your\n   proxy server.\n */\n", "func_signal": "int\nbegin_http_relay( SOCKET s )", "code": "{\n    char buf[1024];\n    char buf2[1024]; /* NTLM Enhancement needs the entire line-buffer, so we copy it before it gets tokenized. */\n    int result;\n    char *auth_what;\n\n    debug(\"begin_http_relay()\\n\");\n\n    if (sendf(s,\"CONNECT %s:%d HTTP/1.0\\r\\n\", dest_host, dest_port) < 0)\n        return START_ERROR;\n    if (proxy_auth_type == PROXY_AUTH_BASIC && basic_auth (s) < 0)\n        return START_ERROR;\n    if (proxy_auth_type == PROXY_AUTH_NTLM && ntlm_auth (s) < 0)\n        return START_ERROR;\n    if (sendf(s,\"\\r\\n\") < 0)\n        return START_ERROR;\n\n    /* get response */\n    if ( line_input(s, buf, sizeof(buf)) < 0 ) {\n        debug(\"failed to read http response.\\n\");\n        return START_ERROR;\n    }\n\n    /* check status */\n    if (!strchr(buf, ' ')) {\n\terror (\"Unexpected http response: '%s'.\\n\", buf);\n\treturn START_ERROR;\n    }\n    result = atoi(strchr(buf,' '));\n\n    switch ( result ) {\n    case 200:\n        /* Conguraturation, connected via http proxy server! */\n        debug(\"connected, start user session.\\n\");\n        break;\n    case 302:                                   /* redirect */\n        do {\n            if (line_input(s, buf, sizeof(buf)))\n                break;\n            downcase(buf);\n            if (expect(buf, \"Location: \")) {\n                relay_host = cut_token(buf, \"//\");\n                cut_token(buf, \"/\");\n                relay_port = atoi(cut_token(buf, \":\"));\n            }\n        } while (strcmp(buf,\"\\r\\n\") != 0);\n        /* NTLM Enhancement: Reset Handshake to INITIAL State, then Retry Handshake */\n        proxy_auth_type = PROXY_AUTH_NTLM;\n        gConnectData.proxyntlm.state = NTLMSTATE_NONE;\n        return START_RETRY;\n\n    /* We handle both 401 and 407 codes here: 401 is WWW-Authenticate, which\n     * not strictly the correct response, but some proxies do send this (e.g.\n     * Symantec's Raptor firewall) */\n    case 401:                                   /* WWW-Auth required */\n    case 407:                                   /* Proxy-Auth required */\n        /** NOTE: As easy implementation, we support only BASIC scheme\n            and ignore realm. */\n        /* If proxy_auth_type is PROXY_AUTH_BASIC and get\n         this result code, authentication was failed. */\n        if (proxy_auth_type == PROXY_AUTH_BASIC) {\n            error(\"Authentication failed.\\n\");\n            return START_ERROR;\n        }\n        auth_what = (result == 401) ? \"WWW-Authenticate:\" : \"Proxy-Authenticate:\";\n        do {\n            if ( line_input(s, buf, sizeof(buf)) ) {\n                break;\n            }\n            /* NTLM Enhancement: Preserve the raw (untokenized) buffer for NTLM Authentication */\n            memset(buf2,0,sizeof(buf2));\n            strncpy(buf2,buf,strlen(buf)-2); /* Copy everything excluding final cr/lf */\n\n            downcase(buf);\n            if (expect(buf, auth_what)) {\n                /* parse type and realm */\n                char *scheme, *realm;\n                scheme = cut_token(buf, \" \");\n                realm = cut_token(scheme, \" \");\n                if ( scheme == NULL || realm == NULL ) {\n                    debug(\"Invalid format of %s field.\", auth_what);\n                    return START_ERROR;         /* fail */\n                }\n                /* check supported auth type */\n                if (expect(scheme, \"ntlm\")) {\n                    proxy_auth_type = PROXY_AUTH_NTLM;\n                    /* Allow NTLM to process incoming NTLM Header (Everything after *-Authenticate: stuff) */\n                    if (ne_input_ntlm(&gConnectData,1,buf2+strlen(auth_what)+1) == NENTLM_BAD) {\n                        debug(\"Failed NTLM Authentication [%s]\",buf2);\n                        return START_ERROR;\n                    }\n                } else\n                if (expect(scheme, \"basic\")) {\n                    proxy_auth_type = PROXY_AUTH_BASIC;\n                } else {\n                    debug(\"Unsupported authentication type: %s\", scheme);\n                }\n            }\n        } while (strcmp(buf,\"\\r\\n\") != 0);\n        if ( proxy_auth_type == PROXY_AUTH_NONE ) {\n            debug(\"Can't find %s in response header.\", auth_what);\n            return START_ERROR;\n        } else {\n            return START_RETRY;\n        }\n\n    default:\n        /* Not allowed */\n        debug(\"http proxy is not allowed.\\n\");\n        return START_ERROR;\n    }\n    /* skip to end of response header */\n    do {\n        if ( line_input(s, buf, sizeof(buf) ) ) {\n            debug(\"Can't skip response headers\\n\");\n            return START_ERROR;\n        }\n    } while ( strcmp(buf,\"\\r\\n\") != 0 );\n\n    return START_OK;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Fill a Triple-DES context with subkeys calculated from two 64bit keys.\n * Does not check the parity bits of the keys, but simply ignore them.\n * Does not check for weak keys.\n */\n", "func_signal": "static int\ntripledes_set2keys (struct _tripledes_ctx *ctx,\n\t\t    const byte * key1,\n\t\t    const byte * key2)", "code": "{\n  int i;\n\n  des_key_schedule (key1, ctx->encrypt_subkeys);\n  des_key_schedule (key2, &(ctx->decrypt_subkeys[32]));\n  burn_stack (32);\n\n  for(i=0; i<32; i+=2)\n    {\n      ctx->decrypt_subkeys[i]\t = ctx->encrypt_subkeys[30-i];\n      ctx->decrypt_subkeys[i+1]  = ctx->encrypt_subkeys[31-i];\n\n      ctx->encrypt_subkeys[i+32] = ctx->decrypt_subkeys[62-i];\n      ctx->encrypt_subkeys[i+33] = ctx->decrypt_subkeys[63-i];\n\n      ctx->encrypt_subkeys[i+64] = ctx->encrypt_subkeys[i];\n      ctx->encrypt_subkeys[i+65] = ctx->encrypt_subkeys[i+1];\n\n      ctx->decrypt_subkeys[i+64] = ctx->decrypt_subkeys[i];\n      ctx->decrypt_subkeys[i+65] = ctx->decrypt_subkeys[i+1];\n    }\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* add domain/host name entry to direct name table */\n", "func_signal": "int\nadd_direct_host( const char *name, int negative)", "code": "{\n    if ( MAX_DIRECT_ADDR_LIST <= n_direct_addr_list ) {\n        error(\"direct address table is full!\\n\");\n        return -1;\n    }\n    if (*name == '*')\n        name++;\n    if (*name == '.')\n        name++;\n    debug(\"adding direct name entry: %s%s\\n\", negative? \"!\": \"\", name);\n    direct_addr_list[n_direct_addr_list].name = downcase(strdup(name));\n    direct_addr_list[n_direct_addr_list].negative = negative;\n    n_direct_addr_list++;\n    return 0;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* ddatalen()\n   Returns 1 if data is available, otherwise return 0\n */\n", "func_signal": "int\nstdindatalen (void)", "code": "{\n    DWORD len = 0;\n    struct stat st;\n    fstat( 0, &st );\n    if ( st.st_mode & _S_IFIFO ) {\n        /* in case of PIPE */\n        if ( !PeekNamedPipe( GetStdHandle(STD_INPUT_HANDLE),\n                             NULL, 0, NULL, &len, NULL) ) {\n            if ( GetLastError() == ERROR_BROKEN_PIPE ) {\n                /* PIPE source is closed */\n                /* read() will detects EOF */\n                len = 1;\n            } else {\n                fatal(\"PeekNamedPipe() failed, errno=%d\\n\",\n                      GetLastError());\n            }\n        }\n    } else if ( st.st_mode & _S_IFREG ) {\n        /* in case of regular file (redirected) */\n        len = 1;                        /* always data ready */\n    } else if ( _kbhit() ) {\n        /* in case of console */\n        len = 1;\n    }\n    return len;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* begin SOCKS5 relaying\n   And no authentication is supported.\n */\n", "func_signal": "int\nbegin_socks5_relay( SOCKET s )", "code": "{\n    unsigned char buf[256], *ptr, *env = socks5_auth;\n    unsigned char n_auth = 0; unsigned char auth_list[10], auth_method;\n    int len, auth_result, i;\n\n    debug( \"begin_socks_relay()\\n\");\n\n    /* request authentication */\n    ptr = buf;\n    PUT_BYTE( ptr++, 5);                        /* SOCKS version (5) */\n\n    if ( env == NULL )\n        env = getparam(ENV_SOCKS5_AUTH);\n    if ( env == NULL ) {\n        /* add no-auth authentication */\n        auth_list[n_auth++] = SOCKS5_AUTH_NOAUTH;\n        /* add user/pass authentication */\n        auth_list[n_auth++] = SOCKS5_AUTH_USERPASS;\n    } else {\n        n_auth = socks5_auth_parse(env, auth_list, 10);\n    }\n    PUT_BYTE( ptr++, n_auth);                   /* num auth */\n    for (i=0; i<n_auth; i++) {\n        debug(\"available auth method[%d] = %s (0x%02x)\\n\",\n              i, socks5_getauthname(auth_list[i]), auth_list[i]);\n        PUT_BYTE( ptr++, auth_list[i]);         /* authentications */\n    }\n    atomic_out( s, buf, ptr-buf );              /* send requst */\n    atomic_in( s, buf, 2 );                     /* recv response */\n    if ( (buf[0] != 5) ||                       /* ver5 response */\n         (buf[1] == 0xFF) ) {                   /* check auth method */\n        error(\"No auth method accepted.\\n\");\n        return -1;\n    }\n    auth_method = buf[1];\n\n    debug(\"auth method: %s\\n\", socks5_getauthname(auth_method));\n\n    switch ( auth_method ) {\n    case SOCKS5_AUTH_REJECT:\n        error(\"No acceptable authentication method\\n\");\n        return -1;                              /* fail */\n\n    case SOCKS5_AUTH_NOAUTH:\n        /* nothing to do */\n        auth_result = 0;\n        break;\n\n    case SOCKS5_AUTH_USERPASS:\n        auth_result = socks5_do_auth_userpass(s);\n        break;\n\n    default:\n        error(\"Unsupported authentication method: %s\\n\",\n              socks5_getauthname( auth_method ));\n        return -1;                              /* fail */\n    }\n    if ( auth_result != 0 ) {\n        error(\"Authentication failed.\\n\");\n        return -1;\n    }\n    /* request to connect */\n    ptr = buf;\n    PUT_BYTE( ptr++, 5);                        /* SOCKS version (5) */\n    PUT_BYTE( ptr++, 1);                        /* CMD: CONNECT */\n    PUT_BYTE( ptr++, 0);                        /* FLG: 0 */\n    if ( dest_addr.sin_addr.s_addr == 0 ) {\n        /* resolved by SOCKS server */\n        PUT_BYTE( ptr++, 3);                    /* ATYP: DOMAINNAME */\n        len = strlen(dest_host);\n        PUT_BYTE( ptr++, len);                  /* DST.ADDR (len) */\n        memcpy( ptr, dest_host, len );          /* (hostname) */\n        ptr += len;\n    } else {\n        /* resolved localy */\n        PUT_BYTE( ptr++, 1 );                   /* ATYP: IPv4 */\n        memcpy( ptr, &dest_addr.sin_addr.s_addr, sizeof(dest_addr.sin_addr));\n        ptr += sizeof(dest_addr.sin_addr);\n    }\n    PUT_BYTE( ptr++, dest_port>>8);     /* DST.PORT */\n    PUT_BYTE( ptr++, dest_port&0xFF);\n    atomic_out( s, buf, ptr-buf);               /* send request */\n    atomic_in( s, buf, 4 );                     /* recv response */\n    if ( (buf[1] != SOCKS5_REP_SUCCEEDED) ) {   /* check reply code */\n        error(\"Got error response from SOCKS server: %d (%s).\\n\",\n              buf[1], lookup(buf[1], socks5_rep_names));\n        return -1;\n    }\n    ptr = buf + 4;\n    switch ( buf[3] ) {                         /* case by ATYP */\n    case 1:                                     /* IP v4 ADDR*/\n        atomic_in( s, ptr, 4+2 );               /* recv IPv4 addr and port */\n        break;\n    case 3:                                     /* DOMAINNAME */\n        atomic_in( s, ptr, 1 );                 /* recv name and port */\n        atomic_in( s, ptr+1, *(unsigned char*)ptr + 2);\n        break;\n    case 4:                                     /* IP v6 ADDR */\n        atomic_in( s, ptr, 16+2 );              /* recv IPv6 addr and port */\n        break;\n    }\n\n    /* Conguraturation, connected via SOCKS5 server! */\n    return 0;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* check s1 is ends with s2.\n   return 1 if exact match or domain part match.\n   return 0 if s1 is shorter than s2 or partial match.\n   For example, \n    ends_with(\"bar.com\", \"bar.com\")        => 1 (exact match)\n    ends_with(\"foo.bar.com\", \"bar.com\")    => 1 (domain match)\n    ends_with(\"foo.beebar.com\", \"bar.com\") => 0 (partial match)\n    ends_with(\"bar\", \"bar.com\")            => 0 (shorter)\n */\n", "func_signal": "domain_match(const char *s1, const char *s2)", "code": "{\n    int len1, len2;\n    const char *tail1, *tail2;\n    len1 = strlen(s1);\n    len2 = strlen(s2);\n    if (len1 < len2 || len1 == 0 || len2 == 0)\n        return 0;                               /* not match */\n    tail1 = s1 + len1;\n    tail2 = s2 + len2;\n    while (0 < len1 && 0 < len2) {\n        if (*--tail1 != *--tail2)\n            break;                              /* not match */\n        len1--, len2--;\n    }\n    if (len2 != 0)\n        return 0;                               /* not match */\n    /* Now exact match, domain match or partial match.\n       Return true if exact or domain match.\n       Or continue checking. */\n    if (tail1 == s1 || tail1[-1] == '.')\n        return 1;                               /* match! */\n    return 0;                                   /* not match */\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Electronic Codebook Mode Triple-DES encryption/decryption of data according to 'mode'.\n * Sometimes this mode is named 'EDE' mode (Encryption-Decryption-Encryption).\n */\n", "func_signal": "static int\ntripledes_ecb_crypt (struct _tripledes_ctx *ctx, const byte * from, byte * to, int mode)", "code": "{\n  u32 left, right, work;\n  u32 *keys;\n\n  keys = mode ? ctx->decrypt_subkeys : ctx->encrypt_subkeys;\n\n  READ_64BIT_DATA (from, left, right)\n  INITIAL_PERMUTATION (left, work, right)\n\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n  DES_ROUND (left, right, work, keys) DES_ROUND (right, left, work, keys)\n\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n  DES_ROUND (right, left, work, keys) DES_ROUND (left, right, work, keys)\n\n  FINAL_PERMUTATION (right, work, left)\n  WRITE_64BIT_DATA (to, right, left)\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Fill a Triple-DES context with subkeys calculated from three 64bit keys.\n * Does not check the parity bits of the keys, but simply ignore them.\n * Does not check for weak keys.\n */\n", "func_signal": "static int\ntripledes_set3keys (struct _tripledes_ctx *ctx,\n\t\t    const byte * key1,\n\t\t    const byte * key2,\n\t\t    const byte * key3)", "code": "{\n  int i;\n\n  des_key_schedule (key1, ctx->encrypt_subkeys);\n  des_key_schedule (key2, &(ctx->decrypt_subkeys[32]));\n  des_key_schedule (key3, &(ctx->encrypt_subkeys[64]));\n  burn_stack (32);\n\n  for(i=0; i<32; i+=2)\n    {\n      ctx->decrypt_subkeys[i]\t = ctx->encrypt_subkeys[94-i];\n      ctx->decrypt_subkeys[i+1]  = ctx->encrypt_subkeys[95-i];\n\n      ctx->encrypt_subkeys[i+32] = ctx->decrypt_subkeys[62-i];\n      ctx->encrypt_subkeys[i+33] = ctx->decrypt_subkeys[63-i];\n\n      ctx->decrypt_subkeys[i+64] = ctx->encrypt_subkeys[30-i];\n      ctx->decrypt_subkeys[i+65] = ctx->encrypt_subkeys[31-i];\n    }\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/* NTLM Authentication Enhancement */\n", "func_signal": "int\nntlm_auth( SOCKET s)", "code": "{\n  int ret = 0;\n  NENTLM_CODE NTHandshakeStatus;\n\n    const char *user = relay_user;\n    char *pass = NULL;\n\n  /* Get username/password for authentication */\n    if (user == NULL)\n        fatal(\"Cannot decide username for proxy authentication.\");\n\n  /* NTLM Guard: If this is the initial handshake, use the Bogus Password, not User-Supplied Password */\n    if ((proxy_auth_type != PROXY_AUTH_NTLM) || (gConnectData.proxyntlm.state != NTLMSTATE_NONE)) {\n      if ((pass = determine_relay_password ()) == NULL &&\n        (pass = readpass(\"Enter proxy authentication password for %s@%s: \",\n                         relay_user, relay_host)) == NULL)\n        fatal(\"Cannot decide password for proxy authentication.\");\n    } else {\n      debug(\"NTLM Handshake: Using a Bogus Password to initialize NTLM Type1 message (this is normal).\\n\");\n      pass = strdup(sBogusPass);\n    }\n\n  /* Initialize the relevant properties in the connectdata structure - copy user/pass pointers */\n    gConnectData.proxypasswd = pass;\n    gConnectData.proxyuser = user;\n\n  /* Invoke NTLM Routine to process the NTLM Handshake */\n    NTHandshakeStatus = ne_output_ntlm(&gConnectData, 1);\n\n  /* Transmit the NTLM Handshake if Valid */\n    if (NTHandshakeStatus == NENTLME_OK) {\n      debug(\"ntlm_auth:  Computed NTLM Handshake = [%s]\\n\",gConnectData.allocptr.proxyuserpwd);\n      if (gConnectData.allocptr.proxyuserpwd) {\n        ret = sendf(s, gConnectData.allocptr.proxyuserpwd);\n      } else {\n        debug(\"ntlm_auth:  Unable to send NTLM Authentication Handshake String.\\n\");\n      }\n    } else {\n      debug(\"ntlm_auth:  General Failure while creating NTLM Authentication Handshake.\\n\");\n    } \n\n  /* Cleanse the Properties in the Structure (let our caller free() the real values) */\n  /* Allow ntlm module to do a safefree() on gConnectData.allocptr.proxyuserpwd */\n    gConnectData.proxypasswd = NULL;\n    gConnectData.proxyuser = NULL;\n    memset (pass, 0, strlen(pass)); /* Password no longer needed - Clobber the Password from RAM */\n\n    //ne_safefree(conn->allocptr.proxyuserpwd);\n    //conn->allocptr.proxyuserpwd = NULL;\n\n  return ret;\n}", "path": "connect.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*\n * Fill a DES context with subkeys calculated from a 64bit key.\n * Does not check parity bits, but simply ignore them.\n * Does not check for weak keys.\n */\n//Lalee declared this non-static \n//static int\n", "func_signal": "int\ndes_setkey (struct _des_ctx *ctx, const byte * key)", "code": "{\n  int i;\n\n  if( selftest_failed )\n    return G10ERR_SELFTEST_FAILED;\n\n  des_key_schedule (key, ctx->encrypt_subkeys);\n  burn_stack (32);\n\n  for(i=0; i<32; i+=2)\n    {\n      ctx->decrypt_subkeys[i]\t= ctx->encrypt_subkeys[30-i];\n      ctx->decrypt_subkeys[i+1] = ctx->encrypt_subkeys[31-i];\n    }\n\n  return 0;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/****************\n * Return some information about the algorithm.  We need algo here to\n * distinguish different flavors of the algorithm.\n * Returns: A pointer to string describing the algorithm or NULL if\n *\t    the ALGO is invalid.\n */\n", "func_signal": "const char *\ndes_get_info( int algo, size_t *keylen,\n\t      size_t *blocksize, size_t *contextsize,\n\t      int (**r_setkey)( void *c, const byte *key, unsigned keylen ),\n\t      void (**r_encrypt)( void *c, byte *outbuf, const byte *inbuf ),\n\t      void (**r_decrypt)( void *c, byte *outbuf, const byte *inbuf )\n\t      )", "code": "{\n    static int did_selftest = 0;\n\n    if( !did_selftest ) {\n\tconst char *s = selftest();\n\tdid_selftest = 1;\n\tif( s ) {\n\t    fprintf(stderr,\"%s\\n\", s );\n\t    selftest_failed = s;\n\t    return NULL;\n\t}\n    }\n\n    if( algo == CIPHER_ALGO_3DES ) {\n\t*keylen = 192;\n\t*blocksize = 8;\n\t*contextsize = sizeof(struct _tripledes_ctx);\n\t*r_setkey = do_tripledes_setkey;\n\t*r_encrypt = do_tripledes_encrypt;\n\t*r_decrypt = do_tripledes_decrypt;\n\treturn \"3DES\";\n    }\n    return NULL;\n}", "path": "des.c", "repo_name": "not404/connect-ntlm", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 142}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tRemove blanks at the beginning and the end of a string.\n  @param\ts\tString to parse.\n  @return\tptr to statically allocated string.\n\n  This function returns a pointer to a statically allocated string,\n  which is identical to the input string, except that all blank\n  characters at the end and the beg. of the string have been removed.\n  Do not free or modify the returned string! Since the returned string\n  is statically allocated, it will be modified at each function call\n  (not re-entrant).\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static char * strstrip(char * s)", "code": "{\n    static char l[ASCIILINESZ+1];\n\tchar * last ;\n\t\n    if (s==NULL) return NULL ;\n    \n\twhile (isspace((int)*s) && *s) s++;\n\tmemset(l, 0, ASCIILINESZ+1);\n\tstrcpy(l, s);\n\tlast = l + strlen(l);\n\twhile (last > l) {\n\t\tif (!isspace((int)*(last-1)))\n\t\t\tbreak ;\n\t\tlast -- ;\n\t}\n\t*last = (char)0;\n\treturn (char*)l ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "char * iniparser_getsecname(dictionary * d, int n)", "code": "{\n    int i ;\n    int foundsec ;\n\n    if (d==NULL || n<0) return NULL ;\n    foundsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            foundsec++ ;\n            if (foundsec>n)\n                break ;\n        }\n    }\n    if (foundsec<=n) {\n        return NULL ;\n    }\n    return d->key[i] ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_getint(dictionary * d, const char * key, int notfound)", "code": "{\n    char    *   str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return (int)strtol(str, NULL, 0);\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tCreate a new dictionary object.\n  @param\tsize\tOptional initial size of the dictionary.\n  @return\t1 newly allocated dictionary objet.\n\n  This function allocates a new dictionary object of given size and returns\n  it. If you do not know in advance (roughly) the number of entries in the\n  dictionary, give size=0.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "dictionary * dictionary_new(int size)", "code": "{\n\tdictionary\t*\td ;\n\n\t/* If no size was specified, allocate space for DICTMINSZ */\n\tif (size<DICTMINSZ) size=DICTMINSZ ;\n\n\tif (!(d = (dictionary *)calloc(1, sizeof(dictionary)))) {\n\t\treturn NULL;\n\t}\n\td->size = size ;\n\td->val  = (char **)calloc(size, sizeof(char*));\n\td->key  = (char **)calloc(size, sizeof(char*));\n\td->hash = (unsigned int *)calloc(size, sizeof(unsigned));\n\treturn d ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dump(dictionary * d, FILE * f)", "code": "{\n    int     i ;\n\n    if (d==NULL || f==NULL) return ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (d->val[i]!=NULL) {\n            fprintf(f, \"[%s]=[%s]\\n\", d->key[i], d->val[i]);\n        } else {\n            fprintf(f, \"[%s]=UNDEF\\n\", d->key[i]);\n        }\n    }\n    return ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "double iniparser_getdouble(dictionary * d, char * key, double notfound)", "code": "{\n    char    *   str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return atof(str);\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tDump a dictionary to an opened file pointer.\n  @param\td\tDictionary to dump\n  @param\tf\tOpened file pointer.\n  @return\tvoid\n\n  Dumps a dictionary onto an opened file pointer. Key pairs are printed out\n  as @c [Key]=[Value], one per line. It is Ok to provide stdout or stderr as\n  output file pointers.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void dictionary_dump(dictionary * d, FILE * out)", "code": "{\n\tint\t\ti ;\n\n\tif (d==NULL || out==NULL) return ;\n\tif (d->n<1) {\n\t\tfprintf(out, \"empty dictionary\\n\");\n\t\treturn ;\n\t}\n\tfor (i=0 ; i<d->size ; i++) {\n        if (d->key[i]) {\n            fprintf(out, \"%20s\\t[%s]\\n\",\n                    d->key[i],\n                    d->val[i] ? d->val[i] : \"UNDEF\");\n        }\n\t}\n\treturn ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "char * iniparser_getstring(dictionary * d, const char * key, char * def)", "code": "{\n    char * lc_key ;\n    char * sval ;\n\n    if (d==NULL || key==NULL)\n        return def ;\n\n    lc_key = strlwc(key);\n    sval = dictionary_get(d, lc_key, def);\n    return sval ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tConvert a string to lowercase.\n  @param\ts\tString to convert.\n  @return\tptr to statically allocated string.\n\n  This function returns a pointer to a statically allocated string\n  containing a lowercased version of the input string. Do not free\n  or modify the returned string! Since the returned string is statically\n  allocated, it will be modified at each function call (not re-entrant).\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static char * strlwc(const char * s)", "code": "{\n    static char l[ASCIILINESZ+1];\n    int i ;\n\n    if (s==NULL) return NULL ;\n    memset(l, 0, ASCIILINESZ+1);\n    i=0 ;\n    while (s[i] && i<ASCIILINESZ) {\n        l[i] = (char)tolower((int)s[i]);\n        i++ ;\n    }\n    l[ASCIILINESZ]=(char)0;\n    return l ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tLoad a single line from an INI file\n  @param    input_line  Input line, may be concatenated multi-line input\n  @param    section     Output space to store section\n  @param    key         Output space to store key\n  @param    value       Output space to store value\n  @return   line_status value\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "static line_status iniparser_line(\n    char * input_line,\n    char * section,\n    char * key,\n    char * value)", "code": "{   \n    line_status sta ;\n    char        line[ASCIILINESZ+1];\n    int         len ;\n\n    strcpy(line, strstrip(input_line));\n    len = (int)strlen(line);\n\n    sta = LINE_UNPROCESSED ;\n    if (len<1) {\n        /* Empty line */\n        sta = LINE_EMPTY ;\n    } else if (line[0]=='#') {\n        /* Comment line */\n        sta = LINE_COMMENT ; \n    } else if (line[0]=='[' && line[len-1]==']') {\n        /* Section name */\n        sscanf(line, \"[%[^]]\", section);\n        strcpy(section, strstrip(section));\n        strcpy(section, strlwc(section));\n        sta = LINE_SECTION ;\n    } else if (sscanf (line, \"%[^=] = \\\"%[^\\\"]\\\"\", key, value) == 2\n           ||  sscanf (line, \"%[^=] = '%[^\\']'\",   key, value) == 2\n           ||  sscanf (line, \"%[^=] = %[^;#]\",     key, value) == 2) {\n        /* Usual key=value, with or without comments */\n        strcpy(key, strstrip(key));\n        strcpy(key, strlwc(key));\n        strcpy(value, strstrip(value));\n        /*\n         * sscanf cannot handle '' or \"\" as empty values\n         * this is done here\n         */\n        if (!strcmp(value, \"\\\"\\\"\") || (!strcmp(value, \"''\"))) {\n            value[0]=0 ;\n        }\n        sta = LINE_VALUE ;\n    } else if (sscanf(line, \"%[^=] = %[;#]\", key, value)==2\n           ||  sscanf(line, \"%[^=] %[=]\", key, value) == 2) {\n        /*\n         * Special cases:\n         * key=\n         * key=;\n         * key=#\n         */\n        strcpy(key, strstrip(key));\n        strcpy(key, strlwc(key));\n        value[0]=0 ;\n        sta = LINE_VALUE ;\n    } else {\n        /* Generate syntax error */\n        sta = LINE_ERROR ;\n    }\n    return sta ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dump_ini(dictionary * d, FILE * f)", "code": "{\n    int     i, j ;\n    char    keym[ASCIILINESZ+1];\n    int     nsec ;\n    char *  secname ;\n    int     seclen ;\n\n    if (d==NULL || f==NULL) return ;\n\n    nsec = iniparser_getnsec(d);\n    if (nsec<1) {\n        /* No section in file: dump all keys as they are */\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            fprintf(f, \"%s = %s\\n\", d->key[i], d->val[i]);\n        }\n        return ;\n    }\n    for (i=0 ; i<nsec ; i++) {\n        secname = iniparser_getsecname(d, i) ;\n        seclen  = (int)strlen(secname);\n        fprintf(f, \"\\n[%s]\\n\", secname);\n        sprintf(keym, \"%s:\", secname);\n        for (j=0 ; j<d->size ; j++) {\n            if (d->key[j]==NULL)\n                continue ;\n            if (!strncmp(d->key[j], keym, seclen+1)) {\n                fprintf(f,\n                        \"%-30s = %s\\n\",\n                        d->key[j]+seclen+1,\n                        d->val[j] ? d->val[j] : \"\");\n            }\n        }\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tGet a value from a dictionary.\n  @param\td\t\tdictionary object to search.\n  @param\tkey\t\tKey to look for in the dictionary.\n  @param    def     Default value to return if key not found.\n  @return\t1 pointer to internally allocated character string.\n\n  This function locates a key in a dictionary and returns a pointer to its\n  value, or the passed 'def' pointer if no such key can be found in\n  dictionary. The returned character pointer points to data internal to the\n  dictionary object, you should not try to free it or modify it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "char * dictionary_get(dictionary * d, char * key, char * def)", "code": "{\n\tunsigned\thash ;\n\tint\t\t\ti ;\n\n\thash = dictionary_hash(key);\n\tfor (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        /* Compare hash */\n\t\tif (hash==d->hash[i]) {\n            /* Compare string, to avoid hash collisions */\n            if (!strcmp(key, d->key[i])) {\n\t\t\t\treturn d->val[i] ;\n\t\t\t}\n\t\t}\n\t}\n\treturn def ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_getnsec(dictionary * d)", "code": "{\n    int i ;\n    int nsec ;\n\n    if (d==NULL) return -1 ;\n    nsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            nsec ++ ;\n        }\n    }\n    return nsec ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "dictionary * iniparser_load(const char * ininame)", "code": "{\n    FILE * in ;\n\n    char line    [ASCIILINESZ+1] ;\n    char section [ASCIILINESZ+1] ;\n    char key     [ASCIILINESZ+1] ;\n    char tmp     [ASCIILINESZ+1] ;\n    char val     [ASCIILINESZ+1] ;\n\n    int  last=0 ;\n    int  len ;\n    int  lineno=0 ;\n    int  errs=0;\n\n    dictionary * dict ;\n\n    if ((in=fopen(ininame, \"r\"))==NULL) {\n        fprintf(stderr, \"iniparser: cannot open %s\\n\", ininame);\n        return NULL ;\n    }\n\n    dict = dictionary_new(0) ;\n    if (!dict) {\n        fclose(in);\n        return NULL ;\n    }\n\n    memset(line,    0, ASCIILINESZ);\n    memset(section, 0, ASCIILINESZ);\n    memset(key,     0, ASCIILINESZ);\n    memset(val,     0, ASCIILINESZ);\n    last=0 ;\n\n    while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) {\n        lineno++ ;\n        len = (int)strlen(line)-1;\n        /* Safety check against buffer overflows */\n        if (line[len]!='\\n') {\n            fprintf(stderr,\n                    \"iniparser: input line too long in %s (%d)\\n\",\n                    ininame,\n                    lineno);\n            dictionary_del(dict);\n            fclose(in);\n            return NULL ;\n        }\n        /* Get rid of \\n and spaces at end of line */\n        while ((len>=0) &&\n                ((line[len]=='\\n') || (isspace(line[len])))) {\n            line[len]=0 ;\n            len-- ;\n        }\n        /* Detect multi-line */\n        if (line[len]=='\\\\') {\n            /* Multi-line value */\n            last=len ;\n            continue ;\n        } else {\n            last=0 ;\n        }\n        switch (iniparser_line(line, section, key, val)) {\n            case LINE_EMPTY:\n            case LINE_COMMENT:\n            break ;\n\n            case LINE_SECTION:\n            errs = dictionary_set(dict, section, NULL);\n            break ;\n\n            case LINE_VALUE:\n            sprintf(tmp, \"%s:%s\", section, key);\n            errs = dictionary_set(dict, tmp, val) ;\n            break ;\n\n            case LINE_ERROR:\n            fprintf(stderr, \"iniparser: syntax error in %s (%d):\\n\",\n                    ininame,\n                    lineno);\n            fprintf(stderr, \"-> %s\\n\", line);\n            errs++ ;\n            break;\n\n            default:\n            break ;\n        }\n        memset(line, 0, ASCIILINESZ);\n        last=0;\n        if (errs<0) {\n            fprintf(stderr, \"iniparser: memory allocation failure\\n\");\n            break ;\n        }\n    }\n    if (errs) {\n        dictionary_del(dict);\n        dict = NULL ;\n    }\n    fclose(in);\n    return dict ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*---------------------------------------------------------------------------\n  \t\t\t\t\t\t\tFunction codes\n ---------------------------------------------------------------------------*/\n/*-------------------------------------------------------------------------*/\n/**\n  @brief\tCompute the hash key for a string.\n  @param\tkey\t\tCharacter string to use for key.\n  @return\t1 unsigned int on at least 32 bits.\n\n  This hash function has been taken from an Article in Dr Dobbs Journal.\n  This is normally a collision-free function, distributing keys evenly.\n  The key is stored anyway in the struct so that collision can be avoided\n  by comparing the key itself in last resort.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "unsigned dictionary_hash(char * key)", "code": "{\n\tint\t\t\tlen ;\n\tunsigned\thash ;\n\tint\t\t\ti ;\n\n\tlen = strlen(key);\n\tfor (hash=0, i=0 ; i<len ; i++) {\n\t\thash += (unsigned)key[i] ;\n\t\thash += (hash<<10);\n\t\thash ^= (hash>>6) ;\n\t}\n\thash += (hash <<3);\n\thash ^= (hash >>11);\n\thash += (hash <<15);\n\treturn hash ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tDelete a dictionary object\n  @param\td\tdictionary object to deallocate.\n  @return\tvoid\n\n  Deallocate a dictionary object and all memory associated to it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void dictionary_del(dictionary * d)", "code": "{\n\tint\t\ti ;\n\n\tif (d==NULL) return ;\n\tfor (i=0 ; i<d->size ; i++) {\n\t\tif (d->key[i]!=NULL)\n\t\t\tfree(d->key[i]);\n\t\tif (d->val[i]!=NULL)\n\t\t\tfree(d->val[i]);\n\t}\n\tfree(d->val);\n\tfree(d->key);\n\tfree(d->hash);\n\tfree(d);\n\treturn ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/* Doubles the allocated size associated to a pointer */\n/* 'size' is the current allocated size. */\n", "func_signal": "static void * mem_double(void * ptr, int size)", "code": "{\n    void * newptr ;\n \n    newptr = calloc(2*size, 1);\n    if (newptr==NULL) {\n        return NULL ;\n    }\n    memcpy(newptr, ptr, size);\n    free(ptr);\n    return newptr ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*--------------------------------------------------------------------------*/\n", "func_signal": "int dictionary_set(dictionary * d, char * key, char * val)", "code": "{\n\tint\t\t\ti ;\n\tunsigned\thash ;\n\n\tif (d==NULL || key==NULL) return -1 ;\n\t\n\t/* Compute hash for this key */\n\thash = dictionary_hash(key) ;\n\t/* Find if value is already in dictionary */\n\tif (d->n>0) {\n\t\tfor (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n\t\t\tif (hash==d->hash[i]) { /* Same hash value */\n\t\t\t\tif (!strcmp(key, d->key[i])) {\t /* Same key */\n\t\t\t\t\t/* Found a value: modify and return */\n\t\t\t\t\tif (d->val[i]!=NULL)\n\t\t\t\t\t\tfree(d->val[i]);\n                    d->val[i] = val ? xstrdup(val) : NULL ;\n                    /* Value has been modified: return */\n\t\t\t\t\treturn 0 ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* Add a new value */\n\t/* See if dictionary needs to grow */\n\tif (d->n==d->size) {\n\n\t\t/* Reached maximum size: reallocate dictionary */\n\t\td->val  = (char **)mem_double(d->val,  d->size * sizeof(char*)) ;\n\t\td->key  = (char **)mem_double(d->key,  d->size * sizeof(char*)) ;\n\t\td->hash = (unsigned int *)mem_double(d->hash, d->size * sizeof(unsigned)) ;\n        if ((d->val==NULL) || (d->key==NULL) || (d->hash==NULL)) {\n            /* Cannot grow dictionary */\n            return -1 ;\n        }\n\t\t/* Double size */\n\t\td->size *= 2 ;\n\t}\n\n    /* Insert key in the first empty slot */\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL) {\n            /* Add key here */\n            break ;\n        }\n    }\n\t/* Copy key */\n\td->key[i]  = xstrdup(key);\n    d->val[i]  = val ? xstrdup(val) : NULL ;\n\td->hash[i] = hash;\n\td->n ++ ;\n\treturn 0 ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief\tDelete a key in a dictionary\n  @param\td\t\tdictionary object to modify.\n  @param\tkey\t\tKey to remove.\n  @return   void\n\n  This function deletes a key in a dictionary. Nothing is done if the\n  key cannot be found.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void dictionary_unset(dictionary * d, char * key)", "code": "{\n\tunsigned\thash ;\n\tint\t\t\ti ;\n\n\tif (key == NULL) {\n\t\treturn;\n\t}\n\n\thash = dictionary_hash(key);\n\tfor (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        /* Compare hash */\n\t\tif (hash==d->hash[i]) {\n            /* Compare string, to avoid hash collisions */\n            if (!strcmp(key, d->key[i])) {\n                /* Found key */\n                break ;\n\t\t\t}\n\t\t}\n\t}\n    if (i>=d->size)\n        /* Key not found */\n        return ;\n\n    free(d->key[i]);\n    d->key[i] = NULL ;\n    if (d->val[i]!=NULL) {\n        free(d->val[i]);\n        d->val[i] = NULL ;\n    }\n    d->hash[i] = 0 ;\n    d->n -- ;\n    return ;\n}", "path": "src\\ini_parser\\dictionary.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Finds out if a given entry exists in a dictionary\n  @param    ini     Dictionary to search\n  @param    entry   Name of the entry to look for\n  @return   integer 1 if entry exists, 0 otherwise\n\n  Finds out if a given entry exists in the dictionary. Since sections\n  are stored as keys with NULL associated values, this is the only way\n  of querying for the presence of sections in a dictionary.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_find_entry(\n    dictionary  *   ini,\n    char        *   entry\n)", "code": "{\n    int found=0 ;\n    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {\n        found = 1 ;\n    }\n    return found ;\n}", "path": "src\\ini_parser\\iniparser.c", "repo_name": "tmahmood/game_engine", "stars": 5, "license": "None", "language": "c", "size": 1332}
{"docstring": "/*********************************************/\n/* UNESCAPE - convert escape seqs to chars   */\n/*********************************************/\n", "func_signal": "char *unescape(char *str)", "code": "{\n   unsigned char *cp1=str;                      /* force unsigned so we    */\n   unsigned char *cp2=str;                      /* can do > 127            */\n\n   if (!str) return NULL;                       /* make sure strings valid */\n\n   while (*cp1)\n   {\n      if (*cp1=='%')                            /* Found an escape?        */\n      {\n         cp1++;\n         if (isxdigit(*cp1))                    /* ensure a hex digit      */\n         {\n            if (*cp1) *cp2=from_hex(*cp1++)*16; /* convert hex to an ascii */\n            if (*cp1) *cp2+=from_hex(*cp1);     /* (hopefully) character   */\n            if ((*cp2<32)||(*cp2==127)) *cp2='_'; /* make '_' if its bad   */\n            if (*cp1) cp2++; cp1++;\n         }\n         else *cp2++='%';\n      }\n      else *cp2++ = *cp1++;                     /* if not, just continue   */\n   }\n   *cp2=*cp1;                                   /* don't forget terminator */\n   return str;                                  /* return the string       */\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* GET_DOMAIN - Get domain portion of host   */\n/*********************************************/\n", "func_signal": "char *get_domain(char *str)", "code": "{\n   char *cp;\n   int  i=group_domains+1;\n\n   cp = str+strlen(str)-1;\n   if (isdigit((int)*cp)) return NULL;   /* ignore IP addresses */\n\n   while (cp!=str)\n   {\n      if (*cp=='.')\n         if (!(--i)) return ++cp;\n      cp--;\n   }\n   return cp;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* GET_CONFIG - get configuration file info  */\n/*********************************************/\n", "func_signal": "void get_config(char *fname)", "code": "{\n   char *kwords[]= { \"Undefined\",         /* 0 = undefined keyword       0  */\n                     \"OutputDir\",         /* Output directory            1  */\n                     \"LogFile\",           /* Log file to use for input   2  */\n                     \"ReportTitle\",       /* Title for reports           3  */\n                     \"HostName\",          /* Hostname to use             4  */\n                     \"IgnoreHist\",        /* Ignore history file         5  */\n                     \"Quiet\",             /* Run in quiet mode           6  */\n                     \"TimeMe\",            /* Produce timing results      7  */\n                     \"Debug\",             /* Produce debug information   8  */\n                     \"HourlyGraph\",       /* Hourly stats graph          9  */\n                     \"HourlyStats\",       /* Hourly stats table         10  */\n                     \"TopSites\",          /* Top sites                  11  */\n                     \"TopURLs\",           /* Top URL's                  12  */\n                     \"TopReferrers\",      /* Top Referrers              13  */\n                     \"TopAgents\",         /* Top User Agents            14  */\n                     \"TopCountries\",      /* Top Countries              15  */\n                     \"HideSite\",          /* Sites to hide              16  */\n                     \"HideURL\",           /* URL's to hide              17  */\n                     \"HideReferrer\",      /* Referrers to hide          18  */\n                     \"HideAgent\",         /* User Agents to hide        19  */\n                     \"IndexAlias\",        /* Aliases for index.html     20  */\n                     \"HTMLHead\",          /* HTML Top1 code             21  */\n                     \"HTMLPost\",          /* HTML Top2 code             22  */\n                     \"HTMLTail\",          /* HTML Tail code             23  */\n                     \"MangleAgents\",      /* Mangle User Agents         24  */\n                     \"IgnoreSite\",        /* Sites to ignore            25  */\n                     \"IgnoreURL\",         /* Url's to ignore            26  */\n                     \"IgnoreReferrer\",    /* Referrers to ignore        27  */\n                     \"IgnoreAgent\",       /* User Agents to ignore      28  */\n                     \"ReallyQuiet\",       /* Dont display ANY messages  29  */\n                     \"GMTTime\",           /* Local or UTC time?         30  */\n                     \"GroupURL\",          /* Group URL's                31  */\n                     \"GroupSite\",         /* Group Sites                32  */\n                     \"GroupReferrer\",     /* Group Referrers            33  */\n                     \"GroupAgent\",        /* Group Agents               34  */\n                     \"GroupShading\",      /* Shade Grouped entries      35  */\n                     \"GroupHighlight\",    /* BOLD Grouped entries       36  */\n                     \"Incremental\",       /* Incremental runs           37  */\n                     \"IncrementalName\",   /* Filename for state data    38  */\n                     \"HistoryName\",       /* Filename for history data  39  */\n                     \"HTMLExtension\",     /* HTML filename extension    40  */\n                     \"HTMLPre\",           /* HTML code at beginning     41  */\n                     \"HTMLBody\",          /* HTML body code             42  */\n                     \"HTMLEnd\",           /* HTML code at end           43  */\n                     \"UseHTTPS\",          /* Use https:// on URL's      44  */\n                     \"IncludeSite\",       /* Sites to always include    45  */\n                     \"IncludeURL\",        /* URL's to always include    46  */\n                     \"IncludeReferrer\",   /* Referrers to include       47  */\n                     \"IncludeAgent\",      /* User Agents to include     48  */\n                     \"PageType\",          /* Page Type (pageview)       49  */\n                     \"VisitTimeout\",      /* Visit timeout (seconds)    50  */\n                     \"GraphLegend\",       /* Graph Legends (yes/no)     51  */\n                     \"GraphLines\",        /* Graph Lines (0=none)       52  */\n                     \"FoldSeqErr\",        /* Fold sequence errors       53  */\n                     \"CountryGraph\",      /* Display ctry graph (0=no)  54  */\n                     \"TopKSites\",         /* Top sites (by KBytes)      55  */\n                     \"TopKURLs\",          /* Top URL's (by KBytes)      56  */\n                     \"TopEntry\",          /* Top Entry Pages            57  */\n                     \"TopExit\",           /* Top Exit Pages             58  */\n                     \"TopSearch\",         /* Top Search Strings         59  */\n                     \"LogType\",           /* Log Type (clf/ftp/squid)   60  */\n                     \"SearchEngine\",      /* SearchEngine strings       61  */\n                     \"GroupDomains\",      /* Group domains (n=level)    62  */\n                     \"HideAllSites\",      /* Hide ind. sites (0=no)     63  */\n                     \"AllSites\",          /* List all sites?            64  */\n                     \"AllURLs\",           /* List all URLs?             65  */\n                     \"AllReferrers\",      /* List all Referrers?        66  */\n                     \"AllAgents\",         /* List all User Agents?      67  */\n                     \"AllSearchStr\",      /* List all Search Strings?   68  */\n                     \"AllUsers\",          /* List all Users?            69  */\n                     \"TopUsers\",          /* Top Usernames to show      70  */\n                     \"HideUser\",          /* Usernames to hide          71  */\n                     \"IgnoreUser\",        /* Usernames to ignore        72  */\n                     \"IncludeUser\",       /* Usernames to include       73  */\n                     \"GroupUser\",         /* Usernames to group         74  */\n                     \"DumpPath\",          /* Path for dump files        75  */\n                     \"DumpExtension\",     /* Dump filename extension    76  */\n                     \"DumpHeader\",        /* Dump header as first rec?  77  */\n                     \"DumpSites\",         /* Dump sites tab file        78  */\n                     \"DumpURLs\",          /* Dump urls tab file         79  */\n                     \"DumpReferrers\",     /* Dump referrers tab file    80  */\n                     \"DumpAgents\",        /* Dump user agents tab file  81  */\n                     \"DumpUsers\",         /* Dump usernames tab file    82  */\n                     \"DumpSearchStr\",     /* Dump search str tab file   83  */\n                     \"DNSCache\",          /* DNS Cache file name        84  */\n                     \"DNSChildren\",       /* DNS Children (0=no DNS)    85  */\n                     \"DailyGraph\",        /* Daily Graph (0=no)         86  */\n                     \"DailyStats\"         /* Daily Stats (0=no)         87  */\n                   };\n\n   FILE *fp;\n\n   char buffer[BUFSIZE];\n   char keyword[32];\n   char value[132];\n   char *cp1, *cp2;\n   int  i,key;\n   int\tnum_kwords=sizeof(kwords)/sizeof(char *);\n\n   if ( (fp=fopen(fname,\"r\")) == NULL)\n   {\n      if (verbose)\n      fprintf(stderr,\"%s %s\\n\",msg_bad_conf,fname);\n      return;\n   }\n\n   while ( (fgets(buffer,BUFSIZE,fp)) != NULL)\n   {\n      /* skip comments and blank lines */\n      if ( (buffer[0]=='#') || isspace((int)buffer[0]) ) continue;\n\n      /* Get keyword */\n      cp1=buffer;cp2=keyword;\n      while ( isalnum((int)*cp1) ) *cp2++ = *cp1++;\n      *cp2='\\0';\n\n      /* Get value */\n      cp2=value;\n      while ( (*cp1!='\\n')&&(*cp1!='\\0')&&(isspace((int)*cp1)) ) cp1++;\n      while ( (*cp1!='\\n')&&(*cp1!='\\0') ) *cp2++ = *cp1++;\n      *cp2--='\\0';\n      while ( (isspace((int)*cp2)) && (cp2 != value) ) *cp2--='\\0';\n\n      /* check if blank keyword/value */\n      if ( (keyword[0]=='\\0') || (value[0]=='\\0') ) continue;\n\n      key=0;\n      for (i=0;i<num_kwords;i++)\n         if (!strcmp(keyword,kwords[i])) { key=i; break; }\n\n      if (key==0) { printf(\"%s '%s' (%s)\\n\",       /* Invalid keyword       */\n                    msg_bad_key,keyword,fname);\n                    continue;\n                  }\n\n      switch (key)\n      {\n        case 1:  out_dir=save_opt(value);          break; /* OutputDir      */\n        case 2:  log_fname=save_opt(value);        break; /* LogFile        */\n        case 3:  msg_title=save_opt(value);        break; /* ReportTitle    */\n        case 4:  hname=save_opt(value);            break; /* HostName       */\n        case 5:  ignore_hist=(value[0]=='n')?0:1;  break; /* IgnoreHist     */\n        case 6:  verbose=(value[0]=='n')?2:1;      break; /* Quiet          */\n        case 7:  time_me=(value[0]=='n')?0:1;      break; /* TimeMe         */\n        case 8:  debug_mode=(value[0]=='n')?0:1;   break; /* Debug          */\n        case 9:  hourly_graph=(value[0]=='n')?0:1; break; /* HourlyGraph    */\n        case 10: hourly_stats=(value[0]=='n')?0:1; break; /* HourlyStats    */\n        case 11: ntop_sites = atoi(value);         break; /* TopSites       */\n        case 12: ntop_urls = atoi(value);          break; /* TopURLs        */\n        case 13: ntop_refs = atoi(value);          break; /* TopRefs        */\n        case 14: ntop_agents = atoi(value);        break; /* TopAgents      */\n        case 15: ntop_ctrys = atoi(value);         break; /* TopCountries   */\n        case 16: add_nlist(value,&hidden_sites);   break; /* HideSite       */\n        case 17: add_nlist(value,&hidden_urls);    break; /* HideURL        */\n        case 18: add_nlist(value,&hidden_refs);    break; /* HideReferrer   */\n        case 19: add_nlist(value,&hidden_agents);  break; /* HideAgent      */\n        case 20: add_nlist(value,&index_alias);    break; /* IndexAlias     */\n        case 21: add_nlist(value,&html_head);      break; /* HTMLHead       */\n        case 22: add_nlist(value,&html_post);      break; /* HTMLPost       */\n        case 23: add_nlist(value,&html_tail);      break; /* HTMLTail       */\n        case 24: mangle_agent=atoi(value);         break; /* MangleAgents   */\n        case 25: add_nlist(value,&ignored_sites);  break; /* IgnoreSite     */\n        case 26: add_nlist(value,&ignored_urls);   break; /* IgnoreURL      */\n        case 27: add_nlist(value,&ignored_refs);   break; /* IgnoreReferrer */\n        case 28: add_nlist(value,&ignored_agents); break; /* IgnoreAgent    */\n        case 29: if (value[0]=='y') verbose=0;     break; /* ReallyQuiet    */\n        case 30: local_time=(value[0]=='y')?0:1;   break; /* GMTTime        */\n        case 31: add_glist(value,&group_urls);     break; /* GroupURL       */\n        case 32: add_glist(value,&group_sites);    break; /* GroupSite      */\n        case 33: add_glist(value,&group_refs);     break; /* GroupReferrer  */\n        case 34: add_glist(value,&group_agents);   break; /* GroupAgent     */\n        case 35: shade_groups=(value[0]=='y')?1:0; break; /* GroupShading   */\n        case 36: hlite_groups=(value[0]=='y')?1:0; break; /* GroupHighlight */\n        case 37: incremental=(value[0]=='y')?1:0;  break; /* Incremental    */\n        case 38: state_fname=save_opt(value);      break; /* State FName    */\n        case 39: hist_fname=save_opt(value);       break; /* History FName  */\n        case 40: html_ext=save_opt(value);         break; /* HTML extension */\n        case 41: add_nlist(value,&html_pre);       break; /* HTML Pre code  */\n        case 42: add_nlist(value,&html_body);      break; /* HTML Body code */\n        case 43: add_nlist(value,&html_end);       break; /* HTML End code  */\n        case 44: use_https=(value[0]=='y')?1:0;    break; /* Use https://   */\n        case 45: add_nlist(value,&include_sites);  break; /* IncludeSite    */\n        case 46: add_nlist(value,&include_urls);   break; /* IncludeURL     */\n        case 47: add_nlist(value,&include_refs);   break; /* IncludeReferrer*/\n        case 48: add_nlist(value,&include_agents); break; /* IncludeAgent   */\n        case 49: add_nlist(value,&page_type);      break; /* PageType       */\n        case 50: visit_timeout=atoi(value);        break; /* VisitTimeout   */\n        case 51: graph_legend=(value[0]=='y')?1:0; break; /* GraphLegend    */\n        case 52: graph_lines = atoi(value);        break; /* GraphLines     */\n        case 53: fold_seq_err=(value[0]=='y')?1:0; break; /* FoldSeqErr     */\n        case 54: ctry_graph=(value[0]=='y')?1:0;   break; /* CountryGraph   */\n        case 55: ntop_sitesK = atoi(value);        break; /* TopKSites (KB) */\n        case 56: ntop_urlsK  = atoi(value);        break; /* TopKUrls (KB)  */\n        case 57: ntop_entry  = atoi(value);        break; /* Top Entry pgs  */\n        case 58: ntop_exit   = atoi(value);        break; /* Top Exit pages */\n        case 59: ntop_search = atoi(value);        break; /* Top Search pgs */\n        case 60: log_type=(value[0]=='f')?\n                 LOG_FTP:((value[0]=='s')?\n                 LOG_SQUID:LOG_CLF);               break; /* LogType        */\n        case 61: add_glist(value,&search_list);    break; /* SearchEngine   */\n        case 62: group_domains=atoi(value);        break; /* GroupDomains   */\n        case 63: hide_sites=(value[0]=='y')?1:0;   break; /* HideAllSites   */\n        case 64: all_sites=(value[0]=='y')?1:0;    break; /* All Sites?     */\n        case 65: all_urls=(value[0]=='y')?1:0;     break; /* All URL's?     */\n        case 66: all_refs=(value[0]=='y')?1:0;     break; /* All Refs       */\n        case 67: all_agents=(value[0]=='y')?1:0;   break; /* All Agents?    */\n        case 68: all_search=(value[0]=='y')?1:0;   break; /* All Srch str   */\n        case 69: all_users=(value[0]=='y')?1:0;    break; /* All Users?     */\n        case 70: ntop_users=atoi(value);           break; /* TopUsers       */\n        case 71: add_nlist(value,&hidden_users);   break; /* HideUser       */\n        case 72: add_nlist(value,&ignored_users);  break; /* IgnoreUser     */\n        case 73: add_nlist(value,&include_users);  break; /* IncludeUser    */\n        case 74: add_glist(value,&group_users);    break; /* GroupUser      */\n        case 75: dump_path=save_opt(value);        break; /* DumpPath       */\n        case 76: dump_ext=save_opt(value);         break; /* Dumpfile ext   */\n        case 77: dump_header=(value[0]=='y')?1:0;  break; /* DumpHeader?    */\n        case 78: dump_sites=(value[0]=='y')?1:0;   break; /* DumpSites?     */\n        case 79: dump_urls=(value[0]=='y')?1:0;    break; /* DumpURLs?      */\n        case 80: dump_refs=(value[0]=='y')?1:0;    break; /* DumpReferrers? */\n        case 81: dump_agents=(value[0]=='y')?1:0;  break; /* DumpAgents?    */\n        case 82: dump_users=(value[0]=='y')?1:0;   break; /* DumpUsers?     */\n        case 83: dump_search=(value[0]=='y')?1:0;  break; /* DumpSrchStrs?  */\n#ifdef USE_DNS\n        case 84: dns_cache=save_opt(value);        break; /* DNSCache fname */\n        case 85: dns_children=atoi(value);         break; /* DNSChildren    */\n#else\n        case 84: /* Disable DNSCache and DNSChildren if DNS is not enabled  */\n        case 85: printf(\"%s '%s' (%s)\\n\",msg_bad_key,keyword,fname); break;\n#endif  /* USE_DNS */\n        case 86: daily_graph=(value[0]=='n')?0:1; break;  /* HourlyGraph    */\n        case 87: daily_stats=(value[0]=='n')?0:1; break;  /* HourlyStats    */\n      }\n   }\n   fclose(fp);\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* SAVE_OPT - save option from config file   */\n/*********************************************/\n", "func_signal": "static char *save_opt(char *str)", "code": "{\n   char *cp1;\n\n   if ( (cp1=malloc(strlen(str)+1))==NULL) return NULL;\n\n   strcpy(cp1,str);\n   return cp1;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* PRINT_VERSION                             */\n/*********************************************/\n", "func_signal": "void print_version()", "code": "{\n uname(&system_info);\n printf(\"Webalizer V%s-%s (%s %s) %s\\n%s\\n\",\n    version,editlvl,\n    system_info.sysname,system_info.release,\n    language,copyright);\n if (debug_mode)\n {\n    printf(\"Mod date: %s  Options: \",moddate);\n#ifdef USE_DNS\n    printf(\"DNS \");\n#else\n    printf(\"none\");\n#endif\n    printf(\"\\nDefault config dir: %s\\n\\n\",ETCDIR);\n }\n else printf(\"\\n\");\n exit(1);\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* ISPAGE - determine if an HTML page or not */\n/*********************************************/\n", "func_signal": "int ispage(char *str)", "code": "{\n   char *cp1, *cp2;\n\n   cp1=cp2=str;\n   while (*cp1!='\\0') { if (*cp1=='.') cp2=cp1; cp1++; }\n   if ((cp2++==str)||(*(--cp1)=='/')) return 1;\n   else return (isinlist(page_type,cp2)!=NULL);\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n", "func_signal": "GLISTPTR new_glist(char *str, char *name)", "code": "{\n   GLISTPTR newptr;\n\n   if (sizeof(newptr->string) < strlen(str) ||\n       sizeof(newptr->name) < strlen(name))\n   {\n      if (verbose)\n\tfprintf(stderr,\"[new_glist] %s\\n\",msg_big_one);\n   }\n   if (( newptr = malloc(sizeof(struct glist))) != NULL)\n     {\n       strncpy(newptr->string, str, sizeof(newptr->string));\n       strncpy(newptr->name, name, sizeof(newptr->name));\n       newptr->next=NULL;\n     }\n   return newptr;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/* Note: Due to the changes made by Pope Gregory XIII in the     */\n/*       16th Centyry (Feb 24, 1582), dates before 1583 will     */\n/*       not return a truely accurate number (will be at least   */\n/*       10 days off).  Somehow, I don't think this will         */\n/*       present much of a problem for most situations :)        */\n/*                                                               */\n/* Usage: days = jdate(day, month, year)                         */\n/*                                                               */\n/* The number returned is adjusted by 5 to facilitate day of     */\n/* week calculations.  The mod of the returned value gives the   */\n/* day of the week the date is.  (ie: dow = days % 7 ) where     */\n/* dow will return 0=Sunday, 1=Monday, 2=Tuesday, etc...         */\n/*                                                               */\n/*****************************************************************/\n", "func_signal": "u_long jdate( int day, int month, int year )", "code": "{\n   u_long days;                      /* value returned */\n   int mtable[] = {0,31,59,90,120,151,181,212,243,273,304,334};\n\n   /* First, calculate base number including leap and Centenial year stuff */\n\n   days=(((u_long)year*365)+day+mtable[month-1]+\n           ((year+4)/4) - ((year/100)-(year/400)));\n\n   /* now adjust for leap year before March 1st */\n\n   if ((year % 4 == 0) && !((year % 100 == 0) &&\n       (year % 400 != 0)) && (month < 3))\n   --days;\n\n   /* done, return with calculated value */\n\n   return(days+5);\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* ADD_GLIST - add item to FIFO linked list  */\n/*********************************************/\n", "func_signal": "int add_glist(char *str, GLISTPTR *list)", "code": "{\n   GLISTPTR newptr,cptr,pptr;\n   char temp_buf[80];\n   char *name=temp_buf;\n\n   /* make local copy of string */\n   strncpy(temp_buf,str,79);\n   temp_buf[79]=0;\n\n   while (!isspace((int)*name)&&*name!=0) name++;\n   if (*name==0) name=temp_buf;\n   else\n   {\n      *name++=0;\n      while (isspace((int)*name)&&*name!=0) name++;\n      if (*name==0) name=temp_buf;\n   }\n\n   if ( (newptr = new_glist(temp_buf, name)) != NULL)\n   {\n      if (*list==NULL) *list=newptr;\n      else\n      {\n         cptr=pptr=*list;\n         while(cptr!=NULL) { pptr=cptr; cptr=cptr->next; };\n         pptr->next = newptr;\n      }\n   } \n   return newptr==NULL;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* ISINGLIST - Test if string is in list     */\n/*********************************************/\n", "func_signal": "char *isinglist(GLISTPTR list, char *str)", "code": "{\n   GLISTPTR lptr;\n\n   lptr=list;\n   while (lptr!=NULL)\n   {\n      if (isinstr(str,lptr->string)) return lptr->name;\n      lptr=lptr->next;\n   }\n   return NULL;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* INIT_COUNTERS - prep counters for use     */\n/*********************************************/\n", "func_signal": "void init_counters()", "code": "{\n   int i;\n   for (i=0;i<TOTAL_RC;i++) response[i].count = 0;\n   for (i=0;i<31;i++)  /* monthly totals      */\n   {\n    tm_xfer[i]=0.0;\n    tm_hit[i]=tm_file[i]=tm_site[i]=tm_page[i]=tm_visit[i]=0;\n   }\n   for (i=0;i<24;i++)  /* hourly totals       */\n   {\n      th_hit[i]=th_file[i]=th_page[i]=0;\n      th_xfer[i]=0.0;\n   }\n   for (i=0;ctry[i].desc;i++) /* country totals */\n   {\n      ctry[i].count=0;\n      ctry[i].files=0;\n      ctry[i].xfer=0;\n   }\n   t_hit=t_file=t_site=t_url=t_ref=t_agent=t_page=t_visit=t_user=0;\n   t_xfer=0.0;\n   mh_hit = dt_site = 0;\n   f_day=l_day=1;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* CTRY_IDX - create unique # from domain    */\n/*********************************************/\n", "func_signal": "u_long ctry_idx(char *str)", "code": "{\n   int i=strlen(str),j=0;\n   u_long idx=0;\n   char *cp1=str+i;\n   for (;i>0;i--) { idx+=((*--cp1-'a'+1)<<j); j+=5; }\n   return idx;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* CUR_TIME - return date/time as a string   */\n/*********************************************/\n", "func_signal": "char *cur_time()", "code": "{\n   /* get system time */\n   now = time(NULL);\n   /* convert to timestamp string */\n   if (local_time)\n      strftime(timestamp,sizeof(timestamp),\"%d-%b-%Y %H:%M %Z\",\n            localtime(&now));\n   else\n      strftime(timestamp,sizeof(timestamp),\"%d-%b-%Y %H:%M GMT\",\n            gmtime(&now));\n\n   return timestamp;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n", "func_signal": "NLISTPTR new_nlist(char *str)", "code": "{\n   NLISTPTR newptr;\n\n   if (sizeof(newptr->string) < strlen(str))\n   {\n      if (verbose)\n    fprintf(stderr,\"[new_nlist] %s\\n\",msg_big_one);\n   }\n   if (( newptr = malloc(sizeof(struct nlist))) != NULL)\n    {strncpy(newptr->string, str, sizeof(newptr->string));newptr->next=NULL;}\n   return newptr;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* MAIN - start here                         */\n/*********************************************/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n   int      i;                           /* generic counter             */\n   char     *cp1, *cp2, *cp3, *str;      /* generic char pointers       */\n   NLISTPTR lptr;                        /* generic list pointer        */\n\n   extern char *optarg;                  /* used for command line       */\n   extern int optind;                    /* parsing routine 'getopt'    */\n   extern int opterr;\n\n   time_t start_time, end_time;          /* program timers              */\n   float  temp_time;                     /* temporary time storage      */\n   struct tms     mytms;                 /* bogus tms structure         */\n\n   int    rec_year,rec_month=1,rec_day,rec_hour,rec_min,rec_sec;\n\n   int    good_rec    =0;                /* 1 if we had a good record   */\n   u_long total_rec   =0;                /* Total Records Processed     */\n   u_long total_ignore=0;                /* Total Records Ignored       */\n   u_long total_bad   =0;                /* Total Bad Records           */\n\n   int    max_ctry;                      /* max countries defined       */\n\n   /* month names used for parsing logfile (shouldn't be lang specific) */\n   char *log_month[12]={ \"jan\", \"feb\", \"mar\",\n                         \"apr\", \"may\", \"jun\",\n                         \"jul\", \"aug\", \"sep\",\n                         \"oct\", \"nov\", \"dec\"};\n\n   /* initalize epoch */\n   epoch=jdate(1,1,1970);                /* used for timestamp adj.     */\n\n   /* add default index. alias */\n   add_nlist(\"index.\",&index_alias);\n\n   snprintf(tmp_buf, sizeof(tmp_buf),\"%s/webalizer.conf\",ETCDIR);\n   /* check for default config file */\n   if (!access(\"webalizer.conf\",F_OK))\n      get_config(\"webalizer.conf\");\n   else if (!access(tmp_buf,F_OK))\n      get_config(tmp_buf);\n\n   /* get command line options */\n   opterr = 0;     /* disable parser errors */\n   while ((i=getopt(argc,argv,\"a:A:b:c:C:dD:e:E:fF:g:GhHiI:l:Lm:M:n:N:o:pP:qQr:R:s:S:t:Tu:U:vVx:XYz:Z:\"))!=EOF)\n   {\n      switch (i)\n      {\n\tcase 'b': xml_mode=1;     \t     break;  /* Danny's mod */\n        case 'a': add_nlist(optarg,&hidden_agents); break; /* Hide agents   */\n        case 'A': ntop_agents=atoi(optarg);  break;  /* Top agents          */\n        case 'c': get_config(optarg);        break;  /* Config file         */\n        case 'C': ntop_ctrys=atoi(optarg);   break;  /* Top countries       */\n        case 'd': debug_mode=1;              break;  /* Debug               */\n\tcase 'D': dns_cache=optarg;          break;  /* DNS Cache filename  */\n        case 'e': ntop_entry=atoi(optarg);   break;  /* Top entry pages     */\n        case 'E': ntop_exit=atoi(optarg);    break;  /* Top exit pages      */\n        case 'f': fold_seq_err=1;            break;  /* Fold sequence errs  */\n        case 'F': log_type=(optarg[0]=='f')?\n                   LOG_FTP:(optarg[0]=='s')?\n                   LOG_SQUID:LOG_CLF;        break;  /* define log type     */\n\tcase 'g': group_domains=atoi(optarg); break; /* GroupDomains (0=no) */\n        case 'G': hourly_graph=0;            break;  /* no hourly graph     */\n        case 'h': print_opts(argv[0]);       break;  /* help                */\n        case 'H': hourly_stats=0;            break;  /* no hourly stats     */\n        case 'i': ignore_hist=1;             break;  /* Ignore history      */\n        case 'I': add_nlist(optarg,&index_alias); break; /* Index alias     */\n        case 'l': graph_lines=atoi(optarg);  break;  /* Graph Lines         */\n        case 'L': graph_legend=0;            break;  /* Graph Legends       */\n        case 'm': visit_timeout=atoi(optarg); break; /* Visit Timeout       */\n        case 'M': mangle_agent=atoi(optarg); break;  /* mangle user agents  */\n        case 'n': hname=optarg;              break;  /* Hostname            */\n        case 'N': dns_children=atoi(optarg); break;  /* # of DNS children   */\n        case 'o': out_dir=optarg;            break;  /* Output directory    */\n        case 'p': incremental=1;             break;  /* Incremental run     */\n        case 'P': add_nlist(optarg,&page_type); break; /* page view types   */\n        case 'q': verbose=1;                 break;  /* Quiet (verbose=1)   */\n        case 'Q': verbose=0;                 break;  /* Really Quiet        */\n        case 'r': add_nlist(optarg,&hidden_refs);   break; /* Hide referrer */\n        case 'R': ntop_refs=atoi(optarg);    break;  /* Top referrers       */\n        case 's': add_nlist(optarg,&hidden_sites);  break; /* Hide site     */\n        case 'S': ntop_sites=atoi(optarg);   break;  /* Top sites           */\n        case 't': msg_title=optarg;          break;  /* Report title        */\n        case 'T': time_me=1;                 break;  /* TimeMe              */\n        case 'u': add_nlist(optarg,&hidden_urls);   break; /* hide URL      */\n        case 'U': ntop_urls=atoi(optarg);    break;  /* Top urls            */\n        case 'v':\n        case 'V': print_version();           break;  /* Version             */\n        case 'x': html_ext=optarg;           break;  /* HTML file extension */\n        case 'X': hide_sites=1;              break;  /* Hide ind. sites     */\n        case 'Y': ctry_graph=0;              break;  /* Supress ctry graph  */\n        case 'z': stylesheet=optarg;\t\t break;\t /* xsl stylesheet      */\n      }\n   }\n\n   if (argc - optind != 0) log_fname = argv[optind];\n   if ( log_fname && (log_fname[0]=='-')) log_fname=NULL; /* force STDIN?   */\n\n   /* check for gzipped file - .gz */\n   if (log_fname) if (!strcmp((log_fname+strlen(log_fname)-3),\".gz\")) gz_log=1;\n\n   /* setup our internal variables */\n   init_counters();                      /* initalize main counters         */\n\n   if (page_type==NULL)                  /* check if page types present     */\n   {\n      if ((log_type == LOG_CLF) || (log_type == LOG_SQUID))\n      {\n         add_nlist(\"htm*\"  ,&page_type); /* if no page types specified, we  */\n         add_nlist(\"cgi\"   ,&page_type); /* use the default ones here...    */\n         if (!isinlist(page_type,html_ext)) add_nlist(html_ext,&page_type);\n      }\n      else add_nlist(\"txt\" ,&page_type); /* FTP logs default to .txt        */\n   }\n\n   for (max_ctry=0;ctry[max_ctry].desc;max_ctry++);\n   if (ntop_ctrys > max_ctry) ntop_ctrys = max_ctry;   /* force upper limit */\n   if (graph_lines> 20)       graph_lines= 20;         /* keep graphs sane! */\n\n   if (log_type == LOG_FTP)\n   {\n      /* disable stuff for ftp logs */\n      ntop_entry=ntop_exit=0;\n      ntop_search=0;\n   }\n   else\n   {\n      if (search_list==NULL)\n      {\n         /* If no search engines defined, define some :) */\n         add_glist(\"yahoo.com      p=\"      ,&search_list);\n         add_glist(\"altavista.com  q=\"      ,&search_list);\n         add_glist(\"google.com     q=\"      ,&search_list);\n         add_glist(\"eureka.com     q=\"      ,&search_list);\n         add_glist(\"lycos.com      query=\"  ,&search_list);\n         add_glist(\"hotbot.com     MT=\"     ,&search_list);\n         add_glist(\"msn.com        MT=\"     ,&search_list);\n         add_glist(\"infoseek.com   qt=\"     ,&search_list);\n         add_glist(\"webcrawler searchText=\" ,&search_list);\n         add_glist(\"excite         search=\" ,&search_list);\n         add_glist(\"netscape.com   search=\" ,&search_list);\n         add_glist(\"mamma.com      query=\"  ,&search_list);\n         add_glist(\"alltheweb.com  query=\"  ,&search_list);\n         add_glist(\"northernlight.com qr=\"  ,&search_list);\n      }\n   }\n\n   /* ensure entry/exits don't exceed urls */\n   i=(ntop_urls>ntop_urlsK)?ntop_urls:ntop_urlsK;\n   if (ntop_entry>i) ntop_entry=i;\n   if (ntop_exit>i)  ntop_exit=i;\n\n   for (i=0;i<MAXHASH;i++)\n   {\n      sm_htab[i]=sd_htab[i]=NULL;        /* initalize hash tables           */\n      um_htab[i]=NULL;\n      rm_htab[i]=NULL;\n      am_htab[i]=NULL;\n      sr_htab[i]=NULL;\n   }\n\n   /* Be polite and announce yourself... */\n   if (verbose>1)\n   {\n      uname(&system_info);\n      printf(\"Webalizer V%s-%s (%s %s) %s\\n\",\n              version,editlvl,system_info.sysname,\n              system_info.release,language);\n   }\n\n#ifndef USE_DNS\n   if (strstr(argv[0],\"webazolver\")!=0)\n   {\n      printf(\"DNS support not present, aborting...\\n\");\n      exit(1);\n   }\n#endif  /* USE_DNS */\n\n   /* open log file */\n   if (gz_log)\n   {\n      gzlog_fp = gzopen(log_fname,\"rb\");\n      if (gzlog_fp==Z_NULL)\n      {\n         /* Error: Can't open log file ... */\n         fprintf(stderr, \"%s %s\\n\",msg_log_err,log_fname);\n         exit(1);\n      }\n   }\n   else\n   {\n      if (log_fname)\n      {\n         log_fp = fopen(log_fname,\"r\");\n         if (log_fp==NULL)\n         {\n            /* Error: Can't open log file ... */\n            fprintf(stderr, \"%s %s\\n\",msg_log_err,log_fname);\n            exit(1);\n         }\n      }\n   }\n\n   /* Using logfile ... */\n   if (verbose>1)\n   {\n      printf(\"%s %s (\",msg_log_use,log_fname?log_fname:\"STDIN\");\n      if (gz_log) printf(\"gzip-\");\n      switch (log_type)\n      {\n         /* display log file type hint */\n         case LOG_CLF:   printf(\"clf)\\n\");   break;\n         case LOG_FTP:   printf(\"ftp)\\n\");   break;\n         case LOG_SQUID: printf(\"squid)\\n\"); break;\n      }\n   }\n\n   /* switch directories if needed */\n   if (out_dir)\n   {\n      if (chdir(out_dir) != 0)\n      {\n         /* Error: Can't change directory to ... */\n         fprintf(stderr, \"%s %s\\n\",msg_dir_err,out_dir);\n         exit(1);\n      }\n   }\n\n#ifdef USE_DNS\n   if (strstr(argv[0],\"webazolver\")!=0)\n   {\n      if (!dns_children) dns_children=5;  /* default dns children if needed */\n      if (!dns_cache)\n      {\n         /* No cache file specified, aborting... */\n         fprintf(stderr,\"%s\\n\",msg_dns_nocf);     /* Must have a cache file */\n         exit(1);\n      }\n   }\n\n   if (dns_cache && dns_children)    /* run-time resolution */\n   {\n      if (dns_children > MAXCHILD) dns_children=MAXCHILD;\n      /* DNS Lookup (#children): */\n      if (verbose>1) printf(\"%s (%d): \",msg_dns_rslv,dns_children);\n      fflush(stdout);\n      (gz_log)?dns_resolver(gzlog_fp):dns_resolver(log_fp);\n      (gz_log)?gzrewind(gzlog_fp):(log_fname)?rewind(log_fp):exit(0);\n   }\n\n   if (strstr(argv[0],\"webazolver\")!=0) exit(0);   /* webazolver exits here */\n\n   if (dns_cache)\n   {\n      if (!open_cache()) { dns_cache=NULL; dns_db=NULL; }\n      else\n      {\n         /* Using DNS cache file <filaneme> */\n         if (verbose>1) printf(\"%s %s\\n\",msg_dns_usec,dns_cache);\n      }\n   }\n#endif  /* USE_DNS */\n\n   /* Creating output in ... */\n   if (verbose>1)\n      printf(\"%s %s\\n\",msg_dir_use,out_dir?out_dir:msg_cur_dir);\n\n   /* prep hostname */\n   if (!hname)\n   {\n      if (uname(&system_info)) hname=\"localhost\";\n      else hname=system_info.nodename;\n   }\n\n   /* Hostname for reports is ... */\n   if (verbose>1) printf(\"%s '%s'\\n\",msg_hostname,hname);\n\n   /* get past history */\n   if (ignore_hist) {if (verbose>1) printf(\"%s\\n\",msg_ign_hist); }\n   else get_history();\n\n   if (incremental)                      /* incremental processing?         */\n   {\n      if ((i=restore_state()))           /* restore internal data structs   */\n      {\n         /* Error: Unable to restore run data (error num) */\n         /* if (verbose) fprintf(stderr,\"%s (%d)\\n\",msg_bad_data,i); */\n         fprintf(stderr,\"%s (%d)\\n\",msg_bad_data,i);\n         exit(1);\n      }\n   }\n\n   /* Allocate memory for our TOP countries array */\n   if (ntop_ctrys  != 0)\n   { if ( (top_ctrys=calloc(ntop_ctrys,sizeof(CLISTPTR))) == NULL)\n    /* Can't get memory, Top Countries disabled! */\n    {if (verbose) fprintf(stderr,\"%s\\n\",msg_nomem_tc); ntop_ctrys=0;}}\n\n   start_time = times(&mytms);\n\n   /*********************************************/\n   /* MAIN PROCESS LOOP - read through log file */\n   /*********************************************/\n\n   while ( (gz_log)?(our_gzgets(gzlog_fp,buffer,BUFSIZE) != Z_NULL):\n           (fgets(buffer,BUFSIZE,log_fname?log_fp:stdin) != NULL))\n   {\n      total_rec++;\n      if (strlen(buffer) == (BUFSIZE-1))\n      {\n         if (verbose)\n         {\n            fprintf(stderr,\"%s\",msg_big_rec);\n            if (debug_mode) fprintf(stderr,\":\\n%s\",buffer);\n            else fprintf(stderr,\"\\n\");\n         }\n\n         total_bad++;                     /* bump bad record counter      */\n\n         /* get the rest of the record */\n         while ( (gz_log)?(our_gzgets(gzlog_fp,buffer,BUFSIZE)!=Z_NULL):\n                 (fgets(buffer,BUFSIZE,log_fname?log_fp:stdin)!=NULL))\n         {\n            if (strlen(buffer) < BUFSIZE-1)\n            {\n               if (debug_mode && verbose) fprintf(stderr,\"%s\\n\",buffer);\n               break;\n            }\n            if (debug_mode && verbose) fprintf(stderr,\"%s\",buffer);\n         }\n         continue;                        /* go get next record if any    */\n      }\n\n      /* got a record... */\n      strcpy(tmp_buf, buffer);            /* save buffer in case of error */\n      if (parse_record(buffer))           /* parse the record             */\n      {\n         /*********************************************/\n         /* PASSED MINIMAL CHECKS, DO A LITTLE MORE   */\n         /*********************************************/\n\n         /* convert month name to lowercase */\n         for (i=4;i<7;i++)\n            log_rec.datetime[i]=tolower(log_rec.datetime[i]);\n\n         /* get year/month/day/hour/min/sec values    */\n         for (i=0;i<12;i++)\n         {\n            if (strncmp(log_month[i],&log_rec.datetime[4],3)==0)\n               { rec_month = i+1; break; }\n         }\n\n         rec_year=atoi(&log_rec.datetime[8]);    /* get year number (int)   */\n         rec_day =atoi(&log_rec.datetime[1]);    /* get day number          */\n         rec_hour=atoi(&log_rec.datetime[13]);   /* get hour number         */\n         rec_min =atoi(&log_rec.datetime[16]);   /* get minute number       */\n         rec_sec =atoi(&log_rec.datetime[19]);   /* get second number       */\n\n         /* Kludge for Netscape server time (0-24?) error                   */\n         if (rec_hour>23) rec_hour=0;\n\n         /* minimal sanity check on date */\n         if ((i>=12)||(rec_min>59)||(rec_sec>59)||(rec_year<1990))\n         {\n            total_bad++;                /* if a bad date, bump counter      */\n            if (verbose)\n            {\n               fprintf(stderr,\"%s: %s [%lu]\",\n                 msg_bad_date,log_rec.datetime,total_rec);\n               if (debug_mode) fprintf(stderr,\":\\n%s\\n\",tmp_buf);\n               else fprintf(stderr,\"\\n\");\n            }\n            continue;                   /* and ignore this record           */\n         }\n\n         /*********************************************/\n         /* GOOD RECORD, CHECK INCREMENTAL/TIMESTAMPS */\n         /*********************************************/\n\n         /* Flag as a good one */\n         good_rec = 1;\n\n         /* get current records timestamp (seconds since epoch) */\n         req_tstamp=cur_tstamp;\n         rec_tstamp=((jdate(rec_day,rec_month,rec_year)-epoch)*86400)+\n                     (rec_hour*3600)+(rec_min*60)+rec_sec;\n\n         /* Do we need to check for duplicate records? (incremental mode)   */\n         if (check_dup)\n         {\n            /* check if less than/equal to last record processed            */\n            if ( rec_tstamp <= cur_tstamp )\n            {\n               /* if it is, assume we have already processed and ignore it  */\n               total_ignore++;\n               continue;\n            }\n            else\n            {\n               /* if it isn't.. disable any more checks this run            */\n               check_dup=0;\n               /* now check if it's a new month                             */\n               if (cur_month != rec_month)\n               {\n                  clear_month();\n                  cur_sec   = rec_sec;          /* set current counters     */\n                  cur_min   = rec_min;\n                  cur_hour  = rec_hour;\n                  cur_day   = rec_day;\n                  cur_month = rec_month;\n                  cur_year  = rec_year;\n                  cur_tstamp= rec_tstamp;\n                  f_day=l_day=rec_day;          /* reset first and last day */\n               }\n            }\n         }\n\n         /* check for out of sequence records */\n         if (rec_tstamp/3600 < cur_tstamp/3600)\n         {\n            if (!fold_seq_err && ((rec_tstamp+SLOP_VAL)/3600<cur_tstamp/3600) )\n               { total_ignore++; continue; }\n            else\n            {\n               rec_sec   = cur_sec;             /* if folding sequence      */\n               rec_min   = cur_min;             /* errors, just make it     */\n               rec_hour  = cur_hour;            /* look like the last       */\n               rec_day   = cur_day;             /* good records timestamp   */\n               rec_month = cur_month;\n               rec_year  = cur_year;\n               rec_tstamp= cur_tstamp;\n            }\n         }\n         cur_tstamp=rec_tstamp;                 /* update current timestamp */\n\n         /*********************************************/\n         /* DO SOME PRE-PROCESS FORMATTING            */\n         /*********************************************/\n\n         /* fix URL field */\n         cp1 = cp2 = log_rec.url;\n         /* handle null '-' case here... */\n         if (*++cp1 == '-') { *cp2++ = '-'; *cp2 = '\\0'; }\n         else\n         {\n            /* strip actual URL out of request */\n            while  ( (*cp1 != ' ') && (*cp1 != '\\0') ) cp1++;\n            if (*cp1 != '\\0')\n            {\n               /* scan to begin of actual URL field */\n               while ((*cp1 == ' ') && (*cp1 != '\\0')) cp1++;\n               /* remove duplicate / if needed */\n               if (( *cp1=='/') && (*(cp1+1)=='/')) cp1++;\n               while ((*cp1 != ' ')&&(*cp1 != '\"')&&(*cp1 != '\\0'))\n                  *cp2++ = *cp1++;\n               *cp2 = '\\0';\n            }\n         }\n\n         /* un-escape URL */\n         unescape(log_rec.url);\n\n         /* check for service (ie: http://) and lowercase if found */\n         if ( (cp2=strstr(log_rec.url,\"://\")) != NULL)\n         {\n            cp1=log_rec.url;\n            while (cp1!=cp2)\n            {\n               if ( (*cp1>='A') && (*cp1<='Z')) *cp1 += 'a'-'A';\n               cp1++;\n            }\n         }\n\n         /* strip query portion of cgi scripts */\n         cp1 = log_rec.url;\n         while (*cp1 != '\\0')\n           if (!isurlchar(*cp1)) { *cp1 = '\\0'; break; }\n           else cp1++;\n         if (log_rec.url[0]=='\\0')\n           { log_rec.url[0]='/'; log_rec.url[1]='\\0'; }\n\n         /* strip off index.html (or any aliases) */\n         lptr=index_alias;\n         while (lptr!=NULL)\n         {\n            if ((cp1=strstr(log_rec.url,lptr->string))!=NULL)\n            {\n               if ((cp1==log_rec.url)||(*(cp1-1)=='/'))\n               {\n                  *cp1='\\0';\n                  if (log_rec.url[0]=='\\0')\n                   { log_rec.url[0]='/'; log_rec.url[1]='\\0'; }\n                  break;\n               }\n            }\n            lptr=lptr->next;\n         }\n\n         /* unescape referrer */\n         unescape(log_rec.refer);\n\n         /* fix referrer field */\n         cp1 = log_rec.refer;\n         cp3 = cp2 = cp1++;\n         if ( (*cp2 != '\\0') && (*cp2 == '\"') )\n         {\n            while ( *cp1 != '\\0' )\n            {\n               cp3=cp2;\n               if ((*cp1<32&&*cp1>0) || *cp1==127 || *cp1=='<') *cp1=0;\n               else *cp2++=*cp1++;\n            }\n            *cp3 = '\\0';\n         }\n\n         /* strip query portion of cgi referrals */\n         cp1 = log_rec.refer;\n         if (*cp1 != '\\0')\n         {\n            while (*cp1 != '\\0')\n            {\n               if (!isurlchar(*cp1))\n               {\n                  /* Save query portion in log.rec.srchstr */\n                  strncpy(log_rec.srchstr,cp1,MAXSRCH);\n                  *cp1++='\\0';\n                  break;\n               }\n               else cp1++;\n            }\n            /* handle null referrer */\n            if (log_rec.refer[0]=='\\0')\n              { log_rec.refer[0]='-'; log_rec.refer[1]='\\0'; }\n         }\n\n         /* if HTTP request, lowercase http://sitename/ portion */\n         cp1 = log_rec.refer;\n         if ( (*cp1=='h') || (*cp1=='H'))\n         {\n            while ( (*cp1!='/') && (*cp1!='\\0'))\n            {\n               if ( (*cp1>='A') && (*cp1<='Z')) *cp1 += 'a'-'A';\n               cp1++;\n            }\n            /* now do hostname */\n            if ( (*cp1=='/') && ( *(cp1+1)=='/')) {cp1++; cp1++;}\n            while ( (*cp1!='/') && (*cp1!='\\0'))\n            {\n               if ( (*cp1>='A') && (*cp1<='Z')) *cp1 += 'a'-'A';\n               cp1++;\n            }\n         }\n\n         /* Do we need to mangle? */\n         if (mangle_agent)\n         {\n            str=cp2=log_rec.agent;\n\t    cp1=strstr(str,\"ompatible\"); /* check known fakers */\n\t    if (cp1!=NULL) {\n\t\twhile (*cp1!=';'&&*cp1!='\\0') cp1++;\n\t\t/* kludge for Mozilla/3.01 (compatible;) */\n\t\tif (*cp1++==';' && strcmp(cp1,\")\\\"\")) { /* success! */\n\t\t    while (*cp1 == ' ') cp1++; /* eat spaces */\n\t\t    while (*cp1!='.'&&*cp1!='\\0'&&*cp1!=';') *cp2++=*cp1++;\n\t\t    if (mangle_agent<5)\n\t\t    {\n\t\t\twhile (*cp1!='.'&&*cp1!=';'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\tif (*cp1!=';'&&*cp1!='\\0') {\n\t\t\t    *cp2++=*cp1++;\n\t\t\t    *cp2++=*cp1++;\n\t\t\t}\n\t\t    }\n\t\t    if (mangle_agent<4)\n\t\t\tif (*cp1>='0'&&*cp1<='9') *cp2++=*cp1++;\n\t\t    if (mangle_agent<3)\n\t\t\twhile (*cp1!=';'&&*cp1!='\\0'&&*cp1!='(') *cp2++=*cp1++;\n\t\t    if (mangle_agent<2)\n\t\t    {\n\t\t\t/* Level 1 - try to get OS */\n\t\t\tcp1=strstr(str,\")\");\n\t\t\tif (cp1!=NULL)\n\t\t\t{\n\t\t\t    *cp2++=' ';\n\t\t\t    *cp2++='(';\n\t\t\t    while (*cp1!=';'&&*cp1!='('&&cp1!=str) cp1--;\n\t\t\t    if (cp1!=str&&*cp1!='\\0') cp1++;\n\t\t\t    while (*cp1==' '&&*cp1!='\\0') cp1++;\n\t\t\t    while (*cp1!=')'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\t    *cp2++=')';\n\t\t\t}\n\t\t    }\n\t\t    *cp2='\\0';\n\t\t} else { /* nothing after \"compatible\", should we mangle? */\n\t\t    /* not for now */\n\t\t}\n\t    } else {\n\t\tcp1=strstr(str,\"Opera\");  /* Opera flavor         */\n\t\tif (cp1!=NULL)\n\t\t{\n\t\t    while (*cp1!='/'&&*cp1!=' '&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t    while (*cp1!='.'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t    if (mangle_agent<5)\n\t\t    {\n\t\t\twhile (*cp1!='.'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\t*cp2++=*cp1++;\n\t\t\t*cp2++=*cp1++;\n\t\t    }\n\t\t    if (mangle_agent<4)\n\t\t\tif (*cp1>='0'&&*cp1<='9') *cp2++=*cp1++;\n\t\t    if (mangle_agent<3)\n\t\t\twhile (*cp1!=' '&&*cp1!='\\0'&&*cp1!='(') \n\t\t\t    *cp2++=*cp1++;\n\t\t    if (mangle_agent<2)\n\t\t    {\n\t\t\tcp1=strstr(str,\"(\");\n\t\t\tif (cp1!=NULL)\n\t\t\t{\n\t\t\t    cp1++;\n\t\t\t    *cp2++=' ';\n\t\t\t    *cp2++='(';\n\t\t\t    while (*cp1!=';'&&*cp1!=')'&&*cp1!='\\0') \n\t\t\t\t*cp2++=*cp1++;\n\t\t\t    *cp2++=')';\n\t\t\t}\n\t\t    }\n\t\t    *cp2='\\0';\n\t\t} else { \n\t\t    cp1=strstr(str,\"Mozilla\");  /* Netscape flavor      */\n\t\t    if (cp1!=NULL)\n\t\t    {\n\t\t\twhile (*cp1!='/'&&*cp1!=' '&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\tif (*cp1==' ') *cp1='/';\n\t\t\twhile (*cp1!='.'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\tif (mangle_agent<5)\n\t\t\t{\n\t\t\t    while (*cp1!='.'&&*cp1!='\\0') *cp2++=*cp1++;\n\t\t\t    *cp2++=*cp1++;\n\t\t\t    *cp2++=*cp1++;\n\t\t\t}\n\t\t\tif (mangle_agent<4)\n\t\t\t    if (*cp1>='0'&&*cp1<='9') *cp2++=*cp1++;\n\t\t\tif (mangle_agent<3)\n\t\t\t    while (*cp1!=' '&&*cp1!='\\0'&&*cp1!='(') \n\t\t\t\t*cp2++=*cp1++;\n\t\t\tif (mangle_agent<2)\n\t\t\t{\n\t\t\t    /* Level 1 - Try to get OS */\n\t\t\t    cp1=strstr(str,\"(\");\n\t\t\t    if (cp1!=NULL)\n\t\t\t    {\n\t\t\t\tcp1++;\n\t\t\t\t*cp2++=' ';\n\t\t\t\t*cp2++='(';\n\t\t\t\twhile (*cp1!=';'&&*cp1!=')'&&*cp1!='\\0') \n\t\t\t\t    *cp2++=*cp1++;\n\t\t\t\t*cp2++=')';\n\t\t\t    }\n\t\t\t}\n\t\t\t*cp2='\\0';\n\t\t    }\n\t\t}\n\t    }\n\t }\n\n         /* if necessary, shrink referrer to fit storage */\n         if (strlen(log_rec.refer)>=MAXREFH)\n         {\n            if (verbose) fprintf(stderr,\"%s [%lu]\\n\",\n                msg_big_ref,total_rec);\n            log_rec.refer[MAXREFH-1]='\\0';\n         }\n\n         /* if necessary, shrink URL to fit storage */\n         if (strlen(log_rec.url)>=MAXURLH)\n         {\n            if (verbose) fprintf(stderr,\"%s [%lu]\\n\",\n                msg_big_req,total_rec);\n            log_rec.url[MAXURLH-1]='\\0';\n         }\n\n         /* fix user agent field */\n         cp1 = log_rec.agent;\n         cp3 = cp2 = cp1++;\n         if ( (*cp2 != '\\0') && ((*cp2 == '\"')||(*cp2 == '(')) )\n         {\n            while (*cp1 |= '\\0') { cp3 = cp2; *cp2++ = *cp1++; }\n            *cp3 = '\\0';\n         }\n         cp1 = log_rec.agent;    /* CHANGE !!! */\n         while (*cp1 != 0)       /* get rid of more common _bad_ chars ;)   */\n         {\n            if ( (*cp1 < 32) || (*cp1==127) || (*cp1=='<') || (*cp1=='>') )\n               { *cp1='\\0'; break; }\n            else cp1++;\n         }\n\n         /* fix username if needed */\n         if (log_rec.ident[0]==0)\n          {  log_rec.ident[0]='-'; log_rec.ident[1]='\\0'; }\n         else\n         {\n            cp3=log_rec.ident;\n            while (*cp3>=32 && *cp3!='\"') cp3++;\n            *cp3='\\0';\n         }\n         /* unescape user name */\n         unescape(log_rec.ident);\n\n         /********************************************/\n         /* PROCESS RECORD                           */\n         /********************************************/\n\n         /* first time through? */\n         if (cur_month == 0)\n         {\n             /* if yes, init our date vars */\n             cur_month=rec_month; cur_year=rec_year;\n             cur_day=rec_day; cur_hour=rec_hour;\n             cur_min=rec_min; cur_sec=rec_sec;\n             f_day=rec_day;\n         }\n\n         /* adjust last day processed if different */\n         if (rec_day > l_day) l_day = rec_day;\n \n         /* update min/sec stuff */\n         if (cur_sec != rec_sec) cur_sec = rec_sec;\n         if (cur_min != rec_min) cur_min = rec_min;\n\n         /* check for hour change  */\n         if (cur_hour != rec_hour)\n         {\n            /* if yes, init hourly stuff */\n            if (ht_hit > mh_hit) mh_hit = ht_hit;\n            ht_hit = 0;\n            cur_hour = rec_hour;\n         }\n\n         /* check for day change   */\n         if (cur_day != rec_day)\n         {\n            /* if yes, init daily stuff */\n            tm_site[cur_day-1]=dt_site; dt_site=0;\n            tm_visit[cur_day-1]=tot_visit(sd_htab);\n            del_hlist(sd_htab);\n            cur_day = rec_day;\n         }\n\n         /* check for month change */\n         if (cur_month != rec_month)\n         {\n            /* if yes, do monthly stuff */\n            t_visit=tot_visit(sm_htab);\n            month_update_exit(req_tstamp);    /* process exit pages      */\n            //write_month_html();               /* generate HTML for month */\n\t\t\twrite_month_xml();\n            clear_month();\n            cur_month = rec_month;            /* update our flags        */\n            cur_year  = rec_year;\n            f_day=l_day=rec_day;\n         }\n\n#ifdef USE_DNS\n         /* Resolve IP address if needed */\n         if (dns_db)\n         {\n            if (inet_addr(log_rec.hostname) != INADDR_NONE)\n            resolve_dns(&log_rec);\n         }\n#endif\n\n         /* lowercase hostname */\n         cp1 = log_rec.hostname;\n         while (*cp1 != '\\0')\n         {\n            if ( (*cp1>='A') && (*cp1<='Z') ) *cp1 += 'a'-'A';\n            if ( (isalnum((int)*cp1))||(*cp1=='.')||(*cp1=='-') ) cp1++;\n            else *cp1='\\0';\n         }\n\n         /* Catch blank hostnames here */\n         if (log_rec.hostname[0]=='\\0')\n            strncpy(log_rec.hostname,\"Unknown\",8);\n\n         /* Ignore/Include check */\n         if ( (isinlist(include_sites,log_rec.hostname)==NULL) &&\n              (isinlist(include_urls,log_rec.url)==NULL)       &&\n              (isinlist(include_refs,log_rec.refer)==NULL)     &&\n              (isinlist(include_agents,log_rec.agent)==NULL)   &&\n              (isinlist(include_users,log_rec.ident)==NULL)    )\n         {\n            if (isinlist(ignored_sites,log_rec.hostname)!=NULL)\n              { total_ignore++; continue; }\n            if (isinlist(ignored_urls,log_rec.url)!=NULL)\n              { total_ignore++; continue; }\n            if (isinlist(ignored_agents,log_rec.agent)!=NULL)\n              { total_ignore++; continue; }\n            if (isinlist(ignored_refs,log_rec.refer)!=NULL)\n              { total_ignore++; continue; }\n            if (isinlist(ignored_users,log_rec.ident)!=NULL)\n              { total_ignore++; continue; }\n         }\n\n         /* Bump response code totals */\n         switch (log_rec.resp_code) {\n          case RC_CONTINUE:         i=IDX_CONTINUE;         break;\n          case RC_SWITCHPROTO:      i=IDX_SWITCHPROTO;      break;\n          case RC_OK:               i=IDX_OK;               break;\n          case RC_CREATED:          i=IDX_CREATED;          break;\n          case RC_ACCEPTED:         i=IDX_ACCEPTED;         break;\n          case RC_NONAUTHINFO:      i=IDX_NONAUTHINFO;      break;\n          case RC_NOCONTENT:        i=IDX_NOCONTENT;        break;\n          case RC_RESETCONTENT:     i=IDX_RESETCONTENT;     break;\n          case RC_PARTIALCONTENT:   i=IDX_PARTIALCONTENT;   break;\n          case RC_MULTIPLECHOICES:  i=IDX_MULTIPLECHOICES;  break;\n          case RC_MOVEDPERM:        i=IDX_MOVEDPERM;        break;\n          case RC_MOVEDTEMP:        i=IDX_MOVEDTEMP;        break;\n          case RC_SEEOTHER:         i=IDX_SEEOTHER;         break;\n          case RC_NOMOD:            i=IDX_NOMOD;            break;\n          case RC_USEPROXY:         i=IDX_USEPROXY;         break;\n \t  case RC_MOVEDTEMPORARILY: i=IDX_MOVEDTEMPORARILY; break;\n          case RC_BAD:              i=IDX_BAD;              break;\n          case RC_UNAUTH:           i=IDX_UNAUTH;           break;\n          case RC_PAYMENTREQ:       i=IDX_PAYMENTREQ;       break;\n          case RC_FORBIDDEN:        i=IDX_FORBIDDEN;        break;\n          case RC_NOTFOUND:         i=IDX_NOTFOUND;         break;\n          case RC_METHODNOTALLOWED: i=IDX_METHODNOTALLOWED; break;\n          case RC_NOTACCEPTABLE:    i=IDX_NOTACCEPTABLE;    break;\n          case RC_PROXYAUTHREQ:     i=IDX_PROXYAUTHREQ;     break;\n          case RC_TIMEOUT:          i=IDX_TIMEOUT;          break;\n          case RC_CONFLICT:         i=IDX_CONFLICT;         break;\n          case RC_GONE:             i=IDX_GONE;             break;\n          case RC_LENGTHREQ:        i=IDX_LENGTHREQ;        break;\n          case RC_PREFAILED:        i=IDX_PREFAILED;        break;\n          case RC_REQENTTOOLARGE:   i=IDX_REQENTTOOLARGE;   break;\n          case RC_REQURITOOLARGE:   i=IDX_REQURITOOLARGE;   break;\n          case RC_UNSUPMEDIATYPE:   i=IDX_UNSUPMEDIATYPE;   break;\n\t  case RC_RNGNOTSATISFIABLE:i=IDX_RNGNOTSATISFIABLE;break;\n\t  case RC_EXPECTATIONFAILED:i=IDX_EXPECTATIONFAILED;break;\n          case RC_SERVERERR:        i=IDX_SERVERERR;        break;\n          case RC_NOTIMPLEMENTED:   i=IDX_NOTIMPLEMENTED;   break;\n          case RC_BADGATEWAY:       i=IDX_BADGATEWAY;       break;\n          case RC_UNAVAIL:          i=IDX_UNAVAIL;          break;\n          case RC_GATEWAYTIMEOUT:   i=IDX_GATEWAYTIMEOUT;   break;\n          case RC_BADHTTPVER:       i=IDX_BADHTTPVER;       break;\n          default:                  i=IDX_UNDEFINED;        break;\n         }\n         response[i].count++;\n\n         /* now save in the various hash tables... */\n         if (log_rec.resp_code==RC_OK || log_rec.resp_code==RC_PARTIALCONTENT)\n            i=1; else i=0;\n         \n         /* URL/ident hash table (only if valid response code) */\n         if ((log_rec.resp_code==RC_OK)||(log_rec.resp_code==RC_NOMOD)||\n             (log_rec.resp_code==RC_PARTIALCONTENT))\n         {\n            /* URL hash table */\n            if (put_unode(log_rec.url,OBJ_REG,(u_long)1,\n                log_rec.xfer_size,&t_url,(u_long)0,(u_long)0,um_htab))\n            {\n               if (verbose)\n               /* Error adding URL node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_u, log_rec.url);\n            }\n\n            /* ident (username) hash table */\n            if (put_inode(log_rec.ident,OBJ_REG,\n                1,(u_long)i,log_rec.xfer_size,&t_user,\n                0,rec_tstamp,im_htab))\n            {\n               if (verbose)\n               /* Error adding ident node, skipping .... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_i, log_rec.ident);\n            }\n         }\n\n         /* referrer hash table */\n         if (ntop_refs)\n         {\n            if (log_rec.refer[0]!='\\0')\n             if (put_rnode(log_rec.refer,OBJ_REG,(u_long)1,&t_ref,rm_htab))\n             {\n              if (verbose)\n              fprintf(stderr,\"%s %s\\n\", msg_nomem_r, log_rec.refer);\n             }\n         }\n\n         /* hostname (site) hash table - daily */\n         if (put_hnode(log_rec.hostname,OBJ_REG,\n             1,(u_long)i,log_rec.xfer_size,&dt_site,\n             0,rec_tstamp,\"\",sd_htab))\n         {\n            if (verbose)\n            /* Error adding host node (daily), skipping .... */\n            fprintf(stderr,\"%s %s\\n\",msg_nomem_dh, log_rec.hostname);\n         }\n\n         /* hostname (site) hash table - monthly */\n         if (put_hnode(log_rec.hostname,OBJ_REG,\n             1,(u_long)i,log_rec.xfer_size,&t_site,\n             0,rec_tstamp,\"\",sm_htab))\n         {\n            if (verbose)\n            /* Error adding host node (monthly), skipping .... */\n            fprintf(stderr,\"%s %s\\n\", msg_nomem_mh, log_rec.hostname);\n         }\n\n         /* user agent hash table */\n         if (ntop_agents)\n         {\n            if (log_rec.agent[0]!='\\0')\n             if (put_anode(log_rec.agent,OBJ_REG,(u_long)1,&t_agent,am_htab))\n             {\n              if (verbose)\n              fprintf(stderr,\"%s %s\\n\", msg_nomem_a, log_rec.agent);\n             }\n         }\n\n         /* bump monthly/daily/hourly totals        */\n         t_hit++; ht_hit++;                         /* daily/hourly hits    */\n         t_xfer += log_rec.xfer_size;               /* total xfer size      */\n         tm_xfer[rec_day-1] += log_rec.xfer_size;   /* daily xfer total     */\n         tm_hit[rec_day-1]++;                       /* daily hits total     */\n         th_xfer[rec_hour] += log_rec.xfer_size;    /* hourly xfer total    */\n         th_hit[rec_hour]++;                        /* hourly hits total    */\n   \n         /* if RC_OK, increase file counters */\n         if (log_rec.resp_code == RC_OK)\n         {\n            t_file++;\n            tm_file[rec_day-1]++;\n            th_file[rec_hour]++;\n         }\n\n         /* Pages (pageview) calculation */\n         if (ispage(log_rec.url))\n         {\n            t_page++;\n            tm_page[rec_day-1]++;\n            th_page[rec_hour]++;\n\n            /* do search string stuff if needed     */\n            if (ntop_search) srch_string(log_rec.srchstr);\n         }\n\n         /*********************************************/\n         /* RECORD PROCESSED - DO GROUPS HERE         */ \n         /*********************************************/\n\n         /* URL Grouping */\n         if ( (cp1=isinglist(group_urls,log_rec.url))!=NULL)\n         {\n            if (put_unode(cp1,OBJ_GRP,(u_long)1,log_rec.xfer_size,\n                &ul_bogus,(u_long)0,(u_long)0,um_htab))\n            {\n               if (verbose)\n               /* Error adding URL node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_u, cp1);\n            }\n         }\n\n         /* Site Grouping */\n         if ( (cp1=isinglist(group_sites,log_rec.hostname))!=NULL)\n         {\n            if (put_hnode(cp1,OBJ_GRP,1,(u_long)(log_rec.resp_code==RC_OK)?1:0,\n                          log_rec.xfer_size,&ul_bogus,\n                          0,rec_tstamp,\"\",sm_htab))\n            {\n               if (verbose)\n               /* Error adding Site node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_mh, cp1);\n            }\n         }\n         else\n         {\n            /* Domain Grouping */\n            if (group_domains)\n            {\n               cp1 = get_domain(log_rec.hostname);\n               if (cp1 != NULL)\n               {\n                  if (put_hnode(cp1,OBJ_GRP,1,\n                      (u_long)(log_rec.resp_code==RC_OK)?1:0,\n                      log_rec.xfer_size,&ul_bogus,\n                      0,rec_tstamp,\"\",sm_htab))\n                  {\n                     if (verbose)\n                     /* Error adding Site node, skipping ... */\n                     fprintf(stderr,\"%s %s\\n\", msg_nomem_mh, cp1);\n                  }\n               }\n            }\n         }\n\n         /* Referrer Grouping */\n         if ( (cp1=isinglist(group_refs,log_rec.refer))!=NULL)\n         {\n            if (put_rnode(cp1,OBJ_GRP,(u_long)1,&ul_bogus,rm_htab))\n            {\n               if (verbose)\n               /* Error adding Referrer node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_r, cp1);\n            }\n         }\n\n         /* User Agent Grouping */\n         if ( (cp1=isinglist(group_agents,log_rec.agent))!=NULL)\n         {\n            if (put_anode(cp1,OBJ_GRP,(u_long)1,&ul_bogus,am_htab))\n            {\n               if (verbose)\n               /* Error adding User Agent node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_a, cp1);\n            }\n         }\n\n         /* Ident (username) Grouping */\n         if ( (cp1=isinglist(group_users,log_rec.ident))!=NULL)\n         {\n            if (put_inode(cp1,OBJ_GRP,1,(u_long)(log_rec.resp_code==RC_OK)?1:0,\n                          log_rec.xfer_size,&ul_bogus,\n                          0,rec_tstamp,im_htab))\n            {\n               if (verbose)\n               /* Error adding Username node, skipping ... */\n               fprintf(stderr,\"%s %s\\n\", msg_nomem_i, cp1);\n            }\n         }\n      }\n\n      /*********************************************/\n      /* BAD RECORD                                */\n      /*********************************************/\n\n      else\n      {\n         /* If first record, check if stupid Netscape header stuff      */\n         if ( (total_rec==1) && (strncmp(buffer,\"format=\",7)==0) )\n         {\n            /* Skipping Netscape header record */\n            if (verbose>1) printf(\"%s\\n\",msg_ign_nscp);\n            /* count it as ignored... */\n            total_ignore++;\n         }\n         else\n         {\n            /* really bad record... */\n            total_bad++;\n            if (verbose)\n            {\n               fprintf(stderr,\"%s (%lu)\",msg_bad_rec,total_rec);\n               if (debug_mode) fprintf(stderr,\":\\n%s\\n\",tmp_buf);\n               else fprintf(stderr,\"\\n\");\n            }\n         }\n      }\n   }\n\n   /*********************************************/\n   /* DONE READING LOG FILE - final processing  */\n   /*********************************************/\n\n   /* close log file if needed */\n   if (gz_log) gzclose(gzlog_fp);\n   else if (log_fname) fclose(log_fp);\n\n   if (good_rec)                             /* were any good records?   */\n   {\n      tm_site[cur_day-1]=dt_site;            /* If yes, clean up a bit   */\n      tm_visit[cur_day-1]=tot_visit(sd_htab);\n      t_visit=tot_visit(sm_htab);\n      if (ht_hit > mh_hit) mh_hit = ht_hit;\n\n      if (total_rec > (total_ignore+total_bad)) /* did we process any?   */\n      {\n         if (incremental)\n         {\n            if (save_state())                /* incremental stuff        */\n            {\n               /* Error: Unable to save current run data */\n               if (verbose) fprintf(stderr,\"%s\\n\",msg_data_err);\n               unlink(state_fname);\n            }\n         }\n         month_update_exit(rec_tstamp);      /* calculate exit pages     */\n    //write_month_html();                 /* write monthly HTML file  */\n\t\twrite_month_xml();\n        write_main_xml();                 /* write main HTML file     */\n\t//write_main_index();\n         put_history();                      /* write history            */\n      }\n\n      end_time = times(&mytms);              /* display timing totals?   */\n      if (time_me || (verbose>1))\n      {\n         printf(\"%lu %s \",total_rec, msg_records);\n         if (total_ignore)\n         {\n            printf(\"(%lu %s\",total_ignore,msg_ignored);\n            if (total_bad) printf(\", %lu %s) \",total_bad,msg_bad);\n               else        printf(\") \");\n         }\n         else if (total_bad) printf(\"(%lu %s) \",total_bad,msg_bad);\n\n         /* get processing time (end-start) */\n         temp_time = (float)(end_time-start_time)/CLK_TCK;\n         printf(\"%s %.2f %s\", msg_in, temp_time, msg_seconds);\n\n         /* calculate records per second */\n         if (temp_time)\n           i=( (int)( (float)total_rec/temp_time ) );\n         else i=0;\n\n         if ( (i>0) && (i<=total_rec) ) printf(\", %d/sec\\n\", i);\n            else  printf(\"\\n\");\n      }\n\n#ifdef USE_DNS\n      if (dns_db) close_cache();\n#endif\n\n      /* Whew, all done! Exit with completion status (0) */\n      exit(0);\n   }\n   else\n   {\n      /* No valid records found... exit with error (1) */\n      if (verbose) printf(\"%s\\n\",msg_no_vrec);\n      exit(1);\n   }\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* ADD_NLIST - add item to FIFO linked list  */\n/*********************************************/\n", "func_signal": "int add_nlist(char *str, NLISTPTR *list)", "code": "{\n   NLISTPTR newptr,cptr,pptr;\n\n   if ( (newptr = new_nlist(str)) != NULL)\n   {\n      if (*list==NULL) *list=newptr;\n      else\n      {\n         cptr=pptr=*list;\n         while(cptr!=NULL) { pptr=cptr; cptr=cptr->next; };\n         pptr->next = newptr;\n      }\n   } \n   return newptr==NULL;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* CLEAR_MONTH - initalize monthly stuff     */\n/*********************************************/\n", "func_signal": "void clear_month()", "code": "{\n   int i;\n\n   init_counters();                  /* reset monthly counters  */\n   del_htabs();                      /* clear hash tables       */\n   if (ntop_ctrys!=0 ) for (i=0;i<ntop_ctrys;i++)  top_ctrys[i]=NULL;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* SRCH_STRING - get search strings from ref */\n/*********************************************/\n", "func_signal": "void srch_string(char *ptr)", "code": "{\n   /* ptr should point to unescaped query string */\n   char tmpbuf[BUFSIZE];\n   char srch[80]=\"\";\n   unsigned char *cp1, *cp2, *cps;\n   int  sp_flg=0;\n\n   /* Check if search engine referrer or return  */\n   if ( (cps=isinglist(search_list,log_rec.refer))==NULL) return; \n\n   /* Try to find query variable */\n   srch[0]='?'; strcpy(&srch[1],cps);              /* First, try \"?...\"      */\n   if ((cp1=strstr(ptr,srch))==NULL)\n   {\n      srch[0]='&';                                 /* Next, try \"&...\"       */\n      if ((cp1=strstr(ptr,srch))==NULL) return;    /* If not found, split... */\n   }\n   cp2=tmpbuf;\n   while (*cp1!='=' && *cp1!=0) cp1++; if (*cp1!=0) cp1++;\n   while (*cp1!='&' && *cp1!=0)\n   {\n      if (*cp1=='\"' || *cp1==',' || *cp1=='?')\n          { cp1++; continue; }                         /* skip bad ones..    */\n      else\n      {\n         if (*cp1=='+') *cp1=' ';                      /* change + to space  */\n         if (sp_flg && *cp1==' ') { cp1++; continue; } /* compress spaces    */\n         if (*cp1==' ') sp_flg=1; else sp_flg=0;       /* (flag spaces here) */\n         *cp2++=tolower(*cp1);                         /* normal character   */\n         cp1++;\n      }\n   }\n   *cp2=0; cp2=tmpbuf;\n   if (tmpbuf[0]=='?') tmpbuf[0]=' ';                  /* format fix ?       */\n   while( *cp2!=0 && isspace(*cp2) ) cp2++;            /* skip leading sps.  */\n   if (*cp2==0) return;\n\n   /* any trailing spaces? */\n   cp1=cp2+strlen(cp2)-1;\n   while (cp1!=cp2) if (isspace(*cp1)) *cp1--='\\0'; else break;\n\n   /* strip invalid chars */\n   cp1=cp2;\n   while (*cp1!=0) { if ((*cp1<32)||(*cp1==127)) *cp1='_'; cp1++; }\n\n   if (put_snode(cp2,(u_long)1,sr_htab))\n   {\n      if (verbose)\n      /* Error adding search string node, skipping .... */\n      fprintf(stderr,\"%s %s\\n\", msg_nomem_sc, tmpbuf);\n   }\n   return;\n}", "path": "src\\xmlwebalizer.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* ISINLIST - Test if string is in list      */\n/*********************************************/\n", "func_signal": "char *isinlist(NLISTPTR list, char *str)", "code": "{\n   NLISTPTR lptr;\n\n   lptr=list;\n   while (lptr!=NULL)\n   {\n      if (isinstr(str,lptr->string)) return lptr->string;\n      lptr=lptr->next;\n   }\n   return NULL;\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/*********************************************/\n/* DEL_GLIST - delete FIFO linked list       */\n/*********************************************/\n", "func_signal": "void del_glist(GLISTPTR *list)", "code": "{\n   GLISTPTR cptr,nptr;\n\n   cptr=*list;\n   while (cptr!=NULL)\n   {\n      nptr=cptr->next;\n      free(cptr);\n      cptr=nptr;\n   }\n}", "path": "src\\linklist.c", "repo_name": "bond/xmlreports", "stars": 4, "license": "other", "language": "c", "size": 769}
{"docstring": "/* is this a dir? */\n/* -1 means it ain't anything .. */\n", "func_signal": "static int\nisdir(char *path)", "code": "{\n\tstruct stat buf;\n\n\tif (stat(path, &buf) < 0)\n\t\treturn -1;\n\n\treturn S_ISDIR(buf.st_mode);\n}", "path": "examples\\ixpsrv.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_stat\n * Function: ixp_fstat\n *\n * Params:\n *\tpath - The path of the file to stat.\n *\tf - A CFid of an open file to stat.\n *\n * Stats the file at P<path> or pointed to by P<f>.\n *\n * Returns:\n *\tReturns a Stat structure, which must be freed by\n * the caller with free(3).\n *\n * S<Stat>\n */\n", "func_signal": "Stat*\nixp_stat(IxpClient *c, const char *path)", "code": "{\n\tStat *stat;\n\tIxpCFid *f;\n\n\tf = walk(c, path);\n\tif(f == nil)\n\t\treturn nil;\n\n\tstat = _stat(c, f->fid);\n\tclunk(f);\n\treturn stat;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_errbuf\n * Function: ixp_errstr\n * Function: ixp_rerrstr\n * Function: ixp_werrstr\n *\n * Params:\n *\tbuf - The buffer to read and/or fill.\n *\tn - The size of the buffer.\n *\tfmt - A format string with which to write the *\terrstr.\n *\t... - Arguments to P<fmt>.\n *\n * These functions simulate Plan 9's errstr functionality.\n * They replace errno in libixp. Note that these functions\n * are not internationalized.\n *\n * F<ixp_errbuf> returns the errstr buffer for the current\n * thread. F<ixp_rerrstr> fills P<buf> with the data from\n * the current thread's error buffer, while F<ixp_errstr>\n * exchanges P<buf>'s contents with those of the current\n * thread's error buffer. F<ixp_werrstr> is takes a format\n * string from which to construct an errstr.\n *\n * Returns:\n *\tF<ixp_errbuf> returns the current thread's error\n * string buffer.\n */\n", "func_signal": "char*\nixp_errbuf()", "code": "{\n\tchar *errbuf;\n\n\terrbuf = thread->errbuf();\n\tif(errno == EINTR)\n\t\tstrncpy(errbuf, \"interrupted\", IXP_ERRMAX);\n\telse if(errno != EPLAN9)\n\t\tstrncpy(errbuf, strerror(errno), IXP_ERRMAX);\n\treturn errbuf;\n}", "path": "libixp\\error.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_write\n * Function: ixp_pwrite\n *\n * Params:\n *\tbuf - A buffer holding the contents to store.\n *\tcount - The number of bytes to store.\n *\toffset - The offset at which to write the data.\n *\n * ixp_write and ixp_pwrite each write P<count> bytes of\n * data stored in P<buf> to the file pointed to by C<f>.\n * ixp_write writes its data at its stored offset, and\n * increments it by P<count>. ixp_pwrite writes its data a\n * P<offset> and does not alter C<f>'s stored offset.\n *\n * Returns:\n *\tThese functions return the number of bytes actually\n * written. Any value less than P<count> must be considered\n * a failure.\n */\n", "func_signal": "long\nixp_write(IxpCFid *f, const void *buf, long count)", "code": "{\n\tint n;\n\n\tthread->lock(&f->iolock);\n\tn = _pwrite(f, buf, count, f->offset);\n\tif(n > 0)\n\t\tf->offset += n;\n\tthread->unlock(&f->iolock);\n\treturn n;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/* This should be moved to libixp */\n", "func_signal": "static void\nwrite_to_buf(Ixp9Req *r, void *buf, uint *len, uint max)", "code": "{\n\tuint offset, count;\n\n//\toffset = (r->fid->omode&OAPPEND) ? *len : r->ifcall.tread.offset;\n\toffset = r->ifcall.tread.offset;\n\tif(offset > *len || r->ifcall.tread.count == 0) {\n\t\tr->ofcall.rread.count = 0;\n\t\treturn;\n\t}\n\n\tcount = r->ifcall.tread.count;\n\tif(max && (count > max - offset))\n\t\tcount = max - offset;\n\n\t*len = offset + count;\n\n\tif(max == 0) {\n\t\t*(void **)buf = ixp_erealloc(*(void **)buf, *len + 1);\n\t\tbuf = *(void **)buf;\n\t}\n\n\tmemcpy((uchar*)buf + offset, r->ifcall.tread.data, count);\n\tr->ofcall.rread.count = count;\n\t((char *)buf)[offset+count] = '\\0';\n}", "path": "examples\\ixpsrv.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_nexttimer\n *\n * Triggers any timers whose timeouts have ellapsed. This is\n * primarilly intended to be called from libixp's select\n * loop.\n *\n * Returns:\n *\tReturns the number of milliseconds until the next\n * timer's timeout.\n */\n", "func_signal": "long\nixp_nexttimer(IxpServer *s)", "code": "{\n\tTimer *t;\n\tlong time, ret;\n\n\tSET(time);\n\tthread->lock(&s->lk);\n\twhile((t = s->timer)) {\n\t\ttime = ixp_msec();\n\t\tif(t->msec > time)\n\t\t\tbreak;\n\t\ts->timer = t->link;\n\n\t\tthread->unlock(&s->lk);\n\t\tt->fn(t->id, t->aux);\n\t\tfree(t);\n\t\tthread->lock(&s->lk);\n\t}\n\tret = 0;\n\tif(t)\n\t\tret = t->msec - time;\n\tthread->unlock(&s->lk);\n\treturn ret;\n}", "path": "libixp\\timer.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_settimer\n *\n * Params:\n *\tmsec - The timeout in milliseconds.\n *\tfn - The function to call after P<msec> milliseconds\n *\t     have elapsed.\n *\taux - An arbitrary argument to pass to P<fn> when it\n *\t      is called.\n * \n * Initializes a callback-based timer to be triggerred after\n * P<msec> milliseconds. The timer is passed its id number\n * and the value of P<aux>.\n *\n * Returns:\n *\tReturns the new timer's unique id number.\n */\n", "func_signal": "long\nixp_settimer(IxpServer *s, long msec, void (*fn)(long, void*), void *aux)", "code": "{\n\tTimer **tp;\n\tTimer *t;\n\tlong time;\n\n\ttime = ixp_msec();\n\tif(time == -1)\n\t\treturn -1;\n\tmsec += time;\n\n\tt = emallocz(sizeof *t);\n\tthread->lock(&s->lk);\n\tt->id = lastid++;\n\tt->msec = msec;\n\tt->fn = fn;\n\tt->aux = aux;\n\n\tfor(tp=&s->timer; *tp; tp=&tp[0]->link)\n\t\tif(tp[0]->msec < msec)\n\t\t\tbreak;\n\tt->link = *tp;\n\t*tp = t;\n\tthread->unlock(&s->lk);\n\treturn t->id;\n}", "path": "libixp\\timer.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_remove\n *\n * Params:\n *\tpath - The path of the file to remove.\n *\n * Removes a file or directory from the remote server.\n *\n * Returns:\n *\tixp_remove returns 0 on failure, 1 on success.\n */\n", "func_signal": "int\nixp_remove(IxpClient *c, const char *path)", "code": "{\n\tFcall fcall;\n\tIxpCFid *f;\n\tint ret;\n\n\tif((f = walk(c, path)) == nil)\n\t\treturn 0;\n\n\tfcall.hdr.type = TRemove;\n\tfcall.hdr.fid = f->fid;;\n\tret = dofcall(c, &fcall);\n\tixp_freefcall(&fcall);\n\tputfid(f);\n\n\treturn ret;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/* Utility Functions */\n", "func_signal": "static FidAux*\nnewfidaux(char *name)", "code": "{\n\tFidAux *f;\n\n\tf = ixp_emallocz(sizeof(*f) + strlen(name) + 1);\n\tf->fd = -1;\n\tstrcpy(f->name, name);\n\treturn f;\n}", "path": "examples\\ixpsrv.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_unsettimer\n *\n * Params:\n *\tid - The id number of the timer to void.\n *\n * Voids the timer identified by P<id>.\n *\n * Returns:\n *\tReturns true if a timer was stopped, false\n * otherwise.\n */\n", "func_signal": "int\nixp_unsettimer(IxpServer *s, long id)", "code": "{\n\tTimer **tp;\n\tTimer *t;\n\n\tthread->lock(&s->lk);\n\tfor(tp=&s->timer; (t=*tp); tp=&t->link)\n\t\tif(t->id == id)\n\t\t\tbreak;\n\tif(t) {\n\t\t*tp = t->link;\n\t\tfree(t);\n\t}\n\tthread->unlock(&s->lk);\n\treturn t != nil;\n}", "path": "libixp\\timer.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/* Utility Functions */\n/**\n * Obtain an empty, reference counted IxpFileId struct.\n */\n", "func_signal": "IxpFileId*\nixp_srv_getfile(void)", "code": "{\n\tIxpFileId *file;\n\tint i;\n\n\tif(!free_fileid) {\n\t\ti = 15;\n\t\tfile = emallocz(i * sizeof *file);\n\t\tfor(; i; i--) {\n\t\t\tfile->next = free_fileid;\n\t\t\tfree_fileid = file++;\n\t\t}\n\t}\n\tfile = free_fileid;\n\tfree_fileid = file->next;\n\tfile->p = nil;\n\tfile->volatil = 0;\n\tfile->nref = 1;\n\tfile->next = nil;\n\tfile->pending = false;\n\treturn file;\n}", "path": "libixp\\srv_util.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_mountfd\n * Function: ixp_mount\n * Function: ixp_nsmount\n *\n * Params:\n *\tfd - A file descriptor which is already connected\n *\t     to a 9P server.\n *\taddress - An address (in Plan 9 resource fomat) at\n *\t          which to connect to a 9P server.\n *\tname - The name of a socket in the process's canonical\n *\t       namespace directory.\n *\n * Initiate a 9P connection with the server at P<address>,\n * connected to on P<fd>, or under the process's namespace\n * directory as P<name>.\n *\n * Returns:\n *\tA pointer to a new 9P client.\n */\n", "func_signal": "IxpClient*\nixp_mountfd(int fd)", "code": "{\n\tIxpClient *c;\n\tFcall fcall;\n\n\tc = emallocz(sizeof *c);\n\tc->fd = fd;\n\n\tmuxinit(c);\n\n\tallocmsg(c, 256);\n\tc->lastfid = RootFid;\n\t/* Override tag matching on TVersion */\n\tc->mintag = IXP_NOTAG;\n\tc->maxtag = IXP_NOTAG+1;\n\n\tfcall.hdr.type = TVersion;\n\tfcall.version.msize = IXP_MAX_MSG;\n\tfcall.version.version = IXP_VERSION;\n\n\tif(dofcall(c, &fcall) == 0) {\n\t\tixp_unmount(c);\n\t\treturn nil;\n\t}\n\n\tif(strcmp(fcall.version.version, IXP_VERSION)\n\t|| fcall.version.msize > IXP_MAX_MSG) {\n\t\twerrstr(\"bad 9P version response\");\n\t\tixp_unmount(c);\n\t\treturn nil;\n\t}\n\n\tc->mintag = 0;\n\tc->maxtag = 255;\n\tc->msize = fcall.version.msize;\n\n\tallocmsg(c, fcall.version.msize);\n\tixp_freefcall(&fcall);\n\n\tfcall.hdr.type = TAttach;\n\tfcall.hdr.fid = RootFid;\n\tfcall.tattach.afid = IXP_NOFID;\n\tfcall.tattach.uname = getenv(\"USER\");\n\tfcall.tattach.aname = \"\";\n\tif(dofcall(c, &fcall) == 0) {\n\t\tixp_unmount(c);\n\t\treturn nil;\n\t}\n\n\treturn c;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/* Can't malloc */\n", "func_signal": "static void\nmfatal(char *name, uint size)", "code": "{\n\tconst char\n\t\tcouldnot[] = \"libixp: fatal: Could not \",\n\t\tparen[] = \"() \",\n\t\tbytes[] = \" bytes\\n\";\n\tchar sizestr[8];\n\tint i;\n\t\n\ti = sizeof sizestr;\n\tdo {\n\t\tsizestr[--i] = '0' + (size%10);\n\t\tsize /= 10;\n\t} while(size > 0);\n\n\twrite(1, couldnot, sizeof(couldnot)-1);\n\twrite(1, name, strlen(name));\n\twrite(1, paren, sizeof(paren)-1);\n\twrite(1, sizestr+i, sizeof(sizestr)-i);\n\twrite(1, bytes, sizeof(bytes)-1);\n\n\texit(1);\n}", "path": "libixp\\util.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Ensure that the data member of 'r' is null terminated,\n * removing any new line from its end.\n */\n", "func_signal": "void\nixp_srv_data2cstring(Ixp9Req *req)", "code": "{\n\tchar *p, *q;\n\tuint i;\n\n\ti = req->ifcall.io.count;\n\tp = req->ifcall.io.data;\n\tif(i && p[i - 1] == '\\n')\n\t\ti--;\n\tq = memchr(p, '\\0', i);\n\tif(q)\n\t\ti = q - p;\n\n\tp = erealloc(req->ifcall.io.data, i+1);\n\tp[i] = '\\0';\n\treq->ifcall.io.data = p;\n}", "path": "libixp\\srv_util.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_vprint\n * Function: ixp_print\n * Variable: ixp_vsmprint\n *\n * Params:\n *\tfmt - The string with which to format the data.\n *\tap - A va_list holding the arguments to the format\n *\t     string.\n *\t... - The arguments to the format string.\n *\n * These functions act like the standard formatted IO\n * functions. They write the result of the formatting to the\n * file pointed to by C<f>.\n *\n * V<ixp_vsmprint> may be set to a function which will\n * format its arguments and return a null terminated string\n * allocated with malloc(3).\n *\n * Returns:\n *\tThese functions return the number of bytes written.\n * There is currently no way to detect failure.\n */\n", "func_signal": "int\nixp_vprint(IxpCFid *f, const char *fmt, va_list ap)", "code": "{\n\tchar *buf;\n\tint n;\n\n\tbuf = ixp_vsmprint(fmt, ap);\n\tif(buf == nil)\n\t\treturn -1;\n\n\tn = ixp_write(f, buf, strlen(buf));\n\tfree(buf);\n\treturn n;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Increase the reference count of every IxpFileId linked\n * to 'f'.\n */\n", "func_signal": "IxpFileId*\nixp_srv_clonefiles(IxpFileId *f)", "code": "{\n\tIxpFileId *r;\n\n\tr = emalloc(sizeof *r);\n\tmemcpy(r, f, sizeof *r);\n\tr->tab.name = estrdup(r->tab.name);\n\tr->nref = 1;\n\tfor(f=f->next; f; f=f->next)\n\t\tassert(f->nref++);\n\treturn r;\n}", "path": "libixp\\srv_util.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_read\n * Function: ixp_pread\n *\n * Params:\n *\tbuf - A buffer in which to store the read data.\n *\tcount - The number of bytes to read.\n *\toffset - The offset at which to begin reading.\n *\n * ixp_read and ixp_pread each read P<count> bytes of data\n * from the file pointed to by P<f>, into P<buf>. ixp_read\n * begins reading at its stored offset, and increments it by\n * the number of bytes read. ixp_pread reads beginning at\n * P<offset> and does not alter C<f>'s stored offset.\n *\n * Returns:\n *\tThese functions return the number of bytes read on\n * success and -1 on failure.\n */\n", "func_signal": "long\nixp_read(IxpCFid *f, void *buf, long count)", "code": "{\n\tint n;\n\n\tthread->lock(&f->iolock);\n\tn = _pread(f, buf, count, f->offset);\n\tif(n > 0)\n\t\tf->offset += n;\n\tthread->unlock(&f->iolock);\n\treturn n;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_create\n * Function: ixp_open\n *\n * Params:\n *\tpath - The path of the file to open or create.\n *\tperm - The permissions with which to create the new\n *\t       file. These will be ANDed with those of the\n *\t       parent directory by the server.\n *\tmode - The file's open mode.\n *\n * ixp_open and ixp_create each open a file at P<path>.\n * P<mode> must include OREAD, OWRITE, or ORDWR, and may\n * include any of the modes specified in 9pmodes(3).\n * ixp_create, additionally, creates a file at P<path> if it\n * doesn't already exist.\n *\n * Returns:\n *\tA pointer on which to operate on the newly\n * opened file.\n */\n", "func_signal": "IxpCFid*\nixp_create(IxpClient *c, const char *path, uint perm, uchar mode)", "code": "{\n\tFcall fcall;\n\tIxpCFid *f;\n\tchar *tpath;;\n\n\ttpath = estrdup(path);\n\n\tf = walkdir(c, tpath, &path);\n\tif(f == nil)\n\t\tgoto done;\n\n\tfcall.hdr.type = TCreate;\n\tfcall.hdr.fid = f->fid;\n\tfcall.tcreate.name = (char*)(uintptr_t)path;\n\tfcall.tcreate.perm = perm;\n\tfcall.tcreate.mode = mode;\n\n\tif(dofcall(c, &fcall) == 0) {\n\t\tclunk(f);\n\t\tf = nil;\n\t\tgoto done;\n\t}\n\n\tinitfid(f, &fcall);\n\tf->mode = mode;\n\n\tixp_freefcall(&fcall);\n\ndone:\n\tfree(tpath);\n\treturn f;\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Function: ixp_unmount\n *\n * Unmounts the client P<c> and frees its data structures.\n */\n", "func_signal": "void\nixp_unmount(IxpClient *c)", "code": "{\n\tIxpCFid *f;\n\n\tshutdown(c->fd, SHUT_RDWR);\n\tclose(c->fd);\n\n\tmuxfree(c);\n\n\twhile((f = c->freefid)) {\n\t\tc->freefid = f->next;\n\t\tthread->mdestroy(&f->iolock);\n\t\tfree(f);\n\t}\n\tfree(c->rmsg.data);\n\tfree(c->wmsg.data);\n\tfree(c);\n}", "path": "libixp\\client.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/**\n * Decrease the reference count of the given IxpFileId,\n * and push it onto the free list when it reaches 0;\n */\n", "func_signal": "void\nixp_srv_freefile(IxpFileId *f)", "code": "{\n\tif(--f->nref)\n\t\treturn;\n\tfree(f->tab.name);\n\tf->next = free_fileid;\n\tfree_fileid = f;\n}", "path": "libixp\\srv_util.c", "repo_name": "bartman/libixp", "stars": 5, "license": "None", "language": "c", "size": 526}
{"docstring": "/* Initialize JIT compiler. */\n", "func_signal": "static void jit_init(lua_State *L)", "code": "{\n  uint32_t flags = jit_cpudetect(L);\n#if LJ_HASJIT\n  jit_State *J = L2J(L);\n  J->flags = flags | JIT_F_ON | JIT_F_OPT_DEFAULT;\n  memcpy(J->param, jit_param_default, sizeof(J->param));\n  jit_init_hotcount(J);\n  lj_dispatch_update(G(L));\n#else\n  UNUSED(flags);\n#endif\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Parse optimization level. */\n", "func_signal": "static int jitopt_level(jit_State *J, const char *str)", "code": "{\n  if (str[0] >= '0' && str[0] <= '9' && str[1] == '\\0') {\n    uint32_t flags;\n    if (str[0] == '0') flags = JIT_F_OPT_0;\n    else if (str[0] == '1') flags = JIT_F_OPT_1;\n    else if (str[0] == '2') flags = JIT_F_OPT_2;\n    else flags = JIT_F_OPT_3;\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | flags;\n    return 1;  /* Ok. */\n  }\n  return 0;  /* No match. */\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Return prototype of first argument (Lua function or prototype object) */\n", "func_signal": "static GCproto *check_Lproto(lua_State *L, int nolua)", "code": "{\n  TValue *o = L->base;\n  if (L->top > o) {\n    if (tvisproto(o)) {\n      return protoV(o);\n    } else if (tvisfunc(o)) {\n      if (isluafunc(funcV(o)))\n\treturn funcproto(funcV(o));\n      else if (nolua)\n\treturn NULL;\n    }\n  }\n  lj_err_argt(L, 1, LUA_TFUNCTION);\n  return NULL;  /* unreachable */\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local info = jit.util.traceinfo(tr) */\n", "func_signal": "LJLIB_CF(jit_util_traceinfo)", "code": "{\n  Trace *T = jit_checktrace(L);\n  if (T) {\n    GCtab *t;\n    lua_createtable(L, 0, 4);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"nins\", (int32_t)T->nins - REF_BIAS - 1);\n    setintfield(L, t, \"nk\", REF_BIAS - (int32_t)T->nk);\n    setintfield(L, t, \"link\", T->link);\n    setintfield(L, t, \"nexit\", T->nsnap);\n    /* There are many more fields. Add them only when needed. */\n    return 1;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Check trace argument. Must not throw for non-existent trace numbers. */\n", "func_signal": "static Trace *jit_checktrace(lua_State *L)", "code": "{\n  TraceNo tr = (TraceNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (tr > 0 && tr < J->sizetrace)\n    return J->trace[tr];\n  return NULL;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local k = jit.util.funck(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funck)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  MSize idx = (MSize)lj_lib_checkint(L, 2);\n  if ((int32_t)idx >= 0) {\n    if (idx < pt->sizekn) {\n      setnumV(L->top-1, pt->k.n[idx]);\n      return 1;\n    }\n  } else {\n    if (~idx < pt->sizekgc) {\n      GCobj *gc = gcref(pt->k.gc[idx]);\n      setgcV(L, L->top-1, &gc->gch, ~gc->gch.gct);\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local info = jit.util.funcinfo(func [,pc]) */\n", "func_signal": "LJLIB_CF(jit_util_funcinfo)", "code": "{\n  GCproto *pt = check_Lproto(L, 1);\n  if (pt) {\n    BCPos pc = (BCPos)lj_lib_optint(L, 2, 0);\n    GCtab *t;\n    lua_createtable(L, 0, 16);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"linedefined\", pt->linedefined);\n    setintfield(L, t, \"lastlinedefined\", pt->lastlinedefined);\n    setintfield(L, t, \"stackslots\", pt->framesize);\n    setintfield(L, t, \"params\", pt->numparams);\n    setintfield(L, t, \"bytecodes\", (int32_t)pt->sizebc);\n    setintfield(L, t, \"gcconsts\", (int32_t)pt->sizekgc);\n    setintfield(L, t, \"nconsts\", (int32_t)pt->sizekn);\n    setintfield(L, t, \"upvalues\", (int32_t)pt->sizeuv);\n    if (pc > 0)\n      setintfield(L, t, \"currentline\", pt->lineinfo ? pt->lineinfo[pc-1] : 0);\n    lua_pushboolean(L, (pt->flags & PROTO_IS_VARARG));\n    lua_setfield(L, -2, \"isvararg\");\n    setstrV(L, L->top++, pt->chunkname);\n    lua_setfield(L, -2, \"source\");\n    lj_err_pushloc(L, pt, pc);\n    lua_setfield(L, -2, \"loc\");\n  } else {\n    GCfunc *fn = funcV(L->base);\n    GCtab *t;\n    lua_createtable(L, 0, 2);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"ffid\", fn->c.ffid);\n    setintfield(L, t, \"upvalues\", fn->c.nupvalues);\n  }\n  return 1;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* jit.opt.start(flags...) */\n", "func_signal": "LJLIB_CF(jit_opt_start)", "code": "{\n#if LJ_HASJIT\n  jit_State *J = L2J(L);\n  int nargs = (int)(L->top - L->base);\n  if (nargs == 0) {\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | JIT_F_OPT_DEFAULT;\n  } else {\n    int i;\n    for (i = 1; i <= nargs; i++) {\n      const char *str = strdata(lj_lib_checkstr(L, i));\n      if (!jitopt_level(J, str) &&\n\t  !jitopt_flag(J, str) &&\n\t  !jitopt_param(J, str))\n\tlj_err_callerv(L, LJ_ERR_JITOPT, str);\n    }\n  }\n#else\n  lj_err_caller(L, LJ_ERR_NOJIT);\n#endif\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local snap = jit.util.tracesnap(tr, sn) */\n", "func_signal": "LJLIB_CF(jit_util_tracesnap)", "code": "{\n  Trace *T = jit_checktrace(L);\n  SnapNo sn = (SnapNo)lj_lib_checkint(L, 2);\n  if (T && sn < T->nsnap) {\n    SnapShot *snap = &T->snap[sn];\n    IRRef2 *map = &T->snapmap[snap->mapofs];\n    BCReg s, nslots = snap->nslots;\n    GCtab *t;\n    lua_createtable(L, nslots ? (int)nslots : 1, 0);\n    t = tabV(L->top-1);\n    setintV(lj_tab_setint(L, t, 0), (int32_t)snap->ref - REF_BIAS);\n    for (s = 0; s < nslots; s++) {\n      TValue *o = lj_tab_setint(L, t, (int32_t)(s+1));\n      IRRef ref = snap_ref(map[s]);\n      if (ref)\n\tsetintV(o, (int32_t)ref - REF_BIAS);\n      else\n\tsetboolV(o, 0);\n    }\n    return 1;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Push a string for every flag bit that is set. */\n", "func_signal": "static void flagbits_to_strings(lua_State *L, uint32_t flags, uint32_t base,\n\t\t\t\tconst char *str)", "code": "{\n  for (; *str; base <<= 1, str += 1+*str)\n    if (flags & base)\n      setstrV(L, L->top++, lj_str_new(L, str+1, *(uint8_t *)str));\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Parse optimization parameter. */\n", "func_signal": "static int jitopt_param(jit_State *J, const char *str)", "code": "{\n  const char *lst = JIT_P_STRING;\n  int i;\n  for (i = 0; i < JIT_P__MAX; i++) {\n    size_t len = *(const uint8_t *)lst;\n    TValue tv;\n    lua_assert(len != 0);\n    if (strncmp(str, lst+1, len) == 0 && str[len] == '=' &&\n\tlj_str_numconv(&str[len+1], &tv)) {\n      J->param[i] = lj_num2int(tv.n);\n      if (i == JIT_P_hotloop)\n\tjit_init_hotcount(J);\n      return 1;  /* Ok. */\n    }\n    lst += 1+len;\n  }\n  return 0;  /* No match. */\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Arch-dependent CPU detection. */\n", "func_signal": "static uint32_t jit_cpudetect(lua_State *L)", "code": "{\n  uint32_t flags = 0;\n#if LJ_TARGET_X86ORX64\n  uint32_t vendor[4];\n  uint32_t features[4];\n  if (lj_vm_cpuid(0, vendor) && lj_vm_cpuid(1, features)) {\n#if !LJ_HASJIT\n#define JIT_F_CMOV\t1\n#endif\n    flags |= ((features[3] >> 15)&1) * JIT_F_CMOV;\n#if LJ_HASJIT\n    flags |= ((features[3] >> 26)&1) * JIT_F_SSE2;\n    flags |= ((features[2] >> 19)&1) * JIT_F_SSE4_1;\n    if (vendor[2] == 0x6c65746e) {  /* Intel. */\n      if ((features[0] & 0x0ff00f00) == 0x00000f00)  /* P4. */\n\tflags |= JIT_F_P4;  /* Currently unused. */\n      else if ((features[0] & 0x0fff0ff0) == 0x000106c0)  /* Atom. */\n\tflags |= JIT_F_LEA_AGU;\n    } else if (vendor[2] == 0x444d4163) {  /* AMD. */\n      uint32_t fam = (features[0] & 0x0ff00f00);\n      if (fam == 0x00000f00)  /* K8. */\n\tflags |= JIT_F_SPLIT_XMM;\n      if (fam >= 0x00000f00)  /* K8, K10. */\n\tflags |= JIT_F_PREFER_IMUL;\n    }\n#endif\n  }\n#ifndef LUAJIT_CPU_NOCMOV\n  if (!(flags & JIT_F_CMOV))\n    luaL_error(L, \"Ancient CPU lacks CMOV support (recompile with -DLUAJIT_CPU_NOCMOV)\");\n#endif\n#if LJ_HASJIT\n  if (!(flags & JIT_F_SSE2))\n    luaL_error(L, \"Sorry, SSE2 CPU support required for this beta release\");\n#endif\n  UNUSED(L);\n#else\n#error \"Missing CPU detection for this architecture\"\n#endif\n  return flags;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local mcode, addr, loop = jit.util.tracemc(tr) */\n", "func_signal": "LJLIB_CF(jit_util_tracemc)", "code": "{\n  Trace *T = jit_checktrace(L);\n  if (T && T->mcode != NULL) {\n    setstrV(L, L->top-1, lj_str_new(L, (const char *)T->mcode, T->szmcode));\n    setnumV(L->top++, cast_num((intptr_t)T->mcode));\n    setintV(L->top++, T->mcloop);\n    return 3;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local ins, m = jit.util.funcbc(func, pc) */\n", "func_signal": "LJLIB_CF(jit_util_funcbc)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  BCPos pc = (BCPos)lj_lib_checkint(L, 2) - 1;\n  if (pc < pt->sizebc) {\n    BCIns ins = pt->bc[pc];\n    BCOp op = bc_op(ins);\n    lua_assert(op < BC__MAX);\n    setintV(L->top, ins);\n    setintV(L->top+1, lj_bc_mode[op]);\n    L->top += 2;\n    return 2;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local k, t [, slot] = jit.util.tracek(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_tracek)", "code": "{\n  Trace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= T->nk && ref < REF_BIAS) {\n    IRIns *ir = &T->ir[ref];\n    int32_t slot = -1;\n    if (ir->o == IR_KSLOT) {\n      slot = ir->op2;\n      ir = &T->ir[ir->op1];\n    }\n    lj_ir_kvalue(L, L->top-2, ir);\n    setintV(L->top-1, (int32_t)irt_type(ir->t));\n    if (slot == -1)\n      return 2;\n    setintV(L->top++, slot);\n    return 3;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Parse optimization flag. */\n", "func_signal": "static int jitopt_flag(jit_State *J, const char *str)", "code": "{\n  const char *lst = JIT_F_OPTSTRING;\n  uint32_t opt;\n  int set = 1;\n  if (str[0] == '+') {\n    str++;\n  } else if (str[0] == '-') {\n    str++;\n    set = 0;\n  } else if (str[0] == 'n' && str[1] == 'o') {\n    str += str[2] == '-' ? 3 : 2;\n    set = 0;\n  }\n  for (opt = JIT_F_OPT_FIRST; ; opt <<= 1) {\n    size_t len = *(const uint8_t *)lst;\n    if (len == 0)\n      break;\n    if (strncmp(str, lst+1, len) == 0 && str[len] == '\\0') {\n      if (set) J->flags |= opt; else J->flags &= ~opt;\n      return 1;  /* Ok. */\n    }\n    lst += 1+len;\n  }\n  return 0;  /* No match. */\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local m, ot, op1, op2, prev = jit.util.traceir(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_traceir)", "code": "{\n  Trace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= REF_BIAS && ref < T->nins) {\n    IRIns *ir = &T->ir[ref];\n    int32_t m = lj_ir_mode[ir->o];\n    setintV(L->top-2, m);\n    setintV(L->top-1, ir->ot);\n    setintV(L->top++, (int32_t)ir->op1 - (irm_op1(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, (int32_t)ir->op2 - (irm_op2(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, ir->prev);\n    return 5;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local addr = jit.util.traceexitstub(idx) */\n", "func_signal": "LJLIB_CF(jit_util_traceexitstub)", "code": "{\n  ExitNo exitno = (ExitNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (exitno < EXITSTUBS_PER_GROUP*LJ_MAX_EXITSTUBGR) {\n    setnumV(L->top-1, cast_num((intptr_t)exitstub_addr(J, exitno)));\n    return 1;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* Initialize hotcount table. */\n", "func_signal": "static void jit_init_hotcount(jit_State *J)", "code": "{\n  HotCount start = (HotCount)J->param[JIT_P_hotloop];\n  HotCount *hotcount = J2GG(J)->hotcount;\n  uint32_t i;\n  for (i = 0; i < HOTCOUNT_SIZE; i++)\n    hotcount[i] = start;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/* local name = jit.util.funcuvname(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funcuvname)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  uint32_t idx = (uint32_t)lj_lib_checkint(L, 2);\n  if (idx < pt->sizeuvname) {\n    setstrV(L, L->top-1, pt->uvname[idx]);\n    return 1;\n  }\n  return 0;\n}", "path": "libs\\luajit\\src\\lib_jit.c", "repo_name": "ghisguth/lua-cmake-source", "stars": 7, "license": "other", "language": "c", "size": 865}
{"docstring": "/*\n * find the next leaf page if any given a chain. Assumes any exhausted leaf \n * pages at the end of the chain have been peeled off before the call.\n */\n", "func_signal": "MdbIndexPage *\nmdb_find_next_leaf(MdbHandle *mdb, MdbIndex *idx, MdbIndexChain *chain)", "code": "{\n\tMdbIndexPage *ipg, *newipg;\n\tguint32 pg;\n\tguint passed = 0;\n\n\tipg = mdb_index_read_bottom_pg(mdb, idx, chain);\n\n\t/*\n\t * If we are at the first page deep and it's not an index page then\n\t * we are simply done. (there is no page to find\n\t */\n\n\tif (mdb->pg_buf[0]==MDB_PAGE_LEAF) {\n\t\t/* Indexes can have leaves at the end that don't appear\n\t\t * in the upper tree, stash the last index found so\n\t\t * we can follow it at the end.  */\n\t\tchain->last_leaf_found = ipg->pg;\n\t\treturn ipg;\n\t}\n\n\t/*\n\t * apply sargs here, currently we don't\n\t */\n\tdo {\n\t\tipg->len = 0;\n\t\t//printf(\"finding next on pg %lu\\n\", ipg->pg);\n\t\tif (!mdb_index_find_next_on_page(mdb, ipg)) {\n\t\t\t//printf(\"find_next_on_page returned 0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpg = mdb_get_int32_msb(mdb->pg_buf, ipg->offset + ipg->len - 3) >> 8;\n\t\t//printf(\"Looking at pg %lu at %lu %d\\n\", pg, ipg->offset, ipg->len);\n\t\tipg->offset += ipg->len;\n\n\t\t/*\n\t\t * add to the chain and call this function\n\t\t * recursively.\n\t\t */\n\t\tnewipg = mdb_chain_add_page(mdb, chain, pg);\n\t\tnewipg = mdb_find_next_leaf(mdb, idx, chain);\n\t\t//printf(\"returning pg %lu\\n\",newipg->pg);\n\t\treturn newipg;\n\t} while (!passed);\n\t/* no more pages */\n\treturn NULL;\n\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_clone_handle:\n * @mdb: Handle to open MDB database file\n *\n * Clones an existing database handle.  Cloned handle shares the file descriptor\n * but has its own page buffer, page position, and similar internal variables.\n *\n * Return value: new handle to the database.\n */\n", "func_signal": "MdbHandle *mdb_clone_handle(MdbHandle *mdb)", "code": "{\n\tMdbHandle *newmdb;\n\tMdbCatalogEntry *entry, *data;\n\tunsigned int i;\n\n\tnewmdb = (MdbHandle *) g_memdup(mdb, sizeof(MdbHandle));\n\tnewmdb->stats = NULL;\n\tnewmdb->catalog = g_ptr_array_new();\n\tfor (i=0;i<mdb->num_catalog;i++) {\n\t\tentry = g_ptr_array_index(mdb->catalog,i);\n\t\tdata = g_memdup(entry,sizeof(MdbCatalogEntry));\n\t\tg_ptr_array_add(newmdb->catalog, data);\n\t}\n\tmdb->backend_name = NULL;\n\tif (mdb->f) {\n\t\tmdb->f->refs++;\n\t}\n\tmdb_iconv_init(mdb);\n\n\treturn newmdb;\n}", "path": "src\\libmdb\\file.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/* functions */\n", "func_signal": "static gchar *\ngmdb_sql_get_basename(char *file_path)", "code": "{\n\tint i, len;\n\tgchar *basename;\n\n\tfor (i=strlen(file_path);i>=0 && file_path[i]!='/';i--);\n\tlen = strlen(file_path) - i + 2;\n\tbasename = g_malloc(len);\n\tif (file_path[i]=='/') {\n\t\tstrncpy(basename,&file_path[i+1],len);\n\t} else {\n\t\tstrncpy(basename,file_path,len);\n\t}\n        basename[len]='\\0';\n\n\treturn basename;\n}", "path": "src\\gmdb2\\sql.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * compute_cost tries to assign a cost to a given index using the sargs \n * available in this query.\n *\n * Indexes with no matching sargs are assigned 0\n * Unique indexes are preferred over non-uniques\n * Operator preference is equal, like, isnull, others \n */\n", "func_signal": "int mdb_index_compute_cost(MdbTableDef *table, MdbIndex *idx)", "code": "{\n\tunsigned int i;\n\tMdbColumn *col;\n\tMdbSarg *sarg = NULL;\n\tint not_all_equal = 0;\n\n\tif (!idx->num_keys) return 0;\n\tif (idx->num_keys > 1) {\n\t\tfor (i=0;i<idx->num_keys;i++) {\n\t\t\tcol=g_ptr_array_index(table->columns,idx->key_col_num[i]-1);\n\t\t\tif (col->sargs) sarg = g_ptr_array_index (col->sargs, 0);\n\t\t\tif (!sarg || sarg->op != MDB_EQUAL) not_all_equal++;\n\t\t}\n\t}\n\n\tcol=g_ptr_array_index(table->columns,idx->key_col_num[0]-1);\n\t/* \n\t * if this is the first key column and there are no sargs,\n\t * then this index is useless.\n\t */\n\tif (!col->num_sargs) return 0;\n\n\tsarg = g_ptr_array_index (col->sargs, 0);\n\n\t/*\n\t * a like with a wild card first is useless as a sarg */\n\tif (sarg->op == MDB_LIKE && sarg->value.s[0]=='%')\n\t\treturn 0;\n\n\t/*\n\t * this needs a lot of tweaking.\n\t */\n\tif (idx->flags & MDB_IDX_UNIQUE) {\n\t\tif (idx->num_keys == 1) {\n\t\t\t//printf(\"op is %d\\n\", sarg->op);\n\t\t\tswitch (sarg->op) {\n\t\t\t\tcase MDB_EQUAL:\n\t\t\t\t\treturn 1; break;\n\t\t\t\tcase MDB_LIKE:\n\t\t\t\t\treturn 4; break;\n\t\t\t\tcase MDB_ISNULL:\n\t\t\t\t\treturn 12; break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 8; break;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (sarg->op) {\n\t\t\t\tcase MDB_EQUAL:\n\t\t\t\t\tif (not_all_equal) return 2; \n\t\t\t\t\telse return 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MDB_LIKE:\n\t\t\t\t\treturn 6; break;\n\t\t\t\tcase MDB_ISNULL:\n\t\t\t\t\treturn 12; break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 9; break;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (idx->num_keys == 1) {\n\t\t\tswitch (sarg->op) {\n\t\t\t\tcase MDB_EQUAL:\n\t\t\t\t\treturn 2; break;\n\t\t\t\tcase MDB_LIKE:\n\t\t\t\t\treturn 5; break;\n\t\t\t\tcase MDB_ISNULL:\n\t\t\t\t\treturn 12; break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 10; break;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (sarg->op) {\n\t\t\t\tcase MDB_EQUAL:\n\t\t\t\t\tif (not_all_equal) return 3; \n\t\t\t\t\telse return 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MDB_LIKE:\n\t\t\t\t\treturn 7; break;\n\t\t\t\tcase MDB_ISNULL:\n\t\t\t\t\treturn 12; break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 11; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * choose_index runs mdb_index_compute_cost for each available index and picks\n * the best.\n *\n * Returns strategy to use (table scan, or index scan)\n */\n", "func_signal": "MdbStrategy \nmdb_choose_index(MdbTableDef *table, int *choice)", "code": "{\n\tunsigned int i;\n\tMdbIndex *idx;\n\tint cost = 0;\n\tint least = 99;\n\n\t*choice = -1;\n\tfor (i=0;i<table->num_idxs;i++) {\n\t\tidx = g_ptr_array_index (table->indices, i);\n\t\tcost = mdb_index_compute_cost(table, idx);\n\t\t//printf(\"cost for %s is %d\\n\", idx->name, cost);\n\t\tif (cost && cost < least) {\n\t\t\tleast = cost;\n\t\t\t*choice = i;\n\t\t}\n\t}\n\t/* and the winner is: *choice */\n\tif (least==99) return MDB_TABLE_SCAN;\n\treturn MDB_INDEX_SCAN;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_remove_backends\n *\n * Removes all entries from and destroys the mdb_backends hash.\n */\n", "func_signal": "void mdb_remove_backends()", "code": "{\n\tg_hash_table_foreach_remove(mdb_backends, mdb_drop_backend, NULL);\n\tg_hash_table_destroy(mdb_backends);\n}", "path": "src\\libmdb\\backend.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * unpack the pages bitmap\n */\n", "func_signal": "int\nmdb_index_unpack_bitmap(MdbHandle *mdb, MdbIndexPage *ipg)", "code": "{\n\tint mask_bit = 0;\n\tint mask_pos = 0x16;\n\tint mask_byte;\n\tint start = 0xf8;\n\tint elem = 0;\n\tint len = 0;\n\n\tipg->idx_starts[elem++]=start;\n\n\t//fprintf(stdout, \"Unpacking index page %lu\\n\", ipg->pg);\n\tdo {\n\t\tlen = 0;\n\t\tdo {\n\t\t\tmask_bit++;\n\t\t\tif (mask_bit==8) {\n\t\t\t\tmask_bit=0;\n\t\t\t\tmask_pos++;\n\t\t\t}\n\t\t\tmask_byte = mdb->pg_buf[mask_pos];\n\t\t\tlen++;\n\t\t} while (mask_pos <= 0xf8 && !((1 << mask_bit) & mask_byte));\n\t\t//fprintf(stdout, \"%d %d %d %d\\n\", mask_pos, mask_bit, mask_byte, len);\n\n\t\tstart += len;\n\t\tif (mask_pos < 0xf8) ipg->idx_starts[elem++]=start;\n\n\t} while (mask_pos < 0xf8);\n\n\t/* if we zero the next element, so we don't pick up the last pages starts*/\n\tipg->idx_starts[elem]=0;\n\n\treturn elem;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_find_file:\n * @filename: path to MDB (database) file\n *\n * Finds and returns the absolute path to an MDB file.  Function will first try\n * to fstat file as passed, then search through the $MDBPATH if not found.\n *\n * Return value: gchar pointer to absolute path. Caller is responsible for\n * freeing.\n **/\n", "func_signal": "static char *mdb_find_file(const char *file_name)", "code": "{\n\tstruct stat status;\n\tgchar *mdbpath, **dir, *tmpfname;\n\tunsigned int i = 0;\n\n\t/* try the provided file name first */\n\tif (!stat(file_name, &status)) {\n\t\treturn g_strdup(file_name);\n\t}\n\t\n\t/* Now pull apart $MDBPATH and try those */\n\tmdbpath = (gchar *) getenv(\"MDBPATH\");\n\t/* no path, can't find file */\n\tif (!mdbpath || !strlen(mdbpath)) return NULL;\n\n\tdir = g_strsplit(mdbpath, \":\", 0); \n\twhile (dir[i]) {\n\t\tif (!strlen(dir[i])) continue;\n\t\ttmpfname = g_strconcat(dir[i++], \"/\", file_name, NULL);\n\t\tif (!stat(tmpfname, &status)) {\n\t\t\tg_strfreev(dir);\n\t\t\treturn tmpfname;\n\t\t}\n\t\tg_free(tmpfname);\n\t}\n\tg_strfreev(dir);\n\treturn NULL;\n}", "path": "src\\libmdb\\file.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_init_backends\n *\n * Initializes the mdb_backends hash and loads the builtin backends.\n * Use mdb_remove_backends() to destroy this hash when done.\n */\n", "func_signal": "void mdb_init_backends()", "code": "{\n\tmdb_backends = g_hash_table_new(g_str_hash, g_str_equal);\n\n\tmdb_register_backend(mdb_access_types, \"access\");\n\tmdb_register_backend(mdb_sybase_types, \"sybase\");\n\tmdb_register_backend(mdb_oracle_types, \"oracle\");\n\tmdb_register_backend(mdb_postgres_types, \"postgres\");\n\tmdb_register_backend(mdb_mysql_types, \"mysql\");\n}", "path": "src\\libmdb\\backend.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * find the next entry on a page (either index or leaf). Uses state information\n * stored in the MdbIndexPage across calls.\n */\n", "func_signal": "int\nmdb_index_find_next_on_page(MdbHandle *mdb, MdbIndexPage *ipg)", "code": "{\n\tif (!ipg->pg) return 0;\n\n\t/* if this page has not been unpacked to it */\n\tif (!ipg->idx_starts[0]){\n\t\t//fprintf(stdout, \"Unpacking page %d\\n\", ipg->pg);\n\t\tmdb_index_unpack_bitmap(mdb, ipg);\n\t}\n\n\t\n\tif (ipg->idx_starts[ipg->start_pos + 1]==0) return 0; \n\tipg->len = ipg->idx_starts[ipg->start_pos+1] - ipg->idx_starts[ipg->start_pos];\n\tipg->start_pos++;\n\t//fprintf(stdout, \"Start pos %d\\n\", ipg->start_pos);\n\n\treturn ipg->len;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_open:\n * @filename: path to MDB (database) file\n * @flags: MDB_NOFLAGS for read-only, MDB_WRITABLE for read/write\n *\n * Opens an MDB file and returns an MdbHandle to it.  MDB File may be relative\n * to the current directory, a full path to the file, or relative to a \n * component of $MDBPATH.\n *\n * Return value: pointer to MdbHandle structure.\n **/\n", "func_signal": "MdbHandle *mdb_open(const char *filename, MdbFileFlags flags)", "code": "{\n\tMdbHandle *mdb;\n\tint open_flags;\n\n\tmdb = (MdbHandle *) g_malloc0(sizeof(MdbHandle));\n\tmdb_set_default_backend(mdb, \"access\");\n#ifdef HAVE_ICONV\n\tmdb->iconv_in = (iconv_t)-1;\n\tmdb->iconv_out = (iconv_t)-1;\n#endif\n\t/* need something to bootstrap with, reassign after page 0 is read */\n\tmdb->fmt = &MdbJet3Constants;\n\tmdb->f = (MdbFile *) g_malloc0(sizeof(MdbFile));\n\tmdb->f->refs = 1;\n\tmdb->f->fd = -1;\n\tmdb->f->filename = mdb_find_file(filename);\n\tif (!mdb->f->filename) { \n\t\tfprintf(stderr, \"Can't alloc filename\\n\");\n\t\tmdb_close(mdb);\n\t\treturn NULL; \n\t}\n\tif (flags & MDB_WRITABLE) {\n\t\tmdb->f->writable = TRUE;\n\t\topen_flags = O_RDWR;\n\t} else {\n\t\topen_flags = O_RDONLY;\n\t}\n\n#ifdef _WIN32\n\topen_flags |= O_BINARY;\n#endif\n\n\tmdb->f->fd = open(mdb->f->filename, open_flags);\n\n\tif (mdb->f->fd==-1) {\n\t\tfprintf(stderr,\"Couldn't open file %s\\n\",mdb->f->filename); \n\t\tmdb_close(mdb);\n\t\treturn NULL;\n\t}\n\tif (!mdb_read_pg(mdb, 0)) {\n\t\tfprintf(stderr,\"Couldn't read first page.\\n\");\n\t\tmdb_close(mdb);\n\t\treturn NULL;\n\t}\n\tif (mdb->pg_buf[0] != 0) {\n\t\tmdb_close(mdb);\n\t\treturn NULL; \n\t}\n\tmdb->f->jet_version = mdb_get_int32(mdb->pg_buf, 0x14);\n\tif (IS_JET4(mdb)) {\n\t\tmdb->fmt = &MdbJet4Constants;\n\t} else if (IS_JET3(mdb)) {\n\t\tmdb->fmt = &MdbJet3Constants;\n\t} else {\n\t\tfprintf(stderr,\"Unknown Jet version.\\n\");\n\t\tmdb_close(mdb);\n\t\treturn NULL; \n\t}\n\tmdb_iconv_init(mdb);\n\n\treturn mdb;\n}", "path": "src\\libmdb\\file.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_get_relationships\n * @mdb: Handle to open MDB database file\n *\n * Generates relationships by reading the MSysRelationships table.\n *   'szColumn' contains the column name of the child table.\n *   'szObject' contains the table name of the child table.\n *   'szReferencedColumn' contains the column name of the parent table.\n *   'szReferencedObject' contains the table name of the parent table.\n *\n * Returns: a string stating that relationships are not supported for the\n *   selected backend, or a string containing SQL commands for setting up\n *   the relationship, tailored for the selected backend.  The caller is\n *   responsible for freeing this string.\n */\n", "func_signal": "char *mdb_get_relationships(MdbHandle *mdb)", "code": "{\n\tunsigned int i;\n\tgchar *text = NULL;  /* String to be returned */\n\tstatic char *bound[4];  /* Bound values */\n\tstatic MdbTableDef *table;  /* Relationships table */\n\tint backend = 0;  /* Backends: 1=oracle */\n\n\tif (strncmp(mdb->backend_name,\"oracle\",6) == 0) {\n\t\tbackend = 1;\n\t} else {\n\t\tif (is_init == 0) { /* the first time through */\n\t\t\tis_init = 1;\n\t\t\treturn (char *) g_strconcat(\n\t\t\t\t\"-- relationships are not supported for \",\n\t\t\t\tmdb->backend_name, NULL);\n\t\t} else { /* the second time through */\n\t\t\tis_init = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_init == 0) {\n\t\ttable = mdb_read_table_by_name(mdb, \"MSysRelationships\", MDB_TABLE);\n\t\tif ((!table) || (table->num_rows == 0)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmdb_read_columns(table);\n\t\tfor (i=0;i<4;i++) {\n\t\t\tbound[i] = (char *) g_malloc0(MDB_BIND_SIZE);\n\t\t}\n\t\tmdb_bind_column_by_name(table, \"szColumn\", bound[0], NULL);\n\t\tmdb_bind_column_by_name(table, \"szObject\", bound[1], NULL);\n\t\tmdb_bind_column_by_name(table, \"szReferencedColumn\", bound[2], NULL);\n\t\tmdb_bind_column_by_name(table, \"szReferencedObject\", bound[3], NULL);\n\t\tmdb_rewind_table(table);\n\n\t\tis_init = 1;\n\t}\n\telse if (table->cur_row >= table->num_rows) {  /* past the last row */\n\t\tfor (i=0;i<4;i++)\n\t\t\tg_free(bound[i]);\n\t\tis_init = 0;\n\t\treturn NULL;\n\t}\n\n\tif (!mdb_fetch_row(table)) {\n\t\tfor (i=0;i<4;i++)\n\t\t\tg_free(bound[i]);\n\t\tis_init = 0;\n\t\treturn NULL;\n\t}\n\n\tswitch (backend) {\n\t  case 1:  /* oracle */\n\t\ttext = g_strconcat(\"alter table \", bound[1],\n\t\t\t\" add constraint \", bound[3], \"_\", bound[1],\n\t\t\t\" foreign key (\", bound[0], \")\"\n\t\t\t\" references \", bound[3], \"(\", bound[2], \")\", NULL);\n\t\tbreak;\n\t}\n\n\treturn (char *)text;\n}", "path": "src\\libmdb\\backend.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/* called when the user closes the window */\n", "func_signal": "static gint\ndelete_event(GtkWidget *widget, GdkEvent *event, gpointer data)", "code": "{\n\t/* signal the main loop to quit */\n\tgtk_main_quit();\n\t/* return FALSE to continue closing the window */\n\treturn FALSE;\n}", "path": "src\\gmdb2\\main2.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * unwind the stack and search for new leaf node\n */\n", "func_signal": "MdbIndexPage *\nmdb_index_unwind(MdbHandle *mdb, MdbIndex *idx, MdbIndexChain *chain)", "code": "{\n\tMdbIndexPage *ipg;\n\n\t//printf(\"page %lu finished\\n\",ipg->pg);\n\tif (chain->cur_depth==1) {\n\t\t//printf(\"cur_depth == 1 we're out\\n\");\n\t\treturn NULL;\n\t}\n\t/* \n\t* unwind the stack until we find something or reach \n\t* the top.\n\t*/\n\tipg = NULL;\n\twhile (chain->cur_depth>1 && ipg==NULL) {\n\t\t//printf(\"chain depth %d\\n\", chain->cur_depth);\n\t\tchain->cur_depth--;\n\t\tipg = mdb_find_next_leaf(mdb, idx, chain);\n\t\tif (ipg) mdb_index_find_next_on_page(mdb, ipg);\n\t}\n\tif (chain->cur_depth==1) {\n\t\t//printf(\"last leaf %lu\\n\", chain->last_leaf_found);\n\t\treturn NULL;\n\t}\n\treturn ipg;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * pack the pages bitmap\n */\n", "func_signal": "int\nmdb_index_pack_bitmap(MdbHandle *mdb, MdbIndexPage *ipg)", "code": "{\n\tint mask_bit = 0;\n\tint mask_pos = 0x16;\n\tint mask_byte = 0;\n\tint elem = 0;\n\tint len, start, i;\n\n\tstart = ipg->idx_starts[elem++];\n\n\twhile (start) {\n\t\t//fprintf(stdout, \"elem %d is %d\\n\", elem, ipg->idx_starts[elem]);\n\t\tlen = ipg->idx_starts[elem] - start;\n\t\t//fprintf(stdout, \"len is %d\\n\", len);\n\t\tfor (i=0; i < len; i++) {\n\t\t\tmask_bit++;\n\t\t\tif (mask_bit==8) {\n\t\t\t\tmask_bit=0;\n\t\t\t\tmdb->pg_buf[mask_pos++] = mask_byte;\n\t\t\t\tmask_byte = 0;\n\t\t\t}\n\t\t\t/* upon reaching the len, set the bit */\n\t\t}\n\t\tmask_byte = (1 << mask_bit) | mask_byte;\n\t\t//fprintf(stdout, \"mask byte is %02x at %d\\n\", mask_byte, mask_pos);\n\t\tstart = ipg->idx_starts[elem++];\n\t}\n\t/* flush the last byte if any */\n\tmdb->pg_buf[mask_pos++] = mask_byte;\n\t/* remember to zero the rest of the bitmap */\n\tfor (i = mask_pos; i < 0xf8; i++) {\n\t\tmdb->pg_buf[mask_pos++] = 0;\n\t}\n\treturn 0;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * XXX - FIX ME\n * This function is grossly inefficient.  It scans the entire index building \n * an IndexChain to a specific row.  We should be checking the index pages \n * for matches against the indexed fields to find the proper leaf page, but\n * getting it working first and then make it fast!\n */\n", "func_signal": "int \nmdb_index_find_row(MdbHandle *mdb, MdbIndex *idx, MdbIndexChain *chain, guint32 pg, guint16 row)", "code": "{\n\tMdbIndexPage *ipg;\n\tint passed = 0;\n\tguint32 pg_row = (pg << 8) | (row & 0xff);\n\tguint32 datapg_row;\n\n\tipg = mdb_index_read_bottom_pg(mdb, idx, chain);\n\n\tdo {\n\t\tipg->len = 0;\n\t\t/*\n\t\t * if no more rows on this leaf, try to find a new leaf\n\t\t */\n\t\tif (!mdb_index_find_next_on_page(mdb, ipg)) {\n\t\t\t/* back to top? We're done */\n\t\t\tif (chain->cur_depth==1)\n\t\t\t\treturn 0;\n\n\t\t\t/* \n\t\t\t * unwind the stack until we find something or reach \n\t\t\t * the top.\n\t\t\t */\n\t\t\twhile (chain->cur_depth>1) {\n\t\t\t\tchain->cur_depth--;\n\t\t\t\tif (!(ipg = mdb_find_next_leaf(mdb, idx, chain)))\n\t\t\t\t\treturn 0;\n\t\t\t\tmdb_index_find_next_on_page(mdb, ipg);\n\t\t\t}\n\t\t\tif (chain->cur_depth==1)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* test row and pg */\n\t\tdatapg_row = mdb_get_int32_msb(mdb->pg_buf, ipg->offset + ipg->len - 4);\n\t\tif (pg_row == datapg_row) {\n\t\t\tpassed = 1;\n\t\t}\n\t\tipg->offset += ipg->len;\n\t} while (!passed);\n\n\t/* index chain from root to leaf should now be in \"chain\" */\n\treturn 1;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/**\n * mdb_close:\n * @mdb: Handle to open MDB database file\n *\n * Dereferences MDB file, closes if reference count is 0, and destroys handle.\n *\n **/\n", "func_signal": "void \nmdb_close(MdbHandle *mdb)", "code": "{\n\tif (!mdb) return;\t\n\tmdb_free_catalog(mdb);\n\tg_free(mdb->stats);\n\tg_free(mdb->backend_name);\n\n\tif (mdb->f) {\n\t\tif (mdb->f->refs > 1) {\n\t\t\tmdb->f->refs--;\n\t\t} else {\n\t\t\tif (mdb->f->fd != -1) close(mdb->f->fd);\n\t\t\tg_free(mdb->f->filename);\n\t\t\tg_free(mdb->f);\n\t\t}\n\t}\n\n\tmdb_iconv_close(mdb);\n\n\tg_free(mdb);\n}", "path": "src\\libmdb\\file.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * returns the bottom page of the IndexChain, if IndexChain is empty it \n * initializes it by reading idx->first_pg (the root page)\n */\n", "func_signal": "MdbIndexPage *\nmdb_index_read_bottom_pg(MdbHandle *mdb, MdbIndex *idx, MdbIndexChain *chain)", "code": "{\n\tMdbIndexPage *ipg;\n\n\t/*\n\t * if it's new use the root index page (idx->first_pg)\n\t */\n\tif (!chain->cur_depth) {\n\t\tipg = &(chain->pages[0]);\n\t\tmdb_index_page_init(ipg);\n\t\tchain->cur_depth = 1;\n\t\tipg->pg = idx->first_pg;\n\t\tif (!(ipg = mdb_find_next_leaf(mdb, idx, chain)))\n\t\t\treturn 0;\n\t} else {\n\t\tipg = &(chain->pages[chain->cur_depth - 1]);\n\t\tipg->len = 0; \n\t}\n\n\tmdb_read_pg(mdb, ipg->pg);\n\n\treturn ipg;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/* \n** mdb_read a wrapper for read that bails if anything is wrong \n*/\n", "func_signal": "ssize_t mdb_read_pg(MdbHandle *mdb, unsigned long pg)", "code": "{\n\tssize_t len;\n\n\tif (pg && mdb->cur_pg == pg) return mdb->fmt->pg_size;\n\n\tlen = _mdb_read_pg(mdb, mdb->pg_buf, pg);\n\t//fprintf(stderr, \"read page %d type %02x\\n\", pg, mdb->pg_buf[0]);\n\tmdb->cur_pg = pg;\n\t/* kan - reset the cur_pos on a new page read */\n\tmdb->cur_pos = 0; /* kan */\n\treturn len;\n}", "path": "src\\libmdb\\file.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/*\n * the main index function.\n * caller provides an index chain which is the current traversal of index\n * pages from the root page to the leaf.  Initially passed as blank, \n * mdb_index_find_next will store it's state information here. Each invocation\n * then picks up where the last one left off, allowing us to scroll through\n * the index one by one.\n *\n * Sargs are applied here but also need to be applied on the whole row b/c\n * text columns may return false positives due to hashing and non-index\n * columns with sarg values can't be tested here.\n */\n", "func_signal": "int\nmdb_index_find_next(MdbHandle *mdb, MdbIndex *idx, MdbIndexChain *chain, guint32 *pg, guint16 *row)", "code": "{\n\tMdbIndexPage *ipg;\n\tint passed = 0;\n\tint idx_sz;\n\tint idx_start = 0;\n\tMdbColumn *col;\n\tguint32 pg_row;\n\n\tipg = mdb_index_read_bottom_pg(mdb, idx, chain);\n\n\t/*\n\t * loop while the sargs don't match\n\t */\n\tdo {\n\t\tipg->len = 0;\n\t\t/*\n\t\t * if no more rows on this leaf, try to find a new leaf\n\t\t */\n\t\tif (!mdb_index_find_next_on_page(mdb, ipg)) {\n\t\t\tif (!chain->clean_up_mode) {\n\t\t\t\tif (!(ipg = mdb_index_unwind(mdb, idx, chain)))\n\t\t\t\t\tchain->clean_up_mode = 1;\n\t\t\t}\n\t\t\tif (chain->clean_up_mode) {\n\t\t\t\t//fprintf(stdout,\"in cleanup mode\\n\");\n\n\t\t\t\tif (!chain->last_leaf_found) return 0;\n\t\t\t\tmdb_read_pg(mdb, chain->last_leaf_found);\n\t\t\t\tchain->last_leaf_found = mdb_get_int32(\n\t\t\t\t\tmdb->pg_buf, 0x0c);\n\t\t\t\t//printf(\"next leaf %lu\\n\", chain->last_leaf_found);\n\t\t\t\tmdb_read_pg(mdb, chain->last_leaf_found);\n\t\t\t\t/* reuse the chain for cleanup mode */\n\t\t\t\tchain->cur_depth = 1;\n\t\t\t\tipg = &chain->pages[0];\n\t\t\t\tmdb_index_page_init(ipg);\n\t\t\t\tipg->pg = chain->last_leaf_found;\n\t\t\t\t//printf(\"next on page %d\\n\",\n\t\t\t\tif (!mdb_index_find_next_on_page(mdb, ipg))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tpg_row = mdb_get_int32_msb(mdb->pg_buf, ipg->offset + ipg->len - 4);\n\t\t*row = pg_row & 0xff;\n\t\t*pg = pg_row >> 8;\n\t\t//printf(\"row = %d pg = %lu ipg->pg = %lu offset = %lu len = %d\\n\", *row, *pg, ipg->pg, ipg->offset, ipg->len);\n\t\tcol=g_ptr_array_index(idx->table->columns,idx->key_col_num[0]-1);\n\t\tidx_sz = mdb_col_fixed_size(col);\n\t\t/* handle compressed indexes, single key indexes only? */\n\t\tif (idx->num_keys==1 && idx_sz>0 && ipg->len - 4 < idx_sz) {\n\t\t\t//printf(\"short index found\\n\");\n\t\t\t//buffer_dump(ipg->cache_value, 0, idx_sz);\n\t\t\tmemcpy(&ipg->cache_value[idx_sz - (ipg->len - 4)], &mdb->pg_buf[ipg->offset], ipg->len);\n\t\t\t//buffer_dump(ipg->cache_value, 0, idx_sz);\n\t\t} else {\n\t\t\tidx_start = ipg->offset + (ipg->len - 4 - idx_sz);\n\t\t\tmemcpy(ipg->cache_value, &mdb->pg_buf[idx_start], idx_sz);\n\t\t}\n\n\t\t//idx_start = ipg->offset + (ipg->len - 4 - idx_sz);\n\t\tpassed = mdb_index_test_sargs(mdb, idx, (char *)(ipg->cache_value), idx_sz);\n\n\t\tipg->offset += ipg->len;\n\t} while (!passed);\n\n\t//fprintf(stdout,\"len = %d pos %d\\n\", ipg->len, ipg->mask_pos);\n\t//buffer_dump(mdb->pg_buf, ipg->offset, ipg->len);\n\n\treturn ipg->len;\n}", "path": "src\\libmdb\\index.c", "repo_name": "Byclosure/mdbtools", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 1360}
{"docstring": "/** Create and write CRC-number.\n */\n", "func_signal": "unsigned int\nbit_write_CRC(Bit_Chain * dat, long unsigned int start_address,\n    unsigned int seed)", "code": "{\n  unsigned int crc;\n\n  while (dat->bit > 0)\n    bit_write_B(dat, 0);\n\n  crc = bit_ckr8(seed, &(dat->chain[start_address]), dat->byte - start_address);\n\n  bit_write_RC(dat, (unsigned char) (crc >> 8));\n  bit_write_RC(dat, (unsigned char) (crc & 0xFF));\n\n  return (crc);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/* Decompresses a system section of a 2004 DWG flie\n */\n", "func_signal": "static int\ndecompress_R2004_section(Bit_Chain* dat, char *decomp,\n                         unsigned long int comp_data_size)", "code": "{\n  int lit_length, i;\n  int comp_offset, comp_bytes;\n  unsigned char opcode1 = 0, opcode2;\n  long unsigned int start_byte = dat->byte;\n  char *src, *dst = decomp;\n\n  // length of the first sequence of uncompressed or literal data.\n  lit_length = read_literal_length(dat, &opcode1);\n\n  for (i = 0; i < lit_length; ++i)\n    *dst++ = bit_read_RC(dat);\n\n  opcode1 = 0x00;\n  while (dat->byte - start_byte < comp_data_size)\n    {\n      if (opcode1 == 0x00)\n        opcode1 = bit_read_RC(dat);\n\n      if (opcode1 >= 0x40)\n        {\n          comp_bytes = ((opcode1 & 0xF0) >> 4) - 1;\n          opcode2 = bit_read_RC(dat);\n          comp_offset = (opcode2 << 2) | ((opcode1 & 0x0C) >> 2);\n\n          if (opcode1 & 0x03)\n            {\n              lit_length = (opcode1 & 0x03);\n              opcode1  = 0x00;\n            }\n          else\n            lit_length = read_literal_length(dat, &opcode1);\n        }\n      else if (opcode1 >= 0x21 && opcode1 <= 0x3F)\n        {\n          comp_bytes  = opcode1 - 0x1E;\n          comp_offset = read_two_byte_offset(dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length(dat, &opcode1);\n        }\n      else if (opcode1 == 0x20)\n        {\n          comp_bytes  = read_long_compression_offset(dat) + 0x21;\n          comp_offset = read_two_byte_offset(dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length(dat, &opcode1);\n        }\n      else if (opcode1 >= 0x12 && opcode1 <= 0x1F)\n        {\n          comp_bytes  = (opcode1 & 0x0F) + 2;\n          comp_offset = read_two_byte_offset(dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length(dat, &opcode1);\n        }\n      else if (opcode1 == 0x10)\n        {\n          comp_bytes  = read_long_compression_offset(dat) + 9;\n          comp_offset = read_two_byte_offset(dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length(dat, &opcode1);\n        }\n      else if (opcode1 == 0x11)\n          break;     // Terminates the input stream, everything is ok!\n      else\n          return 1;  // error in input stream\n\n      //LOG_TRACE(\"got compressed data %d\\n\",comp_bytes)\n      // copy \"compressed data\"\n      src = dst - comp_offset - 1;\n      assert(src > decomp);\n      for (i = 0; i < comp_bytes; ++i)\n        *dst++ = *src++;\n\n      // copy \"literal data\"\n      //LOG_TRACE(\"got literal data %d\\n\",lit_length)\n      for (i = 0; i < lit_length; ++i)\n        *dst++ = bit_read_RC(dat);\n    }\n\n  return 0;  // Success\n}", "path": "src\\decode.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write bit-double with default.\n */\n", "func_signal": "void\nbit_write_DD(Bit_Chain * dat, double value, double default_value)", "code": "{\n  unsigned char *uchar_value;\n\n  unsigned int *uint_value;\n  unsigned int *uint_default;\n\n  if (value == default_value)\n    bit_write_BB(dat, 0);\n  else\n    {\n      uchar_value = (unsigned char *) &value;\n      uint_value = (unsigned int *) &value;\n      uint_default = (unsigned int *) &default_value;\n      if (uint_value[0] == uint_default[0])\n        {\n          if (uint_value[1] != uint_default[1])\n            {\n              bit_write_BB(dat, 2);\n              bit_write_RC(dat, uchar_value[4]);\n              bit_write_RC(dat, uchar_value[5]);\n              bit_write_RC(dat, uchar_value[0]);\n              bit_write_RC(dat, uchar_value[1]);\n              bit_write_RC(dat, uchar_value[2]);\n              bit_write_RC(dat, uchar_value[3]);\n            }\n          else\n            {\n              bit_write_BB(dat, 1);\n              bit_write_RC(dat, uchar_value[0]);\n              bit_write_RC(dat, uchar_value[1]);\n              bit_write_RC(dat, uchar_value[2]);\n              bit_write_RC(dat, uchar_value[3]);\n            }\n        }\n      else\n        {\n          bit_write_BB(dat, 0);\n          bit_write_RD(dat, value);\n        }\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/* R2004 Literal Length\n */\n", "func_signal": "static int\nread_literal_length(Bit_Chain* dat, unsigned char *opcode)", "code": "{\n  int total = 0;\n  unsigned char byte = bit_read_RC(dat);\n\n  *opcode = 0x00;\n\n  if (byte >= 0x01 && byte <= 0x0F)\n    return byte + 3;\n  else if (byte == 0)\n    {\n      total = 0x0F;\n      while ((byte = bit_read_RC(dat)) == 0x00)\n        {\n          total += 0xFF;\n        }\n      return total + byte + 3;\n    }\n  else if (byte & 0xF0)\n    *opcode = byte;\n\n  return 0;\n}", "path": "src\\decode.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write 1 bit.\n */\n", "func_signal": "void\nbit_write_B(Bit_Chain * dat, unsigned char value)", "code": "{\n  if (dat->byte >= dat->size - 1)\n    bit_chain_alloc(dat);\n\n  if (value)\n    dat->chain[dat->byte] |= 0x80 >> dat->bit;\n  else\n    dat->chain[dat->byte] &= ~(0x80 >> dat->bit);\n\n  bit_advance_position(dat, 1);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/* Read R2004 Section Info\n */\n", "func_signal": "static void\nread_R2004_section_info(Bit_Chain* dat, Dwg_Data *dwg,\n                        unsigned long int comp_data_size,\n                        unsigned long int decomp_data_size)", "code": "{\n  char *decomp, *ptr;\n  int i, j;\n  int section_number;\n  int data_size;\n  int start_offset;\n  int unknown;\n\n  decomp = (char *)malloc(decomp_data_size * sizeof(char));\n  if (decomp == 0)\n    return;   // No memory\n\n  decompress_R2004_section(dat, decomp, comp_data_size);\n\n  memcpy(&dwg->header.num_descriptions, decomp, 4);\n  dwg->header.section_info = (Dwg_Section_Info*)\n    malloc(sizeof(Dwg_Section_Info) * dwg->header.num_descriptions);\n\n  LOG_TRACE(\"\\n#### 2004 Section Info fields ####\\n\")\n  LOG_TRACE(\"NumDescriptions: %d\\n\", *((int*)decomp))\n  LOG_TRACE(\"0x02:            %x\\n\", *((int*)decomp + 1))\n  LOG_TRACE(\"0x00007400:      %x\\n\", *((int*)decomp + 2))\n  LOG_TRACE(\"0x00:            %x\\n\", *((int*)decomp + 3))\n  LOG_TRACE(\"Unknown:         %x\\n\", *((int*)decomp + 4))\n\n  ptr = decomp + 20;\n  for (i = 0; i < dwg->header.num_descriptions; ++i)\n    {\n      dwg->header.section_info[i].size            = *((int*)ptr);\n      dwg->header.section_info[i].unknown1 \t      = *((int*)ptr + 1);\n      dwg->header.section_info[i].num_sections    = *((int*)ptr + 2);\n      dwg->header.section_info[i].max_decomp_size = *((int*)ptr + 3);\n      dwg->header.section_info[i].unknown2        = *((int*)ptr + 4);\n      dwg->header.section_info[i].compressed      = *((int*)ptr + 5);\n      dwg->header.section_info[i].type            = *((int*)ptr + 6);\n      dwg->header.section_info[i].encrypted       = *((int*)ptr + 7);\n      ptr += 32;\n      memcpy(dwg->header.section_info[i].name, ptr, 64);\n      ptr += 64;\n\n      LOG_TRACE(\"\\nSection Info description fields\\n\")\n      LOG_TRACE(\"Size:                  %d\",\n           (int) dwg->header.section_info[i].size)\n      LOG_TRACE(\"Unknown:               %d\\n\",\n           (int) dwg->header.section_info[i].unknown1)\n      LOG_TRACE(\"Number of sections:    %d\\n\",\n           (int) dwg->header.section_info[i].num_sections)\n      LOG_TRACE(\"Max decompressed size: %d\\n\",\n           (int) dwg->header.section_info[i].max_decomp_size)\n      LOG_TRACE(\"Unknown:               %d\\n\",\n           (int) dwg->header.section_info[i].unknown2)\n      LOG_TRACE(\"Compressed (0x02):     %x\\n\",\n           (unsigned int) dwg->header.section_info[i].compressed)\n      LOG_TRACE(\"Section Type:          %d\\n\",\n           (int) dwg->header.section_info[i].type)\n      LOG_TRACE(\"Encrypted:             %d\\n\",\n           (int) dwg->header.section_info[i].encrypted)\n      LOG_TRACE(\"SectionName:           %s\\n\\n\",\n            dwg->header.section_info[i].name)\n\n      dwg->header.section_info[i].sections = (Dwg_Section**)\n        malloc(dwg->header.section_info[i].num_sections * sizeof(Dwg_Section*));\n\n      if (dwg->header.section_info[i].num_sections < 10000)\n\t{\n\t  LOG_INFO(\"section count %ld in area %d\\n\",dwg->header.section_info[i].num_sections,i)\n\n\t  for (j = 0; j < dwg->header.section_info[i].num_sections; j++)\n\t    {\n\t      section_number = *((int*)ptr);      // Index into SectionMap\n\t      data_size      = *((int*)ptr + 1);\n\t      start_offset   = *((int*)ptr + 2);\n\t      unknown        = *((int*)ptr + 3);  // high 32 bits of 64-bit start offset?\n\t      ptr += 16;\n\n\t      dwg->header.section_info[i].sections[j] = find_section(dwg, section_number);\n\n\t      LOG_TRACE(\"Section Number: %d\\n\", section_number)\n\t      LOG_TRACE(\"Data size:      %d\\n\", data_size)\n\t      LOG_TRACE(\"Start offset:   %x\\n\", start_offset)\n\t      LOG_TRACE(\"Unknown:        %d\\n\", unknown)\n\t    }\n\t}// sanity check\n      else\n\t{\n\t  LOG_ERROR(\"section count %ld in area %d too high! skipping\\n\",dwg->header.section_info[i].num_sections,i)\n\t}\n    }\n  free(decomp);\n}", "path": "src\\decode.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write handle-references.\n */\n", "func_signal": "void\nbit_write_H(Bit_Chain * dat, Dwg_Handle * handle)", "code": "{\n  int i, j;\n  unsigned char *val;\n  unsigned char code_counter;\n\n  if (handle->value == 0)\n    {\n      bit_write_RC(dat, (handle->code << 4));\n      return;\n    }\n\n  val = (unsigned char *) &handle->value;\n  for (i = 3; i >= 0; i--)\n    if (val[i])\n      break;\n\n  code_counter = handle->code << 4;\n  code_counter |= i + 1;\n\n  bit_write_RC(dat, code_counter);\n\n  for (; i >= 0; i--)\n    bit_write_RC(dat, val[i]);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read bit-double with default.\n */\n", "func_signal": "BITCODE_DD\nbit_read_DD(Bit_Chain * dat, double default_value)", "code": "{\n  unsigned char two_bit_code;\n  unsigned char *uchar_result;\n\n  two_bit_code = bit_read_BB(dat);\n  if (two_bit_code == 0)\n    return default_value;\n  if (two_bit_code == 3)\n    return (bit_read_RD(dat));\n  if (two_bit_code == 2)\n    {\n      uchar_result = (unsigned char *) &default_value;\n      uchar_result[4] = bit_read_RC(dat);\n      uchar_result[5] = bit_read_RC(dat);\n      uchar_result[0] = bit_read_RC(dat);\n      uchar_result[1] = bit_read_RC(dat);\n      uchar_result[2] = bit_read_RC(dat);\n      uchar_result[3] = bit_read_RC(dat);\n\n      return default_value;\n    }\n  else /* if (two_bit_code == 1) */\n    {\n      uchar_result = (unsigned char *) &default_value;\n      uchar_result[0] = bit_read_RC(dat);\n      uchar_result[1] = bit_read_RC(dat);\n      uchar_result[2] = bit_read_RC(dat);\n      uchar_result[3] = bit_read_RC(dat);\n\n      return default_value;\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/* Read R2004 Section Map\n * The Section Map is a vector of number, size, and address triples used\n * to locate the sections in the file.\n */\n", "func_signal": "static void\nread_R2004_section_map(Bit_Chain* dat, Dwg_Data * dwg,\n                       unsigned long int comp_data_size,\n                       unsigned long int decomp_data_size)", "code": "{\n  char *decomp, *ptr;\n  int i;\n  int section_address;\n  int bytes_remaining;\n\n  dwg->header.num_sections = 0;\n  dwg->header.section = 0;\n\n  // allocate memory to hold decompressed data\n  decomp = (char *)malloc(decomp_data_size * sizeof(char));\n  if (decomp == 0)\n    return;   // No memory\n\n  decompress_R2004_section(dat, decomp, comp_data_size);\n\n  LOG_TRACE(\"\\n#### 2004 Section Map fields ####\\n\")\n\n  section_address = 0x100;  // starting address\n\ti = 0;\n\tbytes_remaining = decomp_data_size;\n\tptr = decomp;\n\tdwg->header.num_sections = 0;\n\n\twhile(bytes_remaining)\n\t\t{\n\t\t\tif (dwg->header.num_sections==0)\n\t\t\t\tdwg->header.section = (Dwg_Section*) malloc(sizeof(Dwg_Section));\n\t\t\telse\n\t\t\t\tdwg->header.section = (Dwg_Section*) realloc(dwg->header.section,\n          sizeof(Dwg_Section) * (dwg->header.num_sections+1));\n\n\t\t  dwg->header.section[i].number  = *((int*)ptr);\n\t\t  dwg->header.section[i].size    = *((int*)ptr+1);\n\t\t  dwg->header.section[i].address = section_address;\n\t\t  section_address += dwg->header.section[i].size;\n\t\t\tbytes_remaining -= 8;\n\t\t\tptr+=8;\n\n\t\t  LOG_TRACE(\"SectionNumber: %d\\n\",   dwg->header.section[i].number)\n\t\t  LOG_TRACE(\"SectionSize:   %x\\n\",   dwg->header.section[i].size)\n\t\t  LOG_TRACE(\"SectionAddr:   %x\\n\", dwg->header.section[i].address)\n\n\t\t\tif (dwg->header.section[i].number<0)\n\t\t\t\t{\n\t\t\t    dwg->header.section[i].parent  = *((int*)ptr);\n\t\t\t    dwg->header.section[i].left  = *((int*)ptr+1);\n\t\t\t    dwg->header.section[i].right  = *((int*)ptr+2);\n\t\t\t    dwg->header.section[i].x00  = *((int*)ptr+3);\n\t\t\t\t\tbytes_remaining -= 16;\n\t\t\t\t\tptr+=16;\n\n                            LOG_TRACE(\"Parent: %d\\n\",   (int)dwg->header.section[i].parent)\n                            LOG_TRACE(\"Left: %d\\n\",   (int)dwg->header.section[i].left)\n                            LOG_TRACE(\"Right: %d\\n\",   (int)dwg->header.section[i].right)\n                            LOG_TRACE(\"0x00: %d\\n\",   (int)dwg->header.section[i].x00)\n                            }\n\n\t\t\tdwg->header.num_sections++;\n\t\t\ti++;\n\t\t}\n  free(decomp);\n}", "path": "src\\decode.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write 1 bitlong according to normal order\n */\n", "func_signal": "void\nbit_write_L(Bit_Chain * dat, long unsigned int value)", "code": "{\n  unsigned char *btk;\n\n  btk = (unsigned char *) value;\n  bit_write_RC(dat, btk[3]);\n  bit_write_RC(dat, btk[2]);\n  bit_write_RC(dat, btk[1]);\n  bit_write_RC(dat, btk[0]);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read handle-references.\n */\n", "func_signal": "int\nbit_read_H(Bit_Chain * dat, Dwg_Handle * handle)", "code": "{\n  unsigned char *val;\n  int i;\n\n  handle->code = bit_read_RC(dat);\n  handle->size = handle->code & 0x0f;\n  handle->code = (handle->code & 0xf0) >> 4;\n\n  handle->value = 0;\n  if (handle->size > 4)\n    {\n      LOG_ERROR(\n          \"handle-reference is longer than 4 bytes: %i.%i.%lu\",\n          handle->code, handle->size, handle->value)\n      handle->size = 0;\n      return (-1);\n    }\n\n  val = (unsigned char *) &handle->value;\n  for (i = handle->size - 1; i >= 0; i--)\n    val[i] = bit_read_RC(dat);\n\n  return (0);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/*--------------------------------------------------------------------------------\n * Private functions\n */\n", "func_signal": "static int\ndwg_decode_entity(Bit_Chain * dat, Dwg_Object_Entity * ent)", "code": "{\n  unsigned int i;\n  unsigned int size;\n  int error = 2;\n\n  SINCE(R_2000)\n    {\n      ent->bitsize = bit_read_RL(dat);\n    }\n\n  error = bit_read_H(dat, &(ent->object->handle));\n  if (error)\n    {\n      LOG_ERROR(\n          \"dwg_decode_entity:\\tError in object handle! Current Bit_Chain address: 0x%0x\\n\",\n          (unsigned int) dat->byte)\n      ent->bitsize = 0;\n      ent->extended_size = 0;\n      ent->picture_exists = 0;\n      ent->num_handles = 0;\n      return 0;\n    }\n\n  ent->extended_size = 0;\n  while (size = bit_read_BS(dat))\n    {\n      LOG_TRACE(\"EED size: %lu\\n\", (long unsigned int)size)\n      if (size > 10210)\n        {\n          LOG_ERROR(\n              \"dwg_decode_entity: Absurd! Extended object data size: %lu. Object: %lu (handle).\\n\",\n              (long unsigned int) size, ent->object->handle.value)\n          ent->bitsize = 0;\n          ent->extended_size = 0;\n          ent->picture_exists = 0;\n          ent->num_handles = 0;\n          //XXX\n          return -1;\n          //break;\n        }\n      if (ent->extended_size == 0)\n        {\n          ent->extended = (char *)malloc(size);\n          ent->extended_size = size;\n        }\n      else\n        {\n          ent->extended_size += size;\n          ent->extended = (char *)realloc(ent->extended, ent->extended_size);\n        }\n      error = bit_read_H(dat, &ent->extended_handle);\n      if (error)\n        LOG_ERROR(\"Error reading extended handle!\\n\");\n      for (i = ent->extended_size - size; i < ent->extended_size; i++)\n        ent->extended[i] = bit_read_RC(dat);\n    }\n  ent->picture_exists = bit_read_B(dat);\n  if (ent->picture_exists)\n    {\n      ent->picture_size = bit_read_RL(dat);\n      if (ent->picture_size < 210210)\n        {\n          ent->picture = (char *)malloc(ent->picture_size);\n          for (i = 0; i < ent->picture_size; i++)\n            ent->picture[i] = bit_read_RC(dat);\n        }\n      else\n        {\n          LOG_ERROR(\n              \"dwg_decode_entity:  Absurd! Picture-size: %lu kB. Object: %lu (handle).\\n\",\n              ent->picture_size / 1000, ent->object->handle.value)\n          bit_advance_position(dat, -(4 * 8 + 1));\n        }\n    }\n\n  VERSIONS(R_13,R_14)\n    {\n      ent->bitsize = bit_read_RL(dat);\n    }\n\n  ent->entity_mode = bit_read_BB(dat);\n  ent->num_reactors = bit_read_BL(dat);\n\n  SINCE(R_2004)\n    {\n      ent->xdic_missing_flag = bit_read_B(dat);\n    }\n\n  VERSIONS(R_13,R_14)\n    {\n      ent->isbylayerlt = bit_read_B(dat);\n    }\n\n  ent->nolinks = bit_read_B(dat);\n\n  SINCE(R_2004)\n    {\n      char flag;\n      unsigned char index;\n\n      if (ent->nolinks == 0)\n        {\n          flag = bit_read_B(dat);\n\n          if (flag == 1)\n            index = bit_read_RC(dat);  // color index\n          else\n            {\n              unsigned char c1, c2, c3, c4, c5, c6;\n              char *name=0;\n\n              c1 = bit_read_RC(dat);\n              c2 = bit_read_RC(dat);\n\n              //TODO: verify this\n              // if c2 == 0x80 it's a true type color value and\n              // if c2 == 0xC0 it's a color book color\n\n              if (c2 == 0x80)\n                {\n                  c3 = bit_read_RC(dat);  // rgb color\n                  c4 = bit_read_RC(dat);\n                  c5 = bit_read_RC(dat);\n                  c6 = bit_read_RC(dat);\n\n                  name  = (char*) bit_read_TV(dat);\n                }\n            }\n        }\n      else\n        {\n          char color = bit_read_B(dat);\n        }\n    }\n  OTHER_VERSIONS\n    bit_read_CMC(dat, &ent->color);\n\n  ent->linetype_scale = bit_read_BD(dat);\n\n  SINCE(R_2000)\n    {\n      ent->linetype_flags = bit_read_BB(dat);\n      ent->plotstyle_flags = bit_read_BB(dat);\n    }\n\n  SINCE(R_2007)\n    {\n      ent->material_flags = bit_read_BB(dat);\n      ent->shadow_flags = bit_read_RC(dat);\n    }\n\n  ent->invisible = bit_read_BS(dat);\n\n  SINCE(R_2000)\n    {\n      ent->lineweight = bit_read_RC(dat);\n    }\n\n  return 0;\n}", "path": "src\\decode.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write 1 bitlong (compacted data).\n */\n", "func_signal": "void\nbit_write_BL(Bit_Chain * dat, long unsigned int value)", "code": "{\n  if (value > 255)\n    {\n      bit_write_BB(dat, 0);\n      bit_write_RL(dat, value);\n    }\n  else if (value == 0)\n    bit_write_BB(dat, 2);\n  else\n    {\n      bit_write_BB(dat, 1);\n      bit_write_RC(dat, value);\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read bit-extrusionn.\n */\n", "func_signal": "void\nbit_read_BE(Bit_Chain * dat, double *x, double *y, double *z)", "code": "{\n  if (dat->version >= R_2000 && bit_read_B(dat))\n    {\n      *x = 0.0;\n      *y = 0.0;\n      *z = 1.0;\n    }\n  else\n    {\n      *x = bit_read_BD(dat);\n      *y = bit_read_BD(dat);\n      *z = bit_read_BD(dat);\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read 1 byte (raw char).\n */\n", "func_signal": "BITCODE_RC\nbit_read_RC(Bit_Chain * dat)", "code": "{\n  unsigned char result;\n  unsigned char byte;\n\n  byte = dat->chain[dat->byte];\n  if (dat->bit == 0)\n    result = byte;\n  else\n    {\n      result = byte << dat->bit;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= byte >> (8 - dat->bit);\n        }\n    }\n\n  bit_advance_position(dat, 8);\n  return ((unsigned char) result);\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read 1 nibble.\n */\n", "func_signal": "BITCODE_4BITS\nbit_read_4BITS(Bit_Chain * dat)", "code": "{\n  BITCODE_4BITS result = bit_read_RC(dat);\n  bit_advance_position(dat, -4);\n  //perhaps we have an issue here when the 4bit field is near the end of a bitstream?\n  // (since we initially advance 8bits and then later rewind 4bits)\n  return (result & 0xf0) >> 4;\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read 1 bitdouble (compacted data).\n */\n", "func_signal": "BITCODE_BD\nbit_read_BD(Bit_Chain * dat)", "code": "{\n  unsigned char two_bit_code;\n  long int *res;\n  double result;\n\n  two_bit_code = bit_read_BB(dat);\n\n  if (two_bit_code == 0)\n    {\n      result = bit_read_RD(dat);\n      return (result);\n    }\n  else if (two_bit_code == 1)\n    return (1.0);\n  else if (two_bit_code == 2)\n    return (0.0);\n  else /* if (two_bit_code == 3) */\n    {\n      LOG_ERROR(\"bit_read_BD: unexpected 2-bit code: '11'\")\n      /* create a Not-A-Number (NaN) */\n      res = (long int *) &result;\n      res[0] = -1;\n      res[1] = -1;\n      return (result);\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read 1 bit.\n */\n", "func_signal": "BITCODE_B\nbit_read_B(Bit_Chain * dat)", "code": "{\n  unsigned char result;\n  unsigned char byte;\n\n  byte = dat->chain[dat->byte];\n  result = (byte & (0x80 >> dat->bit)) >> (7 - dat->bit);\n\n  bit_advance_position(dat, 1);\n  return result;\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Write color\n */\n", "func_signal": "void\nbit_write_CMC(Bit_Chain * dat, Dwg_Color* color)", "code": "{\n  bit_write_BS(dat, color->index);\n  if (dat->version >= R_2004)\n    {\n      bit_write_BL(dat, color->rgb);\n      bit_write_RC(dat, color->byte);\n      if (color->byte & 1)\n        bit_write_TV(dat,(unsigned char*) color->name);\n      if (color->byte & 2)\n        bit_write_TV(dat, (unsigned char*)color->book_name);\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/** Read color\n */\n", "func_signal": "void\nbit_read_CMC(Bit_Chain * dat, Dwg_Color* color)", "code": "{\n  color->index = bit_read_BS(dat);\n  if (dat->version >= R_2004)\n    {\n      color->rgb = bit_read_BL(dat);\n      color->byte = bit_read_RC(dat);\n      if (color->byte & 1)\n        color->name = (char*)bit_read_TV(dat);\n      if (color->byte & 2)\n        color->book_name = (char*)bit_read_TV(dat);\n    }\n}", "path": "src\\bits.c", "repo_name": "h4ck3rm1k3/LibreDWGCPlusPlus", "stars": 5, "license": "gpl-3.0", "language": "c", "size": 1426}
{"docstring": "/* Callbacks */\n", "func_signal": "static void\n_dialog_run (GtkDialog       *dialog __UNUSED__,\n             gint             response,\n             X264_Gui_Config *gconfig,\n             X264_Gtk        *x264_gtk)", "code": "{\n  if (response == GTK_RESPONSE_OK)\n    {\n      GIOChannel *file;\n      gchar      *filename;\n      gchar      *dir;\n      gsize       length;\n      gint        res;\n#ifndef _WIN32\n      mode_t      mode;\n#endif\n\n      dir = x264_gtk_path (NULL);\n\n#ifdef _WIN32\n      res = mkdir (dir);\n#else\n      mode =\n        S_IRUSR | S_IXUSR | S_IWUSR |\n        S_IRGRP | S_IXGRP | S_IWGRP |\n        S_IROTH | S_IXOTH | S_IWOTH;\n      res = mkdir (dir, mode);\n#endif /* _WIN32 */\n      if (res != 0 && errno != EEXIST)\n        {\n          g_free (dir);\n\n          return;\n        }\n\n      filename = x264_gtk_path (\"x264.cfg\");\n      g_print (_(\"Writing configuration to %s\\n\"), filename);\n      file = g_io_channel_new_file (filename, \"w+\", NULL);\n      if (file)\n        {\n          _current_get (gconfig, x264_gtk);\n          g_io_channel_set_encoding (file, NULL, NULL);\n          g_io_channel_write_chars (file, (const gchar *)x264_gtk,\n                                    sizeof (X264_Gtk), &length, NULL);\n          g_io_channel_unref (file);\n        }\n      g_free (filename);\n      g_free (dir);\n    }\n}", "path": "ext\\x264\\gtk\\x264_gtk.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* this code assume stride % 16 == 0 */\n", "func_signal": "static void PREFIX_h264_qpel16_h_lowpass_altivec(uint8_t * dst, uint8_t * src, int dstStride, int srcStride)", "code": "{\n  POWERPC_PERF_DECLARE(PREFIX_h264_qpel16_h_lowpass_num, 1);\n  register int i;\n\n  LOAD_ZERO;\n  const vec_u8_t permM2 = vec_lvsl(-2, src);\n  const vec_u8_t permM1 = vec_lvsl(-1, src);\n  const vec_u8_t permP0 = vec_lvsl(+0, src);\n  const vec_u8_t permP1 = vec_lvsl(+1, src);\n  const vec_u8_t permP2 = vec_lvsl(+2, src);\n  const vec_u8_t permP3 = vec_lvsl(+3, src);\n  const vec_s16_t v5ss = vec_splat_s16(5);\n  const vec_u16_t v5us = vec_splat_u16(5);\n  const vec_s16_t v20ss = vec_sl(vec_splat_s16(5),vec_splat_u16(2));\n  const vec_s16_t v16ss = vec_sl(vec_splat_s16(1),vec_splat_u16(4));\n\n  vec_u8_t srcM2, srcM1, srcP0, srcP1, srcP2, srcP3;\n\n  register int align = ((((unsigned long)src) - 2) % 16);\n\n  vec_s16_t srcP0A, srcP0B, srcP1A, srcP1B,\n                      srcP2A, srcP2B, srcP3A, srcP3B,\n                      srcM1A, srcM1B, srcM2A, srcM2B,\n                      sum1A, sum1B, sum2A, sum2B, sum3A, sum3B,\n                      pp1A, pp1B, pp2A, pp2B, pp3A, pp3B,\n                      psumA, psumB, sumA, sumB;\n\n  vec_u8_t sum, vdst, fsum;\n\n  POWERPC_PERF_START_COUNT(PREFIX_h264_qpel16_h_lowpass_num, 1);\n\n  for (i = 0 ; i < 16 ; i ++) {\n    vec_u8_t srcR1 = vec_ld(-2, src);\n    vec_u8_t srcR2 = vec_ld(14, src);\n\n    switch (align) {\n    default: {\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = vec_perm(srcR1, srcR2, permP2);\n      srcP3 = vec_perm(srcR1, srcR2, permP3);\n    } break;\n    case 11: {\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = vec_perm(srcR1, srcR2, permP2);\n      srcP3 = srcR2;\n    } break;\n    case 12: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = srcR2;\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 13: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = srcR2;\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 14: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = srcR2;\n      srcP1 = vec_perm(srcR2, srcR3, permP1);\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 15: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = srcR2;\n      srcP0 = vec_perm(srcR2, srcR3, permP0);\n      srcP1 = vec_perm(srcR2, srcR3, permP1);\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    }\n\n    srcP0A = (vec_s16_t) vec_mergeh(zero_u8v, srcP0);\n    srcP0B = (vec_s16_t) vec_mergel(zero_u8v, srcP0);\n    srcP1A = (vec_s16_t) vec_mergeh(zero_u8v, srcP1);\n    srcP1B = (vec_s16_t) vec_mergel(zero_u8v, srcP1);\n\n    srcP2A = (vec_s16_t) vec_mergeh(zero_u8v, srcP2);\n    srcP2B = (vec_s16_t) vec_mergel(zero_u8v, srcP2);\n    srcP3A = (vec_s16_t) vec_mergeh(zero_u8v, srcP3);\n    srcP3B = (vec_s16_t) vec_mergel(zero_u8v, srcP3);\n\n    srcM1A = (vec_s16_t) vec_mergeh(zero_u8v, srcM1);\n    srcM1B = (vec_s16_t) vec_mergel(zero_u8v, srcM1);\n    srcM2A = (vec_s16_t) vec_mergeh(zero_u8v, srcM2);\n    srcM2B = (vec_s16_t) vec_mergel(zero_u8v, srcM2);\n\n    sum1A = vec_adds(srcP0A, srcP1A);\n    sum1B = vec_adds(srcP0B, srcP1B);\n    sum2A = vec_adds(srcM1A, srcP2A);\n    sum2B = vec_adds(srcM1B, srcP2B);\n    sum3A = vec_adds(srcM2A, srcP3A);\n    sum3B = vec_adds(srcM2B, srcP3B);\n\n    pp1A = vec_mladd(sum1A, v20ss, v16ss);\n    pp1B = vec_mladd(sum1B, v20ss, v16ss);\n\n    pp2A = vec_mladd(sum2A, v5ss, zero_s16v);\n    pp2B = vec_mladd(sum2B, v5ss, zero_s16v);\n\n    pp3A = vec_add(sum3A, pp1A);\n    pp3B = vec_add(sum3B, pp1B);\n\n    psumA = vec_sub(pp3A, pp2A);\n    psumB = vec_sub(pp3B, pp2B);\n\n    sumA = vec_sra(psumA, v5us);\n    sumB = vec_sra(psumB, v5us);\n\n    sum = vec_packsu(sumA, sumB);\n\n    ASSERT_ALIGNED(dst);\n    vdst = vec_ld(0, dst);\n\n    OP_U8_ALTIVEC(fsum, sum, vdst);\n\n    vec_st(fsum, 0, dst);\n\n    src += srcStride;\n    dst += dstStride;\n  }\nPOWERPC_PERF_STOP_COUNT(PREFIX_h264_qpel16_h_lowpass_num, 1);\n}", "path": "ext\\ffmpeg\\libavcodec\\ppc\\h264_template_altivec.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*field dumping for proto declaration and Script*/\n", "func_signal": "void DumpDynField(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)", "code": "{\n\tGenMFField *mffield;\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tfprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t\tfield.name, gf_sg_vrml_get_field_type_by_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tfprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t\tfield.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tif (!sdump->X3DDump) {\n\t\t\t\t\t\tfprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\tsdump->indent++;\n\t\t\t\t\t\tfprintf(sdump->trace, \"<node>\");\n\t\t\t\t\t\tDumpNode(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t\t\tfprintf(sdump->trace, \"</node>\");\n\t\t\t\t\t\tsdump->indent--;\n\t\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\t\tfprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (field.far_ptr) {\n\t\t\t\t\t\t\tfprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\t\tDumpNode(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\t\t\t\t\t\tfprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(sdump->trace, \"/>\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tfprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tDumpSFField(sdump, field.fieldType, field.far_ptr, 0);\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tfprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_by_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tfprintf(sdump->trace, \" \");\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tDumpNode(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tDumpFieldValue(sdump, field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else {\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tfprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_by_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tfprintf(sdump->trace, \" [\");\n\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tfprintf(sdump->trace, \"\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\twhile (l) {\n\t\t\t\t\t\tDumpNode(sdump, l->node, 1, NULL);\n\t\t\t\t\t\tl = l->next;\n\t\t\t\t\t}\n\t\t\t\t\tsdump->indent--;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tDumpSFField(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfprintf(sdump->trace, \"]\");\n\t\t\t}\n\t\t\tfprintf(sdump->trace, \"\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tfprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t\tfield.name, gf_sg_vrml_get_field_type_by_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tfprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t\tfield.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tfprintf(sdump->trace, \">\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tDumpNode(sdump, list->node, 1, NULL);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\tfprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tfprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tDumpSFField(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tfprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "path": "ext\\gpac\\src\\scene_manager\\scene_dump.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* ---------------- public code */\n", "func_signal": "static void *h264_new_extradata(void)", "code": "{\n    h264_rtp_extra_data *data =\n        av_mallocz(sizeof(h264_rtp_extra_data) +\n                   FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (data) {\n        data->cookie = MAGIC_COOKIE;\n    }\n\n    return data;\n}", "path": "ext\\ffmpeg\\libavformat\\rtp_h264.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* TODO: FIX ME we actually ignore the given sub_root since it is only valid \n\t     when animations have been performed,\n         animations evaluation (Render_base) should be part of the core renderer */\n", "func_signal": "void r2d_render_svg_use(GF_Node *node, GF_Node *sub_root, void *rs)", "code": "{\n\tGF_Matrix2D backup_matrix;\n  \tGF_Matrix2D translate;\n\tGF_Node *prev_use;\n\tSVGPropertiesPointers backup_props;\n\tu32 backup_flags;\n\tRenderEffect2D *eff = (RenderEffect2D *)rs;\n\tSVGAllAttributes all_atts;\n\n\tgf_svg_flatten_attributes((SVG_Element *)node, &all_atts);\n\n\tsvg_render_base(node, &all_atts, eff, &backup_props, &backup_flags);\n\n\tgf_mx2d_init(translate);\n\ttranslate.m[2] = (all_atts.x ? all_atts.x->value : 0);\n\ttranslate.m[5] = (all_atts.y ? all_atts.y->value : 0);\n\n\tif (eff->traversing_mode == TRAVERSE_GET_BOUNDS) {\n\t\tsvg_apply_local_transformation(eff, &all_atts, &backup_matrix);\n\t\tif (!svg_is_display_off(eff->svg_props)) {\n\t\t\tif (all_atts.xlink_href) gf_node_render(all_atts.xlink_href->target, eff);\n\t\t\tgf_mx2d_apply_rect(&translate, &eff->bounds);\n\t\t} \n\t\tsvg_restore_parent_transformation(eff, &backup_matrix);\n\t\tgoto end;\n\t}\n\n\tif (svg_is_display_off(eff->svg_props) ||\n\t\t(*(eff->svg_props->visibility) == SVG_VISIBILITY_HIDDEN)) {\n\t\tgoto end;\n\t}\n\n\tsvg_apply_local_transformation(eff, &all_atts, &backup_matrix);\n\n\tgf_mx2d_pre_multiply(&eff->transform, &translate);\n\tif (all_atts.xlink_href) {\n\t\tprev_use = eff->parent_use;\n\t\teff->parent_use = node;\n\t\tgf_node_render(all_atts.xlink_href->target, eff);\n\t\teff->parent_use = prev_use;\n\t}\n\tsvg_restore_parent_transformation(eff, &backup_matrix);  \n\nend:\n\tmemcpy(eff->svg_props, &backup_props, sizeof(SVGPropertiesPointers));\n\teff->svg_flags = backup_flags;\n}", "path": "ext\\gpac\\modules\\render2d\\svg_base_da.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* linear gradient */\n", "func_signal": "static void SVG_UpdateLinearGradient(GF_TextureHandler *txh)", "code": "{\n\tSVG_Element *lg = (SVG_Element *) txh->owner;\n\tSVG_GradientStack *st = (SVG_GradientStack *) gf_node_get_private(txh->owner);\n\tif (!txh->hwtx) txh->hwtx = txh->compositor->r2d->stencil_new(txh->compositor->r2d, GF_STENCIL_LINEAR_GRADIENT);\n\n\tSVG_UpdateGradient(st, lg->children);\n}", "path": "ext\\gpac\\modules\\render2d\\svg_base_da.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* Result must be freed */\n", "func_signal": "x264_param_t *x264_gtk_param_get (X264_Gtk *x264_gtk)", "code": "{\n  x264_param_t *param;\n\n  if (!x264_gtk)\n    return NULL;\n\n  param = (x264_param_t *)g_malloc (sizeof (x264_param_t));\n  if (!param)\n    return NULL;\n\n  x264_param_default (param);\n\n  /* rate control */\n  param->rc.f_ip_factor = 1.0 + (double)x264_gtk->keyframe_boost / 100.0;\n  param->rc.f_pb_factor = 1.0 + (double)x264_gtk->bframes_reduction / 100.0;\n  param->rc.f_qcompress = (double)x264_gtk->bitrate_variability / 100.0;\n\n  param->rc.i_qp_min = x264_gtk->min_qp;\n  param->rc.i_qp_max = x264_gtk->max_qp;\n  param->rc.i_qp_step = x264_gtk->max_qp_step;\n\n  param->i_scenecut_threshold = x264_gtk->scene_cut_threshold;\n  param->i_keyint_min = x264_gtk->min_idr_frame_interval;\n  param->i_keyint_max = x264_gtk->max_idr_frame_interval;\n\n  param->rc.i_vbv_max_bitrate = x264_gtk->vbv_max_bitrate;\n  param->rc.i_vbv_buffer_size = x264_gtk->vbv_buffer_size;\n  param->rc.f_vbv_buffer_init = x264_gtk->vbv_buffer_init;\n\n  /* mb */\n  param->analyse.b_transform_8x8 = x264_gtk->transform_8x8;\n  param->analyse.inter = 0;\n  if (x264_gtk->pframe_search_8)\n    param->analyse.inter |= X264_ANALYSE_PSUB16x16;\n  if (x264_gtk->bframe_search_8)\n    param->analyse.inter |= X264_ANALYSE_BSUB16x16;\n  if (x264_gtk->pframe_search_4)\n    param->analyse.inter |= X264_ANALYSE_PSUB8x8;\n  if (x264_gtk->inter_search_8)\n    param->analyse.inter |= X264_ANALYSE_I8x8;\n  if (x264_gtk->inter_search_4)\n    param->analyse.inter |= X264_ANALYSE_I4x4;\n\n  param->b_bframe_pyramid = x264_gtk->bframe_pyramid && x264_gtk->bframe;\n  param->analyse.b_bidir_me = x264_gtk->bidir_me;\n  param->b_bframe_adaptive = x264_gtk->bframe_adaptive;\n  param->analyse.b_weighted_bipred = x264_gtk->weighted_bipred;\n  param->i_bframe = x264_gtk->bframe;\n  param->i_bframe_bias = x264_gtk->bframe_bias;\n  param->analyse.i_direct_mv_pred = x264_gtk->direct_mode;\n\n/*   param->b_bframe_pyramid = param->b_bframe_pyramid && (param->i_bframe > 1); */\n\n  /* more */\n  param->analyse.i_subpel_refine = x264_gtk->partition_decision + 1;\n  param->analyse.b_bframe_rdo = x264_gtk->bframe_rdo;\n  param->analyse.i_me_method = x264_gtk->me_method;\n  param->analyse.i_me_range = x264_gtk->range;\n  param->analyse.b_chroma_me = x264_gtk->chroma_me;\n  param->analyse.i_trellis = x264_gtk->trellis;\n  param->analyse.i_noise_reduction = x264_gtk->noise_reduction;\n  param->i_frame_reference = x264_gtk->max_ref_frames;\n  param->analyse.b_mixed_references = x264_gtk->mixed_refs;\n  param->analyse.b_fast_pskip = x264_gtk->fast_pskip;\n  param->analyse.b_dct_decimate = x264_gtk->dct_decimate;\n  /* rdo : RD based mode decision for B-frames. Requires subme 6 */\n\n  param->vui.i_sar_width = x264_gtk->sample_ar_x;\n  param->vui.i_sar_height = x264_gtk->sample_ar_y;\n  param->i_threads = x264_gtk->threads;\n  param->b_cabac = x264_gtk->cabac;\n  param->b_deblocking_filter = x264_gtk->deblocking_filter;\n  param->i_deblocking_filter_alphac0 = x264_gtk->strength;\n  param->i_deblocking_filter_beta = x264_gtk->threshold;\n\n  param->i_log_level = x264_gtk->debug_method - 1;\n\n  /* cqm */\n  param->i_cqm_preset = x264_gtk->cqm_preset;\n  if (x264_gtk->cqm_file && (x264_gtk->cqm_file[0] != '\\0'))\n    param->psz_cqm_file = x264_gtk->cqm_file;\n  memcpy( param->cqm_4iy, x264_gtk->cqm_4iy, 16 );\n  memcpy( param->cqm_4ic, x264_gtk->cqm_4ic, 16 );\n  memcpy( param->cqm_4py, x264_gtk->cqm_4py, 16 );\n  memcpy( param->cqm_4pc, x264_gtk->cqm_4pc, 16 );\n  memcpy( param->cqm_8iy, x264_gtk->cqm_8iy, 64 );\n  memcpy( param->cqm_8py, x264_gtk->cqm_8py, 64 );\n\n  /* bitrate */\n  switch (x264_gtk->pass) {\n  case X264_PASS_SINGLE_BITRATE:\n    param->rc.i_rc_method = X264_RC_ABR;\n    param->rc.i_bitrate  = x264_gtk->average_bitrate;\n    break;\n  case X264_PASS_SINGLE_QUANTIZER:\n    param->rc.i_rc_method = X264_RC_CQP;\n    param->rc.i_qp_constant = x264_gtk->quantizer;\n    break;\n  case X264_PASS_MULTIPASS_1ST_FAST:\n    param->analyse.i_subpel_refine = X264_MAX( X264_MIN( 3, param->analyse.i_subpel_refine - 1 ), 1 );\n    param->i_frame_reference = ( param->i_frame_reference + 1 ) >> 1;\n    param->analyse.inter &= ( ~X264_ANALYSE_PSUB8x8 );\n    param->analyse.inter &= ( ~X264_ANALYSE_BSUB16x16 );\n  case X264_PASS_MULTIPASS_1ST:\n    param->rc.i_rc_method = X264_RC_ABR;\n    param->rc.i_bitrate  = x264_gtk->average_bitrate;\n    param->rc.f_rate_tolerance = 4.0;\n    break;\n  case X264_PASS_MULTIPASS_NTH:\n    param->rc.i_rc_method = X264_RC_ABR;\n    param->rc.i_bitrate  = x264_gtk->average_bitrate;\n    param->rc.f_rate_tolerance = 1.0;\n    break;\n  }\n\n  param->rc.b_stat_write = x264_gtk->stat_write;\n  param->rc.b_stat_read = x264_gtk->stat_read;\n\n  /* FIXME: potential mem leak... */\n  param->rc.psz_stat_out = x264_gtk_path (x264_gtk->statsfile_name);\n\n  return param;\n}", "path": "ext\\x264\\gtk\\x264_gtk.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* ---------------- private code */\n", "func_signal": "static void sdp_parse_fmtp_config_h264(AVStream * stream,\n                                       h264_rtp_extra_data * h264_data,\n                                       char *attr, char *value)", "code": "{\n    AVCodecContext *codec = stream->codec;\n    assert(codec->codec_id == CODEC_ID_H264);\n    assert(h264_data != NULL);\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(NULL, AV_LOG_DEBUG, \"H.264/RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n           Packetization Mode:\n           0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n           1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n           2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A), and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(stream, AV_LOG_ERROR,\n                   \"H.264/RTP Interleaved RTP mode is not supported yet.\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6) {\n            char buffer[3];\n            // 6 characters=3 bytes, in hex.\n            uint8_t profile_idc;\n            uint8_t profile_iop;\n            uint8_t level_idc;\n\n            buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\\0';\n            profile_idc = strtol(buffer, NULL, 16);\n            buffer[0] = value[2]; buffer[1] = value[3];\n            profile_iop = strtol(buffer, NULL, 16);\n            buffer[0] = value[4]; buffer[1] = value[5];\n            level_idc = strtol(buffer, NULL, 16);\n\n            // set the parameters...\n            av_log(NULL, AV_LOG_DEBUG,\n                   \"H.264/RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n                   profile_idc, profile_iop, level_idc);\n            h264_data->profile_idc = profile_idc;\n            h264_data->profile_iop = profile_iop;\n            h264_data->level_idc = level_idc;\n        }\n    } else  if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        uint8_t start_sequence[]= { 0, 0, 1 };\n        codec->extradata_size= 0;\n        codec->extradata= NULL;\n\n        while (*value) {\n            char base64packet[1024];\n            uint8_t decoded_packet[1024];\n            uint32_t packet_size;\n            char *dst = base64packet;\n\n            while (*value && *value != ','\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n                *dst++ = *value++;\n            }\n            *dst++ = '\\0';\n\n            if (*value == ',')\n                value++;\n\n            packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet));\n            if (packet_size) {\n                uint8_t *dest= av_malloc(packet_size+sizeof(start_sequence)+codec->extradata_size);\n                if(dest)\n                {\n                    if(codec->extradata_size)\n                    {\n                        // av_realloc?\n                        memcpy(dest, codec->extradata, codec->extradata_size);\n                        av_free(codec->extradata);\n                    }\n\n                    memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence));\n                    memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size);\n\n                    codec->extradata= dest;\n                    codec->extradata_size+= sizeof(start_sequence)+packet_size;\n                } else {\n                    av_log(NULL, AV_LOG_ERROR, \"H.264/RTP Unable to allocate memory for extradata!\");\n                }\n            }\n        }\n        av_log(NULL, AV_LOG_DEBUG, \"H.264/RTP Extradata set to %p (size: %d)!\", codec->extradata, codec->extradata_size);\n    }\n}", "path": "ext\\ffmpeg\\libavformat\\rtp_h264.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*field dumping for proto instance*/\n", "func_signal": "void DumpProtoField(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)", "code": "{\n\tGenMFField *mffield;\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tfprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tfprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"<node>\");\n\t\t\tDumpNode(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tfprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tfprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tfprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tDumpSFField(sdump, field.fieldType, field.far_ptr, 0);\n\t\t\tfprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tfprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tDumpNode(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tfprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tfprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\tif (i) fprintf(sdump->trace, \" \");\n\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\tDumpSFField(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "path": "ext\\gpac\\src\\scene_manager\\scene_dump.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*\n * ********************************************************************\n * interface\n */\n", "func_signal": "Bool QueryInterface(u32 InterfaceType)", "code": "{\n\tif (InterfaceType == GF_AUDIO_OUTPUT_INTERFACE) \n\t\treturn 1;\n\treturn 0;\n}", "path": "ext\\gpac\\modules\\alsa\\alsa.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* Result must be freed */\n", "func_signal": "X264_Gtk *\nx264_gtk_load (void)", "code": "{\n  X264_Gtk     *x264_gtk;\n  GIOChannel   *file;\n  GError       *error = NULL;\n  gchar        *filename;\n\n  x264_gtk = (X264_Gtk *)g_malloc0 (sizeof (X264_Gtk));\n  if (!x264_gtk)\n    return NULL;\n\n  filename = x264_gtk_path (\"x264.cfg\");\n  file = g_io_channel_new_file (filename, \"r\", &error);\n  if (error) {\n    g_print (_(\"x264.cfg: %s\\n\"), error->message);\n    g_print (_(\"Loading default configuration\\n\"));\n    _default_set (x264_gtk);\n  }\n  else {\n    GIOStatus status;\n    gchar    *data = NULL;\n    gsize     length;\n\n    g_print (_(\"Loading configuration from %s\\n\"), filename);\n    g_io_channel_set_encoding (file, NULL, NULL);\n    status = g_io_channel_read_to_end (file, &data, &length, &error);\n    if ((status == G_IO_STATUS_NORMAL) &&\n        (length == sizeof (X264_Gtk))) {\n      memcpy (x264_gtk, data, length);\n    }\n    g_io_channel_shutdown (file, TRUE, NULL);\n    g_io_channel_unref (file);\n  }\n  g_free (filename);\n\n  return x264_gtk;\n}", "path": "ext\\x264\\gtk\\x264_gtk.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* this code assume stride % 16 == 0 */\n", "func_signal": "static void PREFIX_h264_qpel16_v_lowpass_altivec(uint8_t * dst, uint8_t * src, int dstStride, int srcStride)", "code": "{\n  POWERPC_PERF_DECLARE(PREFIX_h264_qpel16_v_lowpass_num, 1);\n\n  register int i;\n\n  LOAD_ZERO;\n  const vec_u8_t perm = vec_lvsl(0, src);\n  const vec_s16_t v20ss = vec_sl(vec_splat_s16(5),vec_splat_u16(2));\n  const vec_u16_t v5us = vec_splat_u16(5);\n  const vec_s16_t v5ss = vec_splat_s16(5);\n  const vec_s16_t v16ss = vec_sl(vec_splat_s16(1),vec_splat_u16(4));\n\n  uint8_t *srcbis = src - (srcStride * 2);\n\n  const vec_u8_t srcM2a = vec_ld(0, srcbis);\n  const vec_u8_t srcM2b = vec_ld(16, srcbis);\n  const vec_u8_t srcM2 = vec_perm(srcM2a, srcM2b, perm);\n//  srcbis += srcStride;\n  const vec_u8_t srcM1a = vec_ld(0, srcbis += srcStride);\n  const vec_u8_t srcM1b = vec_ld(16, srcbis);\n  const vec_u8_t srcM1 = vec_perm(srcM1a, srcM1b, perm);\n//  srcbis += srcStride;\n  const vec_u8_t srcP0a = vec_ld(0, srcbis += srcStride);\n  const vec_u8_t srcP0b = vec_ld(16, srcbis);\n  const vec_u8_t srcP0 = vec_perm(srcP0a, srcP0b, perm);\n//  srcbis += srcStride;\n  const vec_u8_t srcP1a = vec_ld(0, srcbis += srcStride);\n  const vec_u8_t srcP1b = vec_ld(16, srcbis);\n  const vec_u8_t srcP1 = vec_perm(srcP1a, srcP1b, perm);\n//  srcbis += srcStride;\n  const vec_u8_t srcP2a = vec_ld(0, srcbis += srcStride);\n  const vec_u8_t srcP2b = vec_ld(16, srcbis);\n  const vec_u8_t srcP2 = vec_perm(srcP2a, srcP2b, perm);\n//  srcbis += srcStride;\n\n  vec_s16_t srcM2ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcM2);\n  vec_s16_t srcM2ssB = (vec_s16_t) vec_mergel(zero_u8v, srcM2);\n  vec_s16_t srcM1ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcM1);\n  vec_s16_t srcM1ssB = (vec_s16_t) vec_mergel(zero_u8v, srcM1);\n  vec_s16_t srcP0ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcP0);\n  vec_s16_t srcP0ssB = (vec_s16_t) vec_mergel(zero_u8v, srcP0);\n  vec_s16_t srcP1ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcP1);\n  vec_s16_t srcP1ssB = (vec_s16_t) vec_mergel(zero_u8v, srcP1);\n  vec_s16_t srcP2ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcP2);\n  vec_s16_t srcP2ssB = (vec_s16_t) vec_mergel(zero_u8v, srcP2);\n\n  vec_s16_t pp1A, pp1B, pp2A, pp2B, pp3A, pp3B,\n                      psumA, psumB, sumA, sumB,\n                      srcP3ssA, srcP3ssB,\n                      sum1A, sum1B, sum2A, sum2B, sum3A, sum3B;\n\n  vec_u8_t sum, vdst, fsum, srcP3a, srcP3b, srcP3;\n\n  POWERPC_PERF_START_COUNT(PREFIX_h264_qpel16_v_lowpass_num, 1);\n\n  for (i = 0 ; i < 16 ; i++) {\n    srcP3a = vec_ld(0, srcbis += srcStride);\n    srcP3b = vec_ld(16, srcbis);\n    srcP3 = vec_perm(srcP3a, srcP3b, perm);\n    srcP3ssA = (vec_s16_t) vec_mergeh(zero_u8v, srcP3);\n    srcP3ssB = (vec_s16_t) vec_mergel(zero_u8v, srcP3);\n//    srcbis += srcStride;\n\n    sum1A = vec_adds(srcP0ssA, srcP1ssA);\n    sum1B = vec_adds(srcP0ssB, srcP1ssB);\n    sum2A = vec_adds(srcM1ssA, srcP2ssA);\n    sum2B = vec_adds(srcM1ssB, srcP2ssB);\n    sum3A = vec_adds(srcM2ssA, srcP3ssA);\n    sum3B = vec_adds(srcM2ssB, srcP3ssB);\n\n    srcM2ssA = srcM1ssA;\n    srcM2ssB = srcM1ssB;\n    srcM1ssA = srcP0ssA;\n    srcM1ssB = srcP0ssB;\n    srcP0ssA = srcP1ssA;\n    srcP0ssB = srcP1ssB;\n    srcP1ssA = srcP2ssA;\n    srcP1ssB = srcP2ssB;\n    srcP2ssA = srcP3ssA;\n    srcP2ssB = srcP3ssB;\n\n    pp1A = vec_mladd(sum1A, v20ss, v16ss);\n    pp1B = vec_mladd(sum1B, v20ss, v16ss);\n\n    pp2A = vec_mladd(sum2A, v5ss, zero_s16v);\n    pp2B = vec_mladd(sum2B, v5ss, zero_s16v);\n\n    pp3A = vec_add(sum3A, pp1A);\n    pp3B = vec_add(sum3B, pp1B);\n\n    psumA = vec_sub(pp3A, pp2A);\n    psumB = vec_sub(pp3B, pp2B);\n\n    sumA = vec_sra(psumA, v5us);\n    sumB = vec_sra(psumB, v5us);\n\n    sum = vec_packsu(sumA, sumB);\n\n    ASSERT_ALIGNED(dst);\n    vdst = vec_ld(0, dst);\n\n    OP_U8_ALTIVEC(fsum, sum, vdst);\n\n    vec_st(fsum, 0, dst);\n\n    dst += dstStride;\n  }\n  POWERPC_PERF_STOP_COUNT(PREFIX_h264_qpel16_v_lowpass_num, 1);\n}", "path": "ext\\ffmpeg\\libavcodec\\ppc\\h264_template_altivec.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* x264 config management */\n", "func_signal": "static void\n_default_load (GtkButton *button __UNUSED__, gpointer user_data)", "code": "{\n  gchar            buf[64];\n  X264_Gui_Config *config;\n  x264_param_t     param;\n  gint             i;\n\n  if (!user_data)\n    return;\n\n  config = (X264_Gui_Config *)user_data;\n\n  x264_param_default (&param);\n\n  /* bitrate */\n  gtk_combo_box_set_active (GTK_COMBO_BOX (config->bitrate.pass), 1);\n  g_snprintf (buf, 64, \"%d\", param.rc.i_bitrate);\n  gtk_entry_set_text (GTK_ENTRY (config->bitrate.w_average_bitrate), buf);\n  gtk_entry_set_text (GTK_ENTRY (config->bitrate.w_target_bitrate), buf);\n  gtk_range_set_range (GTK_RANGE (config->bitrate.w_quantizer),\n                       0.0,\n                       51.0);\n  gtk_range_set_value (GTK_RANGE (config->bitrate.w_quantizer),\n                       (gdouble)param.rc.i_qp_constant);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->bitrate.update_statfile), FALSE);\n  gtk_entry_set_text (GTK_ENTRY (config->bitrate.statsfile_name), \"x264.stats\");\n  gtk_widget_set_sensitive (config->bitrate.statsfile_name, FALSE);\n  gtk_widget_set_sensitive (config->bitrate.update_statfile, FALSE);\n\n  /* rate control */\n  g_snprintf (buf, 64, \"%d\", round((param.rc.f_ip_factor - 1.0) * 100));\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.bitrate.keyframe_boost), buf);\n  g_snprintf (buf, 64, \"%d\", round((param.rc.f_pb_factor - 1.0) * 100));\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.bitrate.bframes_reduction), buf);\n  g_snprintf (buf, 64, \"%d\", (gint)(param.rc.f_qcompress * 100));\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.bitrate.bitrate_variability), buf);\n\n  g_snprintf (buf, 64, \"%d\", param.rc.i_qp_min);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.quantization_limits.min_qp), buf);\n  g_snprintf (buf, 64, \"%d\", param.rc.i_qp_max);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.quantization_limits.max_qp), buf);\n  g_snprintf (buf, 64, \"%d\", param.rc.i_qp_step);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.quantization_limits.max_qp_step), buf);\n\n  g_snprintf (buf, 64, \"%d\", param.i_scenecut_threshold);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.scene_cuts.scene_cut_threshold), buf);\n  g_snprintf (buf, 64, \"%d\", param.i_keyint_min);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.scene_cuts.min_idr_frame_interval), buf);\n  g_snprintf (buf, 64, \"%d\", param.i_keyint_max);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.scene_cuts.max_idr_frame_interval), buf);\n\n  g_snprintf (buf, 64, \"%d\", param.rc.i_vbv_max_bitrate);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.vbv.vbv_max_bitrate), buf);\n  g_snprintf (buf, 64, \"%d\", param.rc.i_vbv_buffer_size);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.vbv.vbv_buffer_size), buf);\n  g_snprintf (buf, 64, \"%.1f\", param.rc.f_vbv_buffer_init);\n  gtk_entry_set_text (GTK_ENTRY (config->rate_control.vbv.vbv_buffer_init), buf);\n\n  /* mb */\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.transform_8x8), param.analyse.b_transform_8x8);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.pframe_search_8), CHECK_FLAG(param.analyse.inter, X264_ANALYSE_PSUB16x16));\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.bframe_search_8), CHECK_FLAG(param.analyse.inter, X264_ANALYSE_BSUB16x16));\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.pframe_search_4), CHECK_FLAG(param.analyse.inter, X264_ANALYSE_PSUB8x8));\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.inter_search_8), CHECK_FLAG(param.analyse.inter, X264_ANALYSE_I8x8));\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.partitions.inter_search_4), CHECK_FLAG(param.analyse.inter, X264_ANALYSE_I4x4));\n\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.bframes.bframe_pyramid), param.b_bframe_pyramid);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.bframes.bidir_me), param.analyse.b_bidir_me);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.bframes.bframe_adaptive), param.b_bframe_adaptive);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->mb.bframes.weighted_bipred), param.analyse.b_weighted_bipred);\n  g_snprintf (buf, 64, \"%d\", param.i_bframe);\n  gtk_entry_set_text (GTK_ENTRY (config->mb.bframes.bframe), buf);\n  gtk_range_set_value (GTK_RANGE (config->mb.bframes.bframe_bias), (gdouble)param.i_bframe_bias);\n  gtk_combo_box_set_active (GTK_COMBO_BOX (config->mb.bframes.direct_mode), param.analyse.i_direct_mv_pred);\n\n  /* more */\n  if (param.analyse.b_bframe_rdo)\n    gtk_combo_box_set_active (GTK_COMBO_BOX (config->more.motion_estimation.partition_decision), X264_PD_6b);\n  else\n    gtk_combo_box_set_active (GTK_COMBO_BOX (config->more.motion_estimation.partition_decision), param.analyse.i_subpel_refine - 1);\n  gtk_combo_box_set_active (GTK_COMBO_BOX (config->more.motion_estimation.method), param.analyse.i_me_method);\n  g_snprintf (buf, 64, \"%d\", param.analyse.i_me_range);\n  gtk_entry_set_text (GTK_ENTRY (config->more.motion_estimation.range), buf);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.motion_estimation.chroma_me), param.analyse.b_chroma_me);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.motion_estimation.mixed_refs), param.analyse.b_mixed_references);\n  g_snprintf (buf, 64, \"%d\", param.i_frame_reference);\n  gtk_entry_set_text (GTK_ENTRY (config->more.motion_estimation.max_ref_frames), buf);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.motion_estimation.fast_pskip), param.analyse.b_fast_pskip);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.motion_estimation.dct_decimate), param.analyse.b_dct_decimate);\n\n  g_snprintf (buf, 64, \"%d\", param.vui.i_sar_width);\n  gtk_entry_set_text (GTK_ENTRY (config->more.misc.sample_ar_x), buf);\n  g_snprintf (buf, 64, \"%d\", param.vui.i_sar_height);\n  gtk_entry_set_text (GTK_ENTRY (config->more.misc.sample_ar_y), buf);\n  gtk_spin_button_set_value (GTK_SPIN_BUTTON (config->more.misc.threads), param.i_threads);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.misc.cabac), param.b_cabac);\n  gtk_combo_box_set_active (GTK_COMBO_BOX (config->more.misc.trellis), param.analyse.i_trellis);\n  g_snprintf (buf, 64, \"%d\", param.analyse.i_noise_reduction);\n  gtk_entry_set_text (GTK_ENTRY (config->more.misc.noise_reduction), buf);\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->more.misc.df.deblocking_filter), param.b_deblocking_filter);\n  gtk_range_set_value (GTK_RANGE (config->more.misc.df.strength), (gdouble)param.i_deblocking_filter_alphac0);\n  gtk_range_set_value (GTK_RANGE (config->more.misc.df.threshold), (gdouble)param.i_deblocking_filter_beta);\n\n  gtk_combo_box_set_active (GTK_COMBO_BOX (config->more.debug.log_level), param.i_log_level + 1);\n  gtk_entry_set_text (GTK_ENTRY (config->more.debug.fourcc), \"H264\");\n\n  /* cqm */\n  switch (param.i_cqm_preset) {\n  case X264_CQM_FLAT:\n    // workaround: gtk fails to update the matrix entries if we activate the button\n    // that was already active.\n    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->cqm.radio_jvt), TRUE);\n    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->cqm.radio_flat), TRUE);\n    break;\n  case X264_CQM_JVT:\n    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->cqm.radio_jvt), TRUE);\n    break;\n  case X264_CQM_CUSTOM:\n    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (config->cqm.radio_custom), TRUE);\n    break;\n  }\n  if (param.psz_cqm_file && (param.psz_cqm_file[0] != '\\0'))\n    gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (config->cqm.cqm_file), param.psz_cqm_file);\n  for (i = 0; i < 16; i++) {\n    gchar buf[4];\n\n    g_snprintf (buf, 4, \"%d\", param.cqm_4iy[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_4iy[i]), buf);\n    g_snprintf (buf, 4, \"%d\", param.cqm_4ic[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_4ic[i]), buf);\n    g_snprintf (buf, 4, \"%d\", param.cqm_4py[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_4py[i]), buf);\n    g_snprintf (buf, 4, \"%d\", param.cqm_4pc[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_4pc[i]), buf);\n  }\n  for (i = 0; i < 64; i++) {\n    gchar buf[4];\n\n    g_snprintf (buf, 4, \"%d\", param.cqm_8iy[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_8iy[i]), buf);\n    g_snprintf (buf, 4, \"%d\", param.cqm_8py[i]);\n    gtk_entry_set_text (GTK_ENTRY (config->cqm.cqm_8py[i]), buf);\n  }\n}", "path": "ext\\x264\\gtk\\x264_gtk.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "// test by ref -> src -> dst -> out & compare out against ref\n// ref & out are YV12\n", "func_signal": "static int doTest(uint8_t *ref[3], int refStride[3], int w, int h, int srcFormat, int dstFormat,\n                  int srcW, int srcH, int dstW, int dstH, int flags)", "code": "{\n    uint8_t *src[3];\n    uint8_t *dst[3];\n    uint8_t *out[3];\n    int srcStride[3], dstStride[3];\n    int i;\n    uint64_t ssdY, ssdU, ssdV;\n    struct SwsContext *srcContext, *dstContext, *outContext;\n    int res;\n\n    res = 0;\n    for (i=0; i<3; i++){\n        // avoid stride % bpp != 0\n        if (srcFormat==PIX_FMT_RGB24 || srcFormat==PIX_FMT_BGR24)\n            srcStride[i]= srcW*3;\n        else\n            srcStride[i]= srcW*4;\n\n        if (dstFormat==PIX_FMT_RGB24 || dstFormat==PIX_FMT_BGR24)\n            dstStride[i]= dstW*3;\n        else\n            dstStride[i]= dstW*4;\n\n        src[i]= (uint8_t*) malloc(srcStride[i]*srcH);\n        dst[i]= (uint8_t*) malloc(dstStride[i]*dstH);\n        out[i]= (uint8_t*) malloc(refStride[i]*h);\n        if ((src[i] == NULL) || (dst[i] == NULL) || (out[i] == NULL)) {\n            perror(\"Malloc\");\n            res = -1;\n\n            goto end;\n        }\n    }\n\n    dstContext = outContext = NULL;\n    srcContext= sws_getContext(w, h, PIX_FMT_YUV420P, srcW, srcH, srcFormat, flags, NULL, NULL, NULL);\n    if (srcContext == NULL) {\n        fprintf(stderr, \"Failed to get %s ---> %s\\n\",\n                sws_format_name(PIX_FMT_YUV420P),\n                sws_format_name(srcFormat));\n        res = -1;\n\n        goto end;\n    }\n    dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);\n    if (dstContext == NULL) {\n        fprintf(stderr, \"Failed to get %s ---> %s\\n\",\n                sws_format_name(srcFormat),\n                sws_format_name(dstFormat));\n        res = -1;\n\n        goto end;\n    }\n    outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUV420P, flags, NULL, NULL, NULL);\n    if (outContext == NULL) {\n        fprintf(stderr, \"Failed to get %s ---> %s\\n\",\n                sws_format_name(dstFormat),\n                sws_format_name(PIX_FMT_YUV420P));\n        res = -1;\n\n        goto end;\n    }\n//    printf(\"test %X %X %X -> %X %X %X\\n\", (int)ref[0], (int)ref[1], (int)ref[2],\n//        (int)src[0], (int)src[1], (int)src[2]);\n\n    sws_scale(srcContext, ref, refStride, 0, h   , src, srcStride);\n    sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n    sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);\n\n#if defined(ARCH_X86)\n    asm volatile (\"emms\\n\\t\");\n#endif\n\n    ssdY= getSSD(ref[0], out[0], refStride[0], refStride[0], w, h);\n    ssdU= getSSD(ref[1], out[1], refStride[1], refStride[1], (w+1)>>1, (h+1)>>1);\n    ssdV= getSSD(ref[2], out[2], refStride[2], refStride[2], (w+1)>>1, (h+1)>>1);\n\n    if (srcFormat == PIX_FMT_GRAY8 || dstFormat==PIX_FMT_GRAY8) ssdU=ssdV=0; //FIXME check that output is really gray\n\n    ssdY/= w*h;\n    ssdU/= w*h/4;\n    ssdV/= w*h/4;\n\n    if (ssdY>100 || ssdU>100 || ssdV>100){\n        printf(\" %s %dx%d -> %s %4dx%4d flags=%2d SSD=%5lld,%5lld,%5lld\\n\",\n               sws_format_name(srcFormat), srcW, srcH,\n               sws_format_name(dstFormat), dstW, dstH,\n               flags,\n               ssdY, ssdU, ssdV);\n    }\n\n    end:\n\n    sws_freeContext(srcContext);\n    sws_freeContext(dstContext);\n    sws_freeContext(outContext);\n\n    for (i=0; i<3; i++){\n        free(src[i]);\n        free(dst[i]);\n        free(out[i]);\n    }\n\n    return res;\n}", "path": "ext\\ffmpeg\\libswscale\\swscale-example.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "// return 0 on packet, no more left, 1 on packet, 1 on partial packet...\n", "func_signal": "static int h264_handle_packet(RTPDemuxContext * s,\n                              AVPacket * pkt,\n                              uint32_t * timestamp,\n                              const uint8_t * buf,\n                              int len)", "code": "{\n#ifdef DEBUG\n    h264_rtp_extra_data *data = s->dynamic_protocol_context;\n#endif\n    uint8_t nal = buf[0];\n    uint8_t type = (nal & 0x1f);\n    int result= 0;\n    uint8_t start_sequence[]= {0, 0, 1};\n\n    assert(data);\n    assert(data->cookie == MAGIC_COOKIE);\n    assert(buf);\n\n    if (type >= 1 && type <= 23)\n        type = 1;              // simplify the case. (these are all the nal types used internally by the h264 codec)\n    switch (type) {\n    case 0:                    // undefined;\n        result= -1;\n        break;\n\n    case 1:\n        av_new_packet(pkt, len+sizeof(start_sequence));\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n        memcpy(pkt->data+sizeof(start_sequence), buf, len);\n#ifdef DEBUG\n        data->packet_types_received[nal & 0x1f]++;\n#endif\n        break;\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n        // consume the STAP-A NAL\n        buf++;\n        len--;\n        // first we are going to figure out the total size....\n        {\n            int pass= 0;\n            int total_length= 0;\n            uint8_t *dst= NULL;\n\n            for(pass= 0; pass<2; pass++) {\n                const uint8_t *src= buf;\n                int src_len= len;\n\n                do {\n                    uint16_t nal_size = AV_RB16(src); // this going to be a problem if unaligned (can it be?)\n\n                    // consume the length of the aggregate...\n                    src += 2;\n                    src_len -= 2;\n\n                    if (nal_size <= src_len) {\n                        if(pass==0) {\n                            // counting...\n                            total_length+= sizeof(start_sequence)+nal_size;\n                        } else {\n                            // copying\n                            assert(dst);\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n                            dst+= sizeof(start_sequence);\n                            memcpy(dst, src, nal_size);\n#ifdef DEBUG\n                            data->packet_types_received[*src & 0x1f]++;\n#endif\n                            dst+= nal_size;\n                        }\n                    } else {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n                    }\n\n                    // eat what we handled...\n                    src += nal_size;\n                    src_len -= nal_size;\n\n                    if (src_len < 0)\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n                } while (src_len > 2);      // because there could be rtp padding..\n\n                if(pass==0) {\n                    // now we know the total size of the packet (with the start sequences added)\n                    av_new_packet(pkt, total_length);\n                    dst= pkt->data;\n                } else {\n                    assert(dst-pkt->data==total_length);\n                }\n            }\n        }\n        break;\n\n    case 25:                   // STAP-B\n    case 26:                   // MTAP-16\n    case 27:                   // MTAP-24\n    case 29:                   // FU-B\n        av_log(NULL, AV_LOG_ERROR,\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n               type);\n        result= -1;\n        break;\n\n    case 28:                   // FU-A (fragmented nal)\n        buf++;\n        len--;                  // skip the fu_indicator\n        {\n            // these are the same as above, we just redo them here for clarity...\n            uint8_t fu_indicator = nal;\n            uint8_t fu_header = *buf;   // read the fu_header.\n            uint8_t start_bit = fu_header >> 7;\n//            uint8_t end_bit = (fu_header & 0x40) >> 6;\n            uint8_t nal_type = (fu_header & 0x1f);\n            uint8_t reconstructed_nal;\n\n            // reconstruct this packet's true nal; only the data follows..\n            reconstructed_nal = fu_indicator & (0xe0);  // the original nal forbidden bit and NRI are stored in this packet's nal;\n            reconstructed_nal |= nal_type;\n\n            // skip the fu_header...\n            buf++;\n            len--;\n\n#ifdef DEBUG\n            if (start_bit)\n                data->packet_types_received[nal_type]++;\n#endif\n            if(start_bit) {\n                // copy in the start sequence, and the reconstructed nal....\n                av_new_packet(pkt, sizeof(start_sequence)+sizeof(nal)+len);\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n                pkt->data[sizeof(start_sequence)]= reconstructed_nal;\n                memcpy(pkt->data+sizeof(start_sequence)+sizeof(nal), buf, len);\n            } else {\n                av_new_packet(pkt, len);\n                memcpy(pkt->data, buf, len);\n            }\n        }\n        break;\n\n    case 30:                   // undefined\n    case 31:                   // undefined\n    default:\n        av_log(NULL, AV_LOG_ERROR, \"Undefined type (%d)\", type);\n        result= -1;\n        break;\n    }\n\n    return result;\n}", "path": "ext\\ffmpeg\\libavformat\\rtp_h264.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*get the UTC time expressed in RTP timescale*/\n", "func_signal": "u32 gf_rtp_channel_time(GF_RTPChannel *ch)", "code": "{\n\tu32 sec, frac, res;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = ( (u32) ( (frac>>26)*ch->TimeScale) ) >> 6;\n\tres += ch->TimeScale*(sec - ch->ntp_init);\n\treturn (u32) res;\n}", "path": "ext\\gpac\\src\\ietf\\rtp.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* this code assume stride % 16 == 0 *and* tmp is properly aligned */\n", "func_signal": "static void PREFIX_h264_qpel16_hv_lowpass_altivec(uint8_t * dst, int16_t * tmp, uint8_t * src, int dstStride, int tmpStride, int srcStride)", "code": "{\n  POWERPC_PERF_DECLARE(PREFIX_h264_qpel16_hv_lowpass_num, 1);\n  register int i;\n  LOAD_ZERO;\n  const vec_u8_t permM2 = vec_lvsl(-2, src);\n  const vec_u8_t permM1 = vec_lvsl(-1, src);\n  const vec_u8_t permP0 = vec_lvsl(+0, src);\n  const vec_u8_t permP1 = vec_lvsl(+1, src);\n  const vec_u8_t permP2 = vec_lvsl(+2, src);\n  const vec_u8_t permP3 = vec_lvsl(+3, src);\n  const vec_s16_t v20ss = vec_sl(vec_splat_s16(5),vec_splat_u16(2));\n  const vec_u32_t v10ui = vec_splat_u32(10);\n  const vec_s16_t v5ss = vec_splat_s16(5);\n  const vec_s16_t v1ss = vec_splat_s16(1);\n  const vec_s32_t v512si = vec_sl(vec_splat_s32(1),vec_splat_u32(9));\n  const vec_u32_t v16ui = vec_sl(vec_splat_u32(1),vec_splat_u32(4));\n\n  register int align = ((((unsigned long)src) - 2) % 16);\n\n  vec_s16_t srcP0A, srcP0B, srcP1A, srcP1B,\n                      srcP2A, srcP2B, srcP3A, srcP3B,\n                      srcM1A, srcM1B, srcM2A, srcM2B,\n                      sum1A, sum1B, sum2A, sum2B, sum3A, sum3B,\n                      pp1A, pp1B, pp2A, pp2B, psumA, psumB;\n\n  const vec_u8_t mperm = (const vec_u8_t)\n    AVV(0x00, 0x08, 0x01, 0x09, 0x02, 0x0A, 0x03, 0x0B,\n        0x04, 0x0C, 0x05, 0x0D, 0x06, 0x0E, 0x07, 0x0F);\n  int16_t *tmpbis = tmp;\n\n  vec_s16_t tmpM1ssA, tmpM1ssB, tmpM2ssA, tmpM2ssB,\n                      tmpP0ssA, tmpP0ssB, tmpP1ssA, tmpP1ssB,\n                      tmpP2ssA, tmpP2ssB;\n\n  vec_s32_t pp1Ae, pp1Ao, pp1Be, pp1Bo, pp2Ae, pp2Ao, pp2Be, pp2Bo,\n                    pp3Ae, pp3Ao, pp3Be, pp3Bo, pp1cAe, pp1cAo, pp1cBe, pp1cBo,\n                    pp32Ae, pp32Ao, pp32Be, pp32Bo, sumAe, sumAo, sumBe, sumBo,\n                    ssumAe, ssumAo, ssumBe, ssumBo;\n  vec_u8_t fsum, sumv, sum, vdst;\n  vec_s16_t ssume, ssumo;\n\n  POWERPC_PERF_START_COUNT(PREFIX_h264_qpel16_hv_lowpass_num, 1);\n  src -= (2 * srcStride);\n  for (i = 0 ; i < 21 ; i ++) {\n    vec_u8_t srcM2, srcM1, srcP0, srcP1, srcP2, srcP3;\n    vec_u8_t srcR1 = vec_ld(-2, src);\n    vec_u8_t srcR2 = vec_ld(14, src);\n\n    switch (align) {\n    default: {\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = vec_perm(srcR1, srcR2, permP2);\n      srcP3 = vec_perm(srcR1, srcR2, permP3);\n    } break;\n    case 11: {\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = vec_perm(srcR1, srcR2, permP2);\n      srcP3 = srcR2;\n    } break;\n    case 12: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = vec_perm(srcR1, srcR2, permP1);\n      srcP2 = srcR2;\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 13: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = vec_perm(srcR1, srcR2, permP0);\n      srcP1 = srcR2;\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 14: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = vec_perm(srcR1, srcR2, permM1);\n      srcP0 = srcR2;\n      srcP1 = vec_perm(srcR2, srcR3, permP1);\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    case 15: {\n      vec_u8_t srcR3 = vec_ld(30, src);\n      srcM2 = vec_perm(srcR1, srcR2, permM2);\n      srcM1 = srcR2;\n      srcP0 = vec_perm(srcR2, srcR3, permP0);\n      srcP1 = vec_perm(srcR2, srcR3, permP1);\n      srcP2 = vec_perm(srcR2, srcR3, permP2);\n      srcP3 = vec_perm(srcR2, srcR3, permP3);\n    } break;\n    }\n\n    srcP0A = (vec_s16_t) vec_mergeh(zero_u8v, srcP0);\n    srcP0B = (vec_s16_t) vec_mergel(zero_u8v, srcP0);\n    srcP1A = (vec_s16_t) vec_mergeh(zero_u8v, srcP1);\n    srcP1B = (vec_s16_t) vec_mergel(zero_u8v, srcP1);\n\n    srcP2A = (vec_s16_t) vec_mergeh(zero_u8v, srcP2);\n    srcP2B = (vec_s16_t) vec_mergel(zero_u8v, srcP2);\n    srcP3A = (vec_s16_t) vec_mergeh(zero_u8v, srcP3);\n    srcP3B = (vec_s16_t) vec_mergel(zero_u8v, srcP3);\n\n    srcM1A = (vec_s16_t) vec_mergeh(zero_u8v, srcM1);\n    srcM1B = (vec_s16_t) vec_mergel(zero_u8v, srcM1);\n    srcM2A = (vec_s16_t) vec_mergeh(zero_u8v, srcM2);\n    srcM2B = (vec_s16_t) vec_mergel(zero_u8v, srcM2);\n\n    sum1A = vec_adds(srcP0A, srcP1A);\n    sum1B = vec_adds(srcP0B, srcP1B);\n    sum2A = vec_adds(srcM1A, srcP2A);\n    sum2B = vec_adds(srcM1B, srcP2B);\n    sum3A = vec_adds(srcM2A, srcP3A);\n    sum3B = vec_adds(srcM2B, srcP3B);\n\n    pp1A = vec_mladd(sum1A, v20ss, sum3A);\n    pp1B = vec_mladd(sum1B, v20ss, sum3B);\n\n    pp2A = vec_mladd(sum2A, v5ss, zero_s16v);\n    pp2B = vec_mladd(sum2B, v5ss, zero_s16v);\n\n    psumA = vec_sub(pp1A, pp2A);\n    psumB = vec_sub(pp1B, pp2B);\n\n    vec_st(psumA, 0, tmp);\n    vec_st(psumB, 16, tmp);\n\n    src += srcStride;\n    tmp += tmpStride; /* int16_t*, and stride is 16, so it's OK here */\n  }\n\n  tmpM2ssA = vec_ld(0, tmpbis);\n  tmpM2ssB = vec_ld(16, tmpbis);\n  tmpbis += tmpStride;\n  tmpM1ssA = vec_ld(0, tmpbis);\n  tmpM1ssB = vec_ld(16, tmpbis);\n  tmpbis += tmpStride;\n  tmpP0ssA = vec_ld(0, tmpbis);\n  tmpP0ssB = vec_ld(16, tmpbis);\n  tmpbis += tmpStride;\n  tmpP1ssA = vec_ld(0, tmpbis);\n  tmpP1ssB = vec_ld(16, tmpbis);\n  tmpbis += tmpStride;\n  tmpP2ssA = vec_ld(0, tmpbis);\n  tmpP2ssB = vec_ld(16, tmpbis);\n  tmpbis += tmpStride;\n\n  for (i = 0 ; i < 16 ; i++) {\n    const vec_s16_t tmpP3ssA = vec_ld(0, tmpbis);\n    const vec_s16_t tmpP3ssB = vec_ld(16, tmpbis);\n\n    const vec_s16_t sum1A = vec_adds(tmpP0ssA, tmpP1ssA);\n    const vec_s16_t sum1B = vec_adds(tmpP0ssB, tmpP1ssB);\n    const vec_s16_t sum2A = vec_adds(tmpM1ssA, tmpP2ssA);\n    const vec_s16_t sum2B = vec_adds(tmpM1ssB, tmpP2ssB);\n    const vec_s16_t sum3A = vec_adds(tmpM2ssA, tmpP3ssA);\n    const vec_s16_t sum3B = vec_adds(tmpM2ssB, tmpP3ssB);\n\n    tmpbis += tmpStride;\n\n    tmpM2ssA = tmpM1ssA;\n    tmpM2ssB = tmpM1ssB;\n    tmpM1ssA = tmpP0ssA;\n    tmpM1ssB = tmpP0ssB;\n    tmpP0ssA = tmpP1ssA;\n    tmpP0ssB = tmpP1ssB;\n    tmpP1ssA = tmpP2ssA;\n    tmpP1ssB = tmpP2ssB;\n    tmpP2ssA = tmpP3ssA;\n    tmpP2ssB = tmpP3ssB;\n\n    pp1Ae = vec_mule(sum1A, v20ss);\n    pp1Ao = vec_mulo(sum1A, v20ss);\n    pp1Be = vec_mule(sum1B, v20ss);\n    pp1Bo = vec_mulo(sum1B, v20ss);\n\n    pp2Ae = vec_mule(sum2A, v5ss);\n    pp2Ao = vec_mulo(sum2A, v5ss);\n    pp2Be = vec_mule(sum2B, v5ss);\n    pp2Bo = vec_mulo(sum2B, v5ss);\n\n    pp3Ae = vec_sra((vec_s32_t)sum3A, v16ui);\n    pp3Ao = vec_mulo(sum3A, v1ss);\n    pp3Be = vec_sra((vec_s32_t)sum3B, v16ui);\n    pp3Bo = vec_mulo(sum3B, v1ss);\n\n    pp1cAe = vec_add(pp1Ae, v512si);\n    pp1cAo = vec_add(pp1Ao, v512si);\n    pp1cBe = vec_add(pp1Be, v512si);\n    pp1cBo = vec_add(pp1Bo, v512si);\n\n    pp32Ae = vec_sub(pp3Ae, pp2Ae);\n    pp32Ao = vec_sub(pp3Ao, pp2Ao);\n    pp32Be = vec_sub(pp3Be, pp2Be);\n    pp32Bo = vec_sub(pp3Bo, pp2Bo);\n\n    sumAe = vec_add(pp1cAe, pp32Ae);\n    sumAo = vec_add(pp1cAo, pp32Ao);\n    sumBe = vec_add(pp1cBe, pp32Be);\n    sumBo = vec_add(pp1cBo, pp32Bo);\n\n    ssumAe = vec_sra(sumAe, v10ui);\n    ssumAo = vec_sra(sumAo, v10ui);\n    ssumBe = vec_sra(sumBe, v10ui);\n    ssumBo = vec_sra(sumBo, v10ui);\n\n    ssume = vec_packs(ssumAe, ssumBe);\n    ssumo = vec_packs(ssumAo, ssumBo);\n\n    sumv = vec_packsu(ssume, ssumo);\n    sum = vec_perm(sumv, sumv, mperm);\n\n    ASSERT_ALIGNED(dst);\n    vdst = vec_ld(0, dst);\n\n    OP_U8_ALTIVEC(fsum, sum, vdst);\n\n    vec_st(fsum, 0, dst);\n\n    dst += dstStride;\n  }\n  POWERPC_PERF_STOP_COUNT(PREFIX_h264_qpel16_hv_lowpass_num, 1);\n}", "path": "ext\\ffmpeg\\libavcodec\\ppc\\h264_template_altivec.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*we don't need any private context*/\n", "func_signal": "GF_Raster2D *EVG_LoadRenderer()", "code": "{\n\tGF_Raster2D *dr;\n\tGF_SAFEALLOC(dr, GF_Raster2D);\n\tGF_REGISTER_MODULE_INTERFACE(dr, GF_RASTER_2D_INTERFACE, \"GPAC 2D Raster\", \"gpac distribution\")\n\n\n\tdr->stencil_new = evg_stencil_new;\n\tdr->stencil_delete = evg_stencil_delete;\n\tdr->stencil_set_matrix = evg_stencil_set_matrix;\n\tdr->stencil_set_brush_color = evg_stencil_set_brush_color;\n\tdr->stencil_set_gradient_mode = evg_stencil_set_gradient_mode;\n\tdr->stencil_set_linear_gradient = evg_stencil_set_linear_gradient;\n\tdr->stencil_set_radial_gradient = evg_stencil_set_radial_gradient;\n\tdr->stencil_set_gradient_interpolation = evg_stencil_set_gradient_interpolation;\n\tdr->stencil_set_texture = evg_stencil_set_texture;\n\tdr->stencil_set_tiling = evg_stencil_set_tiling;\n\tdr->stencil_set_filter = evg_stencil_set_filter;\n\tdr->stencil_set_color_matrix = evg_stencil_set_color_matrix;\n\tdr->stencil_set_texture_alpha = evg_stencil_set_texture_alpha;\n\tdr->stencil_create_texture = evg_stencil_create_texture;\n\tdr->stencil_texture_modified = NULL;\n\n\tdr->surface_new = evg_surface_new;\n\tdr->surface_delete = evg_surface_delete;\n\tdr->surface_attach_to_device = NULL;\n\tdr->surface_attach_to_texture = evg_surface_attach_to_texture;\n\tdr->surface_attach_to_buffer = evg_surface_attach_to_buffer;\n\tdr->surface_detach = evg_surface_detach;\n\tdr->surface_set_raster_level = evg_surface_set_raster_level;\n\tdr->surface_set_matrix = evg_surface_set_matrix;\n\tdr->surface_set_clipper = evg_surface_set_clipper;\n\tdr->surface_set_path = evg_surface_set_path;\n\tdr->surface_fill = evg_surface_fill;\n\tdr->surface_flush = NULL;\n\tdr->surface_clear = evg_surface_clear;\n\treturn dr;\n}", "path": "ext\\gpac\\modules\\soft_raster\\raster_load.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/*\n\tThis is the generic routine for child traversing - note we are not duplicating the effect\n*/\n", "func_signal": "void svg_render_node(GF_Node *node, RenderEffect2D *eff)", "code": "{\n#if 0\n\tBool has_listener = gf_dom_listener_count(node);\n//\tfprintf(stdout, \"rendering %s of type %s\\n\", gf_node_get_name(node), gf_node_get_class_name(node));\n\tif (has_listener) {\n\t\teff->nb_listeners++;\n\t\tgf_node_render(node, eff);\n\t\teff->nb_listeners--;\n\t} else {\n\t\tgf_node_render(node, eff);\n\t}\n#else\n\tgf_node_render(node, eff);\n#endif\n}", "path": "ext\\gpac\\modules\\render2d\\svg_base_da.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "/* radial gradient */\n", "func_signal": "static void SVG_UpdateRadialGradient(GF_TextureHandler *txh)", "code": "{\n\tSVG_Element *rg = (SVG_Element *) txh->owner;\n\tSVG_GradientStack *st = (SVG_GradientStack *) gf_node_get_private(txh->owner);\n\tif (!txh->hwtx) txh->hwtx = txh->compositor->r2d->stencil_new(txh->compositor->r2d, GF_STENCIL_RADIAL_GRADIENT);\n\tSVG_UpdateGradient(st, rg->children);\n}", "path": "ext\\gpac\\modules\\render2d\\svg_base_da.c", "repo_name": "anaisbetts/yikes", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 17620}
{"docstring": "// TODO: implement with mutex or condvar in order to be independent\n// on thread runqueue api\n", "func_signal": "static void timer_awake_thread(void *_thread)", "code": "{\n  tcb_t *thread = _thread;\n  thread_wake(thread);\n}", "path": "timer.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// recv functions\n", "func_signal": "int pcnet32_collect(device_t *this, eth_frame_t *pkt)", "code": "{\n  mutex_lock(&private(this)->collector_condlock);\n\n  list_add_tail(&pkt->collector_list, &private(this)->collector_list);\n\n  condvar_broadcast(&private(this)->collector_condvar);\n  mutex_unlock(&private(this)->collector_condlock);\n  return 0;\n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// recv polling loop \n", "func_signal": "void pcnet32_main_loop_recv(device_t *this)", "code": "{\n  int i;\n  int rx_waiting=1;\n\n  while (1) {  \n    // condvar wait for interrupt\n    //   .... wile(condition) condvar_wait(blabla);;;;;; ....\n    // interrupt arrived\n\n    for(i = 0; i < PCNET32_RING_SIZE; i++) {\n      write_csr(private(this)->pci->io, PCNET32_CSR0,read_csr(private(this)->pci->io, PCNET32_CSR0));\n          \n      if(list_empty(&f_buff_rx[i].collector_list)) {\t\n\tif(rx_waiting && !(rx_desc[i].status & 0x8000)) {\n\t  f_buff_rx[i].len = rx_desc[i].msg_length;\n\t  uprintf(\"LOW got packet\\n\");\n\t  pcnet32_collect(this, &f_buff_rx[i]);\t  \n\t}       \t\n      }      \n    }\n  }\n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// this func writes a cluster of 4096 bytes 8 sector of 512 bytes\n", "func_signal": "u_int8_t write_cluster(u_int32_t lcn, cluster_t buff)", "code": "{\n\n  u_int32_t sector_num = lcn*CLUSTER_DIM;\n  u_int8_t i;\n  for(i=0; i<CLUSTER_DIM; i++) {\n    //printf(\"writing sector %d\\n\", i);\n    write_sector(buff+(i*512), DRIVE, sector_num+i, N_SECTOR);// read  cluster of 4096 bytes\n    delay(10);\n  }\n  return 0;\n}", "path": "ngulfs_low_api.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// producer-consumer mutex\n", "func_signal": "static void producer(void * arg)", "code": "{\n  xprintf(\"produced starting\\n\");\n\n  while(1);\n\n  while(1) {\n    mutex_lock(&pc_mutex);\n    xprintf(\"Producer: lock acquired \\n\");\n    delay(4000);\n    xprintf(\"Producer: produced releasing lock\\n\");\n    mutex_unlock(&pc_mutex);\n  }\n}", "path": "thread_test.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// init function \n", "func_signal": "void pcnet32_device_init(device_t* this)", "code": "{\n  \n  pci_dev_t  *dev;\n  int i;\n  u_int16_t pci_command;\n  dev = private(this)->pci;\n  \n  uprintf(\"AMD Pcnet32 ethernet interface at %x:%x.%x\\n\", dev->bus, dev->dev, dev->fn);\n  uprintf(\"Mem %p, I/O %p irq %d\\n\", dev->memory, dev->io, dev->irq);\n  \n  pcnet32_reset(dev);\n  \n  /* 32bit mode */\n  write_bcr(dev->io, 20, 2); \n  \n  /* the card  mac address */\n  for(i=0; i<4; i++) {\n    mymac[i] = inl(dev->io + i*4);\n    memcpy(&private(this)->mac, mymac, 6);\n  }\n  \n  print_mac();\n  \n  \n  /* enable bus mastering (for DMA ring access) */\n  pci_bios_read_word(dev, PCI_COMMAND, &pci_command);\n  pci_bios_write_word(dev, PCI_COMMAND, pci_command | PCI_COMMAND_MASTER);\n  \n  /* abilitiamo gli interreupt */\n  set_isr(0x20 + dev->irq, pcnet32_isr);\n  enable_irq(dev->irq);\n\n  pcnet32_print_status(dev);\n  \n  /* mettiamo su l' \"init block\" */\n  \n  init_block.mode = 0x000; // 0=all, 1=tx, 2=rx, 3=none\n  init_block.tlen_res = 0;\n  init_block.rlen_res = 0;\n  init_block.tlen = PCNET32_RING_SIZE_BITS; // length of trasmission buffer ring\n  init_block.rlen = PCNET32_RING_SIZE_BITS; // length of recv  buffer ring\n  \n  for(i=0; i<6; i++)\n    init_block.phys_addr[i] = mac[i]; // paddr: mac address in the init block \n  \n  init_block.filter[0] = 0;          // filter for multicast etc\n  init_block.filter[1] = 0;\n  init_block.rx_ring = (u_int32_t)rx_desc; // init recv descriptor ring buffer addr\n  init_block.tx_ring = (u_int32_t)tx_desc; // init send descriptor ring buffer addr\n  \n  \n  for(i=0;i<PCNET32_RING_SIZE;i++){\n    //tx_desc[i].base = (u_int32_t)&f_buff_tx[i];old system\n    \n\n\n    tx_desc[i].length = -(int16_t)(ETH_MTU);\n    tx_desc[i].status = 0x300;\n    tx_desc[i].misc = 0;\n    \n    rx_desc[i].base = (u_int32_t)&f_buff_rx[i];\n    rx_desc[i].buf_length = -(int16_t)(sizeof(f_buff_rx->payload));\n    rx_desc[i].status = 0x8000;\n\n    // tx buffering init\n    tx_buffer[i].desc=&tx_desc[i];// inizializzo il buffer di puntatori ai descrittori di trasmissione \n    tx_buffer[i].coled=0;// test \n    list_add_tail(&tx_buffer[i].tx_BUFF_list, &private(this)->tx_FREE_list); // viene riempita la lista con tutti i descrittori\n    \n    \n    INIT_LIST_HEAD(&f_buff_rx[i].collector_list);\n  }\n  \n\n  write_csr(dev->io, PCNET32_IADR_LO, (u_int32_t)(&init_block) & 0xFFFF);\n  write_csr(dev->io, PCNET32_IADR_HI, (u_int32_t)(&init_block) >> 16);\n  write_csr(dev->io, PCNET32_CSR4, 0x0915);\n  write_csr(dev->io, PCNET32_CSR0, PCNET32_INIT); // initialize\n  \n  /* aspettiamo porcodio  */\n  i=0;\n  while(i++ < 10000) \n    if(read_csr(dev->io, 0) & PCNET32_IDON) \n      goto init_done;    \n  printf(\"timeout\\n\");\n   panic(\"TIMEOUT\");\n init_done:\n  \n  write_csr(dev->io, PCNET32_CSR0, PCNET32_STRT | PCNET32_IDON);\n  \n  pcnet32_print_status(dev);\n  \n  xprintf(\"AMD pcnet32: I'm ready to run on the net\\n\");\n  \n  for(i = 0; i < PCNET32_RING_SIZE; i++) \n    tx_desc[i].status = 0x300;\n  \n  for(i = 0; i < PCNET32_RING_SIZE; i++)  rx_desc[i].status |= 0x8000;\n  \n  thread_create(pcnet32_main_loop_recv, this, 0);\n  thread_create(pcnet32_main_loop_send, this, 0);\n  //  pcnet32_ether_test(this);\n  \n  \n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "//this func caches the mft file_record\n", "func_signal": "u_int8_t mount(void)", "code": "{\n  read_cluster(MFT_LCN, (cluster_t)&cached_mft);\n  return 0;\n}", "path": "ngulfs_low_api.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// send polling loop \n", "func_signal": "void pcnet32_main_loop_send(device_t *this)", "code": "{\n  int i;\n  int tx_waiting=1; \n  while(1){\n    \n    write_csr(private(this)->pci->io, PCNET32_CSR0,read_csr(private(this)->pci->io, PCNET32_CSR0));\n \n    if(!list_empty(&private(this)->tx_BUSY_list)) {\n      pcnet32_buff_tx_list_t *pkt = list_entry(private(this)->tx_BUSY_list.next,  \n\t\t\t\t\t       pcnet32_buff_tx_list_t , tx_BUFF_list);\n      uprintf(\"main loop send: chiamando decollect(%p, desc = %p)\\n\", pkt, pkt->desc);\n      pcnet32_decollect_tx(this, pkt);\n    }\n    \n    /*    for(i = 0; i < PCNET32_RING_SIZE; i++) {\n      if(!list_empty(&private(this)->tx_BUSY_list)){\n       \tif(tx_waiting && tx_buffer[i].coled){\n\t  pcnet32_decollect_tx(this, &tx_buffer[i]);\n\t  \n\t}\n\t\n      } //else uprintf(\"busy list vuota\\n\");\n      } */\n  }\n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// this func gets lcn from an extent list \n", "func_signal": "u_int32_t get_lcn(extent *list, u_int32_t len, cn_t vcn)", "code": "{\n  cn_t current_vcn = 0;\n  int i;\n  for(i=0; i<len; i++) {\n    current_vcn += list[i].len;\n    if(current_vcn > vcn)\n      return list[i].lcn + vcn - (current_vcn - list[i].len);\n  }\n   \n  printf(\"ERROR, no such lcn for vcn %d\\n\", vcn);\n  return -1;\n}", "path": "ngulfs_low_api.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "/*\n * This is the main work fuction which handles both strtol (uflag = 0) and\n * strtoul (uflag = 1).\n */\n", "func_signal": "unsigned long _strto_l(const char *str, char **endptr, int base, int uflag)", "code": "{\n    unsigned long number = 0;\n    unsigned long cutoff;\n    char *pos = (char *) str;\n#if _STRTO_ENDPTR\n    char *fail_char = (char *) str;\n#endif\n    int digit, cutoff_digit;\n    int negative;\n\n    while (isspace(*pos)) {\t/* skip leading whitespace */\n\t++pos;\n    }\n\n    /* handle optional sign */\n    negative = 0;\n    switch(*pos) {\n    case '-': negative = 1;\t/* fall through to increment pos */\n    case '+': ++pos;\n    }\n\n    if ((base == 16) && (*pos == '0')) { /* handle option prefix */\n\t++pos;\n#if _STRTO_ENDPTR\n\tfail_char = pos;\n#endif\n\tif ((*pos == 'x') || (*pos == 'X')) {\n\t    ++pos;\n\t}\n    }\n    \n    if (base == 0) {\t\t/* dynamic base */\n\tbase = 10;\t\t/* default is 10 */\n\tif (*pos == '0') {\n\t    ++pos;\n\t    base -= 2;\t\t/* now base is 8 (or 16) */\n#if _STRTO_ENDPTR\n\t    fail_char = pos;\n#endif\n\t    if ((*pos == 'x') || (*pos == 'X')) {\n\t\tbase += 8;\t/* base is 16 */\n\t\t++pos;\n\t    }\n\t}\n    }\n\n    if ((base < 2) || (base > 36)) { /* illegal base */\n\tgoto DONE;\n    }\n\n    cutoff = ULONG_MAX / base;\n    cutoff_digit = ULONG_MAX - cutoff * base;\n\n    while (1) {\n\tdigit = 40;\n\tif ((*pos >= '0') && (*pos <= '9')) {\n\t    digit = (*pos - '0');\n\t} else if (*pos >= 'a') {\n\t    digit = (*pos - 'a' + 10);\n\t} else if (*pos >= 'A') {\n\t    digit = (*pos - 'A' + 10);\n\t} else break;\n\n\tif (digit >= base) {\n\t    break;\n\t}\n\n\t++pos;\n#if _STRTO_ENDPTR\n\tfail_char = pos;\n#endif\n\n\t/* adjust number, with overflow check */\n\tif ((number > cutoff)\n\t    || ((number == cutoff) && (digit > cutoff_digit))) {\n\t    number = ULONG_MAX;\n\t    if (uflag) {\n\t\tnegative = 0; /* since unsigned returns ULONG_MAX */\n\t    }\n#if _STRTO_ERRNO\n\t    errno = ERANGE;\n#endif\n\t} else {\n\t    number = number * base + digit;\n\t}\n\n    }\n\n DONE:\n#if _STRTO_ENDPTR\n    if (endptr) {\n\t*endptr = fail_char;\n    }\n#endif\n\n    if (negative) {\n\tif (!uflag && (number > ((unsigned long)(-(1+LONG_MIN)))+1)) {\n#if _STRTO_ERRNO\n\t    errno = ERANGE;\n#endif\n\t    return (unsigned long) LONG_MIN;\n\t}\n\treturn (unsigned long)(-((long)number));\n    } else {\n\tif (!uflag && (number > (unsigned long) LONG_MAX)) {\n#if _STRTO_ERRNO\n\t    errno = ERANGE;\n#endif\n\t    return LONG_MAX;\n\t}\n\treturn number;\n    }\n}", "path": "libc_strtol.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// this func  converts virtual_cn to logical_cn\n", "func_signal": "cn_t vcn_to_lcn(u_int32_t f_idx, u_int32_t vcn)", "code": "{\n  cn_t lcn;\n\n  lcn = get_lcn(cached_mft.ext_ls, cached_mft.len, f_idx);\n  read_file_record_fast(lcn, &frbuff);  //hardcoded bad need change\n  return get_lcn(frbuff.ext_ls, frbuff.len, vcn);\n\n}", "path": "ngulfs_low_api.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// low level function\n", "func_signal": "u_int16_t read_csr(u_int16_t base, u_int16_t address)", "code": "{\n  outw_p(address, base + PCNET32_RAP);\n  return inw(base + PCNET32_RDP);\n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "///////////////\n", "func_signal": "u_int16_t lance_ip_sum_calc(int len_ip_header, u_int16_t buff[])", "code": "{\n  u_int32_t sum=0;\n  u_int16_t i;\n    \n  for (i=0;i<len_ip_header/2;i++){\n    sum = sum + (u_int32_t) buff[i];\n  }\n\t\n  while (sum>>16)\n    sum = (sum & 0xFFFF)+(sum >> 16);\n\n  return ((u_int16_t) ~sum);\n}", "path": "lance_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// this func  reads a cluster of 4096 bytes 8 sector of 512 bytes \n", "func_signal": "u_int8_t read_cluster(u_int32_t lcn, cluster_t buff)", "code": "{\n  \n  u_int32_t sector_num = lcn*CLUSTER_DIM;\n  u_int8_t i;\n  u_int32_t ver;\n  ver=verify_lcn_buffed(lcn);\n  if(ver <= 4) {\n    memcpy(buff, tabula.cls[ver], 4096);\n  } else {\n    \n    for(i=0; i<CLUSTER_DIM; i++) {\n      // printf(\"reading sector\\n\");\n      read_sector(buff+(i*512), DRIVE, sector_num+i, N_SECTOR);// read  cluster of 4096 bytes\n    }\n    buffera(lcn, buff);\n  }\n  return 0;\n}", "path": "ngulfs_low_api.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "// THIS IS KAOS!!!! memory leaks everywhere\n", "func_signal": "int builtin_cd(shell_t* this, int argc, char** argv)", "code": "{\n  char *nwd;\n  char *oldcwd = process_current()->cwd;\n\n  if(argc > 1) \n    nwd = argv[1];\n  else {\n    process_current()->cwd = strdup(\"/\");\n    return 0;\n  }\n\n  // go to parent\n  if(strcmp(nwd, \"..\") == 0) {\n    if(strcmp(oldcwd, \"/\") != 0) {\n      nwd = file_path_dirname(oldcwd);\n      if(strlen(nwd) == 0)\n\tnwd = strdup(\"/\");\n    } else \n      return 0;\n  }\n  \n  char* newcwd = 0;\n  // relative paths\n  if(*nwd != '/') {\n    newcwd =  malloc(strlen(nwd) + strlen(oldcwd) + 1);\n    strcpy(newcwd, oldcwd);\n    if(strcmp(oldcwd, \"/\") != 0) // exception to prevent //path, bug in resolver\n      strcat(newcwd, \"/\");\n    strcat(newcwd, nwd);\n    \n  } else {\n    newcwd = strdup(nwd);\n  }\n\n  fnode_t *fnode = file_resolve_path(newcwd);\n  if(fnode == 0) {\n    xprintf(\"no such directory '%s'\\n\", newcwd);\n    return 1;\n  }\n  if(!(fnode->flags & DIRENT_DIR)) {\n    xprintf(\"'%s' is not a directory\\n\", newcwd);\n    return 1;\n  }\n  // TODO: memory leak. Who allocates fnodes, who caches and who frees them ?\n  //  free(fnode);\n\n  process_current()->cwd = newcwd;\n\n  return 0;\n}", "path": "shell_builtins.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "///// \n", "func_signal": "void setPos(int r, int c)", "code": "{\n  row = r;\n  col = c;\n}", "path": "libc.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "/** this functions switch to the given the context. \n * This function doesn't want to know anything about\n * policy and scheduling algorithm, it just do \n * thread dispatching (as called in VMS & WNT).\n *  Ideally this would be in the microkernel while\n * the scheduler in a subsystem (perhaps usermode) */\n", "func_signal": "void dispatcher_switch_to(struct dispatcher_context* next)", "code": "{\n  struct dispatcher_context *prev = current_context;\n  current_context = next;\n  asm(\"pusha\");\n  __dispatcher_switch_to(prev, next, prev);\n  \n  asm(\"popa\");\n}", "path": "dispatcher.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "//   send functions\n", "func_signal": "int pcnet32_collect_tx(device_t *this, const u_int32_t *payload, u_int32_t len)", "code": "{\n  xprintf(\"PCNET32 collect tx\\n\");\n\n  pcnet32_buff_tx_list_t  *pkt = list_entry(private(this)->tx_FREE_list.next,  \n\t\t\t\t\t    pcnet32_buff_tx_list_t , tx_BUFF_list);\n  // viene prelevato il primo desc libero dalla free list  \n  \n  list_del(&pkt->tx_BUFF_list); // viene eliminato dalla free list \n  \n  pkt->desc->base = (u_int32_t)payload;    // viene passato il puntatore al contenuto e la sua relativa lunghezza\n  pkt->desc->length = -(u_int16_t)len;\n  \n  pkt->coled=1;\n  list_add_tail(&pkt->tx_BUFF_list, &private(this)->tx_BUSY_list); // il pacchetto viene inserito nel buffer\n\n  // non decolletta e spedisce il messaggio\n  //  uprintf(\"user thread: while coled (%p)\\n\", pkt);\n  xprintf(\"waiting coled\\n\");\n  while(pkt->coled);\n  xprintf(\"coled is 0\\n\");\n\n  return len;\n}", "path": "net\\pcnet32_driver.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "/*********************/\n", "func_signal": "void i8255_init()", "code": "{\n  set_isr(0x21, i8255_isr);\n  \n  i8255_write_command(KBD_CMD_SELECT_SCANCODE);\n  i8255_write_data(2);\n}", "path": "i8255.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "///\n", "func_signal": "static void make_eth_arp(u_int8_t* buffer, int code, \n\t\t\t ip_address_t src_ip, mac_address_t src_mac,\n\t\t\t ip_address_t dst_ip, mac_address_t dst_mac)", "code": "{\n\n  arp_frame_t arp;\n  ethernet_frame_t eth;\n\n  arp.hard_type = cpu_to_net16(1);\n  arp.prot_type = cpu_to_net16(ETHER_T_IP);\n  arp.hard_size = 6;\n  arp.prot_size = 4;\n  arp.op = cpu_to_net16(code);\n  memcpy(&arp.sender_eth, src_mac, 6);\n  memcpy(&arp.target_eth, dst_mac, 6);\n  arp.sender_ip = src_ip;\n  arp.target_ip = dst_ip;\n\n  memcpy(&eth.src, src_mac, 6);\n  memcpy(&eth.dst, dst_mac, 6);\n  eth.type = cpu_to_net16(ETHER_T_ARP);\n\n  memcpy(buffer, &eth, sizeof(ethernet_frame_t));\n  memcpy(buffer+sizeof(ethernet_frame_t), &arp, sizeof(arp_frame_t));\n}", "path": "net\\arp.c", "repo_name": "mkmik/mikucos", "stars": 5, "license": "other", "language": "c", "size": 1836}
{"docstring": "/*****************************************************************\n * Return to LISP the reference created for a x_ipcQuerySend or x_ipcMultiQuery.\n * There may be a cleaner way to do this, but this seems the easiest\n * and quickest to implement (reids 11/13/92)\n ****************************************************************/\n", "func_signal": "X_IPC_REF_PTR x_ipcQuerySendRefLISPC (void)", "code": "{\n  X_IPC_REF_PTR result;\n\n  LOCK_M_MUTEX;\n  result = GET_M_GLOBAL(lispRefSaveGlobal);\n  UNLOCK_M_MUTEX;\n\n  return result;\n}", "path": "carmen\\carmen\\src\\ipc\\ipcLisp.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* Find string with the given enumerated value, and copy the string into\n   the (already allocated) LISP vector */\n", "func_signal": "char *enumValNameString (CONST_FORMAT_PTR format, int32 enumVal)", "code": "{\n  char *name;\n\n  if (format->formatter.a[0].i > 2 &&\n      0 <= enumVal && enumVal <= ENUM_MAX_VAL(format)) {\n    name = format->formatter.a[enumVal+2].f->formatter.name;\n    BCOPY(name, (char *)Vecdata(SymbolValue(lisp_value(0))), strlen(name));\n  }  \n  return (char *)SymbolValue(lisp_value(0));\n}", "path": "carmen\\carmen\\src\\ipc\\ipcLisp.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the tool to a mover */\n", "func_signal": "gint\nset_mover(void)", "code": "{\n  utensil = CARMEN_MAP_MOVER;\n  gtk_label_set_text(GTK_LABEL(tool_label), \"mover\");\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* draws a square of size 2 * brush_size on a side onto the pixmap and \n   the map */\n", "func_signal": "void \ndraw_brush( GtkWidget *widget __attribute__ ((unused)), \n\t    gdouble pix_x, gdouble pix_y)", "code": "{\n  int x_left, y_top, x, y;\n\n  GdkRectangle update_rect;\n\n  gdk_gc_set_foreground (drawing_gc, &color);\n\n  x_left = pix_x_to_map(pix_x) - brush_size + .5;\n  y_top  = pix_y_to_map(pix_y) + brush_size + .5;\n  update_rect.x = map_x_to_map_pix(x_left) + 1.0;\n  update_rect.y = map_y_to_map_pix(y_top ) + 1.0;\n  update_rect.width  = map_x_to_map_pix((double)(x_left) + brush_size * 2.0) -\n    update_rect.x + 1.0;\n  if(update_rect.width < 1)\n    update_rect.width = 1;\n  update_rect.height = map_y_to_map_pix((double)(y_top ) - brush_size * 2.0) -\n    update_rect.y + 1.0;\n  if(update_rect.height < 1)\n    update_rect.height = 1;\n  gdk_draw_rectangle (map_pixmap,\n\t\t      drawing_gc,\n\t\t      TRUE,\n\t\t      update_rect.x, update_rect.y,\n\t\t      update_rect.width, update_rect.height);\n\n  map_to_tmp();\n\t\n  for(x = x_left; x < x_left + 2.0 * brush_size; x ++)\n    if(x < map->config.x_size && x >= 0)\n      for(y = y_top - 2.0 * brush_size; y < y_top ; y++)\n\tif(y < map->config.y_size && y >= 0)\n\t  map->map[x][y] = ink;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the fuzzyness for fuzzy fill */\n", "func_signal": "gint \nset_fuzzyness(GtkAdjustment *adj)", "code": "{\n  char fuzzyness_text[10];\n\n  fuzzyness = adj->value;\n  sprintf(fuzzyness_text, \"%.2f\", fuzzyness);\n  gtk_label_set_text(GTK_LABEL(fuzzyness_label), fuzzyness_text);\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* draws a line of width line_size onto the map and the pixmap */\n", "func_signal": "void \ndraw_line(double pix_x1, double pix_y1, double pix_x2, double pix_y2)", "code": "{\n  carmen_bresenham_param_t width, length;\n  int map_x1, map_x2, map_y1, map_y2;\n  int x, y, w, h;\n  double theta;\n\n  theta = calc_theta(pix_x1, pix_y1, pix_x2, pix_y2);\n\n  map_x1 = pix_x_to_map(pix_x1-line_size/2.0*cos(theta + M_PI)*mult) + .5;\n  map_x2 = pix_x_to_map(pix_x2-line_size/2.0*cos(theta + M_PI)*mult) + .5;\n  map_y1 = pix_y_to_map(pix_y1-line_size/2.0*sin(theta + M_PI)*mult) + .5;\n  map_y2 = pix_y_to_map(pix_y2-line_size/2.0*sin(theta + M_PI)*mult) + .5;\n\n  if (drawing_offlimits)\n    {\n      check_offlimits_array_size();\n      offlimits_array[num_offlimits_segments].type = CARMEN_OFFLIMITS_LINE_ID;\n      offlimits_array[num_offlimits_segments].x1 = map_x1;\n      offlimits_array[num_offlimits_segments].y1 = map_y1;\n      offlimits_array[num_offlimits_segments].x2 = map_x2;\n      offlimits_array[num_offlimits_segments].y2 = map_y2;\n\n      num_offlimits_segments++;\n      gdk_gc_set_foreground (drawing_gc, &red);\n      draw_offlimits(num_offlimits_segments-1);\n\n      map_to_tmp();\n      return;\n    }\n  \n  if(map_x1 == map_x2 && map_y1 == map_y2)\n    {\n      if(map_x1 >= 0 && map_x1 < map->config.x_size && map_y1 >= 0 && \n\t map_y1 < map->config.y_size)\n\t{\n\t  map->map[map_x1][map_y1] = ink;\n\t  w = map_x_to_map_pix(map_x1+line_size) - \n\t    (int)(map_x_to_map_pix(map_x1));\n\t  if(w < 1)\n\t    w = 1;\n\t  h = map_y_to_map_pix(map_y1+line_size) - \n\t    (int)(map_y_to_map_pix(map_y1));\n\t  if(h < 1)\n\t    h = 1;\n\t  gdk_draw_rectangle(map_pixmap, drawing_gc, 1,\n\t\t\t     map_x_to_map_pix(map_x1-1.0) + 1.0, \n\t\t\t     map_y_to_map_pix(map_y1+1.0) + 1.0, \n\t\t\t     w, h);\n\t}\n    }\n  else\n    {\n      theta = calc_theta(map_x1, map_y1, map_x2, map_y2);\n      carmen_get_bresenham_parameters(map_x1, map_y1, map_x2, map_y2, &length);\n      \n      gdk_gc_set_foreground (drawing_gc, &color);\n      do\n\t{\n\t  carmen_get_current_point(&length, &x, &y);\n\t  \n\t  map_x1 = x;\n\t  map_x2 = line_size * cos(theta + M_PI/ 2.0) + x + .5;\n\t  map_y1 = y;\n\t  map_y2 = line_size * sin(theta + M_PI/ 2.0) + y + .5;\n\t  if(map_x1 == map_x2 && map_y1 == map_y2)\n\t    {\n\t      if(x >= 0 && x < map->config.x_size && y >= 0 && \n\t\t y < map->config.y_size)\n\t\t{\n\t\t  w = map_x_to_map_pix(x+1) - (int)(map_x_to_map_pix(x));\n\t\t  if(w < 1)\n\t\t    w = 1;\n\t\t  h = map_y_to_map_pix(y) - (int)(map_y_to_map_pix(y+1));\n\t\t  if(h < 1)\n\t\t    h = 1;\n\t\t  map->map[x][y] = ink;\n\t\t  gdk_draw_rectangle(map_pixmap, drawing_gc, 1,\n\t\t\t\t     map_x_to_map_pix(x) + 1.0, \n\t\t\t\t     map_y_to_map_pix(y+1) + 1.0, w, h);\n\t\t}\n\t    }\n\t  \n\t  else\n\t    {\n\t      carmen_get_bresenham_parameters(map_x1, map_y1, map_x2, map_y2, \n\t\t\t\t\t      &width);\n\t      do\n\t\t{\n\t\t  carmen_get_current_point(&width, &x, &y);\n\t\t  \n\t\t  if(x >= 0 && x < map->config.x_size && y >= 0 && \n\t\t     y < map->config.y_size)\n\t\t    {\n\t\t      w = map_x_to_map_pix(x+1) - (int)(map_x_to_map_pix(x));\n\t\t      if(w < 1)\n\t\t\tw = 1;\n\t\t      h = map_y_to_map_pix(y) - (int)(map_y_to_map_pix(y+1));\n\t\t      if(h < 1)\n\t\t\th = 1;\n\t\t      map->map[x][y] = ink;\n\t\t      gdk_draw_rectangle(map_pixmap, drawing_gc, 1,\n\t\t\t\t\t map_x_to_map_pix(x) + 1.0, \n\t\t\t\t\t map_y_to_map_pix(y+1) + 1.0, w,h);\n\t\t    }\n\t\t  \n\t\t}\n\t      while(carmen_get_next_point(&width));\n\t      \n\t      carmen_get_bresenham_parameters(map_x1+1.0 * cos(theta+M_PI/ 4.0), \n\t\t\t\t\t      map_y1+1.0 * sin(theta+M_PI/ 4.0), \n\t\t\t\t\t      map_x2+1.0 * cos(theta+M_PI/ 4.0), \n\t\t\t\t\t      map_y2+1.0 * sin(theta+M_PI/ 4.0), \n\t\t\t\t\t      &width);\n\t      do\n\t\t{\n\t\t  carmen_get_current_point(&width, &x, &y);\n\t\t  \n\t\t  if(x >= 0 && x < map->config.x_size && y >= 0 && \n\t\t     y < map->config.y_size)\n\t\t    {\n\t\t      w = map_x_to_map_pix(x+1) - (int)(map_x_to_map_pix(x));\n\t\t      if(w < 1)\n\t\t\tw = 1;\n\t\t      h = map_y_to_map_pix(y) - (int)(map_y_to_map_pix(y+1));\n\t\t      if(h < 1)\n\t\t\th = 1;\n\t\t      map->map[x][y] = ink;\n\t\t      gdk_draw_rectangle(map_pixmap, drawing_gc, 1,\n\t\t\t\t\t map_x_to_map_pix(x) + 1.0, \n\t\t\t\t\t map_y_to_map_pix(y+1) + 1.0, w,h);\n\t\t    }\n\t\t  \n\t\t}\n\t      while(carmen_get_next_point(&width));\n\t      carmen_get_bresenham_parameters(map_x1+1.0 * cos(theta-M_PI/ 4.0), \n\t\t\t\t\t      map_y1+1.0 * sin(theta-M_PI/ 4.0), \n\t\t\t\t\t      map_x2+1.0 * cos(theta-M_PI/ 4.0), \n\t\t\t\t\t      map_y2+1.0 * sin(theta-M_PI/ 4.0), \n\t\t\t\t\t      &width);\n\t      do\n\t\t{\n\t\t  carmen_get_current_point(&width, &x, &y);\n\t\t  \n\t\t  if(x >= 0 && x < map->config.x_size && y >= 0 && \n\t\t     y < map->config.y_size)\n\t\t    {\n\t\t      w = map_x_to_map_pix(x+1) - (int)(map_x_to_map_pix(x));\n\t\t      if(w < 1)\n\t\t\tw = 1;\n\t\t      h = map_y_to_map_pix(y) - (int)(map_y_to_map_pix(y+1));\n\t\t      if(h < 1)\n\t\t\th = 1;\n\t\t      map->map[x][y] = ink;\n\t\t      gdk_draw_rectangle(map_pixmap, drawing_gc, 1,\n\t\t\t\t\t map_x_to_map_pix(x) + 1.0, \n\t\t\t\t\t map_y_to_map_pix(y+1) + 1.0, \n\t\t\t\t\t w,h);\n\t\t    }\n\t\t  \n\t\t}\n\t      while(carmen_get_next_point(&width));\n\t      \n\t    }\n\t}\n      while(carmen_get_next_point(&length));\n    }\n  map_to_tmp();\n  \n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* fills all adjacent squares with probability within fuzzyness of the original \n   square to the ink color */\n", "func_signal": "void \nfuzzy_fill(double under, int map_x, int map_y, int ** seen)", "code": "{\n  carmen_stack_t *stack = NULL;\n  carmen_stack_t *temp;\n  int w,h;\n\n  temp = calloc(1, sizeof(carmen_stack_t));\n  carmen_test_alloc(temp);\n  temp->x = map_x;\n  temp->y = map_y;\n  push(&stack, temp);\n  while(stack != NULL)\n    {\n      temp = pop(&stack);\n      map_x = temp->x;\n      map_y = temp->y;\n      free(temp);\n      w = map_x_to_map_pix(map_x+1) - (int)(map_x_to_map_pix(map_x));\n      if(w < 1)\n\tw = 1;\n      h = map_y_to_map_pix(map_y) - (int)(map_y_to_map_pix(map_y+1));\n      if(h < 1)\n\th = 1;\n      seen[map_x][map_y] = 1;\n      map->map[map_x][map_y] = ink;\n      gdk_gc_set_foreground (drawing_gc, &color);\n      gdk_draw_rectangle (map_pixmap,\n\t\t\t  drawing_gc,\n\t\t\t  TRUE,\n\t\t\t  map_x_to_map_pix(map_x) + 1.0, map_y_to_map_pix(map_y+1) + 1.0,\n\t\t\t  w, h);\n      if(map_x-1 >=0 && fabs(map->map[map_x-1][map_y] - under) < fuzzyness \n\t && !seen[map_x-1][map_y])\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x-1;\n\t  temp->y = map_y;\n\t  push(&stack, temp);\n\t}\n      if(map_x+1 < map->config.x_size && fabs(map->map[map_x+1][map_y]-under) < fuzzyness \n\t && !seen[map_x+1][map_y])\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x+1;\n\t  temp->y = map_y;\n\t  push(&stack, temp);\n\t}\n      if(map_y-1 >=0 && fabs(map->map[map_x][map_y-1] - under) < fuzzyness \n\t && !seen[map_x][map_y-1])\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x;\n\t  temp->y = map_y-1;\n\t  push(&stack, temp);\n\t}\n      if(map_y+1 < map->config.y_size && fabs(map->map[map_x][map_y+1] - under) < fuzzyness \n\t && !seen[map_x][map_y+1])\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x;\n\t  temp->y = map_y+1;\n\t  push(&stack, temp);\n\t}\n    }\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the tool to a paint can */\n", "func_signal": "gint \nset_fill(void)", "code": "{\n  set_pour();\n  utensil = CARMEN_MAP_FILL;\n  gtk_label_set_text(GTK_LABEL(tool_label), \"fill\");\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the tool to a paint can */\n", "func_signal": "gint \nset_fuzzy_fill(void)", "code": "{\n  set_pour();\n  utensil = CARMEN_MAP_FUZZY_FILL;\n  gtk_label_set_text(GTK_LABEL(tool_label), \"fuzzy fill\");\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "// Add a check for planners with goals-- if we're just tracking'\n// then there is no goal\n", "func_signal": "int\ncarmen_planner_next_waypoint(carmen_traj_point_p waypoint, \n\t\t\t     int* waypoint_index,\n\t\t\t     int *is_goal,\n\t\t\t     carmen_navigator_config_t *nav_conf)", "code": "{  \n  carmen_traj_point_p point;\n  int next_point;\n  double delta_dist, delta_theta;\n\n  regenerate_trajectory(nav_conf);\n\n  carmen_verbose(\"Finding waypoint: %.0f %.0f %.0f\\n\", \n\t\t waypoint->x, waypoint->y, \n\t\t carmen_radians_to_degrees(waypoint->theta));\n\n  if (path.length <= 1)\n    return -1;\n\n  next_point = 0;\n  do {\n    next_point++;\n    point = carmen_planner_util_get_path_point(next_point, &path);\n\n    if (path.length - next_point < 2)\n      break;\n    delta_dist = carmen_distance_traj(waypoint, point);\n  } while (delta_dist < nav_conf->waypoint_tolerance);\n\n  delta_dist = carmen_distance_traj(waypoint, point);\n\n  if (delta_dist < nav_conf->goal_size && path.length - next_point == 1) {\n    if (allow_any_orientation || !goal_is_accessible)\n      return 1;\n    delta_theta = fabs(waypoint->theta - requested_goal.theta) ;\n    if (delta_theta < nav_conf->goal_theta_tolerance)\n      return 1;      \n  }\n\n  if (path.length <= 2)\n    *is_goal = 1;\n  else\n    *is_goal = 0;\n\n  *waypoint = *point;    \n  *waypoint_index = next_point;\n\n  carmen_verbose(\"Waypoint is: %.0f %.0f %.0f (goal %d)\\n\", \n\t\t waypoint->x, waypoint->y,\n\t\t carmen_radians_to_degrees(waypoint->theta), *is_goal);\n\n  return 0;\n}", "path": "carmen\\carmen\\src\\navigator\\planner.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* increments the line size */\n", "func_signal": "gint \nline_incr(void)", "code": "{\n  char line_text[10];\n  line_size ++;\n  \n  sprintf(line_text, \"%d\", carmen_trunc(line_size));\n  gtk_label_set_text(GTK_LABEL(line_label), line_text);\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* draws a rectangle (either filled or not depending upon whether filled is \n   set or not) with line widths of line_size onto the pixmap and the map */\n", "func_signal": "void \ndraw_rectangle(GtkWidget *widget __attribute__ ((unused)), \n\t       gdouble pix_x1, gdouble pix_y1, gdouble pix_x2, gdouble pix_y2)", "code": "{\n  int i, j;\n  double width, height;\n  int map_x1, map_x2, map_y1, map_y2;\n\n  if(pix_x1 < pix_x2)\n    {\n      map_x1 = pix_x_to_map(pix_x1) + .60;\n      map_x2 = pix_x_to_map(pix_x2) + .40;\n    }\n  else\n    {\n      map_x1 = pix_x_to_map(pix_x2) + .60;\n      map_x2 = pix_x_to_map(pix_x1) + .40;\n    }\n  if(pix_y1 > pix_y2)\n    {\n      map_y1 = pix_y_to_map(pix_y1) + .60;\n      map_y2 = pix_y_to_map(pix_y2) + .40;\n    }\n  else\n    {\n      map_y1 = pix_y_to_map(pix_y2) + .60;\n      map_y2 = pix_y_to_map(pix_y1) + .40;\n    }\n  \n  gdk_gc_set_foreground (drawing_gc, &color);\n\n  if (drawing_offlimits)\n    {\n      check_offlimits_array_size();\n      offlimits_array[num_offlimits_segments].type = CARMEN_OFFLIMITS_RECT_ID;\n      offlimits_array[num_offlimits_segments].x1 = map_x1;\n      offlimits_array[num_offlimits_segments].y1 = map_y1;\n      offlimits_array[num_offlimits_segments].x2 = map_x2;\n      offlimits_array[num_offlimits_segments].y2 = map_y2;\n\n      num_offlimits_segments++;\n\t\t\t\n      gdk_gc_set_foreground (drawing_gc, &red);\n      draw_offlimits(num_offlimits_segments-1);\n\n      map_to_tmp();\n    }\n  \n  else if(filled)\n    {\n      for(i = map_x1; i < map_x2; i++)\n\tif(i < map->config.x_size && i >= 0)\n\t  for(j = map_y1; j < map_y2; j++)\n\t    if(j < map->config.y_size && j >= 0)\n\t      map->map[i][j] = ink;\n      width  = map_x_to_map_pix(map_x2) - (int)(map_x_to_map_pix(map_x1));\n      if(width < 1)\n\twidth = 1;\n      height = map_y_to_map_pix(map_y1) - (int)(map_y_to_map_pix(map_y2));\n      if(height < 1)\n\theight = 1;\n\n      gdk_draw_rectangle (map_pixmap, drawing_gc, 1, \n\t\t\t  map_x_to_map_pix(map_x1) + 1.0, \n\t\t\t  map_y_to_map_pix(map_y2) + 1.0, \n\t\t\t  width, height);\n      map_to_tmp();\n    }\n  else\n    {\n      //left line\n      width = map_x_to_map_pix(map_x1) - \n\t(int)(map_x_to_map_pix(map_x1-line_size));\n      height =map_y_to_map_pix(map_y1) - (int)(map_y_to_map_pix(map_y2));\n      if(height < 1)\n\theight = 1;\n      \n      if(width > map_x_to_map_pix(map_x2) - map_x_to_map_pix(map_x1))\n\t{\n\t  for(j = map_y1; j < map_y2; j++)\n\t    if(j>= 0 && j <map->config.y_size)\n\t      for(i = map_x1; i < map_x2; i++)\n\t\tif(i >= 0 && i < map->config.x_size)\n\t\t  map->map[i][j] = ink;\n\t  \n\t  width = map_x_to_map_pix(map_x2) - (int)(map_x_to_map_pix(map_x1));\n\t  if(width < 1)\n\t    width = 1;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x1) + 1.0, \n\t\t\t      map_y_to_map_pix(map_y2) + 1.0, \n\t\t\t      width, height);\n\t}\n      else\n\t{\n\t  for(j = map_y1; j < map_y2; j++)\n\t    if(j>= 0 && j <map->config.y_size)\n\t      for(i = map_x1; i < map_x1 + line_size; i++)\n\t\tif(i >= 0 && i < map->config.x_size)\n\t\t  map->map[i][j] = ink;\n\t  \n\t  if(width < 1)\n\t    width = 1;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x1) + 1.0, \n\t\t\t      map_y_to_map_pix(map_y2) + 1.0, \n\t\t\t      width, height);\n\t  //right line\n\t  width = map_x_to_map_pix(map_x2) - \n\t    (int)(map_x_to_map_pix(map_x2-line_size));\n\t  if(width < 1)\n\t    width = 1;\n\t  \n\t  for(j = map_y1; j < map_y2; j++)\n\t    if(j>= 0 && j <map->config.y_size)\n\t      for(i = map_x2 - line_size; i < map_x2; i++)\n\t\tif(i >= 0 && i < map->config.x_size)\n\t\t  map->map[i][j] = ink;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x2-line_size) + 1.0, \n\t\t\t      map_y_to_map_pix(map_y2) + 1.0, width, height);\n\t  \n\t}\n      //bottom line\n      width = map_x_to_map_pix(map_x2) - (int)(map_x_to_map_pix(map_x1));\n      if(width < 1)\n\twidth = 1;\n      height =map_y_to_map_pix(map_y1) - (int)(map_y_to_map_pix(map_y1+line_size));\n\n      if(height > map_y_to_map_pix(map_y1) - map_y_to_map_pix(map_y2))\n\t{\n\t  for(i = map_x1; i < map_x2; i++)\n\t    if(i >= 0 && i <map->config.x_size)\n\t      for(j = map_y1; j < map_y2; j++)\n\t\tif(j >= 0 && j < map->config.y_size)\n\t\t  map->map[i][j] = ink;\n\n\t  height = map_y_to_map_pix(map_y1) - (int)(map_y_to_map_pix(map_y2));\n\t  if(height < 1)\n\t    height = 1;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x1) + 1.0, map_y_to_map_pix(map_y2) + 1.0, \n\t\t\t      width, map_y_to_map_pix(map_y1) - map_y_to_map_pix(map_y2));\n\t}\n      else\n\t{\n\n\t  for(i = map_x1; i < map_x2; i++)\n\t    if(i >= 0 && i <map->config.x_size)\n\t      for(j = map_y1; j < map_y1 + line_size; j++)\n\t\tif(j >= 0 && j < map->config.y_size)\n\t\t  map->map[i][j] = ink;\n\t  \n\t  if(height < 1)\n\t    height = 1;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x1) + 1.0, \n\t\t\t      map_y_to_map_pix(map_y1+line_size) + 1.0, width, height);\n\t  //top line\n\t  height =map_y_to_map_pix(map_y2) - (int)(map_y_to_map_pix(map_y2+line_size));\n\t  if(height < 1)\n\t    height = 1;\n\t  \n\t  for(i = map_x1; i < map_x2; i++)\n\t    if(i >= 0 && i <map->config.x_size)\n\t      for(j = map_y2 - line_size; j < map_y2; j++)\n\t\tif(j >= 0 && j < map->config.y_size)\n\t\t  map->map[i][j] = ink;\n\t  gdk_draw_rectangle (map_pixmap, drawing_gc, 1,\n\t\t\t      map_x_to_map_pix(map_x1) + 1.0, map_y_to_map_pix(map_y2) + 1.0, \n\t\t\t      width, height);\n\t}\n      map_to_tmp();\n    }\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* 25-Jun-91: fedor: this is really a cheap shot at making ref data work\n   for lisp - lets hope it works. */\n", "func_signal": "int32 x_ipcRefDataLisp(X_IPC_REF_PTR ref)", "code": "{\n  int32 refId, sd;\n  MSG_PTR msg;\n  X_IPC_REF_PTR waitRef;\n  X_IPC_RETURN_VALUE_TYPE returnValue;\n  char *lispDataFlag;\n  \n  msg = x_ipc_msgFind(X_IPC_REF_DATA_QUERY);\n  if (msg == NULL) return 0;\n  \n  if (!ref->msg) {\n    if (!ref->name) {\n      /* 17-Jun-91: fedor: start enforcing correct refs */\n      X_IPC_MOD_ERROR1(\"ERROR: x_ipcReferenceData: Badly Formed Reference: %d\\n\",\n\t\t  ref->refId);\n      return 0;\n    }\n    ref->msg = x_ipc_msgFind(ref->name);\n    if (ref->msg == NULL) return 0;\n  }\n  \n  /* 17-Jun-91: fedor: check if any message form */\n  if (!ref->msg->msgData->msgFormat)\n    return 0;\n  \n  refId = x_ipc_nextSendMessageRef();\n  returnValue = x_ipc_sendMessage((X_IPC_REF_PTR)NULL, msg, \n\t\t\t\t  (char *)&ref->refId, (char *)NULL, refId);\n  \n  if (returnValue != Success) {\n    X_IPC_MOD_ERROR(\"ERROR: x_ipcReferenceData: x_ipc_sendMessage Failed.\\n\");\n    return 0;\n  }\n  waitRef = x_ipcRefCreate(ref->msg, ref->name, refId);\n  \n  LOCK_CM_MUTEX;\n  sd = GET_C_GLOBAL(serverRead);\n  lispDataFlag = LISP_DATA_FLAG();\n  UNLOCK_CM_MUTEX;\n  returnValue = x_ipc_waitForReplyFrom(waitRef, lispDataFlag, TRUE,\n\t\t\t\t       WAITFOREVER, sd);\n  \n  x_ipcRefFree(waitRef);\n  \n  if (returnValue == NullReply) {\n    /* 17-Jun-91: fedor: if NullReply then nothing else was malloced. */\n    return 0;\n  }\n  else\n    return 1;\n}", "path": "carmen\\carmen\\src\\ipc\\ipcLisp.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the pointer to a paint can */\n", "func_signal": "gint \nset_pour(void)", "code": "{\n  if (window->window != NULL)\n    gdk_window_set_cursor (window->window, cfill);\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* Find string with the given enumerated value and return the string length;\n   Return 0 if value outside range or enum has no strings. */\n", "func_signal": "int32 enumValNameLength (CONST_FORMAT_PTR format, int32 enumVal)", "code": "{\n  if (format->formatter.a[0].i > 2 &&\n      0 <= enumVal && enumVal <= ENUM_MAX_VAL(format)) {\n    return strlen(format->formatter.a[enumVal+2].f->formatter.name);\n  } else {\n    return 0;\n  }\n}", "path": "carmen\\carmen\\src\\ipc\\ipcLisp.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the tool to something that makes a rectangle */\n", "func_signal": "gint \nset_rectangle(void)", "code": "{\n  set_cross();\n  utensil = CARMEN_MAP_RECTANGLE;\n  gtk_label_set_text(GTK_LABEL(tool_label), \"rectangle\");\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the cursor to a pointer */\n", "func_signal": "gint \nset_point(void)", "code": "{\n  if (window->window != NULL)\n    gdk_window_set_cursor (window->window, cpoint);\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* LISP floating point numbers are equivalent to C \"double\" format */\n", "func_signal": "void EncodeFloat(double Float, GENERIC_DATA_PTR DataArray, int32 Start)", "code": "{ \n  float RealFloat;\n  \n  DataArray += Start;\n  RealFloat = (float)Float;\n  BCOPY((char *)&RealFloat, DataArray, sizeof(float));\n}", "path": "carmen\\carmen\\src\\ipc\\ipcLisp.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* sets the pointer to an eye dropper (sort of) */\n", "func_signal": "gint \nset_dropper(void)", "code": "{\n  if (window->window != NULL)\n    gdk_window_set_cursor (window->window, cselect);\n  return 1;\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/* fills all adjacent squares with the same probability to the ink color */\n", "func_signal": "void \nfill(double under, int map_x, int map_y)", "code": "{\n  carmen_stack_t *stack = NULL;\n  carmen_stack_t *temp;\n  int w,h;\n\n  temp = calloc(1, sizeof(carmen_stack_t));\n  carmen_test_alloc(temp);\n  temp->x = map_x;\n  temp->y = map_y;\n  push(&stack, temp);\n  while(stack != NULL)\n    {\n      temp = pop(&stack);\n      map_x = temp->x;\n      map_y = temp->y;\n      free(temp);\n      w = map_x_to_map_pix(map_x+1) - (int)(map_x_to_map_pix(map_x));\n      if(w < 1)\n\tw = 1;\n      h = map_y_to_map_pix(map_y) - (int)(map_y_to_map_pix(map_y+1));\n      if(h < 1)\n\th = 1;\n      map->map[map_x][map_y] = ink;\n      gdk_gc_set_foreground (drawing_gc, &color);\n      gdk_draw_rectangle (map_pixmap,\n\t\t\t  drawing_gc,\n\t\t\t  TRUE,\n\t\t\t  map_x_to_map_pix(map_x) + 1.0, map_y_to_map_pix(map_y+1) + 1.0,\n\t\t\t  w, h);\n      if(map_x-1 >=0 && map->map[map_x-1][map_y] == under)\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x-1;\n\t  temp->y = map_y;\n\t  push(&stack, temp);\n\t}\n      if(map_x+1 < map->config.x_size && map->map[map_x+1][map_y] == under)\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x+1;\n\t  temp->y = map_y;\n\t  push(&stack, temp);\n\t}\n      if(map_y-1 >=0 && map->map[map_x][map_y-1] == under)\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x;\n\t  temp->y = map_y-1;\n\t  push(&stack, temp);\n\t}\n      if(map_y+1 < map->config.y_size && map->map[map_x][map_y+1] == under)\n\t{\n\t  temp = calloc(1, sizeof(carmen_stack_t));\n\t  carmen_test_alloc(temp);\n\t  temp->x = map_x;\n\t  temp->y = map_y+1;\n\t  push(&stack, temp);\n\t}\n    }\n}", "path": "carmen\\carmen\\src\\mapeditor\\map_editor_drawing.c", "repo_name": "agarmo/MasterThesis", "stars": 6, "license": "None", "language": "c", "size": 105160}
{"docstring": "/*Fills in the chroma plane fragment maps for a macro block.\n  This version is for use with chroma decimated in the Y direction.\n  _mb:      The macro block to fill.\n  _fplanes: The descriptions of the fragment planes.\n  _x:       The X location of the upper-left hand fragment in the Y plane.\n  _y:       The Y location of the upper-left hand fragment in the Y plane.*/\n", "func_signal": "static void oc_mb_fill_cmapping01(oc_mb *_mb,\n const oc_fragment_plane _fplanes[3],int _x,int _y)", "code": "{\n  int fragi;\n  int j;\n  _y>>=1;\n  fragi=_y*_fplanes[1].nhfrags+_x;\n  for(j=0;j<2;j++){\n    if(_x+j>=_fplanes[1].nhfrags)break;\n    _mb->map[1][j]=fragi+_fplanes[1].froffset;\n    _mb->map[2][j]=fragi+_fplanes[2].froffset;\n    fragi++;\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* interpolated lookup based fromdB function, domain -140dB to 0dB only */\n", "func_signal": "float vorbis_fromdBlook(float a)", "code": "{\n  int i=vorbis_ftoi(a*((float)(-(1<<FROMdB2_SHIFT)))-.5f);\n  return (i<0)?1.f:\n    ((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:\n     FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);\n}", "path": "ccs-project\\vorbis-DM6446\\lookup.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* interpolated 1./sqrt(p) where .5 <= p < 1. */\n", "func_signal": "float vorbis_invsqlook(float a)", "code": "{\n  double d=a*(2.f*(float)INVSQ_LOOKUP_SZ)-(float)INVSQ_LOOKUP_SZ;\n  int i=vorbis_ftoi(d-.5f);\n  return INVSQ_LOOKUP[i]+ (d-i)*(INVSQ_LOOKUP[i+1]-INVSQ_LOOKUP[i]);\n}", "path": "ccs-project\\vorbis-DM6446\\lookup.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* given a list of word lengths, generate a list of codewords.  Works\n   for length ordered or unordered, always assigns the lowest valued\n   codewords first.  Extended to handle unused entries (length 0) */\n", "func_signal": "ogg_uint32_t *_make_words(long *l,long n,long sparsecount)", "code": "{\n  long i,j,count=0;\n  ogg_uint32_t marker[33];\n  ogg_uint32_t *r=_ogg_malloc((sparsecount?sparsecount:n)*sizeof(*r));\n  memset(marker,0,sizeof(marker));\n\n  for(i=0;i<n;i++){\n    long length=l[i];\n    if(length>0){\n      ogg_uint32_t entry=marker[length];\n      \n      /* when we claim a node for an entry, we also claim the nodes\n\t below it (pruning off the imagined tree that may have dangled\n\t from it) as well as blocking the use of any nodes directly\n\t above for leaves */\n      \n      /* update ourself */\n      if(length<32 && (entry>>length)){\n\t/* error condition; the lengths must specify an overpopulated tree */\n\t_ogg_free(r);\n\treturn(NULL);\n      }\n      r[count++]=entry;\n    \n      /* Look to see if the next shorter marker points to the node\n\t above. if so, update it and repeat.  */\n      {\n\tfor(j=length;j>0;j--){\n\t  \n\t  if(marker[j]&1){\n\t    /* have to jump branches */\n\t    if(j==1)\n\t      marker[1]++;\n\t    else\n\t      marker[j]=marker[j-1]<<1;\n\t    break; /* invariant says next upper marker would already\n\t\t      have been moved if it was on the same path */\n\t  }\n\t  marker[j]++;\n\t}\n      }\n      \n      /* prune the tree; the implicit invariant says all the longer\n\t markers were dangling from our just-taken node.  Dangle them\n\t from our *new* node. */\n      for(j=length+1;j<33;j++)\n\tif((marker[j]>>1) == entry){\n\t  entry=marker[j];\n\t  marker[j]=marker[j-1]<<1;\n\t}else\n\t  break;\n    }else\n      if(sparsecount==0)count++;\n  }\n    \n  /* bitreverse the words because our bitwise packer/unpacker is LSb\n     endian */\n  for(i=0,count=0;i<n;i++){\n    ogg_uint32_t temp=0;\n    for(j=0;j<l[i];j++){\n      temp<<=1;\n      temp|=(r[count]>>j)&1;\n    }\n\n    if(sparsecount){\n      if(l[i])\n\tr[count++]=temp;\n    }else\n      r[count++]=temp;\n  }\n\n  return(r);\n}", "path": "ccs-project\\vorbis-DM6446\\sharedbook.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Sets the buffer pointer in each fragment to point to the portion of the\n   image buffer which it corresponds to.\n  _state:   The Theora state to fill.\n  _buf_idx: The index of the buffer pointer to fill.\n            The first three correspond to our reconstructed frame buffers,\n             while the last corresponds to the input image.\n  _img:     The image buffer to fill the fragments with.*/\n", "func_signal": "void oc_state_fill_buffer_ptrs(oc_theora_state *_state,int _buf_idx,\n th_ycbcr_buffer _img)", "code": "{\n  int pli;\n  /*Special handling for the input image to give us the opportunity to skip\n     some updates.\n    The other buffers do not change throughout the encoding process.*/\n  if(_buf_idx==OC_FRAME_IO){\n     if(memcmp(_state->input,_img,sizeof(th_ycbcr_buffer))==0)return;\n     memcpy(_state->input,_img,sizeof(th_ycbcr_buffer));\n  }\n  for(pli=0;pli<3;pli++){\n    th_img_plane  *iplane;\n    oc_fragment_plane *fplane;\n    oc_fragment       *frag;\n    oc_fragment       *vfrag_end;\n    unsigned char     *vpix;\n    iplane=&_img[pli];\n    fplane=&_state->fplanes[pli];\n    vpix=iplane->data;\n    frag=_state->frags+fplane->froffset;\n    vfrag_end=frag+fplane->nfrags;\n    while(frag<vfrag_end){\n      oc_fragment   *hfrag_end;\n      unsigned char *hpix;\n      hpix=vpix;\n      for(hfrag_end=frag+fplane->nhfrags;frag<hfrag_end;frag++){\n        frag->buffer[_buf_idx]=hpix;\n        hpix+=8;\n      }\n      vpix+=iplane->stride<<3;\n    }\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Apply the loop filter to a given set of fragment rows in the given plane.\n  The filter may be run on the bottom edge, affecting pixels in the next row of\n   fragments, so this row also needs to be available.\n  _bv:        The bounding values array.\n  _refi:      The index of the frame buffer to filter.\n  _pli:       The color plane to filter.\n  _fragy0:    The Y coordinate of the first fragment row to filter.\n  _fragy_end: The Y coordinate of the fragment row to stop filtering at.*/\n", "func_signal": "void oc_state_loop_filter_frag_rows(oc_theora_state *_state,int *_bv,\n int _refi,int _pli,int _fragy0,int _fragy_end)", "code": "{\n  _state->opt_vtable.state_loop_filter_frag_rows(_state,_bv,_refi,_pli,\n   _fragy0,_fragy_end);\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/**** pack/unpack helpers ******************************************/\n", "func_signal": "int _ilog(unsigned int v)", "code": "{\n  int ret=0;\n  while(v){\n    ret++;\n    v>>=1;\n  }\n  return(ret);\n}", "path": "ccs-project\\vorbis-DM6446\\sharedbook.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* there might be a straightforward one-line way to do the below\n   that's portable and totally safe against roundoff, but I haven't\n   thought of it.  Therefore, we opt on the side of caution */\n", "func_signal": "long _book_maptype1_quantvals(const static_codebook *b)", "code": "{\n  long vals=floor(pow((float)b->entries,1.f/b->dim));\n\n  /* the above *should* be reliable, but we'll not assume that FP is\n     ever reliable when bitstream sync is at stake; verify via integer\n     means that vals really is the greatest value of dim for which\n     vals^b->bim <= b->entries */\n  /* treat the above as an initial guess */\n  while(1){\n    long acc=1;\n    long acc1=1;\n    int i;\n    for(i=0;i<b->dim;i++){\n      acc*=vals;\n      acc1*=vals+1;\n    }\n    if(acc<=b->entries && acc1>b->entries){\n      return(vals);\n    }else{\n      if(acc>b->entries){\n\tvals--;\n      }else{\n\tvals++;\n      }\n    }\n  }\n}", "path": "ccs-project\\vorbis-DM6446\\sharedbook.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*  Visual C cpuid helper function. For VS2005 we could\n    as well use the _cpuid builtin, but that wouldn't work\n    for VS2003 users, so we do it in inline assembler */\n", "func_signal": "static void oc_cpuid_helper (ogg_uint32_t * CpuInfo, ogg_uint32_t op)", "code": "{\n  _asm {\n    mov eax, [op]\n    mov esi, CpuInfo\n    cpuid\n    mov [esi + 0], eax\n    mov [esi + 4], ebx\n    mov [esi + 8], ecx\n    mov [esi +12], edx\n  }\n}", "path": "ccs-project\\theora-DM6446\\cpu.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Duplicates the pixels on the border of the given reference image out into\n   the surrounding padding for use by unrestricted motion vectors.\n  _state: The context containing the reference buffers.\n  _refi:  The index of the reference buffer to pad.*/\n", "func_signal": "void oc_state_borders_fill(oc_theora_state *_state,int _refi)", "code": "{\n  int pli;\n  for(pli=0;pli<3;pli++){\n    oc_state_borders_fill_rows(_state,_refi,pli,0,\n     _state->ref_frame_bufs[_refi][pli].height);\n    oc_state_borders_fill_caps(_state,_refi,pli);\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Fills in the mapping from macro blocks to their corresponding fragment\n   numbers in each plane.\n  _mbs:     The array of macro blocks.\n  _fplanes: The descriptions of the fragment planes.\n  _ctype:   The chroma decimation type.*/\n", "func_signal": "static void oc_mb_create_mapping(oc_mb _mbs[],\n const oc_fragment_plane _fplanes[3],int _ctype)", "code": "{\n  oc_mb_fill_cmapping_func  mb_fill_cmapping;\n  oc_mb                    *mb0;\n  int                       y;\n  mb0=_mbs;\n  mb_fill_cmapping=OC_MB_FILL_CMAPPING_TABLE[_ctype];\n  /*Loop through the Y plane super blocks.*/\n  for(y=0;y<_fplanes[0].nvfrags;y+=4){\n    int x;\n    for(x=0;x<_fplanes[0].nhfrags;x+=4,mb0+=4){\n      int ymb;\n      /*Loop through the macro blocks in each super block in display order.*/\n      for(ymb=0;ymb<2;ymb++){\n        int xmb;\n        for(xmb=0;xmb<2;xmb++){\n          oc_mb *mb;\n          int    mbx;\n          int    mby;\n          mb=mb0+OC_MB_MAP[ymb][xmb];\n          mbx=x|xmb<<1;\n          mby=y|ymb<<1;\n          mb->x=mbx<<3;\n          mb->y=mby<<3;\n          /*Initialize fragment indexes to -1.*/\n          memset(mb->map,0xFF,sizeof(mb->map));\n          /*Make sure this macro block is within the encoded region.*/\n          if(mbx>=_fplanes[0].nhfrags||mby>=_fplanes[0].nvfrags){\n            mb->mode=OC_MODE_INVALID;\n            continue;\n          }\n          /*Fill in the fragment indices for the Y plane.*/\n          oc_mb_fill_ymapping(mb,_fplanes,mbx,mby);\n          /*Fill in the fragment indices for the chroma planes.*/\n          (*mb_fill_cmapping)(mb,_fplanes,mbx,mby);\n        }\n      }\n    }\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* unpack the quantized list of values for encode/decode ***********/\n/* we need to deal with two map types: in map type 1, the values are\n   generated algorithmically (each column of the vector counts through\n   the values in the quant vector). in map type 2, all the values came\n   in in an explicit list.  Both value lists must be unpacked */\n", "func_signal": "float *_book_unquantize(const static_codebook *b,int n,int *sparsemap)", "code": "{\n  long j,k,count=0;\n  if(b->maptype==1 || b->maptype==2){\n    int quantvals;\n    float mindel=_float32_unpack(b->q_min);\n    float delta=_float32_unpack(b->q_delta);\n    float *r=_ogg_calloc(n*b->dim,sizeof(*r));\n\n    /* maptype 1 and 2 both use a quantized value vector, but\n       different sizes */\n    switch(b->maptype){\n    case 1:\n      /* most of the time, entries%dimensions == 0, but we need to be\n\t well defined.  We define that the possible vales at each\n\t scalar is values == entries/dim.  If entries%dim != 0, we'll\n\t have 'too few' values (values*dim<entries), which means that\n\t we'll have 'left over' entries; left over entries use zeroed\n\t values (and are wasted).  So don't generate codebooks like\n\t that */\n      quantvals=_book_maptype1_quantvals(b);\n      for(j=0;j<b->entries;j++){\n\tif((sparsemap && b->lengthlist[j]) || !sparsemap){\n\t  float last=0.f;\n\t  int indexdiv=1;\n\t  for(k=0;k<b->dim;k++){\n\t    int index= (j/indexdiv)%quantvals;\n\t    float val=b->quantlist[index];\n\t    val=fabs(val)*delta+mindel+last;\n\t    if(b->q_sequencep)last=val;\t  \n\t    if(sparsemap)\n\t      r[sparsemap[count]*b->dim+k]=val;\n\t    else\n\t      r[count*b->dim+k]=val;\n\t    indexdiv*=quantvals;\n\t  }\n\t  count++;\n\t}\n\n      }\n      break;\n    case 2:\n      for(j=0;j<b->entries;j++){\n\tif((sparsemap && b->lengthlist[j]) || !sparsemap){\n\t  float last=0.f;\n\t  \n\t  for(k=0;k<b->dim;k++){\n\t    float val=b->quantlist[j*b->dim+k];\n\t    val=fabs(val)*delta+mindel+last;\n\t    if(b->q_sequencep)last=val;\t  \n\t    if(sparsemap)\n\t      r[sparsemap[count]*b->dim+k]=val;\n\t    else\n\t      r[count*b->dim+k]=val;\n\t  }\n\t  count++;\n\t}\n      }\n      break;\n    }\n\n    return(r);\n  }\n  return(NULL);\n}", "path": "ccs-project\\vorbis-DM6446\\sharedbook.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* interpolated 1./sqrt(p) where .5 <= a < 1. (.100000... to .111111...) in\n   16.16 format \n\n   returns in m.8 format */\n", "func_signal": "long vorbis_invsqlook_i(long a,long e)", "code": "{\n  long i=(a&0x7fff)>>(INVSQ_LOOKUP_I_SHIFT-1); \n  long d=(a&INVSQ_LOOKUP_I_MASK)<<(16-INVSQ_LOOKUP_I_SHIFT); /*  0.16 */\n  long val=INVSQ_LOOKUP_I[i]-                                /*  1.16 */\n    (((INVSQ_LOOKUP_I[i]-INVSQ_LOOKUP_I[i+1])*               /*  0.16 */\n      d)>>16);                                               /* result 1.16 */\n  \n  e+=32;\n  if(e&1)val=(val*5792)>>13; /* multiply val by 1/sqrt(2) */\n  e=(e>>1)-8;\n\n  return(val>>e);\n}", "path": "ccs-project\\vorbis-DM6446\\lookup.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Fills in the chroma plane fragment maps for a macro block.\n  This version is for use with no chroma decimation.\n  This uses the already filled-in Y plane values.\n  _mb:      The macro block to fill.\n  _fplanes: The descriptions of the fragment planes.*/\n", "func_signal": "static void oc_mb_fill_cmapping11(oc_mb *_mb,\n const oc_fragment_plane _fplanes[3])", "code": "{\n  int k;\n  for(k=0;k<4;k++){\n    if(_mb->map[0][k]>=0){\n      _mb->map[1][k]=_mb->map[0][k]+_fplanes[1].froffset;\n      _mb->map[2][k]=_mb->map[0][k]+_fplanes[2].froffset;\n    }\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* interpolated lookup based cos function, domain 0 to PI only */\n/* a is in 0.16 format, where 0==0, 2^^16-1==PI, return 0.14 */\n", "func_signal": "long vorbis_coslook_i(long a)", "code": "{\n  int i=a>>COS_LOOKUP_I_SHIFT;\n  int d=a&COS_LOOKUP_I_MASK;\n  return COS_LOOKUP_I[i]- ((d*(COS_LOOKUP_I[i]-COS_LOOKUP_I[i+1]))>>\n\t\t\t   COS_LOOKUP_I_SHIFT);\n}", "path": "ccs-project\\vorbis-DM6446\\lookup.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Fills in the chroma plane fragment maps for a macro block.\n  This version is for use with chroma decimated in the X direction.\n  _mb:      The macro block to fill.\n  _fplanes: The descriptions of the fragment planes.\n  _x:       The X location of the upper-left hand fragment in the Y plane.\n  _y:       The Y location of the upper-left hand fragment in the Y plane.*/\n", "func_signal": "static void oc_mb_fill_cmapping10(oc_mb *_mb,\n const oc_fragment_plane _fplanes[3],int _x,int _y)", "code": "{\n  int fragi;\n  int i;\n  _x>>=1;\n  fragi=_y*_fplanes[1].nhfrags+_x;\n  for(i=0;i<2;i++){\n    if(_y+i>=_fplanes[1].nvfrags)break;\n    _mb->map[1][i<<1]=fragi+_fplanes[1].froffset;\n    _mb->map[2][i<<1]=fragi+_fplanes[2].froffset;\n    fragi+=_fplanes[1].nhfrags;\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Initialize the accelerated function pointers.*/\n", "func_signal": "void oc_state_vtable_init(oc_theora_state *_state)", "code": "{\n#if defined(USE_ASM)\n  oc_state_vtable_init_x86(_state);\n#else\n  oc_state_vtable_init_c(_state);\n#endif\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/*Marks the fragments which fall all or partially outside the displayable\n   region of the frame.\n  _state: The Theora state containing the fragments to be marked.*/\n", "func_signal": "static void oc_state_border_init(oc_theora_state *_state)", "code": "{\n  typedef struct{\n    int x0;\n    int y0;\n    int xf;\n    int yf;\n  }oc_crop_rect;\n  oc_fragment       *frag;\n  oc_fragment       *yfrag_end;\n  oc_fragment       *xfrag_end;\n  oc_fragment_plane *fplane;\n  oc_crop_rect      *crop;\n  oc_crop_rect       crop_rects[3];\n  int                pli;\n  int                y;\n  int                x;\n  /*The method we use here is slow, but the code is dead simple and handles\n     all the special cases easily.\n    We only ever need to do it once.*/\n  /*Loop through the fragments, marking those completely outside the\n     displayable region and constructing a border mask for those that straddle\n     the border.*/\n  _state->nborders=0;\n  yfrag_end=frag=_state->frags;\n  for(pli=0;pli<3;pli++){\n    fplane=_state->fplanes+pli;\n    crop=crop_rects+pli;\n    /*Set up the cropping rectangle for this plane.*/\n    crop->x0=_state->info.pic_x;\n    crop->xf=_state->info.pic_x+_state->info.pic_width;\n    crop->y0=_state->info.pic_y;\n    crop->yf=_state->info.pic_y+_state->info.pic_height;\n    if(pli>0){\n      if(!(_state->info.pixel_fmt&1)){\n        crop->x0=crop->x0>>1;\n        crop->xf=crop->xf+1>>1;\n      }\n      if(!(_state->info.pixel_fmt&2)){\n        crop->y0=crop->y0>>1;\n        crop->yf=crop->yf+1>>1;\n      }\n    }\n    y=0;\n    for(yfrag_end+=fplane->nfrags;frag<yfrag_end;y+=8){\n      x=0;\n      for(xfrag_end=frag+fplane->nhfrags;frag<xfrag_end;frag++,x+=8){\n        /*First check to see if this fragment is completely outside the\n           displayable region.*/\n        /*Note the special checks for an empty cropping rectangle.\n          This guarantees that if we count a fragment as straddling the\n           border below, at least one pixel in the fragment will be inside\n           the displayable region.*/\n        if(x+8<=crop->x0||crop->xf<=x||y+8<=crop->y0||crop->yf<=y||\n         crop->x0>=crop->xf||crop->y0>=crop->yf){\n          frag->invalid=1;\n        }\n        /*Otherwise, check to see if it straddles the border.*/\n        else if(x<crop->x0&&crop->x0<x+8||x<crop->xf&&crop->xf<x+8||\n         y<crop->y0&&crop->y0<y+8||y<crop->yf&&crop->yf<y+8){\n          ogg_int64_t mask;\n          int         npixels;\n          int         i;\n          mask=npixels=0;\n          for(i=0;i<8;i++){\n            int j;\n            for(j=0;j<8;j++){\n              if(x+j>=crop->x0&&x+j<crop->xf&&y+i>=crop->y0&&y+i<crop->yf){\n                mask|=(ogg_int64_t)1<<(i<<3|j);\n                npixels++;\n              }\n            }\n          }\n          /*Search the fragment array for border info with the same pattern.\n            In general, there will be at most 8 different patterns (per\n            plane).*/\n          for(i=0;;i++){\n            if(i>=_state->nborders){\n              _state->nborders++;\n              _state->borders[i].mask=mask;\n              _state->borders[i].npixels=npixels;\n            }\n            else if(_state->borders[i].mask!=mask)continue;\n            frag->border=_state->borders+i;\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "path": "ccs-project\\theora-DM6446\\state.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* interpolated lookup based fromdB function, domain -140dB to 0dB only */\n/* a is in n.12 format */\n", "func_signal": "float vorbis_fromdBlook_i(long a)", "code": "{\n  int i=(-a)>>(12-FROMdB2_SHIFT);\n  return (i<0)?1.f:\n    ((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:\n     FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);\n}", "path": "ccs-project\\vorbis-DM6446\\lookup.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* decode codebook arrangement is more heavily optimized than encode */\n", "func_signal": "int vorbis_book_init_decode(codebook *c,const static_codebook *s)", "code": "{\n  int i,j,n=0,tabn;\n  int *sortindex;\n  memset(c,0,sizeof(*c));\n  \n  /* count actually used entries */\n  for(i=0;i<s->entries;i++)\n    if(s->lengthlist[i]>0)\n      n++;\n\n  c->entries=s->entries;\n  c->used_entries=n;\n  c->dim=s->dim;\n\n  if(n>0){\n    \n    /* two different remappings go on here.  \n       \n    First, we collapse the likely sparse codebook down only to\n    actually represented values/words.  This collapsing needs to be\n    indexed as map-valueless books are used to encode original entry\n    positions as integers.\n    \n    Second, we reorder all vectors, including the entry index above,\n    by sorted bitreversed codeword to allow treeless decode. */\n\n    /* perform sort */\n    ogg_uint32_t *codes=_make_words(s->lengthlist,s->entries,c->used_entries);\n    ogg_uint32_t **codep=(ogg_uint32_t **)alloca(sizeof(*codep)*n);\n    \n    if(codes==NULL)goto err_out;\n    \n    for(i=0;i<n;i++){\n      codes[i]=bitreverse(codes[i]);\n      codep[i]=codes+i;\n    }\n    \n    qsort(codep,n,sizeof(*codep),sort32a);\n    \n    sortindex=(int *)alloca(n*sizeof(*sortindex));\n    c->codelist=_ogg_malloc(n*sizeof(*c->codelist));\n    /* the index is a reverse index */\n    for(i=0;i<n;i++){\n      int position=codep[i]-codes;\n      sortindex[position]=i;\n    }\n\n    for(i=0;i<n;i++)\n      c->codelist[sortindex[i]]=codes[i];\n    _ogg_free(codes);\n  \n\n    c->valuelist=_book_unquantize(s,n,sortindex);\n    c->dec_index=_ogg_malloc(n*sizeof(*c->dec_index));\n    \n    for(n=0,i=0;i<s->entries;i++)\n      if(s->lengthlist[i]>0)\n\tc->dec_index[sortindex[n++]]=i;\n    \n    c->dec_codelengths=_ogg_malloc(n*sizeof(*c->dec_codelengths));\n    for(n=0,i=0;i<s->entries;i++)\n      if(s->lengthlist[i]>0)\n\tc->dec_codelengths[sortindex[n++]]=s->lengthlist[i];\n    \n    c->dec_firsttablen=_ilog(c->used_entries)-4; /* this is magic */\n    if(c->dec_firsttablen<5)c->dec_firsttablen=5;\n    if(c->dec_firsttablen>8)c->dec_firsttablen=8;\n    \n    tabn=1<<c->dec_firsttablen;\n    c->dec_firsttable=_ogg_calloc(tabn,sizeof(*c->dec_firsttable));\n    c->dec_maxlength=0;\n    \n    for(i=0;i<n;i++){\n      if(c->dec_maxlength<c->dec_codelengths[i])\n\tc->dec_maxlength=c->dec_codelengths[i];\n      if(c->dec_codelengths[i]<=c->dec_firsttablen){\n\togg_uint32_t orig=bitreverse(c->codelist[i]);\n\tfor(j=0;j<(1<<(c->dec_firsttablen-c->dec_codelengths[i]));j++)\n\t  c->dec_firsttable[orig|(j<<c->dec_codelengths[i])]=i+1;\n      }\n    }\n    \n    /* now fill in 'unused' entries in the firsttable with hi/lo search\n       hints for the non-direct-hits */\n    {\n      ogg_uint32_t mask=0xfffffffeUL<<(31-c->dec_firsttablen);\n      long lo=0,hi=0;\n      \n      for(i=0;i<tabn;i++){\n\togg_uint32_t word=i<<(32-c->dec_firsttablen);\n\tif(c->dec_firsttable[bitreverse(word)]==0){\n\t  while((lo+1)<n && c->codelist[lo+1]<=word)lo++;\n\t  while(    hi<n && word>=(c->codelist[hi]&mask))hi++;\n\t  \n\t  /* we only actually have 15 bits per hint to play with here.\n\t     In order to overflow gracefully (nothing breaks, efficiency\n\t     just drops), encode as the difference from the extremes. */\n\t  {\n\t    unsigned long loval=lo;\n\t    unsigned long hival=n-hi;\n\t    \n\t    if(loval>0x7fff)loval=0x7fff;\n\t    if(hival>0x7fff)hival=0x7fff;\n\t    c->dec_firsttable[bitreverse(word)]=\n\t      0x80000000UL | (loval<<15) | hival;\n\t  }\n\t}\n      }\n    }\n  }\n\n  return(0);\n err_out:\n  vorbis_book_clear(c);\n  return(-1);\n}", "path": "ccs-project\\vorbis-DM6446\\sharedbook.c", "repo_name": "marceloguedes/theora-davinci", "stars": 4, "license": "None", "language": "c", "size": 10600}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,\n    png_voidp mem_ptr)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n   if (struct_ptr != NULL)\n   {\n#ifdef PNG_USER_MEM_SUPPORTED\n      if (free_fn != NULL)\n      {\n         png_struct dummy_struct;\n         png_structp png_ptr = &dummy_struct;\n         png_ptr->mem_ptr=mem_ptr;\n         (*(free_fn))(png_ptr, struct_ptr);\n         return;\n      }\n#endif /* PNG_USER_MEM_SUPPORTED */\n#if defined(__TURBOC__) && !defined(__FLAT__)\n      farfree(struct_ptr);\n#else\n# if defined(_MSC_VER) && defined(MAXSEG_64K)\n      hfree(struct_ptr);\n# else\n      free(struct_ptr);\n# endif\n#endif\n   }\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* This function was added at libpng version 1.2.3.  The png_malloc_warn()\n * function will set up png_malloc() to issue a png_warning and return NULL\n * instead of issuing a png_error, if it fails to allocate the requested\n * memory.\n */\n", "func_signal": "png_voidp PNGAPI\npng_malloc_warn(png_structp png_ptr, png_alloc_size_t size)", "code": "{\n   png_voidp ptr;\n   png_uint_32 save_flags;\n   if (png_ptr == NULL)\n      return (NULL);\n\n   save_flags = png_ptr->flags;\n   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;\n   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);\n   png_ptr->flags=save_flags;\n   return(ptr);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* This function is called when the application wants to use another method\n * of allocating and freeing memory.\n */\n", "func_signal": "void PNGAPI\npng_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr\n  malloc_fn, png_free_ptr free_fn)", "code": "{\n   if (png_ptr != NULL)\n   {\n      png_ptr->mem_ptr = mem_ptr;\n      png_ptr->malloc_fn = malloc_fn;\n      png_ptr->free_fn = free_fn;\n   }\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)", "code": "{\n   png_debug(1, \"in png_do_strip_filler\");\n\n   {\n      png_bytep sp=row;\n      png_bytep dp=row;\n      png_uint_32 row_width=row_info->width;\n      png_uint_32 i;\n\n      if ((row_info->color_type == PNG_COLOR_TYPE_RGB ||\n          (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n          (flags & PNG_FLAG_STRIP_ALPHA))) &&\n          row_info->channels == 4)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This converts from RGBX or RGBA to RGB */\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               dp+=3; sp+=4;\n               for (i = 1; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp++;\n               }\n            }\n            /* This converts from XRGB or ARGB to RGB */\n            else\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 24;\n            row_info->rowbytes = row_width * 3;\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */\n               sp += 8; dp += 6;\n               for (i = 1; i < row_width; i++)\n               {\n                  /* This could be (although png_memcpy is probably slower):\n                  png_memcpy(dp, sp, 6);\n                  sp += 8;\n                  dp += 6;\n                  */\n\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp += 2;\n               }\n            }\n            else\n            {\n               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */\n               for (i = 0; i < row_width; i++)\n               {\n                  /* This could be (although png_memcpy is probably slower):\n                  png_memcpy(dp, sp, 6);\n                  sp += 8;\n                  dp += 6;\n                  */\n\n                  sp+=2;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 48;\n            row_info->rowbytes = row_width * 6;\n         }\n         row_info->channels = 3;\n      }\n      else if ((row_info->color_type == PNG_COLOR_TYPE_GRAY ||\n         (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n         (flags & PNG_FLAG_STRIP_ALPHA))) &&\n          row_info->channels == 2)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This converts from GX or GA to G */\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  sp++;\n               }\n            }\n            /* This converts from XG or AG to G */\n            else\n            {\n               for (i = 0; i < row_width; i++)\n               {\n                  sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 8;\n            row_info->rowbytes = row_width;\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n            if (flags & PNG_FLAG_FILLER_AFTER)\n            {\n               /* This converts from GGXX or GGAA to GG */\n               sp += 4; dp += 2;\n               for (i = 1; i < row_width; i++)\n               {\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n                  sp += 2;\n               }\n            }\n            else\n            {\n               /* This converts from XXGG or AAGG to GG */\n               for (i = 0; i < row_width; i++)\n               {\n                  sp += 2;\n                  *dp++ = *sp++;\n                  *dp++ = *sp++;\n               }\n            }\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n         row_info->channels = 1;\n      }\n      if (flags & PNG_FLAG_STRIP_ALPHA)\n        row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;\n   }\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Turn on pixel packing */\n", "func_signal": "void PNGAPI\npng_set_packing(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_packing\");\n\n   if (png_ptr == NULL)\n      return;\n   if (png_ptr->bit_depth < 8)\n   {\n      png_ptr->transformations |= PNG_PACK;\n      png_ptr->usr_bit_depth = 8;\n   }\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct(png_voidp struct_ptr)", "code": "{\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_destroy_struct_2(struct_ptr, NULL, NULL);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Turn on packed pixel swapping */\n", "func_signal": "void PNGAPI\npng_set_packswap(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_packswap\");\n\n   if (png_ptr == NULL)\n      return;\n   if (png_ptr->bit_depth < 8)\n      png_ptr->transformations |= PNG_PACKSWAP;\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n   png_size_t size;\n   png_voidp struct_ptr;\n\n   if (type == PNG_STRUCT_INFO)\n      size = png_sizeof(png_info);\n   else if (type == PNG_STRUCT_PNG)\n      size = png_sizeof(png_struct);\n   else\n      return (NULL);\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (malloc_fn != NULL)\n   {\n      png_struct dummy_struct;\n      png_structp png_ptr = &dummy_struct;\n      png_ptr->mem_ptr=mem_ptr;\n      struct_ptr = (*(malloc_fn))(png_ptr, size);\n      if (struct_ptr != NULL)\n         png_memset(struct_ptr, 0, size);\n      return (struct_ptr);\n   }\n#endif /* PNG_USER_MEM_SUPPORTED */\n\n#if defined(__TURBOC__) && !defined(__FLAT__)\n   struct_ptr = (png_voidp)farmalloc(size);\n#else\n# if defined(_MSC_VER) && defined(MAXSEG_64K)\n   struct_ptr = (png_voidp)halloc(size, 1);\n# else\n   struct_ptr = (png_voidp)malloc(size);\n# endif\n#endif\n   if (struct_ptr != NULL)\n      png_memset(struct_ptr, 0, size);\n\n   return (struct_ptr);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct(int type)", "code": "{\n#ifdef PNG_USER_MEM_SUPPORTED\n   return (png_create_struct_2(type, NULL, NULL));\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Add a filler byte on read, or remove a filler or alpha byte on write.\n * The filler type has changed in v0.95 to allow future 2-byte fillers\n * for 48-bit input data, as well as to avoid problems with some compilers\n * that don't like bytes as parameters.\n */\n", "func_signal": "void PNGAPI\npng_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_filler\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->transformations |= PNG_FILLER;\n   png_ptr->filler = (png_uint_16)filler;\n   if (filler_loc == PNG_FILLER_AFTER)\n      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;\n   else\n      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\n\n   /* This should probably go in the \"do_read_filler\" routine.\n    * I attempted to do that in libpng-1.0.1a but that caused problems\n    * so I restored it in libpng-1.0.2a\n   */\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_ptr->usr_channels = 4;\n   }\n\n   /* Also I added this in libpng-1.0.2a (what happens when we expand\n    * a less-than-8-bit grayscale to GA? */\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)\n   {\n      png_ptr->usr_channels = 2;\n   }\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* This function returns a pointer to the user_transform_ptr associated with\n * the user transform functions.  The application should free any memory\n * associated with this pointer before png_write_destroy and png_read_destroy\n * are called.\n */\n", "func_signal": "png_voidp PNGAPI\npng_get_user_transform_ptr(png_structp png_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return (NULL);\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\n   return ((png_voidp)png_ptr->user_transform_ptr);\n#else\n   return (NULL);\n#endif\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Added to libpng-1.2.7 */\n", "func_signal": "void PNGAPI\npng_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)", "code": "{\n   png_debug(1, \"in png_set_add_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n   png_set_filler(png_ptr, filler, filler_loc);\n   png_ptr->transformations |= PNG_ADD_ALPHA;\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Turn on 16 bit byte swapping */\n", "func_signal": "void PNGAPI\npng_set_swap(png_structp png_ptr)", "code": "{\n   png_debug(1, \"in png_set_swap\");\n\n   if (png_ptr == NULL)\n      return;\n   if (png_ptr->bit_depth == 16)\n      png_ptr->transformations |= PNG_SWAP_BYTES;\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct(png_voidp struct_ptr)", "code": "{\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_destroy_struct_2(struct_ptr, NULL, NULL);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct(int type)", "code": "{\n#ifdef PNG_USER_MEM_SUPPORTED\n   return (png_create_struct_2(type, NULL, NULL));\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_packswap(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_packswap\");\n\n   if (\n       row_info->bit_depth < 8)\n   {\n      png_bytep rp, end, table;\n\n      end = row + row_info->rowbytes;\n\n      if (row_info->bit_depth == 1)\n         table = (png_bytep)onebppswaptable;\n      else if (row_info->bit_depth == 2)\n         table = (png_bytep)twobppswaptable;\n      else if (row_info->bit_depth == 4)\n         table = (png_bytep)fourbppswaptable;\n      else\n         return;\n\n      for (rp = row; rp < end; rp++)\n         *rp = table[*rp];\n   }\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Free a pointer allocated by png_malloc().  If ptr is NULL, return\n * without taking any action.\n */\n", "func_signal": "void PNGAPI\npng_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n   {\n      (*(png_ptr->free_fn))(png_ptr, ptr);\n      return;\n   }\n   else\n      png_free_default(png_ptr, ptr);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_invert(png_row_infop row_info, png_bytep row)", "code": "{\n   png_debug(1, \"in png_do_invert\");\n\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\n   *   if (row_info->bit_depth == 1 &&\n   */\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i++)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp++;\n      }\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 8)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i+=2)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp+=2;\n      }\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i+=4)\n      {\n         *rp = (png_byte)(~(*rp));\n         *(rp+1) = (png_byte)(~(*(rp+1)));\n         rp+=4;\n      }\n   }\n}", "path": "pngtrans.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* This function allows the application to supply a new input function\n * for libpng if standard C streams aren't being used.\n *\n * This function takes as its arguments:\n * png_ptr      - pointer to a png input data structure\n * io_ptr       - pointer to user supplied structure containing info about\n *                the input functions.  May be NULL.\n * read_data_fn - pointer to a new input function that takes as its\n *                arguments a pointer to a png_struct, a pointer to\n *                a location where input data can be stored, and a 32-bit\n *                unsigned int that is the number of bytes to be read.\n *                To exit and output any fatal error messages the new write\n *                function should call png_error(png_ptr, \"Error msg\").\n *                May be NULL, in which case libpng's default function will\n *                be used.\n */\n", "func_signal": "void PNGAPI\npng_set_read_fn(png_structp png_ptr, png_voidp io_ptr,\n   png_rw_ptr read_data_fn)", "code": "{\n   if (png_ptr == NULL)\n      return;\n   png_ptr->io_ptr = io_ptr;\n\n#ifdef PNG_STDIO_SUPPORTED\n   if (read_data_fn != NULL)\n      png_ptr->read_data_fn = read_data_fn;\n   else\n      png_ptr->read_data_fn = png_default_read_data;\n#else\n   png_ptr->read_data_fn = read_data_fn;\n#endif\n\n   /* It is an error to write to a read device */\n   if (png_ptr->write_data_fn != NULL)\n   {\n      png_ptr->write_data_fn = NULL;\n      png_warning(png_ptr,\n         \"It's an error to set both read_data_fn and write_data_fn in the \");\n      png_warning(png_ptr,\n         \"same structure.  Resetting write_data_fn to NULL\");\n   }\n\n#ifdef PNG_WRITE_FLUSH_SUPPORTED\n   png_ptr->output_flush_fn = NULL;\n#endif\n}", "path": "pngrio.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_create_struct_2(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr)", "code": "{\n#endif /* PNG_USER_MEM_SUPPORTED */\n   png_size_t size;\n   png_voidp struct_ptr;\n\n   if (type == PNG_STRUCT_INFO)\n      size = png_sizeof(png_info);\n   else if (type == PNG_STRUCT_PNG)\n      size = png_sizeof(png_struct);\n   else\n      return (png_get_copyright(NULL));\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (malloc_fn != NULL)\n   {\n      png_struct dummy_struct;\n      png_structp png_ptr = &dummy_struct;\n      png_ptr->mem_ptr=mem_ptr;\n      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);\n   }\n   else\n#endif /* PNG_USER_MEM_SUPPORTED */\n   struct_ptr = (png_voidp)farmalloc(size);\n   if (struct_ptr != NULL)\n      png_memset(struct_ptr, 0, size);\n   return (struct_ptr);\n}", "path": "pngmem.c", "repo_name": "jongwook/libpng", "stars": 7, "license": "None", "language": "c", "size": 256}
{"docstring": "/*\n * Remove 802.11 link-layer types from the list of DLT_ values, as\n * we're not in monitor mode, and those DLT_ values will switch us\n * to monitor mode.\n */\n", "func_signal": "static void\nremove_802_11(pcap_t *p)", "code": "{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard 802.11 values.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_AIRONET_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\t/*\n\t\t\t * 802.11.  Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* pcap_lex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int pcap_lex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tpcap__delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tpcap_pop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tpcap_free((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * pcap_lex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Remove DLT_EN10MB from the list of DLT_ values, as we're in monitor mode,\n * and DLT_EN10MB isn't supported in monitor mode.\n */\n", "func_signal": "static void\nremove_en(pcap_t *p)", "code": "{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard DLT_EN10MB.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_EN10MB:\n\t\t\t/*\n\t\t\t * Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Notify kernel that we are done with the buffer.  We don't reset zbuffer so\n * that we know which buffer to use next time around.\n */\n", "func_signal": "static int\npcap_ack_zbuf(pcap_t *p)", "code": "{\n\n\tatomic_store_rel_int(&p->md.bzh->bzh_user_gen,\n\t    p->md.bzh->bzh_kernel_gen);\n\tp->md.bzh = NULL;\n\tp->buffer = NULL;\n\treturn (0);\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void pcap__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tpcap_pop_buffer_state();\n\t *\t\tpcap_push_buffer_state(new_buffer);\n     */\n\tpcap_ensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tpcap__load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (pcap_wrap()) processing, but the only time this flag\n\t * is looked at is after pcap_wrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to pcap_lex() will\n * scan from a @e copy of @a bytes.\n * @param bytes the byte buffer to scan\n * @param len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE pcap__scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n, i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) pcap_alloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap__scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = pcap__scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in pcap__scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Check whether we have any 802.11 link-layer types; return the best\n * of the 802.11 link-layer types if we find one, and return -1\n * otherwise.\n *\n * DLT_IEEE802_11_RADIO, with the radiotap header, is considered the\n * best 802.11 link-layer type; any of the other 802.11-plus-radio\n * headers are second-best; 802.11 with no radio information is\n * the least good.\n */\n", "func_signal": "static int\nfind_802_11(struct bpf_dltlist *bdlp)", "code": "{\n\tint new_dlt;\n\tint i;\n\n\t/*\n\t * Scan the list of DLT_ values, looking for 802.11 values,\n\t * and, if we find any, choose the best of them.\n\t */\n\tnew_dlt = -1;\n\tfor (i = 0; i < bdlp->bfl_len; i++) {\n\t\tswitch (bdlp->bfl_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n\t\t\t/*\n\t\t\t * 802.11, but no radio.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found an 802.11\n\t\t\t * header with radio information.\n\t\t\t */\n\t\t\tif (new_dlt == -1)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_AIRONET_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\t/*\n\t\t\t * 802.11 with radio, but not radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found the radiotap DLT_.\n\t\t\t */\n\t\t\tif (new_dlt != DLT_IEEE802_11_RADIO)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\t/*\n\t\t\t * 802.11 with radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode.\n\t\t\t */\n\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not 802.11.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (new_dlt);\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE pcap__scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) pcap_alloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap__scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tpcap__switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )", "code": "{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 1434 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 1433);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void pcap_ensure_buffer_stack (void)", "code": "{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)pcap_alloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap_ensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)pcap_realloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap_ensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* defined(__APPLE__) && defined(BIOCGDLTLIST) */\n", "func_signal": "static int\npcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)", "code": "{\n\t/*\n\t * Free any user-mode filter we might happen to have installed.\n\t */\n\tpcap_freecode(&p->fcode);\n\n\t/*\n\t * Try to install the kernel filter.\n\t */\n\tif (ioctl(p->fd, BIOCSETF, (caddr_t)fp) == 0) {\n\t\t/*\n\t\t * It worked.\n\t\t */\n\t\tp->md.use_bpf = 1;\t/* filtering in the kernel */\n\n\t\t/*\n\t\t * Discard any previously-received packets, as they might\n\t\t * have passed whatever filter was formerly in effect, but\n\t\t * might not pass this filter (BIOCSETF discards packets\n\t\t * buffered in the kernel, so you can lose packets in any\n\t\t * case).\n\t\t */\n\t\tp->cc = 0;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * We failed.\n\t *\n\t * If it failed with EINVAL, that's probably because the program\n\t * is invalid or too big.  Validate it ourselves; if we like it\n\t * (we currently allow backward branches, to support protochain),\n\t * run it in userland.  (There's no notion of \"too big\" for\n\t * userland.)\n\t *\n\t * Otherwise, just give up.\n\t * XXX - if the copy of the program into the kernel failed,\n\t * we will get EINVAL rather than, say, EFAULT on at least\n\t * some kernels.\n\t */\n\tif (errno != EINVAL) {\n\t\tsnprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"BIOCSETF: %s\",\n\t\t    pcap_strerror(errno));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * install_bpf_program() validates the program.\n\t *\n\t * XXX - what if we already have a filter in the kernel?\n\t */\n\tif (install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\tp->md.use_bpf = 0;\t/* filtering in userland */\n\treturn (0);\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 1434 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Set direction flag: Which packets do we accept on a forwarding\n * single device? IN, OUT or both?\n */\n", "func_signal": "static int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)", "code": "{\n#if defined(BIOCSDIRECTION)\n\tu_int direction;\n\n\tdirection = (d == PCAP_D_IN) ? BPF_D_IN :\n\t    ((d == PCAP_D_OUT) ? BPF_D_OUT : BPF_D_INOUT);\n\tif (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {\n\t\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"Cannot set direction to %s: %s\",\n\t\t        (d == PCAP_D_IN) ? \"PCAP_D_IN\" :\n\t\t\t((d == PCAP_D_OUT) ? \"PCAP_D_OUT\" : \"PCAP_D_INOUT\"),\n\t\t\tstrerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n#elif defined(BIOCSSEESENT)\n\tu_int seesent;\n\n\t/*\n\t * We don't support PCAP_D_OUT.\n\t */\n\tif (d == PCAP_D_OUT) {\n\t\tsnprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"Setting direction to PCAP_D_OUT is not supported on BPF\");\n\t\treturn -1;\n\t}\n\n\tseesent = (d == PCAP_D_INOUT);\n\tif (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {\n\t\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"Cannot set direction to %s: %s\",\n\t\t        (d == PCAP_D_INOUT) ? \"PCAP_D_INOUT\" : \"PCAP_D_IN\",\n\t\t\tstrerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n#else\n\t(void) snprintf(p->errbuf, sizeof(p->errbuf),\n\t    \"This system doesn't support BIOCSSEESENT, so the direction can't be set\");\n\treturn (-1);\n#endif\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */\n", "func_signal": "YY_BUFFER_STATE pcap__create_buffer  (FILE * file, int  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) pcap_alloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap__create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) pcap_alloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in pcap__create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tpcap__init_buffer(b,file );\n\n\treturn b;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void pcap__flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tpcap__load_buffer_state( );\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * pcap_next_zbuf() -- Similar to pcap_next_zbuf_shm(), except wait using\n * select() for data or a timeout, and possibly force rotation of the buffer\n * in the event we time out or are in immediate mode.  Invoke the shared\n * memory check before doing system calls in order to avoid doing avoidable\n * work.\n */\n", "func_signal": "static int\npcap_next_zbuf(pcap_t *p, int *cc)", "code": "{\n\tstruct bpf_zbuf bz;\n\tstruct timeval tv;\n\tstruct timespec cur;\n\tfd_set r_set;\n\tint data, r;\n\tint expire, tmout;\n\n#define TSTOMILLI(ts) (((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))\n\t/*\n\t * Start out by seeing whether anything is waiting by checking the\n\t * next shared memory buffer for data.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * If a previous sleep was interrupted due to signal delivery, make\n\t * sure that the timeout gets adjusted accordingly.  This requires\n\t * that we analyze when the timeout should be been expired, and\n\t * subtract the current time from that.  If after this operation,\n\t * our timeout is less then or equal to zero, handle it like a\n\t * regular timeout.\n\t */\n\ttmout = p->md.timeout;\n\tif (tmout)\n\t\t(void) clock_gettime(CLOCK_MONOTONIC, &cur);\n\tif (p->md.interrupted && p->md.timeout) {\n\t\texpire = TSTOMILLI(&p->md.firstsel) + p->md.timeout;\n\t\ttmout = expire - TSTOMILLI(&cur);\n#undef TSTOMILLI\n\t\tif (tmout <= 0) {\n\t\t\tp->md.interrupted = 0;\n\t\t\tdata = pcap_next_zbuf_shm(p, cc);\n\t\t\tif (data)\n\t\t\t\treturn (data);\n\t\t\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\t\t\t(void) snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"BIOCROTZBUF: %s\", strerror(errno));\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\treturn (pcap_next_zbuf_shm(p, cc));\n\t\t}\n\t}\n\t/*\n\t * No data in the buffer, so must use select() to wait for data or\n\t * the next timeout.  Note that we only call select if the handle\n\t * is in blocking mode.\n\t */\n\tif (p->md.timeout >= 0) {\n\t\tFD_ZERO(&r_set);\n\t\tFD_SET(p->fd, &r_set);\n\t\tif (tmout != 0) {\n\t\t\ttv.tv_sec = tmout / 1000;\n\t\t\ttv.tv_usec = (tmout * 1000) % 1000000;\n\t\t}\n\t\tr = select(p->fd + 1, &r_set, NULL, NULL,\n\t\t    p->md.timeout != 0 ? &tv : NULL);\n\t\tif (r < 0 && errno == EINTR) {\n\t\t\tif (!p->md.interrupted && p->md.timeout) {\n\t\t\t\tp->md.interrupted = 1;\n\t\t\t\tp->md.firstsel = cur;\n\t\t\t}\n\t\t\treturn (0);\n\t\t} else if (r < 0) {\n\t\t\t(void) snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"select: %s\", strerror(errno));\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tp->md.interrupted = 0;\n\t/*\n\t * Check again for data, which may exist now that we've either been\n\t * woken up as a result of data or timed out.  Try the \"there's data\"\n\t * case first since it doesn't require a system call.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * Try forcing a buffer rotation to dislodge timed out or immediate\n\t * data.\n\t */\n\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\t(void) snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"BIOCROTZBUF: %s\", strerror(errno));\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (pcap_next_zbuf_shm(p, cc));\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tpcap_realloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tpcap_restart(pcap_in  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) pcap_realloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void pcap_pop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tpcap__delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tpcap__load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "libpcap-1.1.1\\scanner.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Turn off rfmon mode if necessary.\n */\n", "func_signal": "static void\npcap_cleanup_bpf(pcap_t *p)", "code": "{\n#ifdef HAVE_BSD_IEEE80211\n\tint sock;\n\tstruct ifmediareq req;\n\tstruct ifreq ifr;\n#endif\n\n\tif (p->md.must_do_on_close != 0) {\n\t\t/*\n\t\t * There's something we have to do when closing this\n\t\t * pcap_t.\n\t\t */\n#ifdef HAVE_BSD_IEEE80211\n\t\tif (p->md.must_do_on_close & MUST_CLEAR_RFMON) {\n\t\t\t/*\n\t\t\t * We put the interface into rfmon mode;\n\t\t\t * take it out of rfmon mode.\n\t\t\t *\n\t\t\t * XXX - if somebody else wants it in rfmon\n\t\t\t * mode, this code cannot know that, so it'll take\n\t\t\t * it out of rfmon mode.\n\t\t\t */\n\t\t\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (sock == -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface flags (socket() failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t} else {\n\t\t\t\tmemset(&req, 0, sizeof(req));\n\t\t\t\tstrncpy(req.ifm_name, p->md.device,\n\t\t\t\t    sizeof(req.ifm_name));\n\t\t\t\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"Can't restore interface flags (SIOCGIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif (req.ifm_current & IFM_IEEE80211_MONITOR) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Rfmon mode is currently on;\n\t\t\t\t\t\t * turn it off.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\t\t(void)strncpy(ifr.ifr_name,\n\t\t\t\t\t\t    p->md.device,\n\t\t\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\t\t\tifr.ifr_media =\n\t\t\t\t\t\t    req.ifm_current & ~IFM_IEEE80211_MONITOR;\n\t\t\t\t\t\tif (ioctl(sock, SIOCSIFMEDIA,\n\t\t\t\t\t\t    &ifr) == -1) {\n\t\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t    \"Can't restore interface flags (SIOCSIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n#endif /* HAVE_BSD_IEEE80211 */\n\n\t\t/*\n\t\t * Take this pcap out of the list of pcaps for which we\n\t\t * have to take the interface out of some mode.\n\t\t */\n\t\tpcap_remove_from_pcaps_to_close(p);\n\t\tp->md.must_do_on_close = 0;\n\t}\n\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * In zero-copy mode, p->buffer is just a pointer into one of the two\n\t * memory-mapped buffers, so no need to free it.\n\t */\n\tif (p->md.zerocopy) {\n\t\tif (p->md.zbuf1 != MAP_FAILED && p->md.zbuf1 != NULL)\n\t\t\tmunmap(p->md.zbuf1, p->md.zbufsize);\n\t\tif (p->md.zbuf2 != MAP_FAILED && p->md.zbuf2 != NULL)\n\t\t\tmunmap(p->md.zbuf2, p->md.zbufsize);\n\t}\n#endif\n\tif (p->md.device != NULL) {\n\t\tfree(p->md.device);\n\t\tp->md.device = NULL;\n\t}\n\tpcap_cleanup_live_common(p);\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/*\n * Zero-copy specific close method.  Un-map the shared buffers then call\n * pcap_cleanup_live_common.\n */\n", "func_signal": "static void\npcap_cleanup_zbuf(pcap_t *p)", "code": "{\n\t/*\n\t * Delete the mappings.  Note that p->buffer gets initialized to one\n\t * of the mmapped regions in this case, so do not try and free it\n\t * directly; null it out so that pcap_cleanup_live_common() doesn't\n\t * try to free it.\n\t */\n\tif (p->md.zbuf1 != MAP_FAILED && p->md.zbuf1 != NULL)\n\t\t(void) munmap(p->md.zbuf1, p->md.zbufsize);\n\tif (p->md.zbuf2 != MAP_FAILED && p->md.zbuf2 != NULL)\n\t\t(void) munmap(p->md.zbuf2, p->md.zbufsize);\n\tp->buffer = NULL;\n\tpcap_cleanup_live_common(p);\n}", "path": "libpcap-1.1.1\\pcap-bpf.c", "repo_name": "Saqoosha/OSC-Broadcaster", "stars": 4, "license": "None", "language": "c", "size": 3984}
{"docstring": "/* Find tags <#x#>. Replace with for x=R confirm, for x=A */\n/* target, x=l outlocal, x=h outhost. For others, just    */\n/* skip tag. If outlocal/outhost are not set, the tags are*/\n/* skipped. If confirm/taget are not set, the tags are    */\n/* replaced by \"???????\" */\n", "func_signal": "void copy_xlate(stralloc *out,\n\t\tconst stralloc *line,\n\t\tconst char *params[10],\n\t\tchar q)", "code": "{\n  unsigned int pos;\n  unsigned int nextpos;\n\n  pos = 0;\n  nextpos = 0;\n  out->len = 0;\n  while ((pos += byte_chr(line->s+pos,line->len-pos,'<')) < line->len) {\n    if (pos + 4 < line->len &&\n\tline->s[pos+1] == '#' &&\n\tline->s[pos+3] == '#' &&\n\tline->s[pos+4] == '>') {\n      /* tag. Copy first part of line */\n      if (!stralloc_catb(out,line->s+nextpos,pos-nextpos))\n\tdie_nomem();\n      switch(line->s[pos+2]) {\n      case 'A':\n\tif (q == 'H') strerr_die1x(111,MSG(ERR_SUBST_UNSAFE));\n\tif (!stralloc_cats(out,target)) die_nomem();\n\tbreak;\n      case 'L':\n\tif (!quote(&qline,&local)) die_nomem();\n\tif (!stralloc_cat(out,&qline)) die_nomem();\n\tbreak;\n      case 'R':\n\tif (!stralloc_cats(out,confirm)) die_nomem();\n\tbreak;\n      case 'a':\n\tif (!stralloc_catb(out,target,targetlocal)) die_nomem();\n\tbreak;\n      case 'c':\n\tif (!stralloc_catb(out,confirm+confirmprefix,\n\t\t\t   confirmlocal-confirmprefix)) die_nomem();\n\tbreak;\n      case 'd':\n\tif (listdir != 0)\n\t  if (!stralloc_cats(out,listdir)) die_nomem();\n\tbreak;\n      case 'r':\n\tif (!stralloc_catb(out,confirm,confirmlocal)) die_nomem();\n\tbreak;\n      case 'l':\n\tif (!quote(&qline,&outlocal)) die_nomem();\n\tif (!stralloc_cat(out,&qline)) die_nomem();\n\tbreak;\n      case 'h':\n      case 'H':\n\tif (!stralloc_cat(out,&outhost)) die_nomem();\n\tbreak;\n      case 't':\n\tif (q == 'H') strerr_die1x(111,MSG(ERR_SUBST_UNSAFE));\n\tif (!stralloc_cats(out,verptarget)) die_nomem();\n\tbreak;\n      case 'n':\n\tif (!stralloc_cats(out,szmsgnum)) die_nomem();\n\tbreak;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n\tif (params != 0)\n\t  if (params[line->s[pos+2]-'0'] != 0)\n\t    if (!stralloc_cats(out,params[line->s[pos+2]-'0']))\n\t      die_nomem();\n\tbreak;\n      default:\n\tbreak;\t\t\t/* unknown tags killed */\n      }\n      pos += 5;\n      nextpos = pos;\n    } else\n      ++pos;\t\t\t\t/* try next position */\n  }\n  if (!stralloc_catb(out,line->s+nextpos,line->len-nextpos))\n    die_nomem();\t\t/* remainder */\n}", "path": "copy.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Checks the argument. Only  us-ascii letters, numbers, \".+-_\" are ok. */\n/* NOTE: For addresses this is more restrictive than rfc821/822.        */\n", "func_signal": "void checkarg(const char *s)", "code": "{\n  const char *cp;\n  char ch;\n  cp = s;\n  if (!cp) return;\t\t\t\t/* undef is ok */\n  while ((ch = *cp++)) {\n    if (ch >= 'a' && ch <= 'z')\n\t continue;\t\t\t\t/* lc letters */\n    if (ch >= '0' && ch <='9')\t\t\t/* digits */\n\tcontinue;\n    if (ch == '.' || ch == '-' || ch == '_' || ch == '+')\n\tcontinue;\t\t\t\t/* ok chars */\n    if (ch >= 'A' && ch <= 'Z') continue;\t/* UC LETTERS */\n    strerr_die4x(100,MSG(ERR_NOT_CLEAN),\": \\\"\",s,\"\\\"\");\n  }\n  return;\n}", "path": "ezmlm-request.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* open connection to the SQL server, if it isn't already open. */\n", "func_signal": "static const char *_opensub(struct subdbinfo *info)", "code": "{\n  if (!(sqlite3*)info->conn) {\n    if (!stralloc_copys(&line,info->db)) die_nomem();\n    if (!stralloc_cats(&line,\".db\")) die_nomem();\n    if (!stralloc_0(&line)) die_nomem();\n    if (sqlite3_open_v2(line.s, (sqlite3**)&info->conn, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL) != SQLITE_OK)\n\treturn sqlite3_errmsg((sqlite3*)info->conn); /* init */\n  }\n  return (char *) 0;\n}", "path": "sub-sqlite3.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* the first en of those are ALLOCATED. environ[en] is 0. */\n", "func_signal": "static void env_goodbye(int i)", "code": "{\n alloc_free(environ[i]);\n environ[i] = environ[--en];\n environ[en] = 0;\n}", "path": "env.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* open connection to the SQL server, if it isn't already open. */\n", "func_signal": "static const char *_opensub(struct subdbinfo *info)", "code": "{\n  if (!(MYSQL*)info->conn) {\n    if (!(info->conn = mysql_init((MYSQL *) 0)))\n\t die_nomem();\t\t\t\t\t/* init */\n    if (!(mysql_real_connect((MYSQL*)info->conn,info->host,info->user,info->pw,\n\t\t\t     info->db,info->port,0,0)))\n\t\treturn mysql_error((MYSQL*)info->conn);\n  }\n  return (char *) 0;\n}", "path": "sub-mysql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* this error is for things that happen only if program logic is screwed up */\n", "func_signal": "void die_prog(const char *s)", "code": "{ strerr_die5x(100,FATAL,\"program error (please send bug report to bugs@ezmlm.org): \",s,\" Command: \",cmd); }\n\n/* If we already issued a header than this will look ugly */\nvoid cgierr(const char *s,const char *s1,const char *s2)\n{\n  strerr_warn4(FATAL,s,s1,s2,(struct strerr *)0);\n  oputs(\"Content-type: text/plain\\n\");\n  oputs(\"Status: 500 Couldn't do it\\n\\n\");\n  oputs(\"I tried my best, but:\\n\\n\");\n  if (s) oputs(s);\n  if (s1) oputs(s1);\n  if (s2) oputs(s2);\n  oputs(\"\\n\");\n  substdio_flush(&ssout);\n  _exit(0);\n}", "path": "ezmlm-cgi.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* open connection to the SQL server, if it isn't already open. */\n", "func_signal": "static const char *_opensub(struct subdbinfo *info)", "code": "{\n  if (info->conn == 0) {\n    /* Make connection to database */\n    strnum[fmt_ulong(strnum,info->port)] = 0;\n    info->conn = PQsetdbLogin(info->host,info->port?strnum:\"\",NULL,NULL,\n\t\t\t      info->db,info->user,info->pw);\n    /* Check  to see that the backend connection was successfully made */\n    if (PQstatus((PGconn*)info->conn) == CONNECTION_BAD)\n      return PQerrorMessage((PGconn*)info->conn);\n    /* Suppress output of notices. */\n    PQsetNoticeProcessor((PGconn*)info->conn, dummyNoticeProcessor, NULL);\n  }\n  return (char *) 0;\n}", "path": "sub-pgsql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/**************** MAY BE SUID ROOT HERE ****************************/\n", "func_signal": "void drop_priv(int flagchroot)", "code": "{\n  if (!uid) strerr_die2x(100,FATAL,MSG(ERR_SUID));\t\t/* not as root */\n  if (!euid) {\n    if (flagchroot)\n      if (chroot(dir) == -1)\t\t\t\t/* chroot listdir */\n        strerr_die2sys(111,FATAL,MSG1(ERR_CHROOT,dir));\n    if (setuid(uid) == -1)\t\t\t\t/* setuid */\n      strerr_die2sys(111,FATAL,MSG(ERR_SETUID));\n  }\n  euid = (unsigned long) geteuid();\n  if (!euid) strerr_die2x(100,FATAL,MSG(ERR_SUID));\t\t/* setuid didn't do it*/\n}", "path": "ezmlm-cgi.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Public domain, from djbdns-1.05. */\n/* As per http://cr.yp.to/djbdns/res-disaster.html */\n", "func_signal": "int main()", "code": "{\n  unsigned long u;\n  u = 1;\n  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;\n  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;\n  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;\n  u += u; u += u; u += u; u += u; u += u; u += u; u += u; u += u;\n  if (!u) _exit(0);\n  _exit(1);\n}", "path": "tryulong32.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Creates an entry for message num and the list listno and code \"done\".\n * Returns NULL on success, and the error string on error. */\n", "func_signal": "static const char *_logmsg(struct subdbinfo *info,\n\t\t\t   unsigned long num,\n\t\t\t   unsigned long listno,\n\t\t\t   unsigned long subs,\n\t\t\t   int done)", "code": "{\n  sqlite3_stmt *stmt;\n  int res;\n\n  if (!stralloc_copys(&logline,\"INSERT INTO \")) die_nomem();\n  if (!stralloc_cats(&logline,info->base_table)) die_nomem();\n  if (!stralloc_cats(&logline,\"_mlog (msgnum,listno,tai,subs,done) VALUES (\"))\n\tdie_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,num))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,listno)))\n\tdie_nomem();\n  if (!stralloc_cats(&line,\",\")) die_nomem();\n  if (!stralloc_catb(&line,strnum,fmt_ulong(strnum,now()))) die_nomem();\n  if (!stralloc_cats(&line,\",'\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,subs))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (done < 0) {\n    done = - done;\n    if (!stralloc_append(&logline,\"-\")) die_nomem();\n  }\n  if (!stralloc_catb(&logline,strnum,fmt_uint(strnum,done))) die_nomem();\n  if (!stralloc_append(&logline,\")\")) die_nomem();\n  if (!stralloc_0(&logline)) die_nomem();\n\n  if ((stmt = _sqlquery(info, &logline)) == NULL)\t/* log query */\n\t  return sqlite3_errmsg((sqlite3*)info->conn);\n\n  res = sqlite3_step(stmt);\n  sqlite3_finalize(stmt);\n\n  if (res != SQLITE_DONE)\n  {\n\t  if (res != SQLITE_CONSTRAINT)\t\t/* ignore dups */\n\t\t  return sqlite3_errmsg((sqlite3*)info->conn);\n  }\n\n  return 0;\n}", "path": "sub-sqlite3.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* close connection to SQL server, if open */\n", "func_signal": "static void _closesub(struct subdbinfo *info)", "code": "{\n  if ((MYSQL*)info->conn)\n    mysql_close((MYSQL*)info->conn);\n  info->conn = 0;\t\t\t\t\t/* destroy pointer */\n}", "path": "sub-mysql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/*******************************************************************/\n", "func_signal": "int main(int argc,char **argv)", "code": "{\n  char *cp,*cppath;\n  unsigned long listno,thislistno,tmpuid,msgset;\n  unsigned long msgnum = 0;\n  unsigned long port = 0L;\n  unsigned long tmptarget;\n  unsigned int pos,l;\n  int flagindex = 0;\n  int flagchroot = 1;\t\t/* chroot listdir if SUID root */\n  int ret;\n  char sep;\n\n/******************** we may be SUID ROOT ******************************/\n  uid = (unsigned long) getuid();\t\t\t/* should be http */\n  euid = (unsigned long) geteuid();\t\t\t/* chroot only if 0 */\n\n  if (!euid) {\n    if (!stralloc_copys(&line,auto_etc())) die_nomem();\n    if (!stralloc_cats(&line,EZ_CGIRC)) die_nomem();\n    if (!stralloc_0(&line)) die_nomem();\n    if ((fd = open_read(line.s)) == -1)\t\t\t/* open config */\n      strerr_die2sys(111,FATAL,MSG1(ERR_OPEN,line.s));\n  } else {\n    if ((fd = open_read(EZ_CGIRC_LOC)) == -1)\t\t/* open local config */\n      strerr_die2sys(111,FATAL,MSG1(ERR_OPEN,EZ_CGIRC_LOC));\n  }\n\n  substdio_fdbuf(&ssin,read,fd,inbuf,sizeof(inbuf));\t/* set up buffer */\n\t/* ##### tainted info #####*/\n\n  cmd = env_get(\"QUERY_STRING\");\t\t\t/* get command */\n  cppath = env_get(\"PATH_INFO\");\t\t\t/* get path_info */\n\n  if (!cmd && !cppath)\n    cmd = argv[1];\n\n  if (!cppath || !*cppath) {\n    if (cmd && *cmd) {\n      cmd += scan_ulong(cmd,&thislistno);\n      if (*cmd == ':') cmd++;\t\t\t\t/* allow ':' after ln*/\n    } else\n      thislistno = 0L;\n  } else {\n    if (*cppath == '/') cppath++;\n      cppath += scan_ulong(cppath,&thislistno);\t\t/* this listno */\n      if (!thislistno || *cppath++ == '/') {\n\tif (str_start(cppath,\"index\")) {\n          cppath += 5;\n\t  flagindex = 1;\n\t  if (!thislistno) {\t\t\t\t/* list index */\n\t    drop_priv(0);\t/* <---- dropping privs */\n\t    list_lists();\n\t    close(fd);\n\t    _exit(0);\n\t  }\n\t}\n      }\t\t\t\t\t\t\t/* rest done per list */\n    }\n\n  for (sep = pos = 0;;) {\n    if (getln(&ssin,&cfline,&match,'\\n') == -1)\t\t/* read line */\n      strerr_die2sys(111,FATAL,MSG1(ERR_READ,fn.s));\n    if (!match)\n      break;\n    if (*cfline.s == '#' || cfline.len == 1) continue;\t/* skip comment/blank */\n    cfline.s[cfline.len - 1] = '\\0';\t\t\t/* so all are sz */\n    pos = scan_ulong(cfline.s,&listno);\t\t\t/* listno for line */\n    if (thislistno != listno) continue;\n    sep = cfline.s[pos++];\n    if (cfline.s[pos] == '-') {\t\t\t\t/* no chroot if -uid*/\n      flagchroot = 0;\n      pos++;\n    }\n    pos += scan_ulong(cfline.s+pos,&tmpuid);\t\t/* listno for line */\n    if (tmpuid) uid = tmpuid;\t\t\t\t/* override default */\n    if (!cfline.s[pos++] == sep)\n      die_syntax(\"missing separator after user id\");\n    if (cfline.s[pos] != '/')\n\tdie_syntax(\"dir\");\t\t\t\t/* absolute path */\n    l = byte_chr(cfline.s + pos, cfline.len - pos,sep);\n    if (l == cfline.len - pos)\t\t\t\t/* listno:path:...*/\n      die_syntax(\"missing separator after path\");\n    dir = cfline.s + pos;\n    pos += l;\n    cfline.s[pos++] = '\\0';\t\t\t\t/* .../dir\\0 */\n    break;\t/* do rest after dropping priv */\n  }\n  close(fd);\t\t\t\t\t\t/* don't accept uid 0*/\n  if (!dir) {\n    drop_priv(0);\t/* don't trust cgierr. No dir, no chroot */\n    cgierr(\"list \",MSG(ERR_NOEXIST),\"\");\n  }\n  wrap_chdir(dir);\n  drop_priv(flagchroot);\n\n/******************************* RELAX **********************************/\n\n/********************* continue to process config line ******************/\n\n  flagrobot = 0;\n  if (cfline.s[pos] == '-') {\n    flagobscure = 1;\n    pos++;\n  }\n  local = cfline.s + pos;\n  l = byte_chr(cfline.s + pos, cfline.len - pos,sep);\t/* ... home */\n  if (l < cfline.len - pos) {\t\t\t\t/* optional */\n    pos += l;\n    cfline.s[pos++] = '\\0';\n    home = cfline.s + pos;\n    l = byte_chr(cfline.s + pos, cfline.len - pos,sep);\t/* ... charset */\n    if (l < cfline.len - pos) {\t\t\t\t/* optional */\n      pos += l;\n      cfline.s[pos++] = '\\0';\n      charset = cfline.s + pos;\n      l = byte_chr(cfline.s+pos,cfline.len - pos,sep);\t/* ... stylesheet */\n      if (l < cfline.len - pos) {\t\t\t/* optional */\n        pos += l;\n        cfline.s[pos++] = '\\0';\n        stylesheet = cfline.s + pos;\n        l = byte_chr(cfline.s+pos,cfline.len-pos,sep);\t/* ... bannerURL */\n\tif (l < cfline.len - pos) {\t\t\t/* optional */\n\t  pos += l;\n\t  cfline.s[pos++] = '\\0';\n\t  banner = cfline.s + pos;\n\t}\n      }\n    }\n  }\n  if (!charset || !*charset)\t\t\t\t/* rfc822 default */\n    charset = EZ_CHARSET;\n  if (!stralloc_copys(&curcharset,charset)) die_nomem();\n  csbase = decode_charset(curcharset.s,curcharset.len);\n  if (csbase == CS_BAD) csbase = CS_NONE;\n  cs = csbase;\n  pos = + str_rchr(local,'@');\n  if (!local[pos])\n    die_syntax(\"listaddress lacks '@'\");\t\t/* require host */\n  local[pos++] = '\\0';\n  host = local + pos;\n\n/********************* Accomodate robots and PATH_INFO ****************/\n\n  if (flagindex) {\n    if (*(cppath++) == '/') {\t\t/* /2/index/123 */\n      cppath += scan_ulong(cppath,&msgset);\n      list_set(msgset);\n    } else\t\t\t\t/* /2/index */\n      list_list(thislistno);\n    _exit(0);\n  }\n\n  if (cppath && *cppath) {\t\t/* /2/msgnum */\n    flagrobot = 1;\t\t\t/* allow index, but \"nofollow\" */\n    scan_ulong(cppath,&msgnum);\n  }\t\t\t\t\t/* dealt with normally */\n\n/********************* Get info from server on BASE etc ****************/\n\n  if (!stralloc_copys(&url,\"<a href=\\\"\")) die_nomem();\n  if (!stralloc_copys(&base,\"<base href=\\\"http://\")) die_nomem();\n  cp = env_get(\"SERVER_PORT\");\n  if (cp) {\t\t\t/* port */\n    (void) scan_ulong(cp,&port);\n    if ((unsigned int) port == 443) {\t\t/* https: */\n      if (!stralloc_copys(&base,\"<base href=\\\"https://\")) die_nomem();\n    }\n  }\n  if ((cp = env_get(\"HTTP_HOST\")) || (cp = env_get(\"SERVER_NAME\"))) {\n    if (!stralloc_cats(&base,cp)) die_nomem();\n    if (port && (unsigned int) port != 80 && (unsigned int) port != 443) {\n      if (!stralloc_cats(&base,\":\")) die_nomem();\n      if (!stralloc_catb(&base,strnum,fmt_ulong(strnum,port))) die_nomem();\n    }\n  }\n  if ((cp = env_get(\"SCRIPT_NAME\")) != 0) {\n    if (!stralloc_cats(&base,cp)) die_nomem();\n    pos = str_rchr(cp,'/');\n    if (cp[pos])\n      if (!stralloc_cats(&url,cp + pos + 1)) die_nomem();\n  }\n  if (!stralloc_cats(&base,\"\\\" />\\n\")) die_nomem();\n  if (!stralloc_cats(&url,\"?\")) die_nomem();\n  if (thislistno) {\n    if (!stralloc_catb(&url,strnum,fmt_ulong(strnum,thislistno))) die_nomem();\n    if (!stralloc_cats(&url,\":\")) die_nomem();\n  }\n\n  cache = 1;\t\t\t\t/* don't know if we want to cache */\n\n/****************************** Get command ****************************/\n\n  if (msgnum) {\t\t\t\t/* to support /listno/msgno */\n   msginfo.target = msgnum;\n   msginfo.item = ITEM_MESSAGE;\n   cache = 2;\n  } else {\n      (void) decode_cmd(cmd,&msginfo);\n      if (!do_cmd(&msginfo))\n\tcgierr(\"I'm sorry, Dave ... I can't do that, Dave ...\",\"\",\"\");\n  }\n\n  switch (msginfo.item) {\n    case ITEM_MESSAGE:\n\tif (!(ret = show_message(&msginfo))) {\t/* assume next exists ... */\n\t  cache = 0;\t\t\t\t/* border cond. - no cache */\n\t  msginfo.target = msginfo.source;\t/* show same */\n\t  msginfo.subjnav = 0;\n\t  msginfo.authnav = 0;\n\t  ret = show_message(&msginfo);\n\t}\n\tbreak;\n    case ITEM_AUTHOR:\n\tif (!(ret = show_object(&msginfo,ITEM_AUTHOR)))\n\t  cgierr (\"I couldn't find the author for that message\",\"\",\"\");\n\tbreak;\n    case ITEM_SUBJECT:\n\tif (!(ret = show_object(&msginfo,ITEM_SUBJECT)))\n\t  cgierr (\"I couldn't find the subject for that message\",\"\",\"\");\n\tbreak;\n    case ITEM_DATE:\n\tif (!(ret = show_object(&msginfo,ITEM_DATE))) {\n\t  finddate(&msginfo);\n\t  ret = show_object(&msginfo,ITEM_DATE);\n\t}\n\tbreak;\n    case ITEM_INDEX:\n\tret = 1;\n\tif (show_index(&msginfo)) break;/* msgnumber valid */\n\ttmptarget = msginfo.target;\n\tfindlastmsg(&msginfo);\n\tcache = 0;\t\t\t/* latest one - no cache */\n\tif (msginfo.target > tmptarget) {\n\t  cache = 2;\t\t\t/* first one won't change */\n\t  msginfo.target = 1;\t\t/* try */\n\t  if (show_index(&msginfo)) break;\n\t  msginfo.date = 0;\t\t/* first indexes missing */\n          firstdate(&msginfo);\t\t/* instead get first msg of first */\n\t  date2msg(&msginfo);\t\t/* thread. */\n\t  if (show_index(&msginfo)) break;\n\t} else\n\t  ret = show_index(&msginfo);\n\tbreak;\n    default:\n\tstrerr_die2x(100,FATAL,\"bad item in main\");\n  }\n  if (!ret) {\n    findlastmsg(&msginfo);\t\t/* as last resort; last msgindex */\n    cache = 0;\n    ret = show_message(&msginfo);\n  }\n\n _exit(0);\n (void)argc;\n}", "path": "ezmlm-cgi.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Creates an entry for message num and the list listno and code \"done\".\n * Returns NULL on success, and the error string on error. */\n", "func_signal": "static const char *_logmsg(struct subdbinfo *info,\n\t\t\t   unsigned long num,\n\t\t\t   unsigned long listno,\n\t\t\t   unsigned long subs,\n\t\t\t   int done)", "code": "{\n  if (!stralloc_copys(&logline,\"INSERT INTO \")) die_nomem();\n  if (!stralloc_cats(&logline,info->base_table)) die_nomem();\n  if (!stralloc_cats(&logline,\"_mlog (msgnum,listno,subs,done) VALUES (\"))\n\tdie_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,num))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,listno)))\n\tdie_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,subs))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (done < 0) {\n    done = - done;\n    if (!stralloc_append(&logline,\"-\")) die_nomem();\n  }\n  if (!stralloc_catb(&logline,strnum,fmt_uint(strnum,done))) die_nomem();\n  if (!stralloc_append(&logline,\")\")) die_nomem();\n\n  if (mysql_real_query((MYSQL*)info->conn,logline.s,logline.len))\t/* log query */\n    if (mysql_errno((MYSQL*)info->conn) != ER_DUP_ENTRY)\t/* ignore dups */\n\treturn mysql_error((MYSQL*)info->conn);\n  return 0;\n}", "path": "sub-mysql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* close connection to SQL server, if open */\n", "func_signal": "static void _closesub(struct subdbinfo *info)", "code": "{\n  if ((sqlite3*)info->conn)\n    sqlite3_close((sqlite3*)info->conn);\n  info->conn = 0;\t\t\t\t\t/* destroy pointer */\n}", "path": "sub-sqlite3.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* close connection to SQL server, if open */\n", "func_signal": "static void _closesub(struct subdbinfo *info)", "code": "{\n  if ((PGconn*)info->conn)\n    PQfinish((PGconn*)info->conn);\n  info->conn = 0;\t\t/* Destroy pointer */\n}", "path": "sub-pgsql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* 0 prev prev 1 prev 2 this 3 next 4 next-next */\n", "func_signal": "void toggle_flagpre(int flag)", "code": "{\n  flagpre = flag;\n  precharcount = 0;\n  cn1 = 0; cn2 = 0;\t\t/* just in case */\n}", "path": "ezmlm-cgi.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Fix up the named subdirectory to strip off the leading base directory\n * if it is an absolute path, or reject it if it falls outside of the\n * base directory. */\n", "func_signal": "static const char *fixsubdir(const char *subdir)", "code": "{\n  unsigned int dir_len;\n  if (subdir != 0) {\n    if (subdir[0] == '/') {\n      dir_len = str_len(listdir);\n      if (str_diffn(subdir,listdir,dir_len) != 0\n\t  || (subdir[dir_len] != '/'\n\t      && subdir[dir_len] != 0))\n\tstrerr_die2x(111,FATAL,MSG(ERR_NO_ABSOLUTE));\n      subdir += dir_len;\n      while (*subdir == '/')\n\t++subdir;\n    }\n    if (subdir[str_chr(subdir,'/')] == '/')\n      strerr_die2x(111,FATAL,MSG(ERR_NO_LEVELS));\n    if (subdir[0] == 0\n\t|| (subdir[0] == '.' && subdir[1] == 0))\n      subdir = 0;\n  }\n  return subdir;\n}", "path": "subdb.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* 5. command listlocal[@listhost] userlocal@userhost                   */\n/* 6. which [userlocal@userhost]\t\t\t\t\t*/\n/* The first 3 are valid only if !cfname, i.e. -request operation and   */\n/* listlocal and listhost are always set to outlocal@outhost. Options   */\n/* 4-5 are for the global address (cfname is set). Here listhost is     */\n/* taken from the first list in *cfname matching listlocal, or set to   */\n/* outhost, if not specified. If specified, it's accepted if it matches */\n/* a list in *cfname and silently set to outhost otherwise. Pointers to */\n/* unspecified parts are set to NULL in this routine to be dealt with   */\n/* elsewhere. \"Which\" special argument order (6) is fixed elsewhere.    */\n/* If listhost is not given, \"@outhost\" is added. Absence of 'userhost' */\n/* is accepted to allow commands that take arguments that are not       */\n/* addresses (e.g. -get12-34).                                          */\n", "func_signal": "void parseline(char *cp)", "code": "{\n  char *cp1;\n  char *cp2;\n  char *cp3;\n\n  cp1 = cp;\n  while (*cp1) {\t\t\t\t/* make tabs into spaces */\n    if (*cp1 == '\\t') *cp1 = ' ';\n    ++cp1;\n  }\n\t\t\t\t\t/* NOTE: listname has '\\0' added! */\n  if (listname.len < str_len(cp) && cp[listname.len -1] == '-' &&\n\tcase_starts(cp,listname.s))\t {\t/* normal ezmlm cmd */\n    command = cp + listname.len;\t\t/* after the '-' */\n    listlocal = listname.s;\n    listhost = hostname.s;\n    cp1 = command;\n    while (*cp1 && *cp1 != '-') ++cp1;\t\t/* find next '-' */\n    if (*cp1) {\n      *cp1 = '\\0';\n      userlocal = ++cp1;\t\t\t/* after '-' */\n      cp1 = cp1 + str_rchr(cp1,'@');\t\t/* @ _or_ end */\n      *cp1 = '\\0';\t\t\t\t/* last '=' in userlocal */\n      cp1 = userlocal + str_rchr(userlocal,'=');\n      if (*cp1) {\t\t\t\t/* found '=' */\n        *cp1 = '\\0';\t\t\t\t/* zap */\n        userhost = cp1 + 1;\t\t\t/* char after '=' */\n      }\n    }\n  } else {\t\t\t\t/* '@' before ' ' means complete cmd */\n    if (str_chr(cp,'@') < str_chr(cp,' '))\t/* addr where local failed */\n\tstrerr_die2x(100,FATAL,MSG(ERR_REQ_LOCAL));\n\t\t\t\t\t\t/* to match */\n    command = cp;\n    cp1 = cp + str_chr(cp,' ');\n    if (*cp1) {\n      *cp1++ = '\\0';\n      while (*cp1 && *cp1 == ' ') ++cp1;\t/* skip spaces */\n    }\n    cp2 = 0;\n    if (*cp1) {\t\t\t\t\t/* argument */\n      cp2 = cp1 + str_chr(cp1,' ');\n      cp3 = cp2;\n      while (*cp2 && *cp2 == ' ') ++cp2;\t/* skip spaces */\n      *cp3 = '\\0';\n\n      if (!*cp2)\n        cp2 = 0;\n      else {\n        cp3 = cp2 + str_chr(cp2,' ');\n        *cp3 = '\\0';\n      }\n    } else\n      cp1 = 0;\n\n    if (!cfname && !cp2) {\t/* the single arg is user if we serve a */\n      cp2 = cp1;\t\t/* list. It's list if we serve \"domo@\" */\n      cp1 = 0;\n    }\n    if (cp2) {\n      userlocal = cp2;\n      cp2 += str_chr(cp2,'@');\n      if (*cp2) {\n        *cp2++ = '\\0';\n        userhost = cp2;\n      }\n    }\n    if (cp1) {\n      listlocal = cp1;\n      cp1 += str_chr(cp1,'@');\n      if (*cp1) {\n        *cp1++ = '\\0';\n        listhost = cp1;\n      }\n    }\n  }\n  checkarg(command);\t\t\t/* better safe than sorry */\n  checkarg(userlocal); checkarg(userhost);\n  checkarg(listlocal); checkarg(listhost);\n}", "path": "ezmlm-request.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Public domain, from daemontools-0.76. */\n", "func_signal": "int main()", "code": "{\n#ifdef NeXT\n  printf(\"nextstep\\n\"); exit(0);\n#endif\n  printf(\"unknown\\n\"); exit(0);\n}", "path": "trycpp.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/* Creates an entry for message num and the list listno and code \"done\".\n * Returns NULL on success, and the error string on error. */\n", "func_signal": "static const char *_logmsg(struct subdbinfo *info,\n\t\t\t   unsigned long num,\n\t\t\t   unsigned long listno,\n\t\t\t   unsigned long subs,\n\t\t\t   int done)", "code": "{\n  PGresult *result;\n  PGresult *result2;\n\n  if (!stralloc_copys(&logline,\"INSERT INTO \")) die_nomem();\n  if (!stralloc_cats(&logline,info->base_table)) die_nomem();\n  if (!stralloc_cats(&logline,\"_mlog (msgnum,listno,subs,done) VALUES (\"))\n\tdie_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,num))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,listno)))\n\tdie_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,subs))) die_nomem();\n  if (!stralloc_cats(&logline,\",\")) die_nomem();\n  if (done < 0) {\n    done = - done;\n    if (!stralloc_append(&logline,\"-\")) die_nomem();\n  }\n  if (!stralloc_catb(&logline,strnum,fmt_uint(strnum,done))) die_nomem();\n  if (!stralloc_append(&logline,\")\")) die_nomem();\n\n  if (!stralloc_0(&logline)) die_nomem();\n  result = PQexec((PGconn*)info->conn,logline.s);\n  if(result==NULL)\n    return (PQerrorMessage((PGconn*)info->conn));\n  if(PQresultStatus(result) != PGRES_COMMAND_OK) { /* Check if duplicate */\n    if (!stralloc_copys(&logline,\"SELECT msgnum FROM \")) die_nomem();\n    if (!stralloc_cats(&logline,info->base_table)) die_nomem();\n    if (!stralloc_cats(&logline,\"_mlog WHERE msgnum = \")) die_nomem();\n    if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,num)))\n      die_nomem();\n    if (!stralloc_cats(&logline,\" AND listno = \")) die_nomem();\n    if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,listno)))\n      die_nomem();\n    if (!stralloc_cats(&logline,\" AND done = \")) die_nomem();\n    if (!stralloc_catb(&logline,strnum,fmt_ulong(strnum,done)))\n      die_nomem();\n    /* Query */\n    if (!stralloc_0(&logline)) die_nomem();\n    result2 = PQexec((PGconn*)info->conn,logline.s);\n    if (result2 == NULL)\n      return (PQerrorMessage((PGconn*)info->conn));\n    if (PQresultStatus(result2) != PGRES_TUPLES_OK)\n      return (char *) (PQresultErrorMessage(result2));\n    /* No duplicate, return ERROR from first query */\n    if (PQntuples(result2)<1)\n      return (char *) (PQresultErrorMessage(result));\n    PQclear(result2);\n  }\n  PQclear(result);\n  return 0;\n}", "path": "sub-pgsql.c", "repo_name": "abh/ezmlm-idx", "stars": 6, "license": "gpl-2.0", "language": "c", "size": 3140}
{"docstring": "/*\n * Clone, insert and link a vertex into a polygon based on an existing vertex in another polygon\n */\n", "func_signal": "void PC_insertLinkClonedVertex(struct PC_vertex_ll * toclone, struct PC_vertex_ll * before, struct PC_vertex_ll * after)", "code": "{\n\tassert(toclone);\n\tassert(before);\n\tassert(after);\n\tassert(!toclone->neighbor);\n\tassert(before != after);\n\tassert(toclone != before);\n\tassert(toclone != after);\n\n\tstruct PC_vertex_ll * i1 = PC_alloc_vertex();\n\n\ti1->alpha = PC_calcAlpha(VERTEX_POINT(toclone), VERTEX_POINT(before), VERTEX_POINT(after));\n\n\n\ti1->intersect = true;\n\ti1->c.x = toclone->c.x;\n\ti1->c.y = toclone->c.y;\n\n\t/* NOTE: we do NOT mark the original point as an intersection yet!\n     * [The original point could be a corner, and therefore must be considered when doing sorted inserts]\n     */\n\tPC_linkNeighbours(i1, toclone);\n\tPC_sortedInsert(before, after, i1);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Calculate intersection flags on the first polygon. Slower than the pass done on the second.\n * TODO: pass full first + last polygon pointers\n */\n", "func_signal": "void PC_phase_two_firstpoly(struct PC_vertex_ll * p, struct PC_vertex_ll * other, enum PC_op_t op)", "code": "{\n\tassert(p); assert(other);\n\t\n\tenum edge_status_t gamma_p, gamma_n;\n\n\tstruct PC_vertex_ll * Cip, * Ci, * Cin;\n\tFOR_VERTEX_I_CENTRI(p, Cip, Ci, Cin)\n    \n        /* Calculate previous and next edge statuses */\n\t\tgamma_p = PC_edgeStatus(Cip, Ci, other);\n\t\tgamma_n = PC_edgeStatus(Ci, Cin, other);\n    \n        /* Using edge statuses, calculate vertex flag */\n\t\tCi->flag = PC_calcVertexFlag(gamma_p, gamma_n);\n    \n        /* find the prev + next verticies on the other polygon */\n\t\tstruct PC_vertex_ll * n_prev = Ci->neighbor->prev, * n_i = Ci->neighbor, * n_next =  Ci->neighbor->next;\n\t\tif (!n_prev) n_prev = __find_last(other);\n\t\tif (!n_next) n_next = other;\n\t\n        /* Calculate cross_change based on intersection ordering.\n         * Cross change indicates that we need to change direction when crossing the neighbour link\n         * to avoid creating a self intersection point.\n         */\n        if (Ci->flag == FLG_EN_EX || Ci->flag == FLG_EX_EN)\n            Ci->cross_change = Ci->neighbor->cross_change = !PC_intersection_same_way(Cip, Cin, n_prev, n_next, Ci);\n        else \n            Ci->cross_change = false;\n    \n#ifdef PHASE2_VERBOSE\n\t\tprintf(\"(%4.2f %4.2f)->(%4.2f %4.2f)->(%4.2f %4.2f): %d %d %d\\n\", \n\t\t\t   Cip->c.x, Cip->c.y,\n\t\t\t   Ci->c.x, Ci->c.y, \n\t\t\t   Cin->c.x, Cin->c.y,\n\t\t\t   gamma_p, gamma_n, Ci->flag);\n#endif\n\tEND_FOR_VERTEX_I_CENTRI(p, Cip, Ci, Cin);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Create an Intersection vertex between points A and B, with alpha in (0..1) mapping to (A..B)\n */\n", "func_signal": "struct PC_vertex_ll * PC_createIVertex(struct PC_point * A, struct PC_point * B, double alpha)", "code": "{\n\tassert(A != NULL);\n\tassert(B != NULL);\n\tassert(alpha > 0 && alpha < 1);\n\n\tdouble x = A->x * (1 - alpha) + B->x * alpha;\n\tdouble y = A->y * (1 - alpha) + B->y * alpha;\n\tstruct PC_vertex_ll * v = PC_alloc_vertex();\n\tv->alpha = alpha;\n\tv->intersect = true;\n\tv->c.x = x;\n\tv->c.y = y;\n\treturn v;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/*\n * Calculate the normalized position of point on line start->finish, in range [0..1]\n */\n", "func_signal": "double PC_calcAlpha(struct PC_point * point, struct PC_point * start, struct PC_point * finish)", "code": "{\n\tassert(point);\n\tassert(start);\n\tassert(finish);\n\n\tdouble dx = finish->x - start->x;\n\tdouble dy = finish->y - start->y;\n\tassert(!(_FC(dx, 0) && _FC(dy, 0)));\n\n\tdouble a = 0;\n\tif (dx != 0)\n\t{\n\t\ta = (point->x - start->x) / dx;\n\t} else {\n\t\ta = (point->y - start->y) / dy;\n\t}\n\tassert(a > 0);\n\tassert(a < 1);\n\tassert(!_FC(a, 0));\n\tassert(!_FC(a, 1));\n\n\treturn a;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * returns true if t is within the closed angle (a,b), with the angle being clipped to less than 2pi\n */\n", "func_signal": "bool PC_angle_between(double a, double b, double t)", "code": "{\n    if (b < a)\n        b += M_PI * 2;\n    \n    if (t < a)\n        t += M_PI * 2;\n    \n    return !(t > b);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Calculate the outcode for a point and a set of bounds forming a rectangle.\n */\n", "func_signal": "int PC_outcode(struct PC_point * p, double L, double R, double B, double T)", "code": "{\n\tassert(p != NULL);\n\tassert(L <= R); assert(B <= T);\n\n\tint outcode = 0;\n\tif (p->x < L)\n\t\toutcode |= OC_L;\n\tif (p->x > R)\n\t\toutcode |= OC_R;\n\tif (p->y < B)\n\t\toutcode |= OC_B;\n\tif (p->y > T)\n\t\toutcode |= OC_T;\n    \n\treturn outcode;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Unlink a vertex from the linked-list of verticies. Does not dispose of memory.\n */\n", "func_signal": "void PC_unlink(struct PC_vertex_ll * v)", "code": "{\n\tassert(v);\n\t\n\tif (v->prev)\n\t\tv->prev->next = v->next;\n\tif (v->next)\n\t\tv->next->prev = v->prev;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Insert a Vertex into the linked-list of verticies\n * ip is the vertex to insert after, ti is the vertex to insert\n */\n", "func_signal": "void PC_insertAfter(struct PC_vertex_ll * ip, struct PC_vertex_ll * ti)", "code": "{\n\tassert(ip != NULL);\n\tassert(ti != NULL);\n\tassert(ti->next == NULL);\n\tassert(ti->prev == NULL);\n\n\n\tti->prev = ip;\n\tti->next = ip->next;\n\tif (ip->next)\n\t\tip->next->prev = ti;\n\n\tip->next = ti;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Full Phase 2 of the polygon clipping.\n *\n * In this stage, vertex flags + couples are calculated for all intersection points on both verticies\n * and uninteresting verticies are marked as nonintersecting.\n *\n * an operation is specified since certain operations [subtraction for example] involve inverting the \"inside\"\n * check of the polygon to be subtracted.\n */\n", "func_signal": "void PC_phase_two(struct PC_vertex_ll * p1, struct PC_vertex_ll * p2, enum PC_op_t op)", "code": "{\n\tassert(p1); assert(p2);\n\t\n\tPC_phase_two_firstpoly(p2, p1, op);\n\tPC_phase_two_secondpoly(p1, p2, op);\n\tPC_phase_two_clearNoFlags(p2);\n\tPC_phase_two_buildcouples(p2);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Link sequential En, En or Ex, Ex verticies into couples\n */\n", "func_signal": "void PC_phase_two_buildcouples(struct PC_vertex_ll * p1)", "code": "{\n\tassert(p1);\n\t\n\tstruct PC_vertex_ll * a, * b;\n\t\n\tFOR_VERTEX_PAIR(p1, a, b);\n\tif (a->flag == b->flag && \n\t\t(a->flag == FLG_EN || a->flag == FLG_EX))\n\t{\n\t\tassert(a->neighbor->flag == b->neighbor->flag && (a->next == b || b->next == a));\n\t\t\n\t\ta->couple = b;\n\t\tb->couple = a;\n\t\ta->neighbor->couple = b->neighbor;\n\t\tb->neighbor->couple = a->neighbor;\n\t}\n\t\n\tEND_FOR_VERTEX_PAIR(p1, a, b);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Find the next non-intersecting vertex [including the passed element]\n */\n", "func_signal": "static struct PC_vertex_ll * __find_non_intersect(struct PC_vertex_ll * v)", "code": "{\n\twhile (v && v->intersect)\n\t\tv = v->next;\n\treturn v;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Find the next intersecting vertex [including the passed element]\n * Will not follow all the way around the polygon if it has been closed, as is done in stage 3.\n */\n", "func_signal": "static struct PC_vertex_ll * __find_intersect(struct PC_vertex_ll * vo)", "code": "{\n\tstruct PC_vertex_ll * v = vo;\n\twhile (v && !v->intersect)\n\t{\n\t\tv = v->next;\n\t\t\n\t\tif (v == vo)\n\t\t\treturn NULL;\n\t}\n\treturn v;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/* Polygon accessor functions */\n", "func_signal": "struct PC_vertex_ll * PC_polyPoint(struct PC_vertex_ll * v, double x, double y)", "code": "{\n\tstruct PC_vertex_ll * nv = PC_alloc_vertex();\n\tnv->c.x = x;\n\tnv->c.y = y;\n\n\tif (v)\n\t\tPC_insertAfter(v, nv);\n\t\n\treturn nv;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Check if (a,b) maps to (n_a,n_b) or (n_b, n_a) on the other polygon\n */\n", "func_signal": "bool PC_is_on(struct PC_vertex_ll * a, struct PC_vertex_ll * b)", "code": "{\n\tif (!a->intersect || !b->intersect)\n\t\treturn false;\n\n\tassert(a->neighbor);\n\tassert(b->neighbor);\n\n\tstruct PC_vertex_ll * n_a = a->neighbor;\n\tstruct PC_vertex_ll * n_b = b->neighbor;\n\n\t// wraparound case\n\tif (n_a->next == NULL && n_b->prev == NULL ||\n\t\tn_a->prev == NULL && n_b->next == NULL)\n\t\treturn true;\n\t\n\t// standard case\n\tif (n_a->next == n_b || n_b->next == n_a)\n\t\treturn true;\n\n\treturn false;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Find the midpoint of a line given by (a,b)\n */\n", "func_signal": "struct PC_point PC_midPoint(struct PC_point * a, struct PC_point * b)", "code": "{\n\tassert(a);\n\tassert(b);\n\tstruct PC_point mid;\n\tmid.x = (a->x + b->x) / 2.0;\n\tmid.y = (a->y + b->y) / 2.0;\n\treturn mid;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Delete a flag [or flags] from a vertex, and its couple.\n */\n", "func_signal": "void PC_delete_flag(struct PC_vertex_ll * v, enum flag_type_e flag)", "code": "{\n\tif (flag == FLG_NONE)\n\t\treturn;\n\t\n\tassert(v);\n\tassert(v->intersect);\n\tassert(v->flag != FLG_NONE);\n\tassert(v->neighbor);\n\tassert(!v->couple || v->couple->flag == v->flag);\n\t\n\tenum flag_type_e nf = FLG_NONE;\n\t\n\tif (v->flag == flag)\n\t{\n\t\tv->flag = FLG_NONE;\n\t\tv->intersect = false;\n\t\t\n\t\tif (v->couple)\n\t\t{\n\t\t\tv->couple->flag = FLG_NONE;\n\t\t\tv->couple->intersect = false;\n\t\t}\n\t}\n\telse if (v->flag == FLG_EN_EX && flag == FLG_EN)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_EX;\n\t\t\n\t} else if (v->flag == FLG_EX_EN && flag == FLG_EX)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_EN;\n\t}\n\telse if (v->flag == FLG_EN_EX && flag == FLG_EX)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_EN;\n\t\t\n\t} else if (v->flag == FLG_EX_EN && flag == FLG_EN)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_EX;\n\t} else if (v->flag == FLG_EX_EN && flag == FLG_EX_EN)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_NONE;\n\t} else if (v->flag == FLG_EN_EX && flag == FLG_EN_EX)\n\t{\n\t\tassert (!v->couple);\n\t\tv->flag = FLG_NONE;\n\t} else {\n\t\tassert(false);\n\t}\n\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Prepare for phase 3 by closing the polygon rings\n */\n", "func_signal": "void PC_phase_3_prep(struct PC_vertex_ll * p1, struct PC_vertex_ll * p2)", "code": "{\n\tassert(p1); assert(p2);\n\tassert(!p1->prev); assert(!p2->prev);\n\t\n\t// close the loop\n\tstruct PC_vertex_ll * l = __find_last(p1);\n\tp1->prev = l;\n\tl->next = p1;\n\t\n\tl = __find_last(p2);\n\tl->next = p2;\n\tp2->prev = l;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Allocate an empty vertex\n */\n", "func_signal": "struct PC_vertex_ll * PC_alloc_vertex()", "code": "{\n\tstruct PC_vertex_ll * v = (struct PC_vertex_ll *)malloc(sizeof(struct PC_vertex_ll));\n\t\n\tif (!v) return NULL;\n\t\n\tv->c.x = v->c.y = INFINITY;\n\tv->next = v->prev = v->neighbor = NULL;\n\tv->intersect = false;\n\tv->flag = FLG_NONE;\n\tv->cross_change = false;\n\tv->couple = NULL;\n\tv->alpha = 0;\n\treturn v;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Calculate the window edge coordinates\n */\n", "func_signal": "double PC_calc_WEC(struct PC_point * A, struct PC_point * B, struct PC_point * C, struct PC_point * D)", "code": "{\n\tassert(A != NULL); assert(B != NULL); assert(C != NULL); assert(D != NULL);\n    \n\t// (A - B) dot perpendicular(C - D)\n\treturn (double)(A->y - B->y) * (C->x - D->x) - (A->x - B->x) * (C->y - D->y);\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/**\n * Find the vertex that meets the criteria for a starting vertex in phase 3\n */\n", "func_signal": "static struct PC_vertex_ll * __find_meets_p3_criteria(struct PC_vertex_ll * vo)", "code": "{\n\tstruct PC_vertex_ll * v = vo;\n\twhile (v)\n\t{\n\t\tif (v->flag != FLG_NONE)\n\t\t{\n\t\t\tif (v->couple)\n\t\t\t{\n\t\t\t\t// If we're the second of a couple, and we're an entrance\n\t\t\t\tif (v->flag == FLG_EN && v->couple == v->prev)\n\t\t\t\t\treturn v;\n\t\t\t\tif (v->flag == FLG_EX && v->couple == v->next)\n\t\t\t\t\treturn v;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\tv = v->next;\n\t\t\n\t\tif (v == vo)\n\t\t\treturn NULL;\n\t}\n\treturn v;\n}", "path": "src\\polymath.c", "repo_name": "davidcarne/polyclip", "stars": 6, "license": "None", "language": "c", "size": 156}
{"docstring": "/* Check properties of malloced chunks at the point they are malloced */\n", "func_signal": "static void do_check_malloced_chunk(mstate m, void* mem, size_t s)", "code": "{\n  if (mem != 0) {\n    mchunkptr p = mem2chunk(mem);\n    size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);\n    do_check_inuse_chunk(m, p);\n    assert((sz & CHUNK_ALIGN_MASK) == 0);\n    assert(sz >= MIN_CHUNK_SIZE);\n    assert(sz >= s);\n    /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */\n    assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));\n  }\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Get next free usb device address.\n */\n", "func_signal": "u8 usb_next_address()", "code": "{\n\tu8 addr = core.nextaddress;\n\tcore.nextaddress++;\n\treturn addr;\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Return segment holding given address */\n", "func_signal": "static msegmentptr segment_holding(mstate m, char* addr)", "code": "{\n  msegmentptr sp = &m->seg;\n  for (;;) {\n    if (addr >= sp->base && addr < sp->base + sp->size)\n      return sp;\n    if ((sp = sp->next) == 0)\n      return 0;\n  }\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* ------------------------ comalloc/coalloc support --------------------- */\n", "func_signal": "static void** ialloc(mstate m,\n                     size_t n_elements,\n                     size_t* sizes,\n                     int opts,\n                     void* chunks[])", "code": "{\n  /*\n    This provides common support for independent_X routines, handling\n    all of the combinations that can result.\n\n    The opts arg has:\n    bit 0 set if all elements are same size (using sizes[0])\n    bit 1 set if elements should be zeroed\n  */\n\n  size_t    element_size;   /* chunksize of each element, if all same */\n  size_t    contents_size;  /* total size of elements */\n  size_t    array_size;     /* request size of pointer array */\n  void*     mem;            /* malloced aggregate space */\n  mchunkptr p;              /* corresponding chunk */\n  size_t    remainder_size; /* remaining bytes while splitting */\n  void**    marray;         /* either \"chunks\" or malloced ptr array */\n  mchunkptr array_chunk;    /* chunk for malloced ptr array */\n  flag_t    was_enabled;    /* to disable mmap */\n  size_t    size;\n  size_t    i;\n\n  /* compute array length, if needed */\n  if (chunks != 0) {\n    if (n_elements == 0)\n      return chunks; /* nothing to do */\n    marray = chunks;\n    array_size = 0;\n  }\n  else {\n    /* if empty req, must still return chunk representing empty array */\n    if (n_elements == 0)\n      return (void**)internal_malloc(m, 0);\n    marray = 0;\n    array_size = request2size(n_elements * (sizeof(void*)));\n  }\n\n  /* compute total element size */\n  if (opts & 0x1) { /* all-same-size */\n    element_size = request2size(*sizes);\n    contents_size = n_elements * element_size;\n  }\n  else { /* add up all the sizes */\n    element_size = 0;\n    contents_size = 0;\n    for (i = 0; i != n_elements; ++i)\n      contents_size += request2size(sizes[i]);\n  }\n\n  size = contents_size + array_size;\n\n  /*\n     Allocate the aggregate chunk.  First disable direct-mmapping so\n     malloc won't use it, since we would not be able to later\n     free/realloc space internal to a segregated mmap region.\n  */\n  was_enabled = use_mmap(m);\n  disable_mmap(m);\n  mem = internal_malloc(m, size - CHUNK_OVERHEAD);\n  if (was_enabled)\n    enable_mmap(m);\n  if (mem == 0)\n    return 0;\n\n  if (PREACTION(m)) return 0;\n  p = mem2chunk(mem);\n  remainder_size = chunksize(p);\n\n  assert(!is_mmapped(p));\n\n  if (opts & 0x2) {       /* optionally clear the elements */\n    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);\n  }\n\n  /* If not provided, allocate the pointer array as final part of chunk */\n  if (marray == 0) {\n    size_t  array_chunk_size;\n    array_chunk = chunk_plus_offset(p, contents_size);\n    array_chunk_size = remainder_size - contents_size;\n    marray = (void**) (chunk2mem(array_chunk));\n    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);\n    remainder_size = contents_size;\n  }\n\n  /* split out elements */\n  for (i = 0; ; ++i) {\n    marray[i] = chunk2mem(p);\n    if (i != n_elements-1) {\n      if (element_size != 0)\n        size = element_size;\n      else\n        size = request2size(sizes[i]);\n      remainder_size -= size;\n      set_size_and_pinuse_of_inuse_chunk(m, p, size);\n      p = chunk_plus_offset(p, size);\n    }\n    else { /* the final element absorbs any overallocation slop */\n      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);\n      break;\n    }\n  }\n\n#if DEBUG\n  if (marray != chunks) {\n    /* final element must have exactly exhausted chunk */\n    if (element_size != 0) {\n      assert(remainder_size == element_size);\n    }\n    else {\n      assert(remainder_size == request2size(sizes[i]));\n    }\n    check_inuse_chunk(m, mem2chunk(marray));\n  }\n  for (i = 0; i != n_elements; ++i)\n    check_inuse_chunk(m, mem2chunk(marray[i]));\n\n#endif /* DEBUG */\n\n  POSTACTION(m);\n  return marray;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* default corruption action */\n", "func_signal": "static void reset_on_error(mstate m)", "code": "{\n  int i;\n  ++malloc_corruption_error_count;\n  /* Reinitialize fields to forget about all memory */\n  m->smallbins = m->treebins = 0;\n  m->dvsize = m->topsize = 0;\n  m->seg.base = 0;\n  m->seg.size = 0;\n  m->seg.next = 0;\n  m->top = m->dv = 0;\n  for (i = 0; i < NTREEBINS; ++i)\n    *treebin_at(m, i) = 0;\n  init_bins(m);\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Initialize mparams */\n", "func_signal": "static int init_mparams(void)", "code": "{\n  if (mparams.page_size == 0) {\n    size_t s;\n\n    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;\n    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;\n#if MORECORE_CONTIGUOUS\n    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;\n#else  /* MORECORE_CONTIGUOUS */\n    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;\n#endif /* MORECORE_CONTIGUOUS */\n\n#if (FOOTERS && !INSECURE)\n    {\n#if USE_DEV_RANDOM\n      int fd;\n      unsigned char buf[sizeof(size_t)];\n      /* Try to use /dev/urandom, else fall back on using time */\n      if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0 &&\n          read(fd, buf, sizeof(buf)) == sizeof(buf)) {\n        s = *((size_t *) buf);\n        close(fd);\n      }\n      else\n#endif /* USE_DEV_RANDOM */\n        s = (size_t)(time(0) ^ (size_t)0x55555555U);\n\n      s |= (size_t)8U;    /* ensure nonzero */\n      s &= ~(size_t)7U;   /* improve chances of fault for bad values */\n\n    }\n#else /* (FOOTERS && !INSECURE) */\n    s = (size_t)0x58585858U;\n#endif /* (FOOTERS && !INSECURE) */\n    ACQUIRE_MAGIC_INIT_LOCK();\n    if (mparams.magic == 0) {\n      mparams.magic = s;\n      /* Set up lock for main malloc area */\n      INITIAL_LOCK(&gm->mutex);\n      gm->mflags = mparams.default_mflags;\n    }\n    RELEASE_MAGIC_INIT_LOCK();\n\n#ifndef WIN32\n    mparams.page_size = malloc_getpagesize;\n    mparams.granularity = ((DEFAULT_GRANULARITY != 0)?\n                           DEFAULT_GRANULARITY : mparams.page_size);\n#else /* WIN32 */\n    {\n      SYSTEM_INFO system_info;\n      GetSystemInfo(&system_info);\n      mparams.page_size = system_info.dwPageSize;\n      mparams.granularity = system_info.dwAllocationGranularity;\n    }\n#endif /* WIN32 */\n\n    /* Sanity-check configuration:\n       size_t must be unsigned and as wide as pointer type.\n       ints must be at least 4 bytes.\n       alignment must be at least 8.\n       Alignment, min chunk size, and page size must all be powers of 2.\n    */\n    if ((sizeof(size_t) != sizeof(char*)) ||\n        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||\n        (sizeof(int) < 4)  ||\n        (MALLOC_ALIGNMENT < (size_t)8U) ||\n        ((MALLOC_ALIGNMENT    & (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||\n        ((MCHUNK_SIZE         & (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||\n        ((mparams.granularity & (mparams.granularity-SIZE_T_ONE)) != 0) ||\n        ((mparams.page_size   & (mparams.page_size-SIZE_T_ONE))   != 0))\n      ABORT;\n  }\n  return 0;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Check properties of any chunk, whether free, inuse, mmapped etc  */\n", "func_signal": "static void do_check_any_chunk(mstate m, mchunkptr p)", "code": "{\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Takes usb_irp and split it into\n * several usb packeges (SETUP,IN,OUT)\n * In the usbstack they are transported with the\n * usb_transfer_descriptor data structure.\n */\n", "func_signal": "u16 usb_submit_irp(struct usb_irp *irp)", "code": "{\n\tstruct usb_transfer_descriptor *td;\n\tu8 runloop = 1;\n\tu16 restlength = irp->len;\n\tu8 *td_buf_ptr = irp->buffer;\n\tu8 mybuf[64];\n\n\tu8 togl = irp->dev->epTogl[(irp->endpoint & 0x7F)];\n\n\tswitch (irp->type) {\n\tcase USB_CTRL:\n\t\t/* alle requests mit dem gleichen algorithmus zerteilen\n\t\t * das einzige ist der spezielle get_Device_descriptor request\n\t\t * bei dem eine laenge von 64 angegeben ist.\n\t\t * wenn man an adresse 0 einen get_device_desciptor schickt\n\t\t * dann reichen die ersten 8 byte.\n\t\t */\n\n\t\t/***************** Setup Stage ***********************/\n\t\ttd = usb_create_transfer_descriptor(irp);\n\t\ttd->pid = USB_PID_SETUP;\n\t\ttd->buffer = irp->buffer;\n\n\t\t/* control message are always 8 bytes */\n\t\ttd->actlen = 8;\n\n\t\ttogl = 0;\n\t\t/* start with data0 */\n\t\ttd->togl = togl;\n\t\ttogl = togl ? 0 : 1;\n\n\t\t/**** send token ****/\n\t\thcdi_enqueue(td, irp->dev->ohci);\n\n\t\t/***************** Data Stage ***********************/\n\t\t/**\n\t\t * You can see at bit 7 of bmRequestType if this stage is used,\n\t\t * default requests are always 8 byte greate, from\n\t\t * host to device. Stage 3 is only neccessary if the request\n\t\t * expected datas from the device.\n\t\t * bit7 - 1 = from device to host -> yes we need data stage\n\t\t * bit7 - 0 = from host to device -> no send zero packet\n\t\t *\n\t\t * nach einem setup token kann nur ein IN token in stage 3 folgen\n\t\t * nie aber ein OUT. Ein Zero OUT wird nur als Bestaetigung benoetigt.\n\t\t *\n\t\t *\n\t\t * bit7 = 1\n\t\t *\tDevice to Host\n\t\t *\t- es kommen noch Daten mit PID_IN an\n\t\t *\t- host beendet mit PID_OUT DATA1 Zero\n\t\t * bit7 - 0\n\t\t *\tHost zu Device (wie set address)\n\t\t *\t- device sendet ein PID_IN DATA1 Zero Packet als bestaetigung\n\t\t */\n\t\tmemcpy(mybuf, irp->buffer, td->actlen);\n\t\tusb_device_request *setup = (usb_device_request *) mybuf;\n\t\tu8 bmRequestType = setup->bmRequestType;\n\t\tfree(td);\n\n\t\t/* check bit 7 of bmRequestType */\n\t\tif (bmRequestType & 0x80) { \n\t\t\t/* schleife die die tds generiert */\n\t\t\twhile (runloop && (restlength > 0)) {\n\t\t\t\ttd = usb_create_transfer_descriptor(irp);\n\t\t\t\ttd->actlen = irp->epsize;\n\t\t\t\t/* stop loop if all bytes are send */\n\t\t\t\tif (restlength < irp->epsize) {\n\t\t\t\t\trunloop = 0;\n\t\t\t\t\ttd->actlen = restlength;\n\t\t\t\t}\n\n\t\t\t\ttd->buffer = td_buf_ptr;\n\t\t\t\t/* move pointer for next packet */\n\t\t\t\ttd_buf_ptr += irp->epsize;\n\n\t\t\t\ttd->pid = USB_PID_IN;\n\t\t\t\ttd->togl = togl;\n\t\t\t\ttogl = togl ? 0 : 1;\n\n\t\t\t\t/* wenn device descriptor von adresse 0 angefragt wird werden nur\n\t\t\t\t * die ersten 8 byte abgefragt\n\t\t\t\t */\n\t\t\t\tif (setup->bRequest == GET_DESCRIPTOR && (setup->wValue & 0xff) == 1\n\t\t\t\t\t\t&& td->devaddress == 0) {\n\t\t\t\t\t/* stop loop */\n\t\t\t\t\trunloop = 0;\n\t\t\t\t}\n\n\t\t\t\t/**** send token ****/\n\t\t\t\thcdi_enqueue(td, irp->dev->ohci);\n\n\t\t\t\t/* pruefe ob noch weitere Pakete vom Device abgeholt werden muessen */\n\t\t\t\trestlength = restlength - irp->epsize;\n\t\t\t\tfree(td);\n\t\t\t}\n\t\t}\n\n\n\t\t/***************** Status Stage ***********************/\n\t\t/* Zero packet for end */\n\t\ttd = usb_create_transfer_descriptor(irp);\n\t\ttd->togl = 1;\t\t\t\t\t\t\t\t/* zero data packet = always DATA1 packet */\n\t\ttd->actlen = 0;\n\t\ttd->buffer = NULL;\n\n\t\t/**\n\t\t * bit7 = 1, host beendet mit PID_OUT DATA1 Zero\n\t\t * bit7 = 0, device sendet ein PID_IN DATA1 Zero Packet als bestaetigung\n\t\t */\n\t\t/* check bit 7 of bmRequestType */\n\t\tif (bmRequestType & 0x80) {\n\t\t\ttd->pid = USB_PID_OUT;\n\t\t} else {\n\t\t\ttd->pid = USB_PID_IN;\n\t\t}\n\t\t/**** send token ****/\n\t\thcdi_enqueue(td, irp->dev->ohci);\n\t\tfree(td);\n\t\tbreak;\n\n\tcase USB_BULK:\n\t\t//u8 runloop=1;\n\t\t//u16 restlength = irp->len;\n\t\t//char * td_buf_ptr=irp->buffer;\n\n\t\t/* schleife die die tds generiert */\n\t\twhile (runloop) {\n\t\t\ttd = usb_create_transfer_descriptor(irp);\n\t\t\ttd->endpoint = td->endpoint & 0x7F;\t\t\t\t/* clear direction bit */\n\n\t\t\t/* max packet size for given endpoint */\n\t\t\ttd->actlen = irp->epsize;\n\n\t\t\t/* Generate In Packet  */\n\t\t\tif (irp->endpoint & 0x80)\n\t\t\t\ttd->pid = USB_PID_IN;\n\t\t\telse\n\t\t\t\t/* Generate Out Packet */\n\t\t\t\ttd->pid = USB_PID_OUT;\n\n\t\t\t/* stop loop if all bytes are send */\n\t\t\tif (restlength <= irp->epsize) {\n\t\t\t\trunloop = 0;\n\t\t\t\ttd->actlen = restlength;\n\t\t\t}\n\n\t\t\ttd->buffer = td_buf_ptr;\n\t\t\t/* move pointer for next packet */\n\t\t\ttd_buf_ptr = td_buf_ptr + irp->epsize;\n\n\t\t\ttd->togl = togl;\n\t\t\ttogl = togl ? 0 : 1;\n\t\t\t\t/**** send token ****/\n\t\t\thcdi_enqueue(td, irp->dev->ohci);\n\t\t\tfree(td);\n\t\t}\n\t\t/* next togl */\n\t\t//if(td->pid == USB_PID_OUT) {\n\t\t//if(togl==0) togl=1; else togl=0;\n\t\t//}\n\t\tirp->dev->epTogl[(irp->endpoint & 0x7F)] = togl;\n\n\t\tbreak;\n\t\n\tcase USB_INTR:\n\t\t//u8 runloop=1;\n\t\t//u16 restlength = irp->len;\n\t\t//char * td_buf_ptr=irp->buffer;\n\n\t\t/* schleife die die tds generiert */\n\t\twhile (runloop && (restlength > 0)) {\n\t\t\ttd = usb_create_transfer_descriptor(irp);\n\t\t\t/* max packet size for given endpoint */\n\t\t\ttd->actlen = irp->epsize;\n\n\t\t\ttd->pid = USB_PID_IN;\n\t\t\t/* TODO: USB_PID_OUT */\n\n\t\t\t/* stop loop if all bytes are send */\n\t\t\tif (restlength < irp->epsize) {\n\t\t\t\trunloop = 0;\n\t\t\t\ttd->actlen = restlength;\n\t\t\t}\n\n\t\t\ttd->buffer = td_buf_ptr;\n\t\t\t/* move pointer for next packet */\n\t\t\ttd_buf_ptr += irp->epsize;\n\n\t\t\ttd->togl = togl;\n\t\t\ttogl = togl ? 0 : 1;\n\t\t\t\t\n\t\t\t/**** send token ****/\n\t\t\thcdi_enqueue(td, irp->dev->ohci);\n\t\t\trestlength = restlength - irp->epsize;\n\t\t\tfree(td);\n\t\t}\n\t\tbreak;\n\t\tirp->dev->epTogl[(irp->endpoint & 0x7F)] = togl;\n\t}\n\thcdi_fire(irp->dev->ohci);\n\n\treturn 1;\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Initialize USB stack.\n */\n", "func_signal": "void usb_init(u32 reg)", "code": "{\n\tcore.drivers = list_create();\n\tcore.devices = list_create();\n\tcore.nextaddress = 1;\n\thcdi_init(reg);\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Register new driver at usb stack.\n */\n", "func_signal": "u8 usb_register_driver(struct usb_driver *dev)", "code": "{\n\t/* add driver to driver list */\n\tstruct element *tmp = (struct element *) malloc(sizeof(struct element));\n\ttmp->data = (void *) dev;\n\ttmp->next = NULL;\n\tlist_add_tail(core.drivers, tmp);\n\n\t/** \n\t * first check to find a suitable device \n\t * (root hub drivers need this call here)\n\t */\n\tdev->probe();\n\n\treturn 1;\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Find currently detached device and remove\n * data structures\n */\n", "func_signal": "u8 usb_remove_device(struct usb_device *dev)", "code": "{\n\t/* trigger driver for this device */\n\tstruct usb_driver *drv;\n\tstruct element *iterator = core.drivers->head;\n\twhile (iterator != NULL) {\n\t\tdrv = (struct usb_driver *) iterator->data;\n\t\tif(drv->data && !memcmp(drv->data, dev, sizeof(struct usb_device))) {\n\t\t\tdrv->remove();\n\t\t\tbreak;\n\t\t}\n\t\titerator = iterator->next;\n\t}\n\n\t/* remove from device list */\n\tstruct element *tmp = (struct element *) malloc(sizeof(struct element));\n\ttmp->data = (void *) dev;\n\tlist_delete_element(core.devices, tmp);\n\n\tprintf(\"REMOVED\\n\");\n\n\treturn 1;\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* support for mallopt */\n", "func_signal": "static int change_mparam(int param_number, int value)", "code": "{\n  size_t val = (size_t)value;\n  init_mparams();\n  switch(param_number) {\n  case M_TRIM_THRESHOLD:\n    mparams.trim_threshold = val;\n    return 1;\n  case M_GRANULARITY:\n    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {\n      mparams.granularity = val;\n      return 1;\n    }\n    else\n      return 0;\n  case M_MMAP_THRESHOLD:\n    mparams.mmap_threshold = val;\n    return 1;\n  default:\n    return 0;\n  }\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Realloc using mmap */\n", "func_signal": "static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb)", "code": "{\n  size_t oldsize = chunksize(oldp);\n  if (is_small(nb)) /* Can't shrink mmap regions below small size */\n    return 0;\n  /* Keep old chunk if big enough but not too big */\n  if (oldsize >= nb + SIZE_T_SIZE &&\n      (oldsize - nb) <= (mparams.granularity << 1))\n    return oldp;\n  else {\n    size_t offset = oldp->prev_foot & ~IS_MMAPPED_BIT;\n    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;\n    size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +\n                                         CHUNK_ALIGN_MASK);\n    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,\n                                  oldmmsize, newmmsize, 1);\n    if (cp != CMFAIL) {\n      mchunkptr newp = (mchunkptr)(cp + offset);\n      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;\n      newp->head = (psize|CINUSE_BIT);\n      mark_inuse_foot(m, newp, psize);\n      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;\n      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;\n\n      if (cp < m->least_addr)\n        m->least_addr = cp;\n      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)\n        m->max_footprint = m->footprint;\n      check_mmapped_chunk(m, newp);\n      return newp;\n    }\n  }\n  return 0;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Check properties of free chunks */\n", "func_signal": "static void do_check_free_chunk(mstate m, mchunkptr p)", "code": "{\n  size_t sz = p->head & ~(PINUSE_BIT|CINUSE_BIT);\n  mchunkptr next = chunk_plus_offset(p, sz);\n  do_check_any_chunk(m, p);\n  assert(!cinuse(p));\n  assert(!next_pinuse(p));\n  assert (!is_mmapped(p));\n  if (p != m->dv && p != m->top) {\n    if (sz >= MIN_CHUNK_SIZE) {\n      assert((sz & CHUNK_ALIGN_MASK) == 0);\n      assert(is_aligned(chunk2mem(p)));\n      assert(next->prev_foot == sz);\n      assert(pinuse(p));\n      assert (next == m->top || cinuse(next));\n      assert(p->fd->bk == p);\n      assert(p->bk->fd == p);\n    }\n    else  /* markers are always of size SIZE_T_SIZE */\n      assert(sz == SIZE_T_SIZE);\n  }\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* --------------------------- realloc support --------------------------- */\n", "func_signal": "static void* internal_realloc(mstate m, void* oldmem, size_t bytes)", "code": "{\n  if (bytes >= MAX_REQUEST) {\n    MALLOC_FAILURE_ACTION;\n    return 0;\n  }\n  if (!PREACTION(m)) {\n    mchunkptr oldp = mem2chunk(oldmem);\n    size_t oldsize = chunksize(oldp);\n    mchunkptr next = chunk_plus_offset(oldp, oldsize);\n    mchunkptr newp = 0;\n    void* extra = 0;\n\n    /* Try to either shrink or extend into top. Else malloc-copy-free */\n\n    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&\n                ok_next(oldp, next) && ok_pinuse(next))) {\n      size_t nb = request2size(bytes);\n      if (is_mmapped(oldp))\n        newp = mmap_resize(m, oldp, nb);\n      else if (oldsize >= nb) { /* already big enough */\n        size_t rsize = oldsize - nb;\n        newp = oldp;\n        if (rsize >= MIN_CHUNK_SIZE) {\n          mchunkptr remainder = chunk_plus_offset(newp, nb);\n          set_inuse(m, newp, nb);\n          set_inuse(m, remainder, rsize);\n          extra = chunk2mem(remainder);\n        }\n      }\n      else if (next == m->top && oldsize + m->topsize > nb) {\n        /* Expand into top */\n        size_t newsize = oldsize + m->topsize;\n        size_t newtopsize = newsize - nb;\n        mchunkptr newtop = chunk_plus_offset(oldp, nb);\n        set_inuse(m, oldp, nb);\n        newtop->head = newtopsize |PINUSE_BIT;\n        m->top = newtop;\n        m->topsize = newtopsize;\n        newp = oldp;\n      }\n    }\n    else {\n      USAGE_ERROR_ACTION(m, oldmem);\n      POSTACTION(m);\n      return 0;\n    }\n\n    POSTACTION(m);\n\n    if (newp != 0) {\n      if (extra != 0) {\n        internal_free(m, extra);\n      }\n      check_inuse_chunk(m, newp);\n      return chunk2mem(newp);\n    }\n    else {\n      void* newmem = internal_malloc(m, bytes);\n      if (newmem != 0) {\n        size_t oc = oldsize - overhead_for(oldp);\n        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);\n        internal_free(m, oldmem);\n      }\n      return newmem;\n    }\n  }\n  return 0;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/*  Check all the chunks in a treebin.  */\n", "func_signal": "static void do_check_treebin(mstate m, bindex_t i)", "code": "{\n  tbinptr* tb = treebin_at(m, i);\n  tchunkptr t = *tb;\n  int empty = (m->treemap & (1U << i)) == 0;\n  if (t == 0)\n    assert(empty);\n  if (!empty)\n    do_check_tree(m, t);\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* allocate a small request from the best fitting chunk in a treebin */\n", "func_signal": "static void* tmalloc_small(mstate m, size_t nb)", "code": "{\n  tchunkptr t, v;\n  size_t rsize;\n  bindex_t i;\n  binmap_t leastbit = least_bit(m->treemap);\n  compute_bit2idx(leastbit, i);\n\n  v = t = *treebin_at(m, i);\n  rsize = chunksize(t) - nb;\n\n  while ((t = leftmost_child(t)) != 0) {\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n  }\n\n  if (RTCHECK(ok_address(m, v))) {\n    mchunkptr r = chunk_plus_offset(v, nb);\n    assert(chunksize(v) == rsize + nb);\n    if (RTCHECK(ok_next(v, r))) {\n      unlink_large_chunk(m, v);\n      if (rsize < MIN_CHUNK_SIZE)\n        set_inuse_and_pinuse(m, v, (rsize + nb));\n      else {\n        set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n        set_size_and_pinuse_of_free_chunk(r, rsize);\n        replace_dv(m, r, rsize);\n      }\n      return chunk2mem(v);\n    }\n  }\n\n  CORRUPTION_ERROR_ACTION(m);\n  return 0;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void* win32direct_mmap(size_t size)", "code": "{\n  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n                           PAGE_READWRITE);\n  return (ptr != 0)? ptr: MFAIL;\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* Initialize top chunk and its size */\n", "func_signal": "static void init_top(mstate m, mchunkptr p, size_t psize)", "code": "{\n  /* Ensure alignment */\n  size_t offset = align_offset(chunk2mem(p));\n  p = (mchunkptr)((char*)p + offset);\n  psize -= offset;\n\n  m->top = p;\n  m->topsize = psize;\n  p->head = psize | PINUSE_BIT;\n  /* set size of fake trailing chunk holding overhead space only once */\n  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;\n  m->trim_check = mparams.trim_threshold; /* reset on each update */\n}", "path": "malloc.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/**\n * Call this function periodically for \n * control and transfer management.\n */\n", "func_signal": "void usb_periodic()", "code": "{\n\t// call ever registered driver\t\n\tstruct usb_driver *drv;\n\tstruct element *iterator = core.drivers->head;\n\twhile (iterator != NULL) {\n\t\tdrv = (struct usb_driver *) iterator->data;\n\t\tdrv->check();\n\t\titerator = iterator->next;\n\t}\n}", "path": "usb\\core\\core.c", "repo_name": "lewurm/ppcskel", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 416}
{"docstring": "/* handle routing updates from the session engine. */\n", "func_signal": "int\nrde_update_dispatch(struct imsg *imsg)", "code": "{\n\tstruct rde_peer\t\t*peer;\n\tstruct rde_aspath\t*asp = NULL;\n\tu_char\t\t\t*p, *mpp = NULL;\n\tint\t\t\t error = -1, pos = 0;\n\tu_int16_t\t\t afi, len, mplen;\n\tu_int16_t\t\t withdrawn_len;\n\tu_int16_t\t\t attrpath_len;\n\tu_int16_t\t\t nlri_len;\n\tu_int8_t\t\t prefixlen, safi, subtype;\n\tstruct bgpd_addr\t prefix;\n\tstruct mpattr\t\t mpa;\n\n\tpeer = peer_get(imsg->hdr.peerid);\n\tif (peer == NULL)\t/* unknown peer, cannot happen */\n\t\treturn (-1);\n\tif (peer->state != PEER_UP)\n\t\treturn (-1);\t/* peer is not yet up, cannot happen */\n\n\tp = imsg->data;\n\n\tif (imsg->hdr.len < IMSG_HEADER_SIZE + 2) {\n\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);\n\t\treturn (-1);\n\t}\n\n\tmemcpy(&len, p, 2);\n\twithdrawn_len = ntohs(len);\n\tp += 2;\n\tif (imsg->hdr.len < IMSG_HEADER_SIZE + 2 + withdrawn_len + 2) {\n\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);\n\t\treturn (-1);\n\t}\n\n\tp += withdrawn_len;\n\tmemcpy(&len, p, 2);\n\tattrpath_len = len = ntohs(len);\n\tp += 2;\n\tif (imsg->hdr.len <\n\t    IMSG_HEADER_SIZE + 2 + withdrawn_len + 2 + attrpath_len) {\n\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);\n\t\treturn (-1);\n\t}\n\n\tnlri_len =\n\t    imsg->hdr.len - IMSG_HEADER_SIZE - 4 - withdrawn_len - attrpath_len;\n\tbzero(&mpa, sizeof(mpa));\n\n\tif (attrpath_len != 0) { /* 0 = no NLRI information in this message */\n\t\t/* parse path attributes */\n\t\tasp = path_get();\n\t\twhile (len > 0) {\n\t\t\tif ((pos = rde_attr_parse(p, len, peer, asp,\n\t\t\t    &mpa)) < 0)\n\t\t\t\tgoto done;\n\t\t\tp += pos;\n\t\t\tlen -= pos;\n\t\t}\n\n\t\t/* check for missing but necessary attributes */\n\t\tif ((subtype = rde_attr_missing(asp, peer->conf.ebgp,\n\t\t    nlri_len))) {\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_MISSNG_WK_ATTR,\n\t\t\t    &subtype, sizeof(u_int8_t));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/*\n\t\t * if either ATTR_AS4_AGGREGATOR or ATTR_AS4_PATH is present\n\t\t * try to fixup the attributes.\n\t\t * XXX do not fixup if F_ATTR_LOOP is set.\n\t\t */\n\t\tif (asp->flags & F_ATTR_AS4BYTE_NEW &&\n\t\t    !(asp->flags & F_ATTR_LOOP))\n\t\t\trde_as4byte_fixup(peer, asp);\n\n\t\t/* enforce remote AS if requested */\n\t\tif (asp->flags & F_ATTR_ASPATH &&\n\t\t    peer->conf.enforce_as == ENFORCE_AS_ON)\n\t\t\tif (peer->conf.remote_as !=\n\t\t\t    aspath_neighbor(asp->aspath)) {\n\t\t\t\tlog_peer_warnx(&peer->conf, \"bad path, \"\n\t\t\t\t    \"enforce remote-as enabled\");\n\t\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_ASPATH,\n\t\t\t\t    NULL, 0);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\trde_reflector(peer, asp);\n\t}\n\n\tp = imsg->data;\n\tlen = withdrawn_len;\n\tp += 2;\n\t/* withdraw prefix */\n\twhile (len > 0) {\n\t\tif ((pos = rde_update_get_prefix(p, len, &prefix,\n\t\t    &prefixlen)) == -1) {\n\t\t\t/*\n\t\t\t * the RFC does not mention what we should do in\n\t\t\t * this case. Let's do the same as in the NLRI case.\n\t\t\t */\n\t\t\tlog_peer_warnx(&peer->conf, \"bad withdraw prefix\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\t\tif (prefixlen > 32) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad withdraw prefix\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\tp += pos;\n\t\tlen -= pos;\n\n\t\tif (peer->capa_received.mp_v4 == SAFI_NONE &&\n\t\t    peer->capa_received.mp_v6 != SAFI_NONE) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad AFI, IPv4 disabled\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\trde_update_withdraw(peer, &prefix, prefixlen);\n\t}\n\n\tif (attrpath_len == 0) {\n\t\t/* 0 = no NLRI information in this message */\n\t\tif (nlri_len != 0) {\n\t\t\t/* crap at end of update which should not be there */\n\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t    ERR_UPD_ATTRLIST, NULL, 0);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/* withdraw MP_UNREACH_NLRI if available */\n\tif (mpa.unreach_len != 0) {\n\t\tmpp = mpa.unreach;\n\t\tmplen = mpa.unreach_len;\n\t\tmemcpy(&afi, mpp, 2);\n\t\tmpp += 2;\n\t\tmplen -= 2;\n\t\tafi = ntohs(afi);\n\t\tsafi = *mpp++;\n\t\tmplen--;\n\t\tswitch (afi) {\n\t\tcase AFI_IPv6:\n\t\t\tif (peer->capa_received.mp_v6 == SAFI_NONE) {\n\t\t\t\tlog_peer_warnx(&peer->conf, \"bad AFI, \"\n\t\t\t\t    \"IPv6 disabled\");\n\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t    ERR_UPD_OPTATTR, NULL, 0);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\twhile (mplen > 0) {\n\t\t\t\tif ((pos = rde_update_get_prefix6(mpp, mplen,\n\t\t\t\t    &prefix, &prefixlen)) == -1) {\n\t\t\t\t\tlog_peer_warnx(&peer->conf,\n\t\t\t\t\t    \"bad IPv6 withdraw prefix\");\n\t\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t\t    ERR_UPD_OPTATTR,\n\t\t\t\t\t    mpa.unreach, mpa.unreach_len);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (prefixlen > 128) {\n\t\t\t\t\tlog_peer_warnx(&peer->conf,\n\t\t\t\t\t    \"bad IPv6 withdraw prefix\");\n\t\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t\t    ERR_UPD_OPTATTR,\n\t\t\t\t\t    mpa.unreach, mpa.unreach_len);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tmpp += pos;\n\t\t\t\tmplen -= pos;\n\n\t\t\t\trde_update_withdraw(peer, &prefix, prefixlen);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* silently ignore unsupported multiprotocol AF */\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((asp->flags & ~F_ATTR_MP_UNREACH) == 0) {\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* shift to NLRI information */\n\tp += 2 + attrpath_len;\n\n\t/* aspath needs to be loop free nota bene this is not a hard error */\n\tif (peer->conf.ebgp && !aspath_loopfree(asp->aspath, conf->as))\n\t\tasp->flags |= F_ATTR_LOOP;\n\n\t/* parse nlri prefix */\n\twhile (nlri_len > 0) {\n\t\tif ((pos = rde_update_get_prefix(p, nlri_len, &prefix,\n\t\t    &prefixlen)) == -1) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad nlri prefix\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\t\tif (prefixlen > 32) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad nlri prefix\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\tp += pos;\n\t\tnlri_len -= pos;\n\n\t\tif (peer->capa_received.mp_v4 == SAFI_NONE &&\n\t\t    peer->capa_received.mp_v6 != SAFI_NONE) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad AFI, IPv4 disabled\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\trde_update_update(peer, asp, &prefix, prefixlen);\n\n\t\t/* max prefix checker */\n\t\tif (peer->conf.max_prefix &&\n\t\t    peer->prefix_cnt >= peer->conf.max_prefix) {\n\t\t\tlog_peer_warnx(&peer->conf, \"prefix limit reached\");\n\t\t\trde_update_err(peer, ERR_CEASE, ERR_CEASE_MAX_PREFIX,\n\t\t\t    NULL, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t}\n\n\t/* add MP_REACH_NLRI if available */\n\tif (mpa.reach_len != 0) {\n\t\tmpp = mpa.reach;\n\t\tmplen = mpa.reach_len;\n\t\tmemcpy(&afi, mpp, 2);\n\t\tmpp += 2;\n\t\tmplen -= 2;\n\t\tafi = ntohs(afi);\n\t\tsafi = *mpp++;\n\t\tmplen--;\n\n\t\t/*\n\t\t * this works because asp is not linked.\n\t\t * But first unlock the previously locked nexthop.\n\t\t */\n\t\tif (asp->nexthop) {\n\t\t\tasp->nexthop->refcnt--;\n\t\t\t(void)nexthop_delete(asp->nexthop);\n\t\t\tasp->nexthop = NULL;\n\t\t}\n\t\tif ((pos = rde_get_mp_nexthop(mpp, mplen, afi, asp)) == -1) {\n\t\t\tlog_peer_warnx(&peer->conf, \"bad IPv6 nlri prefix\");\n\t\t\trde_update_err(peer, ERR_UPDATE, ERR_UPD_OPTATTR,\n\t\t\t    mpa.reach, mpa.reach_len);\n\t\t\tgoto done;\n\t\t}\n\t\tmpp += pos;\n\t\tmplen -= pos;\n\n\t\tswitch (afi) {\n\t\tcase AFI_IPv6:\n\t\t\tif (peer->capa_received.mp_v6 == SAFI_NONE) {\n\t\t\t\tlog_peer_warnx(&peer->conf, \"bad AFI, \"\n\t\t\t\t    \"IPv6 disabled\");\n\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t    ERR_UPD_OPTATTR, NULL, 0);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\twhile (mplen > 0) {\n\t\t\t\tif ((pos = rde_update_get_prefix6(mpp, mplen,\n\t\t\t\t    &prefix, &prefixlen)) == -1) {\n\t\t\t\t\tlog_peer_warnx(&peer->conf,\n\t\t\t\t\t    \"bad IPv6 nlri prefix\");\n\t\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t\t    ERR_UPD_OPTATTR,\n\t\t\t\t\t    mpa.reach, mpa.reach_len);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (prefixlen > 128) {\n\t\t\t\t\trde_update_err(peer, ERR_UPDATE,\n\t\t\t\t\t    ERR_UPD_OPTATTR,\n\t\t\t\t\t    mpa.reach, mpa.reach_len);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tmpp += pos;\n\t\t\t\tmplen -= pos;\n\n\t\t\t\trde_update_update(peer, asp, &prefix,\n\t\t\t\t    prefixlen);\n\n\t\t\t\t/* max prefix checker */\n\t\t\t\tif (peer->conf.max_prefix &&\n\t\t\t\t    peer->prefix_cnt >= peer->conf.max_prefix) {\n\t\t\t\t\tlog_peer_warnx(&peer->conf,\n\t\t\t\t\t    \"prefix limit reached\");\n\t\t\t\t\trde_update_err(peer, ERR_CEASE,\n\t\t\t\t\t    ERR_CEASE_MAX_PREFIX, NULL, 0);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* silently ignore unsupported multiprotocol AF */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tif (attrpath_len != 0) {\n\t\t/* unlock the previously locked entry */\n\t\tif (asp->nexthop) {\n\t\t\tasp->nexthop->refcnt--;\n\t\t\t(void)nexthop_delete(asp->nexthop);\n\t\t}\n\t\t/* free allocated attribute memory that is no longer used */\n\t\tpath_put(asp);\n\t}\n\n\treturn (error);\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* convert a 4 byte aspath to a 2byte one. data is freed by aspath_deflate */\n", "func_signal": "u_char *\naspath_deflate(u_char *data, u_int16_t *len, int *flagnew)", "code": "{\n\tu_int8_t\t*seg, *nseg, *ndata;\n\tu_int32_t\t as;\n\tint\t\t i;\n\tu_int16_t\t seg_size, olen, nlen;\n\tu_int8_t\t seg_len;\n\n\t/* first calculate the length of the aspath */\n\tnlen = 0;\n\tseg = data;\n\tolen = *len;\n\tfor (; olen > 0; olen -= seg_size, seg += seg_size) {\n\t\tseg_len = seg[1];\n\t\tseg_size = 2 + sizeof(u_int32_t) * seg_len;\n\t\tnlen += 2 + sizeof(u_int16_t) * seg_len;\n\n\t\tif (seg_size > olen)\n\t\t\tfatalx(\"aspath_deflate: would overflow\");\n\t}\n\n\tif ((ndata = malloc(nlen)) == NULL)\n\t\tfatal(\"aspath_deflate\");\n\n\t/* then copy the aspath */\n\tseg = data;\n\tolen = *len;\n\tfor (nseg = ndata; seg < data + olen; seg += seg_size) {\n\t\t*nseg++ = seg[0];\n\t\t*nseg++ = seg_len = seg[1];\n\t\tseg_size = 2 + sizeof(u_int32_t) * seg_len;\n\n\t\tfor (i = 0; i < seg_len; i++) {\n\t\t\tas = aspath_extract(seg, i);\n\t\t\tif (as > USHRT_MAX) {\n\t\t\t\tas = AS_TRANS;\n\t\t\t\t*flagnew = 1;\n\t\t\t}\n\t\t\t*nseg++ = (as >> 8) & 0xff;\n\t\t\t*nseg++ = as & 0xff;\n\t\t}\n\t}\n\n\tfree(data);\n\t*len = nlen;\n\treturn (ndata);\n}", "path": "rde_attr.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * soft reconfig specific functions\n */\n", "func_signal": "void\nrde_softreconfig_out(struct rib_entry *re, void *ptr)", "code": "{\n\tstruct prefix\t\t*p = re->active;\n\tstruct pt_entry\t\t*pt;\n\tstruct rde_peer\t\t*peer;\n\tstruct rde_aspath\t*oasp, *nasp;\n\tenum filter_actions\t oa, na;\n\tstruct bgpd_addr\t addr;\n\n\tif (p == NULL)\n\t\treturn;\n\n\tpt = re->prefix;\n\tpt_getaddr(pt, &addr);\n\tLIST_FOREACH(peer, &peerlist, peer_l) {\n\t\tif (peer->conf.id == 0)\n\t\t\tcontinue;\n\t\tif (peer->ribid != re->ribid)\n\t\t\tcontinue;\n\t\tif (peer->reconf_out == 0)\n\t\t\tcontinue;\n\t\tif (up_test_update(peer, p) != 1)\n\t\t\tcontinue;\n\n\t\toa = rde_filter(re->ribid, &oasp, rules_l, peer, p->aspath,\n\t\t    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);\n\t\tna = rde_filter(re->ribid, &nasp, newrules, peer, p->aspath,\n\t\t    &addr, pt->prefixlen, p->aspath->peer, DIR_OUT);\n\t\toasp = oasp != NULL ? oasp : p->aspath;\n\t\tnasp = nasp != NULL ? nasp : p->aspath;\n\n\t\tif (oa == ACTION_DENY && na == ACTION_DENY)\n\t\t\t/* nothing todo */\n\t\t\tgoto done;\n\t\tif (oa == ACTION_DENY && na == ACTION_ALLOW) {\n\t\t\t/* send update */\n\t\t\tup_generate(peer, nasp, &addr, pt->prefixlen);\n\t\t\tgoto done;\n\t\t}\n\t\tif (oa == ACTION_ALLOW && na == ACTION_DENY) {\n\t\t\t/* send withdraw */\n\t\t\tup_generate(peer, NULL, &addr, pt->prefixlen);\n\t\t\tgoto done;\n\t\t}\n\t\tif (oa == ACTION_ALLOW && na == ACTION_ALLOW) {\n\t\t\tif (path_compare(nasp, oasp) == 0)\n\t\t\t\tgoto done;\n\t\t\t/* send update */\n\t\t\tup_generate(peer, nasp, &addr, pt->prefixlen);\n\t\t}\n\ndone:\n\t\tif (oasp != p->aspath)\n\t\t\tpath_put(oasp);\n\t\tif (nasp != p->aspath)\n\t\t\tpath_put(nasp);\n\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* clean up */\n", "func_signal": "void\nrde_shutdown(void)", "code": "{\n\tstruct rde_peer\t\t*p;\n\tstruct filter_rule\t*r;\n\tu_int32_t\t\t i;\n\n\t/*\n\t * the decision process is turned off if rde_quit = 1 and\n\t * rde_shutdown depends on this.\n\t */\n\n\t/*\n\t * All peers go down\n\t */\n\tfor (i = 0; i <= peertable.peer_hashmask; i++)\n\t\twhile ((p = LIST_FIRST(&peertable.peer_hashtbl[i])) != NULL)\n\t\t\tpeer_down(p->conf.id);\n\n\t/* free filters */\n\twhile ((r = TAILQ_FIRST(rules_l)) != NULL) {\n\t\tTAILQ_REMOVE(rules_l, r, entry);\n\t\tfilterset_free(&r->set);\n\t\tfree(r);\n\t}\n\tfree(rules_l);\n\n\tnexthop_shutdown();\n\tpath_shutdown();\n\taspath_shutdown();\n\tattr_shutdown();\n\tpt_shutdown();\n\tpeer_shutdown();\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * nexthop specific functions\n */\n", "func_signal": "void\nrde_send_nexthop(struct bgpd_addr *next, int valid)", "code": "{\n\tsize_t\t\t\t size;\n\tint\t\t\t type;\n\n\tif (valid)\n\t\ttype = IMSG_NEXTHOP_ADD;\n\telse\n\t\ttype = IMSG_NEXTHOP_REMOVE;\n\n\tsize = sizeof(struct bgpd_addr);\n\n\tif (imsg_compose(ibuf_main, type, 0, 0, -1, next,\n\t    sizeof(struct bgpd_addr)) == -1)\n\t\tfatal(\"imsg_compose error\");\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * Returns a new prepended aspath. Old needs to be freed by caller.\n */\n", "func_signal": "u_char *\naspath_prepend(struct aspath *asp, u_int32_t as, int quantum, u_int16_t *len)", "code": "{\n\tu_char\t\t*p;\n\tint\t\t l, overflow = 0, shift = 0, size, wpos = 0;\n\tu_int8_t\t type;\n\n\t/* lunatic prepends are blocked in the parser and limited */\n\n\t/* first calculate new size */\n\tif (asp->len > 0) {\n\t\tif (asp->len < 2)\n\t\t\tfatalx(\"aspath_prepend: bad aspath length\");\n\t\ttype = asp->data[0];\n\t\tsize = asp->data[1];\n\t} else {\n\t\t/* empty as path */\n\t\ttype = AS_SET;\n\t\tsize = 0;\n\t}\n\n\tif (quantum > 255)\n\t\tfatalx(\"aspath_prepend: preposterous prepend\");\n\tif (quantum == 0) {\n\t\t/* no change needed but return a copy */\n\t\tp = malloc(asp->len);\n\t\tif (p == NULL)\n\t\t\tfatal(\"aspath_prepend\");\n\t\tmemcpy(p, asp->data, asp->len);\n\t\t*len = asp->len;\n\t\treturn (p);\n\t} else if (type == AS_SET || size + quantum > 255) {\n\t\t/* need to attach a new AS_SEQUENCE */\n\t\tl = 2 + quantum * sizeof(u_int32_t) + asp->len;\n\t\tif (type == AS_SET)\n\t\t\toverflow = quantum;\n\t\telse\n\t\t\toverflow = size + quantum - 255;\n\t} else\n\t\tl = quantum * sizeof(u_int32_t) + asp->len;\n\n\tquantum -= overflow;\n\n\tp = malloc(l);\n\tif (p == NULL)\n\t\tfatal(\"aspath_prepend\");\n\n\t/* first prepends */\n\tas = htonl(as);\n\tif (overflow > 0) {\n\t\tp[wpos++] = AS_SEQUENCE;\n\t\tp[wpos++] = overflow;\n\n\t\tfor (; overflow > 0; overflow--) {\n\t\t\tmemcpy(p + wpos, &as, sizeof(u_int32_t));\n\t\t\twpos += sizeof(u_int32_t);\n\t\t}\n\t}\n\tif (quantum > 0) {\n\t\tshift = 2;\n\t\tp[wpos++] = AS_SEQUENCE;\n\t\tp[wpos++] = quantum + size;\n\n\t\tfor (; quantum > 0; quantum--) {\n\t\t\tmemcpy(p + wpos, &as, sizeof(u_int32_t));\n\t\t\twpos += sizeof(u_int32_t);\n\t\t}\n\t}\n\tmemcpy(p + wpos, asp->data + shift, asp->len - shift);\n\n\t*len = l;\n\treturn (p);\n}", "path": "rde_attr.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * pf table specific functions\n */\n", "func_signal": "void\nrde_send_pftable(u_int16_t id, struct bgpd_addr *addr,\n    u_int8_t len, int del)", "code": "{\n\tstruct pftable_msg pfm;\n\n\tif (id == 0)\n\t\treturn;\n\n\t/* do not run while cleaning up */\n\tif (rde_quit)\n\t\treturn;\n\n\tbzero(&pfm, sizeof(pfm));\n\tstrlcpy(pfm.pftable, pftable_id2name(id), sizeof(pfm.pftable));\n\tmemcpy(&pfm.addr, addr, sizeof(pfm.addr));\n\tpfm.len = len;\n\n\tif (imsg_compose(ibuf_main,\n\t    del ? IMSG_PFTABLE_REMOVE : IMSG_PFTABLE_ADD,\n\t    0, 0, -1, &pfm, sizeof(pfm)) == -1)\n\t\tfatal(\"imsg_compose error\");\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * kroute specific functions\n */\n", "func_signal": "void\nrde_send_kroute(struct prefix *new, struct prefix *old)", "code": "{\n\tstruct kroute_label\t kl;\n\tstruct kroute6_label\t kl6;\n\tstruct bgpd_addr\t addr;\n\tstruct prefix\t\t*p;\n\tenum imsg_type\t\t type;\n\n\t/*\n\t * Make sure that self announce prefixes are not commited to the\n\t * FIB. If both prefixes are unreachable no update is needed.\n\t */\n\tif ((old == NULL || old->aspath->flags & F_PREFIX_ANNOUNCED) &&\n\t    (new == NULL || new->aspath->flags & F_PREFIX_ANNOUNCED))\n\t\treturn;\n\n\tif (new == NULL || new->aspath->flags & F_PREFIX_ANNOUNCED) {\n\t\ttype = IMSG_KROUTE_DELETE;\n\t\tp = old;\n\t} else {\n\t\ttype = IMSG_KROUTE_CHANGE;\n\t\tp = new;\n\t}\n\n\tpt_getaddr(p->prefix, &addr);\n\tswitch (addr.af) {\n\tcase AF_INET:\n\t\tbzero(&kl, sizeof(kl));\n\t\tkl.kr.prefix.s_addr = addr.v4.s_addr;\n\t\tkl.kr.prefixlen = p->prefix->prefixlen;\n\t\tif (p->aspath->flags & F_NEXTHOP_REJECT)\n\t\t\tkl.kr.flags |= F_REJECT;\n\t\tif (p->aspath->flags & F_NEXTHOP_BLACKHOLE)\n\t\t\tkl.kr.flags |= F_BLACKHOLE;\n\t\tif (type == IMSG_KROUTE_CHANGE)\n\t\t\tkl.kr.nexthop.s_addr =\n\t\t\t    p->aspath->nexthop->true_nexthop.v4.s_addr;\n\t\tstrlcpy(kl.label, rtlabel_id2name(p->aspath->rtlabelid),\n\t\t    sizeof(kl.label));\n\t\tif (imsg_compose(ibuf_main, type, 0, 0, -1, &kl,\n\t\t    sizeof(kl)) == -1)\n\t\t\tfatal(\"imsg_compose error\");\n\t\tbreak;\n\tcase AF_INET6:\n\t\tbzero(&kl6, sizeof(kl6));\n\t\tmemcpy(&kl6.kr.prefix, &addr.v6, sizeof(struct in6_addr));\n\t\tkl6.kr.prefixlen = p->prefix->prefixlen;\n\t\tif (p->aspath->flags & F_NEXTHOP_REJECT)\n\t\t\tkl6.kr.flags |= F_REJECT;\n\t\tif (p->aspath->flags & F_NEXTHOP_BLACKHOLE)\n\t\t\tkl6.kr.flags |= F_BLACKHOLE;\n\t\tif (type == IMSG_KROUTE_CHANGE) {\n\t\t\ttype = IMSG_KROUTE6_CHANGE;\n\t\t\tmemcpy(&kl6.kr.nexthop,\n\t\t\t    &p->aspath->nexthop->true_nexthop.v6,\n\t\t\t    sizeof(struct in6_addr));\n\t\t} else\n\t\t\ttype = IMSG_KROUTE6_DELETE;\n\t\tstrlcpy(kl6.label, rtlabel_id2name(p->aspath->rtlabelid),\n\t\t    sizeof(kl6.label));\n\t\tif (imsg_compose(ibuf_main, type, 0, 0, -1, &kl6,\n\t\t    sizeof(kl6)) == -1)\n\t\t\tfatal(\"imsg_compose error\");\n\t\tbreak;\n\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * Find the correct place to insert the prefix in the prefix list.\n * If the active prefix has changed we need to send an update.\n * The to evaluate prefix must not be in the prefix list.\n */\n", "func_signal": "void\nprefix_evaluate(struct prefix *p, struct rib_entry *re)", "code": "{\n\tstruct prefix\t*xp;\n\n\tif (re->flags & F_RIB_NOEVALUATE || rde_noevaluate()) {\n\t\t/* decision process is turned off */\n\t\tif (p != NULL)\n\t\t\tLIST_INSERT_HEAD(&re->prefix_h, p, rib_l);\n\t\tif (re->active != NULL) {\n\t\t\tre->active->aspath->active_cnt--;\n\t\t\tre->active = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (p != NULL) {\n\t\tif (LIST_EMPTY(&re->prefix_h))\n\t\t\tLIST_INSERT_HEAD(&re->prefix_h, p, rib_l);\n\t\telse {\n\t\t\tLIST_FOREACH(xp, &re->prefix_h, rib_l)\n\t\t\t\tif (prefix_cmp(p, xp) > 0) {\n\t\t\t\t\tLIST_INSERT_BEFORE(xp, p, rib_l);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (LIST_NEXT(xp, rib_l) == NULL) {\n\t\t\t\t\t/* if xp last element ... */\n\t\t\t\t\tLIST_INSERT_AFTER(xp, p, rib_l);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\n\txp = LIST_FIRST(&re->prefix_h);\n\tif (xp == NULL || xp->aspath->flags & F_ATTR_LOOP ||\n\t    (xp->aspath->nexthop != NULL &&\n\t    xp->aspath->nexthop->state != NEXTHOP_REACH))\n\t\t/* xp is ineligible */\n\t\txp = NULL;\n\n\tif (re->active != xp) {\n\t\t/* need to generate an update */\n\t\tif (re->active != NULL)\n\t\t\tre->active->aspath->active_cnt--;\n\n\t\t/*\n\t\t * Send update with remove for re->active and add for xp\n\t\t * but remember that xp may be NULL aka ineligible.\n\t\t * Additional decision may be made by the called functions.\n\t\t */\n\t\trde_generate_updates(re->ribid, xp, re->active);\n\t\tif ((re->flags & F_RIB_NOFIB) == 0)\n\t\t\trde_send_kroute(xp, re->active);\n\n\t\tre->active = xp;\n\t\tif (xp != NULL)\n\t\t\txp->aspath->active_cnt++;\n\t}\n}", "path": "rde_decide.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * network announcement stuff\n */\n", "func_signal": "void\nnetwork_init(struct network_head *net_l)", "code": "{\n\tstruct network\t*n;\n\n\treloadtime = time(NULL);\n\n\twhile ((n = TAILQ_FIRST(net_l)) != NULL) {\n\t\tTAILQ_REMOVE(net_l, n, entry);\n\t\tnetwork_add(&n->net, 1);\n\t\tfree(n);\n\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * route reflector helper function\n */\n", "func_signal": "void\nrde_reflector(struct rde_peer *peer, struct rde_aspath *asp)", "code": "{\n\tstruct attr\t*a;\n\tu_int8_t\t*p;\n\tu_int16_t\t len;\n\tu_int32_t\t id;\n\n\t/* check for originator id if eq router_id drop */\n\tif ((a = attr_optget(asp, ATTR_ORIGINATOR_ID)) != NULL) {\n\t\tif (memcmp(&conf->bgpid, a->data, sizeof(conf->bgpid)) == 0) {\n\t\t\t/* this is coming from myself */\n\t\t\tasp->flags |= F_ATTR_LOOP;\n\t\t\treturn;\n\t\t}\n\t} else if (conf->flags & BGPD_FLAG_REFLECTOR) {\n\t\tif (peer->conf.ebgp == 0)\n\t\t\tid = htonl(peer->remote_bgpid);\n\t\telse\n\t\t\tid = conf->bgpid;\n\t\tif (attr_optadd(asp, ATTR_OPTIONAL, ATTR_ORIGINATOR_ID,\n\t\t    &id, sizeof(u_int32_t)) == -1)\n\t\t\tfatalx(\"attr_optadd failed but impossible\");\n\t}\n\n\t/* check for own id in the cluster list */\n\tif (conf->flags & BGPD_FLAG_REFLECTOR) {\n\t\tif ((a = attr_optget(asp, ATTR_CLUSTER_LIST)) != NULL) {\n\t\t\tfor (len = 0; len < a->len;\n\t\t\t    len += sizeof(conf->clusterid))\n\t\t\t\t/* check if coming from my cluster */\n\t\t\t\tif (memcmp(&conf->clusterid, a->data + len,\n\t\t\t\t    sizeof(conf->clusterid)) == 0) {\n\t\t\t\t\tasp->flags |= F_ATTR_LOOP;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t/* prepend own clusterid by replacing attribute */\n\t\t\tlen = a->len + sizeof(conf->clusterid);\n\t\t\tif (len < a->len)\n\t\t\t\tfatalx(\"rde_reflector: cluster-list overflow\");\n\t\t\tif ((p = malloc(len)) == NULL)\n\t\t\t\tfatal(\"rde_reflector\");\n\t\t\tmemcpy(p, &conf->clusterid, sizeof(conf->clusterid));\n\t\t\tmemcpy(p + sizeof(conf->clusterid), a->data, a->len);\n\t\t\tattr_free(asp, a);\n\t\t\tif (attr_optadd(asp, ATTR_OPTIONAL, ATTR_CLUSTER_LIST,\n\t\t\t    p, len) == -1)\n\t\t\t\tfatalx(\"attr_optadd failed but impossible\");\n\t\t\tfree(p);\n\t\t} else if (attr_optadd(asp, ATTR_OPTIONAL, ATTR_CLUSTER_LIST,\n\t\t    &conf->clusterid, sizeof(conf->clusterid)) == -1)\n\t\t\tfatalx(\"attr_optadd failed but impossible\");\n\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* End-of-RIB marker, draft-ietf-idr-restart-13.txt */\n", "func_signal": "void\npeer_send_eor(struct rde_peer *peer, u_int16_t afi, u_int16_t safi)", "code": "{\n\tif (afi == AFI_IPv4 && safi == SAFI_UNICAST) {\n\t\tu_char null[4];\n\n\t\tbzero(&null, 4);\n\t\tif (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,\n\t\t    0, -1, &null, 4) == -1)\n\t\t\tfatal(\"imsg_compose error in peer_send_eor\");\n\t} else {\n\t\tu_int16_t\ti;\n\t\tu_char\t\tbuf[10];\n\n\t\ti = 0;\t/* v4 withdrawn len */\n\t\tbcopy(&i, &buf[0], sizeof(i));\n\t\ti = htons(6);\t/* path attr len */\n\t\tbcopy(&i, &buf[2], sizeof(i));\n\t\tbuf[4] = ATTR_OPTIONAL;\n\t\tbuf[5] = ATTR_MP_UNREACH_NLRI;\n\t\tbuf[6] = 3;\t/* withdrawn len */\n\t\ti = htons(afi);\n\t\tbcopy(&i, &buf[7], sizeof(i));\n\t\tbuf[9] = safi;\n\n\t\tif (imsg_compose(ibuf_se, IMSG_UPDATE, peer->conf.id,\n\t\t    0, -1, &buf, 10) == -1)\n\t\t\tfatal(\"imsg_compose error in peer_send_eor\");\n\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* ARGSUSED */\n", "func_signal": "struct buf *\nimsg_create(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,\n    pid_t pid, u_int16_t datalen)", "code": "{\n\tstruct buf\t*wbuf;\n\tstruct imsg_hdr\t hdr;\n\n\tdatalen += IMSG_HEADER_SIZE;\n\tif (datalen > MAX_IMSGSIZE) {\n\t\terrno = ERANGE;\n\t\treturn (NULL);\n\t}\n\n\thdr.type = type;\n\thdr.flags = 0;\n\thdr.peerid = peerid;\n\tif ((hdr.pid = pid) == 0)\n\t\thdr.pid = ibuf->pid;\n\tif ((wbuf = buf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {\n\t\treturn (NULL);\n\t}\n\tif (imsg_add(wbuf, &hdr, sizeof(hdr)) == -1)\n\t\treturn (NULL);\n\n\treturn (wbuf);\n}", "path": "imsg.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * Extract the asnum out of the as segment at the specified position.\n * Direct access is not possible because of non-aligned reads.\n * ATTENTION: no bounds checks are done.\n */\n", "func_signal": "u_int32_t\naspath_extract(const void *seg, int pos)", "code": "{\n\tconst u_char\t*ptr = seg;\n\tu_int32_t\t as;\n\n\tptr += 2 + sizeof(u_int32_t) * pos;\n\tmemcpy(&as, ptr, sizeof(u_int32_t));\n\treturn (ntohl(as));\n}", "path": "util.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * this function is a bit more complicated than a memcmp() because there are\n * types that need to be considered equal e.g. ACTION_SET_MED and\n * ACTION_SET_RELATIVE_MED. Also ACTION_SET_COMMUNITY and ACTION_SET_NEXTHOP\n * need some special care. It only checks the types and not the values so\n * it does not do a real compare.\n */\n", "func_signal": "int\nfilterset_cmp(struct filter_set *a, struct filter_set *b)", "code": "{\n\tif (strcmp(filterset_name(a->type), filterset_name(b->type)))\n\t\treturn (a->type - b->type);\n\n\tif (a->type == ACTION_SET_COMMUNITY ||\n\t    a->type == ACTION_DEL_COMMUNITY) {\t/* a->type == b->type */\n\t\t/* compare community */\n\t\tif (a->action.community.as - b->action.community.as != 0)\n\t\t\treturn (a->action.community.as -\n\t\t\t    b->action.community.as);\n\t\treturn (a->action.community.type - b->action.community.type);\n\t}\n\n\tif (a->type == ACTION_SET_NEXTHOP && b->type == ACTION_SET_NEXTHOP) {\n\t\t/*\n\t\t * This is the only interesting case, all others are considered\n\t\t * equal. It does not make sense to e.g. set a nexthop and\n\t\t * reject it at the same time. Allow one IPv4 and one IPv6\n\t\t * per filter set or only one of the other nexthop modifiers.\n\t\t */\n\t\treturn (a->action.nexthop.af - b->action.nexthop.af);\n\t}\n\n\t/* equal */\n\treturn (0);\n}", "path": "rde_filter.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* returns a zeroed pt_entry function may not return on fail */\n", "func_signal": "static struct pt_entry4 *\npt_alloc4(void)", "code": "{\n\tstruct pt_entry4\t*p;\n\n\tp = calloc(1, sizeof(*p));\n\tif (p == NULL)\n\t\tfatal(\"pt_alloc\");\n\trdemem.pt4_cnt++;\n\treturn (p);\n}", "path": "rde_prefix.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * control specific functions\n */\n", "func_signal": "void\nrde_dump_rib_as(struct prefix *p, struct rde_aspath *asp, pid_t pid, int flags)", "code": "{\n\tstruct ctl_show_rib\t rib;\n\tstruct buf\t\t*wbuf;\n\tstruct attr\t\t*a;\n\tvoid\t\t\t*bp;\n\tu_int8_t\t\t l;\n\n\tbzero(&rib, sizeof(rib));\n\trib.lastchange = p->lastchange;\n\trib.local_pref = asp->lpref;\n\trib.med = asp->med;\n\trib.prefix_cnt = asp->prefix_cnt;\n\trib.active_cnt = asp->active_cnt;\n\tstrlcpy(rib.descr, asp->peer->conf.descr, sizeof(rib.descr));\n\tmemcpy(&rib.remote_addr, &asp->peer->remote_addr,\n\t    sizeof(rib.remote_addr));\n\trib.remote_id = asp->peer->remote_bgpid;\n\tif (asp->nexthop != NULL) {\n\t\tmemcpy(&rib.true_nexthop, &asp->nexthop->true_nexthop,\n\t\t    sizeof(rib.true_nexthop));\n\t\tmemcpy(&rib.exit_nexthop, &asp->nexthop->exit_nexthop,\n\t\t    sizeof(rib.exit_nexthop));\n\t} else {\n\t\t/* announced network may have a NULL nexthop */\n\t\tbzero(&rib.true_nexthop, sizeof(rib.true_nexthop));\n\t\tbzero(&rib.exit_nexthop, sizeof(rib.exit_nexthop));\n\t\trib.true_nexthop.af = p->prefix->af;\n\t\trib.exit_nexthop.af = p->prefix->af;\n\t}\n\tpt_getaddr(p->prefix, &rib.prefix);\n\trib.prefixlen = p->prefix->prefixlen;\n\trib.origin = asp->origin;\n\trib.flags = 0;\n\tif (p->rib->active == p)\n\t\trib.flags |= F_RIB_ACTIVE;\n\tif (asp->peer->conf.ebgp == 0)\n\t\trib.flags |= F_RIB_INTERNAL;\n\tif (asp->flags & F_PREFIX_ANNOUNCED)\n\t\trib.flags |= F_RIB_ANNOUNCE;\n\tif (asp->nexthop == NULL || asp->nexthop->state == NEXTHOP_REACH)\n\t\trib.flags |= F_RIB_ELIGIBLE;\n\tif (asp->flags & F_ATTR_LOOP)\n\t\trib.flags &= ~F_RIB_ELIGIBLE;\n\trib.aspath_len = aspath_length(asp->aspath);\n\n\tif ((wbuf = imsg_create(ibuf_se_ctl, IMSG_CTL_SHOW_RIB, 0, pid,\n\t    sizeof(rib) + rib.aspath_len)) == NULL)\n\t\treturn;\n\tif (imsg_add(wbuf, &rib, sizeof(rib)) == -1 ||\n\t    imsg_add(wbuf, aspath_dump(asp->aspath),\n\t    rib.aspath_len) == -1)\n\t\treturn;\n\timsg_close(ibuf_se_ctl, wbuf);\n\n\tif (flags & F_CTL_DETAIL)\n\t\tfor (l = 0; l < asp->others_len; l++) {\n\t\t\tif ((a = asp->others[l]) == NULL)\n\t\t\t\tbreak;\n\t\t\tif ((wbuf = imsg_create(ibuf_se_ctl,\n\t\t\t    IMSG_CTL_SHOW_RIB_ATTR, 0, pid,\n\t\t\t    attr_optlen(a))) == NULL)\n\t\t\t\treturn;\n\t\t\tif ((bp = buf_reserve(wbuf, attr_optlen(a))) == NULL) {\n\t\t\t\tbuf_free(wbuf);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (attr_write(bp, attr_optlen(a), a->flags,\n\t\t\t    a->type, a->data, a->len) == -1) {\n\t\t\t\tbuf_free(wbuf);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\timsg_close(ibuf_se_ctl, wbuf);\n\t\t}\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/*\n * 4-Byte ASN helper function.\n * Two scenarios need to be considered:\n * - NEW session with NEW attributes present -> just remove the attributes\n * - OLD session with NEW attributes present -> try to merge them\n */\n", "func_signal": "void\nrde_as4byte_fixup(struct rde_peer *peer, struct rde_aspath *a)", "code": "{\n\tstruct attr\t*nasp, *naggr, *oaggr;\n\tu_int32_t\t as;\n\n\t/* first get the attributes */\n\tnasp = attr_optget(a, ATTR_AS4_PATH);\n\tnaggr = attr_optget(a, ATTR_AS4_AGGREGATOR);\n\n\tif (rde_as4byte(peer)) {\n\t\t/* NEW session using 4-byte ASNs */\n\t\tif (nasp)\n\t\t\tattr_free(a, nasp);\n\t\tif (naggr)\n\t\t\tattr_free(a, naggr);\n\t\treturn;\n\t}\n\t/* OLD session using 2-byte ASNs */\n\t/* try to merge the new attributes into the old ones */\n\tif ((oaggr = attr_optget(a, ATTR_AGGREGATOR))) {\n\t\tmemcpy(&as, oaggr->data, sizeof(as));\n\t\tif (ntohl(as) != AS_TRANS) {\n\t\t\t/* per RFC ignore AS4_PATH and AS4_AGGREGATOR */\n\t\t\tif (nasp)\n\t\t\t\tattr_free(a, nasp);\n\t\t\tif (naggr)\n\t\t\t\tattr_free(a, naggr);\n\t\t\treturn;\n\t\t}\n\t\tif (naggr) {\n\t\t\t/* switch over to new AGGREGATOR */\n\t\t\tattr_free(a, oaggr);\n\t\t\tif (attr_optadd(a, ATTR_OPTIONAL | ATTR_TRANSITIVE,\n\t\t\t    ATTR_AGGREGATOR, naggr->data, naggr->len))\n\t\t\t\tfatalx(\"attr_optadd failed but impossible\");\n\t\t}\n\t}\n\t/* there is no need for AS4_AGGREGATOR any more */\n\tif (naggr)\n\t\tattr_free(a, naggr);\n\n\t/* merge AS4_PATH with ASPATH */\n\tif (nasp)\n\t\taspath_merge(a, nasp);\n}", "path": "rde.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* free a filterset and take care of possible name2id references */\n", "func_signal": "void\nfilterset_free(struct filter_set_head *sh)", "code": "{\n\tstruct filter_set\t*s;\n\tstruct nexthop\t\t*nh;\n\n\twhile ((s = TAILQ_FIRST(sh)) != NULL) {\n\t\tTAILQ_REMOVE(sh, s, entry);\n\t\tif (s->type == ACTION_RTLABEL_ID)\n\t\t\trtlabel_unref(s->action.id);\n\t\telse if (s->type == ACTION_PFTABLE_ID)\n\t\t\tpftable_unref(s->action.id);\n\t\telse if (s->type == ACTION_SET_NEXTHOP &&\n\t\t    bgpd_process == PROC_RDE) {\n\t\t\tnh = nexthop_get(&s->action.nexthop);\n\t\t\t--nh->refcnt;\n\t\t\t(void)nexthop_delete(nh);\n\t\t}\n\t\tfree(s);\n\t}\n}", "path": "rde_filter.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "/* we need to be able to search more than one as */\n", "func_signal": "int\naspath_match(struct aspath *a, enum as_spec type, u_int32_t as)", "code": "{\n\tu_int8_t\t*seg;\n\tint\t\t final;\n\tu_int16_t\t len, seg_size;\n\tu_int8_t\t i, seg_type, seg_len;\n\n\tif (type == AS_EMPTY) {\n\t\tif (a->len == 0)\n\t\t\treturn (1);\n\t\telse\n\t\t\treturn (0);\n\t}\n\n\tfinal = 0;\n\tseg = a->data;\n\tfor (len = a->len; len > 0; len -= seg_size, seg += seg_size) {\n\t\tseg_type = seg[0];\n\t\tseg_len = seg[1];\n\t\tseg_size = 2 + sizeof(u_int32_t) * seg_len;\n\n\t\tfinal = (len == seg_size);\n\n\t\t/* just check the first (leftmost) AS */\n\t\tif (type == AS_PEER) {\n\t\t\tif (as == aspath_extract(seg, 0))\n\t\t\t\treturn (1);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t\t/* just check the final (rightmost) AS */\n\t\tif (type == AS_SOURCE) {\n\t\t\t/* not yet in the final segment */\n\t\t\tif (!final)\n\t\t\t\tcontinue;\n\n\t\t\tif (as == aspath_extract(seg, seg_len - 1))\n\t\t\t\treturn (1);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\n\t\t/* AS_TRANSIT or AS_ALL */\n\t\tfor (i = 0; i < seg_len; i++) {\n\t\t\tif (as == aspath_extract(seg, i)) {\n\t\t\t\t/*\n\t\t\t\t * the source (rightmost) AS is excluded from\n\t\t\t\t * AS_TRANSIT matches.\n\t\t\t\t */\n\t\t\t\tif (final && i == seg_len - 1 &&\n\t\t\t\t    type == AS_TRANSIT)\n\t\t\t\t\treturn (0);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}", "path": "rde_attr.c", "repo_name": "Cougar/openbgpd-linux-port", "stars": 4, "license": "None", "language": "c", "size": 1591}
{"docstring": "//assert a string\n", "func_signal": "static void p_litstr(char** pos, const char* str)", "code": "{\n  if (!*pos)return;\n  char* p = *pos;\n  int len = strlen(str);\n  if (!strncmp(p, str, len)){\n    *pos = p + len;\n  }else{\n    *pos = NULL;\n  }\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/* assumes sexp_parse mallocs each sexp and string individually */\n", "func_signal": "void sexp_free(struct sexp* x)", "code": "{\n  /* free children */\n  for (int i=0; i<x->nelems; i++){\n    switch (x->elems[i].type){\n    case ST_SEXP:\n      sexp_free(x->elems[i].data.sexp);\n      break;\n    case ST_STRING:\n      atom_decref(x->elems[i].data.string);\n      break;\n    case ST_INTEGER:\n      /* needs no freeing */\n      break;\n    }\n  }\n  free(x->elems);\n  /* possibly free filename (depends on reference count) */\n  atom_decref(x->location.filename);\n  /* free this node */\n  free(x);\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/*\n  Tests for vector and deque (and therefore container)\n*/\n", "func_signal": "int main()", "code": "{\n  int i, j;\n\n  vector_t v = make_vector(10, 5);\n\n  for(i = 0; i < 15; i++){\n    vector_push_back(v, strdup(\"test\"));\n  }\n  \n  vector_set(v, 14, strdup(\"testing\"));\n\n  for(i = 0; i < v->location; i++){\n    printf(\"%d\\n\", i);\n    printf(\"%s\\n\", (char*)vector_get(v, i));\n  }\n\n  destroy_vector(v);\n\n  deque_t d = make_deque(10, 5);\n\n  for(i = 0; i < 10; i++){\n    deque_push_back(d, strdup(\"back\"));\n    deque_push_back(d, strdup(\"front\"));    \n  }\n\n  while(d->location){\n    printf(\"%s\\n\", (char*)deque_peek_front(d));\n    deque_pop_front(d);\n  }\n\n  destroy_deque(d);\n  return 0;\n}", "path": "vm\\tests\\container_test.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//parse an integer\n", "func_signal": "static int p_int(char** pos)", "code": "{\n  if (!*pos)return -1;\n  char* int_end;\n  long int ret = strtol(*pos, &int_end, 10);\n  if (int_end == *pos){\n    //no characters matched, error.\n    *pos = NULL;\n    return -1;\n  }\n  *pos = int_end;\n  return (int)ret;\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/* Dumps a sexp out to stdout.\n   Not quite the same as the input format. Just for debugging */\n", "func_signal": "void sexp_dump(struct sexp* x)", "code": "{\n  printf(\"[<%s>:%d:%d %s%s\\n\", x->location.filename->string, x->location.line, x->location.bytepos, sexp_tag_to_string(x->tag), x->nelems == 0 ? \"]\": \"\");\n  if (x->nelems > 0){\n    for (int i=0;i<x->nelems;i++){\n      struct sexp_element* e = &x->elems[i];\n      if (e->type == ST_SEXP)sexp_dump(e->data.sexp);\n      else if (e->type == ST_INTEGER)printf(\"%d\\n\",e->data.integer);\n      else if (e->type == ST_STRING)printf(\"{%s}\\n\", e->data.string->string);\n    }\n    printf(\"]\\n\");\n  }\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//skip whitespace\n", "func_signal": "static void p_ws(char** pos)", "code": "{\n  if (!*pos)return;\n  while (isspace(**pos))\n    (*pos)++;\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/*\n// simple test\nint main() {\n\tbitset_t set = bitset_alloc(8);\n\tbitset_set(set, 3, 1);\n\tbitset_print(set);\n}\n*/\n", "func_signal": "void print_bitset_chars(bitset_t set)", "code": "{\n\tint i;\n\tfor(i = 0; i < set->capacity; ++i)\n\t{\n\t\tif(bitset_get(set, i))\n\t\t{\n\t\t\tprintf(\"%c \", (char)i);\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n}", "path": "vm\\tests\\bitops_test.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//Find a particular element, starting from a particular position\n//Stop when null is found\n", "func_signal": "static int ht_int_keypos(ht_int_t ht, uint64_t key, int startpos, int del)", "code": "{\n  //del indicates whether we should stop upon finding DELETED\n  for (int i=startpos; i != ht->capacity; i++){\n    if (ht->keys[i] == key || ht->values[i] == NULL || (del && ht->values[i] == DELETED)){\n      return i;\n    }\n  }\n  for (int i=0; i != startpos; i++){\n    if (ht->keys[i] == key || ht->values[i] == NULL || (del && ht->values[i] == DELETED)){\n      return i;\n    }\n  }\n  //if the hashtable is correctly rehashed, this should never happen\n  //FIXME: really?\n  return startpos;\n}", "path": "vm\\hashtable.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/* For the moment, everything is printed and nothing is fatal */\n/* Ideally, this should be runtime-configurable */\n", "func_signal": "int _should_say(message_category m)", "code": "{\n  if (m){}\n  return 1;\n}", "path": "vm\\error.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "// simple test\n", "func_signal": "int main()", "code": "{\n\tbitset_t set = bitset_alloc(8);\n\tbitset_set(set, 3, 1);\n\tbitset_print(set);\n}", "path": "vm\\tests\\bitops_test.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//Iteration\n", "func_signal": "ht_int_iter ht_int_begin(ht_int_t ht)", "code": "{\n  ht_int_iter i = {ht, -1};\n  return ht_int_next(i);\n}", "path": "vm\\hashtable.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "// ascii test\n", "func_signal": "int main()", "code": "{\n\t// create a bitset capable of representing any ascii char\n\tbitset_t set = bitset_alloc(128);\n\n\tchar str1[255];\n\n\tprintf(\"\\033[1;34mplease enter characters to set:\\033[0m \");\n\tfgets(str1, 255, stdin);\n\n\tchar* p = str1;\n\twhile(*p != '\\0' && *p != '\\n')\n\t{\n\t\tbitset_set(set, (int)(*p), 1);\n\t\t++p;\n\t}\n\n\tprintf(\"\\n\\033[1;34mbitset looks like:\\n\\033[1;36m\");\n\tbitset_print(set);\n\tprint_bitset_chars(set);\n\n\tprintf(\"\\033[1;34mplease enter characters to delete:\\033[0m \");\n\tfgets(str1, 255, stdin);\n\tp = str1;\n\twhile(*p != '\\0' && *p != '\\n')\n\t{\n\t\tbitset_set(set, (int)(*p), 0);\n\t\t++p;\n\t}\n\n\tprintf(\"\\n\\033[1;34mbitset looks like:\\n\\033[1;36m\");\n\tbitset_print(set);\n\tprint_bitset_chars(set);\n\n\tprintf(\"\\033[0m\\n\");\n\treturn 0;\n}", "path": "vm\\tests\\bitops_test.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//FIXME: lots of memory leaks, especially in error conditions. Not enough error-checking for malformed sexps.\n", "func_signal": "struct program* compile(struct sexp* code)", "code": "{\n  if (!code->tag == S_PROGRAM){\n    say(COMPILE, \"sexp does not appear to be a full program\");\n    return NULL;\n  }\n  struct program* program = malloc(sizeof(struct program));\n  struct sexp_element* globalvars = malloc(code->nelems * sizeof(struct sexp_element));\n  struct sexp** functions = malloc(code->nelems * sizeof(struct sexp*));\n  struct sexp** types = malloc(code->nelems * sizeof(struct sexp*));\n  int nglobals = 0, nfunctions = 0, ntypes = 0;\n\n  //Separate the global objects into types, global variables, and functions\n  for (int i=0;i<code->nelems;i++){\n    if (code->elems[i].type != ST_SEXP){\n      say(COMPILE, \"invalid global\");\n      return NULL;\n    }\n    struct sexp* global = code->elems[i].data.sexp;\n    switch (global->tag){\n    case S_STRUCT:\n    case S_UNION:\n      types[ntypes++] = global;\n      break;\n    case S_VAR:\n      globalvars[nglobals].type = ST_SEXP;\n      globalvars[nglobals].data.sexp = global;\n      nglobals++;\n      break;\n    case S_FUNCTION:\n      functions[nfunctions++] = global;\n      break;\n    default:\n      sayf(COMPILE, \"Invalid global '%s'\", sexp_tag_to_string(global->tag));\n      return NULL;\n    }\n  }\n  \n  build_typemap(ntypes, types);\n  free(types);\n\n\n  build_var_decls(nglobals, globalvars, &program->nglobals, &program->globals);\n\n\n  program->nfunctions = nfunctions;\n  program->functions = malloc(nfunctions * sizeof(struct function));\n \n  ht_atom_t funcnames = ht_atom_alloc();\n  for (int i=0;i<nfunctions;i++){\n    program->functions[i].ID = i;\n    ht_atom_set(funcnames, functions[i]->elems[0].data.string, &program->functions[i]);\n  }\n  ht_atom_t syscall_names = ht_atom_alloc();\n  for (int i=0;i<user_stdlib_count;i++){\n    ht_atom_set(syscall_names, atom_get(user_stdlib_names[i]), new_int(i));\n  }\n  program->main_function = ht_atom_get(funcnames, atom_get(\"main\"));\n  \n  for (int i=0;i<nfunctions;i++){\n    compile_function(functions[i], &program->functions[i], funcnames, syscall_names);\n  }\n  ht_atom_free(funcnames);\n  for (ht_atom_iter i = ht_atom_begin(syscall_names);\n       ht_atom_hasmore(i);\n       i = ht_atom_next(i))\n    free(ht_atom_getvalue(i));\n  ht_atom_free(syscall_names);\n  free(functions);\n  \n  return program;\n}", "path": "vm\\bytecode.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//Find a particular element, starting from a particular position\n//Stop when null is found\n", "func_signal": "static int ht_atom_keypos(ht_atom_t ht, atom key, int startpos, int del)", "code": "{\n  //del indicates whether we should stop upon finding DELETED\n  for (int i=startpos; i != ht->capacity; i++){\n    if (ht->keys[i] == key || ht->keys[i] == NULL || (del && ht->keys[i] == DELETED)){\n      return i;\n    }\n  }\n  for (int i=0; i != startpos; i++){\n    if (ht->keys[i] == key || ht->keys[i] == NULL || (del && ht->keys[i] == DELETED)){\n      return i;\n    }\n  }\n  //if the hashtable is correctly rehashed, this should never happen\n  //FIXME: really?\n  return startpos;\n}", "path": "vm\\hashtable.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/* make sure hashtable is initialised */\n", "func_signal": "static void table_init()", "code": "{\n  if (!atomtable.values){\n    atomtable.capacity = DEFAULT_SIZE;\n    atomtable.emptybuckets = atomtable.capacity;\n    atomtable.totalitems = 0;\n    atomtable.values = calloc(atomtable.capacity, sizeof(atom));\n  }\n}", "path": "vm\\atom.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//parse location information\n", "func_signal": "static struct location p_location(char** pos)", "code": "{\n  struct location l = {.filename = NULL, .bytepos = -1, .line = -1};\n  if (!*pos)return l;\n  p_litstr(pos, \"@\");\n  l.filename = p_string(pos);\n  p_litstr(pos, \":\");\n  l.line = p_int(pos);\n  p_litstr(pos, \":\");\n  l.bytepos = p_int(pos);\n  return l;\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//Fill in location information for sexps that have none\n//NB: some sexps might have filenames but no line numbers\n", "func_signal": "static void fill_in_location(struct sexp* s)", "code": "{\n  struct location* default_loc = &s->location;\n  for (int i=0;i<s->nelems;i++){\n    if (s->elems[i].type == ST_SEXP){\n      struct location* loc = &s->elems[i].data.sexp->location;\n      if (loc->filename == NULL){\n\tloc->filename = atom_addref(default_loc->filename);\n      }\n      fill_in_location(s->elems[i].data.sexp);\n    }\n  }\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/* rehash if necessary */\n", "func_signal": "static void table_rehash()", "code": "{\n  //these are percentages\n  int buckets_used = 100 - (100 * atomtable.emptybuckets) / atomtable.capacity;\n  int fullness = (100 * atomtable.totalitems) / atomtable.capacity;\n\n  int newsize = atomtable.capacity;\n  if (buckets_used > 70 || fullness > 90){\n    newsize = atomtable.capacity * 2;\n  }else if (buckets_used < 15 && fullness < 25){\n    newsize = atomtable.capacity / 2;\n  }\n  if (newsize < DEFAULT_SIZE) newsize = DEFAULT_SIZE;\n  if (newsize != atomtable.capacity){\n    //Rehash, making bigger or smaller\n    int oldcap = atomtable.capacity;\n    atom* oldvals = atomtable.values;\n    atomtable.capacity = atomtable.emptybuckets = newsize;\n    atomtable.totalitems = 0;\n    atomtable.values = calloc(atomtable.capacity, sizeof(atom));\n    for (int i=0;i<oldcap;i++){ //for each old bucket\n      atom a = oldvals[i];\n      while (a != NULL){ //for each element in bucket i\n\tint arrpos = a->hashcode & (atomtable.capacity - 1);\n\tatom oldnext = a->next;\n\t//inset into new table, update a->next\n\ta->next = atomtable.values[arrpos];\n\tatomtable.values[arrpos] = a;\n\t//advance to next element of old chain\n\ta = oldnext;\n      }\n    }\n  }\n}", "path": "vm\\atom.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//parse a single sexp-element\n", "func_signal": "static struct sexp_element p_sexp_element(char** pos)", "code": "{\n  struct sexp_element ret;\n  if (!*pos)return ret;\n  char next = **pos;\n  if (next == '('){\n    ret.type = ST_SEXP;\n    ret.data.sexp = p_sexp(pos);\n  }else if (next == '\"'){\n    ret.type = ST_STRING;\n    ret.data.string = p_string(pos);\n  }else if (isdigit(next) || next == '+' || next == '-'){\n    ret.type = ST_INTEGER;\n    ret.data.integer = p_int(pos);\n  }else{\n    //error\n    sayf(SEXP, \"Expecting sub-element, got %20s\", *pos);\n    *pos = NULL;\n  }\n  return ret;\n}", "path": "vm\\sexp.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "//Iteration\n", "func_signal": "ht_atom_iter ht_atom_begin(ht_atom_t ht)", "code": "{\n  ht_atom_iter i = {ht, -1};\n  return ht_atom_next(i);\n}", "path": "vm\\hashtable.c", "repo_name": "stedolan/Altitude", "stars": 4, "license": "None", "language": "c", "size": 776}
{"docstring": "/*Report whether Wake-on-Lan is enabled*/\n", "func_signal": "static void nic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)", "code": "{\n\n\tstruct nic_private *np = netdev_priv(dev);\n\n\tu8 cfg3 = readb(np->iobase+Config3); /*read config reg 3*/\n\n\twol->supported = WAKE_PHY | WAKE_MAGIC\n\t\t| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\n\n\twol->wolopts = 0;\n\n\tif (cfg3 & Cfg3_LinkUp)\n\t\twol->wolopts |= WAKE_PHY;\n\n\tif (cfg3 & Cfg3_Magic)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "// shows how to use a pointer to pointer.\n// veriosn : 1.0\n// Author : Team -C\n", "func_signal": "main()", "code": "{\n\tint *ptr;\n\tint **ptrtoptr;\n\tint p;\n\tp=9;\n\tptr=&p;\n\tptrtoptr=&ptr;\n\tprintf(\" adress of ptr = %x\\n\",ptrtoptr);\n\tprintf(\" adress of ptrtoptr = %x\\n\",&ptrtoptr);\n\tprintf(\" adress of p = %x\\n\",ptr);\n\tprintf( \" content of *ptr = %x\\n\",*ptr);\n\tprintf( \" content of *ptrtoptr = %x\\n\",*ptrtoptr);\n\tprintf( \" content of **ptrtoptr = %x\\n\",**ptrtoptr);\n}", "path": "Code-2.6.31 (2)\\c-code\\pointers\\part1\\one.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* let us assume that parent (process 1) will be writting to pipe and\nchild (process 2) will be reading from the pipe */\n", "func_signal": "void parent_code()", "code": "{\n\tchar *buf1=\"aaaaaaaaaaaaaaaaaaaa\";\n\tchar *buf=\"bbbbbbbbbbbbbbbbbbbb\";\n\tclose(fds[0]);\n\twrite(fds[1],buf,20);\n\twrite(fds[1],buf1,20);\n\tprintf(\" end of parent\\n\");\n}", "path": "Code-2.6.30\\Unix-Programming\\ipc\\PIPES\\pipe3.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*Report ring sizes */\n", "func_signal": "static void  nic_get_ringparam(struct net_device *dev, struct ethtool_ringparam  *ering)", "code": "{\n\tering->rx_max_pending = RX_BUF_LEN - 1;\n\tering->rx_mini_max_pending = 0;\n\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "// shows how to use memory allocation functions\n// Version : 1.0\n// Author : Team -C\n", "func_signal": "main()", "code": "{\n\tvoid *p;\n\tint *ptr;\n\tp = (void *)malloc(4);\n\tptr = (int *) p;\n\tprintf(\" ptr = %x\\n\",ptr);\n\t*ptr=9898;\n\tprintf(\" *ptr = %d\\n\",*ptr);\ngetchar();\n}", "path": "Code-2.6.26\\c-code\\pointers\\part5\\two.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* Set the ethtool Wake-on-LAN settings. */\n", "func_signal": "static int nic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)", "code": "{\n\tstruct nic_private *np = netdev_priv(dev);\n\tu8 cfg3;\n\n\tcfg3 = readb(np->iobase+Config3); /*read config reg3*/\n\n\tif (wol->wolopts & WAKE_PHY)\n\t\tcfg3 |= Cfg3_LinkUp;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tcfg3 |= Cfg3_Magic;\n\n\twriteb(cfg3,np->iobase+Config3);\n\n\treturn 0;\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*Module initilization routine*/\n", "func_signal": "static int __init nic_init(void)", "code": "{\n\tprintk(\"\\nRegistering nicdriver...\");\n\treturn pci_register_driver(&nic_driver);\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*Get device registers*/\n", "func_signal": "static void nic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)", "code": "{\n\tstruct nic_private *np = netdev_priv(dev);\n\n\tmemcpy_fromio(regbuf, np->iobase, regs->len);\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*Get length of the registers */\n", "func_signal": "static int nic_get_regs_len(struct net_device *dev)", "code": "{\n\t        struct nic_private *np = netdev_priv(dev);\n\t\t        return np->regs_len;\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* this function reads exactly n bytes and places it in buffer before\nreturning, if it fails to read exactly n bytes then it will return NULL */\n", "func_signal": "char * readNBytes(int connfd, int n)", "code": "{\n\tchar *buf,*tbuf;\n\tint nobread=0,nr,ntor;\n\tntor = n;\n\tbuf = (char *) malloc(n);\n\ttbuf = buf;\n\tif( buf == NULL)\n\t\treturn NULL;\n\twhile(1){\n\t\tnr = read(connfd,tbuf,ntor);\n\t\t\n\t\tprintf(\" read %d no of bytes from n/w(Client/Server) \\n\",nr);\n\t\tif( nr <= 0){\n\t\t\tperror(\"sockread:\");\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\ttbuf = tbuf + nr ;\n\t\tnobread += nr;\n\t\tif(nobread == n)\n\t\t\tbreak;\n\t\tntor = ntor - nr;\n\t}\n\treturn buf;\n}", "path": "Code-2.6.26\\network\\netp3\\lib1.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/**\n * This function is called when the user calls read on this device\n * It reads from a 'file' some data into 'buf' which\n * is 'lbuf' long starting from 'ppos' (present position)\n * Understanding the parameters\n * \tbuf  = buffer\n * \tppos = present position\n * \tlbuf = length of the buffer\n * \tfile = file to read\n * The function returns the number of bytes(characters) read.\n * */\n", "func_signal": "static int char_device_read(struct file *file, \n\t\t            char *buf,\n\t\t\t    size_t lbuf,\n\t\t\t    loff_t *ppos)", "code": "{\n\tint maxbytes; /* number of bytes from ppos to MAX_LENGTH */\n\tint bytes_to_do; /* number of bytes to read */\n\tint nbytes; /* number of bytes actually read */\n\n\tmaxbytes = MAX_LENGTH - *ppos;\n\t\n\tif( maxbytes > lbuf ) bytes_to_do = lbuf;\n\telse bytes_to_do = maxbytes;\n\t\n\tif( bytes_to_do == 0 ) {\n\t\tprintk(\"Reached end of device\\n\");\n\t\treturn -ENOSPC; /* Causes read() to return EOF */\n\t}\n\t\n\tnbytes = bytes_to_do - \n\t\t copy_to_user( buf, /* to */\n\t\t\t       char_device_buf + *ppos, /* from */\n\t\t\t       bytes_to_do ); /* how many bytes */\n\t*ppos += nbytes;\n\treturn nbytes;\t\n}", "path": "Code-2.6.30\\ddex\\char\\part3\\char_driver_ioctl.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* This example is used to demonstrate how to detact overruns.\nVersion: 1.0\nAuthor : Team -C\nRemarks : build executable by linking application with efence library\nusing gcc -ggdb overrun.c -lefence -o overrun\nAfter compiling we need to run our program using gdb overrun\n*/\n", "func_signal": "void buggyfunction()", "code": "{\n\tint * intptr;\n\tint i;\n// we are allocating memory to hold only 4 integers in this program.\n\tintptr = (int *) malloc( sizeof(int) *4);\n\tfor(i=0;i<4;i++){\n\t\t*intptr = 55;\n\t\tintptr++;\n\t}\n// we are trying to access memory which is not allocated by us here.\n}", "path": "Code-2.6.30\\c-code\\pointers\\part5\\nooverrun.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/**\n * This function is called when the user calls write on this device\n * It writes into 'file' the contents of 'buf' starting from 'ppos'\n * up to 'lbuf' bytes.\n * Understanding the parameters\n * \tbuf  = buffer\n * \tfile = file to write into\n * \tlbuf = length of the buffer\n * \tppos = present position pointer\n * The function returs the number of characters(bytes) written\n * */\n", "func_signal": "static int char_device_write(struct file *file,\n\t\t            const char *buf,\n\t\t\t    size_t lbuf,\n\t\t\t    loff_t *ppos)", "code": "{\n\tint nbytes; /* Number of bytes written */\n\tint bytes_to_do; /* Number of bytes to write */\n\tint maxbytes; /* Maximum number of bytes that can be written */\n\n\tmaxbytes = MAX_LENGTH - *ppos;\n\n\tif( maxbytes > lbuf ) bytes_to_do = lbuf;\n\telse bytes_to_do = maxbytes;\n\n\tif( bytes_to_do == 0 ) {\n\t\tprintk(\"Reached end of device\\n\");\n\t\treturn -ENOSPC; /* Returns EOF at write() */\n\t}\n\n\tnbytes = bytes_to_do -\n\t         copy_from_user( char_device_buf + *ppos, /* to */\n\t\t\t\t buf, /* from */\n\t\t\t\t bytes_to_do ); /* how many bytes */\n\t*ppos += nbytes;\n\treturn nbytes;\n}", "path": "Code-2.6.30\\ddex\\char\\part3\\char_driver_ioctl.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* Function to fill the aiocb values */\n", "func_signal": "void populate_aiocb(struct aiocb *aio, int fd, off_t offset, int bytes, char *buf,int opcode)", "code": "{\n        aio->aio_fildes = fd;\n        aio->aio_offset = offset;\n        aio->aio_nbytes = bytes;\n        aio->aio_buf = buf;\n\t/* This field could be LIO_READ for read request or LIO_WRITE for write\n \t* request\n        */\n        aio->aio_lio_opcode = opcode;\n}", "path": "Code-2.6.30\\Unix-Programming\\io\\aio\\aio_list\\aio_read_write_list.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "//create_workqueue(myqueue);\n", "func_signal": "void wq_func(void *arg)", "code": "{\n\tprintk(\"%ld %d %s \\n\", jiffies,counter++,current->comm);\n        if( counter < 1000 )\n                schedule_work(&wq);\n}", "path": "Code-2.6.31 (2)\\tst-work-queue.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/**\n * This function is called when a user wants to use this device\n * and has called the open function. \n *\n * The function will keep a count of how many people \n * tried to open it and increments it each time\n * this function is called\n *\n * The function prints out two pieces of information\n * 1. Number of times open() was called on this device\n * 2. Number of processes accessing this device right now\n *\n * Return value\n * \tAlways returns SUCCESS\n * */\n", "func_signal": "static int char_device_open(struct inode *inode,\n\t\t\t    struct file  *file)", "code": "{\n\tstatic int counter = 0;\n\tcounter++;\n\tprintk(\"Number of times open() was called: %d\\n\", counter);\n\tprintk(\"Process id of the current process: %d\\n\", current->pid );\n\treturn SUCCESS;\n}", "path": "Code-2.6.30\\ddex\\char\\part3\\char_driver_ioctl.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/**\n * This function is called when lseek() is called on the device\n * The function should place the ppos pointer of 'file'\n * at an offset of 'offset' from 'orig'\n *\n * if orig = SEEK_SET\n * \tppos = offset\n *\n * if orig = SEEK_END\n * \tppos = MAX_LENGTH - offset\n *\n * if orig = SEEK_CUR\n * \tppos += offset\n *\n * returns the new position\n * */\n", "func_signal": "static loff_t char_device_lseek(struct file *file,\n\t\t            loff_t offset,\n\t\t\t    int orig)", "code": "{\n\tloff_t new_pos=0;\n\tswitch( orig )\n\t{\n\tcase 0: /* SEEK_SET: */\n\t\tnew_pos = offset;\n\t\tbreak;\n\tcase 1: /* SEEK_CUR: */\n\t\tnew_pos = file->f_pos + offset;\n\t\tbreak;\n\tcase 2: /* SEEK_END: */\n\t\tnew_pos = MAX_LENGTH - offset;\n\t\tbreak;\n\t}\t\n\tif( new_pos > MAX_LENGTH ) new_pos = MAX_LENGTH;\n\tif( new_pos < 0 ) new_pos = 0;\n\tfile->f_pos = new_pos;\n\treturn new_pos;\n}", "path": "Code-2.6.30\\ddex\\char\\part3\\char_driver_ioctl.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*put the fram into trasmition buffer*/\n", "func_signal": "static int nic_start_xmit (struct sk_buff *skb, struct net_device *dev)", "code": "{\n\n\t/*get our private struct */\n\tstruct nic_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->iobase;\n\t\n\tunsigned int len = skb->len;\n\n\tprintk(\"In start_xmit\");\n\t\n\t/*see if frame size is more than our trasmition buffer*/\n\tif (likely(len < TX_BUF_LEN)) {\t\t\n\t\tif (len < ETH_ZLEN)  \n\t\t\tmemset(np->txbuf, 0, ETH_ZLEN);\n\t\tskb_copy_and_csum_dev(skb, np->txbuf);\n\t\tdev_kfree_skb(skb);\n\t} else {\n\t\tdev_kfree_skb(skb);\n\t\tnp->txdroped++;\n\t\treturn 0;\n\t}\n\n\t/*tell  device size of frame and threasold  */\n        writel(max(len, (unsigned int)ETH_ZLEN),ioaddr+TxStatus0 );\n\n\treturn 0;\n\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/*Report driver information*/\n", "func_signal": "static void nic_get_drvinfo(struct net_device *dev,struct ethtool_drvinfo *info)", "code": "{\n\tstruct nic_private *np = netdev_priv(dev);\n\tstrcpy(info->driver,\"NIC DRIVER\");\n\tstrcpy(info->version, \"1.0\");\n\tstrcpy(info->bus_info, pci_name(np->pdev));\n\tinfo->regdump_len = np->regs_len;\n}", "path": "Code-2.6.30\\ddex\\ethtool_driver\\nicdriver.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "// function returns whether this can handle the file or not\n", "func_signal": "int canHandle(char *filename)", "code": "{\n\tint len;\n\tchar *end;\n\tprintf(\" Checking whether I can handle %s or not \\n\",filename);\n\tlen = strlen(filename);\n\tend = filename + (len -3);\n\tprintf(\" end = %s\\n\",end);\n\t// just for testing purpose, in the real code the file need to be\n\t// opened and we need to check for magic no's.\n\tif(strcmp(end,\"gif\") == 0)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}", "path": "Code-2.6.31 (2)\\c-code\\build\\make3\\gifhandler.c", "repo_name": "sirishkumar/ldd", "stars": 6, "license": "None", "language": "c", "size": 32832}
{"docstring": "/* zconflex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int zconflex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tzconf_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tzconfpop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tzconffree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    return 0;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void zconfpop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tzconf_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tzconf_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/*\n * Try to open specified file with following names:\n * ./name\n * $(srctree)/name\n * The latter is used when srctree is separate from objtree\n * when compiling the kernel.\n * Return NULL if file is not found.\n */\n", "func_signal": "FILE *zconf_fopen(const char *name)", "code": "{\n\tchar *env, fullname[PATH_MAX+1];\n\tFILE *f;\n\n\tf = fopen(name, \"r\");\n\tif (!f && name[0] != '/') {\n\t\tenv = getenv(SRCTREE);\n\t\tif (env) {\n\t\t\tsprintf(fullname, \"%s/%s\", env, name);\n\t\t\tf = fopen(fullname, \"r\");\n\t\t}\n\t}\n\treturn f;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void zconfrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        zconfensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            zconf_create_buffer(zconfin,YY_BUF_SIZE );\n\t}\n\n\tzconf_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tzconf_load_buffer_state( );\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )", "code": "{\n\tregister int yy_is_jam;\n    \n\tyy_current_state = yy_nxt[yy_current_state][1];\n\tyy_is_jam = (yy_current_state <= 0);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* return non-zero means busy*/\n", "func_signal": "static int sst_erase_busy(struct flash_device *dev, u32 offset)", "code": "{\n\tu8 poll;\n\tulong flash_addr = dev->vaddr;\n\n\tpoll = inb(flash_addr + offset);\t\n\tif(poll & 0x80) // see sst flash datasheet Data# Polling (DQ7) \n\t\treturn 0;\n\treturn 1;\t\n}", "path": "drivers\\flash\\sst_flash.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tzconfpop_buffer_state();\n\t *\t\tzconfpush_buffer_state(new_buffer);\n     */\n\tzconfensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tzconf_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (zconfwrap()) processing, but the only time this flag\n\t * is looked at is after zconfwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void zconfensure_buffer_stack (void)", "code": "{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/*\n * Display a message box. Program will pause and display an \"OK\" button\n * if the parameter 'pause' is non-zero.\n */\n", "func_signal": "int dialog_msgbox(const char *title, const char *prompt, int height, int width,\n                  int pause)", "code": "{\n\tint i, x, y, key = 0;\n\tWINDOW *dialog;\n\n\t/* center dialog box on screen */\n\tx = (COLS - width) / 2;\n\ty = (LINES - height) / 2;\n\n\tdraw_shadow(stdscr, y, x, height, width);\n\n\tdialog = newwin(height, width, y, x);\n\tkeypad(dialog, TRUE);\n\n\tdraw_box(dialog, 0, 0, height, width, dialog_attr, border_attr);\n\n\tprint_title(dialog, title, width);\n\n\twattrset(dialog, dialog_attr);\n\tprint_autowrap(dialog, prompt, width - 2, 1, 2);\n\n\tif (pause) {\n\t\twattrset(dialog, border_attr);\n\t\tmvwaddch(dialog, height - 3, 0, ACS_LTEE);\n\t\tfor (i = 0; i < width - 2; i++)\n\t\t\twaddch(dialog, ACS_HLINE);\n\t\twattrset(dialog, dialog_attr);\n\t\twaddch(dialog, ACS_RTEE);\n\n\t\tprint_button(dialog, \"  Ok  \", height - 2, width / 2 - 4, TRUE);\n\n\t\twrefresh(dialog);\n\t\twhile (key != ESC && key != '\\n' && key != ' ' &&\n\t\t       key != 'O' && key != 'o' && key != 'X' && key != 'x')\n\t\t\tkey = wgetch(dialog);\n\t} else {\n\t\tkey = '\\n';\n\t\twrefresh(dialog);\n\t}\n\n\tdelwin(dialog);\n\treturn key == ESC ? -1 : 0;\n}", "path": "util\\kconfig\\lxdialog\\msgbox.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with zconf_create_buffer()\n * \n */\n", "func_signal": "void zconf_delete_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tzconffree((void *) b->yy_ch_buf  );\n\n\tzconffree((void *) b  );\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/*\n * parse_string \n * size feild is means the maximum len of this output transaction\n */\n", "func_signal": "int parse_string(char buf[], int size, const char * fmt, va_list args)", "code": "{\n\tchar c;\n\tchar *str, *end ,*output;\n\tu32 flags ;\n\tunsigned long long num;\n\tsize_t len;\n\n\tstr = buf;\n\tend = str + size;\n\n\tfor (; *fmt; fmt++) {\n\t\tif (*fmt != '%') {\n\t\t\tif(str < end)\n\t\t\t\t*str = *fmt;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\t\n\t\n\t\tfmt++; // skip first '%'\n\n\t\tswitch (*fmt) {\n\t\tcase 'c':\n\t\t\tc = (u8) va_arg(args, int);\t\n\t\t\tif (str < end)\n\t\t\t\t*str = c;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\tcase 's':\n\t\t\toutput = va_arg(args, char *);\n\t\t\tlen = strlen(output);\n\t\t\tif(str + len < end) \n\t\t\t\tmemcpy(str, output, len);\n\t\t\tstr += len;\n\t\t\tcontinue;\n\t\tcase '%':\n\t\t\tif (str < end)\n\t\t\t\t*str = '%';\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tflags = BASE10 | SINT;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags = BASE10 | USINT;\t\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tflags = BASE16 | USINT;\t\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tflags = (USINT | BASE10);\n\t\t}\n\n\t\t/* only to deal with int/unsigned int now */\n\t\t/* only to deal with 16/10 base */\n\t\tif(flags & USINT) {\n\t\t\tnum = (unsigned int)va_arg(args, unsigned int);\n\t\t} else {\n\t\t\tnum = (signed int)va_arg(args, int);\n\t\t}\n\t\t\n\t\tstr = number(str, end, num, flags);\n\t}\t\n\n\treturn str - buf;\n}", "path": "lib\\printf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tzconfensure_buffer_stack();\n\n\t/* This block is copied from zconf_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from zconf_switch_to_buffer. */\n\tzconf_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */\n", "func_signal": "YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in zconf_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in zconf_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tzconf_init_buffer(b,file );\n\n\treturn b;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a zconfrestart() or at EOF.\n */\n", "func_signal": "static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )", "code": "{\n\tint oerrno = errno;\n    \n\tzconf_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then zconf_init_buffer was _probably_\n     * called from zconfrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = 0;\n    \n\terrno = oerrno;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in zconf_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tzconf_switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will\n * scan from a @e copy of @a bytes.\n * @param bytes the byte buffer to scan\n * @param len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * bytes, int  len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = len + 2;\n\tbuf = (char *) zconfalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in zconf_scan_bytes()\" );\n\n\tfor ( i = 0; i < len; ++i )\n\t\tbuf[i] = bytes[i];\n\n\tbuf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = zconf_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in zconf_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void zconf_flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tzconf_load_buffer_state( );\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tsize_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tzconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tzconfrestart(zconfin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* return non-zero means busy*/\n", "func_signal": "static int sst_program_busy(struct flash_device *dev, u32 offset)", "code": "{\n\tu8 poll1, poll2;\n\tulong flash_addr = dev->vaddr;\n\n\tpoll1 = inb(flash_addr + offset);\t\n\tpoll2 = inb(flash_addr + offset);\t\n\tif((poll1 ^ poll2) & 0x40) // set sst flash datasheet Toggle Bit(DQ6)\n\t\treturn 1;\n\treturn 0;\n}", "path": "drivers\\flash\\sst_flash.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tyy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "util\\kconfig\\lex.zconf.c", "repo_name": "guobamantou/minibios", "stars": 5, "license": "None", "language": "c", "size": 4992}
{"docstring": "//\n", "func_signal": "VOID GFCreateSlice(OUT UCHAR *res, IN UCHAR *src, IN ULONG length, IN UCHAR k, IN UCHAR vector_num)", "code": "{\n\tULONG i;\n\tUCHAR vec[256];\n\n\tGFCreateBasisVector(vec, vector_num, k);\n\tfor(i=0; i<length; i++)\n\t\tres[i] = GFMulVV(src + i*k, vec, k);\n}", "path": "nkcodec\\nk_codec.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID GFAssembleSlices(OUT UCHAR *res, IN UCHAR *src, ULONG part_length, UCHAR k,\n\t\t\t\t\t  IN UCHAR *parts_numbers, IN UCHAR *assemble_matrix)", "code": "{\n\tULONG i, j;\n\tUCHAR vec[256];\n\n\tfor(i=0; i<part_length; i++)\n\t{\n\t\tfor(j=0; j<k; j++)\n\t\t\tvec[j] = src[(parts_numbers[j]-1)*part_length + i];\n\n\t\tGFMulVM(res + i*k, vec, assemble_matrix, k);\n\t}\n}", "path": "nkcodec\\nk_codec.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID FillBlocksToRead(PENCODED_BLOCK pToRead, ULONG StartingSector,\n\t\t\t\t\t  ULONG SectorsNum, UCHAR n, UCHAR k)", "code": "{\n\tFORMATTING formatting;\n\tPENCODED_BLOCK pBlock = pToRead;\n\tULONG CurrentBlock;\n\tULONG ByteOffset;\n\tULONG ByteLength = SectorsNum * SECTOR_LEN;\n\tUCHAR i;\n\n\tCreateFormatting(&formatting, n, k);\n\n\tByteOffset = StartingSector * SECTOR_LEN;\n\tCurrentBlock = ByteOffset / (RAW_LEN * k);\n\n\twhile(ByteLength)\n\t{\n\t\tpBlock->BaseParts = GetBaseOffset(&formatting, CurrentBlock);\n\n\t\tfor(i = 0; i < n-k; i++)\n\t\t\tpBlock->BackupParts[i] = GetBackupOffset(&formatting, CurrentBlock, i);\n\n\t\tpBlock->k = k;\n\t\tpBlock->n = n;\n\t\tpBlock->Offset = ByteOffset - CurrentBlock * (RAW_LEN * k);\n\t\tpBlock->Length = RAW_LEN * k - pBlock->Offset;\n\n\t\tif(ByteLength >= pBlock->Length)\n\t\t\tByteLength -= pBlock->Length;\n\t\telse\n\t\t{\n            pBlock->Length = ByteLength;\n\t\t\tByteLength = 0;\n\t\t}\n\n\t\tCurrentBlock++;\n\t\tByteOffset = CurrentBlock * RAW_LEN * k;\n\t\tpBlock++;\n\t}\n}", "path": "nkcodec\\formatting.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID CreateSptiReadRequest(SCSI_PASS_THROUGH *spt, ULONG StartSector, ULONG SectorCount)", "code": "{\n\tRtlZeroMemory(spt, sizeof(SCSI_PASS_THROUGH));\n\n\tspt->Length              = sizeof(SCSI_PASS_THROUGH);\n\tspt->CdbLength           = 12;\t\t\t\t\t\t\t// CDB packet length\n\tspt->DataIn              = SCSI_IOCTL_DATA_IN;\t\t\t// we will read\n\t//\tspt->DataTransferLength  = (RAW_SECTOR_LENGTH + ECC_LENGTH) * SectorCount;\t// bytes to read\n\tspt->DataTransferLength  = SECTOR_LENGTH * SectorCount;\n\tspt->SenseInfoLength     = 0;\n\tspt->TimeOutValue        = 1;\t\t\t\t\t\t\t// time to wait for operation to finish\n\tspt->DataBufferOffset    = sizeof(SCSI_PASS_THROUGH);\n\tspt->SenseInfoOffset     = 0;\n\n\t//  CDB\n\tspt->Cdb[0]              =  0xBE;\t\t\t\t\t\t// (SPTI READ_CD)\n\n\t// number of the first sector to be read\n\tspt->Cdb[2]              = HIBYTE(HIWORD(StartSector));\n\tspt->Cdb[3]              = LOBYTE(HIWORD(StartSector));\n\tspt->Cdb[4]              = HIBYTE(LOWORD(StartSector));\n\tspt->Cdb[5]              = LOBYTE(LOWORD(StartSector));\n\n\t// number of sectors to read\n\tspt->Cdb[6]              = LOBYTE(HIWORD(SectorCount));\n\tspt->Cdb[7]              = HIBYTE(LOWORD(SectorCount));\n\tspt->Cdb[8]              = LOBYTE(LOWORD(SectorCount));\n\n\t//\tspt->Cdb[9]              = 0xFA;\t\t\t\t\t\t// Read 2352 + 294 bytes\n\tspt->Cdb[9]              = 0x10;\t\t\t\t\t\t// Read 2048 bytes\n}", "path": "nkfilter\\dispatch_read.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS DetectionCompletion(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID context)", "code": "{\n\tPSCSI_REQUEST_BLOCK pSrb;\n\tPCDB pCdb;\n\tPMDL pMdl;\n\tPUCHAR MdlBuffer;\n\tPDEVICE_EXTENSION pDeviceExtension;\n\n\tpSrb = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Scsi.Srb;\n\tpCdb = (PCDB)pSrb->Cdb;\n\n\t// Return immediately on errors\n\tif(!pIrp->MdlAddress)\n\t{\n\t\tpIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tif(!NT_SUCCESS(pIrp->IoStatus.Status))\n\t{\n\t\treturn STATUS_SUCCESS;\n\t}\n\t\n\t// TODO: check if this is a real audio CD\n\t// Now assume that all disks are (n,k)-formatted\n\tpMdl = pIrp->MdlAddress;\n\n\tMmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);\n\tMdlBuffer = MmGetSystemAddressForMdlSafe(pMdl, HighPagePriority);\n\n\tDbgPrint(\"Writing fake TOC\\n\");\n\tMdlBuffer[5] = 0x14;\n\n\t// Clean N, K and ReadOffset\n\t// TODO: investigate the situation what will occur, if they will be in use\n\t// (and whether it can happen or not in reality)\n\tpDeviceExtension = ((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension));\n\tpDeviceExtension->K = 0;\n\tpDeviceExtension->N = 0;\n\tpDeviceExtension->ReadOffset = 0;\n\tpDeviceExtension->pDriverObject->MajorFunction[IRP_MJ_SCSI] = DispatchScsi;\n\n\treturn STATUS_SUCCESS;\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID StartReading(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)", "code": "{\n\tPREAD_REQUEST pRead;\n\tULONG BlocksToRead;\n\tULONG StartingSector, SectorsNum;\n\tPSCSI_REQUEST_BLOCK pSrb;\n\tPCDB pCdb;\n\tPDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)pDeviceObject->DeviceExtension;\n\n\tpSrb = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Scsi.Srb;\n\tpCdb = (PCDB)pSrb->Cdb;\n\n\tStartingSector\t=\t(ULONG)pCdb->CDB10.LogicalBlockByte3 +\n\t\t((ULONG)(pCdb->CDB10.LogicalBlockByte2) << 8) +\n\t\t((ULONG)(pCdb->CDB10.LogicalBlockByte1) << 16) +\n\t\t((ULONG)(pCdb->CDB10.LogicalBlockByte0) << 24);\n\n\tSectorsNum\t\t=\t(ULONG)pCdb->CDB10.TransferBlocksLsb +\n\t\t((ULONG)(pCdb->CDB10.TransferBlocksMsb) << 8);\n\n\tBlocksToRead = GetNumberOfBlocksToRead(StartingSector, SectorsNum, 12);\n\n\tpRead = Allocate(sizeof(READ_REQUEST) + BlocksToRead * sizeof(ENCODED_BLOCK));\n\tRtlZeroMemory(pRead, sizeof(READ_REQUEST) + BlocksToRead * sizeof(ENCODED_BLOCK));\n\n\tpRead->ToRead = (PENCODED_BLOCK)(pRead + 1);\n\tpRead->BlocksNum = BlocksToRead;\n\n\tpRead->k = 12;\n\tpRead->n = 16;\n\n\tpRead->pSourceIrp = pIrp;\n\tpRead->pSourceSrb = pSrb;\n\tpRead->pSourceCdb = pCdb;\n\n\tpRead->SourceBuffer = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, HighPagePriority);\n\n\tpRead->pRemoveLock = &((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension))->RemoveLock;\n\tpRead->pNextDevice = ((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension))->pNextDeviceObject;\n\tpRead->StackSize = pRead->pNextDevice->StackSize;\n\n\tpRead->StartingSector = StartingSector;\n\tpRead->SectorsNum = SectorsNum;\n\n\tAllocateBuffer(pRead->k * (RAW_LEN + ECC_LEN + 2), &(pRead->ReadBuffer),\n\t\t&(pRead->ReadBufferMdl));\n\n\tFillBlocksToRead(pRead->ToRead, StartingSector, SectorsNum, pRead->n, pRead->k);\n\n\tpRead->CurrentBlock = 0;\n\tpRead->CurrentLength = 0;\n\n\tReadCurrentBase(pRead);\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID StartDeduction(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)", "code": "{\n\tPDETECTION_REQUEST pRequest;\n\tPIRP pNewIrp;\n\tPDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)pDeviceObject->DeviceExtension;\n\n\t// Read random sectors of the disk until we get undamaged one\n\t// Deduce N, K and read offset from the sector's subchannel\n\tpRequest = Allocate(sizeof(*pRequest));\n\tRtlZeroMemory(pRequest, sizeof(*pRequest));\n\n\tpRequest->pSourceIrp = pIrp;\n\tpRequest->pNextDevice = ((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension))->pNextDeviceObject;\n\n\tpRequest->MaxAttempts = 5;\n\n\tAllocateBuffer(RAW_LEN + ECC_LEN + 2 + SUBCHANNELS_LEN, &(pRequest->ReadBuffer),\n\t\t&(pRequest->ReadBufferMdl));\n\n\tReadNextSector(pRequest);\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "ULONG GetBackupOffset(PFORMATTING params, ULONG BlockNumber, UCHAR BackupNumber)", "code": "{\n\tULONG BaseZoneNumber, Theta;\n\n\tBaseZoneNumber = BlockNumber / params->BlocksInBaseArea;\n\tTheta = BackupNumber < BaseZoneNumber ? 0 : 1;\n\n\treturn\t(BackupNumber + Theta) * params->SectorsInZone +\n\t\t\tparams->SectorsInBaseArea +\n\t\t\tBlockNumber -\n\t\t\t(1 - Theta) * params->BlocksInBaseArea;\n}", "path": "nkcodec\\formatting.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS DispatchRead (IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)", "code": "{\n\tNTSTATUS stat;\n\tPDEVICE_EXTENSION pDeviceExtension;\n\n\tpDeviceExtension = pDeviceObject->DeviceExtension;\n\n\tif(KeGetCurrentIrql() > PASSIVE_LEVEL)\n\t{\n\t\tDbgPrint(\"Async request\\n\");\n\t\treturn PassIrp(pDeviceObject, pIrp);\n\t}\n\n\tstat = IoAcquireRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\tif(stat != STATUS_SUCCESS)\n\t\treturn CompleteRequest(pIrp, stat, 0, FALSE);\n\n//\n\t{\n\t\tPIRP pNewIrp;\n\t\tPSCSI_REQUEST_BLOCK pSrb;\n\t\tPCHAR ReadBuffer;\n\t\tKEVENT event;\n\t\tIO_STATUS_BLOCK status_block;\n\t\tNTSTATUS status;\n\t\tPIO_STACK_LOCATION stack;\n\t\tPDATA pData;\n\t\tPDEVICE_OBJECT pTarget;\n\n\t\tstack = IoGetCurrentIrpStackLocation(pIrp);\n\n\t\tDbgPrint(\"request Offset = %X, Length = %X\\n\", stack->Parameters.Read.ByteOffset.LowPart,\n\t\t\tstack->Parameters.Read.Length);\n\n\t\tpTarget = stack->DeviceObject;\n\n\t\tpSrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(SCSI_REQUEST_BLOCK), POOL_TAG);\n\t\tReadBuffer = ExAllocatePoolWithTag(NonPagedPool, stack->Parameters.Read.Length, POOL_TAG);\n\n//\t\tCreateSptiReadRequest(pspt, (ULONG)(stack->Parameters.Read.ByteOffset.QuadPart/SECTOR_LENGTH),\n//\t\t\tstack->Parameters.Read.Length/SECTOR_LENGTH);\n\n\t\tif(KeGetCurrentIrql() == PASSIVE_LEVEL)\n\t\t{\n//\t\t\t__asm int 3;\n\n\t\t\tKeInitializeEvent(&event, SynchronizationEvent, FALSE);\n\n\t\t\tpNewIrp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH,\n\t\t\t\tpDeviceExtension->pNextDeviceObject, pspt, BufferSize, pspt, BufferSize,\n\t\t\t\tTRUE, &event, &status_block);\n\n\t\t\tif(!pNewIrp)\n\t\t\t{\n\t\t\t\tDbgPrint(\"Can't create IRP\\n\");\n\t\t\t\tIoReleaseRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\t\t\t\treturn CompleteRequest(pIrp, STATUS_UNSUCCESSFUL, 0, FALSE);\n\t\t\t}\n\n\t\t\tCreateSrb(pSrb, (ULONG)(stack->Parameters.Read.ByteOffset.QuadPart/SECTOR_LENGTH),\n\t\t\t\tstack->Parameters.Read.Length/SECTOR_LENGTH, ReadBuffer, pNewIrp);\n\n\t\t\tDbgPrint(\"Before calling\\n\");\n\n\n//\t\t\tstack =\tIoGetCurrentIrpStackLocation(pNewIrp);\n//\t\t\tDbgPrint(\"Stack flags = %X\\n\", stack->Flags);\n\n\t\t\tstatus = IoCallDriver(pDeviceExtension->pNextDeviceObject, pNewIrp);\n\n\t\t\tDbgPrint(\"After calling\\n\");\n\n\t\t\tif(status == STATUS_PENDING)\n\t\t\t{\n\t\t\t\tKeWaitForSingleObject(&event, Executive, KernelMode, FALSE, 0);\n\t\t\t\tDbgPrint(\"Was pending\\n\");\n\t\t\t}\n\n\t\t\tDbgPrint(\"Passive request: status %X, info %X\\n\",\n\t\t\t\tstatus_block.Status, status_block.Information);\n\t\t\tDbgPrint(\"IRP status %X, info %X\\n\", pNewIrp->IoStatus.Status,\n\t\t\t\tpNewIrp->IoStatus.Information);\n\n//\t\t\tSaveBufferToIrp(pIrp, (PCHAR)(pspt) + sizeof(SCSI_PASS_THROUGH),\n//\t\t\t\tBufferSize - sizeof(SCSI_PASS_THROUGH));\n\n\t\t\tExFreePoolWithTag(pspt, POOL_TAG);\n\n//\t\t\tstatus = CompleteRequest(pIrp, status_block.Status, status_block.Information -\n//\t\t\t\tsizeof(SCSI_PASS_THROUGH), TRUE);\n\n\t\t\tIoReleaseRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\n\t\t\tstatus = PassIrp(pDeviceObject, pIrp);\n\n\t\t\tDbgPrint(\"Dispatch end\\n\");\n\n\t\t\treturn status;\n\t\t}\n\t\telse\n\t\t{\n//\t\t\t__asm int 3;\n\n\t\t\tIoMarkIrpPending(pIrp);\n\n\t\t\tDbgPrint(\"Asynchronous request\\n\");\n\n\t\t\tpNewIrp = IoAllocateIrp(5, FALSE);\n\n\t\t\tif(!pNewIrp)\n\t\t\t{\n\t\t\t\tDbgPrint(\"Can't create IRP\\n\");\n\t\t\t\tIoReleaseRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\t\t\t\treturn CompleteRequest(pIrp, STATUS_UNSUCCESSFUL, 0, FALSE);\n\t\t\t}\n\n\t\t\tpData = ExAllocatePoolWithTag(NonPagedPool, sizeof(DATA), POOL_TAG);\n\n\t\t\tpData->Length = stack->Parameters.Read.Length;\n\t\t\tpData->pIrp = pIrp;\n\t\t\tpData->pRemoveLock = &(pDeviceExtension->RemoveLock);\n\t\t\tpData->pSpt = pspt;\n\n\t\t\tpNewIrp->MdlAddress = NULL;\n\t\t\tpNewIrp->AssociatedIrp.SystemBuffer = pspt;\n\n\t\t\tpNewIrp->UserBuffer = pspt;\n\n\t\t\tpNewIrp->RequestorMode = KernelMode;\n\n\t\t\tstack =\tIoGetCurrentIrpStackLocation(pNewIrp);\n\n\t\t\tstack->MajorFunction = IRP_MJ_DEVICE_CONTROL;\n\t\t\tstack->MinorFunction = 0;\n//\t\t\tstack->DeviceObject = pTarget;\n\n\t\t\tstack->Parameters.DeviceIoControl.InputBufferLength = BufferSize;\n\t\t\tstack->Parameters.DeviceIoControl.OutputBufferLength = BufferSize;\n\t\t\tstack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_PASS_THROUGH;\n\n\t\t\tIoSetCompletionRoutine(pNewIrp, ReadCompletion, pData, TRUE, TRUE, TRUE);\n\n\t\t\tstatus = IoCallDriver(pDeviceExtension->pNextDeviceObject, pNewIrp);\n\n\t\t\treturn STATUS_PENDING;\n\t\t}\n\t}\n}", "path": "nkfilter\\dispatch_read.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID ReadCurrentBase(PREAD_REQUEST pRead)", "code": "{\n\tPIRP pNewIrp;\n\n\tpNewIrp = CreateIrp(pRead->StackSize, pRead->ToRead[pRead->CurrentBlock].BaseParts,\n\t\tpRead->ToRead[pRead->CurrentBlock].k, pRead->ReadBufferMdl, pRead->ReadBuffer,\n\t\tTRUE, FALSE);\n\n\tIoSetCompletionRoutine(pNewIrp, ReadCompletion, pRead, TRUE, TRUE, TRUE);\n    IoCallDriver(pRead->pNextDevice, pNewIrp);\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID GFCreateAssemblingMatrix(OUT UCHAR *res, OUT UCHAR *temp, IN const UCHAR *parts_numbers, IN UCHAR k)", "code": "{\n\tUCHAR i, j;\n\n\tfor(i=0; i<k; i++)\n\t\tfor(j=0; j<k; j++)\n\t\t\tif(j)\n\t\t\t\ttemp[j*k+i] = GFMul(temp[(j-1)*k+i], parts_numbers[i]);\n\t\t\telse\n\t\t\t\ttemp[i] = 1;\n\n\tGFInvertM(res, temp, k);\n}", "path": "nkcodec\\nk_codec.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "PIRP CreateIrp(CCHAR StackSize, ULONG StartingSector, ULONG SectorsCount,\n\tPMDL read_buffer_mdl, PCHAR read_buffer, BOOLEAN get_data, BOOLEAN get_subchannels)", "code": "{\n\tPIRP pIrp;\n\tPSCSI_REQUEST_BLOCK pSrb;\n\tPCDB pCdb;\n\tPIO_STACK_LOCATION pStack;\n\tULONG SECTOR = (get_data ? (RAW_LEN + ECC_LEN + 2) : 0) +\n\t\t(get_subchannels ? SUBCHANNELS_LEN : 0);\n\n\tpIrp = IoAllocateIrp(StackSize, FALSE);\n\n\t// Fill IRP parameters\n\n\tpIrp->RequestorMode = KernelMode;\n\tpIrp->MdlAddress = read_buffer_mdl;\n\n\t// Fill stack data\n\n\tpStack = IoGetNextIrpStackLocation(pIrp);\n\n\tpStack->Parameters.Scsi.Srb = Allocate(sizeof(SCSI_REQUEST_BLOCK));\n\tRtlZeroMemory(pStack->Parameters.Scsi.Srb, sizeof(SCSI_REQUEST_BLOCK));\n\n\tpStack->MajorFunction = IRP_MJ_SCSI;\n\tpStack->Flags = SL_OVERRIDE_VERIFY_VOLUME;\n\n\t// Fill SRB\n\n\tpSrb = pStack->Parameters.Scsi.Srb;\n\n\tpSrb->Length = sizeof(SCSI_REQUEST_BLOCK);\n\tpSrb->QueueAction = SRB_SIMPLE_TAG_REQUEST;\n\tpSrb->CdbLength = 12;\n\tpSrb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER |\n\t\tSRB_FLAGS_ADAPTER_CACHE_ENABLE;\n\tpSrb->DataTransferLength = SECTOR * SectorsCount;\n\tpSrb->TimeOutValue = 1;\n\n\tpSrb->OriginalRequest = pIrp;\n\tpSrb->DataBuffer = read_buffer;\n\n\tpSrb->QueueSortKey = StartingSector;\n\tpSrb->InternalStatus = StartingSector;\n\n\t// Fill CDB\n\n\tpCdb = (PCDB)pSrb->Cdb;\n\n\t// SCSI command\n\tpCdb->READ_CD.OperationCode = SCSIOP_READ_CD;\n\n\t// Number of sectors to read\n\tpCdb->READ_CD.TransferBlocks[1] = HIBYTE(LOWORD(SectorsCount));\n\tpCdb->READ_CD.TransferBlocks[2] = LOBYTE(LOWORD(SectorsCount));\n\n\t// Starting sector number\n\tpCdb->READ_CD.StartingLBA[0] = HIBYTE(HIWORD(StartingSector));\n\tpCdb->READ_CD.StartingLBA[1] = LOBYTE(HIWORD(StartingSector));\n\tpCdb->READ_CD.StartingLBA[2] = HIBYTE(LOWORD(StartingSector));\n\tpCdb->READ_CD.StartingLBA[3] = LOBYTE(LOWORD(StartingSector));\n\n\t// On Audio CDs it is the only option,\n\t// since the whole 2352 bytes are the user data\n\tpCdb->READ_CD.IncludeUserData = (get_data ? 1 : 0);\n\n\t// '2' means block error byte + 1 pad byte + 294 bytes of C2 error codes\n\t// 'block error byte' is all C2 codes 'and'ed\n\tpCdb->READ_CD.ErrorFlags = (get_data ? 2 : 0);\n\n\t// '4' means raw P-W subchannel data (96 bytes)\n\t// Note: R-W channels are interleaved\n\tpCdb->READ_CD.SubChannelSelection = (get_subchannels ? 4 : 0);\n\n    return pIrp;\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS ReadCompletion\t(PDEVICE_OBJECT pDeviceObject, PIRP pNewIrp, PVOID context)", "code": "{\n\tPREAD_REQUEST pRead = (PREAD_REQUEST)context;\n\tUCHAR parts_num[255], i;\n\tPUCHAR AssemblingMatrix, TempMatrix;\n\tPUCHAR DecodeBuffer;\n\n\tPSCSI_REQUEST_BLOCK pSrb = IoGetCurrentIrpStackLocation(pNewIrp)->Parameters.Scsi.Srb;\n\n\t__asm int 3;\n\n\tif(NT_SUCCESS(pNewIrp->IoStatus.Status))\n\t{\n\t\tAssemblingMatrix = Allocate(pRead->k * pRead->k);\n\t\tTempMatrix = Allocate(pRead->k * pRead->k);\n\t\tDecodeBuffer = Allocate(RAW_LEN * pRead->k);\n\n\t\tfor(i=1; i<= pRead->k; i++) parts_num[i-1] = i;\n\n\t\tGFCreateAssemblingMatrix(AssemblingMatrix, TempMatrix, parts_num, pRead->k);\n\t\tGFAssembleSlices(DecodeBuffer, pRead->ReadBuffer,\n\t\t\tRAW_LEN, pRead->k, parts_num, AssemblingMatrix);\n\n\t\tRtlCopyMemory(pRead->SourceBuffer + pRead->CurrentLength,\n\t\t\tDecodeBuffer + pRead->ToRead[pRead->CurrentBlock].Offset,\n\t\t\tpRead->ToRead[pRead->CurrentBlock].Length);\n\n\t\t__asm int 3;\n\n\t\tFree(AssemblingMatrix);\n\t\tFree(TempMatrix);\n\t\tFree(DecodeBuffer);\n\n\t\tpRead->CurrentLength += pRead->ToRead[pRead->CurrentBlock].Length;\n\t\tpRead->CurrentBlock++;\n\n        if(pRead->CurrentBlock < pRead->BlocksNum)\n\t\t\tReadCurrentBase(pRead);\n\t\telse\n\t\t{\n\t\t\tpRead->pSourceSrb->SrbStatus = 1;\n            CompleteRequest(pRead->pSourceIrp, STATUS_SUCCESS,\n\t\t\t\tpRead->SectorsNum * SECTOR_LEN, TRUE);\n\n\t\t\tFreeBuffer(NULL, pRead->ReadBufferMdl);\n\t\t\tFreeIrp(pNewIrp);\n\t\t\tFree(pRead);\n\t\t}\n\t}\n\telse\n\t{\n\t\tCompleteRequest(pRead->pSourceIrp, STATUS_UNSUCCESSFUL, 0, TRUE);\n\n\t\tFreeBuffer(NULL, pRead->ReadBufferMdl);\n\t\tFreeIrp(pNewIrp);\n\t\tFree(pRead);\n\t}\n\n\treturn STATUS_MORE_PROCESSING_REQUIRED;\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "ULONG GetBaseOffset(PFORMATTING params, ULONG BlockNumber)", "code": "{\n\tULONG ZoneNumber, Offset;\n\n\tZoneNumber = BlockNumber / params->BlocksInBaseArea;\n\tOffset = (BlockNumber % params->BlocksInBaseArea) * params->k;\n\n\treturn ZoneNumber * params->SectorsInZone + Offset;\n}", "path": "nkcodec\\formatting.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS DispatchPnP(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)", "code": "{\n\tPIO_STACK_LOCATION pStack;\n\tULONG minor_func;\n\tNTSTATUS status;\n\tPDEVICE_EXTENSION pDeviceExtension;\n\n\tpStack = IoGetCurrentIrpStackLocation(pIrp);\n\tminor_func = pStack->MinorFunction;\n\tpDeviceExtension = (PDEVICE_EXTENSION)pDeviceObject->DeviceExtension;\n\n\t// enter critical section\n\tstatus = IoAcquireRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\n\t// if device is already removing - complete IRP\n\t// FIXME: we should release lock here\n\tif (status != STATUS_SUCCESS)\n\t\treturn CompleteRequest(pIrp, status, 0, FALSE);\n\n\t// notification that tells there are some special files on this device (swap files etc)\n\tif (minor_func == IRP_MN_DEVICE_USAGE_NOTIFICATION)\n\t{\n\t\t// if our driver is on the top of the stack or parent driver has DO_POWER_PAGABLE,\n\t\t// set this flag too\n\t\tif (!pDeviceObject->AttachedDevice ||\n\t\t\t(pDeviceObject->AttachedDevice->Flags & DO_POWER_PAGABLE))\n\t\t\tpDeviceObject->Flags |= DO_POWER_PAGABLE;\n\n\t\t// set completion function and pass request further\n\t\tIoCopyCurrentIrpStackLocationToNext(pIrp);\n\t\tIoSetCompletionRoutine(\tpIrp, UsageNotificationCompletion,\n\t\t\t\t\t\t\t\t(PVOID)pDeviceExtension, TRUE, TRUE, TRUE );\n\n\t\treturn IoCallDriver(pDeviceExtension->pNextDeviceObject, pIrp);\n\t}\n\n\t// starting notification\n\tif (minor_func == IRP_MN_START_DEVICE)\n\t{\n\t\t// set completion function and pass request further\n\t\tIoCopyCurrentIrpStackLocationToNext(pIrp);\n\t\tIoSetCompletionRoutine(\tpIrp, StartDeviceCompletion,\n\t\t\t\t\t\t\t\t(PVOID)pDeviceExtension, TRUE, TRUE, TRUE );\n\t\treturn IoCallDriver(pDeviceExtension->pNextDeviceObject, pIrp);\n\t}\n\n\t// device deletion notification\n\tif (minor_func == IRP_MN_REMOVE_DEVICE)\n\t{\n\t\t// pass request further\n\t\tIoSkipCurrentIrpStackLocation(pIrp);\n\t\tstatus = IoCallDriver(pDeviceExtension->pNextDeviceObject, pIrp);\n\n\t\t// release lock and wait for all IRPs completion\n\t\tIoReleaseRemoveLockAndWait(&pDeviceExtension->RemoveLock, pIrp);\n\n\t\t// remove device\n\t\tRemoveDevice(pDeviceObject);\n\t\treturn status;\n\t}\n\n\t// pass request further\n\tIoSkipCurrentIrpStackLocation(pIrp);\n\tstatus = IoCallDriver(pDeviceExtension->pNextDeviceObject, pIrp);\n\n\t// release lock\n\tIoReleaseRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\n\treturn status;\n}", "path": "nkfilter\\dispatch_pnp.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS DeductionCompletion(PDEVICE_OBJECT pDeviceObject, PIRP pNewIrp, PVOID context)", "code": "{\n\tPDETECTION_REQUEST pRequest = (PDETECTION_REQUEST)context;\n\t//\tPDEVICE_EXTENSION pDeviceExtension = ((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension));\n\t__asm int 3;\n\tpRequest->AttemptCounter++;\n\tif(NT_SUCCESS(pNewIrp->IoStatus.Status) && pRequest->AttemptCounter < pRequest->MaxAttempts &&\n\t\tpRequest->ReadBuffer[RAW_LEN] == 0)\n\t{\n\t\tint i;\n\t\tBOOLEAN first_bit;\n\t\tPCHAR pPSubchannel, pQSubchannel;\n\t\tULONG sector_num, n, k;\n\t\tULONG read_offset;\n\n\t\tDecodeSubchannelData(pRequest->ReadBuffer + RAW_LEN + ECC_LEN + 2);\n\t\tpPSubchannel = pRequest->ReadBuffer + RAW_LEN + ECC_LEN + 2;\n\t\tpQSubchannel = pPSubchannel + 12;\n\n\t\t__asm int 3;\n\n\t\t// Find change from ones to zeroes in first 12 bytes\n\t\tfirst_bit = ((pPSubchannel[0] & (1 << 7)) != 0);\n\t\tfor(i = 0; i < SUBCHANNELS_LEN; i++)\n\t\t{\n\t\t\tif(((pPSubchannel[i / 8] & (1 << (7 - i % 8))) != 0) != first_bit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(i > SUBCHANNELS_LEN / 2)\n\t\t{\n\t\t\tsector_num = *(PULONG)(pQSubchannel[i - 4]);\n\t\t\tn = pQSubchannel[i - 5];\n\t\t\tk = pQSubchannel[i - 6];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsector_num = *(PULONG)(pQSubchannel[i]);\n\t\t\tn = pQSubchannel[i + 5];\n\t\t\tk = pQSubchannel[i + 4];\n\t\t}\n\n\t\t//\tpDeviceExtension->K = (UCHAR)k;\n\t\t//\tpDeviceExtension->N = (UCHAR)n;\n\n\t\tStartReading(pDeviceObject, pRequest->pSourceIrp);\n\t}\n\telse\n\t{\n\t\tCompleteRequest(pRequest->pSourceIrp, STATUS_UNSUCCESSFUL, 0, TRUE);\n\n\t\tFreeBuffer(NULL, pRequest->ReadBufferMdl);\n\t\tFreeIrp(pNewIrp);\n\t\tFree(pRequest);\n\t}\n\n\treturn STATUS_MORE_PROCESSING_REQUIRED;\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS StartDeviceCompletion(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID context)", "code": "{\n\tPDEVICE_EXTENSION pDeviceExtension;\n\n\tpDeviceExtension = (PDEVICE_EXTENSION)context;\n\n\t// If IRP requires further handling, mark it accordingly\n\tif (pIrp->PendingReturned)\n\t\tIoMarkIrpPending(pIrp);\n\n\t// If child device has FILE_REMOVABLE_MEDIA set, set it too\n\tif (pDeviceExtension->pNextDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)\n\t\tpDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;\n\n\t// release lock, which we acquired in DispatchPnP()\n\tIoReleaseRemoveLock(&pDeviceExtension->RemoveLock, pIrp);\n\n\treturn STATUS_SUCCESS;\n}", "path": "nkfilter\\dispatch_pnp.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "NTSTATUS AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPhysicalDeviceObject)", "code": "{\n\tNTSTATUS\t\t\tstatus;\n\tPDEVICE_OBJECT\t\tpThisDeviceObject;\n\tPDEVICE_EXTENSION\tpDeviceExtension;\n\n\t// create device object\n\tstatus = IoCreateDevice(pDriverObject,\t\t\t\t// pointer to driver object\n\t\t\t\t\t\t\tsizeof(DEVICE_EXTENSION),\t//\n\t\t\t\t\t\t\tNULL,\t\t\t\t\t\t// pointer to driver name\n\t\t\t\t\t\t\tFILE_DEVICE_CD_ROM,\t\t\t// device type\n\t\t\t\t\t\t\t0,\t\t\t\t\t\t\t// device characteristics\n\t\t\t\t\t\t\tFALSE,\t\t\t\t\t\t// reserved\n\t\t\t\t\t\t\t&pThisDeviceObject);\t\t// pointer to device will be saved here\n\n\tif(!NT_SUCCESS(status))\n\t{\n\t\treturn status;\n\t}\n\n\t// fill DEVICE_EXTENSION\n\tpDeviceExtension = (PDEVICE_EXTENSION)pThisDeviceObject->DeviceExtension;\n\n\tIoInitializeRemoveLock(&pDeviceExtension->RemoveLock, 0, 0, 0);\n\n\tpDeviceExtension->pThisDeviceObject = pThisDeviceObject;\n\tpDeviceExtension->pPhysicalDeviceObject = pPhysicalDeviceObject;\n\tpDeviceExtension->pDriverObject = pDriverObject;\n\n\t// attach our filter to driver stack\n\tpDeviceExtension->pNextDeviceObject = IoAttachDeviceToDeviceStack(pThisDeviceObject, pPhysicalDeviceObject);\n\tif(pDeviceExtension->pNextDeviceObject == NULL)\n\t{\n\t\tIoDeleteDevice(pThisDeviceObject);\n\t\treturn STATUS_NO_SUCH_DEVICE;\n\t}\n\n\t// inherit some flags\n\tpThisDeviceObject->Flags |= pDeviceExtension->pNextDeviceObject->Flags &\n\t\t(DO_POWER_PAGABLE | DO_DIRECT_IO | DO_BUFFERED_IO);\n\n\t// finish initialization\n\tpThisDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;\n\n\treturn STATUS_SUCCESS;\n}", "path": "nkfilter\\dispatch_pnp.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID RemoveDevice(IN PDEVICE_OBJECT pDeviceObject)", "code": "{\n\tPDEVICE_EXTENSION pDeviceExtension;\n\n\tpDeviceExtension = (PDEVICE_EXTENSION)pDeviceObject->DeviceExtension;\n\n\t// detach device from stack\n\tif (pDeviceExtension->pNextDeviceObject)\n\t\tIoDetachDevice(pDeviceExtension->pNextDeviceObject);\n\n\t// delete device\n\tIoDeleteDevice(pDeviceObject);\n}", "path": "nkfilter\\dispatch_pnp.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "//\n", "func_signal": "VOID ReadNextSector(PDETECTION_REQUEST pRequest)", "code": "{\n\tPIRP pNewIrp;\n\n\t// TODO: generate random sector number each time\n\tpRequest->CurrentSector = 10;\n\tpNewIrp = CreateIrp(pRequest->pNextDevice->StackSize, pRequest->CurrentSector,\n\t\t1, pRequest->ReadBufferMdl, pRequest->ReadBuffer, TRUE, TRUE);\t\n\n\tIoSetCompletionRoutine(pNewIrp, DeductionCompletion, pRequest, TRUE, TRUE, TRUE);\n\tIoCallDriver(pRequest->pNextDevice, pNewIrp);\n}", "path": "nkfilter\\dispatch_scsi.c", "repo_name": "fjarri-attic/nk", "stars": 6, "license": "None", "language": "c", "size": 252}
{"docstring": "/* ac3 read */\n", "func_signal": "static int ac3_read_header(AVFormatContext *s,\n                           AVFormatParameters *ap)", "code": "{\n    AVStream *st;\n\n    st = av_new_stream(s, 0);\n    if (!st)\n        return AVERROR_NOMEM;\n\n    st->codec.codec_type = CODEC_TYPE_AUDIO;\n    st->codec.codec_id = CODEC_ID_AC3;\n    st->need_parsing = 1;\n    /* the parameters will be extracted from the compressed bitstream */\n    return 0;\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\raw.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*\n * Read some scanlines of data from the JPEG decompressor.\n *\n * The return value will be the number of lines actually read.\n * This may be less than the number requested in several cases,\n * including bottom of image, data source suspension, and operating\n * modes that emit multiple scanlines at a time.\n *\n * Note: we warn about excess calls to jpeg_read_scanlines() since\n * this likely signals an application programmer error.  However,\n * an oversize buffer (max_lines > scanlines remaining) is not an error.\n */\n", "func_signal": "GLOBAL(JDIMENSION)\njpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,\n\t\t     JDIMENSION max_lines)", "code": "{\n  JDIMENSION row_ctr;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n  }\n\n  /* Process some data */\n  row_ctr = 0;\n  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);\n  cinfo->output_scanline += row_ctr;\n  return row_ctr;\n}", "path": "plugins\\img\\jpeg\\jpeg\\jdapistd.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/**\n * Do a complex FFT with the parameters defined in ff_fft_init(). The\n * input data must be permuted before with s->revtab table. No\n * 1.0/sqrt(n) normalization is done.\n * AltiVec-enabled\n * This code assumes that the 'z' pointer is 16 bytes-aligned\n * It also assumes all FFTComplex are 8 bytes-aligned pair of float\n * The code is exactly the same as the SSE version, except\n * that successive MUL + ADD/SUB have been merged into\n * fused multiply-add ('vec_madd' in altivec)\n */\n", "func_signal": "void ff_fft_calc_altivec(FFTContext *s, FFTComplex *z)", "code": "{\nPOWERPC_PERF_DECLARE(altivec_fft_num, s->nbits >= 6);\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n    int ln = s->nbits;\n    int\tj, np, np2;\n    int\tnblocks, nloops;\n    register FFTComplex *p, *q;\n    FFTComplex *exptab = s->exptab;\n    int l;\n    FFTSample tmp_re, tmp_im;\n    \nPOWERPC_PERF_START_COUNT(altivec_fft_num, s->nbits >= 6);\n \n    np = 1 << ln;\n\n    /* pass 0 */\n\n    p=&z[0];\n    j=(np >> 1);\n    do {\n        BF(p[0].re, p[0].im, p[1].re, p[1].im, \n           p[0].re, p[0].im, p[1].re, p[1].im);\n        p+=2;\n    } while (--j != 0);\n\n    /* pass 1 */\n\n    \n    p=&z[0];\n    j=np >> 2;\n    if (s->inverse) {\n        do {\n            BF(p[0].re, p[0].im, p[2].re, p[2].im, \n               p[0].re, p[0].im, p[2].re, p[2].im);\n            BF(p[1].re, p[1].im, p[3].re, p[3].im, \n               p[1].re, p[1].im, -p[3].im, p[3].re);\n            p+=4;\n        } while (--j != 0);\n    } else {\n        do {\n            BF(p[0].re, p[0].im, p[2].re, p[2].im, \n               p[0].re, p[0].im, p[2].re, p[2].im);\n            BF(p[1].re, p[1].im, p[3].re, p[3].im, \n               p[1].re, p[1].im, p[3].im, -p[3].re);\n            p+=4;\n        } while (--j != 0);\n    }\n    /* pass 2 .. ln-1 */\n\n    nblocks = np >> 3;\n    nloops = 1 << 2;\n    np2 = np >> 1;\n    do {\n        p = z;\n        q = z + nloops;\n        for (j = 0; j < nblocks; ++j) {\n            BF(p->re, p->im, q->re, q->im,\n               p->re, p->im, q->re, q->im);\n            \n            p++;\n            q++;\n            for(l = nblocks; l < np2; l += nblocks) {\n                CMUL(tmp_re, tmp_im, exptab[l].re, exptab[l].im, q->re, q->im);\n                BF(p->re, p->im, q->re, q->im,\n                   p->re, p->im, tmp_re, tmp_im);\n                p++;\n                q++;\n            }\n\n            p += nloops;\n            q += nloops;\n        }\n        nblocks = nblocks >> 1;\n        nloops = nloops << 1;\n    } while (nblocks != 0);\n\nPOWERPC_PERF_STOP_COUNT(altivec_fft_num, s->nbits >= 6);\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n#ifdef CONFIG_DARWIN\n    register const vector float vczero = (const vector float)(0.);\n#else\n    register const vector float vczero = (const vector float){0.,0.,0.,0.};\n#endif\n    \n    int ln = s->nbits;\n    int\tj, np, np2;\n    int\tnblocks, nloops;\n    register FFTComplex *p, *q;\n    FFTComplex *cptr, *cptr1;\n    int k;\n\nPOWERPC_PERF_START_COUNT(altivec_fft_num, s->nbits >= 6);\n\n    np = 1 << ln;\n\n    {\n        vector float *r, a, b, a1, c1, c2;\n\n        r = (vector float *)&z[0];\n\n        c1 = vcii(p,p,n,n);\n        \n        if (s->inverse)\n            {\n                c2 = vcii(p,p,n,p);\n            }\n        else\n            {\n                c2 = vcii(p,p,p,n);\n            }\n        \n        j = (np >> 2);\n        do {\n            a = vec_ld(0, r);\n            a1 = vec_ld(sizeof(vector float), r);\n            \n            b = vec_perm(a,a,vcprmle(1,0,3,2));\n            a = vec_madd(a,c1,b);\n            /* do the pass 0 butterfly */\n            \n            b = vec_perm(a1,a1,vcprmle(1,0,3,2));\n            b = vec_madd(a1,c1,b);\n            /* do the pass 0 butterfly */\n            \n            /* multiply third by -i */\n            b = vec_perm(b,b,vcprmle(2,3,1,0));\n            \n            /* do the pass 1 butterfly */\n            vec_st(vec_madd(b,c2,a), 0, r);\n            vec_st(vec_nmsub(b,c2,a), sizeof(vector float), r);\n            \n            r += 2;\n        } while (--j != 0);\n    }\n    /* pass 2 .. ln-1 */\n\n    nblocks = np >> 3;\n    nloops = 1 << 2;\n    np2 = np >> 1;\n\n    cptr1 = s->exptab1;\n    do {\n        p = z;\n        q = z + nloops;\n        j = nblocks;\n        do {\n            cptr = cptr1;\n            k = nloops >> 1;\n            do {\n                vector float a,b,c,t1;\n\n                a = vec_ld(0, (float*)p);\n                b = vec_ld(0, (float*)q);\n                \n                /* complex mul */\n                c = vec_ld(0, (float*)cptr);\n                /*  cre*re cim*re */\n                t1 = vec_madd(c, vec_perm(b,b,vcprmle(2,2,0,0)),vczero);\n                c = vec_ld(sizeof(vector float), (float*)cptr);\n                /*  -cim*im cre*im */\n                b = vec_madd(c, vec_perm(b,b,vcprmle(3,3,1,1)),t1);\n                \n                /* butterfly */\n                vec_st(vec_add(a,b), 0, (float*)p);\n                vec_st(vec_sub(a,b), 0, (float*)q);\n                \n                p += 2;\n                q += 2;\n                cptr += 4;\n            } while (--k);\n            \n            p += nloops;\n            q += nloops;\n        } while (--j);\n        cptr1 += nloops * 2;\n        nblocks = nblocks >> 1;\n        nloops = nloops << 1;\n    } while (nblocks != 0);\n\nPOWERPC_PERF_STOP_COUNT(altivec_fft_num, s->nbits >= 6);\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavcodec\\ppc\\fft_altivec.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* mpeg1/h263 input */\n", "func_signal": "static int video_read_header(AVFormatContext *s,\n                             AVFormatParameters *ap)", "code": "{\n    AVStream *st;\n\n    st = av_new_stream(s, 0);\n    if (!st)\n        return AVERROR_NOMEM;\n\n    st->codec.codec_type = CODEC_TYPE_VIDEO;\n    st->codec.codec_id = s->iformat->value;\n    st->need_parsing = 1;\n\n    /* for mjpeg, specify frame rate */\n    /* for mpeg4 specify it too (most mpeg4 streams dont have the fixed_vop_rate set ...)*/\n    if (st->codec.codec_id == CODEC_ID_MJPEG || \n        st->codec.codec_id == CODEC_ID_MPEG4) {\n        if (ap && ap->frame_rate) {\n            st->codec.frame_rate      = ap->frame_rate;\n            st->codec.frame_rate_base = ap->frame_rate_base;\n        } else {\n            st->codec.frame_rate      = 25;\n            st->codec.frame_rate_base = 1;\n        }\n    }\n    return 0;\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\raw.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* called by the codec to allocate the image */\n", "func_signal": "static int jpeg_get_buffer(AVCodecContext *c, AVFrame *picture)", "code": "{\n    JpegOpaque *jctx = c->opaque;\n    AVImageInfo info1, *info = &info1;\n    int ret, i;\n\n    info->width = c->width;\n    info->height = c->height;\n    switch(c->pix_fmt) {\n    case PIX_FMT_YUV420P:\n        info->pix_fmt = PIX_FMT_YUVJ420P;\n        break;\n    case PIX_FMT_YUV422P:\n        info->pix_fmt = PIX_FMT_YUVJ422P;\n        break;\n    case PIX_FMT_YUV444P:\n        info->pix_fmt = PIX_FMT_YUVJ444P;\n        break;\n    default:\n        return -1;\n    }\n    ret = jctx->alloc_cb(jctx->opaque, info);\n    if (ret) {\n        jctx->ret_code = ret;\n        return -1;\n    } else {\n        for(i=0;i<3;i++) {\n            picture->data[i] = info->pict.data[i];\n            picture->linesize[i] = info->pict.linesize[i];\n        }\n        return 0;\n    }\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\jpeg.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* XXX: improve that by looking at several start codes */\n", "func_signal": "static int mpegvideo_probe(AVProbeData *p)", "code": "{\n    int code;\n    const uint8_t *d;\n\n    /* we search the first start code. If it is a sequence, gop or\n       picture start code then we decide it is an mpeg video\n       stream. We do not send highest value to give a chance to mpegts */\n    /* NOTE: the search range was restricted to avoid too many false\n       detections */\n\n    if (p->buf_size < 6)\n        return 0;\n    d = p->buf;\n    code = (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | (d[3]);\n    if ((code & 0xffffff00) == 0x100) {\n        if (code == SEQ_START_CODE ||\n            code == GOP_START_CODE ||\n            code == PICTURE_START_CODE)\n            return 50 - 1;\n        else\n            return 0;\n    }\n    return 0;\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\raw.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* infrastructure for finding fit */\n", "func_signal": "static long _f0_fit(codebook *book,\n\t\t    float *orig,\n\t\t    float *workfit,\n\t\t    int cursor)", "code": "{\n  int dim=book->dim;\n  float norm,base=0.f;\n  int i,best=0;\n  float *lsp=workfit+cursor;\n\n  if(cursor)base=workfit[cursor-1];\n  norm=orig[cursor+dim-1]-base;\n\n  for(i=0;i<dim;i++)\n    lsp[i]=(orig[i+cursor]-base);\n  best=_best(book,lsp,1);\n\n  memcpy(lsp,book->valuelist+best*dim,dim*sizeof(float));\n  for(i=0;i<dim;i++)\n    lsp[i]+=base;\n  return(best);\n}", "path": "plugins\\inp\\ogg\\vorbis\\floor0.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/***********************************************/\n", "func_signal": "static vorbis_info_floor *floor0_copy_info (vorbis_info_floor *i)", "code": "{\n  vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;\n  vorbis_info_floor0 *ret=_ogg_malloc(sizeof(vorbis_info_floor0));\n  memcpy(ret,info,sizeof(vorbis_info_floor0));\n  return(ret);\n}", "path": "plugins\\inp\\ogg\\vorbis\\floor0.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*------------- skip over n bits in bitstream -------------*/\n", "func_signal": "static void skip(MPEG *m, int n)", "code": "{\n   int k;\n\n   if (m->cup.bits < n)\n   {\n      n -= m->cup.bits;\n      k = n >> 3;\n/*--- bytes = n/8 --*/\n      m->cup.bs_ptr += k;\n      n -= k << 3;\n      m->cup.bitbuf = *m->cup.bs_ptr++;\n      m->cup.bits = 8;\n   }\n   m->cup.bits -= n;\n   m->cup.bitbuf -= (m->cup.bitbuf >> m->cup.bits) << m->cup.bits;\n}", "path": "plugins\\inp\\xing\\xingmp3\\cup.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*\n * Decompression initialization.\n * jpeg_read_header must be completed before calling this.\n *\n * If a multipass operating mode was selected, this will do all but the\n * last pass, and thus may take a great deal of time.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_start_decompress (j_decompress_ptr cinfo)", "code": "{\n  if (cinfo->global_state == DSTATE_READY) {\n    /* First call: initialize master control, select active modules */\n    jinit_master_decompress(cinfo);\n    if (cinfo->buffered_image) {\n      /* No more work here; expecting jpeg_start_output next */\n      cinfo->global_state = DSTATE_BUFIMAGE;\n      return TRUE;\n    }\n    cinfo->global_state = DSTATE_PRELOAD;\n  }\n  if (cinfo->global_state == DSTATE_PRELOAD) {\n    /* If file has multiple scans, absorb them all into the coef buffer */\n    if (cinfo->inputctl->has_multiple_scans) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n      for (;;) {\n\tint retcode;\n\t/* Call progress monitor hook if present */\n\tif (cinfo->progress != NULL)\n\t  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n\t/* Absorb some more input */\n\tretcode = (*cinfo->inputctl->consume_input) (cinfo);\n\tif (retcode == JPEG_SUSPENDED)\n\t  return FALSE;\n\tif (retcode == JPEG_REACHED_EOI)\n\t  break;\n\t/* Advance progress counter if appropriate */\n\tif (cinfo->progress != NULL &&\n\t    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {\n\t  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {\n\t    /* jdmaster underestimated number of scans; ratchet up one scan */\n\t    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;\n\t  }\n\t}\n      }\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n    }\n    cinfo->output_scan_number = cinfo->input_scan_number;\n  } else if (cinfo->global_state != DSTATE_PRESCAN)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Perform any dummy output passes, and set up for the final pass */\n  return output_pass_setup(cinfo);\n}", "path": "plugins\\img\\jpeg\\jpeg\\jdapistd.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*\n * Initialize for an output pass in buffered-image mode.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_start_output (j_decompress_ptr cinfo, int scan_number)", "code": "{\n  if (cinfo->global_state != DSTATE_BUFIMAGE &&\n      cinfo->global_state != DSTATE_PRESCAN)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Limit scan number to valid range */\n  if (scan_number <= 0)\n    scan_number = 1;\n  if (cinfo->inputctl->eoi_reached &&\n      scan_number > cinfo->input_scan_number)\n    scan_number = cinfo->input_scan_number;\n  cinfo->output_scan_number = scan_number;\n  /* Perform any dummy output passes, and set up for the real pass */\n  return output_pass_setup(cinfo);\n}", "path": "plugins\\img\\jpeg\\jpeg\\jdapistd.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* raw input */\n", "func_signal": "static int raw_read_header(AVFormatContext *s, AVFormatParameters *ap)", "code": "{\n    AVStream *st;\n    int id;\n\n    st = av_new_stream(s, 0);\n    if (!st)\n        return AVERROR_NOMEM;\n    if (ap) {\n        id = s->iformat->value;\n        if (id == CODEC_ID_RAWVIDEO) {\n            st->codec.codec_type = CODEC_TYPE_VIDEO;\n        } else {\n            st->codec.codec_type = CODEC_TYPE_AUDIO;\n        }\n        st->codec.codec_id = id;\n\n        switch(st->codec.codec_type) {\n        case CODEC_TYPE_AUDIO:\n            st->codec.sample_rate = ap->sample_rate;\n            st->codec.channels = ap->channels;\n            break;\n        case CODEC_TYPE_VIDEO:\n            st->codec.frame_rate      = ap->frame_rate;\n            st->codec.frame_rate_base = ap->frame_rate_base;\n            st->codec.width = ap->width;\n            st->codec.height = ap->height;\n\t    st->codec.pix_fmt = ap->pix_fmt;\n            break;\n        default:\n            return -1;\n        }\n    } else {\n        return -1;\n    }\n    return 0;\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\raw.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "//CONFIG_ENCODERS\n", "func_signal": "static int adx_probe(AVProbeData *p)", "code": "{\n    if (is_adx(p->buf,p->buf_size))\n        return 100;\n    return 0;\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\raw.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* less efficient than the decode side (written for clarity).  We're\n   not bottlenecked here anyway */\n", "func_signal": "float _curve_to_lpc(float *curve,float *lpc,\n\t\t     vorbis_look_floor0 *l)", "code": "{\n  /* map the input curve to a bark-scale curve for encoding */\n  \n  int mapped=l->ln;\n  float *work=alloca(sizeof(float)*mapped);\n  int i,j,last=0;\n  int bark=0;\n  static int seq=0;\n\n  memset(work,0,sizeof(float)*mapped);\n  \n  /* Only the decode side is behavior-specced; for now in the encoder,\n     we select the maximum value of each band as representative (this\n     helps make sure peaks don't go out of range.  In error terms,\n     selecting min would make more sense, but the codebook is trained\n     numerically, so we don't actually lose.  We'd still want to\n     use the original curve for error and noise estimation */\n  \n  for(i=0;i<l->n;i++){\n    bark=l->linearmap[i];\n    if(work[bark]<curve[i])work[bark]=curve[i];\n    if(bark>last+1){\n      /* If the bark scale is climbing rapidly, some bins may end up\n         going unused.  This isn't a waste actually; it keeps the\n         scale resolution even so that the LPC generator has an easy\n         time.  However, if we leave the bins empty we lose energy.\n         So, fill 'em in.  The decoder does not do anything with  he\n         unused bins, so we can fill them anyway we like to end up\n         with a better spectral curve */\n\n      /* we'll always have a bin zero, so we don't need to guard init */\n      long span=bark-last;\n      for(j=1;j<span;j++){\n\tfloat del=(float)j/span;\n\twork[j+last]=work[bark]*del+work[last]*(1.f-del);\n      }\n    }\n    last=bark;\n  }\n\n  /* If we're over-ranged to avoid edge effects, fill in the end of spectrum gap */\n  for(i=bark+1;i<mapped;i++)\n    work[i]=work[i-1];\n\n\n  /**********************/\n\n  for(i=0;i<l->n;i++)\n    curve[i]-=150;\n\n  _analysis_output(\"barkfloor\",seq,work,bark,0,0);\n  _analysis_output(\"barkcurve\",seq++,curve,l->n,1,0);\n\n  for(i=0;i<l->n;i++)\n    curve[i]+=150;\n\n  /**********************/\n  \n  return vorbis_lpc_from_curve(work,lpc,&(l->lpclook));\n}", "path": "plugins\\inp\\ogg\\vorbis\\floor0.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*========== Loader code */\n", "func_signal": "BOOL S69_Test(void)", "code": "{\n\tUBYTE buf[0x80];\n\n\tif(!_mm_read_UBYTES(buf,2,modreader))\n\t\treturn 0;\n\t/* look for id */\n\tif(!memcmp(buf,\"if\",2) || !memcmp(buf,\"JN\",2)) {\n\t\tint i;\n\n\t\t/* skip song message */\n\t\t_mm_fseek(modreader,108,SEEK_CUR);\n\t\t/* sanity checks */\n\t\tif(_mm_read_UBYTE(modreader) > 64) return 0;\n\t\tif(_mm_read_UBYTE(modreader) > 128) return 0;\n\t\tif(_mm_read_UBYTE(modreader) > 127) return 0;\n\t\t/* check order table */\n\t\tif(!_mm_read_UBYTES(buf,0x80,modreader)) return 0;\n\t\tfor(i=0;i<0x80;i++)\n\t\t\tif((buf[i]>=0x80)&&(buf[i]!=0xff)) return 0;\n\t\t/* check tempos table */\n\t\tif(!_mm_read_UBYTES(buf,0x80,modreader)) return 0;\n\t\tfor(i=0;i<0x80;i++)\n\t\t\tif((!buf[i])||(buf[i]>32)) return 0;\n\t\t/* check pattern length table */\n\t\tif(!_mm_read_UBYTES(buf,0x80,modreader)) return 0;\n\t\tfor(i=0;i<0x80;i++)\n\t\t\tif(buf[i]>0x3f) return 0;\n\t} else\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "plugins\\inp\\mikmod\\mikmod\\loaders\\load_669.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/**\n * Initialize libavcodec and register all the codecs and formats.\n */\n", "func_signal": "void av_register_all(void)", "code": "{\n    avcodec_init();\n    avcodec_register_all();\n\n    mpegps_init();\n    mpegts_init();\n#ifdef CONFIG_ENCODERS\n    crc_init();\n    img_init();\n#endif //CONFIG_ENCODERS\n    raw_init();\n    mp3_init();\n    rm_init();\n#ifdef CONFIG_RISKY\n    asf_init();\n#endif\n#ifdef CONFIG_ENCODERS\n    avienc_init();\n#endif //CONFIG_ENCODERS\n    avidec_init();\n    ff_wav_init();\n    swf_init();\n    au_init();\n#ifdef CONFIG_ENCODERS\n    gif_init();\n#endif //CONFIG_ENCODERS\n    mov_init();\n#ifdef CONFIG_ENCODERS\n    movenc_init();\n    jpeg_init();\n#endif //CONFIG_ENCODERS\n    ff_dv_init();\n    fourxm_init();\n#ifdef CONFIG_ENCODERS\n    flvenc_init();\n#endif //CONFIG_ENCODERS\n    flvdec_init();\n    str_init();\n    roq_init();\n    ipmovie_init();\n    wc3_init();\n    westwood_init();\n    film_init();\n    idcin_init();\n    flic_init();\n    vmd_init();\n\n#if defined(AMR_NB) || defined(AMR_NB_FIXED) || defined(AMR_WB)\n    amr_init();\n#endif\n    yuv4mpeg_init();\n    \n#ifdef CONFIG_VORBIS\n    ogg_init();\n#endif\n\n#ifndef CONFIG_WIN32\n    ffm_init();\n#endif\n#ifdef CONFIG_VIDEO4LINUX\n    video_grab_init();\n#endif\n#if defined(CONFIG_AUDIO_OSS) || defined(CONFIG_AUDIO_BEOS)\n    audio_init();\n#endif\n\n#ifdef CONFIG_DV1394\n    dv1394_init();\n#endif\n\n    nut_init();\n    matroska_init();\n\n#ifdef CONFIG_ENCODERS\n    /* image formats */\n    av_register_image_format(&pnm_image_format);\n    av_register_image_format(&pbm_image_format);\n    av_register_image_format(&pgm_image_format);\n    av_register_image_format(&ppm_image_format);\n    av_register_image_format(&pam_image_format);\n    av_register_image_format(&pgmyuv_image_format);\n    av_register_image_format(&yuv_image_format);\n#ifdef CONFIG_ZLIB\n    av_register_image_format(&png_image_format);\n#endif\n    av_register_image_format(&jpeg_image_format);\n    av_register_image_format(&gif_image_format);\n    av_register_image_format(&sgi_image_format);\n#endif //CONFIG_ENCODERS\n\n    /* file protocols */\n    register_protocol(&file_protocol);\n    register_protocol(&pipe_protocol);\n#ifdef CONFIG_NETWORK\n    rtsp_init();\n    rtp_init();\n    register_protocol(&udp_protocol);\n    register_protocol(&rtp_protocol);\n    register_protocol(&tcp_protocol);\n    register_protocol(&http_protocol);\n#endif\n}", "path": "plugins\\inp\\ffmpeg\\ffmpeg\\libavformat\\allformats.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*\n * Finish up after an output pass in buffered-image mode.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_finish_output (j_decompress_ptr cinfo)", "code": "{\n  if ((cinfo->global_state == DSTATE_SCANNING ||\n       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {\n    /* Terminate this pass. */\n    /* We do not require the whole pass to have been completed. */\n    (*cinfo->master->finish_output_pass) (cinfo);\n    cinfo->global_state = DSTATE_BUFPOST;\n  } else if (cinfo->global_state != DSTATE_BUFPOST) {\n    /* BUFPOST = repeat call after a suspension, anything else is error */\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  /* Read markers looking for SOS or EOI */\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\n\t ! cinfo->inputctl->eoi_reached) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return FALSE;\t\t/* Suspend, come back later */\n  }\n  cinfo->global_state = DSTATE_BUFIMAGE;\n  return TRUE;\n}", "path": "plugins\\img\\jpeg\\jpeg\\jdapistd.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*\n * Alternate entry point to read raw data.\n * Processes exactly one iMCU row per call, unless suspended.\n */\n", "func_signal": "GLOBAL(JDIMENSION)\njpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,\n\t\t    JDIMENSION max_lines)", "code": "{\n  JDIMENSION lines_per_iMCU_row;\n\n  if (cinfo->global_state != DSTATE_RAW_OK)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long) cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long) cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);\n  }\n\n  /* Verify that at least one iMCU row can be returned. */\n  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;\n  if (max_lines < lines_per_iMCU_row)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* Decompress directly into user's buffer. */\n  if (! (*cinfo->coef->decompress_data) (cinfo, data))\n    return 0;\t\t\t/* suspension forced, can do nothing more */\n\n  /* OK, we processed one iMCU row. */\n  cinfo->output_scanline += lines_per_iMCU_row;\n  return lines_per_iMCU_row;\n}", "path": "plugins\\img\\jpeg\\jpeg\\jdapistd.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*-------------------------------------------------------------------------*/\n", "func_signal": "IN_OUT L2audio_decode(void *mv, unsigned char *bs, signed short *pcm)", "code": "{\n   MPEG *m = mv;\n   int sync, prot;\n   IN_OUT in_out;\n\n   load_init(m, bs);\t\t/* initialize bit getter */\n/* test sync */\n   in_out.in_bytes = 0;\t\t/* assume fail */\n   in_out.out_bytes = 0;\n   sync = load(m,12);\n   if (sync != 0xFFF)\n      return in_out;\t\t/* sync fail */\n\n   load(m,3);\t\t\t/* skip id and option (checked by init) */\n   prot = load(m,1);\t\t/* load prot bit */\n   load(m,6);\t\t\t/* skip to pad */\n   m->cup.pad = load(m,1);\n   load(m,1);\t\t\t/* skip to mode */\n   m->cup.stereo_sb = look_joint[load(m,4)];\n   if (prot)\n      load(m,4);\t\t\t/* skip to data */\n   else\n      load(m,20);\t\t\t/* skip crc */\n\n   unpack_ba(m);\t\t\t/* unpack bit allocation */\n   unpack_sfs(m);\t\t/* unpack scale factor selectors */\n   unpack_sf(m);\t\t\t/* unpack scale factor */\n   unpack_samp(m);\t\t/* unpack samples */\n\n   m->cup.sbt(m, m->cup.sample, pcm, 36);\n/*-----------*/\n   in_out.in_bytes = m->cup.framebytes + m->cup.pad;\n   in_out.out_bytes = m->cup.outbytes;\n\n   return in_out;\n}", "path": "plugins\\inp\\xing\\xingmp3\\cup.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/*------------- get n bits from bitstream -------------*/\n", "func_signal": "static long load(MPEG *m, int n)", "code": "{\n   unsigned long x;\n\n   if (m->cup.bits < n)\n   {\t\t\t\t/* refill bit buf if necessary */\n      while (m->cup.bits <= 24)\n      {\n\t m->cup.bitbuf = (m->cup.bitbuf << 8) | *m->cup.bs_ptr++;\n\t m->cup.bits += 8;\n      }\n   }\n   m->cup.bits -= n;\n   x = m->cup.bitbuf >> m->cup.bits;\n   m->cup.bitbuf -= x << m->cup.bits;\n   return x;\n}", "path": "plugins\\inp\\xing\\xingmp3\\cup.c", "repo_name": "zig/dcplaya", "stars": 5, "license": "None", "language": "c", "size": 6452}
{"docstring": "/* program FPGA on PCI board 'devnum', with data from bitfile chunk 'ch' */\n", "func_signal": "static int program_5i20_fpga(struct board_info *bd, struct bitfile_chunk *ch)", "code": "{\n    int ctrl_region, data_region, count;\n    __u32 status, control;\n    __u8 *dp;\n\n    printf(\"Opening PCI regions...\\n\");\n    /* open regions for access */\n    ctrl_region = upci_open_region(bd->io.pci.upci_devnum, 1);\n    if ( ctrl_region < 0 ) {\n\terrmsg(__func__, \"could not open device %d, region %d (5i20 control port)\",\n\t    bd->io.pci.upci_devnum, 1 );\n\tgoto cleanup0;\n    }\n    data_region = upci_open_region(bd->io.pci.upci_devnum, 2);\n    if ( data_region < 0 ) {\n\terrmsg(__func__, \"could not open device %d, region %d (5i20 data port)\",\n\t    bd->io.pci.upci_devnum, 2 );\n\tgoto cleanup1;\n    }\n\n\n    //\n    // fix up LASxBRD READY if needed\n    //\n    {\n        int offsets[] = { LAS0BRD_OFFSET, LAS1BRD_OFFSET, LAS2BRD_OFFSET, LAS3BRD_OFFSET };\n        int i;\n\n        printf(\"checking #READY in EEPROM:\\n\" );\n\n        for (i = 0; i < 4; i ++) {\n            __u32 val;\n            int offset = offsets[i];\n\n            val = upci_read_u32(ctrl_region, offset);\n            printf(\"    LAS%dBRD (0x%04x): 0x%08x\", i, offset, val);\n            if (val & LASxBRD_READY) {\n                printf(\" ok\\n\");\n            } else {\n                printf(\"    *** #READY is OFF, i'll fix it for you just this once but you should upgrade your ancient EEPROM\\n\");\n                val |= LASxBRD_READY;\n                upci_write_u32(ctrl_region, offset, val);\n            }\n        }\n    }\n\n\n    printf(\"Resetting FPGA...\\n\" );\n    /* read current state of register */\n    status = upci_read_u32(ctrl_region, CTRL_STAT_OFFSET);\n    /* set /PROGRAM bit low  to reset device */\n    control = status & ~_PROGRAM_MASK;\n    /* set /WRITE and /LED high, (idle state) */\n    control |= _WRITE_MASK | _LED_MASK;\n    /* and write it back */\n    upci_write_u32(ctrl_region, CTRL_STAT_OFFSET, control);\n    /* verify that /INIT and DONE went low */\n    status = upci_read_u32(ctrl_region, CTRL_STAT_OFFSET);\n    if ( status & (DONE_MASK | _INIT_MASK) ) {\n\terrmsg(__func__, \"FPGA did not reset: /INIT = %d, DONE = %d\",\n\t    (status & _INIT_MASK ? 1 : 0), (status & DONE_MASK ? 1 : 0) );\n\tgoto cleanup2;\n    }\n    /* set /PROGRAM high, let FPGA come out of reset */\n    control = status | _PROGRAM_MASK;\n    upci_write_u32(ctrl_region, CTRL_STAT_OFFSET, control);\n    /* wait for /INIT to go high when it finishes clearing memory\n\tThis should take no more than 100uS.  If we assume each PCI read\n\ttakes 30nS (one PCI clock), that is 3300 reads.  Reads actually\n\ttake several clocks, but even at a microsecond each, 3.3mS is not\n\tan excessive timeout value */\n    count = 3300;\n    do {\n\tstatus = upci_read_u32(ctrl_region, CTRL_STAT_OFFSET);\n\tif ( status & _INIT_MASK ) break;\n    } while ( --count > 0 );\n    if ( count == 0 ) {\n\terrmsg(__func__, \"FPGA did not come out of /INIT\" );\n\tgoto cleanup3;\n    }\n    /* set /WRITE low for data transfer, and turn on LED */\n    control = status & ~_WRITE_MASK & ~_LED_MASK;\n    upci_write_u32(ctrl_region, CTRL_STAT_OFFSET, control);\n\n    /* Program the card */\n    count = ch->len;\n    dp = ch->body;\n    printf(\"Writing data to FPGA....\\n\" );\n    while ( count-- > 0 ) {\n\tupci_write_u8(data_region, 0, bit_reverse(*(dp++)));\n    }\n    /* all bytes transferred, clear \"bytes to go\" indicator */\n    printf(\"Data transfer complete...\\n\");\n    status = upci_read_u32(ctrl_region, CTRL_STAT_OFFSET);\n    if ( ! (status & _INIT_MASK) ) {\n\t/* /INIT goes low on CRC error */\n\terrmsg(__func__, \"FPGA asserted /INIT: CRC error\" );\n\tgoto cleanup3;\n    }\n    if ( ! (status & DONE_MASK) ) {\n\terrmsg(__func__, \"FPGA did not assert DONE\" );\n\tgoto cleanup3;\n    }\n    /* turn off write enable and LED */\n    control = status | _WRITE_MASK | _LED_MASK;\n    upci_write_u32(ctrl_region, CTRL_STAT_OFFSET, control);\n    printf(\"Successfully programmed %u bytes\\n\", ch->len);\n    return 0;\ncleanup3:\n    /* set /PROGRAM low (reset device), /WRITE high and LED off */\n    status = upci_read_u32(ctrl_region, CTRL_STAT_OFFSET);\n    control = status & ~_PROGRAM_MASK;\n    control |= _WRITE_MASK | _LED_MASK;\n    upci_write_u32(ctrl_region, CTRL_STAT_OFFSET, control);\ncleanup2:\n    upci_close_region(data_region);\ncleanup1:\n    upci_close_region(ctrl_region);\ncleanup0:\n    return -1;\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/* TODO: Add support for Modbus/UDP. TCP sucks for a such serial protocol ! ;-) */\n", "func_signal": "void InitSocketServer( int UseUdpMode, int PortNbr )", "code": "{\n\n\tint Error = 0;\n#ifdef __WIN32__\n\tWORD wVersionRequested = MAKEWORD(1,1);       // Stuff for WSA functions\n\tWSADATA wsaData;                              // Stuff for WSA functions\n\t// This stuff initializes winsock\n\tWSAStartup(wVersionRequested, &wsaData);\n#else\n\t// to not receive \"Broken pipe\" exception \n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n        if( ModbusDebugLevel>=2 ){   printf(\"INFO CLASSICLADDER--- INIT SOCKET!!!\\n\");  }\t\n\t// Create a socket\n\tserver_s = socket(AF_INET, SOCK_STREAM, 0);\n\tif ( server_s==SOCK_INVALID )\n\t{\n\t\tprintf(\"ERROR CLASSICLADDER--- Failed to open socket server...\\n\");\n\t}\n\telse\n\t{\n\t\tSocketOpened = 1;\n\t\t// Fill-in my socket's address information and bind the socket\n\t\tserver_addr.sin_family = AF_INET;\n\t\tserver_addr.sin_port = htons( PortNbr );\n\t\tserver_addr.sin_addr.s_addr = htonl( INADDR_ANY );\n\t\tError = bind(server_s, (struct sockaddr *)&server_addr, sizeof(server_addr));\n\t\tif ( Error==SOCK_INVALID )\n\t\t{\n\t\t\tprintf(\"ERROR CLASSICLADDER--- Failed to bind socket server...(error=%s)\\n\", strerror(errno));\n\t\t\tCloseSocketServer( );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Listen for connections and then accept\n\t\t\tError = listen(server_s, 1);\n\t\t\tif ( Error==SOCK_INVALID )\n\t\t\t{\n\t\t\t\tprintf(\"ERROR CLASSICLADDER--- Failed to listen socket server...(error=%s)\\n\", strerror(errno));\n\t\t\t\tCloseSocketServer( );\n\t\t\t}\n\t\t\telse\n\t\t\t{     \n                                SocketRunning = 1;\t\t\n#ifdef __WIN32__\n\t\t\t\tThreadHandle = CreateThread( NULL/*no security attributes*/, 16*1024L/*default stack size*/,                                                   \n\t\t\t\t\t(LPTHREAD_START_ROUTINE)SocketServerTcpMainLoop/* thread function*/, \n\t\t\t\t\tNULL/*argument to thread function*/,                \n\t\t\t\t\tTHREAD_QUERY_INFORMATION/*use default creation flags*/,                           \n\t\t\t\t\t&ThreadId/* returns the thread identifier*/);                \n\t  \t\t\tif ( ThreadHandle==NULL )\n#else\n\t\t\t\tError = pthread_create( &thread_socket_server, NULL, (void *(*)(void *))SocketServerTcpMainLoop, (void *)NULL );\n\t\t\t\tif (Error)\n#endif\n\t\t\t\t{\n\t\t\t\t\tprintf(\"ERROR CLASSICLADDER--- Failed to create thread socket server...\\n\");\n\t\t\t\t\tCloseSocketServer( );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{       SocketRunning = 1;\n\t\t\t\t\tprintf(\"INFO CLASSICLADDER--- Server socket init ok (modbus - port %d)!\\n\", PortNbr);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\n\t}\n}", "path": "src\\hal\\classicladder\\socket_server.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/*\n  LS7166Read() - reads one channel\n*/\n", "func_signal": "long LS7166Read(int i)", "code": "{\n  union pos_tag {\n    long l;\n    struct byte_tag { char b0; char b1; char b2; char b3;} byte;\n  } pos;\n\n  rtapi_outb(CTRL(i), 0x03);\n  pos.byte.b0=rtapi_inb(DATA(i));\n  pos.byte.b1=rtapi_inb(DATA(i));\n  pos.byte.b2=rtapi_inb(DATA(i));\n  if (pos.byte.b2 < 0) {\n    pos.byte.b3 = -1;\n  }\n  else {\n    pos.byte.b3 = 0;\n  }\n  return pos.l;\n}", "path": "src\\hal\\drivers\\hal_tiro.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/***********************************************************************\n*                  REALTIME PORT READ AND WRITE FUNCTIONS              *\n************************************************************************/\n", "func_signal": "static void split_input(unsigned char data, io_pin_t *dest, int num)", "code": "{\n    int b;\n    unsigned char mask;\n\n    /* splits a byte into 'num' HAL pins (and their NOTs) */\n    mask = 0x01;\n    for (b = 0 ; b < num ; b++ ) {\n\tif ( data & mask ) {\n\t    /* input high, which means FALSE (active low) */\n\t    *(dest->data) = 0;\n\t    *(dest->io.not) = 1;\n\t} else {\n\t    /* input low, which means TRUE */\n\t    *(dest->data) = 1;\n\t    *(dest->io.not) = 0;\n\t}\n\tmask <<= 1;\n\tdest++;\n    }\n}", "path": "src\\hal\\drivers\\hal_ax5214h.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/* the fpga was originally designed to be programmed serially... even\n   though we are doing it using a parallel interface, the bit ordering\n   is based on the serial interface, and the data needs to be reversed\n*/\n", "func_signal": "static __u8 bit_reverse (__u8 data)", "code": "{\n    static const __u8 swaptab[256] = {\n\t0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,\n\t0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,\n\t0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,\n\t0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,\n\t0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,\n\t0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,\n\t0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,\n\t0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,\n\t0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,\n\t0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,\n\t0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,\n\t0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,\n\t0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,\n\t0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,\n\t0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,\n\t0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF };\n\n    return swaptab[data];\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/************************************************************************/\n", "func_signal": "static void errmsg(const char *funct, const char *fmt, ...)", "code": "{\n    va_list vp;\n\n    va_start(vp, fmt);\n    fprintf(stderr, \"ERROR in %s(): \", funct);\n    vfprintf(stderr, fmt, vp);\n    fprintf(stderr, \"\\n\");\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/***********************************************************************\n*                      BOARD SPECIFIC FUNCTIONS                        *\n************************************************************************/\n/*\n  LS7166Init() - Initializes the channel\n*/\n", "func_signal": "int LS7166Init(int ch)", "code": "{\n\trtapi_outb(CTRL(ch), 0x49);\n\trtapi_outb(CTRL(ch), 0xC3);\n\trtapi_outb(CTRL(ch), 0x80);\n\treturn 0;\n}", "path": "src\\hal\\drivers\\hal_tiro.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// FIXME: the static automatic string makes this function non-reentrant\n", "func_signal": "static const char* hm2_get_pin_secondary_name(hm2_pin_t *pin)", "code": "{\n    static char unknown[100];\n    int sec_pin = pin->sec_pin & 0x3F;  // turn off the \"pin is an output\" bit and \"applies to all instances\" bit\n\n    switch (pin->sec_tag) {\n\n        case HM2_GTAG_ENCODER:\n            switch (sec_pin) {\n                case 1: return \"A\";\n                case 2: return \"B\";\n                case 3: return \"Index\";\n                case 4: return \"IndexMask\";\n                case 0x45:\n                case 5: return \"Probe\";\n            }\n            break;\n\n        case HM2_GTAG_PWMGEN:\n            // FIXME: these depend on the pwmgen mode\n            switch (sec_pin) {\n                case 1: return \"Out0 (PWM or Up)\";\n                case 2: return \"Out1 (Dir or Down)\";\n                case 3: return \"Not-Enable\";\n            }\n            break;\n\n        case HM2_GTAG_STEPGEN:\n            // FIXME: these depend on the stepgen mode\n            switch (sec_pin) {\n                case 1: return \"Step\";\n                case 2: return \"Direction\";\n                case 3: return \"(unused)\";\n                case 4: return \"(unused)\";\n                case 5: return \"(unused)\";\n                case 6: return \"(unused)\";\n            }\n            break;\n\n    }\n\n    rtapi_snprintf(unknown, sizeof(unknown), \"unknown-pin-%d\", sec_pin & 0x7F);\n    return unknown;\n}", "path": "src\\hal\\drivers\\mesa-hostmot2\\pins.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// try to execute a programming command: CardType[:CardID]=FileName\n", "func_signal": "int parse_program_command(char *cmd)", "code": "{\n    char *filename;\n\n    char *device_type;\n    char *device_id;\n\n    struct stat stat_buf;\n    int r;\n\n    // first parse out the filename\n    filename = strchr(cmd, '=');\n    if (filename == NULL) {\n        errmsg(__func__, \"error parsing program command '%s'\\n\", cmd);\n        return EC_BADCL;\n    }\n\n    *filename = '\\0';\n    filename ++;\n\n    r = stat(filename, &stat_buf);\n    if (r != 0) {\n        errmsg(__func__, \"error stating '%s': %s\\n\", filename, strerror(errno));\n        return EC_BADCL;\n    }\n\n\n    // parse out the device id\n    device_id = strchr(cmd, ':');\n    if (device_id != NULL) {\n        *device_id = '\\0';\n        device_id ++;\n        if (*device_id == '\\0') {\n            device_id = NULL;\n        }\n    }\n\n    device_type = cmd;\n    if (*device_type == '\\0') {\n        errmsg(__func__, \"no device type specified\\n\");\n        return EC_BADCL;\n    }\n\n    return program(device_type, device_id, filename);\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// returns TRUE if the FPGA reset, FALSE on error\n", "func_signal": "static int m7i43_cpld_reset(struct board_info *board)", "code": "{\n    uint8_t byte;\n\n    // select the control register\n    epp_addr8(&board->io.epp, 1);\n\n    // bring the Spartan3's PROG_B line low for 1 us (the specs require 300-500 ns or longer)\n    epp_write(&board->io.epp, 0x00);\n    usleep(1);\n\n    // bring the Spartan3's PROG_B line high and wait for 2 ms before sending firmware (required by spec)\n    epp_write(&board->io.epp, 0x01);\n    usleep(2 * 1000);\n\n    // make sure the FPGA is not asserting its DONE bit\n    byte = epp_read(&board->io.epp);\n    if ((byte & 0x01) != 0) {\n        printf(\"error: DONE is not low after CPLD reset!\\n\");\n        return 0;\n    }\n\n    return 1;\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// NOTE: can only list PCI devices, no EPP devices\n", "func_signal": "void list_devices(void)", "code": "{\n    int r;\n    int pci_index;\n\n    int num_pci_devices;\n    int num_boards;\n\n    r = upci_scan_bus();\n    if (r < 0) {\n        errmsg(__func__,\"upci error scanning bus\");\n        exit(EC_SYS);\n    }\n\n    num_pci_devices = r;\n    num_boards = sizeof(board_info_table) / sizeof(struct board_info);\n\n    for (pci_index = 0; pci_index < num_pci_devices; pci_index ++) {\n        struct upci_dev_info p;\n        int board_index;\n\n        upci_get_device_info(&p, pci_index);\n\n        // see if this pci device is in the board table\n        for (board_index = 0; board_index < num_boards; board_index ++) {\n            struct board_info *board = &board_info_table[board_index];\n\n            if (board->io_type != IO_TYPE_PCI) continue;\n            if (board->io.pci.vendor_id != p.vendor_id) continue;\n            if (board->io.pci.device_id != p.device_id) continue;\n            if (board->io.pci.ss_vendor_id != p.ss_vendor_id) continue;\n            if (board->io.pci.ss_device_id != p.ss_device_id) continue;\n\n            printf(\"%s at PCI %02x:%02x.%x\\n\", board->board_type, p.bus, p.dev, p.func);\n        }\n    }\n\n    exit(EC_OK);\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// all pins whose secondary_tag == gtag and whose\n// secondary_unit < num_instances get their source set to secondary and\n// their pin direction updated to match\n", "func_signal": "static void hm2_pins_allocate_all(hostmot2_t *hm2, int gtag, int num_instances)", "code": "{\n    int i;\n\n    for (i = 0; i < hm2->num_pins; i ++) {\n        if ((hm2->pin[i].sec_tag == gtag)\n            && ((hm2->pin[i].sec_unit < num_instances)\n                || ((hm2->pin[i].sec_unit & 0x80) && (num_instances > 0)))\n        ) {\n            hm2_set_pin_source(hm2, i, HM2_PIN_SOURCE_IS_SECONDARY);\n            if (hm2->pin[i].sec_pin & 0x80){\n                hm2_set_pin_direction(hm2, i, HM2_PIN_DIR_IS_OUTPUT);\n            }\n        }\n    }\n}", "path": "src\\hal\\drivers\\mesa-hostmot2\\pins.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/***********************************************************************/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    /* if we are setuid, drop privs until needed */\n    seteuid(getuid());\n\n\n    if (argc != 2) {\n        usage();\n        exit(EC_BADCL);\n    }\n\n    if (strcmp(argv[1], \"list\") == 0) {\n        list_devices();\n        exit(EC_OK);\n    }\n\n    if (strcmp(argv[1], \"help\") == 0) {\n        usage();\n        exit(EC_OK);\n    }\n\n    return parse_program_command(argv[1]);\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/***********************************************************************\n*            REALTIME ENCODER COUNTING AND UPDATE FUNCTIONS            *\n************************************************************************/\n", "func_signal": "static void capture(void *arg, long period)", "code": "{\n    counter_t *cntr;\n    int n;\n\n    cntr = arg;\n    for (n = 0; n < num_chan; n++) {\n\n\t/* capture raw counts to latches */\n\t*(cntr->count) = LS7166Read(n);\n\t/* scale count to make floating point position */\n\t*(cntr->pos) = *(cntr->count) * cntr->pos_scale;\n\t/* move on to next channel */\n\tcntr++;\n    }\n    /* done */\n}", "path": "src\\hal\\drivers\\hal_tiro.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/* remove semaphore from OS-- this must be done *before* sem_close,\n   since rcs_sem_close frees the storage allocated for the rcs_sem_t */\n", "func_signal": "int rcs_sem_destroy(rcs_sem_t * sem)", "code": "{\n    /* remove OS semaphore */\n    if (semctl(*sem, 0, IPC_RMID, 0) == -1) {\n\trcs_print_error(\"semctl(%d,0,%d) failed: (errno = %d) %s\\n\",\n\t    *sem, IPC_RMID, errno, strerror(errno));\n\treturn -1;\n    }\n    return 0;\n}", "path": "src\\libnml\\os_intf\\_sem.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// returns FPGA size in K-gates\n", "func_signal": "static int m7i43_cpld_get_fpga_size(struct board_info *board)", "code": "{\n    uint8_t byte;\n\n    //  select data register\n    epp_addr8(&board->io.epp, 0);\n\n    byte = epp_read(&board->io.epp);\n    if ((byte & 0x01) == 0x01) {\n        return 400;\n    } else {\n        return 200;\n    }\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/***********************************************************************\n*                   LOCAL FUNCTION DEFINITIONS                         *\n************************************************************************/\n", "func_signal": "static int pins_and_params(char *argv[])", "code": "{\n    unsigned short board_addr[MAX_BOARDS];\n    unsigned char dir_bits[MAX_BOARDS], mask;\n    int n, m, retval;\n\n    /* clear port_addr and dir_bits arrays */\n    for (n = 0; n < MAX_BOARDS; n++) {\n\tboard_addr[n] = 0;\n\tdir_bits[n] = 0;\n    }\n    /* parse config string, results in port_addr[] and data_dir[] arrays */\n    num_boards = 0;\n    n = 0;\n    while ((num_boards < MAX_BOARDS) && (argv[n] != 0)) {\n\tboard_addr[num_boards] = parse_board_addr(argv[n]);\n\tif (board_addr[num_boards] == 0) {\n\t    rtapi_print_msg(RTAPI_MSG_ERR,\n\t\t\"AX5124H: ERROR: bad port address '%s'\\n\", argv[n]);\n\t    return -1;\n\t}\n\tn++;\n\tif (argv[n] == 0) {\n\t    rtapi_print_msg(RTAPI_MSG_ERR,\n\t\t\"AX5124H: ERROR: no config info for port %s\\n\", argv[n-1]);\n\t    return -1;\n\t}\n\t/* should be a string of 8 'I\" or \"O\" characters */\n\tdir_bits[num_boards] = 0;\n\tmask = 0x01;\n\tfor ( m = 0 ; m < 8 ; m++ ) {\n\t    /* test character and set/clear bit */\n\t    if ((argv[n][m] == 'i') || (argv[n][m] == 'I')) {\n\t\t/* input, set mask bit to zero */\n\t\tdir_bits[num_boards] &= ~mask;\n\t    } else if ((argv[n][m] == 'o') || (argv[n][m] == 'O')) {\n\t\t/* output, set mask bit to one */\n\t\tdir_bits[num_boards] |= mask;\n\t    } else {\n\t\trtapi_print_msg(RTAPI_MSG_ERR,\n\t\t\"AX5124H: ERROR: bad config info for port %s: '%s'\\n\", argv[n-1], argv[n]);\n\t\treturn -1;\n\t    }\n\t    /* shift mask for next but */\n\t    mask <<= 1;\n\t}\n\tn++;\n\tnum_boards++;\n    }\n    /* OK, now we've parsed everything */\n    if (num_boards == 0) {\n\trtapi_print_msg(RTAPI_MSG_ERR,\n\t    \"AX5214H: ERROR: no ports configured\\n\");\n\treturn -1;\n    }\n    /* have good config info, connect to the HAL */\n    comp_id = hal_init(\"hal_ax5214h\");\n    if (comp_id < 0) {\n\trtapi_print_msg(RTAPI_MSG_ERR, \"AX5214H: ERROR: hal_init() failed\\n\");\n\treturn -1;\n    }\n    /* allocate shared memory for board data */\n    board_array = hal_malloc(num_boards * sizeof(board_t));\n    if (board_array == 0) {\n\trtapi_print_msg(RTAPI_MSG_ERR,\n\t    \"AX5214H: ERROR: hal_malloc() failed\\n\");\n\thal_exit(comp_id);\n\treturn -1;\n    }\n    /* export all the pins and params for each board */\n    for (n = 0; n < num_boards; n++) {\n\t/* config addr and direction */\n\tboard_array[n].base_addr = board_addr[n];\n\tboard_array[n].dir_bits = dir_bits[n];\n\t/* export all vars */\n\tretval = export_board(n, &(board_array[n]));\n\tif (retval != 0) {\n\t    rtapi_print_msg(RTAPI_MSG_ERR,\n\t\t\"AX5214H: ERROR: board %d (%04X) var export failed\\n\", n, board_addr[n]);\n\t    hal_exit(comp_id);\n\t    return -1;\n\t}\n    }\n    return 0;\n}", "path": "src\\hal\\drivers\\hal_ax5214h.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/* signal handler */\n", "func_signal": "static void quit(int sig)", "code": "{\n    if ( ignore_sig ) {\n\treturn;\n    }\n    if ( shmem_id >= 0 ) {\n\trtapi_shmem_delete(shmem_id, comp_id);\n    }\n    if ( comp_id >= 0 ) {\n\thal_exit(comp_id);\n    }\n    exit(exitval);\n}", "path": "src\\hal\\components\\streamer_usr.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/* write data from bitfile chunk 'ch' to FPGA on board 'devnum' */\n", "func_signal": "static int write_fpga_ram(struct board_info *bd, struct bitfile_chunk *ch)", "code": "{\n    int mem_region, n;\n    __u32 data;\n\n    printf(\"Opening PCI region %d...\\n\", bd->io.pci.fpga_pci_region);\n    mem_region = upci_open_region(bd->io.pci.upci_devnum, bd->io.pci.fpga_pci_region);\n    if ( mem_region < 0 ) {\n\terrmsg(__func__, \"could not open device %d, region %d (FPGA memory)\",\n\t    bd->io.pci.upci_devnum, bd->io.pci.fpga_pci_region );\n\treturn -1;\n    }\n    printf(\"Writing data to FPGA...\\n\");\n    data = 0;\n    for ( n = 0 ; n < ch->len ; n++ ) {\n\tdata |= ch->body[n] << ((n & 3) * 8);\n\tif ( (n & 3) == 3 ) {\n\t    /* have 32 bits, write to the RAM */\n\t    upci_write_u32(mem_region, (n & ~3), data);\n\t    /* prep for next 32 */\n\t    data = 0;\n\t}\n    }\n    if ( (n & 3) != 0 ) {\n\t/* have residual bits, write to the RAM */\n\tupci_write_u32(mem_region, (n & ~3), data);\n    }\n    printf(\"Transferred %d bytes\\n\", n);\n    upci_close_region(mem_region);\n    return 0;\n}", "path": "src\\hal\\utils\\bfload.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "// sets up all the IOPort instances, return 0 on success, -errno on failure\n", "func_signal": "void hm2_configure_pins(hostmot2_t *hm2)", "code": "{\n    int i;\n\n    // \n    // the bits in the alt_source register of the ioport function say\n    // whether *output* data comes from the primary source (ioport\n    // function) (0) or the secondary source (1)\n    // \n    // the bits in the data direction register say whether the pins are\n    // inputs (0) or outputs (1)\n    // \n    // if a pin is marked as an input in the ddr, it can be used for its\n    // function (encoder, say) *and* as a digital input pin without\n    // conflict\n    // \n    // Each function instance that is not disabled by the relevant\n    // num_<functions> modparam has all its pins marked 1 in the alt_source\n    // register.  The driver uses this to to keep track of which pins are\n    // \"allocated\" to functions and which pins are available for use as\n    // gpios.\n    // \n\n    // everything defaults to GPIO input...\n    for (i = 0; i < hm2->num_pins; i ++) {\n        hm2_set_pin_source(hm2, i, HM2_PIN_SOURCE_IS_PRIMARY);\n        hm2_set_pin_direction(hm2, i, HM2_PIN_DIR_IS_INPUT);\n    }\n\n\n    //\n    // ... then modules get to take what they want\n    //\n\n    // stepgen is special, it wants to think about what pins it takes\n    hm2_stepgen_allocate_pins(hm2);\n\n    // encoder and pwmgen just get all their enabled instances' pins\n    hm2_pins_allocate_all(hm2, HM2_GTAG_ENCODER, hm2->encoder.num_instances);\n    hm2_pins_allocate_all(hm2, HM2_GTAG_PWMGEN,  hm2->pwmgen.num_instances);\n}", "path": "src\\hal\\drivers\\mesa-hostmot2\\pins.c", "repo_name": "yishinli/emc2", "stars": 5, "license": "other", "language": "c", "size": 33170}
{"docstring": "/*\n * channel_read\n *\n * Read data from a channel\n *\n * It is important to not return 0 until the currently read channel is\n * complete. If we read stuff from the wire but it was no payload data to fill\n * in the buffer with, we MUST make sure to return PACKET_EAGAIN.\n */\n", "func_signal": "static ssize_t channel_read(LIBSSH2_CHANNEL *channel, int stream_id,\n                            char *buf, size_t buflen)", "code": "{\n    LIBSSH2_SESSION *session = channel->session;\n    libssh2pack_t rc;\n    int bytes_read = 0;\n    int bytes_want;\n    int unlink_packet;\n\n    if (channel->read_state == libssh2_NB_state_idle) {\n        _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                       \"channel_read() wants %d bytes from channel %lu/%lu \"\n                       \"stream #%d\",\n                       (int) buflen, channel->local.id, channel->remote.id,\n                       stream_id);\n\n        rc = 1; /* set to >0 to let the while loop start */\n\n        /* process all pending incoming packets */\n        while (rc > 0)\n            rc = _libssh2_transport_read(session);\n\n        if ((rc < 0) && (rc != PACKET_EAGAIN))\n            return -1;\n\n        channel->read_state = libssh2_NB_state_created;\n    }\n    else {\n        /* We're not in the idle state, but in order to \"even out\" the network\n           readings we do a single shot read here as well. Tests prove that\n           this way produces faster transfers. */\n        rc = _libssh2_transport_read(session);\n\n        /* ignore PACKET_EAGAIN but return failure for the rest */\n        if ((rc < 0) && (rc != PACKET_EAGAIN))\n            return -1;\n    }\n\n    /*\n     * =============================== NOTE ===============================\n     * I know this is very ugly and not a really good use of \"goto\", but\n     * this case statement would be even uglier to do it any other way\n     */\n    if (channel->read_state == libssh2_NB_state_jump1) {\n        goto channel_read_ex_point1;\n    }\n\n    rc = 0;\n\n    channel->read_packet = session->packets.head;\n    while (channel->read_packet &&\n           !channel->remote.close &&\n           (bytes_read < (int) buflen)) {\n        LIBSSH2_PACKET *readpkt = channel->read_packet;\n\n        /* In case packet gets destroyed during this iteration */\n        channel->read_next = readpkt->next;\n\n        channel->read_local_id =\n            _libssh2_ntohu32(readpkt->data + 1);\n\n        /*\n         * Either we asked for a specific extended data stream\n         * (and data was available),\n         * or the standard stream (and data was available),\n         * or the standard stream with extended_data_merge\n         * enabled and data was available\n         */\n        if ((stream_id\n             && (readpkt->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA)\n             && (channel->local.id == channel->read_local_id)\n             && (stream_id == (int) _libssh2_ntohu32(readpkt->data + 5)))\n            || (!stream_id && (readpkt->data[0] == SSH_MSG_CHANNEL_DATA)\n                && (channel->local.id == channel->read_local_id))\n            || (!stream_id\n                && (readpkt->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                && (channel->local.id == channel->read_local_id)\n                && (channel->remote.extended_data_ignore_mode ==\n                    LIBSSH2_CHANNEL_EXTENDED_DATA_MERGE))) {\n\n            /* figure out much more data we want to read */\n            bytes_want = buflen - bytes_read;\n            unlink_packet = FALSE;\n\n            if (bytes_want >= (int) (readpkt->data_len - readpkt->data_head)) {\n                /* we want more than this node keeps, so adjust the number and\n                   delete this node after the copy */\n                bytes_want = readpkt->data_len - readpkt->data_head;\n                unlink_packet = TRUE;\n            }\n\n            _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                           \"channel_read() got %d of data from %lu/%lu/%d%s\",\n                           bytes_want, channel->local.id,\n                           channel->remote.id, stream_id,\n                           unlink_packet?\" [ul]\":\"\");\n\n            /* copy data from this struct to the target buffer */\n            memcpy(&buf[bytes_read],\n                   &readpkt->data[readpkt->data_head], bytes_want);\n\n            /* advance pointer and counter */\n            readpkt->data_head += bytes_want;\n            bytes_read += bytes_want;\n\n            /* if drained, remove from list */\n            if (unlink_packet) {\n                if (readpkt->prev) {\n                    readpkt->prev->next = readpkt->next;\n                } else {\n                    session->packets.head = readpkt->next;\n                }\n                if (readpkt->next) {\n                    readpkt->next->prev = readpkt->prev;\n                } else {\n                    session->packets.tail = readpkt->prev;\n                }\n                LIBSSH2_FREE(session, readpkt->data);\n                LIBSSH2_FREE(session, readpkt);\n            }\n        }\n\n        /* check the next struct in the chain */\n        channel->read_packet = channel->read_next;\n    }\n\n    if (bytes_read == 0) {\n        channel->read_state = libssh2_NB_state_idle;\n        if (channel->remote.close) {\n            libssh2_error(session, LIBSSH2_ERROR_CHANNEL_CLOSED,\n                          \"Remote end has closed this channel\", 0);\n            return 0;\n        }\n        else {\n            /*\n             * when non-blocking, we must return PACKET_EAGAIN if we haven't\n             * completed reading the channel\n             */\n            if (!libssh2_channel_eof(channel)) {\n                return PACKET_EAGAIN;\n            }\n            return 0;\n        }\n    }\n    else\n        /* make sure we remain in the created state to focus on emptying the\n           data we already have in the packet brigade before we try to read\n           more off the network again */\n        channel->read_state = libssh2_NB_state_created;\n\n    if(channel->remote.window_size < (LIBSSH2_CHANNEL_WINDOW_DEFAULT*300)) {\n        /* the window is getting too narrow, expand it! */\n\n      channel_read_ex_point1:\n        channel->read_state = libssh2_NB_state_jump1;\n        /* the actual window adjusting may not finish so we need to deal with\n           this special state here */\n        rc = _libssh2_channel_receive_window_adjust(channel,\n                                                    (LIBSSH2_CHANNEL_WINDOW_DEFAULT*600), 0, NULL);\n        if (rc == PACKET_EAGAIN) {\n            return PACKET_EAGAIN;\n        }\n        _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                       \"channel_read() filled %d adjusted %d\",\n                       bytes_read, buflen);\n        /* continue in 'created' state to drain the already read packages\n           first before starting to empty the socket further */\n        channel->read_state = libssh2_NB_state_created;\n    }\n\n    return bytes_read;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_forward_cancel\n *\n * Stop listening on a remote port and free the listener\n * Toss out any pending (un-accept()ed) connections\n *\n * Return 0 on success, PACKET_EAGAIN if would block, -1 on error\n */\n", "func_signal": "LIBSSH2_API int\nlibssh2_channel_forward_cancel(LIBSSH2_LISTENER *listener)", "code": "{\n    int rc;\n    BLOCK_ADJUST(rc, listener->session, channel_forward_cancel(listener));\n    return rc;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * channel_request_pty\n * Duh... Request a PTY\n */\n", "func_signal": "static int channel_request_pty(LIBSSH2_CHANNEL *channel,\n                               const char *term, unsigned int term_len,\n                               const char *modes, unsigned int modes_len,\n                               int width, int height,\n                               int width_px, int height_px)", "code": "{\n    LIBSSH2_SESSION *session = channel->session;\n    unsigned char *s, *data;\n    static const unsigned char reply_codes[3] =\n        { SSH_MSG_CHANNEL_SUCCESS, SSH_MSG_CHANNEL_FAILURE, 0 };\n    unsigned long data_len;\n    int rc;\n\n    if (channel->reqPTY_state == libssh2_NB_state_idle) {\n        /* 41 = packet_type(1) + channel(4) + pty_req_len(4) + \"pty_req\"(7) +\n         * want_reply(1) + term_len(4) + width(4) + height(4) + width_px(4) +\n         * height_px(4) + modes_len(4) */\n        channel->reqPTY_packet_len = term_len + modes_len + 41;\n\n        /* Zero the whole thing out */\n        memset(&channel->reqPTY_packet_requirev_state, 0,\n               sizeof(channel->reqPTY_packet_requirev_state));\n\n        _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                       \"Allocating tty on channel %lu/%lu\", channel->local.id,\n                       channel->remote.id);\n\n        s = channel->reqPTY_packet =\n            LIBSSH2_ALLOC(session, channel->reqPTY_packet_len);\n        if (!channel->reqPTY_packet) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Unable to allocate memory for pty-request\", 0);\n            return -1;\n        }\n\n        *(s++) = SSH_MSG_CHANNEL_REQUEST;\n        _libssh2_htonu32(s, channel->remote.id);\n        s += 4;\n        _libssh2_htonu32(s, sizeof(\"pty-req\") - 1);\n        s += 4;\n        memcpy(s, \"pty-req\", sizeof(\"pty-req\") - 1);\n        s += sizeof(\"pty-req\") - 1;\n\n        *(s++) = 0x01;\n\n        _libssh2_htonu32(s, term_len);\n        s += 4;\n        if (term) {\n            memcpy(s, term, term_len);\n            s += term_len;\n        }\n\n        _libssh2_htonu32(s, width);\n        s += 4;\n        _libssh2_htonu32(s, height);\n        s += 4;\n        _libssh2_htonu32(s, width_px);\n        s += 4;\n        _libssh2_htonu32(s, height_px);\n        s += 4;\n\n        _libssh2_htonu32(s, modes_len);\n        s += 4;\n        if (modes) {\n            memcpy(s, modes, modes_len);\n            s += modes_len;\n        }\n\n        channel->reqPTY_state = libssh2_NB_state_created;\n    }\n\n    if (channel->reqPTY_state == libssh2_NB_state_created) {\n        rc = _libssh2_transport_write(session, channel->reqPTY_packet,\n                                   channel->reqPTY_packet_len);\n        if (rc == PACKET_EAGAIN) {\n            return PACKET_EAGAIN;\n        } else if (rc) {\n            libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                          \"Unable to send pty-request packet\", 0);\n            LIBSSH2_FREE(session, channel->reqPTY_packet);\n            channel->reqPTY_packet = NULL;\n            channel->reqPTY_state = libssh2_NB_state_idle;\n            return -1;\n        }\n        LIBSSH2_FREE(session, channel->reqPTY_packet);\n        channel->reqPTY_packet = NULL;\n\n        _libssh2_htonu32(channel->reqPTY_local_channel, channel->local.id);\n\n        channel->reqPTY_state = libssh2_NB_state_sent;\n    }\n\n    if (channel->reqPTY_state == libssh2_NB_state_sent) {\n        rc = _libssh2_packet_requirev(session, reply_codes, &data, &data_len,\n                                      1, channel->reqPTY_local_channel, 4,\n                                      &channel->reqPTY_packet_requirev_state);\n        if (rc == PACKET_EAGAIN) {\n            return PACKET_EAGAIN;\n        } else if (rc) {\n            channel->reqPTY_state = libssh2_NB_state_idle;\n            return -1;\n        }\n\n        if (data[0] == SSH_MSG_CHANNEL_SUCCESS) {\n            LIBSSH2_FREE(session, data);\n            channel->reqPTY_state = libssh2_NB_state_idle;\n            return 0;\n        }\n    }\n\n    LIBSSH2_FREE(session, data);\n    libssh2_error(session, LIBSSH2_ERROR_CHANNEL_REQUEST_DENIED,\n                  \"Unable to complete request for channel request-pty\", 0);\n    channel->reqPTY_state = libssh2_NB_state_idle;\n    return -1;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_direct_tcpip_ex\n *\n * Tunnel TCP/IP connect through the SSH session to direct host/port\n */\n", "func_signal": "LIBSSH2_API LIBSSH2_CHANNEL *\nlibssh2_channel_direct_tcpip_ex(LIBSSH2_SESSION * session, const char *host,\n                                int port, const char *shost, int sport)", "code": "{\n    LIBSSH2_CHANNEL *ptr;\n    BLOCK_ADJUST_ERRNO(ptr, session,\n                       channel_direct_tcpip(session, host, port, shost, sport));\n    return ptr;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_wait_eof\n *\n * Awaiting channel EOF\n */\n", "func_signal": "LIBSSH2_API int\nlibssh2_channel_wait_eof(LIBSSH2_CHANNEL *channel)", "code": "{\n    int rc;\n    BLOCK_ADJUST(rc, channel->session, channel_wait_eof(channel));\n    return rc;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/* kbd_callback */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    unsigned long hostaddr;\n    int sock, i, auth_pw = 0;\n    struct sockaddr_in sin;\n    const char *fingerprint;\n    char *userauthlist;\n    LIBSSH2_SESSION *session;\n    LIBSSH2_CHANNEL *channel;\n#ifdef WIN32\n    WSADATA wsadata;\n\n    WSAStartup(MAKEWORD(2,0), &wsadata);\n#endif\n\n    if (argc > 1) {\n        hostaddr = inet_addr(argv[1]);\n    } else {\n        hostaddr = htonl(0x7F000001);\n    }\n\n    if(argc > 2) {\n        username = argv[2];\n    }\n    if(argc > 3) {\n        password = argv[3];\n    }\n\n    /* Ultra basic \"connect to port 22 on localhost\"\n     * Your code is responsible for creating the socket establishing the connection\n     */\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n#ifndef WIN32\n    fcntl(sock, F_SETFL, 0);\n#endif\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons(22);\n    sin.sin_addr.s_addr = hostaddr;\n    if (connect(sock, (struct sockaddr*)(&sin),\n                sizeof(struct sockaddr_in)) != 0) {\n        fprintf(stderr, \"failed to connect!\\n\");\n        return -1;\n    }\n\n    /* Create a session instance and start it up\n     * This will trade welcome banners, exchange keys, and setup crypto, compression, and MAC layers\n     */\n    session = libssh2_session_init();\n    if (libssh2_session_startup(session, sock)) {\n        fprintf(stderr, \"Failure establishing SSH session\\n\");\n        return -1;\n    }\n\n    /* At this point we havn't authenticated,\n     * The first thing to do is check the hostkey's fingerprint against our known hosts\n     * Your app may have it hard coded, may go to a file, may present it to the user, that's your call\n     */\n    fingerprint = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n    printf(\"Fingerprint: \");\n    for(i = 0; i < 16; i++) {\n        printf(\"%02X \", (unsigned char)fingerprint[i]);\n    }\n    printf(\"\\n\");\n\n    /* check what authentication methods are available */\n    userauthlist = libssh2_userauth_list(session, username, strlen(username));\n    printf(\"Authentication methods: %s\\n\", userauthlist);\n    if (strstr(userauthlist, \"password\") != NULL) {\n        auth_pw |= 1;\n    }\n    if (strstr(userauthlist, \"keyboard-interactive\") != NULL) {\n        auth_pw |= 2;\n    }\n    if (strstr(userauthlist, \"publickey\") != NULL) {\n        auth_pw |= 4;\n    }\n\n    /* if we got an 4. argument we set this option if supported */ \n    if(argc > 4) {\n        if ((auth_pw & 1) && !strcasecmp(argv[4], \"-p\")) {\n            auth_pw = 1;\n        }\n        if ((auth_pw & 2) && !strcasecmp(argv[4], \"-i\")) {\n            auth_pw = 2;\n        }\n        if ((auth_pw & 4) && !strcasecmp(argv[4], \"-k\")) {\n            auth_pw = 4;\n        }\n    }\n\n    if (auth_pw & 1) {\n        /* We could authenticate via password */\n        if (libssh2_userauth_password(session, username, password)) {\n            printf(\"\\tAuthentication by password failed!\\n\");\n            goto shutdown;\n        } else {\n            printf(\"\\tAuthentication by password succeeded.\\n\");\n        }\n    } else if (auth_pw & 2) {\n        /* Or via keyboard-interactive */\n        if (libssh2_userauth_keyboard_interactive(session, username, &kbd_callback) ) {\n            printf(\"\\tAuthentication by keyboard-interactive failed!\\n\");\n            goto shutdown;\n        } else {\n            printf(\"\\tAuthentication by keyboard-interactive succeeded.\\n\");\n        }\n    } else if (auth_pw & 4) {\n        /* Or by public key */\n        if (libssh2_userauth_publickey_fromfile(session, username, keyfile1, keyfile2, password)) {\n            printf(\"\\tAuthentication by public key failed!\\n\");\n            goto shutdown;\n        } else {\n            printf(\"\\tAuthentication by public key succeeded.\\n\");\n        }\n    } else {\n        printf(\"No supported authentication methods found!\\n\");\n        goto shutdown;\n    }\n\n    /* Request a shell */\n    if (!(channel = libssh2_channel_open_session(session))) {\n        fprintf(stderr, \"Unable to open a session\\n\");\n        goto shutdown;\n    }\n\n    /* Some environment variables may be set,\n     * It's up to the server which ones it'll allow though\n     */\n    libssh2_channel_setenv(channel, \"FOO\", \"bar\");\n\n    /* Request a terminal with 'vanilla' terminal emulation\n     * See /etc/termcap for more options\n     */\n    if (libssh2_channel_request_pty(channel, \"vanilla\")) {\n        fprintf(stderr, \"Failed requesting pty\\n\");\n        goto skip_shell;\n    }\n\n    /* Open a SHELL on that pty */\n    if (libssh2_channel_shell(channel)) {\n        fprintf(stderr, \"Unable to request shell on allocated pty\\n\");\n        goto shutdown;\n    }\n\n    /* At this point the shell can be interacted with using\n     * libssh2_channel_read()\n     * libssh2_channel_read_stderr()\n     * libssh2_channel_write()\n     * libssh2_channel_write_stderr()\n     *\n     * Blocking mode may be (en|dis)abled with: libssh2_channel_set_blocking()\n     * If the server send EOF, libssh2_channel_eof() will return non-0\n     * To send EOF to the server use: libssh2_channel_send_eof()\n     * A channel can be closed with: libssh2_channel_close()\n     * A channel can be freed with: libssh2_channel_free()\n     */\n\n  skip_shell:\n    if (channel) {\n        libssh2_channel_free(channel);\n        channel = NULL;\n    }\n\n    /* Other channel types are supported via:\n     * libssh2_scp_send()\n     * libssh2_scp_recv()\n     * libssh2_channel_direct_tcpip()\n     */\n\n  shutdown:\n\n    libssh2_session_disconnect(session, \"Normal Shutdown, Thank you for playing\");\n    libssh2_session_free(session);\n\n#ifdef WIN32\n    Sleep(1000);\n    closesocket(sock);\n#else\n    sleep(1);\n    close(sock);\n#endif\n    printf(\"all done!\\n\");\n    return 0;\n}", "path": "ssh2\\example\\simple\\ssh2.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_flush_ex\n *\n * Flush data from one (or all) stream\n * Returns number of bytes flushed, or negative on failure\n */\n", "func_signal": "LIBSSH2_API int\nlibssh2_channel_flush_ex(LIBSSH2_CHANNEL *channel, int stream)", "code": "{\n    int rc;\n    BLOCK_ADJUST(rc, channel->session,\n                 _libssh2_channel_flush(channel, stream));\n    return rc;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * _libssh2_channel_open\n *\n * Establish a generic session channel\n */\n", "func_signal": "LIBSSH2_CHANNEL *\n_libssh2_channel_open(LIBSSH2_SESSION * session, const char *channel_type,\n                      unsigned int channel_type_len,\n                      unsigned int window_size, unsigned int packet_size,\n                      const char *message, unsigned int message_len)", "code": "{\n    static const unsigned char reply_codes[3] = {\n        SSH_MSG_CHANNEL_OPEN_CONFIRMATION,\n        SSH_MSG_CHANNEL_OPEN_FAILURE,\n        0\n    };\n    unsigned char *s;\n    int rc;\n\n    if (session->open_state == libssh2_NB_state_idle) {\n        session->open_channel = NULL;\n        session->open_packet = NULL;\n        session->open_data = NULL;\n        /* 17 = packet_type(1) + channel_type_len(4) + sender_channel(4) +\n         * window_size(4) + packet_size(4) */\n        session->open_packet_len = channel_type_len + message_len + 17;\n        session->open_local_channel = _libssh2_channel_nextid(session);\n\n        /* Zero the whole thing out */\n        memset(&session->open_packet_requirev_state, 0,\n               sizeof(session->open_packet_requirev_state));\n\n        _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                       \"Opening Channel - win %d pack %d\", window_size,\n                       packet_size);\n        session->open_channel =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_CHANNEL));\n        if (!session->open_channel) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Unable to allocate space for channel data\", 0);\n            return NULL;\n        }\n        memset(session->open_channel, 0, sizeof(LIBSSH2_CHANNEL));\n\n        session->open_channel->channel_type_len = channel_type_len;\n        session->open_channel->channel_type =\n            LIBSSH2_ALLOC(session, channel_type_len);\n        if (!session->open_channel->channel_type) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Failed allocating memory for channel type name\", 0);\n            LIBSSH2_FREE(session, session->open_channel);\n            session->open_channel = NULL;\n            return NULL;\n        }\n        memcpy(session->open_channel->channel_type, channel_type,\n               channel_type_len);\n\n        /* REMEMBER: local as in locally sourced */\n        session->open_channel->local.id = session->open_local_channel;\n        session->open_channel->remote.window_size = window_size;\n        session->open_channel->remote.window_size_initial = window_size;\n        session->open_channel->remote.packet_size = packet_size;\n\n        CHANNEL_ADD(session, session->open_channel);\n\n        s = session->open_packet =\n            LIBSSH2_ALLOC(session, session->open_packet_len);\n        if (!session->open_packet) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Unable to allocate temporary space for packet\", 0);\n            goto channel_error;\n        }\n        *(s++) = SSH_MSG_CHANNEL_OPEN;\n        _libssh2_htonu32(s, channel_type_len);\n        s += 4;\n\n        memcpy(s, channel_type, channel_type_len);\n        s += channel_type_len;\n\n        _libssh2_htonu32(s, session->open_local_channel);\n        s += 4;\n\n        _libssh2_htonu32(s, window_size);\n        s += 4;\n\n        _libssh2_htonu32(s, packet_size);\n        s += 4;\n\n        if (message && message_len) {\n            memcpy(s, message, message_len);\n            s += message_len;\n        }\n\n        session->open_state = libssh2_NB_state_created;\n    }\n\n    if (session->open_state == libssh2_NB_state_created) {\n        rc = _libssh2_transport_write(session, session->open_packet,\n                                      session->open_packet_len);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block sending channel-open request\", 0);\n            return NULL;\n        } else if (rc) {\n            libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                          \"Unable to send channel-open request\", 0);\n            goto channel_error;\n        }\n\n        session->open_state = libssh2_NB_state_sent;\n    }\n\n    if (session->open_state == libssh2_NB_state_sent) {\n        rc = _libssh2_packet_requirev(session, reply_codes,\n                                      &session->open_data,\n                                      &session->open_data_len, 1,\n                                      session->open_packet + 5 +\n                                      channel_type_len, 4,\n                                      &session->open_packet_requirev_state);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN, \"Would block\", 0);\n            return NULL;\n        } else if (rc) {\n            goto channel_error;\n        }\n\n        if (session->open_data[0] == SSH_MSG_CHANNEL_OPEN_CONFIRMATION) {\n            session->open_channel->remote.id =\n                _libssh2_ntohu32(session->open_data + 5);\n            session->open_channel->local.window_size =\n                _libssh2_ntohu32(session->open_data + 9);\n            session->open_channel->local.window_size_initial =\n                _libssh2_ntohu32(session->open_data + 9);\n            session->open_channel->local.packet_size =\n                _libssh2_ntohu32(session->open_data + 13);\n            _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                           \"Connection Established - ID: %lu/%lu win: %lu/%lu\"\n                           \" pack: %lu/%lu\",\n                           session->open_channel->local.id,\n                           session->open_channel->remote.id,\n                           session->open_channel->local.window_size,\n                           session->open_channel->remote.window_size,\n                           session->open_channel->local.packet_size,\n                           session->open_channel->remote.packet_size);\n            LIBSSH2_FREE(session, session->open_packet);\n            session->open_packet = NULL;\n            LIBSSH2_FREE(session, session->open_data);\n            session->open_data = NULL;\n\n            session->open_state = libssh2_NB_state_idle;\n            return session->open_channel;\n        }\n\n        if (session->open_data[0] == SSH_MSG_CHANNEL_OPEN_FAILURE) {\n            libssh2_error(session, LIBSSH2_ERROR_CHANNEL_FAILURE,\n                          \"Channel open failure\", 0);\n        }\n    }\n\n  channel_error:\n\n    if (session->open_data) {\n        LIBSSH2_FREE(session, session->open_data);\n        session->open_data = NULL;\n    }\n    if (session->open_packet) {\n        LIBSSH2_FREE(session, session->open_packet);\n        session->open_packet = NULL;\n    }\n    if (session->open_channel) {\n        unsigned char channel_id[4];\n        LIBSSH2_FREE(session, session->open_channel->channel_type);\n\n        if (session->open_channel->next) {\n            session->open_channel->next->prev = session->open_channel->prev;\n        }\n        if (session->open_channel->prev) {\n            session->open_channel->prev->next = session->open_channel->next;\n        }\n        if (session->channels.head == session->open_channel) {\n            session->channels.head = session->open_channel->next;\n        }\n        if (session->channels.tail == session->open_channel) {\n            session->channels.tail = session->open_channel->prev;\n        }\n\n        /* Clear out packets meant for this channel */\n        _libssh2_htonu32(channel_id, session->open_channel->local.id);\n        while ((_libssh2_packet_ask(session, SSH_MSG_CHANNEL_DATA,\n                                    &session->open_data,\n                                    &session->open_data_len, 1,\n                                    channel_id, 4) >= 0)\n               ||\n               (_libssh2_packet_ask(session, SSH_MSG_CHANNEL_EXTENDED_DATA,\n                                    &session->open_data,\n                                    &session->open_data_len, 1,\n                                    channel_id, 4) >= 0)) {\n            LIBSSH2_FREE(session, session->open_data);\n            session->open_data = NULL;\n        }\n\n        /* Free any state variables still holding data */\n        if (session->open_channel->write_packet) {\n            LIBSSH2_FREE(session, session->open_channel->write_packet);\n            session->open_channel->write_packet = NULL;\n        }\n\n        LIBSSH2_FREE(session, session->open_channel);\n        session->open_channel = NULL;\n    }\n\n    session->open_state = libssh2_NB_state_idle;\n    return NULL;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n** Here we clean up any resources we allocated. Resource tags is a big part\n** of what we created, but NetWare doesn't ask us to free those.\n*/\n", "func_signal": "void _NonAppStop( void )", "code": "{\n  (void) unregister_library(gLibId);\n  NXMutexFree(gLibLock);\n}", "path": "ssh2\\nw\\nwlib.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_free\n *\n * Make sure a channel is closed, then remove the channel from the session\n * and free its resource(s)\n *\n * Returns 0 on success, -1 on failure\n */\n", "func_signal": "LIBSSH2_API int\nlibssh2_channel_free(LIBSSH2_CHANNEL *channel)", "code": "{\n    int rc;\n    BLOCK_ADJUST(rc, channel->session, _libssh2_channel_free(channel));\n    return rc;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_window_write_ex\n *\n * Check the status of the write window Returns the number of bytes which may\n * be safely writen on the channel without blocking window_size_initial (if\n * passed) will be populated with the size of the initial window as defined by\n * the channel_open request\n */\n", "func_signal": "LIBSSH2_API unsigned long\nlibssh2_channel_window_write_ex(LIBSSH2_CHANNEL * channel,\n                                unsigned long *window_size_initial)", "code": "{\n    if (window_size_initial) {\n        /* For locally initiated channels this is very often 0, so it's not\n         * *that* useful as information goes */\n        *window_size_initial = channel->local.window_size_initial;\n    }\n\n    return channel->local.window_size;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_window_read_ex\n *\n * Check the status of the read window. Returns the number of bytes which the\n * remote end may send without overflowing the window limit read_avail (if\n * passed) will be populated with the number of bytes actually available to be\n * read window_size_initial (if passed) will be populated with the\n * window_size_initial as defined by the channel_open request\n */\n", "func_signal": "LIBSSH2_API unsigned long\nlibssh2_channel_window_read_ex(LIBSSH2_CHANNEL * channel,\n                               unsigned long *read_avail,\n                               unsigned long *window_size_initial)", "code": "{\n    if (window_size_initial) {\n        *window_size_initial = channel->remote.window_size_initial;\n    }\n\n    if (read_avail) {\n        unsigned long bytes_queued = 0;\n        LIBSSH2_PACKET *packet = channel->session->packets.head;\n\n        while (packet) {\n            unsigned char packet_type = packet->data[0];\n\n            if (((packet_type == SSH_MSG_CHANNEL_DATA)\n                 || (packet_type == SSH_MSG_CHANNEL_EXTENDED_DATA))\n                && (_libssh2_ntohu32(packet->data + 1) == channel->local.id)) {\n                bytes_queued += packet->data_len - packet->data_head;\n            }\n\n            packet = packet->next;\n        }\n\n        *read_avail = bytes_queued;\n    }\n\n    return channel->remote.window_size;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_scp_send_ex\n *\n * Send a file using SCP\n *\n */\n", "func_signal": "LIBSSH2_API LIBSSH2_CHANNEL *\nlibssh2_scp_send_ex(LIBSSH2_SESSION * session, const char *path, int mode,\n                    size_t size, long mtime, long atime)", "code": "{\n    int cmd_len;\n    unsigned const char *base;\n    int rc;\n\n    if (session->scpSend_state == libssh2_NB_state_idle) {\n        session->scpSend_command_len =\n            libssh2_shell_quotedsize(path) + sizeof(\"scp -t \") +\n            ((mtime || atime)?1:0);\n\n        session->scpSend_command =\n            LIBSSH2_ALLOC(session, session->scpSend_command_len);\n        if (!session->scpSend_command) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Unable to allocate a command buffer for scp session\",\n                          0);\n            return NULL;\n        }\n\n        sprintf((char *)session->scpSend_command, \"scp -%st \",\n                (mtime || atime)?\"p\":\"\");\n\n        cmd_len = strlen((char *)session->scpSend_command);\n\n        (void)libssh2_shell_quotearg(path,\n                                     &session->scpSend_command[cmd_len],\n                                     session->scpSend_command_len - cmd_len);\n\n        session->scpSend_command[session->scpSend_command_len - 1] = '\\0';\n\n        _libssh2_debug(session, LIBSSH2_DBG_SCP,\n                       \"Opening channel for SCP send\");\n        /* Allocate a channel */\n\n        session->scpSend_state = libssh2_NB_state_created;\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_created) {\n        session->scpSend_channel =\n            libssh2_channel_open_ex(session, \"session\", sizeof(\"session\") - 1,\n                                    LIBSSH2_CHANNEL_WINDOW_DEFAULT,\n                                    LIBSSH2_CHANNEL_PACKET_DEFAULT, NULL, 0);\n        if (!session->scpSend_channel) {\n            if (libssh2_session_last_errno(session) != LIBSSH2_ERROR_EAGAIN) {\n                /* previous call set libssh2_session_last_error(), pass it\n                   through */\n                LIBSSH2_FREE(session, session->scpSend_command);\n                session->scpSend_command = NULL;\n                session->scpSend_state = libssh2_NB_state_idle;\n            }\n            else {\n                libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                              \"Would block starting up channel\", 0);\n            }\n            return NULL;\n        }\n\n        session->scpSend_state = libssh2_NB_state_sent;\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_sent) {\n        /* Request SCP for the desired file */\n        rc = libssh2_channel_process_startup(session->scpSend_channel, \"exec\",\n                                             sizeof(\"exec\") - 1,\n                                             (char *) session->scpSend_command,\n                                             session->scpSend_command_len);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block requesting SCP startup\", 0);\n            return NULL;\n        }\n        else if (rc) {\n            /* previous call set libssh2_session_last_error(), pass it\n               through */\n            LIBSSH2_FREE(session, session->scpSend_command);\n            session->scpSend_command = NULL;\n            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                          \"Unknown error while getting error string\", 0);\n            goto scp_send_error;\n        }\n        LIBSSH2_FREE(session, session->scpSend_command);\n        session->scpSend_command = NULL;\n\n        session->scpSend_state = libssh2_NB_state_sent1;\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_sent1) {\n        /* Wait for ACK */\n        rc = libssh2_channel_read_ex(session->scpSend_channel, 0,\n                                     (char *) session->scpSend_response, 1);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block waiting for response from remote\", 0);\n            return NULL;\n        } else if ((rc <= 0) || (session->scpSend_response[0] != 0)) {\n            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                          \"Invalid ACK response from remote\", 0);\n            goto scp_send_error;\n        }\n\n        if (mtime || atime) {\n            /* Send mtime and atime to be used for file */\n            session->scpSend_response_len =\n                snprintf((char *) session->scpSend_response,\n                         LIBSSH2_SCP_RESPONSE_BUFLEN, \"T%ld 0 %ld 0\\n\", mtime,\n                         atime);\n            _libssh2_debug(session, LIBSSH2_DBG_SCP, \"Sent %s\",\n                           session->scpSend_response);\n        }\n\n        session->scpSend_state = libssh2_NB_state_sent2;\n    }\n\n    /* Send mtime and atime to be used for file */\n    if (mtime || atime) {\n        if (session->scpSend_state == libssh2_NB_state_sent2) {\n            rc = libssh2_channel_write_ex(session->scpSend_channel, 0,\n                                          (char *) session->scpSend_response,\n                                          session->scpSend_response_len);\n            if (rc == PACKET_EAGAIN) {\n                libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                              \"Would block sending time data for SCP file\", 0);\n                return NULL;\n            } else if (rc != (int)session->scpSend_response_len) {\n                libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                              \"Unable to send time data for SCP file\", 0);\n                goto scp_send_error;\n            }\n\n            session->scpSend_state = libssh2_NB_state_sent3;\n        }\n\n        if (session->scpSend_state == libssh2_NB_state_sent3) {\n            /* Wait for ACK */\n            rc = libssh2_channel_read_ex(session->scpSend_channel, 0,\n                                         (char *) session->scpSend_response,\n                                         1);\n            if (rc == PACKET_EAGAIN) {\n                libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                              \"Would block waiting for response\", 0);\n                return NULL;\n            } else if ((rc <= 0) || (session->scpSend_response[0] != 0)) {\n                libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                              \"Invalid ACK response from remote\", 0);\n                goto scp_send_error;\n            }\n\n            session->scpSend_state = libssh2_NB_state_sent4;\n        }\n    } else {\n        if (session->scpSend_state == libssh2_NB_state_sent2) {\n            session->scpSend_state = libssh2_NB_state_sent4;\n        }\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_sent4) {\n        /* Send mode, size, and basename */\n        base = (unsigned char *) strrchr(path, '/');\n        if (base) {\n            base++;\n        } else {\n            base = (unsigned char *) path;\n        }\n\n        session->scpSend_response_len =\n            snprintf((char *) session->scpSend_response,\n                     LIBSSH2_SCP_RESPONSE_BUFLEN, \"C0%o %lu %s\\n\", mode,\n                     (unsigned long) size, base);\n        _libssh2_debug(session, LIBSSH2_DBG_SCP, \"Sent %s\",\n                       session->scpSend_response);\n\n        session->scpSend_state = libssh2_NB_state_sent5;\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_sent5) {\n        rc = libssh2_channel_write_ex(session->scpSend_channel, 0,\n                                      (char *) session->scpSend_response,\n                                      session->scpSend_response_len);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block send core file data for SCP file\", 0);\n            return NULL;\n        } else if (rc != (int)session->scpSend_response_len) {\n            libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,\n                          \"Unable to send core file data for SCP file\", 0);\n            goto scp_send_error;\n        }\n\n        session->scpSend_state = libssh2_NB_state_sent6;\n    }\n\n    if (session->scpSend_state == libssh2_NB_state_sent6) {\n        /* Wait for ACK */\n        rc = libssh2_channel_read_ex(session->scpSend_channel, 0,\n                                     (char *) session->scpSend_response, 1);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block waiting for response\", 0);\n            return NULL;\n        } else if (rc <= 0) {\n            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                          \"Invalid ACK response from remote\", 0);\n            goto scp_send_error;\n        } else if (session->scpSend_response[0] != 0) {\n            /*\n             * Set this as the default error for here, if\n             * we are successful it will be replaced\n             */\n            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                          \"Invalid ACK response from remote\", 0);\n\n            session->scpSend_err_len =\n                _libssh2_channel_packet_data_len(session->scpSend_channel, 0);\n            session->scpSend_err_msg =\n                LIBSSH2_ALLOC(session, session->scpSend_err_len + 1);\n            if (!session->scpSend_err_msg) {\n                goto scp_send_error;\n            }\n            memset(session->scpSend_err_msg, 0, session->scpSend_err_len + 1);\n\n            /* Read the remote error message */\n            rc = libssh2_channel_read_ex(session->scpSend_channel, 0,\n                                         session->scpSend_err_msg,\n                                         session->scpSend_err_len);\n            if (rc <= 0) {\n                /*\n                 * Since we have alread started reading this packet, it is\n                 * already in the systems so it can't return PACKET_EAGAIN\n                 */\n                LIBSSH2_FREE(session, session->scpSend_err_msg);\n                session->scpSend_err_msg = NULL;\n                goto scp_send_error;\n            }\n\n            libssh2_error(session, LIBSSH2_ERROR_SCP_PROTOCOL,\n                          session->scpSend_err_msg, 1);\n            session->scpSend_err_msg = NULL;\n            goto scp_send_error;\n        }\n    }\n\n    session->scpSend_state = libssh2_NB_state_idle;\n\n    return session->scpSend_channel;\n\n  scp_send_error:\n    while (libssh2_channel_free(session->scpSend_channel) == PACKET_EAGAIN);\n    session->scpSend_channel = NULL;\n    session->scpSend_state = libssh2_NB_state_idle;\n    return NULL;\n}", "path": "ssh2\\src\\scp.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * channel_forward_accept\n *\n * Accept a connection\n */\n", "func_signal": "static LIBSSH2_CHANNEL *\nchannel_forward_accept(LIBSSH2_LISTENER *listener)", "code": "{\n    libssh2pack_t rc;\n\n    do {\n        rc = _libssh2_transport_read(listener->session);\n        if (rc == PACKET_EAGAIN) {\n            libssh2_error(listener->session, LIBSSH2_ERROR_EAGAIN,\n                          \"Would block waiting for packet\", 0);\n            return NULL;\n        }\n    } while (rc > 0);\n\n    if (listener->queue) {\n        LIBSSH2_SESSION *session = listener->session;\n        LIBSSH2_CHANNEL *channel;\n\n        channel = listener->queue;\n\n        listener->queue = listener->queue->next;\n        if (listener->queue) {\n            listener->queue->prev = NULL;\n        }\n\n        channel->prev = NULL;\n        channel->next = session->channels.head;\n        session->channels.head = channel;\n\n        if (channel->next) {\n            channel->next->prev = channel;\n        } else {\n            session->channels.tail = channel;\n        }\n        listener->queue_size--;\n\n        return channel;\n    }\n\n    return NULL;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_direct_tcpip_ex\n *\n * Tunnel TCP/IP connect through the SSH session to direct host/port\n */\n", "func_signal": "static LIBSSH2_CHANNEL *\nchannel_direct_tcpip(LIBSSH2_SESSION * session, const char *host,\n                     int port, const char *shost, int sport)", "code": "{\n    LIBSSH2_CHANNEL *channel;\n    unsigned char *s;\n\n    if (session->direct_state == libssh2_NB_state_idle) {\n        session->direct_host_len = strlen(host);\n        session->direct_shost_len = strlen(shost);\n        /* host_len(4) + port(4) + shost_len(4) + sport(4) */\n        session->direct_message_len =\n            session->direct_host_len + session->direct_shost_len + 16;\n\n        _libssh2_debug(session, LIBSSH2_DBG_CONN,\n                       \"Requesting direct-tcpip session to from %s:%d to %s:%d\",\n                       shost, sport, host, port);\n\n        s = session->direct_message =\n            LIBSSH2_ALLOC(session, session->direct_message_len);\n        if (!session->direct_message) {\n            libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                          \"Unable to allocate memory for direct-tcpip connection\",\n                          0);\n            return NULL;\n        }\n        _libssh2_htonu32(s, session->direct_host_len);\n        s += 4;\n        memcpy(s, host, session->direct_host_len);\n        s += session->direct_host_len;\n        _libssh2_htonu32(s, port);\n        s += 4;\n\n        _libssh2_htonu32(s, session->direct_shost_len);\n        s += 4;\n        memcpy(s, shost, session->direct_shost_len);\n        s += session->direct_shost_len;\n        _libssh2_htonu32(s, sport);\n        s += 4;\n    }\n\n    channel =\n        libssh2_channel_open_ex(session, \"direct-tcpip\",\n                                sizeof(\"direct-tcpip\") - 1,\n                                LIBSSH2_CHANNEL_WINDOW_DEFAULT,\n                                LIBSSH2_CHANNEL_PACKET_DEFAULT,\n                                (char *) session->direct_message,\n                                session->direct_message_len);\n\n    /* by default we set (keep?) idle state... */\n    session->direct_state = libssh2_NB_state_idle;\n\n    if (!channel) {\n        if (libssh2_session_last_errno(session) == LIBSSH2_ERROR_EAGAIN) {\n            /* The error code is still set to LIBSSH2_ERROR_EAGAIN,\n               set our state to created to avoid re-creating the package\n               on next invoke */\n            session->direct_state = libssh2_NB_state_created;\n            return NULL;\n        } else {\n            LIBSSH2_FREE(session, session->direct_message);\n            session->direct_message = NULL;\n            return NULL;\n        }\n    }\n\n    LIBSSH2_FREE(session, session->direct_message);\n    session->direct_message = NULL;\n\n    return channel;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * _libssh2_channel_packet_data_len\n *\n * Return the size of the data block of the current packet, or 0 if there\n * isn't a packet.\n */\n", "func_signal": "unsigned long\n_libssh2_channel_packet_data_len(LIBSSH2_CHANNEL * channel, int stream_id)", "code": "{\n    LIBSSH2_SESSION *session = channel->session;\n    LIBSSH2_PACKET *read_packet;\n    uint32_t read_local_id;\n\n    if ((read_packet = session->packets.head) == NULL) {\n        return 0;\n    }\n\n    while (read_packet) {\n        read_local_id = _libssh2_ntohu32(read_packet->data + 1);\n\n        /*\n         * Either we asked for a specific extended data stream\n         * (and data was available),\n         * or the standard stream (and data was available),\n         * or the standard stream with extended_data_merge\n         * enabled and data was available\n         */\n        if ((stream_id\n             && (read_packet->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA)\n             && (channel->local.id == read_local_id)\n             && (stream_id == (int) _libssh2_ntohu32(read_packet->data + 5)))\n            ||\n            (!stream_id\n             && (read_packet->data[0] == SSH_MSG_CHANNEL_DATA)\n             && (channel->local.id == read_local_id))\n            ||\n            (!stream_id\n             && (read_packet->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA)\n             && (channel->local.id == read_local_id)\n             && (channel->remote.extended_data_ignore_mode\n                 == LIBSSH2_CHANNEL_EXTENDED_DATA_MERGE)))\n        {\n            return (read_packet->data_len - read_packet->data_head);\n        }\n        read_packet = read_packet->next;\n    }\n\n    return 0;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/* decrypt() decrypts 'len' bytes from 'source' to 'dest'.\n *\n * returns PACKET_NONE on success and PACKET_FAIL on failure\n */\n", "func_signal": "static libssh2pack_t\ndecrypt(LIBSSH2_SESSION * session, unsigned char *source,\n        unsigned char *dest, int len)", "code": "{\n    struct transportpacket *p = &session->packet;\n    int blocksize = session->remote.crypt->blocksize;\n\n    /* if we get called with a len that isn't an even number of blocksizes\n       we risk losing those extra bytes */\n    assert((len % blocksize) == 0);\n\n    while (len >= blocksize) {\n        if (session->remote.crypt->crypt(session, source,\n                                         &session->remote.crypt_abstract)) {\n            libssh2_error(session, LIBSSH2_ERROR_DECRYPT,\n                          (char *) \"Error decrypting packet\", 0);\n            LIBSSH2_FREE(session, p->payload);\n            return PACKET_FAIL;\n        }\n\n        /* if the crypt() function would write to a given address it\n           wouldn't have to memcpy() and we could avoid this memcpy()\n           too */\n        memcpy(dest, source, blocksize);\n\n        len -= blocksize;       /* less bytes left */\n        dest += blocksize;      /* advance write pointer */\n        source += blocksize;    /* advance read pointer */\n    }\n    return PACKET_NONE;         /* all is fine */\n}", "path": "ssh2\\src\\transport.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_x11_req_ex\n * Request X11 forwarding\n */\n", "func_signal": "LIBSSH2_API int\nlibssh2_channel_x11_req_ex(LIBSSH2_CHANNEL *channel, int single_connection,\n                           const char *auth_proto, const char *auth_cookie,\n                           int screen_number)", "code": "{\n    int rc;\n    BLOCK_ADJUST(rc, channel->session,\n                 channel_x11_req(channel, single_connection, auth_proto,\n                                 auth_cookie, screen_number));\n    return rc;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * libssh2_channel_forward_listen_ex\n *\n * Bind a port on the remote host and listen for connections\n */\n", "func_signal": "LIBSSH2_API LIBSSH2_LISTENER *\nlibssh2_channel_forward_listen_ex(LIBSSH2_SESSION *session, const char *host,\n                                  int port, int *bound_port, int queue_maxsize)", "code": "{\n    LIBSSH2_LISTENER *ptr;\n    BLOCK_ADJUST_ERRNO(ptr, session,\n                       channel_forward_listen(session, host, port, bound_port,\n                                              queue_maxsize));\n    return ptr;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "/*\n * _libssh2_channel_flush\n *\n * Flush data from one (or all) stream\n * Returns number of bytes flushed, or negative on failure\n */\n", "func_signal": "int\n_libssh2_channel_flush(LIBSSH2_CHANNEL *channel, int streamid)", "code": "{\n    LIBSSH2_PACKET *packet = channel->session->packets.head;\n\n    if (channel->flush_state == libssh2_NB_state_idle) {\n        channel->flush_refund_bytes = 0;\n        channel->flush_flush_bytes = 0;\n\n        while (packet) {\n            LIBSSH2_PACKET *next = packet->next;\n            unsigned char packet_type = packet->data[0];\n\n            if (((packet_type == SSH_MSG_CHANNEL_DATA)\n                 || (packet_type == SSH_MSG_CHANNEL_EXTENDED_DATA))\n                && (_libssh2_ntohu32(packet->data + 1) == channel->local.id)) {\n                /* It's our channel at least */\n                long packet_stream_id =\n                    (packet_type ==\n                     SSH_MSG_CHANNEL_DATA) ? 0 : _libssh2_ntohu32(packet->data +\n                                                                 5);\n                if ((streamid == LIBSSH2_CHANNEL_FLUSH_ALL)\n                    || ((packet_type == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                        && ((streamid == LIBSSH2_CHANNEL_FLUSH_EXTENDED_DATA)\n                            || (streamid == packet_stream_id)))\n                    || ((packet_type == SSH_MSG_CHANNEL_DATA)\n                        && (streamid == 0))) {\n                    int bytes_to_flush = packet->data_len - packet->data_head;\n\n                    _libssh2_debug(channel->session, LIBSSH2_DBG_CONN,\n                                   \"Flushing %d bytes of data from stream \"\n                                   \"%lu on channel %lu/%lu\",\n                                   bytes_to_flush, packet_stream_id,\n                                   channel->local.id, channel->remote.id);\n\n                    /* It's one of the streams we wanted to flush */\n                    channel->flush_refund_bytes += packet->data_len - 13;\n                    channel->flush_flush_bytes += bytes_to_flush;\n\n                    LIBSSH2_FREE(channel->session, packet->data);\n                    if (packet->prev) {\n                        packet->prev->next = packet->next;\n                    } else {\n                        channel->session->packets.head = packet->next;\n                    }\n                    if (packet->next) {\n                        packet->next->prev = packet->prev;\n                    } else {\n                        channel->session->packets.tail = packet->prev;\n                    }\n                    LIBSSH2_FREE(channel->session, packet);\n                }\n            }\n            packet = next;\n        }\n\n        channel->flush_state = libssh2_NB_state_created;\n    }\n\n    if (channel->flush_refund_bytes) {\n        int rc;\n\n        rc = _libssh2_channel_receive_window_adjust(channel,\n                                                    channel->flush_refund_bytes,\n                                                    0, NULL);\n        if (rc == PACKET_EAGAIN) {\n            return PACKET_EAGAIN;\n        }\n    }\n\n    channel->flush_state = libssh2_NB_state_idle;\n\n    return channel->flush_flush_bytes;\n}", "path": "ssh2\\src\\channel.c", "repo_name": "kruton/connectbot_native", "stars": 4, "license": "None", "language": "c", "size": 696}
{"docstring": "//\n// Reshuffles windows (like Alt+Tab on most window managers)\n//\n", "func_signal": "void next_window(Display *d, Window win, int screen)", "code": "{\n\tprintf(\"EVENT:KEY:next-window\\n\");\n\tstack_shuffle_next_window(d, win, screen); // desktop.h\n}", "path": "keyboard.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Free from memory\n//\n", "func_signal": "void panel_free()", "code": "{\n\tfree_font(font);\n\tfree_font_library();\n\tXDestroyWindow(panel.display, panel.window);\n}", "path": "panel.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Push this window onto the desktop-stack which will also take a new screenshot\n// push_stack checks for existing stack-items and updates them, so we don't need \n// to do any checking here.\n//\n", "func_signal": "void handle_configure(Display *d, Window w, int screen, StateMachine *state)", "code": "{\n\t// make sure window isn't a \"special\" window\n\tprintf(\"check for override-redirect\\n\");\n\tXWindowAttributes win_attribs;\n\tif (!XGetWindowAttributes(d, w, &win_attribs)) {\n\t\tif (win_attribs.override_redirect) {\n\t\t\tprintf(\"override redirect detected, skipping reconfigure\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// push onto window-stack\n\tprintf(\"push window to stack\\n\");\n\tpush_stack(d, w);\n\t\n\t// resize window\n\tprintf(\"do wm reconfigure\\n\");\n\tXWindowChanges changes;\n\tint topY = state->top_screen_reserved_height + LAYOUT_MARGIN;\n\tchanges.x = LAYOUT_MARGIN; // honour margin\n\tchanges.y = topY; // take top panel into consideration\n\tchanges.width = DisplayWidth(d, screen) - (2*LAYOUT_MARGIN); // honour margin\n\tchanges.height = DisplayHeight(d, screen) - topY/*inc. top margin*/ - LAYOUT_MARGIN/*bottom margin*/;\n\t\n\tif (state->is_hidden) {\n\t\tchanges.y = changes.height+1; // prevent configure event taking over from hide_windows in desktop.h\n\t}\n\t\n\tprintf(\"changing window to: x=%d, y=%d, width=%d, height=%d\\n\", changes.x, changes.y, changes.width, changes.height);\n\tXMoveResizeWindow(d, w, changes.x, changes.y, changes.width, changes.height);\n\tXSetInputFocus(d, w, RevertToPointerRoot, CurrentTime); // set focus on create\n\tXFlush(d);\n}", "path": "size_and_stack.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Fish-out any configure events\n//\n", "func_signal": "void handle_configure_event(XEvent e, int screen, StateMachine *state)", "code": "{\n\tif (e.type == CreateNotify) {\n\t\tprintf(\"EVENT: CreateNotify\\n\");\n\t\tif (e.xcreatewindow.parent == RootWindow(e.xany.display, screen)) {\n\t\t\tprintf(\"Create for upper window\\n\");\n\t\t\thandle_configure(e.xany.display, e.xany.window, screen, state); // some client's don't call configure, so we need to capture them here\n\t\t} else {\n\t\t\tprintf(\"ignoring creation for sub-window\\n\");\n\t\t}\n\t}\n\t\n\telse if (e.type == ConfigureNotify) {\n\t\tprintf(\"EVENT: ConfigureNotify\\n\");\n\t\thandle_configure(e.xconfigure.display, e.xconfigure.event, screen, state);\n\t}\n}", "path": "size_and_stack.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Handle events\n//\n", "func_signal": "Bool panel_handle_events(Display *d, XEvent *e, int screen, StateMachine *state)", "code": "{\n\t// only handle panel events\n\tif (e->xany.window == panel.window) // you can do this as Window is an XID, which is an unsigned long :)\n\t{\n\t\tif (e->type == Expose) {\n\t\t\tprintf(\"EVENT: panel exposed\\n\");\n\t\t\tpanel_redraw(d, screen);\n\t\t\treturn True;\n\t\t}\n\t}\n\treturn False; // pass event on to main event handle\n}", "path": "panel.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Get a windowstack by it's title\n//\n", "func_signal": "WindowStack *get_window_with_title(char *title)", "code": "{\n\tWindowStack *sitem = stack;\n\twhile (sitem != NULL) {\n\t\tif (0 == strcmp(sitem->title, title)) {\n\t\t\treturn sitem;\n\t\t}\n\t\tsitem = sitem->next;\n\t}\n\treturn NULL;\n}", "path": "desktop.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Handle keyevents if present in XEvent\n// @returns: True if app should quit\n//\n", "func_signal": "Bool handle_keyevent(XEvent event, Window active_window, int screen, StateMachine *state)", "code": "{\n\n\tif (event.type == KeyPress) {\n\t\tprintf(\"EVENT: key-press[%d]\\n\", event.xkey.keycode);\n\t\treturn handle_press_event(event.xkey, active_window, screen, state);\n\t}\n\t\n\telse if (event.type == KeyRelease) {\n\t\t\tprintf(\"EVENT: key-release[%d]\\n\", event.xkey.keycode);\n\t\t\treturn handle_release_event(event.xkey, active_window, screen, state);\n\t}\t\n\t\n\treturn False;\n}", "path": "keyboard.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Shuffle windows (just like Alt+Tab in desktop managers)\n//\n", "func_signal": "void stack_shuffle_next_window(Display *d, Window win, int screen)", "code": "{\n\tprintf(\"shuffling windows\\n\");\n\tXCirculateSubwindowsUp(d, RootWindow(d, screen));\n\tXFlush(d);\n}", "path": "desktop.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Check composition\n//\n", "func_signal": "Bool init_composite_extension(Display *d, Window root, int screen)", "code": "{\n\thas_composite_extension = False;\n\tint event_base, error_base;\n\tif (XCompositeQueryExtension(d, &event_base, &error_base)) {\n\t\tint major=0, minor=2; // this is the first version which allowed composite\n\t\tXCompositeQueryVersion(d, &major, &minor);\n\t\thas_composite_extension = (major >= 0 || minor > 2);\n\t\t// begin off-screen composition\n\t\tif (has_composite_extension) {\n\t\t\tXCompositeRedirectSubwindows(d, root, CompositeRedirectAutomatic);\n\t\t}\n\t}\n\treturn has_composite_extension;\n}", "path": "composite.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "// program entry point\n", "func_signal": "int main()", "code": "{\n\tprintf(\"opening display\\n\");\n\tDisplay *d = XOpenDisplay(NULL);\n\t\n\tprintf(\"grabbing default screen\\n\");\n\tint screen = DefaultScreen(d);\n\tprintf(\"default screen = %d\\n\", screen);\n\t\n\tprintf(\"grabbing root window\\n\");\n\tWindow root = DefaultRootWindow(d);\n\tpush_stack(d, root); // add desktop window to stack\n\t\n\tprintf(\"check that composite is configured\\n\");\n\tinit_composite_extension(d, root, screen); // composite.h\n\t\n\t// this is where we will store our window references\n\tprintf(\"init desktop\\n\");\n\tstack_init(d, screen); //desktop.h\n\t\n\t// create cursors\n\tstate.cursors[CursorDefault] = XCreateFontCursor(d, XC_left_ptr);\n\tXDefineCursor(d, root, state.cursors[CursorDefault]);\n\t\n\t// tell root window you'll be capturing it's events\n\tXSetWindowAttributes a;\n\ta.event_mask = ExposureMask|KeyPressMask|KeyReleaseMask|StructureNotifyMask|SubstructureNotifyMask;\n\tXSelectInput(d, root, a.event_mask);\n\t\n\t// use a different event mask for child windows\n\ta.event_mask = KeyPressMask|KeyReleaseMask|StructureNotifyMask|SubstructureNotifyMask;\n\t\n\t// handle errors\n\tXSetErrorHandler(handle_xerror);\n\t\n\t// create panel\n\tpanel_create(d, screen, &state);\n\t\n\t// draw root window\n\troot_window_redraw(NULL, d, screen, &state);\n\n\t// capture those events\n\tXEvent e;\n\t\n\t// main event loop\n\twhile (!app_is_done) {\n\t\tXNextEvent(d, &e);\n\t\t\n\t\tif (panel_handle_events(d, &e, screen, &state)) {\n\t\t\tcontinue; // this event has been handled\n\t\t}\n\t\t\n\t\telse if (root_window_handle_events(d, &e, screen, &state)) {\n\t\t\tcontinue; // this event has been handled\n\t\t}\n\t\t\n\t\telse if (e.type == CreateNotify) {\n\t\t\tprintf(\"Event: create\\n\");\n\t\t\tXSelectInput(e.xcreatewindow.display, e.xcreatewindow.window, a.event_mask);\n\t\t}\n\t\t\t\n\t\telse if (e.type == EnterNotify) {\n\t\t\tprintf(\"EVENT: focus-in\\n\");\n\t\t\tfocused_win = e.xcrossing.window;\n\t\t\t//set_opacity(e.xcrossing.display, e.xcrossing.window, 1.0);\n\t\t}\n\t\t\n\t\telse if (e.type == LeaveNotify) {\n\t\t\tprintf(\"EVENT: focus-out\\n\");\n\t\t\t//set_opacity(e.xcrossing.display, e.xcrossing.window, 0.3); // make window dim if not focused\n\t\t}\n\t\t\n\t\t// handle other events\n\t\tapp_is_done = handle_keyevent(e, focused_win, screen, &state); /* keyboard.h */\n\t\thandle_mouseevent(e, focused_win, &state); /* mouse.h */\n\t\thandle_configure_event(e, screen, &state);\n\t}\n\t\n\t// free cursors\n\tint i;\n\tfor (i=0; i<CursorLast; i++) {\n\t\tXFreeCursor(d, state.cursors[i]);\n\t}\n\troot_window_free();\n\tpanel_free();\n\tstack_free();\n\tXCloseDisplay(d); // shutdown xlib gracefully\n\treturn 0;\n}", "path": "main.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Handle a keypress on any window (inc. Root window)\n//\n", "func_signal": "Bool handle_release_event(XKeyEvent event, Window active_window, int screen, StateMachine *state)", "code": "{\n\tBool should_quit = False;\n\tXComposeStatus status;\n\tKeySym keysym;\n\tchar keybuffer[2];\n\tint length;\n\t\n\t// translate the vendor-dependent keycode to a keysym and string\n\tlength = XLookupString(&event, keybuffer, 1, &keysym, &status);\n\t\n\t// check for release of mod key\n\tprintf(\"keysym=%x\\n\", (int)keysym);\n\t//if ( !(event.state & Mod1Mask || event.state & Mod2Mask) ) {\n\t//\tprintf(\"mod released\\n\");\n\t//\tstate->mod_down = False;\n\t//}\n\t\n\tif (keysym == XK_Hyper_L) {\n\t\tprintf(\"hyper_l released\\n\");\n\t}\n\t\n\tif (keysym == XK_Meta_L) {\n\t\tprintf(\"meta_l released\\n\");\n\t}\n\t\n\tif (keysym == XK_Super_L) {\n\t\tprintf(\"super released\\n\");\n\t}\n\t\n\t// actions-keys are only action-keys when the Mod key is depressed\n\tif (event.state & Mod1Mask || event.state & Mod2Mask) {\n\t\tswitch (keysym) {\n\t\t\tcase ACTIONKEY_QUIT:\n\t\t\t\tshould_quit = True;\n\t\t\t\tbreak;\n\t\t\tcase ACTIONKEY_LAUNCHER:\n\t\t\t\texec_launcher();\n\t\t\t\tbreak;\t\t\t\t\n\t\t\tcase ACTIONKEY_SNAPSHOT:\n\t\t\t\tsnapshot_window(event.display, active_window);\n\t\t\t\tbreak;\n\t\t\tcase ACTIONKEY_KILL_WINDOW:\n\t\t\t\tkill_window(event.display, active_window);\n\t\t\t\tbreak;\n\t\t\tcase ACTIONKEY_NEXT_WINDOW:\n\t\t\t\tnext_window(event.display, active_window, screen);\n\t\t\t\tbreak;\n\t\t\tcase ACTIONKEY_HIDE_ALL_WINDOWS:\n\t\t\t\thide_all_windows(event.display, screen, state);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn should_quit;\n}", "path": "keyboard.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Kill a window\n//\n", "func_signal": "void kill_window(Display *d, Window win)", "code": "{\n\tint result = XDestroyWindow(d, win);\n\tif (result == BadWindow) {\n\t\tfprintf(stderr, \"Could not kill window as it no longer exists\\n\");\n\t}\n}", "path": "keyboard.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Take a snapshot of the given window\n//\n", "func_signal": "void snapshot_window(Display *d, Window win_handle)", "code": "{\n\tprintf(\"attempting to snapshot active window\\n\");\n\t\n\t// can only happen if composite is initialized and configured\n\tif (!has_composite_extension) {\n\t\tfprintf(stderr, \"Cannot snapshot window as composite extension is not enabled\\n\");\n\t\treturn;\n\t}\n\t\n\tprintf(\"WARNING: snapshot_window does nothing currently\\n\");\n\t// add this window to the stack\n\t//push_stack(d, win_handle);\n\t//redraw_stack();\n\n\t/*\n\t// draw to root window with xlib\n\tint screen = DefaultScreen(d);\n\tWindow root = RootWindow(d,screen);\n\tXGetWindowAttributes(d, root, &root_attribs);\n\tGC gc = XCreateGC(d, root, 0, NULL);\n\tXSetForeground(d, gc, WhitePixel(d,0)); // make sure the fg color is white\n\tXFillRectangle(d, root, gc, 0, 0, root_attribs.width, root_attribs.height); // clear root window with fg color\n\tXPutImage(d, root, gc, img, 0, 0, 400, 400, width, height); // draw snapshot to root window at an offset\n\tXDestroyImage(img);\n\t*/\n\t\n\tprintf(\"snapshot taken\\n\");\n}", "path": "composite.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Redraw\n//\n", "func_signal": "void panel_redraw(Display *d, int screen)", "code": "{\n\tcairo_pattern_t *pattern; // for defining gradients\n\tcairo_surface_t *surface=cairo_xlib_surface_create(d, panel.window, panel.visual, panel.width, panel.height + LAYOUT_MARGIN/*for gradient*/);\n\tcairo_t *cr = cairo_create(surface);\n\t\n\t// clear surface with the configured panel bg colour\n\tconst int panel_gradient_offset = 2;\n\tpattern = cairo_pattern_create_linear(0.0, panel_gradient_offset, 0.0, panel.height);\n\tcairo_pattern_add_color_stop_rgba(pattern, 0.0, DOCKPANEL_BG_RGB_LIGHT, 1);\n\tcairo_pattern_add_color_stop_rgba(pattern, 0.1, DOCKPANEL_BG_RGB_MEDIUM, 1);\n\tcairo_pattern_add_color_stop_rgba(pattern, 0.5, DOCKPANEL_BG_RGB_DARK, 1);\n\tcairo_set_source(cr, pattern);\n\tcairo_rectangle(cr, 0, 0, panel.width, panel.height);\n\tcairo_fill(cr);\n\tcairo_pattern_destroy(pattern);\n\t\n\t// draw shadow\n\tpattern = cairo_pattern_create_linear(0.0, panel.height, 0.0/*x stop coordinate*/, panel.height+LAYOUT_MARGIN/*specifies Y stop coordinate NOT height*/);\n\tcairo_pattern_add_color_stop_rgba(pattern, 0/*pos*/, 0, 0, 0, 1);\n\tcairo_pattern_add_color_stop_rgba(pattern, 1/*pos*/, ROOT_WINDOW_BG_RGB, 1); // TODO: don't fake transparency\n\tcairo_rectangle(cr, 0, panel.height, panel.width, LAYOUT_MARGIN);\n\tcairo_set_source(cr, pattern);\n\t//cairo_set_source_rgb(cr, 0.5, 0.5, 0.5);\n\tcairo_fill(cr);\n\tcairo_pattern_destroy(pattern);\n\t\n\t// TODO: add draw code here\n\tcairo_set_source_rgb(cr, 1, 1, 1);\n\tcairo_set_font_face(cr, font.cairo_font);\n  cairo_set_font_size(cr, 26);\n  cairo_move_to(cr, 10, 30);\n  cairo_show_text(cr, DOCKPANEL_LOGO_LETTER);\n\t\n\tcairo_destroy(cr);\n\tcairo_surface_destroy(surface);\n}", "path": "panel.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// \n//\n", "func_signal": "unsigned int init_font(FontFace *font, char *path)", "code": "{\n\tunsigned int result = FT_New_Face(library, path, 0, &font->ft_font);\n\tif (0 == result) {\n\t\tfont->cairo_font = cairo_ft_font_face_create_for_ft_face(font->ft_font, 0);\n\t}\n\treturn result;\n}", "path": "fonts.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Add a new window to the stack\n//\n", "func_signal": "WindowStack *push_stack(Display *d, Window window)", "code": "{\n/*\n\tWindowStack *sitem = NULL;\n\t// see if this window is already in the stack\n\tprintf(\"see if window is already in stack\\n\");\n\tWindowStack *iter = stack;\n\twhile (iter != NULL) {\n\t\tif (iter->window == window) { // we can do this as windows are just unsigned longs\n\t\t\tbreak;\n\t\t}\n\t\titer = iter->next;\n\t}\n\tif (iter != NULL) { // if we haven't reached NULL, the break was called above and we have an existing window!\n\t\t\n\t\t// update existing stack item\n\t\tprintf(\"update existing item\\n\");\n\t\tsitem = iter;\n\t\t\n\t} else {\n\t\t\n\t\t// create a new stack item\n\t\tprintf(\"new window to add to stack\\n\");\n\t\tsitem = (WindowStack *)malloc(sizeof(WindowStack));\n\t\tsitem->window = window;\n\t\tsitem->display = d;\n\t\tif (stack != NULL) {\n\t\t\tsitem->next = stack; // add to stack\n\t\t}\n\t\tstack = sitem; // add item to top of stack\t\n\t}\n\t\n\tif (sitem == NULL) {\n\t\tprintf(\"sitem was NULL when unexpected\\n\");\n\t\treturn stack;\n\t}\n\t\n\t// get/update screenshot\n\tprintf(\"get window properties\\n\");\n\tXWindowAttributes a;\n\tif (XGetWindowAttributes(d, window, &a)) {\n\t\t\n\t\t// release old one if present\n\t\t//printf(\"release old screenshot if present\\n\");\n\t\t//if (sitem->screenshot != NULL) XDestroyImage(sitem->screenshot);\n\t\t\n\t\t// create new one\n\t\t//printf(\"create new screenshot\\n\");\n\t\t//sitem->screenshot = XGetImage(d, window, 0, 0, a.width, a.height, AllPlanes, ZPixmap);\n\t\t\n\t}\n\t\n\t// get window title\n\tprintf(\"get window title\\n\");\n\tXTextProperty prop_title;\n\tint i=0;\n\tif ( !XGetWMName(d, window, &prop_title) ) {\n\t\tprintf(\"title retrieved from Xlib\\n\");\n\t\tsitem->title = (char *)prop_title.value;\n\t} else {\n\t\tprintf(\"titled created from scratch\\n\");\n\t\tchar *title = (char *)malloc(sizeof(char) * 11); // upto 99 unnamed windows\n\t\tsprintf(title, \"Untitled%d\", ++i);\n\t\tsitem->title = title;\n\t}\n*/\t\n\treturn stack; \n}", "path": "desktop.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Handle mouse events in main event loop\n//\n", "func_signal": "void handle_mouseevent(XEvent event, Window active_window, StateMachine *state)", "code": "{\n\tif (event.type == ButtonPress) {\n\t\tprintf(\"EVENT: button pressed\\n\");\n\t\thandle_buttonpress_event(event.xbutton, active_window, state);\n\t}\n\t\n\telse if (event.type == ButtonRelease) {\n\t\tprintf(\"EVENT: button released\\n\");\n\t\thandle_buttonrelease_event(event.xbutton, active_window, state);\n\t}\n\t\n\telse if (event.type == MotionNotify) {\n\t\thandle_motion_event(event.xmotion, active_window, state);\n\t}\n}", "path": "mouse.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Create the panel\n//\n", "func_signal": "void panel_create(Display *d, int screen, StateMachine *state)", "code": "{\n\tprintf(\"panel_create\\n\");\n\t\n\t// open font library\n\tinit_font_library();\n\tinit_font(&font, DOCKPANEL_LOGO_FONT_PATH);\n\t\n\t// create panel\n\tpanel.parent  = RootWindow(d, screen); // owned by root\n\tpanel.height  = DOCKPANEL_HEIGHT; // config.h\n\tpanel.width   = DisplayWidth(d, screen); // stretch\n\tpanel.visual  = DefaultVisual(d, screen);\n\tpanel.display = d;\n\tpanel.screen  = screen;\n\tpanel.attributes.event_mask = ExposureMask;\n\tpanel.attributes.background_pixel = BlackPixel(d, screen);\n\tpanel.attributes.override_redirect = True;\n\tpanel.attribute_mask = CWEventMask | CWBackPixel | CWOverrideRedirect;\n\tpanel.window  = XCreateWindow(d, panel.parent, LAYOUT_MARGIN, 0, panel.width-(2*LAYOUT_MARGIN), panel.height+LAYOUT_MARGIN/*for shadow*/, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0, CopyFromParent, InputOutput, panel.visual, panel.attribute_mask, &panel.attributes);\n\t\n\t// reserve part of screen\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tprintf(\"reserving top of screen %d\\n\", DOCKPANEL_HEIGHT);\n\tstate->top_screen_reserved_height = DOCKPANEL_HEIGHT;\n\tstate->panel_id = panel.window;\n\t\n\t// default cursor\n\tXDefineCursor(d, panel.window, state->cursors[CursorDefault]);\n\t\n\t// map to screen\t\t\t\n\tprintf(\"drawing panel to screen\\n\");\n\tXMapRaised(panel.display, panel.window);\n}", "path": "panel.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "//\n// Hide All Windows\n//\n", "func_signal": "void stack_hide_all_windows(Display *d, int screen, StateMachine *state)", "code": "{\n\tprintf(\"Hiding all windows\\n\");\n\tWindow target = RootWindow(d, screen);\n\tWindow root, parent;\n\tWindow *child;\n\tunsigned int i, count;\n\tunsigned int bottom_screen = (DisplayHeight(d, screen));\n\tif (XQueryTree(d, target, &root, &parent, &child, &count))\n\t{\n\t\tprintf(\"found %d windows to hide\\n\", count);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (*child != state->panel_id) { // panel is exempt\n\t\t\t\tif (state->is_hidden) {\n\t\t\t\t\tXMoveWindow(d, *child, 0, state->top_screen_reserved_height); // restore all windows\n\t\t\t\t} else {\n\t\t\t\t\tXMoveWindow(d, *child, 0, bottom_screen+1); // hide all windows off screen\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild++;\n\t\t}\n\t\tstate->is_hidden = !(state->is_hidden); // swap state->is_hidden marker\n\t\tXFlush(d);\n\t} else {\n\t\tprintf(\"failed to query window tree\\n\");\n\t}\n}", "path": "desktop.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "// handle errors\n", "func_signal": "int handle_xerror(Display *dpy, XErrorEvent *ee)", "code": "{\n\tint i=0, alen = sizeof(ee) / sizeof(XErrorEvent);\n\tfor (i=0; i<alen; i++) {\n\t\tfprintf(stderr, \"An error occurred: %d\\n\", ee[i].error_code);\n\t}\n\treturn 0;\n}", "path": "main.c", "repo_name": "tommed/tuxwm", "stars": 7, "license": "None", "language": "c", "size": 136}
{"docstring": "/* Get the DST timezone offset for the time passed in */\n", "func_signal": "JSInt64\nPRMJ_DSTOffset(JSInt64 local_time)", "code": "{\n    JSInt64 us2s;\n    time_t local;\n    JSInt32 diff;\n    JSInt64  maxtimet;\n    struct tm tm;\n    PRMJTime prtm;\n#ifndef HAVE_LOCALTIME_R\n    struct tm *ptm;\n#endif\n\n\n    JSLL_UI2L(us2s, PRMJ_USEC_PER_SEC);\n    JSLL_DIV(local_time, local_time, us2s);\n\n    /* get the maximum of time_t value */\n    JSLL_UI2L(maxtimet,PRMJ_MAX_UNIX_TIMET);\n\n    if(JSLL_CMP(local_time,>,maxtimet)){\n        JSLL_UI2L(local_time,PRMJ_MAX_UNIX_TIMET);\n    } else if(!JSLL_GE_ZERO(local_time)){\n        /*go ahead a day to make localtime work (does not work with 0) */\n        JSLL_UI2L(local_time,PRMJ_DAY_SECONDS);\n    }\n    JSLL_L2UI(local,local_time);\n    PRMJ_basetime(local_time,&prtm);\n#ifndef HAVE_LOCALTIME_R\n    ptm = localtime(&local);\n    if(!ptm){\n        return JSLL_ZERO;\n    }\n    tm = *ptm;\n#else\n    localtime_r(&local,&tm); /* get dst information */\n#endif\n\n    diff = ((tm.tm_hour - prtm.tm_hour) * PRMJ_HOUR_SECONDS) +\n\t((tm.tm_min - prtm.tm_min) * 60);\n\n    if(diff < 0){\n\tdiff += PRMJ_DAY_SECONDS;\n    }\n\n    JSLL_UI2L(local_time,diff);\n\n    JSLL_MUL(local_time,local_time,us2s);\n\n    return(local_time);\n}", "path": "js\\prmjtime.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 9.1.1.1 XML [[Get]] and 9.2.1.1 XMLList [[Get]]. */\n", "func_signal": "static JSBool\nGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)", "code": "{\n    JSXML *xml, *list, *kid;\n    uint32 index;\n    JSObject *kidobj, *listobj;\n    JSXMLQName *nameqn;\n    jsid funid;\n    jsval roots[2];\n    JSTempValueRooter tvr;\n    JSBool attributes;\n    JSXMLArrayCursor cursor;\n\n    xml = (JSXML *) JS_GetInstancePrivate(cx, obj, &js_XMLClass, NULL);\n    if (!xml)\n        return JS_TRUE;\n\n    if (js_IdIsIndex(id, &index)) {\n        if (xml->xml_class != JSXML_CLASS_LIST) {\n            *vp = (index == 0) ? OBJECT_TO_JSVAL(obj) : JSVAL_VOID;\n        } else {\n            /*\n             * ECMA-357 9.2.1.1 starts here.\n             *\n             * Erratum: 9.2 is not completely clear that indexed properties\n             * correspond to kids, but that's what it seems to say, and it's\n             * what any sane user would want.\n             */\n            if (index < xml->xml_kids.length) {\n                kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);\n                if (!kid) {\n                    *vp = JSVAL_VOID;\n                    return JS_TRUE;\n                }\n                kidobj = js_GetXMLObject(cx, kid);\n                if (!kidobj)\n                    return JS_FALSE;\n\n                *vp = OBJECT_TO_JSVAL(kidobj);\n            } else {\n                *vp = JSVAL_VOID;\n            }\n        }\n        return JS_TRUE;\n    }\n\n    /*\n     * ECMA-357 9.2.1.1/9.1.1.1 qname case.\n     */\n    nameqn = ToXMLName(cx, id, &funid);\n    if (!nameqn)\n        return JS_FALSE;\n    if (funid)\n        return js_GetXMLFunction(cx, obj, funid, vp);\n\n    roots[0] = OBJECT_TO_JSVAL(nameqn->object);\n    JS_PUSH_TEMP_ROOT(cx, 1, roots, &tvr);\n\n    listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);\n    if (listobj) {\n        roots[1] = OBJECT_TO_JSVAL(listobj);\n        tvr.count++;\n\n        list = (JSXML *) JS_GetPrivate(cx, listobj);\n        attributes = (OBJ_GET_CLASS(cx, nameqn->object) ==\n                      &js_AttributeNameClass);\n\n        if (xml->xml_class == JSXML_CLASS_LIST) {\n            XMLArrayCursorInit(&cursor, &xml->xml_kids);\n            while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n                if (kid->xml_class == JSXML_CLASS_ELEMENT &&\n                    !GetNamedProperty(cx, kid, nameqn, attributes, list)) {\n                    listobj = NULL;\n                    break;\n                }\n            }\n            XMLArrayCursorFinish(&cursor);\n        } else {\n            if (!GetNamedProperty(cx, xml, nameqn, attributes, list))\n                listobj = NULL;\n        }\n\n        /*\n         * Erratum: ECMA-357 9.1.1.1 misses that [[Append]] sets the given\n         * list's [[TargetProperty]] to the property that is being appended.\n         * This means that any use of the internal [[Get]] property returns\n         * a list which, when used by e.g. [[Insert]] duplicates the last\n         * element matched by id.\n         * See bug 336921.\n         */\n        list->xml_target = xml;\n        list->xml_targetprop = nameqn;\n        *vp = OBJECT_TO_JSVAL(listobj);\n    }\n\n    JS_POP_TEMP_ROOT(cx, &tvr);\n    return listobj != NULL;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/*\n * These cannot be exposed to web content, and chrome does not need them, so\n * we take them out of the Mozilla client altogether.  Fortunately, there is\n * no way to serialize a native function (see fun_xdrObject in jsfun.c).\n */\n", "func_signal": "static JSBool\nscript_freeze(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\n              jsval *rval)", "code": "{\n    JSXDRState *xdr;\n    JSScript *script;\n    JSBool ok, hasMagic;\n    uint32 len;\n    void *buf;\n    JSString *str;\n\n    if (!JS_InstanceOf(cx, obj, &js_ScriptClass, argv))\n        return JS_FALSE;\n    script = (JSScript *) JS_GetPrivate(cx, obj);\n    if (!script)\n        return JS_TRUE;\n\n    /* create new XDR */\n    xdr = JS_XDRNewMem(cx, JSXDR_ENCODE);\n    if (!xdr)\n        return JS_FALSE;\n\n    /* write  */\n    ok = js_XDRScript(xdr, &script, &hasMagic);\n    if (!ok)\n        goto out;\n    if (!hasMagic) {\n        *rval = JSVAL_VOID;\n        goto out;\n    }\n\n    buf = JS_XDRMemGetData(xdr, &len);\n    if (!buf) {\n        ok = JS_FALSE;\n        goto out;\n    }\n\n    JS_ASSERT((jsword)buf % sizeof(jschar) == 0);\n    len /= sizeof(jschar);\n    str = JS_NewUCStringCopyN(cx, (jschar *)buf, len);\n    if (!str) {\n        ok = JS_FALSE;\n        goto out;\n    }\n\n#if IS_BIG_ENDIAN\n  {\n    jschar *chars;\n    uint32 i;\n\n    /* Swap bytes in Unichars to keep frozen strings machine-independent. */\n    chars = JS_GetStringChars(str);\n    for (i = 0; i < len; i++)\n        chars[i] = JSXDR_SWAB16(chars[i]);\n  }\n#endif\n    *rval = STRING_TO_JSVAL(str);\n\nout:\n    JS_XDRDestroy(xdr);\n    return ok;\n}", "path": "js\\jsscript.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 9.1.1.2 XML [[Put]] and 9.2.1.2 XMLList [[Put]]. */\n", "func_signal": "static JSBool\nPutProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)", "code": "{\n    JSBool ok, primitiveAssign;\n    enum { OBJ_ROOT, ID_ROOT, VAL_ROOT };\n    jsval roots[3];\n    JSTempValueRooter tvr;\n    JSXML *xml, *vxml, *rxml, *kid, *attr, *parent, *copy, *kid2, *match;\n    JSObject *vobj, *nameobj, *attrobj, *parentobj, *kidobj, *copyobj;\n    JSXMLQName *targetprop, *nameqn, *attrqn;\n    uint32 index, i, j, k, n, q;\n    jsval attrval, nsval, junk;\n    jsid funid;\n    JSString *left, *right, *space;\n    JSXMLNamespace *ns;\n\n    xml = (JSXML *) JS_GetInstancePrivate(cx, obj, &js_XMLClass, NULL);\n    if (!xml)\n        return JS_TRUE;\n\n    xml = CHECK_COPY_ON_WRITE(cx, xml, obj);\n    if (!xml)\n        return JS_FALSE;\n\n    /* Precompute vxml for 9.2.1.2 2(c)(vii)(2-3) and 2(d) and 9.1.1.2 1. */\n    vxml = NULL;\n    if (!JSVAL_IS_PRIMITIVE(*vp)) {\n        vobj = JSVAL_TO_OBJECT(*vp);\n        if (OBJECT_IS_XML(cx, vobj))\n            vxml = (JSXML *) JS_GetPrivate(cx, vobj);\n    }\n\n    /* Control flow after here must exit via label out. */\n    ok = js_EnterLocalRootScope(cx);\n    if (!ok)\n        return JS_FALSE;\n    roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);\n    roots[ID_ROOT] = id;\n    roots[VAL_ROOT] = *vp;\n    JS_PUSH_TEMP_ROOT(cx, 3, roots, &tvr);\n\n    if (xml->xml_class == JSXML_CLASS_LIST) {\n        /* ECMA-357 9.2.1.2. */\n        if (js_IdIsIndex(id, &index)) {\n            /* Step 1 sets i to the property index. */\n            i = index;\n\n            /* 2(a-b). */\n            if (xml->xml_target) {\n                ok = ResolveValue(cx, xml->xml_target, &rxml);\n                if (!ok)\n                    goto out;\n                if (!rxml)\n                    goto out;\n                JS_ASSERT(rxml->object);\n            } else {\n                rxml = NULL;\n            }\n\n            /* 2(c). */\n            if (index >= xml->xml_kids.length) {\n                /* 2(c)(i). */\n                if (rxml) {\n                    if (rxml->xml_class == JSXML_CLASS_LIST) {\n                        if (rxml->xml_kids.length != 1)\n                            goto out;\n                        rxml = XMLARRAY_MEMBER(&rxml->xml_kids, 0, JSXML);\n                        if (!rxml)\n                            goto out;\n                        ok = js_GetXMLObject(cx, rxml) != NULL;\n                        if (!ok)\n                            goto out;\n                    }\n\n                    /*\n                     * Erratum: ECMA-357 9.2.1.2 step 2(c)(ii) sets\n                     * _y.[[Parent]] = r_ where _r_ is the result of\n                     * [[ResolveValue]] called on _x.[[TargetObject]] in\n                     * 2(a)(i).  This can result in text parenting text:\n                     *\n                     *    var MYXML = new XML();\n                     *    MYXML.appendChild(new XML(\"<TEAM>Giants</TEAM>\"));\n                     *\n                     * (testcase from Werner Sharp <wsharp@macromedia.com>).\n                     *\n                     * To match insertChildAfter, insertChildBefore,\n                     * prependChild, and setChildren, we should silently\n                     * do nothing in this case.\n                     */\n                    if (!JSXML_HAS_KIDS(rxml))\n                        goto out;\n                }\n\n                /* 2(c)(ii) is distributed below as several js_NewXML calls. */\n                targetprop = xml->xml_targetprop;\n                if (!targetprop || IS_STAR(targetprop->localName)) {\n                    /* 2(c)(iv)(1-2), out of order w.r.t. 2(c)(iii). */\n                    kid = js_NewXML(cx, JSXML_CLASS_TEXT);\n                    if (!kid)\n                        goto bad;\n                } else {\n                    nameobj = js_GetXMLQNameObject(cx, targetprop);\n                    if (!nameobj)\n                        goto bad;\n                    if (OBJ_GET_CLASS(cx, nameobj) == &js_AttributeNameClass) {\n                        /*\n                         * 2(c)(iii)(1-3).\n                         * Note that rxml can't be null here, because target\n                         * and targetprop are non-null.\n                         */\n                        ok = GetProperty(cx, rxml->object, id, &attrval);\n                        if (!ok)\n                            goto out;\n                        if (JSVAL_IS_PRIMITIVE(attrval)) /* no such attribute */\n                            goto out;\n                        attrobj = JSVAL_TO_OBJECT(attrval);\n                        attr = (JSXML *) JS_GetPrivate(cx, attrobj);\n                        if (JSXML_LENGTH(attr) != 0)\n                            goto out;\n\n                        kid = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);\n                    } else {\n                        /* 2(c)(v). */\n                        kid = js_NewXML(cx, JSXML_CLASS_ELEMENT);\n                    }\n                    if (!kid)\n                        goto bad;\n\n                    /* An important bit of 2(c)(ii). */\n                    kid->name = targetprop;\n                }\n\n                /* Final important bit of 2(c)(ii). */\n                kid->parent = rxml;\n\n                /* 2(c)(vi-vii). */\n                i = xml->xml_kids.length;\n                if (kid->xml_class != JSXML_CLASS_ATTRIBUTE) {\n                    /*\n                     * 2(c)(vii)(1) tests whether _y.[[Parent]]_ is not null.\n                     * y.[[Parent]] is here called kid->parent, which we know\n                     * from 2(c)(ii) is _r_, here called rxml.  So let's just\n                     * test that!  Erratum, the spec should be simpler here.\n                     */\n                    if (rxml) {\n                        JS_ASSERT(JSXML_HAS_KIDS(rxml));\n                        n = rxml->xml_kids.length;\n                        j = n - 1;\n                        if (n != 0 && i != 0) {\n                            for (n = j, j = 0; j < n; j++) {\n                                if (rxml->xml_kids.vector[j] ==\n                                    xml->xml_kids.vector[i-1]) {\n                                    break;\n                                }\n                            }\n                        }\n\n                        kidobj = js_GetXMLObject(cx, kid);\n                        if (!kidobj)\n                            goto bad;\n                        ok = Insert(cx, rxml, j + 1, OBJECT_TO_JSVAL(kidobj));\n                        if (!ok)\n                            goto out;\n                    }\n\n                    /*\n                     * 2(c)(vii)(2-3).\n                     * Erratum: [[PropertyName]] in 2(c)(vii)(3) must be a\n                     * typo for [[TargetProperty]].\n                     */\n                    if (vxml) {\n                        kid->name = (vxml->xml_class == JSXML_CLASS_LIST)\n                                    ? vxml->xml_targetprop\n                                    : vxml->name;\n                    }\n                }\n\n                /* 2(c)(viii). */\n                ok = Append(cx, xml, kid);\n                if (!ok)\n                    goto out;\n            }\n\n            /* 2(d). */\n            if (!vxml ||\n                vxml->xml_class == JSXML_CLASS_TEXT ||\n                vxml->xml_class == JSXML_CLASS_ATTRIBUTE) {\n                ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);\n                if (!ok)\n                    goto out;\n                roots[VAL_ROOT] = *vp;\n            }\n\n            /* 2(e). */\n            kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);\n            if (!kid)\n                goto out;\n            parent = kid->parent;\n            if (kid->xml_class == JSXML_CLASS_ATTRIBUTE) {\n                nameobj = js_GetAttributeNameObject(cx, kid->name);\n                if (!nameobj)\n                    goto bad;\n                id = OBJECT_TO_JSVAL(nameobj);\n\n                if (parent) {\n                    /* 2(e)(i). */\n                    parentobj = js_GetXMLObject(cx, parent);\n                    if (!parentobj)\n                        goto bad;\n                    ok = PutProperty(cx, parentobj, id, vp);\n                    if (!ok)\n                        goto out;\n\n                    /* 2(e)(ii). */\n                    ok = GetProperty(cx, parentobj, id, vp);\n                    if (!ok)\n                        goto out;\n                    attr = (JSXML *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(*vp));\n\n                    /* 2(e)(iii). */\n                    xml->xml_kids.vector[i] = attr->xml_kids.vector[0];\n                }\n            }\n\n            /* 2(f). */\n            else if (vxml && vxml->xml_class == JSXML_CLASS_LIST) {\n                /* 2(f)(i) Create a shallow copy _c_ of _V_. */\n                copyobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);\n                if (!copyobj)\n                    goto bad;\n                copy = (JSXML *) JS_GetPrivate(cx, copyobj);\n                n = vxml->xml_kids.length;\n                ok = XMLArraySetCapacity(cx, &copy->xml_kids, n);\n                if (!ok)\n                    goto out;\n                for (k = 0; k < n; k++) {\n                    kid2 = XMLARRAY_MEMBER(&vxml->xml_kids, k, JSXML);\n                    XMLARRAY_SET_MEMBER(&copy->xml_kids, k, kid2);\n                }\n\n                JS_ASSERT(parent != xml);\n                if (parent) {\n                    q = XMLARRAY_FIND_MEMBER(&parent->xml_kids, kid, NULL);\n                    JS_ASSERT(q != XML_NOT_FOUND);\n\n                    ok = IndexToIdVal(cx, q, &id);\n                    if (!ok)\n                        goto out;\n                    ok = Replace(cx, parent, id, OBJECT_TO_JSVAL(copyobj));\n                    if (!ok)\n                        goto out;\n\n#ifdef DEBUG\n                    /* Erratum: this loop in the spec is useless. */\n                    for (j = 0, n = copy->xml_kids.length; j < n; j++) {\n                        kid2 = XMLARRAY_MEMBER(&parent->xml_kids, q + j, JSXML);\n                        JS_ASSERT(XMLARRAY_MEMBER(&copy->xml_kids, j, JSXML)\n                                  == kid2);\n                    }\n#endif\n                }\n\n                /*\n                 * 2(f)(iv-vi).\n                 * Erratum: notice the unhandled zero-length V basis case and\n                 * the off-by-one errors for the n != 0 cases in the spec.\n                 */\n                if (n == 0) {\n                    XMLArrayDelete(cx, &xml->xml_kids, i, JS_TRUE);\n                } else {\n                    ok = XMLArrayInsert(cx, &xml->xml_kids, i + 1, n - 1);\n                    if (!ok)\n                        goto out;\n\n                    for (j = 0; j < n; j++)\n                        xml->xml_kids.vector[i + j] = copy->xml_kids.vector[j];\n                }\n            }\n\n            /* 2(g). */\n            else if (vxml || JSXML_HAS_VALUE(kid)) {\n                if (parent) {\n                    q = XMLARRAY_FIND_MEMBER(&parent->xml_kids, kid, NULL);\n                    JS_ASSERT(q != XML_NOT_FOUND);\n\n                    ok = IndexToIdVal(cx, q, &id);\n                    if (!ok)\n                        goto out;\n                    ok = Replace(cx, parent, id, *vp);\n                    if (!ok)\n                        goto out;\n\n                    vxml = XMLARRAY_MEMBER(&parent->xml_kids, q, JSXML);\n                    if (!vxml)\n                        goto out;\n                    roots[VAL_ROOT] = *vp = OBJECT_TO_JSVAL(vxml->object);\n                }\n\n                /*\n                 * 2(g)(iii).\n                 * Erratum: _V_ may not be of type XML, but all index-named\n                 * properties _x[i]_ in an XMLList _x_ must be of type XML,\n                 * according to 9.2.1.1 Overview and other places in the spec.\n                 *\n                 * Thanks to 2(d), we know _V_ (*vp here) is either a string\n                 * or an XML/XMLList object.  If *vp is a string, call ToXML\n                 * on it to satisfy the constraint.\n                 */\n                if (!vxml) {\n                    JS_ASSERT(JSVAL_IS_STRING(*vp));\n                    vobj = ToXML(cx, *vp);\n                    if (!vobj)\n                        goto bad;\n                    roots[VAL_ROOT] = *vp = OBJECT_TO_JSVAL(vobj);\n                    vxml = (JSXML *) JS_GetPrivate(cx, vobj);\n                }\n                XMLARRAY_SET_MEMBER(&xml->xml_kids, i, vxml);\n            }\n\n            /* 2(h). */\n            else {\n                kidobj = js_GetXMLObject(cx, kid);\n                if (!kidobj)\n                    goto bad;\n                id = ATOM_KEY(cx->runtime->atomState.starAtom);\n                ok = PutProperty(cx, kidobj, id, vp);\n                if (!ok)\n                    goto out;\n            }\n        } else {\n            /*\n             * 3.\n             * Erratum: if x.[[Length]] > 1 or [[ResolveValue]] returns null\n             * or an r with r.[[Length]] != 1, throw TypeError.\n             */\n            n = JSXML_LENGTH(xml);\n            if (n > 1)\n                goto type_error;\n            if (n == 0) {\n                ok = ResolveValue(cx, xml, &rxml);\n                if (!ok)\n                    goto out;\n                if (!rxml || JSXML_LENGTH(rxml) != 1)\n                    goto type_error;\n                ok = Append(cx, xml, rxml);\n                if (!ok)\n                    goto out;\n            }\n            JS_ASSERT(JSXML_LENGTH(xml) == 1);\n            kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);\n            if (!kid)\n                goto out;\n            kidobj = js_GetXMLObject(cx, kid);\n            if (!kidobj)\n                goto bad;\n            ok = PutProperty(cx, kidobj, id, vp);\n            if (!ok)\n                goto out;\n        }\n    } else {\n        /*\n         * ECMA-357 9.1.1.2.\n         * Erratum: move steps 3 and 4 to before 1 and 2, to avoid wasted\n         * effort in ToString or [[DeepCopy]].\n         */\n        if (js_IdIsIndex(id, &index)) {\n            /* See NOTE in spec: this variation is reserved for future use. */\n            ReportBadXMLName(cx, id);\n            goto bad;\n        }\n\n        nameqn = ToXMLName(cx, id, &funid);\n        if (!nameqn)\n            goto bad;\n        if (funid) {\n            ok = js_SetProperty(cx, obj, funid, vp);\n            goto out;\n        }\n        nameobj = nameqn->object;\n\n        if (JSXML_HAS_VALUE(xml))\n            goto out;\n\n        if (!vxml ||\n            vxml->xml_class == JSXML_CLASS_TEXT ||\n            vxml->xml_class == JSXML_CLASS_ATTRIBUTE) {\n            ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);\n            if (!ok)\n                goto out;\n        } else {\n            rxml = DeepCopyInLRS(cx, vxml, 0);\n            if (!rxml || !js_GetXMLObject(cx, rxml))\n                goto bad;\n            vxml = rxml;\n            *vp = OBJECT_TO_JSVAL(vxml->object);\n        }\n        roots[VAL_ROOT] = *vp;\n\n        /*\n         * 6.\n         * Erratum: why is this done here, so early? use is way later....\n         */\n        ok = js_GetDefaultXMLNamespace(cx, &nsval);\n        if (!ok)\n            goto out;\n\n        if (OBJ_GET_CLASS(cx, nameobj) == &js_AttributeNameClass) {\n            /* 7(a). */\n            if (!js_IsXMLName(cx, OBJECT_TO_JSVAL(nameobj)))\n                goto out;\n\n            /* 7(b-c). */\n            if (vxml && vxml->xml_class == JSXML_CLASS_LIST) {\n                n = vxml->xml_kids.length;\n                if (n == 0) {\n                    *vp = STRING_TO_JSVAL(cx->runtime->emptyString);\n                } else {\n                    left = KidToString(cx, vxml, 0);\n                    if (!left)\n                        goto bad;\n\n                    space = ATOM_TO_STRING(cx->runtime->atomState.spaceAtom);\n                    for (i = 1; i < n; i++) {\n                        left = js_ConcatStrings(cx, left, space);\n                        if (!left)\n                            goto bad;\n                        right = KidToString(cx, vxml, i);\n                        if (!right)\n                            goto bad;\n                        left = js_ConcatStrings(cx, left, right);\n                        if (!left)\n                            goto bad;\n                    }\n\n                    roots[VAL_ROOT] = *vp = STRING_TO_JSVAL(left);\n                }\n            } else {\n                ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);\n                if (!ok)\n                    goto out;\n                roots[VAL_ROOT] = *vp;\n            }\n\n            /* 7(d-e). */\n            match = NULL;\n            for (i = 0, n = xml->xml_attrs.length; i < n; i++) {\n                attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);\n                if (!attr)\n                    continue;\n                attrqn = attr->name;\n                if (js_EqualStrings(attrqn->localName, nameqn->localName) &&\n                    (!nameqn->uri ||\n                     js_EqualStrings(attrqn->uri, nameqn->uri))) {\n                    if (!match) {\n                        match = attr;\n                    } else {\n                        nameobj = js_GetAttributeNameObject(cx, attrqn);\n                        if (!nameobj)\n                            goto bad;\n\n                        id = OBJECT_TO_JSVAL(nameobj);\n                        ok = DeleteProperty(cx, obj, id, &junk);\n                        if (!ok)\n                            goto out;\n                        --i;\n                    }\n                }\n            }\n\n            /* 7(f). */\n            attr = match;\n            if (!attr) {\n                /* 7(f)(i-ii). */\n                if (!nameqn->uri) {\n                    left = right = cx->runtime->emptyString;\n                } else {\n                    left = nameqn->uri;\n                    right = nameqn->prefix;\n                }\n                nameqn = js_NewXMLQName(cx, left, right, nameqn->localName);\n                if (!nameqn)\n                    goto bad;\n\n                /* 7(f)(iii). */\n                attr = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);\n                if (!attr)\n                    goto bad;\n                attr->parent = xml;\n                attr->name = nameqn;\n\n                /* 7(f)(iv). */\n                ok = XMLARRAY_ADD_MEMBER(cx, &xml->xml_attrs, n, attr);\n                if (!ok)\n                    goto out;\n\n                /* 7(f)(v-vi). */\n                ns = GetNamespace(cx, nameqn, NULL);\n                if (!ns)\n                    goto bad;\n                ok = AddInScopeNamespace(cx, xml, ns);\n                if (!ok)\n                    goto out;\n            }\n\n            /* 7(g). */\n            attr->xml_value = JSVAL_TO_STRING(*vp);\n            goto out;\n        }\n\n        /* 8-9. */\n        if (!js_IsXMLName(cx, OBJECT_TO_JSVAL(nameobj)) &&\n            !IS_STAR(nameqn->localName)) {\n            goto out;\n        }\n\n        /* 10-11. */\n        id = JSVAL_VOID;\n        primitiveAssign = !vxml && !IS_STAR(nameqn->localName);\n\n        /* 12. */\n        k = n = xml->xml_kids.length;\n        kid2 = NULL;\n        while (k != 0) {\n            --k;\n            kid = XMLARRAY_MEMBER(&xml->xml_kids, k, JSXML);\n            if (kid && MatchElemName(nameqn, kid)) {\n                if (!JSVAL_IS_VOID(id)) {\n                    ok = DeleteByIndex(cx, xml, id, &junk);\n                    if (!ok)\n                        goto out;\n                }\n                ok = IndexToIdVal(cx, k, &id);\n                if (!ok)\n                    goto out;\n                kid2 = kid;\n            }\n        }\n\n        /*\n         * Erratum: ECMA-357 specified child insertion inconsistently:\n         * insertChildBefore and insertChildAfter insert an arbitrary XML\n         * instance, and therefore can create cycles, but appendChild as\n         * specified by the \"Overview\" of 13.4.4.3 calls [[DeepCopy]] on\n         * its argument.  But the \"Semantics\" in 13.4.4.3 do not include\n         * any [[DeepCopy]] call.\n         *\n         * Fixing this (https://bugzilla.mozilla.org/show_bug.cgi?id=312692)\n         * required adding cycle detection, and allowing duplicate kids to\n         * be created (see comment 6 in the bug).  Allowing duplicate kid\n         * references means the loop above will delete all but the lowest\n         * indexed reference, and each [[DeleteByIndex]] nulls the kid's\n         * parent.  Thus the need to restore parent here.  This is covered\n         * by https://bugzilla.mozilla.org/show_bug.cgi?id=327564.\n         */\n        if (kid2) {\n            JS_ASSERT(kid2->parent == xml || !kid2->parent);\n            if (!kid2->parent)\n                kid2->parent = xml;\n        }\n\n        /* 13. */\n        if (JSVAL_IS_VOID(id)) {\n            /* 13(a). */\n            ok = IndexToIdVal(cx, n, &id);\n            if (!ok)\n                goto out;\n\n            /* 13(b). */\n            if (primitiveAssign) {\n                if (!nameqn->uri) {\n                    ns = (JSXMLNamespace *)\n                         JS_GetPrivate(cx, JSVAL_TO_OBJECT(nsval));\n                    left = ns->uri;\n                    right = ns->prefix;\n                } else {\n                    left = nameqn->uri;\n                    right = nameqn->prefix;\n                }\n                nameqn = js_NewXMLQName(cx, left, right, nameqn->localName);\n                if (!nameqn)\n                    goto bad;\n\n                /* 13(b)(iii). */\n                vobj = js_NewXMLObject(cx, JSXML_CLASS_ELEMENT);\n                if (!vobj)\n                    goto bad;\n                vxml = (JSXML *) JS_GetPrivate(cx, vobj);\n                vxml->parent = xml;\n                vxml->name = nameqn;\n\n                /* 13(b)(iv-vi). */\n                ns = GetNamespace(cx, nameqn, NULL);\n                if (!ns)\n                    goto bad;\n                ok = Replace(cx, xml, id, OBJECT_TO_JSVAL(vobj));\n                if (!ok)\n                    goto out;\n                ok = AddInScopeNamespace(cx, vxml, ns);\n                if (!ok)\n                    goto out;\n            }\n        }\n\n        /* 14. */\n        if (primitiveAssign) {\n            JSXMLArrayCursor cursor;\n\n            js_IdIsIndex(id, &index);\n            XMLArrayCursorInit(&cursor, &xml->xml_kids);\n            cursor.index = index;\n            kid = (JSXML *) XMLArrayCursorItem(&cursor);\n            if (JSXML_HAS_KIDS(kid)) {\n                XMLArrayFinish(cx, &kid->xml_kids);\n                ok = XMLArrayInit(cx, &kid->xml_kids, 1);\n            }\n\n            /* 14(b-c). */\n            /* XXXbe Erratum? redundant w.r.t. 7(b-c) else clause above */\n            if (ok) {\n                ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);\n                if (ok && !IS_EMPTY(JSVAL_TO_STRING(*vp))) {\n                    roots[VAL_ROOT] = *vp;\n                    if ((JSXML *) XMLArrayCursorItem(&cursor) == kid)\n                        ok = Replace(cx, kid, JSVAL_ZERO, *vp);\n                }\n            }\n            XMLArrayCursorFinish(&cursor);\n        } else {\n            /* 15(a). */\n            ok = Replace(cx, xml, id, *vp);\n        }\n    }\n\nout:\n    JS_POP_TEMP_ROOT(cx, &tvr);\n    js_LeaveLocalRootScope(cx);\n    return ok;\n\ntype_error:\n    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\n                         JSMSG_BAD_XMLLIST_PUT,\n                         js_ValueToPrintableString(cx, id));\nbad:\n    ok = JS_FALSE;\n    goto out;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 9.2.1.6 XMLList [[Append]]. */\n", "func_signal": "static JSBool\nAppend(JSContext *cx, JSXML *list, JSXML *xml)", "code": "{\n    uint32 i, j, k, n;\n    JSXML *kid;\n\n    JS_ASSERT(list->xml_class == JSXML_CLASS_LIST);\n    i = list->xml_kids.length;\n    n = 1;\n    if (xml->xml_class == JSXML_CLASS_LIST) {\n        list->xml_target = xml->xml_target;\n        list->xml_targetprop = xml->xml_targetprop;\n        n = JSXML_LENGTH(xml);\n        k = i + n;\n        if (!XMLArraySetCapacity(cx, &list->xml_kids, k))\n            return JS_FALSE;\n        for (j = 0; j < n; j++) {\n            kid = XMLARRAY_MEMBER(&xml->xml_kids, j, JSXML);\n            if (kid)\n                XMLARRAY_SET_MEMBER(&list->xml_kids, i + j, kid);\n        }\n        return JS_TRUE;\n    }\n\n    list->xml_target = xml->parent;\n    if (xml->xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION)\n        list->xml_targetprop = NULL;\n    else\n        list->xml_targetprop = xml->name;\n    if (!XMLARRAY_ADD_MEMBER(cx, &list->xml_kids, i, xml))\n        return JS_FALSE;\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "//www.w3.org/2000/xmlns/\";\n", "func_signal": "static JSXMLQName *\nParseNodeToQName(JSContext *cx, JSParseNode *pn, JSXMLArray *inScopeNSes,\n                 JSBool isAttributeName)", "code": "{\n    JSString *str, *uri, *prefix, *localName;\n    size_t length, offset;\n    const jschar *start, *limit, *colon;\n    uint32 n;\n    JSXMLNamespace *ns;\n\n    JS_ASSERT(pn->pn_arity == PN_NULLARY);\n    str = ATOM_TO_STRING(pn->pn_atom);\n    length = JSSTRING_LENGTH(str);\n    start = JSSTRING_CHARS(str);\n    JS_ASSERT(length != 0 && *start != '@');\n    JS_ASSERT(length != 1 || *start != '*');\n\n    uri = cx->runtime->emptyString;\n    limit = start + length;\n    colon = js_strchr_limit(start, ':', limit);\n    if (colon) {\n        offset = PTRDIFF(colon, start, jschar);\n        prefix = js_NewDependentString(cx, str, 0, offset, 0);\n        if (!prefix)\n            return NULL;\n\n        if (STARTS_WITH_XML(start, offset)) {\n            if (offset == 3) {\n                uri = JS_InternString(cx, xml_namespace_str);\n                if (!uri)\n                    return NULL;\n            } else if (offset == 5 && HAS_NS_AFTER_XML(start)) {\n                uri = JS_InternString(cx, xmlns_namespace_str);\n                if (!uri)\n                    return NULL;\n            } else {\n                uri = NULL;\n            }\n        } else {\n            uri = NULL;\n            n = inScopeNSes->length;\n            while (n != 0) {\n                --n;\n                ns = XMLARRAY_MEMBER(inScopeNSes, n, JSXMLNamespace);\n                if (ns->prefix && js_EqualStrings(ns->prefix, prefix)) {\n                    uri = ns->uri;\n                    break;\n                }\n            }\n        }\n\n        if (!uri) {\n            js_ReportCompileErrorNumber(cx, pn,\n                                        JSREPORT_PN | JSREPORT_ERROR,\n                                        JSMSG_BAD_XML_NAMESPACE,\n                                        js_ValueToPrintableString(cx,\n                                            STRING_TO_JSVAL(prefix)));\n            return NULL;\n        }\n\n        localName = js_NewStringCopyN(cx, colon + 1, length - (offset + 1), 0);\n        if (!localName)\n            return NULL;\n    } else {\n        if (isAttributeName) {\n            /*\n             * An unprefixed attribute is not in any namespace, so set prefix\n             * as well as uri to the empty string.\n             */\n            prefix = uri;\n        } else {\n            /*\n             * Loop from back to front looking for the closest declared default\n             * namespace.\n             */\n            n = inScopeNSes->length;\n            while (n != 0) {\n                --n;\n                ns = XMLARRAY_MEMBER(inScopeNSes, n, JSXMLNamespace);\n                if (!ns->prefix || IS_EMPTY(ns->prefix)) {\n                    uri = ns->uri;\n                    break;\n                }\n            }\n            prefix = IS_EMPTY(uri) ? cx->runtime->emptyString : NULL;\n        }\n        localName = str;\n    }\n\n    return js_NewXMLQName(cx, uri, prefix, localName);\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 9.1.1.9 XML [[Equals]] and 9.2.1.9 XMLList [[Equals]]. */\n", "func_signal": "static JSBool\nEquals(JSContext *cx, JSXML *xml, jsval v, JSBool *bp)", "code": "{\n    JSObject *vobj;\n    JSXML *vxml;\n\n    if (JSVAL_IS_PRIMITIVE(v)) {\n        *bp = JS_FALSE;\n        if (xml->xml_class == JSXML_CLASS_LIST) {\n            if (xml->xml_kids.length == 1) {\n                vxml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);\n                if (!vxml)\n                    return JS_TRUE;\n                vobj = js_GetXMLObject(cx, vxml);\n                if (!vobj)\n                    return JS_FALSE;\n                return js_XMLObjectOps.equality(cx, vobj, v, bp);\n            }\n            if (JSVAL_IS_VOID(v) && xml->xml_kids.length == 0)\n                *bp = JS_TRUE;\n        }\n    } else {\n        vobj = JSVAL_TO_OBJECT(v);\n        if (!OBJECT_IS_XML(cx, vobj)) {\n            *bp = JS_FALSE;\n        } else {\n            vxml = (JSXML *) JS_GetPrivate(cx, vobj);\n            if (!XMLEquals(cx, xml, vxml, bp))\n                return JS_FALSE;\n        }\n    }\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* DEBUG */\n", "func_signal": "JSBool\njs_ErrorToException(JSContext *cx, const char *message, JSErrorReport *reportp)", "code": "{\n    JSErrNum errorNumber;\n    const JSErrorFormatString *errorString;\n    JSExnType exn;\n    jsval tv[4];\n    JSTempValueRooter tvr;\n    JSBool ok;\n    JSObject *errProto, *errObject;\n    JSString *messageStr, *filenameStr;\n\n    /*\n     * Tell our caller to report immediately if cx has no active frames, or if\n     * this report is just a warning.\n     */\n    JS_ASSERT(reportp);\n    if (!cx->fp || JSREPORT_IS_WARNING(reportp->flags))\n        return JS_FALSE;\n\n    /* Find the exception index associated with this error. */\n    errorNumber = (JSErrNum) reportp->errorNumber;\n    errorString = js_GetLocalizedErrorMessage(cx, NULL, NULL, errorNumber);\n    exn = errorString ? errorString->exnType : JSEXN_NONE;\n    JS_ASSERT(exn < JSEXN_LIMIT);\n\n#if defined( DEBUG_mccabe ) && defined ( PRINTNAMES )\n    /* Print the error name and the associated exception name to stderr */\n    fprintf(stderr, \"%s\\t%s\\n\",\n            errortoexnname[errorNumber].name,\n            errortoexnname[errorNumber].exception);\n#endif\n\n    /*\n     * Return false (no exception raised) if no exception is associated\n     * with the given error number.\n     */\n    if (exn == JSEXN_NONE)\n        return JS_FALSE;\n\n    /*\n     * Prevent runaway recursion, just as the Exception native constructor\n     * must do, via cx->creatingException.  If an out-of-memory error occurs,\n     * no exception object will be created, but we don't assume that OOM is\n     * the only kind of error that subroutines of this function called below\n     * might raise.\n     */\n    if (cx->creatingException)\n        return JS_FALSE;\n\n    /* After this point the control must flow through the label out. */\n    cx->creatingException = JS_TRUE;\n\n    /* Protect the newly-created strings below from nesting GCs. */\n    memset(tv, 0, sizeof tv);\n    JS_PUSH_TEMP_ROOT(cx, sizeof tv / sizeof tv[0], tv, &tvr);\n\n    /*\n     * Try to get an appropriate prototype by looking up the corresponding\n     * exception constructor name in the scope chain of the current context's\n     * top stack frame, or in the global object if no frame is active.\n     */\n    ok = js_GetClassPrototype(cx, NULL, INT_TO_JSID(exceptions[exn].key),\n                              &errProto);\n    if (!ok)\n        goto out;\n    tv[0] = OBJECT_TO_JSVAL(errProto);\n\n    errObject = js_NewObject(cx, &js_ErrorClass, errProto, NULL);\n    if (!errObject) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[1] = OBJECT_TO_JSVAL(errObject);\n\n    messageStr = JS_NewStringCopyZ(cx, message);\n    if (!messageStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[2] = STRING_TO_JSVAL(messageStr);\n\n    filenameStr = JS_NewStringCopyZ(cx, reportp->filename);\n    if (!filenameStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[3] = STRING_TO_JSVAL(filenameStr);\n\n    ok = InitExnPrivate(cx, errObject, messageStr, filenameStr,\n                        reportp->lineno, reportp);\n    if (!ok)\n        goto out;\n\n    JS_SetPendingException(cx, OBJECT_TO_JSVAL(errObject));\n\n    /* Flag the error report passed in to indicate an exception was raised. */\n    reportp->flags |= JSREPORT_EXCEPTION;\n\nout:\n    JS_POP_TEMP_ROOT(cx, &tvr);\n    cx->creatingException = JS_FALSE;\n    return ok;\n}", "path": "js\\jsexn.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* 13.3.5.4 [[GetNamespace]]([InScopeNamespaces]) */\n", "func_signal": "static JSXMLNamespace *\nGetNamespace(JSContext *cx, JSXMLQName *qn, const JSXMLArray *inScopeNSes)", "code": "{\n    JSXMLNamespace *match, *ns;\n    uint32 i, n;\n    jsval argv[2];\n    JSObject *nsobj;\n\n    JS_ASSERT(qn->uri);\n    if (!qn->uri) {\n        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,\n                             JSMSG_BAD_XML_NAMESPACE,\n                             qn->prefix\n                             ? js_ValueToPrintableString(cx,\n                                   STRING_TO_JSVAL(qn->prefix))\n                             : js_type_strs[JSTYPE_VOID]);\n        return NULL;\n    }\n\n    /* Look for a matching namespace in inScopeNSes, if provided. */\n    match = NULL;\n    if (inScopeNSes) {\n        for (i = 0, n = inScopeNSes->length; i < n; i++) {\n            ns = XMLARRAY_MEMBER(inScopeNSes, i, JSXMLNamespace);\n            if (!ns)\n                continue;\n\n            /*\n             * Erratum, very tricky, and not specified in ECMA-357 13.3.5.4:\n             * If we preserve prefixes, we must match null qn->prefix against\n             * an empty ns->prefix, in order to avoid generating redundant\n             * prefixed and default namespaces for cases such as:\n             *\n             *   x = <t xmlns=\"http://foo.com\"/>\n             *   print(x.toXMLString());\n             *\n             * Per 10.3.2.1, the namespace attribute in t has an empty string\n             * prefix (*not* a null prefix), per 10.3.2.1 Step 6(h)(i)(1):\n             *\n             *   1. If the [local name] property of a is \"xmlns\"\n             *      a. Map ns.prefix to the empty string\n             *\n             * But t's name has a null prefix in this implementation, meaning\n             * *undefined*, per 10.3.2.1 Step 6(c)'s NOTE (which refers to\n             * the http://www.w3.org/TR/xml-infoset/ spec, item 2.2.3, without\n             * saying how \"no value\" maps to an ECMA-357 value -- but it must\n             * map to the *undefined* prefix value).\n             *\n             * Since \"\" != undefined (or null, in the current implementation)\n             * the ECMA-357 spec will fail to match in [[GetNamespace]] called\n             * on t with argument {} U {(prefix=\"\", uri=\"http://foo.com\")}.\n             * This spec bug leads to ToXMLString results that duplicate the\n             * declared namespace.\n             */\n            if (js_EqualStrings(ns->uri, qn->uri) &&\n                (ns->prefix == qn->prefix ||\n                 ((ns->prefix && qn->prefix)\n                  ? js_EqualStrings(ns->prefix, qn->prefix)\n                  : IS_EMPTY(ns->prefix ? ns->prefix : qn->prefix)))) {\n                match = ns;\n                break;\n            }\n        }\n    }\n\n    /* If we didn't match, make a new namespace from qn. */\n    if (!match) {\n        argv[0] = qn->prefix ? STRING_TO_JSVAL(qn->prefix) : JSVAL_VOID;\n        argv[1] = STRING_TO_JSVAL(qn->uri);\n        nsobj = js_ConstructObject(cx, &js_NamespaceClass.base, NULL, NULL,\n                                   2, argv);\n        if (!nsobj)\n            return NULL;\n        match = (JSXMLNamespace *) JS_GetPrivate(cx, nsobj);\n    }\n    return match;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/*\n** Compute the log of the least power of 2 greater than or equal to n\n*/\n", "func_signal": "JS_PUBLIC_API(JSIntn) JS_CeilingLog2(JSUint32 n)", "code": "{\n    JSIntn log2;\n\n    JS_CEILING_LOG2(log2, n);\n    return log2;\n}", "path": "js\\jslog2.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* XML and XMLList */\n", "func_signal": "static JSString *\nxml_toString_helper(JSContext *cx, JSXML *xml)", "code": "{\n    JSString *str, *kidstr;\n    JSXML *kid;\n    JSXMLArrayCursor cursor;\n\n    if (xml->xml_class == JSXML_CLASS_ATTRIBUTE ||\n        xml->xml_class == JSXML_CLASS_TEXT) {\n        return xml->xml_value;\n    }\n\n    if (!HasSimpleContent(xml))\n        return ToXMLString(cx, OBJECT_TO_JSVAL(xml->object));\n\n    str = cx->runtime->emptyString;\n    js_EnterLocalRootScope(cx);\n    XMLArrayCursorInit(&cursor, &xml->xml_kids);\n    while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n        if (kid->xml_class != JSXML_CLASS_COMMENT &&\n            kid->xml_class != JSXML_CLASS_PROCESSING_INSTRUCTION) {\n            kidstr = xml_toString_helper(cx, kid);\n            if (!kidstr) {\n                str = NULL;\n                break;\n            }\n            str = js_ConcatStrings(cx, str, kidstr);\n            if (!str)\n                break;\n        }\n    }\n    XMLArrayCursorFinish(&cursor);\n    js_LeaveLocalRootScopeWithResult(cx, STRING_TO_JSVAL(str));\n    return str;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* NB: called with null cx from the GC, via xml_mark => XMLArrayTrim. */\n", "func_signal": "static JSBool\nXMLArraySetCapacity(JSContext *cx, JSXMLArray *array, uint32 capacity)", "code": "{\n    void **vector;\n\n    if (capacity == 0) {\n        /* We could let realloc(p, 0) free this, but purify gets confused. */\n        if (array->vector)\n            free(array->vector);\n        vector = NULL;\n    } else {\n        if ((size_t)capacity > ~(size_t)0 / sizeof(void *) ||\n            !(vector = (void **)\n                       realloc(array->vector, capacity * sizeof(void *)))) {\n            if (cx)\n                JS_ReportOutOfMemory(cx);\n            return JS_FALSE;\n        }\n    }\n    array->capacity = JSXML_PRESET_CAPACITY | capacity;\n    array->vector = vector;\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/*\n * This routine requires that obj has been locked previously.\n */\n", "func_signal": "static jsint\nGetScriptExecDepth(JSContext *cx, JSObject *obj)", "code": "{\n    jsval v;\n\n    JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));\n    v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_START(&js_ScriptClass));\n    return JSVAL_TO_INT(v);\n}", "path": "js\\jsscript.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 10.2.1 and 10.2.2 */\n", "func_signal": "static JSString *\nXMLToXMLString(JSContext *cx, JSXML *xml, const JSXMLArray *ancestorNSes,\n               uintN indentLevel)", "code": "{\n    JSBool pretty, indentKids;\n    JSStringBuffer sb;\n    JSString *str, *prefix, *kidstr;\n    JSXMLArrayCursor cursor;\n    uint32 i, n;\n    JSXMLArray empty, decls, ancdecls;\n    JSXMLNamespace *ns, *ns2;\n    uintN nextIndentLevel;\n    JSXML *attr, *kid;\n\n    if (!GetBooleanXMLSetting(cx, js_prettyPrinting_str, &pretty))\n        return NULL;\n\n    js_InitStringBuffer(&sb);\n    if (pretty)\n        js_RepeatChar(&sb, ' ', indentLevel);\n    str = NULL;\n\n    switch (xml->xml_class) {\n      case JSXML_CLASS_TEXT:\n        /* Step 4. */\n        if (pretty) {\n            str = ChompXMLWhitespace(cx, xml->xml_value);\n            if (!str)\n                return NULL;\n        } else {\n            str = xml->xml_value;\n        }\n        return EscapeElementValue(cx, &sb, str);\n\n      case JSXML_CLASS_ATTRIBUTE:\n        /* Step 5. */\n        return EscapeAttributeValue(cx, &sb, xml->xml_value);\n\n      case JSXML_CLASS_COMMENT:\n        /* Step 6. */\n        return MakeXMLCommentString(cx, &sb, xml->xml_value);\n\n      case JSXML_CLASS_PROCESSING_INSTRUCTION:\n        /* Step 7. */\n        return MakeXMLPIString(cx, &sb, xml->name->localName, xml->xml_value);\n\n      case JSXML_CLASS_LIST:\n        /* ECMA-357 10.2.2. */\n        XMLArrayCursorInit(&cursor, &xml->xml_kids);\n        i = 0;\n        while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n            if (pretty && i != 0)\n                js_AppendChar(&sb, '\\n');\n\n            kidstr = XMLToXMLString(cx, kid, ancestorNSes, indentLevel);\n            if (!kidstr)\n                break;\n\n            js_AppendJSString(&sb, kidstr);\n            ++i;\n        }\n        XMLArrayCursorFinish(&cursor);\n        if (kid)\n            goto list_out;\n\n        if (!sb.base) {\n            if (!STRING_BUFFER_OK(&sb)) {\n                JS_ReportOutOfMemory(cx);\n                return NULL;\n            }\n            return cx->runtime->emptyString;\n        }\n\n        str = js_NewString(cx, sb.base, STRING_BUFFER_OFFSET(&sb), 0);\n      list_out:\n        if (!str)\n            js_FinishStringBuffer(&sb);\n        return str;\n\n      default:;\n    }\n\n    /* After this point, control must flow through label out: to exit. */\n    if (!js_EnterLocalRootScope(cx))\n        return NULL;\n\n    /* ECMA-357 10.2.1 step 8 onward: handle ToXMLString on an XML element. */\n    if (!ancestorNSes) {\n        XMLArrayInit(cx, &empty, 0);\n        ancestorNSes = &empty;\n    }\n    XMLArrayInit(cx, &decls, 0);\n    ancdecls.capacity = 0;\n\n    /* Clone in-scope namespaces not in ancestorNSes into decls. */\n    XMLArrayCursorInit(&cursor, &xml->xml_namespaces);\n    while ((ns = (JSXMLNamespace *) XMLArrayCursorNext(&cursor)) != NULL) {\n        if (!ns->declared)\n            continue;\n        if (!XMLARRAY_HAS_MEMBER(ancestorNSes, ns, namespace_identity)) {\n            /* NOTE: may want to exclude unused namespaces here. */\n            ns2 = js_NewXMLNamespace(cx, ns->prefix, ns->uri, JS_TRUE);\n            if (!ns2 || !XMLARRAY_APPEND(cx, &decls, ns2))\n                break;\n        }\n    }\n    XMLArrayCursorFinish(&cursor);\n    if (ns)\n        goto out;\n\n    /*\n     * Union ancestorNSes and decls into ancdecls.  Note that ancdecls does\n     * not own its member references.  In the spec, ancdecls has no name, but\n     * is always written out as (AncestorNamespaces U namespaceDeclarations).\n     */\n    if (!XMLArrayInit(cx, &ancdecls, ancestorNSes->length + decls.length))\n        goto out;\n    for (i = 0, n = ancestorNSes->length; i < n; i++) {\n        ns2 = XMLARRAY_MEMBER(ancestorNSes, i, JSXMLNamespace);\n        if (!ns2)\n            continue;\n        JS_ASSERT(!XMLARRAY_HAS_MEMBER(&decls, ns2, namespace_identity));\n        if (!XMLARRAY_APPEND(cx, &ancdecls, ns2))\n            goto out;\n    }\n    for (i = 0, n = decls.length; i < n; i++) {\n        ns2 = XMLARRAY_MEMBER(&decls, i, JSXMLNamespace);\n        if (!ns2)\n            continue;\n        JS_ASSERT(!XMLARRAY_HAS_MEMBER(&ancdecls, ns2, namespace_identity));\n        if (!XMLARRAY_APPEND(cx, &ancdecls, ns2))\n            goto out;\n    }\n\n    /* Step 11, except we don't clone ns unless its prefix is undefined. */\n    ns = GetNamespace(cx, xml->name, &ancdecls);\n    if (!ns)\n        goto out;\n\n    /* Step 12 (NULL means *undefined* here), plus the deferred ns cloning. */\n    if (!ns->prefix) {\n        /*\n         * Create a namespace prefix that isn't used by any member of decls.\n         * Assign the new prefix to a copy of ns.  Flag this namespace as if\n         * it were declared, for assertion-testing's sake later below.\n         *\n         * Erratum: if ns->prefix and xml->name are both null (*undefined* in\n         * ECMA-357), we know that xml was named using the default namespace\n         * (proof: see GetNamespace and the Namespace constructor called with\n         * two arguments).  So we ought not generate a new prefix here, when\n         * we can declare ns as the default namespace for xml.\n         *\n         * This helps descendants inherit the namespace instead of redundantly\n         * redeclaring it with generated prefixes in each descendant.\n         */\n        if (!xml->name->prefix) {\n            prefix = cx->runtime->emptyString;\n        } else {\n            prefix = GeneratePrefix(cx, ns->uri, &ancdecls);\n            if (!prefix)\n                goto out;\n        }\n        ns = js_NewXMLNamespace(cx, prefix, ns->uri, JS_TRUE);\n        if (!ns)\n            goto out;\n\n        /*\n         * If the xml->name was unprefixed, we must remove any declared default\n         * namespace from decls before appending ns.  How can you get a default\n         * namespace in decls that doesn't match the one from name?  Apparently\n         * by calling x.setNamespace(ns) where ns has no prefix.  The other way\n         * to fix this is to update x's in-scope namespaces when setNamespace\n         * is called, but that's not specified by ECMA-357.\n         *\n         * Likely Erratum here, depending on whether the lack of update to x's\n         * in-scope namespace in XML.prototype.setNamespace (13.4.4.36) is an\n         * erratum or not.  Note that changing setNamespace to update the list\n         * of in-scope namespaces will change x.namespaceDeclarations().\n         */\n        if (IS_EMPTY(prefix)) {\n            i = XMLArrayFindMember(&decls, ns, namespace_match);\n            if (i != XML_NOT_FOUND)\n                XMLArrayDelete(cx, &decls, i, JS_TRUE);\n        }\n\n        /*\n         * In the spec, ancdecls has no name, but is always written out as\n         * (AncestorNamespaces U namespaceDeclarations).  Since we compute\n         * that union in ancdecls, any time we append a namespace strong\n         * ref to decls, we must also append a weak ref to ancdecls.  Order\n         * matters here: code at label out: releases strong refs in decls.\n         */\n        if (!XMLARRAY_APPEND(cx, &ancdecls, ns) ||\n            !XMLARRAY_APPEND(cx, &decls, ns)) {\n            goto out;\n        }\n    }\n\n    /* Format the element or point-tag into sb. */\n    js_AppendChar(&sb, '<');\n\n    if (ns->prefix && !IS_EMPTY(ns->prefix)) {\n        js_AppendJSString(&sb, ns->prefix);\n        js_AppendChar(&sb, ':');\n    }\n    js_AppendJSString(&sb, xml->name->localName);\n\n    /*\n     * Step 16 makes a union to avoid writing two loops in step 17, to share\n     * common attribute value appending spec-code.  We prefer two loops for\n     * faster code and less data overhead.\n     */\n\n    /* Step 17(b): append attributes. */\n    XMLArrayCursorInit(&cursor, &xml->xml_attrs);\n    while ((attr = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n        js_AppendChar(&sb, ' ');\n        ns2 = GetNamespace(cx, attr->name, &ancdecls);\n        if (!ns2)\n            break;\n\n        /* 17(b)(ii): NULL means *undefined* here. */\n        if (!ns2->prefix) {\n            prefix = GeneratePrefix(cx, ns2->uri, &ancdecls);\n            if (!prefix)\n                break;\n\n            /* Again, we avoid copying ns2 until we know it's prefix-less. */\n            ns2 = js_NewXMLNamespace(cx, prefix, ns2->uri, JS_TRUE);\n            if (!ns2)\n                break;\n\n            /*\n             * In the spec, ancdecls has no name, but is always written out as\n             * (AncestorNamespaces U namespaceDeclarations).  Since we compute\n             * that union in ancdecls, any time we append a namespace strong\n             * ref to decls, we must also append a weak ref to ancdecls.  Order\n             * matters here: code at label out: releases strong refs in decls.\n             */\n            if (!XMLARRAY_APPEND(cx, &ancdecls, ns2) ||\n                !XMLARRAY_APPEND(cx, &decls, ns2)) {\n                break;\n            }\n        }\n\n        /* 17(b)(iii). */\n        if (!IS_EMPTY(ns2->prefix)) {\n            js_AppendJSString(&sb, ns2->prefix);\n            js_AppendChar(&sb, ':');\n        }\n\n        /* 17(b)(iv). */\n        js_AppendJSString(&sb, attr->name->localName);\n\n        /* 17(d-g). */\n        AppendAttributeValue(cx, &sb, attr->xml_value);\n    }\n    XMLArrayCursorFinish(&cursor);\n    if (attr)\n        goto out;\n\n    /* Step 17(c): append XML namespace declarations. */\n    XMLArrayCursorInit(&cursor, &decls);\n    while ((ns2 = (JSXMLNamespace *) XMLArrayCursorNext(&cursor)) != NULL) {\n        JS_ASSERT(ns2->declared);\n\n        js_AppendCString(&sb, \" xmlns\");\n\n        /* 17(c)(ii): NULL means *undefined* here. */\n        if (!ns2->prefix) {\n            prefix = GeneratePrefix(cx, ns2->uri, &ancdecls);\n            if (!prefix)\n                break;\n            ns2->prefix = prefix;\n        }\n\n        /* 17(c)(iii). */\n        if (!IS_EMPTY(ns2->prefix)) {\n            js_AppendChar(&sb, ':');\n            js_AppendJSString(&sb, ns2->prefix);\n        }\n\n        /* 17(d-g). */\n        AppendAttributeValue(cx, &sb, ns2->uri);\n    }\n    XMLArrayCursorFinish(&cursor);\n    if (ns2)\n        goto out;\n\n    /* Step 18: handle point tags. */\n    n = xml->xml_kids.length;\n    if (n == 0) {\n        js_AppendCString(&sb, \"/>\");\n    } else {\n        /* Steps 19 through 25: handle element content, and open the end-tag. */\n        js_AppendChar(&sb, '>');\n        indentKids = n > 1 ||\n                     (n == 1 &&\n                      (kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML)) &&\n                      kid->xml_class != JSXML_CLASS_TEXT);\n\n        if (pretty && indentKids) {\n            if (!GetUint32XMLSetting(cx, js_prettyIndent_str, &i))\n                goto out;\n            nextIndentLevel = indentLevel + i;\n        } else {\n            nextIndentLevel = 0;\n        }\n\n        XMLArrayCursorInit(&cursor, &xml->xml_kids);\n        while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n            if (pretty && indentKids)\n                js_AppendChar(&sb, '\\n');\n\n            kidstr = XMLToXMLString(cx, kid, &ancdecls, nextIndentLevel);\n            if (!kidstr)\n                break;\n\n            js_AppendJSString(&sb, kidstr);\n        }\n        XMLArrayCursorFinish(&cursor);\n        if (kid)\n            goto out;\n\n        if (pretty && indentKids) {\n            js_AppendChar(&sb, '\\n');\n            js_RepeatChar(&sb, ' ', indentLevel);\n        }\n        js_AppendCString(&sb, \"</\");\n\n        /* Step 26. */\n        if (ns->prefix && !IS_EMPTY(ns->prefix)) {\n            js_AppendJSString(&sb, ns->prefix);\n            js_AppendChar(&sb, ':');\n        }\n\n        /* Step 27. */\n        js_AppendJSString(&sb, xml->name->localName);\n        js_AppendChar(&sb, '>');\n    }\n\n    if (!STRING_BUFFER_OK(&sb)) {\n        JS_ReportOutOfMemory(cx);\n        goto out;\n    }\n\n    str = js_NewString(cx, sb.base, STRING_BUFFER_OFFSET(&sb), 0);\nout:\n    js_LeaveLocalRootScopeWithResult(cx, STRING_TO_JSVAL(str));\n    if (!str && STRING_BUFFER_OK(&sb))\n        js_FinishStringBuffer(&sb);\n    XMLArrayFinish(cx, &decls);\n    if (ancdecls.capacity != 0)\n        XMLArrayFinish(cx, &ancdecls);\n    return str;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/*\n * Erratum? the testcase js/tests/e4x/XML/13.4.4.26.js wants all-whitespace\n * text between tags to be removed by normalize.\n */\n", "func_signal": "static JSBool\nIsXMLSpace(JSString *str)", "code": "{\n    const jschar *cp, *end;\n\n    cp = JSSTRING_CHARS(str);\n    end = cp + JSSTRING_LENGTH(str);\n    while (cp < end) {\n        if (!JS_ISXMLSPACE(*cp))\n            return JS_FALSE;\n        ++cp;\n    }\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* XML and XMLList */\n", "func_signal": "static JSBool\nxml_child(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    JSXML *xml, *list, *kid, *vxml;\n    JSXMLArrayCursor cursor;\n    jsval name, v;\n    JSObject *kidobj;\n\n    XML_METHOD_PROLOG;\n    name = argv[0];\n    if (xml->xml_class == JSXML_CLASS_LIST) {\n        /* ECMA-357 13.5.4.4 */\n        list = xml_list_helper(cx, xml, rval);\n        if (!list)\n            return JS_FALSE;\n\n        XMLArrayCursorInit(&cursor, &xml->xml_kids);\n        while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {\n            kidobj = js_GetXMLObject(cx, kid);\n            if (!kidobj)\n                break;\n            if (!xml_child_helper(cx, kidobj, kid, name, &v))\n                break;\n            if (JSVAL_IS_VOID(v)) {\n                /* The property didn't exist in this kid. */\n                continue;\n            }\n\n            JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));\n            vxml = (JSXML *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));\n            if ((!JSXML_HAS_KIDS(vxml) || vxml->xml_kids.length != 0) &&\n                !Append(cx, list, vxml)) {\n                break;\n            }\n        }\n        XMLArrayCursorFinish(&cursor);\n        return !kid;\n    }\n\n    /* ECMA-357 Edition 2 13.3.4.6 (note 13.3, not 13.4 as in Edition 1). */\n    if (!xml_child_helper(cx, obj, xml, name, rval))\n        return JS_FALSE;\n    if (JSVAL_IS_VOID(*rval) && !xml_list_helper(cx, xml, rval))\n        return JS_FALSE;\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/*\n * Note the asymmetry between js_GetDefaultXMLNamespace and js_SetDefaultXML-\n * Namespace.  Get searches fp->scopeChain for JS_DEFAULT_XML_NAMESPACE_ID,\n * while Set sets JS_DEFAULT_XML_NAMESPACE_ID in fp->varobj (unless fp is a\n * lightweight function activation).  There's no requirement that fp->varobj\n * lie directly on fp->scopeChain, although it should be reachable using the\n * prototype chain from a scope object (cf. JSOPTION_VAROBJFIX in jsapi.h).\n *\n * If Get can't find JS_DEFAULT_XML_NAMESPACE_ID along the scope chain, it\n * creates a default namespace via 'new Namespace()'.  In contrast, Set uses\n * its v argument as the uri of a new Namespace, with \"\" as the prefix.  See\n * ECMA-357 12.1 and 12.1.1.  Note that if Set is called with a Namespace n,\n * the default XML namespace will be set to (\"\", n.uri).  So the uri string\n * is really the only usefully stored value of the default namespace.\n */\n", "func_signal": "JSBool\njs_GetDefaultXMLNamespace(JSContext *cx, jsval *vp)", "code": "{\n    JSStackFrame *fp;\n    JSObject *nsobj, *obj, *tmp;\n    jsval v;\n\n    fp = cx->fp;\n    nsobj = fp->xmlNamespace;\n    if (nsobj) {\n        *vp = OBJECT_TO_JSVAL(nsobj);\n        return JS_TRUE;\n    }\n\n    obj = NULL;\n    for (tmp = fp->scopeChain; tmp; tmp = OBJ_GET_PARENT(cx, obj)) {\n        obj = tmp;\n        if (!OBJ_GET_PROPERTY(cx, obj, JS_DEFAULT_XML_NAMESPACE_ID, &v))\n            return JS_FALSE;\n        if (!JSVAL_IS_PRIMITIVE(v)) {\n            fp->xmlNamespace = JSVAL_TO_OBJECT(v);\n            *vp = v;\n            return JS_TRUE;\n        }\n    }\n\n    nsobj = js_ConstructObject(cx, &js_NamespaceClass.base, NULL, obj, 0, NULL);\n    if (!nsobj)\n        return JS_FALSE;\n    v = OBJECT_TO_JSVAL(nsobj);\n    if (obj &&\n        !OBJ_DEFINE_PROPERTY(cx, obj, JS_DEFAULT_XML_NAMESPACE_ID, v,\n                             JS_PropertyStub, JS_PropertyStub,\n                             JSPROP_PERMANENT, NULL)) {\n        return JS_FALSE;\n    }\n    fp->xmlNamespace = nsobj;\n    *vp = v;\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* ECMA-357 9.1.1.12 XML [[Replace]]. */\n", "func_signal": "static JSBool\nReplace(JSContext *cx, JSXML *xml, jsval id, jsval v)", "code": "{\n    uint32 i, n;\n    JSXML *vxml, *kid;\n    JSObject *vobj;\n    jsval junk;\n    JSString *str;\n\n    if (!JSXML_HAS_KIDS(xml))\n        return JS_TRUE;\n\n    if (!js_IdIsIndex(id, &i)) {\n        ReportBadXMLName(cx, id);\n        return JS_FALSE;\n    }\n\n    /*\n     * 9.1.1.12\n     * [[Replace]] handles _i >= x.[[Length]]_ by incrementing _x.[[Length]_.\n     * It should therefore constrain callers to pass in _i <= x.[[Length]]_.\n     */\n    n = xml->xml_kids.length;\n    if (i >= n) {\n        if (!IndexToIdVal(cx, n, &id))\n            return JS_FALSE;\n        i = n;\n    }\n\n    vxml = NULL;\n    if (!JSVAL_IS_PRIMITIVE(v)) {\n        vobj = JSVAL_TO_OBJECT(v);\n        if (OBJECT_IS_XML(cx, vobj))\n            vxml = (JSXML *) JS_GetPrivate(cx, vobj);\n    }\n\n    switch (vxml ? vxml->xml_class : JSXML_CLASS_LIMIT) {\n      case JSXML_CLASS_ELEMENT:\n        /* OPTION: enforce that descendants have superset namespaces. */\n        if (!CheckCycle(cx, xml, vxml))\n            return JS_FALSE;\n      case JSXML_CLASS_COMMENT:\n      case JSXML_CLASS_PROCESSING_INSTRUCTION:\n      case JSXML_CLASS_TEXT:\n        goto do_replace;\n\n      case JSXML_CLASS_LIST:\n        if (i < n && !DeleteByIndex(cx, xml, id, &junk))\n            return JS_FALSE;\n        if (!Insert(cx, xml, i, v))\n            return JS_FALSE;\n        break;\n\n      default:\n        str = js_ValueToString(cx, v);\n        if (!str)\n            return JS_FALSE;\n\n        vxml = js_NewXML(cx, JSXML_CLASS_TEXT);\n        if (!vxml)\n            return JS_FALSE;\n        vxml->xml_value = str;\n\n      do_replace:\n        vxml->parent = xml;\n        if (i < n) {\n            kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);\n            if (kid)\n                kid->parent = NULL;\n        }\n        if (!XMLARRAY_ADD_MEMBER(cx, &xml->xml_kids, i, vxml))\n            return JS_FALSE;\n        break;\n    }\n\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* Recursive (JSXML *) parameterized version of Equals. */\n", "func_signal": "static JSBool\nXMLEquals(JSContext *cx, JSXML *xml, JSXML *vxml, JSBool *bp)", "code": "{\n    JSXMLQName *qn, *vqn;\n    uint32 i, j, n;\n    JSXMLArrayCursor cursor, vcursor;\n    JSXML *kid, *vkid, *attr, *vattr;\n    JSBool ok;\n    JSObject *xobj, *vobj;\n\nretry:\n    if (xml->xml_class != vxml->xml_class) {\n        if (xml->xml_class == JSXML_CLASS_LIST && xml->xml_kids.length == 1) {\n            xml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);\n            if (xml)\n                goto retry;\n        }\n        if (vxml->xml_class == JSXML_CLASS_LIST && vxml->xml_kids.length == 1) {\n            vxml = XMLARRAY_MEMBER(&vxml->xml_kids, 0, JSXML);\n            if (vxml)\n                goto retry;\n        }\n        *bp = JS_FALSE;\n        return JS_TRUE;\n    }\n\n    qn = xml->name;\n    vqn = vxml->name;\n    if (qn) {\n        *bp = vqn &&\n              js_EqualStrings(qn->localName, vqn->localName) &&\n              js_EqualStrings(qn->uri, vqn->uri);\n    } else {\n        *bp = vqn == NULL;\n    }\n    if (!*bp)\n        return JS_TRUE;\n\n    if (JSXML_HAS_VALUE(xml)) {\n        *bp = js_EqualStrings(xml->xml_value, vxml->xml_value);\n    } else if (xml->xml_kids.length != vxml->xml_kids.length) {\n        *bp = JS_FALSE;\n    } else {\n        XMLArrayCursorInit(&cursor, &xml->xml_kids);\n        XMLArrayCursorInit(&vcursor, &vxml->xml_kids);\n        for (;;) {\n            kid = (JSXML *) XMLArrayCursorNext(&cursor);\n            vkid = (JSXML *) XMLArrayCursorNext(&vcursor);\n            if (!kid || !vkid) {\n                *bp = !kid && !vkid;\n                ok = JS_TRUE;\n                break;\n            }\n            xobj = js_GetXMLObject(cx, kid);\n            vobj = js_GetXMLObject(cx, vkid);\n            ok = xobj && vobj &&\n                 xml_equality(cx, xobj, OBJECT_TO_JSVAL(vobj), bp);\n            if (!ok || !*bp)\n                break;\n        }\n        XMLArrayCursorFinish(&vcursor);\n        XMLArrayCursorFinish(&cursor);\n        if (!ok)\n            return JS_FALSE;\n\n        if (*bp && xml->xml_class == JSXML_CLASS_ELEMENT) {\n            n = xml->xml_attrs.length;\n            if (n != vxml->xml_attrs.length)\n                *bp = JS_FALSE;\n            for (i = 0; *bp && i < n; i++) {\n                attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);\n                if (!attr)\n                    continue;\n                j = XMLARRAY_FIND_MEMBER(&vxml->xml_attrs, attr, attr_identity);\n                if (j == XML_NOT_FOUND) {\n                    *bp = JS_FALSE;\n                    break;\n                }\n                vattr = XMLARRAY_MEMBER(&vxml->xml_attrs, j, JSXML);\n                if (!vattr)\n                    continue;\n                *bp = js_EqualStrings(attr->xml_value, vattr->xml_value);\n            }\n        }\n    }\n\n    return JS_TRUE;\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* XML and XMLList */\n", "func_signal": "static JSBool\nxml_children(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\n             jsval *rval)", "code": "{\n    jsval name;\n\n    name = ATOM_KEY(cx->runtime->atomState.starAtom);\n    return GetProperty(cx, obj, name, rval);\n}", "path": "js\\jsxml.c", "repo_name": "sonia/lulzjs", "stars": 4, "license": "None", "language": "c", "size": 1397}
{"docstring": "/* Evaluate the transfer function that corresponds to the IIR\n * coefficients at zr + zi*I and return the magnitude */\n", "func_signal": "gdouble\ngst_audio_fx_base_iir_filter_calculate_gain (gdouble * a, guint na, gdouble * b,\n    guint nb, gdouble zr, gdouble zi)", "code": "{\n  gdouble sum_ar, sum_ai;\n  gdouble sum_br, sum_bi;\n  gdouble gain_r, gain_i;\n\n  gdouble sum_r_old;\n  gdouble sum_i_old;\n\n  gint i;\n\n  sum_ar = 0.0;\n  sum_ai = 0.0;\n  for (i = na - 1; i >= 0; i--) {\n    sum_r_old = sum_ar;\n    sum_i_old = sum_ai;\n\n    sum_ar = (sum_r_old * zr - sum_i_old * zi) + a[i];\n    sum_ai = (sum_r_old * zi + sum_i_old * zr) + 0.0;\n  }\n\n  sum_br = 0.0;\n  sum_bi = 0.0;\n  for (i = nb - 1; i >= 0; i--) {\n    sum_r_old = sum_br;\n    sum_i_old = sum_bi;\n\n    sum_br = (sum_r_old * zr - sum_i_old * zi) - b[i];\n    sum_bi = (sum_r_old * zi + sum_i_old * zr) - 0.0;\n  }\n  sum_br += 1.0;\n  sum_bi += 0.0;\n\n  gain_r =\n      (sum_ar * sum_br + sum_ai * sum_bi) / (sum_br * sum_br + sum_bi * sum_bi);\n  gain_i =\n      (sum_ai * sum_br - sum_ar * sum_bi) / (sum_br * sum_br + sum_bi * sum_bi);\n\n  return (sqrt (gain_r * gain_r + gain_i * gain_i));\n}", "path": "gst\\audiofx\\audiofxbaseiirfilter.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* GST_ALAW_DEC_USE_TABLE */\n", "func_signal": "static inline gint\nalaw_to_s16 (guint8 a_val)", "code": "{\n  gint t;\n  gint seg;\n\n  a_val ^= 0x55;\n  t = a_val & 0x7f;\n  if (t < 16)\n    t = (t << 4) + 8;\n  else {\n    seg = (t >> 4) & 0x07;\n    t = ((t & 0x0f) << 4) + 0x108;\n    t <<= seg - 1;\n  }\n  return ((a_val & 0x80) ? t : -t);\n}", "path": "gst\\law\\alaw-decode.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* three functions: firstly, OSS has the nasty habit of inserting\n * spaces in the labels, we want to get rid of them. Secondly,\n * i18n is impossible with OSS' way of providing us with mixer\n * labels, so we make a 'given' list of i18n'ed labels. Thirdly, I\n * personally don't like the \"1337\" names that OSS gives to their\n * labels (\"Vol\", \"Mic\", \"Rec\"), I'd rather see full names. */\n", "func_signal": "static void\nfill_labels (void)", "code": "{\n  gint i, pos;\n  const gchar *origs[SOUND_MIXER_NRDEVICES] = SOUND_DEVICE_LABELS;\n  const struct\n  {\n    const gchar *given;\n    const gchar *wanted;\n  }\n  cases[] = {\n    /* Note: this list is simply ripped from soundcard.h. For\n     * some people, some values might be missing (3D surround,\n     * etc.) - feel free to add them. That's the reason why\n     * I'm doing this in such a horribly complicated way. */\n    {\n    \"Vol  \", _(\"Volume\")}, {\n    \"Bass \", _(\"Bass\")}, {\n    \"Trebl\", _(\"Treble\")}, {\n    \"Synth\", _(\"Synth\")}, {\n    \"Pcm  \", _(\"PCM\")}, {\n    \"Spkr \", _(\"Speaker\")}, {\n    \"Line \", _(\"Line-in\")}, {\n    \"Mic  \", _(\"Microphone\")}, {\n    \"CD   \", _(\"CD\")}, {\n    \"Mix  \", _(\"Mixer\")}, {\n    \"Pcm2 \", _(\"PCM-2\")}, {\n    \"Rec  \", _(\"Record\")}, {\n    \"IGain\", _(\"In-gain\")}, {\n    \"OGain\", _(\"Out-gain\")}, {\n    \"Line1\", _(\"Line-1\")}, {\n    \"Line2\", _(\"Line-2\")}, {\n    \"Line3\", _(\"Line-3\")}, {\n    \"Digital1\", _(\"Digital-1\")}, {\n    \"Digital2\", _(\"Digital-2\")}, {\n    \"Digital3\", _(\"Digital-3\")}, {\n    \"PhoneIn\", _(\"Phone-in\")}, {\n    \"PhoneOut\", _(\"Phone-out\")}, {\n    \"Video\", _(\"Video\")}, {\n    \"Radio\", _(\"Radio\")}, {\n    \"Monitor\", _(\"Monitor\")}, {\n    NULL, NULL}\n  };\n\n  labels = g_malloc (sizeof (gchar *) * SOUND_MIXER_NRDEVICES);\n\n  for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {\n    for (pos = 0; cases[pos].given != NULL; pos++) {\n      if (!strcmp (cases[pos].given, origs[i])) {\n        labels[i] = g_strdup (cases[pos].wanted);\n        break;\n      }\n    }\n    if (cases[pos].given == NULL)\n      labels[i] = g_strdup (origs[i]);\n  }\n}", "path": "sys\\oss\\gstossmixertrack.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* this function is called every second and dumps the RTP manager stats */\n", "func_signal": "static gboolean\nprint_stats (GstElement * rtpbin)", "code": "{\n  GObject *session;\n  GValueArray *arr;\n  GValue *val;\n  guint i;\n\n  g_print (\"***********************************\\n\");\n\n  /* get session 0 */\n  g_signal_emit_by_name (rtpbin, \"get-internal-session\", 0, &session);\n\n  /* print all the sources in the session, this includes the internal source */\n  g_object_get (session, \"sources\", &arr, NULL);\n\n  for (i = 0; i < arr->n_values; i++) {\n    GObject *source;\n\n    val = g_value_array_get_nth (arr, i);\n    source = g_value_get_object (val);\n\n    print_source_stats (source);\n  }\n  g_value_array_free (arr);\n\n  g_object_unref (session);\n\n  return TRUE;\n}", "path": "tests\\examples\\rtp\\server-alsasrc-PCMA.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* return a list of caps where we only need to set\n * width and height to get fixed caps */\n", "func_signal": "static GList *\nvideo_crop_get_test_caps (GstElement * videocrop)", "code": "{\n  const GstCaps *allowed_caps;\n  GstPad *srcpad;\n  GList *list = NULL;\n  guint i;\n\n  srcpad = gst_element_get_static_pad (videocrop, \"src\");\n  fail_unless (srcpad != NULL);\n  allowed_caps = gst_pad_get_pad_template_caps (srcpad);\n  fail_unless (allowed_caps != NULL);\n\n  for (i = 0; i < gst_caps_get_size (allowed_caps); ++i) {\n    GstStructure *new_structure;\n    GstCaps *single_caps;\n\n    single_caps = gst_caps_new_empty ();\n    new_structure =\n        gst_structure_copy (gst_caps_get_structure (allowed_caps, i));\n    gst_structure_set (new_structure, \"framerate\", GST_TYPE_FRACTION,\n        1, 1, NULL);\n    gst_structure_remove_field (new_structure, \"width\");\n    gst_structure_remove_field (new_structure, \"height\");\n    gst_caps_append_structure (single_caps, new_structure);\n\n    /* should be fixed without width/height */\n    fail_unless (gst_caps_is_fixed (single_caps));\n\n    list = g_list_prepend (list, single_caps);\n  }\n\n  gst_object_unref (srcpad);\n\n  return list;\n}", "path": "tests\\check\\elements\\videocrop.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* create a socket for sending to remote machine */\n", "func_signal": "static gboolean\ngst_dynudpsink_init_send (GstDynUDPSink * sink)", "code": "{\n  guint bc_val;\n\n  if (sink->sockfd == -1) {\n    /* create sender socket if none available */\n    if ((sink->sock = socket (AF_INET, SOCK_DGRAM, 0)) < 0)\n      goto no_socket;\n\n    bc_val = 1;\n    if (setsockopt (sink->sock, SOL_SOCKET, SO_BROADCAST, &bc_val,\n            sizeof (bc_val)) < 0)\n      goto no_broadcast;\n\n    sink->externalfd = TRUE;\n  } else {\n    sink->sock = sink->sockfd;\n    sink->externalfd = TRUE;\n  }\n  return TRUE;\n\n  /* ERRORS */\nno_socket:\n  {\n    perror (\"socket\");\n    return FALSE;\n  }\nno_broadcast:\n  {\n    perror (\"setsockopt\");\n    CLOSE_IF_REQUESTED (sink);\n    return FALSE;\n  }\n}", "path": "gst\\udp\\gstdynudpsink.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* GstAudioFilter vmethod implementations */\n", "func_signal": "static gboolean\ngst_audio_fx_base_iir_filter_setup (GstAudioFilter * base,\n    GstRingBufferSpec * format)", "code": "{\n  GstAudioFXBaseIIRFilter *filter = GST_AUDIO_FX_BASE_IIR_FILTER (base);\n  gboolean ret = TRUE;\n\n  if (format->width == 32)\n    filter->process = (GstAudioFXBaseIIRFilterProcessFunc)\n        process_32;\n  else if (format->width == 64)\n    filter->process = (GstAudioFXBaseIIRFilterProcessFunc)\n        process_64;\n  else\n    ret = FALSE;\n\n  if (format->channels != filter->nchannels) {\n    guint i;\n    GstAudioFXBaseIIRFilterChannelCtx *ctx;\n\n    if (filter->channels) {\n\n      for (i = 0; i < filter->nchannels; i++) {\n        ctx = &filter->channels[i];\n\n        g_free (ctx->x);\n        g_free (ctx->y);\n      }\n\n      g_free (filter->channels);\n      filter->channels = NULL;\n    }\n\n    filter->nchannels = format->channels;\n\n    filter->channels =\n        g_new0 (GstAudioFXBaseIIRFilterChannelCtx, filter->nchannels);\n    for (i = 0; i < filter->nchannels; i++) {\n      ctx = &filter->channels[i];\n\n      ctx->x = g_new0 (gdouble, filter->na);\n      ctx->y = g_new0 (gdouble, filter->nb);\n    }\n  }\n\n  return ret;\n}", "path": "gst\\audiofx\\audiofxbaseiirfilter.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* build a pipeline equivalent to:\n *\n * gst-launch -v gstrtpbin name=rtpbin \\\n *    $AUDIO_SRC ! audioconvert ! audioresample ! $AUDIO_ENC ! $AUDIO_PAY ! rtpbin.send_rtp_sink_0  \\\n *           rtpbin.send_rtp_src_0 ! udpsink port=5002 host=$DEST                      \\\n *           rtpbin.send_rtcp_src_0 ! udpsink port=5003 host=$DEST sync=false async=false \\\n *        udpsrc port=5007 ! rtpbin.recv_rtcp_sink_0\n */\n", "func_signal": "int\nmain (int argc, char *argv[])", "code": "{\n  GstElement *audiosrc, *audioconv, *audiores, *audioenc, *audiopay;\n  GstElement *rtpbin, *rtpsink, *rtcpsink, *rtcpsrc;\n  GstElement *pipeline;\n  GMainLoop *loop;\n  gboolean res;\n  GstPadLinkReturn lres;\n  GstPad *srcpad, *sinkpad;\n\n  /* always init first */\n  gst_init (&argc, &argv);\n\n  /* the pipeline to hold everything */\n  pipeline = gst_pipeline_new (NULL);\n  g_assert (pipeline);\n\n  /* the audio capture and format conversion */\n  audiosrc = gst_element_factory_make (AUDIO_SRC, \"audiosrc\");\n  g_assert (audiosrc);\n  audioconv = gst_element_factory_make (\"audioconvert\", \"audioconv\");\n  g_assert (audioconv);\n  audiores = gst_element_factory_make (\"audioresample\", \"audiores\");\n  g_assert (audiores);\n  /* the encoding and payloading */\n  audioenc = gst_element_factory_make (AUDIO_ENC, \"audioenc\");\n  g_assert (audioenc);\n  audiopay = gst_element_factory_make (AUDIO_PAY, \"audiopay\");\n  g_assert (audiopay);\n\n  /* add capture and payloading to the pipeline and link */\n  gst_bin_add_many (GST_BIN (pipeline), audiosrc, audioconv, audiores,\n      audioenc, audiopay, NULL);\n\n  res = gst_element_link_many (audiosrc, audioconv, audiores, audioenc,\n      audiopay, NULL);\n  g_assert (res == TRUE);\n\n  /* the rtpbin element */\n  rtpbin = gst_element_factory_make (\"gstrtpbin\", \"rtpbin\");\n  g_assert (rtpbin);\n\n  gst_bin_add (GST_BIN (pipeline), rtpbin);\n\n  /* the udp sinks and source we will use for RTP and RTCP */\n  rtpsink = gst_element_factory_make (\"udpsink\", \"rtpsink\");\n  g_assert (rtpsink);\n  g_object_set (rtpsink, \"port\", 5002, \"host\", DEST_HOST, NULL);\n\n  rtcpsink = gst_element_factory_make (\"udpsink\", \"rtcpsink\");\n  g_assert (rtcpsink);\n  g_object_set (rtcpsink, \"port\", 5003, \"host\", DEST_HOST, NULL);\n  /* no need for synchronisation or preroll on the RTCP sink */\n  g_object_set (rtcpsink, \"async\", FALSE, \"sync\", FALSE, NULL);\n\n  rtcpsrc = gst_element_factory_make (\"udpsrc\", \"rtcpsrc\");\n  g_assert (rtcpsrc);\n  g_object_set (rtcpsrc, \"port\", 5007, NULL);\n\n  gst_bin_add_many (GST_BIN (pipeline), rtpsink, rtcpsink, rtcpsrc, NULL);\n\n  /* now link all to the rtpbin, start by getting an RTP sinkpad for session 0 */\n  sinkpad = gst_element_get_request_pad (rtpbin, \"send_rtp_sink_0\");\n  srcpad = gst_element_get_static_pad (audiopay, \"src\");\n  lres = gst_pad_link (srcpad, sinkpad);\n  g_assert (lres == GST_PAD_LINK_OK);\n  gst_object_unref (srcpad);\n\n  /* get the RTP srcpad that was created when we requested the sinkpad above and\n   * link it to the rtpsink sinkpad*/\n  srcpad = gst_element_get_static_pad (rtpbin, \"send_rtp_src_0\");\n  sinkpad = gst_element_get_static_pad (rtpsink, \"sink\");\n  lres = gst_pad_link (srcpad, sinkpad);\n  g_assert (lres == GST_PAD_LINK_OK);\n  gst_object_unref (srcpad);\n  gst_object_unref (sinkpad);\n\n  /* get an RTCP srcpad for sending RTCP to the receiver */\n  srcpad = gst_element_get_request_pad (rtpbin, \"send_rtcp_src_0\");\n  sinkpad = gst_element_get_static_pad (rtcpsink, \"sink\");\n  lres = gst_pad_link (srcpad, sinkpad);\n  g_assert (lres == GST_PAD_LINK_OK);\n  gst_object_unref (sinkpad);\n\n  /* we also want to receive RTCP, request an RTCP sinkpad for session 0 and\n   * link it to the srcpad of the udpsrc for RTCP */\n  srcpad = gst_element_get_static_pad (rtcpsrc, \"src\");\n  sinkpad = gst_element_get_request_pad (rtpbin, \"recv_rtcp_sink_0\");\n  lres = gst_pad_link (srcpad, sinkpad);\n  g_assert (lres == GST_PAD_LINK_OK);\n  gst_object_unref (srcpad);\n\n  /* set the pipeline to playing */\n  g_print (\"starting sender pipeline\\n\");\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n\n  /* print stats every second */\n  g_timeout_add (1000, (GSourceFunc) print_stats, rtpbin);\n\n  /* we need to run a GLib main loop to get the messages */\n  loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (loop);\n\n  g_print (\"stopping sender pipeline\\n\");\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n\n  return 0;\n}", "path": "tests\\examples\\rtp\\server-alsasrc-PCMA.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* takes over reference for outcaps */\n", "func_signal": "static GstElement *\nsetup_filter (const gchar * name, const gchar * prop, va_list var_args)", "code": "{\n  GstElement *element;\n\n  GST_DEBUG (\"setup_element\");\n  element = gst_check_setup_element (name);\n  g_object_set_valist (G_OBJECT (element), prop, var_args);\n  mysrcpad = gst_check_setup_src_pad (element, &srctemplate, NULL);\n  gst_pad_set_active (mysrcpad, TRUE);\n  mysinkpad = gst_check_setup_sink_pad (element, &sinktemplate, NULL);\n  gst_pad_set_active (mysinkpad, TRUE);\n\n  return element;\n}", "path": "tests\\check\\elements\\videofilter.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* Element class */\n", "func_signal": "static void\ngst_audio_wsinclimit_base_init (gpointer g_class)", "code": "{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);\n\n  gst_element_class_set_details_simple (element_class,\n      \"Low pass & high pass filter\", \"Filter/Effect/Audio\",\n      \"Low pass and high pass windowed sinc filter\",\n      \"Thomas Vander Stichele <thomas at apestaart dot org>, \"\n      \"Steven W. Smith, \"\n      \"Dreamlab Technologies Ltd. <mathis.hofer@dreamlab.net>, \"\n      \"Sebastian Dr\u00f6ge <sebastian.droege@collabora.co.uk>\");\n}", "path": "gst\\audiofx\\audiowsinclimit.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* note: we must not take the object lock here unless we fix up get_property */\n", "func_signal": "static gboolean\ngst_oss4_sink_open (GstAudioSink * asink, gboolean silent_errors)", "code": "{\n  GstOss4Sink *oss;\n  gchar *device;\n  int mode;\n\n  oss = GST_OSS4_SINK (asink);\n\n  if (oss->device)\n    device = g_strdup (oss->device);\n  else\n    device = gst_oss4_audio_find_device (GST_OBJECT_CAST (oss));\n\n  /* desperate times, desperate measures */\n  if (device == NULL)\n    device = g_strdup (\"/dev/dsp0\");\n\n  GST_INFO_OBJECT (oss, \"Trying to open OSS4 device '%s'\", device);\n\n  /* we open in non-blocking mode even if we don't really want to do writes\n   * non-blocking because we can't be sure that this is really a genuine\n   * OSS4 device with well-behaved drivers etc. We really don't want to\n   * hang forever under any circumstances. */\n  oss->fd = open (device, O_WRONLY | O_NONBLOCK, 0);\n  if (oss->fd == -1) {\n    switch (errno) {\n      case EBUSY:\n        goto busy;\n      case EACCES:\n        goto no_permission;\n      default:\n        goto open_failed;\n    }\n  }\n\n  GST_INFO_OBJECT (oss, \"Opened device '%s'\", device);\n\n  /* Make sure it's OSS4. If it's old OSS, let osssink handle it */\n  if (!gst_oss4_audio_check_version (GST_OBJECT_CAST (oss), oss->fd))\n    goto legacy_oss;\n\n  /* now remove the non-blocking flag. */\n  mode = fcntl (oss->fd, F_GETFL);\n  mode &= ~O_NONBLOCK;\n  if (fcntl (oss->fd, F_SETFL, mode) < 0) {\n    /* some drivers do no support unsetting the non-blocking flag, try to\n     * close/open the device then. This is racy but we error out properly. */\n    GST_WARNING_OBJECT (oss, \"failed to unset O_NONBLOCK (buggy driver?), \"\n        \"will try to re-open device now\");\n    gst_oss4_sink_close (asink);\n    if ((oss->fd = open (device, O_WRONLY, 0)) == -1)\n      goto non_block;\n  }\n\n  oss->open_device = device;\n\n  /* not using ENGINEINFO here because it sometimes returns a different and\n   * less useful name than AUDIOINFO for the same device */\n  if (!gst_oss4_property_probe_find_device_name (GST_OBJECT (oss), oss->fd,\n          oss->open_device, &oss->device_name)) {\n    oss->device_name = NULL;\n  }\n\n  /* list output routings, for informational purposes only so far */\n  {\n    oss_mixer_enuminfo routings = { 0, };\n    guint i;\n\n    if (ioctl (oss->fd, SNDCTL_DSP_GET_PLAYTGT_NAMES, &routings) != -1) {\n      GST_LOG_OBJECT (oss, \"%u output routings (static list: %d)\",\n          routings.nvalues, !!(routings.version == 0));\n      for (i = 0; i < routings.nvalues; ++i) {\n        GST_LOG_OBJECT (oss, \"  output routing %d: %s\", i,\n            &routings.strings[routings.strindex[i]]);\n      }\n    }\n  }\n\n  return TRUE;\n\n  /* ERRORS */\nbusy:\n  {\n    if (!silent_errors) {\n      GST_ELEMENT_ERROR (oss, RESOURCE, BUSY,\n          (_(\"Could not open audio device for playback. \"\n                  \"Device is being used by another application.\")), (NULL));\n    }\n    g_free (device);\n    return FALSE;\n  }\nno_permission:\n  {\n    if (!silent_errors) {\n      GST_ELEMENT_ERROR (oss, RESOURCE, OPEN_WRITE,\n          (_(\"Could not open audio device for playback. \"\n                  \"You don't have permission to open the device.\")),\n          GST_ERROR_SYSTEM);\n    }\n    g_free (device);\n    return FALSE;\n  }\nopen_failed:\n  {\n    if (!silent_errors) {\n      GST_ELEMENT_ERROR (oss, RESOURCE, OPEN_WRITE,\n          (_(\"Could not open audio device for playback.\")), GST_ERROR_SYSTEM);\n    }\n    g_free (device);\n    return FALSE;\n  }\nlegacy_oss:\n  {\n    if (!silent_errors) {\n      GST_ELEMENT_ERROR (oss, RESOURCE, OPEN_WRITE,\n          (_(\"Could not open audio device for playback. \"\n                  \"This version of the Open Sound System is not supported by this \"\n                  \"element.\")), (\"Try the 'osssink' element instead\"));\n    }\n    gst_oss4_sink_close (asink);\n    g_free (device);\n    return FALSE;\n  }\nnon_block:\n  {\n    if (!silent_errors) {\n      GST_ELEMENT_ERROR (oss, RESOURCE, SETTINGS, (NULL),\n          (\"Unable to set device %s into non-blocking mode: %s\",\n              oss->device, g_strerror (errno)));\n    }\n    g_free (device);\n    return FALSE;\n  }\n}", "path": "sys\\oss4\\oss4-sink.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* GstBaseTransform vmethod implementations */\n", "func_signal": "static GstFlowReturn\ngst_audio_fx_base_iir_filter_transform_ip (GstBaseTransform * base,\n    GstBuffer * buf)", "code": "{\n  GstAudioFXBaseIIRFilter *filter = GST_AUDIO_FX_BASE_IIR_FILTER (base);\n  guint num_samples;\n  GstClockTime timestamp, stream_time;\n\n  timestamp = GST_BUFFER_TIMESTAMP (buf);\n  stream_time =\n      gst_segment_to_stream_time (&base->segment, GST_FORMAT_TIME, timestamp);\n\n  GST_DEBUG_OBJECT (filter, \"sync to %\" GST_TIME_FORMAT,\n      GST_TIME_ARGS (timestamp));\n\n  if (GST_CLOCK_TIME_IS_VALID (stream_time))\n    gst_object_sync_values (G_OBJECT (filter), stream_time);\n\n  num_samples =\n      GST_BUFFER_SIZE (buf) / (GST_AUDIO_FILTER (filter)->format.width / 8);\n\n  if (gst_base_transform_is_passthrough (base))\n    return GST_FLOW_OK;\n\n  g_return_val_if_fail (filter->a != NULL, GST_FLOW_ERROR);\n\n  filter->process (filter, GST_BUFFER_DATA (buf), num_samples);\n\n  return GST_FLOW_OK;\n}", "path": "gst\\audiofx\\audiofxbaseiirfilter.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "// ###\n", "func_signal": "static gboolean\ngst_osx_ring_buffer_stop (GstRingBuffer * buf)", "code": "{\n  OSErr status;\n  GstOsxRingBuffer *osxbuf;\n\n  osxbuf = GST_OSX_RING_BUFFER (buf);\n\n  GST_DEBUG (\"osx ring buffer stop ioproc: 0x%p device_id %lu\",\n      osxbuf->element->io_proc, (gulong) osxbuf->device_id);\n\n  status = AudioOutputUnitStop (osxbuf->audiounit);\n  if (status)\n    GST_WARNING (\"AudioOutputUnitStop returned %d\", (int) status);\n\n  // ###: why is it okay to directly remove from here but not from pause() ?\n  if (osxbuf->io_proc_active) {\n    gst_osx_ring_buffer_remove_render_callback (osxbuf);\n  }\n  return TRUE;\n}", "path": "sys\\osxaudio\\gstosxringbuffer.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/**\n * gst_avi_subtitle_title_tag:\n * @sub: subtitle element\n * @title: the title of this subtitle stream\n *\n * Send an event to the srcpad of the @sub element with the title\n * of the subtitle stream as a GST_TAG_TITLE\n */\n", "func_signal": "static void\ngst_avi_subtitle_title_tag (GstAviSubtitle * sub, gchar * title)", "code": "{\n  GstTagList *temp_list = gst_tag_list_new ();\n\n  gst_tag_list_add (temp_list, GST_TAG_MERGE_APPEND, GST_TAG_TITLE, title,\n      NULL);\n  gst_pad_push_event (sub->src, gst_event_new_tag (temp_list));\n}", "path": "gst\\avi\\gstavisubtitle.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* get notified of caps and plug in the correct process function */\n", "func_signal": "static gboolean\ngst_audio_wsinclimit_setup (GstAudioFilter * base, GstRingBufferSpec * format)", "code": "{\n  GstAudioWSincLimit *self = GST_AUDIO_WSINC_LIMIT (base);\n\n  gst_audio_wsinclimit_build_kernel (self);\n\n  return GST_AUDIO_FILTER_CLASS (parent_class)->setup (base, format);\n}", "path": "gst\\audiofx\\audiowsinclimit.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* print the stats of a source */\n", "func_signal": "static void\nprint_source_stats (GObject * source)", "code": "{\n  GstStructure *stats;\n  gchar *str;\n\n  /* get the source stats */\n  g_object_get (source, \"stats\", &stats, NULL);\n\n  /* simply dump the stats structure */\n  str = gst_structure_to_string (stats);\n  g_print (\"source stats: %s\\n\", str);\n\n  gst_structure_free (stats);\n  g_free (str);\n}", "path": "tests\\examples\\rtp\\server-alsasrc-PCMA.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "// ###\n", "func_signal": "static gboolean\ngst_osx_ring_buffer_pause (GstRingBuffer * buf)", "code": "{\n  GstOsxRingBuffer *osxbuf = GST_OSX_RING_BUFFER (buf);\n\n  GST_DEBUG (\"osx ring buffer pause ioproc: 0x%p device_id %lu\",\n      osxbuf->element->io_proc, (gulong) osxbuf->device_id);\n  if (osxbuf->io_proc_active) {\n    /* CoreAudio isn't threadsafe enough to do this here; we must deactivate\n     * the render callback elsewhere. See:\n     *   http://lists.apple.com/archives/Coreaudio-api/2006/Mar/msg00010.html\n     */\n    osxbuf->io_proc_needs_deactivation = TRUE;\n  }\n  return TRUE;\n}", "path": "sys\\osxaudio\\gstosxringbuffer.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/*\n * look-up tables (LUT).\n */\n", "func_signal": "static void\ngst_video_balance_update_tables (GstVideoBalance * vb)", "code": "{\n  gint i, j;\n  gdouble y, u, v, hue_cos, hue_sin;\n\n  /* Y */\n  for (i = 0; i < 256; i++) {\n    y = 16 + ((i - 16) * vb->contrast + vb->brightness * 255);\n    if (y < 0)\n      y = 0;\n    else if (y > 255)\n      y = 255;\n    vb->tabley[i] = rint (y);\n  }\n\n  hue_cos = cos (M_PI * vb->hue);\n  hue_sin = sin (M_PI * vb->hue);\n\n  /* U/V lookup tables are 2D, since we need both U/V for each table\n   * separately. */\n  for (i = -128; i < 128; i++) {\n    for (j = -128; j < 128; j++) {\n      u = 128 + ((i * hue_cos + j * hue_sin) * vb->saturation);\n      v = 128 + ((-i * hue_sin + j * hue_cos) * vb->saturation);\n      if (u < 0)\n        u = 0;\n      else if (u > 255)\n        u = 255;\n      if (v < 0)\n        v = 0;\n      else if (v > 255)\n        v = 255;\n      vb->tableu[i + 128][j + 128] = rint (u);\n      vb->tablev[i + 128][j + 128] = rint (v);\n    }\n  }\n}", "path": "gst\\videofilter\\gstvideobalance.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/*\n * Free the state allocated with convolve_init().\n */\n", "func_signal": "void\nconvolve_close (convolve_state * state)", "code": "{\n  if (state)\n    free (state);\n}", "path": "gst\\monoscope\\convolve.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/* GST_ALAW_DEC_USE_TABLE */\n", "func_signal": "static gboolean\ngst_alaw_dec_sink_setcaps (GstPad * pad, GstCaps * caps)", "code": "{\n  GstALawDec *alawdec;\n  GstStructure *structure;\n  int rate, channels;\n  gboolean ret;\n  GstCaps *outcaps;\n\n  alawdec = GST_ALAW_DEC (GST_PAD_PARENT (pad));\n\n  structure = gst_caps_get_structure (caps, 0);\n\n  ret = gst_structure_get_int (structure, \"rate\", &rate);\n  ret &= gst_structure_get_int (structure, \"channels\", &channels);\n  if (!ret)\n    return FALSE;\n\n  outcaps = gst_caps_new_simple (\"audio/x-raw-int\",\n      \"width\", G_TYPE_INT, 16,\n      \"depth\", G_TYPE_INT, 16,\n      \"endianness\", G_TYPE_INT, G_BYTE_ORDER,\n      \"signed\", G_TYPE_BOOLEAN, TRUE,\n      \"rate\", G_TYPE_INT, rate, \"channels\", G_TYPE_INT, channels, NULL);\n\n  ret = gst_pad_set_caps (alawdec->srcpad, outcaps);\n  gst_caps_unref (outcaps);\n\n  if (ret) {\n    GST_DEBUG_OBJECT (alawdec, \"rate=%d, channels=%d\", rate, channels);\n    alawdec->rate = rate;\n    alawdec->channels = channels;\n  }\n  return ret;\n}", "path": "gst\\law\\alaw-decode.c", "repo_name": "zaheerm/gst-plugins-good", "stars": 4, "license": "lgpl-2.1", "language": "c", "size": 14524}
{"docstring": "/*\n *\tvoid r_run (occ_environment *env, int env_size, char *args, int arg0_size, int arg1_size, int kyb_fd, int scr_fd, int err_fd, int *result, int killable)\n *\tRuns a command to completion\n */\n", "func_signal": "static __inline__ void r_run (occ_environment *env, int env_size, char *args, int arg0_size, int arg1_size, int kyb_fd, int scr_fd, int err_fd, int *result, int killable)", "code": "{\n\tpid_t chld_pid, got_pid;\n\tint chld_status;\n\tchar **chld_args;\n\tint i;\n\tint *mem_ptr = NULL;\n\n#ifdef OCCBUILD_KROC\n\tif (killable) {\n\t\tmem_ptr = bsyscalls_set_cleanup (NULL);\n\t\t*mem_ptr = -1;\n\t\tbsyscalls_set_cleanup (r_run_cleanup);\n\t}\n#endif\n\tsignal (SIGCHLD, SIG_IGN);\n\tswitch ((chld_pid = fork())) {\n\tcase -1:\n\t\t*result = -1;\n\t\tfprintf (stderr, \"KRoC: proclib: r_run: unable to fork(): %s\\n\", strerror(errno));\n\t\tbreak;\n\tcase 0:\n\t\t/* child -- cam abuse heap in here :) */\n\t\tif (kyb_fd == -1) {\n\t\t\tclose (0);\n\t\t} else if (kyb_fd != 0) {\n\t\t\tdup2 (kyb_fd, 0);\n\t\t}\n\t\tif (scr_fd == -1) {\n\t\t\tclose (1);\n\t\t} else if (scr_fd != 1) {\n\t\t\tdup2 (scr_fd, 1);\n\t\t}\n\t\tif (err_fd == -1) {\n\t\t\tclose (2);\n\t\t} else if (err_fd != 2) {\n\t\t\tdup2 (err_fd, 2);\n\t\t}\n\t\tfor (i=0; i<env_size; i++) {\n\t\t\tenv[i].ident[env[i].ident_size] = '\\0';\n\t\t\tenv[i].value[env[i].value_size] = '\\0';\n\t\t\tsetenv (env[i].ident, env[i].value, 0);\n\t\t}\n\t\tchld_args = (char **)malloc ((arg0_size + 1) * sizeof (char *));\n\t\tif (!chld_args) {\n\t\t\tfprintf (stderr, \"KRoC: proclib: r_run: child out of memory\\n\");\n\t\t\t_exit (1);\n\t\t}\n\t\tfor (i=0; i<arg0_size; i++) {\n\t\t\tchld_args[i] = (char *)malloc (arg1_size + 1);\n\t\t\tif (!chld_args[i]) {\n\t\t\t\tfprintf (stderr, \"KRoC: proclib: r_run: child out of memory\\n\");\n\t\t\t\t_exit (1);\n\t\t\t}\n\t\t\tmemcpy (chld_args[i], &(args[i * arg1_size]), arg1_size);\n\t\t\tchld_args[i][arg1_size] = '\\0';\n\t\t}\n\t\tchld_args[arg0_size] = NULL;\n\t\texecvp (*chld_args, chld_args);\n\t\t_exit (1);\n\t\tbreak;\n\tdefault:\n\t\t/* parent */\n\t\tif (killable) {\n\t\t\t*mem_ptr = chld_pid;\n\t\t}\n\t\tretry_waitpid:\n\t\tgot_pid = waitpid (chld_pid, &chld_status, 0);\n\t\tif (got_pid != chld_pid) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\tgoto retry_waitpid;\n\t\t\t}\n\t\t\tfprintf (stderr, \"KRoC: proclib: r_run: waitpid returned %d, expecting %d.  Failing\\n\", got_pid, chld_pid);\n\t\t\t*result = -1;\n\t\t} else {\n\t\t\tif (WIFEXITED (chld_status)) {\n\t\t\t\t*result = WEXITSTATUS (chld_status);\n\t\t\t} else if (WIFSIGNALED (chld_status)) {\n\t\t\t\tfprintf (stderr, \"KRoC: proclib: r_run: child exited on signal %d\\n\", WTERMSIG(chld_status));\n\t\t\t\t*result = -1;\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"KRoC: proclib: r_run: child stopped on signal %d\\n\", WSTOPSIG(chld_status));\n\t\t\t\t*result = -1;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "modules\\bsclib\\libsrc\\proclib\\cproc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_verify (ext_chan_t *chan, unsigned int hashcode)\n *\tchannel verify\n */\n", "func_signal": "static int cspdrv_chan_verify (ext_chan_t *chan, unsigned int hashcode)", "code": "{\n\tucsp_chaninfo cinf;\n\n\tcinf.chanid = (int)chan->userptr;\n\tcinf.dir = (int)hashcode;\n\treturn ioctl (csp_fd, IOCTL_TYPE_CHANNEL, (char *)&cinf);\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_moutn (ext_chan_t *chan, unsigned int *ptr, int dimcount)\n *\tdynamic MOBILE output (multi-dimensional)\n *\tneeds mobile-size-field support\n */\n", "func_signal": "static int cspdrv_chan_moutn (ext_chan_t *chan, unsigned int *ptr, int dimcount)", "code": "{\n\tint *wsptr = (int *)ptr;\n\tchar *addr = (char *)(wsptr[0]);\n\tint *dim = (int *)(&(wsptr[1]));\n\tint type_size = wsptr[dimcount + 1];\n\tint mobile_size, d;\n\tucsp_datainfo dinf = {(int)chan->userptr, (char *)dim, sizeof (int) * dimcount};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d) for MOUTN dimensions\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\n\tfor (mobile_size = type_size, d = 0; d < dimcount; mobile_size *= dim[d], d++);\n\tdinf.data = addr;\n\tdinf.length = mobile_size;\n#if 1\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d) for MOUTN\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_read (ext_chan_t *chan, char *ptr, int len)\n *\tchannel read\n */\n", "func_signal": "static int cspdrv_chan_read (ext_chan_t *chan, char *ptr, int len)", "code": "{\n\tucsp_datainfo dinf = {(int)chan->userptr, ptr, len};\n\n#if 0\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d)\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_min (ext_chan_t *chan, void **pptr)\n *\tMOBILE input\n */\n", "func_signal": "static int cspdrv_chan_min (ext_chan_t *chan, void **pptr)", "code": "{\n\tint *wsptr = (int *)pptr;\n\tchar *addr = (char *)(wsptr[0]);\n\tint mobile_size = wsptr[1];\n\tucsp_datainfo dinf = {(int)chan->userptr, addr, mobile_size};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d) for MIN\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_write (ext_chan_t *chan, char *ptr, int len)\n *\tchannel write\n */\n", "func_signal": "static int cspdrv_chan_write (ext_chan_t *chan, char *ptr, int len)", "code": "{\n\tucsp_datainfo dinf = {(int)chan->userptr, ptr, len};\n\n#if 0\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d)\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_mout (ext_chan_t *chan, void **pptr)\n *\tMOBILE output\n */\n", "func_signal": "static int cspdrv_chan_mout (ext_chan_t *chan, void **pptr)", "code": "{\n\tint *wsptr = (int *)pptr;\n\tchar *addr = (char *)(wsptr[0]);\n\tint mobile_size = wsptr[1];\n\tucsp_datainfo dinf = {(int)chan->userptr, addr, mobile_size};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d) for MOUT\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/* file: inc.c */\n", "func_signal": "void increment (int w[])", "code": "{ /* INT v*/\n  int x = w[0];\n  x = x + 1;\n}", "path": "tools\\tinyswig\\inc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tvoid cspdrv_release (int *addr)\n *\treleases a channel\n */\n", "func_signal": "static __inline__ void cspdrv_release (int *addr)", "code": "{\n\text_chan_t *chan = (ext_chan_t *)(*addr);\n\tucsp_chaninfo cinf;\n\n\tif (csp_fd < 0) {\n\t\treturn;\n\t}\n\tcinf.chanid = (int)chan->userptr;\n\tioctl (csp_fd, IOCTL_RELEASE_CHANNEL, (char *)&cinf);\n\t*addr = 0;\n\treturn;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tvoid r_os_getenv (occ_environment *env, char *ident, int ident_size)\n *\tgets an environment variable from this OS process\n */\n", "func_signal": "static __inline__ void r_os_getenv (occ_environment *env, char *ident, int ident_size)", "code": "{\n\tint x;\n\tchar *ptr;\n\n\tx = (ident_size > 127) ? 127 : ident_size;\n\tmemcpy (env->ident, ident, x);\n\tenv->ident[x] = '\\0';\n\tenv->ident_size = x;\n\tptr = getenv (env->ident);\n\tif (!ptr) {\n\t\tenv->value_size = 0;\n\t} else {\n\t\tx = (strlen (ptr) > 127) ? 127 : strlen (ptr);\n\t\tmemcpy (env->value, ptr, x);\n\t\tenv->value[x] = '\\0';\n\t\tenv->value_size = x;\n\t}\n}", "path": "modules\\bsclib\\libsrc\\proclib\\cproc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_enable (ext_chan_t *chan)\n *\tchannel ALT enable\n */\n", "func_signal": "static int cspdrv_chan_enable (ext_chan_t *chan)", "code": "{\n\tucsp_altinfo ainf = {(int)chan->userptr, 0};\n\n\tif (ioctl (csp_fd, IOCTL_ENABLE_CHANNEL, (char *)&ainf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to enable channel: %s\\n\", strerror (errno));\n\t\treturn 0;\n\t}\n\tif (ainf.ready) {\n\t\treturn 1;\n\t}\n\t/* dispatch blocking ALT */\n\tccsp_udc_start_alter (chan, cspdrv_chan_alter, (int *)chan);\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_open (void)\n *\topens the csplib device\n */\n", "func_signal": "static int cspdrv_open (void)", "code": "{\n\tif (csp_fd > -1) {\n\t\treturn 0;\n\t}\n\tcsp_fd = open (\"/dev/cspdrv\", O_RDWR);\n\tif (csp_fd < 0) {\n\t\tcsp_fd = -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_minn (ext_chan_t *chan, unsigned int *ptr, int dimcount)\n *\tdynamic MOBILE input (multi-dimensional)\n *\tneeds mobile-size-field support\n */\n", "func_signal": "static int cspdrv_chan_minn (ext_chan_t *chan, unsigned int *ptr, int dimcount)", "code": "{\n\tint *wsptr = (int *)ptr;\n\tchar **addr = (char **)wsptr;\n\tint *dim = (int *)(&(wsptr[1]));\n\tint type_size = wsptr[dimcount + 1];\n\tint mobile_size, d;\n\tucsp_datainfo dinf = {(int)chan->userptr, (char *)dim, sizeof (int) * dimcount};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d) for MINN dimensions\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n\n\tfor (mobile_size = type_size, d = 0; d < dimcount; mobile_size *= dim[d], d++);\n\t*addr = (char *)dmem_alloc (mobile_size);\n\n\tdinf.data = *addr;\n\tdinf.length = mobile_size;\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d) for MINN\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tcalled to disable a channel\n *\tchannel ALT disable\n */\n", "func_signal": "static int cspdrv_chan_disable (ext_chan_t *chan)", "code": "{\n\tucsp_altinfo ainf = {(int)chan->userptr, 0};\n\n\tif (ioctl (csp_fd, IOCTL_DISABLE_CHANNEL, (char *)&ainf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to disable channel: %s\\n\", strerror (errno));\n\t\treturn 0;\n\t}\n\tif (ainf.ready) {\n\t\t/* thingie has terminated, or doing so */\n\t\treturn 1;\n\t}\n\tif (ccsp_udc_kill_alter (chan) < 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tvoid r_os_setenv (occ_environment *env, int env_size)\n *\tsets environmental varibles in this OS process\n */\n", "func_signal": "static __inline__ void r_os_setenv (occ_environment *env, int env_size)", "code": "{\n\tint x, isize, vsize;\n\n\tfor (x=0; x<env_size; x++) {\n\t\tif (env[x].ident_size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tisize = (env[x].ident_size > 127) ? 127 : env[x].ident_size;\n\t\tenv[x].ident[isize] = '\\0';\n\t\tvsize = (env[x].value_size > 127) ? 127 : env[x].value_size;\n\t\tenv[x].value[vsize] = '\\0';\n\t\tif (!vsize) {\n\t\t\tunsetenv (env[x].ident);\n\t\t} else {\n\t\t\tsetenv (env[x].ident, env[x].value, 1);\n\t\t}\n\t}\n}", "path": "modules\\bsclib\\libsrc\\proclib\\cproc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tvoid cspdrv_chan_alter (void *arg, int *wakeflag)\n *\tcalled as the blocking system-call thread\n */\n", "func_signal": "static void cspdrv_chan_alter (void *arg, int *wakeflag)", "code": "{\n\text_chan_t *chan = (ext_chan_t *)arg;\n\tucsp_altinfo ainf = {(int)chan->userptr, 0};\n\n\tif (ioctl (csp_fd, IOCTL_ALTWT, (char *)&ainf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to ALTWT on channel (aborting): %s\\n\", strerror (errno));\n\t\t_exit (0);\n\t}\n\t*wakeflag = 1;\n\treturn;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/* FIXME: Add timer + run queue info */\n/** STATE\n * (where\n *  ((TIME_AFTER now AREG)\n *   (AREG (out undefined))\n *   (BREG (out undefined))\n *   (CREG (out undefined))\n *   (IPTR (out nextinst)))\n *  ((BEFORE now AREG)\n *   (AREG (out undefined))\n *   (BREG (out undefined))\n *   (CREG (out undefined))\n *   (IPTR (out (str IPTR of next scheduled process)))))\n */\n", "func_signal": "TVM_INSTRUCTION (ins_tin)", "code": "{\n\tWORD current_time = ectx->get_time(ectx);\n\tWORD reschedule_time = AREG;\n\n\tif(TIME_AFTER(current_time, reschedule_time))\n\t{\n\t\t/* Do nothing, as we have already timed out */\n\t\tUNDEFINE_STACK_RET();\n\t}\n\telse\n\t{\n\t\t/* Store our reschedule time in our workspace */\n\t\tWORKSPACE_SET(WPTR, WS_TIME, reschedule_time);\n\t\t/* Store the IPTR in our workspace */\n\t\tWORKSPACE_SET(WPTR, WS_IPTR, (WORD)IPTR);\n\t\t\n\t\t/* We need to insert ourselves into the timer queue, this is an ordered\n\t\t * queue, after that we need to reschedule another process */\n\t\t/* Put ourselves into the timer queue */\n\t\tTIMER_QUEUE_INSERT(WPTR, current_time, reschedule_time);\n\t\t\n\t\t/* FIXME: Is this the correct thing to do next? */\n\t\t/* Since we use the (ALT) STATE to check for READY_P for things on the\n\t\t * timer queue, we should probably set the (ALT) STATE to a known value\n\t\t * here (ie something else than READY_P\n\t\t */\n\t\tWORKSPACE_SET(WPTR, WS_STATE, NOT_PROCESS_P);\n\t\t\n\t\t/* Run the next process */\n\t\tRUN_NEXT_ON_QUEUE_RET();\n\t}\n}", "path": "runtime\\libtvm\\ins_timer.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_min64 (ext_chan_t *chan, unsigned long long *ptr)\n *\tdynamic MOBILE input (single dimension)\n *\tneeds mobile-size-field support\n */\n", "func_signal": "static int cspdrv_chan_min64 (ext_chan_t *chan, unsigned long long *ptr)", "code": "{\n\tint *wsptr = (int *)ptr;\n\tchar **addr = (char **)wsptr;\n\tint *dim = (int *)(&(wsptr[1]));\n\tint type_size = wsptr[2];\n\tucsp_datainfo dinf = {(int)chan->userptr, (char *)dim, sizeof (int)};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d) for MIN64 dimension\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL: got dimension: %d\\n\", getpid(), *dim);\n#endif\n\t*addr = (char *)dmem_alloc ((*dim) * type_size);\n\n\tdinf.data = *addr;\n\tdinf.length = (*dim) * type_size;\n#if 1\nfprintf (stderr, \"[%d] IOCTL_READ_CHANNEL (%d, %p, %d) for MIN64\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_READ_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to read channel: %s\\n\", strerror (errno));\n\t}\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tint cspdrv_chan_mout64 (ext_chan_t *chan, unsigned long long *ptr)\n *\tdynamic MOBILE output (single dimension)\n *\tneeds mobile-size-field support\n */\n", "func_signal": "static int cspdrv_chan_mout64 (ext_chan_t *chan, unsigned long long *ptr)", "code": "{\n\tint *wsptr = (int *)ptr;\n\tchar *addr = (char *)(wsptr[0]);\n\tint *dim = (int *)(&(wsptr[1]));\n\tint type_size = wsptr[2];\n\tint mobile_size = (*dim) * type_size;\n\tucsp_datainfo dinf = {(int)chan->userptr, (char *)dim, sizeof (int)};\n\n#if 1\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d) for MOUT64 dimension (%d)\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length, *dim);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\n\tdinf.data = addr;\n\tdinf.length = mobile_size;\n#if 1\nfprintf (stderr, \"[%d] IOCTL_WRITE_CHANNEL (%d, %p, %d) for MOUT64\\n\",\ngetpid(), dinf.chanid, dinf.data, dinf.length);\n#endif\n\tif (ioctl (csp_fd, IOCTL_WRITE_CHANNEL, (char *)&dinf)) {\n\t\tfprintf (stderr, \"cspdrv: unable to write channel: %s\\n\", strerror (errno));\n\t}\n\tdmem_release ((void *)addr);\n\treturn 0;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n *\tvoid cspdrv_init (char *name, int namelen, int dir, int *addr)\n *\tgrabs a channel\n */\n", "func_signal": "static __inline__ void cspdrv_init (char *name, int namelen, int dir, int *addr)", "code": "{\n\tucsp_chaninfo cinf;\n\text_chan_t *chan = ccsp_udc_alloc_extchan (0);\n\n\tif (cspdrv_open ()) {\n\t\tccsp_udc_free_extchan (chan);\n\t\t*addr = 0;\n\t\treturn;\n\t}\n\tif (namelen >= (sizeof (cinf.name) - 1)) {\n\t\tnamelen = (sizeof (cinf.name) - 1);\n\t}\n\tmemcpy (cinf.name, name, namelen);\n\tcinf.name[namelen] = '\\0';\n\tcinf.dir = (dir == CSP_CHAN_READ) ? CSP_CHANNEL_READER : CSP_CHANNEL_WRITER;\n\tif (ioctl (csp_fd, IOCTL_GET_CHANNEL, (char *)&cinf)) {\n\t\t*addr = 0;\n\t\treturn;\n\t}\n\n\tchan->userptr = (void *)cinf.chanid;\n\tchan->magic = UDC_MAGIC;\n\tchan->flags = UDC_BLOCKING;\n\tchan->chan_verify = cspdrv_chan_verify;\n\n\tif (dir == CSP_CHAN_READ) {\n\t\tchan->chan_read = cspdrv_chan_read;\n\t\tchan->chan_write = NULL;\n\t\tchan->chan_min = cspdrv_chan_min;\n\t\tchan->chan_mout = NULL;\n\t\tchan->chan_min64 = cspdrv_chan_min64;\n\t\tchan->chan_mout64 = NULL;\n\t\tchan->chan_minn = cspdrv_chan_minn;\n\t\tchan->chan_moutn = NULL;\n\t} else {\n\t\tchan->chan_read = NULL;\n\t\tchan->chan_write = cspdrv_chan_write;\n\t\tchan->chan_min = NULL;\n\t\tchan->chan_mout = cspdrv_chan_mout;\n\t\tchan->chan_min64 = NULL;\n\t\tchan->chan_mout64 = cspdrv_chan_mout64;\n\t\tchan->chan_minn = NULL;\n\t\tchan->chan_moutn = cspdrv_chan_moutn;\n\t}\n\tchan->chan_alt_enable = cspdrv_chan_enable;\n\tchan->chan_alt_disable = cspdrv_chan_disable;\n\t*addr = (int)chan;\n\treturn;\n}", "path": "modules\\bsclib\\libsrc\\cspdrvlib\\cspdrvc.c", "repo_name": "clj/kroc_scons", "stars": 4, "license": "None", "language": "c", "size": 9137}
{"docstring": "/*\n** Free a page object allocated by pcache1AllocPage().\n*/\n", "func_signal": "static void pcache1FreePage(PgHdr1 *p)", "code": "{\n  if( p ){\n    if( p->pCache->bPurgeable ){\n      pcache1.nCurrentPage--;\n    }\n    pcache1Free(PGHDR1_TO_PAGE(p));\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Compare the values contained by the two memory cells, returning\n** negative, zero or positive if pMem1 is less than, equal to, or greater\n** than pMem2. Sorting order is NULL's first, followed by numbers (integers\n** and reals) sorted numerically, followed by text ordered by the collating\n** sequence pColl and finally blob's ordered by memcmp().\n**\n** Two NULL values are considered equal by this function.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl)", "code": "{\n  int rc;\n  int f1, f2;\n  int combined_flags;\n\n  /* Interchange pMem1 and pMem2 if the collating sequence specifies\n  ** DESC order.\n  */\n  f1 = pMem1->flags;\n  f2 = pMem2->flags;\n  combined_flags = f1|f2;\n  assert( (combined_flags & MEM_RowSet)==0 );\n \n  /* If one value is NULL, it is less than the other. If both values\n  ** are NULL, return 0.\n  */\n  if( combined_flags&MEM_Null ){\n    return (f2&MEM_Null) - (f1&MEM_Null);\n  }\n\n  /* If one value is a number and the other is not, the number is less.\n  ** If both are numbers, compare as reals if one is a real, or as integers\n  ** if both values are integers.\n  */\n  if( combined_flags&(MEM_Int|MEM_Real) ){\n    if( !(f1&(MEM_Int|MEM_Real)) ){\n      return 1;\n    }\n    if( !(f2&(MEM_Int|MEM_Real)) ){\n      return -1;\n    }\n    if( (f1 & f2 & MEM_Int)==0 ){\n      double r1, r2;\n      if( (f1&MEM_Real)==0 ){\n        r1 = (double)pMem1->u.i;\n      }else{\n        r1 = pMem1->r;\n      }\n      if( (f2&MEM_Real)==0 ){\n        r2 = (double)pMem2->u.i;\n      }else{\n        r2 = pMem2->r;\n      }\n      if( r1<r2 ) return -1;\n      if( r1>r2 ) return 1;\n      return 0;\n    }else{\n      assert( f1&MEM_Int );\n      assert( f2&MEM_Int );\n      if( pMem1->u.i < pMem2->u.i ) return -1;\n      if( pMem1->u.i > pMem2->u.i ) return 1;\n      return 0;\n    }\n  }\n\n  /* If one value is a string and the other is a blob, the string is less.\n  ** If both are strings, compare using the collating functions.\n  */\n  if( combined_flags&MEM_Str ){\n    if( (f1 & MEM_Str)==0 ){\n      return 1;\n    }\n    if( (f2 & MEM_Str)==0 ){\n      return -1;\n    }\n\n    assert( pMem1->enc==pMem2->enc );\n    assert( pMem1->enc==SQLITE_UTF8 || \n            pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );\n\n    /* The collation sequence must be defined at this point, even if\n    ** the user deletes the collation sequence after the vdbe program is\n    ** compiled (this was not always the case).\n    */\n    assert( !pColl || pColl->xCmp );\n\n    if( pColl ){\n      if( pMem1->enc==pColl->enc ){\n        /* The strings are already in the correct encoding.  Call the\n        ** comparison function directly */\n        return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);\n      }else{\n        const void *v1, *v2;\n        int n1, n2;\n        Mem c1;\n        Mem c2;\n        memset(&c1, 0, sizeof(c1));\n        memset(&c2, 0, sizeof(c2));\n        sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);\n        sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);\n        v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);\n        n1 = v1==0 ? 0 : c1.n;\n        v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);\n        n2 = v2==0 ? 0 : c2.n;\n        rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);\n        sqlite3VdbeMemRelease(&c1);\n        sqlite3VdbeMemRelease(&c2);\n        return rc;\n      }\n    }\n    /* If a NULL pointer was passed as the collate function, fall through\n    ** to the blob case and use memcmp().  */\n  }\n \n  /* Both values must be blobs.  Compare using memcmp().  */\n  rc = memcmp(pMem1->z, pMem2->z, (pMem1->n>pMem2->n)?pMem2->n:pMem1->n);\n  if( rc==0 ){\n    rc = pMem1->n - pMem2->n;\n  }\n  return rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Set P4 of the most recently inserted opcode to a column affinity\n** string for index pIdx. A column affinity string has one character\n** for each column in the table, according to the affinity of the column:\n**\n**  Character      Column affinity\n**  ------------------------------\n**  'a'            TEXT\n**  'b'            NONE\n**  'c'            NUMERIC\n**  'd'            INTEGER\n**  'e'            REAL\n**\n** An extra 'b' is appended to the end of the string to cover the\n** rowid that appears as the last column in every index.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx)", "code": "{\n  if( !pIdx->zColAff ){\n    /* The first time a column affinity string for a particular index is\n    ** required, it is allocated and populated here. It is then stored as\n    ** a member of the Index structure for subsequent use.\n    **\n    ** The column affinity string will eventually be deleted by\n    ** sqliteDeleteIndex() when the Index structure itself is cleaned\n    ** up.\n    */\n    int n;\n    Table *pTab = pIdx->pTable;\n    sqlite3 *db = sqlite3VdbeDb(v);\n    pIdx->zColAff = (char *)sqlite3Malloc(pIdx->nColumn+2);\n    if( !pIdx->zColAff ){\n      db->mallocFailed = 1;\n      return;\n    }\n    for(n=0; n<pIdx->nColumn; n++){\n      pIdx->zColAff[n] = pTab->aCol[pIdx->aiColumn[n]].affinity;\n    }\n    pIdx->zColAff[n++] = SQLITE_AFF_NONE;\n    pIdx->zColAff[n] = 0;\n  }\n \n  sqlite3VdbeChangeP4(v, -1, pIdx->zColAff, 0);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Close the cursor.  For additional information see the documentation\n** on the xClose method of the virtual table interface.\n*/\n", "func_signal": "static int fulltextClose(sqlite3_vtab_cursor *pCursor)", "code": "{\n  fulltext_cursor *c = (fulltext_cursor *) pCursor;\n  FTSTRACE((\"FTS3 Close %p\\n\", c));\n  sqlite3_finalize(c->pStmt);\n  sqlite3Fts3ExprFree(c->pExpr);\n  snippetClear(&c->snippet);\n  if( c->result.nData!=0 ){\n    dlrDestroy(&c->reader);\n  }\n  dataBufferDestroy(&c->result);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Return the total number of pages in the database file associated \n** with pPager. Normally, this is calculated as (<db file size>/<page-size>).\n** However, if the file is between 1 and <page-size> bytes in size, then \n** this is considered a 1 page file.\n**\n** If the pager is in error state when this function is called, then the\n** error state error code is returned and *pnPage left unchanged. Or,\n** if the file system has to be queried for the size of the file and\n** the query attempt returns an IO error, the IO error code is returned\n** and *pnPage is left unchanged.\n**\n** Otherwise, if everything is successful, then SQLITE_OK is returned\n** and *pnPage is set to the number of pages in the database.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3PagerPagecount(Pager *pPager, int *pnPage)", "code": "{\n  Pgno nPage;               /* Value to return via *pnPage */\n\n  /* If the pager is already in the error state, return the error code. */\n  if( pPager->errCode ){\n    return pPager->errCode;\n  }\n\n  /* Determine the number of pages in the file. Store this in nPage. */\n  if( pPager->dbSizeValid ){\n    nPage = pPager->dbSize;\n  }else{\n    int rc;                 /* Error returned by OsFileSize() */\n    i64 n = 0;              /* File size in bytes returned by OsFileSize() */\n\n    assert( isOpen(pPager->fd) || pPager->tempFile );\n    if( isOpen(pPager->fd) && (0 != (rc = sqlite3OsFileSize(pPager->fd, &n))) ){\n      pager_error(pPager, rc);\n      return rc;\n    }\n    if( n>0 && n<pPager->pageSize ){\n      nPage = 1;\n    }else{\n      nPage = (Pgno)(n / pPager->pageSize);\n    }\n    if( pPager->state!=PAGER_UNLOCK ){\n      pPager->dbSize = nPage;\n      pPager->dbFileSize = nPage;\n      pPager->dbSizeValid = 1;\n    }\n  }\n\n  /* If the current number of pages in the file is greater than the \n  ** configured maximum pager number, increase the allowed limit so\n  ** that the file can be read.\n  */\n  if( nPage>pPager->mxPgno ){\n    pPager->mxPgno = (Pgno)nPage;\n  }\n\n  /* Set the output variable and return SQLITE_OK */\n  if( pnPage ){\n    *pnPage = nPage;\n  }\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Convert pMem so that it is of type MEM_Real.\n** Invalidate any prior representations.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem *pMem)", "code": "{\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n  pMem->r = sqlite3VdbeRealValue(pMem);\n  MemSetTypeFlag(pMem, MEM_Real);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Write a 64-bit variable-length integer to memory starting at p[0].\n** The length of data write will be between 1 and 9 bytes.  The number\n** of bytes written is returned.\n**\n** A variable-length integer consists of the lower 7 bits of each byte\n** for all bytes that have the 8th bit set and one byte with the 8th\n** bit clear.  Except, if we get to the 9th byte, it stores the full\n** 8 bits and is the last byte.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v)", "code": "{\n  int i, j, n;\n  u8 buf[10];\n  if( v & (((u64)0xff000000)<<32) ){\n    p[8] = (u8)v;\n    v >>= 8;\n    for(i=7; i>=0; i--){\n      p[i] = (u8)((v & 0x7f) | 0x80);\n      v >>= 7;\n    }\n    return 9;\n  }    \n  n = 0;\n  do{\n    buf[n++] = (u8)((v & 0x7f) | 0x80);\n    v >>= 7;\n  }while( v!=0 );\n  buf[0] &= 0x7f;\n  assert( n<=9 );\n  for(i=0, j=n-1; j>=0; j--, i++){\n    p[i] = buf[j];\n  }\n  return n;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* This is the xRowid method.  The SQLite core calls this routine to\n** retrieve the rowid for the current row of the result set.  fts3\n** exposes %_content.docid as the rowid for the virtual table.  The\n** rowid should be written to *pRowid.\n*/\n", "func_signal": "static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid)", "code": "{\n  fulltext_cursor *c = (fulltext_cursor *) pCursor;\n\n  *pRowid = sqlite3_column_int64(c->pStmt, 0);\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* Return a dynamically generated statement of the form\n *   insert into %_content (docid, ...) values (?, ...)\n */\n", "func_signal": "static const char *contentInsertStatement(fulltext_vtab *v)", "code": "{\n  StringBuffer sb;\n  int i;\n\n  initStringBuffer(&sb);\n  append(&sb, \"insert into %_content (docid, \");\n  appendList(&sb, v->nColumn, v->azContentColumn);\n  append(&sb, \") values (?\");\n  for(i=0; i<v->nColumn; ++i)\n    append(&sb, \", ?\");\n  append(&sb, \")\");\n  return stringBufferData(&sb);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Check to see if element iRowid was inserted into the the rowset as\n** part of any insert batch prior to iBatch.  Return 1 or 0.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, u8 iBatch, sqlite3_int64 iRowid)", "code": "{\n  struct RowSetEntry *p;\n  if( iBatch!=pRowSet->iBatch ){\n    if( pRowSet->pEntry ){\n      rowSetToList(pRowSet);\n      pRowSet->pTree = rowSetListToTree(pRowSet->pEntry);\n      pRowSet->pEntry = 0;\n      pRowSet->pLast = 0;\n    }\n    pRowSet->iBatch = iBatch;\n  }\n  p = pRowSet->pTree;\n  while( p ){\n    if( p->v<iRowid ){\n      p = p->pRight;\n    }else if( p->v>iRowid ){\n      p = p->pLeft;\n    }else{\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Another built-in collating sequence: NOCASE. \n**\n** This collating sequence is intended to be used for \"case independant\n** comparison\". SQLite's knowledge of upper and lower case equivalents\n** extends only to the 26 characters used in the English language.\n**\n** At the moment there is only a UTF-8 implementation.\n*/\n", "func_signal": "static int nocaseCollatingFunc(\n  void *NotUsed,\n  int nKey1, const void *pKey1,\n  int nKey2, const void *pKey2\n)", "code": "{\n  int r = sqlite3StrNICmp(\n      (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);\n  UNUSED_PARAMETER(NotUsed);\n  if( 0==r ){\n    r = nKey1-nKey2;\n  }\n  return r;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** This routine adds datatype and collating sequence information to\n** the Table structures of all FROM-clause subqueries in a\n** SELECT statement.\n**\n** Use this routine after name resolution.\n*/\n", "func_signal": "static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect)", "code": "{\n#ifndef SQLITE_OMIT_SUBQUERY\n  Walker w;\n  w.xSelectCallback = selectAddSubqueryTypeInfo;\n  w.xExprCallback = exprWalkNoop;\n  w.pParse = pParse;\n  sqlite3WalkSelect(&w, pSelect);\n#endif\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* Helper function for posListUnion().  Compares the current position\n** between left and right, returning as standard C idiom of <0 if\n** left<right, >0 if left>right, and 0 if left==right.  \"End\" always\n** compares greater.\n*/\n", "func_signal": "static int posListCmp(PLReader *pLeft, PLReader *pRight)", "code": "{\n  assert( pLeft->iType==pRight->iType );\n  if( pLeft->iType==DL_DOCIDS ) return 0;\n\n  if( plrAtEnd(pLeft) ) return plrAtEnd(pRight) ? 0 : 1;\n  if( plrAtEnd(pRight) ) return -1;\n\n  if( plrColumn(pLeft)<plrColumn(pRight) ) return -1;\n  if( plrColumn(pLeft)>plrColumn(pRight) ) return 1;\n\n  if( plrPosition(pLeft)<plrPosition(pRight) ) return -1;\n  if( plrPosition(pLeft)>plrPosition(pRight) ) return 1;\n  if( pLeft->iType==DL_POSITIONS ) return 0;\n\n  if( plrStartOffset(pLeft)<plrStartOffset(pRight) ) return -1;\n  if( plrStartOffset(pLeft)>plrStartOffset(pRight) ) return 1;\n\n  if( plrEndOffset(pLeft)<plrEndOffset(pRight) ) return -1;\n  if( plrEndOffset(pLeft)>plrEndOffset(pRight) ) return 1;\n\n  return 0;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Implementation of the scalar function fts3_tokenizer_internal_test().\n** This function is used for testing only, it is not included in the\n** build unless SQLITE_TEST is defined.\n**\n** The purpose of this is to test that the fts3_tokenizer() function\n** can be used as designed by the C-code in the queryTokenizer and\n** registerTokenizer() functions above. These two functions are repeated\n** in the README.tokenizer file as an example, so it is important to\n** test them.\n**\n** To run the tests, evaluate the fts3_tokenizer_internal_test() scalar\n** function with no arguments. An assert() will fail if a problem is\n** detected. i.e.:\n**\n**     SELECT fts3_tokenizer_internal_test();\n**\n*/\n", "func_signal": "static void intTestFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  int rc;\n  const sqlite3_tokenizer_module *p1;\n  const sqlite3_tokenizer_module *p2;\n  sqlite3 *db = (sqlite3 *)sqlite3_user_data(context);\n\n  /* Test the query function */\n  sqlite3Fts3SimpleTokenizerModule(&p1);\n  rc = queryTokenizer(db, \"simple\", &p2);\n  assert( rc==SQLITE_OK );\n  assert( p1==p2 );\n  rc = queryTokenizer(db, \"nosuchtokenizer\", &p2);\n  assert( rc==SQLITE_ERROR );\n  assert( p2==0 );\n  assert( 0==strcmp(sqlite3_errmsg(db), \"unknown tokenizer: nosuchtokenizer\") );\n\n  /* Test the storage function */\n  rc = registerTokenizer(db, \"nosuchtokenizer\", p1);\n  assert( rc==SQLITE_OK );\n  rc = queryTokenizer(db, \"nosuchtokenizer\", &p2);\n  assert( rc==SQLITE_OK );\n  assert( p2==p1 );\n\n  sqlite3_result_text(context, \"ok\", -1, SQLITE_STATIC);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Remove the memory data structures associated with the given\n** Table.  No changes are made to disk by this routine.\n**\n** This routine just deletes the data structure.  It does not unlink\n** the table data structure from the hash table.  But it does destroy\n** memory structures of the indices and foreign keys associated with \n** the table.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3DeleteTable(Table *pTable)", "code": "{\n  Index *pIndex, *pNext;\n  FKey *pFKey, *pNextFKey;\n  sqlite3 *db;\n\n  if( pTable==0 ) return;\n  db = pTable->dbMem;\n  testcase( db==0 );\n\n  /* Do not delete the table until the reference count reaches zero. */\n  pTable->nRef--;\n  if( pTable->nRef>0 ){\n    return;\n  }\n  assert( pTable->nRef==0 );\n\n  /* Delete all indices associated with this table\n  */\n  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){\n    pNext = pIndex->pNext;\n    assert( pIndex->pSchema==pTable->pSchema );\n    sqlite3DeleteIndex(pIndex);\n  }\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  /* Delete all foreign keys associated with this table. */\n  for(pFKey=pTable->pFKey; pFKey; pFKey=pNextFKey){\n    pNextFKey = pFKey->pNextFrom;\n    sqlite3DbFree(db, pFKey);\n  }\n#endif\n\n  /* Delete the Table structure itself.\n  */\n  sqliteResetColumnNames(pTable);\n  sqlite3DbFree(db, pTable->zName);\n  sqlite3DbFree(db, pTable->zColAff);\n  sqlite3SelectDelete(db, pTable->pSelect);\n#ifndef SQLITE_OMIT_CHECK\n  sqlite3ExprDelete(db, pTable->pCheck);\n#endif\n  sqlite3VtabClear(pTable);\n  sqlite3DbFree(db, pTable);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Free any overflow pages associated with the given Cell.\n*/\n", "func_signal": "static int clearCell(MemPage *pPage, unsigned char *pCell)", "code": "{\n  BtShared *pBt = pPage->pBt;\n  CellInfo info;\n  Pgno ovflPgno;\n  int rc;\n  int nOvfl;\n  u16 ovflPageSize;\n\n  assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n  sqlite3BtreeParseCellPtr(pPage, pCell, &info);\n  if( info.iOverflow==0 ){\n    return SQLITE_OK;  /* No overflow pages. Return without doing anything */\n  }\n  ovflPgno = get4byte(&pCell[info.iOverflow]);\n  assert( pBt->usableSize > 4 );\n  ovflPageSize = pBt->usableSize - 4;\n  nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize;\n  assert( ovflPgno==0 || nOvfl>0 );\n  while( nOvfl-- ){\n    Pgno iNext = 0;\n    MemPage *pOvfl = 0;\n    if( ovflPgno<2 || ovflPgno>pagerPagecount(pBt) ){\n      /* 0 is not a legal page number and page 1 cannot be an \n      ** overflow page. Therefore if ovflPgno<2 or past the end of the \n      ** file the database must be corrupt. */\n      return SQLITE_CORRUPT_BKPT;\n    }\n    if( nOvfl ){\n      rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);\n      if( rc ) return rc;\n    }\n    rc = freePage2(pBt, pOvfl, ovflPgno);\n    if( pOvfl ){\n      sqlite3PagerUnref(pOvfl->pDbPage);\n    }\n    if( rc ) return rc;\n    ovflPgno = iNext;\n  }\n  return SQLITE_OK;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/*\n** Return a pointer to the Pager.nExtra bytes of \"extra\" space \n** allocated along with the specified page.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg)", "code": "{\n  Pager *pPager = pPg->pPager;\n  return (pPager?pPg->pExtra:0);\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* Move the cursor to the first entry in the table.  Return SQLITE_OK\n** on success.  Set *pRes to 0 if the cursor actually points to something\n** or set *pRes to 1 if the table is empty.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes)", "code": "{\n  int rc;\n\n  assert( cursorHoldsMutex(pCur) );\n  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );\n  rc = moveToRoot(pCur);\n  if( rc==SQLITE_OK ){\n    if( pCur->eState==CURSOR_INVALID ){\n      assert( pCur->apPage[pCur->iPage]->nCell==0 );\n      *pRes = 1;\n      rc = SQLITE_OK;\n    }else{\n      assert( pCur->apPage[pCur->iPage]->nCell>0 );\n      *pRes = 0;\n      rc = moveToLeftmost(pCur);\n    }\n  }\n  return rc;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* get the host ID from a sqlite hostid file stored in the \n** user-specific tmp directory, create the ID if it's not there already \n*/\n", "func_signal": "static int proxyGetHostID(char *pHostID, int *pError)", "code": "{\n  int fd;\n  char path[MAXPATHLEN]; \n  size_t len;\n  int rc=SQLITE_OK;\n\n  proxyGetHostIDPath(path, MAXPATHLEN);\n  /* try to create the host ID file, if it already exists read the contents */\n  fd = open(path, O_CREAT|O_WRONLY|O_EXCL, 0644);\n  if( fd<0 ){\n    int err=errno;\n\t\t\n    if( err!=EEXIST ){\n#ifdef SQLITE_PROXY_DEBUG /* set the sqlite error message instead */\n      fprintf(stderr, \"sqlite error creating host ID file %s: %s\\n\",\n              path, strerror(err));\n#endif\n      return SQLITE_PERM;\n    }\n    /* couldn't create the file, read it instead */\n    fd = open(path, O_RDONLY|O_EXCL);\n    if( fd<0 ){\n#ifdef SQLITE_PROXY_DEBUG /* set the sqlite error message instead */\n      int err = errno;\n      fprintf(stderr, \"sqlite error opening host ID file %s: %s\\n\",\n              path, strerror(err));\n#endif\n      return SQLITE_PERM;\n    }\n    len = pread(fd, pHostID, HOSTIDLEN, 0);\n    if( len<0 ){\n      *pError = errno;\n      rc = SQLITE_IOERR_READ;\n    }else if( len<HOSTIDLEN ){\n      *pError = 0;\n      rc = SQLITE_IOERR_SHORT_READ;\n    }\n    close(fd); /* silently leak the fd if it fails */\n    OSTRACE3(\"GETHOSTID  read %s pid=%d\\n\", pHostID, getpid());\n    return rc;\n  }else{\n    /* we're creating the host ID file (use a random string of bytes) */\n    proxyGenerateHostID(pHostID);\n    len = pwrite(fd, pHostID, HOSTIDLEN, 0);\n    if( len<0 ){\n      *pError = errno;\n      rc = SQLITE_IOERR_WRITE;\n    }else if( len<HOSTIDLEN ){\n      *pError = 0;\n      rc = SQLITE_IOERR_WRITE;\n    }\n    close(fd); /* silently leak the fd if it fails */\n    OSTRACE3(\"GETHOSTID  wrote %s pid=%d\\n\", pHostID, getpid());\n    return rc;\n  }\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/* SQLITE_OMIT_UTF16 */\n", "func_signal": "SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i)", "code": "{\n  int iType = sqlite3_value_type( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return iType;\n}", "path": "sqlite3\\sqlite3.c", "repo_name": "ninetydegreesnorth/eMAILsearch", "stars": 4, "license": "None", "language": "c", "size": 4124}
{"docstring": "/** Add a new semantic action that will execute the action for rule\n *  RULENUM on the semantic values in RHS to the list of\n *  alternative actions for STATE.  Assumes that RHS comes from\n *  stack #K of *STACKP. */\n", "func_signal": "static void\nyyaddDeferredAction (yyGLRStack* yystackp, size_t yyk, yyGLRState* yystate,\n\t\t     yyGLRState* rhs, yyRuleNum yyrule)", "code": "{\n  yySemanticOption* yynewOption =\n    &yynewGLRStackItem (yystackp, yyfalse)->yyoption;\n  yynewOption->yystate = rhs;\n  yynewOption->yyrule = yyrule;\n  if (yystackp->yytops.yylookaheadNeeds[yyk])\n    {\n      yynewOption->yyrawchar = yychar;\n      yynewOption->yyval = yylval;\n      yynewOption->yyloc = yylloc;\n    }\n  else\n    yynewOption->yyrawchar = YYEMPTY;\n  yynewOption->yynext = yystate->yysemantics.yyfirstVal;\n  yystate->yysemantics.yyfirstVal = yynewOption;\n\n  YY_RESERVE_GLRSTACK (yystackp);\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static size_t\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      size_t yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return strlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* next -- get the next character, excluding comments. peek() is used to see\n        if a '/' is followed by a '/' or '*'.\n*/\n", "func_signal": "static int\nnext()", "code": "{\n    int c = get();\n    if  (c == '/') {\n        switch (peek()) {\n        case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n        case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                case EOF:\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n        default:\n            return c;\n        }\n    }\n    return c;\n}", "path": "ports\\devel\\jsmin\\jsmin.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Y0 and Y1 represent two possible actions to take in a given\n *  parsing state; return 0 if no combination is possible,\n *  1 if user-mergeable, 2 if Y0 is preferred, 3 if Y1 is preferred.  */\n", "func_signal": "static int\nyypreference (yySemanticOption* y0, yySemanticOption* y1)", "code": "{\n  yyRuleNum r0 = y0->yyrule, r1 = y1->yyrule;\n  int p0 = yydprec[r0], p1 = yydprec[r1];\n\n  if (p0 == p1)\n    {\n      if (yymerger[r0] == 0 || yymerger[r0] != yymerger[r1])\n\treturn 0;\n      else\n\treturn 1;\n    }\n  if (p0 == 0 || p1 == 0)\n    return 0;\n  if (p0 < p1)\n    return 3;\n  if (p1 < p0)\n    return 2;\n  return 0;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Initialize SET to a singleton set containing an empty stack.  */\n", "func_signal": "static yybool\nyyinitStateSet (yyGLRStateSet* yyset)", "code": "{\n  yyset->yysize = 1;\n  yyset->yycapacity = 16;\n  yyset->yystates = (yyGLRState**) YYMALLOC (16 * sizeof yyset->yystates[0]);\n  if (! yyset->yystates)\n    return yyfalse;\n  yyset->yystates[0] = NULL;\n  yyset->yylookaheadNeeds =\n    (yybool*) YYMALLOC (16 * sizeof yyset->yylookaheadNeeds[0]);\n  if (! yyset->yylookaheadNeeds)\n    {\n      YYFREE (yyset->yystates);\n      return yyfalse;\n    }\n  return yytrue;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Assuming that S is a GLRState somewhere on STACK, update the\n *  splitpoint of STACK, if needed, so that it is at least as deep as\n *  S.  */\n", "func_signal": "static inline void\nyyupdateSplit (yyGLRStack* yystackp, yyGLRState* yys)", "code": "{\n  if (yystackp->yysplitPoint != NULL && yystackp->yysplitPoint > yys)\n    yystackp->yysplitPoint = yys;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** True iff Y0 and Y1 represent identical options at the top level.\n *  That is, they represent the same rule applied to RHS symbols\n *  that produce the same terminal symbols.  */\n", "func_signal": "static yybool\nyyidenticalOptions (yySemanticOption* yyy0, yySemanticOption* yyy1)", "code": "{\n  if (yyy0->yyrule == yyy1->yyrule)\n    {\n      yyGLRState *yys0, *yys1;\n      int yyn;\n      for (yys0 = yyy0->yystate, yys1 = yyy1->yystate,\n\t   yyn = yyrhsLength (yyy0->yyrule);\n\t   yyn > 0;\n\t   yys0 = yys0->yypred, yys1 = yys1->yypred, yyn -= 1)\n\tif (yys0->yyposn != yys1->yyposn)\n\t  return yyfalse;\n      return yytrue;\n    }\n  else\n    return yyfalse;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* main -- Output any command line arguments as comments\n        and then minify the input.\n*/\n", "func_signal": "extern int\nmain(int argc, char* argv[])", "code": "{\n    int i;\n    for (i = 1; i < argc; i += 1) {\n        fprintf(stdout, \"// %s\\n\", argv[i]);\n    }\n    jsmin();\n    return 0;\n}", "path": "ports\\devel\\jsmin\\jsmin.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* action -- do something! What you do is determined by the argument:\n        1   Output A. Copy B to A. Get the next B.\n        2   Copy B to A. Get the next B. (Delete A).\n        3   Get the next B. (Delete B).\n   action treats a string as a single character. Wow!\n   action recognizes a regular expression if it is preceded by ( or , or =.\n*/\n", "func_signal": "static void\naction(int d)", "code": "{\n    switch (d) {\n    case 1:\n        putc(theA, stdout);\n    case 2:\n        theA = theB;\n        if (theA == '\\'' || theA == '\"') {\n            for (;;) {\n                putc(theA, stdout);\n                theA = get();\n                if (theA == theB) {\n                    break;\n                }\n                if (theA <= '\\n') {\n                    fprintf(stderr,\n\"Error: JSMIN unterminated string literal: %c\\n\", theA);\n                    exit(1);\n                }\n                if (theA == '\\\\') {\n                    putc(theA, stdout);\n                    theA = get();\n                    if (theA <= '\\n') {\n                        fprintf(stderr,\n    \"Error: JSMIN unterminated string literal: %c\\n\", '\\\\');\n                        exit(1);\n                    }\n                }\n            }\n        }\n    case 3:\n        theB = next();\n        if (theB == '/' && (theA == '(' || theA == ',' || theA == '=' ||\n                            theA == ':' || theA == '[' || theA == '!' || \n                            theA == '&' || theA == '|' || theA == '?' || \n                            theA == '{' || theA == '}' || theA == ';' || \n                            theA == '\\n')) {\n            putc(theA, stdout);\n            putc(theB, stdout);\n            for (;;) {\n                theA = get();\n                if (theA == '/') {\n                    break;\n                } else if (theA =='\\\\') {\n                    putc(theA, stdout);\n                    theA = get();\n                } else if (theA <= '\\n') {\n                    fprintf(stderr,\n\"Error: JSMIN unterminated Regular Expression literal.\\n\", theA);\n                    exit(1);\n                }\n                putc(theA, stdout);\n            }\n            theB = next();\n        }\n    }\n}", "path": "ports\\devel\\jsmin\\jsmin.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Resolve the ambiguity represented in state S, perform the indicated\n *  actions, and set the semantic value of S.  If result != yyok, the chain of\n *  semantic options in S has been cleared instead or it has been left\n *  unmodified except that redundant options may have been removed.  Regardless\n *  of whether result = yyok, S has been left with consistent data so that\n *  yydestroyGLRState can be invoked if necessary.  */\n", "func_signal": "static YYRESULTTAG\nyyresolveValue (yyGLRState* yys, yyGLRStack* yystackp]b4_user_formals[)", "code": "{\n  yySemanticOption* yyoptionList = yys->yysemantics.yyfirstVal;\n  yySemanticOption* yybest;\n  yySemanticOption** yypp;\n  yybool yymerge;\n  YYSTYPE yysval;\n  YYRESULTTAG yyflag;\n  YYLTYPE *yylocp = &yys->yyloc;\n\n  yybest = yyoptionList;\n  yymerge = yyfalse;\n  for (yypp = &yyoptionList->yynext; *yypp != NULL; )\n    {\n      yySemanticOption* yyp = *yypp;\n\n      if (yyidenticalOptions (yybest, yyp))\n\t{\n\t  yymergeOptionSets (yybest, yyp);\n\t  *yypp = yyp->yynext;\n\t}\n      else\n\t{\n\t  switch (yypreference (yybest, yyp))\n\t    {\n\t    case 0:\n\t      yyresolveLocations (yys, 1, yystackp]b4_user_args[);\n\t      return yyreportAmbiguity (yybest, yyp]b4_pure_args[);\n\t      break;\n\t    case 1:\n\t      yymerge = yytrue;\n\t      break;\n\t    case 2:\n\t      break;\n\t    case 3:\n\t      yybest = yyp;\n\t      yymerge = yyfalse;\n\t      break;\n\t    default:\n\t      /* This cannot happen so it is not worth a YYASSERT (yyfalse),\n\t\t but some compilers complain if the default case is\n\t\t omitted.  */\n\t      break;\n\t    }\n\t  yypp = &yyp->yynext;\n\t}\n    }\n\n  if (yymerge)\n    {\n      yySemanticOption* yyp;\n      int yyprec = yydprec[yybest->yyrule];\n      yyflag = yyresolveAction (yybest, yystackp, &yysval,\n\t\t\t\tyylocp]b4_user_args[);\n      if (yyflag == yyok)\n\tfor (yyp = yybest->yynext; yyp != NULL; yyp = yyp->yynext)\n\t  {\n\t    if (yyprec == yydprec[yyp->yyrule])\n\t      {\n\t\tYYSTYPE yysval_other;\n\t\tYYLTYPE yydummy;\n\t\tyyflag = yyresolveAction (yyp, yystackp, &yysval_other,\n\t\t\t\t\t  &yydummy]b4_user_args[);\n\t\tif (yyflag != yyok)\n\t\t  {\n\t\t    yydestruct (\"Cleanup: discarding incompletely merged value for\",\n\t\t\t\tyystos[yys->yylrState],\n\t\t\t\t&yysval]b4_locations_if([, yylocp])[]b4_user_args[);\n\t\t    break;\n\t\t  }\n\t\tyyuserMerge (yymerger[yyp->yyrule], &yysval, &yysval_other);\n\t      }\n\t  }\n    }\n  else\n    yyflag = yyresolveAction (yybest, yystackp, &yysval, yylocp]b4_user_args[);\n\n  if (yyflag == yyok)\n    {\n      yys->yyresolved = yytrue;\n      yys->yysemantics.yysval = yysval;\n    }\n  else\n    yys->yysemantics.yyfirstVal = NULL;\n  return yyflag;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Pop items off stack #K of STACK according to grammar rule RULE,\n *  and push back on the resulting nonterminal symbol.  Perform the\n *  semantic action associated with RULE and store its value with the\n *  newly pushed state, if FORCEEVAL or if STACK is currently\n *  unambiguous.  Otherwise, store the deferred semantic action with\n *  the new state.  If the new state would have an identical input\n *  position, LR state, and predecessor to an existing state on the stack,\n *  it is identified with that existing state, eliminating stack #K from\n *  the STACK.  In this case, the (necessarily deferred) semantic value is\n *  added to the options for the existing state's semantic value.\n */\n", "func_signal": "static inline YYRESULTTAG\nyyglrReduce (yyGLRStack* yystackp, size_t yyk, yyRuleNum yyrule,\n\t     yybool yyforceEval]b4_user_formals[)", "code": "{\n  size_t yyposn = yystackp->yytops.yystates[yyk]->yyposn;\n\n  if (yyforceEval || yystackp->yysplitPoint == NULL)\n    {\n      YYSTYPE yysval;\n      YYLTYPE yyloc;\n\n      YY_REDUCE_PRINT ((yystackp, yyk, yyrule, &yysval, &yyloc]b4_user_args[));\n      YYCHK (yydoAction (yystackp, yyk, yyrule, &yysval,\n\t\t\t &yyloc]b4_user_args[));\n      YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyrule], &yysval, &yyloc);\n      yyglrShift (yystackp, yyk,\n\t\t  yyLRgotoState (yystackp->yytops.yystates[yyk]->yylrState,\n\t\t\t\t yylhsNonterm (yyrule)),\n\t\t  yyposn, &yysval, &yyloc);\n    }\n  else\n    {\n      size_t yyi;\n      int yyn;\n      yyGLRState* yys, *yys0 = yystackp->yytops.yystates[yyk];\n      yyStateNum yynewLRState;\n\n      for (yys = yystackp->yytops.yystates[yyk], yyn = yyrhsLength (yyrule);\n\t   0 < yyn; yyn -= 1)\n\t{\n\t  yys = yys->yypred;\n\t  YYASSERT (yys);\n\t}\n      yyupdateSplit (yystackp, yys);\n      yynewLRState = yyLRgotoState (yys->yylrState, yylhsNonterm (yyrule));\n      YYDPRINTF ((stderr,\n\t\t  \"Reduced stack %lu by rule #%d; action deferred.  Now in state %d.\\n\",\n\t\t  (unsigned long int) yyk, yyrule - 1, yynewLRState));\n      for (yyi = 0; yyi < yystackp->yytops.yysize; yyi += 1)\n\tif (yyi != yyk && yystackp->yytops.yystates[yyi] != NULL)\n\t  {\n\t    yyGLRState* yyp, *yysplit = yystackp->yysplitPoint;\n\t    yyp = yystackp->yytops.yystates[yyi];\n\t    while (yyp != yys && yyp != yysplit && yyp->yyposn >= yyposn)\n\t      {\n\t\tif (yyp->yylrState == yynewLRState && yyp->yypred == yys)\n\t\t  {\n\t\t    yyaddDeferredAction (yystackp, yyk, yyp, yys0, yyrule);\n\t\t    yymarkStackDeleted (yystackp, yyk);\n\t\t    YYDPRINTF ((stderr, \"Merging stack %lu into stack %lu.\\n\",\n\t\t\t\t(unsigned long int) yyk,\n\t\t\t\t(unsigned long int) yyi));\n\t\t    return yyok;\n\t\t  }\n\t\tyyp = yyp->yypred;\n\t      }\n\t  }\n      yystackp->yytops.yystates[yyk] = yys;\n      yyglrShiftDefer (yystackp, yyk, yynewLRState, yyposn, yys0, yyrule);\n    }\n  return yyok;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Pop the symbols consumed by reduction #RULE from the top of stack\n *  #K of STACK, and perform the appropriate semantic action on their\n *  semantic values.  Assumes that all ambiguities in semantic values\n *  have been previously resolved.  Set *VALP to the resulting value,\n *  and *LOCP to the computed location (if any).  Return value is as\n *  for userAction.  */\n", "func_signal": "static inline YYRESULTTAG\nyydoAction (yyGLRStack* yystackp, size_t yyk, yyRuleNum yyrule,\n\t    YYSTYPE* yyvalp, YYLTYPE* yylocp]b4_user_formals[)", "code": "{\n  int yynrhs = yyrhsLength (yyrule);\n\n  if (yystackp->yysplitPoint == NULL)\n    {\n      /* Standard special case: single stack.  */\n      yyGLRStackItem* rhs = (yyGLRStackItem*) yystackp->yytops.yystates[yyk];\n      YYASSERT (yyk == 0);\n      yystackp->yynextFree -= yynrhs;\n      yystackp->yyspaceLeft += yynrhs;\n      yystackp->yytops.yystates[0] = & yystackp->yynextFree[-1].yystate;\n      return yyuserAction (yyrule, yynrhs, rhs,\n\t\t\t   yyvalp, yylocp, yystackp]b4_user_args[);\n    }\n  else\n    {\n      /* At present, doAction is never called in nondeterministic\n       * mode, so this branch is never taken.  It is here in\n       * anticipation of a future feature that will allow immediate\n       * evaluation of selected actions in nondeterministic mode.  */\n      int yyi;\n      yyGLRState* yys;\n      yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];\n      yys = yyrhsVals[YYMAXRHS + YYMAXLEFT].yystate.yypred\n\t= yystackp->yytops.yystates[yyk];]b4_locations_if([[\n      if (yynrhs == 0)\n\t/* Set default location.  */\n\tyyrhsVals[YYMAXRHS + YYMAXLEFT - 1].yystate.yyloc = yys->yyloc;]])[\n      for (yyi = 0; yyi < yynrhs; yyi += 1)\n\t{\n\t  yys = yys->yypred;\n\t  YYASSERT (yys);\n\t}\n      yyupdateSplit (yystackp, yys);\n      yystackp->yytops.yystates[yyk] = yys;\n      return yyuserAction (yyrule, yynrhs, yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,\n\t\t\t   yyvalp, yylocp, yystackp]b4_user_args[);\n    }\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* jsmin -- Copy the input to the output, deleting the characters which are\n        insignificant to JavaScript. Comments will be removed. Tabs will be\n        replaced with spaces. Carriage returns will be replaced with linefeeds.\n        Most spaces and linefeeds will be removed.\n*/\n", "func_signal": "static void\njsmin()", "code": "{\n    theA = '\\n';\n    action(3);\n    while (theA != EOF) {\n        switch (theA) {\n        case ' ':\n            if (isAlphanum(theB)) {\n                action(1);\n            } else {\n                action(2);\n            }\n            break;\n        case '\\n':\n            switch (theB) {\n            case '{':\n            case '[':\n            case '(':\n            case '+':\n            case '-':\n                action(1);\n                break;\n            case ' ':\n                action(3);\n                break;\n            default:\n                if (isAlphanum(theB)) {\n                    action(1);\n                } else {\n                    action(2);\n                }\n            }\n            break;\n        default:\n            switch (theB) {\n            case ' ':\n                if (isAlphanum(theA)) {\n                    action(1);\n                    break;\n                }\n                action(3);\n                break;\n            case '\\n':\n                switch (theA) {\n                case '}':\n                case ']':\n                case ')':\n                case '+':\n                case '-':\n                case '\"':\n                case '\\'':\n                    action(1);\n                    break;\n                default:\n                    if (isAlphanum(theA)) {\n                        action(1);\n                    } else {\n                        action(3);\n                    }\n                }\n                break;\n            default:\n                action(1);\n                break;\n            }\n        }\n    }\n}", "path": "ports\\devel\\jsmin\\jsmin.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/* peek -- get the next character without getting it.\n*/\n", "func_signal": "static int\npeek()", "code": "{\n    theLookahead = get();\n    return theLookahead;\n}", "path": "ports\\devel\\jsmin\\jsmin.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Undelete the last stack that was marked as deleted.  Can only be\n    done once after a deletion, and only when all other stacks have\n    been deleted.  */\n", "func_signal": "static void\nyyundeleteLastStack (yyGLRStack* yystackp)", "code": "{\n  if (yystackp->yylastDeleted == NULL || yystackp->yytops.yysize != 0)\n    return;\n  yystackp->yytops.yystates[0] = yystackp->yylastDeleted;\n  yystackp->yytops.yysize = 1;\n  YYDPRINTF ((stderr, \"Restoring last deleted stack as stack #0.\\n\"));\n  yystackp->yylastDeleted = NULL;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Shift to a new state on stack #K of STACK, corresponding to LR state\n * LRSTATE, at input position POSN, with (resolved) semantic value SVAL.  */\n", "func_signal": "static inline void\nyyglrShift (yyGLRStack* yystackp, size_t yyk, yyStateNum yylrState,\n\t    size_t yyposn,\n\t    YYSTYPE* yyvalp, YYLTYPE* yylocp)", "code": "{\n  yyGLRState* yynewState = &yynewGLRStackItem (yystackp, yytrue)->yystate;\n\n  yynewState->yylrState = yylrState;\n  yynewState->yyposn = yyposn;\n  yynewState->yyresolved = yytrue;\n  yynewState->yypred = yystackp->yytops.yystates[yyk];\n  yynewState->yysemantics.yysval = *yyvalp;\n  yynewState->yyloc = *yylocp;\n  yystackp->yytops.yystates[yyk] = yynewState;\n\n  YY_RESERVE_GLRSTACK (yystackp);\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Resolve the previous N states starting at and including state S.  If result\n *  != yyok, some states may have been left unresolved possibly with empty\n *  semantic option chains.  Regardless of whether result = yyok, each state\n *  has been left with consistent data so that yydestroyGLRState can be invoked\n *  if necessary.  */\n", "func_signal": "static YYRESULTTAG\nyyresolveStates (yyGLRState* yys, int yyn,\n\t\t yyGLRStack* yystackp]b4_user_formals[)", "code": "{\n  if (0 < yyn)\n    {\n      YYASSERT (yys->yypred);\n      YYCHK (yyresolveStates (yys->yypred, yyn-1, yystackp]b4_user_args[));\n      if (! yys->yyresolved)\n\tYYCHK (yyresolveValue (yys, yystackp]b4_user_args[));\n    }\n  return yyok;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Starting at and including state S1, resolve the location for each of the\n *  previous N1 states that is unresolved.  The first semantic option of a state\n *  is always chosen.  */\n", "func_signal": "static void\nyyresolveLocations (yyGLRState* yys1, int yyn1,\n\t\t    yyGLRStack *yystackp]b4_user_formals[)", "code": "{\n  if (0 < yyn1)\n    {\n      yyresolveLocations (yys1->yypred, yyn1 - 1, yystackp]b4_user_args[);\n      if (!yys1->yyresolved)\n\t{\n\t  yySemanticOption *yyoption;\n\t  yyGLRStackItem yyrhsloc[1 + YYMAXRHS];\n\t  int yynrhs;\n\t  int yychar_current;\n\t  YYSTYPE yylval_current;\n\t  YYLTYPE yylloc_current;\n\t  yyoption = yys1->yysemantics.yyfirstVal;\n\t  YYASSERT (yyoption != NULL);\n\t  yynrhs = yyrhsLength (yyoption->yyrule);\n\t  if (yynrhs > 0)\n\t    {\n\t      yyGLRState *yys;\n\t      int yyn;\n\t      yyresolveLocations (yyoption->yystate, yynrhs,\n\t\t\t\t  yystackp]b4_user_args[);\n\t      for (yys = yyoption->yystate, yyn = yynrhs;\n\t\t   yyn > 0;\n\t\t   yys = yys->yypred, yyn -= 1)\n\t\tyyrhsloc[yyn].yystate.yyloc = yys->yyloc;\n\t    }\n\t  else\n\t    {\n\t      /* Both yyresolveAction and yyresolveLocations traverse the GSS\n\t\t in reverse rightmost order.  It is only necessary to invoke\n\t\t yyresolveLocations on a subforest for which yyresolveAction\n\t\t would have been invoked next had an ambiguity not been\n\t\t detected.  Thus the location of the previous state (but not\n\t\t necessarily the previous state itself) is guaranteed to be\n\t\t resolved already.  */\n\t      yyGLRState *yyprevious = yyoption->yystate;\n\t      yyrhsloc[0].yystate.yyloc = yyprevious->yyloc;\n\t    }\n\t  yychar_current = yychar;\n\t  yylval_current = yylval;\n\t  yylloc_current = yylloc;\n\t  yychar = yyoption->yyrawchar;\n\t  yylval = yyoption->yyval;\n\t  yylloc = yyoption->yyloc;\n\t  YYLLOC_DEFAULT ((yys1->yyloc), yyrhsloc, yynrhs);\n\t  yychar = yychar_current;\n\t  yylval = yylval_current;\n\t  yylloc = yylloc_current;\n\t}\n    }\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Invalidate stack #K in STACK.  */\n", "func_signal": "static inline void\nyymarkStackDeleted (yyGLRStack* yystackp, size_t yyk)", "code": "{\n  if (yystackp->yytops.yystates[yyk] != NULL)\n    yystackp->yylastDeleted = yystackp->yytops.yystates[yyk];\n  yystackp->yytops.yystates[yyk] = NULL;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/** Resolve the states for the RHS of OPT, perform its user action, and return\n *  the semantic value and location.  Regardless of whether result = yyok, all\n *  RHS states have been destroyed (assuming the user action destroys all RHS\n *  semantic values if invoked).  */\n", "func_signal": "static YYRESULTTAG\nyyresolveAction (yySemanticOption* yyopt, yyGLRStack* yystackp,\n\t\t YYSTYPE* yyvalp, YYLTYPE* yylocp]b4_user_formals[)", "code": "{\n  yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];\n  int yynrhs;\n  int yychar_current;\n  YYSTYPE yylval_current;\n  YYLTYPE yylloc_current;\n  YYRESULTTAG yyflag;\n\n  yynrhs = yyrhsLength (yyopt->yyrule);\n  yyflag = yyresolveStates (yyopt->yystate, yynrhs, yystackp]b4_user_args[);\n  if (yyflag != yyok)\n    {\n      yyGLRState *yys;\n      for (yys = yyopt->yystate; yynrhs > 0; yys = yys->yypred, yynrhs -= 1)\n\tyydestroyGLRState (\"Cleanup: popping\", yys]b4_user_args[);\n      return yyflag;\n    }\n\n  yyrhsVals[YYMAXRHS + YYMAXLEFT].yystate.yypred = yyopt->yystate;]b4_locations_if([[\n  if (yynrhs == 0)\n    /* Set default location.  */\n    yyrhsVals[YYMAXRHS + YYMAXLEFT - 1].yystate.yyloc = yyopt->yystate->yyloc;]])[\n  yychar_current = yychar;\n  yylval_current = yylval;\n  yylloc_current = yylloc;\n  yychar = yyopt->yyrawchar;\n  yylval = yyopt->yyval;\n  yylloc = yyopt->yyloc;\n  yyflag = yyuserAction (yyopt->yyrule, yynrhs,\n\t\t\t   yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,\n\t\t\t   yyvalp, yylocp, yystackp]b4_user_args[);\n  yychar = yychar_current;\n  yylval = yylval_current;\n  yylloc = yylloc_current;\n  return yyflag;\n}", "path": "ports\\WinTools\\share\\bison\\glr.c", "repo_name": "lloyd/bakery", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 3810}
{"docstring": "/*\n - regc - emit (if appropriate) a byte of code\n */\n", "func_signal": "static void\nregc(char b)", "code": "{\n\tif (regcode != &regdummy)\n\t\t*regcode++ = b;\n\telse\n\t\tregsize++;\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* Dummy F0 modelling for phones, copied directly from us_f0_model.c */\n", "func_signal": "cst_utterance *flat_prosody(cst_utterance *u)", "code": "{\n    /* F0 target model */\n    cst_item *s,*t;\n    cst_relation *targ_rel;\n    float mean, stddev;\n\n    targ_rel = utt_relation_create(u,\"Target\");\n    mean = get_param_float(u->features,\"target_f0_mean\", 100.0);\n    mean *= get_param_float(u->features,\"f0_shift\", 1.0);\n    stddev = get_param_float(u->features,\"target_f0_stddev\", 12.0);\n\n    s=relation_head(utt_relation(u,\"Segment\"));\n    t = relation_append(targ_rel,NULL);\n    item_set_float(t,\"pos\",0.0);\n    item_set_float(t,\"f0\",mean+stddev);\n\n    s=relation_tail(utt_relation(u,\"Segment\"));\n    t = relation_append(targ_rel,NULL);\n\n    item_set_float(t,\"pos\",item_feat_float(s,\"end\"));\n    item_set_float(t,\"f0\",mean-stddev);\n\n    return u;\n}", "path": "flite-1.4-iphone\\src\\cst_synth.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regprop - printable representation of opcode\n */\n", "func_signal": "static char *\nregprop(char *op)", "code": "{\n\tchar *p=NULL;\n\tstatic char buf[50];\n\n\t(void) strcpy(buf, \":\");\n\n\tswitch (OP(op)) {\n\tcase BOL:\n\t\tp = \"BOL\";\n\t\tbreak;\n\tcase EOL:\n\t\tp = \"EOL\";\n\t\tbreak;\n\tcase ANY:\n\t\tp = \"ANY\";\n\t\tbreak;\n\tcase ANYOF:\n\t\tp = \"ANYOF\";\n\t\tbreak;\n\tcase ANYBUT:\n\t\tp = \"ANYBUT\";\n\t\tbreak;\n\tcase BRANCH:\n\t\tp = \"BRANCH\";\n\t\tbreak;\n\tcase EXACTLY:\n\t\tp = \"EXACTLY\";\n\t\tbreak;\n\tcase NOTHING:\n\t\tp = \"NOTHING\";\n\t\tbreak;\n\tcase BACK:\n\t\tp = \"BACK\";\n\t\tbreak;\n\tcase END:\n\t\tp = \"END\";\n\t\tbreak;\n\tcase OPEN+1:\n\tcase OPEN+2:\n\tcase OPEN+3:\n\tcase OPEN+4:\n\tcase OPEN+5:\n\tcase OPEN+6:\n\tcase OPEN+7:\n\tcase OPEN+8:\n\tcase OPEN+9:\n\t    cst_sprintf(buf+cst_strlen(buf), \"OPEN%d\", OP(op)-OPEN);\n\t\tp = NULL;\n\t\tbreak;\n\tcase CLOSE+1:\n\tcase CLOSE+2:\n\tcase CLOSE+3:\n\tcase CLOSE+4:\n\tcase CLOSE+5:\n\tcase CLOSE+6:\n\tcase CLOSE+7:\n\tcase CLOSE+8:\n\tcase CLOSE+9:\n\t    cst_sprintf(buf+cst_strlen(buf), \"CLOSE%d\", OP(op)-CLOSE);\n\t\tp = NULL;\n\t\tbreak;\n\tcase STAR:\n\t\tp = \"STAR\";\n\t\tbreak;\n\tcase PLUS:\n\t\tp = \"PLUS\";\n\t\tbreak;\n\tcase WORDA:\n\t\tp = \"WORDA\";\n\t\tbreak;\n\tcase WORDZ:\n\t\tp = \"WORDZ\";\n\t\tbreak;\n\tdefault:\n\t\tFAIL(\"corrupted opcode\");\n\t\tbreak;\n\t}\n\tif (p != NULL)\n\t\t(void) strcat(buf, p);\n\treturn(buf);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "// generate parameter sequence from pdf sequence using Choleski decomposition\n", "func_signal": "static void mlpgChol(PStreamChol *pst)", "code": "{\n   register int m;\n\n   // generating parameter in each dimension\n   for (m = 0; m <= pst->order; m++) {\n       calc_R_and_r(pst, m);\n       Choleski(pst);\n       Choleski_forward(pst);\n       Choleski_backward(pst, m);\n   }\n   \n   return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regrepeat - repeatedly match something simple, report how many\n */\n", "func_signal": "static int\nregrepeat(cst_regstate *state, char *p)", "code": "{\n\tint count = 0;\n\tconst char *scan;\n\tchar *opnd;\n\n\tscan = state->input;\n\topnd = OPERAND(p);\n\tswitch (OP(p)) {\n\tcase ANY:\n\t\tcount = cst_strlen(scan);\n\t\tscan += count;\n\t\tbreak;\n\tcase EXACTLY:\n\t\twhile (*opnd == *scan) {\n\t\t\tcount++;\n\t\t\tscan++;\n\t\t}\n\t\tbreak;\n\tcase ANYOF:\n\t\twhile (*scan != '\\0' && strchr(opnd, *scan) != NULL) {\n\t\t\tcount++;\n\t\t\tscan++;\n\t\t}\n\t\tbreak;\n\tcase ANYBUT:\n\t\twhile (*scan != '\\0' && strchr(opnd, *scan) == NULL) {\n\t\t\tcount++;\n\t\t\tscan++;\n\t\t}\n\t\tbreak;\n\tdefault:\t\t/* Oh dear.  Called inappropriately. */\n\t\tFAIL(\"internal foulup\");\n\t\tcount = 0;\t/* Best compromise. */\n\t\tbreak;\n\t}\n\tstate->input = scan;\n\n\treturn(count);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regtail - set the next-pointer at the end of a node chain\n */\n", "func_signal": "static void\nregtail(char *p, char *val)", "code": "{\n\tchar *scan;\n\tchar *temp;\n\tint offset;\n\n\tif (p == &regdummy)\n\t\treturn;\n\n\t/* Find last node. */\n\tscan = p;\n\tfor (;;) {\n\t\ttemp = regnext(scan);\n\t\tif (temp == NULL)\n\t\t\tbreak;\n\t\tscan = temp;\n\t}\n\n\tif (OP(scan) == BACK)\n\t\toffset = scan - val;\n\telse\n\t\toffset = val - scan;\n\t*(scan+1) = (offset>>8)&0377;\n\t*(scan+2) = offset&0377;\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/////////////////////////////////////\n// ML using Choleski decomposition //\n/////////////////////////////////////\n", "func_signal": "static void InitDWin(PStreamChol *pst, const float *dynwin, int fsize)", "code": "{\n    int i,j;\n    int leng;\n\n    pst->dw.num = 1;\t// only static\n    if (dynwin) {\n\tpst->dw.num = 2;\t// static + dyn\n    }\n    // memory allocation\n    pst->dw.width = mlpg_alloc(pst->dw.num,int *);\n    for (i = 0; i < pst->dw.num; i++)\n        pst->dw.width[i] = mlpg_alloc(2,int);\n\n    pst->dw.coef = mlpg_alloc(pst->dw.num, double *);\n    pst->dw.coef_ptrs = mlpg_alloc(pst->dw.num, double *);\n    // window for static parameter\tWLEFT = 0, WRIGHT = 1\n    pst->dw.width[0][WLEFT] = pst->dw.width[0][WRIGHT] = 0;\n    pst->dw.coef_ptrs[0] = mlpg_alloc(1,double);\n    pst->dw.coef[0] = pst->dw.coef_ptrs[0];\n    pst->dw.coef[0][0] = 1.0;\n\n    // set delta coefficients\n    for (i = 1; i < pst->dw.num; i++) {\n        pst->dw.coef_ptrs[i] = mlpg_alloc(fsize, double);\n\tpst->dw.coef[i] = pst->dw.coef_ptrs[i];\n        for (j=0; j<fsize; j++) /* FIXME make dynwin doubles for memmove */\n            pst->dw.coef[i][j] = (double)dynwin[j];\n\t// set pointer\n\tleng = fsize / 2;\t\t\t// L (fsize = 2 * L + 1)\n\tpst->dw.coef[i] += leng;\t\t// [L] -> [0]\tcenter\n\tpst->dw.width[i][WLEFT] = -leng;\t// -L\t\tleft\n\tpst->dw.width[i][WRIGHT] = leng;\t//  L\t\tright\n\tif (fsize % 2 == 0) pst->dw.width[i][WRIGHT]--;\n    }\n\n    pst->dw.maxw[WLEFT] = pst->dw.maxw[WRIGHT] = 0;\n    for (i = 0; i < pst->dw.num; i++) {\n\tif (pst->dw.maxw[WLEFT] > pst->dw.width[i][WLEFT])\n\t    pst->dw.maxw[WLEFT] = pst->dw.width[i][WLEFT];\n\tif (pst->dw.maxw[WRIGHT] < pst->dw.width[i][WRIGHT])\n\t    pst->dw.maxw[WRIGHT] = pst->dw.width[i][WRIGHT];\n    }\n\n    return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regnext - dig the \"next\" pointer out of a node\n */\n", "func_signal": "static char *\nregnext(char *p)", "code": "{\n\tint offset;\n\n\tif (p == &regdummy)\n\t\treturn(NULL);\n\n\toffset = NEXT(p);\n\tif (offset == 0)\n\t\treturn(NULL);\n\n\tif (OP(p) == BACK)\n\t\treturn(p-offset);\n\telse\n\t\treturn(p+offset);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - reginsert - insert an operator in front of already-emitted operand\n *\n * Means relocating the operand.\n */\n", "func_signal": "static void\nreginsert(char op, char *opnd)", "code": "{\n\tchar *src;\n\tchar *dst;\n\tchar *place;\n\n\tif (regcode == &regdummy) {\n\t\tregsize += 3;\n\t\treturn;\n\t}\n\n\tsrc = regcode;\n\tregcode += 3;\n\tdst = regcode;\n\twhile (src > opnd)\n\t\t*--dst = *--src;\n\n\tplace = opnd;\t\t/* Op node, where operand used to be. */\n\t*place++ = op;\n\t*place++ = '\\0';\n\t*place++ = '\\0';\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regoptail - regtail on operand of first argument; nop if operandless\n */\n", "func_signal": "static void\nregoptail(char *p, char *val)", "code": "{\n\t/* \"Operandless\" and \"op != BRANCH\" are synonymous in practice. */\n\tif (p == NULL || p == &regdummy || OP(p) != BRANCH)\n\t\treturn;\n\tregtail(OPERAND(p), val);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regatom - the lowest level\n *\n * Optimization:  gobbles an entire sequence of ordinary characters so that\n * it can turn them into a single node, which is smaller to store and\n * faster to run.  Backslashed characters are exceptions, each becoming a\n * separate node; the code is simpler that way and it's not worth fixing.\n */\n", "func_signal": "static char *\nregatom(int *flagp)", "code": "{\n\tchar *ret = NULL;\n\tint flags;\n\n\t*flagp = WORST;\t\t/* Tentatively. */\n\n\tswitch (*regparse++) {\n\t/* FIXME: these chars only have meaning at beg/end of pat? */\n\tcase '^':\n\t\tret = regnode(BOL);\n\t\tbreak;\n\tcase '$':\n\t\tret = regnode(EOL);\n\t\tbreak;\n\tcase '.':\n\t\tret = regnode(ANY);\n\t\t*flagp |= HASWIDTH|SIMPLE;\n\t\tbreak;\n\tcase '[': {\n\t\t\tint class1;\n\t\t\tint classend;\n\n\t\t\tif (*regparse == '^') {\t/* Complement of range. */\n\t\t\t\tret = regnode(ANYBUT);\n\t\t\t\tregparse++;\n\t\t\t} else\n\t\t\t\tret = regnode(ANYOF);\n\t\t\tif (*regparse == ']' || *regparse == '-')\n\t\t\t\tregc(*regparse++);\n\t\t\twhile (*regparse != '\\0' && *regparse != ']') {\n\t\t\t\tif (*regparse == '-') {\n\t\t\t\t\tregparse++;\n\t\t\t\t\tif (*regparse == ']' || *regparse == '\\0')\n\t\t\t\t\t\tregc('-');\n\t\t\t\t\telse {\n\t\t\t\t\t\tclass1 = UCHARAT(regparse-2)+1;\n\t\t\t\t\t\tclassend = UCHARAT(regparse);\n\t\t\t\t\t\tif (class1 > classend+1)\n\t\t\t\t\t\t\tFAIL(\"invalid [] range\");\n\t\t\t\t\t\tfor (; class1 <= classend; class1++)\n\t\t\t\t\t\t\tregc(class1);\n\t\t\t\t\t\tregparse++;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tregc(*regparse++);\n\t\t\t}\n\t\t\tregc('\\0');\n\t\t\tif (*regparse != ']')\n\t\t\t\tFAIL(\"unmatched []\");\n\t\t\tregparse++;\n\t\t\t*flagp |= HASWIDTH|SIMPLE;\n\t\t}\n\t\tbreak;\n\tcase '(':\n\t\tret = reg(1, &flags);\n\t\tif (ret == NULL)\n\t\t\treturn(NULL);\n\t\t*flagp |= flags&(HASWIDTH|SPSTART);\n\t\tbreak;\n\tcase '\\0':\n\tcase '|':\n\tcase '\\n':\n\tcase ')':\n\t\tFAIL(\"internal urp\");\t/* Supposed to be caught earlier. */\n\t\tbreak;\n\tcase '?':\n\tcase '+':\n\tcase '*':\n\t\tFAIL(\"?+* follows nothing\");\n\t\tbreak;\n\tcase '\\\\':\n\t\tswitch (*regparse++) {\n\t\tcase '\\0':\n\t\t\tFAIL(\"trailing \\\\\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tret = regnode(WORDA);\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tret = regnode(WORDZ);\n\t\t\tbreak;\n\t\t/* FIXME: Someday handle \\1, \\2, ... */\n\t\tdefault:\n\t\t\t/* Handle general quoted chars in exact-match routine */\n\t\t\tgoto de_fault;\n\t\t}\n\t\tbreak;\n\tde_fault:\n\tdefault:\n\t\t/*\n\t\t * Encode a string of characters to be matched exactly.\n\t\t *\n\t\t * This is a bit tricky due to quoted chars and due to\n\t\t * '*', '+', and '?' taking the SINGLE char previous\n\t\t * as their operand.\n\t\t *\n\t\t * On entry, the char at regparse[-1] is going to go\n\t\t * into the string, no matter what it is.  (It could be\n\t\t * following a \\ if we are entered from the '\\' case.)\n\t\t *\n\t\t * Basic idea is to pick up a good char in  ch  and\n\t\t * examine the next char.  If it's *+? then we twiddle.\n\t\t * If it's \\ then we frozzle.  If it's other magic char\n\t\t * we push  ch  and terminate the string.  If none of the\n\t\t * above, we push  ch  on the string and go around again.\n\t\t *\n\t\t *  regprev  is used to remember where \"the current char\"\n\t\t * starts in the string, if due to a *+? we need to back\n\t\t * up and put the current char in a separate, 1-char, string.\n\t\t * When  regprev  is NULL,  ch  is the only char in the\n\t\t * string; this is used in *+? handling, and in setting\n\t\t * flags |= SIMPLE at the end.\n\t\t */\n\t\t{\n\t\t\tconst char *regprev;\n\t\t\tchar ch = 0;\n\n\t\t\tregparse--;\t\t\t/* Look at cur char */\n\t\t\tret = regnode(EXACTLY);\n\t\t\tfor ( regprev = 0 ; ; ) {\n\t\t\t\tch = *regparse++;\t/* Get current char */\n\t\t\t\tswitch (*regparse) {\t/* look at next one */\n\n\t\t\t\tdefault:\n\t\t\t\t\tregc(ch);\t/* Add cur to string */\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '.': case '[': case '(':\n\t\t\t\tcase ')': case '|': case '\\n':\n\t\t\t\tcase '$': case '^':\n\t\t\t\tcase '\\0':\n\t\t\t\t/* FIXME, $ and ^ should not always be magic */\n\t\t\t\tmagic:\n\t\t\t\t\tregc(ch);\t/* dump cur char */\n\t\t\t\t\tgoto done;\t/* and we are done */\n\n\t\t\t\tcase '?': case '+': case '*':\n\t\t\t\t\tif (!regprev) \t/* If just ch in str, */\n\t\t\t\t\t\tgoto magic;\t/* use it */\n\t\t\t\t\t/* End mult-char string one early */\n\t\t\t\t\tregparse = regprev; /* Back up parse */\n\t\t\t\t\tgoto done;\n\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tregc(ch);\t/* Cur char OK */\n\t\t\t\t\tswitch (regparse[1]){ /* Look after \\ */\n\t\t\t\t\tcase '\\0':\n\t\t\t\t\tcase '<':\n\t\t\t\t\tcase '>':\n\t\t\t\t\t/* FIXME: Someday handle \\1, \\2, ... */\n\t\t\t\t\t\tgoto done; /* Not quoted */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Backup point is \\, scan\t\t\t\t\t\t\t * point is after it. */\n\t\t\t\t\t\tregprev = regparse;\n\t\t\t\t\t\tregparse++;\n\t\t\t\t\t\tcontinue;\t/* NOT break; */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregprev = regparse;\t/* Set backup point */\n\t\t\t}\n\t\tdone:\n\t\t\tregc('\\0');\n\t\t\t*flagp |= HASWIDTH;\n\t\t\tif (!regprev)\t\t/* One char? */\n\t\t\t\t*flagp |= SIMPLE;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn(ret);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "// Choleski: Choleski factorization of Matrix R\n", "func_signal": "static void Choleski(PStreamChol *pst)", "code": "{\n    register int t, j, k;\n\n    pst->R[0][0] = sqrt(pst->R[0][0]);\n\n    for (j = 1; j < pst->width; j++) pst->R[0][j] /= pst->R[0][0];\n\n    for (t = 1; t < pst->T; t++) {\n\tfor (j = 1; j < pst->width; j++)\n\t    if (t - j >= 0)\n\t\tpst->R[t][0] -= pst->R[t - j][j] * pst->R[t - j][j];\n         \n\tpst->R[t][0] = sqrt(pst->R[t][0]);\n         \n\tfor (j = 1; j < pst->width; j++) {\n\t    for (k = 0; k < pst->dw.maxw[WRIGHT]; k++)\n\t\tif (j != pst->width - 1)\n\t\t    pst->R[t][j] -=\n\t\t\tpst->R[t - k - 1][j - k] * pst->R[t - k - 1][j + 1];\n            \n\t    pst->R[t][j] /= pst->R[t][0];\n\t}\n    }\n   \n    return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "// generate parameter sequence from pdf sequence using gradient\n", "func_signal": "static void mlpgGrad(PStreamChol *pst, const int max, double th, double e,\n\t      double alpha, DVECTOR vm, DVECTOR vv, XBOOL nrmflag)", "code": "{\n   register int m, i, t;\n   double diff, n, dth;\n\n   if (nrmflag == XTRUE)\n       n = (double)(pst->T * pst->vSize) / (double)(vm->length);\n   else n = 1.0;\n\n   // generating parameter in each dimension\n   for (m = 0; m <= pst->order; m++) {\n       calc_R_and_r(pst, m);\n       dth = th * sqrt(vm->data[m]);\n       for (i = 0; i < max; i++) {\n\t   calc_grad(pst, m);\n\t   if (vm != NODATA && vv != NODATA)\n\t       calc_vargrad(pst, m, alpha, n, vm->data[m], vv->data[m]);\n\t   for (t = 0, diff = 0.0; t < pst->T; t++) {\n\t       diff += pst->g[t] * pst->g[t];\n\t       pst->c[t][m] += e * pst->g[t];\n\t   }\n\t   diff = sqrt(diff / (double)pst->T);\n\t   if (diff < dth || diff == 0.0) break;\n       }\n   }\n   \n   return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* 0 failure, 1 success */\n", "func_signal": "regtry(cst_regstate *state, const char *string, char *prog)", "code": "{\n\tint i;\n\tconst char **sp;\n\tconst char **ep;\n\n\tstate->input = string;\n\n\tsp = state->startp;\n\tep = state->endp;\n\tfor (i = CST_NSUBEXP; i > 0; i--) {\n\t\t*sp++ = NULL;\n\t\t*ep++ = NULL;\n\t}\n\tif (regmatch(state, prog)) {\n\t  state->startp[0] = (char *)string;\n\t  state->endp[0] = (char *)state->input;\n\t\treturn(1);\n\t} else\n\t\treturn(0);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* Location. */\n", "func_signal": "regnode(char op)", "code": "{\n\tchar *ret;\n\tchar *ptr;\n\n\tret = regcode;\n\tif (ret == &regdummy) {\n\t\tregsize += 3;\n\t\treturn(ret);\n\t}\n\n\tptr = ret;\n\t*ptr++ = op;\n\t*ptr++ = '\\0';\t\t/* Null \"next\" pointer. */\n\t*ptr++ = '\\0';\n\tregcode = ptr;\n\n\treturn(ret);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* 0 failure, 1 success */\n", "func_signal": "regmatch(cst_regstate *state, char *scan)", "code": "{\n\tchar *next;\t\t/* Next node. */\n\n#ifdef DEBUG\n\tif (scan != NULL && regnarrate)\n\t\tfprintf(regnarrate, \"%s(\\n\", regprop(scan));\n#endif\n\twhile (scan != NULL) {\n#ifdef DEBUG\n\t\tif (regnarrate)\n\t\t\tfprintf(regnarrate, \"%s...\\n\", regprop(scan));\n#endif\n\t\tnext = regnext(scan);\n\n\t\tswitch (OP(scan)) {\n\t\tcase BOL:\n\t\t\tif (state->input != state->bol)\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase EOL:\n\t\t\tif (*state->input != '\\0')\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase WORDA:\n\t\t\t/* Must be looking at a letter, digit, or _ */\n\t\t\tif ((!isalnum((int)*state->input)) && *state->input != '_')\n\t\t\t\treturn(0);\n\t\t\t/* Prev must be BOL or nonword */\n\t\t\tif (state->input > state->bol &&\n\t\t\t    (isalnum((int)state->input[-1]) || state->input[-1] == '_'))\n\t\t\t\treturn(0);\n\t\t\tbreak;\n\t\tcase WORDZ:\n\t\t\t/* Must be looking at non letter, digit, or _ */\n\t\t\tif (isalnum((int)*state->input) || *state->input == '_')\n\t\t\t\treturn(0);\n\t\t\t/* We don't care what the previous char was */\n\t\t\tbreak;\n\t\tcase ANY:\n\t\t\tif (*state->input == '\\0')\n\t\t\t\treturn(0);\n\t\t\tstate->input++;\n\t\t\tbreak;\n\t\tcase EXACTLY: {\n\t\t\t\tint len;\n\t\t\t\tchar *opnd;\n\n\t\t\t\topnd = OPERAND(scan);\n\t\t\t\t/* Inline the first character, for speed. */\n\t\t\t\tif (*opnd != *state->input)\n\t\t\t\t\treturn(0);\n\t\t\t\tlen = cst_strlen(opnd);\n\t\t\t\tif (len > 1 && strncmp(opnd, state->input, len) != 0)\n\t\t\t\t\treturn(0);\n\t\t\t\tstate->input += len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ANYOF:\n \t\t\tif (*state->input == '\\0' || strchr(OPERAND(scan), *state->input) == NULL)\n\t\t\t\treturn(0);\n\t\t\tstate->input++;\n\t\t\tbreak;\n\t\tcase ANYBUT:\n \t\t\tif (*state->input == '\\0' || strchr(OPERAND(scan), *state->input) != NULL)\n\t\t\t\treturn(0);\n\t\t\tstate->input++;\n\t\t\tbreak;\n\t\tcase NOTHING:\n\t\t\tbreak;\n\t\tcase BACK:\n\t\t\tbreak;\n\t\tcase OPEN+1:\n\t\tcase OPEN+2:\n\t\tcase OPEN+3:\n\t\tcase OPEN+4:\n\t\tcase OPEN+5:\n\t\tcase OPEN+6:\n\t\tcase OPEN+7:\n\t\tcase OPEN+8:\n\t\tcase OPEN+9: {\n\t\t\t\tint no;\n\t\t\t\tconst char *save;\n\n\t\t\t\tno = OP(scan) - OPEN;\n\t\t\t\tsave = state->input;\n\n\t\t\t\tif (regmatch(state, next)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't set startp if some later\n\t\t\t\t\t * invocation of the same parentheses\n\t\t\t\t\t * already has.\n\t\t\t\t\t */\n\t\t\t\t\tif (state->startp[no] == NULL)\n\t\t\t\t\t  state->startp[no] = save;\n\t\t\t\t\treturn(1);\n\t\t\t\t} else\n\t\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CLOSE+1:\n\t\tcase CLOSE+2:\n\t\tcase CLOSE+3:\n\t\tcase CLOSE+4:\n\t\tcase CLOSE+5:\n\t\tcase CLOSE+6:\n\t\tcase CLOSE+7:\n\t\tcase CLOSE+8:\n\t\tcase CLOSE+9: {\n\t\t\t\tint no;\n\t\t\t\tconst char *save;\n\n\t\t\t\tno = OP(scan) - CLOSE;\n\t\t\t\tsave = state->input;\n\n\t\t\t\tif (regmatch(state, next)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't set endp if some later\n\t\t\t\t\t * invocation of the same parentheses\n\t\t\t\t\t * already has.\n\t\t\t\t\t */\n\t\t\t\t\tif (state->endp[no] == NULL)\n\t\t\t\t\t  state->endp[no] = save;\n\t\t\t\t\treturn(1);\n\t\t\t\t} else\n\t\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BRANCH: {\n\t\t\t\tconst char *save;\n\n\t\t\t\tif (OP(next) != BRANCH)\t\t/* No choice. */\n\t\t\t\t\tnext = OPERAND(scan);\t/* Avoid recursion. */\n\t\t\t\telse {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tsave = state->input;\n\t\t\t\t\t\tif (regmatch(state, OPERAND(scan)))\n\t\t\t\t\t\t\treturn(1);\n\t\t\t\t\t\tstate->input = save;\n\t\t\t\t\t\tscan = regnext(scan);\n\t\t\t\t\t} while (scan != NULL && OP(scan) == BRANCH);\n\t\t\t\t\treturn(0);\n\t\t\t\t\t/* NOTREACHED */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STAR:\n\t\tcase PLUS: {\n\t\t\t\tchar nextch;\n\t\t\t\tint no;\n\t\t\t\tconst char *save;\n\t\t\t\tint min;\n\n\t\t\t\t/*\n\t\t\t\t * Lookahead to avoid useless match attempts\n\t\t\t\t * when we know what character comes next.\n\t\t\t\t */\n\t\t\t\tnextch = '\\0';\n\t\t\t\tif (OP(next) == EXACTLY)\n\t\t\t\t\tnextch = *OPERAND(next);\n\t\t\t\tmin = (OP(scan) == STAR) ? 0 : 1;\n\t\t\t\tsave = state->input;\n\n\t\t\t\tno = regrepeat(state, OPERAND(scan));\n\t\t\t\twhile (no >= min) {\n\t\t\t\t\t/* If it could work, try it. */\n\t\t\t\t\tif (nextch == '\\0' || *state->input == nextch)\n\t\t\t\t\t  {\n\t\t\t\t\t    if (regmatch(state, next))\n\t\t\t\t\t      return(1);\n\t\t\t\t\t  }\n\t\t\t\t\t/* Couldn't or didn't -- back up. */\n\t\t\t\t\tno--;\n\t\t\t\t\tstate->input = save + no;\n\t\t\t\t}\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase END:\n\t\t\treturn(1);\t/* Success! */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFAIL(\"memory corruption\");\n\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = next;\n\t}\n\n\t/*\n\t * We get here only if there's trouble -- normally \"case END\" is\n\t * the terminating point.\n\t */\n\tFAIL(\"corrupted pointers\");\n\treturn(0);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* from vector.cc */\n", "func_signal": "LVECTOR xlvalloc(long length)", "code": "{\n    LVECTOR x;\n\n    length = MAX(length, 0);\n    x = cst_alloc(struct LVECTOR_STRUCT,1);\n    x->data = cst_alloc(long,MAX(length, 1));\n    x->imag = NULL;\n    x->length = length;\n\n    return x;\n}", "path": "flite-1.4-iphone\\src\\cst_vc.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "// Diagonal Covariance Version\n", "func_signal": "static void mlgparaGrad(DMATRIX pdf, PStreamChol *pst, DMATRIX mlgp, const int max,\n\t\t double th, double e, double alpha, DVECTOR vm, DVECTOR vv,\n\t\t XBOOL nrmflag, XBOOL extvflag)", "code": "{\n    int t, d;\n\n    // error check\n    if (pst->vSize * 2 != pdf->col || pst->order + 1 != mlgp->col) {\n\tcst_errmsg(\"Error mlgparaChol: Different dimension\\n\");\n        cst_error();\n    }\n\n    // mseq: U^{-1}*M,\tifvseq: U^{-1}\n    for (t = 0; t < pst->T; t++) {\n\tfor (d = 0; d < pst->vSize; d++) {\n\t    pst->mseq[t][d] = pdf->data[t][d];\n\t    pst->ivseq[t][d] = pdf->data[t][pst->vSize + d];\n\t}\n    } \n\n    // ML parameter generation\n    mlpgChol(pst);\n\n    // extend variance\n    if (extvflag == XTRUE)\n\tfor (d = 0; d <= pst->order; d++)\n\t    varconv(pst->c, d, pst->T, vm->data[d]);\n\n    // estimating parameters\n    mlpgGrad(pst, max, th, e, alpha, vm, vv, nrmflag);\n\n    // extracting parameters\n    for (t = 0; t < pst->T; t++)\n\tfor (d = 0; d <= pst->order; d++)\n\t    mlgp->data[t][d] = pst->c[t][d];\n\n    return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/*\n - regbranch - one alternative of an | operator\n *\n * Implements the concatenation operator.\n */\n", "func_signal": "static char *\nregbranch(int *flagp)", "code": "{\n\tchar *ret;\n\tchar *chain;\n\tchar *latest;\n\tint flags;\n\n\t*flagp = WORST;\t\t/* Tentatively. */\n\n\tret = regnode(BRANCH);\n\tchain = NULL;\n\twhile (*regparse != '\\0' && *regparse != ')' &&\n\t       *regparse != '\\n' && *regparse != '|') {\n\t\tlatest = regpiece(&flags);\n\t\tif (latest == NULL)\n\t\t\treturn(NULL);\n\t\t*flagp |= flags&HASWIDTH;\n\t\tif (chain == NULL)\t/* First piece. */\n\t\t\t*flagp |= flags&SPSTART;\n\t\telse\n\t\t\tregtail(chain, latest);\n\t\tchain = latest;\n\t}\n\tif (chain == NULL)\t/* Loop ran zero times. */\n\t\t(void) regnode(NOTHING);\n\n\treturn(ret);\n}", "path": "flite-1.4-iphone\\src\\regexp.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "// Choleski_forward: forward substitution to solve linear equations\n", "func_signal": "static void Choleski_forward(PStreamChol *pst)", "code": "{\n    register int t, j;\n    double hold;\n   \n    pst->g[0] = pst->r[0] / pst->R[0][0];\n\n    for (t=1; t < pst->T; t++) {\n\thold = 0.0;\n\tfor (j = 1; j < pst->width; j++)\n\t    if (t - j >= 0 && pst->R[t - j][j] != 0.0)\n\t\thold += pst->R[t - j][j] * pst->g[t - j];\n\tpst->g[t] = (pst->r[t] - hold) / pst->R[t][0];\n    }\n   \n    return;\n}", "path": "flite-1.4-iphone\\src\\cst_mlpg.c", "repo_name": "prohner/TapToTeach", "stars": 5, "license": "None", "language": "c", "size": 17981}
{"docstring": "/* print error msg */\n", "func_signal": "void perror(char *msg)", "code": "{\n\tdisp_color_str(\"ERROR: \", 4);\n\tdisp_str(msg);\n\tdisp_str(\"       \\n\");\n}", "path": "lib\\perror.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                            kenos_main\n *======================================================================*/\n", "func_signal": "PUBLIC int kenos_main()", "code": "{\n//\tunsigned int aint = *((unsigned int *)0x7c00);\n//\tdisp_int(aint);\n//\tperror(\"\");\n//\tkinfo(\"k_info\");\n\n\tdisp_str(\"----- init ata device -----\\n\");\n//\tASSERT(1);\n\tinit_ide_dev();\n\tdisp_str(\"----- end of ata init -----\\n\");\n\n//\tint t = 0;\n//\tchar buf[1024];\n//\tide_rblks(0, 0, 2, buf);\n\t\n\tdisp_str(\"-----\\\"kenos_main\\\" begins-----\\n\");\n\n\tTASK*\t\tp_task;\n\tPROCESS*\tp_proc\t\t= proc_table;\n\tchar*\t\tp_task_stack\t= task_stack + STACK_SIZE_TOTAL;\n\tt_16\t\tselector_ldt\t= SELECTOR_LDT_FIRST;\n\tint\t\ti;\n\tt_8\t\tprivilege;\n\tt_8\t\trpl;\n\tint\t\teflags;\n\t\n\t// init the proc_table\n\tfor(i = 0; i< NR_TASKS + NR_PROCS; i++){\n\t\tif (i < NR_TASKS) {\t/* tasks */\n\t\t\tp_task\t\t= task_table + i;\n\t\t\tprivilege\t= PRIVILEGE_TASK;\n\t\t\trpl\t\t= RPL_TASK;\n\t\t\teflags\t\t= 0x1202;\n\t\t\t/* IF=1, IOPL=1, bit 2 is always 1 */\n\t\t}\n\t\telse {\t\t\t/* user process */\n\t\t\tp_task\t\t= user_proc_table + (i - NR_TASKS);\n\t\t\tprivilege\t= PRIVILEGE_USER;\n\t\t\trpl\t\t= RPL_USER;\n\t\t\teflags\t\t= 0x202;\n\t\t\t/* IF=1, bit 2 is always 1 */\n\t\t}\n\n\t\tstrcpy(p_proc->name, p_task->name);\t/* name of the process */\n\t\tp_proc->pid = i;\t\t\t/* pid */\n\n\t\tp_proc->ldt_sel\t= selector_ldt;\n\t\tmemcpy(&p_proc->ldts[0], &gdt[SELECTOR_KERNEL_CS >> 3],\n\t\t\tsizeof(DESCRIPTOR));\n\t\tp_proc->ldts[0].attr1 = DA_C | privilege << 5;\n\t\t/* change the DPL */\n\t\t\n\t\tmemcpy(&p_proc->ldts[1], &gdt[SELECTOR_KERNEL_DS >> 3],\n\t\t\tsizeof(DESCRIPTOR));\n\t\tp_proc->ldts[1].attr1 = DA_DRW | privilege << 5;\n\t\t/* change the DPL */\n\t\t\n\t\tp_proc->regs.cs = ((8 * 0) & SA_RPL_MASK & SA_TI_MASK) |\n\t\t\t\t\t\t\tSA_TIL | rpl;\n\t\tp_proc->regs.ds = ((8 * 1) & SA_RPL_MASK & SA_TI_MASK) |\n\t\t\t\t\t\t\tSA_TIL | rpl;\n\t\tp_proc->regs.es = ((8 * 1) & SA_RPL_MASK & SA_TI_MASK) |\n\t\t\t\t\t\t\tSA_TIL | rpl;\n\t\tp_proc->regs.fs = ((8 * 1) & SA_RPL_MASK & SA_TI_MASK) |\n\t\t\t\t\t\t\tSA_TIL | rpl;\n\t\tp_proc->regs.ss = ((8 * 1) & SA_RPL_MASK & SA_TI_MASK) |\n\t\t\t\t\t\t\tSA_TIL | rpl;\n\t\tp_proc->regs.gs = (SELECTOR_KERNEL_GS & SA_RPL_MASK) | rpl;\n\t\tp_proc->regs.eip\t= (t_32)p_task->initial_eip;\n\t\tp_proc->regs.esp\t= (t_32)p_task_stack;\n\t\tp_proc->regs.eflags\t= eflags;\n\t\t\n\t\tp_proc->nr_tty\t\t= 0;\n\n\t\tp_task_stack -= p_task->stacksize;\n\t\tp_proc++;\n\t\tp_task++;\n\t\tselector_ldt += 1 << 3;\n\t}\n\tproc_table[0].ticks = proc_table[0].priority = 315;\n\tproc_table[1].ticks = proc_table[1].priority = 5;\n\tproc_table[2].ticks = proc_table[2].priority = 105;\n\tproc_table[3].ticks = proc_table[3].priority = 105;\n\t\n\tproc_table[1].nr_tty = 0;\n\tproc_table[2].nr_tty = 1;\n\tproc_table[3].nr_tty = 1;\n\n\tk_reenter = 0;\n\tticks = 0;\n\t\n\tp_proc_ready = proc_table;\n\t\n\tinit_clock();\n\t\n\trestart();\n\n\twhile(1){}\n}", "path": "kernel\\main.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*\n * initializes the semaphore with the specified integer value.\n */\n", "func_signal": "int ksema_init(struct ksema *sema, unsigned int initval)", "code": "{\n\tif (sema)\n\t\tsema->value = initval;\n\treturn 0;\n}", "path": "kernel\\ksync.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                              schedule\n *======================================================================*/\n", "func_signal": "PUBLIC void sched0(PROCESS *proc_t, PROCESS **p_ready)", "code": "{\n\tPROCESS\t*p;\n\tint\tgreatest_ticks = 0;\n\n\twhile ( 0 == greatest_ticks ) {\n\t\tfor (p = proc_t; p < proc_t + NR_TASKS + NR_PROCS; \n\t\t\tp++) {\n\t\t\t\n\t\t\tif (p->ticks > greatest_ticks) {\n\t\t\t\tgreatest_ticks = p->ticks;\n\t\t\t//\tp_proc_ready = p;\n\t\t\t\t(*p_ready) = p;\n\t\t\t}\n\t\t}\n\n\t\tif (greatest_ticks == 0) {\n\t\t\tfor (p = proc_t; \n\t\t\t\tp < proc_t + NR_TASKS + NR_PROCS; \n\t\t\t\tp++) {\n\t\t\t\t\n\t\t\t\tp->ticks = p->priority;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "kernel\\proc.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                               TestC\n *======================================================================*/\n", "func_signal": "void TestC()", "code": "{\n\tint i = 0;\n\twhile(1){\n//\t\tdisp_str(\"C.\");\n\t\tprintf(\"C\");\n\t\tmilli_delay(100);\n\t}\n}", "path": "kernel\\main.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*===================================================================*\n                            init_8259A\n *===================================================================*/\n", "func_signal": "PUBLIC void init_8259A()", "code": "{\n\tout_byte(INT_M_CTL,\t0x11);\t\t// Master 8259, ICW1.\n\tout_byte(INT_S_CTL,\t0x11);\t\t// Slave  8259, ICW1.\n\t\n\t// Master 8259, ICW2. set the interrupt entry addr to 0x20\n\tout_byte(INT_M_CTLMASK,\tINT_VECTOR_IRQ0);\n\t\n\t// Slave  8259, ICW2. set the interrupt entry addr to 0x28\n\tout_byte(INT_S_CTLMASK,\tINT_VECTOR_IRQ8);\n\t\n\t// Master 8259, ICW3. IR2 to Slave 8259 accordingly\n\tout_byte(INT_M_CTLMASK,\t0x4);\n\t\n\t// Slave 8259, ICW3. IR2 to Master 8259 accordingly\n\tout_byte(INT_S_CTLMASK,\t0x2);\n\tout_byte(INT_M_CTLMASK,\t0x1);\t// Master 8259, ICW4.\n\tout_byte(INT_S_CTLMASK,\t0x1);\t// Slave  8259, ICW4.\n\n\tout_byte(INT_M_CTLMASK,\t0xFF);\t// Master 8259, OCW1.\n\tout_byte(INT_S_CTLMASK,\t0xFF);\t// Slave  8259, OCW1.\n\t\n\tint i;\n\tfor(i=0; i<NR_IRQ; i++){\n\t\tirq_table[i] = spurious_irq;\n\t}\n\n}", "path": "kernel\\i8259.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                                 printf\n *======================================================================*/\n", "func_signal": "int printf(const char *fmt, ...)", "code": "{\n\tint i;\n\tchar buf[256];\n\n\tva_list arg = (va_list)((char*)(&fmt) + 4);\n\t/* 4 \u662f\u53c2\u6570 fmt \u6240\u5360\u5806\u6808\u4e2d\u7684\u5927\u5c0f */\n\ti = vsprintf(buf, fmt, arg);\n\twrite(buf, i);\n\n\treturn i;\n}", "path": "kernel\\printf.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*===================================================================*\n                           spurious_irq\n *===================================================================*/\n", "func_signal": "PUBLIC void spurious_irq(int irq)", "code": "{\n\tdisp_str(\"spurious_irq: \");\n\tdisp_int(irq);\n\tdisp_str(\"\\n\");\n}", "path": "kernel\\i8259.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                           milli_delay\n*======================================================================*/\n", "func_signal": "PUBLIC void milli_delay(int milli_sec)", "code": "{\n\tint t = get_ticks();\n\n\twhile(((get_ticks() - t) * 1000 / HZ) < milli_sec) {}\n}", "path": "kernel\\clock.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                                 kb_ack\n *======================================================================*/\n", "func_signal": "PRIVATE void kb_ack()", "code": "{\n\tt_8 kb_read;\n\n\tdo {\n\t\tkb_read = in_byte(KB_DATA);\n\t} while (kb_read =! KB_ACK);\n}", "path": "kernel\\keyboard.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*\n * Implements the V (up) operation on the specified kernel semaphore.\n */\n", "func_signal": "int ksema_v(struct ksema *sem)", "code": "{\n\tunsigned long eflags;\n//\tstruct task_struct *t;\n\n\tdisable_hwint(eflags);\n\n\t/* Increment the value of the semaphore. */\n\tsem->value++;\n\n\t/* Remove the first task from the semaphore's wait queue and \n\t * wake it up! */\n//\tif (!list_empty(sem->waiting_task_list_head)) {\n//\t\tt = list_pop_head(sem->waiting_task_list_head);\n//\t\tt->state = TASK_RUNNABLE;\n//\t}\n\n\trestore_hwint(eflags);\n\t\n\treturn 0;\n}", "path": "kernel\\ksync.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                                vsprintf\n *======================================================================*/\n", "func_signal": "int vsprintf(char *buf, const char *fmt, va_list args)", "code": "{\n\tchar*\tp;\n\tchar\ttmp[256];\n\tva_list\tp_next_arg = args;\n\n\tfor (p=buf;*fmt;fmt++) {\n\t\tif (*fmt != '%') {\n\t\t\t*p++ = *fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt++;\n\n\t\tswitch (*fmt) {\n\t\tcase 'x':\n\t\t\titoa(tmp, *((int*)p_next_arg));\n\t\t\tstrcpy(p, tmp);\n\t\t\tp_next_arg += 4;\n\t\t\tp += strlen(tmp);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (p - buf);\n}", "path": "kernel\\vsprintf.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                           clock_handler\n *======================================================================*/\n", "func_signal": "PUBLIC void clock_handler(int irq)", "code": "{\n//\tdisp_str(\"#\");\n\tticks++;\n\tp_proc_ready->ticks--;\n\n\tif (k_reenter != 0) {\n//\t\tdisp_str(\"!\");\n\t\treturn;\n\t}\n\n//\tp_proc_ready++;\n\n//\tif (p_proc_ready >= proc_table + NR_TASKS) {\n//\t\tp_proc_ready = proc_table;\n//\t}\n\tif (p_proc_ready->ticks > 0) {\n\t\treturn;\n\t}\n\t\n\tschedule(proc_table, &p_proc_ready);\n\n}", "path": "kernel\\clock.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                               TestA\n *======================================================================*/\n", "func_signal": "void TestA()", "code": "{\n//\tint i = 0;\n//\tsw_sched();\n//\thd_intr();\n//\tprintf(\"<xxxxxxhd: %x>\\n\", get_hd_info());\n//\thd_xxx();\n\tld_mod(\"XMOD.ELF\");\n\t\n\twhile(1){\n//\t\tdisp_str(\"A.\");\n\t\tprintf(\"<Ticks: %x>\", get_ticks());\n//\t\tsw_sched();\n\t\tmilli_delay(100);\n\t}\n}", "path": "kernel\\main.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                            put_irq_handler\n *======================================================================*/\n", "func_signal": "PUBLIC void put_irq_handler(int irq, t_pf_irq_handler handler)", "code": "{\n\tdisable_irq(irq);\n\tirq_table[irq] = handler;\n}", "path": "kernel\\i8259.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                           init_clock\n *======================================================================*/\n", "func_signal": "PUBLIC void init_clock()", "code": "{\n\t/* initialize 8253 PIT */\n\tout_byte(TIMER_MODE, RATE_GENERATOR);\n\tout_byte(TIMER0, (t_8) (TIMER_FREQ/HZ) );\n\tout_byte(TIMER0, (t_8) ((TIMER_FREQ/HZ) >> 8));\n\n\tput_irq_handler(CLOCK_IRQ, clock_handler);\n\tenable_irq(CLOCK_IRQ);\t/* enable the clock interrupt of 8259A */\n}", "path": "kernel\\clock.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                           init_keyboard\n*======================================================================*/\n", "func_signal": "PUBLIC void init_keyboard()", "code": "{\n\tkb_in.count = 0;\n\tkb_in.p_head = kb_in.p_tail = kb_in.buf;\n\n\tcaps_lock\t= 0;\n\tnum_lock\t= 1;\n\tscroll_lock\t= 0;\n\n\tset_leds();\n\n\tput_irq_handler(KEYBOARD_IRQ, keyboard_handler);/* set the handler */\n\tenable_irq(KEYBOARD_IRQ);\n}", "path": "kernel\\keyboard.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*\n * Implements the P (down) operation on the specified kernel semaphore.\n * Do not call this function from an interrupt handler!\n */\n", "func_signal": "int ksema_p(struct ksema *sem)", "code": "{\n\tunsigned long eflags;\n\n\tdisable_hwint(eflags);\n\n//\tif (!sem->value) {\n//\t\t/* Append the current task to the semaphore's wait queue \n//\t\t * and sleep. */\n//\t\tlist_append(sem->waiting_task_list_head, current);\n//\t\tcurrent->state = TASK_UNINTERRUPTIBLE;\n//\t\tschedule();\n//\t}\n\n\t/* Decrement the value of the semaphore. */\n\tsem->value--;\n\t\n\trestore_hwint(eflags);\n\t\n\tif (sem->value < 0) {\n\t\tsem->value++;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "kernel\\ksync.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                               TestB\n *======================================================================*/\n", "func_signal": "void TestB()", "code": "{\n\tint i = 0;\n\twhile(1){\n//\t\tdisp_str(\"B.\");\n\t\tprintf(\"B\");\n\t\tmilli_delay(100);\n\t}\n}", "path": "kernel\\main.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/*======================================================================*\n                           keyboard_read\n*======================================================================*/\n", "func_signal": "PUBLIC void keyboard_read(TTY* p_tty)", "code": "{\n\tt_8\tscan_code;\n\tt_bool\tmake;\t/* TRUE : make  */\n\t\t\t/* FALSE: break */\n\tt_32\tkey = 0;/* a integer presents a key */\n\t/* e.g. when 'Home' is pressed, the 'key' will be assigned to \n\t  the value of 'HOME' which is defined in keyboard.h */\n\t\n\tt_32*\tkeyrow;\t/* point to a row in keymap[] */\n\n\tif(kb_in.count > 0){\n\t\tcode_with_E0 = FALSE;\n\t\tscan_code = get_byte_from_kb_buf();\n\n\t\t/* analyze the scan code */\n\t\tif (scan_code == 0xE1) {\n\t\t\tint i;\n\t\t\tt_8 pausebreak_scan_code[] = {\n\t\t\t\t0xE1, 0x1D, 0x45, 0xE1, 0x9D, 0xC5};\n\t\t\tt_bool is_pausebreak = TRUE;\n\t\t\tfor(i=1;i<6;i++){\n\t\t\t\tif (get_byte_from_kb_buf() !=\n\t\t\t\t\t\tpausebreak_scan_code[i]) {\n\t\t\t\t\tis_pausebreak = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pausebreak) {\n\t\t\t\tkey = PAUSEBREAK;\n\t\t\t}\n\t\t}\n\t\telse if (scan_code == 0xE0) {\n\t\t\tcode_with_E0 = TRUE;\n\t\t\tscan_code = get_byte_from_kb_buf();\n\n\t\t\t/* 'PrintScreen' is pressed */\n\t\t\tif (scan_code == 0x2A) {\n\t\t\t\tcode_with_E0 = FALSE;\n\t\t\t\tif ((scan_code = get_byte_from_kb_buf()) \n\t\t\t\t\t\t\t\t== 0xE0) {\n\t\t\t\t\tcode_with_E0 = TRUE;\n\t\t\t\t\tif ((scan_code =\n\t\t\t\t\t\tget_byte_from_kb_buf()) \n\t\t\t\t\t\t\t\t== 0x37) {\n\t\t\t\t\t\tkey = PRINTSCREEN;\n\t\t\t\t\t\tmake = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* PrintScreen is released */\n\t\t\telse if (scan_code == 0xB7) {\n\t\t\t\tcode_with_E0 = FALSE;\n\t\t\t\tif ((scan_code = get_byte_from_kb_buf())\n\t\t\t\t\t\t\t\t== 0xE0) {\n\t\t\t\t\tcode_with_E0 = TRUE;\n\t\t\t\t\tif ((scan_code =\n\t\t\t\t\t\tget_byte_from_kb_buf()) \n\t\t\t\t\t\t\t\t== 0xAA) {\n\t\t\t\t\t\tkey = PRINTSCREEN;\n\t\t\t\t\t\tmake = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if it is not 'PrintScreen' that has been pressed, \n\t\t    then the scan_code is the value that followed 0xE0. */\n\n\t\tif ((key != PAUSEBREAK) && (key != PRINTSCREEN)) {\n\t\t\t/* Make Code or Break Code */\n\t\t\tmake = (scan_code & FLAG_BREAK ? FALSE : TRUE);\n\t\t\t\n\t\t\t/* point to some row in keymap[] */\n\t\t\tkeyrow = &keymap[(scan_code & 0x7F) * MAP_COLS];\n\n\t\t\tcolumn = 0;\n\n\t\t\tt_bool caps = shift_l || shift_r;\n\t\t\tif (caps_lock) {\n\t\t\t\tif ((keyrow[0] >= 'a') && (keyrow[0] <= 'z')){\n\t\t\t\t\tcaps = !caps;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (caps) {\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\n\t\t\tif (code_with_E0) {\n\t\t\t\tcolumn = 2;\n\t\t\t}\n\n\t\t\tkey = keyrow[column];\n\n\t\t\tswitch(key) {\n\t\t\tcase SHIFT_L:\n\t\t\t\tshift_l\t= make;\n\t\t\t\tbreak;\n\t\t\tcase SHIFT_R:\n\t\t\t\tshift_r\t= make;\n\t\t\t\tbreak;\n\t\t\tcase CTRL_L:\n\t\t\t\tctrl_l\t= make;\n\t\t\t\tbreak;\n\t\t\tcase CTRL_R:\n\t\t\t\tctrl_r\t= make;\n\t\t\t\tbreak;\n\t\t\tcase ALT_L:\n\t\t\t\talt_l\t= make;\n\t\t\t\tbreak;\n\t\t\tcase ALT_R:\n\t\t\t\talt_l\t= make;\n\t\t\t\tbreak;\n\t\t\tcase CAPS_LOCK:\n\t\t\t\tif (make) {\n\t\t\t\t\tcaps_lock   = !caps_lock;\n\t\t\t\t\tset_leds();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase NUM_LOCK:\n\t\t\t\tif (make) {\n\t\t\t\t\tnum_lock    = !num_lock;\n\t\t\t\t\tset_leds();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_LOCK:\n\t\t\t\tif (make) {\n\t\t\t\t\tscroll_lock = !scroll_lock;\n\t\t\t\t\tset_leds();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(make){ /* ignore Break Code */\n\t\t\tt_bool pad = FALSE;\n\n\t\t\t/* deal with the num pad */\n\t\t\tif ((key >= PAD_SLASH) && (key <= PAD_9)) {\n\t\t\t\tpad = TRUE;\n\t\t\t\tswitch(key) {\n\t\t\t/* '/', '*', '-', '+', and 'Enter' in num pad  */\n\t\t\t\tcase PAD_SLASH:\n\t\t\t\t\tkey = '/';\n\t\t\t\t\tbreak;\n\t\t\t\tcase PAD_STAR:\n\t\t\t\t\tkey = '*';\n\t\t\t\t\tbreak;\n\t\t\t\tcase PAD_MINUS:\n\t\t\t\t\tkey = '-';\n\t\t\t\t\tbreak;\n\t\t\t\tcase PAD_PLUS:\n\t\t\t\t\tkey = '+';\n\t\t\t\t\tbreak;\n\t\t\t\tcase PAD_ENTER:\n\t\t\t\t\tkey = ENTER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t/* keys whose value depends on the NumLock */\n\t\t\t\t\tif (num_lock) {\n\t\t\t\t\t/* '0' ~ '9' and '.' in num pad */\n\t\t\t\t\t\tif ((key >= PAD_0) &&\n\t\t\t\t\t\t\t(key <= PAD_9)) {\n\t\t\t\t\t\t\tkey = key - PAD_0 + '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (key == PAD_DOT) {\n\t\t\t\t\t\t\tkey = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tswitch(key) {\n\t\t\t\t\t\tcase PAD_HOME:\n\t\t\t\t\t\t\tkey = HOME;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_END:\n\t\t\t\t\t\t\tkey = END;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_PAGEUP:\n\t\t\t\t\t\t\tkey = PAGEUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_PAGEDOWN:\n\t\t\t\t\t\t\tkey = PAGEDOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_INS:\n\t\t\t\t\t\t\tkey = INSERT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_UP:\n\t\t\t\t\t\t\tkey = UP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_DOWN:\n\t\t\t\t\t\t\tkey = DOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_LEFT:\n\t\t\t\t\t\t\tkey = LEFT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_RIGHT:\n\t\t\t\t\t\t\tkey = RIGHT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PAD_DOT:\n\t\t\t\t\t\t\tkey = DELETE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tkey |= shift_l\t? FLAG_SHIFT_L\t: 0;\n\t\t\tkey |= shift_r\t? FLAG_SHIFT_R\t: 0;\n\t\t\tkey |= ctrl_l\t? FLAG_CTRL_L\t: 0;\n\t\t\tkey |= ctrl_r\t? FLAG_CTRL_R\t: 0;\n\t\t\tkey |= alt_l\t? FLAG_ALT_L\t: 0;\n\t\t\tkey |= alt_r\t? FLAG_ALT_R\t: 0;\n\t\t\tkey |= pad\t? FLAG_PAD\t: 0;\n\n\t\t\tin_process(p_tty, key);\n\t\t}\n\t}\n}", "path": "kernel\\keyboard.c", "repo_name": "kcao/kenos", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 360}
{"docstring": "/**\n *\t@brief Clean up wiimote_t array created by wiiuse_init()\n */\n", "func_signal": "void wiiuse_cleanup(struct wiimote_t** wm, int wiimotes)", "code": "{\n\tint i = 0;\n\n\tif (!wm)\n\t\treturn;\n\n\tWIIUSE_INFO(\"wiiuse clean up...\");\n\n\tfor (; i < wiimotes; ++i) {\n\t\twiiuse_disconnect(wm[i]);\n\t\tfree(wm[i]);\n\t}\n\n\tfree(wm);\n\n\treturn;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Try to resync with the wiimote by starting a new handshake.\n *\n *\t@param wm\t\t\tPointer to a wiimote_t structure.\n */\n", "func_signal": "void wiiuse_resync(struct wiimote_t* wm)", "code": "{\n\tif (!wm)\treturn;\n\n\twm->handshake_state = 0;\n\twiiuse_handshake(wm, NULL, 0);\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Find a wiimote or wiimotes.\n *\n *\t@param wm\t\t\tAn array of wiimote_t structures.\n *\t@param max_wiimotes\tThe number of wiimote structures in \\a wm.\n *\t@param timeout\t\tThe number of seconds before the search times out.\n *\n *\t@return The number of wiimotes found.\n *\n *\t@see wiimote_connect()\n *\n *\tThis function will only look for wiimote devices.\t\t\t\t\t\t\\n\n *\tWhen a device is found the address in the structures will be set.\t\t\\n\n *\tYou can then call wiimote_connect() to connect to the found\t\t\t\t\\n\n *\tdevices.\n */\n", "func_signal": "int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout)", "code": "{\n\tint device_id;\n\tint device_sock;\n\tint found_devices;\n\tint found_wiimotes;\n\n\t/* reset all wiimote bluetooth device addresses */\n\tfor (found_wiimotes = 0; found_wiimotes < max_wiimotes; ++found_wiimotes)\n\t\twm[found_wiimotes]->bdaddr = *BDADDR_ANY;\n\tfound_wiimotes = 0;\n\n\t/* get the id of the first bluetooth device. */\n\tdevice_id = hci_get_route(NULL);\n\tif (device_id < 0) {\n\t\tperror(\"hci_get_route\");\n\t\treturn 0;\n\t}\n\n\t/* create a socket to the device */\n\tdevice_sock = hci_open_dev(device_id);\n\tif (device_sock < 0) {\n\t\tperror(\"hci_open_dev\");\n\t\treturn 0;\n\t}\n\n\tinquiry_info scan_info_arr[128];\n\tinquiry_info* scan_info = scan_info_arr;\n\tmemset(&scan_info_arr, 0, sizeof(scan_info_arr));\n\n\t/* scan for bluetooth devices for 'timeout' seconds */\n\tfound_devices = hci_inquiry(device_id, timeout, 128, NULL, &scan_info, IREQ_CACHE_FLUSH);\n\tif (found_devices < 0) {\n\t\tperror(\"hci_inquiry\");\n\t\treturn 0;\n\t}\n\n\tWIIUSE_INFO(\"Found %i bluetooth device(s).\", found_devices);\n\n\tint i = 0;\n\n\t/* display discovered devices */\n\tfor (; (i < found_devices) && (found_wiimotes < max_wiimotes); ++i) {\n\t\tif ((scan_info[i].dev_class[0] == WM_DEV_CLASS_0) &&\n\t\t\t(scan_info[i].dev_class[1] == WM_DEV_CLASS_1) &&\n\t\t\t(scan_info[i].dev_class[2] == WM_DEV_CLASS_2))\n\t\t{\n\t\t\t/* found a device */\n\t\t\tba2str(&scan_info[i].bdaddr, wm[found_wiimotes]->bdaddr_str);\n\n\t\t\tWIIUSE_INFO(\"Found wiimote (%s) [id %i].\", wm[found_wiimotes]->bdaddr_str, wm[found_wiimotes]->unid);\n\n\t\t\twm[found_wiimotes]->bdaddr = scan_info[i].bdaddr;\n\t\t\tWIIMOTE_ENABLE_STATE(wm[found_wiimotes], WIIMOTE_STATE_DEV_FOUND);\n\t\t\t++found_wiimotes;\n\t\t}\n\t}\n\n\tclose(device_sock);\n\treturn found_wiimotes;\n}", "path": "src\\io_nix.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Handle nunchuk event.\n *\n *\t@param nc\t\tA pointer to a nunchuk_t structure.\n *\t@param msg\t\tThe message specified in the event packet.\n */\n", "func_signal": "void nunchuk_event(struct nunchuk_t* nc, byte* msg)", "code": "{\n\tint i;\n\n\t/* decrypt data */\n\tfor (i = 0; i < 6; ++i)\n\t\tmsg[i] = (msg[i] ^ 0x17) + 0x17;\n\n\t/* get button states */\n\tnunchuk_pressed_buttons(nc, msg[5]);\n\n\t/* calculate joystick state */\n\tcalc_joystick_state(&nc->js, msg[0], msg[1]);\n\n\t/* calculate orientation */\n\tnc->accel.x = msg[2];\n\tnc->accel.y = msg[3];\n\tnc->accel.z = msg[4];\n\n\tcalculate_orientation(&nc->accel_calib, &nc->accel, &nc->orient, NUNCHUK_IS_FLAG_SET(nc, WIIUSE_SMOOTHING));\n\tcalculate_gforce(&nc->accel_calib, &nc->accel, &nc->gforce);\n}", "path": "src\\nunchuk.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief\tSet the bluetooth stack type to use.\n *\n *\t@param wm\t\tArray of wiimote_t structures.\n *\t@param wiimotes\tNumber of objects in the wm array.\n *\t@param type\t\tThe type of bluetooth stack to use.\n */\n", "func_signal": "void wiiuse_set_bluetooth_stack(struct wiimote_t** wm, int wiimotes, enum win_bt_stack_t type)", "code": "{\n\t#ifdef WIN32\n\tint i;\n\n\tif (!wm)\treturn;\n\n\tfor (i = 0; i < wiimotes; ++i)\n\t\twm[i]->stack = type;\n\t#endif\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief\tRead data from the wiimote (event version).\n *\n *\t@param wm\t\tPointer to a wiimote_t structure.\n *\t@param buffer\tAn allocated buffer to store the data as it arrives from the wiimote.\n *\t\t\t\t\tMust be persistent in memory and large enough to hold the data.\n *\t@param addr\t\tThe address of wiimote memory to read from.\n *\t@param len\t\tThe length of the block to be read.\n *\n *\tThe library can only handle one data read request at a time\n *\tbecause it must keep track of the buffer and other\n *\tevents that are specific to that request.  So if a request\n *\thas already been made, subsequent requests will be added\n *\tto a pending list and be sent out when the previous\n *\tfinishes.\n */\n", "func_signal": "int wiiuse_read_data(struct wiimote_t* wm, byte* buffer, unsigned int addr, unsigned short len)", "code": "{\n\tstruct read_req_t* req;\n\n\tif (!wm || !WIIMOTE_IS_CONNECTED(wm))\n\t\treturn 0;\n\tif (!buffer || !len)\n\t\treturn 0;\n\n\t/* make this request structure */\n\treq = (struct read_req_t*)malloc(sizeof(struct read_req_t));\n\treq->cb = NULL;\n\treq->buf = buffer;\n\treq->addr = addr;\n\treq->size = len;\n\treq->wait = len;\n\treq->dirty = 0;\n\treq->next = NULL;\n\n\t/* add this to the request list */\n\tif (!wm->read_req) {\n\t\t/* root node */\n\t\twm->read_req = req;\n\n\t\tWIIUSE_DEBUG(\"Data read request can be sent out immediately.\");\n\n\t\t/* send the request out immediately */\n\t\twiiuse_send_next_pending_read_request(wm);\n\t} else {\n\t\tstruct read_req_t* nptr = wm->read_req;\n\t\tfor (; nptr->next; nptr = nptr->next);\n\t\tnptr->next = req;\n\n\t\tWIIUSE_DEBUG(\"Added pending data read request.\");\n\t}\n\n\treturn 1;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief\tSet the orientation event threshold.\n *\n *\t@param wm\t\t\tPointer to a wiimote_t structure.\n *\t@param threshold\tThe decimal place that should be considered a significant change.\n *\n *\tIf threshold is 0.01, and any angle changes by 0.01 then a significant change\n *\thas occured and the event callback will be invoked.  If threshold is 1 then\n *\tthe angle has to change by a full degree to generate an event.\n */\n", "func_signal": "void wiiuse_set_orient_threshold(struct wiimote_t* wm, float threshold)", "code": "{\n\tif (!wm)\treturn;\n\n\twm->orient_threshold = threshold;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Initialize an array of wiimote structures.\n *\n *\t@param wiimotes\t\tNumber of wiimote_t structures to create.\n *\n *\t@return An array of initialized wiimote_t structures.\n *\n *\t@see wiiuse_connect()\n *\n *\tThe array returned by this function can be passed to various\n *\tfunctions, including wiiuse_connect().\n */\n", "func_signal": "struct wiimote_t** wiiuse_init(int wiimotes)", "code": "{\n\tint i = 0;\n\tstruct wiimote_t** wm = NULL;\n\n\t/*\n\t *\tPlease do not remove this banner.\n\t *\tGPL asks that you please leave output credits intact.\n\t *\tThank you.\n\t *\n\t *\tThis banner is only displayed once so that if you need\n\t *\tto call this function again it won't be intrusive.\n\t */\n\tif (!g_banner) {\n\t\tprintf(\t\"wiiuse v\" WIIUSE_VERSION \" loaded.\\n\"\n\t\t\t\t\"  By: Michael Laforest <thepara[at]gmail{dot}com>\\n\"\n\t\t\t\t\"  http://wiiuse.net  http://wiiuse.sf.net\\n\");\n\t\tg_banner = 1;\n\t}\n\n\tif (!wiimotes)\n\t\treturn NULL;\n\n\twm = malloc(sizeof(struct wiimote_t*) * wiimotes);\n\n\tfor (i = 0; i < wiimotes; ++i) {\n\t\twm[i] = malloc(sizeof(struct wiimote_t));\n\t\tmemset(wm[i], 0, sizeof(struct wiimote_t));\n\n\t\twm[i]->unid = i+1;\n\n\t\t#ifndef WIN32\n\t\t\twm[i]->bdaddr = *BDADDR_ANY;\n\t\t\twm[i]->out_sock = -1;\n\t\t\twm[i]->in_sock = -1;\n\t\t#else\n\t\t\twm[i]->dev_handle = 0;\n\t\t\twm[i]->stack = WIIUSE_STACK_UNKNOWN;\n\t\t\twm[i]->normal_timeout = WIIMOTE_DEFAULT_TIMEOUT;\n\t\t\twm[i]->exp_timeout = WIIMOTE_EXP_TIMEOUT;\n\t\t\twm[i]->timeout = wm[i]->normal_timeout;\n\t\t#endif\n\n\t\twm[i]->state = WIIMOTE_INIT_STATES;\n\t\twm[i]->flags = WIIUSE_INIT_FLAGS;\n\n\t\twm[i]->event = WIIUSE_NONE;\n\n\t\twm[i]->exp.type = EXP_NONE;\n\n\t\twiiuse_set_aspect_ratio(wm[i], WIIUSE_ASPECT_4_3);\n\t\twiiuse_set_ir_position(wm[i], WIIUSE_IR_ABOVE);\n\n\t\twm[i]->orient_threshold = 0.5f;\n\t\twm[i]->accel_threshold = 5;\n\n\t\twm[i]->accel_calib.st_alpha = WIIUSE_DEFAULT_SMOOTH_ALPHA;\n\t}\n\n\treturn wm;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Calculate the roll, pitch, yaw.\n *\n *\t@param ac\t\t\tAn accelerometer (accel_t) structure.\n *\t@param accel\t\t[in] Pointer to a vec3b_t structure that holds the raw acceleration data.\n *\t@param orient\t\t[out] Pointer to a orient_t structure that will hold the orientation data.\n *\t@param rorient\t\t[out] Pointer to a orient_t structure that will hold the non-smoothed orientation data.\n *\t@param smooth\t\tIf smoothing should be performed on the angles calculated. 1 to enable, 0 to disable.\n *\n *\tGiven the raw acceleration data from the accelerometer struct, calculate\n *\tthe orientation of the device and set it in the \\a orient parameter.\n */\n", "func_signal": "void calculate_orientation(struct accel_t* ac, struct vec3b_t* accel, struct orient_t* orient, int smooth)", "code": "{\n\tfloat xg, yg, zg;\n\tfloat x, y, z;\n\n\t/*\n\t *\troll\t- use atan(z / x)\t\t[ ranges from -180 to 180 ]\n\t *\tpitch\t- use atan(z / y)\t\t[ ranges from -180 to 180 ]\n\t *\tyaw\t\t- impossible to tell without IR\n\t */\n\n\t/* yaw - set to 0, IR will take care of it if it's enabled */\n\torient->yaw = 0.0f;\n\n\t/* find out how much it has to move to be 1g */\n\txg = (float)ac->cal_g.x;\n\tyg = (float)ac->cal_g.y;\n\tzg = (float)ac->cal_g.z;\n\n\t/* find out how much it actually moved and normalize to +/- 1g */\n\tx = ((float)accel->x - (float)ac->cal_zero.x) / xg;\n\ty = ((float)accel->y - (float)ac->cal_zero.y) / yg;\n\tz = ((float)accel->z - (float)ac->cal_zero.z) / zg;\n\n\t/* make sure x,y,z are between -1 and 1 for the tan functions */\n\tif (x < -1.0f)\t\t\tx = -1.0f;\n\telse if (x > 1.0f)\t\tx = 1.0f;\n\tif (y < -1.0f)\t\t\ty = -1.0f;\n\telse if (y > 1.0f)\t\ty = 1.0f;\n\tif (z < -1.0f)\t\t\tz = -1.0f;\n\telse if (z > 1.0f)\t\tz = 1.0f;\n\n\t/* if it is over 1g then it is probably accelerating and not reliable */\n\tif (abs(accel->x - ac->cal_zero.x) <= ac->cal_g.x) {\n\t\t/* roll */\n\t\tx = RAD_TO_DEGREE(atan2f(x, z));\n\n\t\torient->roll = x;\n\t\torient->a_roll = x;\n\t}\n\n\tif (abs(accel->y - ac->cal_zero.y) <= ac->cal_g.y) {\n\t\t/* pitch */\n\t\ty = RAD_TO_DEGREE(atan2f(y, z));\n\n\t\torient->pitch = y;\n\t\torient->a_pitch = y;\n\t}\n\n\t/* smooth the angles if enabled */\n\tif (smooth) {\n\t\tapply_smoothing(ac, orient, SMOOTH_ROLL);\n\t\tapply_smoothing(ac, orient, SMOOTH_PITCH);\n\t}\n}", "path": "src\\dynamics.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Connect to a wiimote with a known address.\n *\n *\t@param wm\t\tPointer to a wiimote_t structure.\n *\t@param address\tThe address of the device to connect to.\n *\t\t\t\t\tIf NULL, use the address in the struct set by wiiuse_find().\n *\n *\t@return 1 on success, 0 on failure\n */\n", "func_signal": "static int wiiuse_connect_single(struct wiimote_t* wm, char* address)", "code": "{\n\tstruct sockaddr_l2 addr;\n\n\tif (!wm || WIIMOTE_IS_CONNECTED(wm))\n\t\treturn 0;\n\n\taddr.l2_family = AF_BLUETOOTH;\n\n\tif (address)\n\t\t/* use provided address */\n\t\tstr2ba(address, &addr.l2_bdaddr);\n\telse\n\t\t/* use address of device discovered */\n\t\taddr.l2_bdaddr = wm->bdaddr;\n\n\t/*\n\t *\tOUTPUT CHANNEL\n\t */\n\twm->out_sock = socket(AF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (wm->out_sock == -1)\n\t\treturn 0;\n\n\taddr.l2_psm = htobs(WM_OUTPUT_CHANNEL);\n\n\t/* connect to wiimote */\n\tif (connect(wm->out_sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"connect() output sock\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tINPUT CHANNEL\n\t */\n\twm->in_sock = socket(AF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (wm->in_sock == -1) {\n\t\tclose(wm->out_sock);\n\t\twm->out_sock = -1;\n\t\treturn 0;\n\t}\n\n\taddr.l2_psm = htobs(WM_INPUT_CHANNEL);\n\n\t/* connect to wiimote */\n\tif (connect(wm->in_sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"connect() interrupt sock\");\n\t\tclose(wm->out_sock);\n\t\twm->out_sock = -1;\n\t\treturn 0;\n\t}\n\n\tWIIUSE_INFO(\"Connected to wiimote [id %i].\", wm->unid);\n\n\t/* do the handshake */\n\tWIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);\n\twiiuse_handshake(wm, NULL, 0);\n\n\twiiuse_set_report_type(wm);\n\n\treturn 1;\n}", "path": "src\\io_nix.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Handle the handshake data from the guitar.\n *\n *\t@param cc\t\tA pointer to a classic_ctrl_t structure.\n *\t@param data\t\tThe data read in from the device.\n *\t@param len\t\tThe length of the data block, in bytes.\n *\n *\t@return\tReturns 1 if handshake was successful, 0 if not.\n */\n", "func_signal": "int guitar_hero_3_handshake(struct wiimote_t* wm, struct guitar_hero_3_t* gh3, byte* data, unsigned short len)", "code": "{\n\tint i;\n\tint offset = 0;\n\n\t/*\n\t *\tThe good fellows that made the Guitar Hero 3 controller\n\t *\tfailed to factory calibrate the devices.  There is no\n\t *\tcalibration data on the device.\n\t */\n\n\tgh3->btns = 0;\n\tgh3->btns_held = 0;\n\tgh3->btns_released = 0;\n\tgh3->whammy_bar = 0.0f;\n\n\t/* decrypt data */\n\tfor (i = 0; i < len; ++i)\n\t\tdata[i] = (data[i] ^ 0x17) + 0x17;\n\n\tif (data[offset] == 0xFF) {\n\t\t/*\n\t\t *\tSometimes the data returned here is not correct.\n\t\t *\tThis might happen because the wiimote is lagging\n\t\t *\tbehind our initialization sequence.\n\t\t *\tTo fix this just request the handshake again.\n\t\t *\n\t\t *\tOther times it's just the first 16 bytes are 0xFF,\n\t\t *\tbut since the next 16 bytes are the same, just use\n\t\t *\tthose.\n\t\t */\n\t\tif (data[offset + 16] == 0xFF) {\n\t\t\t/* get the calibration data */\n\t\t\tbyte* handshake_buf = malloc(EXP_HANDSHAKE_LEN * sizeof(byte));\n\n\t\t\tWIIUSE_DEBUG(\"Guitar Hero 3 handshake appears invalid, trying again.\");\n\t\t\twiiuse_read_data_cb(wm, handshake_expansion, handshake_buf, WM_EXP_MEM_CALIBR, EXP_HANDSHAKE_LEN);\n\n\t\t\treturn 0;\n\t\t} else\n\t\t\toffset += 16;\n\t}\n\n\t/* joystick stuff */\n\tgh3->js.max.x = GUITAR_HERO_3_JS_MAX_X;\n\tgh3->js.min.x = GUITAR_HERO_3_JS_MIN_X;\n\tgh3->js.center.x = GUITAR_HERO_3_JS_CENTER_X;\n\tgh3->js.max.y = GUITAR_HERO_3_JS_MAX_Y;\n\tgh3->js.min.y = GUITAR_HERO_3_JS_MIN_Y;\n\tgh3->js.center.y = GUITAR_HERO_3_JS_CENTER_Y;\n\n\t/* handshake done */\n\twm->exp.type = EXP_GUITAR_HERO_3;\n\n\t#ifdef WIN32\n\twm->timeout = WIIMOTE_DEFAULT_TIMEOUT;\n\t#endif\n\n\treturn 1;\n}", "path": "src\\guitar_hero_3.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Handle classic controller event.\n *\n *\t@param cc\t\tA pointer to a classic_ctrl_t structure.\n *\t@param msg\t\tThe message specified in the event packet.\n */\n", "func_signal": "void classic_ctrl_event(struct classic_ctrl_t* cc, byte* msg)", "code": "{\n\tint i, lx, ly, rx, ry;\n\tbyte l, r;\n\n\t/* decrypt data */\n\tfor (i = 0; i < 6; ++i)\n\t\tmsg[i] = (msg[i] ^ 0x17) + 0x17;\n\n\tclassic_ctrl_pressed_buttons(cc, BIG_ENDIAN_SHORT(*(short*)(msg + 4)));\n\n\t/* left/right buttons */\n\tl = (((msg[2] & 0x60) >> 2) | ((msg[3] & 0xE0) >> 5));\n\tr = (msg[3] & 0x1F);\n\n\t/*\n\t *\tTODO - LR range hardcoded from 0x00 to 0x1F.\n\t *\tThis is probably in the calibration somewhere.\n\t */\n\tcc->r_shoulder = ((float)r / 0x1F);\n\tcc->l_shoulder = ((float)l / 0x1F);\n\n\t/* calculate joystick orientation */\n\tlx = (msg[0] & 0x3F);\n\tly = (msg[1] & 0x3F);\n\trx = ((msg[0] & 0xC0) >> 3) | ((msg[1] & 0xC0) >> 5) | ((msg[2] & 0x80) >> 7);\n\try = (msg[2] & 0x1F);\n\n\tcalc_joystick_state(&cc->ljs, lx, ly);\n\tcalc_joystick_state(&cc->rjs, rx, ry);\n}", "path": "src\\classic.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Set flags for the specified wiimote.\n *\n *\t@param wm\t\t\tPointer to a wiimote_t structure.\n *\t@param enable\t\tFlags to enable.\n *\t@param disable\t\tFlags to disable.\n *\n *\t@return The flags set after 'enable' and 'disable' have been applied.\n *\n *\tThe values 'enable' and 'disable' may be any flags OR'ed together.\n *\tFlags are defined in wiiuse.h.\n */\n", "func_signal": "int wiiuse_set_flags(struct wiimote_t* wm, int enable, int disable)", "code": "{\n\tif (!wm)\treturn 0;\n\n\t/* remove mutually exclusive flags */\n\tenable &= ~disable;\n\tdisable &= ~enable;\n\n\twm->flags |= enable;\n\twm->flags &= ~disable;\n\n\treturn wm->flags;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Disconnect a wiimote.\n *\n *\t@param wm\t\tPointer to a wiimote_t structure.\n *\n *\t@see wiiuse_connect()\n *\n *\tNote that this will not free the wiimote structure.\n */\n", "func_signal": "void wiiuse_disconnect(struct wiimote_t* wm)", "code": "{\n\tif (!wm || WIIMOTE_IS_CONNECTED(wm))\n\t\treturn;\n\n\tclose(wm->out_sock);\n\tclose(wm->in_sock);\n\n\twm->out_sock = -1;\n\twm->in_sock = -1;\n\twm->event = WIIUSE_NONE;\n\n\tWIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_CONNECTED);\n\tWIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_HANDSHAKE);\n}", "path": "src\\io_nix.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief\tEnable or disable the rumble.\n *\n *\t@param wm\t\tPointer to a wiimote_t structure.\n *\t@param status\t1 to enable, 0 to disable.\n */\n", "func_signal": "void wiiuse_rumble(struct wiimote_t* wm, int status)", "code": "{\n\tbyte buf;\n\n\tif (!wm || !WIIMOTE_IS_CONNECTED(wm))\n\t\treturn;\n\n\t/* make sure to keep the current lit leds */\n\tbuf = wm->leds;\n\n\tif (status) {\n\t\tWIIUSE_DEBUG(\"Starting rumble...\");\n\t\tWIIMOTE_ENABLE_STATE(wm, WIIMOTE_STATE_RUMBLE);\n\t\tbuf |= 0x01;\n\t} else {\n\t\tWIIUSE_DEBUG(\"Stopping rumble...\");\n\t\tWIIMOTE_DISABLE_STATE(wm, WIIMOTE_STATE_RUMBLE);\n\t}\n\n\t/* preserve IR state */\n\tif (WIIMOTE_IS_SET(wm, WIIMOTE_STATE_IR))\n\t\tbuf |= 0x04;\n\n\twiiuse_send(wm, WM_CMD_RUMBLE, &buf, 1);\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Calculate the gravity forces on each axis.\n *\n *\t@param ac\t\t\tAn accelerometer (accel_t) structure.\n *\t@param accel\t\t[in] Pointer to a vec3b_t structure that holds the raw acceleration data.\n *\t@param gforce\t\t[out] Pointer to a gforce_t structure that will hold the gravity force data.\n */\n", "func_signal": "void calculate_gforce(struct accel_t* ac, struct vec3b_t* accel, struct gforce_t* gforce)", "code": "{\n\tfloat xg, yg, zg;\n\n\t/* find out how much it has to move to be 1g */\n\txg = (float)ac->cal_g.x;\n\tyg = (float)ac->cal_g.y;\n\tzg = (float)ac->cal_g.z;\n\n\t/* find out how much it actually moved and normalize to +/- 1g */\n\tgforce->x = ((float)accel->x - (float)ac->cal_zero.x) / xg;\n\tgforce->y = ((float)accel->y - (float)ac->cal_zero.y) / yg;\n\tgforce->z = ((float)accel->z - (float)ac->cal_zero.z) / zg;\n}", "path": "src\\dynamics.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Set the wiimote smoothing alpha value.\n *\n *\t@param wm\t\t\tPointer to a wiimote_t structure.\n *\t@param alpha\t\tThe alpha value to set. Between 0 and 1.\n *\n *\t@return Returns the old alpha value.\n *\n *\tThe alpha value is between 0 and 1 and is used in an exponential\n *\tsmoothing algorithm.\n *\n *\tSmoothing is only performed if the WIIMOTE_USE_SMOOTHING is set.\n */\n", "func_signal": "float wiiuse_set_smooth_alpha(struct wiimote_t* wm, float alpha)", "code": "{\n\tfloat old;\n\n\tif (!wm)\treturn 0.0f;\n\n\told = wm->accel_calib.st_alpha;\n\n\twm->accel_calib.st_alpha = alpha;\n\n\t/* if there is a nunchuk set that too */\n\tif (wm->exp.type == EXP_NUNCHUK)\n\t\twm->exp.nunchuk.accel_calib.st_alpha = alpha;\n\n\treturn old;\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief\tToggle the state of the rumble.\n *\n *\t@param wm\t\tPointer to a wiimote_t structure.\n */\n", "func_signal": "void wiiuse_toggle_rumble(struct wiimote_t* wm)", "code": "{\n\tif (!wm)\treturn;\n\n\twiiuse_rumble(wm, !WIIMOTE_IS_SET(wm, WIIMOTE_STATE_RUMBLE));\n}", "path": "src\\wiiuse.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Connect to a wiimote or wiimotes once an address is known.\n *\n *\t@param wm\t\t\tAn array of wiimote_t structures.\n *\t@param wiimotes\t\tThe number of wiimote structures in \\a wm.\n *\n *\t@return The number of wiimotes that successfully connected.\n *\n *\t@see wiiuse_find()\n *\t@see wiiuse_connect_single()\n *\t@see wiiuse_disconnect()\n *\n *\tConnect to a number of wiimotes when the address is already set\n *\tin the wiimote_t structures.  These addresses are normally set\n *\tby the wiiuse_find() function, but can also be set manually.\n */\n", "func_signal": "int wiiuse_connect(struct wiimote_t** wm, int wiimotes)", "code": "{\n\tint connected = 0;\n\tint i = 0;\n\n\tfor (; i < wiimotes; ++i) {\n\t\tif (!WIIMOTE_IS_SET(wm[i], WIIMOTE_STATE_DEV_FOUND))\n\t\t\t/* if the device address is not set, skip it */\n\t\t\tcontinue;\n\n\t\tif (wiiuse_connect_single(wm[i], NULL))\n\t\t\t++connected;\n\t}\n\n\treturn connected;\n}", "path": "src\\io_nix.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "/**\n *\t@brief Calculate the angle and magnitude of a joystick.\n *\n *\t@param js\t[out] Pointer to a joystick_t structure.\n *\t@param x\tThe raw x-axis value.\n *\t@param y\tThe raw y-axis value.\n */\n", "func_signal": "void calc_joystick_state(struct joystick_t* js, float x, float y)", "code": "{\n\tfloat rx, ry, ang;\n\n\t/*\n\t *\tSince the joystick center may not be exactly:\n\t *\t\t(min + max) / 2\n\t *\tThen the range from the min to the center and the center to the max\n\t *\tmay be different.\n\t *\tBecause of this, depending on if the current x or y value is greater\n\t *\tor less than the assoicated axis center value, it needs to be interpolated\n\t *\tbetween the center and the minimum or maxmimum rather than between\n\t *\tthe minimum and maximum.\n\t *\n\t *\tSo we have something like this:\n\t *\t\t(x min) [-1] ---------*------ [0] (x center) [0] -------- [1] (x max)\n\t *\tWhere the * is the current x value.\n\t *\tThe range is therefore -1 to 1, 0 being the exact center rather than\n\t *\tthe middle of min and max.\n\t */\n\tif (x == js->center.x)\n\t\trx = 0;\n\telse if (x >= js->center.x)\n\t\trx = ((float)(x - js->center.x) / (float)(js->max.x - js->center.x));\n\telse\n\t\trx = ((float)(x - js->min.x) / (float)(js->center.x - js->min.x)) - 1.0f;\n\n\tif (y == js->center.y)\n\t\try = 0;\n\telse if (y >= js->center.y)\n\t\try = ((float)(y - js->center.y) / (float)(js->max.y - js->center.y));\n\telse\n\t\try = ((float)(y - js->min.y) / (float)(js->center.y - js->min.y)) - 1.0f;\n\n\t/* calculate the joystick angle and magnitude */\n\tang = RAD_TO_DEGREE(atanf(ry / rx));\n\tang -= 90.0f;\n\tif (rx < 0.0f)\n\t\tang -= 180.0f;\n\tjs->ang = absf(ang);\n\tjs->mag = (float) sqrt((rx * rx) + (ry * ry));\n}", "path": "src\\dynamics.c", "repo_name": "sergei/wiiuse", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 185}
{"docstring": "//\n// G_Ticker\n// Make ticcmd_ts for the players.\n//\n", "func_signal": "void G_Ticker (void)", "code": "{ \n    int\t\ti;\n    int\t\tbuf; \n    ticcmd_t*\tcmd;\n    \n    // do player reborns if needed\n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tif (playeringame[i] && players[i].playerstate == PST_REBORN) \n\t    G_DoReborn (i);\n    \n    // do things to change the game state\n    while (gameaction != ga_nothing) \n    { \n\tswitch (gameaction) \n\t{ \n\t  case ga_loadlevel: \n\t    G_DoLoadLevel (); \n\t    break; \n\t  case ga_newgame: \n\t    G_DoNewGame (); \n\t    break; \n\t  case ga_loadgame: \n\t    G_DoLoadGame (); \n\t    break; \n\t  case ga_savegame: \n\t    G_DoSaveGame (); \n\t    break; \n\t  case ga_playdemo: \n\t    G_DoPlayDemo (); \n\t    break; \n\t  case ga_completed: \n\t    G_DoCompleted (); \n\t    break; \n\t  case ga_victory: \n\t    F_StartFinale (); \n\t    break; \n\t  case ga_worlddone: \n\t    G_DoWorldDone (); \n\t    break; \n\t  case ga_screenshot: \n\t    M_ScreenShot (); \n\t    gameaction = ga_nothing; \n\t    break; \n\t  case ga_nothing: \n\t    break; \n\t} \n    }\n    \n    // get commands, check consistancy,\n    // and build new consistancy check\n    buf = (gametic/ticdup)%BACKUPTICS; \n \n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    cmd = &players[i].cmd; \n \n\t    memcpy (cmd, &netcmds[i][buf], sizeof(ticcmd_t)); \n \n\t    if (demoplayback) \n\t\tG_ReadDemoTiccmd (cmd); \n\t    if (demorecording) \n\t\tG_WriteDemoTiccmd (cmd);\n\t    \n\t    // check for turbo cheats\n\t    if (cmd->forwardmove > TURBOTHRESHOLD \n\t\t&& !(gametic&31) && ((gametic>>5)&3) == i )\n\t    {\n\t\tstatic char turbomessage[80];\n\t\textern char *player_names[4];\n\t\tsprintf (turbomessage, \"%s is turbo!\",player_names[i]);\n\t\tplayers[consoleplayer].message = turbomessage;\n\t    }\n\t\t\t\n\t    if (netgame && !netdemo && !(gametic%ticdup) ) \n\t    { \n\t\tif (gametic > BACKUPTICS \n\t\t    && consistancy[i][buf] != cmd->consistancy) \n\t\t{ \n\t\t    I_Error (\"consistency failure (%i should be %i)\",\n\t\t\t     cmd->consistancy, consistancy[i][buf]); \n\t\t} \n\t\tif (players[i].mo) \n\t\t    consistancy[i][buf] = players[i].mo->x; \n\t\telse \n\t\t    consistancy[i][buf] = rndindex; \n\t    } \n\t}\n    }\n    \n    // check for special buttons\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]) \n\t{ \n\t    if (players[i].cmd.buttons & BT_SPECIAL) \n\t    { \n\t\tswitch (players[i].cmd.buttons & BT_SPECIALMASK) \n\t\t{ \n\t\t  case BTS_PAUSE: \n\t\t    paused ^= 1; \n\t\t    if (paused) \n\t\t\tS_PauseSound (); \n\t\t    else \n\t\t\tS_ResumeSound (); \n\t\t    break; \n\t\t\t\t\t \n\t\t  case BTS_SAVEGAME: \n\t\t    if (!savedescription[0]) \n\t\t\tstrcpy (savedescription, \"NET GAME\"); \n\t\t    savegameslot =  \n\t\t\t(players[i].cmd.buttons & BTS_SAVEMASK)>>BTS_SAVESHIFT; \n\t\t    gameaction = ga_savegame; \n\t\t    break; \n\t\t} \n\t    } \n\t}\n    }\n    \n    // do main actions\n    switch (gamestate) \n    { \n      case GS_LEVEL: \n\tP_Ticker (); \n\tST_Ticker (); \n\tAM_Ticker (); \n\tHU_Ticker ();            \n\tbreak; \n\t \n      case GS_INTERMISSION: \n\tWI_Ticker (); \n\tbreak; \n\t\t\t \n      case GS_FINALE: \n\tF_Ticker (); \n\tbreak; \n \n      case GS_DEMOSCREEN: \n\tD_PageTicker (); \n\tbreak; \n    }        \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// TELEPORTATION\n//\n", "func_signal": "int\nEV_Teleport\n( line_t*\tline,\n  int\t\tside,\n  mobj_t*\tthing )", "code": "{\n    int\t\ti;\n    int\t\ttag;\n    mobj_t*\tm;\n    mobj_t*\tfog;\n    unsigned\tan;\n    thinker_t*\tthinker;\n    sector_t*\tsector;\n    fixed_t\toldx;\n    fixed_t\toldy;\n    fixed_t\toldz;\n\n    // don't teleport missiles\n    if (thing->flags & MF_MISSILE)\n\treturn 0;\t\t\n\n    // Don't teleport if hit back of line,\n    //  so you can get out of teleporter.\n    if (side == 1)\t\t\n\treturn 0;\t\n\n    \n    tag = line->tag;\n    for (i = 0; i < numsectors; i++)\n    {\n\tif (sectors[ i ].tag == tag )\n\t{\n\t    thinker = thinkercap.next;\n\t    for (thinker = thinkercap.next;\n\t\t thinker != &thinkercap;\n\t\t thinker = thinker->next)\n\t    {\n\t\t// not a mobj\n\t\tif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\n\t\t    continue;\t\n\n\t\tm = (mobj_t *)thinker;\n\t\t\n\t\t// not a teleportman\n\t\tif (m->type != MT_TELEPORTMAN )\n\t\t    continue;\t\t\n\n\t\tsector = m->subsector->sector;\n\t\t// wrong sector\n\t\tif (sector-sectors != i )\n\t\t    continue;\t\n\n\t\toldx = thing->x;\n\t\toldy = thing->y;\n\t\toldz = thing->z;\n\t\t\t\t\n\t\tif (!P_TeleportMove (thing, m->x, m->y))\n\t\t    return 0;\n\t\t\n\t\tthing->z = thing->floorz;  //fixme: not needed?\n\t\tif (thing->player)\n\t\t    thing->player->viewz = thing->z+thing->player->viewheight;\n\t\t\t\t\n\t\t// spawn teleport fog at source and destination\n\t\tfog = P_SpawnMobj (oldx, oldy, oldz, MT_TFOG);\n\t\tS_StartSound (fog, sfx_telept);\n\t\tan = m->angle >> ANGLETOFINESHIFT;\n\t\tfog = P_SpawnMobj (m->x+20*finecosine[an], m->y+20*finesine[an]\n\t\t\t\t   , thing->z, MT_TFOG);\n\n\t\t// emit sound, where?\n\t\tS_StartSound (fog, sfx_telept);\n\t\t\n\t\t// don't move for a bit\n\t\tif (thing->player)\n\t\t    thing->reactiontime = 18;\t\n\n\t\tthing->angle = m->angle;\n\t\tthing->momx = thing->momy = thing->momz = 0;\n\t\treturn 1;\n\t    }\t\n\t}\n    }\n    return 0;\n}", "path": "p_telept.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_DeathMatchSpawnPlayer \n// Spawns a player at one of the random death match spots \n// called at level load and each death \n//\n", "func_signal": "void G_DeathMatchSpawnPlayer (int playernum)", "code": "{ \n    int             i,j; \n    int\t\t\t\tselections; \n\t \n    selections = deathmatch_p - deathmatchstarts; \n    if (selections < 4) \n\tI_Error (\"Only %i deathmatch spots, 4 required\", selections); \n \n    for (j=0 ; j<20 ; j++) \n    { \n\ti = P_Random() % selections; \n\tif (G_CheckSpot (playernum, &deathmatchstarts[i]) ) \n\t{ \n\t    deathmatchstarts[i].type = playernum+1; \n\t    P_SpawnPlayer (&deathmatchstarts[i]); \n\t    return; \n\t} \n    } \n \n    // no good spot, so the player will probably get stuck \n    P_SpawnPlayer (&playerstarts[playernum]); \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "// Here's for the german edition.\n", "func_signal": "void G_SecretExitLevel (void)", "code": "{ \n    // IF NO WOLF3D LEVELS, NO SECRET EXIT!\n    if ( (gamemode == commercial)\n      && (W_CheckNumForName(\"map31\")<0))\n\tsecretexit = false;\n    else\n\tsecretexit = true; \n    gameaction = ga_completed; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// EV_DoLockedDoor\n// Move a locked door up/down\n//\n", "func_signal": "int\nEV_DoLockedDoor\n( line_t*\tline,\n  vldoor_e\ttype,\n  mobj_t*\tthing )", "code": "{\n    player_t*\tp;\n\t\n    p = thing->player;\n\t\n    if (!p)\n\treturn 0;\n\t\t\n    switch(line->special)\n    {\n      case 99:\t// Blue Lock\n      case 133:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_bluecard] && !p->cards[it_blueskull])\n\t{\n\t    p->message = PD_BLUEO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 134: // Red Lock\n      case 135:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_redcard] && !p->cards[it_redskull])\n\t{\n\t    p->message = PD_REDO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 136:\t// Yellow Lock\n      case 137:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_yellowcard] &&\n\t    !p->cards[it_yellowskull])\n\t{\n\t    p->message = PD_YELLOWO;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\t\n    }\n\n    return EV_DoDoor(line,type);\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// Spawn a door that opens after 5 minutes\n//\n", "func_signal": "void\nP_SpawnDoorRaiseIn5Mins\n( sector_t*\tsec,\n  int\t\tsecnum )", "code": "{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n    \n    P_AddThinker (&door->thinker);\n\n    sec->specialdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 2;\n    door->type = raiseIn5Mins;\n    door->speed = VDOORSPEED;\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n    door->topwait = VDOORWAIT;\n    door->topcountdown = 5 * 60 * 35;\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_SaveGame\n// Called by the menu task.\n// Description is a 24 byte text string \n//\n", "func_signal": "void\nG_SaveGame\n( int\tslot,\n  char*\tdescription )", "code": "{ \n    savegameslot = slot; \n    strcpy (savedescription, description); \n    sendsave = true; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_RecordDemo \n// \n", "func_signal": "void G_RecordDemo (char* name)", "code": "{ \n    int             i; \n    int\t\t\t\tmaxsize;\n\t\n    usergame = false; \n    strcpy (demoname, name); \n    strcat (demoname, \".lmp\"); \n    maxsize = 0x20000;\n    i = M_CheckParm (\"-maxdemo\");\n    if (i && i<myargc-1)\n\tmaxsize = atoi(myargv[i+1])*1024;\n    demobuffer = Z_Malloc (maxsize,PU_STATIC,NULL); \n    demoend = demobuffer + maxsize;\n\t\n    demorecording = true; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// EV_VerticalDoor : open a door manually, no tag value\n//\n", "func_signal": "void\nEV_VerticalDoor\n( line_t*\tline,\n  mobj_t*\tthing )", "code": "{\n    player_t*\tplayer;\n    int\t\tsecnum;\n    sector_t*\tsec;\n    vldoor_t*\tdoor;\n    int\t\tside;\n\t\n    side = 0;\t// only front sides can be used\n\n    //\tCheck for locks\n    player = thing->player;\n\t\t\n    switch(line->special)\n    {\n      case 26: // Blue Lock\n      case 32:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_bluecard] && !player->cards[it_blueskull])\n\t{\n\t    player->message = PD_BLUEK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 27: // Yellow Lock\n      case 34:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_yellowcard] &&\n\t    !player->cards[it_yellowskull])\n\t{\n\t    player->message = PD_YELLOWK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 28: // Red Lock\n      case 33:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_redcard] && !player->cards[it_redskull])\n\t{\n\t    player->message = PD_REDK;\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n    }\n\t\n    // if the sector has an active thinker, use it\n    sec = sides[ line->sidenum[side^1]] .sector;\n    secnum = sec-sectors;\n\n    if (sec->specialdata)\n    {\n\tdoor = sec->specialdata;\n\tswitch(line->special)\n\t{\n\t  case\t1: // ONLY FOR \"RAISE\" DOORS, NOT \"OPEN\"s\n\t  case\t26:\n\t  case\t27:\n\t  case\t28:\n\t  case\t117:\n\t    if (door->direction == -1)\n\t\tdoor->direction = 1;\t// go back up\n\t    else\n\t    {\n\t\tif (!thing->player)\n\t\t    return;\t\t// JDC: bad guys never close doors\n\t\t\n\t\tdoor->direction = -1;\t// start going down immediately\n\t    }\n\t    return;\n\t}\n    }\n\t\n    // for proper sound\n    switch(line->special)\n    {\n      case 117:\t// BLAZING DOOR RAISE\n      case 118:\t// BLAZING DOOR OPEN\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_bdopn);\n\tbreak;\n\t\n      case 1:\t// NORMAL DOOR SOUND\n      case 31:\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_doropn);\n\tbreak;\n\t\n      default:\t// LOCKED DOOR SOUND\n\tS_StartSound((mobj_t *)&sec->soundorg,sfx_doropn);\n\tbreak;\n    }\n\t\n    \n    // new door thinker\n    door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n    P_AddThinker (&door->thinker);\n    sec->specialdata = door;\n    door->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 1;\n    door->speed = VDOORSPEED;\n    door->topwait = VDOORWAIT;\n\n    switch(line->special)\n    {\n      case 1:\n      case 26:\n      case 27:\n      case 28:\n\tdoor->type = normal;\n\tbreak;\n\t\n      case 31:\n      case 32:\n      case 33:\n      case 34:\n\tdoor->type = open;\n\tline->special = 0;\n\tbreak;\n\t\n      case 117:\t// blazing door raise\n\tdoor->type = blazeRaise;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n      case 118:\t// blazing door open\n\tdoor->type = blazeOpen;\n\tline->special = 0;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n    }\n    \n    // find the top and bottom of the movement range\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_PlayerReborn\n// Called after a player dies \n// almost everything is cleared and initialized \n//\n", "func_signal": "void G_PlayerReborn (int player)", "code": "{ \n    player_t*\tp; \n    int\t\ti; \n    int\t\tfrags[MAXPLAYERS]; \n    int\t\tkillcount;\n    int\t\titemcount;\n    int\t\tsecretcount; \n\t \n    memcpy (frags,players[player].frags,sizeof(frags)); \n    killcount = players[player].killcount; \n    itemcount = players[player].itemcount; \n    secretcount = players[player].secretcount; \n\t \n    p = &players[player]; \n    memset (p, 0, sizeof(*p)); \n \n    memcpy (players[player].frags, frags, sizeof(players[player].frags)); \n    players[player].killcount = killcount; \n    players[player].itemcount = itemcount; \n    players[player].secretcount = secretcount; \n \n    p->usedown = p->attackdown = true;\t// don't do anything immediately \n    p->playerstate = PST_LIVE;       \n    p->health = MAXHEALTH; \n    p->readyweapon = p->pendingweapon = wp_pistol; \n    p->weaponowned[wp_fist] = true; \n    p->weaponowned[wp_pistol] = true; \n    p->ammo[am_clip] = 50; \n\t \n    for (i=0 ; i<NUMAMMO ; i++) \n\tp->maxammo[i] = maxammo[i]; \n\t\t \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_DoReborn \n// \n", "func_signal": "void G_DoReborn (int playernum)", "code": "{ \n    int                             i; \n\t \n    if (!netgame)\n    {\n\t// reload the level from scratch\n\tgameaction = ga_loadlevel;  \n    }\n    else \n    {\n\t// respawn at the start\n\n\t// first dissasociate the corpse \n\tplayers[playernum].mo->player = NULL;   \n\t\t \n\t// spawn at random spot if in death match \n\tif (deathmatch) \n\t{ \n\t    G_DeathMatchSpawnPlayer (playernum); \n\t    return; \n\t} \n\t\t \n\tif (G_CheckSpot (playernum, &playerstarts[playernum]) ) \n\t{ \n\t    P_SpawnPlayer (&playerstarts[playernum]); \n\t    return; \n\t}\n\t\n\t// try to spawn at one of the other players spots \n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (G_CheckSpot (playernum, &playerstarts[i]) ) \n\t    { \n\t\tplayerstarts[i].type = playernum+1;\t// fake as other player \n\t\tP_SpawnPlayer (&playerstarts[i]); \n\t\tplayerstarts[i].type = i+1;\t\t// restore \n\t\treturn; \n\t    }\t    \n\t    // he's going to be inside something.  Too bad.\n\t}\n\tP_SpawnPlayer (&playerstarts[playernum]); \n    } \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_PlayerFinishLevel\n// Can when a player completes a level.\n//\n", "func_signal": "void G_PlayerFinishLevel (int player)", "code": "{ \n    player_t*\tp; \n\t \n    p = &players[player]; \n\t \n    memset (p->powers, 0, sizeof (p->powers)); \n    memset (p->cards, 0, sizeof (p->cards)); \n    p->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility \n    p->extralight = 0;\t\t\t// cancel gun flashes \n    p->fixedcolormap = 0;\t\t// cancel ir gogles \n    p->damagecount = 0;\t\t\t// no palette changes \n    p->bonuscount = 0; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// Spawn a door that closes after 30 seconds\n//\n", "func_signal": "void P_SpawnDoorCloseIn30 (sector_t* sec)", "code": "{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\n    P_AddThinker (&door->thinker);\n\n    sec->specialdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 0;\n    door->type = normal;\n    door->speed = VDOORSPEED;\n    door->topcountdown = 30 * 35;\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_WorldDone \n//\n", "func_signal": "void G_WorldDone (void)", "code": "{ \n    gameaction = ga_worlddone; \n\n    if (secretexit) \n\tplayers[consoleplayer].didsecret = true; \n\n    if ( gamemode == commercial )\n    {\n\tswitch (gamemap)\n\t{\n\t  case 15:\n\t  case 31:\n\t    if (!secretexit)\n\t\tbreak;\n\t  case 6:\n\t  case 11:\n\t  case 20:\n\t  case 30:\n\t    F_StartFinale ();\n\t    break;\n\t}\n    }\n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// Return index into \"slideFrames\" array\n// for which door type to use\n//\n", "func_signal": "int P_FindSlidingDoorType(line_t*\tline)", "code": "{\n    int\t\ti;\n    int\t\tval;\n\t\n    for (i = 0;i < MAXSLIDEDOORS;i++)\n    {\n\tval = sides[line->sidenum[0]].midtexture;\n\tif (val == slideFrames[i].frontFrames[0])\n\t    return i;\n    }\n\t\n    return -1;\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// T_VerticalDoor\n//\n", "func_signal": "void T_VerticalDoor (vldoor_t* door)", "code": "{\n    result_e\tres;\n\t\n    switch(door->direction)\n    {\n      case 0:\n\t// WAITING\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_dorcls);\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 1;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 2:\n\t//  INITIAL WAIT\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case raiseIn5Mins:\n\t\tdoor->direction = 1;\n\t\tdoor->type = normal;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case -1:\n\t// DOWN\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->sector->floorheight,\n\t\t\t  false,1,door->direction);\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case blazeClose:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t      case close:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 0;\n\t\tdoor->topcountdown = 35*30;\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\telse if (res == crushed)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeClose:\n\t      case close:\t\t// DO NOT GO BACK UP!\n\t\tbreak;\n\t\t\n\t      default:\n\t\tdoor->direction = 1;\n\t\tS_StartSound((mobj_t *)&door->sector->soundorg,\n\t\t\t     sfx_doropn);\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 1:\n\t// UP\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->topheight,\n\t\t\t  false,1,door->direction);\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case normal:\n\t\tdoor->direction = 0; // wait at top\n\t\tdoor->topcountdown = door->topwait;\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t      case blazeOpen:\n\t      case open:\n\t\tdoor->sector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n    }\n}", "path": "p_doors.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_TimeDemo \n//\n", "func_signal": "void G_TimeDemo (char* name)", "code": "{ \t \n    nodrawers = M_CheckParm (\"-nodraw\"); \n    noblit = M_CheckParm (\"-noblit\"); \n    timingdemo = true; \n    singletics = true; \n\n    defdemoname = name; \n    gameaction = ga_playdemo; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_BuildTiccmd\n// Builds a ticcmd from all of the available inputs\n// or reads it from the demo buffer. \n// If recording a demo, write it out \n// \n", "func_signal": "void G_BuildTiccmd (ticcmd_t* cmd)", "code": "{ \n    int\t\ti; \n    boolean\tstrafe;\n    boolean\tbstrafe; \n    int\t\tspeed;\n    int\t\ttspeed; \n    int\t\tforward;\n    int\t\tside;\n\n    ticcmd_t*\tbase;\n\n    base = I_BaseTiccmd ();\t\t// empty, or external driver\n    memcpy (cmd,base,sizeof(*cmd)); \n\t\n    cmd->consistancy = \n\tconsistancy[consoleplayer][maketic%BACKUPTICS]; \n\n \n    strafe = gamekeydown[key_strafe] || mousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    speed = gamekeydown[key_speed] || joybuttons[joybspeed];\n \n    forward = side = 0;\n    \n    // use two stage accelerative turning\n    // on the keyboard and joystick\n    if (joyxmove < 0\n\t|| joyxmove > 0  \n\t|| gamekeydown[key_right]\n\t|| gamekeydown[key_left]) \n\tturnheld += ticdup; \n    else \n\tturnheld = 0; \n\n    if (turnheld < SLOWTURNTICS) \n\ttspeed = 2;             // slow turn \n    else \n\ttspeed = speed;\n    \n    // let movement keys cancel each other out\n    if (strafe) \n    { \n;\n\tif (gamekeydown[key_right]) \n\t{\n\t    // fprintf(stderr, \"strafe right\\n\");\n\t    side += sidemove[speed];   \n\t}\n\tif (gamekeydown[key_left]) \n\t{\n\t    //\tfprintf(stderr, \"strafe left\\n\");\n\t    side -= sidemove[speed];\n\t}\n\tif (joyxmove > 0) \n\t    side += sidemove[speed]; \n\tif (joyxmove < 0) \n\t    side -= sidemove[speed]; \n \n    } \n    else \n    {\n      \n\tif (gamekeydown[key_right]){ \n\t    cmd->angleturn -= angleturn[tspeed]; \n\t}\n\tif (gamekeydown[key_left]){ \n\t    cmd->angleturn += angleturn[tspeed];\n\t}\n\tif (joyxmove > 0) \n\t    cmd->angleturn -= angleturn[tspeed]; \n\tif (joyxmove < 0) \n\t    cmd->angleturn += angleturn[tspeed]; \n    } \n\n    if (gamekeydown[key_up]) \n    {\n\t// fprintf(stderr, \"up\\n\");\n\tforward += forwardmove[speed]; \n    }\n    if (gamekeydown[key_down]) \n    {\n\t// fprintf(stderr, \"down\\n\");\n\tforward -= forwardmove[speed]; \n    }\n    \n    if (joyymove < 0){ \n\tforward += forwardmove[speed];\n    }\n    if (joyymove > 0){ \n\tforward -= forwardmove[speed];\n    }\n    if (gamekeydown[key_straferight]){\n\tside += sidemove[speed];\t\n    }\nboolean Sleft = false;\t  \n    if (gamekeydown[key_strafeleft]){ \n\tside -= sidemove[speed];\n\tSleft = true;\n    }\n    \n    // buttons\n    cmd->chatchar = HU_dequeueChatChar(); \n \n    if (gamekeydown[key_fire] || mousebuttons[mousebfire] \n\t|| joybuttons[joybfire]){ \n\tcmd->buttons |= BT_ATTACK; \n    }\n    \n    if (gamekeydown[key_use] || joybuttons[joybuse] ) \n    { \n\tcmd->buttons |= BT_USE;\n\t// clear double clicks if hit use button \n\tdclicks = 0;                   \n    } \n\n    // chainsaw overrides\n    // weapon changing keycode\n    // Reggie added this code to scroll through the weapons\n    // instead of needing the weapon number\n     if (gamekeydown['h']){\n     currweap = currweap + 1;\n     \tif (currweap>(NUMWEAPONS-1)){\n    \tcurrweap=0;\n    \t}\n     \tcmd->buttons |= BT_CHANGE; \n    \tcmd->buttons |= currweap<<BT_WEAPONSHIFT; \n     }\n    // end of added code\n    for (i=0 ; i<NUMWEAPONS-1 ; i++)        \n\tif (gamekeydown['1'+i]) \n\t{ \n\t    cmd->buttons |= BT_CHANGE; \n\t    cmd->buttons |= i<<BT_WEAPONSHIFT; \n\t    break; \n\t}\n    \n    // mouse\n    if (mousebuttons[mousebforward]) \n\tforward += forwardmove[speed];\n    \n    // forward double click\n    if (mousebuttons[mousebforward] != dclickstate && dclicktime > 1 ) \n    { \n\tdclickstate = mousebuttons[mousebforward]; \n\tif (dclickstate) \n\t    dclicks++; \n\tif (dclicks == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks = 0; \n\t} \n\telse \n\t    dclicktime = 0; \n    } \n    else \n    { \n\tdclicktime += ticdup; \n\tif (dclicktime > 20) \n\t{ \n\t    dclicks = 0; \n\t    dclickstate = 0; \n\t} \n    }\n    \n    // strafe double click\n    bstrafe =\n\tmousebuttons[mousebstrafe] \n\t|| joybuttons[joybstrafe]; \n    if (bstrafe != dclickstate2 && dclicktime2 > 1 ) \n    { \n\tdclickstate2 = bstrafe; \n\tif (dclickstate2) \n\t    dclicks2++; \n\tif (dclicks2 == 2) \n\t{ \n\t    cmd->buttons |= BT_USE; \n\t    dclicks2 = 0; \n\t} \n\telse \n\t    dclicktime2 = 0; \n    } \n    else \n    { \n\tdclicktime2 += ticdup; \n\tif (dclicktime2 > 20) \n\t{ \n\t    dclicks2 = 0; \n\t    dclickstate2 = 0; \n\t} \n    } \n \n    forward += mousey; \n    if (strafe) \n\tside += mousex*2; \n    else \n\tcmd->angleturn -= mousex*0x8; \n\n    mousex = mousey = 0; \n\t \n    if (forward > MAXPLMOVE) \n\tforward = MAXPLMOVE; \n    else if (forward < -MAXPLMOVE) \n\tforward = -MAXPLMOVE; \n    if (side > MAXPLMOVE) \n\tside = MAXPLMOVE; \n    else if (side < -MAXPLMOVE) \n\tside = -MAXPLMOVE; \n \n   \n    cmd->forwardmove += forward;\n    cmd->sidemove += side;\n    \n    // special buttons\n    if (sendpause) \n    { \n\tsendpause = false; \n\tcmd->buttons = BT_SPECIAL | BTS_PAUSE; \n    } \n \n    if (sendsave) \n    { \n\tsendsave = false; \n\tcmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (savegameslot<<BTS_SAVESHIFT); \n    } \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_InitPlayer \n// Called at the start.\n// Called by the game initialization functions.\n//\n", "func_signal": "void G_InitPlayer (int player)", "code": "{ \n    player_t*\tp; \n \n    // set up the saved info         \n    p = &players[player]; \n\t \n    // clear everything else to defaults \n    G_PlayerReborn (player); \n\t \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "//\n// G_Responder  \n// Get info needed to make ticcmd_ts for the players.\n// \n", "func_signal": "boolean G_Responder (event_t* ev)", "code": "{ \n    // allow spy mode changes even during the demo\n    if (gamestate == GS_LEVEL && ev->type == ev_keydown \n\t&& ev->data1 == KEY_F12 && (singledemo || !deathmatch) )\n    {\n\t// spy mode \n\tdo \n\t{ \n\t    displayplayer++; \n\t    if (displayplayer == MAXPLAYERS) \n\t\tdisplayplayer = 0; \n\t} while (!playeringame[displayplayer] && displayplayer != consoleplayer); \n\treturn true; \n    }\n    \n    // any other key pops up menu if in demos\n    if (gameaction == ga_nothing && !singledemo && \n\t(demoplayback || gamestate == GS_DEMOSCREEN) \n\t) \n    { \n\tif (ev->type == ev_keydown ||  \n\t    (ev->type == ev_mouse && ev->data1) || \n\t    (ev->type == ev_joystick && ev->data1) ) \n\t{ \n\t    M_StartControlPanel (); \n\t    return true; \n\t} \n\treturn false; \n    } \n \n    if (gamestate == GS_LEVEL) \n    { \n#if 0 \n\tif (devparm && ev->type == ev_keydown && ev->data1 == ';') \n\t{ \n\t    G_DeathMatchSpawnPlayer (0); \n\t    return true; \n\t} \n#endif \n\tif (HU_Responder (ev)) \n\t    return true;\t// chat ate the event \n\tif (ST_Responder (ev)) \n\t    return true;\t// status window ate it \n\tif (AM_Responder (ev)) \n\t    return true;\t// automap ate it \n    } \n\t \n    if (gamestate == GS_FINALE) \n    { \n\tif (F_Responder (ev)) \n\t    return true;\t// finale ate the event \n    } \n\t \n    switch (ev->type) \n    { \n      case ev_keydown: \n\tif (ev->data1 == KEY_PAUSE) \n\t{ \n\t    sendpause = true; \n\t    return true; \n\t} \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = true; \n\treturn true;    // eat key down events \n \n      case ev_keyup: \n\tif (ev->data1 <NUMKEYS) \n\t    gamekeydown[ev->data1] = false; \n\treturn false;   // always let key up events filter down \n\t\t \n      case ev_mouse: \n\tmousebuttons[0] = ev->data1 & 1; \n\tmousebuttons[1] = ev->data1 & 2; \n\tmousebuttons[2] = ev->data1 & 4; \n\tmousex = ev->data2*(mouseSensitivity+5)/10; \n\tmousey = ev->data3*(mouseSensitivity+5)/10; \n\treturn true;    // eat events \n \n      case ev_joystick: \n\tjoybuttons[0] = ev->data1 & 1; \n\tjoybuttons[1] = ev->data1 & 2; \n\tjoybuttons[2] = ev->data1 & 4; \n\tjoybuttons[3] = ev->data1 & 8; \n\tjoyxmove = ev->data2; \n\tjoyymove = ev->data3; \n\treturn true;    // eat events \n \n      default: \n\tbreak; \n    } \n\n    return false; \n}", "path": "g_game.c", "repo_name": "Reggi3/ExplorerDoom", "stars": 6, "license": "None", "language": "c", "size": 512}
{"docstring": "/*\n==================\nAINode_Battle_NBG\n==================\n*/\n", "func_signal": "int AINode_Battle_NBG(bot_state_t *bs)", "code": "{\n\tint areanum;\n\tbot_goal_t goal;\n\taas_entityinfo_t entinfo;\n\tbot_moveresult_t moveresult;\n\tfloat attack_skill;\n\tvec3_t target, dir;\n\n\tif (BotIsObserver(bs)) {\n\t\tAIEnter_Observer(bs, \"battle nbg: observer\");\n\t\treturn qfalse;\n\t}\n\t//if in the intermission\n\tif (BotIntermission(bs)) {\n\t\tAIEnter_Intermission(bs, \"battle nbg: intermission\");\n\t\treturn qfalse;\n\t}\n\t//respawn if dead\n\tif (BotIsDead(bs)) {\n\t\tAIEnter_Respawn(bs, \"battle nbg: bot dead\");\n\t\treturn qfalse;\n\t}\n\t//if no enemy\n\tif (bs->enemy < 0) {\n\t\tAIEnter_Seek_NBG(bs, \"battle nbg: no enemy\");\n\t\treturn qfalse;\n\t}\n\t//\n\tBotEntityInfo(bs->enemy, &entinfo);\n\tif (EntityIsDead(&entinfo)) {\n\t\tAIEnter_Seek_NBG(bs, \"battle nbg: enemy dead\");\n\t\treturn qfalse;\n\t}\n\t//\n\tbs->tfl = TFL_DEFAULT;\n\tif (bot_grapple.integer) bs->tfl |= TFL_GRAPPLEHOOK;\n\t//if in lava or slime the bot should be able to get out\n\tif (BotInLavaOrSlime(bs)) bs->tfl |= TFL_LAVA|TFL_SLIME;\n\t//\n\tif (BotCanAndWantsToRocketJump(bs)) {\n\t\tbs->tfl |= TFL_ROCKETJUMP;\n\t}\n\t//map specific code\n\tBotMapScripts(bs);\n\t//update the last time the enemy was visible\n\tif (BotEntityVisible(bs->entitynum, bs->eye, bs->viewangles, 360, bs->enemy)) {\n\t\tbs->enemyvisible_time = FloatTime();\n\t\tVectorCopy(entinfo.origin, target);\n\t\t// if not a player enemy\n\t\tif (bs->enemy >= MAX_CLIENTS) {\n#ifdef MISSIONPACK\n\t\t\t// if attacking an obelisk\n\t\t\tif ( bs->enemy == redobelisk.entitynum ||\n\t\t\t\tbs->enemy == blueobelisk.entitynum ) {\n\t\t\t\ttarget[2] += 16;\n\t\t\t}\n#endif\n\t\t}\n\t\t//update the reachability area and origin if possible\n\t\tareanum = BotPointAreaNum(target);\n\t\tif (areanum && trap_AAS_AreaReachability(areanum)) {\n\t\t\tVectorCopy(target, bs->lastenemyorigin);\n\t\t\tbs->lastenemyareanum = areanum;\n\t\t}\n\t}\n\t//if the bot has no goal or touches the current goal\n\tif (!trap_BotGetTopGoal(bs->gs, &goal)) {\n\t\tbs->nbg_time = 0;\n\t}\n\telse if (BotReachedGoal(bs, &goal)) {\n\t\tbs->nbg_time = 0;\n\t}\n\t//\n\tif (bs->nbg_time < FloatTime()) {\n\t\t//pop the current goal from the stack\n\t\ttrap_BotPopGoal(bs->gs);\n\t\t//if the bot still has a goal\n\t\tif (trap_BotGetTopGoal(bs->gs, &goal))\n\t\t\tAIEnter_Battle_Retreat(bs, \"battle nbg: time out\");\n\t\telse\n\t\t\tAIEnter_Battle_Fight(bs, \"battle nbg: time out\");\n\t\t//\n\t\treturn qfalse;\n\t}\n\t//initialize the movement state\n\tBotSetupForMovement(bs);\n\t//move towards the goal\n\ttrap_BotMoveToGoal(&moveresult, bs->ms, &goal, bs->tfl);\n\t//if the movement failed\n\tif (moveresult.failure) {\n\t\t//reset the avoid reach, otherwise bot is stuck in current area\n\t\ttrap_BotResetAvoidReach(bs->ms);\n\t\t//BotAI_Print(PRT_MESSAGE, \"movement failure %d\\n\", moveresult.traveltype);\n\t\tbs->nbg_time = 0;\n\t}\n\t//\n\tBotAIBlocked(bs, &moveresult, qfalse);\n\t//update the attack inventory values\n\tBotUpdateBattleInventory(bs, bs->enemy);\n\t//choose the best weapon to fight with\n\tBotChooseWeapon(bs);\n\t//if the view is fixed for the movement\n\tif (moveresult.flags & (MOVERESULT_MOVEMENTVIEW|MOVERESULT_SWIMVIEW)) {\n\t\tVectorCopy(moveresult.ideal_viewangles, bs->ideal_viewangles);\n\t}\n\telse if (!(moveresult.flags & MOVERESULT_MOVEMENTVIEWSET)\n\t\t\t\t&& !(bs->flags & BFL_IDEALVIEWSET)) {\n\t\tattack_skill = trap_Characteristic_BFloat(bs->character, CHARACTERISTIC_ATTACK_SKILL, 0, 1);\n\t\t//if the bot is skilled anough and the enemy is visible\n\t\tif (attack_skill > 0.3) {\n\t\t\t//&& BotEntityVisible(bs->entitynum, bs->eye, bs->viewangles, 360, bs->enemy)\n\t\t\tBotAimAtEnemy(bs);\n\t\t}\n\t\telse {\n\t\t\tif (trap_BotMovementViewTarget(bs->ms, &goal, bs->tfl, 300, target)) {\n\t\t\t\tVectorSubtract(target, bs->origin, dir);\n\t\t\t\tvectoangles(dir, bs->ideal_viewangles);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvectoangles(moveresult.movedir, bs->ideal_viewangles);\n\t\t\t}\n\t\t\tbs->ideal_viewangles[2] *= 0.5;\n\t\t}\n\t}\n\t//if the weapon is used for the bot movement\n\tif (moveresult.flags & MOVERESULT_MOVEMENTWEAPON) bs->weaponnum = moveresult.weapon;\n\t//attack the enemy if possible\n\tBotCheckAttack(bs);\n\t//\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_ClearShownDebugLines\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_DebugLine(vec3_t start, vec3_t end, int color)", "code": "{\n\tint line;\n\n\tfor (line = 0; line < MAX_DEBUGLINES; line++)\n\t{\n\t\tif (!debuglines[line])\n\t\t{\n\t\t\tdebuglines[line] = botimport.DebugLineCreate();\n\t\t\tdebuglinevisible[line] = qfalse;\n\t\t\tnumdebuglines++;\n\t\t} //end if\n\t\tif (!debuglinevisible[line])\n\t\t{\n\t\t\tbotimport.DebugLineShow(debuglines[line], start, end, color);\n\t\t\tdebuglinevisible[line] = qtrue;\n\t\t\treturn;\n\t\t} //end else\n\t} //end for\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nBotNearbyGoal\n==================\n*/\n", "func_signal": "int BotNearbyGoal(bot_state_t *bs, int tfl, bot_goal_t *ltg, float range)", "code": "{\n\tint ret;\n\n\t//check if the bot should go for air\n\tif (BotGoForAir(bs, tfl, ltg, range)) return qtrue;\n\t//if the bot is carrying the enemy flag\n\tif (BotCTFCarryingFlag(bs)) {\n\t\t//if the bot is just a few secs away from the base \n\t\tif (trap_AAS_AreaTravelTimeToGoalArea(bs->areanum, bs->origin,\n\t\t\t\tbs->teamgoal.areanum, TFL_DEFAULT) < 300) {\n\t\t\t//make the range really small\n\t\t\trange = 50;\n\t\t}\n\t}\n\t//\n\tret = trap_BotChooseNBGItem(bs->gs, bs->origin, bs->inventory, tfl, ltg, range);\n\t/*\n\tif (ret)\n\t{\n\t\tchar buf[128];\n\t\t//get the goal at the top of the stack\n\t\ttrap_BotGetTopGoal(bs->gs, &goal);\n\t\ttrap_BotGoalName(goal.number, buf, sizeof(buf));\n\t\tBotAI_Print(PRT_MESSAGE, \"%1.1f: new nearby goal %s\\n\", FloatTime(), buf);\n\t}\n    */\n\treturn ret;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nBotLongTermGoal\n==================\n*/\n", "func_signal": "int BotLongTermGoal(bot_state_t *bs, int tfl, int retreat, bot_goal_t *goal)", "code": "{\n\taas_entityinfo_t entinfo;\n\tchar teammate[MAX_MESSAGE_SIZE];\n\tfloat squaredist;\n\tint areanum;\n\tvec3_t dir;\n\n\t//FIXME: also have air long term goals?\n\t//\n\t//if the bot is leading someone and not retreating\n\tif (bs->lead_time > 0 && !retreat) {\n\t\tif (bs->lead_time < FloatTime()) {\n\t\t\tBotAI_BotInitialChat(bs, \"lead_stop\", EasyClientName(bs->lead_teammate, teammate, sizeof(teammate)), NULL);\n\t\t\ttrap_BotEnterChat(bs->cs, bs->teammate, CHAT_TELL);\n\t\t\tbs->lead_time = 0;\n\t\t\treturn BotGetLongTermGoal(bs, tfl, retreat, goal);\n\t\t}\n\t\t//\n\t\tif (bs->leadmessage_time < 0 && -bs->leadmessage_time < FloatTime()) {\n\t\t\tBotAI_BotInitialChat(bs, \"followme\", EasyClientName(bs->lead_teammate, teammate, sizeof(teammate)), NULL);\n\t\t\ttrap_BotEnterChat(bs->cs, bs->teammate, CHAT_TELL);\n\t\t\tbs->leadmessage_time = FloatTime();\n\t\t}\n\t\t//get entity information of the companion\n\t\tBotEntityInfo(bs->lead_teammate, &entinfo);\n\t\t//\n\t\tif (entinfo.valid) {\n\t\t\tareanum = BotPointAreaNum(entinfo.origin);\n\t\t\tif (areanum && trap_AAS_AreaReachability(areanum)) {\n\t\t\t\t//update team goal\n\t\t\t\tbs->lead_teamgoal.entitynum = bs->lead_teammate;\n\t\t\t\tbs->lead_teamgoal.areanum = areanum;\n\t\t\t\tVectorCopy(entinfo.origin, bs->lead_teamgoal.origin);\n\t\t\t\tVectorSet(bs->lead_teamgoal.mins, -8, -8, -8);\n\t\t\t\tVectorSet(bs->lead_teamgoal.maxs, 8, 8, 8);\n\t\t\t}\n\t\t}\n\t\t//if the team mate is visible\n\t\tif (BotEntityVisible(bs->entitynum, bs->eye, bs->viewangles, 360, bs->lead_teammate)) {\n\t\t\tbs->leadvisible_time = FloatTime();\n\t\t}\n\t\t//if the team mate is not visible for 1 seconds\n\t\tif (bs->leadvisible_time < FloatTime() - 1) {\n\t\t\tbs->leadbackup_time = FloatTime() + 2;\n\t\t}\n\t\t//distance towards the team mate\n\t\tVectorSubtract(bs->origin, bs->lead_teamgoal.origin, dir);\n\t\tsquaredist = VectorLengthSquared(dir);\n\t\t//if backing up towards the team mate\n\t\tif (bs->leadbackup_time > FloatTime()) {\n\t\t\tif (bs->leadmessage_time < FloatTime() - 20) {\n\t\t\t\tBotAI_BotInitialChat(bs, \"followme\", EasyClientName(bs->lead_teammate, teammate, sizeof(teammate)), NULL);\n\t\t\t\ttrap_BotEnterChat(bs->cs, bs->teammate, CHAT_TELL);\n\t\t\t\tbs->leadmessage_time = FloatTime();\n\t\t\t}\n\t\t\t//if very close to the team mate\n\t\t\tif (squaredist < Square(100)) {\n\t\t\t\tbs->leadbackup_time = 0;\n\t\t\t}\n\t\t\t//the bot should go back to the team mate\n\t\t\tmemcpy(goal, &bs->lead_teamgoal, sizeof(bot_goal_t));\n\t\t\treturn qtrue;\n\t\t}\n\t\telse {\n\t\t\t//if quite distant from the team mate\n\t\t\tif (squaredist > Square(500)) {\n\t\t\t\tif (bs->leadmessage_time < FloatTime() - 20) {\n\t\t\t\t\tBotAI_BotInitialChat(bs, \"followme\", EasyClientName(bs->lead_teammate, teammate, sizeof(teammate)), NULL);\n\t\t\t\t\ttrap_BotEnterChat(bs->cs, bs->teammate, CHAT_TELL);\n\t\t\t\t\tbs->leadmessage_time = FloatTime();\n\t\t\t\t}\n\t\t\t\t//look at the team mate\n\t\t\t\tVectorSubtract(entinfo.origin, bs->origin, dir);\n\t\t\t\tvectoangles(dir, bs->ideal_viewangles);\n\t\t\t\tbs->ideal_viewangles[2] *= 0.5;\n\t\t\t\t//just wait for the team mate\n\t\t\t\treturn qfalse;\n\t\t\t}\n\t\t}\n\t}\n\treturn BotGetLongTermGoal(bs, tfl, retreat, goal);\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nBotGetItemLongTermGoal\n==================\n*/\n", "func_signal": "int BotGetItemLongTermGoal(bot_state_t *bs, int tfl, bot_goal_t *goal)", "code": "{\n\t//if the bot has no goal\n\tif (!trap_BotGetTopGoal(bs->gs, goal)) {\n\t\t//BotAI_Print(PRT_MESSAGE, \"no ltg on stack\\n\");\n\t\tbs->ltg_time = 0;\n\t}\n\t//if the bot touches the current goal\n\telse if (BotReachedGoal(bs, goal)) {\n\t\tBotChooseWeapon(bs);\n\t\tbs->ltg_time = 0;\n\t}\n\t//if it is time to find a new long term goal\n\tif (bs->ltg_time < FloatTime()) {\n\t\t//pop the current goal from the stack\n\t\ttrap_BotPopGoal(bs->gs);\n\t\t//BotAI_Print(PRT_MESSAGE, \"%s: choosing new ltg\\n\", ClientName(bs->client, netname, sizeof(netname)));\n\t\t//choose a new goal\n\t\t//BotAI_Print(PRT_MESSAGE, \"%6.1f client %d: BotChooseLTGItem\\n\", FloatTime(), bs->client);\n\t\tif (trap_BotChooseLTGItem(bs->gs, bs->origin, bs->inventory, tfl)) {\n\t\t\t/*\n\t\t\tchar buf[128];\n\t\t\t//get the goal at the top of the stack\n\t\t\ttrap_BotGetTopGoal(bs->gs, goal);\n\t\t\ttrap_BotGoalName(goal->number, buf, sizeof(buf));\n\t\t\tBotAI_Print(PRT_MESSAGE, \"%1.1f: new long term goal %s\\n\", FloatTime(), buf);\n            */\n\t\t\tbs->ltg_time = FloatTime() + 20;\n\t\t}\n\t\telse {//the bot gets sorta stuck with all the avoid timings, shouldn't happen though\n\t\t\t//\n#ifdef DEBUG\n\t\t\tchar netname[128];\n\n\t\t\tBotAI_Print(PRT_MESSAGE, \"%s: no valid ltg (probably stuck)\\n\", ClientName(bs->client, netname, sizeof(netname)));\n#endif\n\t\t\t//trap_BotDumpAvoidGoals(bs->gs);\n\t\t\t//reset the avoid goals and the avoid reach\n\t\t\ttrap_BotResetAvoidGoals(bs->gs);\n\t\t\ttrap_BotResetAvoidReach(bs->ms);\n\t\t}\n\t\t//get the goal at the top of the stack\n\t\treturn trap_BotGetTopGoal(bs->gs, goal);\n\t}\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAINode_Intermission\n==================\n*/\n", "func_signal": "int AINode_Intermission(bot_state_t *bs)", "code": "{\n\t//if the intermission ended\n\tif (!BotIntermission(bs)) {\n\t\tif (BotChat_StartLevel(bs)) {\n\t\t\tbs->stand_time = FloatTime() + BotChatTime(bs);\n\t\t}\n\t\telse {\n\t\t\tbs->stand_time = FloatTime() + 2;\n\t\t}\n\t\tAIEnter_Stand(bs, \"intermission: chat\");\n\t}\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAIEnter_Intermission\n==================\n*/\n", "func_signal": "void AIEnter_Intermission(bot_state_t *bs, char *s)", "code": "{\n\tBotRecordNodeSwitch(bs, \"intermission\", \"\", s);\n\t//reset the bot state\n\tBotResetState(bs);\n\t//check for end level chat\n\tif (BotChat_EndLevel(bs)) {\n\t\ttrap_BotEnterChat(bs->cs, 0, bs->chatto);\n\t}\n\tbs->ainode = AINode_Intermission;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAINode_Battle_Fight\n==================\n*/\n", "func_signal": "int AINode_Battle_Fight(bot_state_t *bs)", "code": "{\n\tint areanum;\n\tvec3_t target;\n\taas_entityinfo_t entinfo;\n\tbot_moveresult_t moveresult;\n\n\tif (BotIsObserver(bs)) {\n\t\tAIEnter_Observer(bs, \"battle fight: observer\");\n\t\treturn qfalse;\n\t}\n\n\t//if in the intermission\n\tif (BotIntermission(bs)) {\n\t\tAIEnter_Intermission(bs, \"battle fight: intermission\");\n\t\treturn qfalse;\n\t}\n\t//respawn if dead\n\tif (BotIsDead(bs)) {\n\t\tAIEnter_Respawn(bs, \"battle fight: bot dead\");\n\t\treturn qfalse;\n\t}\n\t//if there is another better enemy\n\tif (BotFindEnemy(bs, bs->enemy)) {\n#ifdef DEBUG\n\t\tBotAI_Print(PRT_MESSAGE, \"found new better enemy\\n\");\n#endif\n\t}\n\t//if no enemy\n\tif (bs->enemy < 0) {\n\t\tAIEnter_Seek_LTG(bs, \"battle fight: no enemy\");\n\t\treturn qfalse;\n\t}\n\t//\n\tBotEntityInfo(bs->enemy, &entinfo);\n\t//if the enemy is dead\n\tif (bs->enemydeath_time) {\n\t\tif (bs->enemydeath_time < FloatTime() - 1.0) {\n\t\t\tbs->enemydeath_time = 0;\n\t\t\tif (bs->enemysuicide) {\n\t\t\t\tBotChat_EnemySuicide(bs);\n\t\t\t}\n\t\t\tif (bs->lastkilledplayer == bs->enemy && BotChat_Kill(bs)) {\n\t\t\t\tbs->stand_time = FloatTime() + BotChatTime(bs);\n\t\t\t\tAIEnter_Stand(bs, \"battle fight: enemy dead\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbs->ltg_time = 0;\n\t\t\t\tAIEnter_Seek_LTG(bs, \"battle fight: enemy dead\");\n\t\t\t}\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\telse {\n\t\tif (EntityIsDead(&entinfo)) {\n\t\t\tbs->enemydeath_time = FloatTime();\n\t\t}\n\t}\n\t//if the enemy is invisible and not shooting the bot looses track easily\n\tif (EntityIsInvisible(&entinfo) && !EntityIsShooting(&entinfo)) {\n\t\tif (random() < 0.2) {\n\t\t\tAIEnter_Seek_LTG(bs, \"battle fight: invisible\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//\n\tVectorCopy(entinfo.origin, target);\n\t// if not a player enemy\n\tif (bs->enemy >= MAX_CLIENTS) {\n#ifdef MISSIONPACK\n\t\t// if attacking an obelisk\n\t\tif ( bs->enemy == redobelisk.entitynum ||\n\t\t\tbs->enemy == blueobelisk.entitynum ) {\n\t\t\ttarget[2] += 16;\n\t\t}\n#endif\n\t}\n\t//update the reachability area and origin if possible\n\tareanum = BotPointAreaNum(target);\n\tif (areanum && trap_AAS_AreaReachability(areanum)) {\n\t\tVectorCopy(target, bs->lastenemyorigin);\n\t\tbs->lastenemyareanum = areanum;\n\t}\n\t//update the attack inventory values\n\tBotUpdateBattleInventory(bs, bs->enemy);\n\t//if the bot's health decreased\n\tif (bs->lastframe_health > bs->inventory[INVENTORY_HEALTH]) {\n\t\tif (BotChat_HitNoDeath(bs)) {\n\t\t\tbs->stand_time = FloatTime() + BotChatTime(bs);\n\t\t\tAIEnter_Stand(bs, \"battle fight: chat health decreased\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//if the bot hit someone\n\tif (bs->cur_ps.persistant[PERS_HITS] > bs->lasthitcount) {\n\t\tif (BotChat_HitNoKill(bs)) {\n\t\t\tbs->stand_time = FloatTime() + BotChatTime(bs);\n\t\t\tAIEnter_Stand(bs, \"battle fight: chat hit someone\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//if the enemy is not visible\n\tif (!BotEntityVisible(bs->entitynum, bs->eye, bs->viewangles, 360, bs->enemy)) {\n\t\tif (BotWantsToChase(bs)) {\n\t\t\tAIEnter_Battle_Chase(bs, \"battle fight: enemy out of sight\");\n\t\t\treturn qfalse;\n\t\t}\n\t\telse {\n\t\t\tAIEnter_Seek_LTG(bs, \"battle fight: enemy out of sight\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//use holdable items\n\tBotBattleUseItems(bs);\n\t//\n\tbs->tfl = TFL_DEFAULT;\n\tif (bot_grapple.integer) bs->tfl |= TFL_GRAPPLEHOOK;\n\t//if in lava or slime the bot should be able to get out\n\tif (BotInLavaOrSlime(bs)) bs->tfl |= TFL_LAVA|TFL_SLIME;\n\t//\n\tif (BotCanAndWantsToRocketJump(bs)) {\n\t\tbs->tfl |= TFL_ROCKETJUMP;\n\t}\n\t//choose the best weapon to fight with\n\tBotChooseWeapon(bs);\n\t//do attack movements\n\tmoveresult = BotAttackMove(bs, bs->tfl);\n\t//if the movement failed\n\tif (moveresult.failure) {\n\t\t//reset the avoid reach, otherwise bot is stuck in current area\n\t\ttrap_BotResetAvoidReach(bs->ms);\n\t\t//BotAI_Print(PRT_MESSAGE, \"movement failure %d\\n\", moveresult.traveltype);\n\t\tbs->ltg_time = 0;\n\t}\n\t//\n\tBotAIBlocked(bs, &moveresult, qfalse);\n\t//aim at the enemy\n\tBotAimAtEnemy(bs);\n\t//attack the enemy if possible\n\tBotCheckAttack(bs);\n\t//if the bot wants to retreat\n\tif (!(bs->flags & BFL_FIGHTSUICIDAL)) {\n\t\tif (BotWantsToRetreat(bs)) {\n\t\t\tAIEnter_Battle_Retreat(bs, \"battle fight: wants to retreat\");\n\t\t\treturn qtrue;\n\t\t}\n\t}\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nBotClearPath\n\n try to deactivate obstacles like proximity mines on the bot's path\n==================\n*/\n", "func_signal": "void BotClearPath(bot_state_t *bs, bot_moveresult_t *moveresult)", "code": "{\n\tint i, bestmine;\n\tfloat dist, bestdist;\n\tvec3_t target, dir;\n\tbsp_trace_t bsptrace;\n\tentityState_t state;\n\n\t// if there is a dead body wearing kamikze nearby\n\tif (bs->kamikazebody) {\n\t\t// if the bot's view angles and weapon are not used for movement\n\t\tif ( !(moveresult->flags & (MOVERESULT_MOVEMENTVIEW | MOVERESULT_MOVEMENTWEAPON)) ) {\n\t\t\t//\n\t\t\tBotAI_GetEntityState(bs->kamikazebody, &state);\n\t\t\tVectorCopy(state.pos.trBase, target);\n\t\t\ttarget[2] += 8;\n\t\t\tVectorSubtract(target, bs->eye, dir);\n\t\t\tvectoangles(dir, moveresult->ideal_viewangles);\n\t\t\t//\n\t\t\tmoveresult->weapon = BotSelectActivateWeapon(bs);\n\t\t\tif (moveresult->weapon == -1) {\n\t\t\t\t// FIXME: run away!\n\t\t\t\tmoveresult->weapon = 0;\n\t\t\t}\n\t\t\tif (moveresult->weapon) {\n\t\t\t\t//\n\t\t\t\tmoveresult->flags |= MOVERESULT_MOVEMENTWEAPON | MOVERESULT_MOVEMENTVIEW;\n\t\t\t\t// if holding the right weapon\n\t\t\t\tif (bs->cur_ps.weapon == moveresult->weapon) {\n\t\t\t\t\t// if the bot is pretty close with it's aim\n\t\t\t\t\tif (InFieldOfVision(bs->viewangles, 20, moveresult->ideal_viewangles)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\tBotAI_Trace(&bsptrace, bs->eye, NULL, NULL, target, bs->entitynum, MASK_SHOT);\n\t\t\t\t\t\t// if the mine is visible from the current position\n\t\t\t\t\t\tif (bsptrace.fraction >= 1.0 || bsptrace.ent == state.number) {\n\t\t\t\t\t\t\t// shoot at the mine\n\t\t\t\t\t\t\ttrap_EA_Attack(bs->client);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (moveresult->flags & MOVERESULT_BLOCKEDBYAVOIDSPOT) {\n\t\tbs->blockedbyavoidspot_time = FloatTime() + 5;\n\t}\n\t// if blocked by an avoid spot and the view angles and weapon are used for movement\n\tif (bs->blockedbyavoidspot_time > FloatTime() &&\n\t\t!(moveresult->flags & (MOVERESULT_MOVEMENTVIEW | MOVERESULT_MOVEMENTWEAPON)) ) {\n\t\tbestdist = 300;\n\t\tbestmine = -1;\n\t\tfor (i = 0; i < bs->numproxmines; i++) {\n\t\t\tBotAI_GetEntityState(bs->proxmines[i], &state);\n\t\t\tVectorSubtract(state.pos.trBase, bs->origin, dir);\n\t\t\tdist = VectorLength(dir);\n\t\t\tif (dist < bestdist) {\n\t\t\t\tbestdist = dist;\n\t\t\t\tbestmine = i;\n\t\t\t}\n\t\t}\n\t\tif (bestmine != -1) {\n\t\t\t//\n\t\t\t// state->generic1 == TEAM_RED || state->generic1 == TEAM_BLUE\n\t\t\t//\n\t\t\t// deactivate prox mines in the bot's path by shooting\n\t\t\t// rockets or plasma cells etc. at them\n\t\t\tBotAI_GetEntityState(bs->proxmines[bestmine], &state);\n\t\t\tVectorCopy(state.pos.trBase, target);\n\t\t\ttarget[2] += 2;\n\t\t\tVectorSubtract(target, bs->eye, dir);\n\t\t\tvectoangles(dir, moveresult->ideal_viewangles);\n\t\t\t// if the bot has a weapon that does splash damage\n\t\t\tif (bs->inventory[INVENTORY_PLASMAGUN] > 0 && bs->inventory[INVENTORY_CELLS] > 0)\n\t\t\t\tmoveresult->weapon = WEAPONINDEX_PLASMAGUN;\n\t\t\telse if (bs->inventory[INVENTORY_ROCKETLAUNCHER] > 0 && bs->inventory[INVENTORY_ROCKETS] > 0)\n\t\t\t\tmoveresult->weapon = WEAPONINDEX_ROCKET_LAUNCHER;\n\t\t\telse if (bs->inventory[INVENTORY_BFG10K] > 0 && bs->inventory[INVENTORY_BFGAMMO] > 0)\n\t\t\t\tmoveresult->weapon = WEAPONINDEX_BFG;\n\t\t\telse {\n\t\t\t\tmoveresult->weapon = 0;\n\t\t\t}\n\t\t\tif (moveresult->weapon) {\n\t\t\t\t//\n\t\t\t\tmoveresult->flags |= MOVERESULT_MOVEMENTWEAPON | MOVERESULT_MOVEMENTVIEW;\n\t\t\t\t// if holding the right weapon\n\t\t\t\tif (bs->cur_ps.weapon == moveresult->weapon) {\n\t\t\t\t\t// if the bot is pretty close with it's aim\n\t\t\t\t\tif (InFieldOfVision(bs->viewangles, 20, moveresult->ideal_viewangles)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\tBotAI_Trace(&bsptrace, bs->eye, NULL, NULL, target, bs->entitynum, MASK_SHOT);\n\t\t\t\t\t\t// if the mine is visible from the current position\n\t\t\t\t\t\tif (bsptrace.fraction >= 1.0 || bsptrace.ent == state.number) {\n\t\t\t\t\t\t\t// shoot at the mine\n\t\t\t\t\t\t\ttrap_EA_Attack(bs->client);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAIEnter_Battle_NBG\n==================\n*/\n", "func_signal": "void AIEnter_Battle_NBG(bot_state_t *bs, char *s)", "code": "{\n\tBotRecordNodeSwitch(bs, \"battle NBG\", \"\", s);\n\tbs->ainode = AINode_Battle_NBG;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAINode_Battle_Retreat\n==================\n*/\n", "func_signal": "int AINode_Battle_Retreat(bot_state_t *bs)", "code": "{\n\tbot_goal_t goal;\n\taas_entityinfo_t entinfo;\n\tbot_moveresult_t moveresult;\n\tvec3_t target, dir;\n\tfloat attack_skill, range;\n\tint areanum;\n\n\tif (BotIsObserver(bs)) {\n\t\tAIEnter_Observer(bs, \"battle retreat: observer\");\n\t\treturn qfalse;\n\t}\n\t//if in the intermission\n\tif (BotIntermission(bs)) {\n\t\tAIEnter_Intermission(bs, \"battle retreat: intermission\");\n\t\treturn qfalse;\n\t}\n\t//respawn if dead\n\tif (BotIsDead(bs)) {\n\t\tAIEnter_Respawn(bs, \"battle retreat: bot dead\");\n\t\treturn qfalse;\n\t}\n\t//if no enemy\n\tif (bs->enemy < 0) {\n\t\tAIEnter_Seek_LTG(bs, \"battle retreat: no enemy\");\n\t\treturn qfalse;\n\t}\n\t//\n\tBotEntityInfo(bs->enemy, &entinfo);\n\tif (EntityIsDead(&entinfo)) {\n\t\tAIEnter_Seek_LTG(bs, \"battle retreat: enemy dead\");\n\t\treturn qfalse;\n\t}\n\t//if there is another better enemy\n\tif (BotFindEnemy(bs, bs->enemy)) {\n#ifdef DEBUG\n\t\tBotAI_Print(PRT_MESSAGE, \"found new better enemy\\n\");\n#endif\n\t}\n\t//\n\tbs->tfl = TFL_DEFAULT;\n\tif (bot_grapple.integer) bs->tfl |= TFL_GRAPPLEHOOK;\n\t//if in lava or slime the bot should be able to get out\n\tif (BotInLavaOrSlime(bs)) bs->tfl |= TFL_LAVA|TFL_SLIME;\n\t//map specific code\n\tBotMapScripts(bs);\n\t//update the attack inventory values\n\tBotUpdateBattleInventory(bs, bs->enemy);\n\t//if the bot doesn't want to retreat anymore... probably picked up some nice items\n\tif (BotWantsToChase(bs)) {\n\t\t//empty the goal stack, when chasing, only the enemy is the goal\n\t\ttrap_BotEmptyGoalStack(bs->gs);\n\t\t//go chase the enemy\n\t\tAIEnter_Battle_Chase(bs, \"battle retreat: wants to chase\");\n\t\treturn qfalse;\n\t}\n\t//update the last time the enemy was visible\n\tif (BotEntityVisible(bs->entitynum, bs->eye, bs->viewangles, 360, bs->enemy)) {\n\t\tbs->enemyvisible_time = FloatTime();\n\t\tVectorCopy(entinfo.origin, target);\n\t\t// if not a player enemy\n\t\tif (bs->enemy >= MAX_CLIENTS) {\n#ifdef MISSIONPACK\n\t\t\t// if attacking an obelisk\n\t\t\tif ( bs->enemy == redobelisk.entitynum ||\n\t\t\t\tbs->enemy == blueobelisk.entitynum ) {\n\t\t\t\ttarget[2] += 16;\n\t\t\t}\n#endif\n\t\t}\n\t\t//update the reachability area and origin if possible\n\t\tareanum = BotPointAreaNum(target);\n\t\tif (areanum && trap_AAS_AreaReachability(areanum)) {\n\t\t\tVectorCopy(target, bs->lastenemyorigin);\n\t\t\tbs->lastenemyareanum = areanum;\n\t\t}\n\t}\n\t//if the enemy is NOT visible for 4 seconds\n\tif (bs->enemyvisible_time < FloatTime() - 4) {\n\t\tAIEnter_Seek_LTG(bs, \"battle retreat: lost enemy\");\n\t\treturn qfalse;\n\t}\n\t//else if the enemy is NOT visible\n\telse if (bs->enemyvisible_time < FloatTime()) {\n\t\t//if there is another enemy\n\t\tif (BotFindEnemy(bs, -1)) {\n\t\t\tAIEnter_Battle_Fight(bs, \"battle retreat: another enemy\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//\n\tBotTeamGoals(bs, qtrue);\n\t//use holdable items\n\tBotBattleUseItems(bs);\n\t//get the current long term goal while retreating\n\tif (!BotLongTermGoal(bs, bs->tfl, qtrue, &goal)) {\n\t\tAIEnter_Battle_SuicidalFight(bs, \"battle retreat: no way out\");\n\t\treturn qfalse;\n\t}\n\t//check for nearby goals periodicly\n\tif (bs->check_time < FloatTime()) {\n\t\tbs->check_time = FloatTime() + 1;\n\t\trange = 150;\n#ifdef CTF\n\t\tif (gametype == GT_CTF) {\n\t\t\t//if carrying a flag the bot shouldn't be distracted too much\n\t\t\tif (BotCTFCarryingFlag(bs))\n\t\t\t\trange = 50;\n\t\t}\n#endif //CTF\n#ifdef MISSIONPACK\n\t\telse if (gametype == GT_1FCTF) {\n\t\t\tif (Bot1FCTFCarryingFlag(bs))\n\t\t\t\trange = 50;\n\t\t}\n\t\telse if (gametype == GT_HARVESTER) {\n\t\t\tif (BotHarvesterCarryingCubes(bs))\n\t\t\t\trange = 80;\n\t\t}\n#endif\n\t\t//\n\t\tif (BotNearbyGoal(bs, bs->tfl, &goal, range)) {\n\t\t\ttrap_BotResetLastAvoidReach(bs->ms);\n\t\t\t//time the bot gets to pick up the nearby goal item\n\t\t\tbs->nbg_time = FloatTime() + range / 100 + 1;\n\t\t\tAIEnter_Battle_NBG(bs, \"battle retreat: nbg\");\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\t//initialize the movement state\n\tBotSetupForMovement(bs);\n\t//move towards the goal\n\ttrap_BotMoveToGoal(&moveresult, bs->ms, &goal, bs->tfl);\n\t//if the movement failed\n\tif (moveresult.failure) {\n\t\t//reset the avoid reach, otherwise bot is stuck in current area\n\t\ttrap_BotResetAvoidReach(bs->ms);\n\t\t//BotAI_Print(PRT_MESSAGE, \"movement failure %d\\n\", moveresult.traveltype);\n\t\tbs->ltg_time = 0;\n\t}\n\t//\n\tBotAIBlocked(bs, &moveresult, qfalse);\n\t//choose the best weapon to fight with\n\tBotChooseWeapon(bs);\n\t//if the view is fixed for the movement\n\tif (moveresult.flags & (MOVERESULT_MOVEMENTVIEW|MOVERESULT_SWIMVIEW)) {\n\t\tVectorCopy(moveresult.ideal_viewangles, bs->ideal_viewangles);\n\t}\n\telse if (!(moveresult.flags & MOVERESULT_MOVEMENTVIEWSET)\n\t\t\t\t&& !(bs->flags & BFL_IDEALVIEWSET) ) {\n\t\tattack_skill = trap_Characteristic_BFloat(bs->character, CHARACTERISTIC_ATTACK_SKILL, 0, 1);\n\t\t//if the bot is skilled anough\n\t\tif (attack_skill > 0.3) {\n\t\t\tBotAimAtEnemy(bs);\n\t\t}\n\t\telse {\n\t\t\tif (trap_BotMovementViewTarget(bs->ms, &goal, bs->tfl, 300, target)) {\n\t\t\t\tVectorSubtract(target, bs->origin, dir);\n\t\t\t\tvectoangles(dir, bs->ideal_viewangles);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvectoangles(moveresult.movedir, bs->ideal_viewangles);\n\t\t\t}\n\t\t\tbs->ideal_viewangles[2] *= 0.5;\n\t\t}\n\t}\n\t//if the weapon is used for the bot movement\n\tif (moveresult.flags & MOVERESULT_MOVEMENTWEAPON) bs->weaponnum = moveresult.weapon;\n\t//attack the enemy if possible\n\tBotCheckAttack(bs);\n\t//\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_DrawPermanentCross\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_DrawPlaneCross(vec3_t point, vec3_t normal, float dist, int type, int color)", "code": "{\n\tint n0, n1, n2, j, line, lines[2];\n\tvec3_t start1, end1, start2, end2;\n\n\t//make a cross in the hit plane at the hit point\n\tVectorCopy(point, start1);\n\tVectorCopy(point, end1);\n\tVectorCopy(point, start2);\n\tVectorCopy(point, end2);\n\n\tn0 = type % 3;\n\tn1 = (type + 1) % 3;\n\tn2 = (type + 2) % 3;\n\tstart1[n1] -= 6;\n\tstart1[n2] -= 6;\n\tend1[n1] += 6;\n\tend1[n2] += 6;\n\tstart2[n1] += 6;\n\tstart2[n2] -= 6;\n\tend2[n1] -= 6;\n\tend2[n2] += 6;\n\n\tstart1[n0] = (dist - (start1[n1] * normal[n1] +\n\t\t\t\tstart1[n2] * normal[n2])) / normal[n0];\n\tend1[n0] = (dist - (end1[n1] * normal[n1] +\n\t\t\t\tend1[n2] * normal[n2])) / normal[n0];\n\tstart2[n0] = (dist - (start2[n1] * normal[n1] +\n\t\t\t\tstart2[n2] * normal[n2])) / normal[n0];\n\tend2[n0] = (dist - (end2[n1] * normal[n1] +\n\t\t\t\tend2[n2] * normal[n2])) / normal[n0];\n\n\tfor (j = 0, line = 0; j < 2 && line < MAX_DEBUGLINES; line++)\n\t{\n\t\tif (!debuglines[line])\n\t\t{\n\t\t\tdebuglines[line] = botimport.DebugLineCreate();\n\t\t\tlines[j++] = debuglines[line];\n\t\t\tdebuglinevisible[line] = qtrue;\n\t\t\tnumdebuglines++;\n\t\t} //end if\n\t\telse if (!debuglinevisible[line])\n\t\t{\n\t\t\tlines[j++] = debuglines[line];\n\t\t\tdebuglinevisible[line] = qtrue;\n\t\t} //end else\n\t} //end for\n\tbotimport.DebugLineShow(lines[0], start1, end1, color);\n\tbotimport.DebugLineShow(lines[1], start2, end2, color);\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function ShowReachableAreas\n", "func_signal": "void AAS_FloodAreas_r(int areanum, int cluster, int *done)", "code": "{\n\tint nextareanum, i, facenum;\n\taas_area_t *area;\n\taas_face_t *face;\n\taas_areasettings_t *settings;\n\taas_reachability_t *reach;\n\n\tAAS_ShowAreaPolygons(areanum, 1, qtrue);\n\t//pointer to the convex area\n\tarea = &aasworld.areas[areanum];\n\tsettings = &aasworld.areasettings[areanum];\n\t//walk through the faces of the area\n\tfor (i = 0; i < area->numfaces; i++)\n\t{\n\t\tfacenum = abs(aasworld.faceindex[area->firstface + i]);\n\t\tface = &aasworld.faces[facenum];\n\t\tif (face->frontarea == areanum)\n\t\t\tnextareanum = face->backarea;\n\t\telse\n\t\t\tnextareanum = face->frontarea;\n\t\tif (!nextareanum)\n\t\t\tcontinue;\n\t\tif (done[nextareanum])\n\t\t\tcontinue;\n\t\tdone[nextareanum] = qtrue;\n\t\tif (aasworld.areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL)\n\t\t\tcontinue;\n\t\tif (AAS_AreaCluster(nextareanum) != cluster)\n\t\t\tcontinue;\n\t\tAAS_FloodAreas_r(nextareanum, cluster, done);\n\t} //end for\n\t//\n\tfor (i = 0; i < settings->numreachableareas; i++)\n\t{\n\t\treach = &aasworld.reachability[settings->firstreachablearea + i];\n\t\tnextareanum = reach->areanum;\n\t\tif (!nextareanum)\n\t\t\tcontinue;\n\t\tif (done[nextareanum])\n\t\t\tcontinue;\n\t\tdone[nextareanum] = qtrue;\n\t\tif (aasworld.areasettings[nextareanum].contents & AREACONTENTS_VIEWPORTAL)\n\t\t\tcontinue;\n\t\tif (AAS_AreaCluster(nextareanum) != cluster)\n\t\t\tcontinue;\n\t\t/*\n\t\tif ((reach->traveltype & TRAVELTYPE_MASK) == TRAVEL_WALKOFFLEDGE)\n\t\t{\n\t\t\tAAS_DebugLine(reach->start, reach->end, 1);\n\t\t}\n\t\t*/\n\t\tAAS_FloodAreas_r(nextareanum, cluster, done);\n\t}\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_PrintTravelType\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_DrawArrow(vec3_t start, vec3_t end, int linecolor, int arrowcolor)", "code": "{\n\tvec3_t dir, cross, p1, p2, up = {0, 0, 1};\n\tfloat dot;\n\n\tVectorSubtract(end, start, dir);\n\tVectorNormalize(dir);\n\tdot = DotProduct(dir, up);\n\tif (dot > 0.99 || dot < -0.99) VectorSet(cross, 1, 0, 0);\n\telse CrossProduct(dir, up, cross);\n\n\tVectorMA(end, -6, dir, p1);\n\tVectorCopy(p1, p2);\n\tVectorMA(p1, 6, cross, p1);\n\tVectorMA(p2, -6, cross, p2);\n\n\tAAS_DebugLine(start, end, linecolor);\n\tAAS_DebugLine(p1, end, arrowcolor);\n\tAAS_DebugLine(p2, end, arrowcolor);\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_ShowAreaPolygons\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_DrawCross(vec3_t origin, float size, int color)", "code": "{\n\tint i;\n\tvec3_t start, end;\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tVectorCopy(origin, start);\n\t\tstart[i] += size;\n\t\tVectorCopy(origin, end);\n\t\tend[i] -= size;\n\t\tAAS_DebugLine(start, end, color);\n\t} //end for\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAIEnter_Seek_LTG\n==================\n*/\n", "func_signal": "void AIEnter_Seek_LTG(bot_state_t *bs, char *s)", "code": "{\n\tbot_goal_t goal;\n\tchar buf[144];\n\n\tif (trap_BotGetTopGoal(bs->gs, &goal)) {\n\t\ttrap_BotGoalName(goal.number, buf, 144);\n\t\tBotRecordNodeSwitch(bs, \"seek LTG\", buf, s);\n\t}\n\telse {\n\t\tBotRecordNodeSwitch(bs, \"seek LTG\", \"no goal\", s);\n\t}\n\tbs->ainode = AINode_Seek_LTG;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAIEnter_Battle_Retreat\n==================\n*/\n", "func_signal": "void AIEnter_Battle_Retreat(bot_state_t *bs, char *s)", "code": "{\n\tBotRecordNodeSwitch(bs, \"battle retreat\", \"\", s);\n\tbs->ainode = AINode_Battle_Retreat;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n==================\nAINode_Stand\n==================\n*/\n", "func_signal": "int AINode_Stand(bot_state_t *bs)", "code": "{\n\n\t//if the bot's health decreased\n\tif (bs->lastframe_health > bs->inventory[INVENTORY_HEALTH]) {\n\t\tif (BotChat_HitTalking(bs)) {\n\t\t\tbs->standfindenemy_time = FloatTime() + BotChatTime(bs) + 0.1;\n\t\t\tbs->stand_time = FloatTime() + BotChatTime(bs) + 0.1;\n\t\t}\n\t}\n\tif (bs->standfindenemy_time < FloatTime()) {\n\t\tif (BotFindEnemy(bs, -1)) {\n\t\t\tAIEnter_Battle_Fight(bs, \"stand: found enemy\");\n\t\t\treturn qfalse;\n\t\t}\n\t\tbs->standfindenemy_time = FloatTime() + 1;\n\t}\n\t// put up chat icon\n\ttrap_EA_Talk(bs->client);\n\t// when done standing\n\tif (bs->stand_time < FloatTime()) {\n\t\ttrap_BotEnterChat(bs->cs, 0, bs->chatto);\n\t\tAIEnter_Seek_LTG(bs, \"stand: time out\");\n\t\treturn qfalse;\n\t}\n\t//\n\treturn qtrue;\n}", "path": "code\\game\\ai_dmnet.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_ShowPolygon\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_ClearShownDebugLines(void)", "code": "{\n\tint i;\n\n\t//make all lines invisible\n\tfor (i = 0; i < MAX_DEBUGLINES; i++)\n\t{\n\t\tif (debuglines[i])\n\t\t{\n\t\t\t//botimport.DebugLineShow(debuglines[i], NULL, NULL, LINECOLOR_NONE);\n\t\t\tbotimport.DebugLineDelete(debuglines[i]);\n\t\t\tdebuglines[i] = 0;\n\t\t\tdebuglinevisible[i] = qfalse;\n\t\t} //end if\n\t} //end for\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "//end of the function AAS_ShowArea\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void AAS_ShowAreaPolygons(int areanum, int color, int groundfacesonly)", "code": "{\n\tint i, facenum;\n\taas_area_t *area;\n\taas_face_t *face;\n\n\t//\n\tif (areanum < 0 || areanum >= aasworld.numareas)\n\t{\n\t\tbotimport.Print(PRT_ERROR, \"area %d out of range [0, %d]\\n\",\n\t\t\t\t\t\t\t\tareanum, aasworld.numareas);\n\t\treturn;\n\t} //end if\n\t//pointer to the convex area\n\tarea = &aasworld.areas[areanum];\n\t//walk through the faces of the area\n\tfor (i = 0; i < area->numfaces; i++)\n\t{\n\t\tfacenum = abs(aasworld.faceindex[area->firstface + i]);\n\t\t//check if face number is in range\n\t\tif (facenum >= aasworld.numfaces)\n\t\t{\n\t\t\tbotimport.Print(PRT_ERROR, \"facenum %d out of range\\n\", facenum);\n\t\t} //end if\n\t\tface = &aasworld.faces[facenum];\n\t\t//ground faces only\n\t\tif (groundfacesonly)\n\t\t{\n\t\t\tif (!(face->faceflags & (FACE_GROUND | FACE_LADDER))) continue;\n\t\t} //end if\n\t\tAAS_ShowFacePolygon(facenum, color, face->frontarea != areanum);\n\t} //end for\n}", "path": "code\\botlib\\be_aas_debug.c", "repo_name": "Cpasjuste/ioquake3", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 4921}
{"docstring": "/*\n *  Bignum objects hold integers outside the range of\n *  Fixnum. Bignum objects are created\n *  automatically when integer calculations would otherwise overflow a\n *  Fixnum. When a calculation involving\n *  Bignum objects returns a result that will fit in a\n *  Fixnum, the result is automatically converted.\n *     \n *  For the purposes of the bitwise operations and <code>[]</code>, a\n *  Bignum is treated as if it were an infinite-length\n *  bitstring with 2's complement representation.\n *     \n *  While Fixnum values are immediate, Bignum\n *  objects are not---assignment and parameter passing work with\n *  references to objects, not the objects themselves.\n *     \n */\n", "func_signal": "void\nInit_Bignum()", "code": "{\n    rb_cBignum = rb_define_class(\"Bignum\", rb_cInteger);\n\n    rb_define_method(rb_cBignum, \"to_s\", rb_big_to_s, -1);\n    rb_define_method(rb_cBignum, \"coerce\", rb_big_coerce, 1);\n    rb_define_method(rb_cBignum, \"-@\", rb_big_uminus, 0);\n    rb_define_method(rb_cBignum, \"+\", rb_big_plus, 1);\n    rb_define_method(rb_cBignum, \"-\", rb_big_minus, 1);\n    rb_define_method(rb_cBignum, \"*\", rb_big_mul, 1);\n    rb_define_method(rb_cBignum, \"/\", rb_big_div, 1);\n    rb_define_method(rb_cBignum, \"%\", rb_big_modulo, 1);\n    rb_define_method(rb_cBignum, \"div\", rb_big_div, 1);\n    rb_define_method(rb_cBignum, \"divmod\", rb_big_divmod, 1);\n    rb_define_method(rb_cBignum, \"modulo\", rb_big_modulo, 1);\n    rb_define_method(rb_cBignum, \"remainder\", rb_big_remainder, 1);\n    rb_define_method(rb_cBignum, \"quo\", rb_big_quo, 1);\n    rb_define_method(rb_cBignum, \"**\", rb_big_pow, 1);\n    rb_define_method(rb_cBignum, \"&\", rb_big_and, 1);\n    rb_define_method(rb_cBignum, \"|\", rb_big_or, 1);\n    rb_define_method(rb_cBignum, \"^\", rb_big_xor, 1);\n    rb_define_method(rb_cBignum, \"~\", rb_big_neg, 0);\n    rb_define_method(rb_cBignum, \"<<\", rb_big_lshift, 1);\n    rb_define_method(rb_cBignum, \">>\", rb_big_rshift, 1);\n    rb_define_method(rb_cBignum, \"[]\", rb_big_aref, 1);\n\n    rb_define_method(rb_cBignum, \"<=>\", rb_big_cmp, 1);\n    rb_define_method(rb_cBignum, \"==\", rb_big_eq, 1);\n    rb_define_method(rb_cBignum, \"eql?\", rb_big_eql, 1);\n    rb_define_method(rb_cBignum, \"hash\", rb_big_hash, 0);\n    rb_define_method(rb_cBignum, \"to_f\", rb_big_to_f, 0);\n    rb_define_method(rb_cBignum, \"abs\", rb_big_abs, 0);\n    rb_define_method(rb_cBignum, \"size\", rb_big_size, 0);\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* Find separator in globbing pattern. */\n", "func_signal": "static char *\nfind_dirsep(const char *s, int flags)", "code": "{\n    const int escape = !(flags & FNM_NOESCAPE);\n\n    register const char *p = s;\n    register char c;\n    int open = 0;\n\n    while (c = *p++) {\n\tswitch (c) {\n\t  case '[':\n\t    open = 1;\n\t    continue;\n\t  case ']':\n\t    open = 0;\n\t    continue;\n\n\t  case '/':\n\t    if (!open)\n\t\treturn (char *)p-1;\n\t    continue;\n\n\t  case '\\\\':\n\t    if (escape && !(c = *p++))\n\t\treturn (char *)p-1;\n\t    continue;\n\t}\n\n\tp = Next(p-1);\n    }\n\n    return (char *)p-1;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     GC.disable    => true or false\n *\n *  Disables garbage collection, returning <code>true</code> if garbage\n *  collection was already disabled.\n *\n *     GC.disable   #=> false\n *     GC.disable   #=> true\n *\n */\n", "func_signal": "VALUE\nrb_gc_disable()", "code": "{\n    int old = dont_gc;\n\n    dont_gc = Qtrue;\n    return old;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     Process::UID.re_exchangeable?   => true or false\n *\n *  Returns +true+ if the real and effective user IDs of a\n *  process may be exchanged on the current platform.\n *\n */\n", "func_signal": "static VALUE\np_uid_exchangeable()", "code": "{\n#if defined(HAVE_SETRESUID) &&  !defined(__CHECKER__)\n    return Qtrue;\n#elif defined(HAVE_SETREUID) && !defined(OBSOLETE_SETREUID)\n    return Qtrue;\n#else\n    return Qfalse;\n#endif\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* should not change ID if -1 */\n", "func_signal": "static int\nbe_chown(const char *path, uid_t owner, gid_t group)", "code": "{\n    if (owner == -1 || group == -1) {\n\tstruct stat st;\n\tif (stat(path, &st) < 0) return -1;\n\tif (owner == -1) owner = st.st_uid;\n\tif (group == -1) group = st.st_gid;\n    }\n    return chown(path, owner, group);\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  A <code>Struct</code> is a convenient way to bundle a number of\n *  attributes together, using accessor methods, without having to write\n *  an explicit class.\n *     \n *  The <code>Struct</code> class is a generator of specific classes,\n *  each one of which is defined to hold a set of variables and their\n *  accessors. In these examples, we'll call the generated class\n *  ``<i>Customer</i>Class,'' and we'll show an example instance of that\n *  class as ``<i>Customer</i>Inst.''\n *     \n *  In the descriptions that follow, the parameter <i>symbol</i> refers\n *  to a symbol, which is either a quoted string or a\n *  <code>Symbol</code> (such as <code>:name</code>).\n */\n", "func_signal": "void\nInit_Struct()", "code": "{\n    rb_cStruct = rb_define_class(\"Struct\", rb_cObject);\n    rb_include_module(rb_cStruct, rb_mEnumerable);\n\n    rb_undef_alloc_func(rb_cStruct);\n    rb_define_singleton_method(rb_cStruct, \"new\", rb_struct_s_def, -1);\n\n    rb_define_method(rb_cStruct, \"initialize\", rb_struct_initialize, -2);\n    rb_define_method(rb_cStruct, \"initialize_copy\", rb_struct_init_copy, 1);\n\n    rb_define_method(rb_cStruct, \"==\", rb_struct_equal, 1);\n    rb_define_method(rb_cStruct, \"eql?\", rb_struct_eql, 1);\n    rb_define_method(rb_cStruct, \"hash\", rb_struct_hash, 0);\n\n    rb_define_method(rb_cStruct, \"to_s\", rb_struct_inspect, 0);\n    rb_define_method(rb_cStruct, \"inspect\", rb_struct_inspect, 0);\n    rb_define_method(rb_cStruct, \"to_a\", rb_struct_to_a, 0);\n    rb_define_method(rb_cStruct, \"values\", rb_struct_to_a, 0);\n    rb_define_method(rb_cStruct, \"size\", rb_struct_size, 0);\n    rb_define_method(rb_cStruct, \"length\", rb_struct_size, 0);\n\n    rb_define_method(rb_cStruct, \"each\", rb_struct_each, 0);\n    rb_define_method(rb_cStruct, \"each_pair\", rb_struct_each_pair, 0);\n    rb_define_method(rb_cStruct, \"[]\", rb_struct_aref, 1);\n    rb_define_method(rb_cStruct, \"[]=\", rb_struct_aset, 2);\n    rb_define_method(rb_cStruct, \"select\", rb_struct_select, -1);\n    rb_define_method(rb_cStruct, \"values_at\", rb_struct_values_at, -1);\n\n    rb_define_method(rb_cStruct, \"members\", rb_struct_members_m, 0);\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  The <code>Enumerable</code> mixin provides collection classes with\n *  several traversal and searching methods, and with the ability to\n *  sort. The class must provide a method <code>each</code>, which\n *  yields successive members of the collection. If\n *  <code>Enumerable#max</code>, <code>#min</code>, or\n *  <code>#sort</code> is used, the objects in the collection must also\n *  implement a meaningful <code><=></code> operator, as these methods\n *  rely on an ordering between members of the collection.\n */\n", "func_signal": "void\nInit_Enumerable()", "code": "{\n    rb_mEnumerable = rb_define_module(\"Enumerable\");\n\n    rb_define_method(rb_mEnumerable,\"to_a\", enum_to_a, 0);\n    rb_define_method(rb_mEnumerable,\"entries\", enum_to_a, 0);\n\n    rb_define_method(rb_mEnumerable,\"sort\", enum_sort, 0);\n    rb_define_method(rb_mEnumerable,\"sort_by\", enum_sort_by, 0);\n    rb_define_method(rb_mEnumerable,\"grep\", enum_grep, 1);\n    rb_define_method(rb_mEnumerable,\"find\", enum_find, -1);\n    rb_define_method(rb_mEnumerable,\"detect\", enum_find, -1);\n    rb_define_method(rb_mEnumerable,\"find_all\", enum_find_all, 0);\n    rb_define_method(rb_mEnumerable,\"select\", enum_find_all, 0);\n    rb_define_method(rb_mEnumerable,\"reject\", enum_reject, 0);\n    rb_define_method(rb_mEnumerable,\"collect\", enum_collect, 0);\n    rb_define_method(rb_mEnumerable,\"map\", enum_collect, 0);\n    rb_define_method(rb_mEnumerable,\"inject\", enum_inject, -1);\n    rb_define_method(rb_mEnumerable,\"partition\", enum_partition, 0);\n    rb_define_method(rb_mEnumerable,\"all?\", enum_all, 0);\n    rb_define_method(rb_mEnumerable,\"any?\", enum_any, 0);\n    rb_define_method(rb_mEnumerable,\"min\", enum_min, 0);\n    rb_define_method(rb_mEnumerable,\"max\", enum_max, 0);\n    rb_define_method(rb_mEnumerable,\"member?\", enum_member, 1);\n    rb_define_method(rb_mEnumerable,\"include?\", enum_member, 1);\n    rb_define_method(rb_mEnumerable,\"each_with_index\", enum_each_with_index, 0);\n    rb_define_method(rb_mEnumerable, \"zip\", enum_zip, -1);\n\n    id_eqq  = rb_intern(\"===\");\n    id_each = rb_intern(\"each\");\n    id_cmp  = rb_intern(\"<=>\");\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* Arrays are ordered, integer-indexed collections of any object. \n * Array indexing starts at 0, as in C or Java.  A negative index is \n * assumed to be relative to the end of the array---that is, an index of -1 \n * indicates the last element of the array, -2 is the next to last \n * element in the array, and so on. \n */\n", "func_signal": "void\nInit_Array()", "code": "{\n    rb_cArray  = rb_define_class(\"Array\", rb_cObject);\n    rb_include_module(rb_cArray, rb_mEnumerable);\n\n    rb_define_alloc_func(rb_cArray, ary_alloc);\n    rb_define_singleton_method(rb_cArray, \"[]\", rb_ary_s_create, -1);\n    rb_define_method(rb_cArray, \"initialize\", rb_ary_initialize, -1);\n    rb_define_method(rb_cArray, \"initialize_copy\", rb_ary_replace, 1);\n\n    rb_define_method(rb_cArray, \"to_s\", rb_ary_to_s, 0);\n    rb_define_method(rb_cArray, \"inspect\", rb_ary_inspect, 0);\n    rb_define_method(rb_cArray, \"to_a\", rb_ary_to_a, 0);\n    rb_define_method(rb_cArray, \"to_ary\", rb_ary_to_ary_m, 0);\n    rb_define_method(rb_cArray, \"frozen?\",  rb_ary_frozen_p, 0);\n\n    rb_define_method(rb_cArray, \"==\", rb_ary_equal, 1);\n    rb_define_method(rb_cArray, \"eql?\", rb_ary_eql, 1);\n    rb_define_method(rb_cArray, \"hash\", rb_ary_hash, 0);\n\n    rb_define_method(rb_cArray, \"[]\", rb_ary_aref, -1);\n    rb_define_method(rb_cArray, \"[]=\", rb_ary_aset, -1);\n    rb_define_method(rb_cArray, \"at\", rb_ary_at, 1);\n    rb_define_method(rb_cArray, \"fetch\", rb_ary_fetch, -1);\n    rb_define_method(rb_cArray, \"first\", rb_ary_first, -1);\n    rb_define_method(rb_cArray, \"last\", rb_ary_last, -1);\n    rb_define_method(rb_cArray, \"concat\", rb_ary_concat, 1);\n    rb_define_method(rb_cArray, \"<<\", rb_ary_push, 1);\n    rb_define_method(rb_cArray, \"push\", rb_ary_push_m, -1);\n    rb_define_method(rb_cArray, \"pop\", rb_ary_pop, 0);\n    rb_define_method(rb_cArray, \"shift\", rb_ary_shift, 0);\n    rb_define_method(rb_cArray, \"unshift\", rb_ary_unshift_m, -1);\n    rb_define_method(rb_cArray, \"insert\", rb_ary_insert, -1);\n    rb_define_method(rb_cArray, \"each\", rb_ary_each, 0);\n    rb_define_method(rb_cArray, \"each_index\", rb_ary_each_index, 0);\n    rb_define_method(rb_cArray, \"reverse_each\", rb_ary_reverse_each, 0);\n    rb_define_method(rb_cArray, \"length\", rb_ary_length, 0);\n    rb_define_alias(rb_cArray,  \"size\", \"length\");\n    rb_define_method(rb_cArray, \"empty?\", rb_ary_empty_p, 0);\n    rb_define_method(rb_cArray, \"index\", rb_ary_index, 1);\n    rb_define_method(rb_cArray, \"rindex\", rb_ary_rindex, 1);\n    rb_define_method(rb_cArray, \"indexes\", rb_ary_indexes, -1);\n    rb_define_method(rb_cArray, \"indices\", rb_ary_indexes, -1);\n    rb_define_method(rb_cArray, \"join\", rb_ary_join_m, -1);\n    rb_define_method(rb_cArray, \"reverse\", rb_ary_reverse_m, 0);\n    rb_define_method(rb_cArray, \"reverse!\", rb_ary_reverse_bang, 0);\n    rb_define_method(rb_cArray, \"sort\", rb_ary_sort, 0);\n    rb_define_method(rb_cArray, \"sort!\", rb_ary_sort_bang, 0);\n    rb_define_method(rb_cArray, \"collect\", rb_ary_collect, 0);\n    rb_define_method(rb_cArray, \"collect!\", rb_ary_collect_bang, 0);\n    rb_define_method(rb_cArray, \"map\", rb_ary_collect, 0);\n    rb_define_method(rb_cArray, \"map!\", rb_ary_collect_bang, 0);\n    rb_define_method(rb_cArray, \"select\", rb_ary_select, 0);\n    rb_define_method(rb_cArray, \"values_at\", rb_ary_values_at, -1);\n    rb_define_method(rb_cArray, \"delete\", rb_ary_delete, 1);\n    rb_define_method(rb_cArray, \"delete_at\", rb_ary_delete_at_m, 1);\n    rb_define_method(rb_cArray, \"delete_if\", rb_ary_delete_if, 0);\n    rb_define_method(rb_cArray, \"reject\", rb_ary_reject, 0);\n    rb_define_method(rb_cArray, \"reject!\", rb_ary_reject_bang, 0);\n    rb_define_method(rb_cArray, \"zip\", rb_ary_zip, -1);\n    rb_define_method(rb_cArray, \"transpose\", rb_ary_transpose, 0);\n    rb_define_method(rb_cArray, \"replace\", rb_ary_replace, 1);\n    rb_define_method(rb_cArray, \"clear\", rb_ary_clear, 0);\n    rb_define_method(rb_cArray, \"fill\", rb_ary_fill, -1);\n    rb_define_method(rb_cArray, \"include?\", rb_ary_includes, 1);\n    rb_define_method(rb_cArray, \"<=>\", rb_ary_cmp, 1);\n\n    rb_define_method(rb_cArray, \"slice\", rb_ary_aref, -1);\n    rb_define_method(rb_cArray, \"slice!\", rb_ary_slice_bang, -1);\n\n    rb_define_method(rb_cArray, \"assoc\", rb_ary_assoc, 1);\n    rb_define_method(rb_cArray, \"rassoc\", rb_ary_rassoc, 1);\n\n    rb_define_method(rb_cArray, \"+\", rb_ary_plus, 1);\n    rb_define_method(rb_cArray, \"*\", rb_ary_times, 1);\n\n    rb_define_method(rb_cArray, \"-\", rb_ary_diff, 1);\n    rb_define_method(rb_cArray, \"&\", rb_ary_and, 1);\n    rb_define_method(rb_cArray, \"|\", rb_ary_or, 1);\n\n    rb_define_method(rb_cArray, \"uniq\", rb_ary_uniq, 0);\n    rb_define_method(rb_cArray, \"uniq!\", rb_ary_uniq_bang, 0);\n    rb_define_method(rb_cArray, \"compact\", rb_ary_compact, 0);\n    rb_define_method(rb_cArray, \"compact!\", rb_ary_compact_bang, 0);\n    rb_define_method(rb_cArray, \"flatten\", rb_ary_flatten, 0);\n    rb_define_method(rb_cArray, \"flatten!\", rb_ary_flatten_bang, 0);\n    rb_define_method(rb_cArray, \"nitems\", rb_ary_nitems, 0);\n\n    id_cmp = rb_intern(\"<=>\");\n    inspect_key = rb_intern(\"__inspect_key__\");\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     Module.constants   => array\n *  \n *  Returns an array of the names of all constants defined in the\n *  system. This list includes the names of all modules and classes.\n *     \n *     p Module.constants.sort[1..5]\n *     \n *  <em>produces:</em>\n *     \n *     [\"ARGV\", \"ArgumentError\", \"Array\", \"Bignum\", \"Binding\"]\n */\n", "func_signal": "static VALUE\nrb_mod_s_constants()", "code": "{\n    NODE *cbase = ruby_cref;\n    void *data = 0;\n\n    while (cbase) {\n\tif (!NIL_P(cbase->nd_clss)) {\n\t    data = rb_mod_const_at(cbase->nd_clss, data);\n\t}\n\tcbase = cbase->nd_next;\n    }\n\n    if (!NIL_P(ruby_cbase)) {\n\tdata = rb_mod_const_of(ruby_cbase, data);\n    }\n    return rb_const_list(data);\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* action routine for decc$to_vms */\n", "func_signal": "static int vms_fileact(char *filespec, int type)", "code": "{\n    if (vms_filespec)\n\tfree(vms_filespec);\n    vms_filespec = malloc(strlen(filespec)+1);\n    strcpy(vms_filespec, filespec);\n    return 1;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     Process.setsid   => fixnum\n *\n *  Establishes this process as a new session and process group\n *  leader, with no controlling tty. Returns the session id. Not\n *  available on all platforms.\n *\n *     Process.setsid   #=> 27422\n */\n", "func_signal": "static VALUE\nproc_setsid()", "code": "{\n#if defined(HAVE_SETSID)\n    int pid;\n\n    rb_secure(2);\n    pid = setsid();\n    if (pid < 0) rb_sys_fail(0);\n    return INT2FIX(pid);\n#elif defined(HAVE_SETPGRP) && defined(TIOCNOTTY)\n  rb_pid_t pid;\n  int ret;\n\n  rb_secure(2);\n  pid = getpid();\n#if defined(SETPGRP_VOID)\n  ret = setpgrp();\n  /* If `pid_t setpgrp(void)' is equivalent to setsid(),\n     `ret' will be the same value as `pid', and following open() will fail.\n     In Linux, `int setpgrp(void)' is equivalent to setpgid(0, 0). */\n#else\n  ret = setpgrp(0, pid);\n#endif\n  if (ret == -1) rb_sys_fail(0);\n\n  if ((fd = open(\"/dev/tty\", O_RDWR)) >= 0) {\n    ioctl(fd, TIOCNOTTY, NULL);\n    close(fd);\n  }\n  return INT2FIX(pid);\n#else\n    rb_notimplement();\n#endif\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\n", "func_signal": "static void\ninit_by_array(unsigned long init_key[], int key_length)", "code": "{\n    int i, j, k;\n    init_genrand(19650218UL);\n    i=1; j=0;\n    k = (N>key_length ? N : key_length);\n    for (; k; k--) {\n        state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL))\n          + init_key[j] + j; /* non linear */\n        state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\n        i++; j++;\n        if (i>=N) { state[0] = state[N-1]; i=1; }\n        if (j>=key_length) j=0;\n    }\n    for (k=N-1; k; k--) {\n        state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL))\n          - i; /* non linear */\n        state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\n        i++;\n        if (i>=N) { state[0] = state[N-1]; i=1; }\n    }\n\n    state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ \n    left = 1; initf = 1;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  <code>Object</code> is the parent class of all classes in Ruby. Its\n *  methods are therefore available to all objects unless explicitly\n *  overridden.\n *     \n *  <code>Object</code> mixes in the <code>Kernel</code> module, making\n *  the built-in kernel functions globally accessible. Although the\n *  instance methods of <code>Object</code> are defined by the\n *  <code>Kernel</code> module, we have chosen to document them here for\n *  clarity.\n *     \n *  In the descriptions of Object's methods, the parameter <i>symbol</i> refers\n *  to a symbol, which is either a quoted string or a\n *  <code>Symbol</code> (such as <code>:name</code>).\n */\n", "func_signal": "void\nInit_Object()", "code": "{\n    VALUE metaclass;\n\n    rb_cObject = boot_defclass(\"Object\", 0);\n    rb_cModule = boot_defclass(\"Module\", rb_cObject);\n    rb_cClass =  boot_defclass(\"Class\",  rb_cModule);\n\n    metaclass = rb_make_metaclass(rb_cObject, rb_cClass);\n    metaclass = rb_make_metaclass(rb_cModule, metaclass);\n    metaclass = rb_make_metaclass(rb_cClass, metaclass);\n\n    rb_mKernel = rb_define_module(\"Kernel\");\n    rb_include_module(rb_cObject, rb_mKernel);\n    rb_define_alloc_func(rb_cObject, rb_class_allocate_instance);\n    rb_define_private_method(rb_cObject, \"initialize\", rb_obj_dummy, 0);\n    rb_define_private_method(rb_cClass, \"inherited\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_cModule, \"included\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_cModule, \"extended\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_cModule, \"method_added\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_cModule, \"method_removed\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_cModule, \"method_undefined\", rb_obj_dummy, 1);\n\n\n    rb_define_method(rb_mKernel, \"nil?\", rb_false, 0);\n    rb_define_method(rb_mKernel, \"==\", rb_obj_equal, 1);\n    rb_define_method(rb_mKernel, \"equal?\", rb_obj_equal, 1);\n    rb_define_method(rb_mKernel, \"===\", rb_equal, 1); \n    rb_define_method(rb_mKernel, \"=~\", rb_obj_pattern_match, 1);\n\n    rb_define_method(rb_mKernel, \"eql?\", rb_obj_equal, 1);\n\n    rb_define_method(rb_mKernel, \"id\", rb_obj_id_obsolete, 0);\n    rb_define_method(rb_mKernel, \"type\", rb_obj_type, 0);\n    rb_define_method(rb_mKernel, \"class\", rb_obj_class, 0);\n\n    rb_define_method(rb_mKernel, \"clone\", rb_obj_clone, 0);\n    rb_define_method(rb_mKernel, \"dup\", rb_obj_dup, 0);\n    rb_define_method(rb_mKernel, \"initialize_copy\", rb_obj_init_copy, 1);\n\n    rb_define_method(rb_mKernel, \"taint\", rb_obj_taint, 0);\n    rb_define_method(rb_mKernel, \"tainted?\", rb_obj_tainted, 0);\n    rb_define_method(rb_mKernel, \"untaint\", rb_obj_untaint, 0);\n    rb_define_method(rb_mKernel, \"freeze\", rb_obj_freeze, 0);\n    rb_define_method(rb_mKernel, \"frozen?\", rb_obj_frozen_p, 0);\n\n    rb_define_method(rb_mKernel, \"to_a\", rb_any_to_a, 0); /* to be removed */\n    rb_define_method(rb_mKernel, \"to_s\", rb_any_to_s, 0);\n    rb_define_method(rb_mKernel, \"inspect\", rb_obj_inspect, 0);\n    rb_define_method(rb_mKernel, \"methods\", rb_obj_methods, -1);\n    rb_define_method(rb_mKernel, \"singleton_methods\", \n\t\t     rb_obj_singleton_methods, -1); /* in class.c */\n    rb_define_method(rb_mKernel, \"protected_methods\", \n\t\t     rb_obj_protected_methods, -1);\n    rb_define_method(rb_mKernel, \"private_methods\", rb_obj_private_methods, -1);\n    rb_define_method(rb_mKernel, \"public_methods\", rb_obj_public_methods, -1);\n    rb_define_method(rb_mKernel, \"instance_variables\", \n\t\t     rb_obj_instance_variables, 0); /* in variable.c */\n    rb_define_method(rb_mKernel, \"instance_variable_get\", rb_obj_ivar_get, 1);\n    rb_define_method(rb_mKernel, \"instance_variable_set\", rb_obj_ivar_set, 2);\n    rb_define_method(rb_mKernel, \"instance_variable_defined?\", rb_obj_ivar_defined, 1);\n    rb_define_private_method(rb_mKernel, \"remove_instance_variable\",\n\t\t\t     rb_obj_remove_instance_variable, 1); /* in variable.c */\n\n    rb_define_method(rb_mKernel, \"instance_of?\", rb_obj_is_instance_of, 1);\n    rb_define_method(rb_mKernel, \"kind_of?\", rb_obj_is_kind_of, 1);\n    rb_define_method(rb_mKernel, \"is_a?\", rb_obj_is_kind_of, 1);\n\n    rb_define_private_method(rb_mKernel, \"singleton_method_added\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_mKernel, \"singleton_method_removed\", rb_obj_dummy, 1);\n    rb_define_private_method(rb_mKernel, \"singleton_method_undefined\", rb_obj_dummy, 1);\n\n    rb_define_global_function(\"sprintf\", rb_f_sprintf, -1); /* in sprintf.c */\n    rb_define_global_function(\"format\", rb_f_sprintf, -1);  /* in sprintf.c  */\n\n    rb_define_global_function(\"Integer\", rb_f_integer, 1);\n    rb_define_global_function(\"Float\", rb_f_float, 1);\n\n    rb_define_global_function(\"String\", rb_f_string, 1);\n    rb_define_global_function(\"Array\", rb_f_array, 1);\n\n    rb_cNilClass = rb_define_class(\"NilClass\", rb_cObject);\n    rb_define_method(rb_cNilClass, \"to_i\", nil_to_i, 0);\n    rb_define_method(rb_cNilClass, \"to_f\", nil_to_f, 0);\n    rb_define_method(rb_cNilClass, \"to_s\", nil_to_s, 0);\n    rb_define_method(rb_cNilClass, \"to_a\", nil_to_a, 0);\n    rb_define_method(rb_cNilClass, \"inspect\", nil_inspect, 0);\n    rb_define_method(rb_cNilClass, \"&\", false_and, 1);\n    rb_define_method(rb_cNilClass, \"|\", false_or, 1);\n    rb_define_method(rb_cNilClass, \"^\", false_xor, 1);\n\n    rb_define_method(rb_cNilClass, \"nil?\", rb_true, 0);\n    rb_undef_alloc_func(rb_cNilClass);\n    rb_undef_method(CLASS_OF(rb_cNilClass), \"new\");\n    rb_define_global_const(\"NIL\", Qnil);\n\n    rb_cSymbol = rb_define_class(\"Symbol\", rb_cObject);\n    rb_define_singleton_method(rb_cSymbol, \"all_symbols\", \n\t\t\t       rb_sym_all_symbols, 0); /* in parse.y */\n    rb_undef_alloc_func(rb_cSymbol);\n    rb_undef_method(CLASS_OF(rb_cSymbol), \"new\");\n\n    rb_define_method(rb_cSymbol, \"to_i\", sym_to_i, 0);\n    rb_define_method(rb_cSymbol, \"to_int\", sym_to_int, 0);\n    rb_define_method(rb_cSymbol, \"inspect\", sym_inspect, 0);\n    rb_define_method(rb_cSymbol, \"to_s\", sym_to_s, 0);\n    rb_define_method(rb_cSymbol, \"id2name\", sym_to_s, 0);\n    rb_define_method(rb_cSymbol, \"to_sym\", sym_to_sym, 0);\n    rb_define_method(rb_cSymbol, \"===\", rb_obj_equal, 1); \n\n    rb_define_method(rb_cModule, \"freeze\", rb_mod_freeze, 0);\n    rb_define_method(rb_cModule, \"===\", rb_mod_eqq, 1);\n    rb_define_method(rb_cModule, \"==\", rb_obj_equal, 1);\n    rb_define_method(rb_cModule, \"<=>\",  rb_mod_cmp, 1);\n    rb_define_method(rb_cModule, \"<\",  rb_mod_lt, 1);\n    rb_define_method(rb_cModule, \"<=\", rb_class_inherited_p, 1);\n    rb_define_method(rb_cModule, \">\",  rb_mod_gt, 1);\n    rb_define_method(rb_cModule, \">=\", rb_mod_ge, 1);\n    rb_define_method(rb_cModule, \"initialize_copy\", rb_mod_init_copy, 1); /* in class.c */\n    rb_define_method(rb_cModule, \"to_s\", rb_mod_to_s, 0);\n    rb_define_method(rb_cModule, \"included_modules\", \n\t\t     rb_mod_included_modules, 0); /* in class.c */\n    rb_define_method(rb_cModule, \"include?\", rb_mod_include_p, 1); /* in class.c */\n    rb_define_method(rb_cModule, \"name\", rb_mod_name, 0);  /* in variable.c */\n    rb_define_method(rb_cModule, \"ancestors\", rb_mod_ancestors, 0); /* in class.c */\n\n    rb_define_private_method(rb_cModule, \"attr\", rb_mod_attr, -1);\n    rb_define_private_method(rb_cModule, \"attr_reader\", rb_mod_attr_reader, -1);\n    rb_define_private_method(rb_cModule, \"attr_writer\", rb_mod_attr_writer, -1);\n    rb_define_private_method(rb_cModule, \"attr_accessor\", rb_mod_attr_accessor, -1);\n\n    rb_define_alloc_func(rb_cModule, rb_module_s_alloc);\n    rb_define_method(rb_cModule, \"initialize\", rb_mod_initialize, 0);\n    rb_define_method(rb_cModule, \"instance_methods\", \n\t\t     rb_class_instance_methods, -1);           /* in class.c */\n    rb_define_method(rb_cModule, \"public_instance_methods\", \n\t\t     rb_class_public_instance_methods, -1);    /* in class.c */\n    rb_define_method(rb_cModule, \"protected_instance_methods\", \n\t\t     rb_class_protected_instance_methods, -1); /* in class.c */\n    rb_define_method(rb_cModule, \"private_instance_methods\", \n\t\t     rb_class_private_instance_methods, -1);   /* in class.c */\n\n    rb_define_method(rb_cModule, \"class_variable_defined?\", rb_mod_cvar_defined, 1);\n    rb_define_method(rb_cModule, \"constants\", rb_mod_constants, 0); /* in variable.c */\n    rb_define_method(rb_cModule, \"const_get\", rb_mod_const_get, 1);\n    rb_define_method(rb_cModule, \"const_set\", rb_mod_const_set, 2);\n    rb_define_method(rb_cModule, \"const_defined?\", rb_mod_const_defined, 1);\n    rb_define_private_method(rb_cModule, \"remove_const\", \n\t\t\t     rb_mod_remove_const, 1); /* in variable.c */\n    rb_define_method(rb_cModule, \"const_missing\", \n\t\t     rb_mod_const_missing, 1); /* in variable.c */\n    rb_define_method(rb_cModule, \"class_variables\", \n\t\t     rb_mod_class_variables, 0); /* in variable.c */\n    rb_define_private_method(rb_cModule, \"remove_class_variable\", \n\t\t\t     rb_mod_remove_cvar, 1); /* in variable.c */\n    rb_define_private_method(rb_cModule, \"class_variable_get\", rb_mod_cvar_get, 1);\n    rb_define_private_method(rb_cModule, \"class_variable_set\", rb_mod_cvar_set, 2);\n\n    rb_define_method(rb_cClass, \"allocate\", rb_obj_alloc, 0);\n    rb_define_method(rb_cClass, \"new\", rb_class_new_instance, -1);\n    rb_define_method(rb_cClass, \"initialize\", rb_class_initialize, -1);\n    rb_define_method(rb_cClass, \"initialize_copy\", rb_class_init_copy, 1); /* in class.c */\n    rb_define_method(rb_cClass, \"superclass\", rb_class_superclass, 0);\n    rb_define_alloc_func(rb_cClass, rb_class_s_alloc);\n    rb_undef_method(rb_cClass, \"extend_object\");\n    rb_undef_method(rb_cClass, \"append_features\");\n\n    rb_cData = rb_define_class(\"Data\", rb_cObject);\n    rb_undef_alloc_func(rb_cData);\n\n    rb_global_variable(&ruby_top_self);\n    ruby_top_self = rb_obj_alloc(rb_cObject);\n    rb_define_singleton_method(ruby_top_self, \"to_s\", main_to_s, 0);\n\n    rb_cTrueClass = rb_define_class(\"TrueClass\", rb_cObject);\n    rb_define_method(rb_cTrueClass, \"to_s\", true_to_s, 0);\n    rb_define_method(rb_cTrueClass, \"&\", true_and, 1);\n    rb_define_method(rb_cTrueClass, \"|\", true_or, 1);\n    rb_define_method(rb_cTrueClass, \"^\", true_xor, 1);\n    rb_undef_alloc_func(rb_cTrueClass);\n    rb_undef_method(CLASS_OF(rb_cTrueClass), \"new\");\n    rb_define_global_const(\"TRUE\", Qtrue);\n\n    rb_cFalseClass = rb_define_class(\"FalseClass\", rb_cObject);\n    rb_define_method(rb_cFalseClass, \"to_s\", false_to_s, 0);\n    rb_define_method(rb_cFalseClass, \"&\", false_and, 1);\n    rb_define_method(rb_cFalseClass, \"|\", false_or, 1);\n    rb_define_method(rb_cFalseClass, \"^\", false_xor, 1);\n    rb_undef_alloc_func(rb_cFalseClass);\n    rb_undef_method(CLASS_OF(rb_cFalseClass), \"new\");\n    rb_define_global_const(\"FALSE\", Qfalse);\n\n    id_eq = rb_intern(\"==\");\n    id_eql = rb_intern(\"eql?\");\n    id_inspect = rb_intern(\"inspect\");\n    id_init_copy = rb_intern(\"initialize_copy\");\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* __GNUC__ */\n", "func_signal": "static void\ngarbage_collect()", "code": "{\n    struct gc_list *list;\n    struct FRAME * volatile frame; /* gcc 2.7.2.3 -O2 bug??  */\n    jmp_buf save_regs_gc_mark;\n    SET_STACK_END;\n\n#ifdef HAVE_NATIVETHREAD\n    if (!is_ruby_native_thread()) {\n\trb_bug(\"cross-thread violation on rb_gc()\");\n    }\n#endif\n    if (dont_gc || during_gc) {\n\tif (!freelist) {\n\t    add_heap();\n\t}\n\treturn;\n    }\n    if (during_gc) return;\n    during_gc++;\n\n    init_mark_stack();\n\n    gc_mark((VALUE)ruby_current_node, 0);\n\n    /* mark frame stack */\n    for (frame = ruby_frame; frame; frame = frame->prev) {\n\trb_gc_mark_frame(frame);\n\tif (frame->tmp) {\n\t    struct FRAME *tmp = frame->tmp;\n\t    while (tmp) {\n\t\trb_gc_mark_frame(tmp);\n\t\ttmp = tmp->prev;\n\t    }\n\t}\n    }\n    gc_mark((VALUE)ruby_scope, 0);\n    gc_mark((VALUE)ruby_dyna_vars, 0);\n    if (finalizer_table) {\n\tmark_tbl(finalizer_table, 0);\n    }\n\n    FLUSH_REGISTER_WINDOWS;\n    /* This assumes that all registers are saved into the jmp_buf (and stack) */\n    setjmp(save_regs_gc_mark);\n    mark_locations_array((VALUE*)save_regs_gc_mark, sizeof(save_regs_gc_mark) / sizeof(VALUE *));\n#if STACK_GROW_DIRECTION < 0\n    rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);\n#elif STACK_GROW_DIRECTION > 0\n    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);\n#else\n    if ((VALUE*)STACK_END < rb_gc_stack_start)\n\trb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);\n    else\n\trb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);\n#endif\n#ifdef __ia64\n    /* mark backing store (flushed register window on the stack) */\n    /* the basic idea from guile GC code                         */\n    rb_gc_mark_locations(rb_gc_register_stack_start, (VALUE*)rb_ia64_bsp());\n#endif\n#if defined(__human68k__) || defined(__mc68000__)\n    rb_gc_mark_locations((VALUE*)((char*)STACK_END + 2),\n\t\t\t (VALUE*)((char*)rb_gc_stack_start + 2));\n#endif\n    rb_gc_mark_threads();\n\n    /* mark protected global variables */\n    for (list = global_List; list; list = list->next) {\n\trb_gc_mark_maybe(*list->varptr);\n    }\n    rb_mark_end_proc();\n    rb_gc_mark_global_tbl();\n\n    rb_mark_tbl(rb_class_tbl);\n    rb_gc_mark_trap_list();\n\n    /* mark generic instance variables for special constants */\n    rb_mark_generic_ivar_tbl();\n\n    rb_gc_mark_parser();\n\n    /* gc_mark objects whose marking are not completed*/\n    do {\n\twhile (!MARK_STACK_EMPTY) {\n\t    if (mark_stack_overflow){\n\t\tgc_mark_all();\n\t    }\n\t    else {\n\t\tgc_mark_rest();\n\t    }\n\t}\n\trb_gc_abort_threads();\n    } while (!MARK_STACK_EMPTY);\n\n    gc_sweep();\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     chop   => string\n *  \n *  Equivalent to <code>($_.dup).chop!</code>, except <code>nil</code>\n *  is never returned. See <code>String#chop!</code>.\n *     \n *     a  =  \"now\\r\\n\"\n *     $_ = a\n *     chop   #=> \"now\"\n *     $_     #=> \"now\"\n *     chop   #=> \"no\"\n *     chop   #=> \"n\"\n *     chop   #=> \"\"\n *     chop   #=> \"\"\n *     a      #=> \"now\\r\\n\"\n */\n", "func_signal": "static VALUE\nrb_f_chop()", "code": "{\n    VALUE str = uscore_get();\n\n    if (RSTRING(str)->len > 0) {\n\tstr = rb_str_dup(str);\n\trb_str_chop_bang(str);\n\trb_lastline_set(str);\n    }\n    return str;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     Module.nesting    => array\n *  \n *  Returns the list of +Modules+ nested at the point of call.\n *     \n *     module M1\n *       module M2\n *         $a = Module.nesting\n *       end\n *     end\n *     $a           #=> [M1::M2, M1]\n *     $a[0].name   #=> \"M1::M2\"\n */\n", "func_signal": "static VALUE\nrb_mod_nesting()", "code": "{\n    NODE *cbase = ruby_cref;\n    VALUE ary = rb_ary_new();\n\n    while (cbase && cbase->nd_next) {\n\tif (!NIL_P(cbase->nd_clss)) rb_ary_push(ary, cbase->nd_clss);\n\tcbase = cbase->nd_next;\n    }\n    if (ruby_wrapper && RARRAY(ary)->len == 0) {\n\trb_ary_push(ary, ruby_wrapper);\n    }\n    return ary;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* System call with warning */\n", "func_signal": "static int\ndo_stat(const char *path, struct stat *pst, int flags)", "code": "{\n    int ret = stat(path, pst);\n    if (ret < 0 && !to_be_ignored(errno))\n\tsys_warning(path);\n\n    return ret;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/* freedtoa(s) must be used to free values s returned by dtoa\n * when MULTIPLE_THREADS is #defined.  It should be used in all cases,\n * but for consistency with earlier versions of dtoa, it is optional\n * when MULTIPLE_THREADS is not defined.\n */\n", "func_signal": "void\nfreedtoa(char *s)", "code": "{\n    Bigint *b = (Bigint *)((int *)s - 1);\n    b->maxwds = 1 << (b->k = *(int*)b);\n    Bfree(b);\n#ifndef MULTIPLE_THREADS\n    if (s == dtoa_result)\n        dtoa_result = 0;\n#endif\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     obj.hash    => fixnum\n *  \n *  Generates a <code>Fixnum</code> hash value for this object. This\n *  function must have the property that <code>a.eql?(b)</code> implies\n *  <code>a.hash == b.hash</code>. The hash value is used by class\n *  <code>Hash</code>. Any hash value that exceeds the capacity of a\n *  <code>Fixnum</code> will be truncated before being used.\n */\n", "func_signal": "VALUE\nrb_obj_id(VALUE obj)", "code": "{\n    /*\n     *                32-bit VALUE space\n     *          MSB ------------------------ LSB\n     *  false   00000000000000000000000000000000\n     *  true    00000000000000000000000000000010\n     *  nil     00000000000000000000000000000100\n     *  undef   00000000000000000000000000000110\n     *  symbol  ssssssssssssssssssssssss00001110\n     *  object  oooooooooooooooooooooooooooooo00        = 0 (mod sizeof(RVALUE))\n     *  fixnum  fffffffffffffffffffffffffffffff1\n     *\n     *                    object_id space\n     *                                       LSB\n     *  false   00000000000000000000000000000000\n     *  true    00000000000000000000000000000010\n     *  nil     00000000000000000000000000000100\n     *  undef   00000000000000000000000000000110\n     *  symbol   000SSSSSSSSSSSSSSSSSSSSSSSSSSS0        S...S % A = 4 (S...S = s...s * A + 4)\n     *  object   oooooooooooooooooooooooooooooo0        o...o % A = 0\n     *  fixnum  fffffffffffffffffffffffffffffff1        bignum if required\n     *\n     *  where A = sizeof(RVALUE)/4\n     *\n     *  sizeof(RVALUE) is\n     *  20 if 32-bit, double is 4-byte aligned\n     *  24 if 32-bit, double is 8-byte aligned\n     *  40 if 64-bit\n     */\n    if (TYPE(obj) == T_SYMBOL) {\n        return (SYM2ID(obj) * sizeof(RVALUE) + (4 << 2)) | FIXNUM_FLAG;\n    }\n    if (SPECIAL_CONST_P(obj)) {\n        return LONG2NUM((long)obj);\n    }\n    return (VALUE)((long)obj|FIXNUM_FLAG);\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "/*\n *  call-seq:\n *     Dir[ array ]                 => array\n *     Dir[ string [, string ...] ] => array\n *\n *  Equivalent to calling\n *  <code>Dir.glob(</code><i>array,</i><code>0)</code> and \n *  <code>Dir.glob([</code><i>string,...</i><code>],0)</code>.\n *\n */\n", "func_signal": "static VALUE\ndir_s_aref(int argc, VALUE *argv, VALUE obj)", "code": "{\n    if (argc == 1) {\n\treturn rb_push_glob(argv[0], 0);\n    }\n    return dir_globs(argc, argv, 0);\n }\n\n/*\n *  call-seq:\n *     Dir.glob( pattern, [flags] ) => array\n *     Dir.glob( pattern, [flags] ) {| filename | block }  => nil\n *\n *  Returns the filenames found by expanding <i>pattern</i> which is\n *  an +Array+ of the patterns or the pattern +String+, either as an\n *  <i>array</i> or as parameters to the block. Note that this pattern\n *  is not a regexp (it's closer to a shell glob). See\n *  <code>File::fnmatch</code> for the meaning of the <i>flags</i>\n *  parameter. Note that case sensitivity depends on your system (so\n *  <code>File::FNM_CASEFOLD</code> is ignored)\n *\n *  <code>*</code>::        Matches any file. Can be restricted by\n *                          other values in the glob. <code>*</code>\n *                          will match all files; <code>c*</code> will\n *                          match all files beginning with\n *                          <code>c</code>; <code>*c</code> will match\n *                          all files ending with <code>c</code>; and\n *                          <code>*c*</code> will match all files that\n *                          have <code>c</code> in them (including at\n *                          the beginning or end). Equivalent to\n *                          <code>/ .* /x</code> in regexp.\n *  <code>**</code>::       Matches directories recursively.\n *  <code>?</code>::        Matches any one character. Equivalent to\n *                          <code>/.{1}/</code> in regexp.\n *  <code>[set]</code>::    Matches any one character in +set+.\n *                          Behaves exactly like character sets in\n *                          Regexp, including set negation\n *                          (<code>[^a-z]</code>).\n *  <code>{p,q}</code>::    Matches either literal <code>p</code> or\n *                          literal <code>q</code>. Matching literals\n *                          may be more than one character in length.\n *                          More than two literals may be specified.\n *                          Equivalent to pattern alternation in\n *                          regexp.\n *  <code>\\</code>::        Escapes the next metacharacter.\n *\n *     Dir[\"config.?\"]                     #=> [\"config.h\"]\n *     Dir.glob(\"config.?\")                #=> [\"config.h\"]\n *     Dir.glob(\"*.[a-z][a-z]\")            #=> [\"main.rb\"]\n *     Dir.glob(\"*.[^r]*\")                 #=> [\"config.h\"]\n *     Dir.glob(\"*.{rb,h}\")                #=> [\"main.rb\", \"config.h\"]\n *     Dir.glob(\"*\")                       #=> [\"config.h\", \"main.rb\"]\n *     Dir.glob(\"*\", File::FNM_DOTMATCH)   #=> [\".\", \"..\", \"config.h\", \"main.rb\"]\n *\n *     rbfiles = File.join(\"**\", \"*.rb\")\n *     Dir.glob(rbfiles)                   #=> [\"main.rb\",\n *                                              \"lib/song.rb\",\n *                                              \"lib/song/karaoke.rb\"]\n *     libdirs = File.join(\"**\", \"lib\")\n *     Dir.glob(libdirs)                   #=> [\"lib\"]\n *\n *     librbfiles = File.join(\"**\", \"lib\", \"**\", \"*.rb\")\n *     Dir.glob(librbfiles)                #=> [\"lib/song.rb\",\n *                                              \"lib/song/karaoke.rb\"]\n *\n *     librbfiles = File.join(\"**\", \"lib\", \"*.rb\")\n *     Dir.glob(librbfiles)                #=> [\"lib/song.rb\"]\n */\nstatic VALUE\ndir_s_glob(argc, argv, obj)\n    int argc;\n    VALUE *argv;\n    VALUE obj;\n{\n    VALUE str, rflags, ary;\n    int flags;\n\n    if (rb_scan_args(argc, argv, \"11\", &str, &rflags) == 2)\n\tflags = NUM2INT(rflags);\n    else\n\tflags = 0;\n\n    ary = rb_check_array_type(str);\n    if (NIL_P(ary)) {\n\tary = rb_push_glob(str, flags);\n    }\n    else {\n\tvolatile VALUE v = ary;\n\tary = dir_globs(RARRAY_LEN(v), RARRAY_PTR(v), flags);\n    }\n\n    if (rb_block_given_p()) {\n\trb_ary_each(ary);\n\treturn Qnil;\n    }\n    return ary;\n}", "path": "test\\scanners\\c\\ruby.in.c", "repo_name": "raldred/CodeRay", "stars": 7, "license": "lgpl-2.1", "language": "c", "size": 10739}
{"docstring": "// \u0221PSP\u02a3\u06b4\u68ec\u03bb\u03aaBytes\n// :\u02ab\u0175\n", "func_signal": "extern unsigned int get_free_mem(void)", "code": "{\n#ifdef DMALLOC\n\tunsigned long all = 0;\n\tunsigned long allocated = 0;\n\n\tdmalloc_get_stats(NULL, NULL, NULL, &all, &allocated, NULL, NULL, NULL,\n\t\t\t\t\t  NULL);\n\n\t// return all - allocated;\n\treturn 25 * 1024 * 1024 - allocated;\n#else\n\tvoid *p[512];\n\tunsigned int block_size = 0x04000000;\t//\u06b4:64MB,2N\u03b7\n\tunsigned int block_free = 0;\n\tint i = 0;\n\n\twhile ((block_size >>= 1) >= 0x0400)\t//\u0421:1KB\n\t{\n\t\tif (NULL != (p[i] = malloc(block_size))) {\n\t\t\tblock_free |= block_size;\n\t\t\t++i;\n\n\t\t\tif (i == sizeof(p) / sizeof(p[0])) {\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (NULL != (p[i] = malloc(0x8000)))\t//\u0421:32KB\n\t{\n\t\tblock_free += 0x8000;\n\t\t++i;\n\n\t\tif (i == sizeof(p) / sizeof(p[0])) {\n\t\t\tgoto abort;\n\t\t}\n\t}\n\n  abort:\n\twhile (i--) {\n\t\tfree(p[i]);\n\t}\n\n\treturn block_free;\n#endif\n}", "path": "src\\common\\utils.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u01f7\u03aaAT3\u013c\u013f\u01f0\u05bb\u013c\u05fa\n *\n * @param spath \u01f08.3\u00b7\u02bd\n *\n * @return AT3\u013c1\uda9f\udd7b0\n */\n", "func_signal": "static int at3_probe(const char *spath)", "code": "{\n\tconst char *p;\n\n\tp = utils_fileext(spath);\n\n\tif (p) {\n\t\tif (stricmp(p, \"at3\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \n *\n * @return\n * - -1 should exit\n * - 0 OK\n */\n", "func_signal": "static int handle_seek(void)", "code": "{\n\tu64 timer_end;\n\n\tif (g_status == ST_FFORWARD) {\n\t\txrRtcGetCurrentTick(&timer_end);\n\n\t\tgeneric_lock();\n\t\tif (g_last_seek_is_forward) {\n\t\t\tgeneric_unlock();\n\n\t\t\tif (pspDiffTime(&timer_end, (u64 *) & g_last_seek_tick) <= 1.0) {\n\t\t\t\tgeneric_lock();\n\n\t\t\t\tif (g_seek_count > 0) {\n\t\t\t\t\tg_play_time += g_seek_seconds;\n\t\t\t\t\tg_seek_count--;\n\t\t\t\t}\n\n\t\t\t\tgeneric_unlock();\n\n\t\t\t\tif (g_play_time >= g_info.duration) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\txrKernelDelayThread(100000);\n\t\t\t} else {\n\t\t\t\tgeneric_lock();\n\n\t\t\t\tg_seek_count = 0;\n\t\t\t\tgeneric_set_playback(true);\n\n\t\t\t\tif (wv_seek_seconds(g_play_time) < 0) {\n\t\t\t\t\tgeneric_unlock();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tg_status = ST_PLAYING;\n\n\t\t\t\tgeneric_unlock();\n\t\t\t\txrKernelDelayThread(100000);\n\t\t\t}\n\t\t} else {\n\t\t\tgeneric_unlock();\n\t\t}\n\t} else if (g_status == ST_FBACKWARD) {\n\t\txrRtcGetCurrentTick(&timer_end);\n\n\t\tgeneric_lock();\n\t\tif (!g_last_seek_is_forward) {\n\t\t\tgeneric_unlock();\n\n\t\t\tif (pspDiffTime(&timer_end, (u64 *) & g_last_seek_tick) <= 1.0) {\n\t\t\t\tgeneric_lock();\n\n\t\t\t\tif (g_seek_count > 0) {\n\t\t\t\t\tg_play_time -= g_seek_seconds;\n\t\t\t\t\tg_seek_count--;\n\t\t\t\t}\n\n\t\t\t\tgeneric_unlock();\n\n\t\t\t\tif (g_play_time < 0) {\n\t\t\t\t\tg_play_time = 0;\n\t\t\t\t}\n\n\t\t\t\txrKernelDelayThread(100000);\n\t\t\t} else {\n\t\t\t\tgeneric_lock();\n\n\t\t\t\tg_seek_count = 0;\n\t\t\t\tgeneric_set_playback(true);\n\n\t\t\t\tif (wv_seek_seconds(g_play_time) < 0) {\n\t\t\t\t\tgeneric_unlock();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tg_status = ST_PLAYING;\n\n\t\t\t\tgeneric_unlock();\n\t\t\t\txrKernelDelayThread(100000);\n\t\t\t}\n\t\t} else {\n\t\t\tgeneric_unlock();\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/// TODO: temp hack\n", "func_signal": "static int push_back_byte(void *id, int c)", "code": "{\n\tset_pos_rel(id, -1, SEEK_CUR);\n\n\treturn c;\n//    return ungetc (c, id);\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * PSP\u05fc\u02b1at3\u0132\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int at3_suspend(void)", "code": "{\n\tgeneric_suspend();\n\tat3_end();\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u0775\n *\n * @note \u0138\u02bd\u03aa\u02eb16\u03bb\n *\n * @param buf \u05b8\n * @param srcbuf \u077b\u05b8\n * @param frames \u05a1\n * @param channels \n */\n", "func_signal": "static void send_to_sndbuf(void *buf, uint16_t * srcbuf, int frames,\n\t\t\t\t\t\t   int channels)", "code": "{\n\tint n;\n\tsigned short *p = (signed short *) buf;\n\n\tif (frames <= 0)\n\t\treturn;\n\n\tif (channels == 2) {\n\t\tmemcpy(buf, srcbuf, frames * channels * sizeof(*srcbuf));\n\t} else {\n\t\tfor (n = 0; n < frames * channels; n++) {\n\t\t\t*p++ = srcbuf[n];\n\t\t\t*p++ = srcbuf[n];\n\t\t}\n\t}\n\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * PSP\u05fc\u02b1WvPack\u0132\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int wv_suspend(void)", "code": "{\n\tgeneric_suspend();\n\twv_end();\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u02bc\u0534\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int __init(void)", "code": "{\n\tgeneric_init();\n\tgeneric_lock();\n\tg_status = ST_UNKNOWN;\n\tgeneric_unlock();\n\n\tg_buff_frame_size = g_buff_frame_start = 0;\n\tg_seek_seconds = 0;\n\tg_play_time = 0.;\n\tmemset(&g_info, 0, sizeof(g_info));\n\twv_buffer = NULL;\n\tg_decoder = NULL;\n\tg_encode_name[0] = '\\0';\n\tg_mode = 0;\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * PSP\u05fc\u02b1\u05b8at3\u0132\n *\n * @param spath \u01f08.3\u00b7\u02bd\n * @param lpath \u01f0\u013c\u02bd\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int at3_resume(const char *spath, const char *lpath)", "code": "{\n\tint ret;\n\n\tret = at3_load(spath, lpath);\n\n\tif (ret != 0) {\n\t\tdbg_printf(d, \"%s: at3_load failed %d\", __func__, ret);\n\t\treturn -1;\n\t}\n\n\tg_play_time = g_suspend_playing_time;\n\tat3_seek_seconds(g_play_time);\n\tg_suspend_playing_time = 0;\n\n\tgeneric_resume(spath, lpath);\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * WvPack\u05b2\u017b\u0635\n * \ud8b6\udefd\n *\n * @note \u0138\u02bd\u03aa\u02eb16\u03bb\n *\n * @param buf \u05b8\n * @param reqn \u05a1\u0421\n * @param pdata \u00fb\u0763\n */\n", "func_signal": "static int wv_audiocallback(void *buf, unsigned int reqn, void *pdata)", "code": "{\n\tint avail_frame;\n\tint snd_buf_frame_size = (int) reqn;\n\tdouble incr;\n\tsigned short *audio_buf = buf;\n\n\tUNUSED(pdata);\n\n\tif (g_status != ST_PLAYING) {\n\t\tif (handle_seek() == -1) {\n\t\t\t__end();\n\t\t\treturn -1;\n\t\t}\n\n\t\txAudioClearSndBuf(buf, snd_buf_frame_size);\n\t\txrKernelDelayThread(100000);\n\t\treturn 0;\n\t}\n\n\twhile (snd_buf_frame_size > 0) {\n\t\tavail_frame = g_buff_frame_size - g_buff_frame_start;\n\n\t\tif (avail_frame >= snd_buf_frame_size) {\n\t\t\tsend_to_sndbuf(audio_buf,\n\t\t\t\t\t\t   &g_buff[g_buff_frame_start * g_info.channels],\n\t\t\t\t\t\t   snd_buf_frame_size, g_info.channels);\n\t\t\tg_buff_frame_start += snd_buf_frame_size;\n\t\t\taudio_buf += snd_buf_frame_size * 2;\n\t\t\tsnd_buf_frame_size = 0;\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tsend_to_sndbuf(audio_buf,\n\t\t\t\t\t\t   &g_buff[g_buff_frame_start * g_info.channels],\n\t\t\t\t\t\t   avail_frame, g_info.channels);\n\t\t\tsnd_buf_frame_size -= avail_frame;\n\t\t\taudio_buf += avail_frame * 2;\n\t\t\tret = WavpackUnpackSamples(g_decoder, wv_buffer, MAX_BLOCK_SIZE);\n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tuint8_t *output;\n\t\t\t\t\n\t\t\t\tif (ret > g_buff_size) {\n\t\t\t\t\tg_buff_size = ret;\n\t\t\t\t\tg_buff =\n\t\t\t\t\t\tsafe_realloc(g_buff,\n\t\t\t\t\t\t\t\t\t g_buff_size * g_info.channels *\n\t\t\t\t\t\t\t\t\t sizeof(*g_buff));\n\n\t\t\t\t\tif (g_buff == NULL) {\n\t\t\t\t\t\t__end();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput = (uint8_t *) g_buff;\n\n\t\t\t\tfor (i = 0; i < ret; ++i) {\n\t\t\t\t\t*output++ = wv_buffer[2 * i];\n\t\t\t\t\t*output++ = wv_buffer[2 * i] >> 8;\n\t\t\t\t\t*output++ = wv_buffer[2 * i + 1];\n\t\t\t\t\t*output++ = wv_buffer[2 * i + 1] >> 8;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__end();\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tg_buff_frame_size = ret;\n\t\t\tg_buff_frame_start = 0;\n\n\t\t\tincr = 1.0 * g_buff_frame_size / g_info.sample_freq;\n\n\t\t\tg_play_time += incr;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u0775\n *\n * @note \u0138\u02bd\u03aa\u02eb16\u03bb\n *\n * @param buf \u05b8\n * @param srcbuf \u077b\u05b8\n * @param frames \u05a1\n * @param channels \n */\n", "func_signal": "static void send_to_sndbuf(void *buf, uint16_t * srcbuf, int frames,\n\t\t\t\t\t\t   int channels)", "code": "{\n\tint n;\n\tsigned short *p = (signed short *) buf;\n\n\tif (frames <= 0)\n\t\treturn;\n\n\tif (channels == 2) {\n\t\tmemcpy(buf, srcbuf, frames * channels * sizeof(*srcbuf));\n\t} else {\n\t\tfor (n = 0; n < frames * channels; n++) {\n\t\t\t*p++ = srcbuf[n];\n\t\t\t*p++ = srcbuf[n];\n\t\t}\n\t}\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u05f0WvPack\u013c \n *\n * @param spath \u00b7\n * @param lpath \u00b7\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int wv_load(const char *spath, const char *lpath)", "code": "{\n\tint fd;\n\n\t__init();\n\n\tif (g_buff != NULL) {\n\t\tfree(g_buff);\n\t\tg_buff = NULL;\n\t}\n\n\tg_buff_size = MAX_BLOCK_SIZE * 2;\n\tg_buff = calloc(g_buff_size, sizeof(*g_buff));\n\n\tif (g_buff == NULL) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tfd = xrIoOpen(spath, PSP_O_RDONLY, 0777);\n\n\tif (fd < 0) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tg_info.filesize = xrIoLseek(fd, 0, PSP_SEEK_END);\n\txrIoClose(fd);\n\n\tg_decoder =\n\t\topen_wvfile(spath, OPEN_WVC | OPEN_TAGS | OPEN_2CH_MAX | OPEN_NORMALIZE,\n\t\t\t\t\t23);\n\n\tif (g_decoder == NULL) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tg_wv_bits_per_sample = WavpackGetBitsPerSample(g_decoder);\n\n\tif (g_wv_bits_per_sample != 16) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tg_info.sample_freq = WavpackGetSampleRate(g_decoder);\n\tg_info.channels = WavpackGetNumChannels(g_decoder);\n\n\tif (g_info.channels != 1 && g_info.channels != 2) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\twv_buffer = calloc(MAX_BLOCK_SIZE * g_info.channels, sizeof(*wv_buffer));\n\n\tif (wv_buffer == NULL) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tif (g_info.sample_freq != 0) {\n\t\tg_info.samples = WavpackGetNumSamples(g_decoder);\n\t\tg_info.duration = (double) g_info.samples / g_info.sample_freq;\n\t} else {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tg_info.avg_bps = WavpackGetAverageBitrate(g_decoder, 1);\n\n\tg_mode = WavpackGetMode(g_decoder);\n\n\tif (g_mode & MODE_VALID_TAG) {\n\t\twv_get_tag();\n\t}\n\n\tg_encode_name[0] = '\\0';\n\n\tif (g_mode & MODE_WVC) {\n\t\tSTRCAT_S(g_encode_name, \" WVC\");\n\t}\n\n\tif (g_mode & MODE_HYBRID) {\n\t\tSTRCAT_S(g_encode_name, \" HYBRID\");\n\t}\n\n\tif (g_mode & MODE_LOSSLESS) {\n\t\tSTRCAT_S(g_encode_name, \" LOSSLESS\");\n\t} else {\n\t\tSTRCAT_S(g_encode_name, \" LOSSY\");\n\t}\n\n\tif (g_mode & MODE_HIGH) {\n\t\tSTRCAT_S(g_encode_name, \" HIGH\");\n\t}\n\n\tif (g_mode & MODE_FAST) {\n\t\tSTRCAT_S(g_encode_name, \" FAST\");\n\t}\n\n\tif (xAudioInit() < 0) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tif (xAudioSetFrequency(g_info.sample_freq) < 0) {\n\t\t__end();\n\t\treturn -1;\n\t}\n\n\tgeneric_lock();\n\tg_status = ST_LOADED;\n\tgeneric_unlock();\n\n\tdbg_printf(d,\n\t\t\t   \"[%d channel(s), %d Hz, %.2f kbps, %02d:%02d, encoder: %s, Ratio: %.3f]\",\n\t\t\t   g_info.channels, g_info.sample_freq, g_info.avg_bps / 1000,\n\t\t\t   (int) (g_info.duration / 60), (int) g_info.duration % 60,\n\t\t\t   g_encode_name,\n\t\t\t   1.0 * g_info.filesize / (g_info.samples * g_info.channels *\n\t\t\t\t\t\t\t\t\t\t(g_wv_bits_per_sample / 8))\n\t\t);\n\n\tdbg_printf(d, \"[%s - %s - %s, wv tag]\", g_info.tag.artist, g_info.tag.album,\n\t\t\t   g_info.tag.title);\n\n\txAudioSetChannelCallback(0, wv_audiocallback, NULL);\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u0363\u05b9WvPack\u013c\u0132\u0163\u057c\u0435\u07f3\u0321\u0534\n *\n * @note \u06b2\u07f3\u0435\u00e3\u0739\u0638\u00f6\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int wv_end(void)", "code": "{\n\t__end();\n\n\txAudioEnd();\n\n\tif (wv_buffer != NULL) {\n\t\tfree(wv_buffer);\n\t\twv_buffer = NULL;\n\t}\n\n\tif (g_buff != NULL) {\n\t\tfree(g_buff);\n\t\tg_buff = NULL;\n\t}\n\n\tg_status = ST_STOPPED;\n\n\tif (g_decoder) {\n\t\tWavpackCloseFile(g_decoder);\n\t\tg_decoder = NULL;\n\t}\n\n\tif (wv != NULL) {\n\t\tbuffered_reader_close(wv);\n\t\twv = NULL;\n\t}\n\n\tif (wvc != NULL) {\n\t\tbuffered_reader_close(wvc);\n\t\twvc = NULL;\n\t}\n\n\tfree_bitrate(&g_inst_br);\n\tgeneric_end();\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u01f7\u03aaWvPack\u013c\u013f\u01f0\u05bb\u013c\u05fa\n *\n * @param spath \u01f08.3\u00b7\u02bd\n *\n * @return WvPack\u013c1\uda9f\udd7b0\n */\n", "func_signal": "static int wv_probe(const char *spath)", "code": "{\n\tconst char *p;\n\n\tp = utils_fileext(spath);\n\n\tif (p) {\n\t\tif (stricmp(p, \"wv\") == 0) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u02bc\u0534\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int __init(void)", "code": "{\n\tgeneric_init();\n\n\tgeneric_lock();\n\tg_status = ST_UNKNOWN;\n\tgeneric_unlock();\n\n\tg_seek_seconds = 0;\n\tg_play_time = 0.;\n\tmemset(&data, 0, sizeof(data));\n\tmemset(&g_info, 0, sizeof(g_info));\n\n\tdata.fd = -1;\n\tdata.use_buffer = true;\n\n\tat3_type = 0;\n\tat3_data_align = 0;\n\tat3_data_start = 0;\n\tat3_data_size = 0;\n\tat3_data_buffer = NULL;\n\tat3_getEDRAM = false;\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u00f5WvPack\u013c\u03e2\n *\n * @param pinfo \u03e2\u1e79\u05b8\n *\n * @return\n */\n", "func_signal": "static int wv_get_info(struct music_info *pinfo)", "code": "{\n\tif (pinfo->type & MD_GET_CURTIME) {\n\t\tpinfo->cur_time = g_play_time;\n\t}\n\tif (pinfo->type & MD_GET_CPUFREQ) {\n\t\tif (g_mode & MODE_WVC)\n\t\t\tpinfo->psp_freq[0] = 222;\n\t\telse\n\t\t\tpinfo->psp_freq[0] = 166;\n\n\t\tpinfo->psp_freq[1] = pinfo->psp_freq[0] / 2;\n\t}\n\tif (pinfo->type & MD_GET_INSKBPS) {\n\t\tif (g_decoder != NULL)\n\t\t\tpinfo->ins_kbps = WavpackGetInstantBitrate(g_decoder) / 1000;\n\t\telse\n\t\t\tpinfo->ins_kbps = g_info.avg_bps / 1000;\n\t}\n\tif (pinfo->type & MD_GET_DECODERNAME) {\n\t\tSTRCPY_S(pinfo->decoder_name, \"wv\");\n\t}\n\tif (pinfo->type & MD_GET_ENCODEMSG) {\n\t\tif (config.show_encoder_msg && g_status != ST_UNKNOWN) {\n\t\t\tSPRINTF_S(pinfo->encode_msg, \"%s %s: %.3f\", g_encode_name,\n\t\t\t\t\t  _(\"\u0479\"),\n\t\t\t\t\t  1.0 * g_info.filesize / (g_info.samples *\n\t\t\t\t\t\t\t\t\t\t\t   g_info.channels *\n\t\t\t\t\t\t\t\t\t\t\t   (g_wv_bits_per_sample / 8)));\n\t\t} else {\n\t\t\tpinfo->encode_msg[0] = '\\0';\n\t\t}\n\t}\n\n\treturn generic_get_info(pinfo);\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * AT3\u05b2\u017b\u0635\n * \ud8b6\udefd\n *\n * @note \u0138\u02bd\u03aa\u02eb16\u03bb\n *\n * @param buf \u05b8\n * @param reqn \u05a1\u0421\n * @param pdata \u00fb\u0763\n */\n", "func_signal": "static int at3_audiocallback(void *buf, unsigned int reqn, void *pdata)", "code": "{\n\tint avail_frame;\n\tint snd_buf_frame_size = (int) reqn;\n\tsigned short *audio_buf = buf;\n\tdouble incr;\n\n\tUNUSED(pdata);\n\n\tif (g_status != ST_PLAYING) {\n\t\tif (g_status == ST_FFORWARD) {\n\t\t\tg_play_time += g_seek_seconds;\n\t\t\tif (g_play_time >= g_info.duration) {\n\t\t\t\t__end();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgeneric_lock();\n\t\t\tg_status = ST_PLAYING;\n\t\t\tgeneric_set_playback(true);\n\t\t\tgeneric_unlock();\n\t\t\tat3_seek_seconds(g_play_time);\n\t\t} else if (g_status == ST_FBACKWARD) {\n\t\t\tg_play_time -= g_seek_seconds;\n\t\t\tif (g_play_time < 0.) {\n\t\t\t\tg_play_time = 0.;\n\t\t\t}\n\t\t\tgeneric_lock();\n\t\t\tg_status = ST_PLAYING;\n\t\t\tgeneric_set_playback(true);\n\t\t\tgeneric_unlock();\n\t\t\tat3_seek_seconds(g_play_time);\n\t\t}\n\t\txAudioClearSndBuf(buf, snd_buf_frame_size);\n\t\txrKernelDelayThread(100000);\n\t\treturn 0;\n\t}\n\n\twhile (snd_buf_frame_size > 0) {\n\t\tavail_frame = g_buff_frame_size - g_buff_frame_start;\n\n\t\tif (avail_frame >= snd_buf_frame_size) {\n\t\t\tsend_to_sndbuf(audio_buf,\n\t\t\t\t\t\t   &g_buff[g_buff_frame_start * 2],\n\t\t\t\t\t\t   snd_buf_frame_size, 2);\n\t\t\tg_buff_frame_start += snd_buf_frame_size;\n\t\t\taudio_buf += snd_buf_frame_size * 2;\n\t\t\tsnd_buf_frame_size = 0;\n\t\t} else {\n\t\t\tint samplesdecoded;\n\t\t\tunsigned long decode_type = 0x1001;\n\t\t\tint res;\n\t\t\tuint16_t *output;\n\n\t\t\tsend_to_sndbuf(audio_buf,\n\t\t\t\t\t\t   &g_buff[g_buff_frame_start * 2], avail_frame, 2);\n\t\t\tsnd_buf_frame_size -= avail_frame;\n\t\t\taudio_buf += avail_frame * 2;\n\t\t\tmemset(at3_mix_buffer, 0, 2048 * 2 * 2);\n\n\t\t\tif (at3_type == TYPE_ATRAC3) {\n\t\t\t\tmemset(at3_data_buffer, 0, 0x180);\n\t\t\t\tif (data.use_buffer) {\n\t\t\t\t\tif (buffered_reader_read\n\t\t\t\t\t\t(data.r, at3_data_buffer,\n\t\t\t\t\t\t at3_data_align) != at3_data_align) {\n\t\t\t\t\t\t__end();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (xrIoRead(data.fd, at3_data_buffer, at3_data_align) !=\n\t\t\t\t\t\tat3_data_align) {\n\t\t\t\t\t\t__end();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (at3_channel_mode) {\n\t\t\t\t\tmemcpy(at3_data_buffer + at3_data_align, at3_data_buffer,\n\t\t\t\t\t\t   at3_data_align);\n\t\t\t\t}\n\t\t\t\tdecode_type = 0x1001;\n\t\t\t} else {\n\t\t\t\tmemset(at3_data_buffer, 0, at3_data_align + 8);\n\t\t\t\tat3_data_buffer[0] = 0x0F;\n\t\t\t\tat3_data_buffer[1] = 0xD0;\n\t\t\t\tat3_data_buffer[2] = at3_at3plus_flagdata[0];\n\t\t\t\tat3_data_buffer[3] = at3_at3plus_flagdata[1];\n\t\t\t\tif (data.use_buffer) {\n\t\t\t\t\tif (buffered_reader_read\n\t\t\t\t\t\t(data.r, at3_data_buffer + 8,\n\t\t\t\t\t\t at3_data_align) != at3_data_align) {\n\t\t\t\t\t\t__end();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (xrIoRead(data.fd, at3_data_buffer + 8, at3_data_align)\n\t\t\t\t\t\t!= at3_data_align) {\n\t\t\t\t\t\t__end();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdecode_type = 0x1000;\n\t\t\t}\n\n\t\t\tat3_codec_buffer[6] = (unsigned long) at3_data_buffer;\n\t\t\tat3_codec_buffer[8] = (unsigned long) at3_mix_buffer;\n\n\t\t\tres = xrAudiocodecDecode(at3_codec_buffer, decode_type);\n\n\t\t\tif (res < 0) {\n\t\t\t\t__end();\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsamplesdecoded = at3_sample_per_frame;\n\t\t\toutput = &g_buff[0];\n\t\t\tmemcpy(output, at3_mix_buffer, samplesdecoded * 4);\n\t\t\tg_buff_frame_size = samplesdecoded;\n\t\t\tg_buff_frame_start = 0;\n\t\t\tincr = (double) samplesdecoded / g_info.sample_freq;\n\t\t\tg_play_time += incr;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * PSP\u05fc\u02b1\u05b8WvPack\u0132\n *\n * @param spath \u01f08.3\u00b7\u02bd\n * @param lpath \u01f0\u013c\u02bd\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int wv_resume(const char *spath, const char *lpath)", "code": "{\n\tint ret;\n\n\tret = wv_load(spath, lpath);\n\tif (ret != 0) {\n\t\tdbg_printf(d, \"%s: wv_load failed %d\", __func__, ret);\n\t\treturn -1;\n\t}\n\n\tg_play_time = g_suspend_playing_time;\n\twv_seek_seconds(g_play_time);\n\tg_suspend_playing_time = 0;\n\n\tgeneric_resume(spath, lpath);\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u0363\u05b9AT3\u013c\u0132\u0163\u0534\n *\n * @note \u06b2\u07f3\u0435\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int __end(void)", "code": "{\n\txAudioEndPre();\n\n\tg_play_time = 0.;\n\tgeneric_lock();\n\tg_status = ST_STOPPED;\n\tgeneric_unlock();\n\n\treturn 0;\n}", "path": "src\\at3player.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "/**\n * \u0363\u05b9WvPack\u013c\u0132\u0163\u0534\n *\n * @note \u06b2\u07f3\u0435\n *\n * @return \u0279\u02b10\n */\n", "func_signal": "static int __end(void)", "code": "{\n\txAudioEndPre();\n\n\tgeneric_lock();\n\tg_status = ST_STOPPED;\n\tgeneric_unlock();\n\n\tg_play_time = 0.;\n\n\treturn 0;\n}", "path": "src\\wvplayer.c", "repo_name": "azuwis/xreader", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 23688}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeBODY (void)", "code": "{\n\tmappt = (short int *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mappt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tfread (mappt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\tmapmappt[0] = mappt;\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "GDECLSPEC void GLES2D_TilesMapFree ()", "code": "{\n\tint i;\n\tfor (i=0;i<8;i++) { if (mapmappt[i]!=NULL) { free (mapmappt[i]); mapmappt[i] = NULL; } }\n\tmappt = NULL;\n//\tfor (i=0;i<8;i++) { if (mapmaparraypt[i]!=NULL) { free (mapmaparraypt[i]); mapmaparraypt[i] = NULL; } }\n//\tmaparraypt = NULL;\n\tif (mapcmappt!=NULL) { free (mapcmappt); mapcmappt = NULL; }\n\tif (mapblockgfxpt!=NULL) { free (mapblockgfxpt); mapblockgfxpt = NULL; }\n\tif (mapblockstrpt!=NULL) { free (mapblockstrpt); mapblockstrpt = NULL; }\n\tif (mapanimstrpt!=NULL) { free (mapanimstrpt); mapanimstrpt = NULL; }\n\n\tfor (i=0;(maplpDDSTiles[i]!=NULL);i++)\n\t{\n\t\tGLES2D_FreeTexture( maplpDDSTiles[i] );\n\t\tmaplpDDSTiles[i] = NULL;\n\t\t//\tSDL_FreeSurface(maplpDDSTiles[i]);\n\t}\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapRelocate(void)", "code": "{\n\tint i, deplct;\n\n\tSDL_Surface *tmp;\n\n\t//BLKSTR * block;\n\t//if (myblock->tl) { topleft collision bit is set }\n\t\n\tfor(i=0; i<mapnumblockstr; i++) {\n\t\t((BLKSTR *) mapblockstrpt)[i].bgoff /= (mapblockwidth*mapblockheight*((mapdepth+1)/8));\n\t\t((BLKSTR *) mapblockstrpt)[i].fgoff /= (mapblockwidth*mapblockheight*((mapdepth+1)/8));\n\t\t((BLKSTR *) mapblockstrpt)[i].fgoff2 /= (mapblockwidth*mapblockheight*((mapdepth+1)/8));\n\t\t((BLKSTR *) mapblockstrpt)[i].fgoff3 /= (mapblockwidth*mapblockheight*((mapdepth+1)/8));\n\t\t//printf (\"B%d: %d,%d,%d,%d\\n\", i, ((BLKSTR *) mapblockstrpt)[i].bgoff,((BLKSTR *) mapblockstrpt)[i].fgoff,((BLKSTR *) mapblockstrpt)[i].fgoff2 ,((BLKSTR *) mapblockstrpt)[i].fgoff3 );\n\t}\n\n\tif (mapdepth == 8) mapdepth = 24;\n\n\tswitch(mapdepth)\n\t{\n\t\tcase 8:\n\t\t\tprintf(\"Loading 8bpp tile map into memory\\n\");\n\t\t\tdeplct=mapblockwidth*mapblockheight;\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t{\n\n\t\t\t\ttmp = SDL_CreateRGBSurfaceFrom (mapblockgfxpt+(deplct)*i,\n\t\t\t\t\t\tmapblockwidth, mapblockheight, mapdepth, mapblockwidth, 0, 0, 0, 0);\n\n\t\t\t\tif (i==0) \n\t\t\t\t\tcolorkey8 = (Uint8*)tmp->pixels;\n\n\t\t\t\t//if ( ((BLKSTR *) mapblockstrpt)[i].trigger ) \n\t\t\t\t\tSDL_SetColorKey(tmp, SDL_SRCCOLORKEY, *(Uint8 *)colorkey8);\n\t\t\t\t\n\t\t\t\tmaplpDDSTiles[i] = GLES2D_CreateTextureFromSurface( tmp, 0 );\n\n\t\t\t\tSDL_FreeSurface ( tmp );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tprintf(\"Loading 16bpp tile map into memory\\n\");\n\t\t\tdeplct=mapblockwidth*mapblockheight*2;\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t{\n\t\t\t\ttmp = SDL_CreateRGBSurfaceFrom (mapblockgfxpt+(deplct)*i,\n\t\t\t\t\t\tmapblockwidth, mapblockheight, mapdepth, mapblockwidth*2, 0XF800, 0X7E0, 0x1F, 0);\n\n\t\t\t\tif (i==0) \n\t\t\t\t\tcolorkey16 = (Uint16*)tmp->pixels;\n\n\t\t\t\t//if ( ((BLKSTR *) mapblockstrpt)[i].trigger ) \n\t\t\t\t\tSDL_SetColorKey(tmp, SDL_SRCCOLORKEY, *(Uint16 *)colorkey16);\n\n\t\t\t\tmaplpDDSTiles[i] = GLES2D_CreateTextureFromSurface( tmp, 0 );\n\t\t\t\tSDL_FreeSurface ( tmp );\n\t\t\t}\t\t\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tprintf(\"Loading 24bpp tile map into memory (converted to RGBA8888)\\n\");\n\t\t\tdeplct=mapblockwidth*mapblockheight*3;\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t{\n\t\t\t\ttmp = SDL_CreateRGBSurfaceFrom (mapblockgfxpt+(deplct)*i,\n\t\t\t\t\tmapblockwidth, mapblockheight, mapdepth, mapblockwidth*3, 0XFF0000, 0XFF00, 0xFF, 0);\n\n\t\t\t\tif (i==0) \n\t\t\t\t\tcolorkey32 = (Uint32*)tmp->pixels;\n\n\t\t\t\t//if ( ((BLKSTR *) mapblockstrpt)[i].trigger ) \n\t\t\t\t\tSDL_SetColorKey(tmp, SDL_SRCCOLORKEY, *(Uint32 *)colorkey32);\n\n\t\t\t\tmaplpDDSTiles[i] = GLES2D_CreateTextureFromSurface( tmp, 0 );\n\t\t\t\tSDL_FreeSurface ( tmp );\n\t\t\t}\t\t\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tprintf(\"Loading 32bpp tile map into memory\\n\");\n\t\t\tdeplct=mapblockwidth*mapblockheight*4;\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t{\n\t\t\t\ttmp = SDL_CreateRGBSurfaceFrom (mapblockgfxpt+(deplct)*i,\n\t\t\t\t\tmapblockwidth, mapblockheight, mapdepth, mapblockwidth*4, 0XFF0000, 0XFF00, 0xFF, 0);\n\n\t\t\t\tif (i==0) \n\t\t\t\t\tcolorkey32 = (Uint32*)tmp->pixels;\n\n\t\t\t\t//if ( ((BLKSTR *) mapblockstrpt)[i].trigger ) \t\t\n\t\t\t\t\tSDL_SetColorKey(tmp, SDL_SRCCOLORKEY, *(Uint32 *)colorkey32);\n\n\t\t\t\tmaplpDDSTiles[i] = GLES2D_CreateTextureFromSurface( tmp, 0 );\n\t\t\t\tSDL_FreeSurface ( tmp );\t\n\t\t\t}\t\t\t\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeANDT (void)", "code": "{\n\tANDTSize =  Mapbyteswapl(mapgenheader.headsize);\n\tmapanimstrpt = (char *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mapanimstrpt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tmapanimstrendpt = (char *) (mapanimstrpt+(Mapbyteswapl(mapgenheader.headsize)));\n\tfread (mapanimstrpt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeNULL (void)", "code": "{\n\tchar * mynllpt;\n\n\tmynllpt = (char *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mynllpt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tfread (mynllpt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\tfree (mynllpt);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// change le numero de la layer (0 \u00e0 7) devant etre affichee\n// ---------------------------------------------------------------------------------\n", "func_signal": "GDECLSPEC int GLES2D_MapChangeLayer (int newlyr)", "code": "{\n\tif (newlyr<0 || newlyr>7 || mapmappt[newlyr] == NULL) return -1;\n\tmappt = mapmappt[newlyr]; //maparraypt = mapmaparraypt[newlyr];\n\tlayer = newlyr;\n\treturn newlyr;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "unsigned long int Mapbyteswapl (unsigned long int i)", "code": "{\n\tunsigned long int j;\n\n\tj   = i&0xFF;\n\tj <<= 8;\n\ti >>= 8;\n\tj  |= i&0xFF;\n\tj <<= 8;\n\ti >>= 8;\n\tj  |= i&0xFF;\n\tj <<= 8;\n\ti >>= 8;\n\tj  |= i&0xFF;\n\t\n\treturn j;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "/* function to handle events */\n", "func_signal": "void handleEvents()", "code": "{\n\tGLES2D_HandleEvents( 20 );\t\n\n\tsprite1->playing = 0;\n\n\tif ( GLES2D_KeyboardPressed( XK_Escape ) || GLES2D_PadPressed( START ) )\n\t{\n\t\tdone = 1;\n\t}\n\n\tif ( GLES2D_KeyboardHold( XK_Up ) || GLES2D_PadHold( PAD_UP ) )\n\t{\n\t\tsprite1->playing = 1;\n\t\tsprite1->frameLayer = 2;\n\n\t\tif ( spriteY > 5 )\n\t\t\tspriteY -= 5;\n\n\t}\n\tif ( GLES2D_KeyboardHold( XK_Down ) || GLES2D_PadHold( PAD_DOWN ) )\n\t{\n\t\tsprite1->playing = 1;\n\t\tsprite1->frameLayer = 1;\n\n\t\tif ( spriteY < 480 - sprite1->texture->dst->h )\n\t\t\tspriteY += 5;\n\t}\n\n\tif ( GLES2D_KeyboardHold( XK_Left ) || GLES2D_PadHold( PAD_LEFT ) )\n\t{\n\t\tsprite1->playing = 1;\n\t\tsprite1->frameLayer = 3;\n\n\t\tif ( spriteX > 5 )\n\t\t\tspriteX -= 5;\n\t}\n\tif ( GLES2D_KeyboardHold( XK_Right ) || GLES2D_PadHold( PAD_RIGHT ) )\n\t{\n\t\tsprite1->playing = 1;\n\t\tsprite1->frameLayer = 4;\n\n\t\tif ( spriteX < 800 - sprite1->texture->dst->w )\n\t\t\tspriteX += 5;\n\t}\n}", "path": "examples\\sprite\\main.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// The x and y paramaters are the offset from the left and top of the map in BLOCKS, NOT pixels.\n// ---------------------------------------------------------------------------------\n", "func_signal": "void MapSetBlock (int x, int y, int strvalue)", "code": "{\n\tshort int * mymappt;\n\n/*\tif (maparraypt!= NULL) {\n\t\tmymappt = maparraypt[y]+x;\n\t} else */{\n\t\tmymappt = mappt;\n\t\tmymappt += x;\n\t\tmymappt += y*mapwidth;\n\t}\n\tif (strvalue >= 0 ) *mymappt = strvalue*sizeof(BLKSTR);\n\telse *mymappt = strvalue*sizeof(ANISTR);\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeLYR4 (void)", "code": "{\n\tmapmappt[4] = (short int *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mapmappt[4]==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tfread (mapmappt[4], Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeMPHD (void)", "code": "{\n\tMPHD\t* hdrmempt;\n\n\thdrmempt = (MPHD *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (hdrmempt==NULL) return 0;\n\tfread (hdrmempt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\tmapwidth=hdrmempt->mapwidth;\n\tmapheight=hdrmempt->mapheight;\n\tmapblockwidth=hdrmempt->blockwidth;\n\tmapblockheight=hdrmempt->blockheight;\n\tmapdepth=hdrmempt->blockdepth;\n\tmapblockstrsize=hdrmempt->blockstrsize;\n\tmapnumblockstr=hdrmempt->numblockstr;\n\tmapnumblockgfx=hdrmempt->numblockgfx;\n\tfree (hdrmempt);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ------------------------------------------------------------\n// renvoie le numero de la tile a l'emplacement (x,y) en blocks\n//\n// returns the content of a block\n// if return is positive then the block is a normal tile\n// if return is negative then the block (-X) is animation (+X)\n// ------------------------------------------------------------\n", "func_signal": "short int MapGetTile( int x , int y )", "code": "{\n\tshort int\tContent;\n\n\tContent = mappt[x+(y*mapwidth)];\n\n\tif( Content >= 0 )\n\t\tContent /= sizeof(BLKSTR);\n\telse\n\t{\n\t\tContent = -Content / sizeof(ANISTR) ;\n\t\tContent = -Content + 1;\n\t}\n\n\treturn Content;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "GDECLSPEC void GLES2D_TilesMapInitAnims()", "code": "{\n\tANISTR\t* myanpt;\n\n\tif (mapanimstrpt==NULL) return;\n\tmyanpt = (ANISTR *) mapanimstrendpt; myanpt--;\n\twhile (myanpt->antype!=-1)\n\t{\n\t\tif (myanpt->antype==AN_PPFR) myanpt->antype = AN_PPFF;\n\t\tif (myanpt->antype==AN_PPRF) myanpt->antype = AN_PPRR;\n\t\tif (myanpt->antype==AN_ONCES) myanpt->antype = AN_ONCE;\n\t\tif ((myanpt->antype==AN_LOOPR) || (myanpt->antype==AN_PPRR))\n\t\t{\n\t\tmyanpt->ancuroff = myanpt->anstartoff;\n\t\tif ((myanpt->anstartoff)!=(myanpt->anendoff)) myanpt->ancuroff=(myanpt->anendoff)-4;\n\t\t} else {\n\t\tmyanpt->ancuroff = myanpt->anstartoff;\n\t\t}\n\t\tmyanpt->ancount = myanpt->andelay;\n\t\tmyanpt--;\n\t}\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeBGFX (void)", "code": "{\n\tunsigned long int i, size;\n\tunsigned long int temp;\n\t\n\tsize=Mapbyteswapl(mapgenheader.headsize);\n\tif (mapdepth == 8) size *= 3;\t//convert 8bit to 24bit\n\tmapblockgfxpt = (char *) malloc (size);\n\tif (mapblockgfxpt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tswitch(mapdepth)\n\t{\n\t\tcase 8:\n//\t\t\tprintf(\"maps en 8 bits non supportees pour l'instant...\\n\");\n//\t\t\treturn -1;\n//\t\t\tfread (mapblockgfxpt, size, 1, mapfilept);\n\t\t\tfor (i=0; i<size; i+=3)\n\t\t\t{\n\t\t\t\tfread (&temp, 1, 1, mapfilept);\n\t\t\t\tmapblockgfxpt[i]=mapcmappt[(temp&0XFF)*3+2];\n\t\t\t\tmapblockgfxpt[i+1]=mapcmappt[(temp&0XFF)*3+1];\n\t\t\t\tmapblockgfxpt[i+2]=mapcmappt[(temp&0XFF)*3];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfor (i=0; i<size; i+=2)\n\t\t\t{\n\t\t\t\tfread (&temp, 2, 1, mapfilept);\n\t\t\t\tmapblockgfxpt[i+1]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i]=temp&0XFF;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tfor (i=0; i<size; i+=3)\n\t\t\t{\n\t\t\t\tfread (&temp, 3, 1, mapfilept);\n\t\t\t\tmapblockgfxpt[i+2]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i+1]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i]=temp&0XFF;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tfor (i=0; i<size; i+=4)\n\t\t\t{\n\t\t\t\tfread (&temp, 4, 1, mapfilept);\n\t\t\t\tmapblockgfxpt[i+3]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i+2]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i+1]=temp&0XFF;\n\t\t\t\ttemp>>=8;\n\t\t\t\tmapblockgfxpt[i]=temp&0XFF;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeBKDT (void)", "code": "{\n\tmapblockstrpt = (char *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mapblockstrpt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tfread (mapblockstrpt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// draws the foreground layer WITH Transparency (couleur de transparence = celle du\n//\t\t\t1er block qui doit etre uni)\n// ---------------------------------------------------------------------------------\n", "func_signal": "GDECLSPEC int GLES2D_TilesMapDrawFG ( int w, int h )", "code": "{\n\tint\t\t\ti, j, mapvclip, maphclip;\n\tint         mapxo, mapyo;\n\tint \t\tnumtile, numanim;\n\tANISTR\t\t* anim;\n\tSDL_Rect TileDestRect;\n\t\n/*\n\tswitch(mapdepth)\n\t{\n\t\tcase 8:\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t\tSDL_SetColorKey(maplpDDSTiles[i], SDL_SRCCOLORKEY,\n\t\t\t\t\t\t*(Uint8 *)maplpDDSTiles[TRANSPBLOCK]->pixels);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t\tSDL_SetColorKey(maplpDDSTiles[i], SDL_SRCCOLORKEY,\n\t\t\t\t\t\t*(Uint16 *)maplpDDSTiles[TRANSPBLOCK]->pixels);\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tfor(i=0; i<mapnumblockgfx; i++)\n\t\t\t\tSDL_SetColorKey(maplpDDSTiles[i], SDL_SRCCOLORKEY,\n\t\t\t\t\t\t*(Uint32 *)maplpDDSTiles[TRANSPBLOCK]->pixels);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n*/\t\n\tmapxo=XPosition[layer]/mapblockwidth;\n\tmapyo=YPosition[layer]/mapblockheight;\n\tmaphclip=XPosition[layer]%mapblockwidth;\n\tmapvclip=YPosition[layer]%mapblockheight;\t\n\t\n\tfor(i=0; i<h/mapblockheight+2;i++)\n\t\tfor(j=0; j<w/mapblockwidth+2;j++)\n\t\t{\t\n\t\t\tTileDestRect.y\t= i*mapblockheight-mapvclip;\n\t\t\tTileDestRect.x\t= j*mapblockwidth-maphclip;\n\t\t\tTileDestRect.h\t= mapblockheight;\n\t\t\tTileDestRect.w\t= mapblockwidth;\n\t\t\t\n\t\t\tnumtile = mappt[mapxo+j+((mapyo+i)*mapwidth)];\n\t\t\t\n\t\t\tif (((mapxo+j)<mapwidth) && ((mapyo+i)<mapheight))\n\t\t\t{\n\t\t\t\tif (numtile>=0)\n\t\t\t\t{\n\t\t\t\t\t//SDL_BlitSurface(maplpDDSTiles[((BLKSTR *) (mapblockstrpt+numtile))->fgoff],\n\t\t\t\t\t//\tNULL, lpDDS, &TileDestRect);\n\n\t\t\t\t\t//if ( ((BLKSTR *) (mapblockstrpt+numtile))->fgoff )\n\t\t\t\t\t//{\n\t\t\t\t\t\tif ( ((BLKSTR *) (mapblockstrpt+numtile))->fgoff ) /* Prevent first transparent block to be drawn to gain FPS */\n\t\t\t\t\t\t\tGLES2D_DrawTextureScaled( maplpDDSTiles[((BLKSTR *) (mapblockstrpt+numtile))->fgoff],\n\t\t\t\t\t\t\t\tTileDestRect.x, TileDestRect.y, TileDestRect.w, TileDestRect.h );\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( ((BLKSTR *) (mapblockstrpt+numtile))->fgoff ) /* Prevent first transparent block to be drawn to gain FPS */\n\t\t\t\t\t{\n\t\t\t\t\t\tanim = (ANISTR *) (mapanimstrendpt + numtile);\n\t\t\t\t\t\tnumanim = mapanimstrpt[ANDTSize+anim->ancuroff+1]&0XFF;\n\t\t\t\t\t\tnumanim <<= 8;\n\t\t\t\t\t\tnumanim |= mapanimstrpt[ANDTSize+anim->ancuroff]&0XFF;\n//\t\t\t\t\t\tnumanim >>= 5;\n\t\t\t\t\t\t//SDL_BlitSurface(maplpDDSTiles[((BLKSTR *) (mapblockstrpt+numanim))->fgoff],\n\t\t\t\t\t\t//\tNULL, lpDDS, &TileDestRect);\n\n\t\t\t\t\t\tGLES2D_DrawTextureScaled( maplpDDSTiles[((BLKSTR *) (mapblockstrpt+numanim))->fgoff],\n\t\t\t\t\t\t\tTileDestRect.x, TileDestRect.y, TileDestRect.w, TileDestRect.h );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// creates a parallax surface from a bitmap file\n// returns true, if an error occurs, returns FALSE\n// errors can be: bitmap not found\n// caution: the parallax surface size must be a multiple of the map block size\n// ---------------------------------------------------------------------------------\n", "func_signal": "GDECLSPEC GLES2D_Texture *GLES2D_TilesMapLoadParallax( char *filename )", "code": "{\n//\tSDL_Surface *SourceSurfaceTmp;\n\n\t// when no map is loaded, return an error\n\tif( GLES2D_TilesMapGetWidth() == 0 )\n\t\treturn 0;\n\n\t// load the bitmap into a surface\n//\tif(ParallaxFilename == NULL)\n//\t\treturn SDL_FALSE;\n\n/*\n\t// Load a BMP sprite into a surface\n\tSourceSurfaceTmp = SDL_LoadBMP( filename );\n\tif ( SourceSurfaceTmp == NULL )\n\t\treturn SDL_FALSE;\n\t\t\n\t// Convert the sprite to the video format (maps colors) \n\tParallaxSurface = SDL_DisplayFormat(SourceSurfaceTmp);\n\tSDL_FreeSurface(SourceSurfaceTmp);\n\tif ( ParallaxSurface == NULL )\n\t\treturn SDL_FALSE;\n\n*/\n\ttmp = GLES2D_CreateTexture( filename, 0 );\n\n//\tPARAW = ParallaxSurface->w;\n//\tPARAH = ParallaxSurface->h;\n\n\n\treturn tmp;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------\n", "func_signal": "int MapDecodeCMAP (void)", "code": "{\n\tmapcmappt = (unsigned char *) malloc (Mapbyteswapl(mapgenheader.headsize));\n\tif (mapcmappt==NULL) { maperror = MER_OUTOFMEM; return -1; }\n\tfread (mapcmappt, Mapbyteswapl(mapgenheader.headsize), 1, mapfilept);\n\tMapCMAPtoPE (mapcmappt, mappept);\n\n\treturn 0;\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "/* function to handle events */\n", "func_signal": "void handleEvents()", "code": "{\n\tGLES2D_HandleEvents( 10 );\n\n\tif ( GLES2D_KeyboardPressed( XK_space ) )\n\t\tprintf(\"space pressed\\n\");\n\n}", "path": "examples\\simple\\main.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "// ---------------------------------------------------------------------------------\n// Returns a BLKSTR pointer, useful for collision detection and examining a block structure.\n// ---------------------------------------------------------------------------------\n", "func_signal": "BLKSTR * MapGetBlock (int x, int y)", "code": "{\n\tshort int * mymappt;\n//\tANISTR * myanpt;\n\n/*\tif (maparraypt!= NULL) {\n\t\tmymappt = maparraypt[y]+x;\n\t} else */\n\t{\n\t\tmymappt = mappt;\n\t\tmymappt += x;\n\t\tmymappt += y*mapwidth;\n\t}\n\n\tif (mymappt >= 0 ) return (BLKSTR*) (((char *)mapblockstrpt) + *mymappt);\n\telse\n\t{\n\t\tprintf(\"anim spoted\\n\");\n\n\t\t//myanpt = (ANISTR *) (mapanimstrendpt + *mymappt);\n\t\t//return (BLKSTR *) (char *)mapblockstrpt + *(long int *)myanpt->ancuroff;\n\t}\n}", "path": "src\\GLES2D_tiles.c", "repo_name": "Cpasjuste/GLES2D", "stars": 7, "license": "None", "language": "c", "size": 1648}
{"docstring": "/**\n *  e1000_init_function_pointers_80003es2lan - Init ESB2 func ptrs.\n *  @hw: pointer to the HW structure\n *\n *  Called to initialize all function pointers and parameters.\n **/\n", "func_signal": "void e1000_init_function_pointers_80003es2lan(struct e1000_hw *hw)", "code": "{\n\te1000_init_mac_ops_generic(hw);\n\te1000_init_nvm_ops_generic(hw);\n\thw->mac.ops.init_params = e1000_init_mac_params_80003es2lan;\n\thw->nvm.ops.init_params = e1000_init_nvm_params_80003es2lan;\n\thw->phy.ops.init_params = e1000_init_phy_params_80003es2lan;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_read_phy_reg_gg82563_80003es2lan - Read GG82563 PHY register\n *  @hw: pointer to the HW structure\n *  @offset: offset of the register to read\n *  @data: pointer to the data returned from the operation\n *\n *  Read the GG82563 PHY register.\n **/\n", "func_signal": "static s32 e1000_read_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,\n                                                  u32 offset, u16 *data)", "code": "{\n\ts32 ret_val;\n\tu32 page_select;\n\tu16 temp;\n\n\tret_val = e1000_acquire_phy_80003es2lan(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\t/* Select Configuration Page */\n\tif ((offset & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {\n\t\tpage_select = GG82563_PHY_PAGE_SELECT;\n\t} else {\n\t\t/*\n\t\t * Use Alternative Page Select register to access\n\t\t * registers 30 and 31\n\t\t */\n\t\tpage_select = GG82563_PHY_PAGE_SELECT_ALT;\n\t}\n\n\ttemp = (u16)((u16)offset >> GG82563_PAGE_SHIFT);\n\tret_val = e1000e_write_phy_reg_mdic(hw, page_select, temp);\n\tif (ret_val) {\n\t\te1000_release_phy_80003es2lan(hw);\n\t\tgoto out;\n\t}\n\n\tif (hw->dev_spec.e80003es2lan.mdic_wa_enable == true) {\n\t\t/*\n\t\t * The \"ready\" bit in the MDIC register may be incorrectly set\n\t\t * before the device has completed the \"Page Select\" MDI\n\t\t * transaction.  So we wait 200us after each MDI command...\n\t\t */\n\t\tudelay(200);\n\n\t\t/* ...and verify the command was successful. */\n\t\tret_val = e1000e_read_phy_reg_mdic(hw, page_select, &temp);\n\n\t\tif (((u16)offset >> GG82563_PAGE_SHIFT) != temp) {\n\t\t\tret_val = -E1000_ERR_PHY;\n\t\t\te1000_release_phy_80003es2lan(hw);\n\t\t\tgoto out;\n\t\t}\n\n\t\tudelay(200);\n\n\t\tret_val = e1000e_read_phy_reg_mdic(hw,\n\t\t                                  MAX_PHY_REG_ADDRESS & offset,\n\t\t                                  data);\n\n\t\tudelay(200);\n\t} else {\n\t\tret_val = e1000e_read_phy_reg_mdic(hw,\n\t\t                                  MAX_PHY_REG_ADDRESS & offset,\n\t\t                                  data);\n\t}\n\n\te1000_release_phy_80003es2lan(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_write_kmrn_reg_80003es2lan - Write kumeran register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to write to\n *  @data: data to write at register offset\n *\n *  Acquire semaphore, then write the data to PHY register\n *  at the offset using the kumeran interface.  Release semaphore\n *  before exiting.\n **/\n", "func_signal": "static s32 e1000_write_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\n                                            u16 data)", "code": "{\n\tu32 kmrnctrlsta;\n\ts32 ret_val = E1000_SUCCESS;\n\n\tret_val = e1000_acquire_mac_csr_80003es2lan(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t               E1000_KMRNCTRLSTA_OFFSET) | data;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\n\tudelay(2);\n\n\te1000_release_mac_csr_80003es2lan(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_acquire_phy_80003es2lan - Acquire rights to access PHY\n *  @hw: pointer to the HW structure\n *\n *  A wrapper to acquire access rights to the correct PHY.\n **/\n", "func_signal": "static s32 e1000_acquire_phy_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu16 mask;\n\n\tmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\n\treturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_init_mac_params_80003es2lan - Init ESB2 MAC func ptrs.\n *  @hw: pointer to the HW structure\n **/\n", "func_signal": "static s32 e1000_init_mac_params_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_adapter *adapter = hw->adapter;\n\tstruct e1000_mac_info *mac = &hw->mac;\n\n\t/* Set media type and media-dependent function pointers */\n\tswitch (adapter->pdev->device) {\n\tcase E1000_DEV_ID_80003ES2LAN_SERDES_DPT:\n\t\thw->phy.media_type = e1000_media_type_internal_serdes;\n\t\tmac->ops.check_for_link = e1000e_check_for_serdes_link;\n\t\tmac->ops.setup_physical_interface =\n\t\t\te1000e_setup_fiber_serdes_link;\n\t\tbreak;\n\tdefault:\n\t\thw->phy.media_type = e1000_media_type_copper;\n\t\tmac->ops.check_for_link = e1000e_check_for_copper_link;\n\t\tmac->ops.setup_physical_interface =\n\t\t\te1000_setup_copper_link_80003es2lan;\n\t\tbreak;\n\t}\n\n\t/* Set mta register count */\n\tmac->mta_reg_count = 128;\n\t/* Set rar entry count */\n\tmac->rar_entry_count = E1000_RAR_ENTRIES;\n\t/* FWSM register */\n\tmac->has_fwsm = true;\n\t/* ARC supported; valid only if manageability features are enabled. */\n\tmac->arc_subsystem_valid =\n\t        (er32(FWSM) & E1000_FWSM_MODE_MASK)\n\t                ? true : false;\n\t/* Adaptive IFS not supported */\n\tmac->adaptive_ifs = false;\n\n\t/* Function pointers */\n\n\t/* bus type/speed/width */\n\tmac->ops.get_bus_info = e1000e_get_bus_info_pcie;\n\t/* reset */\n\tmac->ops.reset_hw = e1000_reset_hw_80003es2lan;\n\t/* hw initialization */\n\tmac->ops.init_hw = e1000_init_hw_80003es2lan;\n\t/* link setup */\n\tmac->ops.setup_link = e1000e_setup_link;\n\t/* check management mode */\n\tmac->ops.check_mng_mode = e1000e_check_mng_mode_generic;\n\t/* multicast address update */\n\tmac->ops.update_mc_addr_list = e1000e_update_mc_addr_list_generic;\n\t/* writing VFTA */\n\tmac->ops.write_vfta = e1000_write_vfta_generic;\n\t/* clearing VFTA */\n\tmac->ops.clear_vfta = e1000_clear_vfta_generic;\n\t/* read mac address */\n\tmac->ops.read_mac_addr = e1000_read_mac_addr_80003es2lan;\n\t/* ID LED init */\n\tmac->ops.id_led_init = e1000e_id_led_init;\n\t/* blink LED */\n\tmac->ops.blink_led = e1000e_blink_led;\n\t/* setup LED */\n\tmac->ops.setup_led = e1000e_setup_led_generic;\n\t/* cleanup LED */\n\tmac->ops.cleanup_led = e1000e_cleanup_led_generic;\n\t/* turn on/off LED */\n\tmac->ops.led_on = e1000e_led_on_generic;\n\tmac->ops.led_off = e1000e_led_off_generic;\n\t/* clear hardware counters */\n\tmac->ops.clear_hw_cntrs = e1000_clear_hw_cntrs_80003es2lan;\n\t/* link info */\n\tmac->ops.get_link_up_info = e1000_get_link_up_info_80003es2lan;\n\n\t/* set lan id for port to determine which phy lock to use */\n\thw->mac.ops.set_lan_id(hw);\n\n\treturn E1000_SUCCESS;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_get_cfg_done_80003es2lan - Wait for configuration to complete\n *  @hw: pointer to the HW structure\n *\n *  Wait a specific amount of time for manageability processes to complete.\n *  This is a function pointer entry point called by the phy module.\n **/\n", "func_signal": "static s32 e1000_get_cfg_done_80003es2lan(struct e1000_hw *hw)", "code": "{\n\ts32 timeout = PHY_CFG_TIMEOUT;\n\ts32 ret_val = E1000_SUCCESS;\n\tu32 mask = E1000_NVM_CFG_DONE_PORT_0;\n\n\tif (hw->bus.func == 1)\n\t\tmask = E1000_NVM_CFG_DONE_PORT_1;\n\n\twhile (timeout) {\n\t\tif (er32(EEMNGCTL) & mask)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t\ttimeout--;\n\t}\n\tif (!timeout) {\n\t\te_dbg(\"MNG configuration cycle has not completed.\\n\");\n\t\tret_val = -E1000_ERR_RESET;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore\n *  @hw: pointer to the HW structure\n *  @mask: specifies which semaphore to acquire\n *\n *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask\n *  will also specify which port we're releasing the lock for.\n **/\n", "func_signal": "static void e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)", "code": "{\n\tu32 swfw_sync;\n\n\twhile (e1000e_get_hw_semaphore(hw) != E1000_SUCCESS)\n\t\t; /* Empty */\n\n\tswfw_sync = er32(SW_FW_SYNC);\n\tswfw_sync &= ~mask;\n\tew32(SW_FW_SYNC, swfw_sync);\n\n\te1000e_put_hw_semaphore(hw);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_release_phy_80003es2lan - Release rights to access PHY\n *  @hw: pointer to the HW structure\n *\n *  A wrapper to release access rights to the correct PHY.\n **/\n", "func_signal": "static void e1000_release_phy_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu16 mask;\n\n\tmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\n\te1000_release_swfw_sync_80003es2lan(hw, mask);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_clear_hw_cntrs_80003es2lan - Clear device specific hardware counters\n *  @hw: pointer to the HW structure\n *\n *  Clears the hardware counters by reading the counter registers.\n **/\n", "func_signal": "static void e1000_clear_hw_cntrs_80003es2lan(struct e1000_hw *hw)", "code": "{\n\te1000e_clear_hw_cntrs_base(hw);\n\n\ter32(PRC64);\n\ter32(PRC127);\n\ter32(PRC255);\n\ter32(PRC511);\n\ter32(PRC1023);\n\ter32(PRC1522);\n\ter32(PTC64);\n\ter32(PTC127);\n\ter32(PTC255);\n\ter32(PTC511);\n\ter32(PTC1023);\n\ter32(PTC1522);\n\n\ter32(ALGNERRC);\n\ter32(RXERRC);\n\ter32(TNCRS);\n\ter32(CEXTERR);\n\ter32(TSCTC);\n\ter32(TSCTFC);\n\n\ter32(MGTPRC);\n\ter32(MGTPDC);\n\ter32(MGTPTC);\n\n\ter32(IAC);\n\ter32(ICRXOC);\n\n\ter32(ICRXPTC);\n\ter32(ICRXATC);\n\ter32(ICTXPTC);\n\ter32(ICTXATC);\n\ter32(ICTXQEC);\n\ter32(ICTXQMTC);\n\ter32(ICRXDMTC);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_release_nvm_80003es2lan - Relinquish rights to access NVM\n *  @hw: pointer to the HW structure\n *\n *  Release the semaphore used to access the EEPROM.\n **/\n", "func_signal": "static void e1000_release_nvm_80003es2lan(struct e1000_hw *hw)", "code": "{\n\te1000e_release_nvm(hw);\n\te1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_setup_copper_link_80003es2lan - Setup Copper Link for ESB2\n *  @hw: pointer to the HW structure\n *\n *  Essentially a wrapper for setting up all things \"copper\" related.\n *  This is a function pointer entry point called by the mac module.\n **/\n", "func_signal": "static s32 e1000_setup_copper_link_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu32 ctrl;\n\ts32 ret_val;\n\tu16 reg_data;\n\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_SLU;\n\tctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tew32(CTRL, ctrl);\n\n\t/*\n\t * Set the mac to wait the maximum time between each\n\t * iteration and increase the max iterations when\n\t * polling the phy; this fixes erroneous timeouts at 10Mbps.\n\t */\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 4),\n\t                                           0xFFFF);\n\tif (ret_val)\n\t\tgoto out;\n\tret_val = e1000_read_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\n\t                                          &reg_data);\n\tif (ret_val)\n\t\tgoto out;\n\treg_data |= 0x3F;\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\n\t                                           reg_data);\n\tif (ret_val)\n\t\tgoto out;\n\tret_val = e1000_read_kmrn_reg_80003es2lan(hw,\n\t                              E1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\n\t                              &reg_data);\n\tif (ret_val)\n\t\tgoto out;\n\treg_data |= E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING;\n\tret_val = e1000_write_kmrn_reg_80003es2lan(hw,\n\t                               E1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\n\t                               reg_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1000_copper_link_setup_gg82563_80003es2lan(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1000e_setup_copper_link(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_read_mac_addr_80003es2lan - Read device MAC address\n *  @hw: pointer to the HW structure\n **/\n", "func_signal": "static s32 e1000_read_mac_addr_80003es2lan(struct e1000_hw *hw)", "code": "{\n\ts32 ret_val = E1000_SUCCESS;\n\n\t/*\n\t * If there's an alternate MAC address place it in RAR0\n\t * so that it will override the Si installed default perm\n\t * address.\n\t */\n\tret_val = e1000_check_alt_mac_addr_generic(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1000_read_mac_addr_generic(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_acquire_nvm_80003es2lan - Acquire rights to access NVM\n *  @hw: pointer to the HW structure\n *\n *  Acquire the semaphore to access the EEPROM.\n **/\n", "func_signal": "static s32 e1000_acquire_nvm_80003es2lan(struct e1000_hw *hw)", "code": "{\n\ts32 ret_val;\n\n\tret_val = e1000_acquire_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1000e_acquire_nvm(hw);\n\n\tif (ret_val)\n\t\te1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_init_nvm_params_80003es2lan - Init ESB2 NVM func ptrs.\n *  @hw: pointer to the HW structure\n **/\n", "func_signal": "static s32 e1000_init_nvm_params_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_nvm_info *nvm = &hw->nvm;\n\tu32 eecd = er32(EECD);\n\tu16 size;\n\n\tnvm->opcode_bits        = 8;\n\tnvm->delay_usec         = 1;\n\tswitch (nvm->override) {\n\tcase e1000_nvm_override_spi_large:\n\t\tnvm->page_size    = 32;\n\t\tnvm->address_bits = 16;\n\t\tbreak;\n\tcase e1000_nvm_override_spi_small:\n\t\tnvm->page_size    = 8;\n\t\tnvm->address_bits = 8;\n\t\tbreak;\n\tdefault:\n\t\tnvm->page_size    = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\n\t\tnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ? 16 : 8;\n\t\tbreak;\n\t}\n\n\tnvm->type = e1000_nvm_eeprom_spi;\n\n\tsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\n\t                  E1000_EECD_SIZE_EX_SHIFT);\n\n\t/*\n\t * Added to a constant, \"size\" becomes the left-shift value\n\t * for setting word_size.\n\t */\n\tsize += NVM_WORD_SIZE_BASE_SHIFT;\n\n\t/* EEPROM access above 16k is unsupported */\n\tif (size > 14)\n\t\tsize = 14;\n\tnvm->word_size\t= 1 << size;\n\n\t/* Function Pointers */\n\tnvm->ops.acquire           = e1000_acquire_nvm_80003es2lan;\n\tnvm->ops.read              = e1000e_read_nvm_eerd;\n\tnvm->ops.release           = e1000_release_nvm_80003es2lan;\n\tnvm->ops.update            = e1000e_update_nvm_checksum_generic;\n\tnvm->ops.valid_led_default = e1000e_valid_led_default;\n\tnvm->ops.validate          = e1000e_validate_nvm_checksum_generic;\n\tnvm->ops.write             = e1000_write_nvm_80003es2lan;\n\n\treturn E1000_SUCCESS;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_acquire_mac_csr_80003es2lan - Acquire rights to access Kumeran register\n *  @hw: pointer to the HW structure\n *\n *  Acquire the semaphore to access the Kumeran interface.\n *\n **/\n", "func_signal": "static s32 e1000_acquire_mac_csr_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu16 mask;\n\n\tmask = E1000_SWFW_CSR_SM;\n\n\treturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_get_cable_length_80003es2lan - Set approximate cable length\n *  @hw: pointer to the HW structure\n *\n *  Find the approximate cable length as measured by the GG82563 PHY.\n *  This is a function pointer entry point called by the phy module.\n **/\n", "func_signal": "static s32 e1000_get_cable_length_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val = E1000_SUCCESS;\n\tu16 phy_data, index;\n\n\tret_val = e1e_rphy(hw, GG82563_PHY_DSP_DISTANCE, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tindex = phy_data & GG82563_DSPD_CABLE_LENGTH;\n\n\tif (index >= GG82563_CABLE_LENGTH_TABLE_SIZE - 5) {\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\n\tphy->min_cable_length = e1000_gg82563_cable_length_table[index];\n\tphy->max_cable_length = e1000_gg82563_cable_length_table[index + 5];\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_get_link_up_info_80003es2lan - Report speed and duplex\n *  @hw: pointer to the HW structure\n *  @speed: pointer to speed buffer\n *  @duplex: pointer to duplex buffer\n *\n *  Retrieve the current speed and duplex configuration.\n **/\n", "func_signal": "static s32 e1000_get_link_up_info_80003es2lan(struct e1000_hw *hw, u16 *speed,\n                                              u16 *duplex)", "code": "{\n\ts32 ret_val;\n\n\tif (hw->phy.media_type == e1000_media_type_copper) {\n\t\tret_val = e1000e_get_speed_and_duplex_copper(hw,\n\t\t                                                    speed,\n\t\t                                                    duplex);\n\t\thw->phy.ops.cfg_on_link_up(hw);\n\t} else {\n\t\tret_val = e1000e_get_speed_and_duplex_fiber_serdes(hw,\n\t\t                                                  speed,\n\t\t                                                  duplex);\n\t}\n\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_initialize_hw_bits_80003es2lan - Init hw bits of ESB2\n *  @hw: pointer to the HW structure\n *\n *  Initializes required hardware-dependent bits needed for normal operation.\n **/\n", "func_signal": "static void e1000_initialize_hw_bits_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu32 reg;\n\n\t/* Transmit Descriptor Control 0 */\n\treg = er32(TXDCTL(0));\n\treg |= (1 << 22);\n\tew32(TXDCTL(0), reg);\n\n\t/* Transmit Descriptor Control 1 */\n\treg = er32(TXDCTL(1));\n\treg |= (1 << 22);\n\tew32(TXDCTL(1), reg);\n\n\t/* Transmit Arbitration Control 0 */\n\treg = er32(TARC(0));\n\treg &= ~(0xF << 27); /* 30:27 */\n\tif (hw->phy.media_type != e1000_media_type_copper)\n\t\treg &= ~(1 << 20);\n\tew32(TARC(0), reg);\n\n\t/* Transmit Arbitration Control 1 */\n\treg = er32(TARC(1));\n\tif (er32(TCTL) & E1000_TCTL_MULR)\n\t\treg &= ~(1 << 28);\n\telse\n\t\treg |= (1 << 28);\n\tew32(TARC(1), reg);\n\n\treturn;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_reset_hw_80003es2lan - Reset the ESB2 controller\n *  @hw: pointer to the HW structure\n *\n *  Perform a global reset to the ESB2 controller.\n **/\n", "func_signal": "static s32 e1000_reset_hw_80003es2lan(struct e1000_hw *hw)", "code": "{\n\tu32 ctrl, icr;\n\ts32 ret_val;\n\n\t/*\n\t * Prevent the PCI-E bus from sticking if there is no TLP connection\n\t * on the last TLP read/write transaction when MAC is reset.\n\t */\n\tret_val = e1000e_disable_pcie_master(hw);\n\tif (ret_val)\n\t\te_dbg(\"PCI-E Master disable polling has failed.\\n\");\n\n\te_dbg(\"Masking off all interrupts\\n\");\n\tew32(IMC, 0xffffffff);\n\n\tew32(RCTL, 0);\n\tew32(TCTL, E1000_TCTL_PSP);\n\te1e_flush();\n\n\tmsleep(10);\n\n\tctrl = er32(CTRL);\n\n\tret_val = e1000_acquire_phy_80003es2lan(hw);\n\te_dbg(\"Issuing a global reset to MAC\\n\");\n\tew32(CTRL, ctrl | E1000_CTRL_RST);\n\te1000_release_phy_80003es2lan(hw);\n\n\tret_val = e1000e_get_auto_rd_done(hw);\n\tif (ret_val)\n\t\t/* We don't want to continue accessing MAC registers. */\n\t\tgoto out;\n\n\t/* Clear any pending interrupt events. */\n\tew32(IMC, 0xffffffff);\n\ticr = er32(ICR);\n\n\tret_val = e1000_check_alt_mac_addr_generic(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "/**\n *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore\n *  @hw: pointer to the HW structure\n *  @mask: specifies which semaphore to acquire\n *\n *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask\n *  will also specify which port we're acquiring the lock for.\n **/\n", "func_signal": "static s32 e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)", "code": "{\n\tu32 swfw_sync;\n\tu32 swmask = mask;\n\tu32 fwmask = mask << 16;\n\ts32 ret_val = E1000_SUCCESS;\n\ts32 i = 0, timeout = 50;\n\n\twhile (i < timeout) {\n\t\tif (e1000e_get_hw_semaphore(hw)) {\n\t\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswfw_sync = er32(SW_FW_SYNC);\n\t\tif (!(swfw_sync & (fwmask | swmask)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Firmware currently using resource (fwmask)\n\t\t * or other software thread using resource (swmask)\n\t\t */\n\t\te1000e_put_hw_semaphore(hw);\n\t\tmdelay(5);\n\t\ti++;\n\t}\n\n\tif (i == timeout) {\n\t\te_dbg(\"Driver can't access resource, SW_FW_SYNC timeout.\\n\");\n\t\tret_val = -E1000_ERR_SWFW_SYNC;\n\t\tgoto out;\n\t}\n\n\tswfw_sync |= swmask;\n\tew32(SW_FW_SYNC, swfw_sync);\n\n\te1000e_put_hw_semaphore(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\e1000_80003es2lan.c", "repo_name": "csd/intel", "stars": 4, "license": "other", "language": "c", "size": 332}
{"docstring": "//\n// P_LoadSubsectors\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadSubsectors (int lump)", "code": "{\n   const byte *data; // cph - const*\n   int  i;\n\n   numsubsectors = W_LumpLength (lump) / sizeof(mapsubsector_t);\n   subsectors = Z_Calloc(numsubsectors,sizeof(subsector_t),PU_LEVEL,0);\n   data = W_CacheLumpNum(lump); // cph - wad lump handling updated\n\n   for (i=0; i<numsubsectors; i++)\n   {\n      subsectors[i].numlines  = (unsigned short)SHORT(((mapsubsector_t *) data)[i].numsegs );\n      subsectors[i].firstline = (unsigned short)SHORT(((mapsubsector_t *) data)[i].firstseg);\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the data\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// Subroutine to add a line number to a block list\n// It simply returns if the line is already in the block\n//\n", "func_signal": "static void AddBlockLine\n(\n   linelist_t **lists,\n   int *count,\n   int *done,\n   int blockno,\n   long lineno\n)", "code": "{\n   linelist_t *l;\n\n   if (done[blockno])\n      return;\n\n   l = malloc(sizeof(linelist_t));\n   l->num = lineno;\n   l->next = lists[blockno];\n   lists[blockno] = l;\n   count[blockno]++;\n   done[blockno] = 1;\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "// killough 4/4/98: delay using texture names until\n// after linedefs are loaded, to allow overloading.\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadSideDefs2(int lump)", "code": "{\n   const byte *data = W_CacheLumpNum(lump); // cph - const*, wad lump handling updated\n   int  i;\n\n   for (i=0; i<numsides; i++)\n   {\n      register mapsidedef_t *msd = (mapsidedef_t *) data + i;\n      register side_t *sd = sides + i;\n      register sector_t *sec;\n\n      sd->textureoffset = SHORT(msd->textureoffset)<<FRACBITS;\n      sd->rowoffset = SHORT(msd->rowoffset)<<FRACBITS;\n\n      // killough 4/4/98: allow sidedef texture names to be overloaded\n      // killough 4/11/98: refined to allow colormaps to work as wall\n      // textures if invalid as colormaps but valid as textures.\n\n      sd->sector = sec = &sectors[SHORT(msd->sector)];\n      switch (sd->special)\n      {\n      case 242:                       // variable colormap via 242 linedef\n         sd->bottomtexture =\n            (sec->bottommap =   R_ColormapNumForName(msd->bottomtexture)) < 0 ?\n            sec->bottommap = 0, R_TextureNumForName(msd->bottomtexture): 0 ;\n         sd->midtexture =\n            (sec->midmap =   R_ColormapNumForName(msd->midtexture)) < 0 ?\n            sec->midmap = 0, R_TextureNumForName(msd->midtexture)  : 0 ;\n         sd->toptexture =\n            (sec->topmap =   R_ColormapNumForName(msd->toptexture)) < 0 ?\n            sec->topmap = 0, R_TextureNumForName(msd->toptexture)  : 0 ;\n         break;\n\n      case 260: // killough 4/11/98: apply translucency to 2s normal texture\n         sd->midtexture = strncasecmp(\"TRANMAP\", msd->midtexture, 8) ?\n                          (sd->special = W_CheckNumForName(msd->midtexture)) < 0 ||\n                          W_LumpLength(sd->special) != 65536 ?\n                          sd->special=0, R_TextureNumForName(msd->midtexture) :\n                                      (sd->special++, 0) : (sd->special=0);\n         sd->toptexture = R_TextureNumForName(msd->toptexture);\n         sd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n         break;\n\n      default:                        // normal cases\n         sd->midtexture = R_TextureNumForName(msd->midtexture);\n         sd->toptexture = R_TextureNumForName(msd->toptexture);\n         sd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n         break;\n      }\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the lump\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadLineDefs\n// Also counts secret lines for intermissions.\n//        ^^^\n// ??? killough ???\n// Does this mean secrets used to be linedef-based, rather than sector-based?\n//\n// killough 4/4/98: split into two functions, to allow sidedef overloading\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadLineDefs (int lump)", "code": "{\n   const byte *data; // cph - const*\n   int  i;\n\n   numlines = W_LumpLength (lump) / sizeof(maplinedef_t);\n   lines = Z_Calloc (numlines,sizeof(line_t),PU_LEVEL,0);\n   data = W_CacheLumpNum (lump); // cph - wad lump handling updated\n\n   for (i=0; i<numlines; i++)\n   {\n      maplinedef_t *mld = (maplinedef_t *) data + i;\n      line_t *ld = lines+i;\n      vertex_t *v1, *v2;\n\n      ld->flags = SHORT(mld->flags);\n      ld->special = SHORT(mld->special);\n      ld->tag = SHORT(mld->tag);\n      v1 = ld->v1 = &vertexes[SHORT(mld->v1)];\n      v2 = ld->v2 = &vertexes[SHORT(mld->v2)];\n      ld->dx = v2->x - v1->x;\n      ld->dy = v2->y - v1->y;\n\n      ld->tranlump = -1;   // killough 4/11/98: no translucency by default\n\n      ld->slopetype = !ld->dx ? ST_VERTICAL : !ld->dy ? ST_HORIZONTAL :\n                      FixedDiv(ld->dy, ld->dx) > 0 ? ST_POSITIVE : ST_NEGATIVE;\n\n      if (v1->x < v2->x)\n      {\n         ld->bbox[BOXLEFT] = v1->x;\n         ld->bbox[BOXRIGHT] = v2->x;\n      }\n      else\n      {\n         ld->bbox[BOXLEFT] = v2->x;\n         ld->bbox[BOXRIGHT] = v1->x;\n      }\n\n      if (v1->y < v2->y)\n      {\n         ld->bbox[BOXBOTTOM] = v1->y;\n         ld->bbox[BOXTOP] = v2->y;\n      }\n      else\n      {\n         ld->bbox[BOXBOTTOM] = v2->y;\n         ld->bbox[BOXTOP] = v1->y;\n      }\n\n      ld->sidenum[0] = SHORT(mld->sidenum[0]);\n      ld->sidenum[1] = SHORT(mld->sidenum[1]);\n\n      // killough 4/4/98: support special sidedef interpretation below\n      if (ld->sidenum[0] != -1 && ld->special)\n         sides[*ld->sidenum].special = ld->special;\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the lump\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadThings\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadThings (int lump)", "code": "{\n   mapthing_t tempthing; // this needed to be added as the SHORT calls were overwriting eachother on reload\n   int  i, numthings = W_LumpLength (lump) / sizeof(mapthing_t);\n   const byte *data = W_CacheLumpNum (lump); // cph - wad lump handling updated, const*\n\n   for (i=0; i<numthings; i++)\n   {\n      mapthing_t *mt = (mapthing_t *) data + i;\n\n      // Do not spawn cool, new monsters if !commercial\n      if (gamemode != commercial)\n         switch(mt->type)\n         {\n         case 68:  // Arachnotron\n         case 64:  // Archvile\n         case 88:  // Boss Brain\n         case 89:  // Boss Shooter\n         case 69:  // Hell Knight\n         case 67:  // Mancubus\n         case 71:  // Pain Elemental\n         case 65:  // Former Human Commando\n         case 66:  // Revenant\n         case 84:  // Wolf SS\n            continue;\n         }\n\n      // Do spawn all other stuff.\n      tempthing.x = SHORT(mt->x);\n      tempthing.y = SHORT(mt->y);\n      tempthing.angle = SHORT(mt->angle);\n      tempthing.type = SHORT(mt->type);\n      tempthing.options = SHORT(mt->options);\n\n      P_SpawnMapThing (&tempthing);\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the data\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadSideDefs\n//\n// killough 4/4/98: split into two functions\n", "func_signal": "static void P_LoadSideDefs (int lump)", "code": "{\n   numsides = W_LumpLength(lump) / sizeof(mapsidedef_t);\n   sides = Z_Calloc(numsides,sizeof(side_t),PU_LEVEL,0);\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadVertexes\n//\n// killough 5/3/98: reformatted, cleaned up\n//\n", "func_signal": "static void P_LoadVertexes (int lump)", "code": "{\n   const byte *data; // cph - const\n   int i;\n\n   // Determine number of lumps:\n   //  total lump length / vertex record length.\n   numvertexes = W_LumpLength(lump) / sizeof(mapvertex_t);\n\n   // Allocate zone memory for buffer.\n   vertexes = Z_Malloc(numvertexes*sizeof(vertex_t),PU_LEVEL,0);\n\n   // Load data into cache.\n   data = W_CacheLumpNum(lump); // cph - wad handling updated\n\n   // Copy and convert vertex coordinates,\n   // internal representation as fixed.\n   for (i=0; i<numvertexes; i++)\n   {\n      vertexes[i].x = SHORT(((mapvertex_t *) data)[i].x)<<FRACBITS;\n      vertexes[i].y = SHORT(((mapvertex_t *) data)[i].y)<<FRACBITS;\n   }\n\n   // Free buffer memory.\n   W_UnlockLumpNum(lump);\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadSegs\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadSegs (int lump)", "code": "{\n   int  i;\n   const byte *data; // cph - const\n\n   numsegs = W_LumpLength(lump) / sizeof(mapseg_t);\n   segs = Z_Calloc(numsegs,sizeof(seg_t),PU_LEVEL,0);\n   data = W_CacheLumpNum(lump); // cph - wad lump handling updated\n\n   for (i=0; i<numsegs; i++)\n   {\n      seg_t *li = segs+i;\n      mapseg_t *ml = (mapseg_t *) data + i;\n\n      int side, linedef;\n      line_t *ldef;\n\n      li->v1 = &vertexes[SHORT(ml->v1)];\n      li->v2 = &vertexes[SHORT(ml->v2)];\n\n      li->miniseg = false; // figgi -- there are no minisegs in classic BSP nodes\n\n      li->angle = (SHORT(ml->angle))<<16;\n      li->offset =(SHORT(ml->offset))<<16;\n      linedef = SHORT(ml->linedef);\n      ldef = &lines[linedef];\n      li->linedef = ldef;\n      side = SHORT(ml->side);\n      li->sidedef = &sides[ldef->sidenum[side]];\n      li->frontsector = sides[ldef->sidenum[side]].sector;\n\n      // killough 5/3/98: ignore 2s flag if second sidedef missing:\n      if (ldef->flags & ML_TWOSIDED && ldef->sidenum[side^1]!=-1)\n         li->backsector = sides[ldef->sidenum[side^1]].sector;\n      else\n         li->backsector = 0;\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the data\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "// killough 4/4/98: delay using sidedefs until they are loaded\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadLineDefs2(int lump)", "code": "{\n   (void)lump;\n   int i = numlines;\n   register line_t *ld = lines;\n   for (;i--;ld++)\n   {\n      { // cph 2002/07/20 - these errors are fatal if not fixed, so apply them in compatibility mode - a desync is better than a crash!\n         // killough 11/98: fix common wad errors (missing sidedefs):\n\n         if (ld->sidenum[0] == -1) {\n            ld->sidenum[0] = 0;  // Substitute dummy sidedef for missing right side\n            // cph - print a warning about the bug\n            printf(\"P_LoadSegs: linedef %d missing first sidedef\\n\",numlines-i);\n         }\n\n         if ((ld->sidenum[1] == -1) && (ld->flags & ML_TWOSIDED)) {\n            ld->flags &= ~ML_TWOSIDED;  // Clear 2s flag for missing left side\n            // cph - print a warning about the bug\n            printf(\"P_LoadSegs: linedef %d has two-sided flag set, but no second sidedef\\n\",numlines-i);\n         }\n      }\n\n      ld->frontsector = ld->sidenum[0]!=-1 ? sides[ld->sidenum[0]].sector : 0;\n      ld->backsector  = ld->sidenum[1]!=-1 ? sides[ld->sidenum[1]].sector : 0;\n      switch (ld->special)\n      {                       // killough 4/11/98: handle special types\n         int lump, j;\n\n      case 260:               // killough 4/11/98: translucent 2s textures\n         lump = sides[*ld->sidenum].special; // translucency from sidedef\n         if (!ld->tag)                       // if tag==0,\n            ld->tranlump = lump;              // affect this linedef only\n         else\n            for (j=0;j<numlines;j++)          // if tag!=0,\n               if (lines[j].tag == ld->tag)    // affect all matching linedefs\n                  lines[j].tranlump = lump;\n         break;\n      }\n   }\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_SpawnDoorRaiseIn5Mins()\n//\n// Spawn a door that opens after 5 minutes (called at level init)\n//\n// Passed the sector of the door, whose type specified the door action\n// Returns nothing\n//\n", "func_signal": "void P_SpawnDoorRaiseIn5Mins\n( sector_t* sec,\n  int   secnum )", "code": "{\n   (void)secnum;\n   vldoor_t* door;\n\n   door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\n   P_AddThinker (&door->thinker);\n\n   sec->ceilingdata = door; //jff 2/22/98\n   sec->special = 0;\n\n   door->thinker.function = T_VerticalDoor;\n   door->sector = sec;\n   door->direction = 2;\n   door->type = raiseIn5Mins;\n   door->speed = VDOORSPEED;\n   door->topheight = P_FindLowestCeilingSurrounding(sec);\n   door->topheight -= 4*FRACUNIT;\n   door->topwait = VDOORWAIT;\n   door->topcountdown = 5 * 60 * 35;\n   door->line = NULL; // jff 1/31/98 remember line that triggered us\n   door->lighttag = 0; /* killough 10/98: no lighting changes */\n}", "path": "apps\\plugins\\doom\\p_doors.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// EV_DoDoor\n//\n// Handle opening a tagged door\n//\n// Passed the line activating the door and the type of door\n// Returns true if a thinker created\n//\n", "func_signal": "int EV_DoDoor\n( line_t* line,\n  vldoor_e  type )", "code": "{\n   int   secnum,rtn;\n   sector_t* sec;\n   vldoor_t* door;\n\n   secnum = -1;\n   rtn = 0;\n\n   // open all doors with the same tag as the activating line\n   while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n   {\n      sec = &sectors[secnum];\n      // if the ceiling already moving, don't start the door action\n      if (P_SectorActive(ceiling_special,sec)) //jff 2/22/98\n         continue;\n\n      // new door thinker\n      rtn = 1;\n      door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n      P_AddThinker (&door->thinker);\n      sec->ceilingdata = door; //jff 2/22/98\n\n      door->thinker.function = T_VerticalDoor;\n      door->sector = sec;\n      door->type = type;\n      door->topwait = VDOORWAIT;\n      door->speed = VDOORSPEED;\n      door->line = line; // jff 1/31/98 remember line that triggered us\n      door->lighttag = 0; /* killough 10/98: no light effects with tagged doors */\n\n      // setup door parameters according to type of door\n      switch(type)\n      {\n      case blazeClose:\n         door->topheight = P_FindLowestCeilingSurrounding(sec);\n         door->topheight -= 4*FRACUNIT;\n         door->direction = -1;\n         door->speed = VDOORSPEED * 4;\n         S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdcls);\n         break;\n\n      case p_close:\n         door->topheight = P_FindLowestCeilingSurrounding(sec);\n         door->topheight -= 4*FRACUNIT;\n         door->direction = -1;\n         S_StartSound((mobj_t *)&door->sector->soundorg,sfx_dorcls);\n         break;\n\n      case close30ThenOpen:\n         door->topheight = sec->ceilingheight;\n         door->direction = -1;\n         S_StartSound((mobj_t *)&door->sector->soundorg,sfx_dorcls);\n         break;\n\n      case blazeRaise:\n      case blazeOpen:\n         door->direction = 1;\n         door->topheight = P_FindLowestCeilingSurrounding(sec);\n         door->topheight -= 4*FRACUNIT;\n         door->speed = VDOORSPEED * 4;\n         if (door->topheight != sec->ceilingheight)\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdopn);\n         break;\n\n      case normal:\n      case p_open:\n         door->direction = 1;\n         door->topheight = P_FindLowestCeilingSurrounding(sec);\n         door->topheight -= 4*FRACUNIT;\n         if (door->topheight != sec->ceilingheight)\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_doropn);\n         break;\n\n      default:\n         break;\n      }\n   }\n   return rtn;\n}", "path": "apps\\plugins\\doom\\p_doors.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_SpawnDoorCloseIn30()\n//\n// Spawn a door that closes after 30 seconds (called at level init)\n//\n// Passed the sector of the door, whose type specified the door action\n// Returns nothing\n//\n", "func_signal": "void P_SpawnDoorCloseIn30 (sector_t* sec)", "code": "{\n   vldoor_t* door;\n\n   door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\n   P_AddThinker (&door->thinker);\n\n   sec->ceilingdata = door; //jff 2/22/98\n   sec->special = 0;\n\n   door->thinker.function = T_VerticalDoor;\n   door->sector = sec;\n   door->direction = 0;\n   door->type = normal;\n   door->speed = VDOORSPEED;\n   door->topcountdown = 30 * 35;\n   door->line = NULL; // jff 1/31/98 remember line that triggered us\n   door->lighttag = 0; /* killough 10/98: no lighting changes */\n}", "path": "apps\\plugins\\doom\\p_doors.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadSectors\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadSectors (int lump)", "code": "{\n   const byte *data; // cph - const*\n   int  i;\n\n   numsectors = W_LumpLength (lump) / sizeof(mapsector_t);\n   sectors = Z_Calloc (numsectors,sizeof(sector_t),PU_LEVEL,0);\n   data = W_CacheLumpNum (lump); // cph - wad lump handling updated\n\n   for (i=0; i<numsectors; i++)\n   {\n      sector_t *ss = sectors + i;\n      const mapsector_t *ms = (mapsector_t *) data + i;\n\n      ss->floorheight = SHORT(ms->floorheight)<<FRACBITS;\n      ss->ceilingheight = SHORT(ms->ceilingheight)<<FRACBITS;\n      ss->floorpic = R_FlatNumForName(ms->floorpic);\n      ss->ceilingpic = R_FlatNumForName(ms->ceilingpic);\n      ss->lightlevel = SHORT(ms->lightlevel);\n      ss->special = SHORT(ms->special);\n      ss->oldspecial = SHORT(ms->special);\n      ss->tag = SHORT(ms->tag);\n      ss->thinglist = NULL;\n      ss->touching_thinglist = NULL;            // phares 3/14/98\n\n      ss->nextsec = -1; //jff 2/26/98 add fields to support locking out\n      ss->prevsec = -1; // stair retriggering until build completes\n\n      // killough 3/7/98:\n      ss->floor_xoffs = 0;\n      ss->floor_yoffs = 0;      // floor and ceiling flats offsets\n      ss->ceiling_xoffs = 0;\n      ss->ceiling_yoffs = 0;\n      ss->heightsec = -1;       // sector used to get floor and ceiling height\n      ss->floorlightsec = -1;   // sector used to get floor lighting\n      // killough 3/7/98: end changes\n\n      // killough 4/11/98 sector used to get ceiling lighting:\n      ss->ceilinglightsec = -1;\n\n      // killough 4/4/98: colormaps:\n      ss->bottommap = ss->midmap = ss->topmap = 0;\n\n      // killough 10/98: sky textures coming from sidedefs:\n      ss->sky = 0;\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the data\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// T_VerticalDoor\n//\n// Passed a door structure containing all info about the door.\n// See P_SPEC.H for fields.\n// Returns nothing.\n//\n// jff 02/08/98 all cases with labels beginning with gen added to support\n// generalized line type behaviors.\n", "func_signal": "void T_VerticalDoor (vldoor_t* door)", "code": "{\n   result_e  res;\n\n   // Is the door waiting, going up, or going down?\n   switch(door->direction)\n   {\n   case 0:\n      // Door is waiting\n      if (!--door->topcountdown)  // downcount and check\n      {\n         switch(door->type)\n         {\n         case blazeRaise:\n         case genBlazeRaise:\n            door->direction = -1; // time to go back down\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdcls);\n            break;\n\n         case normal:\n         case genRaise:\n            door->direction = -1; // time to go back down\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_dorcls);\n            break;\n\n         case close30ThenOpen:\n         case genCdO:\n            door->direction = 1;  // time to go back up\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_doropn);\n            break;\n\n         case genBlazeCdO:\n            door->direction = 1;  // time to go back up\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdopn);\n            break;\n\n         default:\n            break;\n         }\n      }\n      break;\n\n   case 2:\n      // Special case for sector type door that opens in 5 mins\n      if (!--door->topcountdown)  // 5 minutes up?\n      {\n         switch(door->type)\n         {\n         case raiseIn5Mins:\n            door->direction = 1;  // time to raise then\n            door->type = normal;  // door acts just like normal 1 DR door now\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_doropn);\n            break;\n\n         default:\n            break;\n         }\n      }\n      break;\n\n   case -1:\n      // Door is moving down\n      res = T_MovePlane\n            (\n               door->sector,\n               door->speed,\n               door->sector->floorheight,\n               false,\n               1,\n               door->direction\n            );\n\n      /* killough 10/98: implement gradual lighting effects */\n      if (door->lighttag && door->topheight - door->sector->floorheight)\n         EV_LightTurnOnPartway(door->line,\n                               FixedDiv(door->sector->ceilingheight -\n                                        door->sector->floorheight,\n                                        door->topheight -\n                                        door->sector->floorheight));\n\n      // handle door reaching bottom\n      if (res == pastdest)\n      {\n         switch(door->type)\n         {\n            // regular open and close doors are all done, remove them\n         case blazeRaise:\n         case blazeClose:\n         case genBlazeRaise:\n         case genBlazeClose:\n            door->sector->ceilingdata = NULL;  //jff 2/22/98\n            P_RemoveThinker (&door->thinker);  // unlink and free\n            // killough 4/15/98: remove double-closing sound of blazing doors\n            if (comp[comp_blazing])\n               S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdcls);\n            break;\n\n         case normal:\n         case p_close:\n         case genRaise:\n         case genClose:\n            door->sector->ceilingdata = NULL; //jff 2/22/98\n            P_RemoveThinker (&door->thinker);  // unlink and free\n            break;\n\n            // close then open doors start waiting\n         case close30ThenOpen:\n            door->direction = 0;\n            door->topcountdown = TICRATE*30;\n            break;\n\n         case genCdO:\n         case genBlazeCdO:\n            door->direction = 0;\n            door->topcountdown = door->topwait; // jff 5/8/98 insert delay\n            break;\n\n         default:\n            break;\n         }\n      }\n      /* jff 1/31/98 turn lighting off in tagged sectors of manual doors\n       * killough 10/98: replaced with gradual lighting code\n       */\n      else if (res == crushed) // handle door meeting obstruction on way down\n      {\n         switch(door->type)\n         {\n         case genClose:\n         case genBlazeClose:\n         case blazeClose:\n         case p_close:          // Close types do not bounce, merely wait\n            break;\n\n         case blazeRaise:\n         case genBlazeRaise:\n            door->direction = 1;\n            if (!comp[comp_blazing]) {\n               S_StartSound((mobj_t *)&door->sector->soundorg,sfx_bdopn);\n               break;\n            }\n\n         default:             // other types bounce off the obstruction\n            door->direction = 1;\n            S_StartSound((mobj_t *)&door->sector->soundorg,sfx_doropn);\n            break;\n         }\n      }\n      break;\n\n   case 1:\n      // Door is moving up\n      res = T_MovePlane\n            (\n               door->sector,\n               door->speed,\n               door->topheight,\n               false,\n               1,\n               door->direction\n            );\n\n      /* killough 10/98: implement gradual lighting effects */\n      if (door->lighttag && door->topheight - door->sector->floorheight)\n         EV_LightTurnOnPartway(door->line,\n                               FixedDiv(door->sector->ceilingheight -\n                                        door->sector->floorheight,\n                                        door->topheight -\n                                        door->sector->floorheight));\n\n      // handle door reaching the top\n      if (res == pastdest)\n      {\n         switch(door->type)\n         {\n         case blazeRaise:       // regular open/close doors start waiting\n         case normal:\n         case genRaise:\n         case genBlazeRaise:\n            door->direction = 0; // wait at top with delay\n            door->topcountdown = door->topwait;\n            break;\n\n         case close30ThenOpen:  // close and close/open doors are done\n         case blazeOpen:\n         case p_open:\n         case genBlazeOpen:\n         case genOpen:\n         case genCdO:\n         case genBlazeCdO:\n            door->sector->ceilingdata = NULL; //jff 2/22/98\n            P_RemoveThinker (&door->thinker); // unlink and free\n            break;\n\n         default:\n            break;\n         }\n\n         /* jff 1/31/98 turn lighting on in tagged sectors of manual doors\n         * killough 10/98: replaced with gradual lighting code */\n      }\n      break;\n   }\n}", "path": "apps\\plugins\\doom\\p_doors.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// Actually construct the blockmap lump from the level data\n//\n// This finds the intersection of each linedef with the column and\n// row lines at the left and bottom of each blockmap cell. It then\n// adds the line to all block lists touching the intersection.\n//\n", "func_signal": "void P_CreateBlockMap()", "code": "{\n   int xorg,yorg;                 // blockmap origin (lower left)\n   int nrows,ncols;               // blockmap dimensions\n   linelist_t **blocklists=NULL;  // array of pointers to lists of lines\n   int *blockcount=NULL;          // array of counters of line lists\n   int *blockdone=NULL;           // array keeping track of blocks/line\n   int NBlocks;                   // number of cells = nrows*ncols\n   long linetotal=0;              // total length of all blocklists\n   int i,j;\n   int map_minx=INT_MAX;          // init for map limits search\n   int map_miny=INT_MAX;\n   int map_maxx=INT_MIN;\n   int map_maxy=INT_MIN;\n\n   // scan for map limits, which the blockmap must enclose\n\n   for (i=0;i<numvertexes;i++)\n   {\n      fixed_t t;\n\n      if ((t=vertexes[i].x) < map_minx)\n         map_minx = t;\n      else if (t > map_maxx)\n         map_maxx = t;\n      if ((t=vertexes[i].y) < map_miny)\n         map_miny = t;\n      else if (t > map_maxy)\n         map_maxy = t;\n   }\n   map_minx >>= FRACBITS;    // work in map coords, not fixed_t\n   map_maxx >>= FRACBITS;\n   map_miny >>= FRACBITS;\n   map_maxy >>= FRACBITS;\n\n   // set up blockmap area to enclose level plus margin\n\n   xorg = map_minx-blkmargin;\n   yorg = map_miny-blkmargin;\n   ncols = (map_maxx+blkmargin-xorg+1+blkmask)>>blkshift;  //jff 10/12/98\n   nrows = (map_maxy+blkmargin-yorg+1+blkmask)>>blkshift;  //+1 needed for\n   NBlocks = ncols*nrows;                                  //map exactly 1 cell\n\n   // create the array of pointers on NBlocks to blocklists\n   // also create an array of linelist counts on NBlocks\n   // finally make an array in which we can mark blocks done per line\n\n   // CPhipps - calloc's\n   blocklists = calloc(NBlocks,sizeof(linelist_t *));\n   blockcount = calloc(NBlocks,sizeof(int));\n   blockdone = malloc(NBlocks*sizeof(int));\n\n   // initialize each blocklist, and enter the trailing -1 in all blocklists\n   // note the linked list of lines grows backwards\n\n   for (i=0;i<NBlocks;i++)\n   {\n      blocklists[i] = malloc(sizeof(linelist_t));\n      blocklists[i]->num = -1;\n      blocklists[i]->next = NULL;\n      blockcount[i]++;\n   }\n\n   // For each linedef in the wad, determine all blockmap blocks it touches,\n   // and add the linedef number to the blocklists for those blocks\n\n   for (i=0;i<numlines;i++)\n   {\n      int x1 = lines[i].v1->x>>FRACBITS;         // lines[i] map coords\n      int y1 = lines[i].v1->y>>FRACBITS;\n      int x2 = lines[i].v2->x>>FRACBITS;\n      int y2 = lines[i].v2->y>>FRACBITS;\n      int dx = x2-x1;\n      int dy = y2-y1;\n      int vert = !dx;                            // lines[i] slopetype\n      int horiz = !dy;\n      int spos = (dx^dy) > 0;\n      int sneg = (dx^dy) < 0;\n      int bx,by;                                 // block cell coords\n      int minx = x1>x2? x2 : x1;                 // extremal lines[i] coords\n      int maxx = x1>x2? x1 : x2;\n      int miny = y1>y2? y2 : y1;\n      int maxy = y1>y2? y1 : y2;\n\n      // no blocks done for this linedef yet\n\n      memset(blockdone,0,NBlocks*sizeof(int));\n\n      // The line always belongs to the blocks containing its endpoints\n\n      bx = (x1-xorg)>>blkshift;\n      by = (y1-yorg)>>blkshift;\n      AddBlockLine(blocklists,blockcount,blockdone,by*ncols+bx,i);\n      bx = (x2-xorg)>>blkshift;\n      by = (y2-yorg)>>blkshift;\n      AddBlockLine(blocklists,blockcount,blockdone,by*ncols+bx,i);\n\n\n      // For each column, see where the line along its left edge, which\n      // it contains, intersects the Linedef i. Add i to each corresponding\n      // blocklist.\n\n      if (!vert)    // don't interesect vertical lines with columns\n      {\n         for (j=0;j<ncols;j++)\n         {\n            // intersection of Linedef with x=xorg+(j<<blkshift)\n            // (y-y1)*dx = dy*(x-x1)\n            // y = dy*(x-x1)+y1*dx;\n\n            int x = xorg+(j<<blkshift);       // (x,y) is intersection\n            int y = (dy*(x-x1))/dx+y1;\n            int yb = (y-yorg)>>blkshift;      // block row number\n            int yp = (y-yorg)&blkmask;        // y position within block\n\n            if (yb<0 || yb>nrows-1)     // outside blockmap, continue\n               continue;\n\n            if (x<minx || x>maxx)       // line doesn't touch column\n               continue;\n\n            // The cell that contains the intersection point is always added\n\n            AddBlockLine(blocklists,blockcount,blockdone,ncols*yb+j,i);\n\n            // if the intersection is at a corner it depends on the slope\n            // (and whether the line extends past the intersection) which\n            // blocks are hit\n\n            if (yp==0)        // intersection at a corner\n            {\n               if (sneg)       //   \\ - blocks x,y-, x-,y\n               {\n                  if (yb>0 && miny<y)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*(yb-1)+j,i);\n                  if (j>0 && minx<x)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*yb+j-1,i);\n               }\n               else if (spos)  //   / - block x-,y-\n               {\n                  if (yb>0 && j>0 && minx<x)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*(yb-1)+j-1,i);\n               }\n               else if (horiz) //   - - block x-,y\n               {\n                  if (j>0 && minx<x)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*yb+j-1,i);\n               }\n            }\n            else if (j>0 && minx<x) // else not at corner: x-,y\n               AddBlockLine(blocklists,blockcount,blockdone,ncols*yb+j-1,i);\n         }\n      }\n\n      // For each row, see where the line along its bottom edge, which\n      // it contains, intersects the Linedef i. Add i to all the corresponding\n      // blocklists.\n\n      if (!horiz)\n      {\n         for (j=0;j<nrows;j++)\n         {\n            // intersection of Linedef with y=yorg+(j<<blkshift)\n            // (x,y) on Linedef i satisfies: (y-y1)*dx = dy*(x-x1)\n            // x = dx*(y-y1)/dy+x1;\n\n            int y = yorg+(j<<blkshift);       // (x,y) is intersection\n            int x = (dx*(y-y1))/dy+x1;\n            int xb = (x-xorg)>>blkshift;      // block column number\n            int xp = (x-xorg)&blkmask;        // x position within block\n\n            if (xb<0 || xb>ncols-1)   // outside blockmap, continue\n               continue;\n\n            if (y<miny || y>maxy)     // line doesn't touch row\n               continue;\n\n            // The cell that contains the intersection point is always added\n\n            AddBlockLine(blocklists,blockcount,blockdone,ncols*j+xb,i);\n\n            // if the intersection is at a corner it depends on the slope\n            // (and whether the line extends past the intersection) which\n            // blocks are hit\n\n            if (xp==0)        // intersection at a corner\n            {\n               if (sneg)       //   \\ - blocks x,y-, x-,y\n               {\n                  if (j>0 && miny<y)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*(j-1)+xb,i);\n                  if (xb>0 && minx<x)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*j+xb-1,i);\n               }\n               else if (vert)  //   | - block x,y-\n               {\n                  if (j>0 && miny<y)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*(j-1)+xb,i);\n               }\n               else if (spos)  //   / - block x-,y-\n               {\n                  if (xb>0 && j>0 && miny<y)\n                     AddBlockLine(blocklists,blockcount,blockdone,ncols*(j-1)+xb-1,i);\n               }\n            }\n            else if (j>0 && miny<y) // else not on a corner: x,y-\n               AddBlockLine(blocklists,blockcount,blockdone,ncols*(j-1)+xb,i);\n         }\n      }\n   }\n\n   // Add initial 0 to all blocklists\n   // count the total number of lines (and 0's and -1's)\n\n   memset(blockdone,0,NBlocks*sizeof(int));\n   for (i=0,linetotal=0;i<NBlocks;i++)\n   {\n      AddBlockLine(blocklists,blockcount,blockdone,i,0);\n      linetotal += blockcount[i];\n   }\n\n   // Create the blockmap lump\n\n   blockmaplump = Z_Malloc(sizeof(*blockmaplump) * (4+NBlocks+linetotal),\n                           PU_LEVEL, 0);\n   // blockmap header\n\n   blockmaplump[0] = bmaporgx = xorg << FRACBITS;\n   blockmaplump[1] = bmaporgy = yorg << FRACBITS;\n   blockmaplump[2] = bmapwidth  = ncols;\n   blockmaplump[3] = bmapheight = nrows;\n\n   // offsets to lists and block lists\n\n   for (i=0;i<NBlocks;i++)\n   {\n      linelist_t *bl = blocklists[i];\n      long offs = blockmaplump[4+i] =   // set offset to block's list\n                     (i? blockmaplump[4+i-1] : 4+NBlocks) + (i? blockcount[i-1] : 0);\n\n      // add the lines in each block's list to the blockmaplump\n      // delete each list node as we go\n\n      while (bl)\n      {\n         linelist_t *tmp = bl->next;\n         blockmaplump[offs++] = bl->num;\n         free(bl);\n         bl = tmp;\n      }\n   }\n\n   // free all temporary storage\n\n   free (blocklists);\n   free (blockcount);\n   free (blockdone);\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadNodes\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "static void P_LoadNodes (int lump)", "code": "{\n   const byte *data; // cph - const*\n   int  i;\n\n   numnodes = W_LumpLength (lump) / sizeof(mapnode_t);\n   nodes = Z_Malloc (numnodes*sizeof(node_t),PU_LEVEL,0);\n   data = W_CacheLumpNum (lump); // cph - wad lump handling updated\n\n   for (i=0; i<numnodes; i++)\n   {\n      node_t *no = nodes + i;\n      mapnode_t *mn = (mapnode_t *) data + i;\n      int j;\n\n      no->x = SHORT(mn->x)<<FRACBITS;\n      no->y = SHORT(mn->y)<<FRACBITS;\n      no->dx = SHORT(mn->dx)<<FRACBITS;\n      no->dy = SHORT(mn->dy)<<FRACBITS;\n\n      for (j=0 ; j<2 ; j++)\n      {\n         int k;\n         no->children[j] = SHORT(mn->children[j]);\n         for (k=0 ; k<4 ; k++)\n            no->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;\n      }\n   }\n\n   W_UnlockLumpNum(lump); // cph - release the data\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_LoadBlockMap\n//\n// killough 3/1/98: substantially modified to work\n// towards removing blockmap limit (a wad limitation)\n//\n// killough 3/30/98: Rewritten to remove blockmap limit,\n// though current algorithm is brute-force and unoptimal.\n//\n", "func_signal": "static void P_LoadBlockMap (int lump)", "code": "{\n   long count;\n\n   if (M_CheckParm(\"-blockmap\") || (count = W_LumpLength(lump)/2) >= 0x10000)\n      P_CreateBlockMap();\n   else\n   {\n      long i;\n      // cph - const*, wad lump handling updated\n      const short *wadblockmaplump = W_CacheLumpNum(lump);\n      blockmaplump = Z_Malloc(sizeof(*blockmaplump) * count, PU_LEVEL, 0);\n\n      // killough 3/1/98: Expand wad blockmap into larger internal one,\n      // by treating all offsets except -1 as unsigned and zero-extending\n      // them. This potentially doubles the size of blockmaps allowed,\n      // because Doom originally considered the offsets as always signed.\n\n      blockmaplump[0] = SHORT(wadblockmaplump[0]);\n      blockmaplump[1] = SHORT(wadblockmaplump[1]);\n      blockmaplump[2] = (long)(SHORT(wadblockmaplump[2])) & 0xffff;\n      blockmaplump[3] = (long)(SHORT(wadblockmaplump[3])) & 0xffff;\n\n      for (i=4 ; i<count ; i++)\n      {\n         short t = SHORT(wadblockmaplump[i]);          // killough 3/1/98\n         blockmaplump[i] = t == -1 ? -1l : (long) t & 0xffff;\n      }\n\n      W_UnlockLumpNum(lump); // cph - unlock the lump\n\n      bmaporgx = blockmaplump[0]<<FRACBITS;\n      bmaporgy = blockmaplump[1]<<FRACBITS;\n      bmapwidth = blockmaplump[2];\n      bmapheight = blockmaplump[3];\n   }\n\n   // clear out mobj chains - CPhipps - use calloc\n   blocklinks = Z_Calloc (bmapwidth*bmapheight,sizeof(*blocklinks),PU_LEVEL,0);\n   blockmap = blockmaplump+4;\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_SetupLevel\n//\n// killough 5/3/98: reformatted, cleaned up\n", "func_signal": "void P_SetupLevel(int episode, int map, int playermask, skill_t skill)", "code": "{\n   (void)playermask;\n   (void)skill;\n   int   i;\n   char  lumpname[9];\n   int   lumpnum;\n\n\n   totalkills = totalitems = totalsecret = wminfo.maxfrags = 0;\n   wminfo.partime = 180;\n\n   for (i=0; i<MAXPLAYERS; i++)\n      players[i].killcount = players[i].secretcount = players[i].itemcount = 0;\n\n   // Initial height of PointOfView will be set by player think.\n   players[consoleplayer].viewz = 1;\n\n   // Make sure all sounds are stopped before Z_FreeTags.\n   S_Start();\n\n   Z_FreeTags(PU_LEVEL, PU_PURGELEVEL-1);\n   if (rejectlump != -1) { // cph - unlock the reject table\n      W_UnlockLumpNum(rejectlump);\n      rejectlump = -1;\n   }\n\n   P_InitThinkers();\n\n   // if working with a devlopment map, reload it\n   //    W_Reload ();     killough 1/31/98: W_Reload obsolete\n\n   // find map name\n   if (gamemode == commercial)\n   {\n      if (map<10)\n         snprintf (lumpname,sizeof(lumpname),\"map0%d\", map);\n      else\n         snprintf (lumpname,sizeof(lumpname),\"map%d\", map);\n   }\n   else\n   {\n      snprintf(lumpname,sizeof(lumpname), \"E%dM%d\", episode, map);   // killough 1/24/98: simplify\n   }\n\n   lumpnum = W_GetNumForName(lumpname);\n\n   leveltime = 0;\n\n   // note: most of this ordering is important\n\n   // killough 3/1/98: P_LoadBlockMap call moved down to below\n   // killough 4/4/98: split load of sidedefs into two parts,\n   // to allow texture names to be used in special linedefs\n\n   usingGLNodes = false;\n   P_LoadVertexes  (lumpnum+ML_VERTEXES);\n   P_LoadSectors   (lumpnum+ML_SECTORS);\n   P_LoadSideDefs  (lumpnum+ML_SIDEDEFS);\n   P_LoadLineDefs  (lumpnum+ML_LINEDEFS);\n   P_LoadSideDefs2 (lumpnum+ML_SIDEDEFS);\n   P_LoadLineDefs2 (lumpnum+ML_LINEDEFS);\n   P_LoadBlockMap  (lumpnum+ML_BLOCKMAP);\n\n   P_LoadSubsectors(lumpnum + ML_SSECTORS);\n   P_LoadNodes(lumpnum + ML_NODES);\n   P_LoadSegs(lumpnum + ML_SEGS);\n\n   if (rejectlump != -1)\n      W_UnlockLumpNum(rejectlump);\n   rejectlump = lumpnum+ML_REJECT;\n   {\n      int rjlen = W_LumpLength(rejectlump);\n      int rjreq = (numsectors*numsectors+7)/8;\n      if (rjlen < rjreq) {\n         printf(\"P_SetupLevel: REJECT too short (%d<%d) - padded\\n\",rjlen,rjreq);\n         rejectmatrix = W_CacheLumpNumPadded(rejectlump,rjreq,0xff);\n      } else {\n         rejectmatrix = W_CacheLumpNum(rejectlump);\n      }\n   }\n   P_GroupLines();\n\n   P_RemoveSlimeTrails();    // killough 10/98: remove slime trails from wad\n\n   // Note: you don't need to clear player queue slots --\n   // a much simpler fix is in g_game.c -- killough 10/98\n\n   bodyqueslot = 0;\n   deathmatch_p = deathmatchstarts;\n   P_MapStart();\n   P_LoadThings(lumpnum+ML_THINGS);\n\n   // if deathmatch, randomly spawn the active players\n   if (deathmatch)\n      for (i=0; i<MAXPLAYERS; i++)\n         if (playeringame[i])\n         {\n            players[i].mo = NULL;\n            G_DeathMatchSpawnPlayer(i);\n         }\n\n   // killough 3/26/98: Spawn icon landings:\n   if (gamemode==commercial)\n      P_SpawnBrainTargets();\n\n   // clear special respawning que\n   iquehead = iquetail = 0;\n\n   // set up world state\n   P_SpawnSpecials();\n\n   P_MapEnd();\n\n   // preload graphics\n   if (precache)\n      R_PrecacheLevel();\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// EV_DoLockedDoor\n//\n// Handle opening a tagged locked door\n//\n// Passed the line activating the door, the type of door,\n// and the thing that activated the line\n// Returns true if a thinker created\n//\n", "func_signal": "int EV_DoLockedDoor\n( line_t* line,\n  vldoor_e  type,\n  mobj_t* thing )", "code": "{\n   player_t* p;\n\n   // only players can open locked doors\n   p = thing->player;\n   if (!p)\n      return 0;\n\n   // check type of linedef, and if key is possessed to open it\n   switch(line->special)\n   {\n   case 99:  // Blue Lock\n   case 133:\n      if (!p->cards[it_bluecard] && !p->cards[it_blueskull])\n      {\n         p->message = s_PD_BLUEO;             // Ty 03/27/98 - externalized\n         S_StartSound(p->mo,sfx_oof);         // killough 3/20/98\n         return 0;\n      }\n      break;\n\n   case 134: // Red Lock\n   case 135:\n      if (!p->cards[it_redcard] && !p->cards[it_redskull])\n      {\n         p->message = s_PD_REDO;              // Ty 03/27/98 - externalized\n         S_StartSound(p->mo,sfx_oof);         // killough 3/20/98\n         return 0;\n      }\n      break;\n\n   case 136: // Yellow Lock\n   case 137:\n      if (!p->cards[it_yellowcard] && !p->cards[it_yellowskull])\n      {\n         p->message = s_PD_YELLOWO;           // Ty 03/27/98 - externalized\n         S_StartSound(p->mo,sfx_oof);         // killough 3/20/98\n         return 0;\n      }\n      break;\n   }\n\n   // got the key, so open the door\n   return EV_DoDoor(line,type);\n}", "path": "apps\\plugins\\doom\\p_doors.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "//\n// P_Init\n//\n", "func_signal": "void P_Init (void)", "code": "{\n   P_InitSwitchList();\n   P_InitPicAnims();\n   R_InitSprites(sprnames);\n}", "path": "apps\\plugins\\doom\\p_setup.c", "repo_name": "ecrips/Rockbox-FuzeV2", "stars": 4, "license": "None", "language": "c", "size": 103028}
{"docstring": "/*!\n * Parse configuration file given by user, check file and daemon versions\n * and check if signature for externalized config dictionary is same as\n * givenone.\n * @param dict whole configuration file dictionary\n * @see verify_config_sign()\n * @todo Add verify code\n * @bug I have to add certificate to argument list\n */\n", "func_signal": "void\nparse_config(prop_dictionary_t dict)", "code": "{\n\tuint32_t version;\n\tprop_dictionary_t config, sign;\n\tprop_array_t authmod, app;\n\n\tif ((config = prop_dictionary_get(dict, CF_CONFIG)) == NULL)\n\t\terr(EXIT_FAILURE, \"Config file doesn't have required %s section.\\n\", CF_CONFIG);\n\t\n\tif ((sign = prop_dictionary_get(dict, CF_SIGN)) == NULL)\n\t\terr(EXIT_FAILURE, \"Config file doesn't have required %s section.\\n\", CF_SIGN);\n\n\t/* Compare Server and Config file versions and continue only if server => file */\n\tprop_dictionary_get_uint32(config, CF_CONF_VERSION, &version);\n\tif (version > AUTHLOG_VERSION)\n\t\terr(EXIT_FAILURE, \"Config file version %d id incompatible \"\n\t\t    \"with authlogd version %d.\\n\", version, AUTHLOG_VERSION);\n\n\tDPRINTF((\"Config File version validated continue parsing\\n\"));\n\n\t/* Verify config dictionary signature */\n\tif (verify_config_sign(config, sign) != 0)\n\t\terr(EXIT_FAILURE, \"Config Signature doesn't match exiting.\\n\");\n\n\tif ((app = prop_dictionary_get(config, CF_CONF_APP)) == NULL)\n\t\terr(EXIT_FAILURE, \"Config file doesn't have required %s section.\\n\", CF_CONF_APP);\n\t\n\tif ((authmod = prop_dictionary_get(config, CF_CONF_AUTHMOD)) == NULL)\n\t\terr(EXIT_FAILURE, \"Config file doesn't have required %s section.\\n\", CF_CONF_AUTHMOD);\n\n\tparse_authmod_sect(authmod);\n\n\tparse_app_sect(app);\n\t\n\treturn;\n}", "path": "config.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Verfify signature sign against buffer config.\n * @param config buffer with signed data\n * @param config_len buffer len\n * @param sign buffer with signature\n * @param sign_len buffer signature len\n * @return 1 valid checksum 0 invalid.\n */\n", "func_signal": "int\nauthlogd_verify_buf(const char *config, size_t config_len, \n\tconst char *sign, size_t sign_len)", "code": "{\n\t\n\tEVP_VerifyInit(verify_global_conf, sign_method);\n\tEVP_VerifyUpdate(verify_global_conf, config, config_len);\n\treturn EVP_VerifyFinal(verify_global_conf, (const u_char *)sign, sign_len, epubkey);\n}", "path": "ssl.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize auth hash module aplication entries, this routine will create an entry\n * in a application list and add digital hash of application to it for every application\n * in configuration file. This routine is being run from config.c::parse_app_sect function.\n *\n * @param conf_obj app_auth_mod configuration dictionary\n * @param path path to authenticated application\n * @param config pointer to auth_mod_configuration from auth_mod::auth_mod_config.\n */\n", "func_signal": "int\nauth_mod_hash_conf(prop_object_t conf_obj, const char *path, void *config)", "code": "{\n\thash_app_entry_t *app;\n\tmod_hash_conf_t *conf;\n\n\tassert(config != NULL);\n\t\n\tconf = config;\n\t\n\tDPRINTF((\"HASH auth module configuration routine called\\n\"));\n\n\tif (prop_object_type(conf_obj) != PROP_TYPE_STRING) {\n\t\twarn(\"Gid module config element for application %s require <integer> tag\\n\", path);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif ((app = malloc(sizeof(hash_app_entry_t))) == NULL)\n\t\terr(EXIT_FAILURE, \"Cannot Allocate memory %s\\n\", __func__);\n\t\n\tmemset(app, 0, sizeof(hash_app_entry_t));\n\n\tapp->app_hash = prop_string_cstring(conf_obj);\n\tstrncpy(app->app_path, path, MAXPATHLEN);\n\n\tTAILQ_INSERT_HEAD(&hash_apps_list, app, next_app);\n\t\n\treturn 0;\n}", "path": "auth_mod_hash.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize verify module.\n */\n", "func_signal": "void\nauthlogd_verify_init(void)", "code": "{\n\tverify_global_conf =  EVP_MD_CTX_create();\n\tEVP_MD_CTX_init(verify_global_conf);\n\t\n\treturn;\n}", "path": "ssl.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Parse authentication module part of configuration file init\n * default values for every module.\n * @see authmod::init()\n */\n", "func_signal": "static void\nparse_authmod_sect(prop_array_t authmod_array)", "code": "{\n\tprop_object_iterator_t iter;\n\tprop_dictionary_t authmod_dict, authmod_config_dict;\n\tauth_mod_t *auth_mod;\n\tconst char *name;\n\n\titer = prop_array_iterator(authmod_array);\n\t\n\twhile((authmod_dict = prop_object_iterator_next(iter)) != NULL){\n\n\t\tprop_dictionary_get_cstring_nocopy(authmod_dict, CF_CONF_AUTH_NAME, &name);\n\n\t\tDPRINTF((\"auth module: %s configuration found in config file\\n\", name));\n\n\t\tif ((auth_mod = auth_mod_search(name)) == NULL)\n\t\t\twarn(\"Configuration file is wrong I found auth module in it which is not compiled in\\n\");\n\n\t\tauthmod_config_dict = prop_dictionary_get(authmod_dict, CF_CONF_AUTH_CONFIG);\n\n\t\tauth_mod->init(authmod_config_dict, &auth_mod->config);\n\t}\n\t\n\treturn;\n}", "path": "config.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize auth_module defaults. This routine is being run from\n * config.c::parse_authmod_sect function.\n *\n * @param hash_dict authentication module specific details which are parsed by module it self.\n * @param hash_config double pointer to auth_mod_configuration from auth_mod::auth_mod_config.\n */\n", "func_signal": "int\nauth_mod_hash_init(prop_dictionary_t hash_dict, void **hash_config)", "code": "{\n\tmod_hash_conf_t *conf;\n\thash_t *hash;\n\tconst char *hash_type;\n\t\n\tDPRINTF((\"Auth hash mod init function called.\\n\"));\n\n\tif (!prop_dictionary_get_cstring_nocopy(hash_dict, AUTHMOD_HASH_TYPE, &hash_type)) {\n\t\twarn(\"Hash_type was not found in hash module configuration dict default is %s\\n\",\n\t\t    hashes[0].hashname);\n\t\thash_type = hashes[0].hashname;\n\t}\t    \n\tif ((conf = malloc(sizeof(mod_hash_conf_t))) == NULL)\n\t    err(EXIT_FAILURE, \"Cannot allocate memmory for hash mod configuration structure\\n\");\n\n\tmemset(conf, 0, sizeof(mod_hash_conf_t));\n\n\tfor (hash = hashes; hash->hashname != NULL; hash++)\n\t\tif (strncasecmp(hash_type, hash->hashname, strlen(hash->hashname)) == 0)\n\t\t\tconf->mod_hash = hash;\n\n\t*hash_config = conf;\n\n\tTAILQ_INIT(&hash_apps_list);\n\t\n\treturn 0;\n}", "path": "auth_mod_hash.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Generate signature of buffer buff.\n * @param buff text for which we are generating signature\n * @param buff buffer length\n * @return Dynamically allocated string caller is responsible for releasing.\n */\n", "func_signal": "char *\nauthlogd_sign_buf(const char *buff, size_t len)", "code": "{\n\tu_char *buf;\n\tunsigned char sig_b64[65];\n\tunsigned sig_len = EVP_PKEY_size(eprivkey);\n\tchar *signature;\n\t\n\tbuf = malloc ((EVP_PKEY_size(eprivkey)) * sizeof(uint8_t));\n\t\n\tEVP_SignInit(sign_global_conf, sign_method);\n\tEVP_SignUpdate(sign_global_conf, buff, len);\n\tEVP_SignFinal(sign_global_conf, buf, &sig_len, eprivkey);\n\n\tb64_ntop(buf, sig_len, (char *)sig_b64, sizeof(sig_b64));\n\tsignature = strdup((char *)sig_b64);\n\n\treturn signature;\n}", "path": "ssl.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Allocate authentication module entry for next usage.\n */\n", "func_signal": "static auth_mod_t *\nauth_mod_alloc(void)", "code": "{\n\tauth_mod_t *mod;\n\n\tif ((mod = malloc(sizeof(auth_mod_t))) == NULL)\n\t\terr(EXIT_FAILURE, \"auth_mod_alloc failed.\\n\"); \n\t\n\tmemset(mod, 0, sizeof(auth_mod_t));\n\n\treturn mod;\n}", "path": "auth_mod.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Parse application part of configuration file set application values\n * to possibly different values.\n * @see authmod::conf()\n */\n", "func_signal": "static void\nparse_app_sect(prop_array_t app_array)", "code": "{\n\tprop_object_iterator_t iter, app_iter;\n\tprop_dictionary_t app_dict, auth_dict;\n\tprop_array_t app_conf_array;\n\tprop_object_t obj;\n\tauth_mod_t *auth_mod;\n\tconst char *path;\n\tconst char *name;\n\t\n\titer = prop_array_iterator(app_array);\n\t\n\twhile((app_dict = prop_object_iterator_next(iter)) != NULL){\n\n\t\tprop_dictionary_get_cstring_nocopy(app_dict, CF_CONF_APP_PATH, &path);\n\n\t\tDPRINTF((\"app path: %s configuration found in config file\\n\", path));\n\n\t\t/* Get dictionary with auth module auth data */\n\t\tapp_conf_array = prop_dictionary_get(app_dict, CF_CONF_APP_DATA);\n\n\t\tapp_iter = prop_array_iterator(app_conf_array);\n\n\t\twhile((auth_dict = prop_object_iterator_next(app_iter)) != NULL) {\n\n\t\t\tprop_dictionary_get_cstring_nocopy(auth_dict, CF_CONF_APP_DATA_NAME, &name);\n\t\t\t\t\t\t\n\t\t\tif ((auth_mod = auth_mod_search(name)) == NULL)\n\t\t\t\twarn(\"Configuration file is wrong I found auth module in it which is not compiled in\\n\");\n\t\t\t\n\t\t\tobj = prop_dictionary_get(auth_dict, CF_CONF_APP_DATA_DATA);\n\t\t\t\n\t\t\tauth_mod->conf(obj, path, auth_mod->config);\n\t\t\n\t\t}\n\t}\n\treturn;\n}", "path": "config.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Search for auth_mod with given name in a list and return auth_mod_t if found.\n * @param auth_mod_name name of module\n */\n", "func_signal": "auth_mod_t *\nauth_mod_search(const char *auth_mod_name)", "code": "{\n\tauth_mod_t *mod;\n\n\tSLIST_FOREACH(mod, &auth_mod_list, next_mod)\n\t\tif ((strncmp(mod->name, auth_mod_name, MAX_NAME_LEN)) == 0)\n\t\t\treturn mod;\n\t\n\treturn NULL;\n}", "path": "auth_mod.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Authenticate message message from application described by information from\n * auth_msg_t.\n * @param auth_msg Structure containig information used for application authentication.\n * @bug I need to findsending application in a application list somehow.\n */\n", "func_signal": "int\nauth_mod_hash_auth(auth_msg_t *auth_msg, void *config)", "code": "{\n\thash_app_entry_t *app;\n\tmod_hash_conf_t *conf;\n\tchar *hash;\n\tint ret;\n\n\tconf = config;\n\tret = AUTH_MODULE_DENY;\n\t\n\tif ((app = search_app(auth_msg->msg_path)) == NULL)\n\t\treturn AUTH_MODULE_UNKNOWN;\n\n\tif ((hash = conf->mod_hash->filefunc(auth_msg->msg_path, NULL)) == NULL)\n\t\treturn AUTH_MODULE_UNKNOWN;\n\n\tif (strncasecmp(app->app_hash, hash, strlen(app->app_hash)) == 0)\n\t\tret = AUTH_MODULE_ALLOW;\n\t\n\treturn ret;\n}", "path": "auth_mod_hash.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Call authentication modules auth routines to receive\n * authorization for our sender.\n * @param[in] msg message sender creendentials\n * @return One entry from AUTH_MODULE_DENY, AUTH_MODULE_UNKNOW,\n *         AUTH_MODULE_ALLOW.\n */\n", "func_signal": "int\nauth_mod_loop(auth_msg_t *auth)", "code": "{\n\tauth_mod_t *mod;\n\tint ret;\n\t\n\tret = AUTH_MODULE_UNKNOWN;\n\t\n\tif (auth == NULL)\n\t\treturn ret;\n\t\t\t\n\tSLIST_FOREACH(mod, &auth_mod_list, next_mod) {\n\t\tret = mod->auth(auth, mod->config);\n\t\tif ((ret == AUTH_MODULE_DENY) ||\n\t\t    (ret == AUTH_MODULE_UNKNOWN))\n\t\t\tbreak;\n\t}\n\t\n\treturn ret;\n}", "path": "auth_mod.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Search for application in hash_apps_list. \n * @param app_path application path.\n */\n", "func_signal": "static hash_app_entry_t *\nsearch_app(const char *app_path)", "code": "{\n\thash_app_entry_t *app;\n\n\tapp = NULL;\n\t\n\tTAILQ_FOREACH(app, &hash_apps_list, next_app) {\n\t\tif (strncmp(app->app_path, app_path, strlen(app->app_path)) == 0)\n\t\t\treturn app;\n\t}\n\n\treturn app;\n}", "path": "auth_mod_hash.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Destroy Authentication module config structure.\n */\n", "func_signal": "void\nauth_mod_hash_destroy(void **config)", "code": "{\n\thash_app_entry_t *app;\n\tmod_hash_conf_t *conf;\n\n\tconf = *config;\n\n\twhile ((app = TAILQ_FIRST(&hash_apps_list)) != NULL) {\n\t\tTAILQ_REMOVE(&hash_apps_list, app, next_app);\n\t\tfree(app->app_hash);\n\t\tfree(app);\n\t}\n\n\tfree(conf);\n\n\t*config = NULL;\n\n\treturn;\n}", "path": "auth_mod_hash.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Debug routine used for dumping authmod list entries.\n */\n", "func_signal": "static void\nauth_mod_dumplist(void)", "code": "{\n\tauth_mod_t *mod;\n\tint i;\n\n\ti = 1;\n\t\n\tDPRINTF((\"Dumping auth_mod list entries\\n\"));\n\tSLIST_FOREACH(mod, &auth_mod_list, next_mod) {\n\t\tDPRINTF((\"%d. Module name: %s\\n\", i, mod->name));\n\t\ti++;\n\t}\n\treturn;\n}", "path": "auth_mod.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize Openssl library for using.\n */\n", "func_signal": "void\nauthlogd_ssl_init(void)", "code": "{\n\n\tconst char *keyfilename   = privk_file;\n\tconst char *certfilename  = cert_file;\n\n\tSSL_CTX *ctx;\n\n\tFILE *priv;\n\tFILE *certf;\n\n\tDPRINTF((\"Opening files: %s, %s\\n\", certfilename, keyfilename));\n\n\tSSL_library_init();\n\t\n\tif (!(ctx = SSL_CTX_new(SSLv23_method())))\n\t\terr(EXIT_FAILURE, \"Cannot initialize SSL %s\\n\", \n\t\t\tERR_error_string(ERR_get_error(), NULL));\n\n\tif (!(priv  = fopen(keyfilename,  \"r\")) || !(certf = fopen(certfilename, \"r\"))) {\n\t\tDPRINTF((\"Unable to open certfilenameificate file %s and private key file %s\\n\",\n\t\t \tcertfilename, keyfilename));\n\t\treturn;\n\t} \n\n\t/* Close files */\n\tfclose(priv);\n\tfclose(certf);\n\n\t/* Open cert filename file and private key file */\n\tif (!SSL_CTX_use_PrivateKey_file(ctx, keyfilename, SSL_FILETYPE_PEM) ||\n\t    !SSL_CTX_use_certificate_chain_file(ctx, certfilename)) {\n\t\tDPRINTF((\"Unable to load key/certfilename files: %s\\n\", \n\t\t\tERR_error_string(ERR_get_error(), NULL)));\n\t\treturn;\n\t}\n\n\tif (!SSL_CTX_check_private_key(ctx)) {\n\t\tDPRINTF((\"Private key \\\"%s\\\" does not match \"\n\t\t    \"certificate \\\"%s\\\": %s\",\n\t\t    keyfilename, certfilename,\n\t\t    ERR_error_string(ERR_get_error(), NULL)));\n\t\treturn;\n\t}\n\n\t(void)SSL_CTX_set_options(ctx,\n\t    SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_SINGLE_DH_USE);\n\t(void)SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n\tssl_global_conf = ctx;\n\n\treturn;\n}", "path": "ssl.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize auth_module subsystem and setup default auth modules.\n */\n", "func_signal": "void\nauth_mod_init(void)", "code": "{\n\tauth_mod_t *mod1, *mod2;\n\n\tSLIST_INIT(&auth_mod_list);\n\t\t\n\tmod1 = auth_mod_alloc();\n\tstrncpy(mod1->name, \"auth_hash\", MAX_NAME_LEN);\n\tmod1->init = &auth_mod_hash_init;\n\tmod1->conf = &auth_mod_hash_conf;\n\tmod1->destroy = &auth_mod_hash_destroy;\n\tmod1->auth = &auth_mod_hash_auth;\n\tauth_mod_add(mod1);\n\t\n\tmod2 = auth_mod_alloc();\n\tstrncpy(mod2->name, \"auth_gid\", MAX_NAME_LEN);\n\tmod2->init = &auth_mod_gid_init;\n\tmod2->conf = &auth_mod_gid_conf;\n\tmod2->destroy = &auth_mod_gid_destroy;\n\tmod2->auth = &auth_mod_gid_auth;\n\tauth_mod_add(mod2);\n\n\tauth_mod_dumplist();\n}", "path": "auth_mod.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Initialize signing module.\n */\n", "func_signal": "void\nauthlogd_sign_init(void)", "code": "{\n\tSSL *ssl;\n\n\tsign_global_conf =  EVP_MD_CTX_create();\n\tEVP_MD_CTX_init(sign_global_conf);\n\n\tif ((ssl = SSL_new(ssl_global_conf))) {\n\t\tDPRINTF((\"Try to get keys from TLS X.509 cert...\\n\"));\n\n\t\tif (!(xcert = SSL_get_certificate(ssl))) {\n\t\t\tDPRINTF((\"SSL_get_certificate() failed\"));\n\t\t\tSSL_free(ssl);\n\t\t\treturn;\n\t\t}\n\t\tif (!(eprivkey = SSL_get_privatekey(ssl))) {\n\t\t\tDPRINTF((\"SSL_get_privatekey() failed\"));\n\t\t\tSSL_free(ssl);\n\t\t\treturn;\n\t\t}\n\t\tif (!(epubkey = X509_get_pubkey(xcert))) {\n\t\t\tDPRINTF((\"X509_get_pubkey() failed\"));\n\t\t\tSSL_free(ssl);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tSSL_free(ssl);\n\n\tif (EVP_PKEY_DSA != EVP_PKEY_type(epubkey->type)) {\n\t\tDPRINTF((\"X.509 cert has no DSA key\\n\"));\n\t\tEVP_PKEY_free(epubkey);\n\t\teprivkey = NULL;\n\t\tepubkey = NULL;\n\t} else {\n\t\tDPRINTF((\"Got public and private key \"\n\t\t    \"from X.509 --> use type PKIX\\n\"));\n\n\t\tsign_method = EVP_dss1();\n\t}\n}", "path": "ssl.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Verify Signature on config block.\n * @bug Add support for signature checking.\n * @bug I have to add certificate to argument list\n */\n", "func_signal": "static int\nverify_config_sign(prop_dictionary_t config, prop_dictionary_t sign)", "code": "{\n\t\n\tconst char *signb;\n\tconst char *conf;\n\t\n\tconf = prop_dictionary_externalize(config);\n\t\n\tprop_dictionary_get_cstring_nocopy(sign, CF_SIGN_BLOCK, &signb);\n\t\t\n\tif ((authlogd_verify_buf(conf, strlen(conf), signb, strlen(signb))) == 0)\n\t\terr(EXIT_FAILURE, \"Cannot validate config file\\n\");\n\t\n\tDPRINTF((\"Config file digital signature validated!!\\n\"));\n\t\n\treturn 0;\n}", "path": "config.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*!\n * Dump part of configuration file used for sign.\n * @param dict Configuration dictionary\n * @param path Path where we are going to externalize config section\n */\n", "func_signal": "void\ndump_config(prop_dictionary_t dict, const char *path)", "code": "{\n\tprop_dictionary_t config;\n\n\tif ((config = prop_dictionary_get(dict, CF_CONFIG)) == NULL)\n\t\terr(EXIT_FAILURE, \"Config file doesn't have required %s section.\\n\", CF_CONFIG);\n\n\tprop_dictionary_externalize_to_file(config, path);\n\n\treturn;\n}", "path": "config.c", "repo_name": "haad/authlogd", "stars": 4, "license": "None", "language": "c", "size": 1508}
{"docstring": "/*\n * Load CMap stream in PDF file\n */\n", "func_signal": "fz_error *\npdf_loadembeddedcmap(pdf_cmap **cmapp, pdf_xref *xref, fz_obj *stmref)", "code": "{\n\tfz_error *error = fz_okay;\n\tfz_obj *stmobj = stmref;\n\tfz_stream *file;\n\tpdf_cmap *cmap = nil;\n\tpdf_cmap *usecmap;\n\tfz_obj *wmode;\n\tfz_obj *obj;\n\n\tif ((*cmapp = pdf_finditem(xref->store, PDF_KCMAP, stmref)))\n\t{\n\t\tpdf_keepcmap(*cmapp);\n\t\treturn fz_okay;\n\t}\n\n\tpdf_logfont(\"load embedded cmap %d %d {\\n\", fz_tonum(stmref), fz_togen(stmref));\n\n\terror = pdf_resolve(&stmobj, xref);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot resolve cmap object\");\n\n\terror = pdf_openstream(&file, xref, fz_tonum(stmref), fz_togen(stmref));\n\tif (error)\n\t{\n\t\terror = fz_rethrow(error, \"cannot open cmap stream\");\n\t\tgoto cleanup;\n\t}\n\n\terror = pdf_parsecmap(&cmap, file);\n\tif (error)\n\t{\n\t\terror = fz_rethrow(error, \"cannot parse cmap stream\");\n\t\tgoto cleanup;\n\t}\n\n\tfz_dropstream(file);\n\n\twmode = fz_dictgets(stmobj, \"WMode\");\n\tif (fz_isint(wmode))\n\t{\n\t\tpdf_logfont(\"wmode %d\\n\", wmode);\n\t\tpdf_setwmode(cmap, fz_toint(wmode));\n\t}\n\n\tobj = fz_dictgets(stmobj, \"UseCMap\");\n\tif (fz_isname(obj))\n\t{\n\t\tpdf_logfont(\"usecmap /%s\\n\", fz_toname(obj));\n\t\terror = pdf_loadsystemcmap(&usecmap, fz_toname(obj));\n\t\tif (error)\n\t\t{\n\t\t\terror = fz_rethrow(error, \"cannot load system usecmap '%s'\", fz_toname(obj));\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpdf_setusecmap(cmap, usecmap);\n\t\tpdf_dropcmap(usecmap);\n\t}\n\telse if (fz_isindirect(obj))\n\t{\n\t\tpdf_logfont(\"usecmap %d %d R\\n\", fz_tonum(obj), fz_togen(obj));\n\t\terror = pdf_loadembeddedcmap(&usecmap, xref, obj);\n\t\tif (error)\n\t\t{\n\t\t\terror = fz_rethrow(error, \"cannot load embedded usecmap\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpdf_setusecmap(cmap, usecmap);\n\t\tpdf_dropcmap(usecmap);\n\t}\n\n\tpdf_logfont(\"}\\n\");\n\n\terror = pdf_storeitem(xref->store, PDF_KCMAP, stmref, cmap);\n\tif (error)\n\t{\n\t\terror = fz_rethrow(error, \"cannot store cmap resource\");\n\t\tgoto cleanup;\n\t}\n\n\tfz_dropobj(stmobj);\n\n\t*cmapp = cmap;\n\treturn fz_okay;\n\ncleanup:\n\tif (cmap)\n\t\tpdf_dropcmap(cmap);\n\tfz_dropobj(stmobj);\n\treturn error; /* already rethrown */\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Create an Identity-* CMap (for both 1 and 2-byte encodings)\n */\n", "func_signal": "fz_error *\npdf_newidentitycmap(pdf_cmap **cmapp, int wmode, int bytes)", "code": "{\n\tfz_error *error;\n\tpdf_cmap *cmap;\n\n\terror = pdf_newcmap(&cmap);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot create cmap\");\n\n\tsprintf(cmap->cmapname, \"Identity-%c\", wmode ? 'V' : 'H');\n\n\terror = pdf_addcodespace(cmap, 0x0000, 0xffff, bytes);\n\tif (error) {\n\t\tpdf_dropcmap(cmap);\n\t\treturn fz_rethrow(error, \"cannot add code space\");\n\t}\n\n\terror = pdf_maprangetorange(cmap, 0x0000, 0xffff, 0);\n\tif (error) {\n\t\tpdf_dropcmap(cmap);\n\t\treturn fz_rethrow(error, \"cannot map <0000> to <ffff>\");\n\t}\n\n\terror = pdf_sortcmap(cmap);\n\tif (error) {\n\t\tpdf_dropcmap(cmap);\n\t\treturn fz_rethrow(error, \"cannot sort cmap\");\n\t}\n\n\tpdf_setwmode(cmap, wmode);\n\n\t*cmapp = cmap;\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add a range-to-table mapping.\n */\n", "func_signal": "fz_error *\npdf_maprangetotable(pdf_cmap *cmap, int low, int *table, int len)", "code": "{\n\tfz_error *error;\n\tint offset;\n\tint high;\n\tint i;\n\n\thigh = low + len;\n\toffset = cmap->tlen;\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\terror = addtable(cmap, table[i]);\n\t\tif (error)\n\t\t\treturn fz_rethrow(error, \"cannot add range-to-table index\");\n\t}\n\n\terror = addrange(cmap, low, high, TABLE, offset);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot add range-to-table range\");\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Scan convert\n */\n", "func_signal": "static inline void\naddspan(unsigned char *list, int x0, int x1, int xofs)", "code": "{\n\tint x0pix, x0sub;\n\tint x1pix, x1sub;\n\n\tif (x0 == x1)\n\t\treturn;\n\n\t/* x between 0 and width of bbox */\n\tx0 -= xofs;\n\tx1 -= xofs;\n\n\tx0pix = x0 / HSCALE;\n\tx0sub = x0 % HSCALE;\n\tx1pix = x1 / HSCALE;\n\tx1sub = x1 % HSCALE;\n\n\tif (x0pix == x1pix)\n\t{\n\t\tlist[x0pix] += x1sub - x0sub;\n\t\tlist[x0pix+1] += x0sub - x1sub;\n\t}\n\n\telse\n\t{\n\t\tlist[x0pix] += HSCALE - x0sub;\n\t\tlist[x0pix+1] += x0sub;\n\t\tlist[x1pix] += x1sub - HSCALE;\n\t\tlist[x1pix+1] += -x1sub;\n\t}\n}", "path": "raster\\pathscan.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/* decode one 1d code */\n", "func_signal": "static fz_error *\ndec1d(fz_faxd *fax)", "code": "{\n\tint code;\n\n\tif (fax->a == -1)\n\t\tfax->a = 0;\n\n\tif (fax->c)\n\t\tcode = getcode(fax, cf_black_decode, cfd_black_initial_bits);\n\telse\n\t\tcode = getcode(fax, cf_white_decode, cfd_white_initial_bits);\n\n\tif (code == UNCOMPRESSED)\n\t\treturn fz_throw(\"uncompressed data in faxd\");\n\n\tif (code < 0)\n\t\treturn fz_throw(\"negative code in 1d faxd\");\n\n\tif (fax->a + code > fax->columns)\n\t\treturn fz_throw(\"overflow in 1d faxd\");\n\n\tif (fax->c)\n\t\tsetbits(fax->dst, fax->a, fax->a + code);\n\n\tfax->a += code;\n\n\tif (code < 64)\n\t{\n\t\tfax->c = !fax->c;\n\t\tfax->stage = SNORMAL;\n\t}\n\telse\n\t\tfax->stage = SMAKEUP;\n\n\treturn fz_okay;\n}", "path": "stream\\filt_faxd.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Lookup the mapping of a codepoint.\n */\n", "func_signal": "int\npdf_lookupcmap(pdf_cmap *cmap, int cpt)", "code": "{\n\tint l = 0;\n\tint r = cmap->rlen - 1;\n\tint m;\n\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < cmap->ranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > cmap->ranges[m].high)\n\t\t\tl = m + 1;\n\t\telse\n\t\t{\n\t\t\tint i = cpt - cmap->ranges[m].low + cmap->ranges[m].offset;\n\t\t\tif (cmap->ranges[m].flag == TABLE)\n\t\t\t\treturn cmap->table[i];\n\t\t\tif (cmap->ranges[m].flag == MULTI)\n\t\t\t\treturn -1;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (cmap->usecmap)\n\t\treturn pdf_lookupcmap(cmap->usecmap, cpt);\n\n\treturn -1;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Allocate, destroy and simple parameters.\n */\n", "func_signal": "fz_error *\npdf_newcmap(pdf_cmap **cmapp)", "code": "{\n\tpdf_cmap *cmap;\n\n\tcmap = *cmapp = fz_malloc(sizeof(pdf_cmap));\n\tif (!cmap)\n\t\treturn fz_throw(\"outofmem: cmap struct\");\n\n\tcmap->refs = 1;\n\tcmap->staticdata = 0;\n\tstrcpy(cmap->cmapname, \"\");\n\n\tstrcpy(cmap->usecmapname, \"\");\n\tcmap->usecmap = nil;\n\n\tcmap->wmode = 0;\n\n\tcmap->ncspace = 0;\n\n\tcmap->rlen = 0;\n\tcmap->rcap = 0;\n\tcmap->ranges = nil;\n\n\tcmap->tlen = 0;\n\tcmap->tcap = 0;\n\tcmap->table = nil;\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add a codespacerange section.\n * These ranges are used by pdf_decodecmap to decode\n * multi-byte encoded strings.\n */\n", "func_signal": "fz_error *\npdf_addcodespace(pdf_cmap *cmap, unsigned lo, unsigned hi, int n)", "code": "{\n\tint i;\n\n\tassert(!cmap->staticdata);\n\n\tif (cmap->ncspace + 1 == MAXCODESPACE)\n\t\treturn fz_throw(\"assert: too many code space ranges\");\n\n\tcmap->cspace[cmap->ncspace].n = n;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tint o = (n - i - 1) * 8;\n\t\tcmap->cspace[cmap->ncspace].lo[i] = (lo >> o) & 0xFF;\n\t\tcmap->cspace[cmap->ncspace].hi[i] = (hi >> o) & 0xFF;\n\t}\n\n\tcmap->ncspace ++;\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add an integer to the table.\n */\n", "func_signal": "static fz_error *\naddtable(pdf_cmap *cmap, int value)", "code": "{\n\tassert(!cmap->staticdata);\n\tif (cmap->tlen + 1 > cmap->tcap)\n\t{\n\t\tint newcap = cmap->tcap == 0 ? 256 : cmap->tcap * 2;\n\t\tint *newtable = fz_realloc(cmap->table, newcap * sizeof(int));\n\t\tif (!newtable)\n\t\t\treturn fz_throw(\"outofmem: cmap table\");\n\t\tcmap->tcap = newcap;\n\t\tcmap->table = newtable;\n\t}\n\n\tcmap->table[cmap->tlen++] = value;\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add a range.\n */\n", "func_signal": "static fz_error *\naddrange(pdf_cmap *cmap, int low, int high, int flag, int offset)", "code": "{\n\tassert(!cmap->staticdata);\n\tif (cmap->rlen + 1 > cmap->rcap)\n\t{\n\t\tpdf_range *newranges;\n\t\tint newcap = cmap->rcap == 0 ? 256 : cmap->rcap * 2;\n\t\tnewranges = fz_realloc(cmap->ranges, newcap * sizeof(pdf_range));\n\t\tif (!newranges)\n\t\t\treturn fz_throw(\"outofmem: cmap ranges\");\n\t\tcmap->rcap = newcap;\n\t\tcmap->ranges = newranges;\n\t}\n\n\tcmap->ranges[cmap->rlen].low = low;\n\tcmap->ranges[cmap->rlen].high = high;\n\tcmap->ranges[cmap->rlen].flag = flag;\n\tcmap->ranges[cmap->rlen].offset = offset;\n\tcmap->rlen ++;\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/* decode one 2d code */\n", "func_signal": "static fz_error *\ndec2d(fz_faxd *fax)", "code": "{\n\tint code, b1, b2;\n\n\tif (fax->stage == SH1 || fax->stage == SH2)\n\t{\n\t\tif (fax->a == -1)\n\t\t\tfax->a = 0;\n\n\t\tif (fax->c)\n\t\t\tcode = getcode(fax, cf_black_decode, cfd_black_initial_bits);\n\t\telse\n\t\t\tcode = getcode(fax, cf_white_decode, cfd_white_initial_bits);\n\n\t\tif (code == UNCOMPRESSED)\n\t\t\treturn fz_throw(\"uncompressed data in faxd\");\n\n\t\tif (code < 0)\n\t\t\treturn fz_throw(\"negative code in 2d faxd\");\n\n\t\tif (fax->a + code > fax->columns)\n\t\t\treturn fz_throw(\"overflow in 2d faxd\");\n\n\t\tif (fax->c)\n\t\t\tsetbits(fax->dst, fax->a, fax->a + code);\n\n\t\tfax->a += code;\n\n\t\tif (code < 64)\n\t\t{\n\t\t\tfax->c = !fax->c;\n\t\t\tif (fax->stage == SH1)\n\t\t\t\tfax->stage = SH2;\n\t\t\telse if (fax->stage == SH2)\n\t\t\t\tfax->stage = SNORMAL;\n\t\t}\n\n\t\treturn fz_okay;\n\t}\n\n\tcode = getcode(fax, cf_2d_decode, cfd_2d_initial_bits);\n\n\tswitch (code)\n\t{\n\t\tcase H:\n\t\t\tfax->stage = SH1;\n\t\t\tbreak;\n\n\t\tcase P:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tb2 = findchanging(fax->ref, b1, fax->columns);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b2);\n\t\t\tfax->a = b2;\n\t\t\tbreak;\n\n\t\tcase V0:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1);\n\t\t\tfax->a = b1;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VR1:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 + 1);\n\t\t\tfax->a = b1 + 1;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VR2:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 + 2);\n\t\t\tfax->a = b1 + 2;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VR3:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 + 3);\n\t\t\tfax->a = b1 + 3;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VL1:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 - 1);\n\t\t\tfax->a = b1 - 1;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VL2:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 - 2);\n\t\t\tfax->a = b1 - 2;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase VL3:\n\t\t\tb1 = findchangingcolor(fax->ref, fax->a, fax->columns, !fax->c);\n\t\t\tif (fax->c) setbits(fax->dst, fax->a, b1 - 3);\n\t\t\tfax->a = b1 - 3;\n\t\t\tfax->c = !fax->c;\n\t\t\tbreak;\n\n\t\tcase UNCOMPRESSED:\n\t\t\treturn fz_throw(\"uncompressed data in faxd\");\n\n\t\tcase ERROR:\n\t\t\treturn fz_throw(\"invalid code in 2d faxd\");\n\n\t\tdefault:\n\t\t\treturn fz_throw(\"invalid code in 2d faxd (%d)\", code);\n\t}\n\n\treturn 0;\n}", "path": "stream\\filt_faxd.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Active Edge List -- keep track of active edges while sweeping\n */\n", "func_signal": "fz_error *\nfz_newael(fz_ael **aelp)", "code": "{\n\tfz_ael *ael;\n\n\tael = *aelp = fz_malloc(sizeof(fz_ael));\n\tif (!ael)\n\t\treturn fz_outofmem;\n\n\tael->cap = 64;\n\tael->len = 0;\n\tael->edges = fz_malloc(sizeof(fz_edge*) * ael->cap);\n\tif (!ael->edges) {\n\t\tfz_free(ael);\n\t\treturn fz_outofmem;\n\t}\n\n\treturn fz_okay;\n}", "path": "raster\\pathscan.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/* Copy src to string dst of size siz. At most siz-1 characters\n * will be copied. Always NUL terminates (unless siz == 0).\n * Returns strlen(src); if retval >= siz, truncation occurred.\n */\n", "func_signal": "int strlcpy(char *dst, const char *src, int siz)", "code": "{\n\tregister char *d = dst;\n\tregister const char *s = src;\n\tregister int n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}", "path": "base\\util_strlcpy.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Load predefined CMap from system\n */\n", "func_signal": "fz_error *\npdf_loadsystemcmap(pdf_cmap **cmapp, char *name)", "code": "{\n\tfz_error *error = fz_okay;\n\tfz_stream *file;\n\tchar *cmapdir;\n\tchar *usecmapname;\n\tpdf_cmap *usecmap;\n\tpdf_cmap *cmap;\n\tchar path[1024];\n\n\tcmap = nil;\n\tfile = nil;\n\n\tpdf_logfont(\"load system cmap %s {\\n\", name);\n\terror = getstaticcmap(name, &cmap);\n\tif (!error && cmap) {\n\t\t*cmapp = cmap;\n\t\treturn fz_okay;\n\t}\n\tif (error)\n\t\tfz_droperror(error);\n\n#ifdef DUMP_STATIC_CMAPS\n\tprintf(\"\\nCMAP: filenamec='%s'\\n\", name);\n#endif\n\n\tcmapdir = getenv(\"CMAPDIR\");\n\tif (!cmapdir)\n\t\treturn fz_throw(\"ioerror: CMAPDIR environment not set\");\n\n\tstrlcpy(path, cmapdir, sizeof path);\n\tstrlcat(path, DIR_SEP_STR, sizeof path);\n\tstrlcat(path, name, sizeof path);\n\n\terror = fz_openrfile(&file, path);\n\tif (error)\n\t{\n\t\terror = fz_rethrow(error, \"cannot open cmap file '%s'\", name);\n\t\tgoto cleanup;\n\t}\n\n\terror = pdf_parsecmap(&cmap, file);\n\tif (error)\n\t{\n\t\terror = fz_rethrow(error, \"cannot parse cmap file\");\n\t\tgoto cleanup;\n\t}\n\n\tfz_dropstream(file);\n\n#ifdef DUMP_STATIC_CMAPS\n\tpdf_dumpcmapasccode(cmap, name);\n#endif\n\n\tusecmapname = cmap->usecmapname;\n\tif (usecmapname[0])\n\t{\n\t\tpdf_logfont(\"usecmap %s\\n\", usecmapname);\n\t\terror = pdf_loadsystemcmap(&usecmap, usecmapname);\n\t\tif (error)\n\t\t{\n\t\t\terror = fz_rethrow(error, \"cannot load system usecmap '%s'\", usecmapname);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpdf_setusecmap(cmap, usecmap);\n\t\tpdf_dropcmap(usecmap);\n\t}\n\n\tpdf_logfont(\"}\\n\");\n\n\t*cmapp = cmap;\n\treturn fz_okay;\n\ncleanup:\n\tif (cmap)\n\t\tpdf_dropcmap(cmap);\n\tif (file)\n\t\tfz_dropstream(file);\n\treturn error; /* already rethrown */\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add a single one-to-many mapping.\n */\n", "func_signal": "fz_error *\npdf_maponetomany(pdf_cmap *cmap, int low, int *values, int len)", "code": "{\n\tfz_error *error;\n\tint offset;\n\tint i;\n\n\tif (len == 1)\n\t{\n\t\terror = addrange(cmap, low, low, SINGLE, values[0]);\n\t\tif (error)\n\t\t\treturn fz_rethrow(error, \"cannot add one-to-one mapping\");\n\t\treturn fz_okay;\n\t}\n\n\toffset = cmap->tlen;\n\n\terror = addtable(cmap, len);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot add one-to-many table length\");\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\terror = addtable(cmap, values[i]);\n\t\tif (error)\n\t\t\treturn fz_rethrow(error, \"cannot add one-to-many table index\");\n\t}\n\n\terror = addrange(cmap, low, low, MULTI, offset);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot add one-to-many mapping\");\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/* WIN32 */\n", "func_signal": "void fz_cpudetect(void)", "code": "{\n\tstatic int hasrun = 0;\n\n\tunsigned flags = 0;\n\tint i;\n\tchar *env;\n\n\tif (hasrun)\n\t\treturn;\n\thasrun = 1;\n\n\tenv = getenv(\"CPUACCEL\");\n\n\tfor (i = 0; i < sizeof(features) / sizeof(featuretest); i++)\n\t{\n\t\t__try\n\t\t{\n\t\t\tfeatures[i].test();\n\t\t}\n\t\t__except(EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\t/* test failed - disable feature */\n\t\t\tflags &= ~features[i].flag;\n\t\t\tcontinue;\n\t\t}\n\n#if defined(ARCH_X86) || defined(ARCH_X86_64)\n\t\tif (features[i].flag & (HAVE_MMX | HAVE_3DNOW | HAVE_MMXEXT)) {\n\t\t\t/* reset mmx/x87 pipeline state */\n\t\t\t__asm emms;\n\t\t}\n#endif\n\n\t\t/* if we got here the test succeeded */\n\t\tif (enabled(env, features[i].name))\n\t\t\tflags |= features[i].flag;\n\t\telse\n\t\t\tflags &= ~features[i].flag;\n\t}\n\n\tfz_cpuflags = flags;\n\n\tdumpflags();\n}", "path": "base\\base_cpudep.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Sort the input ranges.\n * Merge contiguous input ranges to range-to-range if the output is contiguous.\n * Merge contiguous input ranges to range-to-table if the output is random.\n */\n", "func_signal": "fz_error *\npdf_sortcmap(pdf_cmap *cmap)", "code": "{\n\tfz_error *error;\n\tpdf_range *newranges;\n\tint *newtable;\n\tpdf_range *a;\t\t\t/* last written range on output */\n\tpdf_range *b;\t\t\t/* current range examined on input */\n\n\tassert(!cmap->staticdata);\n\n\tif (cmap->rlen == 0)\n\t\treturn fz_okay;\n\n\tqsort(cmap->ranges, cmap->rlen, sizeof(pdf_range), cmprange);\n\n\ta = cmap->ranges;\n\tb = cmap->ranges + 1;\n\n\twhile (b < cmap->ranges + cmap->rlen)\n\t{\n\t\t/* ignore one-to-many mappings */\n\t\tif (b->flag == MULTI)\n\t\t{\n\t\t\t*(++a) = *b;\n\t\t}\n\n\t\t/* input contiguous */\n\t\telse if (a->high + 1 == b->low)\n\t\t{\n\t\t\t/* output contiguous */\n\t\t\tif (a->high - a->low + a->offset + 1 == b->offset)\n\t\t\t{\n\t\t\t\t/* SR -> R and SS -> R and RR -> R and RS -> R */\n\t\t\t\tif (a->flag == SINGLE || a->flag == RANGE)\n\t\t\t\t{\n\t\t\t\t\ta->flag = RANGE;\n\t\t\t\t\ta->high = b->high;\n\t\t\t\t}\n\n\t\t\t\t/* LS -> L */\n\t\t\t\telse if (a->flag == TABLE && b->flag == SINGLE)\n\t\t\t\t{\n\t\t\t\t\ta->high = b->high;\n\t\t\t\t\terror = addtable(cmap, b->offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\treturn fz_rethrow(error, \"cannot convert LS -> L\");\n\t\t\t\t}\n\n\t\t\t\t/* LR -> LR */\n\t\t\t\telse if (a->flag == TABLE && b->flag == RANGE)\n\t\t\t\t{\n\t\t\t\t\t*(++a) = *b;\n\t\t\t\t}\n\n\t\t\t\t/* XX -> XX */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*(++a) = *b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* output separated */\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* SS -> L */\n\t\t\t\tif (a->flag == SINGLE && b->flag == SINGLE)\n\t\t\t\t{\n\t\t\t\t\ta->flag = TABLE;\n\t\t\t\t\ta->high = b->high;\n\n\t\t\t\t\terror = addtable(cmap, a->offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\treturn fz_rethrow(error, \"cannot convert SS -> L\");\n\n\t\t\t\t\terror = addtable(cmap, b->offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\treturn fz_rethrow(error, \"cannot convert SS -> L\");\n\n\t\t\t\t\ta->offset = cmap->tlen - 2;\n\t\t\t\t}\n\n\t\t\t\t/* LS -> L */\n\t\t\t\telse if (a->flag == TABLE && b->flag == SINGLE)\n\t\t\t\t{\n\t\t\t\t\ta->high = b->high;\n\t\t\t\t\terror = addtable(cmap, b->offset);\n\t\t\t\t\tif (error)\n\t\t\t\t\t\treturn fz_rethrow(error, \"cannot convert LS -> L\");\n\t\t\t\t}\n\n\t\t\t\t/* XX -> XX */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*(++a) = *b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* input separated: XX -> XX */\n\t\telse\n\t\t{\n\t\t\t*(++a) = *b;\n\t\t}\n\n\t\tb ++;\n\t}\n\n\tcmap->rlen = a - cmap->ranges + 1;\n\n\tnewranges = fz_realloc(cmap->ranges, cmap->rlen * sizeof(pdf_range));\n\tif (!newranges)\n\t\treturn fz_throw(\"outofmem: cmap ranges\");\n\tcmap->rcap = cmap->rlen;\n\tcmap->ranges = newranges;\n\n\tif (cmap->tlen)\n\t{\n\t\tnewtable = fz_realloc(cmap->table, cmap->tlen * sizeof(int));\n\t\tif (!newtable)\n\t\t\treturn fz_throw(\"outofmem: cmap table\");\n\t\tcmap->tcap = cmap->tlen;\n\t\tcmap->table = newtable;\n\t}\n\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Add a range of contiguous one-to-one mappings (ie 1..5 maps to 21..25)\n */\n", "func_signal": "fz_error *\npdf_maprangetorange(pdf_cmap *cmap, int low, int high, int offset)", "code": "{\n\tfz_error *error;\n\terror = addrange(cmap, low, high, high - low == 0 ? SINGLE : RANGE, offset);\n\tif (error)\n\t\treturn fz_rethrow(error, \"cannot add range-to-range mapping\");\n\treturn fz_okay;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/*\n * Use the codespace ranges to extract a codepoint from a\n * multi-byte encoded string.\n */\n", "func_signal": "unsigned char *\npdf_decodecmap(pdf_cmap *cmap, unsigned char *buf, int *cpt)", "code": "{\n\tint i, k;\n\n\tfor (k = 0; k < cmap->ncspace; k++)\n\t{\n\t\tunsigned char *lo = cmap->cspace[k].lo;\n\t\tunsigned char *hi = cmap->cspace[k].hi;\n\t\tint n = cmap->cspace[k].n;\n\t\tint c = 0;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (lo[i] <= buf[i] && buf[i] <= hi[i])\n\t\t\t\tc = (c << 8) | buf[i];\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == n) {\n\t\t\t*cpt = c;\n\t\t\treturn buf + n;\n\t\t}\n\t}\n\n\t*cpt = 0;\n\treturn buf + 1;\n}", "path": "mupdf\\pdf_cmap.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "/* Appends src to string dst of size siz (unlike strncat, siz is the\n * full size of dst, not space left). At most siz-1 characters\n * will be copied.  Always NUL terminates (unless siz == 0).\n * Returns strlen(src); if retval >= siz, truncation occurred.\n */\n", "func_signal": "int strlcat(char *dst, const char *src, int siz)", "code": "{\n\tregister char *d = dst;\n\tregister const char *s = src;\n\tregister int n = siz;\n\tint dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (*d != '\\0' && n-- != 0)\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn dlen + strlen(s);\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn dlen + (s - src);\t/* count does not include NUL */\n}", "path": "base\\util_strlcpy.c", "repo_name": "lgchmomo/mupdf", "stars": 4, "license": "gpl-2.0", "language": "c", "size": 2432}
{"docstring": "//Directory functs\n", "func_signal": "DIR_ITER* nitroFSDirOpen(struct _reent *r, DIR_ITER *dirState, const char *path)", "code": "{\n\tstruct nitroDIRStruct *dirStruct=(struct nitroDIRStruct*)dirState->dirStruct; //this makes it lots easier!\n\tstruct stat st;\n\tchar dirname[NITRONAMELENMAX];\n\tchar *cptr;\n\tchar mydirpath[NITROMAXPATHLEN];\t//to hold copy of path string\n\tchar *dirpath=mydirpath;\n\tbool pathfound;\n\tif((cptr=strchr(path,':'))) \n\t\tpath=cptr+1;\t//move path past any device names (if it was nixy style wouldnt need this step >_>)\n\tstrncpy(dirpath,path,sizeof(mydirpath)-1);\t//copy the string (as im gonna mutalate it)\n\tdirStruct->pos=0;\n\tif(*dirpath=='/')\t\t\t\t//if first character is '/' use absolute root path plz\n\t\tdirStruct->cur_dir_id=NITROROOT;\t//first root dir\n\telse\n\t\tdirStruct->cur_dir_id=chdirpathid;\t//else use chdirpath\n\tnitroDirReset(r,dirState);\t\t\t//set dir to current path\n\tdo {\n\t\twhile((cptr=strchr(dirpath,'/'))==dirpath) {\n\t\t\tdirpath++;\t//move past any leading / or // together\n\t\t}\n\t\tif(cptr)\n\t\t\t*cptr=0;\t//erase /\n\t\tif(*dirpath==0) {//are we at the end of the path string?? if so there is nothing to search for we're already here !\n\t\t\tpathfound=true; //mostly this handles searches for root or /  or no path specified cases \n\t\t\tbreak;\n\t\t}\n\t\tpathfound=false;\n\t\twhile(nitroFSDirNext(r,dirState,dirname,&st)==0) {\t\n\t\t\tif((st.st_mode==S_IFDIR) && !(strcmp(dirname,dirpath))) { //if its a directory and name matches dirpath\n\t\t\t\tdirStruct->cur_dir_id=dirStruct->dir_id;  //move us to the next dir in tree\n\t\t\t\tnitroDirReset(r,dirState);\t\t//set dir to current path we just found...\n\t\t\t\tpathfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif(!pathfound) \n\t\t\tbreak;\n\t\tdirpath=cptr+1;\t//move to right after last / we found\n\t} while(cptr); // go till after the last /\n\tif(pathfound) {\n\t\treturn(dirState);\n\t} else {\n\t\treturn(NULL);\n\t}\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// check if the file is the good one, and save the path if desired\n", "func_signal": "bool CheckFile(char *path, bool save)", "code": "{\n    bool ok = false;\n    char ext[7], *ext2 = ext + 2;\n    int i, f;\n    u32 size;\n    \n    // check file extension\n    strcpy(ext, path + strlen(path) - 6);\n    for(i=0; i<7; ++i)\n        ext[i] = tolower(ext[i]);\n    \n    if(!strcmp(ext2, \".nds\") || !strcmp(ext2, \".bin\") || !strcmp(ext, \"ds.gba\")) {\n        if((f = open(path, O_RDWR))) {\n            // check file size\n            size = lseek(f, 0, SEEK_END);\n        \n            if(size == efs_filesize) {\n                bool found = false;\n                char dataChunk[EFS_READBUFFERSIZE];\n                char magicString[12] = \"\";\n                int dataChunk_size, efs_offset = 0;\n                \n                // rebuild magic string\n                strcat(magicString, efsMagicStringP1);\n                strcat(magicString, efsMagicStringP2);\n                \n                // search for magic string\n                lseek(f, 0, SEEK_SET);\n                while(efs_offset<size && !found) {\n                    dataChunk_size = read(f, dataChunk, EFS_READBUFFERSIZE);\n                    \n                    for(i=0; i < dataChunk_size; i++) {\n                        if(dataChunk[i] == magicString[0]) {\n                            if(dataChunk_size-i < 12) {\n                                break;\n                            }\n                            if(memcmp(&dataChunk[i], magicString, 12) == 0) {\n                                found = true;\n                                efs_offset += i;\n                                break;\n                            }\n                        }\n                    }\n                    if(!found) {\n                        efs_offset += dataChunk_size;\n                    }\n                }\n    \n                // check file id\n                if(found == true && (*(int*)(dataChunk+i+12) == efs_id)) {\n                    strcpy(efs_path, path);\n                    // store file path in NDS\n                    if(save) {\n                        // reopening of the file is needed to prevent an offset bug in some DLDI drivers\n                        close(f);\n                        f = open(path, O_RDWR);\n\n                        // correct offset as neoflash DLDI driver has some issues (we know it's word-aligned)\n                        if((efs_offset & 3) < 2)\n                            efs_offset = efs_offset - (efs_offset & 3);\n                        else\n                            efs_offset = efs_offset + 4 - (efs_offset & 3);\n\n                        lseek(f, efs_offset+20, SEEK_SET);\n                        write(f, path, 256);\n                    }\n                    ok = true;\n                }\n            }\n        }\n        close(f);\n    }\n\n    return ok;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// read data from file\n", "func_signal": "int EFS_Read(struct _reent *r, int fd, char *ptr, int len)", "code": "{\n    EFS_FileStruct *file = (EFS_FileStruct*)fd; \n\n    if(file->pos+len > file->end) \n        len = file->end - file->pos;    // don't read past the end of the file\n    if(file->pos > file->end)\n        return 0;   // EOF\n    \n    if (useDLDI) {    \n        // seek to right position and read data\n        lseek(nds_file, file->pos, SEEK_SET);\n        len = read(nds_file, ptr, len);\n    } else {    \n        memcpy(ptr, file->pos + (void*)GBAROM, len);\n    }\n    if (len > 0)\n        file->pos += len;        \n        \n    return len;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/*-----------------------------------------------------------------\nFAT_InitFiles\nReads the FAT information from the CF card.\nYou need to call this before reading any files.\nbool return OUT: true if successful.\n-----------------------------------------------------------------*/\n", "func_signal": "bool FAT_InitFiles (bool initCard)", "code": "{\n\tint i;\n\tint bootSector;\n\tBOOT_SEC* bootSec;\n\t\n\tif (initCard && !CARD_StartUp())\n\t{\n\t\treturn (false);\n\t}\n\t\n\t// Read first sector of card\n\tif (!CARD_ReadSector (0, globalBuffer)) \n\t{\n\t\treturn false;\n\t}\n\t// Check if there is a FAT string, which indicates this is a boot sector\n\tif ((globalBuffer[0x36] == 'F') && (globalBuffer[0x37] == 'A') && (globalBuffer[0x38] == 'T'))\n\t{\n\t\tbootSector = 0;\n\t}\n\t// Check for FAT32\n\telse if ((globalBuffer[0x52] == 'F') && (globalBuffer[0x53] == 'A') && (globalBuffer[0x54] == 'T'))\n\t{\n\t\tbootSector = 0;\n\t}\n\telse\t// This is an MBR\n\t{\n\t\t// Find first valid partition from MBR\n\t\t// First check for an active partition\n\t\tfor (i=0x1BE; (i < 0x1FE) && (globalBuffer[i] != 0x80); i+= 0x10);\n\t\t// If it didn't find an active partition, search for any valid partition\n\t\tif (i == 0x1FE) \n\t\t\tfor (i=0x1BE; (i < 0x1FE) && (globalBuffer[i+0x04] == 0x00); i+= 0x10);\n\t\t\n\t\t// Go to first valid partition\n\t\tif ( i != 0x1FE)\t// Make sure it found a partition\n\t\t{\n\t\t\tbootSector = globalBuffer[0x8 + i] + (globalBuffer[0x9 + i] << 8) + (globalBuffer[0xA + i] << 16) + ((globalBuffer[0xB + i] << 24) & 0x0F);\n\t\t} else {\n\t\t\tbootSector = 0;\t// No partition found, assume this is a MBR free disk\n\t\t}\n\t}\n\n\t// Read in boot sector\n\tbootSec = (BOOT_SEC*) globalBuffer;\n\tCARD_ReadSector (bootSector,  bootSec);\n\t\n\t// Store required information about the file system\n\tif (bootSec->sectorsPerFAT != 0)\n\t{\n\t\tdiscSecPerFAT = bootSec->sectorsPerFAT;\n\t}\n\telse\n\t{\n\t\tdiscSecPerFAT = bootSec->extBlock.fat32.sectorsPerFAT32;\n\t}\n\t\n\tif (bootSec->numSectorsSmall != 0)\n\t{\n\t\tdiscNumSec = bootSec->numSectorsSmall;\n\t}\n\telse\n\t{\n\t\tdiscNumSec = bootSec->numSectors;\n\t}\n\n\tdiscBytePerSec = BYTES_PER_SECTOR;\t// Sector size is redefined to be 512 bytes\n\tdiscSecPerClus = bootSec->sectorsPerCluster * bootSec->bytesPerSector / BYTES_PER_SECTOR;\n\tdiscBytePerClus = discBytePerSec * discSecPerClus;\n\tdiscFAT = bootSector + bootSec->reservedSectors;\n\n\tdiscRootDir = discFAT + (bootSec->numFATs * discSecPerFAT);\n\tdiscData = discRootDir + ((bootSec->rootEntries * sizeof(DIR_ENT)) / BYTES_PER_SECTOR);\n\n\tif ((discNumSec - discData) / bootSec->sectorsPerCluster < 4085)\n\t{\n\t\tdiscFileSystem = FS_FAT12;\n\t}\n\telse if ((discNumSec - discData) / bootSec->sectorsPerCluster < 65525)\n\t{\n\t\tdiscFileSystem = FS_FAT16;\n\t}\n\telse\n\t{\n\t\tdiscFileSystem = FS_FAT32;\n\t}\n\n\tif (discFileSystem != FS_FAT32)\n\t{\n\t\tdiscRootDirClus = FAT16_ROOT_DIR_CLUSTER;\n\t}\n\telse\t// Set up for the FAT32 way\n\t{\n\t\tdiscRootDirClus = bootSec->extBlock.fat32.rootClus;\n\t\t// Check if FAT mirroring is enabled\n\t\tif (!(bootSec->extBlock.fat32.extFlags & 0x80))\n\t\t{\n\t\t\t// Use the active FAT\n\t\t\tdiscFAT = discFAT + ( discSecPerFAT * (bootSec->extBlock.fat32.extFlags & 0x0F));\n\t\t}\n\t}\n\n\treturn (true);\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\fat.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//fs functs\n", "func_signal": "int nitroFSOpen(struct _reent *r, void *fileStruct, const char *path,int flags,int mode)", "code": "{\n\tstruct nitroFSStruct *fatStruct=(struct nitroFSStruct *)fileStruct;\n\tstruct nitroDIRStruct dirStruct;\n\tDIR_ITER dirState;\n\tdirState.dirStruct=&dirStruct;\t//create a temp dirstruct\n\tstruct _reent dre;\t\n\tstruct stat st;\t\t//all these are just used for reading the dir ~_~\n\tchar dirfilename[NITROMAXPATHLEN]; // to hold a full path (i tried to avoid using so much stack but blah :/)\n\tchar *filename; // to hold filename\n\tchar *cptr;\t//used to string searching and manipulation\n\tcptr=(char*)path+strlen(path);\t//find the end...\n\tfilename=NULL;\t\n\tdo {\n\t\tif((*cptr=='/') || (*cptr==':')) { // split at either / or : (whichever comes first form the end!)\n\t\t\tcptr++;\n\t\t\tstrncpy(dirfilename,path,cptr-path);\t//copy string up till and including/ or : zero rest\n\t\t\tdirfilename[cptr-path]=0;\t\t//it seems strncpy doesnt always zero?!\n\t\t\tfilename=cptr;\t//filename = now remainder of string\n\t\t\tbreak;\t\t\t\n\t\t}\n\t} while(cptr--!=path); //search till start\n\tif(!filename) { //we didnt find a / or : ? shouldnt realyl happen but if it does...\n\t\tfilename=(char*)path;\t//filename = complete path\n\t\tdirfilename[0]=0;\t//make directory path \"\"\n\t}\n\tif(nitroFSDirOpen(&dre,&dirState,dirfilename)) {\n\t\tfatStruct->start=0;\n\t\twhile(nitroFSDirNext(&dre,&dirState, dirfilename, &st)==0) {\n\t\t\tif(!(st.st_mode & S_IFDIR) && (strcmp(dirfilename,filename)==0)) { //Found the *file* youre looking for!!\n\t\t\t\tfatStruct->start=dirStruct.romfat.top;\n\t\t\t\tfatStruct->end=dirStruct.romfat.bottom;\n\t\t\t\tif(hasLoader) {\n\t\t\t\t\tfatStruct->start+=LOADEROFFSET;\n\t\t\t\t\tfatStruct->end+=LOADEROFFSET;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fatStruct->start) {\n\t\t\tnitroSubSeek(&fatStruct->pos,fatStruct->start,SEEK_SET);\t//seek to start of file\n\t\t\treturn(0);\t//woot!\n\t\t}\n\t\tnitroFSDirClose(&dre,&dirState);\n\t}\n\treturn(-1);\t//teh fail\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/*-------------------------------------------------------------------------\nresetMemory_ARM7\nClears all of the NDS's RAM that is visible to the ARM7\nWritten by Darkain.\nModified by Chishm:\n * Added STMIA clear mem loop\n--------------------------------------------------------------------------*/\n", "func_signal": "void resetMemory_ARM7 (void)", "code": "{\n\tint i;\n\tu8 settings1, settings2;\n\tu32 settingsOffset = 0;\n\t\n\tREG_IME = 0;\n\n\tfor (i=0; i<16; i++) {\n\t\tSCHANNEL_CR(i) = 0;\n\t\tSCHANNEL_TIMER(i) = 0;\n\t\tSCHANNEL_SOURCE(i) = 0;\n\t\tSCHANNEL_LENGTH(i) = 0;\n\t}\n\tSOUND_CR = 0;\n\n\t//clear out ARM7 DMA channels and timers\n\tfor (i=0; i<4; i++) {\n\t\tDMA_CR(i) = 0;\n\t\tDMA_SRC(i) = 0;\n\t\tDMA_DEST(i) = 0;\n\t\tTIMER_CR(i) = 0;\n\t\tTIMER_DATA(i) = 0;\n\t}\n\n\t//switch to user mode\n  __asm volatile(\n\t\"mov r6, #0x1F                \\n\"\n\t\"msr cpsr, r6                 \\n\"\n\t:\n\t:\n\t: \"r6\"\n\t);\n\n  __asm volatile (\n\t// clear exclusive IWRAM\n\t// 0380:0000 to 0380:FFFF, total 64KiB\n\t\"mov r0, #0 \t\t\t\t\\n\"\t\n\t\"mov r1, #0 \t\t\t\t\\n\"\n\t\"mov r2, #0 \t\t\t\t\\n\"\n\t\"mov r3, #0 \t\t\t\t\\n\"\n\t\"mov r4, #0 \t\t\t\t\\n\"\n\t\"mov r5, #0 \t\t\t\t\\n\"\n\t\"mov r6, #0 \t\t\t\t\\n\"\n\t\"mov r7, #0 \t\t\t\t\\n\"\n\t\"mov r8, #0x03800000\t\t\\n\"\t// Start address part 1\n\t\"sub r8, #0x00008000\t\t\\n\" // Start address part 2\n\t\"mov r9, #0x03800000\t\t\\n\" // End address part 1\n\t\"orr r9, r9, #0x10000\t\t\\n\" // End address part 2\n\t\"clear_EIWRAM_loop:\t\t\t\\n\"\n\t\"stmia r8!, {r0, r1, r2, r3, r4, r5, r6, r7} \\n\"\n\t\"cmp r8, r9\t\t\t\t\t\\n\"\n\t\"blt clear_EIWRAM_loop\t\t\\n\"\n\n\t// clear most of EWRAM - except after 0x023FFE00, which has the ARM9 loop\n\t\"mov r8, #0x02000000\t\t\\n\"\t// Start address\n\t\"mov r9, #0x02400000\t\t\\n\" // End address part 1\n\t\"sub r9, #0x00000200\t\t\\n\" // End address part 2\n\t\"clear_EXRAM_loop:\t\t\t\\n\"\n\t\"stmia r8!, {r0, r1, r2, r3, r4, r5, r6, r7} \\n\"\n\t\"cmp r8, r9\t\t\t\t\t\\n\"\n\t\"blt clear_EXRAM_loop\t\t\\n\"\n\t:\n\t:\n\t: \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\"\n\t);\n  \n\tREG_IE = 0;\n\tREG_IF = ~0;\n\t(*(vu32*)(0x04000000-4)) = 0;  //IRQ_HANDLER ARM7 version\n\t(*(vu32*)(0x04000000-8)) = ~0; //VBLANK_INTR_WAIT_FLAGS, ARM7 version\n\tREG_POWERCNT = 1;  //turn off power to stuffs\n\t\n\t// Get settings location\n\tboot_readFirmware((u32)0x00020, (u8*)&settingsOffset, 0x2);\n\tsettingsOffset *= 8;\n\t\n\t// Reload DS Firmware settings\n\tboot_readFirmware(settingsOffset + 0x070, &settings1, 0x1);\n\tboot_readFirmware(settingsOffset + 0x170, &settings2, 0x1);\n\t\n\tif ((settings1 & 0x7F) == ((settings2+1) & 0x7F)) {\n\t\tboot_readFirmware(settingsOffset + 0x000, (u8*)0x027FFC80, 0x70);\n\t} else {\n\t\tboot_readFirmware(settingsOffset + 0x100, (u8*)0x027FFC80, 0x70);\n\t}\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\boot.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//reads from rom image either gba rom or dldi\n", "func_signal": "inline int nitroSubRead(unsigned int *npos, void *ptr, int len)", "code": "{\n\tif(ndsFile!=NULL) { //read from ndsfile\n\t\tif(ndsFileLastpos!=*npos)\n\t\t\tfseek(ndsFile, *npos, SEEK_SET); //if we need to, move! (might want to verify this succeed)\n\t\tlen=fread(ptr,1,len,ndsFile);\n\t} else {\t//reading from gbarom\n\t\tmemcpy(ptr, *npos+(void*)GBAROM,len); //len isnt checked here because other checks exist in the callers (hopefully)\n\t}\n\tif(len > 0)\n\t\t*npos+=len;\n\tndsFileLastpos=*npos;\t//save the current file nds pos\n\treturn(len);\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//seek around\n", "func_signal": "inline void nitroSubSeek(unsigned int *npos, int pos, int dir)", "code": "{\n\tif((dir==SEEK_SET)||(dir==SEEK_END)) \t//otherwise just set the pos :)\n\t\t*npos=pos;\n\telse if(dir==SEEK_CUR) \n\t\t*npos+=pos;\t//see ez!\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// go back to the beginning of the directory\n", "func_signal": "int EFS_DirReset(struct _reent *r, DIR_ITER *dirState)", "code": "{\n    EFS_DirStruct *dir = (EFS_DirStruct*)dirState->dirStruct;    \n\n    if(useDLDI) {\n        lseek(nds_file, fnt_offset + 8*(dir->dir_id & 0xFFF) + 4, SEEK_SET);\n        read(nds_file, &dir->curr_file_id, sizeof(dir->curr_file_id));\n    } else {\n        memcpy(&dir->curr_file_id, fnt_offset + 8*(dir->dir_id & 0xFFF) + 4 + (void*)GBAROM, sizeof(dir->curr_file_id));\n    }\n    dir->pos = ~1;\n    return 0;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// get some info on a file\n", "func_signal": "int EFS_Fstat(struct _reent *r, int fd, struct stat *st)", "code": "{\n    EFS_FileStruct *file = (EFS_FileStruct*)fd;\n    st->st_size = file->end - file->start;\n    // maybe add some other info?\n    return 0;    \n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//reset dir to start of entry selected by dirStruct->cur_dir_id which should be set in dirOpen okai?!\n", "func_signal": "int nitroDirReset(struct _reent *r, DIR_ITER *dirState)", "code": "{\n\tstruct nitroDIRStruct *dirStruct=(struct nitroDIRStruct*)dirState->dirStruct; //this makes it lots easier!\n\tstruct ROM_FNTDir dirsubtable;\n\tunsigned int *pos=&dirStruct->pos;\n\tnitroSubSeek(pos,fntOffset+((dirStruct->cur_dir_id&NITRODIRMASK)*sizeof(struct ROM_FNTDir)),SEEK_SET);\n\tnitroSubRead(pos, &dirsubtable, sizeof(dirsubtable));\n\tdirStruct->namepos=dirsubtable.entry_start;\t//set namepos to first entry in this dir's table\n\tdirStruct->entry_id=dirsubtable.entry_file_id;\t//get number of first file ID in this branch\n\tdirStruct->parent_id=dirsubtable.parent_id;\t//save parent ID in case we wanna add ../ functionality\n\tdirStruct->spc=0;\t\t\t\t//system path counter, first two dirnext's deliver . and ..\n\treturn(0);\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// open a file\n", "func_signal": "int EFS_Open(struct _reent *r, void *fileStruct, const char *path, int flags, int mode)", "code": "{\n    EFS_FileStruct *file = (EFS_FileStruct*)fileStruct;\n\n    if(useDLDI && !nds_file)\n        return -1;\n        \n    // search for the file in NitroFS\n    filematch = false;\n    searchmode = EFS_SEARCHFILE;\n    file_idpos = 0;\n    file_idsize = 0;\n\n    // parse given path\n    parsePath(path, fileInNDS, false);\n    \n    // search into NitroFS\n    ExtractDirectory(\"/\", EFS_NITROROOTID);\n    \n    if(file_idpos) {\n        file->start = file_idpos;\n        file->pos = file_idpos;\n        file->end = file_idpos + file_idsize;        \n        return 0;\n    }\n  \n    return -1;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/*-----------------------------------------------------------------\nfileRead(buffer, cluster, startOffset, length)\n-----------------------------------------------------------------*/\n", "func_signal": "u32 fileRead (char* buffer, u32 cluster, u32 startOffset, u32 length)", "code": "{\n\tint curByte;\n\tint curSect;\n\t\n\tint dataPos = 0;\n\tint chunks;\n\tint beginBytes;\n\n\tif (cluster == CLUSTER_FREE || cluster == CLUSTER_EOF) \n\t{\n\t\treturn 0;\n\t}\n\t\n\t// Follow cluster list until desired one is found\n\tfor (chunks = startOffset / discBytePerClus; chunks > 0; chunks--)\n\t{\n\t\tcluster = FAT_NextCluster (cluster);\n\t}\n\t\n\t// Calculate the sector and byte of the current position,\n\t// and store them\n\tcurSect = (startOffset % discBytePerClus) / BYTES_PER_SECTOR;\n\tcurByte = startOffset % BYTES_PER_SECTOR;\n\n\t// Load sector buffer for new position in file\n\tCARD_ReadSector( curSect + FAT_ClustToSect(cluster), globalBuffer);\n\n\t// Number of bytes needed to read to align with a sector\n\tbeginBytes = (BYTES_PER_SECTOR < length + curByte ? (BYTES_PER_SECTOR - curByte) : length);\n\n\t// Read first part from buffer, to align with sector boundary\n\tfor (dataPos = 0 ; dataPos < beginBytes; dataPos++)\n\t{\n\t\tbuffer[dataPos] = globalBuffer[curByte++];\n\t}\n\n\t// Read in all the 512 byte chunks of the file directly, saving time\n\tfor ( chunks = ((int)length - beginBytes) / BYTES_PER_SECTOR; chunks > 0; chunks--)\n\t{\n\t\tcurSect++;\n\t\tif (curSect >= discSecPerClus)\n\t\t{\n\t\t\tcurSect = 0;\n\t\t\tcluster = FAT_NextCluster (cluster);\n\t\t}\n\n\t\tCARD_ReadSector( curSect + FAT_ClustToSect( cluster), buffer + dataPos);\n\t\tdataPos += BYTES_PER_SECTOR;\n\t}\n\n\t// Take care of any bytes left over before end of read\n\tif (dataPos < length)\n\t{\n\n\t\t// Update the read buffer\n\t\tcurSect++;\n\t\tcurByte = 0;\n\t\tif (curSect >= discSecPerClus)\n\t\t{\n\t\t\tcurSect = 0;\n\t\t\tcluster = FAT_NextCluster (cluster);\n\t\t}\n\t\tCARD_ReadSector( curSect + FAT_ClustToSect( cluster), globalBuffer);\n\t\t\n\t\t// Read in last partial chunk\n\t\tfor (; dataPos < length; dataPos++)\n\t\t{\n\t\t\tbuffer[dataPos] = globalBuffer[curByte];\n\t\t\tcurByte++;\n\t\t}\n\t}\n\t\n\treturn dataPos;\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\fat.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// close current file\n", "func_signal": "int EFS_Close(struct _reent *r, int fd)", "code": "{\n    // flush writes in the file system\n    if(useDLDI && hasWritten) {\n        if(nds_file)\n            close(nds_file);\n        nds_file = open(efs_path, O_RDWR);\n    }\n    return 0;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//Figure out if its gba or ds, setup stuff\n", "func_signal": "int nitroFSInit(const char *ndsfile)", "code": "{\n\tunsigned int pos=0;\n\tchar romstr[0x10];\n\tchdirpathid=NITROROOT;\n\tndsFileLastpos=0;\n\tndsFile=NULL;\n\tREG_EXMEMCNT &= ~ARM7_OWNS_CARD; //give us gba slot ownership\n\tif(strncmp(((const char *)GBAROM)+LOADERSTROFFSET,LOADERSTR,strlen(LOADERSTR))==0) {\t// We has gba rahm\n\t\tif(strncmp(((const char *)GBAROM)+LOADERSTROFFSET+LOADEROFFSET,LOADERSTR,strlen(LOADERSTR))==0) { //Look for second magic string, if found its a sc.nds or nds.gba\n\t\t\tfntOffset=((u32)*(u32*)(((const char *)GBAROM)+FNTOFFSET+LOADEROFFSET))+LOADEROFFSET;\t\n\t\t\tfatOffset=((u32)*(u32*)(((const char *)GBAROM)+FATOFFSET+LOADEROFFSET))+LOADEROFFSET;\n\t\t\thasLoader=true;\n\t\t\tAddDevice(&nitroFSdevoptab);\n\t\t\treturn(1);\n\t\t} else {\t//Ok, its not a .gba build, so must be emulator\n\t\t\tfntOffset=((u32)*(u32*)(((const char *)GBAROM)+FNTOFFSET));\t\n\t\t\tfatOffset=((u32)*(u32*)(((const char *)GBAROM)+FATOFFSET));\n\t\t\thasLoader=false;\n\t\t\tAddDevice(&nitroFSdevoptab);\n\t\t\treturn(1);\n\t\t}\n\t} else {\t//okay then try something else ~_~ (like dldi)\n\t\tif((ndsFile=fopen(ndsfile,\"rb\"))) {\n\t\t\tnitroSubRead(&pos,romstr,strlen(LOADERSTR));\n\t\t\tif(strncmp(romstr,LOADERSTR,strlen(LOADERSTR))==0) {\t\n\t\t\t\tnitroSubSeek(&pos,LOADEROFFSET+FNTOFFSET,SEEK_SET);\n\t\t\t\tnitroSubRead(&pos,&fntOffset,sizeof(fntOffset));\n\t\t\t\tnitroSubSeek(&pos,LOADEROFFSET+FATOFFSET,SEEK_SET);\n\t\t\t\tnitroSubRead(&pos,&fatOffset,sizeof(fatOffset));\n\t\t\t\tfatOffset+=LOADEROFFSET;\n\t\t\t\tfntOffset+=LOADEROFFSET;\n\t\t\t\thasLoader=true;\n\t\t\t} else {\n\t\t\t\tnitroSubSeek(&pos,FNTOFFSET,SEEK_SET);\n\t\t\t\tnitroSubRead(&pos,&fntOffset,sizeof(fntOffset));\n\t\t\t\tnitroSubSeek(&pos,FATOFFSET,SEEK_SET);\n\t\t\t\tnitroSubRead(&pos,&fatOffset,sizeof(fatOffset));\n\t\t\t\thasLoader=false;\n\t\t\t}\n\t\t\tsetvbuf(ndsFile,NULL,_IONBF,0);\t\t//we dont need double buffs u_u\n\t\t\tAddDevice(&nitroFSdevoptab);\n\t\t\treturn(1);\n\t\t} \n\t}\n\treturn(0);\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\nitrofs.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// write data to file (only works using DLDI)\n", "func_signal": "int EFS_Write(struct _reent *r, int fd, const char *ptr, int len)", "code": "{\n    EFS_FileStruct *file = (EFS_FileStruct*)fd; \n\n    if(file->pos+len > file->end) \n        len = file->end - file->pos;    // don't write past the end of the file\n    if(file->pos > file->end)\n        return 0;   // EOF\n    \n    if (useDLDI) {    \n        // seek to right position and write data\n        lseek(nds_file, file->pos, SEEK_SET);\n        len = write(nds_file, ptr, len);\n        if (len > 0)\n            file->pos += len;    \n        hasWritten = true;\n    } else {    \n        return 0;\n    }\n        \n    return len;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/*-----------------------------------------------------------------\nucase\nReturns the uppercase version of the given char\nchar IN: a character\nchar return OUT: uppercase version of character\n-----------------------------------------------------------------*/\n", "func_signal": "char ucase (char character)", "code": "{\n\tif ((character > 0x60) && (character < 0x7B))\n\t\tcharacter = character - 0x20;\n\treturn (character);\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\fat.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Main function\n", "func_signal": "int main (void)", "code": "{\n\tu32 fileCluster = storedFileCluster;\n\t// Init card\n\tif(!FAT_InitFiles(initDisc))\n\t{\n\t\treturn -1;\n\t}\n\tif ((fileCluster < CLUSTER_FIRST) || (fileCluster >= CLUSTER_EOF)) \t/* Invalid file cluster specified */\n\t{\n\t\tfileCluster = getBootFileCluster(bootName);\n\t}\n\tif (fileCluster == CLUSTER_FREE)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t// ARM9 clears its memory part 1\n\t// copy ARM9 function to RAM, and make the ARM9 jump to it\n\tcopyLoop((void*)TEMP_MEM, (void*)resetMemory1_ARM9, resetMemory1_ARM9_size);\n\t(*(vu32*)0x027FFE24) = (u32)TEMP_MEM;\t// Make ARM9 jump to the function\t\n\t// Wait until the ARM9 has completed its task\n\twhile ((*(vu32*)0x027FFE24) == (u32)TEMP_MEM);\n\n\t// ARM9 clears its memory part 2\n\t// copy ARM9 function to RAM, and make the ARM9 jump to it\n\tcopyLoop((void*)TEMP_MEM, (void*)resetMemory2_ARM9, resetMemory2_ARM9_size);\n\t(*(vu32*)0x027FFE24) = (u32)TEMP_MEM;\t// Make ARM9 jump to the function\n\t// Wait until the ARM9 has completed its task\n\twhile ((*(vu32*)0x027FFE24) == (u32)TEMP_MEM);\n\n\t// Get ARM7 to clear RAM\n\tresetMemory_ARM7();\t\n\t\n\t// ARM9 enters a wait loop\n\t// copy ARM9 function to RAM, and make the ARM9 jump to it\n\tcopyLoop((void*)TEMP_MEM, (void*)startBinary_ARM9, startBinary_ARM9_size);\n\t(*(vu32*)0x027FFE24) = (u32)TEMP_MEM;\t// Make ARM9 jump to the function\n\t\n\t// Load the NDS file\n\tloadBinary_ARM7(fileCluster);\n\t\n\t// Patch with DLDI if desired\n\tif (wantToPatchDLDI) {\n\t\tdldiPatchBinary ((u8*)((u32*)NDS_HEAD)[0x0A], ((u32*)NDS_HEAD)[0x0B]);\n\t}\n\t\n\tstartBinary_ARM7();\n\n\treturn 0;\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\boot.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/*-----------------------------------------------------------------\nFAT_NextCluster\nInternal function - gets the cluster linked from input cluster\n-----------------------------------------------------------------*/\n", "func_signal": "u32 FAT_NextCluster(u32 cluster)", "code": "{\n\tu32 nextCluster = CLUSTER_FREE;\n\tu32 sector;\n\tint offset;\n\t\n\t\n\tswitch (discFileSystem) \n\t{\n\t\tcase FS_UNKNOWN:\n\t\t\tnextCluster = CLUSTER_FREE;\n\t\t\tbreak;\n\t\t\t\n\t\tcase FS_FAT12:\n\t\t\tsector = discFAT + (((cluster * 3) / 2) / BYTES_PER_SECTOR);\n\t\t\toffset = ((cluster * 3) / 2) % BYTES_PER_SECTOR;\n\t\t\tCARD_ReadSector(sector, globalBuffer);\n\t\t\tnextCluster = ((u8*) globalBuffer)[offset];\n\t\t\toffset++;\n\t\t\t\n\t\t\tif (offset >= BYTES_PER_SECTOR) {\n\t\t\t\toffset = 0;\n\t\t\t\tsector++;\n\t\t\t}\n\t\t\t\n\t\t\tCARD_ReadSector(sector, globalBuffer);\n\t\t\tnextCluster |= (((u8*) globalBuffer)[offset]) << 8;\n\t\t\t\n\t\t\tif (cluster & 0x01) {\n\t\t\t\tnextCluster = nextCluster >> 4;\n\t\t\t} else \t{\n\t\t\t\tnextCluster &= 0x0FFF;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase FS_FAT16:\n\t\t\tsector = discFAT + ((cluster << 1) / BYTES_PER_SECTOR);\n\t\t\toffset = cluster % (BYTES_PER_SECTOR >> 1);\n\t\t\t\n\t\t\tCARD_ReadSector(sector, globalBuffer);\n\t\t\t// read the nextCluster value\n\t\t\tnextCluster = ((u16*)globalBuffer)[offset];\n\t\t\t\n\t\t\tif (nextCluster >= 0xFFF7)\n\t\t\t{\n\t\t\t\tnextCluster = CLUSTER_EOF;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FS_FAT32:\n\t\t\tsector = discFAT + ((cluster << 2) / BYTES_PER_SECTOR);\n\t\t\toffset = cluster % (BYTES_PER_SECTOR >> 2);\n\t\t\t\n\t\t\tCARD_ReadSector(sector, globalBuffer);\n\t\t\t// read the nextCluster value\n\t\t\tnextCluster = (((u32*)globalBuffer)[offset]) & 0x0FFFFFFF;\n\t\t\t\n\t\t\tif (nextCluster >= 0x0FFFFFF7)\n\t\t\t{\n\t\t\t\tnextCluster = CLUSTER_EOF;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tnextCluster = CLUSTER_FREE;\n\t\t\tbreak;\n\t}\n\t\n\treturn nextCluster;\n}", "path": "loader_tests\\NDS_loader\\BootLoader\\source\\fat.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "// search in directory for the NDS file\n", "func_signal": "bool SearchDirectory()", "code": "{\n    DIR_ITER *dir;\n    bool found = false;\n    char path[EFS_MAXPATHLEN];\n    char filename[EFS_MAXPATHLEN];\n    struct stat st; \n \n    dir = diropen(\".\");\n    while((dirnext(dir, filename, &st) == 0) && (!found)) {\n        if(st.st_mode & S_IFDIR) {\n            if(((strlen(filename) == 1) && (filename[0]!= '.')) ||\n                ((strlen(filename) == 2) && (strcasecmp(filename, \"..\")))  ||\n                (strlen(filename) > 2))\n            {\n                chdir(filename);\n                found = SearchDirectory();\n                chdir(\"..\");\n            }\n        } else {\n            getcwd(path, EFS_MAXPATHLEN-1);\n            strcat(path, filename);\n        \n            if(CheckFile(path, true)) {\n                found = true;\n                break;\n            }\n        }\n    }\n    dirclose(dir);\n    \n    return found;\n}", "path": "loader_tests\\TouchTest\\src\\arm9\\efs_lib.c", "repo_name": "kusma/nds", "stars": 6, "license": "None", "language": "c", "size": 6092}
{"docstring": "/**\n * You can use this function to make the beeper beep ;) \n * But this function should not be used as it does not\n * generate a delay for the sound and a delay between \n * two sounds. Better is to use the \"sound\" macro, which\n * uses this function and adds the required delays.\n *\n * \"sound(pitch,time,delay)\"\n *\n * 0 = lowest frequency\n * 255 = highest frequency\n *\n * Example:\n * sound(150,50,25);\n * sound(200,50,25);\n *\n * Of course the function \"beep\" is nice to generate\n * sounds when you need to do other things at the same\n * time... \n */\n", "func_signal": "void beep(uint8_t pitch, uint16_t time)", "code": "{\n\tcontrolStatus.beep = true;\n\tsound_timer = time;\n\tOCR2 = 255-pitch;\n\tTCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Writes a string with specified length and offset from SRAM to the LCD.\n * If it is a null terminated string, output will be stopped at the\n * end. It does not need to be null terminated, but it is recommended\n * to use only null terminated strings/buffers, otherwise the function could\n * output any SRAM memory data stored after the string until it reaches a 0\n * or the specified length!\n *\n * Example:\n *\n *\t\t\twriteStringLength(\"RP6 Robot Sytem\",16,0);\n *\t\t\t// would output: \"RP6 Robot Sytem\\n\"\n *\t\t\twriteStringLength(\"RP6 Robot Sytem\",11,4);\n *\t\t\t// would output: \"Robot System\"\n * \t\t\twriteStringLength(\"RP6 Robot Sytem\",40,4);\n *\t\t\t// would output: \"Robot System\"\n *\t\t\t// No matter if the specified length is 40 characters!\n *\n */\n", "func_signal": "void writeStringLengthLCD(char *string, uint8_t length, uint8_t offset)", "code": "{\n\tfor(string = &string[offset]; *string && length; length--)\n\t\twriteCharLCD(*string++);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/** \n * Reads \"length\" Bytes from SPI Interface into the buffer.\n */\n", "func_signal": "void readBufferSPI(uint8_t *buffer, uint8_t length)", "code": "{\n\tuint8_t i = 0;\n\tfor(; i < length; i++) {\n\t\tSPDR = 0xFF;    \n\t\twhile(!(SPSR & (1<<SPIF)));\n\t\tbuffer[i] = SPDR;\n\t}\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Writes a String from SRAM to the LCD.\n */\n", "func_signal": "void writeStringLCD(char *string)", "code": "{\n\twhile(*string)\n\t\twriteCharLCD(*string++);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Write a number (with specified base) to the LCD.\n *\n * Example:\n *\n *\t\t\t// Write a hexadecimal number to the LCD:\n *\t\t\twriteInteger(0xAACC,16);\n *\t\t\t// Instead of 16 you can also write \"HEX\" as this is defined in the\n *\t\t\t// RP6RobotBaseLib.h :\n *\t\t\twriteInteger(0xAACC, HEX);\n *\t\t\t// Other Formats:\n *\t\t\twriteInteger(1024,DEC);  \t// Decimal\n *\t\t\twriteInteger(511,OCT);\t\t// Ocal\n *\t\t\twriteInteger(0b11010111,BIN); // Binary\n */\n", "func_signal": "void writeIntegerLCD(int16_t number, uint8_t base)", "code": "{\n\titoa(number, &lcd_tmp_buffer[0], base);\n\twriteStringLCD(&lcd_tmp_buffer[0]);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Delay with the help of the 10kHz timer.\n * sleep(10) delays for *about* 1ms! Not exaclty, as we do not use assembly routines\n * anywhere in this library!\n *\n * This is a blocking routine, which means that the processor\n * will loop in this routine and (except for interrupts) the\n * normal program flow is stopped!\n * Thus you should use the Stopwatch functions wherever you can!\n *\n * Example:\n *\t\tsleep(1); // delay 1 * 100us = 100us = 0.1ms\n *\t\tsleep(10); // delay 10 * 100us = 1000us = 1ms\n *\t\tsleep(100); // delay 100 * 100us = 10000us = 10ms\n *\t\t// The maximum delay is:\n *\t\tsleep(255); // delay 255 * 100us = 25500us = 25.5ms\n */\n", "func_signal": "void sleep(uint8_t time)", "code": "{\n\tdelay_timer = 0;\n\twhile (delay_timer <= time+1);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Write a single character to the LCD.\n *\n * Example:\n *\n *\t\t\twriteCharLCD('R');\n *\t\t\twriteCharLCD('P');\n *\t\t\twriteCharLCD('6');\n *\t\t\twriteCharLCD(' ');\n *\t\t\twriteCharLCD('0');\n *\t\t\twriteCharLCD(48); // 48 is ASCII code for '0'\n *\t\t\twriteCharLCD(49); // '1'\n *\t\t\twriteCharLCD(50); // '2'\n *\t\t\twriteCharLCD(51); // '3'\n *\t\t\t//...\n *\n *\t\t\twould output:\n *\t\t\tRP6 00123\n *\t\t\tat the current cursor position!\n *\t\t\tuse setCursorPos function to move the cursor to a \n *\t\t\tdifferent location!\n */\n", "func_signal": "void writeCharLCD(uint8_t ch)", "code": "{\n\tPORTB |= LCD_RS;\n\twrite4BitLCDData(ch);\n\tdelayCycles(50);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Writes two Bytes contained in the 16 Bit parameter \"data\".\n * The first byte to be written needs to be in the upper 8 Bits.\n */\n", "func_signal": "void writeWordSPI(uint16_t data)", "code": "{\n\twriteSPI((uint8_t)(data >> 8));\n\twriteSPI((uint8_t)data);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Reads a single Byte from the external EEPROM.\n */\n", "func_signal": "uint8_t SPI_EEPROM_readByte(uint16_t memAddr)", "code": "{\n\tuint8_t data;\n\tPORTB &= ~MEM_CS;\n\twriteSPI(SPI_EEPROM_READ);\n\twriteWordSPI(memAddr);\n\tdata = readSPI();\n\tPORTB |= MEM_CS;\n\treturn data;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Clears the whole LCD!\n */\n", "func_signal": "void clearLCD(void)", "code": "{\n\twriteLCDCommand(0b00000001);\n\tdelayCycles(5500);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Reads a single Databyte from the SPI Interface.\n */\n", "func_signal": "uint8_t readSPI(void)", "code": "{\n\twriteSPI(0xFF);\n\treturn SPDR;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Same as writeInteger, but with defined length.\n * This means this routine will add leading zeros to the number if length is\n * larger than the actual value or cut the upper digits if length is smaller\n * than the actual value.\n *\n * Example:\n *\n *\t\t\t// Write a hexadecimal number to the LCD:\n *\t\t\twriteIntegerLength(0xAACC, 16, 8);\n *\t\t\t// Instead of 16 you can also write \"HEX\" as this is defined in the\n *\t\t\t// RP6ControlLib.h :\n *\t\t\twriteIntegerLength(0xAACC, HEX, 8);\n *\t\t\t// Other Formats:\n *\t\t\twriteIntegerLength(1024,DEC,6);  \t// Decimal\n *\t\t\twriteIntegerLength(511,OCT,4);\t\t// Ocal\n *\t\t\twriteIntegerLength(0b11010111,BIN,8); // Binary\n */\n", "func_signal": "void writeIntegerLengthLCD(int16_t number, uint8_t base, uint8_t length)", "code": "{\n\tchar buffer[17];\n\titoa(number, &buffer[0], base);\n\tint8_t cnt = length - strlen(buffer);\n\tif(cnt > 0) {\n\t\tfor(; cnt > 0; cnt--, writeCharLCD('0'));\n\t\twriteStringLCD(&buffer[0]);\n\t}\n\telse \n\t\twriteStringLengthLCD(&buffer[0],length,-cnt);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Returns EEPROM Status register - for checking if EEPROM is buisy. \n * Writing takes about 5ms. \n */\n", "func_signal": "uint8_t SPI_EEPROM_getStatus(void)", "code": "{\n\tuint8_t status;\n\tPORTB &= ~MEM_CS;\n\twriteSPI(SPI_EEPROM_RDSR);\n\tstatus = readSPI();\n\tPORTB |= MEM_CS;\n\treturn status;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Clears some characters after the given position.\n */\n", "func_signal": "void clearPosLCD(uint8_t line, uint8_t pos, uint8_t length)", "code": "{\n\tsetCursorPosLCD(line,pos);\n\twhile(length--)\n\t\twriteCharLCD(' ');\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Write \"length\" Bytes from the Buffer to the EEPROM. \n * YOU CAN ONLY WRITE MAXIMAL 64 BYTES AT ONCE!!! This is the Pagesize!\n * You can NOT cross a page boundary! For example when you write 20 Bytes \n * starting at address 54, you will not write up to Byte address 74, but\n * instead only up to 63 and then it continues at Byte 0 and writes \n * the rest up to Byte 10!\n *\n */\n", "func_signal": "void SPI_EEPROM_writeBytes(uint16_t startAddr, uint8_t *buffer, uint8_t length)", "code": "{\n\twhile(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);\n\tSPI_EEPROM_enableWrite();\n\tPORTB &= ~MEM_CS;\n\twriteSPI(SPI_EEPROM_WRITE);\n\twriteWordSPI(startAddr);\n\twriteBufferSPI(&buffer[0], length);\n\tPORTB |= MEM_CS;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * This function has no timing stuff, but otherwise\n * it has the same effect as \"beep\". It only sets the pitch\n * and this can be used to generate tone sequences which\n * would sound bad if the beeper turns of for a very short time\n * in between - such as alarm tones or special melodies etc. \n */\n", "func_signal": "void setBeeperPitch(uint8_t pitch)", "code": "{\n\tcontrolStatus.beep = false;\n\tOCR2 = 255-pitch;\n\tif(pitch) \n\t\tTCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);\t\n\telse \n\t\tTCCR2 = 0;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Write a 8bit-byte in two nibbles of 4bit to the LCD.\n */\n", "func_signal": "void write4BitLCDData(uint8_t data)", "code": "{\n\tsetLCDD(data >> 4);\n\tsetLCDD(data);\n\tdelayCycles(150);\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Reads the Microphone peak detector and discharges it afterwards.\n * \n */\n", "func_signal": "uint16_t getMicrophonePeak(void)", "code": "{\n\tuint16_t tmp;\n\ttmp = readADC(ADC_MIC);\n\tif(tmp > 4) \n\t\tdischargePeakDetector();\n\treturn tmp;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/** \n * This function discharges the Capacitor of the peak detection circuit \n * used for the Microphone. This is required to remove any previous\n * charge from the capacitor. \n */\n", "func_signal": "void dischargePeakDetector(void)", "code": "{\n\tDDRA |= MIC;\n\tPORTA &= ~MIC;\n\tmSleep(1);\n\tDDRA &= ~MIC;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/**\n * Reads TWO Bytes from the SPI Interface and returns them as\n * a 16 Bit value with first byte read in the upper 8 bits.\n */\n", "func_signal": "uint16_t readWordSPI(void)", "code": "{\n\tuint16_t data = 0;\n\tdata = readSPI() << 8;\n\tdata |= readSPI();\n\treturn data;\n}", "path": "library\\RP6control\\RP6ControlLib.c", "repo_name": "kokx/fhict-proftaak4", "stars": 5, "license": "None", "language": "c", "size": 238}
{"docstring": "/* ngx_sort() is implemented as insertion sort because we need stable sort */\n", "func_signal": "void\nngx_sort(void *base, size_t n, size_t size,\n    ngx_int_t (*cmp)(const void *, const void *))", "code": "{\n    u_char  *p1, *p2, *p;\n\n    p = ngx_alloc(size, ngx_cycle->log);\n    if (p == NULL) {\n        return;\n    }\n\n    for (p1 = (u_char *) base + size;\n         p1 < (u_char *) base + n * size;\n         p1 += size)\n    {\n        ngx_memcpy(p, p1, size);\n\n        for (p2 = p1;\n             p2 > (u_char *) base && cmp(p2 - size, p) > 0;\n             p2 -= size)\n        {\n            ngx_memcpy(p2, p2 - size, size);\n        }\n\n        ngx_memcpy(p2, p, size);\n    }\n\n    ngx_free(p);\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_string.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * we ignore any possible event setting error and\n * fallback to usual periodic file retests\n */\n", "func_signal": "static void\nngx_open_file_add_event(ngx_open_file_cache_t *cache,\n    ngx_cached_open_file_t *file, ngx_open_file_info_t *of, ngx_log_t *log)", "code": "{\n    ngx_open_file_cache_event_t  *fev;\n\n    if (!(ngx_event_flags & NGX_USE_VNODE_EVENT)\n        || !of->events\n        || file->event\n        || of->fd == NGX_INVALID_FILE\n        || file->uses < of->min_uses)\n    {\n        return;\n    }\n\n    file->use_event = 0;\n\n    file->event = ngx_calloc(sizeof(ngx_event_t), log);\n    if (file->event== NULL) {\n        return;\n    }\n\n    fev = ngx_alloc(sizeof(ngx_open_file_cache_event_t), log);\n    if (fev == NULL) {\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    fev->fd = of->fd;\n    fev->file = file;\n    fev->cache = cache;\n\n    file->event->handler = ngx_open_file_cache_remove;\n    file->event->data = fev;\n\n    /*\n     * although vnode event may be called while ngx_cycle->poll\n     * destruction, however, cleanup procedures are run before any\n     * memory freeing and events will be canceled.\n     */\n\n    file->event->log = ngx_cycle->log;\n\n    if (ngx_add_event(file->event, NGX_VNODE_EVENT, NGX_ONESHOT_EVENT)\n        != NGX_OK)\n    {\n        ngx_free(file->event->data);\n        ngx_free(file->event);\n        file->event = NULL;\n        return;\n    }\n\n    /*\n     * we do not set file->use_event here because there may be a race\n     * condition: a file may be deleted between opening the file and\n     * adding event, so we rely upon event notification only after\n     * one file revalidation on next file access\n     */\n\n    return;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_open_file_cache.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * the event timer rbtree may contain the duplicate keys, however,\n * it should not be a problem, because we use the rbtree to find\n * a minimum timer value only\n */\n", "func_signal": "ngx_int_t\nngx_event_timer_init(ngx_log_t *log)", "code": "{\n    ngx_rbtree_init(&ngx_event_timer_rbtree, &ngx_event_timer_sentinel,\n                    ngx_rbtree_insert_timer_value);\n\n#if (NGX_THREADS)\n\n    if (ngx_event_timer_mutex) {\n        ngx_event_timer_mutex->log = log;\n        return NGX_OK;\n    }\n\n    ngx_event_timer_mutex = ngx_mutex_init(log, 0);\n    if (ngx_event_timer_mutex == NULL) {\n        return NGX_ERROR;\n    }\n\n#endif\n\n    return NGX_OK;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\event\\ngx_event_timer.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* Linux strerror_r() */\n", "func_signal": "u_char *ngx_strerror_r(int err, u_char *errstr, size_t size)", "code": "{\n    char  *str;\n\n    if (size == 0) {\n        return 0;\n    }\n\n    errstr[0] = '\\0';\n\n    str = strerror_r(err, (char *) errstr, size);\n\n    if (str != (char *) errstr) {\n        return ngx_cpystrn(errstr, (u_char *) str, size);\n    }\n\n    while (*errstr && size) {\n        errstr++;\n        size--;\n    }\n\n    return errstr;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\os\\unix\\ngx_errno.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* AF_INET only */\n", "func_signal": "in_addr_t\nngx_inet_addr(u_char *text, size_t len)", "code": "{\n    u_char      *p, c;\n    in_addr_t    addr;\n    ngx_uint_t   octet, n;\n\n    addr = 0;\n    octet = 0;\n    n = 0;\n\n    for (p = text; p < text + len; p++) {\n\n        c = *p;\n\n        if (c >= '0' && c <= '9') {\n            octet = octet * 10 + (c - '0');\n            continue;\n        }\n\n        if (c == '.' && octet < 256) {\n            addr = (addr << 8) + octet;\n            octet = 0;\n            n++;\n            continue;\n        }\n\n        return INADDR_NONE;\n    }\n\n    if (n != 3) {\n        return INADDR_NONE;\n    }\n\n    if (octet < 256) {\n        addr = (addr << 8) + octet;\n        return htonl(addr);\n    }\n\n    return INADDR_NONE;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_inet.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* the copy input filter */\n", "func_signal": "ngx_int_t\nngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)", "code": "{\n    ngx_buf_t    *b;\n    ngx_chain_t  *cl;\n\n    if (buf->pos == buf->last) {\n        return NGX_OK;\n    }\n\n    if (p->free) {\n        cl = p->free;\n        b = cl->buf;\n        p->free = cl->next;\n        ngx_free_chain(p->pool, cl);\n\n    } else {\n        b = ngx_alloc_buf(p->pool);\n        if (b == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    ngx_memcpy(b, buf, sizeof(ngx_buf_t));\n    b->shadow = buf;\n    b->tag = p->tag;\n    b->last_shadow = 1;\n    b->recycled = 1;\n    buf->shadow = b;\n\n    cl = ngx_alloc_chain_link(p->pool);\n    if (cl == NULL) {\n        return NGX_ERROR;\n    }\n\n    cl->buf = b;\n    cl->next = NULL;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0, \"input buf #%d\", b->num);\n\n    if (p->in) {\n        *p->last_in = cl;\n    } else {\n        p->in = cl;\n    }\n    p->last_in = &cl->next;\n\n    return NGX_OK;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\event\\ngx_event_pipe.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* __amd64__ */\n", "func_signal": "static ngx_inline void\nngx_cpuid(uint32_t i, uint32_t *buf)", "code": "{\n    uint32_t  eax, ebx, ecx, edx;\n\n    __asm__ (\n\n        \"cpuid\"\n\n    : \"=a\" (eax), \"=b\" (ebx), \"=c\" (ecx), \"=d\" (edx) : \"a\" (i) );\n\n    buf[0] = eax;\n    buf[1] = ebx;\n    buf[2] = edx;\n    buf[3] = ecx;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_cpuinfo.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* auto detect the L2 cache line size of modern and widespread CPUs */\n", "func_signal": "void\nngx_cpuinfo(void)", "code": "{\n    u_char    *vendor;\n    uint32_t   vbuf[5], cpu[4];\n\n    vbuf[0] = 0;\n    vbuf[1] = 0;\n    vbuf[2] = 0;\n    vbuf[3] = 0;\n    vbuf[4] = 0;\n\n    ngx_cpuid(0, vbuf);\n\n    vendor = (u_char *) &vbuf[1];\n\n    if (vbuf[0] == 0) {\n        return;\n    }\n\n    ngx_cpuid(1, cpu);\n\n    if (ngx_strcmp(vendor, \"GenuineIntel\") == 0) {\n\n        switch ((cpu[0] & 0xf00) >> 8) {\n\n        /* Pentium */\n        case 5:\n            ngx_cacheline_size = 32;\n            break;\n\n        /* Pentium Pro, II, III */\n        case 6:\n            ngx_cacheline_size = 32;\n\n            if ((cpu[0] & 0xf0) >= 0xd0) {\n                /* Intel Core */\n                ngx_cacheline_size = 64;\n            }\n\n            break;\n\n        /*\n         * Pentium 4, although its cache line size is 64 bytes,\n         * it prefetches up to two cache lines during memory read\n         */\n        case 15:\n            ngx_cacheline_size = 128;\n            break;\n        }\n\n    } else if (ngx_strcmp(vendor, \"AuthenticAMD\") == 0) {\n        ngx_cacheline_size = 64;\n    }\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_cpuinfo.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* AF_INET only */\n", "func_signal": "static ngx_int_t\nngx_http_geo_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)", "code": "{\n    ngx_radix_tree_t *tree = (ngx_radix_tree_t *) data;\n\n    struct sockaddr_in         *sin;\n    ngx_http_variable_value_t  *vv;\n\n    sin = (struct sockaddr_in *) r->connection->sockaddr;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http geo started\");\n\n    vv = (ngx_http_variable_value_t *)\n                       ngx_radix32tree_find(tree, ntohl(sin->sin_addr.s_addr));\n\n    *v = *vv;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http geo: %V %v\", &r->connection->addr_text, v);\n\n    return NGX_OK;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\http\\modules\\ngx_http_geo_module.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * the ready data requires 3 syscalls:\n *     aio_write(), aio_error(), aio_return()\n * the non-ready data requires 4 (kqueue) or 5 syscalls:\n *     aio_write(), aio_error(), notifiction, aio_error(), aio_return()\n *                               timeout, aio_cancel(), aio_error()\n */\n", "func_signal": "ssize_t\nngx_aio_read(ngx_connection_t *c, u_char *buf, size_t size)", "code": "{\n    int           n;\n    ngx_event_t  *rev;\n\n    rev = c->read;\n\n    if (!rev->ready) {\n        ngx_log_error(NGX_LOG_ALERT, c->log, 0, \"second aio post\");\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                   \"rev->complete: %d\", rev->complete);\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                   \"aio size: %d\", size);\n\n    if (!rev->complete) {\n        ngx_memzero(&rev->aiocb, sizeof(struct aiocb));\n\n        rev->aiocb.aio_fildes = c->fd;\n        rev->aiocb.aio_buf = buf;\n        rev->aiocb.aio_nbytes = size;\n\n#if (NGX_HAVE_KQUEUE)\n        rev->aiocb.aio_sigevent.sigev_notify_kqueue = ngx_kqueue;\n        rev->aiocb.aio_sigevent.sigev_notify = SIGEV_KEVENT;\n        rev->aiocb.aio_sigevent.sigev_value.sigval_ptr = rev;\n#endif\n\n        if (aio_read(&rev->aiocb) == -1) {\n            ngx_log_error(NGX_LOG_CRIT, rev->log, ngx_errno,\n                          \"aio_read() failed\");\n            rev->error = 1;\n            return NGX_ERROR;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                       \"aio_read: #%d OK\", c->fd);\n\n        rev->active = 1;\n        rev->ready = 0;\n    }\n\n    rev->complete = 0;\n\n    n = aio_error(&rev->aiocb);\n    if (n == -1) {\n        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno, \"aio_error() failed\");\n        rev->error = 1;\n        return NGX_ERROR;\n    }\n\n    if (n != 0) {\n        if (n == NGX_EINPROGRESS) {\n            if (rev->ready) {\n                ngx_log_error(NGX_LOG_ALERT, c->log, n,\n                              \"aio_read() still in progress\");\n                rev->ready = 0;\n            }\n            return NGX_AGAIN;\n        }\n\n        ngx_log_error(NGX_LOG_CRIT, c->log, n, \"aio_read() failed\");\n        rev->error = 1;\n        rev->ready = 0;\n        return NGX_ERROR;\n    }\n\n    n = aio_return(&rev->aiocb);\n    if (n == -1) {\n        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,\n                      \"aio_return() failed\");\n\n        rev->error = 1;\n        rev->ready = 0;\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, rev->log, 0,\n                   \"aio_read: #%d %d\", c->fd, n);\n\n    if (n == 0) {\n        rev->eof = 1;\n        rev->ready = 0;\n    } else {\n        rev->ready = 1;\n    }\n\n    rev->active = 0;\n\n    return n;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\os\\unix\\ngx_aio_read.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* TODO: currently fd only */\n", "func_signal": "ngx_int_t ngx_http_send_cached(ngx_http_request_t *r)", "code": "{\n    ngx_int_t            rc;\n    ngx_hunk_t          *h;\n    ngx_chain_t          out;\n    ngx_http_log_ctx_t  *ctx;\n\n    ctx = r->connection->log->data;\n    ctx->action = \"sending response to client\";\n\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = r->cache->data.size;\n    r->headers_out.last_modified_time = r->cache->last_modified;\n\n    if (ngx_http_set_content_type(r) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* we need to allocate all before the header would be sent */\n\n    if (!(h = ngx_pcalloc(r->pool, sizeof(ngx_hunk_t)))) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (!(h->file = ngx_pcalloc(r->pool, sizeof(ngx_file_t)))) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rc = ngx_http_send_header(r);\n\n    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n        return rc;\n    }\n\n    h->type = r->main ? NGX_HUNK_FILE : NGX_HUNK_FILE|NGX_HUNK_LAST;\n\n    h->file_pos = 0;\n    h->file_last = r->cache->data.size;\n\n    h->file->fd = r->cache->fd;\n    h->file->log = r->connection->log;\n\n    out.hunk = h;\n    out.next = NULL;\n\n    return ngx_http_output_filter(r, &out);\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\http\\ngx_http_cache.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* AF_INET only */\n", "func_signal": "ngx_int_t\nngx_ptocidr(ngx_str_t *text, void *cidr)", "code": "{\n    u_char           *addr, *mask, *last;\n    ngx_int_t         shift;\n    ngx_inet_cidr_t  *in_cidr;\n\n    in_cidr = cidr;\n    addr = text->data;\n    last = addr + text->len;\n\n    mask = ngx_strlchr(addr, last, '/');\n\n    in_cidr->addr = ngx_inet_addr(addr, (mask ? mask : last) - addr);\n\n    if (in_cidr->addr == INADDR_NONE) {\n        return NGX_ERROR;\n    }\n\n    if (mask == NULL) {\n        in_cidr->mask = 0xffffffff;\n        return NGX_OK;\n    }\n\n    mask++;\n\n    shift = ngx_atoi(mask, last - mask);\n    if (shift == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    if (shift == 0) {\n\n        /* the x86 compilers use the shl instruction that shifts by modulo 32 */\n\n        in_cidr->mask = 0;\n\n        if (in_cidr->addr == 0) {\n            return NGX_OK;\n        }\n\n        return NGX_DONE;\n    }\n\n    in_cidr->mask = htonl((ngx_uint_t) (0 - (1 << (32 - shift))));\n\n    if (in_cidr->addr == (in_cidr->addr & in_cidr->mask)) {\n        return NGX_OK;\n    }\n\n    in_cidr->addr &= in_cidr->mask;\n\n    return NGX_DONE;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_inet.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * FreeBSD does not test /etc/localtime change, however, we can workaround it\n * by calling tzset() with TZ and then without TZ to update timezone.\n * The trick should work since FreeBSD 2.1.0.\n *\n * Linux does not test /etc/localtime change in localtime(),\n * but may stat(\"/etc/localtime\") several times in every strftime(),\n * therefore we use it to update timezone.\n *\n * Solaris does not test /etc/TIMEZONE change too and no workaround available.\n */\n", "func_signal": "void\nngx_timezone_update(void)", "code": "{\n#if (NGX_FREEBSD)\n\n    if (getenv(\"TZ\")) {\n        return;\n    }\n\n    putenv(\"TZ=UTC\");\n\n    tzset();\n\n    unsetenv(\"TZ\");\n\n    tzset();\n\n#elif (NGX_LINUX)\n    time_t      s;\n    struct tm  *t;\n    char        buf[4];\n\n    s = time(0);\n\n    t = localtime(&s);\n\n    strftime(buf, 4, \"%H\", t);\n\n#endif\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\os\\unix\\ngx_time.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* ! NGX_HAVE_KQUEUE */\n", "func_signal": "ssize_t\nngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain)", "code": "{\n    u_char        *prev;\n    ssize_t        n, size;\n    ngx_err_t      err;\n    ngx_array_t    vec;\n    ngx_event_t   *rev;\n    struct iovec  *iov, iovs[NGX_IOVS];\n\n    prev = NULL;\n    iov = NULL;\n    size = 0;\n\n    vec.elts = iovs;\n    vec.nelts = 0;\n    vec.size = sizeof(struct iovec);\n    vec.nalloc = NGX_IOVS;\n    vec.pool = c->pool;\n\n    /* coalesce the neighbouring bufs */\n\n    while (chain) {\n        if (prev == chain->buf->last) {\n            iov->iov_len += chain->buf->end - chain->buf->last;\n\n        } else {\n            iov = ngx_array_push(&vec);\n            if (iov == NULL) {\n                return NGX_ERROR;\n            }\n\n            iov->iov_base = (void *) chain->buf->last;\n            iov->iov_len = chain->buf->end - chain->buf->last;\n        }\n\n        size += chain->buf->end - chain->buf->last;\n        prev = chain->buf->end;\n        chain = chain->next;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                   \"readv: %d:%d\", vec.nelts, iov->iov_len);\n\n    rev = c->read;\n\n    do {\n        n = readv(c->fd, (struct iovec *) vec.elts, vec.nelts);\n\n        if (n == 0) {\n            rev->ready = 0;\n            rev->eof = 1;\n\n            return n;\n\n        } else if (n > 0) {\n\n            if (n < size && !(ngx_event_flags & NGX_USE_GREEDY_EVENT)) {\n                rev->ready = 0;\n            }\n\n            return n;\n        }\n\n        err = ngx_socket_errno;\n\n        if (err == NGX_EAGAIN || err == NGX_EINTR) {\n            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n                           \"readv() not ready\");\n            n = NGX_AGAIN;\n\n        } else {\n            n = ngx_connection_error(c, err, \"readv() failed\");\n            break;\n        }\n\n    } while (err == NGX_EINTR);\n\n    rev->ready = 0;\n\n    if (n == NGX_ERROR){\n        c->read->error = 1;\n    }\n\n    return n;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\os\\unix\\ngx_readv_chain.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * We use ngx_strcasecmp()/ngx_strncasecmp() for 7-bit ASCII strings only,\n * and implement our own ngx_strcasecmp()/ngx_strncasecmp()\n * to avoid libc locale overhead.  Besides, we use the ngx_uint_t's\n * instead of the u_char's, because they are slightly faster.\n */\n", "func_signal": "ngx_int_t\nngx_strcasecmp(u_char *s1, u_char *s2)", "code": "{\n    ngx_uint_t  c1, c2;\n\n    for ( ;; ) {\n        c1 = (ngx_uint_t) *s1++;\n        c2 = (ngx_uint_t) *s2++;\n\n        c1  = (c1 >= 'A' && c1 <= 'Z') ? (c1 | 0x20) : c1;\n        c2  = (c2 >= 'A' && c2 <= 'Z') ? (c2 | 0x20) : c2;\n\n        if (c1 == c2) {\n\n            if (c1) {\n                continue;\n            }\n\n            return 0;\n        }\n\n        return c1 - c2;\n    }\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_string.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* NGX_RESOLVE_A only */\n", "func_signal": "static ngx_int_t\nngx_resolve_name_locked(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx)", "code": "{\n    uint32_t              hash;\n    in_addr_t             addr, *addrs;\n    ngx_int_t             rc;\n    ngx_uint_t            naddrs;\n    ngx_resolver_ctx_t   *next;\n    ngx_resolver_node_t  *rn;\n\n    hash = ngx_crc32_short(ctx->name.data, ctx->name.len);\n\n    rn = ngx_resolver_lookup_name(r, &ctx->name, hash);\n\n    if (rn) {\n\n        if (rn->valid >= ngx_time()) {\n\n            ngx_log_debug0(NGX_LOG_DEBUG_CORE, r->log, 0, \"resolve cached\");\n\n            ngx_queue_remove(&rn->queue);\n\n            rn->expire = ngx_time() + r->expire;\n\n            ngx_queue_insert_head(&r->name_expire_queue, &rn->queue);\n\n            naddrs = rn->naddrs;\n\n            if (naddrs) {\n\n                /* NGX_RESOLVE_A answer */\n\n                if (naddrs != 1) {\n                    addr = 0;\n                    addrs = ngx_resolver_dup(r, rn->u.addrs,\n                                             naddrs * sizeof(in_addr_t));\n                    if (addrs == NULL) {\n                        return NGX_ERROR;\n                    }\n\n                } else {\n                    addr = rn->u.addr;\n                    addrs = NULL;\n                }\n\n                ctx->next = rn->waiting;\n                rn->waiting = NULL;\n\n                /* unlock name mutex */\n\n                do {\n                    ctx->state = NGX_OK;\n                    ctx->naddrs = naddrs;\n                    ctx->addrs = (naddrs == 1) ? &ctx->addr : addrs;\n                    ctx->addr = addr;\n                    next = ctx->next;\n\n                    ctx->handler(ctx);\n\n                    ctx = next;\n                } while (ctx);\n\n                if (addrs) {\n                    ngx_resolver_free(r, addrs);\n                }\n\n                return NGX_OK;\n            }\n\n            /* NGX_RESOLVE_CNAME */\n\n            if (ctx->recursion++ < NGX_RESOLVER_MAX_RECURSION) {\n\n                ctx->name.len = rn->cnlen;\n                ctx->name.data = rn->u.cname;\n\n                return ngx_resolve_name_locked(r, ctx);\n            }\n\n            ctx->next = rn->waiting;\n            rn->waiting = NULL;\n\n            /* unlock name mutex */\n\n            do {\n                ctx->state = NGX_RESOLVE_NXDOMAIN;\n                next = ctx->next;\n\n                ctx->handler(ctx);\n\n                ctx = next;\n            } while (ctx);\n\n            return NGX_OK;\n        }\n\n        if (rn->waiting) {\n\n            ctx->next = rn->waiting;\n            rn->waiting = ctx;\n\n            return NGX_AGAIN;\n        }\n\n        ngx_queue_remove(&rn->queue);\n\n        /* lock alloc mutex */\n\n        ngx_resolver_free_locked(r, rn->query);\n        rn->query = NULL;\n\n        if (rn->cnlen) {\n            ngx_resolver_free_locked(r, rn->u.cname);\n        }\n\n        if (rn->naddrs > 1) {\n            ngx_resolver_free_locked(r, rn->u.addrs);\n        }\n\n        /* unlock alloc mutex */\n\n    } else {\n\n        rn = ngx_resolver_alloc(r, sizeof(ngx_resolver_node_t));\n        if (rn == NULL) {\n            return NGX_ERROR;\n        }\n\n        rn->name = ngx_resolver_dup(r, ctx->name.data, ctx->name.len);\n        if (rn->name == NULL) {\n            ngx_resolver_free(r, rn);\n            return NGX_ERROR;\n        }\n\n        rn->node.key = hash;\n        rn->nlen = (u_short) ctx->name.len;\n        rn->query = NULL;\n\n        ngx_rbtree_insert(&r->name_rbtree, &rn->node);\n    }\n\n    rc = ngx_resolver_create_name_query(rn, ctx);\n\n    if (rc == NGX_ERROR) {\n        goto failed;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_rbtree_delete(&r->name_rbtree, &rn->node);\n\n        ngx_resolver_free(r, rn->query);\n        ngx_resolver_free(r, rn->name);\n        ngx_resolver_free(r, rn);\n\n        ctx->state = NGX_RESOLVE_NXDOMAIN;\n        ctx->handler(ctx);\n\n        return NGX_OK;\n    }\n\n    if (ngx_resolver_send_query(r, rn) != NGX_OK) {\n        goto failed;\n    }\n\n    if (ctx->event == NULL) {\n        ctx->event = ngx_resolver_calloc(r, sizeof(ngx_event_t));\n        if (ctx->event == NULL) {\n            goto failed;\n        }\n\n        ctx->event->handler = ngx_resolver_timeout_handler;\n        ctx->event->data = ctx;\n        ctx->event->log = r->log;\n        ctx->ident = -1;\n\n        ngx_add_timer(ctx->event, ctx->timeout);\n    }\n\n    if (ngx_queue_empty(&r->name_resend_queue)) {\n        ngx_add_timer(r->event, (ngx_msec_t) (r->resend_timeout * 1000));\n    }\n\n    rn->expire = ngx_time() + r->resend_timeout;\n\n    ngx_queue_insert_head(&r->name_resend_queue, &rn->queue);\n\n    rn->cnlen = 0;\n    rn->naddrs = 0;\n    rn->valid = 0;\n    rn->waiting = ctx;\n\n    ctx->state = NGX_AGAIN;\n\n    return NGX_AGAIN;\n\nfailed:\n\n    ngx_rbtree_delete(&r->name_rbtree, &rn->node);\n\n    if (rn->query) {\n        ngx_resolver_free(r, rn->query);\n    }\n\n    ngx_resolver_free(r, rn->name);\n\n    ngx_resolver_free(r, rn);\n\n    return NGX_ERROR;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_resolver.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * ngx_utf8_decode() decodes two and more bytes UTF sequences only\n * the return values:\n *    0x80 - 0x10ffff         valid character\n *    0x110000 - 0xfffffffd   invalid sequence\n *    0xfffffffe              incomplete sequence\n *    0xffffffff              error\n */\n", "func_signal": "uint32_t\nngx_utf8_decode(u_char **p, size_t n)", "code": "{\n    size_t    len;\n    uint32_t  u, i, valid;\n\n    u = **p;\n\n    if (u > 0xf0) {\n\n        u &= 0x07;\n        valid = 0xffff;\n        len = 3;\n\n    } else if (u > 0xe0) {\n\n        u &= 0x0f;\n        valid = 0x7ff;\n        len = 2;\n\n    } else if (u > 0xc0) {\n\n        u &= 0x1f;\n        valid = 0x7f;\n        len = 1;\n\n    } else {\n        (*p)++;\n        return 0xffffffff;\n    }\n\n    if (n - 1 < len) {\n        return 0xfffffffe;\n    }\n\n    (*p)++;\n\n    while (len) {\n        i = *(*p)++;\n\n        if (i < 0x80) {\n            return 0xffffffff;\n        }\n\n        u = (u << 6) | (i & 0x3f);\n\n        len--;\n    }\n\n    if (u > valid) {\n        return u;\n    }\n\n    return 0xffffffff;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_string.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n * ngx_strstrn() and ngx_strcasestrn() are intended to search for static\n * substring with known length in null-terminated string. The argument n\n * must be length of the second substring - 1.\n */\n", "func_signal": "u_char *\nngx_strstrn(u_char *s1, char *s2, size_t n)", "code": "{\n    u_char  c1, c2;\n\n    c2 = *(u_char *) s2++;\n\n    do {\n        do {\n            c1 = *s1++;\n\n            if (c1 == 0) {\n                return NULL;\n            }\n\n        } while (c1 != c2);\n\n    } while (ngx_strncmp(s1, (u_char *) s2, n) != 0);\n\n    return --s1;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_string.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* AF_INET only */\n", "func_signal": "static ngx_int_t\nngx_resolver_create_addr_query(ngx_resolver_node_t *rn, ngx_resolver_ctx_t *ctx)", "code": "{\n    u_char                *p, *d;\n    size_t                 len;\n    ngx_int_t              n;\n    ngx_uint_t             ident;\n    ngx_resolver_query_t  *query;\n\n    len = sizeof(ngx_resolver_query_t)\n          + sizeof(\".255.255.255.255.in-addr.arpa.\") - 1\n          + sizeof(ngx_resolver_qs_t);\n\n    p = ngx_resolver_calloc(ctx->resolver, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    rn->query = p;\n    query = (ngx_resolver_query_t *) p;\n\n    ident = ngx_random();\n\n    query->ident_hi = (u_char) ((ident >> 8) & 0xff);\n    query->ident_lo = (u_char) (ident & 0xff);\n\n    /* recursion query */\n    query->flags_hi = 1; query->flags_lo = 0;\n\n    /* one question */\n    query->nqs_hi = 0; query->nqs_lo = 1;\n    query->nan_hi = 0; query->nan_lo = 0;\n    query->nns_hi = 0; query->nns_lo = 0;\n    query->nar_hi = 0; query->nar_lo = 0;\n\n    p += sizeof(ngx_resolver_query_t);\n\n    for (n = 0; n < 32; n += 8){\n        d = ngx_sprintf(&p[1], \"%ud\", (ctx->addr >> n) & 0xff);\n        *p = (u_char) (d - &p[1]);\n        p = d;\n    }\n\n    /* query type \"PTR\", IP query class */\n    ngx_memcpy(p, \"\\7in-addr\\4arpa\\0\\0\\14\\0\\1\", 18);\n\n    rn->qlen = (u_short)\n                  (p + sizeof(\"\\7in-addr\\4arpa\") + sizeof(ngx_resolver_qs_t)\n                   - rn->query);\n\n    return NGX_OK;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\core\\ngx_resolver.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/* AF_INET only */\n", "func_signal": "static char *\nngx_http_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)", "code": "{\n    ngx_int_t                   rc;\n    ngx_str_t                  *value, file;\n    ngx_uint_t                  i;\n    ngx_inet_cidr_t             cidrin;\n    ngx_http_geo_conf_ctx_t    *ctx;\n    ngx_http_variable_value_t  *var, *old, **v;\n\n    ctx = cf->ctx;\n\n    if (cf->args->nelts != 2) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid number of the geo parameters\");\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[0].data, \"include\") == 0) {\n        file = value[1];\n\n        if (ngx_conf_full_name(cf->cycle, &file, 1) == NGX_ERROR){\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n\n        return ngx_conf_parse(cf, &file);\n    }\n\n    if (ngx_strcmp(value[0].data, \"default\") == 0) {\n        cidrin.addr = 0;\n        cidrin.mask = 0;\n\n    } else {\n        rc = ngx_ptocidr(&value[0], &cidrin);\n\n        if (rc == NGX_ERROR) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid parameter \\\"%V\\\"\", &value[0]);\n            return NGX_CONF_ERROR;\n        }\n\n        if (rc == NGX_DONE) {\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"low address bits of %V are meaningless\",\n                               &value[0]);\n        }\n\n        cidrin.addr = ntohl(cidrin.addr);\n        cidrin.mask = ntohl(cidrin.mask);\n    }\n\n    var = NULL;\n    v = ctx->values.elts;\n\n    for (i = 0; i < ctx->values.nelts; i++) {\n        if ((size_t) v[i]->len != value[1].len) {\n            continue;\n        }\n\n        if (ngx_strncmp(value[1].data, v[i]->data, value[1].len) == 0) {\n            var = v[i];\n            break;\n        }\n    }\n\n    if (var == NULL) {\n        var = ngx_palloc(ctx->pool, sizeof(ngx_http_variable_value_t));\n        if (var == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->len = value[1].len;\n        var->data = ngx_pstrdup(ctx->pool, &value[1]);\n        if (var->data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->valid = 1;\n        var->no_cacheable = 0;\n        var->not_found = 0;\n\n        v = ngx_array_push(&ctx->values);\n        if (v == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *v = var;\n    }\n\n    for (i = 2; i; i--) {\n        rc = ngx_radix32tree_insert(ctx->tree, cidrin.addr, cidrin.mask,\n                                    (uintptr_t) var);\n        if (rc == NGX_OK) {\n            return NGX_CONF_OK;\n        }\n\n        if (rc == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n\n        /* rc == NGX_BUSY */\n\n        old  = (ngx_http_variable_value_t *)\n                    ngx_radix32tree_find(ctx->tree, cidrin.addr & cidrin.mask);\n\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                \"duplicate parameter \\\"%V\\\", value: \\\"%v\\\", old value: \\\"%v\\\"\",\n                &value[0], var, old);\n\n        rc = ngx_radix32tree_delete(ctx->tree, cidrin.addr, cidrin.mask);\n\n        if (rc == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_ERROR;\n}", "path": "dumbproxy\\nginx-0.7.22\\src\\http\\modules\\ngx_http_geo_module.c", "repo_name": "mikeyk/couchdb-lounge", "stars": 5, "license": "apache-2.0", "language": "c", "size": 1879}
{"docstring": "/*\n     *  Initialization\n     */\n", "func_signal": "int __init xxxfb_init(void)", "code": "{\n    int cmap_len, retval;\t\n   \n    /*\n     *  For kernel boot options (in 'video=xxxfb:<options>' format)\n     */\n#ifndef MODULE\n    char *option = NULL;\n\n    if (fb_get_options(\"xxxfb\", &option))\n\t    return -ENODEV;\n    xxxfb_setup(option);\n#endif\n\n    /* \n     * Here we set the screen_base to the vitrual memory address\n     * for the framebuffer. Usually we obtain the resource address\n     * from the bus layer and then translate it to virtual memory\n     * space via ioremap. Consult ioport.h. \n     */\n    info.screen_base = framebuffer_virtual_memory;\t\n    info.fbops = &xxxfb_ops;\n    info.fix = xxxfb_fix;\n    info.pseudo_palette = pseudo_palette;\n\n    /*\n     * Set up flags to indicate what sort of acceleration your\n     * driver can provide (pan/wrap/copyarea/etc.) and whether it\n     * is a module -- see FBINFO_* in include/linux/fb.h\n     */\n    info.flags = FBINFO_DEFAULT;\n    info.par = current_par;\n\n    /*\n     * This should give a reasonable default video mode. The following is\n     * done when we can set a video mode. \n     */\n    if (!mode_option)\n\tmode_option = \"640x480@60\";\t \t\n\n    retval = fb_find_mode(&info.var, &info, mode_option, NULL, 0, NULL, 8);\n  \n    if (!retval || retval == 4)\n\treturn -EINVAL;\t\t\t\n\n    /* This has to been done !!! */\t\n    fb_alloc_cmap(&info.cmap, cmap_len, 0);\n\t\n    /* \n     * The following is done in the case of having hardware with a static \n     * mode. If we are setting the mode ourselves we don't call this. \n     */\t\n    info.var = xxxfb_var;\n\t\n    if (register_framebuffer(&info) < 0)\n\treturn -EINVAL;\n    printk(KERN_INFO \"fb%d: %s frame buffer device\\n\", info.node,\n\t   info.fix.id);\n    return 0;\n}", "path": "drivers\\video\\skeletonfb.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_io_space_region_setup\n *\n * PARAMETERS:  Handle              - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_io_space_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tACPI_FUNCTION_TRACE (\"ev_io_space_region_setup\");\n\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\t*region_context = NULL;\n\t}\n\telse {\n\t\t*region_context = handler_context;\n\t}\n\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*\n * XDR functions for basic NFS types\n */\n", "func_signal": "static inline u32 *\ndecode_fh(u32 *p, struct svc_fh *fhp)", "code": "{\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\t/* FIXME: Look up export pointer here and verify\n\t * Sun Secure RPC if requested */\n\treturn p + (NFS_FHSIZE >> 2);\n}", "path": "fs\\nfsd\\nfsxdr.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*======================================================================\n\n    The card status event handler.  Mostly, this schedules other\n    stuff to run after an event is received.  A CARD_REMOVAL event\n    also sets some flags to discourage the net drivers from trying\n    to talk to the card any more.\n\n    When a CARD_REMOVAL event is received, we immediately set a flag\n    to block future accesses to this device.  All the functions that\n    actually access the device should check this flag to make sure\n    the card is still present.\n\n======================================================================*/\n", "func_signal": "static int elsa_cs_event(event_t event, int priority,\n                          event_callback_args_t *args)", "code": "{\n    dev_link_t *link = args->client_data;\n    local_info_t *dev = link->priv;\n\n    DEBUG(1, \"elsa_cs_event(%d)\\n\", event);\n\n    switch (event) {\n    case CS_EVENT_CARD_REMOVAL:\n        link->state &= ~DEV_PRESENT;\n        if (link->state & DEV_CONFIG) {\n            ((local_info_t*)link->priv)->busy = 1;\n\t    elsa_cs_release(link);\n        }\n        break;\n    case CS_EVENT_CARD_INSERTION:\n        link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;\n        elsa_cs_config(link);\n        break;\n    case CS_EVENT_PM_SUSPEND:\n        link->state |= DEV_SUSPEND;\n        /* Fall through... */\n    case CS_EVENT_RESET_PHYSICAL:\n        /* Mark the device as stopped, to block IO until later */\n        dev->busy = 1;\n        if (link->state & DEV_CONFIG)\n            pcmcia_release_configuration(link->handle);\n        break;\n    case CS_EVENT_PM_RESUME:\n        link->state &= ~DEV_SUSPEND;\n        /* Fall through... */\n    case CS_EVENT_CARD_RESET:\n        if (link->state & DEV_CONFIG)\n            pcmcia_request_configuration(link->handle, &link->conf);\n        dev->busy = 0;\n        break;\n    }\n    return 0;\n}", "path": "drivers\\isdn\\hisax\\elsa_cs.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/* \n * This will do for now, once we decide which bootldr we're finally \n * going to use then we'll remove this function and do it properly\n *\n * Partions are currently (as offsets from base of flash):\n * 0x00000000 - 0x003FFFFF - bootloader (!)\n * 0x00400000 - 0x00FFFFFF - Flashdisk\n */\n", "func_signal": "static int __init epxa_default_partitions(struct mtd_info *master, struct mtd_partition **pparts)", "code": "{\n\tstruct mtd_partition *parts;\n\tint ret, i;\n\tint npartitions = 0;\n\tchar *names; \n\tconst char *name = \"jffs\";\n\n\tprintk(\"Using default partitions for %s\\n\",BOARD_NAME);\n\tnpartitions=1;\n\tparts = kmalloc(npartitions*sizeof(*parts)+strlen(name), GFP_KERNEL);\n\tmemzero(parts,npartitions*sizeof(*parts)+strlen(name));\n\tif (!parts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\ti=0;\n\tnames = (char *)&parts[npartitions];\t\n\tparts[i].name = names;\n\tnames += strlen(name) + 1;\n\tstrcpy(parts[i].name, name);\n\n#ifdef CONFIG_EPXA10DB\n\tparts[i].size = FLASH_SIZE-0x00400000;\n\tparts[i].offset = 0x00400000;\n#else\n\tparts[i].size = FLASH_SIZE-0x00180000;\n\tparts[i].offset = 0x00180000;\n#endif\n\n out:\n\t*pparts = parts;\n\treturn npartitions;\n}", "path": "drivers\\mtd\\maps\\epxa10db-flash.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*======================================================================\n\n    This deletes a driver \"instance\".  The device is de-registered\n    with Card Services.  If it has been released, all local data\n    structures are freed.  Otherwise, the structures will be freed\n    when the device is released.\n\n======================================================================*/\n", "func_signal": "static void elsa_cs_detach(dev_link_t *link)", "code": "{\n    dev_link_t **linkp;\n    local_info_t *info = link->priv;\n    int ret;\n\n    DEBUG(0, \"elsa_cs_detach(0x%p)\\n\", link);\n\n    /* Locate device structure */\n    for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)\n        if (*linkp == link) break;\n    if (*linkp == NULL)\n        return;\n\n    if (link->state & DEV_CONFIG)\n        elsa_cs_release(link);\n\n    /* Break the link with Card Services */\n    if (link->handle) {\n        ret = pcmcia_deregister_client(link->handle);\n\tif (ret != CS_SUCCESS)\n\t    cs_error(link->handle, DeregisterClient, ret);\n    }\n\n    /* Unlink device structure and free it */\n    *linkp = link->next;\n    kfree(info);\n\n}", "path": "drivers\\isdn\\hisax\\elsa_cs.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*  DMA'able memory allocation stuff.\n */\n", "func_signal": "static inline void *dmaalloc(size_t size)", "code": "{\n\tunsigned long addr;\n\n\tif (size == 0) {\n\t\treturn NULL;\n\t}\n\taddr = __get_dma_pages(GFP_KERNEL, get_order(size));\n\tif (addr) {\n\t\tstruct page *page;\n\n\t\tfor (page = virt_to_page(addr); page < virt_to_page(addr+size); page++)\n\t\t\tSetPageReserved(page);\n\t}\n\treturn (void *)addr;\n}", "path": "drivers\\char\\ftape\\lowlevel\\ftape-buffer.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_pci_bar_region_setup\n *\n * PARAMETERS:  Handle              - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling\n *\n * MUTEX:       Assumes namespace is not locked\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_pci_bar_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tACPI_FUNCTION_TRACE (\"ev_pci_bar_region_setup\");\n\n\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*======================================================================\n\n    After a card is removed, elsa_cs_release() will unregister the net\n    device, and release the PCMCIA configuration.  If the device is\n    still open, this will be postponed until it is closed.\n\n======================================================================*/\n", "func_signal": "static void elsa_cs_release(dev_link_t *link)", "code": "{\n    local_info_t *local = link->priv;\n\n    DEBUG(0, \"elsa_cs_release(0x%p)\\n\", link);\n\n    if (local) {\n    \tif (local->cardnr >= 0) {\n    \t    /* no unregister function with hisax */\n\t    HiSax_closecard(local->cardnr);\n\t}\n    }\n    /* Unlink the device chain */\n    link->dev = NULL;\n\n    /* Don't bother checking to see if these succeed or not */\n    if (link->win)\n        pcmcia_release_window(link->win);\n    pcmcia_release_configuration(link->handle);\n    pcmcia_release_io(link->handle, &link->io);\n    pcmcia_release_irq(link->handle, &link->irq);\n    link->state &= ~DEV_CONFIG;\n}", "path": "drivers\\isdn\\hisax\\elsa_cs.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_default_region_setup\n *\n * PARAMETERS:  Handle              - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_default_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tACPI_FUNCTION_TRACE (\"ev_default_region_setup\");\n\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\t*region_context = NULL;\n\t}\n\telse {\n\t\t*region_context = handler_context;\n\t}\n\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*\n * XDR release functions\n */\n", "func_signal": "int\nnfssvc_release_fhandle(struct svc_rqst *rqstp, u32 *p,\n\t\t\t\t\tstruct nfsd_fhandle *resp)", "code": "{\n\tfh_put(&resp->fh);\n\treturn 1;\n}", "path": "fs\\nfsd\\nfsxdr.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*======================================================================\n\n    elsa_cs_attach() creates an \"instance\" of the driver, allocatingx\n    local data structures for one device.  The device is registered\n    with Card Services.\n\n    The dev_link structure is initialized, but we don't actually\n    configure the card at this point -- we wait until we receive a\n    card insertion event.\n\n======================================================================*/\n", "func_signal": "static dev_link_t *elsa_cs_attach(void)", "code": "{\n    client_reg_t client_reg;\n    dev_link_t *link;\n    local_info_t *local;\n    int ret, i;\n\n    DEBUG(0, \"elsa_cs_attach()\\n\");\n\n    /* Allocate space for private device-specific data */\n    local = kmalloc(sizeof(local_info_t), GFP_KERNEL);\n    if (!local) return NULL;\n    memset(local, 0, sizeof(local_info_t));\n    local->cardnr = -1;\n    link = &local->link; link->priv = local;\n\n    /* Interrupt setup */\n    link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING|IRQ_FIRST_SHARED;\n    link->irq.IRQInfo1 = IRQ_INFO2_VALID|IRQ_LEVEL_ID|IRQ_SHARE_ID;\n    if (irq_list[0] == -1)\n        link->irq.IRQInfo2 = irq_mask;\n    else\n        for (i = 0; i < 4; i++)\n            link->irq.IRQInfo2 |= 1 << irq_list[i];\n    link->irq.Handler = NULL;\n\n    /*\n      General socket configuration defaults can go here.  In this\n      client, we assume very little, and rely on the CIS for almost\n      everything.  In most clients, many details (i.e., number, sizes,\n      and attributes of IO windows) are fixed by the nature of the\n      device, and can be hard-wired here.\n    */\n    link->io.NumPorts1 = 8;\n    link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;\n    link->io.IOAddrLines = 3;\n\n    link->conf.Attributes = CONF_ENABLE_IRQ;\n    link->conf.Vcc = 50;\n    link->conf.IntType = INT_MEMORY_AND_IO;\n\n    /* Register with Card Services */\n    link->next = dev_list;\n    dev_list = link;\n    client_reg.dev_info = &dev_info;\n    client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;\n    client_reg.EventMask =\n        CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |\n        CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |\n        CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;\n    client_reg.event_handler = &elsa_cs_event;\n    client_reg.Version = 0x0210;\n    client_reg.event_callback_args.client_data = link;\n    ret = pcmcia_register_client(&link->handle, &client_reg);\n    if (ret != CS_SUCCESS) {\n        cs_error(link->handle, RegisterClient, ret);\n        elsa_cs_detach(link);\n        return NULL;\n    }\n\n    return link;\n}", "path": "drivers\\isdn\\hisax\\elsa_cs.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*\n * Decode a file name and make sure that the path contains\n * no slashes or null bytes.\n */\n", "func_signal": "static inline u32 *\ndecode_filename(u32 *p, char **namp, int *lenp)", "code": "{\n\tchar\t\t*name;\n\tint\t\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}", "path": "fs\\nfsd\\nfsxdr.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*\n * RFC2451: Weak key checks SHOULD be performed.\n */\n", "func_signal": "static int setkey(u32 *expkey, const u8 *key, unsigned int keylen, u32 *flags)", "code": "{\n\tconst u8 *k;\n\tu8 *b0, *b1;\n\tu32 n, w;\n\tu8 bits0[56], bits1[56];\n\n\tn  = parity[key[0]]; n <<= 4;\n\tn |= parity[key[1]]; n <<= 4;\n\tn |= parity[key[2]]; n <<= 4;\n\tn |= parity[key[3]]; n <<= 4;\n\tn |= parity[key[4]]; n <<= 4;\n\tn |= parity[key[5]]; n <<= 4;\n\tn |= parity[key[6]]; n <<= 4;\n\tn |= parity[key[7]];\n\tw = 0x88888888L;\n\t\n\tif ((*flags & CRYPTO_TFM_REQ_WEAK_KEY)\n\t    && !((n - (w >> 3)) & w)) {  /* 1 in 10^10 keys passes this test */\n\t\tif (n < 0x41415151) {\n\t\t\tif (n < 0x31312121) {\n\t\t\t\tif (n < 0x14141515) {\n\t\t\t\t\t/* 01 01 01 01 01 01 01 01 */\n\t\t\t\t\tif (n == 0x11111111) goto weak;\n\t\t\t\t\t/* 01 1F 01 1F 01 0E 01 0E */\n\t\t\t\t\tif (n == 0x13131212) goto weak;\n\t\t\t\t} else {\n\t\t\t\t\t/* 01 E0 01 E0 01 F1 01 F1 */\n\t\t\t\t\tif (n == 0x14141515) goto weak;\n\t\t\t\t\t/* 01 FE 01 FE 01 FE 01 FE */\n\t\t\t\t\tif (n == 0x16161616) goto weak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n < 0x34342525) {\n\t\t\t\t\t/* 1F 01 1F 01 0E 01 0E 01 */\n\t\t\t\t\tif (n == 0x31312121) goto weak;\n\t\t\t\t\t/* 1F 1F 1F 1F 0E 0E 0E 0E (?) */\n\t\t\t\t\tif (n == 0x33332222) goto weak;\n\t\t\t\t} else {\n\t\t\t\t\t/* 1F E0 1F E0 0E F1 0E F1 */\n\t\t\t\t\tif (n == 0x34342525) goto weak;\n\t\t\t\t\t/* 1F FE 1F FE 0E FE 0E FE */\n\t\t\t\t\tif (n == 0x36362626) goto weak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (n < 0x61616161) {\n\t\t\t\tif (n < 0x44445555) {\n\t\t\t\t\t/* E0 01 E0 01 F1 01 F1 01 */\n\t\t\t\t\tif (n == 0x41415151) goto weak;\n\t\t\t\t\t/* E0 1F E0 1F F1 0E F1 0E */\n\t\t\t\t\tif (n == 0x43435252) goto weak;\n\t\t\t\t} else {\n\t\t\t\t\t/* E0 E0 E0 E0 F1 F1 F1 F1 (?) */\n\t\t\t\t\tif (n == 0x44445555) goto weak;\n\t\t\t\t\t/* E0 FE E0 FE F1 FE F1 FE */\n\t\t\t\t\tif (n == 0x46465656) goto weak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n < 0x64646565) {\n\t\t\t\t\t/* FE 01 FE 01 FE 01 FE 01 */\n\t\t\t\t\tif (n == 0x61616161) goto weak;\n\t\t\t\t\t/* FE 1F FE 1F FE 0E FE 0E */\n\t\t\t\t\tif (n == 0x63636262) goto weak;\n\t\t\t\t} else {\n\t\t\t\t\t/* FE E0 FE E0 FE F1 FE F1 */\n\t\t\t\t\tif (n == 0x64646565) goto weak;\n\t\t\t\t\t/* FE FE FE FE FE FE FE FE */\n\t\t\t\t\tif (n == 0x66666666) goto weak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tgoto not_weak;\nweak:\n\t\t*flags |= CRYPTO_TFM_RES_WEAK_KEY;\n\t\treturn -EINVAL;\n\t}\n\nnot_weak:\n\n\t/* explode the bits */\n\tn = 56;\n\tb0 = bits0;\n\tb1 = bits1;\n\t\n\tdo {\n\t\tw = (256 | *key++) << 2;\n\t\tdo {\n\t\t\t--n;\n\t\t\tb1[n] = 8 & w;\n\t\t\tw >>= 1;\n\t\t\tb0[n] = 4 & w;\n\t\t} while ( w >= 16 );\n\t} while ( n );\n\t\n\t/* put the bits in the correct places */\n\tn = 16;\n\tk = rotors;\n\t\n\tdo {\n\t\tw   = (b1[k[ 0   ]] | b0[k[ 1   ]]) << 4;\n\t\tw  |= (b1[k[ 2   ]] | b0[k[ 3   ]]) << 2;\n\t\tw  |=  b1[k[ 4   ]] | b0[k[ 5   ]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[ 6   ]] | b0[k[ 7   ]]) << 4;\n\t\tw  |= (b1[k[ 8   ]] | b0[k[ 9   ]]) << 2;\n\t\tw  |=  b1[k[10   ]] | b0[k[11   ]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[12   ]] | b0[k[13   ]]) << 4;\n\t\tw  |= (b1[k[14   ]] | b0[k[15   ]]) << 2;\n\t\tw  |=  b1[k[16   ]] | b0[k[17   ]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[18   ]] | b0[k[19   ]]) << 4;\n\t\tw  |= (b1[k[20   ]] | b0[k[21   ]]) << 2;\n\t\tw  |=  b1[k[22   ]] | b0[k[23   ]];\n\t\texpkey[0] = w;\n\t\t\n\t\tw   = (b1[k[ 0+24]] | b0[k[ 1+24]]) << 4;\n\t\tw  |= (b1[k[ 2+24]] | b0[k[ 3+24]]) << 2;\n\t\tw  |=  b1[k[ 4+24]] | b0[k[ 5+24]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[ 6+24]] | b0[k[ 7+24]]) << 4;\n\t\tw  |= (b1[k[ 8+24]] | b0[k[ 9+24]]) << 2;\n\t\tw  |=  b1[k[10+24]] | b0[k[11+24]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[12+24]] | b0[k[13+24]]) << 4;\n\t\tw  |= (b1[k[14+24]] | b0[k[15+24]]) << 2;\n\t\tw  |=  b1[k[16+24]] | b0[k[17+24]];\n\t\tw <<= 8;\n\t\tw  |= (b1[k[18+24]] | b0[k[19+24]]) << 4;\n\t\tw  |= (b1[k[20+24]] | b0[k[21+24]]) << 2;\n\t\tw  |=  b1[k[22+24]] | b0[k[23+24]];\n\t\t\n\t\tROR(w, 4, 28);      /* could be eliminated */\n\t\texpkey[1] = w;\n\n\t\tk += 48;\n\t\texpkey += 2;\n\t} while (--n);\n\n\treturn 0;\n}", "path": "crypto\\des.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_pci_config_region_setup\n *\n * PARAMETERS:  Handle             - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling\n *\n * MUTEX:       Assumes namespace is not locked\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_pci_config_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tacpi_status                     status = AE_OK;\n\tacpi_integer                    pci_value;\n\tstruct acpi_pci_id              *pci_id = *region_context;\n\tunion acpi_operand_object       *handler_obj;\n\tstruct acpi_namespace_node      *parent_node;\n\tstruct acpi_namespace_node      *pci_root_node;\n\tunion acpi_operand_object       *region_obj = (union acpi_operand_object   *) handle;\n\tstruct acpi_device_id           object_hID;\n\n\n\tACPI_FUNCTION_TRACE (\"ev_pci_config_region_setup\");\n\n\n\thandler_obj = region_obj->region.handler;\n\tif (!handler_obj) {\n\t\t/*\n\t\t * No installed handler. This shouldn't happen because the dispatch\n\t\t * routine checks before we get here, but we check again just in case.\n\t\t */\n\t\tACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,\n\t\t\t\"Attempting to init a region %p, with no handler\\n\", region_obj));\n\t\treturn_ACPI_STATUS (AE_NOT_EXIST);\n\t}\n\n\t*region_context = NULL;\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\tif (pci_id) {\n\t\t\tACPI_MEM_FREE (pci_id);\n\t\t}\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tparent_node = acpi_ns_get_parent_node (region_obj->region.node);\n\n\t/*\n\t * Get the _SEG and _BBN values from the device upon which the handler\n\t * is installed.\n\t *\n\t * We need to get the _SEG and _BBN objects relative to the PCI BUS device.\n\t * This is the device the handler has been registered to handle.\n\t */\n\n\t/*\n\t * If the address_space.Node is still pointing to the root, we need\n\t * to scan upward for a PCI Root bridge and re-associate the op_region\n\t * handlers with that device.\n\t */\n\tif (handler_obj->address_space.node == acpi_gbl_root_node) {\n\t\t/* Start search from the parent object */\n\n\t\tpci_root_node = parent_node;\n\t\twhile (pci_root_node != acpi_gbl_root_node) {\n\t\t\tstatus = acpi_ut_execute_HID (pci_root_node, &object_hID);\n\t\t\tif (ACPI_SUCCESS (status)) {\n\t\t\t\t/* Got a valid _HID, check if this is a PCI root */\n\n\t\t\t\tif (!(ACPI_STRNCMP (object_hID.value, PCI_ROOT_HID_STRING,\n\t\t\t\t\t\t   sizeof (PCI_ROOT_HID_STRING)))) {\n\t\t\t\t\t/* Install a handler for this PCI root bridge */\n\n\t\t\t\t\tstatus = acpi_install_address_space_handler ((acpi_handle) pci_root_node,\n\t\t\t\t\t\t\t   ACPI_ADR_SPACE_PCI_CONFIG,\n\t\t\t\t\t\t\t   ACPI_DEFAULT_HANDLER, NULL, NULL);\n\t\t\t\t\tif (ACPI_FAILURE (status)) {\n\t\t\t\t\t\tif (status == AE_SAME_HANDLER) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * It is OK if the handler is already installed on the root\n\t\t\t\t\t\t\t * bridge.  Still need to return a context object for the\n\t\t\t\t\t\t\t * new PCI_Config operation region, however.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tstatus = AE_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tACPI_REPORT_ERROR ((\n\t\t\t\t\t\t\t\t\"Could not install pci_config handler for Root Bridge %4.4s, %s\\n\",\n\t\t\t\t\t\t\t\tacpi_ut_get_node_name (pci_root_node), acpi_format_exception (status)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpci_root_node = acpi_ns_get_parent_node (pci_root_node);\n\t\t}\n\n\t\t/* PCI root bridge not found, use namespace root node */\n\t}\n\telse {\n\t\tpci_root_node = handler_obj->address_space.node;\n\t}\n\n\t/*\n\t * If this region is now initialized, we are done.\n\t * (install_address_space_handler could have initialized it)\n\t */\n\tif (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {\n\t\treturn_ACPI_STATUS (AE_OK);\n\t}\n\n\t/* Region is still not initialized. Create a new context */\n\n\tpci_id = ACPI_MEM_CALLOCATE (sizeof (struct acpi_pci_id));\n\tif (!pci_id) {\n\t\treturn_ACPI_STATUS (AE_NO_MEMORY);\n\t}\n\n\t/*\n\t * For PCI_Config space access, we need the segment, bus,\n\t * device and function numbers.  Acquire them here.\n\t */\n\n\t/*\n\t * Get the PCI device and function numbers from the _ADR object\n\t * contained in the parent's scope.\n\t */\n\tstatus = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR, parent_node, &pci_value);\n\n\t/*\n\t * The default is zero, and since the allocation above zeroed\n\t * the data, just do nothing on failure.\n\t */\n\tif (ACPI_SUCCESS (status)) {\n\t\tpci_id->device  = ACPI_HIWORD (ACPI_LODWORD (pci_value));\n\t\tpci_id->function = ACPI_LOWORD (ACPI_LODWORD (pci_value));\n\t}\n\n\t/* The PCI segment number comes from the _SEG method */\n\n\tstatus = acpi_ut_evaluate_numeric_object (METHOD_NAME__SEG, pci_root_node, &pci_value);\n\tif (ACPI_SUCCESS (status)) {\n\t\tpci_id->segment = ACPI_LOWORD (pci_value);\n\t}\n\n\t/* The PCI bus number comes from the _BBN method */\n\n\tstatus = acpi_ut_evaluate_numeric_object (METHOD_NAME__BBN, pci_root_node, &pci_value);\n\tif (ACPI_SUCCESS (status)) {\n\t\tpci_id->bus = ACPI_LOWORD (pci_value);\n\t}\n\n\t/* Complete this device's pci_id */\n\n\tacpi_os_derive_pci_id (pci_root_node, region_obj->region.node, &pci_id);\n\n\t*region_context = pci_id;\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/* \n * RFC2451:\n *\n *   For DES-EDE3, there is no known need to reject weak or\n *   complementation keys.  Any weakness is obviated by the use of\n *   multiple keys.\n *\n *   However, if the first two or last two independent 64-bit keys are\n *   equal (k1 == k2 or k2 == k3), then the DES3 operation is simply the\n *   same as DES.  Implementers MUST reject keys that exhibit this\n *   property.\n *\n */\n", "func_signal": "static int des3_ede_setkey(void *ctx, const u8 *key,\n                           unsigned int keylen, u32 *flags)", "code": "{\n\tunsigned int i, off;\n\tstruct des3_ede_ctx *dctx = ctx;\n\n\tif (!(memcmp(key, &key[DES_KEY_SIZE], DES_KEY_SIZE) && \n\t    memcmp(&key[DES_KEY_SIZE], &key[DES_KEY_SIZE * 2],\n\t    \t\t\t\t\tDES_KEY_SIZE))) {\n\n\t\t*flags |= CRYPTO_TFM_RES_BAD_KEY_SCHED;\n\t\treturn -EINVAL;\n\t}\n\t\n\tfor (i = 0, off = 0; i < 3; i++, off += DES_EXPKEY_WORDS,\n\t\t\t\t\t\t\tkey += DES_KEY_SIZE) {\n\t\tint ret = setkey(&dctx->expkey[off], key, DES_KEY_SIZE, flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\t\n\treturn 0;\n}", "path": "crypto\\des.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/**\n *      xxxfb_set_par - Optional function. Alters the hardware state.\n *      @info: frame buffer structure that represents a single frame buffer\n *\n *\tUsing the fb_var_screeninfo in fb_info we set the resolution of the\n *\tthis particular framebuffer. This function alters the par AND the\n *\tfb_fix_screeninfo stored in fb_info. It doesn't not alter var in \n *\tfb_info since we are using that data. This means we depend on the\n *\tdata in var inside fb_info to be supported by the hardware. \n *\txxxfb_check_var is always called before xxxfb_set_par to ensure this.\n *\tAgain if you can't can't the resolution you don't need this function.\n *\n */\n", "func_signal": "static int xxxfb_set_par(struct fb_info *info)", "code": "{\n    struct xxx_par *par = (struct xxx_par *) info->par;\n    /* ... */\n    return 0;\t\n}", "path": "drivers\\video\\skeletonfb.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*======================================================================\n\n    elsa_cs_config() is scheduled to run after a CARD_INSERTION event\n    is received, to configure the PCMCIA socket, and to make the\n    device available to the system.\n\n======================================================================*/\n", "func_signal": "static int get_tuple(client_handle_t handle, tuple_t *tuple,\n                     cisparse_t *parse)", "code": "{\n    int i = pcmcia_get_tuple_data(handle, tuple);\n    if (i != CS_SUCCESS) return i;\n    return pcmcia_parse_tuple(handle, tuple, parse);\n}", "path": "drivers\\isdn\\hisax\\elsa_cs.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_system_memory_region_setup\n *\n * PARAMETERS:  Handle              - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling, a nop for now\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_system_memory_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tunion acpi_operand_object       *region_desc = (union acpi_operand_object *) handle;\n\tstruct acpi_mem_space_context   *local_region_context;\n\n\n\tACPI_FUNCTION_TRACE (\"ev_system_memory_region_setup\");\n\n\n\tif (function == ACPI_REGION_DEACTIVATE) {\n\t\tif (*region_context) {\n\t\t\tACPI_MEM_FREE (*region_context);\n\t\t\t*region_context = NULL;\n\t\t}\n\t\treturn_ACPI_STATUS (AE_OK);\n\t}\n\n\t/* Create a new context */\n\n\tlocal_region_context = ACPI_MEM_CALLOCATE (sizeof (struct acpi_mem_space_context));\n\tif (!(local_region_context)) {\n\t\treturn_ACPI_STATUS (AE_NO_MEMORY);\n\t}\n\n\t/* Save the region length and address for use in the handler */\n\n\tlocal_region_context->length = region_desc->region.length;\n\tlocal_region_context->address = region_desc->region.address;\n\n\t*region_context = local_region_context;\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ev_cmos_region_setup\n *\n * PARAMETERS:  Handle              - Region we are interested in\n *              Function            - Start or stop\n *              handler_context     - Address space handler context\n *              region_context      - Region specific context\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Do any prep work for region handling\n *\n * MUTEX:       Assumes namespace is not locked\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ev_cmos_region_setup (\n\tacpi_handle                     handle,\n\tu32                             function,\n\tvoid                            *handler_context,\n\tvoid                            **region_context)", "code": "{\n\tACPI_FUNCTION_TRACE (\"ev_cmos_region_setup\");\n\n\n\treturn_ACPI_STATUS (AE_OK);\n}", "path": "drivers\\acpi\\events\\evrgnini.c", "repo_name": "fzqing/linux-2.6", "stars": 5, "license": "other", "language": "c", "size": 76043}
{"docstring": "/*\n * This function will sync a device/file, and optionally attempt to\n * flush the buffer cache.  The latter is basically only useful for\n * system benchmarks and for torturing systems in burn-in tests.  :)\n */\n", "func_signal": "errcode_t ext2fs_sync_device(int fd, int flushb)", "code": "{\n\t/*\n\t * We always sync the device in case we're running on old\n\t * kernels for which we can lose data if we don't.  (There\n\t * still is a race condition for those kernels, but this\n\t * reduces it greatly.)\n\t */\n\tif (fsync (fd) == -1)\n\t\treturn errno;\n\n\tif (flushb) {\n\n#ifdef BLKFLSBUF\n\t\tif (ioctl (fd, BLKFLSBUF, 0) == 0)\n\t\t\treturn 0;\n#else\n#ifdef __GNUC__\n #warning BLKFLSBUF not defined\n#endif /* __GNUC__ */\n#endif\n#ifdef FDFLUSH\n\t\tioctl (fd, FDFLUSH, 0);   /* In case this is a floppy */\n#else\n#ifdef __GNUC__\n #warning FDFLUSH not defined\n#endif /* __GNUC__ */\n#endif\n\t}\n\treturn 0;\n}", "path": "ext2fs\\flushb.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * myproc is called once for every block in the file\n **********************************************************************/\n", "func_signal": "static int myproc(ext2_filsys fs,\n\t\t\t\t  blk_t *blocknr,\n\t\t\t\t  int blockcnt,\n\t\t\t\t  void *private)", "code": "{\n\tint err;\n\tstruct ext2_inode *ino = private;\n\tstatic nextblock = 0;\n\n\tif (blockcnt < 0)\t\t\t/* We're reading an inderect block */\n\t\treturn 0;\n\n\tif (nextblock+1 < blockcnt)\n\t\tmemset(blockbuf, 0, fs->blocksize);\n\n\twhile (nextblock++ < blockcnt)\n\t\tif (fwrite(blockbuf, fs->blocksize, 1, ofile) < 0) {\n\t\t\tfprintf(stderr,\"Cannot write destination file\\n\");\n\t\t\treturn BLOCK_ABORT;\n\t\t}\n\n\terr = io_channel_read_blk(fs->io, *blocknr, 1, blockbuf);\n\tif (err) {\n\t\tfprintf(stderr,\"Cannot read source file\\n\");\n\t\treturn BLOCK_ABORT;\n\t}\n\n\tif (fwrite(blockbuf, MIN(fs->blocksize, ino->i_size - blockcnt*fs->blocksize), 1, ofile) < 0) {\n\t\tfprintf(stderr,\"Cannot write destination file\\n\");\n\t\treturn BLOCK_ABORT;\n\t}\n\t\n\treturn 0;\n}", "path": "src\\e2cp.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * myproc is a callback routine which is called once for each entry\n * in the directory\n **********************************************************************/\n", "func_signal": "static int myproc(struct ext2_dir_entry *dirent,\n\t\t\t\t  int\toffset,\n\t\t\t\t  int\tblocksize,\n\t\t\t\t  char\t*buf,\n\t\t\t\t  void\t*private)", "code": "{\n\tif (dirent->inode == ino) {\n\t\tint real_len = dirent->name_len & 0xff;\n\t\tif (directory[0]==0) {\n\t\t\tstrncpy(directory, dirent->name, real_len);\n\t\t\tdirectory[real_len]=0;\n\t\t}\n\t\telse {\n\t\t\tstrncpy(dir2, dirent->name, real_len);\n\t\t\tdir2[real_len]=0;\n\t\t\tstrcat(dir2, \"/\");\n\t\t\tstrcat(dir2,directory);\n\t\t\tstrcpy(directory,dir2);\n\t\t}\n\t\treturn DIRENT_ABORT;\n\t}\n\n\treturn 0;\n}", "path": "src\\e2pwd.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * This procedure frees a badblocks list.\n */\n", "func_signal": "void ext2fs_u32_list_free(ext2_u32_list bb)", "code": "{\n\tif (bb->magic != EXT2_ET_MAGIC_BADBLOCKS_LIST)\n\t\treturn;\n\n\tif (bb->list)\n\t\text2fs_free_mem(&bb->list);\n\tbb->list = 0;\n\text2fs_free_mem(&bb);\n}", "path": "ext2fs\\freefs.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Free the inode cache structure\n */\n", "func_signal": "static void ext2fs_free_inode_cache(struct ext2_inode_cache *icache)", "code": "{\n\tif (--icache->refcount)\n\t\treturn;\n\tif (icache->buffer)\n\t\text2fs_free_mem(&icache->buffer);\n\tif (icache->cache)\n\t\text2fs_free_mem(&icache->cache);\n\ticache->buffer_blk = 0;\n\text2fs_free_mem(&icache);\n}", "path": "ext2fs\\freefs.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * This function frees a directory list\n */\n", "func_signal": "static void free_dirlist(struct dir_list **list)", "code": "{\n\tstruct dir_list *dp, *next;\n\n\tfor (dp = *list; dp; dp = next) {\n\t\tnext = dp->next;\n\t\tfree(dp->name);\n\t\tfree(dp);\n\t}\n\t*list = 0;\n}", "path": "ext2fs\\finddev.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * getfstype finds the type of the file system on the partition.\n * It is not very good at it, but it identifies ext2 file systems,\n * which is the important thing.\n *\n * Returns the file system type or a negative error code.\n **********************************************************************/\n", "func_signal": "int\ngetfstype(int disk, unsigned short parttype, unsigned long start)", "code": "{\n\tstatic union {\n\t\tu_char\tbytes[512];\n\t\tu_short shorts[256];\n\t\tu_long\tlongs[128];\n\t} testblock;\n\tint err;\n\n\tif (parttype == PART_SWAP)\n\t\treturn SWAP;\n\n\tif (parttype == PART_DOS32)\n\t\treturn MSDOSFS;\n\n\terr=readdisk(disk, start, 1, &testblock);\n\tif (err) return -err;\n\n#if 0\n\tif (strncmp(testblock.bytes+3,\"MSDOS\",5)==0) /* There must be a better way to do this */\n\t\treturn MSDOSFS;\n#endif\n\n\terr=readdisk(disk, start+2, 1, &testblock);\n\tif (err) return -err;\n\n\tif (testblock.shorts[28]==EXT2_SUPER_MAGIC)\n\t\treturn EXT2FS;\n\n\terr=readdisk(disk, start+7, 1, &testblock);\n\tif (err) return -err;\n\n\tif (memcmp(testblock.bytes+0x1f6, \"SWAP-SPACE\", 10)==0)\n\t\treturn SWAP;\n\n\treturn 0;\n}", "path": "src\\part.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * main routine\n **********************************************************************/\n", "func_signal": "main(int argc, char **argv)", "code": "{\n\tint err, c;\n\tchar *src, *dst;\n\text2_filsys fs;\n\tino_t ino;\n\tstruct ext2_inode e2ino;\n\n\topterr = 0;\n\twhile ((c=getopt(argc, argv, \"bt\")) != -1) {\n\t\tswitch (c) {\n         case 'b': \n\t\t case 't': omode[1] = c; break;\n\t\t case '?': usage();\n\t\t}\n\t}\n\n\tif (argc!=optind+2)\n\t\tusage();\n\n\tsrc = argv[optind];\n\tdst = argv[optind+1];\n\n\n\t/* Open file system */\n\terr = ext2fs_open(0, 0, 0, 0, dos_io_manager, &fs);\n\tif (err)\n\t\te2_err(\"Cannot open ext2 file system\",err);\n\n\t/* Allocate file buffer */\n\tblockbuf = malloc(fs->blocksize);\n\tif (!blockbuf) {\n\t\tfprintf(stderr,\"Cannot malloc buffer\\n\");\n\t\texit(1);\n\t}\n\n\t/* Lookup specified name */\n\terr = ext2fs_namei(fs, 2, cwdino, src, &ino);\n\tif (err)\n\t\te2_err(\"Cannot find source file\",err);\n\n\t/* Read specified inode */\n\terr = ext2fs_read_inode(fs, ino, &e2ino);\n\tif (err)\n\t\te2_err(\"Cannot read inode information\",err);\n\n\t/* Is it a regular file? */\n\tif (!S_ISREG(e2ino.i_mode)) {\n\t\tfprintf(stderr,\"%s is not a regular file\\n\",src);\n\t\texit(1);\n\t}\n\n\tofile=fopen(dst,omode);\n\tif (!ofile) {\n\t\tfprintf(stderr,\"Cannot create %s\\n\",dst);\n\t\texit(1);\n\t}\n\n\terr = ext2fs_block_iterate(fs, ino, 0, 0, myproc, &e2ino);\n\tif (err)\n\t\te2_err(\"Cannot read source file\",err);\n\n\treturn 0;\n}", "path": "src\\e2cp.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Free a directory block list\n */\n", "func_signal": "void ext2fs_free_dblist(ext2_dblist dblist)", "code": "{\n\tif (!dblist || (dblist->magic != EXT2_ET_MAGIC_DBLIST))\n\t\treturn;\n\n\tif (dblist->list)\n\t\text2fs_free_mem(&dblist->list);\n\tdblist->list = 0;\n\tif (dblist->fs && dblist->fs->dblist == dblist)\n\t\tdblist->fs->dblist = 0;\n\tdblist->magic = 0;\n\text2fs_free_mem(&dblist);\n}", "path": "ext2fs\\freefs.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * usage prints usage information and exits\n **********************************************************************/\n", "func_signal": "void\nusage()", "code": "{\n\tfprintf(stderr, \"usage: e2cp [-bt] source_file destination_file\\n\");\n\texit(1);\n}", "path": "src\\e2cp.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Convert an os_type to a string\n */\n", "func_signal": "int e2p_string2os(char *str)", "code": "{\n\tconst char\t**cpp;\n\tint\t\ti = 0;\n\n\tfor (cpp = os_tab; *cpp; cpp++, i++) {\n\t\tif (!strcasecmp(str, *cpp))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}", "path": "e2p\\ostype.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Basic cut-down MD4 transform.  Returns only 32 bits of result.\n */\n", "func_signal": "static void halfMD4Transform (__u32 buf[4], __u32 const in[])", "code": "{\n\t__u32\ta = buf[0], b = buf[1], c = buf[2], d = buf[3];\n\n\t/* Round 1 */\n\tROUND(F, a, b, c, d, in[0] + K1,  3);\n\tROUND(F, d, a, b, c, in[1] + K1,  7);\n\tROUND(F, c, d, a, b, in[2] + K1, 11);\n\tROUND(F, b, c, d, a, in[3] + K1, 19);\n\tROUND(F, a, b, c, d, in[4] + K1,  3);\n\tROUND(F, d, a, b, c, in[5] + K1,  7);\n\tROUND(F, c, d, a, b, in[6] + K1, 11);\n\tROUND(F, b, c, d, a, in[7] + K1, 19);\n\n\t/* Round 2 */\n\tROUND(G, a, b, c, d, in[1] + K2,  3);\n\tROUND(G, d, a, b, c, in[3] + K2,  5);\n\tROUND(G, c, d, a, b, in[5] + K2,  9);\n\tROUND(G, b, c, d, a, in[7] + K2, 13);\n\tROUND(G, a, b, c, d, in[0] + K2,  3);\n\tROUND(G, d, a, b, c, in[2] + K2,  5);\n\tROUND(G, c, d, a, b, in[4] + K2,  9);\n\tROUND(G, b, c, d, a, in[6] + K2, 13);\n\n\t/* Round 3 */\n\tROUND(H, a, b, c, d, in[3] + K3,  3);\n\tROUND(H, d, a, b, c, in[7] + K3,  9);\n\tROUND(H, c, d, a, b, in[2] + K3, 11);\n\tROUND(H, b, c, d, a, in[6] + K3, 15);\n\tROUND(H, a, b, c, d, in[1] + K3,  3);\n\tROUND(H, d, a, b, c, in[5] + K3,  9);\n\tROUND(H, c, d, a, b, in[0] + K3, 11);\n\tROUND(H, b, c, d, a, in[4] + K3, 15);\n\n\tbuf[0] += a;\n\tbuf[1] += b;\n\tbuf[2] += c;\n\tbuf[3] += d;\n}", "path": "ext2fs\\dirhash.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/* The old legacy hash */\n", "func_signal": "static ext2_dirhash_t dx_hack_hash (const char *name, int len,\n\t\t\t\t    int unsigned_flag)", "code": "{\n\t__u32 hash, hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;\n\tconst unsigned char *ucp = (const unsigned char *) name;\n\tconst signed char *scp = (const signed char *) name;\n\tint c;\n\n\twhile (len--) {\n\t\tif (unsigned_flag)\n\t\t\tc = (int) *ucp++;\n\t\telse\n\t\t\tc = (int) *scp++;\n\t\thash = hash1 + (hash0 ^ (c * 7152373));\n\t\t\n\t\tif (hash & 0x80000000) hash -= 0x7fffffff;\n\t\thash1 = hash0;\n\t\thash0 = hash;\n\t}\n\treturn (hash0 << 1);\n}", "path": "ext2fs\\dirhash.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * main routine\n **********************************************************************/\n", "func_signal": "main(int argc, char **argv)", "code": "{\n\tint err, i;\n\text2_filsys fs;\n\tino_t dotdotino;\n\tstruct ext2_inode e2ino;\n\tchar *filename;\n\n\tif (argc!=1)\n\t\tusage();\n\n\t/* Open file system */\n\terr = ext2fs_open(0, 0, 0, 0, dos_io_manager, &fs);\n\tif (err)\n\t\te2_err(\"Cannot open ext2 file system\",err);\n\n\n\t/* Loop until we have the root */\n\tfor (ino=cwdino; ino!=2; ino=dotdotino) {\n\t\t/* Look up '..' */\n\t\terr = ext2fs_namei(fs, 2, ino, \"..\", &dotdotino);\n\t\tif (err)\n\t\t\te2_err(\"Cannot find '..'\",err);\n\n\t\terr = ext2fs_read_inode(fs, dotdotino, &e2ino);\n\t\tif (err)\n\t\t\te2_err(\"Cannot read '..'\", err);\n\n\t\tif (!S_ISDIR(e2ino.i_mode)) {\n\t\t\tfprintf(stderr,\".. is not a directory\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t/* Loop through all directory entries */\n\t\terr = ext2fs_dir_iterate(fs, dotdotino, 0, 0, myproc, 0);\n\t\tif (err)\n\t\t\te2_err(\"Cannot read directory\",err);\n\t}\n\n\tprintf(\"/%s\\n\",directory);\n}", "path": "src\\e2pwd.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Returns the hash of a filename.  If len is 0 and name is NULL, then\n * this function can be used to test whether or not a hash version is\n * supported.\n * \n * The seed is an 4 longword (32 bits) \"secret\" which can be used to\n * uniquify a hash.  If the seed is all zero's, then some default seed\n * may be used.\n * \n * A particular hash version specifies whether or not the seed is\n * represented, and whether or not the returned hash is 32 bits or 64\n * bits.  32 bit hashes will return 0 for the minor hash.\n */\n", "func_signal": "errcode_t ext2fs_dirhash(int version, const char *name, int len,\n\t\t\t const __u32 *seed,\n\t\t\t ext2_dirhash_t *ret_hash,\n\t\t\t ext2_dirhash_t *ret_minor_hash)", "code": "{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32 \t\tin[8], buf[4];\n\tint\t\tunsigned_flag = 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t/* Check to see if the seed is all zero's */\n\tif (seed) {\n\t\tfor (i=0; i < 4; i++) {\n\t\t\tif (seed[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < 4)\n\t\t\tmemcpy(buf, seed, sizeof(buf));\n\t}\n\t\t\n\tswitch (version) {\n\tcase EXT2_HASH_LEGACY_UNSIGNED:\n\t\tunsigned_flag++;\n\tcase EXT2_HASH_LEGACY:\n\t\thash = dx_hack_hash(name, len, unsigned_flag);\n\t\tbreak;\n\tcase EXT2_HASH_HALF_MD4_UNSIGNED:\n\t\tunsigned_flag++;\n\tcase EXT2_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\tstr2hashbuf(p, len, in, 8, unsigned_flag);\n\t\t\thalfMD4Transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase EXT2_HASH_TEA_UNSIGNED:\n\t\tunsigned_flag++;\n\tcase EXT2_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\tstr2hashbuf(p, len, in, 4, unsigned_flag);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tdefault:\n\t\t*ret_hash = 0;\n\t\treturn EXT2_ET_DIRHASH_UNSUPP;\n\t}\n\t*ret_hash = hash & ~1;\n\tif (ret_minor_hash)\n\t\t*ret_minor_hash = minor_hash;\n\treturn 0;\n}", "path": "ext2fs\\dirhash.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * usage prints usage information and exits\n **********************************************************************/\n", "func_signal": "void\nusage()", "code": "{\n\tfprintf(stderr, \"usage: e2pwd\\n\");\n\texit(1);\n}", "path": "src\\e2pwd.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**********************************************************************\n * get_part() fetches 16 partition descriptors from the disk.\n *\n * Returns error code.\n **********************************************************************/\n", "func_signal": "int\nget_part(int disk, struct part_desc *pl)", "code": "{\n\tint i, next, err;\n\tlong startsect;\n\n\terr=readdisk(disk, 0, 1, &fs);\n\tif (err) return err;\n\n\tif (fs.magic!=FIRST_SECT_MAGIC)\n\t\treturn E2E_BADPART;\n\t\n\tmemset(pl,0,sizeof(*pl)*16);\n\tfor (i=0; i<4; i++) {\n\t\tif (fs.part[i].sys_ind) {\n\t\t\tpl[i].is_extended = fs.part[i].sys_ind==EXTENDED_PARTITION;\n\t\t\tpl[i].start = fs.part[i].start_sectlo+(fs.part[i].start_secthi<<16);\n\t\t\tpl[i].length = fs.part[i].nr_sectslo+(fs.part[i].nr_sectshi<<16);\n\t\t\tpl[i].parttype = fs.part[i].sys_ind;\n\t\t}\n\t}\n\tnext=4;\n\n\tfor (i=0; i<4; i++) {\n\t\tif (fs.part[i].sys_ind==EXTENDED_PARTITION) {\n\t\t\tstartsect = pl[i].start;\n\t\t\twhile (1) {\n\t\t\t\tif (next==16)\n\t\t\t\t\treturn 0;\n\n\t\t\t\terr=readdisk(disk, startsect, 1, &fs2);\n\t\t\t\tif (err) return err;\n\n\t\t\t\tif (fs2.magic!=FIRST_SECT_MAGIC)\n\t\t\t\t\treturn E2E_BADPART;\n\n\t\t\t\tpl[next].start = startsect + fs2.part[0].start_sectlo+(fs2.part[0].start_secthi<<16);\n\t\t\t\tpl[next].length = fs2.part[0].nr_sectslo+(fs2.part[0].nr_sectshi<<16);\n\t\t\t\tnext++;\n\t\t\t\tif (fs2.part[1].sys_ind!=EXTENDED_PARTITION)\n\t\t\t\t\tbreak;\n\t\t\t\tstartsect += fs2.part[1].start_sectlo+(fs2.part[1].start_secthi<<16);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "path": "src\\part.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * This function finds the pathname to a block device with a given\n * device number.  It returns a pointer to allocated memory to the\n * pathname on success, and NULL on failure.\n */\n", "func_signal": "char *ext2fs_find_block_device(dev_t device)", "code": "{\n\tstruct dir_list *list = 0, *new_list = 0;\n\tstruct dir_list *current;\n\tchar\t*ret_path = 0;\n\n\t/*\n\t * Add the starting directories to search...\n\t */\n\tadd_to_dirlist(\"/devices\", &list);\n\tadd_to_dirlist(\"/devfs\", &list);\n\tadd_to_dirlist(\"/dev\", &list);\n\t\n\twhile (list) {\n\t\tcurrent = list;\n\t\tlist = list->next;\n#ifdef DEBUG\n\t\tprintf(\"Scanning directory %s\\n\", current->name);\n#endif\n\t\tscan_dir(current->name, device, &new_list, &ret_path);\n\t\tfree(current->name);\n\t\tfree(current);\n\t\tif (ret_path)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're done checking at this level, descend to\n\t\t * the next level of subdirectories. (breadth-first)\n\t\t */\n\t\tif (list == 0) {\n\t\t\tlist = new_list;\n\t\t\tnew_list = 0;\n\t\t}\n\t}\n\tfree_dirlist(&list);\n\tfree_dirlist(&new_list);\n\treturn ret_path;\n}", "path": "ext2fs\\finddev.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * This function adds an entry to the directory list\n */\n", "func_signal": "static void add_to_dirlist(const char *name, struct dir_list **list)", "code": "{\n\tstruct dir_list *dp;\n\n\tdp = malloc(sizeof(struct dir_list));\n\tif (!dp)\n\t\treturn;\n\tdp->name = malloc(strlen(name)+1);\n\tif (!dp->name) {\n\t\tfree(dp);\n\t\treturn;\n\t}\n\tstrcpy(dp->name, name);\n\tdp->next = *list;\n\t*list = dp;\n}", "path": "ext2fs\\finddev.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/*\n * Helper function which is private to this module.  Used by\n * ext2fs_dir_iterate() and ext2fs_dblist_dir_iterate()\n */\n", "func_signal": "int ext2fs_process_dir_block(ext2_filsys fs,\n\t\t\t     blk_t\t*blocknr,\n\t\t\t     e2_blkcnt_t blockcnt,\n\t\t\t     blk_t\tref_block EXT2FS_ATTR((unused)),\n\t\t\t     int\tref_offset EXT2FS_ATTR((unused)),\n\t\t\t     void\t*priv_data)", "code": "{\n\tstruct dir_context *ctx = (struct dir_context *) priv_data;\n\tunsigned int\toffset = 0;\n\tunsigned int\tnext_real_entry = 0;\n\tint\t\tret = 0;\n\tint\t\tchanged = 0;\n\tint\t\tdo_abort = 0;\n\tint\t\tentry, size;\n\tstruct ext2_dir_entry *dirent;\n\n\tif (blockcnt < 0)\n\t\treturn 0;\n\n\tentry = blockcnt ? DIRENT_OTHER_FILE : DIRENT_DOT_FILE;\n\t\n\tctx->errcode = ext2fs_read_dir_block(fs, *blocknr, ctx->buf);\n\tif (ctx->errcode)\n\t\treturn BLOCK_ABORT;\n\n\twhile (offset < fs->blocksize) {\n\t\tdirent = (struct ext2_dir_entry *) (ctx->buf + offset);\n\t\tif (((offset + dirent->rec_len) > fs->blocksize) ||\n\t\t    (dirent->rec_len < 8) ||\n\t\t    ((dirent->rec_len % 4) != 0) ||\n\t\t    (((dirent->name_len & 0xFF)+8) > dirent->rec_len)) {\n\t\t\tctx->errcode = EXT2_ET_DIR_CORRUPTED;\n\t\t\treturn BLOCK_ABORT;\n\t\t}\n\t\tif (!dirent->inode &&\n\t\t    !(ctx->flags & DIRENT_FLAG_INCLUDE_EMPTY))\n\t\t\tgoto next;\n\n\t\tret = (ctx->func)(ctx->dir,\n\t\t\t\t  (next_real_entry > offset) ?\n\t\t\t\t  DIRENT_DELETED_FILE : entry,\n\t\t\t\t  dirent, offset,\n\t\t\t\t  fs->blocksize, ctx->buf,\n\t\t\t\t  ctx->priv_data);\n\t\tif (entry < DIRENT_OTHER_FILE)\n\t\t\tentry++;\n\t\t\t\n\t\tif (ret & DIRENT_CHANGED)\n\t\t\tchanged++;\n\t\tif (ret & DIRENT_ABORT) {\n\t\t\tdo_abort++;\n\t\t\tbreak;\n\t\t}\nnext:\t\t\n \t\tif (next_real_entry == offset)\n\t\t\tnext_real_entry += dirent->rec_len;\n \n \t\tif (ctx->flags & DIRENT_FLAG_INCLUDE_REMOVED) {\n\t\t\tsize = ((dirent->name_len & 0xFF) + 11) & ~3;\n\n\t\t\tif (dirent->rec_len != size)  {\n\t\t\t\tunsigned int final_offset;\n\n\t\t\t\tfinal_offset = offset + dirent->rec_len;\n\t\t\t\toffset += size;\n\t\t\t\twhile (offset < final_offset &&\n\t\t\t\t       !ext2fs_validate_entry(ctx->buf,\n\t\t\t\t\t\t\t      offset,\n\t\t\t\t\t\t\t      final_offset))\n\t\t\t\t\toffset += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\toffset += dirent->rec_len;\n\t}\n\n\tif (changed) {\n\t\tctx->errcode = ext2fs_write_dir_block(fs, *blocknr, ctx->buf);\n\t\tif (ctx->errcode)\n\t\t\treturn BLOCK_ABORT;\n\t}\n\tif (do_abort)\n\t\treturn BLOCK_ABORT;\n\treturn 0;\n}", "path": "ext2fs\\dir_iterate.c", "repo_name": "mmeeks/ext2tools", "stars": 7, "license": "other", "language": "c", "size": 444}
{"docstring": "/**\n * fc_rport_prli_resp - Process Login (PRLI) response handler\n * @sp: current sequence in the PRLI exchange\n * @fp: response frame\n * @rp_arg: Fibre Channel remote port\n *\n * Locking Note: This function will be called without the rport lock\n * held, but it will lock, call an _enter_* function or fc_rport_error\n * and then unlock the rport.\n */\n", "func_signal": "static void fc_rport_prli_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t       void *rp_arg)", "code": "{\n\tstruct fc_rport *rport = rp_arg;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tu32 roles = FC_RPORT_ROLE_UNKNOWN;\n\tu32 fcp_parm = 0;\n\tu8 op;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_DEBUG_RPORT(\"Received a PRLI response from port (%6x)\\n\",\n\t\t       rport->port_id);\n\n\tif (rdata->rp_state != RPORT_ST_PRLI) {\n\t\tFC_DBG(\"Received a PRLI response, but in state %s\\n\",\n\t\t       fc_rport_state(rport));\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rport, fp);\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC) {\n\t\tpp = fc_frame_payload_get(fp, sizeof(*pp));\n\t\tif (pp && pp->prli.prli_spp_len >= sizeof(pp->spp)) {\n\t\t\tfcp_parm = ntohl(pp->spp.spp_params);\n\t\t\tif (fcp_parm & FCP_SPPF_RETRY)\n\t\t\t\trdata->flags |= FC_RP_FLAGS_RETRY;\n\t\t}\n\n\t\trport->supported_classes = FC_COS_CLASS3;\n\t\tif (fcp_parm & FCP_SPPF_INIT_FCN)\n\t\t\troles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\t\tif (fcp_parm & FCP_SPPF_TARG_FCN)\n\t\t\troles |= FC_RPORT_ROLE_FCP_TARGET;\n\n\t\trport->roles = roles;\n\t\tfc_rport_enter_rtv(rport);\n\n\t} else {\n\t\tFC_DBG(\"Bad ELS response\\n\");\n\t\trdata->event = RPORT_EV_FAILED;\n\t\tqueue_work(rport_event_queue, &rdata->event_work);\n\t}\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\n\tput_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_recv_prlo_req - Handle incoming Process Logout (PRLO) request\n * @rport: Fibre Channel remote port that initiated PRLO\n * @sp: current sequence in the PRLO exchange\n * @fp: PRLO request frame\n *\n * Locking Note: The rport lock is exected to be held before calling\n * this function.\n */\n", "func_signal": "static void fc_rport_recv_prlo_req(struct fc_rport *rport, struct fc_seq *sp,\n\t\t\t\t   struct fc_frame *fp)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tstruct fc_frame_header *fh;\n\tstruct fc_seq_els_data rjt_data;\n\n\tfh = fc_frame_header_get(fp);\n\n\tFC_DEBUG_RPORT(\"Received PRLO request from port (%6x) \"\n\t\t       \"while in state %s\\n\", ntoh24(fh->fh_s_id),\n\t\t       fc_rport_state(rport));\n\n\trjt_data.fp = NULL;\n\trjt_data.reason = ELS_RJT_UNAB;\n\trjt_data.explan = ELS_EXPL_NONE;\n\tlport->tt.seq_els_rsp_send(sp, ELS_LS_RJT, &rjt_data);\n\tfc_frame_free(fp);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_login - Start the remote port login state machine\n * @rport: Fibre Channel remote port\n *\n * Locking Note: Called without the rport lock held. This\n * function will hold the rport lock, call an _enter_*\n * function and then unlock the rport.\n */\n", "func_signal": "int fc_rport_login(struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_DEBUG_RPORT(\"Login to port (%6x)\\n\", rport->port_id);\n\n\tfc_rport_enter_plogi(rport);\n\n\tmutex_unlock(&rdata->rp_mutex);\n\n\treturn 0;\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_enter_ready - The rport is ready\n * @rport: Fibre Channel remote port that is ready\n *\n * Locking Note: The rport lock is expected to be held before calling\n * this routine.\n */\n", "func_signal": "static void fc_rport_enter_ready(struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\n\tfc_rport_state_enter(rport, RPORT_ST_READY);\n\n\tFC_DEBUG_RPORT(\"Port (%6x) is Ready\\n\", rport->port_id);\n\n\trdata->event = RPORT_EV_CREATED;\n\tqueue_work(rport_event_queue, &rdata->event_work);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_recv_logo_req - Handle incoming Logout (LOGO) request\n * @rport: Fibre Channel remote port that initiated LOGO\n * @sp: current sequence in the LOGO exchange\n * @fp: LOGO request frame\n *\n * Locking Note: The rport lock is exected to be held before calling\n * this function.\n */\n", "func_signal": "static void fc_rport_recv_logo_req(struct fc_rport *rport, struct fc_seq *sp,\n\t\t\t\t   struct fc_frame *fp)", "code": "{\n\tstruct fc_frame_header *fh;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tfh = fc_frame_header_get(fp);\n\n\tFC_DEBUG_RPORT(\"Received LOGO request from port (%6x) \"\n\t\t       \"while in state %s\\n\", ntoh24(fh->fh_s_id),\n\t\t       fc_rport_state(rport));\n\n\trdata->event = RPORT_EV_LOGO;\n\tqueue_work(rport_event_queue, &rdata->event_work);\n\n\tlport->tt.seq_els_rsp_send(sp, ELS_LS_ACC, NULL);\n\tfc_frame_free(fp);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/*\n * These two functions convert virtual addresses to PCI addresses and PCI\n * addresses to virtual addresses.  Note that it is only legal to use these\n * on memory obtained via get_zeroed_page or kmalloc.\n */\n", "func_signal": "unsigned long __virt_to_bus(unsigned long res)", "code": "{\n\tWARN_ON(res < PAGE_OFFSET || res >= (unsigned long)high_memory);\n\n\treturn (res - PAGE_OFFSET) + (*CSR_PCISDRAMBASE & 0xfffffff0);\n}", "path": "arch\\arm\\mach-footbridge\\common.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_enter_rtv - Send Request Timeout Value (RTV) request to peer\n * @rport: Fibre Channel remote port to send RTV to\n *\n * Locking Note: The rport lock is expected to be held before calling\n * this routine.\n */\n", "func_signal": "static void fc_rport_enter_rtv(struct fc_rport *rport)", "code": "{\n\tstruct fc_frame *fp;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tFC_DEBUG_RPORT(\"Port (%6x) entered RTV state from %s state\\n\",\n\t\t       rport->port_id, fc_rport_state(rport));\n\n\tfc_rport_state_enter(rport, RPORT_ST_RTV);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_rtv));\n\tif (!fp) {\n\t\tfc_rport_error(rport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, rport, fp, ELS_RTV,\n\t\t\t\t     fc_rport_rtv_resp, rport, lport->e_d_tov))\n\t\tfc_rport_error(rport, fp);\n\telse\n\t\tget_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_els_rtv_resp - Request Timeout Value response handler\n * @sp: current sequence in the RTV exchange\n * @fp: response frame\n * @rp_arg: Fibre Channel remote port\n *\n * Many targets don't seem to support this.\n *\n * Locking Note: This function will be called without the rport lock\n * held, but it will lock, call an _enter_* function or fc_rport_error\n * and then unlock the rport.\n */\n", "func_signal": "static void fc_rport_rtv_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t      void *rp_arg)", "code": "{\n\tstruct fc_rport *rport = rp_arg;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tu8 op;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_DEBUG_RPORT(\"Received a RTV response from port (%6x)\\n\",\n\t\t       rport->port_id);\n\n\tif (rdata->rp_state != RPORT_ST_RTV) {\n\t\tFC_DBG(\"Received a RTV response, but in state %s\\n\",\n\t\t       fc_rport_state(rport));\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rport, fp);\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC) {\n\t\tstruct fc_els_rtv_acc *rtv;\n\t\tu32 toq;\n\t\tu32 tov;\n\n\t\trtv = fc_frame_payload_get(fp, sizeof(*rtv));\n\t\tif (rtv) {\n\t\t\ttoq = ntohl(rtv->rtv_toq);\n\t\t\ttov = ntohl(rtv->rtv_r_a_tov);\n\t\t\tif (tov == 0)\n\t\t\t\ttov = 1;\n\t\t\trdata->r_a_tov = tov;\n\t\t\ttov = ntohl(rtv->rtv_e_d_tov);\n\t\t\tif (toq & FC_ELS_RTV_EDRES)\n\t\t\t\ttov /= 1000000;\n\t\t\tif (tov == 0)\n\t\t\t\ttov = 1;\n\t\t\trdata->e_d_tov = tov;\n\t\t}\n\t}\n\n\tfc_rport_enter_ready(rport);\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\n\tput_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_enter_logo - Send Logout (LOGO) request to peer\n * @rport: Fibre Channel remote port to send LOGO to\n *\n * Locking Note: The rport lock is expected to be held before calling\n * this routine.\n */\n", "func_signal": "static void fc_rport_enter_logo(struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tFC_DEBUG_RPORT(\"Port (%6x) entered LOGO state from %s state\\n\",\n\t\t       rport->port_id, fc_rport_state(rport));\n\n\tfc_rport_state_enter(rport, RPORT_ST_LOGO);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_logo));\n\tif (!fp) {\n\t\tfc_rport_error(rport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, rport, fp, ELS_LOGO,\n\t\t\t\t  fc_rport_logo_resp, rport, lport->e_d_tov))\n\t\tfc_rport_error(rport, fp);\n\telse\n\t\tget_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_enter_plogi - Send Port Login (PLOGI) request to peer\n * @rport: Fibre Channel remote port to send PLOGI to\n *\n * Locking Note: The rport lock is expected to be held before calling\n * this routine.\n */\n", "func_signal": "static void fc_rport_enter_plogi(struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tFC_DEBUG_RPORT(\"Port (%6x) entered PLOGI state from %s state\\n\",\n\t\t       rport->port_id, fc_rport_state(rport));\n\n\tfc_rport_state_enter(rport, RPORT_ST_PLOGI);\n\n\trport->maxframe_size = FC_MIN_MAX_PAYLOAD;\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\n\tif (!fp) {\n\t\tfc_rport_error(rport, fp);\n\t\treturn;\n\t}\n\trdata->e_d_tov = lport->e_d_tov;\n\n\tif (!lport->tt.elsct_send(lport, rport, fp, ELS_PLOGI,\n\t\t\t\t  fc_rport_plogi_resp, rport, lport->e_d_tov))\n\t\tfc_rport_error(rport, fp);\n\telse\n\t\tget_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_plogi_recv_resp - Handle incoming ELS PLOGI response\n * @sp: current sequence in the PLOGI exchange\n * @fp: response frame\n * @rp_arg: Fibre Channel remote port\n *\n * Locking Note: This function will be called without the rport lock\n * held, but it will lock, call an _enter_* function or fc_rport_error\n * and then unlock the rport.\n */\n", "func_signal": "static void fc_rport_plogi_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *rp_arg)", "code": "{\n\tstruct fc_rport *rport = rp_arg;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_els_flogi *plp;\n\tunsigned int tov;\n\tu16 csp_seq;\n\tu16 cssp_seq;\n\tu8 op;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_DEBUG_RPORT(\"Received a PLOGI response from port (%6x)\\n\",\n\t\t       rport->port_id);\n\n\tif (rdata->rp_state != RPORT_ST_PLOGI) {\n\t\tFC_DBG(\"Received a PLOGI response, but in state %s\\n\",\n\t\t       fc_rport_state(rport));\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rport, fp);\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC &&\n\t    (plp = fc_frame_payload_get(fp, sizeof(*plp))) != NULL) {\n\t\trport->port_name = get_unaligned_be64(&plp->fl_wwpn);\n\t\trport->node_name = get_unaligned_be64(&plp->fl_wwnn);\n\n\t\ttov = ntohl(plp->fl_csp.sp_e_d_tov);\n\t\tif (ntohs(plp->fl_csp.sp_features) & FC_SP_FT_EDTR)\n\t\t\ttov /= 1000;\n\t\tif (tov > rdata->e_d_tov)\n\t\t\trdata->e_d_tov = tov;\n\t\tcsp_seq = ntohs(plp->fl_csp.sp_tot_seq);\n\t\tcssp_seq = ntohs(plp->fl_cssp[3 - 1].cp_con_seq);\n\t\tif (cssp_seq < csp_seq)\n\t\t\tcsp_seq = cssp_seq;\n\t\trdata->max_seq = csp_seq;\n\t\trport->maxframe_size =\n\t\t\tfc_plogi_get_maxframe(plp, lport->mfs);\n\n\t\t/*\n\t\t * If the rport is one of the well known addresses\n\t\t * we skip PRLI and RTV and go straight to READY.\n\t\t */\n\t\tif (rport->port_id >= FC_FID_DOM_MGR)\n\t\t\tfc_rport_enter_ready(rport);\n\t\telse\n\t\t\tfc_rport_enter_prli(rport);\n\t} else\n\t\tfc_rport_error(rport, fp);\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\n\tput_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_recv_req - Receive a request from a rport\n * @sp: current sequence in the PLOGI exchange\n * @fp: response frame\n * @rp_arg: Fibre Channel remote port\n *\n * Locking Note: Called without the rport lock held. This\n * function will hold the rport lock, call an _enter_*\n * function and then unlock the rport.\n */\n", "func_signal": "void fc_rport_recv_req(struct fc_seq *sp, struct fc_frame *fp,\n\t\t       struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tstruct fc_frame_header *fh;\n\tstruct fc_seq_els_data els_data;\n\tu8 op;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tels_data.fp = NULL;\n\tels_data.explan = ELS_EXPL_NONE;\n\tels_data.reason = ELS_RJT_NONE;\n\n\tfh = fc_frame_header_get(fp);\n\n\tif (fh->fh_r_ctl == FC_RCTL_ELS_REQ && fh->fh_type == FC_TYPE_ELS) {\n\t\top = fc_frame_payload_op(fp);\n\t\tswitch (op) {\n\t\tcase ELS_PLOGI:\n\t\t\tfc_rport_recv_plogi_req(rport, sp, fp);\n\t\t\tbreak;\n\t\tcase ELS_PRLI:\n\t\t\tfc_rport_recv_prli_req(rport, sp, fp);\n\t\t\tbreak;\n\t\tcase ELS_PRLO:\n\t\t\tfc_rport_recv_prlo_req(rport, sp, fp);\n\t\t\tbreak;\n\t\tcase ELS_LOGO:\n\t\t\tfc_rport_recv_logo_req(rport, sp, fp);\n\t\t\tbreak;\n\t\tcase ELS_RRQ:\n\t\t\tels_data.fp = fp;\n\t\t\tlport->tt.seq_els_rsp_send(sp, ELS_RRQ, &els_data);\n\t\t\tbreak;\n\t\tcase ELS_REC:\n\t\t\tels_data.fp = fp;\n\t\t\tlport->tt.seq_els_rsp_send(sp, ELS_REC, &els_data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tels_data.reason = ELS_RJT_UNSUP;\n\t\t\tlport->tt.seq_els_rsp_send(sp, ELS_LS_RJT, &els_data);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&rdata->rp_mutex);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_enter_prli - Send Process Login (PRLI) request to peer\n * @rport: Fibre Channel remote port to send PRLI to\n *\n * Locking Note: The rport lock is expected to be held before calling\n * this routine.\n */\n", "func_signal": "static void fc_rport_enter_prli(struct fc_rport *rport)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_frame *fp;\n\n\tFC_DEBUG_RPORT(\"Port (%6x) entered PRLI state from %s state\\n\",\n\t\t       rport->port_id, fc_rport_state(rport));\n\n\tfc_rport_state_enter(rport, RPORT_ST_PRLI);\n\n\tfp = fc_frame_alloc(lport, sizeof(*pp));\n\tif (!fp) {\n\t\tfc_rport_error(rport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, rport, fp, ELS_PRLI,\n\t\t\t\t  fc_rport_prli_resp, rport, lport->e_d_tov))\n\t\tfc_rport_error(rport, fp);\n\telse\n\t\tget_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_state_enter - Change the rport's state\n * @rport: The rport whose state should change\n * @new: The new state of the rport\n *\n * Locking Note: Called with the rport lock held\n */\n", "func_signal": "static void fc_rport_state_enter(struct fc_rport *rport,\n\t\t\t\t enum fc_rport_state new)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tif (rdata->rp_state != new)\n\t\trdata->retries = 0;\n\trdata->rp_state = new;\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_set_rport_loss_tmo - Set the remote port loss timeout in seconds.\n * @rport: Pointer to Fibre Channel remote port structure\n * @timeout: timeout in seconds\n */\n", "func_signal": "void fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)", "code": "{\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout + 5;\n\telse\n\t\trport->dev_loss_tmo = 30;\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_logo_resp - Logout (LOGO) response handler\n * @sp: current sequence in the LOGO exchange\n * @fp: response frame\n * @rp_arg: Fibre Channel remote port\n *\n * Locking Note: This function will be called without the rport lock\n * held, but it will lock, call an _enter_* function or fc_rport_error\n * and then unlock the rport.\n */\n", "func_signal": "static void fc_rport_logo_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t       void *rp_arg)", "code": "{\n\tstruct fc_rport *rport = rp_arg;\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tu8 op;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_DEBUG_RPORT(\"Received a LOGO response from port (%6x)\\n\",\n\t\t       rport->port_id);\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rport, fp);\n\t\tgoto err;\n\t}\n\n\tif (rdata->rp_state != RPORT_ST_LOGO) {\n\t\tFC_DEBUG_RPORT(\"Received a LOGO response, but in state %s\\n\",\n\t\t\t       fc_rport_state(rport));\n\t\tgoto out;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC) {\n\t\tfc_rport_enter_rtv(rport);\n\t} else {\n\t\tFC_DBG(\"Bad ELS response\\n\");\n\t\trdata->event = RPORT_EV_LOGO;\n\t\tqueue_work(rport_event_queue, &rdata->event_work);\n\t}\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\n\tput_device(&rport->dev);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_error - Handler for any errors\n * @rport: The fc_rport object\n * @fp: The frame pointer\n *\n * If the error was caused by a resource allocation failure\n * then wait for half a second and retry, otherwise retry\n * immediately.\n *\n * Locking Note: The rport lock is expected to be held before\n * calling this routine\n */\n", "func_signal": "static void fc_rport_error(struct fc_rport *rport, struct fc_frame *fp)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tunsigned long delay = 0;\n\n\tFC_DEBUG_RPORT(\"Error %ld in state %s, retries %d\\n\",\n\t\t       PTR_ERR(fp), fc_rport_state(rport), rdata->retries);\n\n\tif (!fp || PTR_ERR(fp) == -FC_EX_TIMEOUT) {\n\t\t/*\n\t\t * Memory allocation failure, or the exchange timed out.\n\t\t *  Retry after delay\n\t\t */\n\t\tif (rdata->retries < rdata->local_port->max_retry_count) {\n\t\t\trdata->retries++;\n\t\t\tif (!fp)\n\t\t\t\tdelay = msecs_to_jiffies(500);\n\t\t\tget_device(&rport->dev);\n\t\t\tschedule_delayed_work(&rdata->retry_work, delay);\n\t\t} else {\n\t\t\tswitch (rdata->rp_state) {\n\t\t\tcase RPORT_ST_PLOGI:\n\t\t\tcase RPORT_ST_PRLI:\n\t\t\tcase RPORT_ST_LOGO:\n\t\t\t\trdata->event = RPORT_EV_FAILED;\n\t\t\t\tqueue_work(rport_event_queue,\n\t\t\t\t\t   &rdata->event_work);\n\t\t\t\tbreak;\n\t\t\tcase RPORT_ST_RTV:\n\t\t\t\tfc_rport_enter_ready(rport);\n\t\t\t\tbreak;\n\t\t\tcase RPORT_ST_NONE:\n\t\t\tcase RPORT_ST_READY:\n\t\t\tcase RPORT_ST_INIT:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_recv_prli_req - Handle incoming Process Login (PRLI) request\n * @rport: Fibre Channel remote port that initiated PRLI\n * @sp: current sequence in the PRLI exchange\n * @fp: PRLI request frame\n *\n * Locking Note: The rport lock is exected to be held before calling\n * this function.\n */\n", "func_signal": "static void fc_rport_recv_prli_req(struct fc_rport *rport,\n\t\t\t\t   struct fc_seq *sp, struct fc_frame *rx_fp)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_exch *ep;\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_els_spp *rspp;\t/* request service param page */\n\tstruct fc_els_spp *spp;\t/* response spp */\n\tunsigned int len;\n\tunsigned int plen;\n\tenum fc_els_rjt_reason reason = ELS_RJT_UNAB;\n\tenum fc_els_rjt_explan explan = ELS_EXPL_NONE;\n\tenum fc_els_spp_resp resp;\n\tstruct fc_seq_els_data rjt_data;\n\tu32 f_ctl;\n\tu32 fcp_parm;\n\tu32 roles = FC_RPORT_ROLE_UNKNOWN;\n\trjt_data.fp = NULL;\n\n\tfh = fc_frame_header_get(rx_fp);\n\n\tFC_DEBUG_RPORT(\"Received PRLI request from port (%6x) \"\n\t\t       \"while in state %s\\n\", ntoh24(fh->fh_s_id),\n\t\t       fc_rport_state(rport));\n\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_READY:\n\t\treason = ELS_RJT_NONE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tlen = fr_len(rx_fp) - sizeof(*fh);\n\tpp = fc_frame_payload_get(rx_fp, sizeof(*pp));\n\tif (pp == NULL) {\n\t\treason = ELS_RJT_PROT;\n\t\texplan = ELS_EXPL_INV_LEN;\n\t} else {\n\t\tplen = ntohs(pp->prli.prli_len);\n\t\tif ((plen % 4) != 0 || plen > len) {\n\t\t\treason = ELS_RJT_PROT;\n\t\t\texplan = ELS_EXPL_INV_LEN;\n\t\t} else if (plen < len) {\n\t\t\tlen = plen;\n\t\t}\n\t\tplen = pp->prli.prli_spp_len;\n\t\tif ((plen % 4) != 0 || plen < sizeof(*spp) ||\n\t\t    plen > len || len < sizeof(*pp)) {\n\t\t\treason = ELS_RJT_PROT;\n\t\t\texplan = ELS_EXPL_INV_LEN;\n\t\t}\n\t\trspp = &pp->spp;\n\t}\n\tif (reason != ELS_RJT_NONE ||\n\t    (fp = fc_frame_alloc(lport, len)) == NULL) {\n\t\trjt_data.reason = reason;\n\t\trjt_data.explan = explan;\n\t\tlport->tt.seq_els_rsp_send(sp, ELS_LS_RJT, &rjt_data);\n\t} else {\n\t\tsp = lport->tt.seq_start_next(sp);\n\t\tWARN_ON(!sp);\n\t\tpp = fc_frame_payload_get(fp, len);\n\t\tWARN_ON(!pp);\n\t\tmemset(pp, 0, len);\n\t\tpp->prli.prli_cmd = ELS_LS_ACC;\n\t\tpp->prli.prli_spp_len = plen;\n\t\tpp->prli.prli_len = htons(len);\n\t\tlen -= sizeof(struct fc_els_prli);\n\n\t\t/*\n\t\t * Go through all the service parameter pages and build\n\t\t * response.  If plen indicates longer SPP than standard,\n\t\t * use that.  The entire response has been pre-cleared above.\n\t\t */\n\t\tspp = &pp->spp;\n\t\twhile (len >= plen) {\n\t\t\tspp->spp_type = rspp->spp_type;\n\t\t\tspp->spp_type_ext = rspp->spp_type_ext;\n\t\t\tspp->spp_flags = rspp->spp_flags & FC_SPP_EST_IMG_PAIR;\n\t\t\tresp = FC_SPP_RESP_ACK;\n\t\t\tif (rspp->spp_flags & FC_SPP_RPA_VAL)\n\t\t\t\tresp = FC_SPP_RESP_NO_PA;\n\t\t\tswitch (rspp->spp_type) {\n\t\t\tcase 0:\t/* common to all FC-4 types */\n\t\t\t\tbreak;\n\t\t\tcase FC_TYPE_FCP:\n\t\t\t\tfcp_parm = ntohl(rspp->spp_params);\n\t\t\t\tif (fcp_parm * FCP_SPPF_RETRY)\n\t\t\t\t\trdata->flags |= FC_RP_FLAGS_RETRY;\n\t\t\t\trport->supported_classes = FC_COS_CLASS3;\n\t\t\t\tif (fcp_parm & FCP_SPPF_INIT_FCN)\n\t\t\t\t\troles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\t\t\t\tif (fcp_parm & FCP_SPPF_TARG_FCN)\n\t\t\t\t\troles |= FC_RPORT_ROLE_FCP_TARGET;\n\t\t\t\trport->roles = roles;\n\n\t\t\t\tspp->spp_params =\n\t\t\t\t\thtonl(lport->service_params);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresp = FC_SPP_RESP_INVL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspp->spp_flags |= resp;\n\t\t\tlen -= plen;\n\t\t\trspp = (struct fc_els_spp *)((char *)rspp + plen);\n\t\t\tspp = (struct fc_els_spp *)((char *)spp + plen);\n\t\t}\n\n\t\t/*\n\t\t * Send LS_ACC.\t If this fails, the originator should retry.\n\t\t */\n\t\tf_ctl = FC_FC_EX_CTX | FC_FC_LAST_SEQ;\n\t\tf_ctl |= FC_FC_END_SEQ | FC_FC_SEQ_INIT;\n\t\tep = fc_seq_exch(sp);\n\t\tfc_fill_fc_hdr(fp, FC_RCTL_ELS_REP, ep->did, ep->sid,\n\t\t\t       FC_TYPE_ELS, f_ctl, 0);\n\t\tlport->tt.seq_send(lport, sp, fp);\n\n\t\t/*\n\t\t * Get lock and re-check state.\n\t\t */\n\t\tswitch (rdata->rp_state) {\n\t\tcase RPORT_ST_PRLI:\n\t\t\tfc_rport_enter_ready(rport);\n\t\t\tbreak;\n\t\tcase RPORT_ST_READY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfc_frame_free(rx_fp);\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_rport_recv_plogi_req - Handle incoming Port Login (PLOGI) request\n * @rport: Fibre Channel remote port that initiated PLOGI\n * @sp: current sequence in the PLOGI exchange\n * @fp: PLOGI request frame\n *\n * Locking Note: The rport lock is exected to be held before calling\n * this function.\n */\n", "func_signal": "static void fc_rport_recv_plogi_req(struct fc_rport *rport,\n\t\t\t\t    struct fc_seq *sp, struct fc_frame *rx_fp)", "code": "{\n\tstruct fc_rport_libfc_priv *rdata = rport->dd_data;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp = rx_fp;\n\tstruct fc_exch *ep;\n\tstruct fc_frame_header *fh;\n\tstruct fc_els_flogi *pl;\n\tstruct fc_seq_els_data rjt_data;\n\tu32 sid;\n\tu64 wwpn;\n\tu64 wwnn;\n\tenum fc_els_rjt_reason reject = 0;\n\tu32 f_ctl;\n\trjt_data.fp = NULL;\n\n\tfh = fc_frame_header_get(fp);\n\n\tFC_DEBUG_RPORT(\"Received PLOGI request from port (%6x) \"\n\t\t       \"while in state %s\\n\", ntoh24(fh->fh_s_id),\n\t\t       fc_rport_state(rport));\n\n\tsid = ntoh24(fh->fh_s_id);\n\tpl = fc_frame_payload_get(fp, sizeof(*pl));\n\tif (!pl) {\n\t\tFC_DBG(\"incoming PLOGI from %x too short\\n\", sid);\n\t\tWARN_ON(1);\n\t\t/* XXX TBD: send reject? */\n\t\tfc_frame_free(fp);\n\t\treturn;\n\t}\n\twwpn = get_unaligned_be64(&pl->fl_wwpn);\n\twwnn = get_unaligned_be64(&pl->fl_wwnn);\n\n\t/*\n\t * If the session was just created, possibly due to the incoming PLOGI,\n\t * set the state appropriately and accept the PLOGI.\n\t *\n\t * If we had also sent a PLOGI, and if the received PLOGI is from a\n\t * higher WWPN, we accept it, otherwise an LS_RJT is sent with reason\n\t * \"command already in progress\".\n\t *\n\t * XXX TBD: If the session was ready before, the PLOGI should result in\n\t * all outstanding exchanges being reset.\n\t */\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_INIT:\n\t\tFC_DEBUG_RPORT(\"incoming PLOGI from %6x wwpn %llx state INIT \"\n\t\t\t       \"- reject\\n\", sid, wwpn);\n\t\treject = ELS_RJT_UNSUP;\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tFC_DEBUG_RPORT(\"incoming PLOGI from %x in PLOGI state %d\\n\",\n\t\t\t       sid, rdata->rp_state);\n\t\tif (wwpn < lport->wwpn)\n\t\t\treject = ELS_RJT_INPROG;\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_READY:\n\t\tFC_DEBUG_RPORT(\"incoming PLOGI from %x in logged-in state %d \"\n\t\t\t       \"- ignored for now\\n\", sid, rdata->rp_state);\n\t\t/* XXX TBD - should reset */\n\t\tbreak;\n\tcase RPORT_ST_NONE:\n\tdefault:\n\t\tFC_DEBUG_RPORT(\"incoming PLOGI from %x in unexpected \"\n\t\t\t       \"state %d\\n\", sid, rdata->rp_state);\n\t\tbreak;\n\t}\n\n\tif (reject) {\n\t\trjt_data.reason = reject;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tlport->tt.seq_els_rsp_send(sp, ELS_LS_RJT, &rjt_data);\n\t\tfc_frame_free(fp);\n\t} else {\n\t\tfp = fc_frame_alloc(lport, sizeof(*pl));\n\t\tif (fp == NULL) {\n\t\t\tfp = rx_fp;\n\t\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\t\tlport->tt.seq_els_rsp_send(sp, ELS_LS_RJT, &rjt_data);\n\t\t\tfc_frame_free(fp);\n\t\t} else {\n\t\t\tsp = lport->tt.seq_start_next(sp);\n\t\t\tWARN_ON(!sp);\n\t\t\tfc_rport_set_name(rport, wwpn, wwnn);\n\n\t\t\t/*\n\t\t\t * Get session payload size from incoming PLOGI.\n\t\t\t */\n\t\t\trport->maxframe_size =\n\t\t\t\tfc_plogi_get_maxframe(pl, lport->mfs);\n\t\t\tfc_frame_free(rx_fp);\n\t\t\tfc_plogi_fill(lport, fp, ELS_LS_ACC);\n\n\t\t\t/*\n\t\t\t * Send LS_ACC.\t If this fails,\n\t\t\t * the originator should retry.\n\t\t\t */\n\t\t\tf_ctl = FC_FC_EX_CTX | FC_FC_LAST_SEQ;\n\t\t\tf_ctl |= FC_FC_END_SEQ | FC_FC_SEQ_INIT;\n\t\t\tep = fc_seq_exch(sp);\n\t\t\tfc_fill_fc_hdr(fp, FC_RCTL_ELS_REP, ep->did, ep->sid,\n\t\t\t\t       FC_TYPE_ELS, f_ctl, 0);\n\t\t\tlport->tt.seq_send(lport, sp, fp);\n\t\t\tif (rdata->rp_state == RPORT_ST_PLOGI)\n\t\t\t\tfc_rport_enter_prli(rport);\n\t\t}\n\t}\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/**\n * fc_plogi_get_maxframe - Get max payload from the common service parameters\n * @flp: FLOGI payload structure\n * @maxval: upper limit, may be less than what is in the service parameters\n */\n", "func_signal": "static unsigned int\nfc_plogi_get_maxframe(struct fc_els_flogi *flp, unsigned int maxval)", "code": "{\n\tunsigned int mfs;\n\n\t/*\n\t * Get max payload from the common service parameters and the\n\t * class 3 receive data field size.\n\t */\n\tmfs = ntohs(flp->fl_csp.sp_bb_data) & FC_SP_BB_DATA_MASK;\n\tif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\n\t\tmaxval = mfs;\n\tmfs = ntohs(flp->fl_cssp[3 - 1].cp_rdfs);\n\tif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\n\t\tmaxval = mfs;\n\treturn maxval;\n}", "path": "drivers\\scsi\\libfc\\fc_rport.c", "repo_name": "xsacha/i780-kernel", "stars": 4, "license": "other", "language": "c", "size": 63833}
{"docstring": "/*\n * DarwinBuildModifierMaps\n *      Use the keyMap field of keyboard info structure to populate\n *      the modMap and modifierKeycodes fields.\n */\n", "func_signal": "static void DarwinBuildModifierMaps(darwinKeyboardInfo *info)", "code": "{\n    int i;\n    KeySym *k;\n\n    memset(info->modMap, NoSymbol, sizeof(info->modMap));\n    memset(info->modifierKeycodes, 0, sizeof(info->modifierKeycodes));\n\n    for (i = 0; i < NUM_KEYCODES; i++) {\n        k = info->keyMap + i * GLYPHS_PER_KEY;\n\n        switch (*k) {\n            case XK_Shift_L:\n                info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;\n                info->modMap[MIN_KEYCODE + i] = ShiftMask;\n                break;\n\n            case XK_Shift_R:\n#ifdef NX_MODIFIERKEY_RSHIFT\n                info->modifierKeycodes[NX_MODIFIERKEY_RSHIFT][0] = i;\n#else\n                info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;\n#endif\n                info->modMap[MIN_KEYCODE + i] = ShiftMask;\n                break;\n\n            case XK_Control_L:\n                info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;\n                info->modMap[MIN_KEYCODE + i] = ControlMask;\n                break;\n\n            case XK_Control_R:\n#ifdef NX_MODIFIERKEY_RCONTROL\n                info->modifierKeycodes[NX_MODIFIERKEY_RCONTROL][0] = i;\n#else\n                info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;\n#endif\n                info->modMap[MIN_KEYCODE + i] = ControlMask;\n                break;\n\n            case XK_Caps_Lock:\n                info->modifierKeycodes[NX_MODIFIERKEY_ALPHALOCK][0] = i;\n                info->modMap[MIN_KEYCODE + i] = LockMask;\n                break;\n\n            case XK_Alt_L:\n                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;\n                info->modMap[MIN_KEYCODE + i] = Mod1Mask;\n                if(!quartzOptionSendsAlt)\n                    *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.\n                break;\n\n            case XK_Alt_R:\n#ifdef NX_MODIFIERKEY_RALTERNATE\n                info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;\n#else\n                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;\n#endif\n                if(!quartzOptionSendsAlt)\n                    *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.\n                info->modMap[MIN_KEYCODE + i] = Mod1Mask;\n                break;\n\n            case XK_Mode_switch:\n                ErrorF(\"DarwinBuildModifierMaps: XK_Mode_switch encountered, unable to determine side.\\n\");\n                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;\n#ifdef NX_MODIFIERKEY_RALTERNATE\n                info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;\n#endif\n                info->modMap[MIN_KEYCODE + i] = Mod1Mask;\n                break;\n\n            case XK_Meta_L:\n                info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;\n                info->modMap[MIN_KEYCODE + i] = Mod2Mask;\n                break;\n\n            case XK_Meta_R:\n#ifdef NX_MODIFIERKEY_RCOMMAND\n                info->modifierKeycodes[NX_MODIFIERKEY_RCOMMAND][0] = i;\n#else\n                info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;\n#endif\n                info->modMap[MIN_KEYCODE + i] = Mod2Mask;\n                break;\n\n            case XK_Num_Lock:\n                info->modMap[MIN_KEYCODE + i] = Mod3Mask;\n                break;\n        }\n    }\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinModifierStringToNXMask\n *      Returns 0 if string is not a known modifier.\n */\n", "func_signal": "int DarwinModifierStringToNXMask(const char *str, int separatelr)", "code": "{\n#ifdef NX_DEVICELSHIFTKEYMASK\n    if(separatelr) {\n        if (!strcasecmp(str, \"shift\"))    return NX_DEVICELSHIFTKEYMASK | NX_DEVICERSHIFTKEYMASK;\n        if (!strcasecmp(str, \"control\"))  return NX_DEVICELCTLKEYMASK | NX_DEVICERCTLKEYMASK;\n        if (!strcasecmp(str, \"option\"))   return NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;\n        if (!strcasecmp(str, \"alt\"))   return NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;\n        if (!strcasecmp(str, \"command\"))  return NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK;\n        if (!strcasecmp(str, \"lshift\"))   return NX_DEVICELSHIFTKEYMASK;\n        if (!strcasecmp(str, \"rshift\"))   return NX_DEVICERSHIFTKEYMASK;\n        if (!strcasecmp(str, \"lcontrol\")) return NX_DEVICELCTLKEYMASK;\n        if (!strcasecmp(str, \"rcontrol\")) return NX_DEVICERCTLKEYMASK;\n        if (!strcasecmp(str, \"loption\"))  return NX_DEVICELALTKEYMASK;\n        if (!strcasecmp(str, \"roption\"))  return NX_DEVICERALTKEYMASK;\n        if (!strcasecmp(str, \"lalt\"))  return NX_DEVICELALTKEYMASK;\n        if (!strcasecmp(str, \"ralt\"))  return NX_DEVICERALTKEYMASK;\n        if (!strcasecmp(str, \"lcommand\")) return NX_DEVICELCMDKEYMASK;\n        if (!strcasecmp(str, \"rcommand\")) return NX_DEVICERCMDKEYMASK;\n    } else {\n#endif\n        if (!strcasecmp(str, \"shift\"))    return NX_SHIFTMASK;\n        if (!strcasecmp(str, \"control\"))  return NX_CONTROLMASK;\n        if (!strcasecmp(str, \"option\"))   return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"alt\"))   return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"command\"))  return NX_COMMANDMASK;\n        if (!strcasecmp(str, \"lshift\"))   return NX_SHIFTMASK;\n        if (!strcasecmp(str, \"rshift\"))   return NX_SHIFTMASK;\n        if (!strcasecmp(str, \"lcontrol\")) return NX_CONTROLMASK;\n        if (!strcasecmp(str, \"rcontrol\")) return NX_CONTROLMASK;\n        if (!strcasecmp(str, \"loption\"))  return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"roption\"))  return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"lalt\"))  return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"ralt\"))  return NX_ALTERNATEMASK;\n        if (!strcasecmp(str, \"lcommand\")) return NX_COMMANDMASK;\n        if (!strcasecmp(str, \"rcommand\")) return NX_COMMANDMASK;\n#ifdef NX_DEVICELSHIFTKEYMASK\n    }\n#endif\n    if (!strcasecmp(str, \"lock\"))     return NX_ALPHASHIFTMASK;\n    if (!strcasecmp(str, \"fn\"))       return NX_SECONDARYFNMASK;\n    if (!strcasecmp(str, \"help\"))     return NX_HELPMASK;\n    if (!strcasecmp(str, \"numlock\"))  return NX_NUMERICPADMASK;\n    return 0;\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinModifierNXKeycodeToNXKey\n *      Returns -1 if keycode+side is not a modifier key\n *      outSide may be NULL, else it gets 0 for left and 1 for right.\n */\n", "func_signal": "int DarwinModifierNXKeycodeToNXKey(unsigned char keycode, int *outSide)", "code": "{\n    int key, side;\n\n    keycode += MIN_KEYCODE;\n\n    // search modifierKeycodes for this keycode+side\n    pthread_mutex_lock(&keyInfo_mutex);\n    for (key = 0; key < NX_NUMMODIFIERS; key++) {\n        for (side = 0; side <= 1; side++) {\n            if (keyInfo.modifierKeycodes[key][side] == keycode) break;\n        }\n    }\n    pthread_mutex_unlock(&keyInfo_mutex);\n\n    if (key == NX_NUMMODIFIERS) {\n        return -1;\n    }\n    if (outSide) *outSide = side;\n\n    return key;\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*-\n *-----------------------------------------------------------------------\n * RegionSetExtents --\n *\tReset the extents of a region to what they should be. Called by\n *\tSubtract and Intersect as they can't figure it out along the\n *\tway or do so easily, as Union can.\n *\n * Results:\n *\tNone.\n *\n * Side Effects:\n *\tThe region's 'extents' structure is overwritten.\n *\n *-----------------------------------------------------------------------\n */\n", "func_signal": "static void\nRegionSetExtents (RegionPtr pReg)", "code": "{\n    BoxPtr pBox, pBoxEnd;\n\n    if (!pReg->data)\n\treturn;\n    if (!pReg->data->size)\n    {\n\tpReg->extents.x2 = pReg->extents.x1;\n\tpReg->extents.y2 = pReg->extents.y1;\n\treturn;\n    }\n\n    pBox = RegionBoxptr(pReg);\n    pBoxEnd = RegionEnd(pReg);\n\n    /*\n     * Since pBox is the first rectangle in the region, it must have the\n     * smallest y1 and since pBoxEnd is the last rectangle in the region,\n     * it must have the largest y2, because of banding. Initialize x1 and\n     * x2 from  pBox and pBoxEnd, resp., as good things to initialize them\n     * to...\n     */\n    pReg->extents.x1 = pBox->x1;\n    pReg->extents.y1 = pBox->y1;\n    pReg->extents.x2 = pBoxEnd->x2;\n    pReg->extents.y2 = pBoxEnd->y2;\n\n    assert(pReg->extents.y1 < pReg->extents.y2);\n    while (pBox <= pBoxEnd) {\n\tif (pBox->x1 < pReg->extents.x1)\n\t    pReg->extents.x1 = pBox->x1;\n\tif (pBox->x2 > pReg->extents.x2)\n\t    pReg->extents.x2 = pBox->x2;\n\tpBox++;\n    };\n\n    assert(pReg->extents.x1 < pReg->extents.x2);\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * Create a full screen window\n */\n", "func_signal": "Bool\nwinCreateBoundingWindowFullScreen (ScreenPtr pScreen)", "code": "{\n  winScreenPriv(pScreen);\n  winScreenInfo\t\t*pScreenInfo = pScreenPriv->pScreenInfo;\n  int\t\t\tiX = pScreenInfo->dwInitialX;\n  int\t\t\tiY = pScreenInfo->dwInitialY;\n  int\t\t\tiWidth = pScreenInfo->dwWidth;\n  int\t\t\tiHeight = pScreenInfo->dwHeight;\n  HWND\t\t\t*phwnd = &pScreenPriv->hwndScreen;\n  WNDCLASSEX\t\twc;\n  char\t\t\tszTitle[256];\n\n#if CYGDEBUG\n  winDebug (\"winCreateBoundingWindowFullScreen\\n\");\n#endif\n\n  /* Setup our window class */\n  wc.cbSize=sizeof(WNDCLASSEX);\n  wc.style = CS_HREDRAW | CS_VREDRAW;\n  wc.lpfnWndProc = winWindowProc;\n  wc.cbClsExtra = 0;\n  wc.cbWndExtra = 0;\n  wc.hInstance = g_hInstance;\n  wc.hIcon = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,\n\t\tGetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);\n  wc.hCursor = 0;\n  wc.hbrBackground = 0;\n  wc.lpszMenuName = NULL;\n  wc.lpszClassName = WINDOW_CLASS;\n  wc.hIconSm = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,\n\t\tGetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);\n  RegisterClassEx (&wc);\n\n  /* Set display and screen-specific tooltip text */\n  if (g_pszQueryHost != NULL)\n    snprintf (szTitle,\n\t    sizeof (szTitle),\n\t    WINDOW_TITLE_XDMCP,\n\t    g_pszQueryHost,\n\t    display,\n\t    (int) pScreenInfo->dwScreen);\n  else    \n    snprintf (szTitle,\n\t    sizeof (szTitle),\n\t    WINDOW_TITLE,\n\t    display, \n\t    (int) pScreenInfo->dwScreen);\n\n  /* Create the window */\n  *phwnd = CreateWindowExA (0,\t\t\t/* Extended styles */\n\t\t\t    WINDOW_CLASS,\t/* Class name */\n\t\t\t    szTitle,\t\t/* Window name */\n\t\t\t    WS_POPUP,\n\t\t\t    iX,\t\t\t/* Horizontal position */\n\t\t\t    iY,\t\t\t/* Vertical position */\n\t\t\t    iWidth,\t\t/* Right edge */ \n\t\t\t    iHeight,\t\t/* Bottom edge */\n\t\t\t    (HWND) NULL,\t/* No parent or owner window */\n\t\t\t    (HMENU) NULL,\t/* No menu */\n\t\t\t    GetModuleHandle (NULL),/* Instance handle */\n\t\t\t    pScreenPriv);\t/* ScreenPrivates */\n\n  /* Branch on the server engine */\n  switch (pScreenInfo->dwEngine)\n    {\n#ifdef XWIN_NATIVEGDI\n    case WIN_SERVER_SHADOW_GDI:\n      /* Show the window */\n      ShowWindow (*phwnd, SW_SHOWMAXIMIZED);\n      break;\n#endif\n\n    default:\n      /* Hide the window */\n      ShowWindow (*phwnd, SW_SHOWNORMAL);\n      break;\n    }\n\n  /* Send first paint message */\n  UpdateWindow (*phwnd);\n\n  /* Attempt to bring our window to the top of the display */\n  BringWindowToTop (*phwnd);\n\n  return TRUE;\n}", "path": "hw\\xwin\\wincreatewnd.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*-\n *-----------------------------------------------------------------------\n * RegionUnionO --\n *\tHandle an overlapping band for the union operation. Picks the\n *\tleft-most rectangle each time and merges it into the region.\n *\n * Results:\n *\tTRUE if successful.\n *\n * Side Effects:\n *\tpReg is overwritten.\n *\tpOverlap is set to TRUE if any boxes overlap.\n *\n *-----------------------------------------------------------------------\n */\n", "func_signal": "static Bool\nRegionUnionO (\n    RegionPtr\tpReg,\n    BoxPtr\tr1,\n    BoxPtr  \tr1End,\n    BoxPtr\tr2,\n    BoxPtr  \tr2End,\n    short\ty1,\n    short\ty2,\n    Bool\t*pOverlap)", "code": "{\n    BoxPtr     pNextRect;\n    int        x1;     /* left and right side of current union */\n    int        x2;\n\n    assert (y1 < y2);\n    assert(r1 != r1End && r2 != r2End);\n\n    pNextRect = RegionTop(pReg);\n\n    /* Start off current rectangle */\n    if (r1->x1 < r2->x1)\n    {\n\tx1 = r1->x1;\n\tx2 = r1->x2;\n\tr1++;\n    }\n    else\n    {\n\tx1 = r2->x1;\n\tx2 = r2->x2;\n\tr2++;\n    }\n    while (r1 != r1End && r2 != r2End)\n    {\n\tif (r1->x1 < r2->x1) MERGERECT(r1) else MERGERECT(r2);\n    }\n\n    /* Finish off whoever (if any) is left */\n    if (r1 != r1End)\n    {\n\tdo\n\t{\n\t    MERGERECT(r1);\n\t} while (r1 != r1End);\n    }\n    else if (r2 != r2End)\n    {\n\tdo\n\t{\n\t    MERGERECT(r2);\n\t} while (r2 != r2End);\n    }\n    \n    /* Add current rectangle */\n    NEWRECT(pReg, pNextRect, x1, y1, x2, y2);\n\n    return TRUE;\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/* Set the repeat rates based on global preferences and keycodes for modifiers.\n * Precondition: Has the keyInfo_mutex lock.\n */\n", "func_signal": "static void DarwinKeyboardSetRepeat(DeviceIntPtr pDev, int initialKeyRepeatValue, int keyRepeatValue)", "code": "{\n    if(initialKeyRepeatValue == 300000) { // off\n        /* Turn off repeats globally */\n        XkbSetRepeatKeys(pDev, -1, AutoRepeatModeOff);\n    } else {\n        int i;\n        XkbControlsPtr      ctrl;\n        XkbControlsRec      old;\n\n        /* Turn on repeats globally */\n        XkbSetRepeatKeys(pDev, -1, AutoRepeatModeOn);\n        \n        /* Setup the bit mask for individual key repeats */\n        ctrl = pDev->key->xkbInfo->desc->ctrls;\n        old= *ctrl;\n        \n        ctrl->repeat_delay = initialKeyRepeatValue * 15;\n        ctrl->repeat_interval = keyRepeatValue * 15;\n\n        /* Turn off key-repeat for modifier keys, on for others */\n        /* First set them all on */\n        for(i=0; i < XkbPerKeyBitArraySize; i++)\n            ctrl->per_key_repeat[i] = -1;\n\n        /* Now turn off the modifiers */\n        for(i=0; i < 32; i++) {\n            unsigned char keycode;\n            \n            keycode = keyInfo.modifierKeycodes[i][0];\n            if(keycode)\n                ClearBit(ctrl->per_key_repeat, keycode + MIN_KEYCODE);\n\n            keycode = keyInfo.modifierKeycodes[i][1];\n            if(keycode)\n                ClearBit(ctrl->per_key_repeat, keycode + MIN_KEYCODE);\n        }\n\n        /* Hurray for data duplication */\n        if (pDev->kbdfeed)\n            memcpy(pDev->kbdfeed->ctrl.autoRepeats, ctrl->per_key_repeat, XkbPerKeyBitArraySize);\n\n        //fprintf(stderr, \"per_key_repeat =\\n\");\n        //for(i=0; i < XkbPerKeyBitArraySize; i++)\n        //    fprintf(stderr, \"%02x%s\", ctrl->per_key_repeat[i], (i + 1) & 7 ? \"\" : \"\\n\");\n\n        /* And now we notify the puppies about the changes */\n        XkbDDXChangeControls(pDev, &old, ctrl);\n    }\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*****************************************************************\n *   RegionCreate(rect, size)\n *     This routine does a simple malloc to make a structure of\n *     REGION of \"size\" number of rectangles.\n *****************************************************************/\n", "func_signal": "RegionPtr\nRegionCreate(BoxPtr rect, int size)", "code": "{\n    RegionPtr pReg;\n   \n    pReg = (RegionPtr)malloc(sizeof(RegionRec));\n    if (!pReg)\n\treturn &RegionBrokenRegion;\n\n    RegionInit (pReg, rect, size);\n    \n    return pReg;\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * Adjust the client area so that any auto-hide toolbars\n * will work correctly.\n */\n", "func_signal": "static Bool\nwinAdjustForAutoHide (RECT *prcWorkArea)", "code": "{\n  APPBARDATA\t\tabd;\n  HWND\t\t\thwndAutoHide;\n\n  winDebug (\"winAdjustForAutoHide - Original WorkArea: %d %d %d %d\\n\",\n\t  (int) prcWorkArea->top, (int) prcWorkArea->left,\n\t  (int) prcWorkArea->bottom, (int) prcWorkArea->right);\n\n  /* Find out if the Windows taskbar is set to auto-hide */\n  ZeroMemory (&abd, sizeof (abd));\n  abd.cbSize = sizeof (abd);\n  if (SHAppBarMessage (ABM_GETSTATE, &abd) & ABS_AUTOHIDE)\n    winDebug (\"winAdjustForAutoHide - Taskbar is auto hide\\n\");\n\n  /* Look for a TOP auto-hide taskbar */\n  abd.uEdge = ABE_TOP;\n  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);\n  if (hwndAutoHide != NULL)\n    {\n      winDebug (\"winAdjustForAutoHide - Found TOP auto-hide taskbar\\n\");\n      prcWorkArea->top += 1;\n    }\n\n  /* Look for a LEFT auto-hide taskbar */\n  abd.uEdge = ABE_LEFT;\n  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);\n  if (hwndAutoHide != NULL)\n    {\n      winDebug (\"winAdjustForAutoHide - Found LEFT auto-hide taskbar\\n\");\n      prcWorkArea->left += 1;\n    }\n\n  /* Look for a BOTTOM auto-hide taskbar */\n  abd.uEdge = ABE_BOTTOM;\n  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);\n  if (hwndAutoHide != NULL)\n    {\n      winDebug (\"winAdjustForAutoHide - Found BOTTOM auto-hide taskbar\\n\");\n      prcWorkArea->bottom -= 1;\n    }\n\n  /* Look for a RIGHT auto-hide taskbar */\n  abd.uEdge = ABE_RIGHT;\n  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);\n  if (hwndAutoHide != NULL)\n    {\n      winDebug (\"winAdjustForAutoHide - Found RIGHT auto-hide taskbar\\n\");\n      prcWorkArea->right -= 1;\n    }\n\n  winDebug (\"winAdjustForAutoHide - Adjusted WorkArea: %d %d %d %d\\n\",\n\t  (int) prcWorkArea->top, (int) prcWorkArea->left,\n\t  (int) prcWorkArea->bottom, (int) prcWorkArea->right);\n  \n#if 0\n  /* Obtain the task bar window dimensions */\n  abd.hWnd = hwndAutoHide;\n  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETTASKBARPOS, &abd);\n  winDebug (\"hwndAutoHide %08x abd.hWnd %08x %d %d %d %d\\n\",\n\t  hwndAutoHide, abd.hWnd,\n\t  abd.rc.top, abd.rc.left, abd.rc.bottom, abd.rc.right);\n#endif\n\n  return TRUE;\n}", "path": "hw\\xwin\\wincreatewnd.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * Create our primary Windows display window\n */\n", "func_signal": "Bool\nwinCreateBoundingWindowWindowed (ScreenPtr pScreen)", "code": "{\n  winScreenPriv(pScreen);\n  winScreenInfo\t\t*pScreenInfo = pScreenPriv->pScreenInfo;\n  int\t\t\tiWidth = pScreenInfo->dwUserWidth;\n  int\t\t\tiHeight = pScreenInfo->dwUserHeight;\n  int                   iPosX;\n  int                   iPosY;\n  HWND\t\t\t*phwnd = &pScreenPriv->hwndScreen;\n  WNDCLASSEX\t\twc;\n  RECT\t\t\trcClient, rcWorkArea;\n  DWORD\t\t\tdwWindowStyle;\n  BOOL\t\t\tfForceShowWindow = FALSE;\n  char\t\t\tszTitle[256];\n  \n  winDebug (\"winCreateBoundingWindowWindowed - User w: %d h: %d\\n\",\n\t  (int) pScreenInfo->dwUserWidth, (int) pScreenInfo->dwUserHeight);\n  winDebug (\"winCreateBoundingWindowWindowed - Current w: %d h: %d\\n\",\n\t  (int) pScreenInfo->dwWidth, (int) pScreenInfo->dwHeight);\n\n  /* Set the common window style flags */\n  dwWindowStyle = WS_OVERLAPPED | WS_SYSMENU | WS_MINIMIZEBOX;\n  \n  /* Decorated or undecorated window */\n  if (pScreenInfo->fDecoration\n#ifdef XWIN_MULTIWINDOWEXTWM\n      && !pScreenInfo->fMWExtWM\n#endif\n      && !pScreenInfo->fRootless\n#ifdef XWIN_MULTIWINDOW\n      && !pScreenInfo->fMultiWindow\n#endif\n      )\n    {\n        /* Try to handle startup via run.exe. run.exe instructs Windows to \n         * hide all created windows. Detect this case and make sure the \n         * window is shown nevertheless */\n        STARTUPINFO   startupInfo;\n        GetStartupInfo(&startupInfo);\n        if (startupInfo.dwFlags & STARTF_USESHOWWINDOW && \n                startupInfo.wShowWindow == SW_HIDE)\n        {\n          fForceShowWindow = TRUE;\n        } \n        dwWindowStyle |= WS_CAPTION;\n        if (pScreenInfo->fScrollbars)\n            dwWindowStyle |= WS_THICKFRAME | WS_MAXIMIZEBOX;\n    }\n  else\n    dwWindowStyle |= WS_POPUP;\n\n  /* Setup our window class */\n  wc.cbSize=sizeof(WNDCLASSEX);\n  wc.style = CS_HREDRAW | CS_VREDRAW;\n  wc.lpfnWndProc = winWindowProc;\n  wc.cbClsExtra = 0;\n  wc.cbWndExtra = 0;\n  wc.hInstance = g_hInstance;\n  wc.hIcon = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,\n\t\tGetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);\n  wc.hCursor = 0;\n  wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);\n  wc.lpszMenuName = NULL;\n  wc.lpszClassName = WINDOW_CLASS;\n  wc.hIconSm = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,\n\t\tGetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);\n  RegisterClassEx (&wc);\n\n  /* Get size of work area */\n  winGetWorkArea (&rcWorkArea, pScreenInfo);\n\n  /* Adjust for auto-hide taskbars */\n  winAdjustForAutoHide (&rcWorkArea);\n\n  /* Did the user specify a position? */\n  if (pScreenInfo->fUserGavePosition)\n    {\n      iPosX = pScreenInfo->dwInitialX;\n      iPosY = pScreenInfo->dwInitialY;\n    }\n  else\n    {\n      iPosX = rcWorkArea.left;\n      iPosY = rcWorkArea.top;\n    }\n\n  /* Did the user specify a height and width? */\n  if (pScreenInfo->fUserGaveHeightAndWidth)\n    {\n      /* User gave a desired height and width, try to accomodate */\n#if CYGDEBUG\n      winDebug (\"winCreateBoundingWindowWindowed - User gave height \"\n\t      \"and width\\n\");\n#endif\n      \n      /* Adjust the window width and height for borders and title bar */\n      if (pScreenInfo->fDecoration\n#ifdef XWIN_MULTIWINDOWEXTWM\n\t  && !pScreenInfo->fMWExtWM\n#endif\n\t  && !pScreenInfo->fRootless\n#ifdef XWIN_MULTIWINDOW\n\t  && !pScreenInfo->fMultiWindow\n#endif\n\t  )\n\t{\n#if CYGDEBUG\n\t  winDebug (\"winCreateBoundingWindowWindowed - Window has decoration\\n\");\n#endif\n\t  /* Are we using scrollbars? */\n\t  if (pScreenInfo->fScrollbars)\n\t    {\n#if CYGDEBUG\n\t      winDebug (\"winCreateBoundingWindowWindowed - Window has \"\n\t\t      \"scrollbars\\n\");\n#endif\n\n\t      iWidth += 2 * GetSystemMetrics (SM_CXSIZEFRAME);\n\t      iHeight += 2 * GetSystemMetrics (SM_CYSIZEFRAME) \n\t\t+ GetSystemMetrics (SM_CYCAPTION);\n\t    }\n\t  else\n\t    {\n#if CYGDEBUG\n\t      winDebug (\"winCreateBoundingWindowWindowed - Window does not have \"\n\t\t      \"scrollbars\\n\");\n#endif\n\n\t      iWidth += 2 * GetSystemMetrics (SM_CXFIXEDFRAME);\n\t      iHeight += 2 * GetSystemMetrics (SM_CYFIXEDFRAME) \n\t\t+ GetSystemMetrics (SM_CYCAPTION);\n\t    }\n\t}\n    }\n  else\n    {\n      /* By default, we are creating a window that is as large as possible */\n#if CYGDEBUG\n      winDebug (\"winCreateBoundingWindowWindowed - User did not give \"\n\t      \"height and width\\n\");\n#endif\n      /* Defaults are wrong if we have multiple monitors */\n      if (pScreenInfo->fMultipleMonitors)\n\t{\n\t  iWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);\n\t  iHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);\n\t}\n    }\n\n  /* Clean up the scrollbars flag, if necessary */\n  if ((!pScreenInfo->fDecoration\n#ifdef XWIN_MULTIWINDOWEXTWM\n       || pScreenInfo->fMWExtWM\n#endif\n       || pScreenInfo->fRootless\n#ifdef XWIN_MULTIWINDOW\n       || pScreenInfo->fMultiWindow\n#endif\n       )\n      && pScreenInfo->fScrollbars)\n    {\n      /* We cannot have scrollbars if we do not have a window border */\n      pScreenInfo->fScrollbars = FALSE;\n    }\n \n  if (TRUE \n#ifdef XWIN_MULTIWINDOWEXTWM\n       && !pScreenInfo->fMWExtWM\n#endif\n#ifdef XWIN_MULTIWINDOW\n       && !pScreenInfo->fMultiWindow\n#endif\n     )\n    {\n      /* Trim window width to fit work area */\n      if (iWidth > (rcWorkArea.right - rcWorkArea.left))\n        iWidth = rcWorkArea.right - rcWorkArea.left;\n  \n      /* Trim window height to fit work area */\n      if (iHeight >= (rcWorkArea.bottom - rcWorkArea.top))\n        iHeight = rcWorkArea.bottom - rcWorkArea.top;\n  \n#if CYGDEBUG\n      winDebug (\"winCreateBoundingWindowWindowed - Adjusted width: %d \"\\\n\t      \"height: %d\\n\",\n    \t  iWidth, iHeight);\n#endif\n    }\n\n  /* Set display and screen-specific tooltip text */\n  if (g_pszQueryHost != NULL)\n    snprintf (szTitle,\n\t    sizeof (szTitle),\n\t    WINDOW_TITLE_XDMCP,\n\t    g_pszQueryHost,\n\t    display,\n\t    (int) pScreenInfo->dwScreen);\n  else    \n    snprintf (szTitle,\n\t    sizeof (szTitle),\n\t    WINDOW_TITLE,\n\t    display, \n\t    (int) pScreenInfo->dwScreen);\n\n  /* Create the window */\n  *phwnd = CreateWindowExA (0,\t\t\t/* Extended styles */\n\t\t\t    WINDOW_CLASS,\t/* Class name */\n\t\t\t    szTitle,\t\t/* Window name */\n\t\t\t    dwWindowStyle,\n\t\t\t    iPosX,\t        /* Horizontal position */\n\t\t\t    iPosY,\t        /* Vertical position */\n\t\t\t    iWidth,\t\t/* Right edge */\n\t\t\t    iHeight,\t\t/* Bottom edge */\n\t\t\t    (HWND) NULL,\t/* No parent or owner window */\n\t\t\t    (HMENU) NULL,\t/* No menu */\n\t\t\t    GetModuleHandle (NULL),/* Instance handle */\n\t\t\t    pScreenPriv);\t/* ScreenPrivates */\n  if (*phwnd == NULL)\n    {\n      ErrorF (\"winCreateBoundingWindowWindowed - CreateWindowEx () failed\\n\");\n      return FALSE;\n    }\n\n#if CYGDEBUG\n  winDebug (\"winCreateBoundingWindowWindowed - CreateWindowEx () returned\\n\");\n#endif\n\n  if (fForceShowWindow)\n  {\n      ErrorF(\"winCreateBoundingWindowWindowed - Setting normal windowstyle\\n\");\n      ShowWindow(*phwnd, SW_SHOW);      \n  }\n\n  /* Get the client area coordinates */\n  if (!GetClientRect (*phwnd, &rcClient))\n    {\n      ErrorF (\"winCreateBoundingWindowWindowed - GetClientRect () \"\n\t      \"failed\\n\");\n      return FALSE;\n    }\n\n  winDebug (\"winCreateBoundingWindowWindowed - WindowClient \"\n\t  \"w %ld h %ld r %ld l %ld b %ld t %ld\\n\",\n\t  rcClient.right - rcClient.left,\n\t  rcClient.bottom - rcClient.top,\n\t  rcClient.right, rcClient.left,\n\t  rcClient.bottom, rcClient.top);\n  \n  /* We adjust the visual size if the user did not specify it */\n  if (!(pScreenInfo->fScrollbars && pScreenInfo->fUserGaveHeightAndWidth))\n    {\n      /*\n       * User did not give a height and width with scrollbars enabled,\n       * so we will resize the underlying visual to be as large as\n       * the initial view port (page size).  This way scrollbars will\n       * not appear until the user shrinks the window, if they ever do.\n       *\n       * NOTE: We have to store the viewport size here because\n       * the user may have an autohide taskbar, which would\n       * cause the viewport size to be one less in one dimension\n       * than the viewport size that we calculated by subtracting\n       * the size of the borders and caption.\n       */\n      pScreenInfo->dwWidth = rcClient.right - rcClient.left;\n      pScreenInfo->dwHeight = rcClient.bottom - rcClient.top;\n    }\n\n#if 0\n  /*\n   * NOTE: For the uninitiated, the page size is the number of pixels\n   * that we can display in the x or y direction at a time and the\n   * range is the total number of pixels in the x or y direction that we\n   * have available to display.  In other words, the page size is the\n   * size of the window area minus the space the caption, borders, and\n   * scrollbars (if any) occupy, and the range is the size of the\n   * underlying X visual.  Notice that, contrary to what some of the\n   * MSDN Library arcticles lead you to believe, the windows\n   * ``client area'' size does not include the scrollbars.  In other words,\n   * the whole client area size that is reported to you is drawable by\n   * you; you do not have to subtract the size of the scrollbars from\n   * the client area size, and if you did it would result in the size\n   * of the scrollbars being double counted.\n   */\n\n  /* Setup scrollbar page and range, if scrollbars are enabled */\n  if (pScreenInfo->fScrollbars)\n    {\n      SCROLLINFO\t\tsi;\n      \n      /* Initialize the scrollbar info structure */\n      si.cbSize = sizeof (si);\n      si.fMask = SIF_RANGE | SIF_PAGE;\n      si.nMin = 0;\n      \n      /* Setup the width range and page size */\n      si.nMax = pScreenInfo->dwWidth - 1;\n      si.nPage = rcClient.right - rcClient.left;\n      winDebug (\"winCreateBoundingWindowWindowed - HORZ nMax: %d nPage :%d\\n\",\n\t      si.nMax, si.nPage);\n      SetScrollInfo (*phwnd, SB_HORZ, &si, TRUE);\n      \n      /* Setup the height range and page size */\n      si.nMax = pScreenInfo->dwHeight - 1;\n      si.nPage = rcClient.bottom - rcClient.top;\n      winDebug (\"winCreateBoundingWindowWindowed - VERT nMax: %d nPage :%d\\n\",\n\t      si.nMax, si.nPage);\n      SetScrollInfo (*phwnd, SB_VERT, &si, TRUE);\n    }\n#endif\n\n  /* Show the window */\n  if (FALSE\n#ifdef XWIN_MULTIWINDOWEXTWM\n      || pScreenInfo->fMWExtWM\n#endif\n#ifdef XWIN_MULTIWINDOW\n      || pScreenInfo->fMultiWindow\n#endif\n      )\n    {\n#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)\n      pScreenPriv->fRootWindowShown = FALSE;\n#endif\n      ShowWindow (*phwnd, SW_HIDE);\n    }\n  else\n    ShowWindow (*phwnd, SW_SHOWNORMAL);\n  if (!UpdateWindow (*phwnd))\n    {\n      ErrorF (\"winCreateBoundingWindowWindowed - UpdateWindow () failed\\n\");\n      return FALSE;\n    }\n  \n  /* Attempt to bring our window to the top of the display */\n  if (TRUE\n#ifdef XWIN_MULTIWINDOWEXTWM\n      && !pScreenInfo->fMWExtWM\n#endif\n      && !pScreenInfo->fRootless\n#ifdef XWIN_MULTIWINDOW\n      && !pScreenInfo->fMultiWindow\n#endif\n      )\n    {\n      if (!BringWindowToTop (*phwnd))\n\t{\n\t  ErrorF (\"winCreateBoundingWindowWindowed - BringWindowToTop () \"\n\t\t  \"failed\\n\");\n\t  return FALSE;\n\t}\n    }\n\n#ifdef XWIN_NATIVEGDI\n  /* Paint window background blue */\n  if (pScreenInfo->dwEngine == WIN_SERVER_NATIVE_GDI)\n    winPaintBackground (*phwnd, RGB (0x00, 0x00, 0xFF));\n#endif\n\n  winDebug (\"winCreateBoundingWindowWindowed -  Returning\\n\");\n\n  return TRUE;\n}", "path": "hw\\xwin\\wincreatewnd.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinModifierNXKeyToNXKeycode\n *      Return the keycode for an NX_MODIFIERKEY_* modifier.\n *      side = 0 for left or 1 for right.\n *      Returns 0 if key+side is not a known modifier.\n */\n", "func_signal": "int DarwinModifierNXKeyToNXKeycode(int key, int side)", "code": "{\n    int retval;\n    pthread_mutex_lock(&keyInfo_mutex);\n    retval = keyInfo.modifierKeycodes[key][side];\n    pthread_mutex_unlock(&keyInfo_mutex);\n\n    return retval;\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n    Clip a list of scanlines to a region.  The caller has allocated the\n    space.  FSorted is non-zero if the scanline origins are in ascending\n    order.\n    returns the number of new, clipped scanlines.\n*/\n", "func_signal": "int\nRegionClipSpans(\n    RegionPtr\tprgnDst,\n    DDXPointPtr ppt,\n    int\t    \t*pwidth,\n    int\t\tnspans,\n    DDXPointPtr\tpptNew,\n    int\t\t*pwidthNew,\n    int\t\tfSorted)", "code": "{\n    DDXPointPtr pptLast;\n    int\t*pwidthNewStart;\t/* the vengeance of Xerox! */\n    int\ty, x1, x2;\n    int\tnumRects;\n\n    good(prgnDst);\n    pptLast = ppt + nspans;\n    pwidthNewStart = pwidthNew;\n\n    if (!prgnDst->data)\n    {\n\t/* Do special fast code with clip boundaries in registers(?) */\n\t/* It doesn't pay much to make use of fSorted in this case, \n\t   so we lump everything together. */\n\n\tint clipx1, clipx2, clipy1, clipy2;\n\n\tclipx1 = prgnDst->extents.x1;\n\tclipy1 = prgnDst->extents.y1;\n\tclipx2 = prgnDst->extents.x2;\n\tclipy2 = prgnDst->extents.y2;\n\t    \n\tfor (; ppt != pptLast; ppt++, pwidth++)\n\t{\n\t    y = ppt->y;\n\t    x1 = ppt->x;\n\t    if (clipy1 <= y && y < clipy2)\n\t    {\n\t\tx2 = x1 + *pwidth;\n\t\tif (x1 < clipx1)    x1 = clipx1;\n\t\tif (x2 > clipx2)    x2 = clipx2;\n\t\tif (x1 < x2)\n\t\t{\n\t\t    /* part of span in clip rectangle */\n\t\t    pptNew->x = x1;\n\t\t    pptNew->y = y;\n\t\t    *pwidthNew = x2 - x1;\n\t\t    pptNew++;\n\t\t    pwidthNew++;\n\t\t}\n\t    }\n\t} /* end for */\n\n    }\n    else if ((numRects = prgnDst->data->numRects))\n    {\n\t/* Have to clip against many boxes */\n\tBoxPtr pboxBandStart, pboxBandEnd;\n\tBoxPtr pbox;\n\tBoxPtr pboxLast;\n\tint clipy1, clipy2;\n\n\t/* In this case, taking advantage of sorted spans gains more than\n\t   the sorting costs. */\n\tif ((! fSorted) && (nspans > 1))\n\t    QuickSortSpans(ppt, pwidth, nspans);\n\n\tpboxBandStart = RegionBoxptr(prgnDst);\n\tpboxLast = pboxBandStart + numRects;\n    \n\tNextBand();\n\n\tfor (; ppt != pptLast; )\n\t{\n\t    y = ppt->y;\n\t    if (y < clipy2)\n\t    {\n\t\t/* span is in the current band */\n\t\tpbox = pboxBandStart;\n\t\tx1 = ppt->x;\n\t\tx2 = x1 + *pwidth;\n\t\tdo\n\t\t{ /* For each box in band */\n\t\t    int newx1, newx2;\n\n\t\t    newx1 = x1;\n\t\t    newx2 = x2;\n\t\t    if (newx1 < pbox->x1)   newx1 = pbox->x1;\n\t\t    if (newx2 > pbox->x2)   newx2 = pbox->x2;\n\t\t    if (newx1 < newx2)\n\t\t    {\n\t\t\t/* Part of span in clip rectangle */\n\t\t\tpptNew->x = newx1;\n\t\t\tpptNew->y = y;\n\t\t\t*pwidthNew = newx2 - newx1;\n\t\t\tpptNew++;\n\t\t\tpwidthNew++;\n\t\t    }\n\t\t    pbox++;\n\t\t} while (pbox != pboxBandEnd);\n\t\tppt++;\n\t\tpwidth++;\n\t    }\n\t    else\n\t    {\n\t\t/* Move to next band, adjust ppt as needed */\n\t\tpboxBandStart = pboxBandEnd;\n\t\tif (pboxBandStart == pboxLast)\n\t\t    break; /* We're completely done */\n\t\tNextBand();\n\t    }\n\t}\n    }\n    return pwidthNew - pwidthNewStart;\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*-\n *-----------------------------------------------------------------------\n * RegionAppend --\n * \n *      \"Append\" the rgn rectangles onto the end of dstrgn, maintaining\n *      knowledge of YX-banding when it's easy.  Otherwise, dstrgn just\n *      becomes a non-y-x-banded random collection of rectangles, and not\n *      yet a true region.  After a sequence of appends, the caller must\n *      call RegionValidate to ensure that a valid region is constructed.\n *\n * Results:\n *\tTRUE if successful.\n *\n * Side Effects:\n *      dstrgn is modified if rgn has rectangles.\n *\n */\n", "func_signal": "Bool\nRegionAppend(RegionPtr dstrgn, RegionPtr rgn)", "code": "{\n    int numRects, dnumRects, size;\n    BoxPtr new, old;\n    Bool prepend;\n\n    if (RegionNar(rgn))\n\treturn RegionBreak (dstrgn);\n    \n    if (!rgn->data && (dstrgn->data == &RegionEmptyData))\n    {\n\tdstrgn->extents = rgn->extents;\n\tdstrgn->data = NULL;\n\treturn TRUE;\n    }\n\n    numRects = RegionNumRects(rgn);\n    if (!numRects)\n\treturn TRUE;\n    prepend = FALSE;\n    size = numRects;\n    dnumRects = RegionNumRects(dstrgn);\n    if (!dnumRects && (size < 200))\n\tsize = 200; /* XXX pick numbers out of a hat */\n    RECTALLOC(dstrgn, size);\n    old = RegionRects(rgn);\n    if (!dnumRects)\n\tdstrgn->extents = rgn->extents;\n    else if (dstrgn->extents.x2 > dstrgn->extents.x1)\n    {\n\tBoxPtr first, last;\n\n\tfirst = old;\n\tlast = RegionBoxptr(dstrgn) + (dnumRects - 1);\n\tif ((first->y1 > last->y2) ||\n\t    ((first->y1 == last->y1) && (first->y2 == last->y2) &&\n\t     (first->x1 > last->x2)))\n\t{\n\t    if (rgn->extents.x1 < dstrgn->extents.x1)\n\t\tdstrgn->extents.x1 = rgn->extents.x1;\n\t    if (rgn->extents.x2 > dstrgn->extents.x2)\n\t\tdstrgn->extents.x2 = rgn->extents.x2;\n\t    dstrgn->extents.y2 = rgn->extents.y2;\n\t}\n\telse\n\t{\n\t    first = RegionBoxptr(dstrgn);\n\t    last = old + (numRects - 1);\n\t    if ((first->y1 > last->y2) ||\n\t\t((first->y1 == last->y1) && (first->y2 == last->y2) &&\n\t\t (first->x1 > last->x2)))\n\t    {\n\t\tprepend = TRUE;\n\t\tif (rgn->extents.x1 < dstrgn->extents.x1)\n\t\t    dstrgn->extents.x1 = rgn->extents.x1;\n\t\tif (rgn->extents.x2 > dstrgn->extents.x2)\n\t\t    dstrgn->extents.x2 = rgn->extents.x2;\n\t\tdstrgn->extents.y1 = rgn->extents.y1;\n\t    }\n\t    else\n\t\tdstrgn->extents.x2 = dstrgn->extents.x1;\n\t}\n    }\n    if (prepend)\n    {\n\tnew = RegionBox(dstrgn, numRects);\n\tif (dnumRects == 1)\n\t    *new = *RegionBoxptr(dstrgn);\n\telse\n\t    memmove((char *)new,(char *)RegionBoxptr(dstrgn),\n\t\t  dnumRects * sizeof(BoxRec));\n\tnew = RegionBoxptr(dstrgn);\n    }\n    else\n\tnew = RegionBoxptr(dstrgn) + dnumRects;\n    if (numRects == 1)\n\t*new = *old;\n    else\n\tmemmove((char *)new, (char *)old, numRects * sizeof(BoxRec));\n    dstrgn->data->numRects += numRects;\n    return TRUE;\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/* dixLookupWindow requires a lot of setup not necessary for this test.\n * Simple wrapper that returns either one of the fake root window or the\n * fake client window. If the requested ID is neither of those wanted,\n * return whatever the real dixLookupWindow does.\n */\n", "func_signal": "int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)", "code": "{\n    if (id == root.drawable.id)\n    {\n        *win = &root;\n        return Success;\n    } else if (id == window.drawable.id)\n    {\n        *win = &window;\n        return Success;\n    }\n\n    return __real_dixLookupWindow(win, id, client, access);\n}", "path": "test\\xi2\\protocol-xiselectevents.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinModifierNXKeyToNXMask\n *      Returns 0 if key is not a known modifier key.\n */\n", "func_signal": "int DarwinModifierNXKeyToNXMask(int key)", "code": "{\n    switch (key) {\n        case NX_MODIFIERKEY_ALPHALOCK:   return NX_ALPHASHIFTMASK;\n#ifdef NX_DEVICELSHIFTKEYMASK\n        case NX_MODIFIERKEY_SHIFT:       return NX_DEVICELSHIFTKEYMASK;\n        case NX_MODIFIERKEY_RSHIFT:      return NX_DEVICERSHIFTKEYMASK;\n        case NX_MODIFIERKEY_CONTROL:     return NX_DEVICELCTLKEYMASK;\n        case NX_MODIFIERKEY_RCONTROL:    return NX_DEVICERCTLKEYMASK;\n        case NX_MODIFIERKEY_ALTERNATE:   return NX_DEVICELALTKEYMASK;\n        case NX_MODIFIERKEY_RALTERNATE:  return NX_DEVICERALTKEYMASK;\n        case NX_MODIFIERKEY_COMMAND:     return NX_DEVICELCMDKEYMASK;\n        case NX_MODIFIERKEY_RCOMMAND:    return NX_DEVICERCMDKEYMASK;\n#else\n        case NX_MODIFIERKEY_SHIFT:       return NX_SHIFTMASK;\n        case NX_MODIFIERKEY_CONTROL:     return NX_CONTROLMASK;\n        case NX_MODIFIERKEY_ALTERNATE:   return NX_ALTERNATEMASK;\n        case NX_MODIFIERKEY_COMMAND:     return NX_COMMANDMASK;\n#endif\n        case NX_MODIFIERKEY_NUMERICPAD:  return NX_NUMERICPADMASK;\n        case NX_MODIFIERKEY_HELP:        return NX_HELPMASK;\n        case NX_MODIFIERKEY_SECONDARYFN: return NX_SECONDARYFNMASK;\n    }\n    return 0;\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/* ||| I should apply the merge sort code to rectangle sorting above, and see\n   if mapping time can be improved.  But right now I've been at work 12 hours,\n   so forget it.\n*/\n", "func_signal": "static void QuickSortSpans(\n    DDXPointRec spans[],\n    int\t    \twidths[],\n    int\t    \tnumSpans)", "code": "{\n    int\t    y;\n    int\t    i, j, m;\n    DDXPointPtr    r;\n\n    /* Always called with numSpans > 1 */\n    /* Sorts only by y, doesn't bother to sort by x */\n\n    do\n    {\n\tif (numSpans < 9)\n\t{\n\t    /* Do insertion sort */\n\t    int yprev;\n\n\t    yprev = spans[0].y;\n\t    i = 1;\n\t    do\n\t    { /* while i != numSpans */\n\t\ty = spans[i].y;\n\t\tif (yprev > y)\n\t\t{\n\t\t    /* spans[i] is out of order.  Move into proper location. */\n\t\t    DDXPointRec tpt;\n\t\t    int\t    tw, k;\n\n\t\t    for (j = 0; y >= spans[j].y; j++) {}\n\t\t    tpt = spans[i];\n\t\t    tw  = widths[i];\n\t\t    for (k = i; k != j; k--)\n\t\t    {\n\t\t\tspans[k] = spans[k-1];\n\t\t\twidths[k] = widths[k-1];\n\t\t    }\n\t\t    spans[j] = tpt;\n\t\t    widths[j] = tw;\n\t\t    y = spans[i].y;\n\t\t} /* if out of order */\n\t\typrev = y;\n\t\ti++;\n\t    } while (i != numSpans);\n\t    return;\n\t}\n\n\t/* Choose partition element, stick in location 0 */\n\tm = numSpans / 2;\n\tif (spans[m].y > spans[0].y)\t\tExchangeSpans(m, 0);\n\tif (spans[m].y > spans[numSpans-1].y)   ExchangeSpans(m, numSpans-1);\n\tif (spans[m].y > spans[0].y)\t\tExchangeSpans(m, 0);\n\ty = spans[0].y;\n\n        /* Partition array */\n        i = 0;\n        j = numSpans;\n        do\n\t{\n\t    r = &(spans[i]);\n\t    do\n\t    {\n\t\tr++;\n\t\ti++;\n            } while (i != numSpans && r->y < y);\n\t    r = &(spans[j]);\n\t    do\n\t    {\n\t\tr--;\n\t\tj--;\n            } while (y < r->y);\n            if (i < j)\n\t\tExchangeSpans(i, j);\n        } while (i < j);\n\n        /* Move partition element back to middle */\n        ExchangeSpans(0, j);\n\n\t/* Recurse */\n        if (numSpans-j-1 > 1)\n\t    QuickSortSpans(&spans[j+1], &widths[j+1], numSpans-j-1);\n        numSpans = j;\n    } while (numSpans > 1);\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/* DEBUG */\n", "func_signal": "Bool\nRegionBreak (RegionPtr pReg)", "code": "{\n    xfreeData (pReg);\n    pReg->extents = RegionEmptyBox;\n    pReg->data = &RegionBrokenData;\n    return FALSE;\n}", "path": "dix\\region.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinKeyboardInit\n *      Get the Darwin keyboard map and compute an equivalent\n *      X keyboard map and modifier map. Set the new keyboard\n *      device structure.\n */\n", "func_signal": "void DarwinKeyboardInit(DeviceIntPtr pDev)", "code": "{\n    // Open a shared connection to the HID System.\n    // Note that the Event Status Driver is really just a wrapper\n    // for a kIOHIDParamConnectType connection.\n    assert(darwinParamConnect = NXOpenEventStatus());\n\n    InitKeyboardDeviceStruct(pDev, NULL, NULL, DarwinChangeKeyboardControl);\n\n    DarwinKeyboardReloadHandler();\n\n    CopyKeyClass(pDev, inputInfo.keyboard);\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * DarwinModifierNXMaskToNXKey\n *      Returns -1 if mask is not a known modifier mask.\n */\n", "func_signal": "int DarwinModifierNXMaskToNXKey(int mask)", "code": "{\n    switch (mask) {\n        case NX_ALPHASHIFTMASK:       return NX_MODIFIERKEY_ALPHALOCK;\n        case NX_SHIFTMASK:            return NX_MODIFIERKEY_SHIFT;\n#ifdef NX_DEVICELSHIFTKEYMASK\n        case NX_DEVICELSHIFTKEYMASK:  return NX_MODIFIERKEY_SHIFT;\n        case NX_DEVICERSHIFTKEYMASK:  return NX_MODIFIERKEY_RSHIFT;\n#endif\n        case NX_CONTROLMASK:          return NX_MODIFIERKEY_CONTROL;\n#ifdef NX_DEVICELCTLKEYMASK\n        case NX_DEVICELCTLKEYMASK:    return NX_MODIFIERKEY_CONTROL;\n        case NX_DEVICERCTLKEYMASK:    return NX_MODIFIERKEY_RCONTROL;\n#endif\n        case NX_ALTERNATEMASK:        return NX_MODIFIERKEY_ALTERNATE;\n#ifdef NX_DEVICELALTKEYMASK\n        case NX_DEVICELALTKEYMASK:    return NX_MODIFIERKEY_ALTERNATE;\n        case NX_DEVICERALTKEYMASK:    return NX_MODIFIERKEY_RALTERNATE;\n#endif\n        case NX_COMMANDMASK:          return NX_MODIFIERKEY_COMMAND;\n#ifdef NX_DEVICELCMDKEYMASK\n        case NX_DEVICELCMDKEYMASK:    return NX_MODIFIERKEY_COMMAND;\n        case NX_DEVICERCMDKEYMASK:    return NX_MODIFIERKEY_RCOMMAND;\n#endif\n        case NX_NUMERICPADMASK:       return NX_MODIFIERKEY_NUMERICPAD;\n        case NX_HELPMASK:             return NX_MODIFIERKEY_HELP;\n        case NX_SECONDARYFNMASK:      return NX_MODIFIERKEY_SECONDARYFN;\n    }\n    return -1;\n}", "path": "hw\\xquartz\\quartzKeyboard.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * Find the work area of all attached monitors\n */\n", "func_signal": "static Bool\nwinGetWorkArea (RECT *prcWorkArea, winScreenInfo *pScreenInfo)", "code": "{\n  int\t\t\tiPrimaryWidth, iPrimaryHeight;\n  int\t\t\tiWidth, iHeight;\n  int\t\t\tiLeft, iTop;\n  int\t\t\tiPrimaryNonWorkAreaWidth, iPrimaryNonWorkAreaHeight;\n\n  /* SPI_GETWORKAREA only gets the work area of the primary screen. */\n  SystemParametersInfo (SPI_GETWORKAREA, 0, prcWorkArea, 0);\n\n  /* Bail out here if we aren't using multiple monitors */\n  if (!pScreenInfo->fMultipleMonitors)\n    return TRUE;\n  \n  winDebug (\"winGetWorkArea - Original WorkArea: %d %d %d %d\\n\",\n\t  (int) prcWorkArea->top, (int) prcWorkArea->left,\n\t  (int) prcWorkArea->bottom, (int) prcWorkArea->right);\n\n  /* Get size of full virtual screen */\n  iWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);\n  iHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);\n\n  winDebug (\"winGetWorkArea - Virtual screen is %d x %d\\n\", iWidth, iHeight);\n\n  /* Get origin of full virtual screen */\n  iLeft = GetSystemMetrics (SM_XVIRTUALSCREEN);\n  iTop = GetSystemMetrics (SM_YVIRTUALSCREEN);\n\n  winDebug (\"winGetWorkArea - Virtual screen origin is %d, %d\\n\", iLeft, iTop);\n  \n  /* Get size of primary screen */\n  iPrimaryWidth = GetSystemMetrics (SM_CXSCREEN);\n  iPrimaryHeight = GetSystemMetrics (SM_CYSCREEN);\n\n  winDebug (\"winGetWorkArea - Primary screen is %d x %d\\n\",\n\t iPrimaryWidth, iPrimaryHeight);\n  \n  /* Work out how much of the primary screen we aren't using */\n  iPrimaryNonWorkAreaWidth = iPrimaryWidth - (prcWorkArea->right -\n\t\t\t\t\t      prcWorkArea->left);\n  iPrimaryNonWorkAreaHeight = iPrimaryHeight - (prcWorkArea->bottom\n\t\t\t\t\t\t- prcWorkArea->top);\n  \n  /* Update the rectangle to include all monitors */\n  if (iLeft < 0) \n    {\n      prcWorkArea->left = iLeft;\n    }\n  if (iTop < 0) \n    {\n      prcWorkArea->top = iTop;\n    }\n  prcWorkArea->right = prcWorkArea->left + iWidth -\n    iPrimaryNonWorkAreaWidth;\n  prcWorkArea->bottom = prcWorkArea->top + iHeight -\n    iPrimaryNonWorkAreaHeight;\n  \n  winDebug (\"winGetWorkArea - Adjusted WorkArea for multiple \"\n\t  \"monitors: %d %d %d %d\\n\",\n\t  (int) prcWorkArea->top, (int) prcWorkArea->left,\n\t  (int) prcWorkArea->bottom, (int) prcWorkArea->right);\n  \n  return TRUE;\n}", "path": "hw\\xwin\\wincreatewnd.c", "repo_name": "wereHamster/xorg-server", "stars": 5, "license": "other", "language": "c", "size": 28844}
{"docstring": "/*\n * Read one byte (i.e. two nibbles) from the LCD controller.\n */\n", "func_signal": "uint8_t\nhd44780_inbyte(uint8_t rs)", "code": "{\n  uint8_t x;\n\n  x = hd44780_innibble(rs) << 4;\n  x |= hd44780_innibble(rs);\n\n  return x;\n}", "path": "lcd_uart\\hd44780.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/* send byte to SPI */\n", "func_signal": "void spi_send_byte(uint8_t cData)", "code": "{\n\tPORTD &= ~_BV(SPI_SS);\n\t_delay_us(30);\n\tSPDR = cData;\n\tloop_until_bit_is_set(SPSR, SPIF);\n\t_delay_us(30);\n\tPORTD |= _BV(SPI_SS);\n\t/* if slow mode add some delay acc. spec. */\n\t_delay_us(150+2*slowModeDelay);\n}", "path": "iqrf\\spi.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//**************************************************\n//Function to receive a single byte\n//*************************************************\n", "func_signal": "unsigned char receiveByte( void )", "code": "{\nunsigned char data, status;\n\nwhile(!(UCSRA & (1<<RXC)));   // Wait for incomming data\n\nstatus = UCSRA;\ndata = UDR;\n\nreturn(data);\n}", "path": "sd_card_uart\\UART_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Send one nibble out to the LCD controller.\n */\n", "func_signal": "static void\nhd44780_outnibble(uint8_t n, uint8_t rs)", "code": "{\n  uint8_t x;\n\n//   HD44780_PORTOUT &= ~_BV(HD44780_RW);\n  if (rs)\n    HD44780_PORTOUT |= _BV(HD44780_RS);\n  else\n    HD44780_PORTOUT &= ~_BV(HD44780_RS);\n  x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ((n << HD44780_D4) & HD44780_DATABITS);\n  HD44780_PORTOUT = x;\n  (void)hd44780_pulse_e(false);\n}", "path": "lcd_uart\\hd44780.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Initialize the LCD controller.\n *\n * The initialization sequence has a mandatory timing so the\n * controller can safely recognize the type of interface desired.\n * This is the only area where timed waits are really needed as\n * the busy flag cannot be probed initially.\n */\n", "func_signal": "void\nhd44780_init(void)", "code": "{\n\n  HD44780_DDR = _BV(HD44780_RS) | /*_BV(HD44780_RW) |*/ _BV(HD44780_E)\n    | HD44780_DATABITS;\n\n  _delay_ms(15);\t\t/* 40 ms needed for Vcc = 2.7 V */\n  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);\n  _delay_ms(4.1);\n  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);\n  _delay_ms(0.1);\n  hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);\n\n  hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);\n  hd44780_wait_ready();\n  hd44780_outcmd(HD44780_FNSET(0, 1, 0));\n  hd44780_wait_ready();\n  hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));\n  hd44780_wait_ready();\n}", "path": "lcd_uart\\hd44780.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/* send 1 byte */\n", "func_signal": "uint8_t iqrf_send_byte(uint8_t cData)", "code": "{\n\tiqrfTx[0] = cData;\n\treturn iqrf_send_buff(iqrfTx,1);\n}", "path": "iqrf\\iqrf.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/* get data from iqrf */\n", "func_signal": "uint8_t iqrf_get_data(uint8_t len)", "code": "{\n\tuint8_t crcs ;\n\t\n\tptype = 0x00+len;\n\n\t/* crc slave */\n\tcrcs = ptype ^ 0x5F;\n\t/* crc master */\n\tcrcm = 0xF0 ^ ptype ^ 0x5F;\n\t\n\tspi_send_byte(0xF0);\n\tspi_send_byte(ptype);\n\n\tfor (i = 0; i < len; i++) {\n\t\tiqrfRx[i] = spi_transcieve_byte(0x00);\n\t\tcrcs ^= iqrfRx[i];\n\t}\n\t\n\tiqrfRx[len] = spi_transcieve_byte(crcm);\n\n\t\n\tif (crcs == iqrfRx[len]) {\n\t\tfRxIQRF = len;\n\t\ttemp = 1;\n\t} else {\n\t\ttemp = 0;\n\t}\n\n\t/* according spec. some dummy bytes */\n\tspi_send_byte(0x00);\n\tspi_send_byte(0x00);\t\n\t\n\treturn temp;\n\n}", "path": "iqrf\\iqrf.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Send one byte to the LCD controller.  As we are in 4-bit mode, we\n * have to send two nibbles.\n */\n", "func_signal": "void\nhd44780_outbyte(uint8_t b, uint8_t rs)", "code": "{\n  hd44780_outnibble(b >> 4, rs);\n  hd44780_outnibble(b & 0xf, rs);\n}", "path": "lcd_uart\\hd44780.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//UART0 initialize\n// desired baud rate: 19200\n// actual: baud rate:19231 (0.2%)\n// char size: 8 bit\n// parity: Disabled\n", "func_signal": "void uart0_init(void)", "code": "{\n UCSRB = 0x00; //disable while setting baud rate\n UCSRA = 0x00;\n UCSRC = (1 << URSEL) | 0x06;\n UBRRL = 0x19; //set baud rate lo\n UBRRH = 0x00; //set baud rate hi\n UCSRB = 0x18;\n}", "path": "sd_card_uart\\SD_main.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//******************************************************************\n//Function: to send a command to SD card\n//Arguments: unsigned char (8-bit command value)\n// & unsigned long (32-bit command argument)\n//return: unsigned char; response byte\n//******************************************************************\n", "func_signal": "unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)", "code": "{\nunsigned char response, retry=0;\n\nSD_CS_ASSERT;\n/*TODO: add better checking of command */\nSPI_transmit(cmd | 0x40); //send command, first two bits always '01'\nSPI_transmit(arg>>24);\nSPI_transmit(arg>>16);\nSPI_transmit(arg>>8);\nSPI_transmit(arg);\n/* crc is ignored unless it's not enabled */\nSPI_transmit(0x95);\n\nwhile((response = SPI_receive()) == 0xff) //wait response\n   if(retry++ > 0xfe) break; //time out error\n\nSPI_receive(); //extra 8 CLK\nSD_CS_DEASSERT;\n\nreturn response; //return state\n}", "path": "sd_card_uart\\SD_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "// count seconds\n", "func_signal": "SIGNAL (SIG_OUTPUT_COMPARE1A)", "code": "{\n  uchar tcnt1h = TCNT1H;\n\n  OCR1A += XTAL / DEBOUNCE;\t\t// new compare value\n\n  if( ++prescaler == (uchar)DEBOUNCE ){\n    prescaler = 0;\n    second++;\t\t\t\t// exact one second over\n#if XTAL % DEBOUNCE\t\t\t// handle remainder\n    OCR1A += XTAL % DEBOUNCE; \t\t// compare once per second\n#endif\n  }\n  TCNT1H = tcnt1h;\t\t\t// restore for delay() !\n}", "path": "1wire\\timebase.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Send character c down the UART Tx, wait until tx holding register\n * is empty.\n */\n", "func_signal": "int\nuart_putchar(char c, FILE *stream)", "code": "{\n\n  if (c == '\\a')\n    {\n      fputs(\"*ring*\\n\", stderr);\n      return 0;\n    }\n\n  if (c == '\\n')\n    uart_putchar('\\r', stream);\n  loop_until_bit_is_set(UCSRA, UDRE);\n  UDR = c;\n\n  return 0;\n}", "path": "iqrf\\uart.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Read one nibble from the LCD controller.\n */\n", "func_signal": "static uint8_t\nhd44780_innibble(uint8_t rs)", "code": "{\n  uint8_t x;\n\n//   HD44780_PORTOUT |= _BV(HD44780_RW);\n  HD44780_DDR &= ~HD44780_DATABITS;\n  if (rs)\n    HD44780_PORTOUT |= _BV(HD44780_RS);\n  else\n    HD44780_PORTOUT &= ~_BV(HD44780_RS);\n  x = hd44780_pulse_e(true);\n  HD44780_DDR |= HD44780_DATABITS;\n//   HD44780_PORTOUT &= ~_BV(HD44780_RW);\n\n  return (x & HD44780_DATABITS) >> HD44780_D4;\n}", "path": "lcd_uart\\hd44780.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/*\n * Send character c down the UART Tx, wait until tx holding register\n * is empty.\n */\n", "func_signal": "int\nuart_putchar(char c, FILE *stream)", "code": "{\n\n  if (c == '\\a')\n    {\n      fputs(\"*ring*\\n\", stderr);\n      return 0;\n    }\n\n  if (c == '\\n')\n    uart_putchar('\\r', stream);\n  loop_until_bit_is_set(UCSRA, UDRE);\n  UDR = c;\n\n  return 0;\n}", "path": "lcd_uart\\uart.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//******************************************************************\n//Function: to read a single block from SD card\n//Arguments: none\n//return: unsigned char; will be 0 if no error,\n// otherwise the response byte will be sent\n//******************************************************************\n", "func_signal": "unsigned char SD_readSingleBlock(unsigned long startBlock)", "code": "{\nunsigned char response;\nunsigned int i, retry=0;\n\nresponse = SD_sendCommand(READ_SINGLE_BLOCK, startBlock<<9); //read a Block command\n//block address converted to starting address of 512 byte Block\nif(response != 0x00) //check for SD status: 0x00 - OK (No flags set)\n  return response;\n\nSD_CS_ASSERT;\n\nwhile(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)\n  if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out\n\nfor(i=0; i<512; i++) //read 512 bytes\n  buffer[i] = SPI_receive();\n\nSPI_receive(); //receive incoming CRC (16-bit), CRC is ignored here\nSPI_receive();\n\nSPI_receive(); //extra 8 clock pulses\nSD_CS_DEASSERT;\n\nreturn 0;\n}", "path": "sd_card_uart\\SD_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/* send and retrieve byte */\n", "func_signal": "uint8_t spi_transcieve_byte(uint8_t cData)", "code": "{\n\tPORTD &= ~_BV(SPI_SS);\n\t_delay_us(30);\n\tSPDR = cData;\n\tloop_until_bit_is_set(SPSR, SPIF);\n\tcData = SPDR;\n\t_delay_us(30);\n\tPORTD |= _BV(SPI_SS);\n\t_delay_us(150+2*slowModeDelay);\n\n\treturn cData;\n}", "path": "iqrf\\spi.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//*****************************************************************\n//Function: to erase specified no. of blocks of SD card\n//Arguments: none\n//return: unsigned char; will be 0 if no error,\n// otherwise the response byte will be sent\n//*****************************************************************\n", "func_signal": "unsigned char SD_erase (unsigned long startBlock, unsigned long totalBlocks)", "code": "{\nunsigned char response;\n\nresponse = SD_sendCommand(ERASE_BLOCK_START_ADDR, startBlock<<9); //send starting block address\nif(response != 0x00) //check for SD status: 0x00 - OK (No flags set)\n  return response;\n\nresponse = SD_sendCommand(ERASE_BLOCK_END_ADDR,(startBlock + totalBlocks - 1)<<9); //send end block address\nif(response != 0x00)\n  return response;\n\nresponse = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); //erase all selected blocks\nif(response != 0x00)\n  return response;\n\nreturn 0; //normal return\n}", "path": "sd_card_uart\\SD_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//call this routine to initialize all peripherals\n", "func_signal": "void init_devices(void)", "code": "{\n cli();\n port_init();\n spi_init();\n uart_init();\n\n MCUCR = 0x00;\n GICR  = 0x00;\n TIMSK = 0x00; //timer interrupt sources\n //all peripherals are now initialized\n}", "path": "sd_card_uart\\SD_main.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//***************************************************\n//Function to transmit a string in RAM\n//***************************************************\n", "func_signal": "void transmitString(unsigned char* string)", "code": "{\n  while (*string)\n   transmitByte(*string++);\n}", "path": "sd_card_uart\\UART_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "//***************************************************\n//Function to transmit a single byte\n//***************************************************\n", "func_signal": "void transmitByte( unsigned char data )", "code": "{\nwhile ( !(UCSRA & (1<<UDRE)) );  // Wait for empty transmit buffer\nUDR = data;                      //Start transmition\n\n}", "path": "sd_card_uart\\UART_routines.c", "repo_name": "nandra/AVR", "stars": 6, "license": "None", "language": "c", "size": 112}
{"docstring": "/* returns 0 for success, 2 for libpng problem, 4 for out of memory */\n", "func_signal": "int readpng2_init(mainprog_info *mainprog_ptr)", "code": "{\n    png_structp  png_ptr;       /* note:  temporary variables! */\n    png_infop  info_ptr;\n\n\n    /* could also replace libpng warning-handler (final NULL), but no need: */\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      readpng2_error_handler, NULL);\n    if (!png_ptr)\n        return 4;   /* out of memory */\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return 4;   /* out of memory */\n    }\n\n\n    /* we could create a second info struct here (end_info), but it's only\n     * useful if we want to keep pre- and post-IDAT chunk info separated\n     * (mainly for PNG-aware image editors and converters) */\n\n\n    /* setjmp() must be called in every function that calls a PNG-reading\n     * libpng function, unless an alternate error handler was installed--\n     * but compatible error handlers must either use longjmp() themselves\n     * (as in this program) or exit immediately, so here we are: */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return 2;\n    }\n\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n    /* prepare the reader to ignore all recognized chunks whose data won't be\n     * used, i.e., all chunks recognized by libpng except for IHDR, PLTE, IDAT,\n     * IEND, tRNS, bKGD, gAMA, and sRGB (small performance improvement) */\n    {\n        /* These byte strings were copied from png.h.  If a future libpng\n         * version recognizes more chunks, add them to this list.  If a\n         * future version of readpng2.c recognizes more chunks, delete them\n         * from this list. */\n        static const png_byte chunks_to_ignore[] = {\n             99,  72,  82,  77, '\\0',  /* cHRM */\n            104,  73,  83,  84, '\\0',  /* hIST */\n            105,  67,  67,  80, '\\0',  /* iCCP */\n            105,  84,  88, 116, '\\0',  /* iTXt */\n            111,  70,  70, 115, '\\0',  /* oFFs */\n            112,  67,  65,  76, '\\0',  /* pCAL */\n            112,  72,  89, 115, '\\0',  /* pHYs */\n            115,  66,  73,  84, '\\0',  /* sBIT */\n            115,  67,  65,  76, '\\0',  /* sCAL */\n            115,  80,  76,  84, '\\0',  /* sPLT */\n            115,  84,  69,  82, '\\0',  /* sTER */\n            116,  69,  88, 116, '\\0',  /* tEXt */\n            116,  73,  77,  69, '\\0',  /* tIME */\n            122,  84,  88, 116, '\\0'   /* zTXt */\n        };\n\n        png_set_keep_unknown_chunks(png_ptr, 1 /* PNG_HANDLE_CHUNK_NEVER */,\n          chunks_to_ignore, sizeof(chunks_to_ignore)/5);\n    }\n#endif /* PNG_UNKNOWN_CHUNKS_SUPPORTED */\n\n\n    /* instead of doing png_init_io() here, now we set up our callback\n     * functions for progressive decoding */\n\n    png_set_progressive_read_fn(png_ptr, mainprog_ptr,\n      readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);\n\n\n    /*\n     * may as well enable or disable MMX routines here, if supported;\n     *\n     * to enable all:  mask = png_get_mmx_flagmask (\n     *                   PNG_SELECT_READ | PNG_SELECT_WRITE, &compilerID);\n     *                 flags = png_get_asm_flags (png_ptr);\n     *                 flags |= mask;\n     *                 png_set_asm_flags (png_ptr, flags);\n     *\n     * to disable all:  mask = png_get_mmx_flagmask (\n     *                   PNG_SELECT_READ | PNG_SELECT_WRITE, &compilerID);\n     *                  flags = png_get_asm_flags (png_ptr);\n     *                  flags &= ~mask;\n     *                  png_set_asm_flags (png_ptr, flags);\n     */\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \\\n    defined(PNG_LIBPNG_VER) && (PNG_LIBPNG_VER >= 10200)\n    /*\n     * WARNING:  This preprocessor approach means that the following code\n     *           cannot be used with a libpng DLL older than 1.2.0--the\n     *           compiled-in symbols for the new functions will not exist.\n     *           (Could use dlopen() and dlsym() on Unix and corresponding\n     *           calls for Windows, but not portable...)\n     */\n    {\n#ifdef PNG_ASSEMBLER_CODE_SUPPORTED\n        png_uint_32 mmx_disable_mask = 0;\n        png_uint_32 asm_flags, mmx_mask;\n        int compilerID;\n\n        if (mainprog_ptr->nommxfilters)\n            mmx_disable_mask |= ( PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                                | PNG_ASM_FLAG_MMX_READ_FILTER_UP    \\\n                                | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                                | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH );\n        if (mainprog_ptr->nommxcombine)\n            mmx_disable_mask |= PNG_ASM_FLAG_MMX_READ_COMBINE_ROW;\n        if (mainprog_ptr->nommxinterlace)\n            mmx_disable_mask |= PNG_ASM_FLAG_MMX_READ_INTERLACE;\n        asm_flags = png_get_asm_flags(png_ptr);\n        png_set_asm_flags(png_ptr, asm_flags & ~mmx_disable_mask);\n\n\n        /* Now query libpng's asm settings, just for yuks.  Note that this\n         * differs from the querying of its *potential* MMX capabilities\n         * in readpng2_version_info(); this is true runtime verification. */\n\n        asm_flags = png_get_asm_flags(png_ptr);\n        mmx_mask = png_get_mmx_flagmask(PNG_SELECT_READ | PNG_SELECT_WRITE,\n          &compilerID);\n        if (asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_COMPILED)\n            fprintf(stderr,\n              \"  MMX support (%s version) is compiled into libpng\\n\",\n              compilerID == 1? \"MSVC++\" :\n              (compilerID == 2? \"GNU C\" : \"unknown\"));\n        else\n            fprintf(stderr, \"  MMX support is not compiled into libpng\\n\");\n        fprintf(stderr, \"  MMX instructions are %ssupported by CPU\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU)? \"\" : \"not \");\n        fprintf(stderr, \"  MMX read support for combining rows is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)? \"en\" : \"dis\");\n        fprintf(stderr,\n          \"  MMX read support for expanding interlacing is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_INTERLACE)? \"en\" : \"dis\");\n        fprintf(stderr, \"  MMX read support for \\\"sub\\\" filter is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? \"en\" : \"dis\");\n        fprintf(stderr, \"  MMX read support for \\\"up\\\" filter is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? \"en\" : \"dis\");\n        fprintf(stderr, \"  MMX read support for \\\"avg\\\" filter is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? \"en\" : \"dis\");\n        fprintf(stderr, \"  MMX read support for \\\"Paeth\\\" filter is %sabled\\n\",\n          (asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? \"en\" : \"dis\");\n        asm_flags &= (mmx_mask & ~( PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  \\\n                                  | PNG_ASM_FLAG_MMX_READ_INTERLACE    \\\n                                  | PNG_ASM_FLAG_MMX_READ_FILTER_SUB   \\\n                                  | PNG_ASM_FLAG_MMX_READ_FILTER_UP    \\\n                                  | PNG_ASM_FLAG_MMX_READ_FILTER_AVG   \\\n                                  | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ));\n        if (asm_flags)\n            fprintf(stderr,\n              \"  additional MMX support is also enabled (0x%02lx)\\n\",\n              asm_flags);\n#else  /* !PNG_ASSEMBLER_CODE_SUPPORTED */\n        fprintf(stderr, \"  MMX querying is disabled in libpng.\\n\");\n#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */\n    }\n#endif\n\n\n    /* make sure we save our pointers for use in readpng2_decode_data() */\n\n    mainprog_ptr->png_ptr = png_ptr;\n    mainprog_ptr->info_ptr = info_ptr;\n\n\n    /* and that's all there is to initialization */\n\n    return 0;\n}", "path": "libpng\\contrib\\gregbook\\readpng2.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Test one file */\n", "func_signal": "int\ntest_one_file(PNG_CONST char *inname, PNG_CONST char *outname)", "code": "{\n   static png_FILE_p fpin;\n   static png_FILE_p fpout;  /* \"static\" prevents setjmp corruption */\n   png_structp read_ptr;\n   png_infop read_info_ptr, end_info_ptr;\n#ifdef PNG_WRITE_SUPPORTED\n   png_structp write_ptr;\n   png_infop write_info_ptr;\n   png_infop write_end_info_ptr;\n#else\n   png_structp write_ptr = NULL;\n   png_infop write_info_ptr = NULL;\n   png_infop write_end_info_ptr = NULL;\n#endif\n   png_bytep row_buf;\n   png_uint_32 y;\n   png_uint_32 width, height;\n   int num_pass, pass;\n   int bit_depth, color_type;\n#ifdef PNG_SETJMP_SUPPORTED\n#ifdef USE_FAR_KEYWORD\n   jmp_buf jmpbuf;\n#endif\n#endif\n\n#if defined(_WIN32_WCE)\n   TCHAR path[MAX_PATH];\n#endif\n   char inbuf[256], outbuf[256];\n\n   row_buf = NULL;\n\n#if defined(_WIN32_WCE)\n   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);\n   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)\n#else\n   if ((fpin = fopen(inname, \"rb\")) == NULL)\n#endif\n   {\n      fprintf(STDERR, \"Could not find input file %s\\n\", inname);\n      return (1);\n   }\n\n#if defined(_WIN32_WCE)\n   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);\n   if ((fpout = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL)) == INVALID_HANDLE_VALUE)\n#else\n   if ((fpout = fopen(outname, \"wb\")) == NULL)\n#endif\n   {\n      fprintf(STDERR, \"Could not open output file %s\\n\", outname);\n      FCLOSE(fpin);\n      return (1);\n   }\n\n   png_debug(0, \"Allocating read and write structures\");\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n   read_ptr =\n      png_create_read_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,\n      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,\n      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);\n#else\n   read_ptr =\n      png_create_read_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,\n      png_error_ptr_NULL, png_error_ptr_NULL);\n#endif\n#if defined(PNG_NO_STDIO)\n   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,\n       pngtest_warning);\n#endif\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n  user_chunk_data[0] = 0;\n  user_chunk_data[1] = 0;\n  user_chunk_data[2] = 0;\n  user_chunk_data[3] = 0;\n  png_set_read_user_chunk_fn(read_ptr, user_chunk_data,\n    read_user_chunk_callback);\n\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG\n   write_ptr =\n      png_create_write_struct_2(PNG_LIBPNG_VER_STRING, png_voidp_NULL,\n      png_error_ptr_NULL, png_error_ptr_NULL, png_voidp_NULL,\n      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);\n#else\n   write_ptr =\n      png_create_write_struct(PNG_LIBPNG_VER_STRING, png_voidp_NULL,\n      png_error_ptr_NULL, png_error_ptr_NULL);\n#endif\n#if defined(PNG_NO_STDIO)\n   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,\n       pngtest_warning);\n#endif\n#endif\n   png_debug(0, \"Allocating read_info, write_info and end_info structures\");\n   read_info_ptr = png_create_info_struct(read_ptr);\n   end_info_ptr = png_create_info_struct(read_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n   write_info_ptr = png_create_info_struct(write_ptr);\n   write_end_info_ptr = png_create_info_struct(write_ptr);\n#endif\n\n#ifdef PNG_SETJMP_SUPPORTED\n   png_debug(0, \"Setting jmpbuf for read struct\");\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(jmpbuf))\n#else\n   if (setjmp(png_jmpbuf(read_ptr)))\n#endif\n   {\n      fprintf(STDERR, \"%s -> %s: libpng read error\\n\", inname, outname);\n      png_free(read_ptr, row_buf);\n      row_buf = NULL;\n      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n      png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n      png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n      FCLOSE(fpin);\n      FCLOSE(fpout);\n      return (1);\n   }\n#ifdef USE_FAR_KEYWORD\n   png_memcpy(png_jmpbuf(read_ptr), jmpbuf, png_sizeof(jmp_buf));\n#endif\n\n#ifdef PNG_WRITE_SUPPORTED\n   png_debug(0, \"Setting jmpbuf for write struct\");\n#ifdef USE_FAR_KEYWORD\n   if (setjmp(jmpbuf))\n#else\n   if (setjmp(png_jmpbuf(write_ptr)))\n#endif\n   {\n      fprintf(STDERR, \"%s -> %s: libpng write error\\n\", inname, outname);\n      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n      png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n      png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n      FCLOSE(fpin);\n      FCLOSE(fpout);\n      return (1);\n   }\n#ifdef USE_FAR_KEYWORD\n   png_memcpy(png_jmpbuf(write_ptr), jmpbuf, png_sizeof(jmp_buf));\n#endif\n#endif\n#endif\n\n   png_debug(0, \"Initializing input and output streams\");\n#if !defined(PNG_NO_STDIO)\n   png_init_io(read_ptr, fpin);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_init_io(write_ptr, fpout);\n#  endif\n#else\n   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,\n#    if defined(PNG_WRITE_FLUSH_SUPPORTED)\n      pngtest_flush);\n#    else\n      NULL);\n#    endif\n#  endif\n#endif\n   if (status_dots_requested == 1)\n   {\n#ifdef PNG_WRITE_SUPPORTED\n      png_set_write_status_fn(write_ptr, write_row_callback);\n#endif\n      png_set_read_status_fn(read_ptr, read_row_callback);\n   }\n   else\n   {\n#ifdef PNG_WRITE_SUPPORTED\n      png_set_write_status_fn(write_ptr, png_write_status_ptr_NULL);\n#endif\n      png_set_read_status_fn(read_ptr, png_read_status_ptr_NULL);\n   }\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)\n   {\n     int i;\n     for (i = 0; i<256; i++)\n        filters_used[i] = 0;\n     png_set_read_user_transform_fn(read_ptr, count_filters);\n   }\n#endif\n#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\n   zero_samples = 0;\n   png_set_write_user_transform_fn(write_ptr, count_zero_samples);\n#endif\n\n#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n#  ifndef PNG_HANDLE_CHUNK_ALWAYS\n#    define PNG_HANDLE_CHUNK_ALWAYS       3\n#  endif\n   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,\n      png_bytep_NULL, 0);\n#endif\n#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)\n#  ifndef PNG_HANDLE_CHUNK_IF_SAFE\n#    define PNG_HANDLE_CHUNK_IF_SAFE      2\n#  endif\n   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE,\n      png_bytep_NULL, 0);\n#endif\n\n   png_debug(0, \"Reading info struct\");\n   png_read_info(read_ptr, read_info_ptr);\n\n   png_debug(0, \"Transferring info struct\");\n   {\n      int interlace_type, compression_type, filter_type;\n\n      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,\n          &color_type, &interlace_type, &compression_type, &filter_type))\n      {\n         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,\n#if defined(PNG_WRITE_INTERLACING_SUPPORTED)\n            color_type, interlace_type, compression_type, filter_type);\n#else\n            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);\n#endif\n      }\n   }\n#if defined(PNG_FIXED_POINT_SUPPORTED)\n#if defined(PNG_cHRM_SUPPORTED)\n   {\n      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,\n         blue_y;\n      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,\n         &red_y, &green_x, &green_y, &blue_x, &blue_y))\n      {\n         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,\n            red_y, green_x, green_y, blue_x, blue_y);\n      }\n   }\n#endif\n#if defined(PNG_gAMA_SUPPORTED)\n   {\n      png_fixed_point gamma;\n\n      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))\n      {\n         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);\n      }\n   }\n#endif\n#else /* Use floating point versions */\n#if defined(PNG_FLOATING_POINT_SUPPORTED)\n#if defined(PNG_cHRM_SUPPORTED)\n   {\n      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,\n         blue_y;\n      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,\n         &red_y, &green_x, &green_y, &blue_x, &blue_y))\n      {\n         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,\n            red_y, green_x, green_y, blue_x, blue_y);\n      }\n   }\n#endif\n#if defined(PNG_gAMA_SUPPORTED)\n   {\n      double gamma;\n\n      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))\n      {\n         png_set_gAMA(write_ptr, write_info_ptr, gamma);\n      }\n   }\n#endif\n#endif /* floating point */\n#endif /* fixed point */\n#if defined(PNG_iCCP_SUPPORTED)\n   {\n      png_charp name;\n      png_charp profile;\n      png_uint_32 proflen;\n      int compression_type;\n\n      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,\n                      &profile, &proflen))\n      {\n         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,\n                      profile, proflen);\n      }\n   }\n#endif\n#if defined(PNG_sRGB_SUPPORTED)\n   {\n      int intent;\n\n      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))\n      {\n         png_set_sRGB(write_ptr, write_info_ptr, intent);\n      }\n   }\n#endif\n   {\n      png_colorp palette;\n      int num_palette;\n\n      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))\n      {\n         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);\n      }\n   }\n#if defined(PNG_bKGD_SUPPORTED)\n   {\n      png_color_16p background;\n\n      if (png_get_bKGD(read_ptr, read_info_ptr, &background))\n      {\n         png_set_bKGD(write_ptr, write_info_ptr, background);\n      }\n   }\n#endif\n#if defined(PNG_hIST_SUPPORTED)\n   {\n      png_uint_16p hist;\n\n      if (png_get_hIST(read_ptr, read_info_ptr, &hist))\n      {\n         png_set_hIST(write_ptr, write_info_ptr, hist);\n      }\n   }\n#endif\n#if defined(PNG_oFFs_SUPPORTED)\n   {\n      png_int_32 offset_x, offset_y;\n      int unit_type;\n\n      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,\n         &unit_type))\n      {\n         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);\n      }\n   }\n#endif\n#if defined(PNG_pCAL_SUPPORTED)\n   {\n      png_charp purpose, units;\n      png_charpp params;\n      png_int_32 X0, X1;\n      int type, nparams;\n\n      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,\n         &nparams, &units, &params))\n      {\n         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,\n            nparams, units, params);\n      }\n   }\n#endif\n#if defined(PNG_pHYs_SUPPORTED)\n   {\n      png_uint_32 res_x, res_y;\n      int unit_type;\n\n      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))\n      {\n         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);\n      }\n   }\n#endif\n#if defined(PNG_sBIT_SUPPORTED)\n   {\n      png_color_8p sig_bit;\n\n      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))\n      {\n         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);\n      }\n   }\n#endif\n#if defined(PNG_sCAL_SUPPORTED)\n#ifdef PNG_FLOATING_POINT_SUPPORTED\n   {\n      int unit;\n      double scal_width, scal_height;\n\n      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,\n         &scal_height))\n      {\n         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);\n      }\n   }\n#else\n#ifdef PNG_FIXED_POINT_SUPPORTED\n   {\n      int unit;\n      png_charp scal_width, scal_height;\n\n      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,\n          &scal_height))\n      {\n         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width, scal_height);\n      }\n   }\n#endif\n#endif\n#endif\n#if defined(PNG_TEXT_SUPPORTED)\n   {\n      png_textp text_ptr;\n      int num_text;\n\n      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)\n      {\n         png_debug1(0, \"Handling %d iTXt/tEXt/zTXt chunks\", num_text);\n         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);\n      }\n   }\n#endif\n#if defined(PNG_tIME_SUPPORTED)\n   {\n      png_timep mod_time;\n\n      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))\n      {\n         png_set_tIME(write_ptr, write_info_ptr, mod_time);\n#if defined(PNG_TIME_RFC1123_SUPPORTED)\n         /* we have to use png_memcpy instead of \"=\" because the string\n            pointed to by png_convert_to_rfc1123() gets free'ed before\n            we use it */\n         png_memcpy(tIME_string,\n                    png_convert_to_rfc1123(read_ptr, mod_time),\n                    png_sizeof(tIME_string));\n         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';\n         tIME_chunk_present++;\n#endif /* PNG_TIME_RFC1123_SUPPORTED */\n      }\n   }\n#endif\n#if defined(PNG_tRNS_SUPPORTED)\n   {\n      png_bytep trans;\n      int num_trans;\n      png_color_16p trans_values;\n\n      if (png_get_tRNS(read_ptr, read_info_ptr, &trans, &num_trans,\n         &trans_values))\n      {\n         int sample_max = (1 << read_info_ptr->bit_depth);\n         /* libpng doesn't reject a tRNS chunk with out-of-range samples */\n         if (!((read_info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&\n            (int)trans_values->gray > sample_max) ||\n            (read_info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\n            ((int)trans_values->red > sample_max ||\n            (int)trans_values->green > sample_max ||\n            (int)trans_values->blue > sample_max))))\n           png_set_tRNS(write_ptr, write_info_ptr, trans, num_trans,\n              trans_values);\n      }\n   }\n#endif\n#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)\n   {\n      png_unknown_chunkp unknowns;\n      int num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr,\n         &unknowns);\n      if (num_unknowns)\n      {\n         png_size_t i;\n         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,\n           num_unknowns);\n         /* copy the locations from the read_info_ptr.  The automatically\n            generated locations in write_info_ptr are wrong because we\n            haven't written anything yet */\n         for (i = 0; i < (png_size_t)num_unknowns; i++)\n           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,\n             unknowns[i].location);\n      }\n   }\n#endif\n\n#ifdef PNG_WRITE_SUPPORTED\n   png_debug(0, \"Writing info struct\");\n\n/* If we wanted, we could write info in two steps:\n   png_write_info_before_PLTE(write_ptr, write_info_ptr);\n */\n   png_write_info(write_ptr, write_info_ptr);\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n   if (user_chunk_data[0] != 0)\n   {\n     png_byte png_sTER[5] = {115,  84,  69,  82, '\\0'};\n\n     unsigned char\n       ster_chunk_data[1];\n\n     if (verbose)\n        fprintf(STDERR, \"stereo mode = %lu\\n\",\n          (unsigned long)(user_chunk_data[0] - 1));\n     ster_chunk_data[0]=(unsigned char)(user_chunk_data[0] - 1);\n     png_write_chunk(write_ptr, png_sTER, ster_chunk_data, 1);\n   }\n   if (user_chunk_data[1] != 0 || user_chunk_data[2] != 0)\n   {\n     png_byte png_vpAg[5] = {118, 112,  65, 103, '\\0'};\n\n     unsigned char\n       vpag_chunk_data[9];\n\n     if (verbose)\n        fprintf(STDERR, \"vpAg = %lu x %lu, units=%lu\\n\",\n          (unsigned long)user_chunk_data[1],\n          (unsigned long)user_chunk_data[2],\n          (unsigned long)user_chunk_data[3]);\n     png_save_uint_32(vpag_chunk_data, user_chunk_data[1]);\n     png_save_uint_32(vpag_chunk_data + 4, user_chunk_data[2]);\n     vpag_chunk_data[8] = (unsigned char)(user_chunk_data[3] & 0xff);\n     png_write_chunk(write_ptr, png_vpAg, vpag_chunk_data, 9);\n   }\n\n#endif\n#endif\n\n#ifdef SINGLE_ROWBUF_ALLOC\n   png_debug(0, \"Allocating row buffer...\");\n   row_buf = (png_bytep)png_malloc(read_ptr,\n      png_get_rowbytes(read_ptr, read_info_ptr));\n   png_debug1(0, \"0x%08lx\", (unsigned long)row_buf);\n#endif /* SINGLE_ROWBUF_ALLOC */\n   png_debug(0, \"Writing row data\");\n\n#if defined(PNG_READ_INTERLACING_SUPPORTED) || \\\n  defined(PNG_WRITE_INTERLACING_SUPPORTED)\n   num_pass = png_set_interlace_handling(read_ptr);\n#  ifdef PNG_WRITE_SUPPORTED\n   png_set_interlace_handling(write_ptr);\n#  endif\n#else\n   num_pass = 1;\n#endif\n\n#ifdef PNGTEST_TIMING\n   t_stop = (float)clock();\n   t_misc += (t_stop - t_start);\n   t_start = t_stop;\n#endif\n   for (pass = 0; pass < num_pass; pass++)\n   {\n      png_debug1(0, \"Writing row data for pass %d\", pass);\n      for (y = 0; y < height; y++)\n      {\n#ifndef SINGLE_ROWBUF_ALLOC\n         png_debug2(0, \"\\nAllocating row buffer (pass %d, y = %ld)...\", pass, y);\n         row_buf = (png_bytep)png_malloc(read_ptr,\n            png_get_rowbytes(read_ptr, read_info_ptr));\n         png_debug2(0, \"0x%08lx (%ld bytes)\", (unsigned long)row_buf,\n            png_get_rowbytes(read_ptr, read_info_ptr));\n#endif /* !SINGLE_ROWBUF_ALLOC */\n         png_read_rows(read_ptr, (png_bytepp)&row_buf, png_bytepp_NULL, 1);\n\n#ifdef PNG_WRITE_SUPPORTED\n#ifdef PNGTEST_TIMING\n         t_stop = (float)clock();\n         t_decode += (t_stop - t_start);\n         t_start = t_stop;\n#endif\n         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);\n#ifdef PNGTEST_TIMING\n         t_stop = (float)clock();\n         t_encode += (t_stop - t_start);\n         t_start = t_stop;\n#endif\n#endif /* PNG_WRITE_SUPPORTED */\n\n#ifndef SINGLE_ROWBUF_ALLOC\n         png_debug2(0, \"Freeing row buffer (pass %d, y = %ld)\", pass, y);\n         png_free(read_ptr, row_buf);\n         row_buf = NULL;\n#endif /* !SINGLE_ROWBUF_ALLOC */\n      }\n   }\n\n#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);\n#endif\n#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)\n   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);\n#endif\n\n   png_debug(0, \"Reading and writing end_info data\");\n\n   png_read_end(read_ptr, end_info_ptr);\n#if defined(PNG_TEXT_SUPPORTED)\n   {\n      png_textp text_ptr;\n      int num_text;\n\n      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)\n      {\n         png_debug1(0, \"Handling %d iTXt/tEXt/zTXt chunks\", num_text);\n         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);\n      }\n   }\n#endif\n#if defined(PNG_tIME_SUPPORTED)\n   {\n      png_timep mod_time;\n\n      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))\n      {\n         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);\n#if defined(PNG_TIME_RFC1123_SUPPORTED)\n         /* we have to use png_memcpy instead of \"=\" because the string\n            pointed to by png_convert_to_rfc1123() gets free'ed before\n            we use it */\n         png_memcpy(tIME_string,\n                    png_convert_to_rfc1123(read_ptr, mod_time),\n                    png_sizeof(tIME_string));\n         tIME_string[png_sizeof(tIME_string) - 1] = '\\0';\n         tIME_chunk_present++;\n#endif /* PNG_TIME_RFC1123_SUPPORTED */\n      }\n   }\n#endif\n#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)\n   {\n      png_unknown_chunkp unknowns;\n      int num_unknowns;\n      num_unknowns = (int)png_get_unknown_chunks(read_ptr, end_info_ptr,\n         &unknowns);\n      if (num_unknowns)\n      {\n         png_size_t i;\n         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,\n           num_unknowns);\n         /* copy the locations from the read_info_ptr.  The automatically\n            generated locations in write_end_info_ptr are wrong because we\n            haven't written the end_info yet */\n         for (i = 0; i < (png_size_t)num_unknowns; i++)\n           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,\n             unknowns[i].location);\n      }\n   }\n#endif\n#ifdef PNG_WRITE_SUPPORTED\n   png_write_end(write_ptr, write_end_info_ptr);\n#endif\n\n#ifdef PNG_EASY_ACCESS_SUPPORTED\n   if (verbose)\n   {\n      png_uint_32 iwidth, iheight;\n      iwidth = png_get_image_width(write_ptr, write_info_ptr);\n      iheight = png_get_image_height(write_ptr, write_info_ptr);\n      fprintf(STDERR, \"Image width = %lu, height = %lu\\n\",\n         (unsigned long)iwidth, (unsigned long)iheight);\n   }\n#endif\n\n   png_debug(0, \"Destroying data structs\");\n#ifdef SINGLE_ROWBUF_ALLOC\n   png_debug(1, \"destroying row_buf for read_ptr\");\n   png_free(read_ptr, row_buf);\n   row_buf = NULL;\n#endif /* SINGLE_ROWBUF_ALLOC */\n   png_debug(1, \"destroying read_ptr, read_info_ptr, end_info_ptr\");\n   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);\n#ifdef PNG_WRITE_SUPPORTED\n   png_debug(1, \"destroying write_end_info_ptr\");\n   png_destroy_info_struct(write_ptr, &write_end_info_ptr);\n   png_debug(1, \"destroying write_ptr, write_info_ptr\");\n   png_destroy_write_struct(&write_ptr, &write_info_ptr);\n#endif\n   png_debug(0, \"Destruction complete.\");\n\n   FCLOSE(fpin);\n   FCLOSE(fpout);\n\n   png_debug(0, \"Opening files for comparison\");\n#if defined(_WIN32_WCE)\n   MultiByteToWideChar(CP_ACP, 0, inname, -1, path, MAX_PATH);\n   if ((fpin = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)\n#else\n   if ((fpin = fopen(inname, \"rb\")) == NULL)\n#endif\n   {\n      fprintf(STDERR, \"Could not find file %s\\n\", inname);\n      return (1);\n   }\n\n#if defined(_WIN32_WCE)\n   MultiByteToWideChar(CP_ACP, 0, outname, -1, path, MAX_PATH);\n   if ((fpout = CreateFile(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)\n#else\n   if ((fpout = fopen(outname, \"rb\")) == NULL)\n#endif\n   {\n      fprintf(STDERR, \"Could not find file %s\\n\", outname);\n      FCLOSE(fpin);\n      return (1);\n   }\n\n   for (;;)\n   {\n      png_size_t num_in, num_out;\n\n         READFILE(fpin, inbuf, 1, num_in);\n         READFILE(fpout, outbuf, 1, num_out);\n\n      if (num_in != num_out)\n      {\n         fprintf(STDERR, \"\\nFiles %s and %s are of a different size\\n\",\n                 inname, outname);\n         if (wrote_question == 0)\n         {\n            fprintf(STDERR,\n         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",\n              inname, PNG_ZBUF_SIZE);\n            fprintf(STDERR,\n              \"\\n   filtering heuristic (libpng default), compression\");\n            fprintf(STDERR,\n              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",\n              ZLIB_VERSION);\n            wrote_question = 1;\n         }\n         FCLOSE(fpin);\n         FCLOSE(fpout);\n         return (0);\n      }\n\n      if (!num_in)\n         break;\n\n      if (png_memcmp(inbuf, outbuf, num_in))\n      {\n         fprintf(STDERR, \"\\nFiles %s and %s are different\\n\", inname, outname);\n         if (wrote_question == 0)\n         {\n            fprintf(STDERR,\n         \"   Was %s written with the same maximum IDAT chunk size (%d bytes),\",\n                 inname, PNG_ZBUF_SIZE);\n            fprintf(STDERR,\n              \"\\n   filtering heuristic (libpng default), compression\");\n            fprintf(STDERR,\n              \" level (zlib default),\\n   and zlib version (%s)?\\n\\n\",\n              ZLIB_VERSION);\n            wrote_question = 1;\n         }\n         FCLOSE(fpin);\n         FCLOSE(fpout);\n         return (0);\n      }\n   }\n\n   FCLOSE(fpin);\n   FCLOSE(fpout);\n\n   return (0);\n}", "path": "libpng\\pngtest.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* 0: sTER mode + 1\n     * 1: vpAg width\n     * 2: vpAg height\n     * 3: vpAg units\n     */\n", "func_signal": "static int read_user_chunk_callback(png_struct *png_ptr,\n   png_unknown_chunkp chunk)", "code": "{\n  png_uint_32\n    *user_chunk_data;\n\n  /* Return one of the following: */\n     /* return (-n);  chunk had an error */\n     /* return (0);  did not recognize */\n     /* return (n);  success */\n\n  /* The unknown chunk structure contains the chunk data:\n   * png_byte name[5];\n   * png_byte *data;\n   * png_size_t size;\n   *\n   *  Note that libpng has already taken care of the CRC handling.\n   */\n\n  if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&     /* s  T */\n      chunk->name[2] ==  69 && chunk->name[3] ==  82)       /* E  R */\n     {\n       /* Found sTER chunk */\n       if (chunk->size != 1)\n         return (-1); /* Error return */\n       if (chunk->data[0] != 0 && chunk->data[0] != 1)\n          return (-1);  /* Invalid mode */\n       user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);\n       user_chunk_data[0]=chunk->data[0]+1;\n       return (1);\n     }\n  if (chunk->name[0] != 118 || chunk->name[1] != 112 ||    /* v  p */\n      chunk->name[2] !=  65 || chunk->name[3] != 103)      /* A  g */\n    return (0); /* Did not recognize */\n\n  /* Found ImageMagick vpAg chunk */\n\n  if (chunk->size != 9)\n    return (-1); /* Error return */\n\n  user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);\n\n  user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data);\n  user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4);\n  user_chunk_data[3]=(png_uint_32)chunk->data[8];\n\n  return (1);\n\n}", "path": "libpng\\pngtest.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* function was added to libpng 1.2.0 and should always exist by default */\n", "func_signal": "void PNGAPI\npng_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)", "code": "{\n/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */\n    if (png_ptr != NULL)\n    png_ptr->asm_flags = 0;\n    asm_flags = asm_flags; /* Quiet the compiler */\n}", "path": "libpng\\pngset.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Put a variable of the form \"name=value\" into the environment */\n", "func_signal": "int SDL_putenv(const char *variable)", "code": "{\n\tsize_t bufferlen;\n\tchar *value;\n\tconst char *sep;\n\n\tsep = SDL_strchr(variable, '=');\n\tif ( sep == NULL ) {\n\t\treturn -1;\n\t}\n\tbufferlen = SDL_strlen(variable)+1;\n\tif ( bufferlen > SDL_envmemlen ) {\n\t\tchar *newmem = (char *)SDL_realloc(SDL_envmem, bufferlen);\n\t\tif ( newmem == NULL ) {\n\t\t\treturn -1;\n\t\t}\n\t\tSDL_envmem = newmem;\n\t\tSDL_envmemlen = bufferlen;\n\t}\n\tSDL_strlcpy(SDL_envmem, variable, bufferlen);\n\tvalue = SDL_envmem + (sep - variable);\n\t*value++ = '\\0';\n\tif ( !SetEnvironmentVariable(SDL_envmem, *value ? value : NULL) ) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "SDL-1.2.13\\src\\stdlib\\SDL_getenv.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* this function was added to libpng 1.2.0 */\n", "func_signal": "void PNGAPI\npng_set_mmx_thresholds (png_structp png_ptr,\n                        png_byte mmx_bitdepth_threshold,\n                        png_uint_32 mmx_rowbytes_threshold)", "code": "{\n/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */\n    if (png_ptr == NULL)\n       return;\n    /* Quiet the compiler */\n    mmx_bitdepth_threshold = mmx_bitdepth_threshold;\n    mmx_rowbytes_threshold = mmx_rowbytes_threshold;\n}", "path": "libpng\\pngset.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* 6.3.0 */\n", "func_signal": "int ph_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value)", "code": "{\n    switch (attrib)\n    {\n        case SDL_GL_DOUBLEBUFFER:\n             *value=this->gl_config.double_buffer;\n             break;\n        case SDL_GL_STENCIL_SIZE:\n             *value=this->gl_config.stencil_size;\n             break;\n        case SDL_GL_DEPTH_SIZE:\n             *value=this->gl_config.depth_size;\n             break;\n#if (_NTO_VERSION >= 630)\n        case SDL_GL_RED_SIZE:\n             *value=this->gl_config.red_size;\n             break;\n        case SDL_GL_GREEN_SIZE:\n             *value=this->gl_config.green_size;\n             break;\n        case SDL_GL_BLUE_SIZE:\n             *value=this->gl_config.blue_size;\n             break;\n        case SDL_GL_ALPHA_SIZE:\n             *value=this->gl_config.alpha_size;\n             break;\n        case SDL_GL_ACCUM_RED_SIZE:\n             *value=this->gl_config.accum_red_size;\n             break;\n        case SDL_GL_ACCUM_GREEN_SIZE:\n             *value=this->gl_config.accum_green_size;\n             break;\n        case SDL_GL_ACCUM_BLUE_SIZE:\n             *value=this->gl_config.accum_blue_size;\n             break;\n        case SDL_GL_ACCUM_ALPHA_SIZE:\n             *value=this->gl_config.accum_alpha_size;\n             break;\n        case SDL_GL_STEREO:\n             *value=this->gl_config.stereo;\n             break;\n#endif /* 6.3.0 */\n        default:\n             *value=0;\n             return(-1);\n    }\n    return 0;\n}", "path": "SDL-1.2.13\\src\\video\\photon\\SDL_ph_gl.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Retrieve a variable named \"name\" from the environment */\n", "func_signal": "char *SDL_getenv(const char *name)", "code": "{\n\tint len, i;\n\tchar *value;\n\n\tvalue = (char *)0;\n\tif ( SDL_env ) {\n\t\tlen = SDL_strlen(name);\n\t\tfor ( i=0; SDL_env[i] && !value; ++i ) {\n\t\t\tif ( (SDL_strncmp(SDL_env[i], name, len) == 0) &&\n\t\t\t     (SDL_env[i][len] == '=') ) {\n\t\t\t\tvalue = &SDL_env[i][len+1];\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}", "path": "SDL-1.2.13\\src\\stdlib\\SDL_getenv.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* This code is actual for the Photon3D Runtime which was available prior to 6.3 only */\n", "func_signal": "int ph_SetupOpenGLContext(_THIS, int width, int height, int bpp, Uint32 flags)", "code": "{\n    PhDim_t dim;\n    uint64_t OGLAttrib[PH_OGL_MAX_ATTRIBS];\n    int exposepost=0;\n    int OGLargc;\n\n    dim.w=width;\n    dim.h=height;\n    \n    if ((oglctx!=NULL) && (oglflags==flags) && (oglbpp==bpp))\n    {\n       PdOpenGLContextResize(oglctx, &dim);\n       PhDCSetCurrent(oglctx);\n       return 0;\n    }\n    else\n    {\n       if (oglctx!=NULL)\n       {\n          PhDCSetCurrent(NULL);\n          PhDCRelease(oglctx);\n          oglctx=NULL;\n          exposepost=1;\n       }\n    }\n\n    OGLargc=0;\n    if (this->gl_config.depth_size)\n    {\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_DEPTH_BITS;\n        OGLAttrib[OGLargc++]=this->gl_config.depth_size;\n    }\n    if (this->gl_config.stencil_size)\n    {\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_STENCIL_BITS;\n        OGLAttrib[OGLargc++]=this->gl_config.stencil_size;\n    }\n    OGLAttrib[OGLargc++]=PHOGL_ATTRIB_FORCE_SW;\n    if (flags & SDL_FULLSCREEN)\n    {\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_FULLSCREEN;\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_DIRECT;\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_FULLSCREEN_BEST;\n        OGLAttrib[OGLargc++]=PHOGL_ATTRIB_FULLSCREEN_CENTER;\n    }\n    OGLAttrib[OGLargc++]=PHOGL_ATTRIB_NONE;\n\n    if (this->gl_config.double_buffer)\n    {\n        oglctx=PdCreateOpenGLContext(2, &dim, 0, OGLAttrib);\n    }\n    else\n    {\n        oglctx=PdCreateOpenGLContext(1, &dim, 0, OGLAttrib);\n    }\n\n    if (oglctx==NULL)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): cannot create OpenGL context !\\n\");\n        return -1;\n    }\n\n    PhDCSetCurrent(oglctx);\n\n    PtFlush();\n\n    oglflags=flags;\n    oglbpp=bpp;\n\n    if (exposepost!=0)\n    {\n        /* OpenGL context has been recreated, so report about this fact */\n        SDL_PrivateExpose();\n    }\n\n    return 0;\n}", "path": "SDL-1.2.13\\src\\video\\photon\\SDL_ph_gl.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,\n   int num_text)", "code": "{\n   int i;\n\n   png_debug1(1, \"in %s storage function\", (png_ptr->chunk_name[0] == '\\0' ?\n      \"text\" : (png_const_charp)png_ptr->chunk_name));\n\n   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)\n      return(0);\n\n   /* Make sure we have enough space in the \"text\" array in info_struct\n    * to hold all of the incoming text_ptr objects.\n    */\n   if (info_ptr->num_text + num_text > info_ptr->max_text)\n   {\n      if (info_ptr->text != NULL)\n      {\n         png_textp old_text;\n         int old_max;\n\n         old_max = info_ptr->max_text;\n         info_ptr->max_text = info_ptr->num_text + num_text + 8;\n         old_text = info_ptr->text;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));\n         if (info_ptr->text == NULL)\n           {\n             png_free(png_ptr, old_text);\n             return(1);\n           }\n         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *\n            png_sizeof(png_text)));\n         png_free(png_ptr, old_text);\n      }\n      else\n      {\n         info_ptr->max_text = num_text + 8;\n         info_ptr->num_text = 0;\n         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,\n            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));\n         if (info_ptr->text == NULL)\n           return(1);\n#ifdef PNG_FREE_ME_SUPPORTED\n         info_ptr->free_me |= PNG_FREE_TEXT;\n#endif\n      }\n      png_debug1(3, \"allocated %d entries for info_ptr->text\",\n         info_ptr->max_text);\n   }\n   for (i = 0; i < num_text; i++)\n   {\n      png_size_t text_length, key_len;\n      png_size_t lang_len, lang_key_len;\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\n\n      if (text_ptr[i].key == NULL)\n          continue;\n\n      key_len = png_strlen(text_ptr[i].key);\n\n      if (text_ptr[i].compression <= 0)\n      {\n        lang_len = 0;\n        lang_key_len = 0;\n      }\n      else\n#ifdef PNG_iTXt_SUPPORTED\n      {\n        /* set iTXt data */\n        if (text_ptr[i].lang != NULL)\n          lang_len = png_strlen(text_ptr[i].lang);\n        else\n          lang_len = 0;\n        if (text_ptr[i].lang_key != NULL)\n          lang_key_len = png_strlen(text_ptr[i].lang_key);\n        else\n          lang_key_len = 0;\n      }\n#else\n      {\n        png_warning(png_ptr, \"iTXt chunk not supported.\");\n        continue;\n      }\n#endif\n\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\n      {\n         text_length = 0;\n#ifdef PNG_iTXt_SUPPORTED\n         if (text_ptr[i].compression > 0)\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\n         else\n#endif\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\n      }\n      else\n      {\n         text_length = png_strlen(text_ptr[i].text);\n         textp->compression = text_ptr[i].compression;\n      }\n\n      textp->key = (png_charp)png_malloc_warn(png_ptr,\n         (png_uint_32)\n         (key_len + text_length + lang_len + lang_key_len + 4));\n      if (textp->key == NULL)\n        return(1);\n      png_debug2(2, \"Allocated %lu bytes at %x in png_set_text\",\n         (png_uint_32)\n         (key_len + lang_len + lang_key_len + text_length + 4),\n         (int)textp->key);\n\n      png_memcpy(textp->key, text_ptr[i].key,\n         (png_size_t)(key_len));\n      *(textp->key + key_len) = '\\0';\n#ifdef PNG_iTXt_SUPPORTED\n      if (text_ptr[i].compression > 0)\n      {\n         textp->lang = textp->key + key_len + 1;\n         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);\n         *(textp->lang + lang_len) = '\\0';\n         textp->lang_key = textp->lang + lang_len + 1;\n         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\n         *(textp->lang_key + lang_key_len) = '\\0';\n         textp->text = textp->lang_key + lang_key_len + 1;\n      }\n      else\n#endif\n      {\n#ifdef PNG_iTXt_SUPPORTED\n         textp->lang=NULL;\n         textp->lang_key=NULL;\n#endif\n         textp->text = textp->key + key_len + 1;\n      }\n      if (text_length)\n         png_memcpy(textp->text, text_ptr[i].text,\n            (png_size_t)(text_length));\n      *(textp->text + text_length) = '\\0';\n\n#ifdef PNG_iTXt_SUPPORTED\n      if (textp->compression > 0)\n      {\n         textp->text_length = 0;\n         textp->itxt_length = text_length;\n      }\n      else\n#endif\n      {\n         textp->text_length = text_length;\n#ifdef PNG_iTXt_SUPPORTED\n         textp->itxt_length = 0;\n#endif\n      }\n      info_ptr->num_text++;\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\n   }\n   return(0);\n}", "path": "libpng\\pngset.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* WARNING:  This may not work for systems with 64-bit pid_t */\n", "func_signal": "void SDL_WaitThread(SDL_Thread *thread, int *status)", "code": "{\n\terrno = 0;\n\twhile ( errno != ECHILD ) {\n\t\twaitpid(thread->handle, NULL, 0);\n\t}\n}", "path": "SDL-1.2.13\\src\\thread\\irix\\SDL_systhread.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/*\n * Note: If we are terminated, this could be called in the middle of\n * another SDL video routine -- notably UpdateRects.\n */\n", "func_signal": "void WSCONS_VideoQuit(_THIS)", "code": "{\n  int mode = WSDISPLAYIO_MODE_EMUL;\n\n  if (private->shadowmem != NULL) {\n    SDL_free(private->shadowmem);\n    private->shadowmem = NULL;\n  }\n  private->fbstart = NULL;\n  if (this->screen != NULL) {\n    this->screen->pixels = NULL;\n  }\n\n  if (private->SDL_modelist[0] != NULL) {\n    SDL_free(private->SDL_modelist[0]);\n    private->SDL_modelist[0] = NULL;\n  }\n\n  if (ioctl(private->fd, WSDISPLAYIO_SMODE, &mode) == -1) {\n    WSCONS_ReportError(\"ioctl SMODE\");\n  }\n\n  WSCONS_ReleaseKeyboard(this);\n\n  if (private->fd != -1) {\n    close(private->fd);\n    private->fd = -1;\n  }\n}", "path": "SDL-1.2.13\\src\\video\\wscons\\SDL_wsconsvideo.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Put a variable of the form \"name=value\" into the environment */\n", "func_signal": "int SDL_putenv(const char *variable)", "code": "{\n\tconst char *name, *value;\n\tint added;\n\tint len, i;\n\tchar **new_env;\n\tchar *new_variable;\n\n\t/* A little error checking */\n\tif ( ! variable ) {\n\t\treturn(-1);\n\t}\n\tname = variable;\n\tfor ( value=variable; *value && (*value != '='); ++value ) {\n\t\t/* Keep looking for '=' */ ;\n\t}\n\tif ( *value ) {\n\t\t++value;\n\t} else {\n\t\treturn(-1);\n\t}\n\n\t/* Allocate memory for the variable */\n\tnew_variable = SDL_strdup(variable);\n\tif ( ! new_variable ) {\n\t\treturn(-1);\n\t}\n\n\t/* Actually put it into the environment */\n\tadded = 0;\n\ti = 0;\n\tif ( SDL_env ) {\n\t\t/* Check to see if it's already there... */\n\t\tlen = (value - name);\n\t\tfor ( ; SDL_env[i]; ++i ) {\n\t\t\tif ( SDL_strncmp(SDL_env[i], name, len) == 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If we found it, just replace the entry */\n\t\tif ( SDL_env[i] ) {\n\t\t\tSDL_free(SDL_env[i]);\n\t\t\tSDL_env[i] = new_variable;\n\t\t\tadded = 1;\n\t\t}\n\t}\n\n\t/* Didn't find it in the environment, expand and add */\n\tif ( ! added ) {\n\t\tnew_env = SDL_realloc(SDL_env, (i+2)*sizeof(char *));\n\t\tif ( new_env ) {\n\t\t\tSDL_env = new_env;\n\t\t\tSDL_env[i++] = new_variable;\n\t\t\tSDL_env[i++] = (char *)0;\n\t\t\tadded = 1;\n\t\t} else {\n\t\t\tSDL_free(new_variable);\n\t\t}\n\t}\n\treturn (added ? 0 : -1);\n}", "path": "SDL-1.2.13\\src\\stdlib\\SDL_getenv.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* This function is called when there is a warning, but the library thinks\n * it can continue anyway.  Replacement functions don't have to do anything\n * here if you don't want to.  In the default configuration, png_ptr is\n * not used, but it is passed in case it may be useful.\n */\n", "func_signal": "static void\npngtest_warning(png_structp png_ptr, png_const_charp message)", "code": "{\n   PNG_CONST char *name = \"UNKNOWN (ERROR!)\";\n   if (png_ptr != NULL && png_ptr->error_ptr != NULL)\n      name = png_ptr->error_ptr;\n   fprintf(STDERR, \"%s: libpng warning: %s\\n\", name, message);\n}", "path": "libpng\\pngtest.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* returns 0 for success, 2 for libpng (longjmp) problem */\n", "func_signal": "int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length)", "code": "{\n    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;\n    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;\n\n\n    /* setjmp() must be called in every function that calls a PNG-reading\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->png_ptr = NULL;\n        mainprog_ptr->info_ptr = NULL;\n        return 2;\n    }\n\n\n    /* hand off the next chunk of input data to libpng for decoding */\n\n    png_process_data(png_ptr, info_ptr, rawbuf, length);\n\n    return 0;\n}", "path": "libpng\\contrib\\gregbook\\readpng2.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Retrieve a variable named \"name\" from the environment */\n", "func_signal": "char *SDL_getenv(const char *name)", "code": "{\n\tsize_t bufferlen;\n\n\tbufferlen = GetEnvironmentVariable(name, SDL_envmem, (DWORD)SDL_envmemlen);\n\tif ( bufferlen == 0 ) {\n\t\treturn NULL;\n\t}\n\tif ( bufferlen > SDL_envmemlen ) {\n\t\tchar *newmem = (char *)SDL_realloc(SDL_envmem, bufferlen);\n\t\tif ( newmem == NULL ) {\n\t\t\treturn NULL;\n\t\t}\n\t\tSDL_envmem = newmem;\n\t\tSDL_envmemlen = bufferlen;\n\t\tGetEnvironmentVariable(name, SDL_envmem, (DWORD)SDL_envmemlen);\n\t}\n\treturn SDL_envmem;\n}", "path": "SDL-1.2.13\\src\\stdlib\\SDL_getenv.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* This code is actual for the built-in PhGL support, which became available since 6.3 */\n", "func_signal": "int ph_SetupOpenGLContext(_THIS, int width, int height, int bpp, Uint32 flags)", "code": "{\n    qnxgl_buf_attrib_t qnxgl_attribs[PH_OGL_MAX_ATTRIBS];\n    qnxgl_buf_attrib_t* qnxgl_attribs_slide;\n    int num_interfaces = 0;\n    int num_buffers = 0;\n\n    /* Initialize the OpenGL subsystem */\n\n    num_interfaces = qnxgl_init(NULL, NULL, 0);\n\n    if (num_interfaces < 0)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): cannot initialize OpenGL subsystem !\\n\");\n        return -1;\n    }\n    if (num_interfaces == 0)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): there are no available OpenGL renderers was found !\\n\");\n        return -1;\n    }\n\n    /* Driver is linked */\n    this->gl_config.driver_loaded=1;\n\n    /* Initialize the OpenGL context attributes */\n    qnxgl_attribs_slide=qnxgl_attribs;\n\n    /* Depth size */\n    if (this->gl_config.depth_size)\n    {\n        fprintf(stderr, \"setted depth size %d\\n\", this->gl_config.depth_size);\n        qnxgl_attribs_slide = qnxgl_attrib_set_depth(qnxgl_attribs_slide, this->gl_config.depth_size);\n    }\n\n    /* Stencil size */\n    if (this->gl_config.stencil_size)\n    {\n        qnxgl_attribs_slide = qnxgl_attrib_set_stencil(qnxgl_attribs_slide, this->gl_config.stencil_size);\n    }\n\n    /* The sum of the accum bits of each channel */\n    if ((this->gl_config.accum_red_size != 0) && (this->gl_config.accum_blue_size != 0) &&\n        (this->gl_config.accum_green_size != 0))\n    {\n        qnxgl_attribs_slide = qnxgl_attrib_set_accum(qnxgl_attribs_slide,\n           this->gl_config.accum_red_size + this->gl_config.accum_blue_size +\n           this->gl_config.accum_green_size + this->gl_config.accum_alpha_size);\n    }\n    \n    /* Stereo mode */\n    if (this->gl_config.stereo)\n    {\n        qnxgl_attribs_slide = qnxgl_attrib_set_stereo(qnxgl_attribs_slide);\n    }\n\n    /* Fullscreen mode */\n    if ((flags & SDL_FULLSCREEN) == SDL_FULLSCREEN)\n    {\n        qnxgl_attribs_slide = qnxgl_attrib_set_hint_fullscreen(qnxgl_attribs_slide);\n    }\n    \n    /* Double buffering mode */\n    if (this->gl_config.double_buffer)\n    {\n        num_buffers=2;\n    }\n    else\n    {\n        num_buffers=1;\n    }\n\n    /* Loading the function pointers so we can use the extensions */\n    GLPH_LOAD_FUNCS_GC(oglctx);\n\n    /* Set the buffers region to be that of our window's region */\n    qnxgl_attribs_slide = glph_attrib_set_region(qnxgl_attribs_slide, PtWidgetRid(window));\n\n    /* End of the attributes array */\n    qnxgl_attribs_slide = qnxgl_attrib_set_end(qnxgl_attribs_slide);\n    \n    /* Create the buffers with the specified color model */\n    fprintf(stderr, \"ARGB: %d, %d, %d, %d\\n\", this->gl_config.alpha_size, this->gl_config.red_size, this->gl_config.green_size, this->gl_config.blue_size);\n    oglbuffers = qnxgl_buffers_create(\n                   QNXGL_FORMAT_BEST_RGB,\n/*                 __QNXGL_BUILD_FORMAT(0, __QNXGL_COLOR_MODEL_RGB, this->gl_config.alpha_size,\n                     this->gl_config.red_size, this->gl_config.green_size, this->gl_config.blue_size), */\n                 num_buffers, width, height, qnxgl_attribs, -1);\n\n\n    if (oglbuffers == NULL)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): failed to create OpenGL buffers !\\n\");\n        qnxgl_finish();\n        return -1;\n    }\n\n    /* Create a QNXGL context for the previously created buffer */\n    oglctx = qnxgl_context_create(oglbuffers, NULL);\n\n    if (oglctx == NULL)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): failed to create OpenGL context !\\n\");\n        qnxgl_buffers_destroy(oglbuffers);\n        qnxgl_finish();\n        return -1;\n    }\n\n    /* Attempt to make the context current so we can use OpenGL commands */\n    if (qnxgl_set_current(oglctx) == -1)\n    {\n        SDL_SetError(\"ph_SetupOpenGLContext(): failed to make the OpenGL context current !\\n\");\n        qnxgl_context_destroy(oglctx);\n        qnxgl_buffers_destroy(oglbuffers);\n        qnxgl_finish();\n        return -1;\n    }\n\n    PtFlush();\n\n    oglflags=flags;\n    oglbpp=bpp;\n\n    return 0;\n}", "path": "SDL-1.2.13\\src\\video\\photon\\SDL_ph_gl.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* this function was added to libpng 1.2.6 */\n", "func_signal": "void PNGAPI\npng_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max,\n    png_uint_32 user_height_max)", "code": "{\n    /* Images with dimensions larger than these limits will be\n     * rejected by png_set_IHDR().  To accept any PNG datastream\n     * regardless of dimensions, set both limits to 0x7ffffffL.\n     */\n    if (png_ptr == NULL) return;\n    png_ptr->user_width_max = user_width_max;\n    png_ptr->user_height_max = user_height_max;\n}", "path": "libpng\\pngset.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Free a pointer.  It is removed from the list at the same time. */\n", "func_signal": "void\npng_debug_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL)\n      fprintf(STDERR, \"NULL pointer to png_debug_free.\\n\");\n   if (ptr == 0)\n   {\n#if 0 /* This happens all the time. */\n      fprintf(STDERR, \"WARNING: freeing NULL pointer\\n\");\n#endif\n      return;\n   }\n\n   /* Unlink the element from the list. */\n   {\n      memory_infop FAR *ppinfo = &pinformation;\n      for (;;)\n      {\n         memory_infop pinfo = *ppinfo;\n         if (pinfo->pointer == ptr)\n         {\n            *ppinfo = pinfo->next;\n            current_allocation -= pinfo->size;\n            if (current_allocation < 0)\n               fprintf(STDERR, \"Duplicate free of memory\\n\");\n            /* We must free the list element too, but first kill\n               the memory that is to be freed. */\n            png_memset(ptr, 0x55, pinfo->size);\n            png_free_default(png_ptr, pinfo);\n            pinfo = NULL;\n            break;\n         }\n         if (pinfo->next == NULL)\n         {\n            fprintf(STDERR, \"Pointer %x not found\\n\", (unsigned int)ptr);\n            break;\n         }\n         ppinfo = &pinfo->next;\n      }\n   }\n\n   /* Finally free the data. */\n   if (verbose)\n      printf(\"Freeing %x\\n\", ptr);\n   png_free_default(png_ptr, ptr);\n   ptr = NULL;\n}", "path": "libpng\\pngtest.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/* Draw a randomly sized and colored box centered about (X,Y) */\n", "func_signal": "void DrawBox(SDL_Surface *screen, int X, int Y, int width, int height)", "code": "{\n\tstatic unsigned int seeded = 0;\n\tSDL_Rect area;\n\tUint32 color;\n        Uint32 randc;\n\n\t/* Seed the random number generator */\n\tif ( seeded == 0 ) {\n\t\tsrand(time(NULL));\n\t\tseeded = 1;\n\t}\n\n\t/* Get the bounds of the rectangle */\n\tarea.w = (rand()%width);\n\tarea.h = (rand()%height);\n\tarea.x = X-(area.w/2);\n\tarea.y = Y-(area.h/2);\n        randc = (rand()%NUM_COLORS);\n\n        if (screen->format->BytesPerPixel==1)\n        {\n            color = randc;\n        }\n        else\n        {\n            color = SDL_MapRGB(screen->format, randc, randc, randc);\n        }\n\n\t/* Do it! */\n\tSDL_FillRect(screen, &area, color);\n\tif ( screen->flags & SDL_DOUBLEBUF ) {\n\t\tSDL_Flip(screen);\n\t} else {\n\t\tSDL_UpdateRects(screen, 1, &area);\n\t}\n}", "path": "SDL-1.2.13\\test\\graywin.c", "repo_name": "Summeli/SDL_Symbian", "stars": 7, "license": "None", "language": "c", "size": 6436}
{"docstring": "/** Shared library initialization function: the _init() function is called\n *  after dlopen() has loaded the shared library. This function must not\n *  be declared static.\n */\n", "func_signal": "static void init(void)", "code": "{\n  check_threading_library();\n  vg_set_main_thread_state();\n  /* glibc up to and including version 2.7 triggers conflicting accesses   */\n  /* on stdout and stderr when sending output to one of these streams from */\n  /* more than one thread. Suppress data race reports on these objects.    */\n  DRD_IGNORE_VAR(*stdout);\n  DRD_IGNORE_VAR(*stderr);\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/**\n * Setup for interactive control of a callgrind run\n */\n", "func_signal": "static void setup_control(void)", "code": "{\n  Int fd, size;\n  SysRes res;\n  Char* dir;\n\n  CLG_ASSERT(thisPID != 0);\n\n  fd = -1;\n  dir = CLG_(get_out_directory)();\n  out_file = CLG_(get_out_file)();\n\n  /* name of command file */\n  size = VG_(strlen)(dir) + VG_(strlen)(DEFAULT_COMMANDNAME) +10;\n  command_file = (char*) CLG_MALLOC(\"cl.command.sc.1\", size);\n  CLG_ASSERT(command_file != 0);\n  VG_(sprintf)(command_file, \"%s/%s.%d\",\n\t       dir, DEFAULT_COMMANDNAME, thisPID);\n\n  /* This is for compatibility with the \"Force Now\" Button of current\n   * KCachegrind releases, as it doesn't use \".pid\" to distinguish\n   * different callgrind instances from same base directory.\n   */\n  command_file2 = (char*) CLG_MALLOC(\"cl.command.sc.2\", size);\n  CLG_ASSERT(command_file2 != 0);\n  VG_(sprintf)(command_file2, \"%s/%s\",\n\t       dir, DEFAULT_COMMANDNAME);\n\n  size = VG_(strlen)(dir) + VG_(strlen)(DEFAULT_RESULTNAME) +10;\n  result_file = (char*) CLG_MALLOC(\"cl.command.sc.3\", size);\n  CLG_ASSERT(result_file != 0);\n  VG_(sprintf)(result_file, \"%s/%s.%d\",\n\t       dir, DEFAULT_RESULTNAME, thisPID);\n\n  /* If we get a command from a command file without .pid, use\n   * a result file without .pid suffix\n   */\n  result_file2 = (char*) CLG_MALLOC(\"cl.command.sc.4\", size);\n  CLG_ASSERT(result_file2 != 0);\n  VG_(sprintf)(result_file2, \"%s/%s\",\n               dir, DEFAULT_RESULTNAME);\n\n  info_file = (char*) CLG_MALLOC(\"cl.command.sc.5\",\n                                 VG_(strlen)(DEFAULT_INFONAME) + 10);\n  CLG_ASSERT(info_file != 0);\n  VG_(sprintf)(info_file, \"%s.%d\", DEFAULT_INFONAME, thisPID);\n\n  CLG_DEBUG(1, \"Setup for interactive control (PID: %d):\\n\", thisPID);\n  CLG_DEBUG(1, \"  output file:    '%s'\\n\", out_file);\n  CLG_DEBUG(1, \"  command file:   '%s'\\n\", command_file);\n  CLG_DEBUG(1, \"  result file:    '%s'\\n\", result_file);\n  CLG_DEBUG(1, \"  info file:      '%s'\\n\", info_file);\n\n  /* create info file to indicate that we are running */ \n  res = VG_(open)(info_file, VKI_O_WRONLY|VKI_O_TRUNC, 0);\n  if (res.isError) { \n    res = VG_(open)(info_file, VKI_O_CREAT|VKI_O_WRONLY,\n\t\t   VKI_S_IRUSR|VKI_S_IWUSR);\n    if (res.isError) {\n      VG_(message)(Vg_DebugMsg, \n\t\t   \"warning: can't write info file '%s'\", info_file);\n      info_file = 0;\n      fd = -1;\n    }\n  }\n  if (!res.isError)\n      fd = (Int) res.res;\n  if (fd>=0) {\n    Char buf[512];\n    Int i;\n\n    WRITE_STR3(fd,\n\t       \"# This file is generated by Callgrind-\" VERSION \".\\n\"\n\t       \"# It is used to enable controlling the supervision of\\n\"\n\t       \"#  '\", VG_(args_the_exename), \"'\\n\"\n\t       \"# by external tools.\\n\\n\");\n    \n    VG_(sprintf)(buf, \"version: \" COMMAND_VERSION \"\\n\");\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n    \n    WRITE_STR3(fd, \"base: \", dir, \"\\n\");\n    WRITE_STR3(fd, \"dumps: \", out_file, \"\\n\");\n    WRITE_STR3(fd, \"control: \", command_file, \"\\n\");\n    WRITE_STR3(fd, \"result: \", result_file, \"\\n\");\n\n    WRITE_STR2(fd, \"cmd: \", VG_(args_the_exename));    \n    for (i = 0; i < VG_(sizeXA)( VG_(args_for_client) ); i++) {\n        HChar* arg = * (HChar**)VG_(indexXA)( VG_(args_for_client), i );\n\tif (!arg) continue;\n\tWRITE_STR2(fd, \" \", arg);\n    }\n    VG_(write)(fd, \"\\n\", 1);\n    VG_(close)(fd);\n  }\n}", "path": "callgrind\\command.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// pthread_mutex_init\n", "func_signal": "PTH_FUNC(int, pthreadZumutexZuinit,\n         pthread_mutex_t *mutex,\n         const pthread_mutexattr_t* attr)", "code": "{\n  int ret;\n  int res;\n  OrigFn fn;\n  int mt;\n  VALGRIND_GET_ORIG_FN(fn);\n  mt = PTHREAD_MUTEX_DEFAULT;\n  if (attr)\n    pthread_mutexattr_gettype(attr, &mt);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__PRE_MUTEX_INIT,\n                             mutex, pthread_to_drd_mutex_type(mt), 0, 0, 0);\n  CALL_FN_W_WW(ret, fn, mutex, attr);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__POST_MUTEX_INIT,\n                             mutex, 0, 0, 0, 0);\n  return ret;\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Run Info: Persistant information of the callgrind run */\n", "func_signal": "static Int dump_info(Int fd)", "code": "{\n    Char* buf = outbuf;\n    int i;\n    \n    if ( (fd = createRes(fd)) <0) return fd;\n\n    /* creator */\n    VG_(sprintf)(buf, \"creator: callgrind-\" VERSION \"\\n\");\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    /* version */\n    VG_(sprintf)(buf, \"version: \" COMMAND_VERSION \"\\n\");\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n    \n    /* \"pid:\" line */\n    VG_(sprintf)(buf, \"pid: %d\\n\", VG_(getpid)());\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n    \n    /* \"base:\" line */\n    WRITE_STR3(fd, \"base: \", out_file, \"\\n\");\n    \n    /* \"cmd:\" line */\n    WRITE_STR2(fd, \"cmd: \", VG_(args_the_exename));\n    for (i = 0; i < VG_(sizeXA)( VG_(args_for_client) ); i++) {\n        HChar* arg = * (HChar**)VG_(indexXA)( VG_(args_for_client), i );\n\tif (!arg) continue;\n\tWRITE_STR2(fd, \" \", arg);\n    }\n    VG_(write)(fd, \"\\n\", 1);\n\n    return fd;\n}", "path": "callgrind\\command.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// pthread_detach\n", "func_signal": "PTH_FUNC(int, pthreadZudetach, pthread_t pt_thread)", "code": "{\n  int ret;\n  OrigFn fn;\n  VALGRIND_GET_ORIG_FN(fn);\n  {\n    CALL_FN_W_W(ret, fn, pt_thread);\n    if (ret == 0)\n    {\n      vg_set_joinable(pt_thread, 0);\n    }\n  }\n  return ret;\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/** Stop and print an error message in case a non-supported threading\n *  library (LinuxThreads) has been detected.\n */\n", "func_signal": "static void check_threading_library(void)", "code": "{\n  if (detected_linuxthreads())\n  {\n    if (getenv(\"LD_ASSUME_KERNEL\"))\n    {\n      fprintf(stderr,\n              \"Detected the LinuxThreads threading library. Sorry, but DRD only supports\\n\"\n              \"the newer NPTL (Native POSIX Threads Library). Please try to rerun DRD\\n\"\n              \"after having unset the environment variable LD_ASSUME_KERNEL. Giving up.\\n\"\n              );\n    }\n    else\n    {\n      fprintf(stderr,\n              \"Detected the LinuxThreads threading library. Sorry, but DRD only supports\\n\"\n              \"the newer NPTL (Native POSIX Threads Library). Please try to rerun DRD\\n\"\n              \"after having upgraded to a newer version of your Linux distribution.\\n\"\n              \"Giving up.\\n\"\n              );\n    }\n    abort();\n  }\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// Function definitions.\n", "func_signal": "int main(int argc, char** argv)", "code": "{\n  int optchar;\n  pthread_t threadid;\n\n  while ((optchar = getopt(argc, argv, \"dmp\")) != EOF)\n  {\n    switch (optchar)\n    {\n    case 'd':\n      s_debug = 1;\n      break;\n    case 'm':\n      s_do_mutual_exclusion = 1;\n      break;\n    case 'p':\n      s_do_printf = 1;\n      break;\n    default:\n      assert(0);\n    }\n  }\n\n  sem_init(&s_sem, 0, 1);\n\n  // Switch to line-buffered mode, such that timing information can be \n  // obtained for each printf() call with strace.\n  setlinebuf(stdout);\n\n  if (s_debug)\n  {\n    printf(\"&s_d1 = %p; &s_d2 = %p; &s_d3 = %p\\n\", &s_d1, &s_d2, &s_d3);\n  }\n\n  s_d1 = 1;\n  s_d3 = 3;\n\n  pthread_create(&threadid, 0, thread_func, 0);\n  // Wait until the printf() in the created thread finished.\n\n  {\n    if (s_do_mutual_exclusion) sem_wait(&s_sem);\n    s_d3++;\n    if (s_do_mutual_exclusion) sem_post(&s_sem);\n  }\n\n  // Wait until the thread finished.\n  //printf(\"Before call to pthread_join()\\n\");\n  //fflush(stdout);\n  pthread_join(threadid, 0);\n  //printf(\"After call to pthread_join()\\n\");\n  //fflush(stdout);\n  if (s_do_printf) printf(\"s_d2 = %g (should be 2)\\n\", s_d2);\n  if (s_do_printf) printf(\"s_d3 = %g (should be 5)\\n\", s_d3);\n\n  sem_destroy(&s_sem);\n\n  return 0;\n}", "path": "drd\\tests\\sem_as_mutex.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Build the Valgrind-specific part of a signal frame. */\n", "func_signal": "static void build_vg_sigframe(struct vg_sigframe *frame,\n\t\t\t      ThreadState *tst,\n\t\t\t      const vki_sigset_t *mask,\n\t\t\t      UInt flags,\n\t\t\t      Int sigNo)", "code": "{\n   frame->sigNo_private = sigNo;\n   frame->magicPI       = 0x31415927;\n   frame->vex_shadow1   = tst->arch.vex_shadow1;\n   frame->vex_shadow2   = tst->arch.vex_shadow2;\n   /* HACK ALERT */\n   frame->vex           = tst->arch.vex;\n   /* end HACK ALERT */\n   frame->mask          = tst->sig_mask;\n   frame->handlerflags  = flags;\n   frame->magicE        = 0x27182818;\n}", "path": "coregrind\\m_sigframe\\sigframe-amd64-linux.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// pthread_cancel\n", "func_signal": "PTH_FUNC(int, pthreadZucancel, pthread_t pt_thread)", "code": "{\n  int res;\n  int ret;\n  OrigFn fn;\n  VALGRIND_GET_ORIG_FN(fn);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__PRE_THREAD_CANCEL,\n                             pt_thread, 0, 0, 0, 0);\n  CALL_FN_W_W(ret, fn, pt_thread);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__POST_THREAD_CANCEL,\n                             pt_thread, ret==0, 0, 0, 0);\n  return ret;\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/*------------------------------------------------------------*/\n/*--- Statistics printing                                  ---*/\n/*------------------------------------------------------------*/\n", "func_signal": "void drd_print_malloc_stats(void)", "code": "{\n  DRD_Chunk* mc;\n  SizeT     nblocks = 0;\n  SizeT     nbytes  = 0;\n   \n  if (VG_(clo_verbosity) == 0)\n    return;\n  if (VG_(clo_xml))\n    return;\n\n  /* Count memory still in use. */\n  VG_(HT_ResetIter)(drd_malloc_list);\n  while ((mc = VG_(HT_Next)(drd_malloc_list)))\n  {\n    nblocks++;\n    nbytes += mc->size;\n  }\n\n  VG_(message)(Vg_DebugMsg, \n               \"malloc/free: in use at exit: %lu bytes in %lu blocks.\",\n               nbytes, nblocks);\n  VG_(message)(Vg_DebugMsg, \n               \"malloc/free: %lu allocs, %lu frees, %lu bytes allocated.\",\n               cmalloc_n_mallocs,\n               cmalloc_n_frees, cmalloc_bs_mallocd);\n  if (VG_(clo_verbosity) > 1)\n    VG_(message)(Vg_DebugMsg, \" \");\n}", "path": "drd\\drd_malloc_wrappers.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// pthread_mutex_destroy\n", "func_signal": "PTH_FUNC(int, pthreadZumutexZudestroy,\n         pthread_mutex_t *mutex)", "code": "{\n  int ret;\n  int res;\n  OrigFn fn;\n  VALGRIND_GET_ORIG_FN(fn);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__PRE_MUTEX_DESTROY,\n                             mutex, 0, 0, 0, 0);\n  CALL_FN_W_W(ret, fn, mutex);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__POST_MUTEX_DESTROY,\n                             mutex, mutex_type(mutex), 0, 0, 0);\n  return ret;\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Do trivial stuff with a reader-writer lock. */\n", "func_signal": "int main ( void )", "code": "{\n  int r;\n  pthread_rwlock_t rwl;\n\n  r = pthread_rwlock_init( &rwl, NULL );  assert(r == 0);\n\n  r = pthread_rwlock_wrlock( &rwl );      assert(r == 0);\n  r = pthread_rwlock_unlock( &rwl );      assert(r == 0);\n\n  r = pthread_rwlock_rdlock( &rwl );      assert(r == 0);\n  r = pthread_rwlock_rdlock( &rwl );      assert(r == 0);\n  r = pthread_rwlock_unlock( &rwl );      assert(r == 0);\n  r = pthread_rwlock_unlock( &rwl );      assert(r == 0);\n\n  /* this should fail - lock is unowned now */\n  r = pthread_rwlock_unlock( &rwl );      assert(r == 0);\n\n  r = pthread_rwlock_destroy( &rwl );     assert(r == 0);\n\n  return 0;\n}", "path": "helgrind\\tests\\tc12_rwl_trivial.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// pthread_create*\n", "func_signal": "pthread_t *thread, const pthread_attr_t *attr,\n         void *(*start) (void *), void *arg)", "code": "{\n  int    res;\n  int    ret;\n  OrigFn fn;\n  VgPosixThreadArgs vgargs;\n\n  VALGRIND_GET_ORIG_FN(fn);\n\n  vg_start_suppression(&vgargs.wrapper_started,\n                       sizeof(vgargs.wrapper_started));\n  vgargs.start = start;\n  vgargs.arg   = arg;\n  vgargs.wrapper_started = 0;\n  vgargs.detachstate = PTHREAD_CREATE_JOINABLE;\n  if (attr)\n  {\n    if (pthread_attr_getdetachstate(attr, &vgargs.detachstate) != 0)\n    {\n      assert(0);\n    }\n  }\n  assert(vgargs.detachstate == PTHREAD_CREATE_JOINABLE\n         || vgargs.detachstate == PTHREAD_CREATE_DETACHED);\n#if 0\n  pthread_mutex_init(&vgargs.mutex, 0);\n  pthread_cond_init(&vgargs.cond, 0);\n  pthread_mutex_lock(&vgargs.mutex);\n#endif\n  /* Suppress NPTL-specific conflicts between creator and created thread. */\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__DRD_STOP_RECORDING,\n                             0, 0, 0, 0, 0);\n  CALL_FN_W_WWWW(ret, fn, thread, attr, vg_thread_wrapper, &vgargs);\n  VALGRIND_DO_CLIENT_REQUEST(res, -1, VG_USERREQ__DRD_START_RECORDING,\n                             0, 0, 0, 0, 0);\n#if 0\n  pthread_cond_wait(&vgargs.cond, &vgargs.mutex);\n  pthread_mutex_unlock(&vgargs.mutex);\n  pthread_cond_destroy(&vgargs.cond);\n  pthread_mutex_destroy(&vgargs.mutex);\n#else\n  // Yes, you see it correctly, busy waiting ... The problem is that\n  // POSIX threads functions cannot be called here -- the functions defined\n  // in this file (drd_intercepts.c) would be called instead of those in\n  // libpthread.so. This loop is necessary because vgargs is allocated on the\n  // stack, and the created thread reads it.\n  if (ret == 0)\n  {\n    while (! vgargs.wrapper_started)\n    {\n      sched_yield();\n    }\n  }\n#endif\n  return ret;\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/** Return 1 if LinuxThread has been detected, and 0 otherwise. */\n", "func_signal": "static int detected_linuxthreads(void)", "code": "{\n#if defined(linux)\n#if defined(_CS_GNU_LIBPTHREAD_VERSION)\n  /* Linux with a recent glibc. */\n  char buffer[256];\n  unsigned len;\n  len = confstr(_CS_GNU_LIBPTHREAD_VERSION, buffer, sizeof(buffer));\n  assert(len <= sizeof(buffer));\n  return len > 0 && buffer[0] == 'l';\n#else\n  /* Linux without _CS_GNU_LIBPTHREAD_VERSION: most likely LinuxThreads. */\n  return 1;\n#endif\n#else\n  /* Another OS than Linux, hence no LinuxThreads. */\n  return 0;\n#endif\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Return False and don't do anything, just set the client to take a\n   segfault, if it looks like the frame is corrupted. */\n", "func_signal": "static \nBool restore_vg_sigframe ( ThreadState *tst, \n                           struct vg_sigframe *frame, Int *sigNo )", "code": "{\n   if (frame->magicPI != 0x31415927 ||\n       frame->magicE  != 0x27182818) {\n      VG_(message)(Vg_UserMsg, \"Thread %d return signal frame \"\n                               \"corrupted.  Killing process.\",\n\t\t   tst->tid);\n      VG_(set_default_handler)(VKI_SIGSEGV);\n      VG_(synth_fault)(tst->tid);\n      *sigNo = VKI_SIGSEGV;\n      return False;\n   }\n   tst->sig_mask         = frame->mask;\n   tst->tmp_sig_mask     = frame->mask;\n   tst->arch.vex_shadow1 = frame->vex_shadow1;\n   tst->arch.vex_shadow2 = frame->vex_shadow2;\n   /* HACK ALERT */\n   tst->arch.vex         = frame->vex;\n   /* end HACK ALERT */\n   *sigNo                = frame->sigNo_private;\n   return True;\n}", "path": "coregrind\\m_sigframe\\sigframe-amd64-linux.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Dump info on current callgrind state */\n", "func_signal": "static Int dump_state(Int fd)", "code": "{\n    Char* buf = outbuf;\n    thread_info** th;\n    int t, p;\n    Int orig_tid = CLG_(current_tid);\n\n    if ( (fd = createRes(fd)) <0) return fd;\n\n    VG_(sprintf)(buf, \"instrumentation: %s\\n\",\n\t\t CLG_(instrument_state) ? \"on\":\"off\");\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    if (!CLG_(instrument_state)) return fd;\n\n    VG_(sprintf)(buf, \"executed-bbs: %llu\\n\", CLG_(stat).bb_executions);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    VG_(sprintf)(buf, \"executed-calls: %llu\\n\", CLG_(stat).call_counter);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    VG_(sprintf)(buf, \"distinct-bbs: %d\\n\", CLG_(stat).distinct_bbs);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    VG_(sprintf)(buf, \"distinct-calls: %d\\n\", CLG_(stat).distinct_jccs);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    VG_(sprintf)(buf, \"distinct-functions: %d\\n\", CLG_(stat).distinct_fns);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    VG_(sprintf)(buf, \"distinct-contexts: %d\\n\", CLG_(stat).distinct_contexts);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    /* \"events:\" line. Given here because it will be dynamic in the future */\n    p = VG_(sprintf)(buf, \"events: \");\n    CLG_(sprint_eventmapping)(buf+p, CLG_(dumpmap));\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n    VG_(write)(fd, \"\\n\", 1);\n\t\t\n    /* \"part:\" line (number of last part. Is 0 at start */\n    VG_(sprintf)(buf, \"\\npart: %d\\n\", CLG_(get_dump_counter)());\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\t\t\n    /* threads */\n    th = CLG_(get_threads)();\n    p = VG_(sprintf)(buf, \"threads:\");\n    for(t=1;t<VG_N_THREADS;t++) {\n\tif (!th[t]) continue;\n\tp += VG_(sprintf)(buf+p, \" %d\", t);\n    }\n    p += VG_(sprintf)(buf+p, \"\\n\");\n    VG_(write)(fd, (void*)buf, p);\n\n    VG_(sprintf)(buf, \"current-tid: %d\\n\", orig_tid);\n    VG_(write)(fd, (void*)buf, VG_(strlen)(buf));\n\n    /* current event counters */\n    dump_fd = fd;\n    CLG_(forall_threads)(dump_state_of_thread);\n\n    return fd;\n}", "path": "callgrind\\command.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/** @note The function mutex_type() has been declared inline in order\n *  to avoid that it shows up in call stacks.\n */\n", "func_signal": "static __inline__ MutexT mutex_type(pthread_mutex_t* mutex)", "code": "{\n#if defined(HAVE_PTHREAD_MUTEX_T__M_KIND)\n  /* LinuxThreads. */\n  const int kind = mutex->__m_kind;\n#elif defined(HAVE_PTHREAD_MUTEX_T__DATA__KIND)\n  /* NPTL. */\n  const int kind = mutex->__data.__kind;\n#else\n  /* Another POSIX threads implementation. Regression tests will fail. */\n  const int kind = PTHREAD_MUTEX_DEFAULT;\n  fprintf(stderr,\n          \"Did not recognize your POSIX threads implementation. Giving up.\\n\");\n  assert(0);\n#endif\n  return pthread_to_drd_mutex_type(kind);\n}", "path": "drd\\drd_pthread_intercepts.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "// The comparisons use SUB instructions, and this can result in having a\n// (nonptr - ptr) situation legitimately;  at one point I was flagging\n// errors when that happened.\n", "func_signal": "int main(void)", "code": "{\n   char* buf = malloc(sizeof(char) * 6);\n\n   // Known zero non-pointer\n   char* nz = (char*)((long)buf^(long)buf);  // known non-pointer\n\n   // Unknown zero nonptr;  make them zero but unknown\n   char* unz;\n   ((char*)&unz)[0] = '\\0';\n   ((char*)&unz)[1] = '\\0';\n   ((char*)&unz)[2] = '\\0';\n   ((char*)&unz)[3] = '\\0';\n\n   if (buf == nz)  return 1;\n   if (nz  == buf) return 1;     // --> n - p, but legitimate\n   if (buf == unz) return 1;\n   if (unz == buf) return 1;\n\n   return 0;\n}", "path": "exp-ptrcheck\\tests\\cmp.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Extend the stack segment downwards if needed so as to ensure the\n   new signal frames are mapped to something.  Return a Bool\n   indicating whether or not the operation was successful.\n*/\n", "func_signal": "static Bool extend ( ThreadState *tst, Addr addr, SizeT size )", "code": "{\n   ThreadId        tid = tst->tid;\n   NSegment const* stackseg = NULL;\n\n   if (VG_(extend_stack)(addr, tst->client_stack_szB)) {\n      stackseg = VG_(am_find_nsegment)(addr);\n      if (0 && stackseg)\n\t VG_(printf)(\"frame=%#lx seg=%#lx-%#lx\\n\",\n\t\t     addr, stackseg->start, stackseg->end);\n   }\n\n   if (stackseg == NULL || !stackseg->hasR || !stackseg->hasW) {\n      VG_(message)(\n         Vg_UserMsg,\n         \"Can't extend stack to %#lx during signal delivery for thread %d:\",\n         addr, tid);\n      if (stackseg == NULL)\n         VG_(message)(Vg_UserMsg, \"  no stack segment\");\n      else\n         VG_(message)(Vg_UserMsg, \"  too small or bad protection modes\");\n\n      /* set SIGSEGV to default handler */\n      VG_(set_default_handler)(VKI_SIGSEGV);\n      VG_(synth_fault_mapping)(tid, addr);\n\n      /* The whole process should be about to die, since the default\n\t action of SIGSEGV to kill the whole process. */\n      return False;\n   }\n\n   /* For tracking memory events, indicate the entire frame has been\n      allocated. */\n   VG_TRACK( new_mem_stack_signal, addr - VG_STACK_REDZONE_SZB,\n             size + VG_STACK_REDZONE_SZB, tid );\n\n   return True;\n}", "path": "coregrind\\m_sigframe\\sigframe-amd64-linux.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/* Allocate memory and note change in memory available */\n", "func_signal": "static\n__inline__\nvoid* drd_new_block(ThreadId tid,\n                    SizeT size, SizeT align,\n                    Bool is_zeroed)", "code": "{\n  Addr p;\n\n  cmalloc_n_mallocs ++;\n\n  // Allocate and zero\n  p = (Addr)VG_(cli_malloc)(align, size);\n  if (!p) {\n    return NULL;\n  }\n  if (is_zeroed) VG_(memset)((void*)p, 0, size);\n  s_start_using_mem_callback(p, p + size, 0/*ec_uniq*/);\n\n  // Only update this stat if allocation succeeded.\n  cmalloc_bs_mallocd += size;\n\n  VG_(HT_add_node)(drd_malloc_list, create_DRD_Chunk(tid, p, size));\n\n  return (void*)p;\n}", "path": "drd\\drd_malloc_wrappers.c", "repo_name": "eeight/tdheap", "stars": 7, "license": "gpl-2.0", "language": "c", "size": 24756}
{"docstring": "/*\n * Final wrapup - pad to 64-byte boundary with the bit pattern\n * 1 0* (64-bit count of bits processed, MSB-first)\n */\n", "func_signal": "static void MD5Final(unsigned char digest[16], struct MD5Context *ctx)", "code": "{\n    unsigned count;\n    unsigned char *p;\n\n    /* Compute number of bytes mod 64 */\n    count = (ctx->bits[0] >> 3) & 0x3F;\n\n    /* Set the first char of padding to 0x80.  This is safe since there is\n       always at least one byte free */\n    p = ctx->in + count;\n    *p++ = 0x80;\n\n    /* Bytes of padding needed to make 64 bytes */\n    count = 64 - 1 - count;\n\n    /* Pad out to 56 mod 64 */\n    if (count < 8) {\n\t/* Two lots of padding:  Pad the first block to 64 bytes */\n\tmemset(p, 0, count);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (FcChar32 *) ctx->in);\n\n\t/* Now fill the next block with 56 bytes */\n\tmemset(ctx->in, 0, 56);\n    } else {\n\t/* Pad block to 56 bytes */\n\tmemset(p, 0, count - 8);\n    }\n    byteReverse(ctx->in, 14);\n\n    /* Append length in bits and transform */\n    ((FcChar32 *) ctx->in)[14] = ctx->bits[0];\n    ((FcChar32 *) ctx->in)[15] = ctx->bits[1];\n\n    MD5Transform(ctx->buf, (FcChar32 *) ctx->in);\n    byteReverse((unsigned char *) ctx->buf, 4);\n    memcpy(digest, ctx->buf, 16);\n    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * The core of the MD5 algorithm, this alters an existing MD5 hash to\n * reflect the addition of 16 longwords of new data.  MD5Update blocks\n * the data and converts bytes into longwords for this routine.\n */\n", "func_signal": "static void MD5Transform(FcChar32 buf[4], FcChar32 in[16])", "code": "{\n    register FcChar32 a, b, c, d;\n\n    a = buf[0];\n    b = buf[1];\n    c = buf[2];\n    d = buf[3];\n\n    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n    buf[0] += a;\n    buf[1] += b;\n    buf[2] += c;\n    buf[3] += d;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Given a cache and an object, return a pointer to where\n * the serialized copy of the object is stored\n */\n", "func_signal": "void *\nFcSerializePtr (FcSerialize *serialize, const void *object)", "code": "{\n    intptr_t\toffset = FcSerializeOffset (serialize, object);\n\n    if (!offset)\n\treturn NULL;\n    return (void *) ((char *) serialize->linear + offset);\n}", "path": "src\\fcserialize.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Map a cache file into memory\n */\n", "func_signal": "static FcCache *\nFcDirCacheMapFd (int fd, struct stat *fd_stat, struct stat *dir_stat)", "code": "{\n    FcCache\t*cache;\n    FcBool\tallocated = FcFalse;\n\n    if (fd_stat->st_size < sizeof (FcCache))\n\treturn NULL;\n    cache = FcCacheFindByStat (fd_stat);\n    if (cache)\n    {\n\tif (FcCacheTimeValid (cache, dir_stat))\n\t    return cache;\n\tFcDirCacheUnload (cache);\n\tcache = NULL;\n    }\n\n    /*\n     * Lage cache files are mmap'ed, smaller cache files are read. This\n     * balances the system cost of mmap against per-process memory usage.\n     */\n    if (fd_stat->st_size >= FC_CACHE_MIN_MMAP)\n    {\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\tcache = mmap (0, fd_stat->st_size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (cache == MAP_FAILED)\n\t    cache = NULL;\n#elif defined(_WIN32)\n\t{\n\t    HANDLE hFileMap;\n\n\t    cache = NULL;\n\t    hFileMap = CreateFileMapping((HANDLE) _get_osfhandle(fd), NULL,\n\t\t\t\t\t PAGE_READONLY, 0, 0, NULL);\n\t    if (hFileMap != NULL)\n\t    {\n\t\tcache = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0,\n\t\t\t\t       fd_stat->st_size);\n\t\tCloseHandle (hFileMap);\n\t    }\n\t}\n#endif\n    }\n    if (!cache)\n    {\n\tcache = malloc (fd_stat->st_size);\n\tif (!cache)\n\t    return NULL;\n\n\tif (read (fd, cache, fd_stat->st_size) != fd_stat->st_size)\n\t{\n\t    free (cache);\n\t    return NULL;\n\t}\n\tallocated = FcTrue;\n    }\n    if (cache->magic != FC_CACHE_MAGIC_MMAP ||\n\tcache->version < FC_CACHE_CONTENT_VERSION ||\n\tcache->size != fd_stat->st_size ||\n\t!FcCacheTimeValid (cache, dir_stat) ||\n\t!FcCacheInsert (cache, fd_stat))\n    {\n\tif (allocated)\n\t    free (cache);\n\telse\n\t{\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\t    munmap (cache, fd_stat->st_size);\n#elif defined(_WIN32)\n\t    UnmapViewOfFile (cache);\n#endif\n\t}\n\treturn NULL;\n    }\n\n    /* Mark allocated caches so they're freed rather than unmapped */\n    if (allocated)\n\tcache->magic = FC_CACHE_MAGIC_ALLOC;\n\t\n    return cache;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Load the configuration files and scan for available fonts\n */\n", "func_signal": "FcConfig *\nFcInitLoadConfigAndFonts (void)", "code": "{\n    FcConfig\t*config = FcInitLoadConfig ();\n\n    FcInitDebug ();\n    if (!config)\n\treturn 0;\n    if (!FcConfigBuildFonts (config))\n    {\n\tFcConfigDestroy (config);\n\treturn 0;\n    }\n    return config;\n}", "path": "src\\fcinit.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Generate a random level number, distributed\n * so that each level is 1/4 as likely as the one before\n *\n * Note that level numbers run 1 <= level <= MAX_LEVEL\n */\n", "func_signal": "static int\nrandom_level (void)", "code": "{\n    /* tricky bit -- each bit is '1' 75% of the time */\n    long int\tbits = FcRandom () | FcRandom ();\n    int\tlevel = 0;\n\n    while (++level < FC_CACHE_MAX_LEVEL)\n    {\n\tif (bits & 1)\n\t    break;\n\tbits >>= 1;\n    }\n    return level;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Free all library-allocated data structures.\n */\n", "func_signal": "void\nFcFini (void)", "code": "{\n    if (_fcConfig)\n\tFcConfigDestroy (_fcConfig);\n\n    FcPatternFini ();\n    FcCacheFini ();\n    if (FcDebug() & FC_DBG_MEMORY)\n\tFcMemReport ();\n}", "path": "src\\fcinit.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/* write serialized state to the cache file */\n", "func_signal": "FcBool\nFcDirCacheWrite (FcCache *cache, FcConfig *config)", "code": "{\n    FcChar8\t    *dir = FcCacheDir (cache);\n    FcChar8\t    cache_base[CACHEBASE_LEN];\n    FcChar8\t    *cache_hashed;\n    int \t    fd;\n    FcAtomic \t    *atomic;\n    FcStrList\t    *list;\n    FcChar8\t    *cache_dir = NULL;\n    FcChar8\t    *test_dir;\n    FcCacheSkip     *skip;\n    struct stat     cache_stat;\n    int\t\t    magic;\n    int\t\t    written;\n\n    /*\n     * Write it to the first directory in the list which is writable\n     */\n\n    list = FcStrListCreate (config->cacheDirs);\n    if (!list)\n\treturn FcFalse;\n    while ((test_dir = FcStrListNext (list))) {\n\tif (access ((char *) test_dir, W_OK|X_OK) == 0)\n\t{\n\t    cache_dir = test_dir;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * If the directory doesn't exist, try to create it\n\t     */\n\t    if (access ((char *) test_dir, F_OK) == -1) {\n\t\tif (FcMakeDirectory (test_dir))\n\t\t{\n\t\t    cache_dir = test_dir;\n\t\t    break;\n\t\t}\n\t    }\n\t    /*\n\t     * Otherwise, try making it writable\n\t     */\n\t    else if (chmod ((char *) test_dir, 0755) == 0)\n\t    {\n\t\tcache_dir = test_dir;\n\t\tbreak;\n\t    }\n\t}\n    }\n    FcStrListDone (list);\n    if (!cache_dir)\n\treturn FcFalse;\n\n    FcDirCacheBasename (dir, cache_base);\n    cache_hashed = FcStrPlus (cache_dir, cache_base);\n    if (!cache_hashed)\n        return FcFalse;\n\n    if (FcDebug () & FC_DBG_CACHE)\n        printf (\"FcDirCacheWriteDir dir \\\"%s\\\" file \\\"%s\\\"\\n\",\n\t\tdir, cache_hashed);\n\n    atomic = FcAtomicCreate ((FcChar8 *)cache_hashed);\n    if (!atomic)\n\tgoto bail1;\n\n    if (!FcAtomicLock (atomic))\n\tgoto bail3;\n\n    fd = open((char *)FcAtomicNewFile (atomic), O_RDWR | O_CREAT | O_BINARY, 0666);\n    if (fd == -1)\n\tgoto bail4;\n\n    /* Temporarily switch magic to MMAP while writing to file */\n    magic = cache->magic;\n    if (magic != FC_CACHE_MAGIC_MMAP)\n\tcache->magic = FC_CACHE_MAGIC_MMAP;\n\n    /*\n     * Write cache contents to file\n     */\n    written = write (fd, cache, cache->size);\n\n    /* Switch magic back */\n    if (magic != FC_CACHE_MAGIC_MMAP)\n\tcache->magic = magic;\n\n    if (written != cache->size)\n    {\n\tperror (\"write cache\");\n\tgoto bail5;\n    }\n\n    close(fd);\n    if (!FcAtomicReplaceOrig(atomic))\n        goto bail4;\n\n    /* If the file is small, update the cache chain entry such that the\n     * new cache file is not read again.  If it's large, we don't do that\n     * such that we reload it, using mmap, which is shared across processes.\n     */\n    if (cache->size < FC_CACHE_MIN_MMAP &&\n\t(skip = FcCacheFindByAddr (cache)) &&\n\tFcStat (cache_hashed, &cache_stat))\n    {\n\tskip->cache_dev = cache_stat.st_dev;\n\tskip->cache_ino = cache_stat.st_ino;\n\tskip->cache_mtime = cache_stat.st_mtime;\n    }\n\n    FcStrFree (cache_hashed);\n    FcAtomicUnlock (atomic);\n    FcAtomicDestroy (atomic);\n    return FcTrue;\n\n bail5:\n    close (fd);\n bail4:\n    FcAtomicUnlock (atomic);\n bail3:\n    FcAtomicDestroy (atomic);\n bail1:\n    FcStrFree (cache_hashed);\n    return FcFalse;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Serialization helper object -- allocate space in the\n * yet-to-be-created linear array for a serialized font set\n */\n", "func_signal": "FcSerialize *\nFcSerializeCreate (void)", "code": "{\n    FcSerialize\t*serialize;\n\n    serialize = malloc (sizeof (FcSerialize));\n    if (!serialize)\n\treturn NULL;\n    serialize->size = 0;\n    serialize->linear = NULL;\n    serialize->cs_freezer = NULL;\n    memset (serialize->buckets, '\\0', sizeof (serialize->buckets));\n    return serialize;\n}", "path": "src\\fcserialize.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Reread the configuration and available font lists\n */\n", "func_signal": "FcBool\nFcInitReinitialize (void)", "code": "{\n    FcConfig\t*config;\n\n    config = FcInitLoadConfigAndFonts ();\n    if (!config)\n\treturn FcFalse;\n    FcConfigSetCurrent (config);\n    return FcTrue;\n}", "path": "src\\fcinit.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\n", "func_signal": "static void MD5Update(struct MD5Context *ctx, const unsigned char *buf, unsigned len)", "code": "{\n    FcChar32 t;\n\n    /* Update bitcount */\n\n    t = ctx->bits[0];\n    if ((ctx->bits[0] = t + ((FcChar32) len << 3)) < t)\n\tctx->bits[1]++; \t/* Carry from low to high */\n    ctx->bits[1] += len >> 29;\n\n    t = (t >> 3) & 0x3f;\t/* Bytes already in shsInfo->data */\n\n    /* Handle any leading odd-sized chunks */\n\n    if (t) {\n\tunsigned char *p = (unsigned char *) ctx->in + t;\n\n\tt = 64 - t;\n\tif (len < t) {\n\t    memcpy(p, buf, len);\n\t    return;\n\t}\n\tmemcpy(p, buf, t);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (FcChar32 *) ctx->in);\n\tbuf += t;\n\tlen -= t;\n    }\n    /* Process data in 64-byte chunks */\n\n    while (len >= 64) {\n\tmemcpy(ctx->in, buf, 64);\n\tbyteReverse(ctx->in, 16);\n\tMD5Transform(ctx->buf, (FcChar32 *) ctx->in);\n\tbuf += 64;\n\tlen -= 64;\n    }\n\n    /* Handle any remaining bytes of data. */\n\n    memcpy(ctx->in, buf, len);\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Initialize the default library configuration\n */\n", "func_signal": "FcBool\nFcInit (void)", "code": "{\n    FcConfig\t*config;\n\n    if (_fcConfig)\n\treturn FcTrue;\n    config = FcInitLoadConfigAndFonts ();\n    if (!config)\n\treturn FcFalse;\n    FcConfigSetCurrent (config);\n    if (FcDebug() & FC_DBG_MEMORY)\n\tFcMemReport ();\n    return FcTrue;\n}", "path": "src\\fcinit.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Insert cache into the list\n */\n", "func_signal": "static FcBool\nFcCacheInsert (FcCache *cache, struct stat *cache_stat)", "code": "{\n    FcCacheSkip    **update[FC_CACHE_MAX_LEVEL];\n    FcCacheSkip    *s, **next;\n    int\t\t    i, level;\n\n    /*\n     * Find links along each chain\n     */\n    next = fcCacheChains;\n    for (i = fcCacheMaxLevel; --i >= 0; )\n    {\n\tfor (; (s = next[i]); next = s->next)\n\t    if (s->cache > cache)\n\t\tbreak;\n        update[i] = &next[i];\n    }\n\n    /*\n     * Create new list element\n     */\n    level = random_level ();\n    if (level > fcCacheMaxLevel)\n    {\n\tlevel = fcCacheMaxLevel + 1;\n\tupdate[fcCacheMaxLevel] = &fcCacheChains[fcCacheMaxLevel];\n\tfcCacheMaxLevel = level;\n    }\n\n    s = malloc (sizeof (FcCacheSkip) + (level - 1) * sizeof (FcCacheSkip *));\n    if (!s)\n\treturn FcFalse;\n\n    s->cache = cache;\n    s->size = cache->size;\n    s->ref = 1;\n    if (cache_stat)\n    {\n\ts->cache_dev = cache_stat->st_dev;\n\ts->cache_ino = cache_stat->st_ino;\n\ts->cache_mtime = cache_stat->st_mtime;\n    }\n    else\n    {\n\ts->cache_dev = 0;\n\ts->cache_ino = 0;\n\ts->cache_mtime = 0;\n    }\n\n    /*\n     * Insert into all fcCacheChains\n     */\n    for (i = 0; i < level; i++)\n    {\n\ts->next[i] = *update[i];\n\t*update[i] = s;\n    }\n    return FcTrue;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * build a single charset from a source file\n *\n * The file format is quite simple, either\n * a single hex value or a pair separated with a dash\n *\n * Comments begin with '#'\n */\n", "func_signal": "static const FcCharSet *\nscan (FILE *f, char *file, FcCharSetFreezer *freezer)", "code": "{\n    FcCharSet\t    *c = 0;\n    FcCharSet\t    *n;\n    int\t\t    start, end, ucs4;\n    char\t    line[1024];\n    int\t\t    lineno = 0;\n\n    while (get_line (f, line, &lineno))\n    {\n\tif (!strncmp (line, \"include\", 7))\n\t{\n\t    FILE *included_f;\n\t    char *included_file;\n\t    included_file = strchr (line, ' ');\n            if (!included_file)\n                fatal (file, lineno,\n                       \"invalid syntax, expected: include filename\");\n\t    while (isspace(*included_file))\n\t\tincluded_file++;\n\t    included_f = scanopen (included_file);\n\t    if (!included_f)\n\t\tfatal (included_file, 0, \"can't open\");\n\t    n = scan (included_f, included_file, freezer);\n\t    fclose (included_f);\n\t    if (!c)\n\t\tc = FcCharSetCreate ();\n\t    if (!FcCharSetMerge (c, n, NULL))\n\t\tfatal (file, lineno, \"out of memory\");\n\t    FcCharSetDestroy (n);\n\t    continue;\n\t}\n\tif (strchr (line, '-'))\n\t{\n\t    if (sscanf (line, \"%x-%x\", &start, &end) != 2)\n\t\tfatal (file, lineno, \"parse error\");\n\t}\n\telse\n\t{\n\t    if (sscanf (line, \"%x\", &start) != 1)\n\t\tfatal (file, lineno, \"parse error\");\n\t    end = start;\n\t}\n\tif (!c)\n\t    c = FcCharSetCreate ();\n\tfor (ucs4 = start; ucs4 <= end; ucs4++)\n\t{\n\t    if (!FcCharSetAddChar (c, ucs4))\n\t\tfatal (file, lineno, \"out of memory\");\n\t}\n    }\n    n = FcCharSetFreeze (freezer, c);\n    FcCharSetDestroy (c);\n    return n;\n}", "path": "fc-lang\\fc-lang.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Given an object, return the offset in the serialized array where\n * the serialized copy of the object is stored\n */\n", "func_signal": "intptr_t\nFcSerializeOffset (FcSerialize *serialize, const void *object)", "code": "{\n    uintptr_t\tbucket = ((uintptr_t) object) % FC_SERIALIZE_HASH_SIZE;\n    FcSerializeBucket  *buck;\n\n    for (buck = serialize->buckets[bucket]; buck; buck = buck->next)\n\tif (buck->object == object)\n\t    return buck->offset;\n    return 0;\n}", "path": "src\\fcserialize.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\n", "func_signal": "static void MD5Init(struct MD5Context *ctx)", "code": "{\n    ctx->buf[0] = 0x67452301;\n    ctx->buf[1] = 0xefcdab89;\n    ctx->buf[2] = 0x98badcfe;\n    ctx->buf[3] = 0x10325476;\n\n    ctx->bits[0] = 0;\n    ctx->bits[1] = 0;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Build a cache structure from the given contents\n */\n", "func_signal": "FcCache *\nFcDirCacheBuild (FcFontSet *set, const FcChar8 *dir, struct stat *dir_stat, FcStrSet *dirs)", "code": "{\n    FcSerialize\t*serialize = FcSerializeCreate ();\n    FcCache *cache;\n    int i;\n    intptr_t\tcache_offset;\n    intptr_t\tdirs_offset;\n    FcChar8\t*dir_serialize;\n    intptr_t\t*dirs_serialize;\n    FcFontSet\t*set_serialize;\n\n    if (!serialize)\n\treturn NULL;\n    /*\n     * Space for cache structure\n     */\n    cache_offset = FcSerializeReserve (serialize, sizeof (FcCache));\n    /*\n     * Directory name\n     */\n    if (!FcStrSerializeAlloc (serialize, dir))\n\tgoto bail1;\n    /*\n     * Subdirs\n     */\n    dirs_offset = FcSerializeAlloc (serialize, dirs, dirs->num * sizeof (FcChar8 *));\n    for (i = 0; i < dirs->num; i++)\n\tif (!FcStrSerializeAlloc (serialize, dirs->strs[i]))\n\t    goto bail1;\n\n    /*\n     * Patterns\n     */\n    if (!FcFontSetSerializeAlloc (serialize, set))\n\tgoto bail1;\n\n    /* Serialize layout complete. Now allocate space and fill it */\n    cache = malloc (serialize->size);\n    if (!cache)\n\tgoto bail1;\n    /* shut up valgrind */\n    memset (cache, 0, serialize->size);\n\n    serialize->linear = cache;\n\n    cache->magic = FC_CACHE_MAGIC_ALLOC;\n    cache->version = FC_CACHE_CONTENT_VERSION;\n    cache->size = serialize->size;\n    cache->mtime = (int) dir_stat->st_mtime;\n\n    /*\n     * Serialize directory name\n     */\n    dir_serialize = FcStrSerialize (serialize, dir);\n    if (!dir_serialize)\n\tgoto bail2;\n    cache->dir = FcPtrToOffset (cache, dir_serialize);\n\n    /*\n     * Serialize sub dirs\n     */\n    dirs_serialize = FcSerializePtr (serialize, dirs);\n    if (!dirs_serialize)\n\tgoto bail2;\n    cache->dirs = FcPtrToOffset (cache, dirs_serialize);\n    cache->dirs_count = dirs->num;\n    for (i = 0; i < dirs->num; i++)\n    {\n\tFcChar8\t*d_serialize = FcStrSerialize (serialize, dirs->strs[i]);\n\tif (!d_serialize)\n\t    goto bail2;\n\tdirs_serialize[i] = FcPtrToOffset (dirs_serialize, d_serialize);\n    }\n\n    /*\n     * Serialize font set\n     */\n    set_serialize = FcFontSetSerialize (serialize, set);\n    if (!set_serialize)\n\tgoto bail2;\n    cache->set = FcPtrToOffset (cache, set_serialize);\n\n    FcSerializeDestroy (serialize);\n\n    FcCacheInsert (cache, NULL);\n\n    return cache;\n\nbail2:\n    free (cache);\nbail1:\n    FcSerializeDestroy (serialize);\n    return NULL;\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Reserve space in the serialization array\n */\n", "func_signal": "intptr_t\nFcSerializeReserve (FcSerialize *serialize, int size)", "code": "{\n    intptr_t\toffset = serialize->size;\n    serialize->size += FcAlignSize (size);\n    return offset;\n}", "path": "src\\fcserialize.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * return the path from the directory containing 'cache' to 'file'\n */\n", "func_signal": "static const FcChar8 *\nfile_base_name (const FcChar8 *cache, const FcChar8 *file)", "code": "{\n    int\t\t    cache_len = strlen ((char *) cache);\n\n    if (!strncmp ((char *) cache, (char *) file, cache_len) && file[cache_len] == '/')\n\treturn file + cache_len + 1;\n    return file;\n}", "path": "fc-cat\\fc-cat.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n * Note: this code is harmless on little-endian machines.\n */\n", "func_signal": "void byteReverse(unsigned char *buf, unsigned longs)", "code": "{\n    FcChar32 t;\n    do {\n\tt = (FcChar32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n\t    ((unsigned) buf[1] << 8 | buf[0]);\n\t*(FcChar32 *) buf = t;\n\tbuf += 4;\n    } while (--longs);\n}", "path": "src\\fccache.c", "repo_name": "chemoelectric/fontconfig", "stars": 6, "license": "other", "language": "c", "size": 2859}
{"docstring": "/*\n**\n** Function:        Vec_Norm()\n**\n** Description:     Vector normalization\n**\n** Links to text:\n**\n** Arguments:\n**\n**  Word16 *Vect\n**  Word16 Len\n**\n** Outputs:\n**\n**  Word16 *Vect\n**\n** Return value:  The power of 2 by which the data vector multiplyed.\n**\n*/\n", "func_signal": "Word16  Vec_Norm( Word16 *Vect, Word16 Len )", "code": "{\n    int   i  ;\n\n    Word16  Acc0,Acc1   ;\n    Word16  Exp   ;\n    Word16  Rez ;\n    Word32  Temp  ;\n\n    static   short ShiftTable[16] = {\n      0x0001 ,\n      0x0002 ,\n      0x0004 ,\n      0x0008 ,\n      0x0010 ,\n      0x0020 ,\n      0x0040 ,\n      0x0080 ,\n      0x0100 ,\n      0x0200 ,\n      0x0400 ,\n      0x0800 ,\n      0x1000 ,\n      0x2000 ,\n      0x4000 ,\n      0x7fff\n   } ;\n\n    /* Find absolute maximum */\n    Acc1 = (Word16) 0 ;\n    for ( i = 0 ; i < Len ; i ++ ) {\n        Acc0 = abs_s( Vect[i] ) ;\n        if ( Acc0 > Acc1 )\n            Acc1 = Acc0 ;\n    }\n\n    /* Get the shift count */\n    Rez = norm_s( Acc1 ) ;\n    Exp = ShiftTable[Rez] ;\n\n    /* Normalize all the vector */\n    for ( i = 0 ; i < Len ; i ++ ) {\n        Temp = L_mult( Exp, Vect[i] ) ;\n        Temp = L_shr( Temp, 4 ) ;\n        Vect[i] = extract_l( Temp ) ;\n    }\n\n    Rez = sub( Rez, (Word16) 3) ;\n    return Rez ;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Rand_lbc()\n**\n** Description:     Generator of random numbers\n**\n** Links to text:   Section 3.10.2\n**\n** Arguments:\n**\n**  Word16 *p\n**\n** Outputs:\n**\n**  Word16 *p\n**\n** Return value:\n**\n**  Word16 random number\n**\n*/\n", "func_signal": "Word16   Rand_lbc( Word16 *p )", "code": "{\n    Word32   Temp ;\n\n    Temp = L_deposit_l( *p ) ;\n    Temp &= (Word32) 0x0000ffff ;\n    Temp = Temp*(Word32)521 + (Word32) 259 ;\n    *p = extract_l( Temp ) ;\n    return extract_l( Temp ) ;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Fcbk_Pack()\n**\n** Description:     Encoding of the pulse positions and gains for the high\n**                  rate case.\n**                  Combinatorial encoding is used to transmit the optimal\n**                  combination of pulse locations.\n**\n** Links to text:   Section 2.15\n**\n** Arguments:\n**\n**  Word16 *Dpnt    Excitation vector\n**  SFSDEF *Sfs     Encoded parameters of the excitation model\n**  BESTDEF *Best   Parameters of the best excitation model\n**  Word16 Np       Number of pulses (6 for even subframes; 5 for odd subframes)\n**\n** Outputs:\n**\n**  SFSDEF *Sfs     Encoded parameters of the excitation model\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Fcbk_Pack( Word16 *Dpnt, SFSDEF *Sfs, BESTDEF *Best, Word16 Np )", "code": "{\n    int   i,j   ;\n\n\n    /* Code the amplitudes and positions */\n    j = MaxPulseNum - (int) Np ;\n\n    (*Sfs).Pamp = (Word16) 0 ;\n    (*Sfs).Ppos = (Word32) 0 ;\n\n    for ( i = 0 ; i < SubFrLen/Sgrid ; i ++ ) {\n\n        if ( Dpnt[(int)(*Best).GridId + Sgrid*i] == (Word16) 0 )\n            (*Sfs).Ppos = L_add( (*Sfs).Ppos, CombinatorialTable[j][i] ) ;\n        else {\n            (*Sfs).Pamp = shl( (*Sfs).Pamp, (Word16) 1 ) ;\n            if ( Dpnt[(int)(*Best).GridId + Sgrid*i] < (Word16) 0 )\n                (*Sfs).Pamp = add( (*Sfs).Pamp, (Word16) 1 ) ;\n\n            j ++ ;\n            /* Check for end */\n            if ( j == MaxPulseNum )\n                break ;\n        }\n    }\n\n    (*Sfs).Mamp = (*Best).MampId ;\n    (*Sfs).Grid = (*Best).GridId ;\n    (*Sfs).Tran = (*Best).UseTrn ;\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Filt_Lpf()\n**\n** Description:     Applies the pitch postfilter for each subframe.\n**\n** Links to text:   Section 3.6\n**\n** Arguments:\n**\n**  Word16 *Tv      Pitch postfiltered excitation\n**  Word16 *Buff    decoded excitation\n**  PFDEF Pf        Pitch postfilter parameters\n**  Word16 Sfc      Subframe index\n**\n** Outputs:\n**\n**  Word16 *Tv      Pitch postfiltered excitation\n**\n** Return value: None\n**\n*/\n", "func_signal": "void  Filt_Lpf( Word16 *Tv, Word16 *Buff, PFDEF Pf, Word16 Sfc )", "code": "{\n    int   i  ;\n\n    Word32   Acc0 ;\n\n    for ( i = 0 ; i < SubFrLen ; i ++ ) {\n        Acc0 = L_mult( Buff[PitchMax+(int)Sfc*SubFrLen+i], Pf.ScGn ) ;\n        Acc0 = L_mac( Acc0, Buff[PitchMax+(int)Sfc*SubFrLen+(int)Pf.Indx+i],\n                                                                Pf.Gain ) ;\n        Tv[(int)Sfc*SubFrLen+i] = round_( Acc0 ) ;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n**  Function:     Corr_h_X()\n**\n**  Description:    Compute  correlations of input response h[] with\n**                  the target vector X[].\n**\n**  Links to the text: Section 2.16\n**\n** Arguments:\n**\n**      Word16 h[]              Impulse response.\n**      Word16 X[]              Target vector.\n**      Word16 D[]              Correlations.\n**\n**  Outputs:\n**\n**      Word16 D[]              Correlations.\n**\n**  Return value:           None\n*/\n", "func_signal": "void Cor_h_X(Word16 h[], Word16 X[], Word16 D[])", "code": "{\n    Word16 i, j;\n    Word32 s, max;\n    Word32 y32[SubFrLen];\n\n    /* first keep the result on 32 bits and find absolute maximum */\n\n    max = 0;\n\n    for (i = 0; i < SubFrLen; i++) {\n        s = 0;\n        for (j = i; j <  SubFrLen; j++)\n            s = L_mac(s, X[j], h[j-i]);\n\n        y32[i] = s;\n\n        s = L_abs(s);\n        if(s > max) max = s;\n    }\n\n    /*\n     * Find the number of right shifts to do on y32[]\n     * so that maximum is on 13 bits\n     */\n\n    j = norm_l(max);\n    if( sub(j,16) > 0) j = 16;\n\n    j = sub(18, j);\n\n    for(i=0; i<SubFrLen; i++)\n        D[i] = extract_l( L_shr(y32[i], j) );\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n**  Function:  G_code()\n**\n**  Description: Compute the gain of innovative code.\n**\n**\n**  Links to the text: Section 2.16\n**\n** Input arguments:\n**\n**      Word16 X[]        Code target.  (in Q0)\n**      Word16 Y[]        Filtered innovation code. (in Q12)\n**\n** Output:\n**\n**      Word16 *gain_q    Gain of innovation code.  (in Q0)\n**\n**  Return value:\n**\n**      Word16  index of innovation code gain\n**\n*/\n", "func_signal": "Word16 G_code(Word16 X[], Word16 Y[], Word16 *gain_q)", "code": "{\n    Word16 i;\n    Word16 xy, yy, exp_xy, exp_yy, gain, gain_nq;\n    Word32 L_xy, L_yy;\n    Word16 dist, dist_min;\n\n\n    /* Scale down Y[] by 8 to avoid overflow */\n    for(i=0; i<SubFrLen; i++)\n        Y[i] = shr(Y[i], 3);\n\n    /* Compute scalar product <X[],Y[]> */\n    L_xy = 0L;\n    for(i=0; i<SubFrLen; i++)\n        L_xy = L_mac(L_xy, X[i], Y[i]);\n\n    exp_xy = norm_l(L_xy);\n    xy = extract_h( L_shl(L_xy, exp_xy) );\n\n    if(xy <= 0) {\n        gain = 0;\n        *gain_q =FcbkGainTable[gain];\n        return(gain);\n    }\n\n    /* Compute scalar product <Y[],Y[]> */\n    L_yy = 0L;\n    for(i=0; i<SubFrLen; i++)\n        L_yy = L_mac(L_yy, Y[i], Y[i]);\n\n    exp_yy = norm_l(L_yy);\n    yy     = extract_h( L_shl(L_yy, exp_yy) );\n\n    /* compute gain = xy/yy */\n    xy = shr(xy, 1);             /* Be sure xy < yy */\n    gain_nq = div_s( xy, yy);\n\n    i = add(exp_xy, 5);          /* Denormalization of division */\n    i = sub(i, exp_yy);\n\n    gain_nq = shr(gain_nq, i);\n\n    gain = (Word16) 0;\n    dist_min = sub(gain_nq, FcbkGainTable[0]);\n    dist_min = abs_s(dist_min);\n    for ( i =  1; i <NumOfGainLev ; i ++ ) {\n        dist = sub(gain_nq, FcbkGainTable[i]);\n        dist =abs_s(dist);\n        if ( dist< dist_min) {\n            dist_min = dist;\n            gain = (Word16) i ;\n        }\n    }\n    *gain_q = FcbkGainTable[gain];\n\n    return(gain);\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/* 16 bit var1 -> LSB,     2 */\n/*\n**\n** Function:        Read_lbc()\n**\n** Description:     Read in a file\n**\n** Links to text:   Sections 2.2 & 4\n**\n** Arguments:\n**\n**  Word16 *Dpnt\n**  int     Len\n**  FILE *Fp\n**\n** Outputs:\n**\n**  Word16 *Dpnt\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Read_lbc( Word16 *Dpnt, int Len, FILE *Fp )", "code": "{\n    int   i  ;\n\n    for ( i = 0 ; i < Len ; i ++ )\n        Dpnt[i] = (Word16) 0 ;\n\n    fread ( (char *)Dpnt, sizeof(Word16), Len, Fp ) ;\n\n    return;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Comp_Pw()\n**\n** Description:     Computes harmonic noise filter coefficients.\n**                  For each subframe, the optimal lag is searched around the\n**                  open loop pitch lag based on only positive correlation\n**                  maximization.\n**\n** Links to text:   Section 2.11\n**\n** Arguments:\n**\n**  Word16 *Dpnt    Formant perceptually weighted speech\n**  Word16 Start\n**  Word16 Olp      Open loop pitch lag\n**\n** Outputs:         None\n**\n** Return value:\n**\n**  PWDEF   Word16  Indx  lag of the harmonic noise shaping filter\n**          Word16  Gain  gain of the harmonic noise shaping filter\n**\n*/\n", "func_signal": "PWDEF Comp_Pw( Word16 *Dpnt, Word16 Start, Word16 Olp )", "code": "{\n\n    int   i,j   ;\n\n    Word32   Lcr[15] ;\n    Word16   Scr[15] ;\n    PWDEF    Pw ;\n\n    Word32   Acc0,Acc1   ;\n    Word16   Exp   ;\n\n    Word16   Ccr,Enr  ;\n    Word16   Mcr,Mnr  ;\n\n    /* Compute and save target energy */\n    Lcr[0] = (Word32) 0 ;\n    for ( i = 0 ; i < SubFrLen ; i ++ )\n        Lcr[0] = L_mac( Lcr[0], Dpnt[Start+i], Dpnt[Start+i] ) ;\n\n    /* Compute all Crosses and energys */\n    for ( i = 0 ; i <= 2*PwRange ; i ++ ) {\n\n        Acc1 = Acc0 = (Word32) 0 ;\n        for ( j = 0 ; j < SubFrLen ; j ++ ) {\n            Acc0 = L_mac( Acc0, Dpnt[Start+j],\n                                            Dpnt[Start-(Olp-PwRange+i)+j]) ;\n            Acc1 = L_mac( Acc1, Dpnt[Start-(Olp-PwRange+i)+j],\n                                            Dpnt[Start-(Olp-PwRange+i)+j] ) ;\n        }\n\n        /* Save both */\n        Lcr[2*i+1] = Acc1 ;\n        Lcr[2*i+2] = Acc0 ;\n    }\n\n    /* Normalize to maximum */\n    Acc1 = (Word32) 0 ;\n    for ( i = 0 ; i < 15 ; i ++ ) {\n        Acc0 = Lcr[i] ;\n        Acc0 = L_abs( Acc0 ) ;\n        if ( Acc0 > Acc1 )\n            Acc1 = Acc0 ;\n    }\n\n    Exp = norm_l( Acc1 ) ;\n    for ( i = 0 ; i < 15 ; i ++ ) {\n        Acc0 = L_shl( Lcr[i], Exp ) ;\n        Scr[i] = round_( Acc0 ) ;\n\n    }\n\n    /* Find the best pair */\n    Pw.Indx = (Word16) -1 ;\n    Pw.Gain = (Word16) 0  ;\n\n    Mcr = (Word16) 1 ;\n    Mnr = (Word16) 0x7fff ;\n\n    for ( i = 0 ; i <= 2*PwRange ; i ++ ) {\n\n        Enr = Scr[2*i+1] ;\n        Ccr = Scr[2*i+2] ;\n\n        if ( Ccr <= (Word16) 0 )\n            continue ;\n\n        Exp = mult_r( Ccr, Ccr ) ;\n\n        /* Compute the cross */\n        Acc0 = L_mult( Exp, Mnr ) ;\n        Acc0 = L_msu ( Acc0, Enr, Mcr ) ;\n\n        if ( Acc0 > (Word32) 0 ) {\n            Mcr = Exp ;\n            Mnr = Enr ;\n            Pw.Indx = (Word16)i ;\n        }\n    }\n\n    if ( Pw.Indx == -1 ) {\n        Pw.Indx = Olp ;\n        return Pw ;\n    }\n\n    /* Check the db limit */\n    Acc0 = L_mult( Scr[0], Mnr ) ;\n    Acc1 = Acc0 ;\n    Acc0 = L_shr( Acc0, (Word16) 2 ) ;\n    Acc1 = L_shr( Acc1, (Word16) 3 ) ;\n    Acc0 = L_add( Acc0, Acc1 ) ;\n    Acc1 = L_mult( Scr[2*Pw.Indx+2], Scr[2*Pw.Indx+2] ) ;\n    Acc0 = L_sub( Acc0, Acc1 ) ;\n\n    if ( Acc0 < (Word32) 0 ) {\n\n        Exp = Scr[2*Pw.Indx + 2] ;\n\n        if ( Exp >= Mnr )\n            Pw.Gain = PwConst ;\n        else {\n            Pw.Gain = div_s( Exp, Mnr ) ;\n            Pw.Gain = mult_r( Pw.Gain, PwConst ) ;\n        }\n    }\n\n    Pw.Indx = Olp - PwRange + Pw.Indx ;\n\n    return Pw ;\n\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Fcbk_Unpk()\n**\n** Description:     Decoding of the fixed codebook excitation for both rates.\n**                  Gains, pulse positions, grid position (odd or even), signs\n**                  are decoded and used to reconstruct the excitation.\n**\n** Links to text:   Section 2.17 & 3.5\n**\n** Arguments:\n**\n**  Word16 *Tv      Decoded excitation vector\n**  SFSDEF Sfs      Encoded parameters of the excitation (for one subframe)\n**  Word16 Olp      Closed loop adaptive pitch lag\n**  Word16 Sfc      Subframe index\n**\n** Outputs:\n**\n**  Word16 *Tv      Decoded excitation vector\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Fcbk_Unpk( Word16 *Tv, SFSDEF Sfs, Word16 Olp, Word16 Sfc )", "code": "{\n    int   i,j   ;\n\n    Word32   Acc0  ;\n    Word16   Np ;\n    Word16 Tv_tmp[SubFrLen+4];\n    Word16 acelp_gain, acelp_sign, acelp_shift, acelp_pos;\n    Word16 offset, ipos, T0_acelp, gain_T0;\n\n\n\n    switch(WrkRate)  {\n        case Rate63: {\n\n            Np = Nb_puls[(int)Sfc] ;\n\n            for ( i = 0 ; i < SubFrLen ; i ++ )\n                Tv[i] = (Word16) 0 ;\n\n            if ( Sfs.Ppos >= MaxPosTable[Sfc] )\n                return ;\n\n            /* Decode the amplitudes and positions */\n            j = MaxPulseNum - (int) Np ;\n\n            Acc0 = Sfs.Ppos ;\n\n            for ( i = 0 ; i < SubFrLen/Sgrid ; i ++ )  {\n\n                Acc0 = L_sub( Acc0, CombinatorialTable[j][i] ) ;\n\n                if ( Acc0 < (Word32) 0 ) {\n                    Acc0 = L_add( Acc0, CombinatorialTable[j][i] ) ;\n                    j ++ ;\n                    if ( (Sfs.Pamp & (1 << (MaxPulseNum-j) )) != (Word16) 0 )\n                        Tv[(int)Sfs.Grid + Sgrid*i] = -FcbkGainTable[Sfs.Mamp] ;\n                    else\n                        Tv[(int)Sfs.Grid + Sgrid*i] =  FcbkGainTable[Sfs.Mamp] ;\n\n                    if ( j == MaxPulseNum )\n                        break ;\n                }\n            }\n\n            if ( Sfs.Tran == (Word16) 1 )\n                Gen_Trn( Tv, Tv, Olp ) ;\n            break;\n        }\n\n        case Rate53: {\n            for ( i = 0 ; i < SubFrLen+4 ; i ++ )\n                Tv_tmp[i] = (Word16) 0 ;\n\n            /* decoding gain */\n            acelp_gain = FcbkGainTable[Sfs.Mamp];\n            /* decoding grid */\n            acelp_shift = Sfs.Grid;\n            /* decoding Sign */\n            acelp_sign = Sfs.Pamp;\n            /* decoding Pos */\n            acelp_pos = (short) Sfs.Ppos;\n\n            offset  = 0;\n            for(i=0; i<4; i++) {\n                ipos = (acelp_pos & (Word16)0x0007) ;\n                ipos = shl(ipos,3) + acelp_shift + offset;\n                if( (acelp_sign & 1 )== 1) {\n                    Tv_tmp[ipos] = acelp_gain;\n                }\n                else {\n                    Tv_tmp[ipos] = -acelp_gain;\n                }\n                offset = add(offset,2);\n                acelp_pos = shr(acelp_pos, 3);\n                acelp_sign = shr(acelp_sign,1);\n            }\n            for (i = 0; i < SubFrLen; i++) Tv[i] = Tv_tmp[i];\n            T0_acelp = search_T0( (Word16) (Olp-1+Sfs.AcLg), Sfs.AcGn,\n                                                            &gain_T0);\n            if(T0_acelp <SubFrLen-2) {\n                /* code[i] += 0.8 * code[i-Olp] */\n                for (i = T0_acelp ; i < SubFrLen; i++)\n                    Tv[i] = add(Tv[i], mult(Tv[i-T0_acelp ], gain_T0));\n            }\n\n            break;\n        }\n    }\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Scale()\n**\n** Description:     Postfilter gain scaling\n**\n** Links to text:   Section 3.9\n**\n** Arguments:\n**\n**  Word16 *Tv\n**  Word32 Sen\n**\n**  Inputs:\n**\n**  Word16 DecStat.Gain\n**\n** Outputs:\n**\n**  Word16 *Tv\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Scale( Word16 *Tv, Word32 Sen )", "code": "{\n    int   i ;\n\n    Word32   Acc0,Acc1   ;\n    Word16   Exp,SfGain  ;\n\n\n    Acc0 = Sen ;\n    Acc1 = Comp_En( Tv ) ;\n\n    /* Normalize both */\n    if ( (Acc1 != (Word32) 0) && (Acc0 != (Word32) 0 ) ) {\n\n        Exp = norm_l( Acc1 ) ;\n        Acc1 = L_shl( Acc1, Exp ) ;\n\n        SfGain = norm_l( Acc0 ) ;\n        Acc0 = L_shl( Acc0, SfGain ) ;\n        Acc0 = L_shr( Acc0, (Word16) 1 ) ;\n        Exp = sub( Exp, SfGain ) ;\n        Exp = add( Exp, (Word16) 1 ) ;\n        Exp = sub( (Word16) 6, Exp ) ;\n        if ( Exp < (Word16) 0 )\n            Exp = (Word16) 0 ;\n\n        SfGain = extract_h( Acc1 ) ;\n\n        SfGain = div_l( Acc0, SfGain ) ;\n\n        Acc0 = L_deposit_h( SfGain ) ;\n\n        Acc0 = L_shr( Acc0, Exp ) ;\n\n        SfGain = Sqrt_lbc( Acc0 ) ;\n    }\n    else\n        SfGain = 0x1000 ;\n\n    /* Filter the data */\n    for ( i = 0 ; i < SubFrLen ; i ++ ) {\n\n        /* Update gain */\n        Acc0 = L_deposit_h( DecStat.Gain ) ;\n        Acc0 = L_msu( Acc0, DecStat.Gain, (Word16) 0x0800 ) ;\n        Acc0 = L_mac( Acc0, SfGain, (Word16) 0x0800 ) ;\n        DecStat.Gain = round_( Acc0 ) ;\n\n        Exp = add( DecStat.Gain, shr( DecStat.Gain, (Word16) 4) ) ;\n\n        Acc0 = L_mult( Tv[i], Exp ) ;\n        Acc0 = L_shl( Acc0, (Word16) 4 ) ;\n        Tv[i] = round_( Acc0 ) ;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Mem_Shift()\n**\n** Description:     Memory shift, update of the high-passed input speech signal\n**\n** Links to text:\n**\n** Arguments:\n**\n**  Word16 *PrevDat\n**  Word16 *DataBuff\n**\n** Outputs:\n**\n**  Word16 *PrevDat\n**  Word16 *DataBuff\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Mem_Shift( Word16 *PrevDat, Word16 *DataBuff )", "code": "{\n    int   i  ;\n\n    Word16   Dpnt[Frame+LpcFrame-SubFrLen] ;\n\n    /*  Form Buffer  */\n    for ( i = 0 ; i < LpcFrame-SubFrLen ; i ++ )\n        Dpnt[i] = PrevDat[i] ;\n    for ( i = 0 ; i < Frame ; i ++ )\n        Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i] ;\n\n    /* Update PrevDat */\n    for ( i = 0 ; i < LpcFrame-SubFrLen ; i ++ )\n        PrevDat[i] = Dpnt[Frame+i] ;\n\n    /* Update DataBuff */\n    for ( i = 0 ; i < Frame ; i ++ )\n        DataBuff[i] = Dpnt[(LpcFrame-SubFrLen)/2+i] ;\n\n    return;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Comp_Lpf()\n**\n** Description:     Computes pitch postfilter parameters.\n**                  The pitch postfilter lag is first derived (Find_B\n**                  and Find_F). Then, the one that gives the largest\n**                  contribution is used to calculate the gains (Get_Ind).\n**\n**\n** Links to text:   Section 3.6\n**\n** Arguments:\n**\n**  Word16 *Buff    decoded excitation\n**  Word16 Olp      Decoded pitch lag\n**  Word16 Sfc      Subframe index\n**\n** Outputs:\n**\n**\n** Return value:\n**\n**  PFDEF       Pitch postfilter parameters: PF.Gain    Pitch Postfilter gain\n**                                           PF.ScGn    Pitch Postfilter scaling gain\n**                                           PF.Indx    Pitch postfilter lag\n*/\n", "func_signal": "PFDEF Comp_Lpf( Word16 *Buff, Word16 Olp, Word16 Sfc )", "code": "{\n    int   i,j   ;\n\n    PFDEF Pf    ;\n    Word32   Lcr[5] ;\n    Word16   Scr[5] ;\n    Word16   Bindx, Findx ;\n    Word16   Exp ;\n\n    Word32   Acc0,Acc1 ;\n\n    /* Initialize */\n    Pf.Indx = (Word16) 0 ;\n    Pf.Gain = (Word16) 0 ;\n    Pf.ScGn = (Word16) 0x7fff ;\n\n    /* Find both indices */\n    Bindx = Find_B( Buff, Olp, Sfc ) ;\n    Findx = Find_F( Buff, Olp, Sfc ) ;\n\n    /* Combine the results */\n    if ( (Bindx == (Word16) 0) && (Findx == (Word16) 0) )\n        return Pf ;\n\n    /* Compute target energy */\n    Acc0 = (Word32) 0 ;\n    for ( j = 0 ; j < SubFrLen ; j ++ )\n        Acc0 = L_mac( Acc0, Buff[PitchMax+(int)Sfc*SubFrLen+j],\n                                    Buff[PitchMax+(int)Sfc*SubFrLen+j] ) ;\n    Lcr[0] = Acc0 ;\n\n    if ( Bindx != (Word16) 0 ) {\n        Acc0 = (Word32) 0 ;\n        Acc1 = (Word32) 0 ;\n        for ( j = 0 ; j < SubFrLen ; j ++ ) {\n            Acc0 = L_mac( Acc0, Buff[PitchMax+(int)Sfc*SubFrLen+j],\n                        Buff[PitchMax+(int)Sfc*SubFrLen+(int)Bindx+j] ) ;\n            Acc1 = L_mac( Acc1, Buff[PitchMax+(int)Sfc*SubFrLen+(int)Bindx+j],\n                        Buff[PitchMax+(int)Sfc*SubFrLen+(int)Bindx+j] ) ;\n        }\n        Lcr[1] = Acc0 ;\n        Lcr[2] = Acc1 ;\n    }\n    else {\n        Lcr[1] = (Word32) 0 ;\n        Lcr[2] = (Word32) 0 ;\n    }\n\n    if ( Findx != (Word16) 0 ) {\n        Acc0 = (Word32) 0 ;\n        Acc1 = (Word32) 0 ;\n        for ( j = 0 ; j < SubFrLen ; j ++ ) {\n            Acc0 = L_mac( Acc0, Buff[PitchMax+(int)Sfc*SubFrLen+j],\n                        Buff[PitchMax+(int)Sfc*SubFrLen+(int)Findx+j] ) ;\n            Acc1 = L_mac( Acc1, Buff[PitchMax+(int)Sfc*SubFrLen+(int)Findx+j],\n                        Buff[PitchMax+(int)Sfc*SubFrLen+(int)Findx+j] ) ;\n        }\n        Lcr[3] = Acc0 ;\n        Lcr[4] = Acc1 ;\n    }\n    else {\n        Lcr[3] = (Word32) 0 ;\n        Lcr[4] = (Word32) 0 ;\n    }\n\n    /* Normalize and convert to shorts */\n    Acc1 = 0L ;\n    for ( i = 0 ; i < 5 ; i ++ ) {\n        Acc0 = Lcr[i] ;\n        if ( Acc0 > Acc1 )\n            Acc1 = Acc0 ;\n    }\n\n    Exp = norm_l( Acc1 ) ;\n    for ( i = 0 ; i < 5 ; i ++ ) {\n        Acc0 = L_shl( Lcr[i], Exp ) ;\n        Scr[i] = extract_h( Acc0 ) ;\n    }\n\n    /* Select the best pair */\n    if ( (Bindx != (Word16) 0) && ( Findx == (Word16) 0) )\n        Pf = Get_Ind( Bindx, Scr[0], Scr[1], Scr[2] ) ;\n\n    if ( (Bindx == (Word16) 0) && ( Findx != (Word16) 0) )\n        Pf = Get_Ind( Findx, Scr[0], Scr[3], Scr[4] ) ;\n\n    if ( (Bindx != (Word16) 0) && ( Findx != (Word16) 0) ) {\n        Exp = mult_r( Scr[1], Scr[1] ) ;\n        Acc0 = L_mult( Exp, Scr[4] ) ;\n        Exp = mult_r( Scr[3], Scr[3] ) ;\n        Acc1 = L_mult( Exp, Scr[2] ) ;\n        if ( Acc0 > Acc1 )\n            Pf = Get_Ind( Bindx, Scr[0], Scr[1], Scr[2] ) ;\n        else\n            Pf = Get_Ind( Findx, Scr[0], Scr[3], Scr[4] ) ;\n    }\n\n    return Pf ;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Filt_Pw()\n**\n** Description:     Applies harmonic noise shaping filter.\n**                  Lth order FIR filter on each subframe (L: lag of the filter).\n**\n** Links to text:   Section 2.11\n**\n** Arguments:\n**\n**  Word16 *DataBuff    Target vector\n**  Word16 *Dpnt        Formant perceptually weighted speech\n**  Word16 Start\n**  PWDEF   Pw          Parameters of the harmonic noise shaping filter\n**\n** Outputs:\n**\n**  Word16 *DataBuff    Target vector\n**\n** Return value:        None\n**\n*/\n", "func_signal": "void  Filt_Pw( Word16 *DataBuff, Word16 *Dpnt, Word16 Start, PWDEF Pw )", "code": "{\n    int   i  ;\n\n    Word32   Acc0 ;\n\n    /* Perform the harmonic weighting */\n    for ( i = 0 ; i < SubFrLen ; i ++ ) {\n        Acc0 = L_deposit_h( Dpnt[PitchMax+Start+i] ) ;\n        Acc0 = L_msu( Acc0, Pw.Gain, Dpnt[PitchMax+Start-Pw.Indx+i] ) ;\n        DataBuff[Start+(Word16)i] = round_( Acc0 ) ;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Comp_Info()\n**\n** Description:     Voiced/unvoiced classifier.\n**                  It is based on a cross correlation maximization over the\n**                  last 120 samples of the frame and with an index varying\n**                  around the decoded pitch lag (from L-3 to L+3). Then the\n**                  prediction gain is tested to declare the frame voiced or\n**                  unvoiced.\n**\n** Links to text:   Section 3.10.2\n**\n** Arguments:\n**\n**  Word16 *Buff  decoded excitation\n**  Word16 Olp    Decoded pitch lag\n**\n** Outputs: None\n**\n** Return value:\n**\n**      Word16   Estimated pitch value\n*/\n", "func_signal": "Word16   Comp_Info( Word16 *Buff, Word16 Olp, Word16 *Gain, Word16 *ShGain)", "code": "{\n    int   i,j   ;\n\n    Word32   Acc0,Acc1 ;\n\n    Word16   Tenr ;\n    Word16   Ccr,Enr ;\n    Word16   Indx ;\n\n    /* Normalize the excitation */\n    *ShGain = Vec_Norm( Buff, (Word16) (PitchMax+Frame) ) ;\n\n    if ( Olp > (Word16) (PitchMax-3) )\n        Olp = (Word16) (PitchMax-3) ;\n\n    Indx = Olp ;\n\n    Acc1 = (Word32) 0 ;\n\n    for ( i = (int)Olp-3 ; i <= (int)Olp+3 ; i ++ ) {\n\n        Acc0 = (Word32) 0 ;\n        for ( j = 0 ; j < 2*SubFrLen ; j ++ )\n            Acc0 = L_mac( Acc0, Buff[PitchMax+Frame-2*SubFrLen+j],\n                                    Buff[PitchMax+Frame-2*SubFrLen-i+j] ) ;\n\n        if ( Acc0 > Acc1 ) {\n            Acc1 = Acc0 ;\n            Indx = (Word16) i ;\n        }\n    }\n\n    /* Compute target energy */\n    Acc0 = (Word32) 0 ;\n    for ( j = 0 ; j < 2*SubFrLen ; j ++ )\n        Acc0 = L_mac( Acc0, Buff[PitchMax+Frame-2*SubFrLen+j],\n                                    Buff[PitchMax+Frame-2*SubFrLen+j] ) ;\n    Tenr = round_( Acc0 ) ;\n    *Gain = Tenr;\n\n    /* Compute best energy */\n    Acc0 = (Word32) 0 ;\n    for ( j = 0 ; j < 2*SubFrLen ; j ++ )\n        Acc0 = L_mac( Acc0, Buff[PitchMax+Frame-2*SubFrLen-(int)Indx+j],\n                            Buff[PitchMax+Frame-2*SubFrLen-(int)Indx+j] ) ;\n\n    Ccr = round_( Acc1 ) ;\n\n    if ( Ccr <= (Word16) 0 )\n        return (Word16) 0 ;\n\n    Enr = round_( Acc0 ) ;\n\n    Acc0 = L_mult( Enr, Tenr ) ;\n    Acc0 = L_shr( Acc0, (Word16) 3 ) ;\n\n    Acc0 = L_msu( Acc0, Ccr, Ccr ) ;\n\n    if ( Acc0 < (Word32) 0 )\n        return Indx ;\n    else\n        return (Word16) 0 ;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Get_Rez()\n**\n** Description:     Gets delayed contribution from the previous excitation\n**                  vector.\n**\n** Links to text:   Sections 2.14, 2.18 & 3.4\n**\n** Arguments:\n**\n**  Word16 *Tv      delayed excitation\n**  Word16 *PrevExc Previous excitation vector\n**  Word16 Lag      Closed loop pitch lag\n**\n** Outputs:\n**\n**  Word16 *Tv      delayed excitation\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Get_Rez( Word16 *Tv, Word16 *PrevExc, Word16 Lag )", "code": "{\n    int   i  ;\n\n    for ( i = 0 ; i < ClPitchOrd/2 ; i ++ )\n        Tv[i] = PrevExc[PitchMax - (int) Lag - ClPitchOrd/2 + i] ;\n\n    for ( i = 0 ; i < SubFrLen+ClPitchOrd/2 ; i ++ )\n        Tv[ClPitchOrd/2+i] = PrevExc[PitchMax - (int)Lag + i%(int)Lag] ;\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Comp_En()\n**\n** Description:     Compute energy of a subframe vector\n**\n** Links to text:\n**\n** Arguments:\n**\n**  Word16 *Dpnt\n**\n** Outputs:         None\n**\n** Return value:\n**\n**      Word32 energy\n**\n*/\n", "func_signal": "Word32   Comp_En( Word16 *Dpnt )", "code": "{\n    int   i ;\n    Word32   Rez ;\n    Word16   Temp[SubFrLen] ;\n\n    for ( i = 0 ; i < SubFrLen ; i ++ )\n        Temp[i] = shr( Dpnt[i], (Word16) 2 ) ;\n\n    Rez = (Word32) 0 ;\n    for ( i = 0 ; i < SubFrLen ; i ++ )\n        Rez = L_mac( Rez, Temp[i], Temp[i] ) ;\n\n    return Rez ;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Estim_Pitch()\n**\n** Description: Open loop pitch estimation made twice per frame (one for\n**              the first two subframes and one for the last two).\n**              The method is based on the maximization of the\n**              crosscorrelation of the speech.\n**\n** Links to text:   Section 2.9\n**\n** Arguments:\n**\n**  Word16 *Dpnt    Perceptually weighted speech\n**  Word16 Start    Starting index defining the subframes under study\n**\n** Outputs:\n**\n** Return value:\n**\n**  Word16      Open loop pitch period\n**\n*/\n", "func_signal": "Word16   Estim_Pitch( Word16 *Dpnt, Word16 Start )", "code": "{\n    int   i,j   ;\n\n    Word32   Acc0,Acc1   ;\n\n    Word16   Exp,Tmp  ;\n    Word16   Ccr,Enr  ;\n\n    Word16   Indx = (Word16) PitchMin ;\n\n    Word16   Mxp = (Word16) 30 ;\n    Word16   Mcr = (Word16) 0x4000 ;\n    Word16   Mnr = (Word16) 0x7fff ;\n\n    Word16   Pr ;\n\n    /* Init the energy estimate */\n    Pr = Start - (Word16)PitchMin + (Word16)1 ;\n    Acc1 = (Word32) 0 ;\n    for ( j = 0 ; j < 2*SubFrLen ; j ++ )\n        Acc1 = L_mac( Acc1, Dpnt[Pr+j], Dpnt[Pr+j] ) ;\n\n    /* Main Olp search loop */\n    for ( i = PitchMin ; i <= PitchMax-3 ; i ++ ) {\n\n        Pr = sub( Pr, (Word16) 1 ) ;\n\n        /* Energy update */\n        Acc1 = L_msu( Acc1, Dpnt[Pr+2*SubFrLen], Dpnt[Pr+2*SubFrLen] ) ;\n        Acc1 = L_mac( Acc1, Dpnt[Pr], Dpnt[Pr] ) ;\n\n        /*  Compute the cross */\n        Acc0 = (Word32) 0 ;\n        for ( j = 0 ; j < 2*SubFrLen ; j ++ )\n            Acc0 = L_mac( Acc0, Dpnt[Start+j], Dpnt[Pr+j] ) ;\n\n        if ( Acc0 > (Word32) 0 ) {\n\n            /* Compute Exp and mant of the cross */\n            Exp = norm_l( Acc0 ) ;\n            Acc0 = L_shl( Acc0, Exp ) ;\n            Exp = shl( Exp, (Word16) 1 ) ;\n            Ccr = round_( Acc0 ) ;\n            Acc0 = L_mult( Ccr, Ccr ) ;\n            Ccr = norm_l( Acc0 ) ;\n            Acc0 = L_shl( Acc0, Ccr ) ;\n            Exp = add( Exp, Ccr ) ;\n            Ccr = extract_h( Acc0 ) ;\n\n            /* Do the same with energy */\n            Acc0 = Acc1 ;\n            Enr = norm_l( Acc0 ) ;\n            Acc0 = L_shl( Acc0, Enr ) ;\n            Exp = sub( Exp, Enr ) ;\n            Enr = round_( Acc0 ) ;\n\n            if ( Ccr >= Enr ) {\n                Exp = sub( Exp, (Word16) 1 ) ;\n                Ccr = shr( Ccr, (Word16) 1 ) ;\n            }\n\n            if ( Exp <= Mxp ) {\n\n                if ( (Exp+1) < Mxp ) {\n                    Indx = (Word16) i ;\n                    Mxp = Exp ;\n                    Mcr = Ccr ;\n                    Mnr = Enr ;\n                    continue ;\n                }\n\n                if ( (Exp+1) == Mxp )\n                    Tmp = shr( Mcr, (Word16) 1 ) ;\n                else\n                    Tmp = Mcr ;\n\n                /* Compare with equal exponents */\n                Acc0 = L_mult( Ccr, Mnr ) ;\n                Acc0 = L_msu( Acc0, Enr, Tmp ) ;\n                if ( Acc0 > (Word32) 0 ) {\n\n                    if ( ((Word16)i - Indx) < (Word16) PitchMin ) {\n                        Indx = (Word16) i ;\n                        Mxp = Exp ;\n                        Mcr = Ccr ;\n                        Mnr = Enr ;\n                    }\n\n                    else {\n                        Acc0 = L_mult( Ccr, Mnr ) ;\n                        Acc0 = L_negate(L_shr( Acc0, (Word16) 2 ) ) ;\n                        Acc0 = L_mac( Acc0, Ccr, Mnr ) ;\n                        Acc0 = L_msu( Acc0, Enr, Tmp ) ;\n                        if ( Acc0 > (Word32) 0 ) {\n                            Indx = (Word16) i ;\n                            Mxp = Exp ;\n                            Mcr = Ccr ;\n                            Mnr = Enr ;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return Indx ;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Rem_Dc()\n**\n** Description:     High-pass filtering\n**\n** Links to text:   Section 2.3\n**\n** Arguments:\n**\n**  Word16 *Dpnt\n**\n** Inputs:\n**\n**  CodStat.HpfZdl  FIR filter memory from previous frame (1 word)\n**  CodStat.HpfPdl  IIR filter memory from previous frame (1 word)\n**\n** Outputs:\n**\n**  Word16 *Dpnt\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Rem_Dc( Word16 *Dpnt )", "code": "{\n    int   i  ;\n\n\n    Word32   Acc0,Acc1 ;\n\n    if ( UseHp ) {\n        for ( i = 0 ; i < Frame ; i ++ ) {\n\n            /* Do the Fir and scale by 2 */\n            Acc0 = L_mult( Dpnt[i], (Word16) 0x4000 ) ;\n            Acc0 = L_mac ( Acc0, CodStat.HpfZdl, (Word16) 0xc000 ) ;\n            CodStat.HpfZdl = Dpnt[i] ;\n\n            /* Do the Iir part */\n            Acc1 = L_mls( CodStat.HpfPdl, (Word16) 0x7f00 ) ;\n            Acc0 = L_add( Acc0, Acc1 ) ;\n            CodStat.HpfPdl = Acc0 ;\n            Dpnt[i] = round_(Acc0) ;\n        }\n    }\n    else {\n        for ( i = 0 ; i < Frame ; i ++ )\n            Dpnt[i] = shr( Dpnt[i], (Word16) 1 ) ;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\util_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Cor_h()\n**\n** Description:     Compute correlations of h[] needed for the codebook search.\n**\n** Links to text:   Section 2.16\n**\n** Arguments:\n**\n**  Word16 h[]              Impulse response.\n**  Word16 rr[]             Correlations.\n**\n**  Outputs:\n**\n**  Word16 rr[]             Correlations.\n**\n**  Return value :          None\n*/\n", "func_signal": "void Cor_h(Word16 *H, Word16 *rr)", "code": "{\n    Word16 *rri0i0, *rri1i1, *rri2i2, *rri3i3;\n    Word16 *rri0i1, *rri0i2, *rri0i3;\n    Word16 *rri1i2, *rri1i3, *rri2i3;\n\n    Word16 *p0, *p1, *p2, *p3;\n\n    Word16 *ptr_hd, *ptr_hf, *ptr_h1, *ptr_h2;\n    Word32 cor;\n    Word16 i, k, ldec, l_fin_sup, l_fin_inf;\n    Word16 h[SubFrLen2];\n\n    /* Scaling for maximum precision */\n\n    cor = 0;\n    for(i=0; i<SubFrLen; i++)\n        cor = L_mac(cor, H[i], H[i]);\n\n    if(extract_h(cor) > 32000 ) {\n        for(i=0; i<SubFrLen; i++) h[i+4] = shr(H[i], 1);\n    }\n    else {\n        k = norm_l(cor);\n        k = shr(k, 1);\n        for(i=0; i<SubFrLen; i++) h[i+4] = shl(H[i], k);\n    }\n\n    for(i=0; i<4; i++) h[i] = 0;\n\n    /* Init pointers */\n\n    rri0i0 = rr;\n    rri1i1 = rri0i0 + NB_POS;\n    rri2i2 = rri1i1 + NB_POS;\n    rri3i3 = rri2i2 + NB_POS;\n\n    rri0i1 = rri3i3 + NB_POS;\n    rri0i2 = rri0i1 + MSIZE;\n    rri0i3 = rri0i2 + MSIZE;\n    rri1i2 = rri0i3 + MSIZE;\n    rri1i3 = rri1i2 + MSIZE;\n    rri2i3 = rri1i3 + MSIZE;\n\n /*\n  * Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]\n  */\n\n    p0 = rri0i0 + NB_POS-1;   /* Init pointers to last position of rrixix[] */\n    p1 = rri1i1 + NB_POS-1;\n    p2 = rri2i2 + NB_POS-1;\n    p3 = rri3i3 + NB_POS-1;\n\n    ptr_h1 = h;\n    cor    = 0;\n    for(i=0;  i<NB_POS; i++) {\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        *p3-- = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        *p2-- = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        *p1-- = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h1); ptr_h1++;\n        *p0-- = extract_h(cor);\n    }\n\n\n /*\n  * Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]\n  */\n\n    l_fin_sup = MSIZE-1;\n    l_fin_inf = l_fin_sup-(Word16)1;\n    ldec = NB_POS+1;\n\n    ptr_hd = h;\n    ptr_hf = ptr_hd + 2;\n\n    for(k=0; k<NB_POS; k++) {\n\n        p3 = rri2i3 + l_fin_sup;\n        p2 = rri1i2 + l_fin_sup;\n        p1 = rri0i1 + l_fin_sup;\n        p0 = rri0i3 + l_fin_inf;\n        cor = 0;\n        ptr_h1 = ptr_hd;\n        ptr_h2 =  ptr_hf;\n\n        for(i=k+(Word16)1; i<NB_POS; i++ ) {\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p3 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p2 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p1 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p0 = extract_h(cor);\n\n            p3 -= ldec;\n            p2 -= ldec;\n            p1 -= ldec;\n            p0 -= ldec;\n        }\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p3 = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p2 = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p1 = extract_h(cor);\n\n        l_fin_sup -= NB_POS;\n        l_fin_inf--;\n        ptr_hf += STEP;\n    }\n\n /*\n  * Compute elements of: rri0i2[], rri1i3[]\n  */\n\n    ptr_hd = h;\n    ptr_hf = ptr_hd + 4;\n    l_fin_sup = MSIZE-1;\n    l_fin_inf = l_fin_sup-(Word16)1;\n    for(k=0; k<NB_POS; k++) {\n        p3 = rri1i3 + l_fin_sup;\n        p2 = rri0i2 + l_fin_sup;\n        p1 = rri1i3 + l_fin_inf;\n        p0 = rri0i2 + l_fin_inf;\n\n        cor = 0;\n        ptr_h1 = ptr_hd;\n        ptr_h2 =  ptr_hf;\n        for(i=k+(Word16)1; i<NB_POS; i++ ) {\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p3 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p2 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p1 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p0 = extract_h(cor);\n\n            p3 -= ldec;\n            p2 -= ldec;\n            p1 -= ldec;\n            p0 -= ldec;\n        }\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p3 = extract_h(cor);\n\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p2 = extract_h(cor);\n\n\n        l_fin_sup -= NB_POS;\n        l_fin_inf--;\n        ptr_hf += STEP;\n    }\n\n /*\n  * Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]\n  */\n\n    ptr_hd = h;\n    ptr_hf = ptr_hd + 6;\n    l_fin_sup = MSIZE-1;\n    l_fin_inf = l_fin_sup-(Word16)1;\n    for(k=0; k<NB_POS; k++) {\n\n        p3 = rri0i3 + l_fin_sup;\n        p2 = rri2i3 + l_fin_inf;\n        p1 = rri1i2 + l_fin_inf;\n        p0 = rri0i1 + l_fin_inf;\n\n        ptr_h1 = ptr_hd;\n        ptr_h2 =  ptr_hf;\n        cor = 0;\n        for(i=k+(Word16)1; i<NB_POS; i++ ) {\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p3 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p2 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p1 = extract_h(cor);\n\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n            *p0 = extract_h(cor);\n\n            p3 -= ldec;\n            p2 -= ldec;\n            p1 -= ldec;\n            p0 -= ldec;\n        }\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        cor = L_mac(cor, *ptr_h1, *ptr_h2); ptr_h1++; ptr_h2++;\n        *p3 = extract_h(cor);\n\n        l_fin_sup -= NB_POS;\n        l_fin_inf--;\n        ptr_hf += STEP;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/*\n**\n** Function:        Gen_Trn()\n**\n** Description:     Generation of a train of Dirac functions with the period\n**                  Olp.\n**\n** Links to text:   Section 2.15\n**\n** Arguments:\n**\n**  Word16 *Dst     Fixed codebook excitation vector with  train of Dirac\n**  Word16 *Src     Fixed codebook excitation vector without train of Dirac\n**  Word16 Olp      Closed-loop pitch lag of subframe 0 (for subframes 0 & 1)\n**                  Closed-loop pitch lag of subframe 2 (for subframes 2 & 3)\n**\n** Outputs:\n**\n**  Word16 *Dst     excitation vector\n**\n** Return value:    None\n**\n*/\n", "func_signal": "void  Gen_Trn( Word16 *Dst, Word16 *Src, Word16 Olp )", "code": "{\n    int   i  ;\n\n    Word16   Tmp0,Tmp1   ;\n    Word16   Tmp[SubFrLen] ;\n\n    Tmp0 = Olp ;\n\n    for ( i = 0 ; i < SubFrLen ; i ++ ) {\n        Tmp[i] = Src[i] ;\n        Dst[i] = Src[i] ;\n    }\n\n    while ( Tmp0 < SubFrLen ) {\n        for ( i = (int) Tmp0 ; i < SubFrLen ; i ++ ) {\n            Tmp1 = add( Dst[i], Tmp[i-(int)Tmp0] ) ;\n            Dst[i] = Tmp1 ;\n        }\n        Tmp0 = add( Tmp0, Olp ) ;\n    }\n\n    return;\n}", "path": "g723\\src.orig\\exc_lbc.c", "repo_name": "happyherry/g723.1", "stars": 7, "license": "None", "language": "c", "size": 1908}
{"docstring": "/* Call processFunction on the uncompressed data of a STORED entry.\n */\n", "func_signal": "static bool processStoredEntry(const ZipArchive *pArchive,\n    const ZipEntry *pEntry, ProcessZipEntryContentsFunction processFunction,\n    void *cookie)", "code": "{\n    size_t bytesLeft = pEntry->compLen;\n    while (bytesLeft > 0) {\n        unsigned char buf[32 * 1024];\n        ssize_t n;\n        size_t count;\n        bool ret;\n\n        count = bytesLeft;\n        if (count > sizeof(buf)) {\n            count = sizeof(buf);\n        }\n        n = read(pArchive->fd, buf, count);\n        if (n < 0 || (size_t)n != count) {\n            LOGE(\"Can't read %zu bytes from zip file: %ld\\n\", count, n);\n            return false;\n        }\n        ret = processFunction(buf, n, cookie);\n        if (!ret) {\n            return false;\n        }\n        bytesLeft -= count;\n    }\n    return true;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * (This is a mzHashTableLookup callback.)\n *\n * Compare two ZipEntry structs, by name.\n */\n", "func_signal": "static int hashcmpZipEntry(const void* ventry1, const void* ventry2)", "code": "{\n    const ZipEntry* entry1 = (const ZipEntry*) ventry1;\n    const ZipEntry* entry2 = (const ZipEntry*) ventry2;\n\n    if (entry1->fileNameLen != entry2->fileNameLen)\n        return entry1->fileNameLen - entry2->fileNameLen;\n    return memcmp(entry1->fileName, entry2->fileName, entry1->fileNameLen);\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Verify /META-INF/MANIFEST.MF against the digest in a signature file. */\n", "func_signal": "static const ZipEntry *verifyManifest(const ZipArchive *pArchive,\n        const ZipEntry *sfEntry)", "code": "{\n    static const char prefix[] = \"SHA1-Digest-Manifest: \", eol[] = \"\\r\\n\";\n    uint8_t expected[SHA_DIGEST_SIZE + 3], actual[SHA_DIGEST_SIZE];\n\n    char *sfBuf = slurpEntry(pArchive, sfEntry);\n    if (sfBuf == NULL) return NULL;\n\n    char *line, *save;\n    for (line = strtok_r(sfBuf, eol, &save); line != NULL;\n         line = strtok_r(NULL, eol, &save)) {\n        if (!strncasecmp(prefix, line, sizeof(prefix) - 1)) {\n            UnterminatedString fn = mzGetZipEntryFileName(sfEntry);\n            const char *digest = line + sizeof(prefix) - 1;\n            int n = b64_pton(digest, expected, sizeof(expected));\n            if (n != SHA_DIGEST_SIZE) {\n                LOGE(\"Invalid base64 in %.*s: %s (%d)\\n\",\n                        fn.len, fn.str, digest, n);\n                line = NULL;\n            }\n            break;\n        }\n    }\n\n    free(sfBuf);\n\n    if (line == NULL) {\n        LOGE(\"No digest manifest in signature file\\n\");\n        return false;\n    }\n\n    const char *mfName = \"META-INF/MANIFEST.MF\";\n    const ZipEntry *mfEntry = mzFindZipEntry(pArchive, mfName);\n    if (mfEntry == NULL) {\n        LOGE(\"No manifest file %s\\n\", mfName);\n        return NULL;\n    }\n\n    if (!digestEntry(pArchive, mfEntry, NULL, 0, actual)) return NULL;\n    if (memcmp(expected, actual, SHA_DIGEST_SIZE)) {\n        UnterminatedString fn = mzGetZipEntryFileName(sfEntry);\n        LOGE(\"Wrong digest for %s in %.*s\\n\", mfName, fn.len, fn.str);\n        return NULL;\n    }\n\n    LOGI(\"Verified %s\\n\", mfName);\n    return mfEntry;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Inflate all entries under zipDir to the directory specified by\n * targetDir, which must exist and be a writable directory.\n *\n * The immediate children of zipDir will become the immediate\n * children of targetDir; e.g., if the archive contains the entries\n *\n *     a/b/c/one\n *     a/b/c/two\n *     a/b/c/d/three\n *\n * and mzExtractRecursive(a, \"a/b/c\", \"/tmp\") is called, the resulting\n * files will be\n *\n *     /tmp/one\n *     /tmp/two\n *     /tmp/d/three\n *\n * Returns true on success, false on failure.\n */\n", "func_signal": "bool mzExtractRecursive(const ZipArchive *pArchive,\n                        const char *zipDir, const char *targetDir,\n                        int flags, const struct utimbuf *timestamp,\n                        void (*callback)(const char *fn, void *), void *cookie)", "code": "{\n    if (zipDir[0] == '/') {\n        LOGE(\"mzExtractRecursive(): zipDir must be a relative path.\\n\");\n        return false;\n    }\n    if (targetDir[0] != '/') {\n        LOGE(\"mzExtractRecursive(): targetDir must be an absolute path.\\n\");\n        return false;\n    }\n\n    unsigned int zipDirLen;\n    char *zpath;\n\n    zipDirLen = strlen(zipDir);\n    zpath = (char *)malloc(zipDirLen + 2);\n    if (zpath == NULL) {\n        LOGE(\"Can't allocate %d bytes for zip path\\n\", zipDirLen + 2);\n        return false;\n    }\n    /* If zipDir is empty, we'll extract the entire zip file.\n     * Otherwise, canonicalize the path.\n     */\n    if (zipDirLen > 0) {\n        /* Make sure there's (hopefully, exactly one) slash at the\n         * end of the path.  This way we don't need to worry about\n         * accidentally extracting \"one/twothree\" when a path like\n         * \"one/two\" is specified.\n         */\n        memcpy(zpath, zipDir, zipDirLen);\n        if (zpath[zipDirLen-1] != '/') {\n            zpath[zipDirLen++] = '/';\n        }\n    }\n    zpath[zipDirLen] = '\\0';\n\n    /* Set up the helper structure that we'll use to assemble paths.\n     */\n    MzPathHelper helper;\n    helper.targetDir = targetDir;\n    helper.targetDirLen = strlen(helper.targetDir);\n    helper.zipDir = zpath;\n    helper.zipDirLen = strlen(helper.zipDir);\n    helper.buf = NULL;\n    helper.bufLen = 0;\n\n    /* Walk through the entries and extract anything whose path begins\n     * with zpath.\n//TODO: since the entries are sorted, binary search for the first match\n//      and stop after the first non-match.\n     */\n    unsigned int i;\n    bool seenMatch = false;\n    int ok = true;\n    for (i = 0; i < pArchive->numEntries; i++) {\n        ZipEntry *pEntry = pArchive->pEntries + i;\n        if (pEntry->fileNameLen < zipDirLen) {\n//TODO: look out for a single empty directory entry that matches zpath, but\n//      missing the trailing slash.  Most zip files seem to include\n//      the trailing slash, but I think it's legal to leave it off.\n//      e.g., zpath \"a/b/\", entry \"a/b\", with no children of the entry.\n            /* No chance of matching.\n             */\n#if SORT_ENTRIES\n            if (seenMatch) {\n                /* Since the entries are sorted, we can give up\n                 * on the first mismatch after the first match.\n                 */\n                break;\n            }\n#endif\n            continue;\n        }\n        /* If zpath is empty, this strncmp() will match everything,\n         * which is what we want.\n         */\n        if (strncmp(pEntry->fileName, zpath, zipDirLen) != 0) {\n#if SORT_ENTRIES\n            if (seenMatch) {\n                /* Since the entries are sorted, we can give up\n                 * on the first mismatch after the first match.\n                 */\n                break;\n            }\n#endif\n            continue;\n        }\n        /* This entry begins with zipDir, so we'll extract it.\n         */\n        seenMatch = true;\n\n        /* Find the target location of the entry.\n         */\n        const char *targetFile = targetEntryPath(&helper, pEntry);\n        if (targetFile == NULL) {\n            LOGE(\"Can't assemble target path for \\\"%.*s\\\"\\n\",\n                    pEntry->fileNameLen, pEntry->fileName);\n            ok = false;\n            break;\n        }\n\n        /* With DRY_RUN set, invoke the callback but don't do anything else.\n         */\n        if (flags & MZ_EXTRACT_DRY_RUN) {\n            if (callback != NULL) callback(targetFile, cookie);\n            continue;\n        }\n\n        /* Create the file or directory.\n         */\n#define UNZIP_DIRMODE 0755\n#define UNZIP_FILEMODE 0644\n        if (pEntry->fileName[pEntry->fileNameLen-1] == '/') {\n            if (!(flags & MZ_EXTRACT_FILES_ONLY)) {\n                int ret = dirCreateHierarchy(\n                        targetFile, UNZIP_DIRMODE, timestamp, false);\n                if (ret != 0) {\n                    LOGE(\"Can't create containing directory for \\\"%s\\\": %s\\n\",\n                            targetFile, strerror(errno));\n                    ok = false;\n                    break;\n                }\n                LOGD(\"Extracted dir \\\"%s\\\"\\n\", targetFile);\n            }\n        } else {\n            /* This is not a directory.  First, make sure that\n             * the containing directory exists.\n             */\n            int ret = dirCreateHierarchy(\n                    targetFile, UNZIP_DIRMODE, timestamp, true);\n            if (ret != 0) {\n                LOGE(\"Can't create containing directory for \\\"%s\\\": %s\\n\",\n                        targetFile, strerror(errno));\n                ok = false;\n                break;\n            }\n\n            /* With FILES_ONLY set, we need to ignore metadata entirely,\n             * so treat symlinks as regular files.\n             */\n            if (!(flags & MZ_EXTRACT_FILES_ONLY) && mzIsZipEntrySymlink(pEntry)) {\n                /* The entry is a symbolic link.\n                 * The relative target of the symlink is in the\n                 * data section of this entry.\n                 */\n                if (pEntry->uncompLen == 0) {\n                    LOGE(\"Symlink entry \\\"%s\\\" has no target\\n\",\n                            targetFile);\n                    ok = false;\n                    break;\n                }\n                char *linkTarget = malloc(pEntry->uncompLen + 1);\n                if (linkTarget == NULL) {\n                    ok = false;\n                    break;\n                }\n                ok = mzReadZipEntry(pArchive, pEntry, linkTarget,\n                        pEntry->uncompLen);\n                if (!ok) {\n                    LOGE(\"Can't read symlink target for \\\"%s\\\"\\n\",\n                            targetFile);\n                    free(linkTarget);\n                    break;\n                }\n                linkTarget[pEntry->uncompLen] = '\\0';\n\n                /* Make the link.\n                 */\n                ret = symlink(linkTarget, targetFile);\n                if (ret != 0) {\n                    LOGE(\"Can't symlink \\\"%s\\\" to \\\"%s\\\": %s\\n\",\n                            targetFile, linkTarget, strerror(errno));\n                    free(linkTarget);\n                    ok = false;\n                    break;\n                }\n                LOGD(\"Extracted symlink \\\"%s\\\" -> \\\"%s\\\"\\n\",\n                        targetFile, linkTarget);\n                free(linkTarget);\n            } else {\n                /* The entry is a regular file.\n                 * Open the target for writing.\n                 */\n                int fd = creat(targetFile, UNZIP_FILEMODE);\n                if (fd < 0) {\n                    LOGE(\"Can't create target file \\\"%s\\\": %s\\n\",\n                            targetFile, strerror(errno));\n                    ok = false;\n                    break;\n                }\n\n                bool ok = mzExtractZipEntryToFile(pArchive, pEntry, fd);\n                close(fd);\n                if (!ok) {\n                    LOGE(\"Error extracting \\\"%s\\\"\\n\", targetFile);\n                    ok = false;\n                    break;\n                }\n\n                if (timestamp != NULL && utime(targetFile, timestamp)) {\n                    LOGE(\"Error touching \\\"%s\\\"\\n\", targetFile);\n                    ok = false;\n                    break;\n                }\n\n                LOGD(\"Extracted file \\\"%s\\\"\\n\", targetFile);\n            }\n        }\n\n        if (callback != NULL) callback(targetFile, cookie);\n    }\n\n    free(helper.buf);\n    free(zpath);\n\n    return ok;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Uncompress \"pEntry\" in \"pArchive\" to \"fd\" at the current offset.\n */\n", "func_signal": "bool mzExtractZipEntryToFile(const ZipArchive *pArchive,\n    const ZipEntry *pEntry, int fd)", "code": "{\n    bool ret = mzProcessZipEntryContents(pArchive, pEntry, writeProcessFunction,\n            (void *)fd);\n    if (!ret) {\n        LOGE(\"Can't extract entry to file.\\n\");\n        return false;\n    }\n    return true;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Compute the hash code for a ZipEntry filename.\n *\n * Not expected to be compatible with any other hash function, so we init\n * to 2 to ensure it doesn't happen to match.\n */\n", "func_signal": "static unsigned int computeHash(const char* name, int nameLen)", "code": "{\n    unsigned int hash = 2;\n\n    while (nameLen--)\n        hash = hash * 31 + *name++;\n\n    return hash;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Get the SHA-1 digest of a zip file entry. */\n", "func_signal": "static bool digestEntry(const ZipArchive *pArchive, const ZipEntry *pEntry,\n        unsigned *doneBytes, unsigned totalBytes,\n        uint8_t digest[SHA_DIGEST_SIZE])", "code": "{\n    struct DigestContext context;\n    SHA_init(&context.digest);\n    context.doneBytes = doneBytes;\n    context.totalBytes = totalBytes;\n    if (!mzProcessZipEntryContents(pArchive, pEntry, updateHash, &context)) {\n        UnterminatedString fn = mzGetZipEntryFileName(pEntry);\n        LOGE(\"Can't digest %.*s\\n\", fn.len, fn.str);\n        return false;\n    }\n\n    memcpy(digest, SHA_final(&context.digest), SHA_DIGEST_SIZE);\n\n#ifdef LOG_VERBOSE\n    UnterminatedString fn = mzGetZipEntryFileName(pEntry);\n    char base64[SHA_DIGEST_SIZE * 3];\n    b64_ntop(digest, SHA_DIGEST_SIZE, base64, sizeof(base64));\n    LOGV(\"sha1(%.*s) = %s\\n\", fn.len, fn.str, base64);\n#endif\n\n    return true;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Parse the contents of a Zip archive.  After confirming that the file\n * is in fact a Zip, we scan out the contents of the central directory and\n * store it in a hash table.\n *\n * Returns \"true\" on success.\n */\n", "func_signal": "static bool parseZipArchive(ZipArchive* pArchive, const MemMapping* pMap)", "code": "{\n    bool result = false;\n    const unsigned char* ptr;\n    unsigned int i, numEntries, cdOffset;\n    unsigned int val;\n\n    /*\n     * The first 4 bytes of the file will either be the local header\n     * signature for the first file (LOCSIG) or, if the archive doesn't\n     * have any files in it, the end-of-central-directory signature (ENDSIG).\n     */\n    val = get4LE(pMap->addr);\n    if (val == ENDSIG) {\n        LOGI(\"Found Zip archive, but it looks empty\\n\");\n        goto bail;\n    } else if (val != LOCSIG) {\n        LOGV(\"Not a Zip archive (found 0x%08x)\\n\", val);\n        goto bail;\n    }\n\n    /*\n     * Find the EOCD.  We'll find it immediately unless they have a file\n     * comment.\n     */\n    ptr = pMap->addr + pMap->length - ENDHDR;\n\n    while (ptr >= (const unsigned char*) pMap->addr) {\n        if (*ptr == (ENDSIG & 0xff) && get4LE(ptr) == ENDSIG)\n            break;\n        ptr--;\n    }\n    if (ptr < (const unsigned char*) pMap->addr) {\n        LOGI(\"Could not find end-of-central-directory in Zip\\n\");\n        goto bail;\n    }\n\n    /*\n     * There are two interesting items in the EOCD block: the number of\n     * entries in the file, and the file offset of the start of the\n     * central directory.\n     */\n    numEntries = get2LE(ptr + ENDSUB);\n    cdOffset = get4LE(ptr + ENDOFF);\n\n    LOGVV(\"numEntries=%d cdOffset=%d\\n\", numEntries, cdOffset);\n    if (numEntries == 0 || cdOffset >= pMap->length) {\n        LOGW(\"Invalid entries=%d offset=%d (len=%zd)\\n\",\n            numEntries, cdOffset, pMap->length);\n        goto bail;\n    }\n\n    /*\n     * Create data structures to hold entries.\n     */\n    pArchive->numEntries = numEntries;\n    pArchive->pEntries = (ZipEntry*) calloc(numEntries, sizeof(ZipEntry));\n    pArchive->pHash = mzHashTableCreate(mzHashSize(numEntries), NULL);\n    if (pArchive->pEntries == NULL || pArchive->pHash == NULL)\n        goto bail;\n\n    ptr = pMap->addr + cdOffset;\n    for (i = 0; i < numEntries; i++) {\n        ZipEntry* pEntry;\n        unsigned int fileNameLen, extraLen, commentLen, localHdrOffset;\n        const unsigned char* localHdr;\n        const char *fileName;\n\n        if (ptr + CENHDR > (const unsigned char*)pMap->addr + pMap->length) {\n            LOGW(\"Ran off the end (at %d)\\n\", i);\n            goto bail;\n        }\n        if (get4LE(ptr) != CENSIG) {\n            LOGW(\"Missed a central dir sig (at %d)\\n\", i);\n            goto bail;\n        }\n\n        localHdrOffset = get4LE(ptr + CENOFF);\n        fileNameLen = get2LE(ptr + CENNAM);\n        extraLen = get2LE(ptr + CENEXT);\n        commentLen = get2LE(ptr + CENCOM);\n        fileName = (const char*)ptr + CENHDR;\n        if (fileName + fileNameLen > (const char*)pMap->addr + pMap->length) {\n            LOGW(\"Filename ran off the end (at %d)\\n\", i);\n            goto bail;\n        }\n        if (!validFilename(fileName, fileNameLen)) {\n            LOGW(\"Invalid filename (at %d)\\n\", i);\n            goto bail;\n        }\n\n#if SORT_ENTRIES\n        /* Figure out where this entry should go (binary search).\n         */\n        if (i > 0) {\n            int low, high;\n\n            low = 0;\n            high = i - 1;\n            while (low <= high) {\n                int mid;\n                int diff;\n                int diffLen;\n\n                mid = low + ((high - low) / 2); // avoid overflow\n\n                if (pArchive->pEntries[mid].fileNameLen < fileNameLen) {\n                    diffLen = pArchive->pEntries[mid].fileNameLen;\n                } else {\n                    diffLen = fileNameLen;\n                }\n                diff = strncmp(pArchive->pEntries[mid].fileName, fileName,\n                        diffLen);\n                if (diff == 0) {\n                    diff = pArchive->pEntries[mid].fileNameLen - fileNameLen;\n                }\n                if (diff < 0) {\n                    low = mid + 1;\n                } else if (diff > 0) {\n                    high = mid - 1;\n                } else {\n                    high = mid;\n                    break;\n                }\n            }\n\n            unsigned int target = high + 1;\n            assert(target <= i);\n            if (target != i) {\n                /* It belongs somewhere other than at the end of\n                 * the list.  Make some room at [target].\n                 */\n                memmove(pArchive->pEntries + target + 1,\n                        pArchive->pEntries + target,\n                        (i - target) * sizeof(ZipEntry));\n            }\n            pEntry = &pArchive->pEntries[target];\n        } else {\n            pEntry = &pArchive->pEntries[0];\n        }\n#else\n        pEntry = &pArchive->pEntries[i];\n#endif\n\n        //LOGI(\"%d: localHdr=%d fnl=%d el=%d cl=%d\\n\",\n        //    i, localHdrOffset, fileNameLen, extraLen, commentLen);\n\n        pEntry->fileNameLen = fileNameLen;\n        pEntry->fileName = fileName;\n\n        pEntry->compLen = get4LE(ptr + CENSIZ);\n        pEntry->uncompLen = get4LE(ptr + CENLEN);\n        pEntry->compression = get2LE(ptr + CENHOW);\n        pEntry->modTime = get4LE(ptr + CENTIM);\n        pEntry->crc32 = get4LE(ptr + CENCRC);\n\n        /* These two are necessary for finding the mode of the file.\n         */\n        pEntry->versionMadeBy = get2LE(ptr + CENVEM);\n        if ((pEntry->versionMadeBy & 0xff00) != 0 &&\n                (pEntry->versionMadeBy & 0xff00) != CENVEM_UNIX)\n        {\n            LOGW(\"Incompatible \\\"version made by\\\": 0x%02x (at %d)\\n\",\n                    pEntry->versionMadeBy >> 8, i);\n            goto bail;\n        }\n        pEntry->externalFileAttributes = get4LE(ptr + CENATX);\n\n        // Perform pMap->addr + localHdrOffset, ensuring that it won't\n        // overflow. This is needed because localHdrOffset is untrusted.\n        if (!safe_add((uintptr_t *)&localHdr, (uintptr_t)pMap->addr,\n            (uintptr_t)localHdrOffset)) {\n            LOGW(\"Integer overflow adding in parseZipArchive\\n\");\n            goto bail;\n        }\n        if ((uintptr_t)localHdr + LOCHDR >\n            (uintptr_t)pMap->addr + pMap->length) {\n            LOGW(\"Bad offset to local header: %d (at %d)\\n\", localHdrOffset, i);\n            goto bail;\n        }\n        if (get4LE(localHdr) != LOCSIG) {\n            LOGW(\"Missed a local header sig (at %d)\\n\", i);\n            goto bail;\n        }\n        pEntry->offset = localHdrOffset + LOCHDR\n            + get2LE(localHdr + LOCNAM) + get2LE(localHdr + LOCEXT);\n        if (!safe_add(NULL, pEntry->offset, pEntry->compLen)) {\n            LOGW(\"Integer overflow adding in parseZipArchive\\n\");\n            goto bail;\n        }\n        if ((size_t)pEntry->offset + pEntry->compLen > pMap->length) {\n            LOGW(\"Data ran off the end (at %d)\\n\", i);\n            goto bail;\n        }\n\n#if !SORT_ENTRIES\n        /* Add to hash table; no need to lock here.\n         * Can't do this now if we're sorting, because entries\n         * will move around.\n         */\n        addEntryToHashTable(pArchive->pHash, pEntry);\n#endif\n\n        //dumpEntry(pEntry);\n        ptr += CENHDR + fileNameLen + extraLen + commentLen;\n    }\n\n#if SORT_ENTRIES\n    /* If we're sorting, we have to wait until all entries\n     * are in their final places, otherwise the pointers will\n     * probably point to the wrong things.\n     */\n    for (i = 0; i < numEntries; i++) {\n        /* Add to hash table; no need to lock here.\n         */\n        addEntryToHashTable(pArchive->pHash, &pArchive->pEntries[i]);\n    }\n#endif\n\n    result = true;\n\nbail:\n    if (!result) {\n        mzHashTableFree(pArchive->pHash);\n        pArchive->pHash = NULL;\n    }\n    return result;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Given the values of targetDir and zipDir in the helper,\n * return the target filename of the provided entry.\n * The helper must be initialized first.\n */\n", "func_signal": "static const char *targetEntryPath(MzPathHelper *helper, ZipEntry *pEntry)", "code": "{\n    int needLen;\n    bool firstTime = (helper->buf == NULL);\n\n    /* target file <-- targetDir + / + entry[zipDirLen:]\n     */\n    needLen = helper->targetDirLen + 1 +\n            pEntry->fileNameLen - helper->zipDirLen + 1;\n    if (needLen > helper->bufLen) {\n        char *newBuf;\n\n        needLen *= 2;\n        newBuf = (char *)realloc(helper->buf, needLen);\n        if (newBuf == NULL) {\n            return NULL;\n        }\n        helper->buf = newBuf;\n        helper->bufLen = needLen;\n    }\n\n    /* Every path will start with the target path and a slash.\n     */\n    if (firstTime) {\n        char *p = helper->buf;\n        memcpy(p, helper->targetDir, helper->targetDirLen);\n        p += helper->targetDirLen;\n        if (p == helper->buf || p[-1] != '/') {\n            helper->targetDirLen += 1;\n            *p++ = '/';\n        }\n    }\n\n    /* Replace the custom part of the path with the appropriate\n     * part of the entry's path.\n     */\n    char *epath = helper->buf + helper->targetDirLen;\n    memcpy(epath, pEntry->fileName + helper->zipDirLen,\n            pEntry->fileNameLen - helper->zipDirLen);\n    epath += pEntry->fileNameLen - helper->zipDirLen;\n    *epath = '\\0';\n\n    return helper->buf;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Find a /META-INF/xxx.SF signature file signed by a matching xxx.RSA file. */\n", "func_signal": "static const ZipEntry *verifySignature(const ZipArchive *pArchive,\n        const RSAPublicKey *pKeys, unsigned int numKeys)", "code": "{\n    static const char prefix[] = \"META-INF/\";\n    static const char rsa[] = \".RSA\", sf[] = \".SF\";\n\n    unsigned int i, j;\n    for (i = 0; i < mzZipEntryCount(pArchive); ++i) {\n        const ZipEntry *rsaEntry = mzGetZipEntryAt(pArchive, i);\n        UnterminatedString rsaName = mzGetZipEntryFileName(rsaEntry);\n        int rsaLen = mzGetZipEntryUncompLen(rsaEntry);\n        if (rsaLen >= RSANUMBYTES && rsaName.len > sizeof(prefix) &&\n                !strncmp(rsaName.str, prefix, sizeof(prefix) - 1) &&\n                !strncmp(rsaName.str + rsaName.len - sizeof(rsa) + 1,\n                         rsa, sizeof(rsa) - 1)) {\n            char *sfName = malloc(rsaName.len - sizeof(rsa) + sizeof(sf) + 1);\n            if (sfName == NULL) {\n                LOGE(\"Can't allocate %d bytes for filename\\n\", rsaName.len);\n                continue;\n            }\n\n            /* Replace .RSA with .SF */\n            strncpy(sfName, rsaName.str, rsaName.len - sizeof(rsa) + 1);\n            strcpy(sfName + rsaName.len - sizeof(rsa) + 1, sf);\n            const ZipEntry *sfEntry = mzFindZipEntry(pArchive, sfName);\n\n            if (sfEntry == NULL) {\n                LOGW(\"Missing signature file %s\\n\", sfName);\n                free(sfName);\n                continue;\n            }\n\n            free(sfName);\n\n            uint8_t sfDigest[SHA_DIGEST_SIZE];\n            if (!digestEntry(pArchive, sfEntry, NULL, 0, sfDigest)) continue;\n\n            char *rsaBuf = slurpEntry(pArchive, rsaEntry);\n            if (rsaBuf == NULL) continue;\n\n            /* Try to verify the signature with all the keys. */\n            uint8_t *sig = (uint8_t *) rsaBuf + rsaLen - RSANUMBYTES;\n            for (j = 0; j < numKeys; ++j) {\n                if (RSA_verify(&pKeys[j], sig, RSANUMBYTES, sfDigest)) {\n                    free(rsaBuf);\n                    LOGI(\"Verified %.*s\\n\", rsaName.len, rsaName.str);\n                    return sfEntry;\n                }\n            }\n\n            free(rsaBuf);\n            LOGW(\"Can't verify %.*s\\n\", rsaName.len, rsaName.str);\n        }\n    }\n\n    LOGE(\"No signature (%d files)\\n\", mzZipEntryCount(pArchive));\n    return NULL;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Return true if the entry is a symbolic link.\n */\n", "func_signal": "bool mzIsZipEntrySymlink(const ZipEntry* pEntry)", "code": "{\n    if ((pEntry->versionMadeBy & 0xff00) == CENVEM_UNIX) {\n        return S_ISLNK(pEntry->externalFileAttributes >> 16);\n    }\n    return false;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Find a matching entry.\n *\n * Returns NULL if no matching entry found.\n */\n", "func_signal": "const ZipEntry* mzFindZipEntry(const ZipArchive* pArchive,\n        const char* entryName)", "code": "{\n    unsigned int itemHash = computeHash(entryName, strlen(entryName));\n\n    return (const ZipEntry*)mzHashTableLookup(pArchive->pHash,\n                itemHash, (char*) entryName, hashcmpZipName, false);\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Read an entry into a buffer allocated by the caller.\n */\n", "func_signal": "bool mzReadZipEntry(const ZipArchive* pArchive, const ZipEntry* pEntry,\n        char *buf, int bufLen)", "code": "{\n    CopyProcessArgs args;\n    bool ret;\n    \n    args.buf = buf;\n    args.bufLen = bufLen;\n    ret = mzProcessZipEntryContents(pArchive, pEntry, copyProcessFunction,\n            (void *)&args);\n    if (!ret) {\n        LOGE(\"Can't extract entry to buffer.\\n\");\n        return false;\n    }\n    return true;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Verify all the files in a Zip archive against the manifest. */\n", "func_signal": "static bool verifyArchive(const ZipArchive *pArchive, const ZipEntry *mfEntry)", "code": "{\n    static const char namePrefix[] = \"Name: \";\n    static const char contPrefix[] = \" \";  // Continuation of the filename\n    static const char digestPrefix[] = \"SHA1-Digest: \";\n    static const char eol[] = \"\\r\\n\";\n\n    char *mfBuf = slurpEntry(pArchive, mfEntry);\n    if (mfBuf == NULL) return false;\n\n    /* we're using calloc() here, so the initial state of the array is false */\n    bool *unverified = (bool *) calloc(mzZipEntryCount(pArchive), sizeof(bool));\n    if (unverified == NULL) {\n        LOGE(\"Can't allocate valid flags\\n\");\n        free(mfBuf);\n        return false;\n    }\n\n    /* Mark all the files in the archive that need to be verified.\n     * As we scan the manifest and check signatures, we'll unset these flags.\n     * At the end, we'll make sure that all the flags are unset.\n     */\n\n    unsigned i, totalBytes = 0;\n    for (i = 0; i < mzZipEntryCount(pArchive); ++i) {\n        const ZipEntry *entry = mzGetZipEntryAt(pArchive, i);\n        UnterminatedString fn = mzGetZipEntryFileName(entry);\n        int len = mzGetZipEntryUncompLen(entry);\n\n        // Don't validate: directories, the manifest, *.RSA, and *.SF.\n\n        if (entry == mfEntry) {\n            LOGV(\"Skipping manifest %.*s\\n\", fn.len, fn.str);\n        } else if (fn.len > 0 && fn.str[fn.len-1] == '/' && len == 0) {\n            LOGV(\"Skipping directory %.*s\\n\", fn.len, fn.str);\n        } else if (!strncasecmp(fn.str, \"META-INF/\", 9) && (\n                !strncasecmp(fn.str + fn.len - 4, \".RSA\", 4) ||\n                !strncasecmp(fn.str + fn.len - 3, \".SF\", 3))) {\n            LOGV(\"Skipping signature %.*s\\n\", fn.len, fn.str);\n        } else {\n            unverified[i] = true;\n            totalBytes += len;\n        }\n    }\n\n    unsigned doneBytes = 0;\n    char *line, *save, *name = NULL;\n    for (line = strtok_r(mfBuf, eol, &save); line != NULL;\n         line = strtok_r(NULL, eol, &save)) {\n        if (!strncasecmp(line, namePrefix, sizeof(namePrefix) - 1)) {\n            // \"Name:\" introducing a new stanza\n            if (name != NULL) {\n                LOGE(\"No digest:\\n  %s\\n\", name);\n                break;\n            }\n\n            name = strdup(line + sizeof(namePrefix) - 1);\n            if (name == NULL) {\n                LOGE(\"Can't copy filename in %s\\n\", line);\n                break;\n            }\n        } else if (!strncasecmp(line, contPrefix, sizeof(contPrefix) - 1)) {\n            // Continuing a long name (nothing else should be continued)\n            const char *tail = line + sizeof(contPrefix) - 1;\n            if (name == NULL) {\n                LOGE(\"Unexpected continuation:\\n  %s\\n\", tail);\n            }\n\n            char *concat;\n            if (asprintf(&concat, \"%s%s\", name, tail) < 0) {\n                LOGE(\"Can't append continuation %s\\n\", tail);\n                break;\n            }\n            free(name);\n            name = concat;\n        } else if (!strncasecmp(line, digestPrefix, sizeof(digestPrefix) - 1)) {\n            // \"Digest:\" supplying a hash code for the current stanza\n            const char *base64 = line + sizeof(digestPrefix) - 1;\n            if (name == NULL) {\n                LOGE(\"Unexpected digest:\\n  %s\\n\", base64);\n                break;\n            }\n\n            const ZipEntry *entry = mzFindZipEntry(pArchive, name);\n            if (entry == NULL) {\n                LOGE(\"Missing file:\\n  %s\\n\", name);\n                break;\n            }\n            if (!mzIsZipEntryIntact(pArchive, entry)) {\n                LOGE(\"Corrupt file:\\n  %s\\n\", name);\n                break;\n            }\n            if (!unverified[mzGetZipEntryIndex(pArchive, entry)]) {\n                LOGE(\"Unexpected file:\\n  %s\\n\", name);\n                break;\n            }\n\n            uint8_t expected[SHA_DIGEST_SIZE + 3], actual[SHA_DIGEST_SIZE];\n            int n = b64_pton(base64, expected, sizeof(expected));\n            if (n != SHA_DIGEST_SIZE) {\n                LOGE(\"Invalid base64:\\n  %s\\n  %s\\n\", name, base64);\n                break;\n            }\n\n            if (!digestEntry(pArchive, entry, &doneBytes, totalBytes, actual) ||\n                memcmp(expected, actual, SHA_DIGEST_SIZE) != 0) {\n                LOGE(\"Wrong digest:\\n  %s\\n\", name);\n                break;\n            }\n\n            LOGI(\"Verified %s\\n\", name);\n            unverified[mzGetZipEntryIndex(pArchive, entry)] = false;\n            free(name);\n            name = NULL;\n        }\n    }\n\n    if (name != NULL) free(name);\n    free(mfBuf);\n\n    for (i = 0; i < mzZipEntryCount(pArchive) && !unverified[i]; ++i) ;\n    free(unverified);\n\n    // This means we didn't get to the end of the manifest successfully.\n    if (line != NULL) return false;\n\n    if (i < mzZipEntryCount(pArchive)) {\n        const ZipEntry *entry = mzGetZipEntryAt(pArchive, i);\n        UnterminatedString fn = mzGetZipEntryFileName(entry);\n        LOGE(\"No digest for %.*s\\n\", fn.len, fn.str);\n        return false;\n    }\n\n    return true;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Close a ZipArchive, closing the file and freeing the contents.\n *\n * NOTE: the ZipArchive may not have been fully created.\n */\n", "func_signal": "void mzCloseZipArchive(ZipArchive* pArchive)", "code": "{\n    LOGV(\"Closing archive %p\\n\", pArchive);\n\n    if (pArchive->fd >= 0)\n        close(pArchive->fd);\n    if (pArchive->map.addr != NULL)\n        sysReleaseShmem(&pArchive->map);\n\n    free(pArchive->pEntries);\n\n    mzHashTableFree(pArchive->pHash);\n\n    pArchive->fd = -1;\n    pArchive->pHash = NULL;\n    pArchive->pEntries = NULL;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* Return an allocated buffer with the contents of a zip file entry. */\n", "func_signal": "static char *slurpEntry(const ZipArchive *pArchive, const ZipEntry *pEntry)", "code": "{\n    if (!mzIsZipEntryIntact(pArchive, pEntry)) {\n        UnterminatedString fn = mzGetZipEntryFileName(pEntry);\n        LOGE(\"Invalid %.*s\\n\", fn.len, fn.str);\n        return NULL;\n    }\n\n    int len = mzGetZipEntryUncompLen(pEntry);\n    char *buf = malloc(len + 1);\n    if (buf == NULL) {\n        UnterminatedString fn = mzGetZipEntryFileName(pEntry);\n        LOGE(\"Can't allocate %d bytes for %.*s\\n\", len, fn.len, fn.str);\n        return NULL;\n    }\n\n    if (!mzReadZipEntry(pArchive, pEntry, buf, len)) {\n        UnterminatedString fn = mzGetZipEntryFileName(pEntry);\n        LOGE(\"Can't read %.*s\\n\", fn.len, fn.str);\n        free(buf);\n        return NULL;\n    }\n\n    buf[len] = '\\0';\n    return buf;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Open a Zip archive and scan out the contents.\n *\n * The easiest way to do this is to mmap() the whole thing and do the\n * traditional backward scan for central directory.  Since the EOCD is\n * a relatively small bit at the end, we should end up only touching a\n * small set of pages.\n *\n * This will be called on non-Zip files, especially during startup, so\n * we don't want to be too noisy about failures.  (Do we want a \"quiet\"\n * flag?)\n *\n * On success, we fill out the contents of \"pArchive\".\n */\n", "func_signal": "int mzOpenZipArchive(const char* fileName, ZipArchive* pArchive)", "code": "{\n    MemMapping map;\n    int err;\n\n    LOGV(\"Opening archive '%s' %p\\n\", fileName, pArchive);\n\n    map.addr = NULL;\n    memset(pArchive, 0, sizeof(*pArchive));\n\n    pArchive->fd = open(fileName, O_RDONLY, 0);\n    if (pArchive->fd < 0) {\n        err = errno ? errno : -1;\n        LOGV(\"Unable to open '%s': %s\\n\", fileName, strerror(err));\n        goto bail;\n    }\n\n    if (sysMapFileInShmem(pArchive->fd, &map) != 0) {\n        err = -1;\n        LOGW(\"Map of '%s' failed\\n\", fileName);\n        goto bail;\n    }\n\n    if (map.length < ENDHDR) {\n        err = -1;\n        LOGV(\"File '%s' too small to be zip (%zd)\\n\", fileName, map.length);\n        goto bail;\n    }\n\n    if (!parseZipArchive(pArchive, &map)) {\n        err = -1;\n        LOGV(\"Parsing '%s' failed\\n\", fileName);\n        goto bail;\n    }\n\n    err = 0;\n    sysCopyMap(&pArchive->map, &map);\n    map.addr = NULL;\n\nbail:\n    if (err != 0)\n        mzCloseZipArchive(pArchive);\n    if (map.addr != NULL)\n        sysReleaseShmem(&map);\n    return err;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Stream the uncompressed data through the supplied function,\n * passing cookie to it each time it gets called.  processFunction\n * may be called more than once.\n *\n * If processFunction returns false, the operation is abandoned and\n * mzProcessZipEntryContents() immediately returns false.\n *\n * This is useful for calculating the hash of an entry's uncompressed contents.\n */\n", "func_signal": "bool mzProcessZipEntryContents(const ZipArchive *pArchive,\n    const ZipEntry *pEntry, ProcessZipEntryContentsFunction processFunction,\n    void *cookie)", "code": "{\n    bool ret = false;\n    off_t oldOff;\n\n    /* save current offset */\n    oldOff = lseek(pArchive->fd, 0, SEEK_CUR);\n\n    /* Seek to the beginning of the entry's compressed data. */\n    lseek(pArchive->fd, pEntry->offset, SEEK_SET);\n\n    switch (pEntry->compression) {\n    case STORED:\n        ret = processStoredEntry(pArchive, pEntry, processFunction, cookie);\n        break;\n    case DEFLATED:\n        ret = processDeflatedEntry(pArchive, pEntry, processFunction, cookie);\n        break;\n    default:\n        LOGE(\"Unsupported compression type %d for entry '%s'\\n\",\n                pEntry->compression, pEntry->fileName);\n        break;\n    }\n\n    /* restore file offset */\n    lseek(pArchive->fd, oldOff, SEEK_SET);\n    return ret;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n * Check the CRC on this entry; return true if it is correct.\n * May do other internal checks as well.\n */\n", "func_signal": "bool mzIsZipEntryIntact(const ZipArchive *pArchive, const ZipEntry *pEntry)", "code": "{\n    unsigned long crc;\n    bool ret;\n\n    crc = crc32(0L, Z_NULL, 0);\n    ret = mzProcessZipEntryContents(pArchive, pEntry, crcProcessFunction,\n            (void *)&crc);\n    if (!ret) {\n        LOGE(\"Can't calculate CRC for entry\\n\");\n        return false;\n    }\n    if (crc != (unsigned long)pEntry->crc32) {\n        LOGW(\"CRC for entry %.*s (0x%08lx) != expected (0x%08lx)\\n\",\n                pEntry->fileNameLen, pEntry->fileName, crc, pEntry->crc32);\n        return false;\n    }\n    return true;\n}", "path": "minzip\\Zip.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "/* mzProcessZipEntryContents callback to update an SHA-1 hash context. */\n", "func_signal": "static bool updateHash(const unsigned char *data, int dataLen, void *cookie)", "code": "{\n    struct DigestContext *context = (struct DigestContext *) cookie;\n    SHA_update(&context->digest, data, dataLen);\n    if (context->doneBytes != NULL) {\n        *context->doneBytes += dataLen;\n        if (context->totalBytes > 0) {\n            ui_set_progress(*context->doneBytes * 1.0 / context->totalBytes);\n        }\n    }\n    return true;\n}", "path": "verifier.c", "repo_name": "kruton/android_bootable_recovery", "stars": 4, "license": "None", "language": "c", "size": 368}
{"docstring": "//\n//\tDraw any buttons inserted into the horizontal scrollbar\n//\tassume that the button widths have already been calculated\n//\tNote: RECT *rect is the rectangle of the scrollbar\n//\t      leftright: 1 = left, 2 = right, 3 = both\n//\n", "func_signal": "static LRESULT DrawHorzButtons(SCROLLBAR *sbar, HDC hdc, const RECT *rect, int leftright)", "code": "{\n\tint i;\n\tint xposl, xposr;\n\tRECT ctrl;\n\tSCROLLBUT *sbut = sbar->sbButtons;\n\t\n\txposl = rect->left - sbar->nButSizeBefore;\n\txposr = rect->right;\n\t\n\tfor(i = 0; i < sbar->nButtons; i++)\n\t{\n\t\tif((leftright & SBBP_LEFT) && sbut[i].uPlacement == SBBP_LEFT)\n\t\t{\n\t\t\tint butwidth = GetSingleButSize(sbar, &sbut[i]);\n\t\t\tSetRect(&ctrl, xposl, rect->top, xposl + butwidth, rect->bottom);\n\t\t\tRotateRect0(sbar, &ctrl);\n\t\t\tDrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);\n\t\t\t\n\t\t\txposl += butwidth;\n\t\t}\n\n\t\tif((leftright & SBBP_RIGHT) && sbut[i].uPlacement == SBBP_RIGHT)\n\t\t{\n\t\t\tint butwidth = GetSingleButSize(sbar, &sbut[i]);\n\t\t\tSetRect(&ctrl, xposr, rect->top, xposr + butwidth, rect->bottom);\n\t\t\tRotateRect0(sbar, &ctrl);\n\t\t\tDrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);\n\t\t\txposr += butwidth;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tFind the size in pixels of all the inserted buttons,\n//\teither before or after the specified scrollbar\n//\n", "func_signal": "static int GetButtonSize(SCROLLBAR *sbar, HWND hwnd, UINT uBeforeAfter)", "code": "{\n\tint i;\n\tint nPixels = 0;\n\n\tSCROLLBUT *sbut = sbar->sbButtons;\n\t\n\tfor(i = 0; i < sbar->nButtons; i++)\n\t{\n\t\t//only consider those buttons on the same side as nTopBottom says\n\t\tif(sbut[i].uPlacement == uBeforeAfter)\n\t\t{\n\t\t\tnPixels += GetSingleButSize(sbar, &sbut[i]);\n\t\t}\n\t}\n\n\treturn nPixels;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tPaint a checkered rectangle, with each alternate\n//\tpixel being assigned a different colour\n//\n", "func_signal": "static void DrawCheckedRect(HDC hdc, RECT *rect, COLORREF fg, COLORREF bg)", "code": "{\n\tstatic WORD wCheckPat[8] = \n\t{ \n\t\t0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555 \n\t};\n\n\tHBITMAP hbmp;\n\tHBRUSH  hbr, hbrold;\n\tCOLORREF fgold, bgold;\n\n\thbmp = CreateBitmap(8, 8, 1, 1, wCheckPat);\n\thbr  = CreatePatternBrush(hbmp);\n\n\tUnrealizeObject(hbr);\n\tSetBrushOrgEx(hdc, rect->left, rect->top, 0);\n\n\thbrold = (HBRUSH)SelectObject(hdc, hbr);\n\n\tfgold = SetTextColor(hdc, fg);\n\tbgold = SetBkColor(hdc, bg);\n\t\n\tPatBlt(hdc, rect->left, rect->top, \n\t\t\t\trect->right - rect->left, \n\t\t\t\trect->bottom - rect->top, \n\t\t\t\tPATCOPY);\n\t\n\tSetBkColor(hdc, bgold);\n\tSetTextColor(hdc, fgold);\n\t\n\tSelectObject(hdc, hbrold);\n\tDeleteObject(hbr);\n\tDeleteObject(hbmp);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tDraw a simple blank scrollbar push-button. Can be used\n//\tto draw a push button, or the scrollbar thumb\n//\tdrawflag - could set to BF_FLAT to make flat scrollbars\n//\n", "func_signal": "void DrawBlankButton(HDC hdc, const RECT *rect, UINT drawflag)", "code": "{\n\tRECT rc = *rect;\n\t\t\n#ifndef FLAT_SCROLLBARS\t\n\tdrawflag &= ~BF_FLAT;\n#endif\n\t\n\tDrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | drawflag | BF_ADJUST);\n\tFillRect(hdc, &rc, GetSysColorBrush(COLOR_BTNFACE));\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tLeft button released\n//\n", "func_signal": "static LRESULT LButtonUp(SCROLLWND *sw, HWND hwnd, WPARAM wParam, LPARAM lParam)", "code": "{\n\tRECT rect;\n\t//UINT thisportion;\n\tHDC hdc;\n\tPOINT pt;\n\tRECT winrect;\n\tUINT buttonIdx = 0;\n\t\n\t//current scrollportion is the button that we clicked down on\n\tif(uCurrentScrollPortion != HTSCROLL_NONE)\n\t{\n\t\tSCROLLBAR *sb = &sw->sbarHorz;\n\t\tlParam = GetMessagePos();\n\t\tReleaseCapture();\n\n\t\tGetWindowRect(hwnd, &winrect);\n\t\tpt.x = LOWORD(lParam);\n\t\tpt.y = HIWORD(lParam);\n\n\t\t//emulate the mouse input on a scrollbar here...\n\t\tif(uCurrentScrollbar == SB_HORZ)\n\t\t{\n\t\t\t//get the total area of the normal Horz scrollbar area\n\t\t\tsb = &sw->sbarHorz;\n\t\t\tGetHScrollRect(sw, hwnd, &rect);\n\t\t}\n\t\telse if(uCurrentScrollbar == SB_VERT)\n\t\t{\n\t\t\t//get the total area of the normal Horz scrollbar area\n\t\t\tsb = &sw->sbarVert;\n\t\t\tGetVScrollRect(sw, hwnd, &rect);\n\t\t}\n\n\t\t//we need to do different things depending on if the\n\t\t//user is activating the scrollbar itself, or one of\n\t\t//the inserted buttons\n\t\tswitch(uCurrentScrollPortion)\n\t\t{\n#ifdef INCLUDE_BUTTONS\n\t\t//inserted buttons are being clicked\n\t\tcase HTSCROLL_INSERTED:\n\t\t\t\n\t\t\t//get the rectangle of the ACTIVE button \n\t\t\tbuttonIdx = GetButtonFromPt(sb, &rect, pt, FALSE);\n\t\t\tGetButtonRectFromId(sb, &rect, uCurrentButton);\n\t\n\t\t\tOffsetRect(&rect, -winrect.left, -winrect.top);\n\n\t\t\t//Send the notification BEFORE we redraw, so the\n\t\t\t//bitmap can be changed smoothly by the user if they require\n\t\t\tif(uCurrentButton == buttonIdx)\n\t\t\t{\n\t\t\t\tSCROLLBUT *sbut = &sb->sbButtons[buttonIdx];\n\t\t\t\tUINT cmdid = sbut->uCmdId;\n\t\t\t\t\n\t\t\t\tif((sbut->uButType & SBBT_MASK) == SBBT_TOGGLEBUTTON)\n\t\t\t\t\tsbut->uState ^= 1;\n\n\t\t\t\t//send a notify??\t\t\t\t\n\t\t\t\t//only post a message if the command id is valid\n\t\t\t\tif(cmdid != -1 && cmdid > 0)\n\t\t\t\t\tSendMessage(hwnd, WM_COMMAND, MAKEWPARAM(cmdid, CSBN_CLICKED), 0);\n\t\t\t\n\t\t\t\t//user might have deleted this button, so redraw whole area\n\t\t\t\tNCPaint(sw, hwnd, 1, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//otherwise, just redraw the button in its new state\n\t\t\t\thdc = GetWindowDC(hwnd);\n\t\t\t\tDrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_NORMAL);\n\t\t\t\tReleaseDC(hwnd, hdc);\n\t\t\t}\n\t\n\t\t\tbreak;\n#endif\t// INCLUDE_BUTTONS\n\n\t\t//The scrollbar is active\n\t\tcase HTSCROLL_LEFT:  case HTSCROLL_RIGHT: \n\t\tcase HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT: \n\t\tcase HTSCROLL_NONE:\n\t\t\t\n\t\t\tKillTimer(hwnd, uScrollTimerId);\n\n\t\tcase HTSCROLL_THUMB: \n\t\n\t\t\t//In case we were thumb tracking, make sure we stop NOW\n\t\t\tif(sw->fThumbTracking == TRUE)\n\t\t\t{\n\t\t\t\tSendScrollMessage(hwnd, uScrollTimerMsg, SB_THUMBPOSITION, nLastPos);\n\t\t\t\tsw->fThumbTracking = FALSE;\n\t\t\t}\n\n\t\t\t//send the SB_ENDSCROLL message now that scrolling has finished\n\t\t\tSendScrollMessage(hwnd, uScrollTimerMsg, SB_ENDSCROLL, 0);\n\n\t\t\t//adjust the total scroll area to become where the scrollbar\n\t\t\t//really is (take into account the inserted buttons)\n\t\t\tGetRealScrollRect(sb, &rect);\n\t\t\tOffsetRect(&rect, -winrect.left, -winrect.top);\n\t\t\thdc = GetWindowDC(hwnd);\n\t\t\t\n\t\t\t//draw whichever scrollbar sb is\n\t\t\tNCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NORMAL);\n\n\t\t\tReleaseDC(hwnd, hdc);\n\t\t\tbreak;\n\t\t}\n\n\t\t//reset our state to default\n\t\tuCurrentScrollPortion = HTSCROLL_NONE;\n\t\tuScrollTimerPortion\t  = HTSCROLL_NONE;\n\t\tuScrollTimerId\t\t  = 0;\n\n\t\tuScrollTimerMsg       = 0;\n\t\tuCurrentScrollbar     = COOLSB_NONE;\n\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t// Can't remember why I did this!\n\t\tif(GetCapture() == hwnd)\n\t\t{\n\t\t\tReleaseCapture();\n\t\t}*/\n\t}\n\n\treturn CallWindowProc(sw->oldproc, hwnd, WM_LBUTTONUP, wParam, lParam);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tInput: rectangle of the total scrollbar area\n//\tOutput: adjusted to take the inserted buttons into account\n//\n", "func_signal": "static void GetRealVertScrollRect(SCROLLBAR *sb, RECT *rect)", "code": "{\n\tif(sb->fButVisibleBefore) rect->top += sb->nButSizeBefore;\n\tif(sb->fButVisibleAfter)  rect->bottom -= sb->nButSizeAfter;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tSend the specified message to the tooltip control\n//\n", "func_signal": "static void __stdcall RelayMouseEvent(HWND hwnd, HWND hwndToolTip, UINT event)", "code": "{\n#ifdef COOLSB_TOOLTIPS\n\tMSG msg;\n\n\tCoolSB_ZeroMemory(&msg, sizeof(MSG));\n\tmsg.hwnd = hwnd;\n\tmsg.message = event;\n\n\tSendMessage(hwndToolTip, TTM_RELAYEVENT, 0, (LONG)&msg);\n#else\n\tUNREFERENCED_PARAMETER(hwnd);\n\tUNREFERENCED_PARAMETER(hwndToolTip);\n\tUNREFERENCED_PARAMETER(event);\n#endif\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\n", "func_signal": "static void RedrawNonClient(HWND hwnd, BOOL fFrameChanged)", "code": "{\n\tif(fFrameChanged == FALSE)\n\t{\n\t\t/*\n\t\tRECT rect;\n\t\tHRGN hrgn1, hrgn2;\n\t\t\n\t\tSCROLLWND *sw = GetScrollWndFromHwnd(hwnd);\n\t\t\n\t\tGetScrollRect(sw, SB_HORZ, hwnd, &rect);\n\t\thrgn1 = CreateRectRgnIndirect(&rect);\n\t\t\n\t\tGetScrollRect(sw, SB_VERT, hwnd, &rect);\n\t\thrgn2 = CreateRectRgnIndirect(&rect);\n\t\t\n\t\tCombineRgn(hrgn1, hrgn2, hrgn1, RGN_OR);\n\t\t\n\t\tSendMessage(hwnd, WM_NCPAINT, (WPARAM)hrgn1, 0);\n\t\t\n\t\tDeleteObject(hrgn1);\n\t\tDeleteObject(hrgn2);*/\n\n\t\tSendMessage(hwnd, WM_NCPAINT, (WPARAM)1, 0);\n\t}\n\telse\n\t{\n\t\tSetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE\n\t\t\t| SWP_FRAMECHANGED | SWP_DRAWFRAME);\n\t}\n}", "path": "coolsb\\coolsblib.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tModify the properties of the specified scrollbar button.\n//\twSBflags - SB_HORZ / SB_VERT only\n//\tuItem    - the command identifier specified when the button was created,\n//\t\t\t   or a non-negative position of the button, depending on if\n//\t\t\t   fByCmd is FALSE or TRUE, respectively\n//\n", "func_signal": "BOOL WINAPI CoolSB_ModifyButton (HWND hwnd, int wSBflags, UINT uItem, BOOL fByCmd, SCROLLBUT *psb)", "code": "{\n\tSCROLLBAR *sbar;\n\tSCROLLBUT *sbut;\n\n\tif(!psb) return FALSE;\n\n\t//find if this window is CoolScroll enabled\n\tif(!(sbar = GetScrollBarFromHwnd(hwnd, wSBflags)))\n\t\treturn FALSE;\n\n\t//find the button to modify, depending on if we\n\t//are modifying by position or command id\n\tif(fByCmd == FALSE)\n\t{\n\t\t//button from position\n\t\tif((int)uItem < 0 || (int)uItem >= (UINT)sbar->nButtons)\n\t\t\treturn FALSE;\n\t\telse\n\t\t\tsbut = &sbar->sbButtons[uItem];\n\t}\n\telse if(fByCmd == TRUE)\n\t{\n\t\t//button from command identifier\n\t\tif(!(sbut = GetButtonFromId(sbar, uItem)))\n\t\t\treturn FALSE;\n\t}\n\n\tif(psb->fMask & SBBF_TYPE)\t\t\tsbut->uButType   = psb->uButType;\n\tif(psb->fMask & SBBF_STATE)\t\t\tsbut->uState\t = psb->uState;\n\tif(psb->fMask & SBBF_ID)\t\t\tsbut->uCmdId     = psb->uCmdId;\n\tif(psb->fMask & SBBF_SIZE)\t\t\tsbut->nSize\t\t = psb->nSize;\n\tif(psb->fMask & SBBF_PLACEMENT)\t\tsbut->uPlacement = psb->uPlacement;\n\tif(psb->fMask & SBBF_BITMAP)\t\tsbut->hBmp\t\t = psb->hBmp;\n\tif(psb->fMask & SBBF_ENHMETAFILE)\tsbut->hEmf\t\t = psb->hEmf;\n\tif(psb->fMask & SBBF_CURSOR)\t\tsbut->hCurs\t\t = psb->hCurs;\n\t\n\tif(psb->fMask & SBBF_BUTMINMAX)\n\t{\n\t\tsbut->nMinSize = psb->nMinSize;\n\t\tsbut->nMaxSize = psb->nMaxSize;\n\t}\n\n\treturn TRUE;\n}", "path": "coolsb\\coolsblib.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//  CoolScrollbar subclass procedure.\n//\tHandle all messages needed to mimick normal windows scrollbars\n//\n", "func_signal": "LRESULT CALLBACK CoolSBWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)", "code": "{\n\tWNDPROC oldproc;\n\tSCROLLWND *swnd = GetScrollWndFromHwnd(hwnd);\n\tstatic int count;\n\n\tswitch(message)\n\t{\n\tcase WM_NCDESTROY:\n\t\t//this should NEVER be called, because the user\n\t\t//should have called Uninitialize() themselves.\n\n\t\t//However, if the user tries to call Uninitialize().. \n\t\t//after this window is destroyed, this window's entry in the lookup\n\t\t//table will not be there, and the call will fail\n\t\toldproc = swnd->oldproc;\n\t\tUninitializeCoolSB(hwnd);\n\t\t\n\t\t//we must call the original window procedure, otherwise it\n\t\t//will never get the WM_NCDESTROY message, and it wouldn't\n\t\t//be able to clean up etc.\n\t\treturn CallWindowProc(oldproc, hwnd, message, wParam, lParam);\n\n\tcase WM_NCCALCSIZE:\n\t\treturn NCCalcSize(swnd, hwnd, wParam, lParam);\n\n\tcase WM_NCPAINT:\n\t\treturn NCPaint(swnd, hwnd, wParam, lParam);\t\n\n\tcase WM_NCHITTEST:\n\t\treturn NCHitTest(swnd, hwnd, wParam, lParam);\n\n\tcase WM_NCRBUTTONDOWN: case WM_NCRBUTTONUP: \n\tcase WM_NCMBUTTONDOWN: case WM_NCMBUTTONUP: \n\t\tRelayMouseEvent(hwnd, swnd->hwndToolTip, (WM_MOUSEMOVE-WM_NCMOUSEMOVE) + (message));\n\t\tif(wParam == HTHSCROLL || wParam == HTVSCROLL) \n\t\t\treturn 0;\n\t\telse \n\t\t\tbreak;\n\n\tcase WM_NCLBUTTONDBLCLK:\n\t\t//TRACE(\"WM_NCLBUTTONDBLCLK %d\\n\", count++);\n\t\tif(wParam == HTHSCROLL || wParam == HTVSCROLL)\n\t\t\treturn NCLButtonDown(swnd, hwnd, wParam, lParam);\n\t\telse\n\t\t\tbreak;\n\n\tcase WM_NCLBUTTONDOWN:\n\t\t//TRACE(\"WM_NCLBUTTONDOWN%d\\n\", count++);\n\t\tRelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONDOWN);\n\t\treturn NCLButtonDown(swnd, hwnd, wParam, lParam);\n\n\n\tcase WM_LBUTTONUP:\n\t\t//TRACE(\"WM_LBUTTONUP %d\\n\", count++);\n\t\tRelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONUP);\n\t\treturn LButtonUp(swnd, hwnd, wParam, lParam);\n\n\tcase WM_NOTIFY:\n\t\treturn CoolSB_Notify(swnd, hwnd, wParam, lParam);\n\n\t//Mouse moves are received when we set the mouse capture,\n\t//even when the mouse moves over the non-client area\n\tcase WM_MOUSEMOVE: \n\t\t//TRACE(\"WM_MOUSEMOVE %d\\n\", count++);\n\t\treturn MouseMove(swnd, hwnd, wParam, lParam);\n\t\n\tcase WM_TIMER:\n\t\treturn CoolSB_Timer(swnd, hwnd, wParam, lParam);\n\n\t//case WM_STYLECHANGING:\n\t//\treturn CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGING, wParam, lParam);\n\tcase WM_STYLECHANGED:\n\n\t\tif(swnd->bPreventStyleChange)\n\t\t{\n\t\t\t// the NCPAINT handler has told us to eat this message!\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n            if (message == WM_STYLECHANGED) \n\t\t\t\treturn CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGED, wParam, lParam);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\tcase WM_NCMOUSEMOVE: \n\t\t{\n\t\t\tstatic LONG lastpos = -1;\n\n\t\t\t//TRACE(\"WM_NCMOUSEMOVE %d\\n\", count++);\n\n\t\t\t//The problem with NCMOUSEMOVE is that it is sent continuously\n\t\t\t//even when the mouse is stationary (under win2000 / win98)\n\t\t\t//\n\t\t\t//Tooltips don't like being sent a continous stream of mouse-moves\n\t\t\t//if the cursor isn't moving, because they will think that the mouse\n\t\t\t//is moving position, and the internal timer will never expire\n\t\t\t//\n\t\t\tif(lastpos != lParam)\n\t\t\t{\n\t\t\t\tRelayMouseEvent(hwnd, swnd->hwndToolTip, WM_MOUSEMOVE);\n\t\t\t\tlastpos = lParam;\n\t\t\t}\n\t\t}\n\n\t\treturn NCMouseMove(swnd, hwnd, wParam, lParam);\n\n\n\tcase WM_SETCURSOR:\n\t\treturn CoolSB_SetCursor(swnd, hwnd, wParam, lParam);\n\n\tcase WM_CAPTURECHANGED:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\t\n\treturn CallWindowProc(swnd->oldproc, hwnd, message, wParam, lParam);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n// Need to detect if we have clicked in the scrollbar region or not\n//\n", "func_signal": "static LRESULT NCHitTest(SCROLLWND *sw, HWND hwnd, WPARAM wParam, LPARAM lParam)", "code": "{\n\tRECT hrect;\n\tRECT vrect;\n\tPOINT pt;\n\n\tpt.x = LOWORD(lParam);\n\tpt.y = HIWORD(lParam);\n\t\n\t//work out exactly where the Horizontal and Vertical scrollbars are\n\tGetHScrollRect(sw, hwnd, &hrect);\n\tGetVScrollRect(sw, hwnd, &vrect);\n\t\n\t//Clicked in the horizontal scrollbar area\n\tif(sw->sbarHorz.fScrollVisible && PtInRect(&hrect, pt))\n\t{\n\t\treturn HTHSCROLL;\n\t}\n\t//Clicked in the vertical scrollbar area\n\telse if(sw->sbarVert.fScrollVisible && PtInRect(&vrect, pt))\n\t{\n\t\treturn HTVSCROLL;\n\t}\n\t//clicked somewhere else\n\telse\n\t{\n\t\treturn CallWindowProc(sw->oldproc, hwnd, WM_NCHITTEST, wParam, lParam);\n\t}\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tused for hot-tracking over the scroll buttons\n//\n", "func_signal": "static LRESULT NCMouseMove(SCROLLWND *sw, HWND hwnd, WPARAM wHitTest, LPARAM lParam)", "code": "{\n\t//install a timer for the mouse-over events, if the mouse moves\n\t//over one of the scrollbars\n#ifdef HOT_TRACKING\n\thwndCurCoolSB = hwnd;\n\tif(wHitTest == HTHSCROLL)\n\t{\n\t\tif(uMouseOverScrollbar == SB_HORZ)\n\t\t\treturn CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);\n\n\t\tuLastHitTestPortion = HTSCROLL_NONE;\n\t\tuHitTestPortion     = HTSCROLL_NONE;\n\t\tGetScrollRect(sw, SB_HORZ, hwnd, &MouseOverRect);\n\t\tuMouseOverScrollbar = SB_HORZ;\n\t\tuMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);\n\n\t\tNCPaint(sw, hwnd, 1, 0);\n\t}\n\telse if(wHitTest == HTVSCROLL)\n\t{\n\t\tif(uMouseOverScrollbar == SB_VERT)\n\t\t\treturn CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);\n\n\t\tuLastHitTestPortion = HTSCROLL_NONE;\n\t\tuHitTestPortion     = HTSCROLL_NONE;\n\t\tGetScrollRect(sw, SB_VERT, hwnd, &MouseOverRect);\n\t\tuMouseOverScrollbar = SB_VERT;\n\t\tuMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);\n\n\t\tNCPaint(sw, hwnd, 1, 0);\n\t}\n\n#endif //HOT_TRACKING\n\treturn CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tReturn the index of the button covering the specified point\n//\trect\t\t- rectangle of the whole scrollbar area\n//\tpt\t\t\t- screen coords of the mouse\n//\tfReturnRect - do/don't modify the rect to return the button's area\n//\n", "func_signal": "static UINT GetHorzButtonFromPt(SCROLLBAR *sb, RECT *rect, POINT pt, BOOL fReturnRect)", "code": "{\n\tint leftpos = rect->left, rightpos = rect->right;\n\tint i;\n\tint butwidth;\n\tSCROLLBUT *sbut = sb->sbButtons;\n\n\tif(!PtInRect(rect, pt))\n\t\treturn -1;\n\n\tif(sb->fButVisibleAfter)\n\t\trightpos -= sb->nButSizeAfter;\n\n\tfor(i = 0; i < sb->nButtons; i++)\n\t{\n\t\tif(sb->fButVisibleBefore && sbut[i].uPlacement == SBBP_LEFT)\n\t\t{\n\t\t\tbutwidth = GetSingleButSize(sb, &sbut[i]);\n\t\t\t\n\t\t\t//if the current button is under the specified point\n\t\t\tif(pt.x >= leftpos && pt.x < leftpos + butwidth)\n\t\t\t{\n\t\t\t\t//if the caller wants us to return the rectangle of the button\n\t\t\t\tif(fReturnRect)\n\t\t\t\t{\n\t\t\t\t\trect->left  = leftpos;\n\t\t\t\t\trect->right = leftpos + butwidth;\n\t\t\t\t}\n\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tleftpos += butwidth;\n\t\t}\n\t\telse if(sb->fButVisibleAfter && sbut[i].uPlacement == SBBP_RIGHT)\n\t\t{\n\t\t\tbutwidth = GetSingleButSize(sb, &sbut[i]);\n\n\t\t\t//if the current button is under the specified point\n\t\t\tif(pt.x >= rightpos && pt.x < rightpos + butwidth)\n\t\t\t{\n\t\t\t\t//if the caller wants us to return the rectangle of the button\n\t\t\t\tif(fReturnRect)\n\t\t\t\t{\n\t\t\t\t\trect->left  = rightpos;\n\t\t\t\t\trect->right = rightpos + butwidth;\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\trightpos += butwidth;\n\t\t}\n\t}\n\n\treturn -1;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\n//\n", "func_signal": "static UINT GetButtonFromPt(SCROLLBAR *sb, RECT *rect, POINT pt, BOOL fReturnRect)", "code": "{\n\tif(sb->nBarType == SB_HORZ)\n\t{\n\t\treturn GetHorzButtonFromPt(sb, rect, pt, fReturnRect);\n\t}\n\telse\n\t{\n\t\treturn GetVertButtonFromPt(sb, rect, pt, fReturnRect);\n\t}\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tWe must allocate from in the non-client area for our scrollbars\n//\tCall the default window procedure first, to get the borders (if any)\n//\tallocated some space, then allocate the space for the scrollbars\n//\tif they fit\n//\n", "func_signal": "static LRESULT NCCalcSize(SCROLLWND *sw, HWND hwnd, WPARAM wParam, LPARAM lParam)", "code": "{\n\tNCCALCSIZE_PARAMS *nccsp;\n\tRECT *rect;\n\tRECT oldrect;\n\tBOOL fCalcValidRects = (wParam == TRUE);\n\tSCROLLBAR *sb;\n\tUINT ret;\n\tDWORD dwStyle;\n\n\t//Regardless of the value of fCalcValidRects, the first rectangle \n\t//in the array specified by the rgrc structure member of the \n\t//NCCALCSIZE_PARAMS structure contains the coordinates of the window,\n\t//so we can use the exact same code to modify this rectangle, when\n\t//wParam is TRUE and when it is FALSE.\n\tnccsp = (NCCALCSIZE_PARAMS *)lParam;\n\trect = &nccsp->rgrc[0];\n\toldrect = *rect;\n\n\tdwStyle = GetWindowLong(hwnd, GWL_STYLE);\n\n\t// TURN OFF SCROLL-STYLES.\n    if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )\n    {\n        sw->bPreventStyleChange = TRUE;\n        SetWindowLong(hwnd, GWL_STYLE, dwStyle & ~(WS_VSCROLL|WS_HSCROLL));\n    }\n\t\n\t//call the default procedure to get the borders allocated\n\tret = CallWindowProc(sw->oldproc, hwnd, WM_NCCALCSIZE, wParam, lParam);\n\n\t// RESTORE PREVIOUS STYLES (if present at all)\n    if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )\n    {\n        sw->bPreventStyleChange = TRUE;\n        SetWindowLong(hwnd, GWL_STYLE, dwStyle);\n    }\n\n\t// calculate what the size of each window border is,\n\tsw->cxLeftEdge   = rect->left     - oldrect.left;\n\tsw->cxRightEdge  = oldrect.right  - rect->right;\n\tsw->cyTopEdge    = rect->top      - oldrect.top;\n\tsw->cyBottomEdge = oldrect.bottom - rect->bottom;\n\n\tsb = &sw->sbarHorz;\n\n\t//if there is room, allocate some space for the horizontal scrollbar\n\t//NOTE: Change the \">\" to a \">=\" to make the horz bar totally fill the\n\t//window before disappearing\n\tif((sb->fScrollFlags & CSBS_VISIBLE) && \n#ifdef COOLSB_FILLWINDOW\n\t\trect->bottom - rect->top >= GetScrollMetric(sb, SM_CYHORZSB))\n#else\n\t\trect->bottom - rect->top > GetScrollMetric(sb, SM_CYHORZSB))\n#endif\n\t{\n\t\trect->bottom -= GetScrollMetric(sb, SM_CYHORZSB);\n\t\tsb->fScrollVisible = TRUE;\n\t}\n\telse\n\t\tsb->fScrollVisible = FALSE;\n\n\tsb = &sw->sbarVert;\n\n\t//if there is room, allocate some space for the vertical scrollbar\n\tif((sb->fScrollFlags & CSBS_VISIBLE) && \n\t\trect->right - rect->left >= GetScrollMetric(sb, SM_CXVERTSB))\n\t{\n\t\tif(sw->fLeftScrollbar)\n\t\t\trect->left  += GetScrollMetric(sb, SM_CXVERTSB);\n\t\telse\n\t\t\trect->right -= GetScrollMetric(sb, SM_CXVERTSB);\n\n\t\tsb->fScrollVisible = TRUE;\n\t}\n\telse\n\t\tsb->fScrollVisible = FALSE;\n\n#ifdef INCLUDE_BUTTONS\n#ifdef RESIZABLE_BUTTONS\n\tResizeButtonsToFit(sw, &sw->sbarHorz, hwnd);\n\tResizeButtonsToFit(sw, &sw->sbarVert, hwnd);\n#endif\n#endif\n\n\t//don't return a value unless we actually modify the other rectangles\n\t//in the NCCALCSIZE_PARAMS structure. In this case, we return 0\n\t//no matter what the value of fCalcValidRects is\n\treturn ret;//FALSE;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tCalculate the screen coordinates of the area taken by the\n//  vertical scrollbar\n//\n", "func_signal": "static BOOL GetVScrollRect(SCROLLWND *sw, HWND hwnd, RECT *rect)", "code": "{\n\tGetWindowRect(hwnd, rect);\n\trect->top\t += sw->cyTopEdge;\t\t\t\t\t\t//top window edge\n\t\n\trect->bottom -= sw->cyBottomEdge + \n\t\t\t\t\t(sw->sbarHorz.fScrollVisible ?\t\t//bottom window edge\n\t\t\t\t\tGetScrollMetric(&sw->sbarHorz, SM_CYHORZSB) : 0);\n\n\tif(sw->fLeftScrollbar)\n\t{\n\t\trect->left\t+= sw->cxLeftEdge;\n\t\trect->right = rect->left + (sw->sbarVert.fScrollVisible ?\n\t\t\t\t\tGetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);\n\t}\n\telse\n\t{\n\t\trect->right  -= sw->cxRightEdge;\n\t\trect->left    = rect->right - (sw->sbarVert.fScrollVisible ?\t\n\t\t\t\t\tGetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);\n\t}\n\n\treturn TRUE;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tCUSTOM DRAW support\n//\t\n", "func_signal": "static LRESULT PostCustomPrePostPaint0(HWND hwnd, HDC hdc, SCROLLBAR *sb, UINT dwStage)", "code": "{\n#ifdef CUSTOM_DRAW\n\tNMCSBCUSTOMDRAW\tnmcd;\n\n\tCoolSB_ZeroMemory(&nmcd, sizeof nmcd);\n\tnmcd.hdr.hwndFrom = hwnd;\n\tnmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);\n\tnmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;\n\tnmcd.nBar\t\t  = sb->nBarType;\n\tnmcd.dwDrawStage  = dwStage;\n\tnmcd.hdc\t\t  = hdc;\n\n\thwnd = GetParent(hwnd);\n\treturn SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)&nmcd);\n#else\n\treturn 0;\n#endif\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n// Draw the specified metafile\n//\n", "func_signal": "static void DrawMetaFile(HDC hdc, HENHMETAFILE hemf, RECT *rect)", "code": "{\n\tRECT rc;\n\tPOINT pt;\n\n\tSetRect(&rc, 0, 0, rect->right-rect->left, rect->bottom-rect->top);\n\tSetWindowOrgEx(hdc, -rect->left, -rect->top, &pt);\n\tPlayEnhMetaFile(hdc, hemf, &rc);\n\tSetWindowOrgEx(hdc, pt.x, pt.y, 0);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tWe must intercept any calls to SetWindowLong, to check if\n//  left-scrollbars are taking effect or not\n//\n", "func_signal": "static LRESULT CoolSB_StyleChange(SCROLLWND *swnd, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)", "code": "{\n\tSTYLESTRUCT *ss = (STYLESTRUCT *)lParam;\n\n\tif(wParam == GWL_EXSTYLE)\n\t{\n\t\tif(ss->styleNew & WS_EX_LEFTSCROLLBAR)\n\t\t\tswnd->fLeftScrollbar = TRUE;\n\t\telse\n\t\t\tswnd->fLeftScrollbar = FALSE;\n\t}\n\n\treturn CallWindowProc(swnd->oldproc, hwnd, msg, wParam, lParam);\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "//\n//\tWork out the scrollbar width/height for either type of scrollbar (SB_HORZ/SB_VERT)\n//\trect - coords of the scrollbar.\n//\tstore results into *thumbsize and *thumbpos\n//\n", "func_signal": "static int CalcThumbSize(SCROLLBAR *sbar, const RECT *rect, int *pthumbsize, int *pthumbpos)", "code": "{\n\tSCROLLINFO *si;\n\tint scrollsize;\t\t\t//total size of the scrollbar including arrow buttons\n\tint workingsize;\t\t//working area (where the thumb can slide)\n\tint siMaxMin;\n\tint butsize;\n\tint startcoord;\n\tint thumbpos = 0, thumbsize = 0;\n\n\tint adjust=0;\n\tstatic int count=0;\n\n\t//work out the width (for a horizontal) or the height (for a vertical)\n\t//of a standard scrollbar button\n\tbutsize = GetScrollMetric(sbar, SM_SCROLL_LENGTH);\n\n\tif(1) //sbar->nBarType == SB_HORZ)\n\t{\n\t\tscrollsize = rect->right - rect->left;\n\t\tstartcoord = rect->left;\n\t}\n\t/*else if(sbar->nBarType == SB_VERT)\n\t{\n\t\tscrollsize = rect->bottom - rect->top;\n\t\tstartcoord = rect->top;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}*/\n\n\tsi = &sbar->scrollInfo;\n\tsiMaxMin = si->nMax - si->nMin + 1;\n\tworkingsize = scrollsize - butsize * 2;\n\n\t//\n\t// Work out the scrollbar thumb SIZE\n\t//\n\tif(si->nPage == 0)\n\t{\n\t\tthumbsize = butsize;\n\t}\n\telse if(siMaxMin > 0)\n\t{\n\t\tthumbsize = MulDiv(si->nPage, workingsize, siMaxMin);\n\n\t\tif(thumbsize < sbar->nMinThumbSize)\n\t\t\tthumbsize = sbar->nMinThumbSize;\n\t}\n\n\t//\n\t// Work out the scrollbar thumb position\n\t//\n\tif(siMaxMin > 0)\n\t{\n\t\tint pagesize = max(1, si->nPage);\n\t\tthumbpos = MulDiv(si->nPos - si->nMin, workingsize-thumbsize, siMaxMin - pagesize);\n\t\t\n\t\tif(thumbpos < 0)\t\t\t\t\t\t\n\t\t\tthumbpos = 0;\n\n\t\tif(thumbpos >= workingsize-thumbsize)\t\n\t\t\tthumbpos = workingsize-thumbsize;\n\t}\n\n\tthumbpos += startcoord + butsize;\n\n\t*pthumbpos  = thumbpos;\n\t*pthumbsize = thumbsize;\n\n\treturn 1;\n}", "path": "src\\coolsb\\coolscroll.c", "repo_name": "jsleroy/CoolSB", "stars": 5, "license": "None", "language": "c", "size": 153}
{"docstring": "/*\n *\tInitiate the EAP-GTC session by sending a challenge to the peer.\n */\n", "func_signal": "static int gtc_initiate(void *type_data, EAP_HANDLER *handler)", "code": "{\n\tint length;\n\tEAP_DS *eap_ds = handler->eap_ds;\n\trlm_eap_gtc_t *inst = (rlm_eap_gtc_t *) type_data;\n\n\t/*\n\t *\tFIXME: call radius_xlat on the challenge\n\t */\n\tlength = strlen(inst->challenge);\n\n\t/*\n\t *\tWe're sending a request...\n\t */\n\teap_ds->request->code = PW_EAP_REQUEST;\n\n\teap_ds->request->type.data = malloc(length);\n\tif (eap_ds->request->type.data == NULL) {\n\t\tradlog(L_ERR, \"rlm_eap_gtc: out of memory\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(eap_ds->request->type.data, inst->challenge, length);\n\teap_ds->request->type.length = length;\n\n\t/*\n\t *\tWe don't need to authorize the user at this point.\n\t *\n\t *\tWe also don't need to keep the challenge, as it's\n\t *\tstored in 'handler->eap_ds', which will be given back\n\t *\tto us...\n\t */\n\thandler->stage = AUTHENTICATE;\n\n\treturn 1;\n}", "path": "src\\modules\\rlm_eap\\types\\rlm_eap_gtc\\rlm_eap_gtc.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_affected_rows\n *\n *\tPurpose: End the select query, such as freeing memory or result\n *\n *************************************************************************/\n", "func_signal": "static int sql_affected_rows(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\n\treturn mysql_affected_rows(mysql_sock->sock);\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_finish_select_query\n *\n *\tPurpose: End the select query, such as freeing memory or result\n *\n *************************************************************************/\n", "func_signal": "static int sql_finish_select_query(SQLSOCK * sqlsocket, SQL_CONFIG *config)", "code": "{\n#if (MYSQL_VERSION_ID >= 40100)\n\tint status;\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n#endif\n\tsql_free_result(sqlsocket, config);\n#if (MYSQL_VERSION_ID >= 40100)\n\tstatus = mysql_next_result(mysql_sock->sock);\n\tif (status == 0) {\n\t\t/* there are more results */\n\t\tsql_finish_query(sqlsocket, config);\n\t}  else if (status > 0) {\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot get next result\");\n\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t       mysql_error(mysql_sock->sock));\n\t\treturn sql_check_error(status);\n\t}\n#endif\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_check_error\n *\n *\tPurpose: check the error to see if the server is down\n *\n *************************************************************************/\n", "func_signal": "static int sql_check_error(int error)", "code": "{\n\tswitch(error) {\n\tcase CR_SERVER_GONE_ERROR:\n\tcase CR_SERVER_LOST:\n\tcase -1:\n\t\tradlog(L_DBG, \"rlm_sql_mysql: MYSQL check_error: %d, returning SQL_DOWN\", error);\n\t\treturn SQL_DOWN;\n\t\tbreak;\n\tcase 0:\n\t\treturn 0;\n\t\tbreak;\n\tcase CR_OUT_OF_MEMORY:\n\tcase CR_COMMANDS_OUT_OF_SYNC:\n\tcase CR_UNKNOWN_ERROR:\n\tdefault:\n\t\tradlog(L_DBG, \"rlm_sql_mysql: MYSQL check_error: %d received\", error);\n\t\treturn -1;\n\t\tbreak;\n\t}\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tAttach the module.\n */\n", "func_signal": "static int gtc_attach(CONF_SECTION *cs, void **instance)", "code": "{\n\trlm_eap_gtc_t\t*inst;\n\tDICT_VALUE\t*dval;\n\n\tinst = malloc(sizeof(*inst));\n\tif (!inst) {\n\t\tradlog(L_ERR, \"rlm_eap_gtc: out of memory\");\n\t\treturn -1;\n\t}\n\tmemset(inst, 0, sizeof(*inst));\n\n\t/*\n\t *\tParse the configuration attributes.\n\t */\n\tif (cf_section_parse(cs, inst, module_config) < 0) {\n\t\tgtc_detach(inst);\n\t\treturn -1;\n\t}\n\n\tdval = dict_valbyname(PW_AUTH_TYPE, inst->auth_type_name);\n\tif (!dval) {\n\t\tradlog(L_ERR, \"rlm_eap_gtc: Unknown Auth-Type %s\",\n\t\t       inst->auth_type_name);\n\t\tgtc_detach(inst);\n\t\treturn -1;\n\t}\n\n\tinst->auth_type = dval->value;\n\n\t*instance = inst;\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_eap\\types\\rlm_eap_gtc\\rlm_eap_gtc.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_select_query\n *\n *\tPurpose: Issue a select query to the database\n *\n *************************************************************************/\n", "func_signal": "static int sql_select_query(SQLSOCK *sqlsocket, SQL_CONFIG *config,\n\t\t\t    char *querystr)", "code": "{\n\tint ret;\n\n\tret = sql_query(sqlsocket, config, querystr);\n\tif(ret)\n\t\treturn ret;\n\tret = sql_store_result(sqlsocket, config);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/* Why? Per http://www.mysql.com/doc/n/o/node_591.html,\n\t * this cannot return an error.  Perhaps just to complain if no\n\t * fields are found?\n\t */\n\tsql_num_fields(sqlsocket, config);\n\n\treturn ret;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tJust return the rcode ... this function is autz, auth, acct, and\n *\tpreacct!\n */\n", "func_signal": "static int always_return(void *instance, REQUEST *request)", "code": "{\n\t/* quiet the compiler */\n\trequest = request;\n\n\treturn ((struct rlm_always_t *)instance)->rcode;\n}", "path": "src\\modules\\rlm_always\\rlm_always.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_free_result\n *\n *\tPurpose: database specific free_result. Frees memory allocated\n *               for a result set\n *\n *************************************************************************/\n", "func_signal": "static int sql_free_result(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\n\tif (mysql_sock->result) {\n\t\tmysql_free_result(mysql_sock->result);\n\t\tmysql_sock->result = NULL;\n\t}\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tDetach the module.\n */\n", "func_signal": "static int gtc_detach(void *arg)", "code": "{\n\trlm_eap_gtc_t *inst = (rlm_eap_gtc_t *) arg;\n\n\n\tfree(inst);\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_eap\\types\\rlm_eap_gtc\\rlm_eap_gtc.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_destroy_socket\n *\n *\tPurpose: Free socket and any private connection data\n *\n *************************************************************************/\n", "func_signal": "static int sql_destroy_socket(SQLSOCK *sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\tfree(sqlsocket->conn);\n\tsqlsocket->conn = NULL;\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tAuthenticate a previously sent challenge.\n */\n", "func_signal": "static int gtc_authenticate(void *type_data, EAP_HANDLER *handler)", "code": "{\n\tVALUE_PAIR *vp;\n\tEAP_DS *eap_ds = handler->eap_ds;\n\trlm_eap_gtc_t *inst = (rlm_eap_gtc_t *) type_data;\n\n\t/*\n\t *\tGet the Cleartext-Password for this user.\n\t */\n\trad_assert(handler->request != NULL);\n\trad_assert(handler->stage == AUTHENTICATE);\n\n\t/*\n\t *\tSanity check the response.  We need at least one byte\n\t *\tof data.\n\t */\n\tif (eap_ds->response->length <= 4) {\n\t\tradlog(L_ERR, \"rlm_eap_gtc: corrupted data\");\n\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\treturn 0;\n\t}\n\n#if 0\n\tif ((debug_flag > 2) && fr_log_fp) {\n\t\tint i;\n\n\t\tfor (i = 0; i < eap_ds->response->length - 4; i++) {\n\t\t\tif ((i & 0x0f) == 0) fprintf(fr_log_fp, \"%d: \", i);\n\n\t\t\tfprintf(fr_log_fp, \"%02x \", eap_ds->response->type.data[i]);\n\n\t\t\tif ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");\n\t\t}\n\t}\n#endif\n\n\t/*\n\t *\tHandle passwords here.\n\t */\n\tif (inst->auth_type == PW_AUTHTYPE_LOCAL) {\n\t\t/*\n\t\t *\tFor now, do clear-text password authentication.\n\t\t */\n\t\tvp = pairfind(handler->request->config_items, PW_CLEARTEXT_PASSWORD);\n\t\tif (!vp) {\n\t\t\tDEBUG2(\"  rlm_eap_gtc: ERROR: Cleartext-Password is required for authentication.\");\n\t\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (eap_ds->response->type.length != vp->length) {\n\t\t\tDEBUG2(\"  rlm_eap_gtc: ERROR: Passwords are of different length. %d %d\", eap_ds->response->type.length, vp->length);\n\t\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (memcmp(eap_ds->response->type.data,\n\t\t\t   vp->vp_strvalue, vp->length) != 0) {\n\t\t\tDEBUG2(\"  rlm_eap_gtc: ERROR: Passwords are different\");\n\t\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t *\tEAP packets can be ~64k long maximum, and\n\t\t *\twe don't like that.\n\t\t */\n\t} else if (eap_ds->response->type.length <= 128) {\n\t\tint rcode;\n\n\t\t/*\n\t\t *\tIf there was a User-Password in the request,\n\t\t *\twhy the heck are they using EAP-GTC?\n\t\t */\n\t\tpairdelete(&handler->request->packet->vps, PW_USER_PASSWORD);\n\n\t\tvp = pairmake(\"User-Password\", \"\", T_OP_EQ);\n\t\tif (!vp) {\n\t\t\tradlog(L_ERR, \"rlm_eap_gtc: out of memory\");\n\t\t\treturn 0;\n\t\t}\n\t\tvp->length = eap_ds->response->type.length;\n\t\tmemcpy(vp->vp_strvalue, eap_ds->response->type.data, vp->length);\n\t\tvp->vp_strvalue[vp->length] = 0;\n\n\t\t/*\n\t\t *\tAdd the password to the request, and allow\n\t\t *\tanother module to do the work of authenticating it.\n\t\t */\n\t\tpairadd(&handler->request->packet->vps, vp);\n\t\thandler->request->password = vp;\n\n\t\t/*\n\t\t *\tThis is a wild & crazy hack.\n\t\t */\n\t\trcode = module_authenticate(inst->auth_type, handler->request);\n\t\tif (rcode != RLM_MODULE_OK) {\n\t\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\t\treturn 0;\n\t\t}\n\n\t} else {\n\t\tradlog(L_ERR, \"rlm_eap_gtc: Response is too large to understand\");\n\t\teap_ds->request->code = PW_EAP_FAILURE;\n\t\treturn 0;\n\n\t}\n\n\tDEBUG2(\"  rlm_eap_gtc: Everything is OK.\");\n\n\teap_ds->request->code = PW_EAP_SUCCESS;\n\n\treturn 1;\n}", "path": "src\\modules\\rlm_eap\\types\\rlm_eap_gtc\\rlm_eap_gtc.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_finish_query\n *\n *\tPurpose: As a single SQL statement may return multiple results\n *\tsets, (for example stored procedures) it is necessary to check\n *\twhether more results exist and process them in turn if so.\n *\n *************************************************************************/\n", "func_signal": "static int sql_finish_query(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n#if (MYSQL_VERSION_ID >= 40100)\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\tint status;\n\nskip_next_result:\n\tstatus = sql_store_result(sqlsocket, config);\n\tif (status != 0) {\n\t\treturn status;\n\t} else if (mysql_sock->result != NULL) {\n\t\tradlog(L_DBG, \"rlm_sql_mysql: SQL statement returned unexpected result\");\n\t\tsql_free_result(sqlsocket, config);\n\t}\n\tstatus = mysql_next_result(mysql_sock->sock);\n\tif (status == 0) {\n\t\t/* there are more results */\n\t\tgoto skip_next_result;\n\t}  else if (status > 0) {\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot get next result\");\n\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t       mysql_error(mysql_sock->sock));\n\t\treturn sql_check_error(status);\n\t}\n#endif\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_create_socket\n *\n *\tPurpose: Establish connection to the db\n *\n *************************************************************************/\n", "func_signal": "static int sql_init_socket(SQLSOCK *sqlsocket, SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock;\n\tunsigned long sql_flags;\n\n\tif (!sqlsocket->conn) {\n\t\tsqlsocket->conn = (rlm_sql_mysql_sock *)rad_malloc(sizeof(rlm_sql_mysql_sock));\n\t\tif (!sqlsocket->conn) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tmysql_sock = sqlsocket->conn;\n\tmemset(mysql_sock, 0, sizeof(*mysql_sock));\n\n\tradlog(L_INFO, \"rlm_sql_mysql: Starting connect to MySQL server for #%d\",\n\t\t\tsqlsocket->id);\n\n\tmysql_init(&(mysql_sock->conn));\n\tmysql_options(&(mysql_sock->conn), MYSQL_READ_DEFAULT_GROUP, \"freeradius\");\n#if (MYSQL_VERSION_ID >= 40100)\n\tsql_flags = CLIENT_MULTI_RESULTS | CLIENT_FOUND_ROWS;\n#else\n\tsql_flags = CLIENT_FOUND_ROWS;\n#endif\n\tif (!(mysql_sock->sock = mysql_real_connect(&(mysql_sock->conn),\n\t\t\t\t\t\t    config->sql_server,\n\t\t\t\t\t\t    config->sql_login,\n\t\t\t\t\t\t    config->sql_password,\n\t\t\t\t\t\t    config->sql_db,\n\t\t\t\t\t\t    atoi(config->sql_port),\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    sql_flags))) {\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Couldn't connect socket to MySQL server %s@%s:%s\", config->sql_login, config->sql_server, config->sql_db);\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Mysql error '%s'\", mysql_error(&mysql_sock->conn));\n\t\tmysql_sock->sock = NULL;\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tchecksimul fakes some other variables besides the rcode...\n */\n", "func_signal": "static int always_checksimul(void *instance, REQUEST *request)", "code": "{\n\tstruct rlm_always_t *inst = instance;\n\n\trequest->simul_count = inst->simulcount;\n\n\tif (inst->mpp)\n\t\trequest->simul_mpp = 2;\n\n\treturn inst->rcode;\n}", "path": "src\\modules\\rlm_always\\rlm_always.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_fetch_row\n *\n *\tPurpose: database specific fetch_row. Returns a SQL_ROW struct\n *               with all the data for the query in 'sqlsocket->row'. Returns\n *\t\t 0 on success, -1 on failure, SQL_DOWN if database is down.\n *\n *************************************************************************/\n", "func_signal": "static int sql_fetch_row(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\tint status;\n\n\t/*\n\t *  Check pointer before de-referencing it.\n\t */\n\tif (!mysql_sock->result) {\n\t\treturn SQL_DOWN;\n\t}\n\nretry_fetch_row:\n\tsqlsocket->row = mysql_fetch_row(mysql_sock->result);\n\n\tif (sqlsocket->row == NULL) {\n\t\tstatus = sql_check_error(mysql_errno(mysql_sock->sock));\n\t\tif (status != 0) {\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot fetch row\");\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t\t       mysql_error(mysql_sock->sock));\n\t\t\treturn status;\n\t\t}\n#if (MYSQL_VERSION_ID >= 40100)\n\t\tsql_free_result(sqlsocket, config);\n\t\tstatus = mysql_next_result(mysql_sock->sock);\n\t\tif (status == 0) {\n\t\t\t/* there are more results */\n\t\t\tif ((sql_store_result(sqlsocket, config) == 0)\n\t\t\t && (mysql_sock->result != NULL))\n\t\t\t\tgoto retry_fetch_row;\n\t\t} else if (status > 0) {\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot get next result\");\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t\t       mysql_error(mysql_sock->sock));\n\t\t\treturn sql_check_error(status);\n\t\t}\n#endif\n\t}\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_error\n *\n *\tPurpose: database specific error. Returns error associated with\n *               connection\n *\n *************************************************************************/\n", "func_signal": "static const char *sql_error(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\n\tif (mysql_sock == NULL || mysql_sock->sock == NULL) {\n\t\treturn \"rlm_sql_mysql: no connection to db\";\n\t}\n\treturn mysql_error(mysql_sock->sock);\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_query\n *\n *\tPurpose: Issue a query to the database\n *\n *************************************************************************/\n", "func_signal": "static int sql_query(SQLSOCK * sqlsocket, SQL_CONFIG *config, char *querystr)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\n\tif (config->sqltrace)\n\t\tradlog(L_DBG,\"rlm_sql_mysql: query:  %s\", querystr);\n\tif (mysql_sock->sock == NULL) {\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Socket not connected\");\n\t\treturn SQL_DOWN;\n\t}\n\n\tmysql_query(mysql_sock->sock, querystr);\n\treturn sql_check_error(mysql_errno(mysql_sock->sock));\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_store_result\n *\n *\tPurpose: database specific store_result function. Returns a result\n *               set for the query. In case of multiple results, get the\n *               first non-empty one.\n *\n *************************************************************************/\n", "func_signal": "static int sql_store_result(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\tint status;\n\n\tif (mysql_sock->sock == NULL) {\n\t\tradlog(L_ERR, \"rlm_sql_mysql: Socket not connected\");\n\t\treturn SQL_DOWN;\n\t}\nretry_store_result:\n\tif (!(mysql_sock->result = mysql_store_result(mysql_sock->sock))) {\n\t\tstatus = sql_check_error(mysql_errno(mysql_sock->sock));\n\t\tif (status != 0) {\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot store result\");\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t\t       mysql_error(mysql_sock->sock));\n\t\t\treturn status;\n\t\t}\n#if (MYSQL_VERSION_ID >= 40100)\n\t\tstatus = mysql_next_result(mysql_sock->sock);\n\t\tif (status == 0) {\n\t\t\t/* there are more results */\n\t\t\tgoto retry_store_result;\n\t\t} else if (status > 0) {\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: Cannot get next result\");\n\t\t\tradlog(L_ERR, \"rlm_sql_mysql: MySQL error '%s'\",\n\t\t\t       mysql_error(mysql_sock->sock));\n\t\t\treturn sql_check_error(status);\n\t\t}\n#endif\n\t}\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*\n *\tPerform all of the wondrous variants of digest authentication.\n */\n", "func_signal": "static int digest_authenticate(void *instance, REQUEST *request)", "code": "{\n\tint i;\n\tsize_t a1_len, a2_len, kd_len;\n\tuint8_t a1[(MAX_STRING_LEN + 1) * 5]; /* can be 5 attributes */\n\tuint8_t a2[(MAX_STRING_LEN + 1) * 3]; /* can be 3 attributes */\n\tuint8_t kd[(MAX_STRING_LEN + 1) * 5];\n\tuint8_t hash[16];\t/* MD5 output */\n\tVALUE_PAIR *vp, *passwd, *algo;\n\tVALUE_PAIR *qop, *nonce;\n\n\tinstance = instance;\t/* -Wunused */\n\n\t/*\n\t *\tWe require access to the plain-text password.\n\t */\n\tpasswd = pairfind(request->config_items, PW_DIGEST_HA1);\n\tif (passwd) {\n\t\tif (passwd->length != 32) {\n\t\t\tradlog_request(L_AUTH, 0, request, \"Digest-HA1 has invalid length, authentication failed.\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\t} else {\n\t\tpasswd = pairfind(request->config_items, PW_CLEARTEXT_PASSWORD);\n\t}\n\tif (!passwd) {\n\t\tradlog_request(L_AUTH, 0, request, \"Cleartext-Password or Digest-HA1 is required for authentication.\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\t/*\n\t *\tWe need these, too.\n\t */\n\tvp = pairfind(request->packet->vps, PW_DIGEST_ATTRIBUTES);\n\tif (vp == NULL) {\n\t\tRDEBUG(\"ERROR: You set 'Auth-Type = Digest' for a request that did not contain any digest attributes!\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\t/*\n\t *\tLoop through the Digest-Attributes, sanity checking them.\n\t */\n\tRDEBUG(\"    rlm_digest: Converting Digest-Attributes to something sane...\");\n\twhile (vp) {\n\t\tint length = vp->length;\n\t\tint attrlen;\n\t\tuint8_t *p = &vp->vp_octets[0];\n\t\tVALUE_PAIR *sub;\n\n\t\t/*\n\t\t *\tUntil this stupidly encoded attribure is exhausted.\n\t\t */\n\t\twhile (length > 0) {\n\t\t\t/*\n\t\t\t *\tThe attribute type must be valid\n\t\t\t */\n\t\t\tif ((p[0] == 0) || (p[0] > 10)) {\n\t\t\t\tRDEBUG(\"ERROR: Received Digest-Attributes with invalid sub-attribute %d\", p[0]);\n\t\t\t\treturn RLM_MODULE_INVALID;\n\t\t\t}\n\n\t\t\tattrlen = p[1];\t/* stupid VSA format */\n\n\t\t\t/*\n\t\t\t *\tToo short.\n\t\t\t */\n\t\t\tif (attrlen < 3) {\n\t\t\t\tRDEBUG(\"ERROR: Received Digest-Attributes with short sub-attribute %d, of length %d\", p[0], attrlen);\n\t\t\t\treturn RLM_MODULE_INVALID;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tToo long.\n\t\t\t */\n\t\t\tif (attrlen > length) {\n\t\t\t\tRDEBUG(\"ERROR: Received Digest-Attributes with long sub-attribute %d, of length %d\", p[0], attrlen);\n\t\t\t\treturn RLM_MODULE_INVALID;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tCreate a new attribute, broken out of\n\t\t\t *\tthe stupid sub-attribute crap.\n\t\t\t *\n\t\t\t *\tDidn't they know that VSA's exist?\n\t\t\t */\n\t\t\tsub = radius_paircreate(request, &request->packet->vps,\n\t\t\t\t\t\tPW_DIGEST_REALM - 1 + p[0],\n\t\t\t\t\t\tPW_TYPE_STRING);\n\t\t\tmemcpy(&sub->vp_octets[0], &p[2], attrlen - 2);\n\t\t\tsub->vp_octets[attrlen - 2] = '\\0';\n\t\t\tsub->length = attrlen - 2;\n\n\t\t\tif ((debug_flag > 1) && fr_log_fp) {\n\t\t\t  fputc('\\t', fr_log_fp);\n\t\t\t  vp_print(fr_log_fp, sub);\n\t\t\t  fputc('\\n', fr_log_fp);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tFIXME: Check for the existence\n\t\t\t *\tof the necessary attributes!\n\t\t\t */\n\n\t\t\tlength -= attrlen;\n\t\t\tp += attrlen;\n\t\t} /* loop over this one attribute */\n\n\t\t/*\n\t\t *\tFind the next one, if it exists.\n\t\t */\n\t\tvp = pairfind(vp->next, PW_DIGEST_ATTRIBUTES);\n\t}\n\n\t/*\n\t *\tWe require access to the Digest-Nonce-Value\n\t */\n\tnonce = pairfind(request->packet->vps, PW_DIGEST_NONCE);\n\tif (!nonce) {\n\t\tRDEBUG(\"ERROR: No Digest-Nonce: Cannot perform Digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\t/*\n\t *\tA1 = Digest-User-Name \":\" Realm \":\" Password\n\t */\n\tvp = pairfind(request->packet->vps, PW_DIGEST_USER_NAME);\n\tif (!vp) {\n\t\tRDEBUG(\"ERROR: No Digest-User-Name: Cannot perform Digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\tmemcpy(&a1[0], &vp->vp_octets[0], vp->length);\n\ta1_len = vp->length;\n\n\ta1[a1_len] = ':';\n\ta1_len++;\n\n\tvp = pairfind(request->packet->vps, PW_DIGEST_REALM);\n\tif (!vp) {\n\t\tRDEBUG(\"ERROR: No Digest-Realm: Cannot perform Digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\tmemcpy(&a1[a1_len], &vp->vp_octets[0], vp->length);\n\ta1_len += vp->length;\n\n\ta1[a1_len] = ':';\n\ta1_len++;\n\n\tif (passwd->attribute == PW_CLEARTEXT_PASSWORD) {\n\t\tmemcpy(&a1[a1_len], &passwd->vp_octets[0], passwd->length);\n\t\ta1_len += passwd->length;\n\t\ta1[a1_len] = '\\0';\n\t\tRDEBUG2(\"A1 = %s\", a1);\n\t} else {\n\t\ta1[a1_len] = '\\0';\n\t\tRDEBUG2(\"A1 = %s (using Digest-HA1)\", a1);\n\t\ta1_len = 16;\n\t}\n\n\t/*\n\t *\tSee which variant we calculate.\n\t *\tAssume MD5 if no Digest-Algorithm attribute received\n\t */\n\talgo = pairfind(request->packet->vps, PW_DIGEST_ALGORITHM);\n\tif ((algo == NULL) ||\n\t    (strcasecmp(algo->vp_strvalue, \"MD5\") == 0)) {\n\t\t/*\n\t\t *\tSet A1 to Digest-HA1 if no User-Password found\n\t\t */\n\t\tif (passwd->attribute == PW_DIGEST_HA1) {\n\t\t\tif (fr_hex2bin(passwd->vp_strvalue, &a1[0], 16) != 16) {\n\t\t\t\tRDEBUG2(\"Invalid text in Digest-HA1\");\n\t\t\t\treturn RLM_MODULE_INVALID;\n\t\t\t}\n\t\t}\n\n\t} else if (strcasecmp(algo->vp_strvalue, \"MD5-sess\") == 0) {\n\t\t/*\n\t\t *\tK1 = H(A1) : Digest-Nonce ... : H(A2)\n\t\t *\n\t\t *\tIf we find Digest-HA1, we assume it contains\n\t\t *\tH(A1).\n\t\t */\n\t\tif (passwd->attribute == PW_CLEARTEXT_PASSWORD) {\n\t\t\tfr_md5_calc(hash, &a1[0], a1_len);\n\t\t\tfr_bin2hex(hash, (char *) &a1[0], 16);\n\t\t} else {\t/* MUST be Digest-HA1 */\n\t\t\tmemcpy(&a1[0], passwd->vp_strvalue, 32);\n\t\t}\n\t\ta1_len = 32;\n\n\t\ta1[a1_len] = ':';\n\t\ta1_len++;\n\n\t\t/*\n\t\t *\tTack on the Digest-Nonce. Length must be even\n\t\t */\n\t\tif ((nonce->length & 1) != 0) {\n\t\t\tRDEBUG(\"ERROR: Received Digest-Nonce hex string with invalid length: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\t\tmemcpy(&a1[a1_len], &nonce->vp_octets[0], nonce->length);\n\t\ta1_len += nonce->length;\n\n\t\ta1[a1_len] = ':';\n\t\ta1_len++;\n\n\t\tvp = pairfind(request->packet->vps, PW_DIGEST_CNONCE);\n\t\tif (!vp) {\n\t\t\tRDEBUG(\"ERROR: No Digest-CNonce: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\n\t\t/*\n\t\t *      Digest-CNonce length must be even\n\t\t */\n\t\tif ((vp->length & 1) != 0) {\n\t\t\tRDEBUG(\"ERROR: Received Digest-CNonce hex string with invalid length: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\t\tmemcpy(&a1[a1_len], &vp->vp_octets[0], vp->length);\n\t\ta1_len += vp->length;\n\n\t} else if ((algo != NULL) &&\n\t\t   (strcasecmp(algo->vp_strvalue, \"MD5\") != 0)) {\n\t\t/*\n\t\t *\tWe check for \"MD5-sess\" and \"MD5\".\n\t\t *\tAnything else is an error.\n\t\t */\n\t\tRDEBUG(\"ERROR: Unknown Digest-Algorithm \\\"%s\\\": Cannot perform Digest authentication\", vp->vp_strvalue);\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\t/*\n\t *\tA2 = Digest-Method \":\" Digest-URI\n\t */\n\tvp = pairfind(request->packet->vps, PW_DIGEST_METHOD);\n\tif (!vp) {\n\t\tRDEBUG(\"ERROR: No Digest-Method: Cannot perform Digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\tmemcpy(&a2[0], &vp->vp_octets[0], vp->length);\n\ta2_len = vp->length;\n\n\ta2[a2_len] = ':';\n\ta2_len++;\n\n\tvp = pairfind(request->packet->vps, PW_DIGEST_URI);\n\tif (!vp) {\n\t\tRDEBUG(\"ERROR: No Digest-URI: Cannot perform Digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\tmemcpy(&a2[a2_len], &vp->vp_octets[0], vp->length);\n\ta2_len += vp->length;\n\n\t/*\n\t *  QOP is \"auth-int\", tack on \": Digest-Body-Digest\"\n\t */\n\tqop = pairfind(request->packet->vps, PW_DIGEST_QOP);\n\tif ((qop != NULL) &&\n\t    (strcasecmp(qop->vp_strvalue, \"auth-int\") == 0)) {\n\t\tVALUE_PAIR *body;\n\n\t\t/*\n\t\t *\tAdd in Digest-Body-Digest\n\t\t */\n\t\ta2[a2_len] = ':';\n\t\ta2_len++;\n\n\t\t/*\n\t\t *  Must be a hex representation of an MD5 digest.\n\t\t */\n\t\tbody = pairfind(request->packet->vps, PW_DIGEST_BODY_DIGEST);\n\t\tif (!body) {\n\t\t\tRDEBUG(\"ERROR: No Digest-Body-Digest: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\n\t\tif ((a2_len + body->length) > sizeof(a2)) {\n\t\t\tRDEBUG(\"ERROR: Digest-Body-Digest is too long\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\n\t\tmemcpy(a2 + a2_len, body->vp_octets, body->length);\n\t\ta2_len += body->length;\n\n\t} else if ((qop != NULL) &&\n\t\t   (strcasecmp(qop->vp_strvalue, \"auth\") != 0)) {\n\t\tRDEBUG(\"ERROR: Unknown Digest-QOP \\\"%s\\\": Cannot perform Digest authentication\", qop->vp_strvalue);\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\ta2[a2_len] = '\\0';\n\tRDEBUG2(\"A2 = %s\", a2);\n\n\t/*\n\t *     KD = H(A1) : Digest-Nonce ... : H(A2).\n\t *     Compute MD5 if Digest-Algorithm == \"MD5-Sess\",\n\t *     or if we found a User-Password.\n\t */\n\tif (((algo != NULL) &&\n\t     (strcasecmp(algo->vp_strvalue, \"MD5-Sess\") == 0)) ||\n\t    (passwd->attribute == PW_CLEARTEXT_PASSWORD)) {\n\t\ta1[a1_len] = '\\0';\n\t\tfr_md5_calc(&hash[0], &a1[0], a1_len);\n\t} else {\n\t\tmemcpy(&hash[0], &a1[0], a1_len);\n\t}\n\tfr_bin2hex(hash, (char *) kd, sizeof(hash));\n\n#ifndef NRDEBUG\n\tif (debug_flag > 1) {\n\t\tfr_printf_log(\"H(A1) = \");\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tfr_printf_log(\"%02x\", hash[i]);\n\t\t}\n\t\tfr_printf_log(\"\\n\");\n\t}\n#endif\n\tkd_len = 32;\n\n\tkd[kd_len] = ':';\n\tkd_len++;\n\n\tmemcpy(&kd[kd_len], nonce->vp_octets, nonce->length);\n\tkd_len += nonce->length;\n\n\t/*\n\t *\tNo QOP defined.  Do RFC 2069 compatibility.\n\t */\n\tif (!qop) {\n\t\t/*\n\t\t *\tDo nothing here.\n\t\t */\n\n\t} else {\t\t/* Digest-QOP MUST be \"auth\" or \"auth-int\" */\n\t\t/*\n\t\t *\tTack on \":\" Digest-Nonce-Count \":\" Digest-CNonce\n\t\t *\t       \":\" Digest-QOP\n\t\t */\n\t\tkd[kd_len] = ':';\n\t\tkd_len++;\n\n\t\tvp = pairfind(request->packet->vps, PW_DIGEST_NONCE_COUNT);\n\t\tif (!vp) {\n\t\t\tRDEBUG(\"ERROR: No Digest-Nonce-Count: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\t\tmemcpy(&kd[kd_len], &vp->vp_octets[0], vp->length);\n\t\tkd_len += vp->length;\n\n\t\tkd[kd_len] = ':';\n\t\tkd_len++;\n\n\t\tvp = pairfind(request->packet->vps, PW_DIGEST_CNONCE);\n\t\tif (!vp) {\n\t\t\tRDEBUG(\"ERROR: No Digest-CNonce: Cannot perform Digest authentication\");\n\t\t\treturn RLM_MODULE_INVALID;\n\t\t}\n\t\tmemcpy(&kd[kd_len], &vp->vp_octets[0], vp->length);\n\t\tkd_len += vp->length;\n\n\t\tkd[kd_len] = ':';\n\t\tkd_len++;\n\n\t\tmemcpy(&kd[kd_len], &qop->vp_octets[0], qop->length);\n\t\tkd_len += qop->length;\n\t}\n\n\t/*\n\t *\tTack on \":\" H(A2)\n\t */\n\tkd[kd_len] = ':';\n\tkd_len++;\n\n\tfr_md5_calc(&hash[0], &a2[0], a2_len);\n\n\tfr_bin2hex(hash, (char *) kd + kd_len, sizeof(hash));\n\n#ifndef NRDEBUG\n\tif (debug_flag > 1) {\n\t\tfr_printf_log(\"H(A2) = \");\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tfr_printf_log(\"%02x\", hash[i]);\n\t\t}\n\t\tfr_printf_log(\"\\n\");\n\t}\n#endif\n\tkd_len += 32;\n\n\tkd[kd_len] = 0;\n\n\tRDEBUG2(\"KD = %s\\n\", &kd[0]);\n\n\t/*\n\t *\tTake the hash of KD.\n\t */\n\tfr_md5_calc(&hash[0], &kd[0], kd_len);\n\tmemcpy(&kd[0], &hash[0], 16);\n\n\t/*\n\t *\tGet the binary value of Digest-Response\n\t */\n\tvp = pairfind(request->packet->vps, PW_DIGEST_RESPONSE);\n\tif (!vp) {\n\t\tRDEBUG(\"ERROR: No Digest-Response attribute in the request.  Cannot perform digest authentication\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n\tif (fr_hex2bin(&vp->vp_strvalue[0], &hash[0], vp->length >> 1) != (vp->length >> 1)) {\n\t\tRDEBUG2(\"Invalid text in Digest-Response\");\n\t\treturn RLM_MODULE_INVALID;\n\t}\n\n#ifndef NRDEBUG\n\tif (debug_flag > 1) {\n\t\tfr_printf_log(\"EXPECTED \");\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tfr_printf_log(\"%02x\", kd[i]);\n\t\t}\n\t\tfr_printf_log(\"\\n\");\n\n\t\tfr_printf_log(\"RECEIVED \");\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tfr_printf_log(\"%02x\", hash[i]);\n\t\t}\n\t\tfr_printf_log(\"\\n\");\n\t}\n#endif\n\n\t/*\n\t *  And finally, compare the digest in the packet with KD.\n\t */\n\tif (memcmp(&kd[0], &hash[0], 16) == 0) {\n\t\treturn RLM_MODULE_OK;\n\t}\n\n\tRDEBUG(\"FAILED authentication\");\n\treturn RLM_MODULE_REJECT;\n}", "path": "src\\modules\\rlm_digest\\rlm_digest.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/*************************************************************************\n *\n *\tFunction: sql_close\n *\n *\tPurpose: database specific close. Closes an open database\n *               connection\n *\n *************************************************************************/\n", "func_signal": "static int sql_close(SQLSOCK * sqlsocket, UNUSED SQL_CONFIG *config)", "code": "{\n\trlm_sql_mysql_sock *mysql_sock = sqlsocket->conn;\n\n\tif (mysql_sock && mysql_sock->sock){\n\t\tmysql_close(mysql_sock->sock);\n\t\tmysql_sock->sock = NULL;\n\t}\n\n\treturn 0;\n}", "path": "src\\modules\\rlm_sql\\drivers\\rlm_sql_mysql\\sql_mysql.c", "repo_name": "jacques/freeradius", "stars": 5, "license": "gpl-2.0", "language": "c", "size": 14512}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tClear Piano\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tClearPiano(void)", "code": "{\t\n\tint\ti;\t\n\t\n\tfor(i=0;i<32;i++)\t\n\t\tPIANOkhit[i]=0;\t\n\t\n\tUpdatePianoKeys();\t\n\tSwapPage();\t\n\tUpdatePianoKeys();\t\n\tSwapPage();\t\n\t\n\tTITLEm=3;\t\n\tSCROLLpos=0;\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/*\n * PHYSICALLY DISPLAY 'SCREEN'\n */\n", "func_signal": "void showscreen(void)", "code": "{\n#ifdef USE_X11\n  if (shmem_flag)\n    {\n      XShmPutImage(display, window, gc, ximage,\n\t\t   0,0,\n\t\t   0,0,\n\t\t   WWIDTH, WHEIGHT, False);\n    }\n  else\n    {\n      XPutImage(display, window, gc, ximage,\n\t\t   0,0,\n\t\t   0,0,\n\t\t   WWIDTH, WHEIGHT);\n    }\n  XSync(display, False);\n#else\n  memcpy(realscreen, screen, 64000);\n#endif\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tDraw Scroll\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tDrawScroll(void)", "code": "{\t\n\tint\tx,y;\t\n\t\n\tfor(y=0;y<8;y++)\t\n\t{\t\n\t\tfor(x=0;x<256;x++)\t\n\t\t{\t\n\t\t\tPlotPixel(x,152+y,PIXELbuff[(y*264)+(PIXELoff+x)]);\t\n\t\t}\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tDo Title Scroll\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tDoTitleScroll(void)", "code": "{\t\n\tSwapPage();\t\n\t\n\tTITLEwp++;\t\n\tif(TITLEwp==16)\t\n\t{\t\n\t\tTITLEwp=0;\t\n\t\tTITLEwf+=2;\t\n\t\tTITLEwf&=7;\t\n\t}\t\n\tDrawWilly4(TITLEwf+4);\t\n\t\n\tDrawScroll();\t\n\t\n\tPIXELoff++;\t\n\tif(PIXELoff==8)\t\n\t{\t\n\t\tPIXELoff=0;\t\n\t\tSCROLLpos++;\t\n\t\tif(SCROLLpos==290)\t\n\t\t{\t\n\t\t\tTITLEm=0;\t\n\t\t\tDEMOm=0;\t\n\t\t\tMODE=1;\t\n\t\n\t\t\tif(MUSICtype==0)\t\n\t\t\t\tmodon=MIDASplayModuleSection(mod,0x00,0x08,0x00,TRUE);\t\n\t\t\telse\t\n\t\t\t\tmodon=MIDASplayModuleSection(mod,0x09,0x0c,0x00,TRUE);\t\n\t\n\t\t\tif(MUSICon==1)\t\n\t\t\t\tMIDASsetMusicVolume(modon,64);\t\n\t\t\telse\t\n\t\t\t\tMIDASsetMusicVolume(modon,0);\t\n\t\n\t\t}\t\n\t\telse\t\n\t\t{\t\n\t\t\tUpdateScrollBuffer();\t\n\t\t\tFillPixelBuff();\t\n\t\t}\t\n\t}\t\n\t\n\tif(KeyTable[key_f1]==1)\t\n\t{\t\n\t\tTITLEm=4;\t\n\t\tPREFSm=0;\t\n\t}\t\n\t\n\tif( KeyTable[key_return]==1 )\t\n\t{\t\n\t\n\t\tTITLEm=0;\t\n\t\tDEMOm=0;\t\n\t\tMODE=2;\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n// Main Code.\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "int main(int argc, BYTE *argv[])", "code": "{\t\n\tint\tquit=0;\t\n\t\n#ifdef USE_X11\n\tinit_Xdisplay(NULL);\n\n\tslowdown_init(FHZ);\n#else\n\t/*ADMNOTE: set up SVGALIB */\n\tvga_init();\n\tvga_setmode(5);\n\tkeyboard_init();\n\tkeyboard_setdefaulteventhandler();\n\trealscreen=(BYTE*) vga_getgraphmem();\n#endif\n\n        pix_offset = 33 + 4*WIDTH;  /* for screen centering in this mode */\n\t//pix_offset = (XMAG * 33) + (YMAG * WIDTH * 4);  /* for screen centering in this mode */\n\n\n\tif(argc==2)\t\n\t{\t\n\t\tFORCE=1;\t\n\t}\t\n\telse\t\n\t{\t\n\t\tFORCE=0;\t\n\t}\t\n\t\n\tMIDASstartup();\t\n\t\n\tLoadInfo();\t\n\t\n\tSetupSound();\t\n\t\n\tGetVideoMode( &old_video );\t\n\n\tscreen = page1;\n\t\n\t/*-------------------------------------------------------------\t*/\n\t\n\tREFRESH=MIDASgetDisplayRefreshRate();\t\n\tif(REFRESH==0)\t\n\t\tREFRESH=59450;\t\n\t\n\tMIDASsetOption(MIDAS_OPTION_FILTER_MODE,MIDAS_FILTER_NONE);\t\n\t\n\tif(MIDASinit()==FALSE)\t\n\t{\t\n\t\treturn(0);\t\n\t}\t\n\t\n\tmod=MIDASloadModule(\"mm-data1.dat\");\t\n\t//ADMNOTE: filenames changed, now not M$ wav\n\twav=MIDASloadWaveSample(\"mm-data2.raw\",MIDAS_LOOP_NO);\t\n\tdie=MIDASloadWaveSample(\"mm-data3.raw\",MIDAS_LOOP_NO);\t\n\tpick=MIDASloadWaveSample(\"mm-data4.raw\",MIDAS_LOOP_NO);\n\t/*\twav=MIDASloadWaveSample(\"mm-data2.dat\",MIDAS_LOOP_NO);\t\n\tdie=MIDASloadWaveSample(\"mm-data3.dat\",MIDAS_LOOP_NO);\t\n\tpick=MIDASloadWaveSample(\"mm-data4.dat\",MIDAS_LOOP_NO);*/\n\t\n\tMIDASsetTimerCallbacks(REFRESH,TRUE,&PREvr,NULL,NULL);\t\n\tMIDASopenChannels(9);\t\n\t\n\t/*-------------------------------------------------------------\t*/\n\t\n\tSetKeyboard();\t\n\t\n\tCls(0);\t\n\tWaitVR();\t\n\tPaletteSet(PALblack);\t\n\t\n\tWaitVR();\t\n\tCls(0);\t\n\tSwapPage();\t\n\t\n\tWaitVR();\t\n\tPaletteSet(PALmain);\t\n\tCls(0);\t\n\tSwapPage();\t\n\t\n\tLOADm=0;\t\n\t\n\tdo\t\n\t{\t\n\t\n\t\n\t\tswitch(MODE)\t\n\t\t{\t\n\t\t\tcase\t0://TITLES\t\n\t\t\t\tTitles();\t\n\t\t\t\tbreak;\t\n\t\t\tcase\t1://DEMO\t\n\t\t\t\tDoDemo();\t\n\t\t\t\tbreak;\t\n\t\t\tcase\t2://GAME\t\n\t\t\t\tDoGame();\t\n\t\t\t\tbreak;\t\n\t\t\tcase\t3://LOADING\t\n\t\t\t\tDoLoading();\t\n\t\t\t\tbreak;\t\n\t\t}\t\n\t\n\t\n\t\tif( KeyTable[key_f10]==1 )\t\n\t\t\tquit=1;\t\n\t\n\t}\t\n\twhile( quit==0 );\t\n\t\n\t/*-------------------------------------------------------------\t*/\n\tif(modon!=0)\t\n\t\tMIDASstopModule(modon);\t\n\t\n\tMIDAScloseChannels();\t\n\tMIDASfreeModule(mod);\t\n\tMIDASfreeSample(wav);\t\n\tMIDASfreeSample(die);\t\n\tMIDASfreeSample(pick);\t\n\tMIDASclose();\t\n\t\n\t/*-------------------------------------------------------------\t*/\n\t\n\tWaitVR2();\t\n\tPaletteSet(PALblack);\t\n\t\n\tWaitVR2();\t\n\tSetVideoMode(old_video);\t\n\t\n\tSaveInfo();\t\n\t\t\n\tprintf(\"Manic Miner PC %s.\\n\",VERSION);\t\n\tprintf(\"Andy Noble (andy@andyn.demon.co.uk) 8/1997 - DOS version\\n\");\n\tprintf(\"Adam D. Moss (adam@foxbox.org) 12/1997 - UNIX port\\n\");\n\t\n\t/*printf(\"Refresh=%d\\n\\n\",REFRESH);\t*/\n\n\t/*ADMNOTE - vga/kbd stuff*/\n#ifdef USE_X11\n#else\n\tkeyboard_close();\n\tvga_setmode(TEXT);\n#endif\n\n\t\n\treturn(0);\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tTitles\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tTitles(void)", "code": "{\t\n\tswitch(TITLEm)\t\n\t{\t\n\t\tcase\t0:\t\n\t\t\tTitleSetup();\t\n\t\t\tbreak;\t\n\t\tcase\t1:\t\n\t\t\tDoPiano();\t\n\t\t\tbreak;\t\n\t\tcase\t2:\t\n\t\t\tClearPiano();\t\n\t\t\tbreak;\t\n\t\tcase\t3:\t\n\t\t\tDoTitleScroll();\t\n\t\t\tbreak;\t\n\t\tcase\t4:\t\n\t\t\tDoPrefs();\t\n\t\t\tbreak;\t\n\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tPlay The Piano\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tDoPiano(void)", "code": "{\t\n\tint\ti,j;\t\n\tBYTE\tkey1,key2,key3,key4;\t\n\t\n\tfor(i=0;i<32;i++)\t\n\t\tPIANOkhit[i]=0;\t\n\t\n\t/* ADM */\n/*\tMIDASgetPlayStatus(modon,&stat);\t\n\t\n\tif(stat.pattern==14)\t\n\t{\t\n\t\tTITLEm=2;\t\n\t\tMIDASstopModule(modon);\t\n\t\tmodon=0;\t\n\t}\t*/\n\n#ifdef USE_MIKMOD\n\tif(mod->sngpos==17)\t\n\t{\t\n\t\tTITLEm=2;\t\n\t\tMIDASstopModule(modon);\t\n\t\tmodon=0;\t\n\t}\n#endif\n\n\t\n\tUpdatePianoKeys();\t\n\tSwapPage();\t\n\t\n\tif(KeyTable[key_f1]==1)\t\n\t{\t\n\t\tTITLEm=4;\t\n\t\tPREFSm=0;\t\n\t\tMIDASstopModule(modon);\t\n\t\tmodon=0;\t\n\t}\t\n\t\n\tif( KeyTable[key_return]==1 )\t\n\t{\t\n\t\n\t\tTITLEm=0;\t\n\t\tDEMOm=0;\t\n\t\tMODE=2;\t\n\t\tMIDASstopModule(modon);\t\n\t\tmodon=0;\t\n\t}\t\n\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tFade Palette\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "int PaletteFade( unsigned char *pal1, unsigned char *pal2 )", "code": "{\t\n\tint\tcount,changed;\t\n\t\n\tchanged=0;\t\n\t\n\tfor(count=0;count<768;count++)\t\n\t{\t\n\t\n\t\tif(*pal1 != *pal2)\t\n\t\t{\t\n\t\t\tif(*pal1 > *pal2)\t\n\t\t\t{\t\n\t\t\t\t*pal2+=1;\t\n\t\t\t\tchanged=1;\t\n\t\t\t}\t\n\t\t\telse\t\n\t\t\t{\t\n\t\t\t\t*pal2-=1;\t\n\t\t\t\tchanged=1;\t\n\t\t\t}\t\n\t\t}\t\n\t\n\t\tpal1++;\t\n\t\tpal2++;\t\n\t\n\t}\t\n\treturn(changed);\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tADMNOTE: UNIX: Update keyboard state\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "int DoKeymap ( void )", "code": "{\n#ifdef USE_X11\n\n  KeySym ks = 0;\n  int kstat;\n  XEvent event;\n  char buf[21];\n\n  while (XPending(display))\n    {\n      XNextEvent(display, &event);\n\n      switch (event.type)\n\t{\n\tcase KeyPress:\n\t  kstat = 1;\n\tcase KeyRelease:\n\t  if (event.type == KeyRelease)\n\t    kstat = 0;\n\n\t  XLookupString(&event.xkey, buf, 20, &ks, NULL);\n\t  \n\t  switch (ks)\n\t    {\n\t    case 0xFF0D : KeyTable[key_return] = kstat; break;\n\t    case 0xFF52 :\n\t    case 0xFF97 :\n\t    case ' '    : KeyTable[key_space]  = kstat; break;\n\t    case 0xFF51 :\n\t    case 'O'    :\n\t    case 'o'    : KeyTable[key_o]      = kstat; break;\n\t    case 0xFF53 :\n\t    case 'P'    :\n\t    case 'p'    : KeyTable[key_p]      = kstat; break;\n\t    case 0xFF1B : KeyTable[key_esc]    = kstat; break;\n\t    case 0xFF91 :\n\t    case 0xFFBE : KeyTable[key_f1]     = kstat; break;\n\t    case 0xFF92 :\n\t    case 0xFFBF : KeyTable[key_f2]     = kstat; break;\n\t    case 0xFF93 :\n\t    case 0xFFC0 : KeyTable[key_f3]     = kstat; break;\n\t    case 0xFF94 :\n\t    case 0xFFC1 : KeyTable[key_f4]     = kstat; break;\n\t    case 0xFFC7 : KeyTable[key_f10]    = kstat; break;\n\t    default: break;\n\t    }\n\n\t  break;\n\tdefault: break;\n\t}\n    }\n\n#else\n  if (keyboard_update()==0) return;\n\n  /* Otherwise, something changed with the keyboard...\n  // ah, sod it... */\n\n  memcpy(KeyTable, keyboard_getstate(), 256);\n#endif\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tDraw Piano Key\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tDrawKey(int xpos,int ypos,BYTE block)", "code": "{\t\n\tint\tx,y,block2;\t\n\tBYTE\tdata;\t\n\t\n\txpos*=8;\t\n\typos*=8;\t\n\t\n\tblock2=(WORD)block;\t\n\tblock2*=128;\t\n\t\n\tfor(y=0;y<16;y++)\t\n\t{\t\n\t\tfor(x=0;x<8;x++)\t\n\t\t{\t\n\t\t\tdata=GFXpkeys[block2];\t\n\t\t\tPlotPixel(xpos+x,ypos+y,data);\t\n\t\t\tblock2++;\t\n\t\t}\t\n\t}\t\n\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "///////////////////////////////////////////////////////////////\t\n//\tNext Demo Level\t\n///////////////////////////////////////////////////////////////\t\n", "func_signal": "void\tNextDemo(void)", "code": "{\t\n\tLEVEL++;\t\n\tif(LEVEL==20)\t\n\t\tLEVEL=0;\t\n\t\n\tif(LEVEL==40)\t\n\t\tLEVEL=20;\t\n\t\n\tDemoSetup();\t\n}", "path": "mm-demo.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tFill Pixel buffer with text\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tFillPixelBuff(void)", "code": "{\t\n\tint\ti,x,y,dx,dy;\t\n\tWORD\talpha;\t\n\tWORD\tpoint;\t\n\tBYTE\t*font,*alias,data,data2;\t\n\t\n\tdx=0;dy=0;\t\n\t\n\tfor(i=0;i<33;i++)\t\n\t{\t\n\t\talpha=(WORD)SCROLLbuff[i];\t\n\t\talpha-=32;\t\n\t\talpha*=64;\t\n\t\n\t\tfont=(fontb+alpha);\t\n\t\talias=(GFXfant+alpha);\t\n\t\n\t\tfor(y=0;y<8;y++)\t\n\t\t{\t\n\t\t\tfor(x=0;x<8;x++)\t\n\t\t\t{\t\n\t\t\t\tdata=*font;\t\n\t\t\t\tif(data!=0)\t\n\t\t\t\t\tPIXELbuff[((dy+y)*264)+(dx+x)]=102;\t\n\t\t\t\telse\t\n\t\t\t\t\tPIXELbuff[((dy+y)*264)+(dx+x)]=PAPER;\t\n\t\n\t\t\t\tdata2=*alias;\t\n\t\t\t\tif(data2!=0)\t\n\t\t\t\t\tPIXELbuff[((dy+y)*264)+(dx+x)]=107;\t\n\t\n\t\t\t\tfont++;\t\n\t\t\t\talias++;\t\n\t\n\t\t\t}\t\n\t\t}\t\n\t\tdx+=8;\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tPrint Text\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tFontPrint2( int xpos, int ypos, BYTE *text )", "code": "{\t\n\tint\tcount,count2,count3;\t\n\tint\tcurrentx,currenty;\t\n\tint\talpha;\t\n\tBYTE\t*fonty,*fonty2,data,data2;\t\n\t\n\tcount=0;\t\n\t\n\txpos*=8;\t\n\typos*=8;\t\n\t\n\tcurrentx=xpos;\t\n\tcurrenty=ypos;\t\n\t\n\twhile( *text != 0 )\t\n\t{\t\n\t\talpha=(int)*text;\t\n\t\ttext++;\t\n\t\n\t\tif(alpha==170) /*=\"|\"\t */\n\t\t{\t\n\t\t\tcurrentx=0;\t\n\t\t\tcurrenty+=8;\t\n\t\t\talpha=(int)*text;\t\n\t\t\ttext++;\t\n\t\t}\t\n\t\n\t\n\t\talpha-=32;\t\n\t\n\t\tif(alpha>96)\t\n\t\t\talpha-=32;\t\n\t\n\t\talpha*=64;\t\n\t\tcount++;\t\n\t\tif(count==33)\t\n\t\t\treturn;\t\n\t\n\t\tfonty=(fontb+alpha);\t\n\t\tfonty2=(GFXfant+alpha);\t\n\t\n\t\txpos=currentx;\t\n\t\typos=currenty;\t\n\t\n\t\tfor(count2=0;count2<8;count2++)\t\n\t\t{\t\n\t\t\tfor(count3=0;count3<8;count3++)\t\n\t\t\t{\t\n\t\t\t\tif( (*fonty != 0))\t\n\t\t\t\t\tPlotPixel(xpos,ypos,0);\t\n\t\t\t\telse\t\n\t\t\t\t{\t\n\t\t\t\t\tif(*fonty2==1)\t\n\t\t\t\t\t{\t\n\t\t\t\t\t\tdata=GetPixel(xpos,ypos);\t\n\t\t\t\t\t\tdata2=data&15;\t\n\t\t\t\t\t\tdata2+=3;\t\n\t\t\t\t\t\tif(data2>15)\t\n\t\t\t\t\t\t\tdata2=15;\t\n\t\t\t\t\t\tdata&=240;\t\n\t\t\t\t\t\tdata|=data2;\t\n\t\t\t\t\t\tPlotPixel(xpos,ypos,data);\t\n\t\t\t\t\t}\t\n\t\t\t\t}\t\n\t\t\t\tfonty++;\t\n\t\t\t\tfonty2++;\t\n\t\t\t\txpos++;\t\n\t\t\t}\t\n\t\t\txpos=currentx;\t\n\t\t\typos++;\t\n\t\t}\t\n\t\tcurrentx+=8;\t\n\t}\t\n\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tSetup Prefs\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tSetupPrefs(void)", "code": "{\t\n\tint\tcount;\t\n\t\n\tfor(count=0;count<768;count++)\t\n\t{\t\n\t\tPALover[count]=PALmain[count];\t\n\t}\t\n\t\n\tDoPrefsExtra();\t\n\tSwapPage();\t\n\t\n\tPaletteSet(PALover);\t\n\tDoPrefsExtra();\t\n\t\n\tPREFSh1=0;\t\n\tPREFSh2=0;\t\n\tPREFSh3=0;\t\n\tPREFSm=1;\t\n\t\n\tmodon=MIDASplayModuleSection(mod,0x12,0x15,0x12,TRUE);\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tDo Background Fill 1\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tFill1(void)", "code": "{\t\n\tint\tx,y,block2;\t\n\tBYTE\tdata;\t\n\t\n\tblock2=0;\t\n\t\n\tfor(y=0;y<24;y++)\t\n\t{\t\n\t\tfor(x=0;x<16;x++)\t\n\t\t{\t\n\t\t\tdata=GFXfill[block2];\t\n\t\t\tPlotPixel(152+x,40+y,data);\t\n\t\t\tblock2++;\t\n\t\t}\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tDraw Level Title Plate\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tDrawTPlate2(void)", "code": "{\t\n\tint\tx,y;\t\n\tBYTE\tdata;\t\n\t\n\tfor(y=0;y<8;y++)\t\n\t{\t\n\t\tfor(x=0;x<256;x++)\t\n\t\t{\t\n\t\t\tPlotPixel(x,128+y,GFXtplate[(y*256)+x]);\t\n\t\t}\t\n\t}\t\n\tFontPrint2(8,16,\"\u007f1997 Andy Noble\");\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tClear Current Page\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void Cls( BYTE col )", "code": "{\n  int pcol, i;\n  uint16* u16p;\n  uint32* u32p;\n\n  memset(screen, col, 64000);\n\n#ifdef USE_X11\n  switch (bytesdeep)\n    {\n    case 1:\n      pcol = ((uint8 *)pix)[col];\n      memset((uint8 *)ximage->data, pcol, WWIDTH*WHEIGHT);\n      break;\n    case 2:\n      pcol = ((uint16 *)pix)[col];\n      u16p = (uint16 *)ximage->data;\n      for (i=0;i<WWIDTH*WHEIGHT;i++)\n\t{\n\t  *u16p++ = pcol;\n\t}\n      break;\n    default:\n      pcol = ((uint32 *)pix)[col];\n      u32p = (uint32 *)ximage->data;\n      for (i=0;i<WWIDTH*WHEIGHT;i++)\n\t{\n\t  *u32p++ = pcol;\n\t}\n      break;\n    }\n#endif\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tUpdate Scroll Buffer\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tUpdateScrollBuffer(void)", "code": "{\t\n\tint\ti;\t\n\t\n\tfor(i=0;i<33;i++)\t\n\t{\t\n\t\tSCROLLbuff[i]=SCROLLtext[SCROLLpos+i];\t\n\t}\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tSet Palette1 with Palette2\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void PaletteFill( char *pal1, char *pal2 )", "code": "{\t\n\tint\tcount;\t\n\t\n\tfor(count=0;count<768;count++)\t\n\t\tpal1[count]=pal2[count];\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/////////////////////////////////////////////////////////////\t\n//\tLoad Stuff at Start\t\n/////////////////////////////////////////////////////////////*/\t\n", "func_signal": "void\tLoadInfo(void)", "code": "{\t\n\tFILE\t*file;\t\n\t\n\tfile=fopen( \"mm-conf.cfg\", \"rb\" );\t\n\tif(file==NULL)\t\n\t{\t\n\t\tHISCORE=0;\t\n\t\tSPEED=3;\t\n\t\tTONKS=0;\t\n\t\tMUSICtype=0;\t\n\t\treturn;\t\n\t}\t\n\tfread( &HISCORE, sizeof(unsigned long), 1, file );\t\n\tfread( &SPEED, sizeof(BYTE), 1, file );\t\n\tfread( &TONKS, sizeof(BYTE), 1, file );\t\n\tfread( &MUSICtype, sizeof(BYTE), 1, file );\t\n\tfclose( file );\t\n}", "path": "manic.c", "repo_name": "lkundrak/manicminer", "stars": 5, "license": "None", "language": "c", "size": 200}
{"docstring": "/* invoked when a frame is available to be read\n\n      frame         actions taken by\n   received     ECHO                SINK\n   --------     ----                ----\n        MSG     send echo RPY       partial: ignore\n                                    complete: send empty RPY\n\n        RPY     update out parameters for null_trip\n                if complete, leave RSPWAIT\n\n    ERR/NUL     if complete, leave RSPWAIT\n\n        ANS     ignore              ignore  \n\n */\n", "func_signal": "static void\npro_frame_available (PROFILE_INSTANCE   *pi)", "code": "{\n    int                  size;\n    char                *buffer,\n                        *payload;\n    FRAME               *f;\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) pi -> user_ptr1;\n\n    if (!(f = bpc_query_frame (pi -> channel, BLU_QUERY_ANYTYPE,\n                               BLU_QUERY_ANYMSG, BLU_QUERY_ANYANS)))\n      return;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr,\n                 \"%s frame_available: type=%c number=%ld answer=%ld more=%c size=%ld\\n\",\n                 pro_name (pi -> channel -> profile_registration -> uri),\n                 f -> msg_type, f -> message_number, f -> answer_number,\n                 f -> more, f -> size);\n        fprintf (stderr, f -> size > 75 ? \"%-75.75s...\\n\" : \"%s\\n\",\n                 f -> payload);\n        fflush (stderr);\n    }\n\n    switch (f -> msg_type) {\n        case BLU_FRAME_TYPE_MSG:\n            if (il -> pl_flags & PRO_ECHOMODE)\n                payload = f -> payload, size = f -> size;\n            else if (f -> more == BLU_FRAME_COMPLETE)\n                payload = EMPTY_RPY, size = sizeof EMPTY_RPY - 1;\n            else\n                break;\n            if ((buffer = bpc_buffer_allocate (pi -> channel, size)) != NULL) {\n                memcpy (buffer, payload, size);\n                bpc_send (pi -> channel, BLU_FRAME_TYPE_RPY,\n                          f -> message_number, BLU_FRAME_IGNORE_ANSNO,\n                          f -> more, buffer, size);\n            } else\n                bp_log (pi -> channel -> conn, LOG_PROF, 5,\n                        \"%s frame_available: out of memory\",\n                        pro_name (pi -> channel -> profile_registration -> uri));\n            break;\n\n        case BLU_FRAME_TYPE_RPY:\n            if (f -> size <= il -> pl_rlen) {\n                memcpy (il -> pl_rbuf, f -> payload, f -> size);\n                il -> pl_rbuf += f -> size, il -> pl_rlen -= f -> size;\n            } else\n                il -> pl_rlen = -1;\n            /* and fall... */\n        case BLU_FRAME_TYPE_ERR:\n        case BLU_FRAME_TYPE_NUL:\n            if (f -> more == BLU_FRAME_COMPLETE) {\n                il -> pl_flags &= ~PRO_RSPWAIT;\n                SEM_POST (&il -> pl_sem);\n            }\n            break;\n\n        case BLU_FRAME_TYPE_ANS:\n        default:\n            break;\n    }\n\n    bpc_frame_destroy (pi -> channel, f);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when we know whether the channel has finally closed or not\n   (regardless of who requested it)\n\n   if nothing happened, do nothing\n\n   if we requested the close, leave PRO_LOCALDATA for null_close\n\n   if we're doing a round-trip, signal null_trip and release the semaphore\n\n   otherwise, lib_free PRO_LOCALDATA\n */\n", "func_signal": "static void\npro_close_confirmation (PROFILE_INSTANCE        *pi,\n                        char                     status,\n                        DIAGNOSTIC              *error,\n                        char                     origin,\n                        char                     scope)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) pi -> user_ptr1;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        if (error)\n            fprintf (stderr,\n                     \"%s close_confirmation: status=%c error=[%d] \\\"%s\\\" origin=%c scope=%c\\n\",\n                     pro_name (pi -> channel -> profile_registration -> uri),\n                     status, error -> code, error -> message ? error -> message\n                                                             : \"<NULL>\",\n                     origin, scope);\n        else \n            fprintf (stderr,\n                     \"%s close_confirmation: status=%c no error origin=%c scope=%c\\n\",\n                     pro_name (pi -> channel -> profile_registration -> uri),\n                     status, origin, scope);\n        fflush (stderr);\n    }\n    \n    if (status != PRO_ACTION_SUCCESS)\n        return;\n\n    pi -> user_ptr1 = NULL;\n\n    if (il -> pl_flags & PRO_CLSWAIT)\n        il -> pl_flags &= ~PRO_CLSWAIT;\n    else if (il -> pl_flags & PRO_START) {\n        il -> pl_pi = NULL;\n        if (il -> pl_flags & PRO_RSPWAIT) {\n            il -> pl_flags &= ~PRO_RSPWAIT;\n            SEM_POST (&il -> pl_sem);\n        }\n    }\n    else\n        lib_free (il);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked just before the session is released\n\n   do session-wide finalization\n\n   return value is ignored by wrapper\n */\n", "func_signal": "static char *\npro_session_fin (PROFILE_REGISTRATION   *pr,\n                 BP_CONNECTION          *bp)", "code": "{\n    if (((PRO_LOCALDATA *) pr -> user_ptr) -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s session_fin\\n\", pro_name (pr -> uri));\n        fflush (stderr);\n    }\n\n    return NULL;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when a response is received to null_close's request to close\n   the channel\n\n   note failure\n*/\n", "func_signal": "static void\npro_close_callback (void                *clientData,\n                    CHANNEL_INSTANCE    *ci,\n                    DIAGNOSTIC          *error)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) clientData;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n      if (error)\n          fprintf (stderr, \"%s pro_close_callback: error=[%d] \\\"%s\\\" \\n\",\n                   pro_name (ci -> profile_registration -> uri),\n                   error -> code,\n                   error -> message ? error -> message : \"<NULL>\");\n      else\n          fprintf (stderr, \"%s pro_close_callback: no error\\n\",\n                   pro_name (ci -> profile_registration -> uri));\n        fflush (stderr);\n    }\n\n    if (error) {\n        il -> pl_flags |= PRO_DENIED, il -> pl_flags &= ~PRO_CLSWAIT;\n\n        printf (\"unable to close channel: [%d] %s\\n\",\n                error -> code,\n                error -> message ? error -> message : \"<NULL>\");\n    }\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/*    profile methods */\n", "func_signal": "static char *\npro_name (char *uri)", "code": "{\n    char        *cp;\n\n    if ((cp = strrchr (uri, '/')) != NULL)\n        return ++cp;\n    return uri;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when the local peer is about to do a tuning reset */\n", "func_signal": "static void\npro_tuning_reset_indication (PROFILE_INSTANCE  *pi)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) pi -> user_ptr1;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s tuning_reset_indication\\n\",\n                 pro_name (pi -> channel -> profile_registration -> uri));\n        fflush (stderr);\n    }\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when a response is received to null_start's request to start a channel\n\n   note failure\n*/\n", "func_signal": "static void\npro_start_callback (void                *clientData,\n                    CHANNEL_INSTANCE    *ci,\n                    DIAGNOSTIC          *error)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) clientData;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n      if (error)\n          fprintf (stderr, \"%s pro_start_callback: error=[%d] \\\"%s\\\" \\n\",\n                   pro_name (ci -> profile_registration -> uri),\n                   error -> code,\n                   error -> message ? error -> message : \"<NULL>\");\n      else\n          fprintf (stderr, \"%s pro_start_callback: no error\\n\",\n                   pro_name (ci -> profile_registration -> uri));\n        fflush (stderr);\n    }\n\n    if (error)\n        printf (\"unable to start channel: [%d] %s\\n\",\n                   error -> code,\n                   error -> message ? error -> message : \"<NULL>\");\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked if profile is about to be made available for the session\n\n   do session-wide initialization\n\n   on failure, the wrapper makes no further calls to the profile\n */\n", "func_signal": "static char *\npro_session_init (PROFILE_REGISTRATION  *pr,\n                  BP_CONNECTION         *bp)", "code": "{\n    if (((PRO_LOCALDATA *) pr -> user_ptr) -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s session_init: role='%c' mode=\\\"%s\\\"\\n\",\n                 pro_name (pr -> uri), bp -> role, bp -> mode);\n        fflush (stderr);\n    }\n\n    return NULL;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* initiator: send a message, get back reply */\n", "func_signal": "extern int\nnull_trip (void                         *v,\n           char                         *ibuf,\n           int                           ilen,\n           char                         *obuf,\n           int                           omaxlen)", "code": "{\n    char                *buffer;\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) v;\n    PROFILE_INSTANCE    *pi;\n\n    if (!(pi = il -> pl_pi)) {\n        SEM_DESTROY (&il -> pl_sem);\n        lib_free (il);\n        return NULL_DONE;\n    }\n    if (!(il -> pl_flags & PRO_READY))\n        return NULL_BUSY;\n\n    if (!(buffer = bpc_buffer_allocate (pi -> channel, ilen)))\n        return NULL_ERROR;\n    memcpy (buffer, ibuf, ilen);\n\n    il -> pl_rbuf = obuf, il -> pl_rlen = omaxlen;\n    il -> pl_flags |= PRO_RSPWAIT, il -> pl_flags &= ~PRO_READY;\n\n    bpc_send (pi -> channel, BLU_FRAME_TYPE_MSG, BLU_FRAME_MSGNO_UNUSED,\n              BLU_FRAME_IGNORE_ANSNO, BLU_FRAME_COMPLETE, buffer, ilen);\n\n    SEM_WAIT (&il -> pl_sem);\n\n    if (!il -> pl_pi) {\n        SEM_DESTROY (&il -> pl_sem);\n        lib_free (il);\n        return NULL_DONE;\n    }\n\n    il -> pl_flags |= PRO_READY;\n\n    if (il -> pl_rlen < 0)\n        return NULL_ERROR;\n\n    return (omaxlen - il -> pl_rlen);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/*\n   invoked when we or the peer asks to close a session/channel\n   (or perhaps due to transport problem, etc.)\n\n   if the remote peer is asking, reject it\n\n   otherwise, accept it\n */\n", "func_signal": "static void\npro_close_indication (PROFILE_INSTANCE  *pi,\n                      DIAGNOSTIC        *request,\n                      char               origin,\n                      char               scope)", "code": "{\n    BP_CONNECTION       *bp = pi -> channel -> conn;\n    DIAGNOSTIC          *d;\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) pi -> user_ptr1;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr,\n                 \"%s close_indication: request=[%d] \\\"%s\\\" origin=%c scope=%c\\n\",\n                 pro_name (pi -> channel -> profile_registration -> uri),\n                 request -> code, request -> message ? request -> message\n                                                     : \"<NULL>\",\n                 origin, scope);\n        fflush (stderr);\n    }\n               \n    d = ((il -> pl_flags & PRO_START) && (origin == PRO_ACTION_REMOTE))\n            ? bp_diagnostic_new (bp, 500, NULL, \"no thanks\")\n            : NULL;\n\n    bpc_close_response (pi -> channel, d);\n\n    if (d)\n        bp_diagnostic_destroy (bp, d);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* initiator: start channel */\n", "func_signal": "void *\nnull_start (BP_CONNECTION               *bp,\n            PROFILE_REGISTRATION        *pr,\n            char                        *serverName)", "code": "{\n    DIAGNOSTIC          *d;\n    PRO_LOCALDATA       *pl = pr -> user_ptr,\n                        *il;\n    PROFILE              ps,\n                        *p = &ps;\n\n    memset (p, 0, sizeof *p);\n    p -> uri = pr -> uri;\n    p -> piggyback_length = strlen (p -> piggyback = \"\");\n\n    if (!(il = (PRO_LOCALDATA *) lib_malloc (sizeof *il)))\n        return NULL;\n    memcpy (il, pl, sizeof *il);\n    il -> pl_flags |= PRO_START;\n\n    /* this blocks! */\n    d = bp_start_request (bp, BLU_CHAN0_CHANO_DEFAULT, BLU_CHAN0_MSGNO_DEFAULT,\n                          p, serverName, pro_start_callback, (void *) il);\n\n    if (d) {\n        printf (\"unable to start channel: [%d] %s\\n\",\n                d -> code, d -> message);\n        bp_diagnostic_destroy (bp, d);\n    }\n\n    if (il -> pl_pi) {\n        SEM_INIT (&il -> pl_sem, 0);\n        il -> pl_flags |= PRO_READY;\n    } else\n        lib_free (il), il = NULL;\n\n    return ((void *) il);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/*\n * This unlocks a previously locked user name.\n * It does nothing if the name isn't locked.\n */\n", "func_signal": "void sasl_otp_unlock(char *path,\n        char * authID)", "code": "{\n    char fname[290];\n\n    sprintf(fname, \"%s/%s.LOCK\", path, authID);\n    unlink(fname);\n}", "path": "beepcore-c\\profiles\\SASLutils\\otp_db.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/*\n * This reads an OTP record from the password database.\n * It returns 0 if all was well, else 1 for any problem.\n */\n", "func_signal": "int sasl_otp_read(char *path,\n        char * authID,\n        char mech[8],\n        int * count,\n        char seed[64],\n        char pass[8])", "code": "{\n    FILE * pwfile;\n    char count_str[20];\n    char pass_encoded[18];\n    char fname[290];\n\n    sprintf(fname, \"%s/%s\", path, authID);\n    pwfile = fopen(fname, \"r\");\n    if (pwfile == NULL) return 1;\n    if (NULL == fgets(mech, 8, pwfile)) {\n        fclose(pwfile);\n        return 1;\n    }\n    if (mech[strlen(mech)-1] == '\\n')\n        mech[strlen(mech)-1] = '\\0';\n    if (NULL == fgets(count_str, 20, pwfile)) {\n        fclose(pwfile);\n        return 1;\n    }\n    (*count) = atoi(count_str);\n    if (NULL == fgets(seed, 64, pwfile)) {\n        fclose(pwfile);\n        return 1;\n    }\n    if (seed[strlen(seed)-1] == '\\n')\n        seed[strlen(seed)-1] = '\\0';\n    if (NULL == fgets(pass_encoded, 17, pwfile)) {\n        fclose(pwfile);\n        return 1;\n    }\n    from_hex(pass_encoded, 16, pass);\n    fclose(pwfile);\n    return 0;\n}", "path": "beepcore-c\\profiles\\SASLutils\\otp_db.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when we know whether the tuning reset occurred */\n", "func_signal": "static void\npro_tuning_reset_confirmation (PROFILE_INSTANCE        *pi,\n                               char                     status)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) pi -> user_ptr1;\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s tuning_reset_confirmation: status=%c\\n\",\n                 pro_name (pi -> channel -> profile_registration -> uri),\n                 status);\n        fflush (stderr);\n    }\n\n    pro_close_confirmation (pi, status, NULL, PRO_ACTION_LOCAL,\n                            PRO_ACTION_SESSION);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when profile is registered with the wrapper\n\n   do process-wide initialization\n\n   on failure, the wrapper makes no further calls to the profile for\n               the duration of the session\n */\n", "func_signal": "static char *\npro_connection_init (PROFILE_REGISTRATION  *pr,\n                     BP_CONNECTION         *bp)", "code": "{\n    if (((PRO_LOCALDATA *) pr -> user_ptr) -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s connection_init\\n\", pro_name (pr -> uri));\n        fflush (stderr);\n    }\n\n    return NULL;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked just before wrapper is destroyed\n\n   do process-wide finalization\n\n   return value is ignored by wrapper\n */\n", "func_signal": "static char *\npro_connection_fin (PROFILE_REGISTRATION   *pr,\n                    BP_CONNECTION          *bp)", "code": "{\n    if (((PRO_LOCALDATA *) pr -> user_ptr) -> pl_flags & PRO_DEBUG) {\n        fprintf (stderr, \"%s connection_fin\\n\", pro_name (pr -> uri));\n        fflush (stderr);\n    }\n\n    return NULL;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when a our request to start a channel has resulted in the channel starting\n\n   remember PRO_LOCALDATA passed as clientData\n */\n", "func_signal": "static void\npro_start_confirmation (void             *clientData,\n                        PROFILE_INSTANCE        *pi,\n                        PROFILE                 *po)", "code": "{\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) clientData;\n    struct configobj    *appconfig = bp_get_config (pi -> channel -> conn);\n\n    if (il -> pl_flags & PRO_DEBUG) {\n        char    *cp,\n               **pp;\n        static char *pairs[] = {\n            PRIVACY_REMOTE_SUBJECTNAME, \"PRIVACY_REMOTE_SUBJECTNAME\",\n            PRIVACY_CIPHER_NAME,        \"PRIVACY_CIPHER_NAME\",\n            PRIVACY_CIPHER_PROTOCOL,    \"PRIVACY_CIPHER_PROTOCOL\",\n            PRIVACY_CIPHER_SBITS,       \"PRIVACY_CIPHER_SBITS\",\n            SASL_LOCAL_MECHANISM,       \"SASL_LOCAL_MECHANISM\",\n            SASL_LOCAL_CODE,            \"SASL_LOCAL_CODE\",\n            SASL_LOCAL_REASON,          \"SASL_LOCAL_REASON\",\n            SASL_REMOTE_MECHANISM,      \"SASL_REMOTE_MECHANISM\",\n            SASL_REMOTE_USERNAME,       \"SASL_REMOTE_USERNAME\",\n            SASL_REMOTE_TARGET,         \"SASL_REMOTE_TARGET\",\n            SASL_REMOTE_CODE,           \"SASL_REMOTE_CODE\",\n            SASL_REMOTE_REASON,         \"SASL_REMOTE_REASON\",\n          NULL\n        };      \n\n        fprintf (stderr, \"%s start_confirmation: piggyback=\\\"%s\\\"\\n\",\n                 pro_name (po -> uri),\n                 po -> piggyback ? po -> piggyback : \"<NULL>\");\n        for (pp = pairs; *pp; pp++)\n            if ((cp = config_get (appconfig, *pp++)) != NULL)\n                fprintf (stderr, \"    %s: \\\"%s\\\"\\n\", *pp, cp);\n\n        fflush (stderr);\n    }\n\n    il -> pl_pi = pi, pi -> user_ptr1 = il;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/*    module entry points */\n", "func_signal": "static PROFILE_REGISTRATION *\npro_init (struct configobj  *appconfig,\n          int                echoP)", "code": "{\n    int                   debugP;\n    char                 *cp;\n    PRO_LOCALDATA        *pl;\n    PROFILE_REGISTRATION *pr;\n\n    if (!(pr = (PROFILE_REGISTRATION *) lib_malloc (sizeof *pr +\n                                                    sizeof *pl))) {\n        log_line (LOG_PROF, 6, \"unable to allocate PR\");\n        return NULL;\n    }\n    memset (pr, 0, sizeof *pr);\n\n    cp = echoP ? NULL_ECHO_DEBUG : NULL_SINK_DEBUG;\n    debugP = 0;\n    if ((cp = config_get (appconfig, cp)) != NULL)\n        debugP = atoi (cp);\n\n    cp = echoP ? NULL_ECHO_URI : NULL_SINK_URI;\n    if (!(pr -> uri = config_get (appconfig, cp)))\n        pr -> uri = echoP ? PRO_ECHO_URI : PRO_SINK_URI;\n\n    cp = echoP ? NULL_ECHO_IMODES : NULL_SINK_IMODES;\n    if (!(pr -> initiator_modes = config_get (appconfig, cp)))\n        pr -> initiator_modes = \"plaintext,encrypted\";\n    cp = echoP ? NULL_ECHO_LMODES : NULL_SINK_LMODES;\n    if (!(pr -> listener_modes = config_get (appconfig, cp)))\n        pr -> listener_modes = \"plaintext,encrypted\";\n\n    pr -> full_messages = 0;\n    pr -> thread_per_channel = 0;\n\n    pr -> proreg_connection_init = pro_connection_init;\n    pr -> proreg_connection_fin  = pro_connection_fin;\n    pr -> proreg_session_init = pro_session_init;\n    pr -> proreg_session_fin  = pro_session_fin;\n    pr -> proreg_start_indication   = pro_start_indication;\n    pr -> proreg_start_confirmation = pro_start_confirmation;\n    pr -> proreg_close_indication   = pro_close_indication;\n    pr -> proreg_close_confirmation = pro_close_confirmation;\n    pr -> proreg_tuning_reset_indication   = pro_tuning_reset_indication;\n    pr -> proreg_tuning_reset_confirmation = pro_tuning_reset_confirmation;\n    pr -> proreg_frame_available = pro_frame_available;\n\n    pr -> user_ptr = pl = (PRO_LOCALDATA *) (((char *) pr) + sizeof *pr);\n    memset (pl, 0, sizeof *pl);\n    if (echoP)\n        pl -> pl_flags |= PRO_ECHOMODE;\n    if (debugP)\n        pl -> pl_flags |= PRO_DEBUG;\n\n    return pr;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* invoked when the peer asks to start a channel\n\n   if not echoing, ignore any piggyback'd data  \n   clone PRO_LOCALDATA and accept it\n */\n", "func_signal": "static void\npro_start_indication (PROFILE_INSTANCE  *pi,\n                      PROFILE           *po)", "code": "{\n    DIAGNOSTIC           ds,\n                        *d = &ds;\n    PRO_LOCALDATA       *pl = pi -> channel -> profile_registration\n                                 -> user_ptr,\n                        *il;\n    PROFILE              ps,\n                        *p = &ps;\n    struct configobj    *appconfig = bp_get_config (pi -> channel -> conn);\n\n    if (pl -> pl_flags & PRO_DEBUG) {\n        char    *cp,\n               **pp;\n        static char *pairs[] = {\n            PRIVACY_REMOTE_SUBJECTNAME, \"PRIVACY_REMOTE_SUBJECTNAME\",\n            PRIVACY_CIPHER_NAME,        \"PRIVACY_CIPHER_NAME\",\n            PRIVACY_CIPHER_PROTOCOL,    \"PRIVACY_CIPHER_PROTOCOL\",\n            PRIVACY_CIPHER_SBITS,       \"PRIVACY_CIPHER_SBITS\",\n            SASL_LOCAL_MECHANISM,       \"SASL_LOCAL_MECHANISM\",\n            SASL_LOCAL_CODE,            \"SASL_LOCAL_CODE\",\n            SASL_LOCAL_REASON,          \"SASL_LOCAL_REASON\",\n            SASL_REMOTE_MECHANISM,      \"SASL_REMOTE_MECHANISM\",\n            SASL_REMOTE_USERNAME,       \"SASL_REMOTE_USERNAME\",\n            SASL_REMOTE_TARGET,         \"SASL_REMOTE_TARGET\",\n            SASL_REMOTE_CODE,           \"SASL_REMOTE_CODE\",\n            SASL_REMOTE_REASON,         \"SASL_REMOTE_REASON\",\n          NULL\n        };      \n\n        fprintf (stderr, \"%s start_indication: piggyback=\\\"%s\\\"\\n\",\n                 pro_name (po -> uri),\n                 po -> piggyback ? po -> piggyback : \"<NULL>\");\n        for (pp = pairs; *pp; pp++)\n            if ((cp = config_get (appconfig, *pp++)) != NULL)\n                fprintf (stderr, \"    %s: \\\"%s\\\"\\n\", *pp, cp);\n\n        fflush (stderr);\n    }\n               \n    if (!(il = (PRO_LOCALDATA *) lib_malloc (sizeof *il))) {\n        memset (d, 0, sizeof *d);\n        d -> code = 421;\n        d -> message = \"out of memory\";\n        bpc_start_response (pi -> channel, po, d);\n        return;\n    }\n    memcpy (il, pl, sizeof *il);\n    il -> pl_pi = pi, pi -> user_ptr1 = il;\n\n    if (il -> pl_flags & PRO_ECHOMODE)\n        p = po;\n    else {\n        memset (p, 0, sizeof *p);\n        p -> uri = po -> uri;\n    }\n\n    bpc_start_response (pi -> channel, p, NULL);\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/* initiator: close channel */\n", "func_signal": "extern int\nnull_close (void        *v)", "code": "{\n    BP_CONNECTION       *bp;\n    DIAGNOSTIC          *d;\n    PRO_LOCALDATA       *il = (PRO_LOCALDATA *) v;\n    PROFILE_INSTANCE    *pi;\n\n    if (!(pi = il -> pl_pi)) {\n        SEM_DESTROY (&il -> pl_sem);\n        lib_free (il);\n        return NULL_DONE;\n    }\n    if (!(il -> pl_flags & PRO_READY))\n        return NULL_BUSY;\n\n    il -> pl_flags |= PRO_CLSWAIT, il -> pl_flags &= ~PRO_READY;\n\n    bp = pi -> channel -> conn;\n    if ((d = bpc_close_request (pi -> channel, BLU_CHAN0_MSGNO_DEFAULT, 200,\n                                NULL, NULL, pro_close_callback,\n                                (void *) il)) != NULL) {\n        printf (\"unable to close channel: [%d] %s\\n\",\n                d -> code, d -> message);\n        bp_diagnostic_destroy (bp, d);\n\n        il -> pl_flags |= PRO_READY, il -> pl_flags &= ~PRO_CLSWAIT;\n        return NULL_ERROR;\n    }\n\n    /* could use a semaphore instead of a spinlock, but it's an example... */\n    while (il -> pl_flags & PRO_CLSWAIT)\n        YIELD ();\n\n    if (il -> pl_flags & PRO_DENIED) {\n        il -> pl_flags |= PRO_READY, il -> pl_flags &= ~PRO_DENIED;\n        return NULL_DENIED;\n    }\n\n    SEM_DESTROY (&il -> pl_sem);\n    lib_free (il);\n    return NULL_OK;\n}", "path": "beepcore-c\\profiles\\null-profiles.c", "repo_name": "sam-github/swirl", "stars": 6, "license": "None", "language": "c", "size": 832}
{"docstring": "/**\n * ytv_browser_fetch_entries:\n * @self: a #YtvBrowser\n *\n * Request a new set of #YtvEntry to the #YtvFeed\n */\n", "func_signal": "void\nytv_browser_fetch_entries (YtvBrowser* self)", "code": "{\n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->fetch_entries == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_fetch_entries\\n\");\n        }\n\n        YTV_BROWSER_GET_IFACE (self)->fetch_entries (self);\n\n        return;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_order_get_type:\n *\n * GType system helper function\n *\n * returns: a #GType\n */\n", "func_signal": "GType\nytv_youtube_order_get_type (void)", "code": "{\n        static GType type = 0;\n\n        if (G_UNLIKELY (type == 0))\n        {\n                static const GEnumValue values[] = {\n                        { YTV_YOUTUBE_ORDER_RELEVANCE,\n                          \"YTV_YOUTUBE_ORDER_RELEVANCE\", \"relevance\" },\n                        { YTV_YOUTUBE_ORDER_PUBLISHED,\n                          \"YTV_YOUTUBE_ORDER_PUBLISHED\", \"published\" },\n                        { YTV_YOUTUBE_ORDER_VIEWCOUNT,\n                          \"YTV_YOUTUBE_ORDER_VIEWCOUNT\", \"viewcount\" },\n                        { YTV_YOUTUBE_ORDER_RATING,\n                          \"YTV_YOUTUBE_ORDER_RATING\", \"rating\" },\n                        { 0, NULL, NULL }\n                };\n\n                type = g_enum_register_static (\"YtvYoutubeOrderType\", values);\n        }\n\n        return type;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_standard_feed:\n * @self: a #YtvUriBuilder\n * @type: a type of standard of feed\n *\n * Constructs an URI for the standard feed indicated by @type\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_standard_feed (YtvUriBuilder* self, guint type)", "code": "{\n        gchar* retval;\n\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_standard_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_standard_feed\n                (self, type);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_new:\n *\n * Creates a new instance of the #YtvYoutubeUriBuilder which\n * implements the #YtvUriBuilder interface\n *\n * returns: (not-null): a new youtube implementation of the\n * #YtvUriBuilder interface\n */\n", "func_signal": "YtvUriBuilder*\nytv_youtube_uri_builder_new (void)", "code": "{\n        YtvYoutubeUriBuilder* self;\n\n        self = g_object_new (YTV_TYPE_YOUTUBE_URI_BUILDER, NULL);\n\n        return YTV_URI_BUILDER (self);\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_next_page:\n * @self: a #YtvBrowser\n *\n * Request the next page in the feed\n *\n * return value: TRUE if it is possible to request the next page; otherwise\n * FALSE\n */\n", "func_signal": "gboolean\nytv_browser_next_page (YtvBrowser* self)", "code": "{\n        gboolean retval;\n        \n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->next_page == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_next_page\\n\");\n        }\n\n        retval = YTV_BROWSER_GET_IFACE (self)->next_page (self);\n\n        return retval;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_related_feed:\n * @self: a #YtvUriBuilder\n * @vid: (not-ok): the video id\n *\n * Constructs an URI for the feed with the entries related to the @vid\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_related_feed (YtvUriBuilder* self, const gchar* vid)", "code": "{\n        gchar* retval;\n\n        g_assert (vid != NULL);\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_related_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_related_feed\n                (self, vid);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_set_feed:\n * @self: a #YtvBrowser\n * @feed: (not-null): a #YtvFeed\n *\n * Set the feed which view @self will display\n */\n", "func_signal": "void\nytv_browser_set_feed (YtvBrowser* self, YtvFeed* feed)", "code": "{\n        YtvFeed* validate;\n\n        g_assert (YTV_IS_BROWSER (self));\n        g_assert (YTV_IS_FEED (feed));\n\n        if (YTV_BROWSER_GET_IFACE (self)->set_feed == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_set_feed\\n\");\n        }\n\n        YTV_BROWSER_GET_IFACE (self)->set_feed (self, feed);\n\n        validate = ytv_browser_get_feed (self);\n        g_assert (feed == validate);\n        g_object_unref (validate);\n\n        return;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_list_get_length:\n * @self: An #YtvList instance\n *\n * Obtains the number of elements contained in the list\n *\n * Return value: the length of the list\n *\n **/\n", "func_signal": "guint\nytv_list_get_length (YtvList *self)", "code": "{\n        g_assert (YTV_IS_LIST (self));\n        g_assert (YTV_LIST_GET_IFACE (self)->get_length_func != NULL);\n\n        return YTV_LIST_GET_IFACE (self)->get_length_func (self);\n}", "path": "src\\ytv-list.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_thumbnail:\n * @self: a #YtvUriBuilder\n * @vid: (not-ok): the video id\n *\n * Constructs an URI for the @vid entry's thumbnail\n *\n * returns: (null-ok): (caller-owns): the URI string for the thumbnail.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_thumbnail (YtvUriBuilder* self, const gchar* vid)", "code": "{\n        gchar* retval;\n\n        g_assert (vid != NULL);\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_thumbnail != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_thumbnail\n                (self, vid);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_time_get_type:\n *\n * GType system helper function\n *\n * returns: a #GType\n */\n", "func_signal": "GType\nytv_youtube_time_get_type (void)", "code": "{\n        static GType type = 0;\n\n        if (G_UNLIKELY (type == 0))\n        {\n                static const GEnumValue values[] = {\n                        { YTV_YOUTUBE_TIME_TODAY,\n                          \"YTV_YOUTUBE_TIME_TODAY\", \"today\" },\n                        { YTV_YOUTUBE_TIME_THIS_WEEK,\n                          \"YTV_YOUTUBE_TIME_THIS_WEEK\", \"this_week\" },\n                        { YTV_YOUTUBE_TIME_THIS_MONTH,\n                          \"YTV_YOUTUBE_TIME_THIS_MONTH\", \"this_month\" },\n                        { YTV_YOUTUBE_TIME_ALL_TIME,\n                          \"YTV_YOUTUBE_TIME_ALL_TIME\", \"all_time\" },\n                        { 0, NULL, NULL }\n                };\n\n                type = g_enum_register_static (\"YtvYoutubeTimeType\", values);\n        }\n\n        return type;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_prev_page:\n * @self: a #YtvBrowser\n *\n * Request the prev page in the feed\n *\n * return value: TRUE if it is possible to request the prev page; otherwise\n * FALSE\n */\n", "func_signal": "gboolean\nytv_browser_prev_page (YtvBrowser* self)", "code": "{\n        gboolean retval;\n        \n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->prev_page == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_prev_page\\n\");\n        }\n\n        retval = YTV_BROWSER_GET_IFACE (self)->prev_page (self);\n\n        return retval;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_user_feed:\n * @self: a #YtvUriBuilder\n * @user: (not-null): the username who uploaded the videos to look up\n *\n * Constructs an URI for the feed with the entries uploaded by the specified user.\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_user_feed (YtvUriBuilder* self, const gchar* user)", "code": "{\n        gchar* retval;\n\n        g_assert (user != NULL);\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_user_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_user_feed\n                (self, user);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_current_feed:\n * @self: a #YtvUriBuilder\n *\n * Reconstructs the URI for the previous requested feed\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_current_feed (YtvUriBuilder* self)", "code": "{\n        gchar* retval;\n\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_current_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_current_feed\n                (self);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_alt_get_type:\n *\n * GType system helper function\n *\n * returns: a #GType\n */\n", "func_signal": "GType\nytv_youtube_alt_get_type (void)", "code": "{\n        static GType type = 0;\n\n        if (G_UNLIKELY (type == 0))\n        {\n                static const GEnumValue values[] = {\n                        { YTV_YOUTUBE_ALT_ATOM,\n                          \"YTV_YOUTUBE_ALT_ATOM\", \"atom\" },\n                        { YTV_YOUTUBE_ALT_RSS,\n                          \"YTV_YOUTUBE_ALT_RSS\", \"rss\" },\n                        { YTV_YOUTUBE_ALT_JSON,\n                          \"YTV_YOUTUBE_ALT_JSON\", \"json\" },\n                        { YTV_YOUTUBE_ALT_JSON_IN_SCRIPT,\n                          \"YTV_YOUTUBE_ALT_JSON_IN_SCRIPT\", \"json-in-script\" },\n                        { 0, NULL, NULL }\n                };\n\n                type = g_enum_register_static (\"YtvYoutubeAltType\", values);\n        }\n\n        return type;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_list_copy:\n * @self: An #YtvList instance\n *\n * Creates a shallow copy of the list. It doesn't copy the items. It,\n * however, creates a new list with new references to the same\n * items. The items will get an extra reference added for the new list\n * being their second parent, setting their reference count to for\n * example two. Which means that both lists (the original and the\n * copy) must be unreferenced after use.\n *\n * Return value: A copy of this list\n *\n **/\n", "func_signal": "YtvList*\nytv_list_copy (YtvList *self)", "code": "{\n        YtvList *retval;\n\n        g_assert (YTV_IS_LIST (self));\n        g_assert (YTV_LIST_GET_IFACE (self)->copy_func != NULL);\n\n        retval = YTV_LIST_GET_IFACE (self)->copy_func (self);\n\n        g_assert (YTV_IS_LIST (retval));\n\n        return retval;\n}", "path": "src\\ytv-list.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_get_feed:\n * @self: a #YtvBrowser\n *\n * returns: (not-null) (caller-owns): The displayed #YtvFeed\n */\n", "func_signal": "YtvFeed*\nytv_browser_get_feed (YtvBrowser* self)", "code": "{\n        YtvFeed* retval;\n        \n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->get_feed == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_get_feed\\n\");\n        }\n\n        retval = YTV_BROWSER_GET_IFACE (self)->get_feed (self);\n\n        g_assert (retval != NULL);\n\n        return retval;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_search_feed:\n * @self: a #YtvUriBuilder\n * @query: (not-null): a string to search\n *\n * Constructs an URI for the feed with the results of the search\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_search_feed (YtvUriBuilder* self, const gchar* query)", "code": "{\n        gchar* retval;\n\n        g_assert (query != NULL);\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_standard_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->search_feed\n                (self, query);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_get_focused_entry_view:\n * @self: a #YtvBrowser\n *\n * Get the currently focused #YtvEntryView\n *\n * returns: (not-null) (caller-owns): The focused #YtvEntryView\n */\n", "func_signal": "YtvEntryView*\nytv_browser_get_focused_entry_view (YtvBrowser* self)", "code": "{\n        YtvEntryView* retval;\n\n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->get_focused_entry_view == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_get_focused_entry_view\\n\");\n        }\n\n        retval = YTV_BROWSER_GET_IFACE (self)->get_focused_entry_view (self);\n\n        g_assert (retval != NULL);\n        \n        return retval;\n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_youtube_uri_builder_get_keywords_feed:\n * @self: a #YtvUriBuilder\n * @category: (null-ok): the category to browse\n * @keywords: (null-ok): the space separated keywords list to browse\n *\n * Constructs an URI for the feed with the entries in the category or tagged\n * by the keywords string.\n *\n * returns: (null-ok): (caller-owns): the URI string representing the resource.\n * The string must be freed after use.\n */\n", "func_signal": "gchar*\nytv_youtube_uri_builder_get_keywords_feed (YtvUriBuilder* self, const gchar* category,\n                                           const gchar* keywords)", "code": "{\n        gchar* retval;\n\n        g_assert (category != NULL || keywords != NULL);\n        g_assert (YTV_IS_YOUTUBE_URI_BUILDER (self));\n        g_assert (YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_keywords_feed != NULL);\n\n        retval = YTV_YOUTUBE_URI_BUILDER_GET_CLASS (self)->get_keywords_feed\n                (self, category, keywords);\n\n        return retval;\n}", "path": "src\\ytv-youtube-uri-builder.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/**\n * ytv_browser_clean:\n * @self: a #YtvBrowser\n *\n * Will remove the displayed #YtvFeed\n */\n", "func_signal": "void\nytv_browser_clean (YtvBrowser* self)", "code": "{\n        g_assert (YTV_IS_BROWSER (self));\n\n        if (YTV_BROWSER_GET_IFACE (self)->clean == NULL)\n        {\n                g_critical (\"You must implement ytv_browser_clean\\n\");\n        }\n\n        YTV_BROWSER_GET_IFACE (self)->clean (self);\n\n        return;        \n}", "path": "src\\ytv-browser.c", "repo_name": "ceyusa/ytv", "stars": 5, "license": "None", "language": "c", "size": 312}
{"docstring": "/* -------------------------------- lists -------------------------------- */\n", "func_signal": "static s7_pointer s7_immutable_cons(s7_scheme *sc, s7_pointer a, s7_pointer b)", "code": "{\n  s7_pointer x;\n  x = new_cell(sc); /* might trigger gc, expansion here does not help */\n  car(x) = a;\n  cdr(x) = b;\n  set_type(x, T_PAIR | T_IMMUTABLE);\n  return(x);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* should (min 1 1.5) return 1? */\n", "func_signal": "static s7_pointer g_max(s7_scheme *sc, s7_pointer args)", "code": "{\n  #define H_max \"(max ...) returns the maximum of its arguments\"\n  int i;\n  s7_pointer x;\n  s7_num_t n;\n\n  if (!s7_is_real(car(args)))\n    return(s7_wrong_type_arg_error(sc, \"max\", 1, car(args), \"a real\"));\n\n  n = number(car(args));\n  for (i = 2, x = cdr(args); x != sc->NIL; i++, x = cdr(x)) \n    {\n      if (!s7_is_real(car(x)))\n\treturn(s7_wrong_type_arg_error(sc, \"max\", i, car(x), \"a real\"));\n      n = num_max(n, number(car(x)));\n    }\n  return(make_number(sc, n));\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* initialized later */\n", "func_signal": "static s7_num_t num_add(s7_num_t a, s7_num_t b)", "code": "{\n  s7_num_t ret;\n  ret.type = a.type | b.type;\n  \n  switch (num_type(ret))\n    {\n    case NUM_INT: \n      integer(ret) = integer(a) + integer(b);\n      break;\n      \n    case NUM_RATIO:\n      {\n\ts7_Int d1, d2, n1, n2;\n\td1 = num_to_denominator(a);\n\tn1 = num_to_numerator(a);\n\td2 = num_to_denominator(b);\n\tn2 = num_to_numerator(b);\n\tif (d1 == d2)                                     /* the easy case -- if overflow here, it matches the int case */\n\t  return(make_ratio(n1 + n2, d1));                /* d1 can't be zero */\n\n#if (!WITH_GMP)\n\tif ((d1 > s7_int_max) || (d2 > s7_int_max) ||     /* before counting bits, check that overflow is possible */\n\t    (n1 > s7_int_max) || (n2 > s7_int_max) ||\n\t    (n1 < s7_int_min) || (n2 < s7_int_min))\n\t  {\n\t    int d1bits, d2bits;\n\t    d1bits = integer_length(d1);\n\t    d2bits = integer_length(d2);\n\t    if (((d1bits + d2bits) > s7_int_bits) ||\n\t\t((d1bits + integer_length(n2)) > (s7_int_bits - 1)) ||\n\t\t((d2bits + integer_length(n1)) > (s7_int_bits - 1)))\n\t      return(make_real(((long double)n1 / (long double)d1) + ((long double)n2 / (long double)d2)));\n\t  }\n#endif\n\treturn(make_ratio(n1 * d2 + n2 * d1, d1 * d2));\n      }\n      break;\n      \n    case NUM_REAL2:\n    case NUM_REAL:\n      real(ret) = num_to_real(a) + num_to_real(b);\n      break;\n      \n    default:\n      /* NUM_COMPLEX is 4 separate types */\n      return(make_complex(num_to_real_part(a) + num_to_real_part(b),\n\t\t\t  num_to_imag_part(a) + num_to_imag_part(b)));\n      break;\n    }\n  return(ret);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* (string-ref (with-output-to-string (lambda () (write \"1234\") (values (get-output-string) 1)))) */\n", "func_signal": "static s7_pointer g_with_output_to_file(s7_scheme *sc, s7_pointer args)", "code": "{\n  #define H_with_output_to_file \"(with-output-to-file filename thunk) opens filename as the temporary current-output-port and calls thunk\"\n  s7_pointer old_output_port;\n  \n  if (!s7_is_string(car(args)))\n    return(s7_wrong_type_arg_error(sc, \"with-output-to-file\", 1, car(args), \"a string (a filename)\"));\n  if (!is_thunk(sc, cadr(args)))\n    return(s7_wrong_type_arg_error(sc, \"with-output-to-file\", 2, cadr(args), \"a thunk\"));\n  \n  old_output_port = sc->output_port;\n  sc->output_port = s7_open_output_file(sc, s7_string(car(args)), \"w\");\n  push_stack(sc, OP_UNWIND_OUTPUT, old_output_port, sc->output_port);\n  sc->code = cadr(args);\n  sc->args = sc->NIL;\n  eval(sc, OP_APPLY);\n  s7_close_output_port(sc, sc->output_port);\n  sc->output_port = old_output_port;\n\n  if ((is_pair(sc->value)) &&            \n      (car(sc->value) == sc->VALUES))\n    sc->value = splice_in_values(sc, cdr(sc->value));\n\n  return(sc->value);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- initialization -------------------------------- */\n", "func_signal": "s7_scheme *s7_init(void)", "code": "{\n  int i;\n  s7_scheme *sc;\n  \n  init_ctables();\n  \n  sc = (s7_scheme *)calloc(1, sizeof(s7_scheme)); /* malloc is not recommended here */\n#if HAVE_PTHREADS\n  sc->orig_sc = sc;\n#endif\n  \n  sc->gc_off = (bool *)calloc(1, sizeof(bool));\n  (*(sc->gc_off)) = true;                         /* sc->args and so on are not set yet, so a gc during init -> segfault */\n  sc->longjmp_ok = false;\n  \n  sc->strbuf_size = INITIAL_STRBUF_SIZE;\n  sc->strbuf = (char *)calloc(sc->strbuf_size, sizeof(char));\n  \n  sc->read_line_buf = NULL;\n  sc->read_line_buf_size = 0;\n\n  sc->NIL = &sc->_NIL;\n  sc->T = &sc->_T;\n  sc->F = &sc->_F;\n  sc->EOF_OBJECT = &sc->_EOF_OBJECT;\n  sc->UNSPECIFIED = &sc->_UNSPECIFIED;  \n  sc->UNDEFINED = &sc->_UNDEFINED;\n\n  set_type(sc->NIL, T_NIL | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->NIL) = cdr(sc->NIL) = sc->UNSPECIFIED;\n  \n  set_type(sc->T, T_BOOLEAN | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->T) = cdr(sc->T) = sc->UNSPECIFIED;\n  \n  set_type(sc->F, T_BOOLEAN | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->F) = cdr(sc->F) = sc->UNSPECIFIED;\n  \n  set_type(sc->EOF_OBJECT, T_UNTYPED | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->EOF_OBJECT) = cdr(sc->EOF_OBJECT) = sc->UNSPECIFIED;\n  \n  set_type(sc->UNSPECIFIED, T_UNTYPED | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->UNSPECIFIED) = cdr(sc->UNSPECIFIED) = sc->UNSPECIFIED;\n  \n  set_type(sc->UNDEFINED, T_UNTYPED | T_ATOM | T_GC_MARK | T_IMMUTABLE | T_SIMPLE | T_DONT_COPY);\n  car(sc->UNDEFINED) = cdr(sc->UNDEFINED) = sc->UNSPECIFIED;\n  \n  sc->nil_vector = (s7_pointer *)malloc(BLOCK_VECTOR_SIZE * sizeof(s7_pointer));\n  sc->unspecified_vector = (s7_pointer *)malloc(BLOCK_VECTOR_SIZE * sizeof(s7_pointer));\n  for (i = 0; i < BLOCK_VECTOR_SIZE; i++) \n    {\n      sc->nil_vector[i] = sc->NIL;\n      sc->unspecified_vector[i] = sc->UNSPECIFIED;\n    }\n\n  sc->input_port = sc->NIL;\n  sc->input_port_stack = sc->NIL;\n  sc->output_port = sc->NIL;\n  sc->error_port = sc->NIL;\n  \n  sc->code = sc->NIL;\n  sc->cur_code = ERROR_INFO_DEFAULT;\n  sc->args = sc->NIL;\n  sc->value = sc->NIL;\n  sc->x = sc->NIL;\n  sc->y = sc->NIL;\n  sc->z = sc->NIL;\n  sc->error_exiter = NULL;\n  sc->default_rng = NULL;\n  \n  sc->heap_size = INITIAL_HEAP_SIZE;\n  sc->heap = (s7_pointer *)malloc((sc->heap_size + 1) * sizeof(s7_pointer));\n  \n  sc->free_heap = (s7_cell **)malloc(sc->heap_size * sizeof(s7_cell *));\n  sc->free_heap_top = INITIAL_HEAP_SIZE;\n  {\n    s7_cell *cells = (s7_cell *)calloc(INITIAL_HEAP_SIZE, sizeof(s7_cell));\n    for (i = 0; i < INITIAL_HEAP_SIZE; i++)\n      {\n\tsc->heap[i] = &cells[i];\n \tsc->free_heap[i] = sc->heap[i];\n \tsc->heap[i]->hloc = i;\n      }\n    sc->heap[sc->heap_size] = NULL;\n  }\n  \n  /* this has to precede s7_make_* allocations */\n  sc->temps_size = GC_TEMPS_SIZE;\n  sc->temps_ctr = 0;\n  sc->temps = (s7_pointer *)malloc(sc->temps_size * sizeof(s7_pointer));\n  for (i = 0; i < sc->temps_size; i++)\n    sc->temps[i] = sc->NIL;\n\n  sc->circular_refs = (s7_pointer *)calloc(CIRCULAR_REFS_SIZE, sizeof(s7_pointer));\n  \n  sc->protected_objects_size = (int *)malloc(sizeof(int));\n  (*(sc->protected_objects_size)) = INITIAL_PROTECTED_OBJECTS_SIZE;\n  sc->protected_objects_loc = (int *)malloc(sizeof(int));\n  (*(sc->protected_objects_loc)) = 0;\n  sc->protected_objects = s7_make_vector(sc, INITIAL_PROTECTED_OBJECTS_SIZE); /* realloc happens to the embedded array, so this pointer is global */\n  set_immutable(sc->protected_objects);\n  typeflag(sc->protected_objects) |= T_DONT_COPY;\n  \n  sc->stack_top = 0;\n  sc->stack = s7_make_vector(sc, INITIAL_STACK_SIZE);\n  sc->stack_size = INITIAL_STACK_SIZE;\n  sc->stack_size2 = sc->stack_size / 2;\n  \n  /* keep the symbol table out of the heap */\n  sc->symbol_table = (s7_pointer)calloc(1, sizeof(s7_cell));\n  set_type(sc->symbol_table, T_VECTOR | T_FINALIZABLE | T_DONT_COPY);\n  vector_length(sc->symbol_table) = SYMBOL_TABLE_SIZE;\n  vector_elements(sc->symbol_table) = (s7_pointer *)malloc(SYMBOL_TABLE_SIZE * sizeof(s7_pointer));\n  s7_vector_fill(sc, sc->symbol_table, sc->NIL);\n  sc->symbol_table->hloc = NOT_IN_HEAP;\n  \n  sc->gensym_counter = (long *)calloc(1, sizeof(long));\n  sc->tracing = (bool *)calloc(1, sizeof(bool));\n  sc->trace_all = (bool *)calloc(1, sizeof(bool));\n\n#if WITH_ENCAPSULATION\n  sc->encapsulators = sc->NIL;\n#endif\n\n  sc->trace_list = (s7_pointer *)calloc(INITIAL_TRACE_LIST_SIZE, sizeof(s7_pointer));\n  sc->trace_list_size = INITIAL_TRACE_LIST_SIZE;\n  sc->trace_top = 0;\n  sc->trace_depth = 0;\n\n#if HAVE_PTHREADS\n  sc->thread_ids = (int *)calloc(1, sizeof(int));\n  sc->thread_id = 0;\n  sc->key_values = sc->NIL;\n#endif\n  \n  sc->global_env = s7_cons(sc, s7_make_vector(sc, SYMBOL_TABLE_SIZE), sc->NIL);\n  sc->envir = sc->global_env;\n  \n  /* keep the small_ints out of the heap */\n  sc->small_ints = (s7_pointer *)malloc((NUM_SMALL_INTS + 1) * sizeof(s7_pointer));\n  for (i = 0; i <= NUM_SMALL_INTS; i++) \n    {\n      s7_pointer p;\n      p = (s7_pointer)calloc(1, sizeof(s7_cell));\n      p->flag = T_OBJECT | T_IMMUTABLE | T_ATOM | T_NUMBER | T_SIMPLE | T_DONT_COPY;\n      p->hloc = NOT_IN_HEAP;\n      number_type(p) = NUM_INT;\n      integer(number(p)) = (s7_Int)i;\n      sc->small_ints[i] = p;\n    }\n  \n  sc->real_zero = (s7_pointer)calloc(1, sizeof(s7_cell));\n  sc->real_zero->flag = T_OBJECT | T_IMMUTABLE | T_ATOM | T_NUMBER | T_SIMPLE | T_DONT_COPY;\n  sc->real_zero->hloc = NOT_IN_HEAP;\n  number_type(sc->real_zero) = NUM_REAL;\n  real(number(sc->real_zero)) = (s7_Double)0.0;\n\n  sc->real_one = (s7_pointer)calloc(1, sizeof(s7_cell));\n  sc->real_one->flag = T_OBJECT | T_IMMUTABLE | T_ATOM | T_NUMBER | T_SIMPLE | T_DONT_COPY;\n  sc->real_one->hloc = NOT_IN_HEAP;\n  number_type(sc->real_one) = NUM_REAL;\n  real(number(sc->real_one)) = (s7_Double)1.0;\n\n  /* initialization of global pointers to special symbols */\n  assign_syntax(sc, \"lambda\",            OP_LAMBDA);\n  assign_syntax(sc, \"lambda*\",           OP_LAMBDA_STAR);      /* part of define* */\n  assign_syntax(sc, \"quote\",             OP_QUOTE);\n  assign_syntax(sc, \"define\",            OP_DEFINE0);\n  assign_syntax(sc, \"define*\",           OP_DEFINE_STAR);\n  assign_syntax(sc, \"define-constant\",   OP_DEFINE_CONSTANT0);\n  assign_syntax(sc, \"if\",                OP_IF0);\n  assign_syntax(sc, \"begin\",             OP_BEGIN);\n  assign_syntax(sc, \"set!\",              OP_SET0);\n  assign_syntax(sc, \"let\",               OP_LET0);\n  assign_syntax(sc, \"let*\",              OP_LET_STAR0);\n  assign_syntax(sc, \"letrec\",            OP_LETREC0);\n  assign_syntax(sc, \"cond\",              OP_COND0);\n  assign_syntax(sc, \"and\",               OP_AND0);\n  assign_syntax(sc, \"or\",                OP_OR0);\n  assign_syntax(sc, \"case\",              OP_CASE0);\n  assign_syntax(sc, \"macro\",             OP_MACRO0);           /* r4rs macro syntax, I think */\n  assign_syntax(sc, \"defmacro\",          OP_DEFMACRO);         /* CL-style macro syntax */\n  assign_syntax(sc, \"defmacro*\",         OP_DEFMACRO_STAR);\n  assign_syntax(sc, \"define-macro\",      OP_DEFINE_MACRO);     /* Scheme-style macro syntax */\n  assign_syntax(sc, \"define-macro*\",     OP_DEFINE_MACRO_STAR); \n  assign_syntax(sc, \"define-expansion\",  OP_DEFINE_EXPANSION); /* read-time (immediate) macro expansion */\n  assign_syntax(sc, \"do\",                OP_DO);\n  assign_syntax(sc, \"with-environment\",  OP_WITH_ENV0);\n  \n  sc->LAMBDA = s7_make_symbol(sc, \"lambda\");\n  typeflag(sc->LAMBDA) |= T_DONT_COPY; \n  \n  sc->LAMBDA_STAR = s7_make_symbol(sc, \"lambda*\");\n  typeflag(sc->LAMBDA_STAR) |= T_DONT_COPY; \n  \n  sc->QUOTE = s7_make_symbol(sc, \"quote\");\n  typeflag(sc->QUOTE) |= T_DONT_COPY; \n  \n  sc->QUASIQUOTE = s7_make_symbol(sc, \"quasiquote\");\n  typeflag(sc->QUASIQUOTE) |= T_DONT_COPY;  /* add the immutable bit later */\n  \n  sc->UNQUOTE = s7_make_symbol(sc, \"unquote\");\n  typeflag(sc->UNQUOTE) |= T_DONT_COPY; \n  \n  sc->UNQUOTE_SPLICING = s7_make_symbol(sc, \"unquote-splicing\");\n  typeflag(sc->UNQUOTE_SPLICING) |= T_DONT_COPY; \n  \n  sc->MACROEXPAND = s7_make_symbol(sc, \"macroexpand\");\n  typeflag(sc->MACROEXPAND) |= T_DONT_COPY; \n  \n  sc->FEED_TO = s7_make_symbol(sc, \"=>\");\n  typeflag(sc->FEED_TO) |= T_DONT_COPY; \n  \n  #define object_set_name \"(generalized set!)\"\n  sc->OBJECT_SET = s7_make_symbol(sc, object_set_name);   /* will call g_object_set */\n  typeflag(sc->OBJECT_SET) |= T_DONT_COPY; \n\n  sc->APPLY = s7_make_symbol(sc, \"apply\");\n  typeflag(sc->APPLY) |= T_DONT_COPY; \n  \n  sc->CONS = s7_make_symbol(sc, \"cons\");\n  typeflag(sc->CONS) |= T_DONT_COPY; \n  \n  sc->APPEND = s7_make_symbol(sc, \"append\");\n  typeflag(sc->APPEND) |= T_DONT_COPY; \n  \n  sc->CDR = s7_make_symbol(sc, \"cdr\");\n  typeflag(sc->CDR) |= T_DONT_COPY; \n  \n  sc->ELSE = s7_make_symbol(sc, \"else\");\n  typeflag(sc->ELSE) |= T_DONT_COPY; \n  add_to_current_environment(sc, sc->ELSE, sc->T); \n\n  sc->VECTOR = s7_make_symbol(sc, \"vector\");\n  typeflag(sc->VECTOR) |= T_DONT_COPY; \n  \n  sc->VALUES = s7_make_symbol(sc, \"values\");\n  typeflag(sc->VALUES) |= T_DONT_COPY; \n\n  sc->ERROR = s7_make_symbol(sc, \"error\");\n  typeflag(sc->ERROR) |= T_DONT_COPY; \n\n  sc->WRONG_TYPE_ARG = s7_make_symbol(sc, \"wrong-type-arg\");\n  typeflag(sc->WRONG_TYPE_ARG) |= T_DONT_COPY; \n\n  sc->WRONG_NUMBER_OF_ARGS = s7_make_symbol(sc, \"wrong-number-of-args\");\n  typeflag(sc->WRONG_NUMBER_OF_ARGS) |= T_DONT_COPY; \n\n  sc->FORMAT_ERROR = s7_make_symbol(sc, \"format-error\");\n  typeflag(sc->FORMAT_ERROR) |= T_DONT_COPY; \n\n  sc->OUT_OF_RANGE = s7_make_symbol(sc, \"out-of-range\");\n  typeflag(sc->OUT_OF_RANGE) |= T_DONT_COPY; \n\n  sc->KEY_KEY = s7_make_keyword(sc, \"key\");\n  typeflag(sc->KEY_KEY) |= T_DONT_COPY; \n  \n  sc->KEY_OPTIONAL = s7_make_keyword(sc, \"optional\");\n  typeflag(sc->KEY_OPTIONAL) |= T_DONT_COPY; \n  \n  sc->KEY_REST = s7_make_keyword(sc, \"rest\");\n  typeflag(sc->KEY_REST) |= T_DONT_COPY; \n\n  sc->__FUNC__ = s7_make_symbol(sc, \"__func__\");\n  typeflag(sc->__FUNC__) |= T_DONT_COPY; \n\n  sc->ERROR_HOOK = s7_make_symbol(sc, \"*error-hook*\");\n  typeflag(sc->ERROR_HOOK) |= T_DONT_COPY; \n\n  sc->TRACE_HOOK = s7_make_symbol(sc, \"*trace-hook*\");\n  typeflag(sc->TRACE_HOOK) |= T_DONT_COPY; \n\n  sc->SET = s7_make_symbol(sc, \"set!\");\n  typeflag(sc->SET) |= T_DONT_COPY; \n\n  (*(sc->gc_off)) = false;\n\n\n  /* pws first so that make-procedure-with-setter has a type tag */\n  s7_define_function(sc, \"make-procedure-with-setter\",         g_make_procedure_with_setter,         2, 0, false, H_make_procedure_with_setter);\n  s7_define_function(sc, \"procedure-with-setter?\",             g_is_procedure_with_setter,           1, 0, false, H_is_procedure_with_setter);\n  s7_define_function(sc, \"procedure-with-setter-setter-arity\", g_procedure_with_setter_setter_arity, 1, 0, false, \"kludge to get setter's arity\");\n  pws_tag = s7_new_type(\"<procedure-with-setter>\", pws_print, pws_free,\tpws_equal, pws_mark, pws_apply,\tpws_set);\n  \n\n  s7_define_function(sc, \"gensym\",                  g_gensym,                  0, 1, false, H_gensym);\n  s7_define_function(sc, \"symbol-table\",            g_symbol_table,            0, 0, false, H_symbol_table);\n  s7_define_function(sc, \"symbol?\",                 g_is_symbol,               1, 0, false, H_is_symbol);\n  s7_define_function(sc, \"symbol->string\",          g_symbol_to_string,        1, 0, false, H_symbol_to_string);\n  s7_define_function(sc, \"string->symbol\",          g_string_to_symbol,        1, 0, false, H_string_to_symbol);\n  s7_define_function(sc, \"symbol->value\",           g_symbol_to_value,         1, 1, false, H_symbol_to_value);\n#if WITH_PROFILING\n  s7_define_function(sc, \"symbol-calls\",            g_symbol_calls,            1, 0, false, H_symbol_calls);\n#endif\n  \n  s7_define_function(sc, \"global-environment\",      g_global_environment,      0, 0, false, H_global_environment);\n  s7_define_function(sc, \"current-environment\",     g_current_environment,     0, CURRENT_ENVIRONMENT_OPTARGS, false, H_current_environment);\n  s7_define_function(sc, \"provided?\",               g_is_provided,             1, 0, false, H_is_provided);\n  s7_define_function(sc, \"provide\",                 g_provide,                 1, 0, false, H_provide);\n  s7_define_function(sc, \"defined?\",                g_is_defined,              1, 1, false, H_is_defined);\n  s7_define_function(sc, \"constant?\",               g_is_constant,             1, 0, false, H_is_constant);\n\n  \n  s7_define_function(sc, \"keyword?\",                g_is_keyword,              1, 0, false, H_is_keyword);\n  s7_define_function(sc, \"make-keyword\",            g_make_keyword,            1, 0, false, H_make_keyword);\n  s7_define_function(sc, \"symbol->keyword\",         g_symbol_to_keyword,       1, 0, false, H_symbol_to_keyword);\n  s7_define_function(sc, \"keyword->symbol\",         g_keyword_to_symbol,       1, 0, false, H_keyword_to_symbol);\n  \n\n  s7_define_function(sc, \"hash-table?\",             g_is_hash_table,           1, 0, false, H_is_hash_table);\n  s7_define_function(sc, \"make-hash-table\",         g_make_hash_table,         0, 1, false, H_make_hash_table);\n  s7_define_function(sc, \"hash-table-ref\",          g_hash_table_ref,          2, 0, false, H_hash_table_ref);\n  s7_define_set_function(sc, \"hash-table-set!\",     g_hash_table_set,          3, 0, false, H_hash_table_set);\n  s7_define_function(sc, \"hash-table-size\",         g_hash_table_size,         1, 0, false, H_hash_table_size);\n  s7_define_function(sc, \"hash-table-for-each\",     g_hash_table_for_each,     2, 0, true,  H_hash_table_for_each);  \n  \n  s7_define_function(sc, \"port-line-number\",        g_port_line_number,        1, 0, false, H_port_line_number);\n  s7_define_function(sc, \"port-filename\",           g_port_filename,           1, 0, false, H_port_filename);\n  \n  s7_define_function(sc, \"input-port?\",             g_is_input_port,           1, 0, false, H_is_input_port);\n  s7_define_function(sc, \"output-port?\",            g_is_output_port,          1, 0, false, H_is_output_port);\n  s7_define_function(sc, \"char-ready?\",             g_is_char_ready,           0, 1, false, H_is_char_ready);\n  s7_define_function(sc, \"eof-object?\",             g_is_eof_object,           1, 0, false, H_is_eof_object);\n  \n  s7_define_function(sc, \"current-input-port\",      g_current_input_port,      0, 0, false, H_current_input_port);\n  s7_define_function(sc, \"set-current-input-port\",  g_set_current_input_port,  1, 0, false, H_set_current_input_port);\n  s7_define_function(sc, \"current-output-port\",     g_current_output_port,     0, 0, false, H_current_output_port);\n  s7_define_function(sc, \"set-current-output-port\", g_set_current_output_port, 1, 0, false, H_set_current_output_port);\n  s7_define_function(sc, \"current-error-port\",      g_current_error_port,      0, 0, false, H_current_error_port);\n  s7_define_function(sc, \"set-current-error-port\",  g_set_current_error_port,  1, 0, false, H_set_current_error_port);\n  s7_define_function(sc, \"close-input-port\",        g_close_input_port,        1, 0, false, H_close_input_port);\n  s7_define_function(sc, \"close-output-port\",       g_close_output_port,       1, 0, false, H_close_output_port);\n  s7_define_function(sc, \"open-input-file\",         g_open_input_file,         1, 1, false, H_open_input_file);\n  s7_define_function(sc, \"open-output-file\",        g_open_output_file,        1, 1, false, H_open_output_file);\n  s7_define_function(sc, \"open-input-string\",       g_open_input_string,       1, 0, false, H_open_input_string);\n  s7_define_function(sc, \"open-output-string\",      g_open_output_string,      0, 0, false, H_open_output_string);\n  s7_define_function(sc, \"get-output-string\",       g_get_output_string,       1, 0, false, H_get_output_string);\n  \n  s7_define_function(sc, \"read-char\",               g_read_char,               0, 1, false, H_read_char);\n  s7_define_function(sc, \"peek-char\",               g_peek_char,               0, 1, false, H_peek_char);\n  s7_define_function(sc, \"read\",                    g_read,                    0, 1, false, H_read);\n  s7_define_function(sc, \"newline\",                 g_newline,                 0, 1, false, H_newline);\n  s7_define_function(sc, \"write-char\",              g_write_char,              1, 1, false, H_write_char);\n  s7_define_function(sc, \"write\",                   g_write,                   1, 1, false, H_write);\n  s7_define_function(sc, \"display\",                 g_display,                 1, 1, false, H_display);\n  s7_define_function(sc, \"read-byte\",               g_read_byte,               0, 1, false, H_read_byte);\n  s7_define_function(sc, \"write-byte\",              g_write_byte,              1, 1, false, H_write_byte);\n  s7_define_function(sc, \"read-line\",               g_read_line,               0, 2, false, H_read_line);\n  \n  s7_define_function(sc, \"call-with-input-string\",  g_call_with_input_string,  2, 0, false, H_call_with_input_string);\n  s7_define_function(sc, \"call-with-input-file\",    g_call_with_input_file,    2, 0, false, H_call_with_input_file);\n  s7_define_function(sc, \"with-input-from-string\",  g_with_input_from_string,  2, 0, false, H_with_input_from_string);\n  s7_define_function(sc, \"with-input-from-file\",    g_with_input_from_file,    2, 0, false, H_with_input_from_file);\n  \n  s7_define_function(sc, \"call-with-output-string\", g_call_with_output_string, 1, 0, false, H_call_with_output_string);\n  s7_define_function(sc, \"call-with-output-file\",   g_call_with_output_file,   2, 0, false, H_call_with_output_file);\n  s7_define_function(sc, \"with-output-to-string\",   g_with_output_to_string,   1, 0, false, H_with_output_to_string);\n  s7_define_function(sc, \"with-output-to-file\",     g_with_output_to_file,     2, 0, false, H_with_output_to_file);\n  \n  \n  s7_define_function(sc, \"number->string\",          g_number_to_string,        1, 2, false, H_number_to_string);\n  s7_define_function(sc, \"string->number\",          g_string_to_number,        1, 2, false, H_string_to_number);\n  s7_define_function(sc, \"make-polar\",              g_make_polar,              2, 0, false, H_make_polar);\n  s7_define_function(sc, \"make-rectangular\",        g_make_rectangular,        2, 0, false, H_make_rectangular);\n  s7_define_function(sc, \"magnitude\",               g_magnitude,               1, 0, false, H_magnitude);\n  s7_define_function(sc, \"angle\",                   g_angle,                   1, 0, false, H_angle);\n  s7_define_function(sc, \"real-part\",               g_real_part,               1, 0, false, H_real_part);\n  s7_define_function(sc, \"imag-part\",               g_imag_part,               1, 0, false, H_imag_part);\n  s7_define_function(sc, \"numerator\",               g_numerator,               1, 0, false, H_numerator);\n  s7_define_function(sc, \"denominator\",             g_denominator,             1, 0, false, H_denominator);\n  s7_define_function(sc, \"rationalize\",             g_rationalize,             1, 1, false, H_rationalize);\n  s7_define_function(sc, \"abs\",                     g_abs,                     1, 0, false, H_abs);\n  s7_define_function(sc, \"exp\",                     g_exp,                     1, 0, false, H_exp);\n  s7_define_function(sc, \"log\",                     g_log,                     1, 1, false, H_log);\n  s7_define_function(sc, \"sin\",                     g_sin,                     1, 0, false, H_sin);\n  s7_define_function(sc, \"cos\",                     g_cos,                     1, 0, false, H_cos);\n  s7_define_function(sc, \"tan\",                     g_tan,                     1, 0, false, H_tan);\n  s7_define_function(sc, \"asin\",                    g_asin,                    1, 0, false, H_asin);\n  s7_define_function(sc, \"acos\",                    g_acos,                    1, 0, false, H_acos);\n  s7_define_function(sc, \"atan\",                    g_atan,                    1, 1, false, H_atan);\n  s7_define_function(sc, \"sinh\",                    g_sinh,                    1, 0, false, H_sinh);\n  s7_define_function(sc, \"cosh\",                    g_cosh,                    1, 0, false, H_cosh);\n  s7_define_function(sc, \"tanh\",                    g_tanh,                    1, 0, false, H_tanh);\n  s7_define_function(sc, \"asinh\",                   g_asinh,                   1, 0, false, H_asinh);\n  s7_define_function(sc, \"acosh\",                   g_acosh,                   1, 0, false, H_acosh);\n  s7_define_function(sc, \"atanh\",                   g_atanh,                   1, 0, false, H_atanh);\n  s7_define_function(sc, \"sqrt\",                    g_sqrt,                    1, 0, false, H_sqrt);\n  s7_define_function(sc, \"expt\",                    g_expt,                    2, 0, false, H_expt);\n  s7_define_function(sc, \"floor\",                   g_floor,                   1, 0, false, H_floor);\n  s7_define_function(sc, \"ceiling\",                 g_ceiling,                 1, 0, false, H_ceiling);\n  s7_define_function(sc, \"truncate\",                g_truncate,                1, 0, false, H_truncate);\n  s7_define_function(sc, \"round\",                   g_round,                   1, 0, false, H_round);\n  s7_define_function(sc, \"lcm\",                     g_lcm,                     0, 0, true,  H_lcm);\n  s7_define_function(sc, \"gcd\",                     g_gcd,                     0, 0, true,  H_gcd);\n  s7_define_function(sc, \"+\",                       g_add,                     0, 0, true,  H_add);\n  s7_define_function(sc, \"-\",                       g_subtract,                1, 0, true,  H_subtract);\n  s7_define_function(sc, \"*\",                       g_multiply,                0, 0, true,  H_multiply);\n  s7_define_function(sc, \"/\",                       g_divide,                  1, 0, true,  H_divide);\n  s7_define_function(sc, \"max\",                     g_max,                     1, 0, true,  H_max);\n  s7_define_function(sc, \"min\",                     g_min,                     1, 0, true,  H_min);\n  s7_define_function(sc, \"quotient\",                g_quotient,                2, 0, false, H_quotient);\n  s7_define_function(sc, \"remainder\",               g_remainder,               2, 0, false, H_remainder);\n  s7_define_function(sc, \"modulo\",                  g_modulo,                  2, 0, false, H_modulo);\n  s7_define_function(sc, \"=\",                       g_equal,                   2, 0, true,  H_equal);\n  s7_define_function(sc, \"<\",                       g_less,                    2, 0, true,  H_less);\n  s7_define_function(sc, \">\",                       g_greater,                 2, 0, true,  H_greater);\n  s7_define_function(sc, \"<=\",                      g_less_or_equal,           2, 0, true,  H_less_or_equal);\n  s7_define_function(sc, \">=\",                      g_greater_or_equal,        2, 0, true,  H_greater_or_equal);\n  s7_define_function(sc, \"number?\",                 g_is_number,               1, 0, false, H_is_number);\n  s7_define_function(sc, \"integer?\",                g_is_integer,              1, 0, false, H_is_integer);\n  s7_define_function(sc, \"real?\",                   g_is_real,                 1, 0, false, H_is_real);\n  s7_define_function(sc, \"complex?\",                g_is_complex,              1, 0, false, H_is_complex);\n  s7_define_function(sc, \"rational?\",               g_is_rational,             1, 0, false, H_is_rational);\n  s7_define_function(sc, \"even?\",                   g_is_even,                 1, 0, false, H_is_even);\n  s7_define_function(sc, \"odd?\",                    g_is_odd,                  1, 0, false, H_is_odd);\n  s7_define_function(sc, \"zero?\",                   g_is_zero,                 1, 0, false, H_is_zero);\n  s7_define_function(sc, \"positive?\",               g_is_positive,             1, 0, false, H_is_positive);\n  s7_define_function(sc, \"negative?\",               g_is_negative,             1, 0, false, H_is_negative);\n  s7_define_function(sc, \"inexact->exact\",          g_inexact_to_exact,        1, 0, false, H_inexact_to_exact);\n  s7_define_function(sc, \"exact->inexact\",          g_exact_to_inexact,        1, 0, false, H_exact_to_inexact);\n  s7_define_function(sc, \"exact?\",                  g_is_exact,                1, 0, false, H_is_exact);\n  s7_define_function(sc, \"inexact?\",                g_is_inexact,              1, 0, false, H_is_inexact);\n\n  s7_define_function(sc, \"integer-length\",          g_integer_length,          1, 0, false, H_integer_length);\n  s7_define_function(sc, \"logior\",                  g_logior,                  1, 0, true,  H_logior);\n  s7_define_function(sc, \"logxor\",                  g_logxor,                  1, 0, true,  H_logxor);\n  s7_define_function(sc, \"logand\",                  g_logand,                  1, 0, true,  H_logand);\n  s7_define_function(sc, \"lognot\",                  g_lognot,                  1, 0, false, H_lognot);\n  s7_define_function(sc, \"ash\",                     g_ash,                     2, 0, false, H_ash);\n  \n  rng_tag = s7_new_type_x(\"<random-number-generator>\", print_rng, free_rng, equal_rng, NULL, NULL, NULL, NULL, copy_random_state, NULL);\n  s7_define_function(sc, \"random\",                  g_random,                  1, 1, false, H_random);\n  s7_define_function(sc, \"make-random-state\",       g_make_random_state,       1, 0, false, H_make_random_state);\n\n  \n  s7_define_function(sc, \"char-upcase\",             g_char_upcase,             1, 0, false, H_char_upcase);\n  s7_define_function(sc, \"char-downcase\",           g_char_downcase,           1, 0, false, H_char_downcase);\n  s7_define_function(sc, \"char->integer\",           g_char_to_integer,         1, 0, false, H_char_to_integer);\n  s7_define_function(sc, \"integer->char\",           g_integer_to_char,         1, 0, false, H_integer_to_char);\n  \n  s7_define_function(sc, \"char-upper-case?\",        g_is_char_upper_case,      1, 0, false, H_is_char_upper_case);\n  s7_define_function(sc, \"char-lower-case?\",        g_is_char_lower_case,      1, 0, false, H_is_char_lower_case);\n  s7_define_function(sc, \"char-alphabetic?\",        g_is_char_alphabetic,      1, 0, false, H_is_char_alphabetic);\n  s7_define_function(sc, \"char-numeric?\",           g_is_char_numeric,         1, 0, false, H_is_char_numeric);\n  s7_define_function(sc, \"char-whitespace?\",        g_is_char_whitespace,      1, 0, false, H_is_char_whitespace);\n  s7_define_function(sc, \"char?\",                   g_is_char,                 1, 0, false, H_is_char);\n  \n  s7_define_function(sc, \"char=?\",                  g_chars_are_equal,         2, 0, true,  H_chars_are_equal);\n  s7_define_function(sc, \"char<?\",                  g_chars_are_less,          2, 0, true,  H_chars_are_less);\n  s7_define_function(sc, \"char>?\",                  g_chars_are_greater,       2, 0, true,  H_chars_are_greater);\n  s7_define_function(sc, \"char<=?\",                 g_chars_are_leq,           2, 0, true,  H_chars_are_leq);\n  s7_define_function(sc, \"char>=?\",                 g_chars_are_geq,           2, 0, true,  H_chars_are_geq);\n  s7_define_function(sc, \"char-ci=?\",               g_chars_are_ci_equal,      2, 0, true,  H_chars_are_ci_equal);\n  s7_define_function(sc, \"char-ci<?\",               g_chars_are_ci_less,       2, 0, true,  H_chars_are_ci_less);\n  s7_define_function(sc, \"char-ci>?\",               g_chars_are_ci_greater,    2, 0, true,  H_chars_are_ci_greater);\n  s7_define_function(sc, \"char-ci<=?\",              g_chars_are_ci_leq,        2, 0, true,  H_chars_are_ci_leq);\n  s7_define_function(sc, \"char-ci>=?\",              g_chars_are_ci_geq,        2, 0, true,  H_chars_are_ci_geq);\n  \n  \n  s7_define_function(sc, \"string?\",                 g_is_string,               1, 0, false, H_is_string);\n  s7_define_function(sc, \"make-string\",             g_make_string,             1, 1, false, H_make_string);\n  s7_define_function(sc, \"string-length\",           g_string_length,           1, 0, false, H_string_length);\n  s7_define_function(sc, \"string-ref\",              g_string_ref,              2, 0, false, H_string_ref);\n  s7_define_set_function(sc, \"string-set!\",         g_string_set,              3, 0, false, H_string_set);\n  \n  s7_define_function(sc, \"string=?\",                g_strings_are_equal,       2, 0, true,  H_strings_are_equal);\n  s7_define_function(sc, \"string<?\",                g_strings_are_less,        2, 0, true,  H_strings_are_less);\n  s7_define_function(sc, \"string>?\",                g_strings_are_greater,     2, 0, true,  H_strings_are_greater);\n  s7_define_function(sc, \"string<=?\",               g_strings_are_leq,         2, 0, true,  H_strings_are_leq);\n  s7_define_function(sc, \"string>=?\",               g_strings_are_geq,         2, 0, true,  H_strings_are_geq);\n  s7_define_function(sc, \"string-ci=?\",             g_strings_are_ci_equal,    2, 0, true,  H_strings_are_ci_equal);\n  s7_define_function(sc, \"string-ci<?\",             g_strings_are_ci_less,     2, 0, true,  H_strings_are_ci_less);\n  s7_define_function(sc, \"string-ci>?\",             g_strings_are_ci_greater,  2, 0, true,  H_strings_are_ci_greater);\n  s7_define_function(sc, \"string-ci<=?\",            g_strings_are_ci_leq,      2, 0, true,  H_strings_are_ci_leq);\n  s7_define_function(sc, \"string-ci>=?\",            g_strings_are_ci_geq,      2, 0, true,  H_strings_are_ci_geq);\n  \n  s7_define_function(sc, \"string-append\",           g_string_append,           0, 0, true,  H_string_append);\n  s7_define_set_function(sc, \"string-fill!\",        g_string_fill,             2, 0, false, H_string_fill);\n  s7_define_function(sc, \"string-copy\",             g_string_copy,             1, 0, false, H_string_copy);\n  s7_define_function(sc, \"substring\",               g_substring,               2, 1, false, H_substring);\n  s7_define_function(sc, \"string\",                  g_string,                  0, 0, true,  H_string);\n  s7_define_function(sc, \"list->string\",            g_list_to_string,          1, 0, false, H_list_to_string);\n  s7_define_function(sc, \"string->list\",            g_string_to_list,          1, 0, false, H_string_to_list);\n  s7_define_function(sc, \"object->string\",          g_object_to_string,        1, 0, false, H_object_to_string);\n  s7_define_function(sc, \"format\",                  g_format,                  1, 0, true,  H_format);\n  s7_define_function(sc, \"string-for-each\",         g_string_for_each,         2, 0, true,  H_string_for_each);  \n\n\n  s7_define_function(sc, \"null?\",                   g_is_null,                 1, 0, false, H_is_null);\n  s7_define_function(sc, \"list?\",                   g_is_list,                 1, 0, false, H_is_list);\n  s7_define_function(sc, \"pair?\",                   g_is_pair,                 1, 0, false, H_is_pair);\n  s7_define_function(sc, \"reverse\",                 g_reverse,                 1, 0, false, H_reverse);\n  s7_define_set_function(sc, \"reverse!\",            g_reverse_in_place,        1, 0, false, H_reverse_in_place); /* used by Snd code */\n  s7_define_function(sc, \"cons\",                    g_cons,                    2, 0, false, H_cons);\n  s7_define_function(sc, \"car\",                     g_car,                     1, 0, false, H_car);\n  s7_define_function(sc, \"cdr\",                     g_cdr,                     1, 0, false, H_cdr);\n  s7_define_function(sc, \"set-car!\",                g_set_car,                 2, 0, false, H_set_car);\n  s7_define_function(sc, \"set-cdr!\",                g_set_cdr,                 2, 0, false, H_set_cdr);\n  s7_define_function(sc, \"caar\",                    g_caar,                    1, 0, false, H_caar);\n  s7_define_function(sc, \"cadr\",                    g_cadr,                    1, 0, false, H_cadr);\n  s7_define_function(sc, \"cdar\",                    g_cdar,                    1, 0, false, H_cdar);\n  s7_define_function(sc, \"cddr\",                    g_cddr,                    1, 0, false, H_cddr);\n  s7_define_function(sc, \"caaar\",                   g_caaar,                   1, 0, false, H_caaar);\n  s7_define_function(sc, \"caadr\",                   g_caadr,                   1, 0, false, H_caadr);\n  s7_define_function(sc, \"cadar\",                   g_cadar,                   1, 0, false, H_cadar);\n  s7_define_function(sc, \"cdaar\",                   g_cdaar,                   1, 0, false, H_cdaar);\n  s7_define_function(sc, \"caddr\",                   g_caddr,                   1, 0, false, H_caddr);\n  s7_define_function(sc, \"cdddr\",                   g_cdddr,                   1, 0, false, H_cdddr);\n  s7_define_function(sc, \"cdadr\",                   g_cdadr,                   1, 0, false, H_cdadr);\n  s7_define_function(sc, \"cddar\",                   g_cddar,                   1, 0, false, H_cddar);\n  s7_define_function(sc, \"caaaar\",                  g_caaaar,                  1, 0, false, H_caaaar);\n  s7_define_function(sc, \"caaadr\",                  g_caaadr,                  1, 0, false, H_caaadr);\n  s7_define_function(sc, \"caadar\",                  g_caadar,                  1, 0, false, H_caadar);\n  s7_define_function(sc, \"cadaar\",                  g_cadaar,                  1, 0, false, H_cadaar);\n  s7_define_function(sc, \"caaddr\",                  g_caaddr,                  1, 0, false, H_caaddr);\n  s7_define_function(sc, \"cadddr\",                  g_cadddr,                  1, 0, false, H_cadddr);\n  s7_define_function(sc, \"cadadr\",                  g_cadadr,                  1, 0, false, H_cadadr);\n  s7_define_function(sc, \"caddar\",                  g_caddar,                  1, 0, false, H_caddar);\n  s7_define_function(sc, \"cdaaar\",                  g_cdaaar,                  1, 0, false, H_cdaaar);\n  s7_define_function(sc, \"cdaadr\",                  g_cdaadr,                  1, 0, false, H_cdaadr);\n  s7_define_function(sc, \"cdadar\",                  g_cdadar,                  1, 0, false, H_cdadar);\n  s7_define_function(sc, \"cddaar\",                  g_cddaar,                  1, 0, false, H_cddaar);\n  s7_define_function(sc, \"cdaddr\",                  g_cdaddr,                  1, 0, false, H_cdaddr);\n  s7_define_function(sc, \"cddddr\",                  g_cddddr,                  1, 0, false, H_cddddr);\n  s7_define_function(sc, \"cddadr\",                  g_cddadr,                  1, 0, false, H_cddadr);\n  s7_define_function(sc, \"cdddar\",                  g_cdddar,                  1, 0, false, H_cdddar);\n  s7_define_function(sc, \"assq\",                    g_assq,                    2, 0, false, H_assq);\n  s7_define_function(sc, \"assv\",                    g_assv,                    2, 0, false, H_assv);\n  s7_define_function(sc, \"assoc\",                   g_assoc,                   2, 0, false, H_assoc);\n  s7_define_function(sc, \"memq\",                    g_memq,                    2, 0, false, H_memq);\n  s7_define_function(sc, \"memv\",                    g_memv,                    2, 0, false, H_memv);\n  s7_define_function(sc, \"member\",                  g_member,                  2, 0, false, H_member);\n  s7_define_function(sc, \"append\",                  g_append,                  0, 0, true,  H_append);\n  s7_define_function(sc, \"list\",                    g_list,                    0, 0, true,  H_list);\n  s7_define_function(sc, \"list-ref\",                g_list_ref,                2, 0, false, H_list_ref);\n  s7_define_set_function(sc, \"list-set!\",           g_list_set,                3, 0, false, H_list_set);\n  s7_define_function(sc, \"list-tail\",               g_list_tail,               2, 0, false, H_list_tail);\n  s7_define_function(sc, \"make-list\",               g_make_list,               1, 1, false, H_make_list);\n\n  s7_define_function(sc, \"length\",                  g_length,                  1, 0, false, H_length);\n  s7_define_function(sc, \"copy\",                    g_copy,                    1, 0, false, H_copy);\n  s7_define_set_function(sc, \"fill!\",               g_fill,                    2, 0, false, H_fill);\n  \n  \n  s7_define_function(sc, \"vector?\",                 g_is_vector,               1, 0, false, H_is_vector);\n  s7_define_function(sc, \"vector->list\",            g_vector_to_list,          1, 0, false, H_vector_to_list);\n  s7_define_function(sc, \"list->vector\",            g_list_to_vector,          1, 0, false, H_list_to_vector);\n  s7_define_set_function(sc, \"vector-fill!\",        g_vector_fill,             2, 0, false, H_vector_fill);\n  s7_define_function(sc, \"vector\",                  g_vector,                  0, 0, true,  H_vector);\n  s7_define_function(sc, \"vector-length\",           g_vector_length,           1, 0, false, H_vector_length);\n  s7_define_function(sc, \"vector-ref\",              g_vector_ref,              2, 0, VECTOR_REST_ARGS, H_vector_ref);\n  s7_define_set_function(sc, \"vector-set!\",         g_vector_set,              3, 0, VECTOR_REST_ARGS, H_vector_set);\n  s7_define_function(sc, \"make-vector\",             g_make_vector,             1, 1, false, H_make_vector);\n#if WITH_MULTIDIMENSIONAL_VECTORS\n  s7_define_function(sc, \"vector-dimensions\",       g_vector_dimensions,       1, 0, false, H_vector_dimensions);\n#endif\n  s7_define_function(sc, \"vector-for-each\",         g_vector_for_each,         2, 0, true,  H_vector_for_each);\n  s7_define_function(sc, \"vector-map\",              g_vector_map,              2, 0, true,  H_vector_map);\n  s7_define_set_function(sc, \"sort!\",               g_sort_in_place,           2, 0, false, H_sort_in_place);\n  \n\n  s7_define_function(sc, \"call/cc\",                 g_call_cc,                 1, 0, false, H_call_cc);\n  s7_define_function(sc, \"call-with-current-continuation\", g_call_cc,          1, 0, false, H_call_cc);\n  s7_define_function(sc, \"call-with-exit\",          g_call_with_exit,          1, 0, false, H_call_with_exit);\n  s7_define_function(sc, \"continuation?\",           g_is_continuation,         1, 0, false, H_is_continuation);\n\n  s7_define_function(sc, \"load\",                    g_load,                    1, 1, false, H_load);\n  s7_define_function(sc, \"eval\",                    g_eval,                    1, 1, false, H_eval);\n  s7_define_function(sc, \"eval-string\",             g_eval_string,             1, 1, false, H_eval_string);\n  s7_define_function(sc, \"apply\",                   g_apply,                   1, 0, true,  H_apply);\n  s7_define_function(sc, \"for-each\",                g_for_each,                2, 0, true,  H_list_for_each);\n  s7_define_function(sc, \"map\",                     g_map,                     2, 0, true,  H_list_map);\n\n  s7_define_function(sc, \"values\",                  g_values,                  0, 0, true,  H_values);\n  s7_define_function(sc, \"dynamic-wind\",            g_dynamic_wind,            3, 0, false, H_dynamic_wind);\n  s7_define_function(sc, \"catch\",                   g_catch,                   3, 0, false, H_catch);\n  s7_define_function(sc, \"error\",                   g_error,                   0, 0, true,  H_error);\n  \n  s7_define_function(sc, \"trace\",                   g_trace,                   0, 0, true,  H_trace);\n  s7_define_function(sc, \"untrace\",                 g_untrace,                 0, 0, true,  H_untrace);\n  s7_define_variable(sc, \"*trace-hook*\", sc->NIL);\n\n  s7_define_function(sc, \"stack\",                   g_stack,                   0, 1, false, H_stack);\n  s7_define_function(sc, \"stacktrace\",              g_stacktrace,              0, 1, false, H_stacktrace);\n\n  s7_define_function(sc, \"gc\",                      g_gc,                      0, 1, false, H_gc);\n  s7_define_function(sc, \"quit\",                    g_quit,                    0, 0, false, H_quit);\n\n  s7_define_function(sc, \"procedure?\",              g_is_procedure,            1, 0, false, H_is_procedure);\n  s7_define_function(sc, \"procedure-documentation\", g_procedure_documentation, 1, 0, false, H_procedure_documentation);\n  s7_define_function(sc, \"help\",                    g_procedure_documentation, 1, 0, false, H_procedure_documentation);\n  s7_define_function(sc, \"procedure-arity\",         g_procedure_arity,         1, 0, false, H_procedure_arity);\n  s7_define_function(sc, \"procedure-source\",        g_procedure_source,        1, 0, false, H_procedure_source);\n  s7_define_function(sc, \"procedure-environment\",   g_procedure_environment,   1, 0, false, H_procedure_environment);\n  \n  \n  s7_define_function(sc, \"not\",                     g_not,                     1, 0, false, H_not);\n  s7_define_function(sc, \"boolean?\",                g_is_boolean,              1, 0, false, H_is_boolean);\n  s7_define_function(sc, \"eq?\",                     g_is_eq,                   2, 0, false, H_is_eq);\n  s7_define_function(sc, \"eqv?\",                    g_is_eqv,                  2, 0, false, H_is_eqv);\n  s7_define_function(sc, \"equal?\",                  g_is_equal,                2, 0, false, H_is_equal);\n  \n  s7_define_function(sc, \"s7-version\",              g_s7_version,              0, 0, false, H_s7_version);\n  s7_define_set_function(sc, object_set_name,       g_object_set,              1, 0, true, \"internal setter redirection\");\n  s7_define_function(sc, \"_quasiquote_\",            g_quasiquote,              2, 0, false, \"internal quasiquote handler\");\n  \n  s7_define_variable(sc, \"*features*\", sc->NIL);\n  s7_define_variable(sc, \"*load-path*\", sc->NIL);\n  s7_define_variable(sc, \"*vector-print-length*\", sc->small_ints[8]);\n  s7_define_variable(sc, \"*load-hook*\", sc->NIL);\n\n  s7_define_variable(sc, \"*error-hook*\", sc->NIL);\n  sc->error_info = s7_make_and_fill_vector(sc, ERROR_INFO_SIZE, ERROR_INFO_DEFAULT);\n  s7_define_constant(sc, \"*error-info*\", sc->error_info);\n  \n  g_provide(sc, make_list_1(sc, s7_make_symbol(sc, \"s7\")));\n\n#if HAVE_PTHREADS\n  thread_tag = s7_new_type(\"<thread>\",          thread_print, thread_free, thread_equal, thread_mark, NULL, NULL);\n  lock_tag =   s7_new_type(\"<lock>\",            lock_print,   lock_free,   lock_equal,   NULL,        NULL, NULL);\n  key_tag =    s7_new_type(\"<thread-variable>\", key_print,    key_free,    key_equal,    NULL,        get_key, set_key);\n\n  s7_define_function(sc, \"make-thread\",             g_make_thread,             1, 0, false, H_make_thread);\n  s7_define_function(sc, \"join-thread\",             g_join_thread,             1, 0, false, H_join_thread);\n  s7_define_function(sc, \"thread?\",                 g_is_thread,               1, 0, false, H_is_thread);\n\n  s7_define_function(sc, \"make-lock\",               g_make_lock,               0, 0, false, H_make_lock); /* \"mutex\" is ugly (and opaque) jargon */\n  s7_define_function(sc, \"grab-lock\",               g_grab_lock,               1, 0, false, H_grab_lock);\n  s7_define_function(sc, \"release-lock\",            g_release_lock,            1, 0, false, H_release_lock);\n  s7_define_function(sc, \"lock?\",                   g_is_lock,                 1, 0, false, H_is_lock);\n\n  s7_define_function(sc, \"make-thread-variable\",    g_make_thread_variable,    0, 0, false, H_make_thread_variable);\n  s7_define_function(sc, \"thread-variable?\",        g_is_thread_variable,      1, 0, false, H_is_thread_variable);\n\n  g_provide(sc, make_list_1(sc, s7_make_symbol(sc, \"threads\")));\n#endif\n\n#if WITH_ENCAPSULATION\n  encapsulator_tag = s7_new_type(\"<encapsulator>\",  encapsulator_print, encapsulator_free, encapsulator_equal, encapsulator_mark, encapsulator_apply, NULL);\n  s7_define_function(sc, \"open-encapsulator\",       g_open_encapsulator,       0, 0, false, H_open_encapsulator);\n  s7_define_function(sc, \"close-encapsulator\",      g_close_encapsulator,      1, 0, false, H_close_encapsulator);\n  s7_define_function(sc, \"encapsulator?\",           g_is_encapsulator,         1, 0, false, H_is_encapsulator);\n  s7_define_function(sc, \"encapsulator-bindings\",   g_encapsulator_bindings,   1, 0, false, H_encapsulator_bindings);\n#endif\n\n#if WITH_MULTIDIMENSIONAL_VECTORS\n  g_provide(sc, make_list_1(sc, s7_make_symbol(sc, \"multidimensional-vectors\")));\n#endif\n\n  sc->VECTOR_FUNCTION = s7_name_to_value(sc, \"vector\");\n\n  sc->VECTOR_SET = s7_symbol_value(sc, s7_make_symbol(sc, \"vector-set!\"));\n  typeflag(sc->VECTOR_SET) |= T_DONT_COPY; \n\n  sc->LIST_SET = s7_symbol_value(sc, s7_make_symbol(sc, \"list-set!\"));\n  typeflag(sc->LIST_SET) |= T_DONT_COPY; \n\n  sc->HASH_TABLE_SET = s7_symbol_value(sc, s7_make_symbol(sc, \"hash-table-set!\"));\n  typeflag(sc->HASH_TABLE_SET) |= T_DONT_COPY; \n\n  sc->STRING_SET = s7_symbol_value(sc, s7_make_symbol(sc, \"string-set!\"));\n  typeflag(sc->STRING_SET) |= T_DONT_COPY; \n\n  {\n    int top;\n    top = sizeof(s7_Int);\n    s7_int_max = (top == 8) ? LONG_MAX : SHRT_MAX;\n    s7_int_min = (top == 8) ? LONG_MIN : SHRT_MIN;\n    s7_int_bits = (top == 8) ? 63 : 31;\n    s7_int_digits = (top == 8) ? 18 : 8;\n\n    s7_define_constant(sc, \"most-positive-fixnum\", s7_make_integer(sc, (top == 8) ? LLONG_MAX : ((top == 4) ? LONG_MAX : SHRT_MAX)));\n    s7_define_constant(sc, \"most-negative-fixnum\", s7_make_integer(sc, (top == 8) ? LLONG_MIN : ((top == 4) ? LONG_MIN : SHRT_MIN)));\n\n    if (top == 4) default_rationalize_error = 1.0e-6;\n    s7_define_constant(sc, \"pi\", s7_make_real(sc, 3.1415926535897932384626433832795029L)); /* M_PI is not good enough for s7_Double = long double */\n\n    /* for s7_Double, float gives about 9 digits, double 18, long Double claims 28 but I don't see more than about 22? */\n  }\n\n  s7_eval_c_string(sc, \"(macro quasiquote (lambda (l) (_quasiquote_ 0 (cadr l))))\");\n\n#if WITH_GMP\n  s7_gmp_init(sc);\n#endif\n\n  /* s7_define_function(sc, \"dump-heap\", g_dump_heap, 0, 0, false, \"hiho\"); */\n\n  /* macroexpand */\n  s7_eval_c_string(sc, \"(define-macro (macroexpand mac) `(,(procedure-source (car mac)) ',mac))\");\n\n  /* multiple values */\n  /* call-with-values is almost a no-op in this context */\n  s7_eval_c_string(sc, \"(define-macro (call-with-values producer consumer) `(,consumer (,producer)))\"); \n  /* (call-with-values (lambda () (values 1 2 3)) +) */\n\n  s7_eval_c_string(sc, \"(define-macro (multiple-value-bind vars expression . body) `((lambda ,vars ,@body) ,expression))\");\n  /* (multiple-value-bind (a b) (values 1 2) (+ a b)) */\n  /*   named \"receive\" in srfi-8 which strikes me as perverse */\n\n  s7_eval_c_string(sc, \"(define-macro (multiple-value-set! vars expr . body)\\n\\\n                          (let ((local-vars (map (lambda (n) (gensym)) vars)))\\n\\\n                            `((lambda ,local-vars ,@(map (lambda (n ln) `(set! ,n ,ln)) vars local-vars) ,@body) ,expr)))\");\n\n#if 0\n  /*\n(define-macro (let*-values vals . body)\n  (let ((args '())\n\t(exprs '()))\n    (for-each\n     (lambda (arg+expr)\n       (set! args (cons (car arg+expr) args))\n       (set! exprs (cons (cadr arg+expr) exprs)))\n     vals)\n    (let ((form `((lambda ,(car args) ,@body) ,(car exprs))))\n      (if (not (null? (cdr args)))\n\t  (for-each\n\t   (lambda (arg expr)\n\t     (set! form `((lambda ,arg ,form) ,expr)))\n\t   (cdr args)\n\t   (cdr exprs)))\n      form)))\n  */\n#endif\n\n\n#if WITH_ENCAPSULATION\n  s7_eval_c_string(sc, \"                                 \\n\\\n      (define-macro (encapsulate . body)                 \\n\\\n\t(let ((encap (gensym)))                          \\n\\\n\t  `(let ((,encap (open-encapsulator)))           \\n\\\n\t     (dynamic-wind                               \\n\\\n\t\t (lambda ()                              \\n\\\n\t\t   #f)                                   \\n\\\n\t\t (lambda ()                              \\n\\\n\t\t   ,@body)                               \\n\\\n\t\t (lambda ()                              \\n\\\n\t\t   ((,encap))                            \\n\\\n\t\t   (close-encapsulator ,encap))))))\");\n#endif\n\n  /* s7_eval_c_string(sc, \"(define (ratio? n) (and (rational? n) (not (integer? n))))\"); */\n\n\n#if WITH_FORCE\n  s7_eval_c_string(\"(define (force object) (object))\");\n\n  s7_eval_c_string(\"(define-macro (delay expression)         \\n\\\n                      `(let ((result-ready? #f)              \\n\\\n  \t                     (result #f))                    \\n\\\n                         (lambda ()                          \\n\\\n                           (if result-ready?                 \\n\\\n\t                       result                        \\n\\\n\t                       (let ((x (let ()              \\n\\\n\t\t                          ,expression)))     \\n\\\n\t                         (if result-ready?           \\n\\\n\t\t                     result                  \\n\\\n                                    (begin                   \\n\\\n\t\t                      (set! result-ready? #t)\\n\\\n\t\t                      (set! result x)        \\n\\\n\t\t                      result)))))))\");\n#endif\n\t   \n  return(sc);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- leftovers -------------------------------- */\n", "func_signal": "static s7_pointer g_quit(s7_scheme *sc, s7_pointer args)", "code": "{\n  #define H_quit \"(quit) returns from the evaluator\"\n\n  push_stack(sc, OP_QUIT, sc->NIL, sc->NIL);\n  return(sc->NIL);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- quasiquote -------------------------------- */\n", "func_signal": "static s7_pointer g_quasiquote_1(s7_scheme *sc, int level, s7_pointer form)", "code": "{\n  if (!is_pair(form))\n    {\n      if ((s7_is_number(form)) ||\n\t  (s7_is_string(form)) ||\n\t  (s7_is_procedure(form)))\n\treturn(form);\n      return(make_list_2(sc, sc->QUOTE, form));\n    }\n  /* from here, form is a pair */\n\n  if (car(form) == sc->QUASIQUOTE)\n    {\n      s7_pointer r;\n      r = g_quasiquote_1(sc, level + 1, cdr(form));\n      if ((is_pair(r)) &&\n\t  (car(r) == sc->QUOTE) &&\n\t  (car(cdr(r)) == cdr(form)))\n\treturn(make_list_2(sc, sc->QUOTE, form));\n      return(make_list_3(sc, sc->CONS, make_list_2(sc, sc->QUOTE, sc->QUASIQUOTE), r));\n    }\n\n  if (level == 0)\n    {\n      if (car(form) == sc->UNQUOTE)\n\treturn(car(cdr(form)));\n\t      \n      if (car(form) == sc->UNQUOTE_SPLICING)\n\treturn(form);\n\t      \n      if ((is_pair(car(form))) &&\n\t  (caar(form) == sc->UNQUOTE_SPLICING))\n\t{\n\t  s7_pointer l, r;\n\t  l = car(cdr(car(form)));\n\t  if (cdr(form) == sc->NIL)\n\t    return(l);\n\n\t  r = g_quasiquote_1(sc, level, cdr(form));\n\n\t  if ((is_pair(r)) &&\n\t      (car(r) == sc->QUOTE) &&\n\t      (car(cdr(r)) == sc->NIL))\n\t    return(l);\n\t  return(make_list_3(sc, sc->APPEND, l, r));\n\t}\n      \n      goto MCONS;\n    }\n\n  /* level != 0 */\n  if (car(form) == sc->UNQUOTE)\n    {\n      s7_pointer r;\n      r = g_quasiquote_1(sc, level - 1, cdr(form));\n\n      if ((is_pair(r)) &&\n\t  (car(r) == sc->QUOTE) &&\n\t  (car(cdr(r)) == cdr(form)))\n\treturn(make_list_2(sc, sc->QUOTE, form));\n\n      return(make_list_3(sc, sc->CONS, make_list_2(sc, sc->QUOTE, sc->UNQUOTE), r));\n    }\n  \n  if (car(form) == sc->UNQUOTE_SPLICING)\n    {\n      s7_pointer r;\n      r = g_quasiquote_1(sc, level - 1, cdr(form));\n\n      if ((is_pair(r)) &&\n\t  (car(r) == sc->QUOTE) &&\n\t  (car(cdr(r)) == cdr(form)))\n\treturn(make_list_2(sc, sc->QUOTE, form));\n\n      return(make_list_3(sc, sc->CONS, make_list_2(sc, sc->QUOTE, sc->UNQUOTE_SPLICING), r));\n    }\n\t      \n MCONS:\n  {\n    s7_pointer l, r;\n\n    l = g_quasiquote_1(sc, level, car(form));\n    r = g_quasiquote_1(sc, level, cdr(form));\n\n    if ((is_pair(r)) &&\n\t(is_pair(l)) &&\n\t(car(r) == sc->QUOTE) &&\n\t(car(l) == car(r)) &&\n\t(car(cdr(r)) == cdr(form)) &&\n\t(car(cdr(l)) == car(form)))\n      return(make_list_2(sc, sc->QUOTE, form));\n\n    if (l == sc->VECTOR_FUNCTION)\n      return(g_vector(sc, make_list_1(sc, r))); /* eval? */\n\n    return(make_list_3(sc, sc->CONS, l, r));\n  }\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* slightly ugly:\n\n(define-macro (cerror . args)\n  `(call/cc\n    (lambda (continue)\n      (apply error continue ',args))))\n\n;;; now ((vector-ref *error-info* 0)) will continue from the error\n*/\n", "func_signal": "static s7_pointer s7_error_1(s7_scheme *sc, s7_pointer type, s7_pointer info, bool exit_eval)", "code": "{\n  int i;\n  s7_pointer catcher;\n  catcher = sc->F;\n\n  vector_element(sc->error_info, ERROR_TYPE) = type;\n  vector_element(sc->error_info, ERROR_DATA) = info;\n  vector_element(sc->error_info, ERROR_CODE) = sc->cur_code;\n  vector_element(sc->error_info, ERROR_CODE_LINE) = ERROR_INFO_DEFAULT;\n  vector_element(sc->error_info, ERROR_CODE_FILE) = ERROR_INFO_DEFAULT;\n  vector_element(sc->error_info, ERROR_ENVIRONMENT) = sc->envir;\n  s7_gc_on(sc, true);  /* this is in case we were triggered from the sort function -- clumsy! */\n\n  /* (let ((x 32)) (define (h1 a) (* a \"hi\")) (define (h2 b) (+ b (h1 b))) (h2 1)) */\n\n  if (is_pair(sc->cur_code))\n    {\n      int line, j, top;\n      line = pair_line_number(sc->cur_code);\n      if ((line > 0) &&\n\t  (remembered_line_number(line) != 0) &&\n\t  (remembered_file_name(line)))\n\t{\n\t  vector_element(sc->error_info, ERROR_CODE_LINE) = s7_make_integer(sc, remembered_line_number(line));\n\t  vector_element(sc->error_info, ERROR_CODE_FILE) = s7_make_string(sc, remembered_file_name(line));\t  \n\t}\n\n      for (top = sc->stack_top, j = ERROR_ENVIRONMENT + 1; (top > 0) && (j < ERROR_INFO_SIZE); top -= 4, j++)\n\tvector_element(sc->error_info, j) = vector_element(sc->stack, top - 3);\n      if (j < ERROR_INFO_SIZE)\n\tvector_element(sc->error_info, j) = ERROR_INFO_DEFAULT;\n    }\n\n  sc->cur_code = ERROR_INFO_DEFAULT;\n\n  /* if (!s7_is_continuation(type))... */\n\n  /* top is 1 past actual top, top - 1 is op, if op = OP_CATCH, top - 4 is the cell containing the catch struct */\n  for (i = sc->stack_top - 1; i >= 3; i -= 4)\n    {\n      opcode_t op;\n      s7_pointer x;\n      op = (opcode_t)s7_integer(vector_element(sc->stack, i));\n      \n      switch (op)\n\t{\n\tcase OP_DYNAMIC_WIND:\n\t  x = vector_element(sc->stack, i - 3);\n\t  if (dynamic_wind_state(x) == T_DWIND_BODY)\n\t    {\n\t      push_stack(sc, OP_EVAL_DONE, sc->args, sc->code); \n\t      sc->args = sc->NIL;\n\t      sc->code = dynamic_wind_out(x);\n\t      eval(sc, OP_APPLY);\n\t    }\n\t  break;\n\n\tcase OP_CATCH:\n\t  x = vector_element(sc->stack, i - 3);\n\t  if ((type == sc->T) ||\n\t      (catch_tag(x) == sc->T) ||\n\t      (s7_is_eq(catch_tag(x), type)))\n\t    {\n\t      catcher = x;\n\t      goto GOT_CATCH;\n\t    }\n\t  break;\n\n\tcase OP_UNWIND_OUTPUT:\n\t  x = vector_element(sc->stack, i - 3); /* \"code\" = port that we opened */\n\t  s7_close_output_port(sc, x);\n\t  x = vector_element(sc->stack, i - 1); /* \"args\" = port that we shadowed, if not #f */\n\t  if (x != sc->F)\n\t    sc->output_port = x;\n\t  break;\n\n\tcase OP_UNWIND_INPUT:\n\t  s7_close_input_port(sc, vector_element(sc->stack, i - 3)); /* \"code\" = port that we opened */\n\t  sc->input_port = vector_element(sc->stack, i - 1); /* \"args\" = port that we shadowed */\n\t  break;\n\n\tcase OP_TRACE_RETURN:\n\t  sc->trace_depth--;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n  \nGOT_CATCH:\n  if (catcher != sc->F)\n    {\n      sc->args = make_list_2(sc, type, info);\n      sc->code = catch_handler(catcher);\n      sc->stack_top = catch_goto_loc(catcher);\n      sc->op = OP_APPLY;\n\n      /* explicit eval needed if s7_call called into scheme where a caught error occurred (ex6 in exs7.c)\n       *  but putting it here (via eval(sc, OP_APPLY)) means the C stack is not cleared correctly in non-s7-call cases, \n       *  so defer it until s7_call \n       */\n    }\n  else\n    {\n      /* (set! *error-hook* (lambda (tag args) (apply format (cons #t args)))) */\n      s7_pointer error_hook, error_hook_binding;\n\n      error_hook_binding = s7_find_symbol_in_environment(sc, sc->envir, sc->ERROR_HOOK, true);\n      if ((error_hook_binding != sc->NIL) &&\n\t  (is_procedure(symbol_value(error_hook_binding))))\n\t{\n\t  error_hook = symbol_value(error_hook_binding);\n\t  set_symbol_value(error_hook_binding, sc->NIL);\n\t  /* if the *error-hook* function triggers an error, we had better not have *error-hook* still set! */\n\n\t  push_stack(sc, OP_ERROR_HOOK_QUIT, sc->NIL, error_hook); /* restore *error-hook* upon successful evaluation */\n\t  sc->args = make_list_2(sc, type, info);\n\t  sc->code = error_hook;\n\t  sc->op = OP_APPLY;\n\t}\n      else\n\t{\n\t  /* if info is not a list, send object->string to current error port,\n\t   *   else assume car(info) is a format control string, and cdr(info) are its args\n\t   */\n\t  if ((!s7_is_list(sc, info)) ||\n\t      (!s7_is_string(car(info))))\n\t    format_to_output(sc, \n\t\t\t     s7_current_error_port(sc), \n\t\t\t     \"\\n;~A ~A\",\n\t\t\t     make_list_2(sc, type, info));\n\t  else\n\t    {\n\t      const char *carstr;\n\t      int i, len;\n\t      bool use_format = false;\n\t      \n\t      /* it's possible that the error string is just a string -- not intended for format */\n\t      carstr = s7_string(car(info));\n\t      len = string_length(car(info));\n\t      for (i = 0; i < len; i++)\n\t\tif (carstr[i] == '~')\n\t\t  {\n\t\t    use_format = true;\n\t\t    break;\n\t\t  }\n\t      \n\t      if (use_format)\n\t\t{\n\t\t  char *errstr;\n\t\t  len += 8;\n\t\t  errstr = (char *)malloc(len * sizeof(char));\n\t\t  snprintf(errstr, len, \"\\n;%s\", s7_string(car(info)));\n\t\t  format_to_output(sc,\n\t\t\t\t   s7_current_error_port(sc), \n\t\t\t\t   errstr,\n\t\t\t\t   cdr(info));\n\t\t  free(errstr);\n\t\t}\n\t      else format_to_output(sc, \n\t\t\t\t    s7_current_error_port(sc), \n\t\t\t\t    \"\\n;~A ~A\",\n\t\t\t\t    make_list_2(sc, type, info));\n\t    }\n\t  \n\t  /* now display location and \\n at end */\n\t  \n\t  if (is_input_port(sc->input_port))\n\t    {\n\t      const char *filename = NULL;\n\t      int line;\n\t      \n\t      filename = port_filename(sc->input_port);\n\t      line = port_line_number(sc->input_port);\n\t      \n\t      if (filename)\n\t\tformat_to_output(sc,\n\t\t\t\t s7_current_error_port(sc), \n\t\t\t\t \", ~A[~D]\",\n\t\t\t\t make_list_2(sc, s7_make_string(sc, filename), s7_make_integer(sc, line)));\n\t      else \n\t\t{\n\t\t  if (line > 0)\n\t\t    format_to_output(sc,\n\t\t\t\t     s7_current_error_port(sc), \n\t\t\t\t     \", line ~D\", \n\t\t\t\t     make_list_1(sc, s7_make_integer(sc, line)));\n\t\t}\n\t    }\n\t  s7_newline(sc, s7_current_error_port(sc));\n\n\t  if (is_pair(vector_element(sc->error_info, ERROR_CODE)))\n\t    {\n\t      format_to_output(sc, \n\t\t\t       s7_current_error_port(sc), \n\t\t\t       \";    ~A\", \n\t\t\t       make_list_1(sc, vector_element(sc->error_info, ERROR_CODE)));\n\t      s7_newline(sc, s7_current_error_port(sc));\n\n\t      if (s7_is_string(vector_element(sc->error_info, ERROR_CODE_FILE)))\n\t\t{\n\t\t  format_to_output(sc,\n\t\t\t\t   s7_current_error_port(sc), \n\t\t\t\t   \";    [~S, line ~D]\",\n\t\t\t\t   make_list_2(sc, \n\t\t\t\t\t       vector_element(sc->error_info, ERROR_CODE_FILE), \n\t\t\t\t\t       vector_element(sc->error_info, ERROR_CODE_LINE)));\n\t\t  s7_newline(sc, s7_current_error_port(sc));\n\t\t}\n\t    }\n\t  \n\t  if ((exit_eval) &&\n\t      (sc->error_exiter))\n\t    (*(sc->error_exiter))();\n\n\t  /* if (s7_is_continuation(type))\n\t   *   go into repl here with access to continuation?  Or expect *error-handler* to deal with it?\n\t   */\n\t  sc->value = type;\n\t  stack_reset(sc);\n\t  sc->op = OP_ERROR_QUIT;\n\t}\n    }\n  \n  if (sc->longjmp_ok)\n    {\n      longjmp(sc->goto_start, 1); /* this is trying to clear the C stack back to some clean state */\n    }\n\n  return(type);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- multiple-values -------------------------------- */\n", "func_signal": "static s7_pointer splice_in_values(s7_scheme *sc, s7_pointer args)", "code": "{\n  if (sc->stack_top > 0)\n    {\n      /* code = args yet to eval in order, args = evalled args reversed */\n      s7_pointer *vel;\n      int top;\n      top = sc->stack_top - 4;\n      vel = (s7_pointer *)(vector_elements(sc->stack) + top);\n      /*\n       * code = vel[0]\n       * args = vel[2]\n       * op =   (opcode_t)integer(number(vel[3]))\n      */\n      if ((opcode_t)integer(number(vel[3])) == OP_EVAL_ARGS1)\n\t{\n\t  s7_pointer x;\n\t  /* splice into the caller's arg list, leaving the last for the eval args loop to handle */\n\t  for (x = args; cdr(x) != sc->NIL; x = cdr(x))\n\t    vel[2] = s7_cons(sc, car(x), vel[2]);\n\t  return(car(x));\n\t}\n    }\n\n  /* let it meander back up the call chain until someone knows where to splice it */\n  return(s7_cons(sc, sc->VALUES, args));\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* TODO: tie in (and test/document) the caller function input port\n */\n", "func_signal": "static int inchar(s7_scheme *sc, s7_pointer pt)", "code": "{\n  int c;\n  if (pt == sc->NIL) return(EOF);\n  \n  if (is_file_port(pt))\n    c = fgetc(port_file(pt));\n  else \n    {\n      if ((!(port_string(pt))) ||\n\t  (port_string_length(pt) <= port_string_point(pt)))\n\treturn(EOF);\n      c = port_string(pt)[port_string_point(pt)++];\n    }\n\n  if (c == '\\n')\n    port_line_number(pt)++;\n\n  return(c);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------- error handlers -------- */\n", "func_signal": "static const char *s7_type_name(s7_pointer arg)", "code": "{\n  switch (type(arg))\n    {\n    case T_NIL:          return(\"nil\");\n    case T_UNTYPED:      return(\"untyped\");\n    case T_BOOLEAN:      return(\"boolean\");\n    case T_STRING:       return(\"string\");\n    case T_SYMBOL:       return(\"symbol\");\n    case T_PAIR:         return(\"pair\");\n    case T_CLOSURE:\n    case T_CLOSURE_STAR: return(\"closure\");\n    case T_GOTO:\n    case T_CONTINUATION: return(\"continuation\");\n    case T_C_FUNCTION:   return(\"function\");\n    case T_C_MACRO:      return(\"macro\");\n    case T_C_POINTER:    return(\"c-pointer\");\n    case T_CHARACTER:    return(\"character\");\n    case T_VECTOR:       return(\"vector\");\n    case T_MACRO:        return(\"macro\");\n    case T_CATCH:        return(\"catch\");\n    case T_DYNAMIC_WIND: return(\"dynamic-wind\");\n    case T_HASH_TABLE:   return(\"hash-table\");\n    case T_C_OBJECT:     return(object_types[c_object_type(arg)].name);\n\n    case T_INPUT_PORT:\n      {\n\tif (is_file_port(arg))\n\t  return(\"input file port\");\n\tif (is_string_port(arg))\n\t  return(\"input string port\");\n\treturn(\"input port\");\n      }\n\n    case T_OUTPUT_PORT:\n      {\n\tif (is_file_port(arg))\n\t  return(\"output file port\");\n\tif (is_string_port(arg))\n\t  return(\"output string port\");\n\treturn(\"output port\");\n      }\n      \n    case T_NUMBER: \n      {\n\tswitch (number_type(arg))\n\t  {\n\t  case NUM_INT:   return(\"integer\");\n\t  case NUM_RATIO: return(\"ratio\");\n\t  case NUM_REAL:  \n\t  case NUM_REAL2: return(\"real\");\n\t  default:        return(\"complex number\"); /* \"a complex\" doesn't sound right */\n\t  }\n      }\n    }\n  return(\"messed up object\");\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- strings -------------------------------- */\n", "func_signal": "s7_pointer s7_make_string_with_length(s7_scheme *sc, const char *str, int len)", "code": "{\n  s7_pointer x;\n  x = new_cell(sc);\n  set_type(x, T_STRING | T_ATOM | T_FINALIZABLE | T_SIMPLE | T_DONT_COPY);\n  string_value(x) = s7_strdup_with_len(str, len);\n  string_length(x) = len;\n  return(x);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/*        (define (func a) (let ((cvar (+ a 1))) cvar))\n *        (define-constant cvar 23)\n *        (func 1)\n *        ;can't bind or set an immutable object: cvar\n */\n", "func_signal": "static s7_pointer s7_find_value_in_environment(s7_scheme *sc, s7_pointer val)", "code": "{ \n  s7_pointer x, y, vec; \n  for (x = sc->envir; (x != sc->NIL) && (!s7_is_vector(car(x))); x = cdr(x)) \n    for (y = car(x); y != sc->NIL; y = cdr(y)) \n      if (cdr(car(y)) == val)\n\treturn(car(y));\n  \n  if (s7_is_vector(car(x)))\n    {\n      int i, len;\n      vec = car(x);\n      len = vector_length(vec);\n      for (i = 0; i < len; i++)\n\tif (vector_element(vec, i) != sc->NIL)\n\t  for (y = vector_element(vec, i); y != sc->NIL; y = cdr(y)) \n\t    if (cdr(car(y)) == val)\n\t      return(car(y));\n    }\n  return(sc->F); \n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* all explicit write-* in eval assume current-output-port -- error fallback handling, etc */\n/*   internal reads assume sc->input_port is the input port */\n", "func_signal": "static s7_pointer eval(s7_scheme *sc, opcode_t first_op)", "code": "{\n  sc->cur_code = ERROR_INFO_DEFAULT;\n  sc->op = first_op;\n  \n  /* this procedure can be entered recursively (via s7_call for example), so it's no place for a setjmp\n   *   I don't think the recursion can hurt our continuations because s7_call is coming from hooks and\n   *   callbacks that are implicit in our stack.\n   */\n  \n START:\n\n  switch (sc->op) \n    {\n      /* in gcc, this becomes a jump table, so we're not doing a linear search (gcc s7.c -S -I.) */\n    case OP_READ_INTERNAL:\n      sc->tok = token(sc);\n\n      switch (sc->tok)\n\t{\n\tcase TOKEN_EOF:\n\t  pop_stack(sc);\n\t  goto START;\n\n\tcase TOKEN_RIGHT_PAREN:\n\t  return(read_error(sc, \"unexpected close paren\"));\n\n\tcase TOKEN_COMMA:\n\t  return(read_error(sc, \"unexpected comma\"));\n\n\tdefault:\n\t  sc->value = read_expression(sc);\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n\n      \n      /* g_read(p) from C \n       *   read one expr, return it, let caller deal with input port setup \n       */\n    case OP_READ_RETURN_EXPRESSION:\n      return(sc->F);\n      \n      \n      /* (read p) from scheme\n       *    \"p\" becomes current input port for eval's duration, then pops back before returning value into calling expr\n       */\n    case OP_READ_POP_AND_RETURN_EXPRESSION:\n      pop_input_port(sc);\n      \n      if (sc->tok == TOKEN_EOF)\n\t{\n\t  sc->value = sc->EOF_OBJECT;\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      pop_stack(sc);\n      goto START;\n      \n      \n      /* load(\"file\"); from C (g_load) -- assume caller will clean up\n       *   read and evaluate exprs until EOF that matches (stack reflects nesting)\n       */\n    case OP_LOAD_RETURN_IF_EOF:  /* loop here until eof (via push stack below) */\n      if (sc->tok != TOKEN_EOF)\n\t{\n\t  push_stack(sc, OP_LOAD_RETURN_IF_EOF, sc->NIL, sc->NIL);\n\t  push_stack(sc, OP_READ_INTERNAL, sc->NIL, sc->NIL);\n\t  sc->code = sc->value;\n\t  goto EVAL;             /* we read an expression, now evaluate it, and return to read the next */\n\t}\n      return(sc->F);\n      \n      \n      /* (load \"file\") in scheme \n       *    read and evaluate all exprs, then upon EOF, close current and pop input port stack\n       */\n    case OP_LOAD_CLOSE_AND_POP_IF_EOF:\n      if (sc->tok != TOKEN_EOF)\n\t{\n\t  push_stack(sc, OP_LOAD_CLOSE_AND_POP_IF_EOF, sc->NIL, sc->NIL); /* was push args, code */\n\t  push_stack(sc, OP_READ_INTERNAL, sc->NIL, sc->NIL);\n\t  sc->code = sc->value;\n\t  goto EVAL;             /* we read an expression, now evaluate it, and return to read the next */\n\t}\n      s7_close_input_port(sc, sc->input_port);\n      pop_input_port(sc);\n      pop_stack(sc);\n      goto START;\n      \n      \n      /* read and evaluate string expression(s?)\n       *    assume caller (C via g_eval_c_string) is dealing with the string port\n       */\n    case OP_EVAL_STRING:\n      /* (eval-string (string-append \"(list 1 2 3)\" (string #\\newline) (string #\\newline))) \n       *    needs to be sure to get rid of the trailing white space before checking for EOF\n       *    else it tries to eval twice and gets \"attempt to apply 1?, line 2\"\n       */\n      if ((sc->tok != TOKEN_EOF) && \n\t  (port_string_point(sc->input_port) < port_string_length(sc->input_port))) /* ran past end somehow? */\n\t{\n\t  int c = 0;\n\t  while (isspace(c = port_string(sc->input_port)[port_string_point(sc->input_port)++]))\n\t    if (c == '\\n')\n\t      port_line_number(sc->input_port)++;\n\n\t  if ((c != EOF) && (c != 0))\n\t    {\n\t      backchar(sc, c, sc->input_port);\n\t      push_stack(sc, OP_EVAL_STRING, sc->NIL, sc->value);\n\t      push_stack(sc, OP_READ_INTERNAL, sc->NIL, sc->NIL);\n\t    }\n\t  else push_stack(sc, OP_EVAL_STRING_DONE, sc->NIL, sc->value);\n\t}\n      else push_stack(sc, OP_EVAL_STRING_DONE, sc->NIL, sc->value);\n      sc->code = sc->value;\n      goto EVAL;\n      \n      \n    case OP_EVAL_DONE:\n    case OP_EVAL_STRING_DONE:\n     return(sc->F);\n\n\n\n    case OP_LIST_FOR_EACH:\n      sc->x = sc->args; /* save lists */\n      sc->args = sc->NIL;\n      for (sc->y = sc->x; sc->y != sc->NIL; sc->y = cdr(sc->y))\n\t{\n\t  if (car(sc->y) == sc->NIL)\n\t    return(eval_error(sc, \"for-each args are not the same length\", sc->x));\n\n\t  sc->args = s7_cons(sc, caar(sc->y), sc->args);\n\t  car(sc->y) = cdar(sc->y);                           /* cdr this arg list */\n\t}\n      sc->args = safe_reverse_in_place(sc, sc->args);\n      if (car(sc->x) == sc->NIL)                              /* reached the end of the 1st arg list, so don't loop back via push_stack */\n\t{\n\t  for (sc->y = cdr(sc->x); sc->y != sc->NIL; sc->y = cdr(sc->y))\n\t    if (car(sc->y) != sc->NIL)\n\t      return(eval_error(sc, \"for-each args are not the same length\", sc->x));\n\t  goto APPLY;\n\t}\n      push_stack(sc, OP_LIST_FOR_EACH, sc->x, sc->code);\n      goto APPLY;\n      \n      \n    case OP_LIST_MAP:\n      /* car of args incoming is arglist, cdr is values list (nil to start) */\n      sc->x = sc->args;\n      cdr(sc->x) = s7_cons(sc, sc->value, cdr(sc->x));       /* add current value to list */\n      \n      if (caar(sc->x) == sc->NIL)\n\t{\n\t  for (sc->y = cdar(sc->x); sc->y != sc->NIL; sc->y = cdr(sc->y))\n\t    if (car(sc->y) != sc->NIL)\n\t      return(eval_error(sc, \"map args are not the same length\", sc->x));\n\n\t  sc->value = safe_reverse_in_place(sc, cdr(sc->x));\n\t  /* should this expand values objects?\n\t   *    (apply + (map (lambda (n) (values n (+ n 1))) (list 1 2)))\n\t   */\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      sc->args = sc->NIL;\n      for (sc->y = car(sc->x); sc->y != sc->NIL; sc->y = cdr(sc->y))\n\t{\n\t  if (car(sc->y) == sc->NIL)\n\t    return(eval_error(sc, \"map args are not the same length\", sc->x));\n\n\t  sc->args = s7_cons(sc, caar(sc->y), sc->args);\n\t  car(sc->y) = cdar(sc->y);\n\t}\n      sc->args = safe_reverse_in_place(sc, sc->args);\n      push_stack(sc, OP_LIST_MAP, sc->x, sc->code);\n      goto APPLY;\n\n\n    case OP_VECTOR_FOR_EACH:\n    case OP_HASH_TABLE_FOR_EACH:\n      /* func = sc->code, func-args = caddr(sc->args), counter = car(sc->args), len = cadr(sc->args), vector(s) = cdddr(sc->args) */\n      if (s7_integer(car(sc->args)) < s7_integer(cadr(sc->args)))\n\t{\n\t  s7_pointer x, y, vargs, fargs;\n\t  int loc;\n\t  /* next loop iteration */\n\n\t  vargs = cdddr(sc->args);\n\t  fargs = caddr(sc->args);\n\t  loc = s7_integer(car(sc->args));\n\t  for (x = fargs, y = vargs; x != sc->NIL; x = cdr(x), y = cdr(y))\n\t    car(x) = vector_element(car(y), loc);   /* make func's arglist */\n\n\t  integer(number(car(sc->args))) = loc + 1;\n\t  push_stack(sc, sc->op, sc->args, sc->code);\n\t  sc->args = fargs;\n\t  goto APPLY;\n\t}\n      \n      /* loop done */\n      sc->value = sc->UNSPECIFIED;\n      pop_stack(sc);\n      goto START;\n      \n\n    case OP_VECTOR_MAP1:\n      {\n\tint loc;\n\tloc = s7_integer(cadr(sc->args));\n\tinteger(number(cadr(sc->args))) = loc + 1;\n\tvector_element(car(sc->args), loc) = sc->value;\n      }\n      /* drop into VECTOR_MAP0 */\n\n      \n    case OP_VECTOR_MAP0:\n      /* func = sc->code, \n       * new-vector = car(sc->args), \n       * func-args = cadddr(sc->args), \n       * counter = cadr(sc->args), \n       * len = caddr(sc->args), \n       * vector(s) = cddddr(sc->args) \n       */\n      if (s7_integer(cadr(sc->args)) < s7_integer(caddr(sc->args)))\n\t{\n\t  s7_pointer x, y, vargs, fargs;\n\t  int loc;\n\t  /* next loop iteration */\n\n\t  vargs = cddddr(sc->args);\n\t  fargs = cadddr(sc->args);\n\t  loc = s7_integer(cadr(sc->args));\n\t  for (x = fargs, y = vargs; x != sc->NIL; x = cdr(x), y = cdr(y))\n\t    car(x) = vector_element(car(y), loc);\n\n\t  push_stack(sc, OP_VECTOR_MAP1, sc->args, sc->code);\n\t  sc->args = fargs;\n\t  goto APPLY;\n\t}\n      \n      /* loop done */\n      sc->value = car(sc->args);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_STRING_FOR_EACH:\n      /* func = sc->code, func-args = caddr(sc->args), counter = car(sc->args), len = cadr(sc->args), string(s) = cdddr(sc->args) */\n      if (s7_integer(car(sc->args)) < s7_integer(cadr(sc->args)))\n\t{\n\t  s7_pointer x, y, vargs, fargs;\n\t  int loc;\n\n\t  vargs = cdddr(sc->args);\n\t  fargs = caddr(sc->args);\n\t  loc = s7_integer(car(sc->args));\n\t  for (x = fargs, y = vargs; x != sc->NIL; x = cdr(x), y = cdr(y))\n\t    car(x) = s7_make_character(sc, string_value(car(y))[loc]);\n\n\t  integer(number(car(sc->args))) = loc + 1;\n\t  push_stack(sc, OP_STRING_FOR_EACH, sc->args, sc->code);\n\t  sc->args = fargs;\n\t  goto APPLY;\n\t}\n      \n      sc->value = sc->UNSPECIFIED;\n      pop_stack(sc);\n      goto START;\n      \n\n    case OP_OBJECT_FOR_EACH:\n      /* func = sc->code, func-args = caddr(sc->args), counter = car(sc->args), len = cadr(sc->args), object(s) = cdddr(sc->args) */\n      if (s7_integer(car(sc->args)) < s7_integer(cadr(sc->args)))\n\t{\n\t  s7_pointer x, y, vargs, fargs;\n\t  int loc;\n\n\t  vargs = cdddr(sc->args);\n\t  fargs = caddr(sc->args);\n\t  loc = s7_integer(car(sc->args));\n\t  sc->x = s7_cons(sc, car(sc->args), sc->NIL);\n\n\t  for (x = fargs, y = vargs; x != sc->NIL; x = cdr(x), y = cdr(y))\n\t    car(x) = (*(object_types[c_object_type(car(y))].apply))(sc, car(y), sc->x);\n\n\t  integer(number(car(sc->args))) = loc + 1;\n\t  push_stack(sc, OP_OBJECT_FOR_EACH, sc->args, sc->code);\n\t  sc->args = fargs;\n\t  goto APPLY;\n\t}\n      \n      sc->value = sc->UNSPECIFIED;\n      pop_stack(sc);\n      goto START;\n      \n\n    case OP_DO: \n      /* setup is very similar to let */\n      /* sc->code is the stuff after \"do\" */\n\n      if ((!is_pair(sc->code)) ||            /* (do . 1) */\n\t  ((!is_pair(car(sc->code))) &&      /* (do 123) */\n\t   (car(sc->code) != sc->NIL)))      /* (do () ...) is ok */\n\treturn(eval_error(sc, \"do: var list is not a list: ~S\", sc->code));\n\n      if ((!is_pair(cadr(sc->code))) &&      /* (do ((i 0)) 123) */\n\t  (cadr(sc->code) != sc->NIL))       /* no end-test? */\n\treturn(eval_error(sc, \"do: end-test and end-value list is not a list: ~A\", sc->code));\n\n      if (car(sc->code) == sc->NIL)            /* (do () ...) */\n\t{\n\t  sc->envir = new_frame_in_env(sc, sc->envir); \n\t  sc->args = s7_cons(sc, sc->NIL, cadr(sc->code));\n\t  sc->code = cddr(sc->code);\n\t  goto DO_END0;\n\t}\n      \n      /* eval each init value, then set up the new frame (like let, not let*) */\n      \n      sc->args = sc->NIL;       /* the evaluated var-data */\n      sc->value = sc->code;     /* protect it */\n      sc->code = car(sc->code); /* the vars */\n      \n      \n    case OP_DO_INIT:\n      sc->args = s7_cons(sc, sc->value, sc->args); /* code will be last element (first after reverse) */\n      if (is_pair(sc->code))\n\t{\n\t  /* here sc->code is a list like: ((i 0 (+ i 1)) ...)\n\t   *   so cadar gets the init value\n\t   */\n\t  if (!(is_pair(car(sc->code))))          /* (do (4) (= 3)) */\n\t    return(eval_error(sc, \"do: variable name missing? ~A\", sc->code));\n\n\t  if (is_pair(cdar(sc->code)))\n\t    {\n\t      if ((!is_pair(cddar(sc->code))) &&\n\t\t  (cddar(sc->code) != sc->NIL))       /* (do ((i 0 . 1)) ...) */\n\t\treturn(eval_error(sc, \"do: variable info is an improper list?: ~A\", sc->code));\n\n\t      if ((is_pair(cddar(sc->code))) && \n\t\t  (cdr(cddar(sc->code)) != sc->NIL))  /* (do ((i 0 1 (+ i 1))) ...) */\n\t\treturn(eval_error(sc, \"do: variable info has extra stuff after the increment: ~A\", sc->code));\n\t    }\n\n\t  push_stack(sc, OP_DO_INIT, sc->args, cdr(sc->code));\n\t  sc->code = cadar(sc->code);\n\t  sc->args = sc->NIL;\n\t  goto EVAL;\n\t}\n\n      if (sc->code != sc->NIL)                    /* (do ((i 0 i) . 1) ((= i 1))) */\n\treturn(eval_error(sc, \"do: list of variables is improper: ~A\", sc->code));\n      \n      /* all done */\n      sc->args = safe_reverse_in_place(sc, sc->args);\n      sc->code = car(sc->args); /* saved at the start */\n      sc->args = cdr(sc->args); /* init values */\n      sc->envir = new_frame_in_env(sc, sc->envir); \n\n      sc->value = sc->NIL;\n      for (sc->x = car(sc->code), sc->y = sc->args; sc->y != sc->NIL; sc->x = cdr(sc->x), sc->y = cdr(sc->y)) \n\tsc->value = s7_cons(sc, add_to_local_environment(sc, caar(sc->x), car(sc->y)), sc->value);\n\n      /* now we've set up the environment, next set up for loop */\n\n      sc->y = safe_reverse_in_place(sc, sc->value);\n      sc->args = sc->NIL;\n      for (sc->x = car(sc->code); sc->y != sc->NIL; sc->x = cdr(sc->x), sc->y = cdr(sc->y))       \n\tif (cddar(sc->x) != sc->NIL) /* no incr expr, so ignore it henceforth */\n\t  {\n\t    sc->value = s7_cons(sc, caddar(sc->x), sc->NIL);\n\t    sc->value = s7_cons(sc, car(sc->y), sc->value);\n\t    sc->args = s7_cons(sc, sc->value, sc->args);\n\t  }\n      sc->value = safe_reverse_in_place(sc, sc->args);\n      sc->args = s7_cons(sc, sc->value, cadr(sc->code));\n      sc->code = cddr(sc->code);\n      \n      \n    DO_END0:\n    case OP_DO_END0:\n      /* here vars have been init'd or incr'd\n       *    args = (cons var-data end-data)\n       *    code = body\n       */\n      \n      push_stack(sc, OP_DO_END1, sc->args, sc->code);\n      /* evaluate the endtest */\n      sc->code = cadr(sc->args);\n      sc->args = sc->NIL;\n      goto EVAL;\n      \n      \n    case OP_DO_END1:\n      /* sc->value should be result of endtest evaluation */\n      if (is_true(sc, sc->value))\n\t{\n\t  /* we're done -- deal with result exprs */\n\t  sc->code = cddr(sc->args);\n\t  sc->args = sc->NIL;\n\t  goto BEGIN;\n\t}\n      \n      /* evaluate the body and step vars, etc */\n      push_stack(sc, OP_DO_STEP0, sc->args, sc->code);\n      /* sc->code is ready to go */\n      sc->args = sc->NIL;\n      goto BEGIN;\n      \n      \n    case OP_DO_STEP0:\n      /* increment all vars, return to endtest \n       *   these are also updated in parallel at the end, so we gather all the incremented values first\n       */\n      if (car(sc->args) == sc->NIL)\n\tgoto DO_END0;\n      \n      push_stack(sc, OP_DO_END0, sc->args, sc->code);\n      sc->code = s7_cons(sc, sc->NIL, car(sc->args));   /* car = list of newly incremented values, cdr = list of slots */\n      sc->args = car(sc->args);\n      \n      \n    DO_STEP1:\n    case OP_DO_STEP1:\n      if (sc->args == sc->NIL)\n\t{\n\t  sc->y = cdr(sc->code);\n\t  sc->code = safe_reverse_in_place(sc, car(sc->code));\n\t  for (sc->x = sc->code; sc->y != sc->NIL && sc->x != sc->NIL; sc->x = cdr(sc->x), sc->y = cdr(sc->y))\n\t    set_symbol_value(caar(sc->y), car(sc->x));\n\n\t  /* \"real\" schemes rebind here, rather than reset, but that is expensive,\n\t   *    and only matters once in a blue moon (closure over enclosed lambda referring to a do var)\n\t   *    and the caller can easily mimic the correct behavior in that case by adding a let,\n\t   *    making the rebinding explicit.\n\t   *\n\t   * Hmmm... I'll leave this alone, but there are other less cut-and-dried cases:\n\t   *\n\t   *   (let ((j (lambda () 0))\n\t   *         (k 0))\n\t   *     (do ((i (j) (j))\n\t   *          (j (lambda () 1) (lambda () (+ i 1)))) ; bind here hits different \"i\" than reset\n\t   *         ((= i 3) k)\n\t   *       (set! k (+ k i))))\n\t   *\n\t   *   is it 6 or 3?\n\t   *\n\t   * if we had a way to tell that there were no lambdas in the do expression, would that\n\t   *   guarantee that set was ok?  Here's a bad case:\n\t   *\n\t   *   (let ((f #f))\n\t   *     (do ((i 0 (+ i 1)))\n\t   *         ((= i 3))\n\t   *       (let () ; so that the define is ok\n\t   *         (define (x) i)\n\t   *         (if (= i 1) (set! f x))))\n\t   *    (f))\n\t   *\n\t   * s7 says 3, guile says 1.\n\t   */\n\t  \n\t  sc->value = sc->NIL;\n\t  pop_stack(sc); \n\t  goto DO_END0;\n\t}\n      push_stack(sc, OP_DO_STEP2, sc->args, sc->code);\n      /* here sc->args is a list like (((i . 0) (+ i 1)) ...)\n       *   so sc->code becomes (+ i 1) in this case \n       */\n      sc->code = cadar(sc->args);\n      sc->args = sc->NIL;\n      goto EVAL;\n      \n\n    case OP_DO_STEP2:\n      car(sc->code) = s7_cons(sc, sc->value, car(sc->code));  /* add this value to our growing list */\n      sc->args = cdr(sc->args);                               /* go to next */\n      goto DO_STEP1;\n      \n\n    case OP_WITH_ENV1:\n      sc->envir = sc->args;                              /* restore previous environment */\n      pop_stack(sc);\n      goto START;\n\n\n    case OP_WITH_ENV0:\n      /* (with-environment env . body) */\n      push_stack(sc, OP_WITH_ENV1, sc->envir, sc->NIL);  /* save current env */\n      push_stack(sc, OP_WITH_ENV2, sc->NIL, sc->code);\n      sc->args = sc->NIL;\n      sc->code = car(sc->code);                          /* eval env arg */\n      goto EVAL;\n\n      \n    case OP_WITH_ENV2:\n      sc->envir = sc->value;                             /* in new env... */\n      sc->code = cdr(sc->code);                          /*   handle body */\n      /* goto BEGIN; */\n\n\n    BEGIN:\n    case OP_BEGIN:\n      if (!is_pair(sc->code)) \n\t{\n\t  if (sc->code != sc->NIL)            /* (begin . 1) */\n\t    return(eval_error(sc, \"unexpected dot or '() at end of body?\", sc->code));\n\n\t  sc->value = sc->code;\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      \n      if (cdr(sc->code) != sc->NIL) \n\tpush_stack(sc, OP_BEGIN, sc->NIL, cdr(sc->code));\n      \n      sc->code = car(sc->code);\n      sc->cur_code = sc->code;\n      /* goto EVAL; */\n      \n\n    EVAL:\n    case OP_EVAL:       /* main part of evaluation */\n      if (is_pair(sc->code))                /* switching type check order here slows us down */\n\t{\n\t  /* using a local s7_pointer for sc->x here drastically slows things down?!? */\n\t  sc->x = car(sc->code);\n\t  if (is_syntax(sc->x))\n\t    {     \n\t      sc->code = cdr(sc->code);\n\t      sc->op = (opcode_t)syntax_opcode(sc->x);\n\t      goto START;\n\t    } \n\t  push_stack(sc, OP_EVAL_ARGS0, sc->NIL, sc->code);\n\t  sc->code = sc->x;\n\t  goto EVAL;\n\t} \n\n      if (s7_is_symbol(sc->code))\n\t{\n\t  /* expand eval_symbol here to speed it up by a lot */\n\t  s7_pointer x;\n\t  if (is_not_local(sc->code))\n\t    x = symbol_global_slot(sc->code);\n\t  else x = s7_find_symbol_in_environment(sc, sc->envir, sc->code, true);\n\t  if (x != sc->NIL) \n\t    sc->value = symbol_value(x);\n\t  else sc->value = eval_symbol(sc, sc->code);\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n\n      sc->value = sc->code;\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_EVAL_ARGS0:\n      if (is_any_macro(sc->value))\n\t{    \n\t  /* macro expansion */\n\t  if (!(is_c_macro(sc->value)))\n\t    push_stack(sc, OP_EVAL_MACRO, sc->NIL, sc->NIL);\n\t  /* code is the macro invocation: (mac-name ...), args is nil, value is the macro code bound to mac-name */\n\t  sc->args = make_list_1(sc, sc->code); \n\t  sc->code = sc->value;\n\t  goto APPLY;\n\t} \n      else \n\t{\n\t  /* here sc->value is the func, sc->code is the entire expression */\n#if WITH_ENCAPSULATION\n\t  if ((is_encapsulating(sc)) &&\n\t      (cdr(sc->code) != sc->NIL) &&\n\t      (is_setter(sc->value)) &&\n\t      (s7_is_symbol(cadr(sc->code))))\n\t    encapsulate(sc, cadr(sc->code));\n\t  \n\t  /* we currently ignore any case that involves an accessor such as (string-set! (vector-ref ...)).\n\t   *   In cases that don't involve set-applicable objects, we can say (for example) that the vector itself is not\n\t   *   being changed, and it is impossible to handle multi-level cases because we have to save both the values\n\t   *   and the accessor-paths to those values: \n\t   *\n\t   *     (let* ((s (make-string 8 #\\x)) (v (vector s))) (encapsulate (string-set! (vector-ref v 0) 1 #\\a)))\n\t   *\n\t   *   here both the vector string value, and its reference back to the string variable need to be saved,\n\t   *   else a later string-set! is ambiguous (if a new string holds the original string value, \"s\" won't change\n\t   *   in the post-encapsulated new string-set! case, but would have changed without the encapsulation).  The set-applicable \n\t   *   object case ought to be do-able, but then the check above becomes very messy -- we have to make sure \n\t   *   it's a single level reference, eval_symbol caadr(?), save, but then restore becomes problematic.\n\t   * This has become trickier than I expected.\n\t   */\n#endif\n\t  sc->code = cdr(sc->code);\n\n\t  /* here [after the cdr] sc->args is nil, sc->value is the operator (car of list), sc->code is the rest -- the args.\n\t   *   EVAL_ARGS0 can be called within the EVAL_ARGS1 loop if it's a nested expression:\n\t   * (+ 1 2 (* 2 3)):\n\t   *   e0args: (), value: +, code: (1 2 (* 2 3))\n\t   *   e1args: (+), value: +, code: (1 2 (* 2 3))\n\t   *   e1args: (1 +), value: +, code: (2 (* 2 3))\n\t   *   e1args: (2 1 +), value: +, code: ((* 2 3))\n\t   *   e0args: (), value: *, code: (2 3)\n\t   *   e1args: (*), value: *, code: (2 3)\n\t   *   e1args: (2 *), value: *, code: (3)\n\t   *   e1args: (3 2 *), value: *, code: ()\n\t   *   <end -> apply the * op>\n\t   *   e1args: (6 2 1 +), value: +, code: ()\n\t   */\n\t}\n      \n      \n    EVAL_ARGS:\n    case OP_EVAL_ARGS1:\n      /* this is where most of s7's compute time goes */\n      /* expanding the function calls (s7_cons, new_cell, and eval_symbol) in place seems to speed up s7 by a noticeable amount! */\n      /*    before expansion: sc->args = s7_cons(sc, sc->value, sc->args); */\n      {\n        s7_pointer x;\n#if HAVE_PTHREADS\n\tx = new_cell(sc); \n#else\n\tif (sc->free_heap_top > 0)\n\t  x = sc->free_heap[--(sc->free_heap_top)];\n\telse x = new_cell(sc);\n#endif\n\tcar(x) = sc->value;\n\tcdr(x) = sc->args;\n\tset_type(x, T_PAIR);\n\tsc->args = x;\n      }\n\n      /* 1st time, value = op, args = nil (only e0 entry is from op_eval above), code is full list (at e0) */\n      if (is_pair(sc->code))  /* evaluate current arg */\n\t{ \n\t  int typ;\n\t  s7_pointer car_code;\n\t  car_code = car(sc->code);\n\t  typ = type(car_code);\n\n\t  if (typ == T_PAIR)\n\t    {\n\t      push_stack(sc, OP_EVAL_ARGS1, sc->args, cdr(sc->code));\n\t      sc->code = car_code;\n\t      sc->args = sc->NIL;\n\t      goto EVAL;\n\t    }\n\n\t  if (typ == T_SYMBOL)\n\t    {\n\t      /* expand eval_symbol here to speed it up, was sc->value = eval_symbol(sc, car(sc->code)); */\n\t      s7_pointer x;\n\t      if (is_not_local(car_code))\n\t\tx = symbol_global_slot(car_code);\n\t      else x = s7_find_symbol_in_environment(sc, sc->envir, car_code, true);\n\t      if (x != sc->NIL) \n\t\tsc->value = symbol_value(x);\n\t      else sc->value = eval_symbol(sc, car_code);\n\t    }\n\t  \n\t  else sc->value = car_code;\n\t  sc->code = cdr(sc->code);\n\t  goto EVAL_ARGS;\n\t}\n      else                       /* got all args -- go to apply */\n\t{\n\t  if (sc->code != sc->NIL)\n\t    {\n\t      int len;\n\t      char *msg, *argstr;\n\t      s7_pointer result;\n\t      argstr = s7_object_to_c_string(sc, s7_append(sc, \n\t\t\t\t\t\t\t   s7_reverse(sc, cdr(sc->args)), \n\t\t\t\t\t\t\t   s7_cons(sc, car(sc->args), sc->code)));\n\t      len = strlen(argstr) + 32;\n\t      msg = (char *)malloc(len * sizeof(char));\n\t      len = snprintf(msg, len, \"improper list of arguments: %s?\", argstr);\n\t      free(argstr);\n\t      result = s7_make_string_with_length(sc, msg, len);\n\t      free(msg);\n\t      s7_error(sc, sc->ERROR, result);\n\t    }\n\n\t  sc->args = safe_reverse_in_place(sc, sc->args); \n\t  /* we could omit this reversal in many cases: all built in ops could\n\t   *   assume reversed args, things like eq? and + don't care about order, etc.\n\t   *   But, I think the reversal is not taking any noticeable percentage of\n\t   *   the overall compute time (ca 1% according to callgrind).\n\t   */\n\t  sc->code = car(sc->args);\n\t  sc->args = cdr(sc->args);\n\t  /* goto APPLY;  */\n\t}\n      \n      \n      /* ---------------- OP_APPLY ---------------- */\n    APPLY:\n    case OP_APPLY:      /* apply 'code' to 'args' */\n\n#if WITH_PROFILING\n      symbol_calls(sc->code)++;\n#endif\n\n      if (*(sc->tracing)) \n\ttrace_apply(sc);\n\n    APPLY_WITHOUT_TRACE:\n      if (sc->stack_top >= sc->stack_size2)\n\tincrease_stack_size(sc);\n\n      switch (type(sc->code))\n\t{\n\tcase T_C_FUNCTION: \t                  /* -------- C-based function -------- */\n\t  {\n\t    int len;\n\t    len = safe_list_length(sc, sc->args);\n\t    if (len < c_function_required_args(sc->code))\n\t      return(s7_error(sc, \n\t\t\t      sc->WRONG_NUMBER_OF_ARGS, \n\t\t\t      make_list_3(sc, \n\t\t\t\t\t  s7_make_string_with_length(sc, \"~A: not enough arguments: ~A\", 28), \n\t\t\t\t\t  sc->code, sc->args)));\n\t    \n\t    if (c_function_all_args(sc->code) < len)\n\t      return(s7_error(sc, \n\t\t\t      sc->WRONG_NUMBER_OF_ARGS, \n\t\t\t      make_list_3(sc, \n\t\t\t\t\t  s7_make_string_with_length(sc, \"~A: too many arguments: ~A\", 26),\n\t\t\t\t\t  sc->code, sc->args)));\n\n\t    sc->value = c_function_call(sc->code)(sc, sc->args);\n\n\t    if (sc->stack_top != 0)\n\t      pop_stack(sc);\n\t    else return(sc->value); /* or perhaps sc->F? */\n\n\t    /* this is trying to get around an existing, but very well-hidden bug:\n\t     *  (defgenerator tanhsin (frequency 100.0))\n\t     *  (define (tanhsin gen) #f)\n\t     *  (define (crash) (let ((hi (make-tanhsin))) (catch #t (lambda () (mus-run hi 0.0)) (lambda args 123))))\n\t     *  (crash)\n\t     * and we pop_stack once too often somewhere.  I'd put a guard OP_QUIT at the start, but \n\t     *   reset_stack would need to be changed and so on.\n\t     */\n\n\t    goto START;\n\t  }\n\n\n\tcase T_C_MACRO: \t                    /* -------- C-based macro -------- */\n\t  {\n\t    int len;\n\t    s7_pointer macsym;\n\t    macsym = caar(sc->args);\n\t    sc->args = cdar(sc->args);\n\n\t    len = safe_list_length(sc, sc->args);\n\t    if (len < c_macro_required_args(sc->code))\n\t      return(s7_error(sc, \n\t\t\t      sc->WRONG_NUMBER_OF_ARGS, \n\t\t\t      make_list_3(sc, \n\t\t\t\t\t  s7_make_string_with_length(sc, \"~A: not enough arguments: ~A\", 28), \n\t\t\t\t\t  macsym, sc->args)));\n\t    \n\t    if (c_macro_all_args(sc->code) < len)\n\t      return(s7_error(sc, \n\t\t\t      sc->WRONG_NUMBER_OF_ARGS, \n\t\t\t      make_list_3(sc, \n\t\t\t\t\t  s7_make_string_with_length(sc, \"~A: too many arguments: ~A\", 26),\n\t\t\t\t\t  macsym, sc->args)));\n\n\t    sc->code = c_macro_call(sc->code)(sc, sc->args);\n\t    sc->args = sc->NIL;\n\t    goto EVAL;\n\t  }\n\n\t  \n\tcase T_CLOSURE:                              /* -------- normal function (lambda), or macro -------- */\n\tcase T_MACRO:\n\t  sc->envir = new_frame_in_env(sc, closure_environment(sc->code)); \n\t  \n\t  /* load up the current args into the ((args) (lambda)) layout [via the current environment] */\n\n\t  /* (defmacro hi (a b) `(+ ,a ,b)) */\n\t  /*   -> code: #<macro>, args: ((hi 2 3)), closure args: (defmac-9) */\n\t  /*   then back again: code: #<closure>, args: (2 3), closure args: (a b) */\n\n\t  for (sc->x = closure_args(sc->code), sc->y = sc->args; is_pair(sc->x); sc->x = cdr(sc->x), sc->y = cdr(sc->y)) \n\t    {\n\t      if (sc->y == sc->NIL)\n\t\treturn(s7_error(sc, \n\t\t\t\tsc->WRONG_NUMBER_OF_ARGS, \n\t\t\t\tmake_list_3(sc, \n\t\t\t\t\t    s7_make_string_with_length(sc, \"~A: not enough arguments: ~A\", 28),\n\t\t\t\t\t    g_procedure_source(sc, make_list_1(sc, sc->code)), \n\t\t\t\t\t    sc->args)));\n\t      add_to_local_environment(sc, car(sc->x), car(sc->y));\n\t    }\n\t  \n\t  if (sc->x == sc->NIL) \n\t    {\n\t      if (sc->y != sc->NIL)\n\t\treturn(s7_error(sc, \n\t\t\t\tsc->WRONG_NUMBER_OF_ARGS, \n\t\t\t\tmake_list_3(sc, \n\t\t\t\t\t    s7_make_string_with_length(sc, \"~A: too many arguments: ~A\", 26), \n\t\t\t\t\t    g_procedure_source(sc, make_list_1(sc, sc->code)), \n\t\t\t\t\t    sc->args)));\n\t    } \n\t  else \n\t    {\n\t      if (s7_is_symbol(sc->x))\n\t\tadd_to_local_environment(sc, sc->x, sc->y); \n\t      else \n\t\t{\n\t\t  if (is_macro(sc->code))\n\t\t    return(eval_error(sc, \"~A: undefined argument to macro?\", sc->x));\n\t\t  else return(eval_error(sc, \"~A: undefined argument to function?\", sc->x));\n\t\t}\n\t    }\n\n\t  sc->code = closure_body(sc->code);\n\t  sc->args = sc->NIL;\n\t  goto BEGIN;\n\t  \n\tcase T_CLOSURE_STAR:\t                  /* -------- define* (lambda*) -------- */\n\t  { \n\t    sc->envir = new_frame_in_env(sc, closure_environment(sc->code)); \n\t    \n\t    /* sc->code is a closure: ((args body) envir)\n\t     * (define* (hi a (b 1)) (+ a b))\n\t     * (procedure-source hi) -> (lambda* (a (b 1)) (+ a b))\n\t     *\n\t     * so rather than spinning through the args binding names to values in the\n\t     *   procedure's new environment (as in the usual closure case above),\n\t     *   we scan the current args, and match against the\n\t     *   template in the car of the closure, binding as we go.\n\t     *\n\t     * for each actual arg, if it's not a keyword that matches a member of the \n\t     *   template, bind it to its current (place-wise) arg, else bind it to\n\t     *   that arg.  If it's the symbol :key or :optional, just go on.\n\t     *   If it's :rest bind the next arg to the trailing args at this point.\n\t     *   All args can be accessed by their name as a keyword.\n\t     *   In other words (define* (hi (a 1)) ...) is the same as (define* (hi :key (a 1)) ...) etc.\n\t     *\n\t     * all args are optional, any arg with no default value defaults to #f.\n\t     */\n\t    \n\t    /* set all default values */\n\t    for (sc->z = closure_args(sc->code); is_pair(sc->z); sc->z = cdr(sc->z))\n\t      {\n\t\t/* bind all the args to something (default value or #f or maybe #undefined) */\n\t\tif (!((car(sc->z) == sc->KEY_KEY) ||\n\t\t      (car(sc->z) == sc->KEY_OPTIONAL) ||\n\t\t      (car(sc->z) == sc->KEY_REST)))                  /* :optional and :key always ignored, :rest dealt with later */\n\t\t  {\n\t\t    if (is_pair(car(sc->z)))                          /* (define* (hi (a mus-next)) a) */\n\t\t      add_to_local_environment(sc,                    /* or (define* (hi (a 'hi)) (list a (eq? a 'hi))) */\n\t\t\t\t\t       caar(sc->z), \n\t\t\t\t\t       lambda_star_argument_default_value(sc, cadar(sc->z)));\n\t\t                                                      /* mus-next, for example, needs to be evaluated before binding */\n\t\t    else add_to_local_environment(sc, car(sc->z), sc->F);\n\t\t  }\n\t      }\n\t    if (s7_is_symbol(sc->z))                                  /* dotted (last) arg? -- make sure its name exists in the current environment */\n\t      add_to_local_environment(sc, sc->z, sc->F);\n\t    \n\t    /* now get the current args, re-setting args that have explicit values */\n\t    sc->x = closure_args(sc->code);\n\t    sc->y = sc->args; \n\t    sc->z = sc->NIL;\n\t    while ((is_pair(sc->x)) &&\n\t\t   (is_pair(sc->y)))\n\t      {\n\t\tif ((car(sc->x) == sc->KEY_KEY) ||\n\t\t    (car(sc->x) == sc->KEY_OPTIONAL))\n\t\t  sc->x = cdr(sc->x);\n\t\telse\n\t\t  {\n\t\t    if (car(sc->x) == sc->KEY_REST)\n\t\t      {\n\t\t\t/* next arg is bound to trailing args from this point as a list */\n\t\t\tsc->z = sc->KEY_REST;\n\t\t\tsc->x = cdr(sc->x);\n\t\t\tif (is_pair(car(sc->x)))\n\t\t\t  lambda_star_argument_set_value(sc, caar(sc->x), sc->y);\n\t\t\telse lambda_star_argument_set_value(sc, car(sc->x), sc->y);\n\t\t\tsc->y = cdr(sc->y);\n\t\t\tsc->x = cdr(sc->x);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tif (s7_is_keyword(car(sc->y)))\n\t\t\t  {\n\t\t\t    char *name;   /* need to remove the ':' before checking the lambda args */\n\t\t\t    s7_pointer sym;\n\t\t\t    name = symbol_name(car(sc->y));\n\t\t\t    if (name[0] == ':')\n\t\t\t      sym = s7_make_symbol(sc, (const char *)(name + 1));\n\t\t\t    else\n\t\t\t      {\n\t\t\t\t/* must be a trailing ':' here, else not s7_is_keyword */\n\t\t\t\tname[symbol_name_length(car(sc->y)) - 1] = '\\0';\n\t\t\t\tsym = s7_make_symbol(sc, name);\n\t\t\t\tname[symbol_name_length(car(sc->y)) - 1] = ':';\n\t\t\t      }\n\t\t\t    if (lambda_star_argument_set_value(sc, sym, car(cdr(sc->y))))\n\t\t\t      sc->y = cddr(sc->y);\n\t\t\t    else         /* might be passing a keyword as a normal argument value! */\n\t\t\t      {\n\t\t\t\tif (is_pair(car(sc->x)))\n\t\t\t\t  lambda_star_argument_set_value(sc, caar(sc->x), car(sc->y));\n\t\t\t\telse lambda_star_argument_set_value(sc, car(sc->x), car(sc->y));\n\t\t\t\tsc->y = cdr(sc->y);\n\t\t\t      }\n\t\t\t  }\n\t\t\telse \n\t\t\t  {\n\t\t\t    if (is_pair(car(sc->x)))\n\t\t\t      lambda_star_argument_set_value(sc, caar(sc->x), car(sc->y));\n\t\t\t    else lambda_star_argument_set_value(sc, car(sc->x), car(sc->y));\n\t\t\t    sc->y = cdr(sc->y);\n\t\t\t  }\n\t\t\tsc->x = cdr(sc->x);\n\t\t      }\n\t\t  }\n\t      }\n\n\t    /* check for trailing args with no :rest arg */\n\t    if (sc->y != sc->NIL)\n\t      {\n\t\tif ((sc->x == sc->NIL) &&\n\t\t    (is_pair(sc->y)))\n\t\t  {\n\t\t    if (sc->z != sc->KEY_REST)\n\t\t      return(s7_error(sc, \n\t\t\t\t      sc->WRONG_NUMBER_OF_ARGS, \n\t\t\t\t      make_list_3(sc, \n\t\t\t\t\t\t  s7_make_string_with_length(sc, \"~A: too many arguments: ~A\", 22), \n\t\t\t\t\t\t  g_procedure_source(sc, make_list_1(sc, sc->code)), \n\t\t\t\t\t\t  sc->args)));\n\t\t  } \n\t\telse \n\t\t  {\n\t\t    /* final arg was dotted? */\n\t\t    if (s7_is_symbol(sc->x))\n\t\t      add_to_local_environment(sc, sc->x, sc->y); \n\t\t  }\n\t      }\n\n\t    /* evaluate the function body */\n\t    sc->code = closure_body(sc->code);\n\t    sc->args = sc->NIL;\n\t    goto BEGIN;\n\t  }\n\t\t\n\tcase T_CONTINUATION:\t                  /* -------- continuation (\"call-with-continuation\") -------- */\n\t  {\n\t    check_for_dynamic_winds(sc, sc->code);\n\t    sc->stack = copy_stack(sc, continuation_stack(sc->code), continuation_stack_top(sc->code));\n\t    sc->stack_size = continuation_stack_size(sc->code);\n\t    sc->stack_size2 = sc->stack_size / 2;\n\t    sc->stack_top = continuation_stack_top(sc->code);\n\t    if (sc->args == sc->NIL)\n\t      sc->value = sc->NIL;\n\t    else\n\t      {\n\t\tif (cdr(sc->args) == sc->NIL)\n\t\t  sc->value = car(sc->args);\n\t\telse sc->value = splice_in_values(sc, sc->args);\n\t      }\n\t    pop_stack(sc);\n\t    goto START;\n\t  }\n\n\tcase T_GOTO:\t                          /* -------- goto (\"call-with-exit\") -------- */\n\t  {\n\t    int i, new_stack_top;\n\t    new_stack_top = (sc->code)->object.goto_loc;\n\t    /* look for dynamic-wind in the stack section that we are jumping out of */\n\t    for (i = sc->stack_top - 1; i > new_stack_top; i -= 4)\n\t      {\n\t\topcode_t op;\n\t\top = (opcode_t)s7_integer(vector_element(sc->stack, i));\n\t\tif (op == OP_DYNAMIC_WIND)\n\t\t  {\n\t\t    sc->z = vector_element(sc->stack, i - 3);\n\t\t    if (dynamic_wind_state(sc->z) == T_DWIND_BODY)\n\t\t      {\n\t\t\tpush_stack(sc, OP_EVAL_DONE, sc->args, sc->code); \n\t\t\tsc->args = sc->NIL;\n\t\t\tsc->code = dynamic_wind_out(sc->z);\n\t\t\teval(sc, OP_APPLY);\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (op == OP_TRACE_RETURN)\n\t\t      sc->trace_depth--;\n\t\t  }\n\t      }\n\t    \n\t    sc->stack_top = new_stack_top;\n\t    sc->value = (sc->args != sc->NIL) ? car(sc->args) : sc->NIL;\n\t    pop_stack(sc);\n\t    goto START;\n\t  }\n\n\tcase T_C_OBJECT:\t                  /* -------- applicable object -------- */\n\t  sc ->value = s7_apply_object(sc, sc->code, sc->args);\n\t  if (sc->stack_top > 0)\n\t    pop_stack(sc);\n\t  goto START;\n\n\tcase T_VECTOR:                            /* -------- vector as applicable object -------- */\n\t  /* sc->code is the vector, sc->args is the list of dimensions */\n\t  sc->value = vector_ref_1(sc, sc->code, sc->args);\n\t  pop_stack(sc);\n\t  goto START;\n\n\tcase T_STRING:                            /* -------- string as applicable object -------- */\n\t  if (cdr(sc->args) != sc->NIL)\n\t    return(s7_wrong_number_of_args_error(sc, \"string ref (via string as applicable object)\", sc->args));\n\t  sc->value = g_string_ref(sc, make_list_2(sc, sc->code, car(sc->args)));\n\t  pop_stack(sc);\n\t  goto START;\n\n\tcase T_PAIR:                              /* -------- list as applicable object -------- */\n\t  if (cdr(sc->args) != sc->NIL)\n\t    return(s7_wrong_number_of_args_error(sc, \"list ref (via list as applicable object)\", sc->args));\n\t  /* \n\t   * I suppose we could take n args here = repeated list-refs\n\t   * ((list (list 1 2) 3) 0 0) -> 1 (caar)\n\t   */\n\t  sc->value = g_list_ref(sc, make_list_2(sc, sc->code, car(sc->args)));\n\t  pop_stack(sc);\n\t  goto START;\n\n\tcase T_HASH_TABLE:                        /* -------- hash-table as applicable object -------- */\n\t  if (cdr(sc->args) != sc->NIL)\n\t    return(s7_wrong_number_of_args_error(sc, \"hash-table ref (via hash-table as applicable object)\", sc->args));\n\t  sc->value = g_hash_table_ref(sc, make_list_2(sc, sc->code, car(sc->args)));\n\t  pop_stack(sc);\n\t  goto START;\n\n\tdefault:\n\t  return(eval_error(sc, \"attempt to apply ~S?\", sc->code));\n\t}\n      /* ---------------- end OP_APPLY ---------------- */\n\n      \n    case OP_EVAL_MACRO:    /* after (scheme-side) macroexpansion, evaluate the resulting expression */\n      /* if the macro is more than a quasiquoted expression, then we come through here twice */\n      sc->code = sc->value;\n      goto EVAL;\n      \n      \n    case OP_LAMBDA: \n      /* this includes unevaluated symbols (direct symbol table refs) in macro arg list */\n      if ((!is_pair(sc->code)) ||\n\t  (!is_pair(cdr(sc->code))))                               /* (lambda) or (lambda #f) */\n\treturn(eval_error(sc, \"lambda: no args or no body? ~A\", sc->code));\n\n      if (!s7_is_list(sc, car(sc->code)))\n\t{\n\t  if (!s7_is_symbol(car(sc->code)))                        /* (lambda \"hi\" ...) */\n\t    return(eval_error(sc, \"lambda parameter ~S is not a symbol\", car(sc->code)));\n\t}\n      else\n\t{\n\t  for (sc->x = car(sc->code); sc->x != sc->NIL; sc->x = cdr(sc->x))\n\t    if ((!s7_is_symbol(sc->x)) &&                          /* (lambda (a . b) 0) */\n\t\t((!is_pair(sc->x)) ||                              /* (lambda (a . 0.0) a) */\n\t\t (!s7_is_symbol(car(sc->x)))))                     /* (lambda (\"a\") a) or (lambda (a \"a\") a) */\n\t      return(eval_error(sc, \"lambda parameter ~S is not a symbol\", sc->x));\n\t}\n      sc->value = make_closure(sc, sc->code, sc->envir, T_CLOSURE);\n      pop_stack(sc);\n      goto START;\n\n\n    case OP_LAMBDA_STAR:\n      if ((!is_pair(sc->code)) ||\n\t  (!is_pair(cdr(sc->code))))                                /* (lambda*) or (lambda* #f) */\n\treturn(eval_error(sc, \"lambda*: no args or no body? ~A\", sc->code));\n\n      if (!s7_is_list(sc, car(sc->code)))\n\t{\n\t  if (!s7_is_symbol(car(sc->code)))                        /* (lambda* \"hi\" ...) */\n\t    return(eval_error(sc, \"lambda* parameter ~S is not a symbol\", car(sc->code)));\n\t}\n      else\n\t{ \n\t  for (sc->x = car(sc->code); sc->x != sc->NIL; sc->x = cdr(sc->x))\n\t    if ((!s7_is_symbol(sc->x)) &&                          \n\t\t((!is_pair(sc->x)) ||\n\t\t ((!s7_is_symbol(car(sc->x))) &&\n\t\t  ((!is_pair(car(sc->x))) ||                       /* check for stuff like (lambda* (()) 1) (lambda* ((a . 0)) 1) etc */\n\t\t   (!s7_is_symbol(caar(sc->x))) ||\n\t\t   (cdar(sc->x) == sc->NIL) ||\n\t\t   (cddar(sc->x) != sc->NIL)))))\n\t      return(eval_error(sc, \"lambda* parameter ~S is confused\", sc->x));\n\t}\n      sc->value = make_closure(sc, sc->code, sc->envir, T_CLOSURE_STAR);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_QUOTE:\n      if ((!is_pair(sc->code)) ||                /* (quote . -1) */\n\t  (cdr(sc->code) != sc->NIL))            /* (quote . (1 2)) or (quote 1 1) */\n\treturn(eval_error(sc, \"quote syntax error ~A\", sc->code));\n\n      sc->value = car(sc->code);\n      /* should this be immutable? (set-car! '(1 . 2) 3) */\n      pop_stack(sc);\n      goto START;\n\n      \n    case OP_DEFINE_CONSTANT1:\n      /* define-constant -> OP_DEFINE_CONSTANT0 -> OP_DEFINE0..1, then back to here */\n      /*   at this point, sc->value is the symbol that we want to be immutable, sc->code is the original pair */\n\n      sc->x = s7_find_symbol_in_environment(sc, sc->envir, sc->value, false);\n      s7_set_immutable(car(sc->x));\n      pop_stack(sc);\n      goto START;\n\n\n    case OP_DEFINE_CONSTANT0:\n      push_stack(sc, OP_DEFINE_CONSTANT1, sc->NIL, sc->code);\n\n      \n    case OP_DEFINE_STAR:\n    case OP_DEFINE0:\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"define: nothing to define? ~A\", sc->code));   /* (define) */\n\n      if (!is_pair(cdr(sc->code)))\n\treturn(eval_error(sc, \"define: no value? ~A\", sc->code));            /* (define var) */\n\n      if ((!is_pair(car(sc->code))) &&\n\t  (cddr(sc->code) != sc->NIL))                                       /* (define var 1 . 2) */\n\treturn(eval_error(sc, \"define: more than 1 value? ~A\", sc->code));   /* (define var 1 2) */\n\n      if (is_pair(car(sc->code))) \n\t{\n\t  sc->x = caar(sc->code);\n\t  if (sc->op == OP_DEFINE_STAR)\n\t    sc->code = s7_cons(sc, sc->LAMBDA_STAR, s7_cons(sc, cdar(sc->code), cdr(sc->code)));\n\t  else sc->code = s7_cons(sc, sc->LAMBDA, s7_cons(sc, cdar(sc->code), cdr(sc->code)));\n\t} \n      else \n\t{\n\t  sc->x = car(sc->code);\n\t  sc->code = cadr(sc->code);\n\t}\n      if (!s7_is_symbol(sc->x))                                             /* (define (3 a) a) */\n\treturn(eval_error(sc, \"define a non-symbol? ~S\", sc->x));\n\n      if (s7_is_immutable(sc->x))                                           /* (define pi 3) or (define (pi a) a) */\n\treturn(eval_error(sc, \"define: ~S is immutable\", sc->x));\n      \n      push_stack(sc, OP_DEFINE1, sc->NIL, sc->x);\n      goto EVAL;\n      \n      \n    case OP_DEFINE1:\n      /* sc->code is the symbol being defined, sc->value is its value\n       *   if sc->value is a closure, car is of the form ((args...) body...)\n       *   so the doc string if any is (cadr (car value))\n       *   and the arg list gives the number of optional args up to the dot\n       */\n\n      /* it's not possible to expand and replace macros at this point without evaluating\n       *   the body.  Just as examples, say we have a macro \"mac\", \n       *   (define (hi) (call/cc (lambda (mac) (mac 1))))\n       *   (define (hi) (quote (mac 1))) or macroexpand etc\n       *   (define (hi mac) (mac 1)) assuming mac here is a function passed as an arg,\n       * etc...  \n       */\n\n      /* if we're defining a function, add its symbol to the new function's environment under the name __func__ */\n      if ((is_closure(sc->value)) || \n\t  (is_closure_star(sc->value)))\n\tclosure_environment(sc->value) = \n\t  s7_cons(sc, \n\t\t  s7_cons(sc, \n\t\t\t  port_filename(sc->input_port) ? s7_immutable_cons(sc, \n\t\t\t\t\t\t\t\t\t   sc->__FUNC__, \t\t\t\t\t\t\t\t\t       \n\t\t\t\t\t\t\t\t\t   make_list_3(sc, \n\t\t\t\t\t\t\t\t\t\t       sc->code,\n\t\t\t\t\t\t\t\t\t\t       s7_make_string(sc, port_filename(sc->input_port)),\n\t\t\t\t\t\t\t\t\t\t       s7_make_integer(sc, port_line_number(sc->input_port)))) :\n\t\t\t\t\t\t\t s7_immutable_cons(sc, sc->__FUNC__, sc->code), \n\t\t\t  sc->NIL), \n\t\t  closure_environment(sc->value));\n      else\n\t{\n\t  if (s7_is_procedure_with_setter(sc->value))\n\t    {\n\t      s7_pws_t *f = (s7_pws_t *)s7_object_value(sc->value);\n\t      f->name = s7_strdup(symbol_name(sc->code));\n\t    }\n\t}\n\n      /* add the newly defined thing to the current environment */\n      sc->x = s7_find_symbol_in_environment(sc, sc->envir, sc->code, false);\n      if (sc->x != sc->NIL) \n\tset_symbol_value(sc->x, sc->value); \n      else add_to_current_environment(sc, sc->code, sc->value); \n      sc->value = sc->code;\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_SET2:\n      sc->code = s7_cons(sc, s7_cons(sc, sc->value, sc->args), sc->code);\n\n      \n    case OP_SET0:                                                 /* entry for set! */\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"set! syntax error ~A\", sc->code)); /* set! . 1) */\n\n      if (s7_is_immutable(car(sc->code)))                         /* (set! pi 3) */\n\treturn(eval_error(sc, \"set!: can't alter immutable object: ~S\", car(sc->code)));\n      \n      if ((cdr(sc->code) == sc->NIL) ||\n\t  (cddr(sc->code) != sc->NIL))                            /* (set! var) */\n\treturn(eval_error(sc, \"~A: wrong number of args to set!\", sc->code));\n\n      if (is_pair(car(sc->code))) /* has accessor */\n\t{\n\t  if (is_pair(caar(sc->code)))\n\t    {\n\t      push_stack(sc, OP_SET2, cdar(sc->code), cdr(sc->code));\n\t      sc->code = caar(sc->code);\n\t      goto EVAL;\n\t    }\n\t  \n\t  if (!s7_is_symbol(caar(sc->code)))                      /* (set! (1 2) #t) */\n\t    return(eval_error(sc, \"~A: non-symbol as generalized set! accessor?\", sc->code)); \n\n\t  sc->x = s7_symbol_value(sc, caar(sc->code));\n\t  if ((is_c_object(sc->x)) &&\n\t      (object_set_function(sc->x)))\n\t    sc->code = s7_cons(sc, sc->OBJECT_SET, s7_append(sc, car(sc->code), cdr(sc->code)));   /* use set method (append flattens the lists) */\n\t  else \n\t    {\n\t      switch (type(sc->x))\n\t\t{\n\t\tcase T_VECTOR:\n\t\t  /* sc->x is the vector, sc->code is expr without the set! */\n\t\t  /*  args have not been evaluated! */\n\t\t  sc->code = s7_cons(sc, sc->VECTOR_SET, s7_append(sc, car(sc->code), cdr(sc->code)));\n\t\t  break;\n\t\t  \n\t\tcase T_STRING:\n\t\t  sc->code = s7_cons(sc, sc->STRING_SET, s7_append(sc, car(sc->code), cdr(sc->code))); \n\t\t  break;\n\n\t\tcase T_PAIR:\n\t\t  sc->code = s7_cons(sc, sc->LIST_SET, s7_append(sc, car(sc->code), cdr(sc->code))); \n\t\t  break;\n\n\t\tcase T_HASH_TABLE:\n\t\t  sc->code = s7_cons(sc, sc->HASH_TABLE_SET, s7_append(sc, car(sc->code), cdr(sc->code))); \n\t\t  break;\n\n\t\tdefault:\n\t\t  return(eval_error(sc, \"no generalized set for ~A\", caar(sc->code)));\n\t\t}\n\t    }\n\t}\n      else \n\t{\n\t  if (!s7_is_symbol(car(sc->code)))                  /* (set! 12345 1) */\n\t    return(eval_error(sc, \"set! can't change ~S\", car(sc->code)));\n\t  \n\t  push_stack(sc, OP_SET1, sc->NIL, car(sc->code));\n\t  sc->code = cadr(sc->code);\n\t}\n      goto EVAL;\n      \n      \n    case OP_SET1:     \n      sc->y = s7_find_symbol_in_environment(sc, sc->envir, sc->code, true);\n      if (sc->y != sc->NIL) \n\t{\n#if WITH_ENCAPSULATION\n\t  if (is_encapsulating(sc))\n\t    encapsulate(sc, sc->code);\n#endif\n\t  set_symbol_value(sc->y, sc->value); \n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      return(eval_error(sc, \"set! ~A: unbound variable\", sc->code));\n      \n      \n    case OP_IF0:\n      if (!is_pair(sc->code))                               /* (if) or (if . 1) */\n\treturn(eval_error(sc, \"(if): if needs at least 2 expressions\", sc->code));\n\n      if (!is_pair(cdr(sc->code)))                          /* (if 1) */\n\treturn(eval_error(sc, \"(if ~A): if needs another clause\", car(sc->code)));\n      \n      if ((!is_pair(cddr(sc->code))) &&\n\t  (cddr(sc->code) != sc->NIL))                      /* (if 1 2 . 3) */\n\treturn(eval_error(sc, \"if: ~A has improper list?\", sc->code));\n\n      if ((is_pair(cddr(sc->code))) && \n\t  (cdddr(sc->code) != sc->NIL))                     /* (if 1 2 3 4) */\n\treturn(eval_error(sc, \"too many clauses for if: ~A\", sc->code));\n      \n      \n      push_stack(sc, OP_IF1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_IF1:\n      if (is_true(sc, sc->value))\n\tsc->code = car(sc->code);\n      else\n\tsc->code = cadr(sc->code);  /* (if #f 1) ==> #<unspecified> because car(sc->NIL) = sc->UNSPECIFIED */\n      goto EVAL;\n      \n      \n    case OP_LET0:\n      /* sc->code is everything after the let: (let ((a 1)) a) so sc->code is (((a 1)) a) */\n      /*   car it can be either a list or a symbol (\"named let\") */\n\n      if ((!is_pair(sc->code)) ||            /* (let . 1) */\n\t  (!is_pair(cdr(sc->code))) ||       /* (let) */\n\t  ((!is_pair(car(sc->code))) &&      /* (let 1 ...) */\n\t   (car(sc->code) != sc->NIL) &&\n\t   (!s7_is_symbol(car(sc->code)))))\n\treturn(eval_error(sc, \"let syntax error: ~A\", sc->code));\n\n      if ((s7_is_symbol(car(sc->code))) &&\n\t  (((!is_pair(cadr(sc->code))) &&    /* (let hi #t) */\n\t    (cadr(sc->code) != sc->NIL)) ||\n\t   (cddr(sc->code) == sc->NIL)))     /* (let hi ()) */\n      \treturn(eval_error(sc, \"named let syntax error: ~A\", sc->code));\n\n      sc->args = sc->NIL;\n      sc->value = sc->code;\n      sc->code = s7_is_symbol(car(sc->code)) ? cadr(sc->code) : car(sc->code);\n      \n      \n    case OP_LET1:       /* let -- calculate parameters */\n      sc->args = s7_cons(sc, sc->value, sc->args);\n      if (is_pair(sc->code)) \n\t{ \n\t  if (!is_pair(car(sc->code)))          /* (let ((x)) ...) or (let ((x 1) . (y 2)) ...) */\n\t    return(eval_error(sc, \"let syntax error (no value?): ~A\", car(sc->code)));\n\n\t  if (!(is_pair(cdar(sc->code))))       /* (let ((x . 1))...) */\n\t    return(eval_error(sc, \"let syntax error (not a proper list?): ~A\", car(sc->code)));\n\n\t  if (cddar(sc->code) != sc->NIL)       /* (let ((x 1 2 3)) ...) */\n\t    return(eval_error(sc, \"let syntax error (more than one value?): ~A\", car(sc->code)));\n\n\t  push_stack(sc, OP_LET1, sc->args, cdr(sc->code));\n\t  sc->code = cadar(sc->code);\n\t  sc->args = sc->NIL;\n\t  goto EVAL;\n\t} \n\n      if (sc->code != sc->NIL)                  /* (let* ((a 1) . b) a) */\n\treturn(eval_error(sc, \"let var list improper?: ~A\", sc->code));\n\n      sc->args = safe_reverse_in_place(sc, sc->args);\n      sc->code = car(sc->args);\n      sc->args = cdr(sc->args);\n      \n      \n    case OP_LET2:\n      sc->envir = new_frame_in_env(sc, sc->envir); \n      for (sc->x = s7_is_symbol(car(sc->code)) ? cadr(sc->code) : car(sc->code), sc->y = sc->args; sc->y != sc->NIL; sc->x = cdr(sc->x), sc->y = cdr(sc->y)) \n\t{\n\t  if (!(s7_is_symbol(caar(sc->x))))\n\t    return(eval_error(sc, \"bad variable ~S in let bindings\", car(sc->code)));\n\n\t  /* check for name collisions -- not sure this is required by Scheme */\n\t  if (s7_find_symbol_in_environment(sc, sc->envir, caar(sc->x), false) != sc->NIL)\n\t    return(eval_error(sc, \"duplicate identifier in let\", caar(sc->x)));\n\n\t  add_to_local_environment(sc, caar(sc->x), car(sc->y)); /* expansion here does not help */\n\t}\n      if (s7_is_symbol(car(sc->code))) \n\t{    /* named let */\n\t  for (sc->x = cadr(sc->code), sc->args = sc->NIL; sc->x != sc->NIL; sc->x = cdr(sc->x)) \n\t    sc->args = s7_cons(sc, caar(sc->x), sc->args);\n\t  \n\t  sc->x = s7_make_closure(sc, s7_cons(sc, safe_reverse_in_place(sc, sc->args), cddr(sc->code)), sc->envir); \n\t  add_to_local_environment(sc, car(sc->code), sc->x); \n\t  sc->code = cddr(sc->code);\n\t  sc->args = sc->NIL;\n\t} \n      else \n\t{\n\t  sc->code = cdr(sc->code);\n\t  sc->args = sc->NIL;\n\t}\n      goto BEGIN;\n      \n      \n    case OP_LET_STAR0:\n      if ((!is_pair(sc->code)) ||                /* (let* . 1) */\n\t  (!is_pair(cdr(sc->code))) ||           /* (let*) */\n\t  ((!is_pair(car(sc->code))) &&          /* (let* 1 ...), also there's no named let* */\n\t   (car(sc->code) != sc->NIL)))\n\treturn(eval_error(sc, \"let* syntax error: ~A\", sc->code));\n      \n      if (car(sc->code) == sc->NIL) \n\t{\n\t  sc->envir = new_frame_in_env(sc, sc->envir); \n\t  sc->code = cdr(sc->code);\n\t  goto BEGIN;\n\t}\n      \n      if ((!is_pair(car(sc->code))) ||            /* (let* x ... ) */\n\t  (!is_pair(caar(sc->code))) ||           /* (let* (x) ...) */\n\t  (!is_pair(cdaar(sc->code))))            /* (let* ((x . 1)) ...) */\n\treturn(eval_error(sc, \"let* variable list syntax error: ~A\", sc->code));\n      \n      push_stack(sc, OP_LET_STAR1, cdr(sc->code), car(sc->code));\n      sc->code = cadaar(sc->code);\n      goto EVAL;\n      \n      \n    case OP_LET_STAR1:    /* let* -- calculate parameters */\n      if (!(s7_is_symbol(caar(sc->code))))\n\treturn(eval_error(sc, \"bad variable ~S in let* bindings\", car(sc->code)));\n\n      if (!is_pair(car(sc->code)))          /* (let* ((x)) ...) */\n\treturn(eval_error(sc, \"let* syntax error (no value?): ~A\", car(sc->code)));\n\n      if (!(is_pair(cdar(sc->code))))       /* (let* ((x . 1))...) */\n\treturn(eval_error(sc, \"let* syntax error (not a proper list?): ~A\", car(sc->code)));\n\n      if (cddar(sc->code) != sc->NIL)       /* (let* ((x 1 2 3)) ...) */\n\treturn(eval_error(sc, \"let* syntax error (more than one value?): ~A\", car(sc->code)));\n\n      sc->envir = new_frame_in_env(sc, sc->envir); \n      /* we can't skip this new frame -- we have to imitate a nested let, otherwise\n       *\n       *   (let ((f1 (lambda (arg) (+ arg 1))))\n       *     (let* ((x 32)\n       *            (f1 (lambda (arg) (f1 (+ x arg)))))\n       *       (f1 1)))\n       *\n       * will hang.\n       */\n\n      add_to_local_environment(sc, caar(sc->code), sc->value); \n      sc->code = cdr(sc->code);\n      if (is_pair(sc->code)) \n\t{ \n\t  push_stack(sc, OP_LET_STAR1, sc->args, sc->code);\n\t  sc->code = cadar(sc->code);\n\t  sc->args = sc->NIL;\n\t  goto EVAL;\n\t} \n\n      if (sc->code != sc->NIL)                    /* (let* ((a 1) . b) a) */\n\treturn(eval_error(sc, \"let* var list improper?: ~A\", sc->code));\n\n      sc->code = sc->args;\n      sc->args = sc->NIL;\n      goto BEGIN;\n      \n      \n    case OP_LETREC0:\n      if ((!is_pair(sc->code)) ||                 /* (letrec . 1) */\n\t  (!is_pair(cdr(sc->code))) ||            /* (letrec) */\n\t  ((!is_pair(car(sc->code))) &&           /* (letrec 1 ...) */\n\t   (car(sc->code) != sc->NIL)))\n\treturn(eval_error(sc, \"letrec syntax error: ~A\", sc->code));\n      \n      /* get all local vars and set to #undefined\n       * get parallel list of values\n       * eval each member of values list with env still full of #undefined's\n       * assign each value to its variable\n       * eval body\n       */\n      sc->envir = new_frame_in_env(sc, sc->envir); \n      sc->args = sc->NIL;\n      sc->value = sc->code;\n      sc->code = car(sc->code);\n\n      for (sc->x = sc->code; sc->x != sc->NIL; sc->x = cdr(sc->x))\n\t{\n\t  if ((!is_pair(car(sc->x))) ||             /* (letrec (1 2) #t) */\n\t      (!(s7_is_symbol(caar(sc->x)))))\n\t    return(eval_error(sc, \"bad variable ~S in letrec bindings\", car(sc->x)));\n\n\t  add_to_local_environment(sc, caar(sc->x), sc->UNDEFINED);\n\t}\n\n      \n    case OP_LETREC1:    /* letrec -- calculate parameters */\n      sc->args = s7_cons(sc, sc->value, sc->args);\n      if (is_pair(sc->code)) \n\t{ \n\t  if (!is_pair(car(sc->code)))          /* (letrec ((x)) x) -- perhaps this is legal? */\n\t    return(eval_error(sc, \"letrec syntax error (no value?): ~A\", car(sc->code)));\n\n\t  if (!(is_pair(cdar(sc->code))))       /* (letrec ((x . 1))...) */\n\t    return(eval_error(sc, \"letrec syntax error (not a proper list?): ~A\", car(sc->code)));\n\n\t  if (cddar(sc->code) != sc->NIL)       /* (letrec ((x 1 2 3)) ...) */\n\t    return(eval_error(sc, \"letrec syntax error (more than one value?): ~A\", car(sc->code)));\n\n\t  push_stack(sc, OP_LETREC1, sc->args, cdr(sc->code));\n\t  sc->code = cadar(sc->code);\n\t  sc->args = sc->NIL;\n\t  goto EVAL;\n\t} \n\n      sc->args = safe_reverse_in_place(sc, sc->args); \n      sc->code = car(sc->args);\n      sc->args = cdr(sc->args);\n      \n\n    case OP_LETREC2:\n      for (sc->x = car(sc->code), sc->y = sc->args; sc->y != sc->NIL; sc->x = cdr(sc->x), sc->y = cdr(sc->y))\n\ts7_symbol_set_value(sc, caar(sc->x), car(sc->y));\n      sc->code = cdr(sc->code);\n      sc->args = sc->NIL;\n      goto BEGIN;\n      \n      \n    case OP_COND0:\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"syntax error in cond: ~A\", sc->code));\n      for (sc->x = sc->code; sc->x != sc->NIL; sc->x = cdr(sc->x))\n\tif (!is_pair(car(sc->x)))    /* (cond 1) or (cond (#t 1) 3) */\n\t  return(eval_error(sc, \"every clause in cond must be a list: ~A\", car(sc->x)));\n\n      push_stack(sc, OP_COND1, sc->NIL, sc->code);\n      sc->code = caar(sc->code);\n      goto EVAL;\n      \n      \n    case OP_COND1:\n      if (is_true(sc, sc->value))     /* got a hit */\n\t{\n\t  sc->code = cdar(sc->code);\n\t  if (sc->code == sc->NIL)\n\t    {\n\t      pop_stack(sc);      /* no result clause, so return test, (cond (#t)) -> #t, (cond ((+ 1 2))) -> 3 */\n\t      goto START;\n\t    }\n\t  if (!is_pair(sc->code)) /* (cond (1 . 2)...) */\n\t    return(eval_error(sc, \"syntax error in cond: ~A\", sc->code));\n\t  \n\t  if (car(sc->code) == sc->FEED_TO) \n\t    {\n\t      if (!is_pair(cdr(sc->code))) \n\t\treturn(eval_error(sc, \"syntax error in cond: ~A\", cdr(sc->code)));\n\n\t      sc->x = make_list_2(sc, sc->QUOTE, sc->value); \n\t      sc->code = make_list_2(sc, cadr(sc->code), sc->x);\n\t      goto EVAL;\n\t    }\n\t  \n\t  goto BEGIN;\n\t}\n\n      sc->code = cdr(sc->code);\n      if (sc->code == sc->NIL)\n\t{\n\t  sc->value = sc->NIL;\n\t  pop_stack(sc);\n\t  goto START;\n\t} \n\t  \n      push_stack(sc, OP_COND1, sc->NIL, sc->code);\n      sc->code = caar(sc->code);\n      goto EVAL;\n      \n      \n    case OP_AND0:\n      if (sc->code == sc->NIL) \n\t{\n\t  sc->value = sc->T;\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"and: syntax error: ~A\", sc->code));\n      push_stack(sc, OP_AND1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_AND1:\n      if ((is_false(sc, sc->value)) ||\n\t  (sc->code == sc->NIL))\n\t{\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"and: syntax error: ~A\", sc->code));\n\n      if (cdr(sc->code) != sc->NIL)\n\tpush_stack(sc, OP_AND1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_OR0:\n      if (sc->code == sc->NIL) \n\t{\n\t  sc->value = sc->F;\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"or: syntax error: ~A\", sc->code));\n      push_stack(sc, OP_OR1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_OR1:\n      if ((is_true(sc, sc->value)) ||\n\t  (sc->code == sc->NIL))\n\t{\n\t  pop_stack(sc);\n\t  goto START;\n\t}\n      if (!is_pair(sc->code))\n\treturn(eval_error(sc, \"and: syntax error: ~A\", sc->code));\n\n      if (cdr(sc->code) != sc->NIL)\n\tpush_stack(sc, OP_OR1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_MACRO0:     /* this is tinyscheme's weird macro syntax */\n      /*\n\t(macro (when form)\n\t`(if ,(cadr form) (begin ,@(cddr form))))\n      */\n      /* (macro (when form) ...) or (macro do (lambda (form) ...))\n       *   sc->code is the business after the \"macro\"\n       *   so in 1st case, car(sc->code) is '(when form), and in 2nd it is 'do\n       *   in 1st case, put caar(sc->code) \"when\" into sc->x for later symbol definition, in 2nd use car(sc->code)\n       *   in 1st case, wrap up a lambda:\n       *      '(lambda (form) ...)\n       *   in 2nd case, it's ready to go\n       * goto eval popping to OP_MACRO1\n       *   eval sees the lambda and creates a closure (s7_make_closure): car => code, cdr => environment\n       */\n      if (is_pair(car(sc->code))) \n\t{\n\t  sc->x = caar(sc->code);\n\t  sc->code = s7_cons(sc, sc->LAMBDA, s7_cons(sc, cdar(sc->code), cdr(sc->code)));\n\t} \n      else \n\t{\n\t  sc->x = car(sc->code);\n\t  sc->code = cadr(sc->code);\n\t}\n      if (!s7_is_symbol(sc->x)) \n\treturn(eval_error(sc, \"~S: variable is not a symbol\", sc->x));\n\n      push_stack(sc, OP_MACRO1, sc->NIL, sc->x);   /* sc->x (the name symbol) will be sc->code when we pop to OP_MACRO1 */\n      goto EVAL;\n      \n      \n    case OP_MACRO1:\n      /* here sc->code is the name (a symbol), sc->value is a closure object, its car is the form as called\n       *     (macro (when form)\n       *       `(if ,(cadr form) (begin ,@(cddr form))))\n       * has become:\n       *     ((form) \n       *      (quasiquote \n       *        (if (unquote (cadr form)) \n       *            (begin (unquote-splicing (cddr form))))))\n       * with \n       *   sc->code: when \n       *   sc->value: #<closure> \n       * where \"form\" is the thing presented to us in the code, i.e. (when mumble do-this)\n       *   and the following code takes that as its argument and transforms it in some way\n       */\n\n      if (!s7_is_symbol(sc->code))\n\treturn(eval_error(sc, \"macro name is not a symbol?\", sc->code));\n\n      set_type(sc->value, T_MACRO | T_ANY_MACRO);\n      \n      /* find name in environment, and define it */\n      sc->x = s7_find_symbol_in_environment(sc, sc->envir, sc->code, false); \n      if (sc->x != sc->NIL) \n\tset_symbol_value(sc->x, sc->value); \n      else add_to_current_environment(sc, sc->code, sc->value); \n      \n      /* pop back to wherever the macro call was */\n      sc->x = sc->value;\n      sc->value = sc->code;\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_DEFMACRO:\n    case OP_DEFMACRO_STAR:\n      \n      /* (defmacro name (args) body) ->\n       *\n       *    (macro (defmacro dform)\n       *      (let ((form (gensym \"defmac\")))            \n       *        `(macro (,(cadr dform) ,form)   \n       *          (apply\n       *            (lambda ,(caddr dform)      \n       *             ,@(cdddr dform))          \n       *            (cdr ,form)))))             \n       *    \n       *    end up with name as sc->x, args and body as sc->z going to OP_MACRO1, ((gensym) (lambda (args) body)) going to eval\n       */\n\n      sc->x = car(sc->code);\n      if (!s7_is_symbol(sc->x))\n\treturn(eval_error(sc, \"defmacro: ~S is not a symbol?\", sc->x)); /* (defmacro 3 (a) #f) */\n\n      if (is_immutable(sc->x))\n\treturn(eval_error(sc, \"defmacro: ~S is immutable\", sc->x));     /* (defmacro pi (a) `(+ ,a 1)) */\n\n      /* (defmacro hi (a) `(+ ,a 1))\n       *   cdr(sc->code): ((a) (quasiquote (+ (unquote a) 1)))\n       *   caddr(sc->code):    (quasiquote (+ (unquote a) 1))\n       *   cadr(caddr(sc->code):           (+ (unquote a) 1)\n       *   g_quasiquote_2(sc, 0, ^):       (cons (quote +) (cons a (cons 1 (quote ()))))\n       *\n       * so the quasiquote can be evaluated immediately.  It's possible that we could\n       *   always precompute quasiquotes, but this change takes care of 99% of the cases.\n       */\n\n      if ((is_pair(cdr(sc->code))) &&\n\t  (is_pair(cddr(sc->code))) &&\n\t  (is_pair(caddr(sc->code))) &&\n\t  (s7_is_symbol(caaddr(sc->code))) &&\n\t  (caaddr(sc->code) == sc->QUASIQUOTE) &&\n\t  (cdddr(sc->code) == sc->NIL))            /* protect against (defmacro hi (a) `(+ ,a 1) #f) */\n\t{\n\t  sc->z = s7_cons(sc,\n\t\t\t  cadr(sc->code),\n\t\t\t  s7_cons(sc,\n\t\t\t\t  g_quasiquote_2(sc, 0, cadr(caddr(sc->code))),\n\t\t\t\t  sc->NIL));\n\t}\n      else sc->z = cdr(sc->code);\n\n      /* could we make macros safe automatically by doing the symbol lookups right now?\n       *   we'd replace each name with a reference to the current binding cons.  I think\n       *   this is how Guile implements hygenic macros -- is it worth the bother?\n       *\n       * Isn't it just as good to say:\n       *\n       * (define-macro (mac a b) \n       *   `(with-environment (global-environment)\n       *      (+ ,a ,b)))\n       *\n       * now if we rebind +\n       *\n       * (let ((+ -)) \n       *   (mac 1 2))\n       * 3\n       */\n\n      sc->x = car(sc->code);            /* just in case g_quasiquote stepped on sc->x */\n      sc->y = s7_gensym(sc, \"defmac\");\n      sc->code = s7_cons(sc, \n\t\t\t sc->LAMBDA,\n\t\t\t s7_cons(sc, \n\t\t\t\t make_list_1(sc, sc->y),\n\t\t\t\t make_list_1(sc, \n\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t     sc->APPLY,\n\t\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t\t\t     (sc->op == OP_DEFMACRO_STAR) ? sc->LAMBDA_STAR : sc->LAMBDA,\n\t\t\t\t\t\t\t\t     sc->z),\n\t\t\t\t\t\t\t     make_list_1(sc, make_list_2(sc, sc->CDR, sc->y)))))));\n\n      /* so, (defmacro hi (a b) `(+ ,a ,b)) becomes:\n       *   sc->x: hi\n       *   sc->code: (lambda (defmac-21) \n       *               (apply (lambda (a b) \n       *                        (cons (quote +) (cons a (cons b (quote ()))))) \n       *                      (cdr defmac-21)))\n       */\n      push_stack(sc, OP_MACRO1, sc->NIL, sc->x);   /* sc->x (the name symbol) will be sc->code when we pop to OP_MACRO1 */\n      goto EVAL;\n\n\n    case OP_EXPANSION:\n      /* sc->x is the value (sc->value right now is sc->code, the macro name symbol) */\n      set_type(sc->x, T_MACRO | T_ANY_MACRO | T_EXPANSION);\n      set_type(sc->value, type(sc->value) | T_EXPANSION);\n      pop_stack(sc);\n      goto START;\n\n\n    case OP_DEFINE_EXPANSION:\n      /* read-time macros, suggested by Rick */\n      push_stack(sc, OP_EXPANSION, sc->NIL, sc->NIL);\n      /* drop into define-macro */\n\n\n    case OP_DEFINE_MACRO:\n    case OP_DEFINE_MACRO_STAR:\n      if (!is_pair(car(sc->code)))\n\treturn(s7_wrong_type_arg_error(sc, \"define-macro\", 1, car(sc->code), \"a list (name ...)\"));\n\n      sc->x = caar(sc->code);\n      if (!s7_is_symbol(sc->x))\n\treturn(eval_error(sc, \"define-macro: ~S is not a symbol?\", sc->x));\n\n      if (is_immutable(sc->x))\n\treturn(eval_error(sc, \"define-macro: ~S is immutable\", sc->x));\n\n      /* (define-macro (hi a) `(+ ,a 1))\n       *   cdr(sc->code): ((quasiquote (+ (unquote a) 1)))\n       *   so in this case we want cadr, not caddr of defmacro\n       */\n\n      if ((is_pair(cdr(sc->code))) &&\n\t  (is_pair(cadr(sc->code))) &&\n\t  (s7_is_symbol(caadr(sc->code))) &&\n\t  (caadr(sc->code) == sc->QUASIQUOTE) &&\n\t  (cddr(sc->code) == sc->NIL))\n\t{\n\t  sc->z = s7_cons(sc,\n\t\t\t  g_quasiquote_2(sc, 0, cadr(cadr(sc->code))),\n\t\t\t  sc->NIL);\n\t}\n      else sc->z = cdr(sc->code);\n\n      sc->x = caar(sc->code); /* just in case g_quasiquote stepped on sc->x */\n      sc->y = s7_gensym(sc, \"defmac\");\n      sc->code = s7_cons(sc,\n\t\t\t sc->LAMBDA,\n\t\t\t s7_cons(sc, \n\t\t\t\t make_list_1(sc, sc->y),\n\t\t\t\t make_list_1(sc, \n\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t     sc->APPLY,\n\t\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t\t\t     (sc->op == OP_DEFINE_MACRO_STAR) ? sc->LAMBDA_STAR : sc->LAMBDA,\n\t\t\t\t\t\t\t\t     s7_cons(sc, \n\t\t\t\t\t\t\t\t\t     cdar(sc->code), /* arg list */\n\t\t\t\t\t\t\t\t\t     sc->z)),\n\t\t\t\t\t\t\t     make_list_1(sc, make_list_2(sc, sc->CDR, sc->y)))))));\n\n      /* (define-macro (hi a b) `(+ ,a ,b)) becomes:\n       *   sc->x: hi\n       *   sc->code: (lambda (defmac-22) (apply (lambda (a b) (cons (quote +) (cons a (cons b (quote ()))))) (cdr defmac-22)))\n       */\n      push_stack(sc, OP_MACRO1, sc->NIL, sc->x);   /* sc->x (the name symbol) will be sc->code when we pop to OP_MACRO1 */\n      goto EVAL;\n      \n      \n    case OP_CASE0:      /* case, car(sc->code) is the selector */\n      if ((!is_pair(sc->code)) ||\n\t  (!is_pair(cdr(sc->code))) ||\n\t  (!is_pair(cadr (sc->code)))) \n\treturn(eval_error(sc, \"syntax error in case: ~A\", sc->code));\n      \n      push_stack(sc, OP_CASE1, sc->NIL, cdr(sc->code));\n      sc->code = car(sc->code);\n      goto EVAL;\n      \n      \n    case OP_CASE1: \n      for (sc->x = sc->code; sc->x != sc->NIL; sc->x = cdr(sc->x)) \n\t{\n\t  if ((!is_pair(sc->x)) ||\n\t      (!is_pair(car(sc->x))))\n\t    return(eval_error(sc, \"case clause ~A messed up\", sc->x));\t \n   \n\t  sc->y = caar(sc->x);\n\t  if (!is_pair(sc->y))\n\t    {\n\t      if (sc->y != sc->ELSE)\n\t\treturn(eval_error(sc, \"case clause key list ~A is not a list or 'else'\", sc->y));\n\t      if (cdr(sc->x) != sc->NIL)\n\t\treturn(eval_error(sc, \"case 'else' clause is not the last\", sc->x));\n\t      break;\n\t    }\n\n\t  for ( ; sc->y != sc->NIL; sc->y = cdr(sc->y)) \n\t    if (s7_is_eqv(car(sc->y), sc->value)) \n\t      break;\n\t  \n\t  if (sc->y != sc->NIL) \n\t    break;\n\t}\n\n      if (sc->x != sc->NIL) \n\t{\n\t  if (is_pair(caar(sc->x))) \n\t    {\n\t      sc->code = cdar(sc->x);\n\t      goto BEGIN;\n\t    } \n\t  push_stack(sc, OP_CASE2, sc->NIL, cdar(sc->x));\n\t  sc->code = caar(sc->x);\n\t  goto EVAL;\n\t} \n\n      sc->value = sc->NIL;\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_CASE2: \n      if (is_true(sc, sc->value)) \n\tgoto BEGIN;\n      sc->value = sc->NIL;\n      pop_stack(sc);\n      goto START;\n      \n\n    case OP_TRACE_HOOK_QUIT:\n      goto APPLY_WITHOUT_TRACE;\n\n      \n    case OP_ERROR_HOOK_QUIT:\n      s7_symbol_set_value(sc, sc->ERROR_HOOK, sc->code);\n\n      /* now mimic the end of the normal error handler.  Since this error hook evaluation can happen\n       *   in an arbitrary s7_call nesting, we can't just return from the current evaluation --\n       *   we have to jump to the original (top-level) call.  Otherwise '#<unspecified> or whatever\n       *   is simply treated as the (non-error) return value, and the higher level evaluations\n       *   get confused.\n       */\n      stack_reset(sc);\n      sc->op = OP_ERROR_QUIT;\n      /* sc->value = sc->UNSPECIFIED; */ /* return the *error-hook* function's value if possible */\n      if (sc->longjmp_ok)\n\t{\n\t  longjmp(sc->goto_start, 1);\n\t}\n      return(sc->value); /* not executed I hope */\n\n\n    case OP_ERROR_QUIT:\n    case OP_QUIT:\n    case OP_UNWIND_OUTPUT:\n    case OP_UNWIND_INPUT:\n      return(sc->F);\n      break;\n      \n\n    case OP_DYNAMIC_WIND:\n      if (dynamic_wind_state(sc->code) == T_DWIND_INIT)\n\t{\n\t  dynamic_wind_set_state(sc->code, T_DWIND_BODY);\n\t  push_stack(sc, OP_DYNAMIC_WIND, sc->NIL, sc->code);\n\t  sc->args = sc->NIL;\n\t  sc->code = dynamic_wind_body(sc->code);\n\t  goto APPLY;\n\t}\n      else\n\t{\n\t  if (dynamic_wind_state(sc->code) == T_DWIND_BODY)\n\t    {\n\t      dynamic_wind_set_state(sc->code, T_DWIND_FINISH);\n\t      push_stack(sc, OP_DYNAMIC_WIND, sc->value, sc->code);\n\t      sc->args = sc->NIL;\n\t      sc->code = dynamic_wind_out(sc->code);\n\t      goto APPLY;\n\t    }\n\t  else\n\t    {\n\t      /* (+ 1 (dynamic-wind (lambda () #f) (lambda () (values 2 3 4)) (lambda () #f)) 5) */\n\t      if ((is_pair(sc->args)) &&\n\t\t  (car(sc->args) == sc->VALUES))\n\t\tsc->value = splice_in_values(sc, cdr(sc->args));\n\t      else sc->value = sc->args;                         /* value saved above */ \n\t      pop_stack(sc); \n\t      goto START;\n\t    }\n\t}\n      break;\n      \n\n    case OP_CATCH:\n      pop_stack(sc);\n      goto START;\n\n\n    case OP_TRACE_RETURN:\n      trace_return(sc);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_LIST: \n      /* sc->args is sc->NIL at first */\n      /*    was: sc->args = s7_cons(sc, sc->value, sc->args); */ \n      {\n\ts7_pointer x;\n#if HAVE_PTHREADS\n\tx = new_cell(sc);\n#else\n\tif (sc->free_heap_top > 0)\n\t  x = sc->free_heap[--(sc->free_heap_top)];\n\telse x = new_cell(sc);\n#endif\n\tcar(x) = sc->value;\n\tcdr(x) = sc->args;\n\tset_type(x, T_PAIR);\n\tsc->args = x;\n      }\n      sc->tok = token(sc);\n\n      switch (sc->tok)\n\t{\n\tcase TOKEN_RIGHT_PAREN:\n\t  sc->value = remember_line(sc, safe_reverse_in_place(sc, sc->args));\n\n\t  /* read-time macro expansion\n\t   *\n\t   *   (defmacro hi (a) (format #t \"hi...\") `(+ ,a 1))\n\t   *   (define (ho b) (+ 1 (hi b)))\n\t   *\n\t   * here sc->value is: (ho b), (hi b), (+ 1 (hi b)), (define (ho b) (+ 1 (hi b)))\n\t   * \n\t   * but... first we can't tell for sure at this point that \"hi\" really is a macro\n\t   *\n\t   *   (letrec ((hi ... (hi...))) will be confused about the 2nd hi,\n\t   *   or (call/cc (lambda (hi) (hi 1))) etc.\n\t   *\n\t   * second, figuring out that we're quoted is not easy -- we have to march all the\n\t   * way to the bottom of the stack looking for op_read_quote or op_read_vector\n\t   *\n\t   *    #(((hi)) 2) or '(((hi)))\n\t   *\n\t   * or op_read_list with args not equal (quote) or (macroexapand)\n\t   *\n\t   *    '(hi 3) or (macroexpand (hi 3) or (quote (hi 3))\n\t   *\n\t   * and those are only the problems I noticed!\n\t   *\n\t   * The hardest of these problems involve shadowing, so Rick asked for \"define-expansion\"\n\t   *   which is just like define-macro, but the programmer guarantees that the macro\n\t   *   name will not be shadowed.  So I'll also assume that the other funny cases are\n\t   *   being avoided -- see what happens!\n\t   *\n\t   *   (define-expansion (hi a) `(+ ,a 1))\n\t   *   (define (ho b) (+ 1 (hi b)))\n\t   *   (procedure-source ho) -> (lambda (b) (+ 1 (+ b 1)))\n\t   */\n\t  \n\t  if ((sc->value != sc->NIL) &&\n\t      (is_expansion(car(sc->value))) &&\n\t      (sc->stack_top >= 4) &&\n\t      ((int)integer(number(vector_element(sc->stack, sc->stack_top - 1))) != OP_READ_QUOTE) && /* '(hi 1) for example */\n\t      (car(vector_element(sc->stack, sc->stack_top - 2)) != sc->QUOTE) &&                      /* (quote (hi 1)) */\n\t      (car(vector_element(sc->stack, sc->stack_top - 2)) != sc->MACROEXPAND))                  /* (macroexpand (hi 1)) */\n\t    {\n\t      s7_pointer x;\n\t      x = symbol_value(s7_find_symbol_in_environment(sc, sc->envir, car(sc->value), true));\n\t      sc->args = make_list_1(sc, sc->value); \n\t      sc->code = x;\n\t      goto APPLY;\n\t    }\n\t  break;\n\n\tcase TOKEN_DOT:\n\t  push_stack(sc, OP_READ_DOT, sc->args, sc->NIL);\n\t  sc->tok = token(sc);\n\t  sc->value = read_expression(sc);\n\t  break;\n\n\tcase TOKEN_EOF:\n\t  /* we should be able to scan the stack for the earlist OP_READ_LIST,\n\t   *  and find where the current list started\n\t   */\n\t  return(missing_close_paren_error(sc));\n\n\tdefault:\n\t  push_stack(sc, OP_READ_LIST, sc->args, sc->NIL);\n\t  sc->value = read_expression(sc);\n\t  break;\n\t}\n      pop_stack(sc);\n      goto START;\n\n      \n    case OP_READ_DOT:\n      if (token(sc) != TOKEN_RIGHT_PAREN)\n\t{\n\t  back_up_stack(sc);\n\t  sc->value = read_error(sc, \"stray dot?\");            /* (+ 1 . 2 3) or (list . ) */\n\t  goto START;\n\t}\n      /* args = previously read stuff, value = thing just after the dot and before the ')':\n       *   (list 1 2 . 3)\n       *   value: 3, args: (2 1 list) \n       *   '(1 . 2)\n       *   value: 2, args: (1)\n       *\n       * but we also get here in a lambda arg list:\n       *   (lambda (a b . c) #f)\n       *   value: c, args: (b a)\n       *\n       * so we have to leave any error checks until later, I guess\n       *   -- in eval_args1, if we end with non-pair-not-nil then\n       *      something is fishy\n       */\n      sc->value = s7_reverse_in_place(sc, sc->value, sc->args);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_QUOTE:\n      sc->value = make_list_2(sc, sc->QUOTE, sc->value);\n      pop_stack(sc);\n      goto START;      \n      \n      \n    case OP_READ_QUASIQUOTE:\n      sc->value = make_list_2(sc, sc->QUASIQUOTE, sc->value);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_QUASIQUOTE_VECTOR:\n      sc->value = make_list_3(sc, sc->APPLY, sc->VECTOR, make_list_2(sc, sc->QUASIQUOTE, sc->value));\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_UNQUOTE:\n      sc->value = make_list_2(sc, sc->UNQUOTE, sc->value);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_UNQUOTE_SPLICING:\n      sc->value = make_list_2(sc, sc->UNQUOTE_SPLICING, sc->value);\n      pop_stack(sc);\n      goto START;\n      \n      \n    case OP_READ_VECTOR:\n      sc->value = g_vector(sc, sc->value);\n      set_immutable(sc->value); /* a vector constant should be immutable? */\n      pop_stack(sc);\n      goto START;\n\n      \n    default:\n      return(eval_error(sc, \"~A: unknown operator!\", s7_make_integer(sc, sc->op)));\n    }\n  return(sc->F);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* ---------------------------------------- length, copy, fill ---------------------------------------- */\n", "func_signal": "static s7_pointer g_length(s7_scheme *sc, s7_pointer args)", "code": "{\n  #define H_length \"(length obj) returns the length of obj, which can be a list, vector, string, or hash-table\"\n  \n  s7_pointer lst = car(args);\n  \n  if (lst == sc->NIL)\n    return(small_int(sc, 0));\n\n  switch (type(lst))\n    {\n    case T_PAIR:\n      {\n\tint len;\n\tlen = s7_list_length(sc, lst);\n  \n\tif (len < 0) \n\t  return(s7_wrong_type_arg_error(sc, \"length:\", 0, lst, \"a proper (not a dotted) list\"));\n\tif (len == 0)\n\t  return(s7_wrong_type_arg_error(sc, \"length:\", 0, lst, \"a proper (not a circular) list\"));\n\t\n\treturn(s7_make_integer(sc, len));\n      }\n\n    case T_VECTOR:\n      return(g_vector_length(sc, args));\n\n    case T_STRING:\n      return(g_string_length(sc, args));\n\n    case T_HASH_TABLE:\n      return(g_hash_table_size(sc, args));\n\n    case T_C_OBJECT:\n      return(s7_object_length(sc, lst));\n\n    default:\n      return(s7_wrong_type_arg_error(sc, \"length\", 0, lst, \"a list, vector, string, or hash-table\"));\n    }\n  \n  return(small_int(sc, 0));\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* ugh */\n", "func_signal": "static int vector_compare(const void *v1, const void *v2)", "code": "{\n    int start;\n    car(compare_proc_args) = (*(s7_pointer *)v1);\n    cadr(compare_proc_args) = (*(s7_pointer *)v2);\n\n    start = compare_sc->stack_top; /* see note below */\n    push_stack(compare_sc, OP_EVAL_DONE, compare_sc->args, compare_sc->code); \n    compare_sc->args = compare_proc_args;\n    compare_sc->code = compare_proc;\n    eval(compare_sc, OP_APPLY);\n\n    if (compare_sc->stack_top < start)\n      {\n\ts7_gc_on(compare_sc, true);\n\tlongjmp(compare_sc->goto_qsort_end, 1);\n      }\n    if (is_true(compare_sc, compare_sc->value))\n      return(-1);\n    return(1);\n  }\n#endif\n\n\n#if HAVE_PTHREADS\nstatic pthread_mutex_t sort_lock = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic s7_pointer g_sort_in_place(s7_scheme *sc, s7_pointer args)\n{\n  #define H_sort_in_place \"(sort! list-or-vector func) sorts a list or vector using func to compare elements.\\\nIf its first argument is a list, the list is copied (despite the '!').\"\n\n  int gc_loc;\n  s7_pointer vect;\n\n#if HAVE_NESTED_FUNCTIONS\n  s7_pointer compare_proc, compare_proc_args;\n  auto int vector_compare(const void *v1, const void *v2);\n\n  int vector_compare(const void *v1, const void *v2)\n  {\n    int start;\n    car(compare_proc_args) = (*(s7_pointer *)v1);\n    cadr(compare_proc_args) = (*(s7_pointer *)v2);\n\n    start = sc->stack_top;\n    /* qsort is a large and complex function (250 lines in libc), so we can't easily\n     *   expand it in our eval loop, but we may want to jump out of the sort via call/cc,\n     *   so we look for the stack being unwound past the start point -- this is a kludge!\n     * Currently, if an error occurs in the sort function, we depend on s7_error to\n     *   turn it back on; is there any case where we'd want it off despite hitting\n     *   an error?\n     */\n\n    push_stack(sc, OP_EVAL_DONE, sc->args, sc->code); \n    sc->args = compare_proc_args;\n    sc->code = compare_proc;\n    eval(sc, OP_APPLY);\n\n    if (sc->stack_top < start)\n      {\n\ts7_gc_on(sc, true);\n\tlongjmp(sc->goto_qsort_end, 1);\n      }\n    if (is_true(sc, sc->value))\n      return(-1);\n    return(1);\n  }\n#endif\n\n  vect = car(args);\n\n  if (s7_is_list(sc, vect))\n    {\n      s7_pointer val;\n      if (sc->free_heap_top < 4096) gc(sc);\n      s7_gc_on(sc, false);\n      val = g_sort_in_place(sc, make_list_2(sc, \n\t\t\t\t\t    g_list_to_vector(sc, make_list_1(sc, vect)), \n\t\t\t\t\t    cadr(args)));\n      if (s7_is_vector(val))\n\tval = s7_vector_to_list(sc, val);\n      s7_gc_on(sc, true);\n      return(val);\n    }\n\n  if (!s7_is_vector(vect))\n    return(s7_wrong_type_arg_error(sc, \"sort!\", 1, vect, \"a vector or a list\"));\n  if (!s7_is_procedure(cadr(args)))\n    return(s7_wrong_type_arg_error(sc, \"sort!\", 2, cadr(args), \"a procedure\"));\n\n#if HAVE_PTHREADS\n  pthread_mutex_lock(&sort_lock);\n#endif\n\n  compare_proc = cadr(args);\n#if (!HAVE_NESTED_FUNCTIONS)\n  compare_sc = sc;\n#endif\n\n  compare_proc_args = make_list_2(sc, sc->F, sc->F);\n  gc_loc = s7_gc_protect(sc, compare_proc_args);\n\n  qsort((void *)s7_vector_elements(vect), vector_length(vect), sizeof(s7_pointer), vector_compare); /* qsort sizes are type size_t */\n\n  if (setjmp(sc->goto_qsort_end) != 0)\n    vect = sc->value;\n\n  s7_gc_unprotect_at(sc, gc_loc);\n\n#if HAVE_PTHREADS\n  pthread_mutex_unlock(&sort_lock);\n#endif\n\n  return(vect);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* make symbol or number atom from string */\n", "func_signal": "static s7_pointer make_atom(s7_scheme *sc, char *q, int radix, bool want_symbol)", "code": "{\n  #define ISDIGIT(Chr, Rad) (digits[(int)Chr] < Rad)\n\n  char c, *p, *slash1 = NULL, *slash2 = NULL, *plus = NULL, *ex1 = NULL, *ex2 = NULL;\n  bool has_dec_point1 = false, has_i = false, has_dec_point2 = false;\n  int has_plus_or_minus = 0, current_radix;\n\n#if (!WITH_GMP)\n  #define ATOLL(x) strtoll(x, (char **)NULL, radix)\n  #define ATOF(x) ((radix == 10) ? atof(x) : string_to_double_with_radix(x, radix))\n#endif\n\n  current_radix = radix;\n  p = q;\n  c = *p++; \n  \n  /* a number starts with + - . or digit, but so does 1+ for example */\n  \n  if (c == '#')\n    return(make_sharp_constant(sc, p, true)); /* make_sharp_constant expects the '#' to be removed */\n  \n  if ((c == '+') || (c == '-')) \n    { \n      c = *p++; \n      if (c == '.') \n\t{ \n\t  has_dec_point1 = true; \n\t  c = *p++; \n\t} \n      if (!ISDIGIT(c, current_radix))\n\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n    } \n  else \n    {\n      if (c == '.')         /* .0 */\n\t{ \n\t  has_dec_point1 = true; \n\t  c = *p++; \n\n\t  if (!ISDIGIT(c, current_radix))\n\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\t} \n      else \n\t{\n\t  if (!ISDIGIT(c, current_radix))\n\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\t}\n    }\n  \n  for ( ; (c = *p) != 0; ++p) \n    {\n      if (!ISDIGIT(c, current_radix)) \n\t{\n\t  current_radix = radix;\n\n\t  if (c =='.') \n\t    {\n\t      if (((has_dec_point1) ||\n\t\t   (slash1)) &&\n\t\t  (has_plus_or_minus == 0)) /* 1.. or 1/2. */\n\t\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\n\t      if (((has_dec_point2) ||\n\t\t   (slash2)) &&\n\t\t  (has_plus_or_minus != 0)) /* 1+1.. or 1+1/2. */\n\t\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\n\t      if ((!ISDIGIT(p[1], current_radix)) &&\n\t\t  (!ISDIGIT(p[-1], current_radix))) \n\t\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\t      \n\t      if (has_plus_or_minus == 0)\n\t\thas_dec_point1 = true;\n\t      else has_dec_point2 = true;\n\t      continue;\n\t    }\n\t  else \n\t    {\n\t      if (exponent_table[(int)c])\n\t\t{\n\t\t  if (current_radix > 10)\n\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\t\t  /* see note above */\n\n\t\t  current_radix = 10;\n\n\t\t  if (((ex1) ||\n\t\t       (slash1)) &&\n\t\t      (has_plus_or_minus == 0)) /* ee */\n\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\n\t\t  if (((ex2) ||\n\t\t       (slash2)) &&\n\t\t      (has_plus_or_minus != 0)) /* 1+1.0ee */\n\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\n\t\t  if ((!ISDIGIT(p[-1], current_radix)) &&\n\t\t      (p[-1] != '.'))\n\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F); \n\n\t\t  if (has_plus_or_minus == 0)\n\t\t    {\n\t\t      ex1 = p;\n\t\t      has_dec_point1 = true; /* decimal point illegal from now on */\n\t\t    }\n\t\t  else \n\t\t    {\n\t\t      ex2 = p;\n\t\t      has_dec_point2 = true;\n\t\t    }\n\t\t  p++;\n\t\t  if ((*p == '-') || (*p == '+')) p++;\n\t\t  if (ISDIGIT(*p, current_radix))\n\t\t    continue;\n\t\t}\n\t      else\n\t\t{\n\t\t  if ((c == '+') || (c == '-'))\n\t\t    {\n\t\t      if (has_plus_or_minus != 0) /* already have the separator */\n\t\t\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\t\t      \n\t\t      if (c == '+') has_plus_or_minus = 1; else has_plus_or_minus = -1;\n\t\t      plus = (char *)(p + 1);\n\t\t      continue;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (c == '/')\n\t\t\t{\n\t\t\t  if ((has_plus_or_minus == 0) &&\n\t\t\t      ((ex1) ||\n\t\t\t       (slash1) ||\n\t\t\t       (has_dec_point1)))\n\t\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\n\t\t\t  if ((has_plus_or_minus != 0) &&\n\t\t\t      ((ex2) ||\n\t\t\t       (slash2) ||\n\t\t\t       (has_dec_point2)))\n\t\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\t\t\t  \n\t\t\t  if (has_plus_or_minus == 0)\n\t\t\t    slash1 = (char *)(p + 1);\n\t\t\t  else slash2 = (char *)(p + 1);\n\n\t\t\t  if ((!ISDIGIT(p[1], current_radix)) ||\n\t\t\t      (!ISDIGIT(p[-1], current_radix)))\n\t\t\t    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\n\t\t\t  continue;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  if ((has_plus_or_minus != 0) && \n\t\t\t      (!has_i) && \n\t\t\t      (c == 'i'))\n\t\t\t    {\n\t\t\t      has_i = true;\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  return((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\t}\n    }\n  \n  if ((has_plus_or_minus != 0) &&\n      (!has_i))\n    return((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\n  if (has_i)\n    {\n#if (!WITH_GMP)\n      s7_Double rl = 0.0, im = 0.0;\n#endif\n      s7_pointer result;\n      int len;\n      char *saved_q;\n      len = strlen(q);\n      \n      if (q[len - 1] != 'i')\n\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\n      saved_q = s7_strdup_with_len(q, len);\n\n      /* look for cases like 1+i */\n      if ((q[len - 2] == '+') || (q[len - 2] == '-'))\n\tq[len - 1] = '1';\n      else q[len - 1] = '\\0'; /* remove 'i' */\n      \n      if (ex1) (*ex1) = 'e';\n      if (ex2) (*ex2) = 'e';\n      (*((char *)(plus - 1))) = '\\0';\n\n#if (!WITH_GMP)\n      if ((has_dec_point1) ||\n\t  (ex1))\n\t{\n\t  /* (string->number \"1100.1+0.11i\" 2) -- need to split into 2 honest reals before passing to non-base-10 ATOF */\n\t  rl = ATOF(q);\n\t}\n      else\n\t{\n\t  if (slash1)\n\t    rl = (s7_Double)ATOLL(q) / (s7_Double)ATOLL(slash1);\n\t  else rl = (s7_Double)ATOLL(q);\n\t}\n      if (rl == -0.0) rl = 0.0;\n\n      if ((has_dec_point2) ||\n\t  (ex2))\n\tim = ATOF(plus);\n      else\n\t{\n\t  if (slash2)\n\t    im = (s7_Double)ATOLL(plus) / (s7_Double)ATOLL(slash2);\n\t  else im = (s7_Double)ATOLL(plus);\n\t}\n      if ((has_plus_or_minus == -1) && \n\t  (im != 0.0))\n\tim = -im;\n      result = s7_make_complex(sc, rl, im);\n#else\n      result = string_to_either_complex(sc, q, slash1, ex1, has_dec_point1, plus, slash2, ex2, has_dec_point2, radix, has_plus_or_minus);\n#endif\n\n      memcpy((void *)q, (void *)saved_q, len);\n      free(saved_q);\n      return(result);\n    }\n\n  \n  if ((has_dec_point1) ||\n      (ex1))\n    {\n      s7_pointer result;\n      char old_e = 0;\n\n      if (slash1)  /* not complex, so slash and \".\" is not a number */\n\treturn((want_symbol) ? s7_make_symbol(sc, q) : sc->F);\n\n      if (ex1)\n\t{\n\t  old_e = (*ex1);\n\t  (*ex1) = 'e';\n\t}\n\n#if (!WITH_GMP)\n      result = s7_make_real(sc, ATOF(q));\n#else\n      result = string_to_either_real(sc, q, radix);\n#endif\n      \n      if (ex1)\n\t(*ex1) = old_e;\n\n      return(result);\n    }\n  \n  if (slash1)\n#if (!WITH_GMP)\n    return(s7_make_ratio(sc, ATOLL(q), ATOLL(slash1)));\n#else\n    return(string_to_either_ratio(sc, q, slash1, radix));\n#endif\n  \n#if (!WITH_GMP)\n  return(s7_make_integer(sc, ATOLL(q)));\n#else\n  return(string_to_either_integer(sc, q, radix));\n#endif\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* -------------------------------- ports -------------------------------- */\n", "func_signal": "static char *describe_port(s7_scheme *sc, s7_pointer p)", "code": "{\n  char *desc;\n  desc = (char *)malloc(64 * sizeof(char));\n  snprintf(desc, 64, \"<port%s%s%s>\",\n  \t   (is_file_port(p)) ? \" file\" : ((is_string_port(p)) ? \" string\" : \" function\"),\n\t   (is_input_port(p)) ? \" input\" : \" output\",\n\t   (port_is_closed(p)) ? \" (closed)\" : \"\");\n  return(desc);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* this gives room for 4000 files each of 1000000 lines */\n", "func_signal": "static s7_pointer remember_line(s7_scheme *sc, s7_pointer obj)", "code": "{\n  if (sc->input_port != sc->NIL)\n    set_pair_line_number(obj, port_line_number(sc->input_port) | (port_file_number(sc->input_port) << 20));\n  return(obj);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* ---------------- reader funcs for eval ---------------- */\n", "func_signal": "static void back_up_stack(s7_scheme *sc)", "code": "{\n  opcode_t top_op;\n  top_op =(opcode_t)s7_integer(vector_element(sc->stack, sc->stack_top - 1));\n  if (top_op == OP_READ_DOT)\n    {\n      pop_stack(sc);\n      top_op =(opcode_t)s7_integer(vector_element(sc->stack, sc->stack_top - 1));\n    }\n  if (top_op == OP_READ_VECTOR)\n    {\n      pop_stack(sc);\n      top_op =(opcode_t)s7_integer(vector_element(sc->stack, sc->stack_top - 1));\n    }\n  if (top_op == OP_READ_QUOTE)\n    pop_stack(sc);\n\n  if (top_op == OP_EVAL_STRING) /* ?? */\n    pop_stack(sc);\n}", "path": "s7.c", "repo_name": "dchest/CocoaScheme", "stars": 4, "license": "None", "language": "c", "size": 268}
{"docstring": "/* binsearch: find the right bin for x */\n", "func_signal": "int\nbinsearch(double x, double *v, int n)", "code": "{\n\tint low, high, mid, cond;\n\n\tlow = 1;\t\t\t/* skip -Inf */\n\thigh = n-2;\t\t/* and +Inf */\n\twhile(low <= high){\n\t\tmid = (low+high) / 2;\n\t\tif((cond = bincmp(x, v[mid], v[mid+1])) < 0)\n\t\t\thigh = mid-1;\n\t\telse if(cond > 0)\n\t\t\tlow = mid+1;\n\t\telse\n\t\t\treturn mid;\n\t}\n\tif(x < v[1])\n\t\treturn 0;\n\treturn n-1;\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* get: return value of cov_ij */\n", "func_signal": "double\nget(int i, int j)", "code": "{\n\tint aux;\n\tdouble xsd, ysd, cov;\n\tCsum *c;\n\n\tif(j < i){\t/* it's a symmetric matrix */\n\t\taux = i;\n\t\ti = j;\n\t\tj = aux;\n\t}\n\tc = *(csumtab+i) + j-i;\n\tif(c->n){\n\t\txsd = sqrt(c->xm2/c->n);\n\t\tysd = sqrt(c->ym2/c->n);\n\t\tcov = c->sum/c->n;\n\t}else\n\t\treturn Inf(1);\n\tif(pearson){\n\t\tif(xsd > 0.0 && ysd > 0.0)\n\t\t\tcov /= xsd*ysd;\n\t\telse if(cov >= 0.0)\n\t\t\tcov = Inf(1);\n\t\telse if(cov < 0.0)\n\t\t\tcov = Inf(-1);\n\t}\n\treturn cov;\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* ecalloc: allocate memory or die */\n", "func_signal": "void *\necalloc(ulong n, ulong size)", "code": "{\n\tvoid *p;\n\n\tif((p = calloc(n, size)) == nil)\n\t\tsysfatal(\"out of memory\");\n\treturn p;\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* bincmp: check if min \u2264 x < max */\n", "func_signal": "int\nbincmp(double x, double min, double max)", "code": "{\n\tif(x < min)\n\t\treturn -1;\n\tif(x >= max)\n\t\treturn 1;\n\treturn 0;\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* Routine to interpret input and return estimate of type.\n * This needs to read at most 2 lines\n */\n", "func_signal": "input_type lex()", "code": "{\n\tint i=0, ndigits=0, nlines=0;\n\tchar *c;\n\t\n\twhile (c = getc(stdin)) {\n\t\tif (c == '\\n') {\n\t\t\tndigits=0; \n\t\t\t++nlines;\n\t\t\tif ( c = getc(stdin) != EOF && nlines < 2) {\n\t\t\t\tungetc(c, stdin);\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (isdigit(c) || c == '.') {\n\t\t\tif (ndigits == 0)\n\t\t\t\t++i;\n\t\t\t++ndigits;\n\t\t}\n\n\t\t\n\t\tif (isspace(c)) {\n\t\t\tndigits=0;\n\t\t}\n\t\t\n\t\tif (nlines == 2 || c == EOF)\n\t\t\tbreak;\n\t}\n\t\n\tif (chatty) {\n\t\tprintf(\"nlines: %d, i: %d\\n\", nlines, i);\n\t}\n\t\n\tif (nlines == 1) {\n\t\tif (i < 2)\n\t\t\treturn SCALAR;\n\t\telse return VECTOR;\n\t}\n\t\n\tif (i > 1)\n\t\treturn MATRIX;\n\telse return VECTOR;\n}", "path": "lexer.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* emalloc: allocate memory or die */\n", "func_signal": "void *\nemalloc(ulong n)", "code": "{\n\tvoid *p;\n\n\tif((p = malloc(n)) == nil)\n\t\tsysfatal(\"out of memory\");\n\treturn p;\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* creatran: build histogram ranges from s or bp */\n", "func_signal": "void\ncreatran(char *s, char *name, Biobuf *bp)", "code": "{\n\tchar *p, *ep, *line, *t;\n\tint i, nl, nx;\n\tulong nb;\t/* may overflow without too much effort */\n\tdouble x, min, max, delt;\n\n\tif(s){\n\t\tif((t = strdup(s)) == nil)\n\t\t\tsysfatal(\"out of memory\");\n\t\twhile(p = strtok(dim == 0 ? t : nil, \",\")){\n\t\t\tif(sscanf(p, \"%lg:%lg:%ld\", &min, &max, &nb) != 3 || nb == 0)\n\t\t\t\tsysfatal(\"%s: invalid range\", p);\n\t\t\tdelt = (max-min)/nb;\n\t\t\tfor(i = 0; i < nb; i++)\n\t\t\t\taddran(min + i*delt, 'w');\n\t\t\taddran(max, 'w');\t/* remember finite precision */\n\t\t\taddran(0.0, 'l');\n\t\t}\n\t\tfree(t);\n\t}else\n\t\tfor(nl = 1; line = Brdstr(bp, '\\n', 1); free(line), nl++){\n\t\t\tif(p = strchr(line, '#'))\n\t\t\t\t*p = '\\0';\n\t\t\tfor(nx = 0, p = line; *p != '\\0'; nx++){\n\t\t\t\tx = strtod(p, &ep);\n\t\t\t\tif(ep == p){\n\t\t\t\t\tif(!isspace(*p))\n\t\t\t\t\t\tsysfatal(\"%s:%d: invalid range\", name, nl);\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = ep;\n\t\t\t\taddran(x, 'w');\n\t\t\t}\n\t\t\tif(*p == '\\0' && p != line){\n\t\t\t\tif(nx < 2)\n\t\t\t\t\tsysfatal(\"%s:%d: invalid range\", name, nl);\n\t\t\t\taddran(0.0, 'l');\n\t\t\t}\n\t\t}\n\tfacs = emalloc(dim*sizeof(int));\n\tfacs[0] = 1;\n\tfor(i = 1; i < dim; i++)\n\t\tfacs[i] = nbins[i-1]*facs[i-1];\n\tnb = nbins[0];\n\tfor(i = 1; i < dim; i++)\n\t\tnb *= nbins[i];\n\tif((freq = calloc(nb, sizeof(uint))) == nil)\n\t\tsysfatal(\"out of memory\");\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* fill: fill histogram with data in bp */\n", "func_signal": "void\nfill(Biobuf *bp)", "code": "{\n\tstatic double *pnt = nil;\n\tdouble *q;\n\tchar *line, *p;\n\n\tif(pnt == nil)\n\t\tpnt = emalloc(dim*sizeof(double));\n\twhile(line = Brdline(bp, '\\n')){\n\t\tline[Blinelen(bp)-1] = '\\0';\n\t\tif(p = strchr(line, '#'))\n\t\t\t*p = '\\0';\n\t\tif(p = strtok(line, \" \\t\")){\n\t\t\tq = pnt;\n\t\t\tdo{\n\t\t\t\tif(sscanf(p, \"%lg\", q) == 1)\n\t\t\t\t\tq++;\n\t\t\t}while(p = strtok(nil, \" \\t\"));\n\t\t\tif(q-pnt == dim)\n\t\t\t\taddpoint(pnt);\n\t\t}\n\t}\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* addpoint: add pt to histogram */\n", "func_signal": "void\naddpoint(double pnt[])", "code": "{\n\tint i, n;\n\n\tn = 0;\n\tfor(i = 0; i < dim; i++)\n\t\tn += facs[i]*binsearch(pnt[i], range[i], nbins[i]);\n\tfreq[n]++;\n\tnentries++;\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* printr: print range limits */\n", "func_signal": "int\nprintr(double x, double y)", "code": "{\n\tint n;\n\tchar *fm;\n\n\tfm = fmt;\n\tif(isInf(x, 1))\n\t\tfm = \"-\u221e\";\n\tn = sprint(bufp, fm, x);\n\t*(bufp + n++) = ' ';\n\tfm = fmt;\n\tif(isInf(y, 1))\n\t\tfm = \"+\u221e\";\n\tn += sprint(bufp+n, fm, y);\n\t*(bufp + n++) = ' ';\n\treturn n;\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* use the first 4 moments of a data set to find the mean, standard deviation,\nskewness and kurtosis */\n", "func_signal": "void\nmain(int argc, char *argv[])", "code": "{\n\tBiobuf bstdin, bstdout, *bf;\n\tint i, pres;\n\tchar fmt1[7], fmt2[21], *p;\n\tdouble sd, skew, kurt;\n\tlong n;\n\n\tpres = 5;\n\tARGBEGIN{\n\tcase 'p':\n\t\tp = EARGF(usage());\n\t\tpres = atoi(p);\n\t\tif(pres < 1 || pres > MAXPRES)\n\t\t\tsysfatal(\"invalid precision: %s\", p);\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\tmemset(momtab, 0, sizeof(momtab));\n\tif(argc){\n\t\tfor(; argc--; argv++)\n\t\t\tif((bf = Bopen(*argv, OREAD)) == nil)\n\t\t\t\tfprint(2, \"%s: unable to open %s: %r\\n\", argv0, *argv);\n\t\t\telse{\n\t\t\t\tfill(*argv, bf);\n\t\t\t\tBterm(bf);\n\t\t\t}\n\t}else{\n\t\tBinit(&bstdin, 0, OREAD);\n\t\tfill(\"<stdin>\", &bstdin);\n\t}\n\tsprint(fmt1, \"%%.%dg \", pres);\n\tsprint(fmt2, \"%%.%dg %%.%dg %%.%dg\\n\", pres, pres, pres);\n\tBinit(&bstdout, 1, OWRITE);\n\tfor(i = 0; i < ncol; i++){\n\t\tBprint(&bstdout, fmt1, momtab[i].m1);\n\t\tif((n = momtab[i].n-1) > 0){\n\t\t\tsd = sqrt(momtab[i].m2 / n);\n\t\t\tskew = momtab[i].m3 / (n*pow(sd, 3));\n\t\t\tkurt = momtab[i].m4 / (n*pow(sd, 4));\n\t\t\tBprint(&bstdout, fmt2, sd, skew, kurt);\n\t\t}else\n\t\t\tBprint(&bstdout, \"NaN NaN NaN\\n\");\n\t}\n\tBterm(&bstdout);\n\texits(nil);\n}", "path": "mom.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* fill momtab with data in bf */\n", "func_signal": "void\nfill(char *name, Biobuf *bf)", "code": "{\n\tchar *line, *tok;\n\tlong nl;\n\tint ntok;\n\tdouble x;\n\n\t/* this will fail for lines longer than the bio buffer; Brdstr is an alternative */\n\tfor(nl = 1; (line = Brdline(bf, '\\n')); nl++){\n\t\tline[Blinelen(bf)-1] = '\\0';\n\t\tntok = 0;\n\t\twhile(ntok < MAXCOL && (tok = strtok(ntok == 0 ? line : nil, \" \\t\\r\")) ){\n\t\t\tif(sscanf(tok, \"%lg\", &x) == 1)\n\t\t\t\taddval(momtab+ntok, x);\n\t\t\tntok++;\n\t\t}\n\t\tif(ntok > ncol)\n\t\t\tncol = ntok;\n\t}\n\tif(Blinelen(bf)){\n\t\tfprint(2, \"%s: %s: line %ld too long\\n\", argv0, name, nl);\n\t\texits(\"Brdline\");\n\t}\n}", "path": "mom.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* printhis: write histogram to stdout */\n", "func_signal": "void\nprinthis(Biobuf *bp, int n)", "code": "{\n\tint i, k;\n\tdouble x;\n\tchar *fm;\n\n\tfor(i = 0; i < nbins[n]; i++){\n\t\tk = printr(*(range[n] + i), *(range[n] + i+1));\n\t\tbufp += k;\n\t\tind += i*facs[n];\n\t\tif(n < dim-1)\n\t\t\tprinthis(bp, n+1);\n\t\telse{\n\t\t\tfm = fmt;\n\t\t\tx = freq[ind];\n\t\t\tif(denflag && nentries > 0)\n\t\t\t\tx /= nentries;\n\t\t\tif(logflag && x == 0.0)\n\t\t\t\tfm = \"-\u221e\";\n\t\t\telse if(logflag)\n\t\t\t\tx = log10(x);\n\t\t\tsprint(bufp, fm, x);\n\t\t\tBprint(bp, \"%s\\n\", buf);\n\t\t}\n\t\tbufp -= k;\n\t\tind -= i*facs[n];\n\t}\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* addran: add range element */\n", "func_signal": "void\naddran(double x, char c)", "code": "{\n\tstatic int nalloc[3];\n\tstatic double *r;\n\tint i;\n\n\tif(dim > 2)\n\t\tsysfatal(\"too many dimensions\");\n\t/* remember the \u00b1Inf at the extremes */\n\tif(range[dim] == nil){\n\t\tnalloc[dim] = INIT;\n\t\trange[dim] = emalloc(nalloc[dim]*sizeof(double));\n\t\t*range[dim] = Inf(1);\n\t\tr = range[dim] + 1;\n\t\tnbins[dim] = 1;\n\t}\n\tif(c == 'w'){\n\t\ti = r-range[dim];\n\t\tif(i >= nalloc[dim]-1){\n\t\t\trange[dim] = realloc(range[dim], GROW*nalloc[dim]*sizeof(double));\n\t\t\tif(range[dim] == nil)\n\t\t\t\tsysfatal(\"out of memory\");\n\t\t\tr = range[dim] + nalloc[dim]-1;\n\t\t\tnalloc[dim] *= GROW;\n\t\t}\n\t\t*r++ = x;\n\t\tnbins[dim]++;\n\t}else if(c == 'l'){\n\t\t*r = Inf(1);\n\t\tdim++;\n\t}\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* fill: read data in bp */\n", "func_signal": "void\nfill(Biobuf *bp)", "code": "{\n\tstatic double *v = nil;\n\tdouble *q;\n\tchar *line, *p, *s;\n\tCsum **c;\n\tint n;\n\n\twhile(line = Brdline(bp, '\\n')){\n\t\tline[Blinelen(bp)-1] = '\\0';\n\t\tif(p = strchr(line, '#'))\n\t\t\t*p = '\\0';\n\t\tif(csumtab == nil){\n\t\t\tif((s = strdup(line)) == nil)\n\t\t\t\tsysfatal(\"out of memory\");\n\t\t\tfor(n = 0; strtok(n == 0 ? s : nil, \" \\t\"); n++)\n\t\t\t\t;\n\t\t\tif(n){\n\t\t\t\tnfields = n;\n\t\t\t\tv = emalloc(nfields*sizeof(double));\n\t\t\t\tcsumtab = emalloc(nfields*sizeof(Csum *));\n\t\t\t\tfor(c = csumtab; n > 0; c++)\n\t\t\t\t\t*c = ecalloc(n--, sizeof(Csum));\n\t\t\t}\n\t\t\tfree(s);\n\t\t}\n\t\tif(p = strtok(line, \" \\t\")){\n\t\t\tq = v;\n\t\t\tdo{\n\t\t\t\tif(sscanf(p, \"%lg\", q) != 1)\n\t\t\t\t\t*q = Inf(1);\n\t\t\t\tif(++q - v >= nfields)\n\t\t\t\t\tbreak;\n\t\t\t}while(p = strtok(nil, \" \\t\"));\n\t\t\tif(q - v == nfields)\n\t\t\t\tadd(v);\n\t\t}\n\t}\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* add: add values in v to the calculations; formulas taken from B. P. Welford\n(1962).\"Note on a method for calculating corrected sums of squares and\nproducts\".  Technometrics 4(3):419\u2013420 */\n", "func_signal": "void\nadd(double *v)", "code": "{\n\tint i, j;\n\tdouble x, y, xm1, ym1, xm2, ym2;\n\tlong n;\n\tCsum *c;\n\n\tfor(i = 0; i < nfields; i++)\n\t\tfor(j = i; j < nfields; j++)\n\t\t\tif(!isInf(v[i], 1) && !isInf(v[j], 1)){\n\t\t\t\tc = *(csumtab+i) + j-i;\n\t\t\t\tx = v[i];\n\t\t\t\ty = v[j];\n\t\t\t\txm1 = c->xm1;\n\t\t\t\tym1 = c->ym1;\n\t\t\t\txm2 = c->xm2;\n\t\t\t\tym2 = c->ym2;\n\t\t\t\tn = c->n;\n\t\t\t\tc->xm1 += (x - xm1)/(n+1);\n\t\t\t\tc->ym1 += (y - ym1)/(n+1);\n\t\t\t\tc->xm2 += n*pow(x - xm1, 2)/(n+1);\n\t\t\t\tc->ym2 += n*pow(y - ym1, 2)/(n+1);\n\t\t\t\tc->sum += n*(x - xm1)*(y - ym1)/(n+1);\n\t\t\t\tc->n++;\n\t\t\t}\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* add val to our calculations; formulas deduced from \"Formulas for Robust,\nOne-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical\nMoments.\" Philippe P. P\u00e9bay, Technical Report SAND2008-6212, Sandia National\nLaboratories, September 2008.  */\n", "func_signal": "void\naddval(Moments *m, double val)", "code": "{\n\tdouble n, m1, m2, m3;\n\n\tn = m->n;\n\tm1 = m->m1;\n\tm2 = m->m2;\n\tm3 = m->m3;\n\tm->m1 += (val - m1)/(n+1);\n\tm->m2 += n*pow(val - m1, 2)/(n+1);\n\tm->m3 += n*(n-1)*pow(val - m1, 3)/pow(n+1, 2) - 3.0*m2*(val-m1)/(n+1);\n\tm->m4 += n*(n*n-n+1)*pow(val - m1, 4)/pow(n+1, 3) + 6.0*m2*pow(val - m1, 2)/pow(n+1, 2) - 4.0*m3*(val - m1)/(n+1);\n\tm->n++;\n}", "path": "mom.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* find the covariance matrix for a data set */\n", "func_signal": "void\nmain(int argc, char *argv[])", "code": "{\n\tBiobuf *bp, bstdin, bstdout;\n\tint i, j, pres;\n\tchar fmt[6];\n\tchar *fm;\n\tdouble val;\n\n\tpres = 5;\n\tARGBEGIN{\n\tcase 'p':\n\t\tpres = atoi(EARGF(usage()));\n\t\tif(pres < 1 || pres > MAXPRES)\n\t\t\tsysfatal(\"invalid precision: %d\", pres);\n\t\tbreak;\n\tcase 'r':\n\t\tpearson = 1;\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\tif(argc){\n\t\tfor(; argc--; argv++)\n\t\t\tif((bp = Bopen(*argv, OREAD)) == nil)\n\t\t\t\tfprint(2, \"%s: unable to open %s: %r\\n\", argv0, *argv);\n\t\t\telse{\n\t\t\t\tfill(bp);\n\t\t\t\tBterm(bp);\n\t\t\t}\n\t}else{\n\t\tBinit(&bstdin, 0, OREAD);\n\t\tfill(&bstdin);\n\t}\n\tsprint(fmt, \"%%.%dg\", pres);\n\tBinit(&bstdout, 1, OWRITE);\n\tfor(i = 0; i < nfields; i++)\n\t\tfor(j = 0; j < nfields; j++){\n\t\t\tval = get(i, j);\n\t\t\tfm = fmt;\n\t\t\tif(isInf(val, 1))\n\t\t\t\tfm = \"+\u221e\";\n\t\t\telse if(isInf(val, -1))\n\t\t\t\tfm = \"-\u221e\";\n\t\t\tBprint(&bstdout, fm, val);\n\t\t\tBprint(&bstdout, j < nfields-1 ? \" \" : \"\\n\");\n\t\t}\n\tBterm(&bstdout);\n\texits(nil);\n}", "path": "cov.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* emalloc: allocate memory or die */\n", "func_signal": "void *\nemalloc(ulong n)", "code": "{\n\tvoid *p;\n\n\tif((p = malloc(n)) == nil)\n\t\tsysfatal(\"out of memory\");\n\treturn p;\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* fill a histogram of numeric values */\n", "func_signal": "void\nmain(int argc, char *argv[])", "code": "{\n\tBiobuf *bp, bstdin, bstdout;\n\tchar *name;\n\tint i, pres;\n\n\tname = nil;\n\tpres = 5;\n\tARGBEGIN{\n\tcase 'd':\n\t\tdenflag = 1;\n\t\tbreak;\n\tcase 'f':\n\t\tname = EARGF(usage());\n\t\tbreak;\n\tcase 'l':\n\t\tlogflag = 1;\n\t\tbreak;\n\tcase 'p':\n\t\tpres = atoi(EARGF(usage()));\n\t\tif(pres < 1 || pres > MAXPRES)\n\t\t\tsysfatal(\"invalid precision: %d\", pres);\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t}ARGEND\n\tif(name){\n\t\tif((bp = Bopen(name, OREAD)) == nil)\n\t\t\tsysfatal(\"%s: %r\", name);\n\t\tcreatran(nil, name, bp);\n\t\tBterm(bp);\n\t}else if(argc){\n\t\tcreatran(*argv++, nil, nil);\n\t\targc--;\n\t}else\n\t\tusage();\n\tif(argc){\n\t\tfor(i = 0; i < argc; i++, argv++)\n\t\t\tif((bp = Bopen(*argv, OREAD)) != nil){\n\t\t\t\tfill(bp);\n\t\t\t\tBterm(bp);\n\t\t\t}else{\n\t\t\t\tfprint(2, \"%s: %s: %r\\n\", argv0, *argv);\n\t\t\t\tif(argc == 1)\n\t\t\t\t\texits(\"badfile\");\n\t\t\t}\n\t}else{\n\t\tBinit(&bstdin, 0, OREAD);\n\t\tfill(&bstdin);\n\t}\n\tBinit(&bstdout, 1, OWRITE);\n\tsprint(fmt, \"%%.%dg\", pres);\n\tprinthis(&bstdout, 0);\n\tBterm(&bstdout);\n\n\texits(nil);\n}", "path": "his.c", "repo_name": "jrm8005/AnalystsWorkbench", "stars": 4, "license": "other", "language": "c", "size": 2105}
{"docstring": "/* There are no leading zeros on the digits generated at str, but that's not\n   currently a documented feature.  */\n", "func_signal": "size_t\nmpn_get_str (unsigned char *str, int base, mp_ptr up, mp_size_t un)", "code": "{\n  mp_ptr powtab_mem, powtab_mem_ptr;\n  mp_limb_t big_base;\n  size_t digits_in_base;\n  powers_t powtab[30];\n  int pi;\n  mp_size_t n;\n  mp_ptr p, t;\n  size_t out_len;\n\n  /* Special case zero, as the code below doesn't handle it.  */\n  if (un == 0)\n    {\n      str[0] = 0;\n      return 1;\n    }\n\n  if (POW2_P (base))\n    {\n      /* The base is a power of 2.  Convert from most significant end.  */\n      mp_limb_t n1, n0;\n      int bits_per_digit = __mp_bases[base].big_base;\n      int cnt;\n      int bit_pos;\n      mp_size_t i;\n      unsigned char *s = str;\n\n      n1 = up[un - 1];\n      count_leading_zeros (cnt, n1);\n\n      /* BIT_POS should be R when input ends in least significant nibble,\n\t R + bits_per_digit * n when input ends in nth least significant\n\t nibble. */\n\n      {\n\tunsigned long bits;\n\n\tbits = GMP_NUMB_BITS * un - cnt + GMP_NAIL_BITS;\n\tcnt = bits % bits_per_digit;\n\tif (cnt != 0)\n\t  bits += bits_per_digit - cnt;\n\tbit_pos = bits - (un - 1) * GMP_NUMB_BITS;\n      }\n\n      /* Fast loop for bit output.  */\n      i = un - 1;\n      for (;;)\n\t{\n\t  bit_pos -= bits_per_digit;\n\t  while (bit_pos >= 0)\n\t    {\n\t      *s++ = (n1 >> bit_pos) & ((1 << bits_per_digit) - 1);\n\t      bit_pos -= bits_per_digit;\n\t    }\n\t  i--;\n\t  if (i < 0)\n\t    break;\n\t  n0 = (n1 << -bit_pos) & ((1 << bits_per_digit) - 1);\n\t  n1 = up[i];\n\t  bit_pos += GMP_NUMB_BITS;\n\t  *s++ = n0 | (n1 >> bit_pos);\n\n\t  if (!(i & 0xFF)) SCHEME_BIGNUM_USE_FUEL(1);\n\t}\n\n      *s = 0;\n\n      return s - str;\n    }\n\n  /* General case.  The base is not a power of 2.  */\n\n  if (un < GET_STR_PRECOMPUTE_THRESHOLD)\n    {\n      struct powers ptab[1];\n      ptab[0].base = base;\n      return mpn_sb_get_str (str, (size_t) 0, up, un, ptab) - str;\n    }\n\n  /* Allocate one large block for the powers of big_base.  With the current\n     scheme, we need to allocate twice as much as would be possible if a\n     minimal set of powers were generated.  */\n#define ALLOC_SIZE (2 * un + 30)\n {\n   TMP_DECL (marker);\n   TMP_MARK (marker);\n\n   powtab_mem = __GMP_ALLOCATE_FUNC_LIMBS (ALLOC_SIZE);\n   powtab_mem_ptr = powtab_mem;\n\n  /* Compute a table of powers: big_base^1, big_base^2, big_base^4, ...,\n     big_base^(2^k), for k such that the biggest power is between U and\n     sqrt(U).  */\n\n  big_base = __mp_bases[base].big_base;\n  digits_in_base = __mp_bases[base].chars_per_limb;\n\n  powtab[0].base = base; /* FIXME: hack for getting base to mpn_sb_get_str */\n  powtab[1].p = &big_base;\n  powtab[1].n = 1;\n  powtab[1].digits_in_base = digits_in_base;\n  powtab[1].base = base;\n  powtab[2].p = &big_base;\n  powtab[2].n = 1;\n  powtab[2].digits_in_base = digits_in_base;\n  powtab[2].base = base;\n  n = 1;\n  pi = 2;\n  p = &big_base;\n  for (;;)\n    {\n      ++pi;\n      t = powtab_mem_ptr;\n      powtab_mem_ptr += 2 * n;\n      mpn_sqr_n (t, p, n);\n      n *= 2; n -= t[n - 1] == 0;\n      digits_in_base *= 2;\n      p = t;\n      powtab[pi].p = p;\n      powtab[pi].n = n;\n      powtab[pi].digits_in_base = digits_in_base;\n      powtab[pi].base = base;\n\n      if (2 * n > un)\n\tbreak;\n    }\n  ASSERT_ALWAYS (ALLOC_SIZE > powtab_mem_ptr - powtab_mem);\n\n  /* Using our precomputed powers, now in powtab[], convert our number.  */\n  out_len = mpn_dc_get_str (str, 0, up, un, powtab + pi) - str;\n\n  __GMP_FREE_FUNC_LIMBS (powtab_mem, ALLOC_SIZE);\n  \n  TMP_FREE(marker);\n }\n\n  return out_len;\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* Return the address of the ld.so allocated common symbol\t*/\n/* with the least address, or 0 if none.\t\t\t*/\n", "func_signal": "static ptr_t GC_first_common()", "code": "{\n    ptr_t result = 0;\n    extern struct link_dynamic _DYNAMIC;\n    struct rtc_symb * curr_symbol;\n    \n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    curr_symbol = _DYNAMIC.ldd -> ldd_cp;\n    for (; curr_symbol != 0; curr_symbol = curr_symbol -> rtc_next) {\n        if (result == 0\n            || (ptr_t)(curr_symbol -> rtc_sp -> n_value) < result) {\n            result = (ptr_t)(curr_symbol -> rtc_sp -> n_value);\n        }\n    }\n    return(result);\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* mpn_mul_1 -- Multiply a limb vector with a single limb and\n   store the product in a second limb vector. */\n", "func_signal": "mp_limb_t\nmpn_mul_1 (mp_ptr res_ptr, mp_srcptr s1_ptr, mp_size_t s1_size, mp_limb_t s2_limb)", "code": "{\n  register mp_limb_t cy_limb;\n  register mp_size_t j;\n  register mp_limb_t prod_high, prod_low;\n\n  SCHEME_BIGNUM_USE_FUEL(s1_size);\n\n  /* The loop counter and index J goes from -S1_SIZE to -1.  This way\n     the loop becomes faster.  */\n  j = -s1_size;\n\n  /* Offset the base pointers to compensate for the negative indices.  */\n  s1_ptr -= j;\n  res_ptr -= j;\n\n  cy_limb = 0;\n  do\n    {\n      umul_ppmm (prod_high, prod_low, s1_ptr[j], s2_limb);\n\n      prod_low += cy_limb;\n      cy_limb = (prod_low < cy_limb) + prod_high;\n\n      res_ptr[j] = prod_low;\n    }\n  while (++j != 0);\n\n  return cy_limb;\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* The _dyld_* functions have an internal lock so no _dyld functions\n   can be called while the world is stopped without the risk of a deadlock.\n   Because of this we MUST setup callbacks BEFORE we ever stop the world.\n   This should be called BEFORE any thread in created and WITHOUT the\n   allocation lock held. */\n", "func_signal": "void GC_init_dyld()", "code": "{\n  static GC_bool initialized = FALSE;\n  char *bind_fully_env = NULL;\n  \n  if(initialized) return;\n  \n  /* PLTSCHEME: not if dls are disabled */\n  if (GC_no_dls) {\n    initialized = TRUE;\n    return;\n  }\n  \n#   ifdef DARWIN_DEBUG\n  GC_printf0(\"Registering dyld callbacks...\\n\");\n#   endif\n  \n  /* Apple's Documentation:\n     When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n     calls the specified callback (func) once for each of the images that is\n     currently loaded into the program. When a new image is added to the program,\n     your callback is called again with the mach_header for the new image, and the \t\n     virtual memory slide amount of the new image. \n     \n     This WILL properly register already linked libraries and libraries \n     linked in the future\n  */\n  \n    _dyld_register_func_for_add_image(GC_dyld_image_add);\n    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n\n    /* Set this early to avoid reentrancy issues. */\n    initialized = TRUE;\n\n    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n    \n    if (bind_fully_env == NULL) {\n#   ifdef DARWIN_DEBUG\n      GC_printf0(\"Forcing full bind of GC code...\\n\");\n#   endif\n      \n      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n    }\n\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* From os_dep.c\t*/\n", "func_signal": "word GC_register_map_entries(char *maps)", "code": "{\n    char prot_buf[5];\n    char *buf_ptr = maps;\n    int count;\n    word start, end;\n    unsigned int maj_dev;\n    word least_ha, greatest_ha;\n    unsigned i;\n    word datastart = (word)(DATASTART);\n\n    /* Compute heap bounds. FIXME: Should be done by add_to_heap?\t*/\n\tleast_ha = (word)(-1);\n\tgreatest_ha = 0;\n\tfor (i = 0; i < GC_n_heap_sects; ++i) {\n\t    word sect_start = (word)GC_heap_sects[i].hs_start;\n\t    word sect_end = sect_start + GC_heap_sects[i].hs_bytes;\n\t    if (sect_start < least_ha) least_ha = sect_start;\n\t    if (sect_end > greatest_ha) greatest_ha = sect_end;\n        }\n    \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n\t    greatest_ha = (word)GC_scratch_last_end_ptr; \n\n    for (;;) {\n        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n\tif (buf_ptr == NULL) return 1;\n\tif (prot_buf[1] == 'w') {\n\t    /* This is a writable mapping.  Add it to\t\t*/\n\t    /* the root set unless it is already otherwise\t*/\n\t    /* accounted for.\t\t\t\t\t*/\n\t    if (start <= (word)GC_stackbottom && end >= (word)GC_stackbottom) {\n\t\t/* Stack mapping; discard\t*/\n\t\tcontinue;\n\t    }\n#\t    ifdef THREADS\n\t      if (GC_segment_is_thread_stack(start, end)) continue;\n#\t    endif\n\t    /* We no longer exclude the main data segment.\t\t*/\n\t    if (start < least_ha && end > least_ha) {\n\t\tend = least_ha;\n\t    }\n\t    if (start < greatest_ha && end > greatest_ha) {\n\t\tstart = greatest_ha;\n\t    }\n\t    if (start >= least_ha && end <= greatest_ha) continue;\n\t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n\t}\n    }\n    return 1;\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  IFAST_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\n  SHIFT_TEMPS\t\t\t/* for DESCALE */\n  ISHIFT_TEMPS\t\t\t/* for IDESCALE */\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n\n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n\n    tmp10 = tmp0 + tmp2;\t/* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;\t/* phases 5-3 */\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;\t/* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n    \n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n\n    z13 = tmp6 + tmp5;\t\t/* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);\n    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);\n    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);\n    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);\n    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);\n    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);\n    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);\n    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);\n\n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n    \n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part */\n\n    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);\n    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);\n\n    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);\n    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)\n\t    - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];\n    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];\n    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];\n    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];\n\n    tmp7 = z11 + z13;\t\t/* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\t/* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n\n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "libs\\fltk\\jpeg\\jidctfst.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Module initialization routine for merged upsampling/color conversion.\n *\n * NB: this is called under the conditions determined by use_merged_upsample()\n * in jdmaster.c.  That routine MUST correspond to the actual capabilities\n * of this module; no safety checks are made here.\n */\n", "func_signal": "GLOBAL(void)\njinit_merged_upsampler (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample;\n\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *) upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    upsample->upmethod = h2v2_merged_upsample;\n    /* Allocate a spare row buffer */\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    upsample->upmethod = h2v1_merged_upsample;\n    /* No spare row needed */\n    upsample->spare_row = NULL;\n  }\n\n  build_ycc_rgb_table(cinfo);\n}", "path": "libs\\fltk\\jpeg\\jdmerge.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* mpn_submul_1 -- multiply the S1_SIZE long limb vector pointed to by S1_PTR\n   by S2_LIMB, subtract the S1_SIZE least significant limbs of the product\n   from the limb vector pointed to by RES_PTR.  Return the most significant\n   limb of the product, adjusted for carry-out from the subtraction.\n */\n", "func_signal": "mp_limb_t\nmpn_submul_1 (mp_ptr res_ptr, mp_srcptr s1_ptr, mp_size_t s1_size, mp_limb_t s2_limb)", "code": "{\n  register mp_limb_t cy_limb;\n  register mp_size_t j;\n  register mp_limb_t prod_high, prod_low;\n  register mp_limb_t x;\n\n  SCHEME_BIGNUM_USE_FUEL(s1_size);\n\n  /* The loop counter and index J goes from -SIZE to -1.  This way\n     the loop becomes faster.  */\n  j = -s1_size;\n\n  /* Offset the base pointers to compensate for the negative indices.  */\n  res_ptr -= j;\n  s1_ptr -= j;\n\n  cy_limb = 0;\n  do\n    {\n      umul_ppmm (prod_high, prod_low, s1_ptr[j], s2_limb);\n\n      prod_low += cy_limb;\n      cy_limb = (prod_low < cy_limb) + prod_high;\n\n      x = res_ptr[j];\n      prod_low = x - prod_low;\n      cy_limb += (prod_low > x);\n      res_ptr[j] = prod_low;\n    }\n  while (++j != 0);\n\n  return cy_limb;\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* The comments in mpn/generic/divrem_1.c apply here too.\n\n   As noted in the algorithms section of the manual, the shifts in the loop\n   for the unnorm case can be avoided by calculating r = a%(d*2^n), followed\n   by a final (r*2^n)%(d*2^n).  In fact if it happens that a%(d*2^n) can\n   skip a division where (a*2^n)%(d*2^n) can't then there's the same number\n   of divide steps, though how often that happens depends on the assumed\n   distributions of dividend and divisor.  In any case this idea is left to\n   CPU specific implementations to consider.  */\n", "func_signal": "mp_limb_t\nmpn_mod_1 (mp_srcptr up, mp_size_t un, mp_limb_t d)", "code": "{\n  mp_size_t  i;\n  mp_limb_t  n1, n0, r;\n  mp_limb_t  dummy;\n\n  ASSERT (un >= 0);\n  ASSERT (d != 0);\n\n  /* Botch: Should this be handled at all?  Rely on callers?\n     But note un==0 is currently required by mpz/fdiv_r_ui.c and possibly\n     other places.  */\n  if (un == 0)\n    return 0;\n\n  d <<= GMP_NAIL_BITS;\n\n  if ((d & GMP_LIMB_HIGHBIT) != 0)\n    {\n      /* High limb is initial remainder, possibly with one subtract of\n\t d to get r<d.  */\n      r = up[un - 1] << GMP_NAIL_BITS;\n      if (r >= d)\n\tr -= d;\n      r >>= GMP_NAIL_BITS;\n      un--;\n      if (un == 0)\n\treturn r;\n\n      if (BELOW_THRESHOLD (un, MOD_1_NORM_THRESHOLD))\n\t{\n\tplain:\n\t  for (i = un - 1; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd (dummy, r, r, n0, d);\n\t      r >>= GMP_NAIL_BITS;\n\t    }\n\t  return r;\n\t}\n      else\n\t{\n\t  mp_limb_t  inv;\n\t  invert_limb (inv, d);\n\t  for (i = un - 1; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd_preinv (dummy, r, r, n0, d, inv);\n\t      r >>= GMP_NAIL_BITS;\n\t    }\n\t  return r;\n\t}\n    }\n  else\n    {\n      int norm;\n\n      /* Skip a division if high < divisor.  Having the test here before\n\t normalizing will still skip as often as possible.  */\n      r = up[un - 1] << GMP_NAIL_BITS;\n      if (r < d)\n\t{\n\t  r >>= GMP_NAIL_BITS;\n\t  un--;\n\t  if (un == 0)\n\t    return r;\n\t}\n      else\n\tr = 0;\n\n      /* If udiv_qrnnd doesn't need a normalized divisor, can use the simple\n\t code above. */\n      if (! UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (un, MOD_1_UNNORM_THRESHOLD))\n\tgoto plain;\n\n      count_leading_zeros (norm, d);\n      d <<= norm;\n\n      n1 = up[un - 1] << GMP_NAIL_BITS;\n      r = (r << norm) | (n1 >> (GMP_LIMB_BITS - norm));\n\n      if (UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (un, MOD_1_UNNORM_THRESHOLD))\n\t{\n\t  for (i = un - 2; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd (dummy, r, r,\n\t\t\t  (n1 << norm) | (n0 >> (GMP_NUMB_BITS - norm)),\n\t\t\t  d);\n\t      r >>= GMP_NAIL_BITS;\n\t      n1 = n0;\n\t    }\n\t  udiv_qrnnd (dummy, r, r, n1 << norm, d);\n\t  r >>= GMP_NAIL_BITS;\n\t  return r >> norm;\n\t}\n      else\n\t{\n\t  mp_limb_t inv;\n\t  invert_limb (inv, d);\n\n\t  for (i = un - 2; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd_preinv (dummy, r, r,\n\t\t\t\t (n1 << norm) | (n0 >> (GMP_NUMB_BITS - norm)),\n\t\t\t\t d, inv);\n\t      r >>= GMP_NAIL_BITS;\n\t      n1 = n0;\n\t    }\n\t  udiv_qrnnd_preinv (dummy, r, r, n1 << norm, d, inv);\n\t  r >>= GMP_NAIL_BITS;\n\t  return r >> norm;\n\t}\n    }\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.\n */\n", "func_signal": "METHODDEF(void)\nh2v2_merged_upsample (j_decompress_ptr cinfo,\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\n\t\t      JSAMPARRAY output_buf)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr0, outptr1;\n  JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  int * Crrtab = upsample->Cr_r_tab;\n  int * Cbbtab = upsample->Cb_b_tab;\n  INT32 * Crgtab = upsample->Cr_g_tab;\n  INT32 * Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr*2];\n  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = GETJSAMPLE(*inptr00++);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    outptr0 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr00++);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    outptr0 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr01++);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n    outptr1 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr01++);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n    outptr1 += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr00);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    y  = GETJSAMPLE(*inptr01);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n  }\n}", "path": "libs\\fltk\\jpeg\\jdmerge.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* !PCR */\n", "func_signal": "void GC_register_dynamic_libraries()", "code": "{}\n\nint GC_no_dynamic_loading;\n\n#endif /* !PCR */\n\n#endif /* !DYNAMIC_LOADING */\n\n#ifndef HAVE_REGISTER_MAIN_STATIC_DATA\n\n/* Do we need to separately register the main static data segment? */\nGC_bool GC_register_main_static_data()\n{\n  return TRUE;\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* mpn_addmul_1 -- multiply the S1_SIZE long limb vector pointed to by S1_PTR\n   by S2_LIMB, add the S1_SIZE least significant limbs of the product to the\n   limb vector pointed to by RES_PTR.  Return the most significant limb of\n   the product, adjusted for carry-out from the addition. */\n", "func_signal": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)", "code": "{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n \n  SCHEME_BIGNUM_USE_FUEL(n);\n \n  cl = 0;\n  do\n    {\n      ul = *up++;\n      umul_ppmm (hpl, lpl, ul, vl);\n                                                                                \n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n                                                                                \n      rl = *rp;\n      lpl = rl + lpl;\n      cl += lpl < rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n                                                                                \n  return cl;\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Initialize for an upsampling pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_merged_upsample (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n\n  /* Mark the spare buffer empty */\n  upsample->spare_full = FALSE;\n  /* Initialize total-height counter for detecting bottom of image */\n  upsample->rows_to_go = cinfo->output_height;\n}", "path": "libs\\fltk\\jpeg\\jdmerge.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* Perform machine dependent cif processing */\n", "func_signal": "ffi_status\nffi_prep_cif_machdep (ffi_cif *cif)", "code": "{\n  /* Set the return type flag */\n  switch (cif->rtype->type)\n    {\n    case FFI_TYPE_VOID:\n      cif->flags = 0;\n      break;\n\n    case FFI_TYPE_STRUCT:\n      if (cif->rtype->size > 4 && cif->rtype->size <= 8)\n\tcif->flags = CIF_FLAGS_DINT;\n      else if (cif->rtype->size <= 4)\n\tcif->flags = CIF_FLAGS_STRUCT;\n      else\n\tcif->flags = 0;\n      break;\n\n    case FFI_TYPE_FLOAT:\n      cif->flags = CIF_FLAGS_FLOAT;\n      break;\n\n    case FFI_TYPE_DOUBLE:\n      cif->flags = CIF_FLAGS_DOUBLE;\n      break;\n\n    case FFI_TYPE_LONGDOUBLE:\n      cif->flags = CIF_FLAGS_LDOUBLE;\n      break;\n\n    case FFI_TYPE_POINTER:\n      cif->flags = CIF_FLAGS_POINTER;\n      break;\n\n    case FFI_TYPE_SINT64:\n    case FFI_TYPE_UINT64:\n      cif->flags = CIF_FLAGS_DINT;\n      break;\n\n    default:\n      cif->flags = CIF_FLAGS_INT;\n      break;\n    }\n\n  return FFI_OK;\n}", "path": "libs\\mzs\\src\\foreign\\gcc\\libffi\\src\\m68k\\ffi.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* Does not work for U == 0 or V == 0.  It would be tough to make it work for\n   V == 0 since gcd(x,0) = x, and U does not generally fit in an mp_limb_t.\n\n   The threshold for doing u%v when size==1 will vary by CPU according to\n   the speed of a division and the code generated for the main loop.  Any\n   tuning for this is left to a CPU specific implementation.  */\n", "func_signal": "mp_limb_t\nmpn_gcd_1 (mp_srcptr up, mp_size_t size, mp_limb_t vlimb)", "code": "{\n  mp_limb_t      ulimb;\n  unsigned long  zero_bits, u_low_zero_bits;\n\n  ASSERT (size >= 1);\n  ASSERT (vlimb != 0);\n  /* ASSERT_MPN_NONZERO_P (up, size); */\n\n  ulimb = up[0];\n\n  /* Need vlimb odd for modexact, want it odd to get common zeros. */\n  count_trailing_zeros (zero_bits, vlimb);\n  vlimb >>= zero_bits;\n\n  if (size > 1)\n    {\n      /* Must get common zeros before the mod reduction.  If ulimb==0 then\n\t vlimb already gives the common zeros.  */\n      if (ulimb != 0)\n\t{\n\t  count_trailing_zeros (u_low_zero_bits, ulimb);\n\t  zero_bits = MIN (zero_bits, u_low_zero_bits);\n\t}\n\n      ulimb = MPN_MOD_OR_MODEXACT_1_ODD (up, size, vlimb);\n      if (ulimb == 0)\n\tgoto done;\n\n      goto strip_u_maybe;\n    }\n\n  /* size==1, so up[0]!=0 */\n  count_trailing_zeros (u_low_zero_bits, ulimb);\n  ulimb >>= u_low_zero_bits;\n  zero_bits = MIN (zero_bits, u_low_zero_bits);\n\n  /* make u bigger */\n  if (vlimb > ulimb)\n    MP_LIMB_T_SWAP (ulimb, vlimb);\n\n  /* if u is much bigger than v, reduce using a division rather than\n     chipping away at it bit-by-bit */\n  if ((ulimb >> 16) > vlimb)\n    {\n      ulimb %= vlimb;\n      if (ulimb == 0)\n\tgoto done;\n      goto strip_u_maybe;\n    }\n\n  while (ulimb != vlimb)\n    {\n      ASSERT (ulimb & 1);\n      ASSERT (vlimb & 1);\n\n      if (ulimb > vlimb)\n\t{\n\t  ulimb -= vlimb;\n\t  do\n\t    {\n\t      ulimb >>= 1;\n\t      ASSERT (ulimb != 0);\n\t    strip_u_maybe:\n\t      ;\n\t    }\n\t  while ((ulimb & 1) == 0);\n\t}\n      else /*  vlimb > ulimb.  */\n\t{\n\t  vlimb -= ulimb;\n\t  do\n\t    {\n\t      vlimb >>= 1;\n\t      ASSERT (vlimb != 0);\n\t    }\n\t  while ((vlimb & 1) == 0);\n\t}\n    }\n\n done:\n  return vlimb << zero_bits;\n}", "path": "libs\\mzs\\src\\mzscheme\\src\\gmp\\gmp.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* ffi_prep_args is called by the assembly routine once stack space has\n   been allocated for the function's arguments.  */\n", "func_signal": "static void *\nffi_prep_args (void *stack, extended_cif *ecif)", "code": "{\n  unsigned int i;\n  void **p_argv;\n  char *argp;\n  ffi_type **p_arg;\n  void *struct_value_ptr;\n\n  argp = stack;\n\n  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n      && ecif->cif->rtype->size > 8)\n    struct_value_ptr = ecif->rvalue;\n  else\n    struct_value_ptr = NULL;\n\n  p_argv = ecif->avalue;\n\n  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n       i != 0;\n       i--, p_arg++)\n    {\n      size_t z;\n\n      /* Align if necessary.  */\n      if (((*p_arg)->alignment - 1) & (unsigned) argp)\n\targp = (char *) ALIGN (argp, (*p_arg)->alignment);\n\n\t  z = (*p_arg)->size;\n\t  if (z < sizeof (int))\n\t    {\n\t      switch ((*p_arg)->type)\n\t\t{\n\t\tcase FFI_TYPE_SINT8:\n\t\t  *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;\n\t\t  break;\n\n\t\tcase FFI_TYPE_UINT8:\n\t\t  *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;\n\t\t  break;\n\n\t\tcase FFI_TYPE_SINT16:\n\t\t  *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;\n\t\t  break;\n\n\t\tcase FFI_TYPE_UINT16:\n\t\t  *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;\n\t\t  break;\n\n\t\tcase FFI_TYPE_STRUCT:\n\t\t  memcpy (argp + sizeof (int) - z, *p_argv, z);\n\t\t  break;\n\n\t\tdefault:\n\t\t  FFI_ASSERT (0);\n\t\t}\n\t      z = sizeof (int);\n\t    }\n\t  else\n\t    memcpy (argp, *p_argv, z);\n\t  p_argv++;\n\t  argp += z;\n    }\n\n  return struct_value_ptr;\n}", "path": "libs\\mzs\\src\\foreign\\gcc\\libffi\\src\\m68k\\ffi.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Initialize tables for YCC->RGB colorspace conversion.\n * This is taken directly from jdcolor.c; see that file for more info.\n */\n", "func_signal": "LOCAL(void)\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  int i;\n  INT32 x;\n  SHIFT_TEMPS\n\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cr_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n  upsample->Cb_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    upsample->Cr_r_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    upsample->Cb_b_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "path": "libs\\fltk\\jpeg\\jdmerge.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* This should never be called by a thread holding the lock */\n", "func_signal": "static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide)", "code": "{\n    unsigned long start,end,i;\n    const struct section *sec;\n    if (GC_no_dls) return;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#       endif\n        GC_add_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/* This should never be called by a thread holding the lock */\n", "func_signal": "static void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide)", "code": "{\n    unsigned long start,end,i;\n    const struct section *sec;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#\t\tendif\n        GC_remove_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}", "path": "libs\\mzs\\src\\mzscheme\\gc\\dyn_load.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.\n */\n", "func_signal": "METHODDEF(void)\nh2v1_merged_upsample (j_decompress_ptr cinfo,\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\n\t\t      JSAMPARRAY output_buf)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr;\n  JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  int * Crrtab = upsample->Cr_r_tab;\n  int * Cbbtab = upsample->Cb_b_tab;\n  INT32 * Crgtab = upsample->Cr_g_tab;\n  INT32 * Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n    outptr += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n    outptr += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr0);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n  }\n}", "path": "libs\\fltk\\jpeg\\jdmerge.c", "repo_name": "amitksaha/spark-scheme", "stars": 6, "license": "gpl-3.0", "language": "c", "size": 14757}
{"docstring": "/*\n** Add connection db to the blocked connections list. It is assumed\n** that it is not already a part of the list.\n*/\n", "func_signal": "static void addToBlockedList(sqlite3 *db)", "code": "{\n  sqlite3 **pp;\n  assertMutexHeld();\n  for(\n    pp=&sqlite3BlockedList; \n    *pp && (*pp)->xUnlockNotify!=db->xUnlockNotify; \n    pp=&(*pp)->pNextBlocked\n  );\n  db->pNextBlocked = *pp;\n  *pp = db;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Link the chunk at mem3.aPool[i] so that is on the list rooted\n** at *pRoot.\n*/\n", "func_signal": "static void memsys3LinkIntoList(u32 i, u32 *pRoot)", "code": "{\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  mem3.aPool[i].u.list.next = *pRoot;\n  mem3.aPool[i].u.list.prev = 0;\n  if( *pRoot ){\n    mem3.aPool[*pRoot].u.list.prev = i;\n  }\n  *pRoot = i;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\n", "func_signal": "static void pthreadMutexLeave(sqlite3_mutex *p)", "code": "{\n  assert( pthreadMutexHeld(p) );\n  p->nRef--;\n  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n  if( p->nRef==0 ){\n    pthread_mutex_unlock(&p->mutex);\n  }\n#else\n  pthread_mutex_unlock(&p->mutex);\n#endif\n\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    printf(\"leave mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Delete the cell at index iCell of node pNode. After removing the\n** cell, adjust the r-tree data structure if required.\n*/\n", "func_signal": "static int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight)", "code": "{\n  int rc;\n\n  if( SQLITE_OK!=(rc = fixLeafParent(pRtree, pNode)) ){\n    return rc;\n  }\n\n  /* Remove the cell from the node. This call just moves bytes around\n  ** the in-memory node image, so it cannot fail.\n  */\n  nodeDeleteCell(pRtree, pNode, iCell);\n\n  /* If the node is not the tree root and now has less than the minimum\n  ** number of cells, remove it from the tree. Otherwise, update the\n  ** cell in the parent node so that it tightly contains the updated\n  ** node.\n  */\n  if( pNode->iNode!=1 ){\n    RtreeNode *pParent = pNode->pParent;\n    if( (pParent->iNode!=1 || NCELL(pParent)!=1) \n     && (NCELL(pNode)<RTREE_MINCELLS(pRtree))\n    ){\n      rc = removeNode(pRtree, pNode, iHeight);\n    }else{\n      fixBoundingBox(pRtree, pNode);\n    }\n  }\n\n  return rc;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/* \n** Rtree virtual table module xDisconnect method.\n*/\n", "func_signal": "static int rtreeDisconnect(sqlite3_vtab *pVtab)", "code": "{\n  rtreeRelease((Rtree *)pVtab);\n  return SQLITE_OK;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Return true if the current thread holds the database connection\n** mutex and all required BtShared mutexes.\n**\n** This routine is used inside assert() statements only.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3 *db)", "code": "{\n  int i;\n  if( !sqlite3_mutex_held(db->mutex) ){\n    return 0;\n  }\n  for(i=0; i<db->nDb; i++){\n    Btree *p;\n    p = db->aDb[i].pBt;\n    if( p && p->sharable &&\n         (p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){\n      return 0;\n    }\n  }\n  return 1;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/* Compare the current term to pTerm[nTerm], returning strcmp-style\n** results.  If isPrefix, equality means equal through nTerm bytes.\n*/\n", "func_signal": "static int interiorReaderTermCmp(InteriorReader *pReader,\n                                 const char *pTerm, int nTerm, int isPrefix)", "code": "{\n  const char *pReaderTerm = interiorReaderTerm(pReader);\n  int nReaderTerm = interiorReaderTermBytes(pReader);\n  int c, n = nReaderTerm<nTerm ? nReaderTerm : nTerm;\n\n  if( n==0 ){\n    if( nReaderTerm>0 ) return -1;\n    if( nTerm>0 ) return 1;\n    return 0;\n  }\n\n  c = memcmp(pReaderTerm, pTerm, n);\n  if( c!=0 ) return c;\n  if( isPrefix && n==nTerm ) return 0;\n  return nReaderTerm - nTerm;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Free a parsed fts3 query expression allocated by sqlite3Fts3ExprParse().\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *p)", "code": "{\n  if( p ){\n    sqlite3Fts3ExprFree(p->pLeft);\n    sqlite3Fts3ExprFree(p->pRight);\n    sqlite3_free(p);\n  }\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** The input azIn is a NULL-terminated list of tokens.  Remove the first\n** token and all punctuation tokens.  Remove the quotes from\n** around string literal tokens.\n**\n** Example:\n**\n**     input:      tokenize chinese ( 'simplifed' , 'mixed' )\n**     output:     chinese simplifed mixed\n**\n** Another example:\n**\n**     input:      delimiters ( '[' , ']' , '...' )\n**     output:     [ ] ...\n*/\n", "func_signal": "static void tokenListToIdList(char **azIn)", "code": "{\n  int i, j;\n  if( azIn ){\n    for(i=0, j=-1; azIn[i]; i++){\n      if( safe_isalnum(azIn[i][0]) || azIn[i][1] ){\n        dequoteString(azIn[i]);\n        if( j>=0 ){\n          azIn[j] = azIn[i];\n        }\n        j++;\n      }\n    }\n    azIn[j] = 0;\n  }\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/* SQLITE_OMIT_UTF16 */\n", "func_signal": "SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i)", "code": "{\n  int iType = sqlite3_value_type( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return iType;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Destroy a bitmap object.  Reclaim all memory used.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p)", "code": "{\n  if( p==0 ) return;\n  if( p->iDivisor ){\n    unsigned int i;\n    for(i=0; i<BITVEC_NPTR; i++){\n      sqlite3BitvecDestroy(p->u.apSub[i]);\n    }\n  }\n  sqlite3_free(p);\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/* Returns SQLITE_ROW with *pidx set to the maximum segment idx found\n** at iLevel.  Returns SQLITE_DONE if there are no segments at\n** iLevel.  Otherwise returns an error.\n*/\n", "func_signal": "static int segdir_max_index(fulltext_vtab *v, int iLevel, int *pidx)", "code": "{\n  sqlite3_stmt *s;\n  int rc = sql_get_statement(v, SEGDIR_MAX_INDEX_STMT, &s);\n  if( rc!=SQLITE_OK ) return rc;\n\n  rc = sqlite3_bind_int(s, 1, iLevel);\n  if( rc!=SQLITE_OK ) return rc;\n\n  rc = sqlite3_step(s);\n  /* Should always get at least one row due to how max() works. */\n  if( rc==SQLITE_DONE ) return SQLITE_DONE;\n  if( rc!=SQLITE_ROW ) return rc;\n\n  /* NULL means that there were no inputs to max(). */\n  if( SQLITE_NULL==sqlite3_column_type(s, 0) ){\n    rc = sqlite3_step(s);\n    if( rc==SQLITE_ROW ) return SQLITE_ERROR;\n    return rc;\n  }\n\n  *pidx = sqlite3_column_int(s, 0);\n\n  /* We expect only one row.  We must execute another sqlite3_step()\n   * to complete the iteration; otherwise the table will remain locked. */\n  rc = sqlite3_step(s);\n  if( rc==SQLITE_ROW ) return SQLITE_ERROR;\n  if( rc!=SQLITE_DONE ) return rc;\n  return SQLITE_ROW;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** If pFile holds a lock on a conch file, then release that lock.\n*/\n", "func_signal": "static int proxyReleaseConch(unixFile *pFile)", "code": "{\n  int rc;                     /* Subroutine return code */\n  proxyLockingContext *pCtx;  /* The locking context for the proxy lock */\n  unixFile *conchFile;        /* Name of the conch file */\n\n  pCtx = (proxyLockingContext *)pFile->lockingContext;\n  conchFile = pCtx->conchFile;\n  OSTRACE4(\"RELEASECONCH  %d for %s pid=%d\\n\", conchFile->h,\n           (pCtx->lockProxyPath ? pCtx->lockProxyPath : \":auto:\"), \n           getpid());\n  pCtx->conchHeld = 0;\n  rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);\n  OSTRACE3(\"RELEASECONCH  %d %s\\n\", conchFile->h,\n           (rc==SQLITE_OK ? \"ok\" : \"failed\"));\n  return rc;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Delete an entire VDBE.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p)", "code": "{\n  sqlite3 *db;\n\n  if( NEVER(p==0) ) return;\n  db = p->db;\n  if( p->pPrev ){\n    p->pPrev->pNext = p->pNext;\n  }else{\n    assert( db->pVdbe==p );\n    db->pVdbe = p->pNext;\n  }\n  if( p->pNext ){\n    p->pNext->pPrev = p->pPrev;\n  }\n  releaseMemArray(p->aVar, p->nVar);\n  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n  vdbeFreeOpArray(db, p->aOp, p->nOp);\n  sqlite3DbFree(db, p->aLabel);\n  sqlite3DbFree(db, p->aColName);\n  sqlite3DbFree(db, p->zSql);\n  p->magic = VDBE_MAGIC_DEAD;\n  sqlite3DbFree(db, p->pFree);\n  sqlite3DbFree(db, p);\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/* TODO(shess) The assertions are great, but what if we're in NDEBUG\n** and the blob is empty or otherwise contains suspect data?\n*/\n", "func_signal": "static void interiorReaderInit(const char *pData, int nData,\n                               InteriorReader *pReader)", "code": "{\n  int n, nTerm;\n\n  /* Require at least the leading flag byte */\n  assert( nData>0 );\n  assert( pData[0]!='\\0' );\n\n  CLEAR(pReader);\n\n  /* Decode the base blockid, and set the cursor to the first term. */\n  n = fts3GetVarint(pData+1, &pReader->iBlockid);\n  assert( 1+n<=nData );\n  pReader->pData = pData+1+n;\n  pReader->nData = nData-(1+n);\n\n  /* A single-child interior node (such as when a leaf node was too\n  ** large for the segment directory) won't have any terms.\n  ** Otherwise, decode the first term.\n  */\n  if( pReader->nData==0 ){\n    dataBufferInit(&pReader->term, 0);\n  }else{\n    n = fts3GetVarint32(pReader->pData, &nTerm);\n    dataBufferInit(&pReader->term, nTerm);\n    dataBufferReplace(&pReader->term, pReader->pData+n, nTerm);\n    assert( n+nTerm<=pReader->nData );\n    pReader->pData += n+nTerm;\n    pReader->nData -= n+nTerm;\n  }\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Select a currently unused rowid for a new r-tree record.\n*/\n", "func_signal": "static int newRowid(Rtree *pRtree, i64 *piRowid)", "code": "{\n  int rc;\n  sqlite3_bind_null(pRtree->pWriteRowid, 1);\n  sqlite3_bind_null(pRtree->pWriteRowid, 2);\n  sqlite3_step(pRtree->pWriteRowid);\n  rc = sqlite3_reset(pRtree->pWriteRowid);\n  *piRowid = sqlite3_last_insert_rowid(pRtree->db);\n  return rc;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Create a temporary file name in zBuf.  zBuf must be big enough to\n** hold at pVfs->mxPathname characters.\n*/\n", "func_signal": "static int getTempname(int nBuf, char *zBuf)", "code": "{\n  static char zChars[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"0123456789\";\n  size_t i, j;\n  char zTempPath[MAX_PATH+1];\n  if( sqlite3_temp_directory ){\n    sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", sqlite3_temp_directory);\n  }else if( isNT() ){\n    char *zMulti;\n    WCHAR zWidePath[MAX_PATH];\n    GetTempPathW(MAX_PATH-30, zWidePath);\n    zMulti = unicodeToUtf8(zWidePath);\n    if( zMulti ){\n      sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", zMulti);\n      free(zMulti);\n    }else{\n      return SQLITE_NOMEM;\n    }\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    char *zUtf8;\n    char zMbcsPath[MAX_PATH];\n    GetTempPathA(MAX_PATH-30, zMbcsPath);\n    zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath);\n    if( zUtf8 ){\n      sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", zUtf8);\n      free(zUtf8);\n    }else{\n      return SQLITE_NOMEM;\n    }\n#endif\n  }\n  for(i=sqlite3Strlen30(zTempPath); i>0 && zTempPath[i-1]=='\\\\'; i--){}\n  zTempPath[i] = 0;\n  sqlite3_snprintf(nBuf-30, zBuf,\n                   \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPath);\n  j = sqlite3Strlen30(zBuf);\n  sqlite3_randomness(20, &zBuf[j]);\n  for(i=0; i<20; i++, j++){\n    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n  }\n  zBuf[j] = 0;\n  OSTRACE2(\"TEMP FILENAME: %s\\n\", zBuf);\n  return SQLITE_OK; \n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Generate VDBE code that prepares for doing an operation that\n** might change the database.\n**\n** This routine starts a new transaction if we are not already within\n** a transaction.  If we are already within a transaction, then a checkpoint\n** is set if the setStatement parameter is true.  A checkpoint should\n** be set for operations that might fail (due to a constraint) part of\n** the way through and which will need to undo some writes without having to\n** rollback the whole transaction.  For operations where all constraints\n** can be checked before any changes are made to the database, it is never\n** necessary to undo a write and the checkpoint should not be set.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb)", "code": "{\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  sqlite3CodeVerifySchema(pParse, iDb);\n  pToplevel->writeMask |= 1<<iDb;\n  pToplevel->isMultiWrite |= setStatement;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** Make an shallow copy of pFrom into pTo.  Prior contents of\n** pTo are freed.  The pFrom->z field is not duplicated.  If\n** pFrom->z is used, then pTo->z points to the same thing as pFrom->z\n** and flags gets srcType (either MEM_Ephem or MEM_Static).\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType)", "code": "{\n  assert( (pFrom->flags & MEM_RowSet)==0 );\n  sqlite3VdbeMemReleaseExternal(pTo);\n  memcpy(pTo, pFrom, MEMCELLSIZE);\n  pTo->xDel = 0;\n  if( (pFrom->flags&MEM_Dyn)!=0 || pFrom->z==pFrom->zMalloc ){\n    pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem);\n    assert( srcType==MEM_Ephem || srcType==MEM_Static );\n    pTo->flags |= srcType;\n  }\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n** If the source-list item passed as an argument was augmented with an\n** INDEXED BY clause, then try to locate the specified index. If there\n** was such a clause and the named index cannot be found, return \n** SQLITE_ERROR and leave an error in pParse. Otherwise, populate \n** pFrom->pIndex and return SQLITE_OK.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom)", "code": "{\n  if( pFrom->pTab && pFrom->zIndex ){\n    Table *pTab = pFrom->pTab;\n    char *zIndex = pFrom->zIndex;\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; \n        pIdx && sqlite3StrICmp(pIdx->zName, zIndex); \n        pIdx=pIdx->pNext\n    );\n    if( !pIdx ){\n      sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndex, 0);\n      return SQLITE_ERROR;\n    }\n    pFrom->pIndex = pIdx;\n  }\n  return SQLITE_OK;\n}", "path": "sqloutliner\\sqlite3.c", "repo_name": "ZaneA/LibOrgParser", "stars": 5, "license": "other", "language": "c", "size": 1860}
{"docstring": "/*\n     *  Unaligned 32-bit pattern fill using 32/64-bit memory accesses\n     */\n", "func_signal": "static void bitfill32(unsigned long *dst, int dst_idx, u32 pat, u32 n)", "code": "{\n\tunsigned long val = pat;\n\tunsigned long first, last;\n\n\tif (!n)\n\t\treturn;\n\n#if BITS_PER_LONG == 64\n\tval |= val << 32;\n#endif\n\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));\n\n\tif (dst_idx+n <= BITS_PER_LONG) {\n\t\t// Single word\n\t\tif (last)\n\t\t\tfirst &= last;\n\t\t*dst = comp(val, *dst, first);\n\t} else {\n\t\t// Multiple destination words\n\t\t// Leading bits\n\t\tif (first) {\n\t\t\t*dst = comp(val, *dst, first);\n\t\t\tdst++;\n\t\t\tn -= BITS_PER_LONG-dst_idx;\n\t\t}\n\n\t\t// Main chunk\n\t\tn /= BITS_PER_LONG;\n\t\twhile (n >= 8) {\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\t*dst++ = val;\n\t\t\tn -= 8;\n\t\t}\n\t\twhile (n--)\n\t\t\t*dst++ = val;\n\n\t\t// Trailing bits\n\t\tif (last)\n\t\t\t*dst = comp(val, *dst, last);\n\t}\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Get the video params out of `var'. If a value doesn't fit, round\n\t * it up, if it's too big, return -EINVAL.\n\t */\n", "func_signal": "static int ami_decode_var(struct fb_var_screeninfo *var,\n                          struct amifb_par *par)", "code": "{\n\tu_short clk_shift, line_shift;\n\tu_long maxfetchstop, fstrt, fsize, fconst, xres_n, yres_n;\n\tu_int htotal, vtotal;\n\n\t/*\n\t * Find a matching Pixel Clock\n\t */\n\n\tfor (clk_shift = TAG_SHRES; clk_shift <= TAG_LORES; clk_shift++)\n\t\tif (var->pixclock <= pixclock[clk_shift])\n\t\t\tbreak;\n\tif (clk_shift > TAG_LORES) {\n\t\tDPRINTK(\"pixclock too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpar->clk_shift = clk_shift;\n\n\t/*\n\t * Check the Geometry Values\n\t */\n\n\tif ((par->xres = var->xres) < 64)\n\t\tpar->xres = 64;\n\tif ((par->yres = var->yres) < 64)\n\t\tpar->yres = 64;\n\tif ((par->vxres = var->xres_virtual) < par->xres)\n\t\tpar->vxres = par->xres;\n\tif ((par->vyres = var->yres_virtual) < par->yres)\n\t\tpar->vyres = par->yres;\n\n\tpar->bpp = var->bits_per_pixel;\n\tif (!var->nonstd) {\n\t\tif (par->bpp < 1)\n\t\t\tpar->bpp = 1;\n\t\tif (par->bpp > maxdepth[clk_shift]) {\n\t\t\tif (round_down_bpp && maxdepth[clk_shift])\n\t\t\t\tpar->bpp = maxdepth[clk_shift];\n\t\t\telse {\n\t\t\t\tDPRINTK(\"invalid bpp\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else if (var->nonstd == FB_NONSTD_HAM) {\n\t\tif (par->bpp < 6)\n\t\t\tpar->bpp = 6;\n\t\tif (par->bpp != 6) {\n\t\t\tif (par->bpp < 8)\n\t\t\t\tpar->bpp = 8;\n\t\t\tif (par->bpp != 8 || !IS_AGA) {\n\t\t\t\tDPRINTK(\"invalid bpp for ham mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDPRINTK(\"unknown nonstd mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * FB_VMODE_SMOOTH_XPAN will be cleared, if one of the folloing\n\t * checks failed and smooth scrolling is not possible\n\t */\n\n\tpar->vmode = var->vmode | FB_VMODE_SMOOTH_XPAN;\n\tswitch (par->vmode & FB_VMODE_MASK) {\n\t\tcase FB_VMODE_INTERLACED:\n\t\t\tline_shift = 0;\n\t\t\tbreak;\n\t\tcase FB_VMODE_NONINTERLACED:\n\t\t\tline_shift = 1;\n\t\t\tbreak;\n\t\tcase FB_VMODE_DOUBLE:\n\t\t\tif (!IS_AGA) {\n\t\t\t\tDPRINTK(\"double mode only possible with aga\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tline_shift = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTK(\"unknown video mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t}\n\tpar->line_shift = line_shift;\n\n\t/*\n\t * Vertical and Horizontal Timings\n\t */\n\n\txres_n = par->xres<<clk_shift;\n\tyres_n = par->yres<<line_shift;\n\tpar->htotal = down8((var->left_margin+par->xres+var->right_margin+var->hsync_len)<<clk_shift);\n\tpar->vtotal = down2(((var->upper_margin+par->yres+var->lower_margin+var->vsync_len)<<line_shift)+1);\n\n\tif (IS_AGA)\n\t\tpar->bplcon3 = sprpixmode[clk_shift];\n\telse\n\t\tpar->bplcon3 = 0;\n\tif (var->sync & FB_SYNC_BROADCAST) {\n\t\tpar->diwstop_h = par->htotal-((var->right_margin-var->hsync_len)<<clk_shift);\n\t\tif (IS_AGA)\n\t\t\tpar->diwstop_h += mod4(var->hsync_len);\n\t\telse\n\t\t\tpar->diwstop_h = down4(par->diwstop_h);\n\n\t\tpar->diwstrt_h = par->diwstop_h - xres_n;\n\t\tpar->diwstop_v = par->vtotal-((var->lower_margin-var->vsync_len)<<line_shift);\n\t\tpar->diwstrt_v = par->diwstop_v - yres_n;\n\t\tif (par->diwstop_h >= par->htotal+8) {\n\t\t\tDPRINTK(\"invalid diwstop_h\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->diwstop_v > par->vtotal) {\n\t\t\tDPRINTK(\"invalid diwstop_v\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!IS_OCS) {\n\t\t\t/* Initialize sync with some reasonable values for pwrsave */\n\t\t\tpar->hsstrt = 160;\n\t\t\tpar->hsstop = 320;\n\t\t\tpar->vsstrt = 30;\n\t\t\tpar->vsstop = 34;\n\t\t} else {\n\t\t\tpar->hsstrt = 0;\n\t\t\tpar->hsstop = 0;\n\t\t\tpar->vsstrt = 0;\n\t\t\tpar->vsstop = 0;\n\t\t}\n\t\tif (par->vtotal > (PAL_VTOTAL+NTSC_VTOTAL)/2) {\n\t\t\t/* PAL video mode */\n\t\t\tif (par->htotal != PAL_HTOTAL) {\n\t\t\t\tDPRINTK(\"htotal invalid for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_h < PAL_DIWSTRT_H) {\n\t\t\t\tDPRINTK(\"diwstrt_h too low for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_v < PAL_DIWSTRT_V) {\n\t\t\t\tDPRINTK(\"diwstrt_v too low for pal\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thtotal = PAL_HTOTAL>>clk_shift;\n\t\t\tvtotal = PAL_VTOTAL>>1;\n\t\t\tif (!IS_OCS) {\n\t\t\t\tpar->beamcon0 = BMC0_PAL;\n\t\t\t\tpar->bplcon3 |= BPC3_BRDRBLNK;\n\t\t\t} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\n\t\t\t           AMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\n\t\t\t\tpar->beamcon0 = BMC0_PAL;\n\t\t\t\tpar->hsstop = 1;\n\t\t\t} else if (amiga_vblank != 50) {\n\t\t\t\tDPRINTK(\"pal not supported by this chipset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NTSC video mode\n\t\t\t * In the AGA chipset seems to be hardware bug with BPC3_BRDRBLNK\n\t\t\t * and NTSC activated, so than better let diwstop_h <= 1812\n\t\t\t */\n\t\t\tif (par->htotal != NTSC_HTOTAL) {\n\t\t\t\tDPRINTK(\"htotal invalid for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_h < NTSC_DIWSTRT_H) {\n\t\t\t\tDPRINTK(\"diwstrt_h too low for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (par->diwstrt_v < NTSC_DIWSTRT_V) {\n\t\t\t\tDPRINTK(\"diwstrt_v too low for ntsc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thtotal = NTSC_HTOTAL>>clk_shift;\n\t\t\tvtotal = NTSC_VTOTAL>>1;\n\t\t\tif (!IS_OCS) {\n\t\t\t\tpar->beamcon0 = 0;\n\t\t\t\tpar->bplcon3 |= BPC3_BRDRBLNK;\n\t\t\t} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\n\t\t\t           AMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\n\t\t\t\tpar->beamcon0 = 0;\n\t\t\t\tpar->hsstop = 1;\n\t\t\t} else if (amiga_vblank != 60) {\n\t\t\t\tDPRINTK(\"ntsc not supported by this chipset\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (IS_OCS) {\n\t\t\tif (par->diwstrt_h >= 1024 || par->diwstop_h < 1024 ||\n\t\t\t    par->diwstrt_v >=  512 || par->diwstop_v <  256) {\n\t\t\t\tDPRINTK(\"invalid position for display on ocs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else if (!IS_OCS) {\n\t\t/* Programmable video mode */\n\t\tpar->hsstrt = var->right_margin<<clk_shift;\n\t\tpar->hsstop = (var->right_margin+var->hsync_len)<<clk_shift;\n\t\tpar->diwstop_h = par->htotal - mod8(par->hsstrt) + 8 - (1 << clk_shift);\n\t\tif (!IS_AGA)\n\t\t\tpar->diwstop_h = down4(par->diwstop_h) - 16;\n\t\tpar->diwstrt_h = par->diwstop_h - xres_n;\n\t\tpar->hbstop = par->diwstrt_h + 4;\n\t\tpar->hbstrt = par->diwstop_h + 4;\n\t\tif (par->hbstrt >= par->htotal + 8)\n\t\t\tpar->hbstrt -= par->htotal;\n\t\tpar->hcenter = par->hsstrt + (par->htotal >> 1);\n\t\tpar->vsstrt = var->lower_margin<<line_shift;\n\t\tpar->vsstop = (var->lower_margin+var->vsync_len)<<line_shift;\n\t\tpar->diwstop_v = par->vtotal;\n\t\tif ((par->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\n\t\t\tpar->diwstop_v -= 2;\n\t\tpar->diwstrt_v = par->diwstop_v - yres_n;\n\t\tpar->vbstop = par->diwstrt_v - 2;\n\t\tpar->vbstrt = par->diwstop_v - 2;\n\t\tif (par->vtotal > 2048) {\n\t\t\tDPRINTK(\"vtotal too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (par->htotal > 2048) {\n\t\t\tDPRINTK(\"htotal too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpar->bplcon3 |= BPC3_EXTBLKEN;\n\t\tpar->beamcon0 = BMC0_HARDDIS | BMC0_VARVBEN | BMC0_LOLDIS |\n\t\t                BMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARBEAMEN |\n\t\t                BMC0_PAL | BMC0_VARCSYEN;\n\t\tif (var->sync & FB_SYNC_HOR_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_HSYTRUE;\n\t\tif (var->sync & FB_SYNC_VERT_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_VSYTRUE;\n\t\tif (var->sync & FB_SYNC_COMP_HIGH_ACT)\n\t\t\tpar->beamcon0 |= BMC0_CSYTRUE;\n\t\thtotal = par->htotal>>clk_shift;\n\t\tvtotal = par->vtotal>>1;\n\t} else {\n\t\tDPRINTK(\"only broadcast modes possible for ocs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Checking the DMA timing\n\t */\n\n\tfconst = 16<<maxfmode<<clk_shift;\n\n\t/*\n\t * smallest window start value without turn off other dma cycles\n\t * than sprite1-7, unless you change min_fstrt\n\t */\n\n\n\tfsize = ((maxfmode+clk_shift <= 1) ? fconst : 64);\n\tfstrt = downx(fconst, par->diwstrt_h-4) - fsize;\n\tif (fstrt < min_fstrt) {\n\t\tDPRINTK(\"fetch start too low\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * smallest window start value where smooth scrolling is possible\n\t */\n\n\tfstrt = downx(fconst, par->diwstrt_h-fconst+(1<<clk_shift)-4) - fsize;\n\tif (fstrt < min_fstrt)\n\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\tmaxfetchstop = down16(par->htotal - 80);\n\n\tfstrt = downx(fconst, par->diwstrt_h-4) - 64 - fconst;\n\tfsize = upx(fconst, xres_n + modx(fconst, downx(1<<clk_shift, par->diwstrt_h-4)));\n\tif (fstrt + fsize > maxfetchstop)\n\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\tfsize = upx(fconst, xres_n);\n\tif (fstrt + fsize > maxfetchstop) {\n\t\tDPRINTK(\"fetch stop too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (maxfmode + clk_shift <= 1) {\n\t\tfsize = up64(xres_n + fconst - 1);\n\t\tif (min_fstrt + fsize - 64 > maxfetchstop)\n\t\t\tpar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\n\n\t\tfsize = up64(xres_n);\n\t\tif (min_fstrt + fsize - 64 > maxfetchstop) {\n\t\t\tDPRINTK(\"fetch size too high\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfsize -= 64;\n\t} else\n\t\tfsize -= fconst;\n\n\t/*\n\t * Check if there is enough time to update the bitplane pointers for ywrap\n\t */\n\n\tif (par->htotal-fsize-64 < par->bpp*64)\n\t\tpar->vmode &= ~FB_VMODE_YWRAP;\n\n\t/*\n\t * Bitplane calculations and check the Memory Requirements\n\t */\n\n\tif (amifb_ilbm) {\n\t\tpar->next_plane = div8(upx(16<<maxfmode, par->vxres));\n\t\tpar->next_line = par->bpp*par->next_plane;\n\t\tif (par->next_line * par->vyres > fb_info.fix.smem_len) {\n\t\t\tDPRINTK(\"too few video mem\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpar->next_line = div8(upx(16<<maxfmode, par->vxres));\n\t\tpar->next_plane = par->vyres*par->next_line;\n\t\tif (par->next_plane * par->bpp > fb_info.fix.smem_len) {\n\t\t\tDPRINTK(\"too few video mem\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Hardware Register Values\n\t */\n\n\tpar->bplcon0 = BPC0_COLOR | bplpixmode[clk_shift];\n\tif (!IS_OCS)\n\t\tpar->bplcon0 |= BPC0_ECSENA;\n\tif (par->bpp == 8)\n\t\tpar->bplcon0 |= BPC0_BPU3;\n\telse\n\t\tpar->bplcon0 |= par->bpp<<12;\n\tif (var->nonstd == FB_NONSTD_HAM)\n\t\tpar->bplcon0 |= BPC0_HAM;\n\tif (var->sync & FB_SYNC_EXT)\n\t\tpar->bplcon0 |= BPC0_ERSY;\n\n\tif (IS_AGA)\n\t\tpar->fmode = bplfetchmode[maxfmode];\n\n\tswitch (par->vmode & FB_VMODE_MASK) {\n\t\tcase FB_VMODE_INTERLACED:\n\t\t\tpar->bplcon0 |= BPC0_LACE;\n\t\t\tbreak;\n\t\tcase FB_VMODE_DOUBLE:\n\t\t\tif (IS_AGA)\n\t\t\t\tpar->fmode |= FMODE_SSCAN2 | FMODE_BSCAN2;\n\t\t\tbreak;\n\t}\n\n\tif (!((par->vmode ^ var->vmode) & FB_VMODE_YWRAP)) {\n\t\tpar->xoffset = var->xoffset;\n\t\tpar->yoffset = var->yoffset;\n\t\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\t\tif (par->xoffset || par->yoffset < 0 || par->yoffset >= par->vyres)\n\t\t\t\tpar->xoffset = par->yoffset = 0;\n\t\t} else {\n\t\t\tif (par->xoffset < 0 || par->xoffset > upx(16<<maxfmode, par->vxres-par->xres) ||\n\t\t\t    par->yoffset < 0 || par->yoffset > par->vyres-par->yres)\n\t\t\t\tpar->xoffset = par->yoffset = 0;\n\t\t}\n\t} else\n\t\tpar->xoffset = par->yoffset = 0;\n\n\tpar->crsr.crsr_x = par->crsr.crsr_y = 0;\n\tpar->crsr.spot_x = par->crsr.spot_y = 0;\n\tpar->crsr.height = par->crsr.width = 0;\n\n\treturn 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Fill the `var' structure based on the values in `par' and maybe\n\t * other values read out of the hardware.\n\t */\n", "func_signal": "static int ami_encode_var(struct fb_var_screeninfo *var,\n                          struct amifb_par *par)", "code": "{\n\tu_short clk_shift, line_shift;\n\n\tmemset(var, 0, sizeof(struct fb_var_screeninfo));\n\n\tclk_shift = par->clk_shift;\n\tline_shift = par->line_shift;\n\n\tvar->xres = par->xres;\n\tvar->yres = par->yres;\n\tvar->xres_virtual = par->vxres;\n\tvar->yres_virtual = par->vyres;\n\tvar->xoffset = par->xoffset;\n\tvar->yoffset = par->yoffset;\n\n\tvar->bits_per_pixel = par->bpp;\n\tvar->grayscale = 0;\n\n\tvar->red.offset = 0;\n\tvar->red.msb_right = 0;\n\tvar->red.length = par->bpp;\n\tif (par->bplcon0 & BPC0_HAM)\n\t    var->red.length -= 2;\n\tvar->blue = var->green = var->red;\n\tvar->transp.offset = 0;\n\tvar->transp.length = 0;\n\tvar->transp.msb_right = 0;\n\n\tif (par->bplcon0 & BPC0_HAM)\n\t\tvar->nonstd = FB_NONSTD_HAM;\n\telse\n\t\tvar->nonstd = 0;\n\tvar->activate = 0;\n\n\tvar->height = -1;\n\tvar->width = -1;\n\n\tvar->pixclock = pixclock[clk_shift];\n\n\tif (IS_AGA && par->fmode & FMODE_BSCAN2)\n\t\tvar->vmode = FB_VMODE_DOUBLE;\n\telse if (par->bplcon0 & BPC0_LACE)\n\t\tvar->vmode = FB_VMODE_INTERLACED;\n\telse\n\t\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\tif (!IS_OCS && par->beamcon0 & BMC0_VARBEAMEN) {\n\t\tvar->hsync_len = (par->hsstop-par->hsstrt)>>clk_shift;\n\t\tvar->right_margin = par->hsstrt>>clk_shift;\n\t\tvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\n\t\tvar->vsync_len = (par->vsstop-par->vsstrt)>>line_shift;\n\t\tvar->lower_margin = par->vsstrt>>line_shift;\n\t\tvar->upper_margin = (par->vtotal>>line_shift) - var->yres - var->lower_margin - var->vsync_len;\n\t\tvar->sync = 0;\n\t\tif (par->beamcon0 & BMC0_HSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_HOR_HIGH_ACT;\n\t\tif (par->beamcon0 & BMC0_VSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_VERT_HIGH_ACT;\n\t\tif (par->beamcon0 & BMC0_CSYTRUE)\n\t\t\tvar->sync |= FB_SYNC_COMP_HIGH_ACT;\n\t} else {\n\t\tvar->sync = FB_SYNC_BROADCAST;\n\t\tvar->hsync_len = (152>>clk_shift) + mod4(par->diwstop_h);\n\t\tvar->right_margin = ((par->htotal - down4(par->diwstop_h))>>clk_shift) + var->hsync_len;\n\t\tvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\n\t\tvar->vsync_len = 4>>line_shift;\n\t\tvar->lower_margin = ((par->vtotal - par->diwstop_v)>>line_shift) + var->vsync_len;\n\t\tvar->upper_margin = (((par->vtotal - 2)>>line_shift) + 1) - var->yres -\n\t\t                    var->lower_margin - var->vsync_len;\n\t}\n\n\tif (par->bplcon0 & BPC0_ERSY)\n\t\tvar->sync |= FB_SYNC_EXT;\n\tif (par->vmode & FB_VMODE_YWRAP)\n\t\tvar->vmode |= FB_VMODE_YWRAP;\n\n\treturn 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/**\n * init_cpu_profiler - enable/setup per cpu profiling hooks.\n * @cpunum: The processor instance.\n *\n * FIXME: doesn't do much yet...\n */\n", "func_signal": "static inline void __init\ninit_percpu_prof(int cpunum)", "code": "{\n\tcpu_data[cpunum].prof_counter = 1;\n\tcpu_data[cpunum].prof_multiplier = 1;\n}", "path": "arch\\parisc\\kernel\\processor.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Build the Copper List\n\t */\n", "func_signal": "static void ami_build_copper(void)", "code": "{\n\tstruct amifb_par *par = &currentpar;\n\tcopins *copl, *cops;\n\tu_long p;\n\n\tcurrentcop = 1 - currentcop;\n\n\tcopl = copdisplay.list[currentcop][1];\n\n\t(copl++)->l = CWAIT(0, 10);\n\t(copl++)->l = CMOVE(par->bplcon0, bplcon0);\n\t(copl++)->l = CMOVE(0, sprpt[0]);\n\t(copl++)->l = CMOVE2(0, sprpt[0]);\n\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tcops = copdisplay.list[currentcop][0];\n\n\t\t(cops++)->l = CWAIT(0, 10);\n\t\t(cops++)->l = CMOVE(par->bplcon0, bplcon0);\n\t\t(cops++)->l = CMOVE(0, sprpt[0]);\n\t\t(cops++)->l = CMOVE2(0, sprpt[0]);\n\n\t\t(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v+1), diwstrt);\n\t\t(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v+1), diwstop);\n\t\t(cops++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\n\t\t(cops++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\n\t\tif (!IS_OCS) {\n\t\t\t(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v+1,\n\t\t\t                    par->diwstop_h, par->diwstop_v+1), diwhigh);\n\t\t\t(cops++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\n\t\t\t                    par->diwstop_h, par->diwstop_v), diwhigh);\n#if 0\n\t\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\t\t(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt+1), vbstrt);\n\t\t\t\t(copl++)->l = CMOVE(vbstop2hw(par->vbstop+1), vbstop);\n\t\t\t\t(cops++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(cops++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\n\t\t\t\t(cops++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\n\t\t\t}\n#endif\n\t\t}\n\t\tp = ZTWO_PADDR(copdisplay.list[currentcop][0]);\n\t\t(copl++)->l = CMOVE(highw(p), cop2lc);\n\t\t(copl++)->l = CMOVE2(loww(p), cop2lc);\n\t\tp = ZTWO_PADDR(copdisplay.list[currentcop][1]);\n\t\t(cops++)->l = CMOVE(highw(p), cop2lc);\n\t\t(cops++)->l = CMOVE2(loww(p), cop2lc);\n\t\tcopdisplay.rebuild[0] = cops;\n\t} else {\n\t\t(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\n\t\t(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\n\t\tif (!IS_OCS) {\n\t\t\t(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\n\t\t\t                    par->diwstop_h, par->diwstop_v), diwhigh);\n#if 0\n\t\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\t\t(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\n\t\t\t\t(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\n\t\t\t\t(copl++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\tcopdisplay.rebuild[1] = copl;\n\n\tami_update_par();\n\tami_rebuild_copper();\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Rebuild the Copper List\n\t *\n\t * We only change the things that are not static\n\t */\n", "func_signal": "static void ami_rebuild_copper(void)", "code": "{\n\tstruct amifb_par *par = &currentpar;\n\tcopins *copl, *cops;\n\tu_short line, h_end1, h_end2;\n\tshort i;\n\tu_long p;\n\n\tif (IS_AGA && maxfmode + par->clk_shift == 0)\n\t\th_end1 = par->diwstrt_h-64;\n\telse\n\t\th_end1 = par->htotal-32;\n\th_end2 = par->ddfstop+64;\n\n\tami_set_sprite();\n\n\tcopl = copdisplay.rebuild[1];\n\tp = par->bplpt0;\n\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\tif ((par->vyres-par->yoffset) != 1 || !mod2(par->diwstrt_v)) {\n\t\t\tif (par->yoffset > par->vyres-par->yres) {\n\t\t\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t\t\t(copl++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t\t\t(copl++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t\t\t}\n\t\t\t\tline = par->diwstrt_v + ((par->vyres-par->yoffset)<<par->line_shift) - 1;\n\t\t\t\twhile (line >= 512) {\n\t\t\t\t\t(copl++)->l = CWAIT(h_end1, 510);\n\t\t\t\t\tline -= 512;\n\t\t\t\t}\n\t\t\t\tif (line >= 510 && IS_AGA && maxfmode + par->clk_shift == 0)\n\t\t\t\t\t(copl++)->l = CWAIT(h_end1, line);\n\t\t\t\telse\n\t\t\t\t\t(copl++)->l = CWAIT(h_end2, line);\n\t\t\t\tp = par->bplpt0wrap;\n\t\t\t}\n\t\t} else p = par->bplpt0wrap;\n\t}\n\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t(copl++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t(copl++)->l = CMOVE2(loww(p), bplpt[i]);\n\t}\n\tcopl->l = CEND;\n\n\tif (par->bplcon0 & BPC0_LACE) {\n\t\tcops = copdisplay.rebuild[0];\n\t\tp = par->bplpt0;\n\t\tif (mod2(par->diwstrt_v))\n\t\t\tp -= par->next_line;\n\t\telse\n\t\t\tp += par->next_line;\n\t\tif (par->vmode & FB_VMODE_YWRAP) {\n\t\t\tif ((par->vyres-par->yoffset) != 1 || mod2(par->diwstrt_v)) {\n\t\t\t\tif (par->yoffset > par->vyres-par->yres+1) {\n\t\t\t\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t\t\t\t(cops++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t\t\t\t(cops++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t\t\t\t}\n\t\t\t\t\tline = par->diwstrt_v + ((par->vyres-par->yoffset)<<par->line_shift) - 2;\n\t\t\t\t\twhile (line >= 512) {\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end1, 510);\n\t\t\t\t\t\tline -= 512;\n\t\t\t\t\t}\n\t\t\t\t\tif (line > 510 && IS_AGA && maxfmode + par->clk_shift == 0)\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end1, line);\n\t\t\t\t\telse\n\t\t\t\t\t\t(cops++)->l = CWAIT(h_end2, line);\n\t\t\t\t\tp = par->bplpt0wrap;\n\t\t\t\t\tif (mod2(par->diwstrt_v+par->vyres-par->yoffset))\n\t\t\t\t\t\tp -= par->next_line;\n\t\t\t\t\telse\n\t\t\t\t\t\tp += par->next_line;\n\t\t\t\t}\n\t\t\t} else p = par->bplpt0wrap - par->next_line;\n\t\t}\n\t\tfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\n\t\t\t(cops++)->l = CMOVE(highw(p), bplpt[i]);\n\t\t\t(cops++)->l = CMOVE2(loww(p), bplpt[i]);\n\t\t}\n\t\tcops->l = CEND;\n\t}\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * VBlank Display Interrupt\n\t */\n", "func_signal": "static irqreturn_t amifb_interrupt(int irq, void *dev_id)", "code": "{\n\tif (do_vmode_pan || do_vmode_full)\n\t\tami_update_display();\n\n\tif (do_vmode_full)\n\t\tami_init_display();\n\n\tif (do_vmode_pan) {\n\t\tflash_cursor();\n\t\tami_rebuild_copper();\n\t\tdo_cursor = do_vmode_pan = 0;\n\t} else if (do_cursor) {\n\t\tflash_cursor();\n\t\tami_set_sprite();\n\t\tdo_cursor = 0;\n\t} else {\n\t\tif (flash_cursor())\n\t\t\tami_set_sprite();\n\t}\n\n\tif (do_blank) {\n\t\tami_do_blank();\n\t\tdo_blank = 0;\n\t}\n\n\tif (do_vmode_full) {\n\t\tami_reinit_copper();\n\t\tdo_vmode_full = 0;\n\t}\n\treturn IRQ_HANDLED;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Amiga Frame Buffer Specific ioctls\n\t */\n", "func_signal": "static int amifb_ioctl(struct fb_info *info,\n\t\t       unsigned int cmd, unsigned long arg)", "code": "{\n\tunion {\n\t\tstruct fb_fix_cursorinfo fix;\n\t\tstruct fb_var_cursorinfo var;\n\t\tstruct fb_cursorstate state;\n\t} crsr;\n\tvoid __user *argp = (void __user *)arg;\n\tint i;\n\n\tswitch (cmd) {\n\t\tcase FBIOGET_FCURSORINFO:\n\t\t\ti = ami_get_fix_cursorinfo(&crsr.fix);\n\t\t\tif (i)\n\t\t\t\treturn i;\n\t\t\treturn copy_to_user(argp, &crsr.fix,\n\t\t\t\t\t    sizeof(crsr.fix)) ? -EFAULT : 0;\n\n\t\tcase FBIOGET_VCURSORINFO:\n\t\t\ti = ami_get_var_cursorinfo(&crsr.var,\n\t\t\t\t((struct fb_var_cursorinfo __user *)arg)->data);\n\t\t\tif (i)\n\t\t\t\treturn i;\n\t\t\treturn copy_to_user(argp, &crsr.var,\n\t\t\t\t\t    sizeof(crsr.var)) ? -EFAULT : 0;\n\n\t\tcase FBIOPUT_VCURSORINFO:\n\t\t\tif (copy_from_user(&crsr.var, argp, sizeof(crsr.var)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn ami_set_var_cursorinfo(&crsr.var,\n\t\t\t\t((struct fb_var_cursorinfo __user *)arg)->data);\n\n\t\tcase FBIOGET_CURSORSTATE:\n\t\t\ti = ami_get_cursorstate(&crsr.state);\n\t\t\tif (i)\n\t\t\t\treturn i;\n\t\t\treturn copy_to_user(argp, &crsr.state,\n\t\t\t\t\t    sizeof(crsr.state)) ? -EFAULT : 0;\n\n\t\tcase FBIOPUT_CURSORSTATE:\n\t\t\tif (copy_from_user(&crsr.state, argp,\n\t\t\t\t\t   sizeof(crsr.state)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn ami_set_cursorstate(&crsr.state);\n\t}\n\treturn -EINVAL;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Flash the cursor (called by VBlank interrupt)\n\t */\n", "func_signal": "static int flash_cursor(void)", "code": "{\n\tstatic int cursorcount = 1;\n\n\tif (cursormode == FB_CURSOR_FLASH) {\n\t\tif (!--cursorcount) {\n\t\t\tcursorstate = -cursorstate;\n\t\t\tcursorcount = cursorrate;\n\t\t\tif (!is_blanked)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/**\n * Process incoming association frame\n *\n * Although it could be possible to deal with some incoming association\n * messages without creating a new session we are keeping things simple. We\n * do not accept new association messages if there is a session in progress\n * and the messages do not belong to that session.\n *\n * If an association message arrives that causes the creation of a session\n * (WLP_ASSOC_E1) while we are in the process of creating a session then we\n * rely on the neighbor mutex to protect the data. That is, the new session\n * will not be started until the previous is completed.\n */\n", "func_signal": "static\nvoid wlp_receive_assoc_frame(struct wlp *wlp, struct sk_buff *skb,\n\t\t\t     struct uwb_dev_addr *src)", "code": "{\n\tstruct device *dev = &wlp->rc->uwb_dev.dev;\n\tstruct wlp_frame_assoc *assoc = (void *) skb->data;\n\tstruct wlp_session *session = wlp->session;\n\tu8 version;\n\td_fnstart(5, dev, \"wlp %p, skb %p\\n\", wlp, skb);\n\n\tif (wlp_get_version(wlp, &assoc->version, &version,\n\t\t\t    sizeof(assoc->version)) < 0)\n\t\tgoto error;\n\tif (version != WLP_VERSION) {\n\t\tdev_err(dev, \"Unsupported WLP version in association \"\n\t\t\t\"message.\\n\");\n\t\tgoto error;\n\t}\n\tif (session != NULL) {\n\t\t/* Function that created this session is still holding the\n\t\t * &wlp->mutex to protect this session. */\n\t\tif (assoc->type == session->exp_message ||\n\t\t    assoc->type == WLP_ASSOC_F0) {\n\t\t\tif (!memcmp(&session->neighbor_addr, src,\n\t\t\t\t   sizeof(*src))) {\n\t\t\t\tsession->data = skb;\n\t\t\t\t(session->cb)(wlp);\n\t\t\t} else {\n\t\t\t\tdev_err(dev, \"Received expected message from \"\n\t\t\t\t\t\"unexpected source.  Expected message \"\n\t\t\t\t\t\"%d or F0 from %02x:%02x, but received \"\n\t\t\t\t\t\"it from %02x:%02x. Dropping.\\n\",\n\t\t\t\t\tsession->exp_message,\n\t\t\t\t\tsession->neighbor_addr.data[1],\n\t\t\t\t\tsession->neighbor_addr.data[0],\n\t\t\t\t\tsrc->data[1], src->data[0]);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"Association already in progress. \"\n\t\t\t\t\"Dropping.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\twlp_direct_assoc_frame(wlp, skb, src);\n\t}\n\td_fnend(5, dev, \"wlp %p\\n\", wlp);\n\treturn;\nerror:\n\tkfree_skb(skb);\n\td_fnend(5, dev, \"wlp %p\\n\", wlp);\n}", "path": "drivers\\uwb\\wlp\\txrx.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * (Un)Blank the screen (called by VBlank interrupt)\n\t */\n", "func_signal": "static void ami_do_blank(void)", "code": "{\n\tstruct amifb_par *par = &currentpar;\n#if defined(CONFIG_FB_AMIGA_AGA)\n\tu_short bplcon3 = par->bplcon3;\n#endif\n\tu_char red, green, blue;\n\n\tif (do_blank > 0) {\n\t\tcustom.dmacon = DMAF_RASTER | DMAF_SPRITE;\n\t\tred = green = blue = 0;\n\t\tif (!IS_OCS && do_blank > 1) {\n\t\t\tswitch (do_blank) {\n\t\t\t\tcase FB_BLANK_VSYNC_SUSPEND:\n\t\t\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vtotal+4);\n\t\t\t\t\tcustom.vsstop = vsstop2hw(par->vtotal+4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FB_BLANK_HSYNC_SUSPEND:\n\t\t\t\t\tcustom.hsstrt = hsstrt2hw(par->htotal+16);\n\t\t\t\t\tcustom.hsstop = hsstop2hw(par->htotal+16);\n\t\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\t\t\tcustom.vsstop = vsstrt2hw(par->vsstop);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FB_BLANK_POWERDOWN:\n\t\t\t\t\tcustom.hsstrt = hsstrt2hw(par->htotal+16);\n\t\t\t\t\tcustom.hsstop = hsstop2hw(par->htotal+16);\n\t\t\t\t\tcustom.vsstrt = vsstrt2hw(par->vtotal+4);\n\t\t\t\t\tcustom.vsstop = vsstop2hw(par->vtotal+4);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(par->beamcon0 & BMC0_VARBEAMEN)) {\n\t\t\t\tcustom.htotal = htotal2hw(par->htotal);\n\t\t\t\tcustom.vtotal = vtotal2hw(par->vtotal);\n\t\t\t\tcustom.beamcon0 = BMC0_HARDDIS | BMC0_VARBEAMEN |\n\t\t\t\t                  BMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARCSYEN;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcustom.dmacon = DMAF_SETCLR | DMAF_RASTER | DMAF_SPRITE;\n\t\tred = red0;\n\t\tgreen = green0;\n\t\tblue = blue0;\n\t\tif (!IS_OCS) {\n\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\tcustom.vsstop = vsstop2hw(par->vsstop);\n\t\t\tcustom.beamcon0 = par->beamcon0;\n\t\t}\n\t}\n#if defined(CONFIG_FB_AMIGA_AGA)\n\tif (IS_AGA) {\n\t\tcustom.bplcon3 = bplcon3;\n\t\tcustom.color[0] = rgb2hw8_high(red, green, blue);\n\t\tcustom.bplcon3 = bplcon3 | BPC3_LOCT;\n\t\tcustom.color[0] = rgb2hw8_low(red, green, blue);\n\t\tcustom.bplcon3 = bplcon3;\n\t} else\n#endif\n#if defined(CONFIG_FB_AMIGA_ECS)\n\tif (par->bplcon0 & BPC0_SHRES) {\n\t\tu_short color, mask;\n\t\tint i;\n\n\t\tmask = 0x3333;\n\t\tcolor = rgb2hw2(red, green, blue);\n\t\tfor (i = 12; i >= 0; i -= 4)\n\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t\tmask <<=2; color >>= 2;\n\t\tfor (i = 3; i >= 0; i--)\n\t\t\tcustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\n\t} else\n#endif\n\t\tcustom.color[0] = rgb2hw4(red, green, blue);\n\tis_blanked = do_blank > 0 ? do_blank : 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Change the video mode (called by VBlank interrupt)\n\t */\n", "func_signal": "static void ami_init_display(void)", "code": "{\n\tstruct amifb_par *par = &currentpar;\n\tint i;\n\n\tcustom.bplcon0 = par->bplcon0 & ~BPC0_LACE;\n\tcustom.bplcon2 = (IS_OCS ? 0 : BPC2_KILLEHB) | BPC2_PF2P2 | BPC2_PF1P2;\n\tif (!IS_OCS) {\n\t\tcustom.bplcon3 = par->bplcon3;\n\t\tif (IS_AGA)\n\t\t\tcustom.bplcon4 = BPC4_ESPRM4 | BPC4_OSPRM4;\n\t\tif (par->beamcon0 & BMC0_VARBEAMEN) {\n\t\t\tcustom.htotal = htotal2hw(par->htotal);\n\t\t\tcustom.hbstrt = hbstrt2hw(par->hbstrt);\n\t\t\tcustom.hbstop = hbstop2hw(par->hbstop);\n\t\t\tcustom.hsstrt = hsstrt2hw(par->hsstrt);\n\t\t\tcustom.hsstop = hsstop2hw(par->hsstop);\n\t\t\tcustom.hcenter = hcenter2hw(par->hcenter);\n\t\t\tcustom.vtotal = vtotal2hw(par->vtotal);\n\t\t\tcustom.vbstrt = vbstrt2hw(par->vbstrt);\n\t\t\tcustom.vbstop = vbstop2hw(par->vbstop);\n\t\t\tcustom.vsstrt = vsstrt2hw(par->vsstrt);\n\t\t\tcustom.vsstop = vsstop2hw(par->vsstop);\n\t\t}\n\t}\n\tif (!IS_OCS || par->hsstop)\n\t\tcustom.beamcon0 = par->beamcon0;\n\tif (IS_AGA)\n\t\tcustom.fmode = par->fmode;\n\n\t/*\n\t * The minimum period for audio depends on htotal\n\t */\n\n\tamiga_audio_min_period = div16(par->htotal);\n\n\tis_lace = par->bplcon0 & BPC0_LACE ? 1 : 0;\n#if 1\n\tif (is_lace) {\n\t\ti = custom.vposr >> 15;\n\t} else {\n\t\tcustom.vposw = custom.vposr | 0x8000;\n\t\ti = 1;\n\t}\n#else\n\ti = 1;\n\tcustom.vposw = custom.vposr | 0x8000;\n#endif\n\tcustom.cop2lc = (u_short *)ZTWO_PADDR(copdisplay.list[currentcop][i]);\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Initialisation\n\t */\n", "func_signal": "static int __init amifb_init(void)", "code": "{\n\tint tag, i, err = 0;\n\tu_long chipptr;\n\tu_int defmode;\n\n#ifndef MODULE\n\tchar *option = NULL;\n\n\tif (fb_get_options(\"amifb\", &option)) {\n\t\tamifb_video_off();\n\t\treturn -ENODEV;\n\t}\n\tamifb_setup(option);\n#endif\n\tif (!MACH_IS_AMIGA || !AMIGAHW_PRESENT(AMI_VIDEO))\n\t\treturn -ENODEV;\n\n\t/*\n\t * We request all registers starting from bplpt[0]\n\t */\n\tif (!request_mem_region(CUSTOM_PHYSADDR+0xe0, 0x120,\n\t\t\t\t\"amifb [Denise/Lisa]\"))\n\t\treturn -EBUSY;\n\n\tcustom.dmacon = DMAF_ALL | DMAF_MASTER;\n\n\tswitch (amiga_chipset) {\n#ifdef CONFIG_FB_AMIGA_OCS\n\t\tcase CS_OCS:\n\t\t\tstrcat(fb_info.fix.id, \"OCS\");\ndefault_chipset:\n\t\t\tchipset = TAG_OCS;\n\t\t\tmaxdepth[TAG_SHRES] = 0;\t/* OCS means no SHRES */\n\t\t\tmaxdepth[TAG_HIRES] = 4;\n\t\t\tmaxdepth[TAG_LORES] = 6;\n\t\t\tmaxfmode = TAG_FMODE_1;\n\t\t\tdefmode = amiga_vblank == 50 ? DEFMODE_PAL\n\t\t\t\t\t\t     : DEFMODE_NTSC;\n\t\t\tfb_info.fix.smem_len = VIDEOMEMSIZE_OCS;\n\t\t\tbreak;\n#endif /* CONFIG_FB_AMIGA_OCS */\n\n#ifdef CONFIG_FB_AMIGA_ECS\n\t\tcase CS_ECS:\n\t\t\tstrcat(fb_info.fix.id, \"ECS\");\n\t\t\tchipset = TAG_ECS;\n\t\t\tmaxdepth[TAG_SHRES] = 2;\n\t\t\tmaxdepth[TAG_HIRES] = 4;\n\t\t\tmaxdepth[TAG_LORES] = 6;\n\t\t\tmaxfmode = TAG_FMODE_1;\n\t\t\tif (AMIGAHW_PRESENT(AMBER_FF))\n\t\t\t    defmode = amiga_vblank == 50 ? DEFMODE_AMBER_PAL\n\t\t\t\t\t\t\t : DEFMODE_AMBER_NTSC;\n\t\t\telse\n\t\t\t    defmode = amiga_vblank == 50 ? DEFMODE_PAL\n\t\t\t\t\t\t\t : DEFMODE_NTSC;\n\t\t\tif (amiga_chip_avail()-CHIPRAM_SAFETY_LIMIT >\n\t\t\t    VIDEOMEMSIZE_ECS_1M)\n\t\t\t\tfb_info.fix.smem_len = VIDEOMEMSIZE_ECS_2M;\n\t\t\telse\n\t\t\t\tfb_info.fix.smem_len = VIDEOMEMSIZE_ECS_1M;\n\t\t\tbreak;\n#endif /* CONFIG_FB_AMIGA_ECS */\n\n#ifdef CONFIG_FB_AMIGA_AGA\n\t\tcase CS_AGA:\n\t\t\tstrcat(fb_info.fix.id, \"AGA\");\n\t\t\tchipset = TAG_AGA;\n\t\t\tmaxdepth[TAG_SHRES] = 8;\n\t\t\tmaxdepth[TAG_HIRES] = 8;\n\t\t\tmaxdepth[TAG_LORES] = 8;\n\t\t\tmaxfmode = TAG_FMODE_4;\n\t\t\tdefmode = DEFMODE_AGA;\n\t\t\tif (amiga_chip_avail()-CHIPRAM_SAFETY_LIMIT >\n\t\t\t    VIDEOMEMSIZE_AGA_1M)\n\t\t\t\tfb_info.fix.smem_len = VIDEOMEMSIZE_AGA_2M;\n\t\t\telse\n\t\t\t\tfb_info.fix.smem_len = VIDEOMEMSIZE_AGA_1M;\n\t\t\tbreak;\n#endif /* CONFIG_FB_AMIGA_AGA */\n\n\t\tdefault:\n#ifdef CONFIG_FB_AMIGA_OCS\n\t\t\tprintk(\"Unknown graphics chipset, defaulting to OCS\\n\");\n\t\t\tstrcat(fb_info.fix.id, \"Unknown\");\n\t\t\tgoto default_chipset;\n#else /* CONFIG_FB_AMIGA_OCS */\n\t\t\terr = -ENODEV;\n\t\t\tgoto amifb_error;\n#endif /* CONFIG_FB_AMIGA_OCS */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Calculate the Pixel Clock Values for this Machine\n\t */\n\n\t{\n\tu_long tmp = DIVUL(200000000000ULL, amiga_eclock);\n\n\tpixclock[TAG_SHRES] = (tmp + 4) / 8;\t/* SHRES:  35 ns / 28 MHz */\n\tpixclock[TAG_HIRES] = (tmp + 2) / 4;\t/* HIRES:  70 ns / 14 MHz */\n\tpixclock[TAG_LORES] = (tmp + 1) / 2;\t/* LORES: 140 ns /  7 MHz */\n\t}\n\n\t/*\n\t * Replace the Tag Values with the Real Pixel Clock Values\n\t */\n\n\tfor (i = 0; i < NUM_TOTAL_MODES; i++) {\n\t\tstruct fb_videomode *mode = &ami_modedb[i];\n\t\ttag = mode->pixclock;\n\t\tif (tag == TAG_SHRES || tag == TAG_HIRES || tag == TAG_LORES) {\n\t\t\tmode->pixclock = pixclock[tag];\n\t\t}\n\t}\n\n\t/*\n\t *  These monitor specs are for a typical Amiga monitor (e.g. A1960)\n\t */\n\tif (fb_info.monspecs.hfmin == 0) {\n\t    fb_info.monspecs.hfmin = 15000;\n\t    fb_info.monspecs.hfmax = 38000;\n\t    fb_info.monspecs.vfmin = 49;\n\t    fb_info.monspecs.vfmax = 90;\n\t}\n\n\tfb_info.fbops = &amifb_ops;\n\tfb_info.par = &currentpar;\n\tfb_info.flags = FBINFO_DEFAULT;\n\n\tif (!fb_find_mode(&fb_info.var, &fb_info, mode_option, ami_modedb,\n\t\t\t  NUM_TOTAL_MODES, &ami_modedb[defmode], 4)) {\n\t\terr = -EINVAL;\n\t\tgoto amifb_error;\n\t}\n\n\tfb_videomode_to_modelist(ami_modedb, NUM_TOTAL_MODES,\n\t\t\t\t &fb_info.modelist);\n\n\tround_down_bpp = 0;\n\tchipptr = chipalloc(fb_info.fix.smem_len+\n\t                    SPRITEMEMSIZE+\n\t                    DUMMYSPRITEMEMSIZE+\n\t                    COPINITSIZE+\n\t                    4*COPLISTSIZE);\n\n\tassignchunk(videomemory, u_long, chipptr, fb_info.fix.smem_len);\n\tassignchunk(spritememory, u_long, chipptr, SPRITEMEMSIZE);\n\tassignchunk(dummysprite, u_short *, chipptr, DUMMYSPRITEMEMSIZE);\n\tassignchunk(copdisplay.init, copins *, chipptr, COPINITSIZE);\n\tassignchunk(copdisplay.list[0][0], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[0][1], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[1][0], copins *, chipptr, COPLISTSIZE);\n\tassignchunk(copdisplay.list[1][1], copins *, chipptr, COPLISTSIZE);\n\n\t/*\n\t * access the videomem with writethrough cache\n\t */\n\tfb_info.fix.smem_start = (u_long)ZTWO_PADDR(videomemory);\n\tvideomemory = (u_long)ioremap_writethrough(fb_info.fix.smem_start,\n\t\t\t\t\t\t   fb_info.fix.smem_len);\n\tif (!videomemory) {\n\t\tprintk(\"amifb: WARNING! unable to map videomem cached writethrough\\n\");\n\t\tfb_info.screen_base = (char *)ZTWO_VADDR(fb_info.fix.smem_start);\n\t} else\n\t\tfb_info.screen_base = (char *)videomemory;\n\n\tmemset(dummysprite, 0, DUMMYSPRITEMEMSIZE);\n\n\t/*\n\t * Enable Display DMA\n\t */\n\n\tcustom.dmacon = DMAF_SETCLR | DMAF_MASTER | DMAF_RASTER | DMAF_COPPER |\n\t                DMAF_BLITTER | DMAF_SPRITE;\n\n\t/*\n\t * Make sure the Copper has something to do\n\t */\n\n\tami_init_copper();\n\n\tif (request_irq(IRQ_AMIGA_COPPER, amifb_interrupt, 0,\n\t                \"fb vertb handler\", &currentpar)) {\n\t\terr = -EBUSY;\n\t\tgoto amifb_error;\n\t}\n\n\tfb_alloc_cmap(&fb_info.cmap, 1<<fb_info.var.bits_per_pixel, 0);\n\n\tif (register_framebuffer(&fb_info) < 0) {\n\t\terr = -EINVAL;\n\t\tgoto amifb_error;\n\t}\n\n\tprintk(\"fb%d: %s frame buffer device, using %dK of video memory\\n\",\n\t       fb_info.node, fb_info.fix.id, fb_info.fix.smem_len>>10);\n\n\treturn 0;\n\namifb_error:\n\tamifb_deinit();\n\treturn err;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/**\n * collect_boot_cpu_data - Fill the boot_cpu_data structure.\n *\n * This function collects and stores the generic processor information\n * in the boot_cpu_data structure.\n */\n", "func_signal": "void __init collect_boot_cpu_data(void)", "code": "{\n\tmemset(&boot_cpu_data, 0, sizeof(boot_cpu_data));\n\n\tboot_cpu_data.cpu_hz = 100 * PAGE0->mem_10msec; /* Hz of this PARISC */\n\n\t/* get CPU-Model Information... */\n#define p ((unsigned long *)&boot_cpu_data.pdc.model)\n\tif (pdc_model_info(&boot_cpu_data.pdc.model) == PDC_OK)\n\t\tprintk(KERN_INFO \n\t\t\t\"model %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]);\n#undef p\n\n\tif (pdc_model_versions(&boot_cpu_data.pdc.versions, 0) == PDC_OK)\n\t\tprintk(KERN_INFO \"vers  %08lx\\n\", \n\t\t\tboot_cpu_data.pdc.versions);\n\n\tif (pdc_model_cpuid(&boot_cpu_data.pdc.cpuid) == PDC_OK)\n\t\tprintk(KERN_INFO \"CPUID vers %ld rev %ld (0x%08lx)\\n\",\n\t\t\t(boot_cpu_data.pdc.cpuid >> 5) & 127,\n\t\t\tboot_cpu_data.pdc.cpuid & 31,\n\t\t\tboot_cpu_data.pdc.cpuid);\n\n\tif (pdc_model_capabilities(&boot_cpu_data.pdc.capabilities) == PDC_OK)\n\t\tprintk(KERN_INFO \"capabilities 0x%lx\\n\",\n\t\t\tboot_cpu_data.pdc.capabilities);\n\n\tif (pdc_model_sysmodel(boot_cpu_data.pdc.sys_model_name) == PDC_OK)\n\t\tprintk(KERN_INFO \"model %s\\n\",\n\t\t\tboot_cpu_data.pdc.sys_model_name);\n\n\tboot_cpu_data.hversion =  boot_cpu_data.pdc.model.hversion;\n\tboot_cpu_data.sversion =  boot_cpu_data.pdc.model.sversion;\n\n\tboot_cpu_data.cpu_type = parisc_get_cpu_type(boot_cpu_data.hversion);\n\tboot_cpu_data.cpu_name = cpu_name_version[boot_cpu_data.cpu_type][0];\n\tboot_cpu_data.family_name = cpu_name_version[boot_cpu_data.cpu_type][1];\n}", "path": "arch\\parisc\\kernel\\processor.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Initialise the Copper Initialisation List\n\t */\n", "func_signal": "static void __init ami_init_copper(void)", "code": "{\n\tcopins *cop = copdisplay.init;\n\tu_long p;\n\tint i;\n\n\tif (!IS_OCS) {\n\t\t(cop++)->l = CMOVE(BPC0_COLOR | BPC0_SHRES | BPC0_ECSENA, bplcon0);\n\t\t(cop++)->l = CMOVE(0x0181, diwstrt);\n\t\t(cop++)->l = CMOVE(0x0281, diwstop);\n\t\t(cop++)->l = CMOVE(0x0000, diwhigh);\n\t} else\n\t\t(cop++)->l = CMOVE(BPC0_COLOR, bplcon0);\n\tp = ZTWO_PADDR(dummysprite);\n\tfor (i = 0; i < 8; i++) {\n\t\t(cop++)->l = CMOVE(0, spr[i].pos);\n\t\t(cop++)->l = CMOVE(highw(p), sprpt[i]);\n\t\t(cop++)->l = CMOVE2(loww(p), sprpt[i]);\n\t}\n\n\t(cop++)->l = CMOVE(IF_SETCLR | IF_COPER, intreq);\n\tcopdisplay.wait = cop;\n\t(cop++)->l = CEND;\n\t(cop++)->l = CMOVE(0, copjmp2);\n\tcop->l = CEND;\n\n\tcustom.cop1lc = (u_short *)ZTWO_PADDR(copdisplay.init);\n\tcustom.copjmp1 = 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n * Display CPU info for all CPUs.\n */\n", "func_signal": "int\nshow_cpuinfo (struct seq_file *m, void *v)", "code": "{\n\tint\tn;\n\n\tfor(n=0; n<boot_cpu_data.cpu_count; n++) {\n#ifdef CONFIG_SMP\n\t\tif (0 == cpu_data[n].hpa)\n\t\t\tcontinue;\n#endif\n\t\tseq_printf(m, \"processor\\t: %d\\n\"\n\t\t\t\t\"cpu family\\t: PA-RISC %s\\n\",\n\t\t\t\t n, boot_cpu_data.family_name);\n\n\t\tseq_printf(m, \"cpu\\t\\t: %s\\n\",  boot_cpu_data.cpu_name );\n\n\t\t/* cpu MHz */\n\t\tseq_printf(m, \"cpu MHz\\t\\t: %d.%06d\\n\",\n\t\t\t\t boot_cpu_data.cpu_hz / 1000000,\n\t\t\t\t boot_cpu_data.cpu_hz % 1000000  );\n\n\t\tseq_printf(m, \"model\\t\\t: %s\\n\"\n\t\t\t\t\"model name\\t: %s\\n\",\n\t\t\t\t boot_cpu_data.pdc.sys_model_name,\n\t\t\t\t cpu_data[n].dev ? \n\t\t\t\t cpu_data[n].dev->name : \"Unknown\" );\n\n\t\tseq_printf(m, \"hversion\\t: 0x%08x\\n\"\n\t\t\t        \"sversion\\t: 0x%08x\\n\",\n\t\t\t\t boot_cpu_data.hversion,\n\t\t\t\t boot_cpu_data.sversion );\n\n\t\t/* print cachesize info */\n\t\tshow_cache_info(m);\n\n\t\tseq_printf(m, \"bogomips\\t: %lu.%02lu\\n\",\n\t\t\t     cpu_data[n].loops_per_jiffy / (500000 / HZ),\n\t\t\t     (cpu_data[n].loops_per_jiffy / (5000 / HZ)) % 100);\n\n\t\tseq_printf(m, \"software id\\t: %ld\\n\\n\",\n\t\t\t\tboot_cpu_data.pdc.model.sw_id);\n\t}\n\treturn 0;\n}", "path": "arch\\parisc\\kernel\\processor.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/**\n * processor_probe - Determine if processor driver should claim this device.\n * @dev: The device which has been found.\n *\n * Determine if processor driver should claim this chip (return 0) or not \n * (return 1).  If so, initialize the chip and tell other partners in crime \n * they have work to do.\n */\n", "func_signal": "static int __cpuinit processor_probe(struct parisc_device *dev)", "code": "{\n\tunsigned long txn_addr;\n\tunsigned long cpuid;\n\tstruct cpuinfo_parisc *p;\n\n#ifdef CONFIG_SMP\n\tif (num_online_cpus() >= NR_CPUS) {\n\t\tprintk(KERN_INFO \"num_online_cpus() >= NR_CPUS\\n\");\n\t\treturn 1;\n\t}\n#else\n\tif (boot_cpu_data.cpu_count > 0) {\n\t\tprintk(KERN_INFO \"CONFIG_SMP=n  ignoring additional CPUs\\n\");\n\t\treturn 1;\n\t}\n#endif\n\n\t/* logical CPU ID and update global counter\n\t * May get overwritten by PAT code.\n\t */\n\tcpuid = boot_cpu_data.cpu_count;\n\ttxn_addr = dev->hpa.start;\t/* for legacy PDC */\n\n#ifdef CONFIG_64BIT\n\tif (is_pdc_pat()) {\n\t\tulong status;\n\t\tunsigned long bytecnt;\n\t        pdc_pat_cell_mod_maddr_block_t pa_pdc_cell;\n#undef USE_PAT_CPUID\n#ifdef USE_PAT_CPUID\n\t\tstruct pdc_pat_cpu_num cpu_info;\n#endif\n\n\t\tstatus = pdc_pat_cell_module(&bytecnt, dev->pcell_loc,\n\t\t\tdev->mod_index, PA_VIEW, &pa_pdc_cell);\n\n\t\tBUG_ON(PDC_OK != status);\n\n\t\t/* verify it's the same as what do_pat_inventory() found */\n\t\tBUG_ON(dev->mod_info != pa_pdc_cell.mod_info);\n\t\tBUG_ON(dev->pmod_loc != pa_pdc_cell.mod_location);\n\n\t\ttxn_addr = pa_pdc_cell.mod[0];   /* id_eid for IO sapic */\n\n#ifdef USE_PAT_CPUID\n/* We need contiguous numbers for cpuid. Firmware's notion\n * of cpuid is for physical CPUs and we just don't care yet.\n * We'll care when we need to query PAT PDC about a CPU *after*\n * boot time (ie shutdown a CPU from an OS perspective).\n */\n\t\t/* get the cpu number */\n\t\tstatus = pdc_pat_cpu_get_number(&cpu_info, dev->hpa.start);\n\n\t\tBUG_ON(PDC_OK != status);\n\n\t\tif (cpu_info.cpu_num >= NR_CPUS) {\n\t\t\tprintk(KERN_WARNING \"IGNORING CPU at 0x%x,\"\n\t\t\t\t\" cpu_slot_id > NR_CPUS\"\n\t\t\t\t\" (%ld > %d)\\n\",\n\t\t\t\tdev->hpa.start, cpu_info.cpu_num, NR_CPUS);\n\t\t\t/* Ignore CPU since it will only crash */\n\t\t\tboot_cpu_data.cpu_count--;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tcpuid = cpu_info.cpu_num;\n\t\t}\n#endif\n\t}\n#endif\n\n\tp = &cpu_data[cpuid];\n\tboot_cpu_data.cpu_count++;\n\n\t/* initialize counters - CPU 0 gets it_value set in time_init() */\n\tif (cpuid)\n\t\tmemset(p, 0, sizeof(struct cpuinfo_parisc));\n\n\tp->loops_per_jiffy = loops_per_jiffy;\n\tp->dev = dev;\t\t/* Save IODC data in case we need it */\n\tp->hpa = dev->hpa.start;\t/* save CPU hpa */\n\tp->cpuid = cpuid;\t/* save CPU id */\n\tp->txn_addr = txn_addr;\t/* save CPU IRQ address */\n#ifdef CONFIG_SMP\n\t/*\n\t** FIXME: review if any other initialization is clobbered\n\t**\tfor boot_cpu by the above memset().\n\t*/\n\n\t/* stolen from init_percpu_prof() */\n\tcpu_data[cpuid].prof_counter = 1;\n\tcpu_data[cpuid].prof_multiplier = 1;\n#endif\n\n\t/*\n\t** CONFIG_SMP: init_smp_config() will attempt to get CPUs into\n\t** OS control. RENDEZVOUS is the default state - see mem_set above.\n\t**\tp->state = STATE_RENDEZVOUS;\n\t*/\n\n#if 0\n\t/* CPU 0 IRQ table is statically allocated/initialized */\n\tif (cpuid) {\n\t\tstruct irqaction actions[];\n\n\t\t/*\n\t\t** itimer and ipi IRQ handlers are statically initialized in\n\t\t** arch/parisc/kernel/irq.c. ie Don't need to register them.\n\t\t*/\n\t\tactions = kmalloc(sizeof(struct irqaction)*MAX_CPU_IRQ, GFP_ATOMIC);\n\t\tif (!actions) {\n\t\t\t/* not getting it's own table, share with monarch */\n\t\t\tactions = cpu_irq_actions[0];\n\t\t}\n\n\t\tcpu_irq_actions[cpuid] = actions;\n\t}\n#endif\n\n\t/* \n\t * Bring this CPU up now! (ignore bootstrap cpuid == 0)\n\t */\n#ifdef CONFIG_SMP\n\tif (cpuid) {\n\t\tcpu_set(cpuid, cpu_present_map);\n\t\tcpu_up(cpuid);\n\t}\n#endif\n\n\t/* If we've registered more than one cpu,\n\t * we'll use the jiffies clocksource since cr16\n\t * is not synchronized between CPUs.\n\t */\n\tupdate_cr16_clocksource();\n\n\treturn 0;\n}", "path": "arch\\parisc\\kernel\\processor.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n     *  Unaligned forward bit copy using 32-bit or 64-bit memory accesses\n     */\n", "func_signal": "static void bitcpy(unsigned long *dst, int dst_idx, const unsigned long *src,\n\t\t   int src_idx, u32 n)", "code": "{\n\tunsigned long first, last;\n\tint shift = dst_idx-src_idx, left, right;\n\tunsigned long d0, d1;\n\tint m;\n\n\tif (!n)\n\t\treturn;\n\n\tshift = dst_idx-src_idx;\n\tfirst = ~0UL >> dst_idx;\n\tlast = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));\n\n\tif (!shift) {\n\t\t// Same alignment for source and dest\n\n\t\tif (dst_idx+n <= BITS_PER_LONG) {\n\t\t\t// Single word\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\t*dst = comp(*src, *dst, first);\n\t\t} else {\n\t\t\t// Multiple destination words\n\t\t\t// Leading bits\n\t\t\tif (first) {\n\t\t\t\t*dst = comp(*src, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tsrc++;\n\t\t\t\tn -= BITS_PER_LONG-dst_idx;\n\t\t\t}\n\n\t\t\t// Main chunk\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 8) {\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\t*dst++ = *src++;\n\t\t\t\tn -= 8;\n\t\t\t}\n\t\t\twhile (n--)\n\t\t\t\t*dst++ = *src++;\n\n\t\t\t// Trailing bits\n\t\t\tif (last)\n\t\t\t\t*dst = comp(*src, *dst, last);\n\t\t}\n\t} else {\n\t\t// Different alignment for source and dest\n\n\t\tright = shift & (BITS_PER_LONG-1);\n\t\tleft = -shift & (BITS_PER_LONG-1);\n\n\t\tif (dst_idx+n <= BITS_PER_LONG) {\n\t\t\t// Single destination word\n\t\t\tif (last)\n\t\t\t\tfirst &= last;\n\t\t\tif (shift > 0) {\n\t\t\t\t// Single source word\n\t\t\t\t*dst = comp(*src >> right, *dst, first);\n\t\t\t} else if (src_idx+n <= BITS_PER_LONG) {\n\t\t\t\t// Single source word\n\t\t\t\t*dst = comp(*src << left, *dst, first);\n\t\t\t} else {\n\t\t\t\t// 2 source words\n\t\t\t\td0 = *src++;\n\t\t\t\td1 = *src;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t}\n\t\t} else {\n\t\t\t// Multiple destination words\n\t\t\td0 = *src++;\n\t\t\t// Leading bits\n\t\t\tif (shift > 0) {\n\t\t\t\t// Single source word\n\t\t\t\t*dst = comp(d0 >> right, *dst, first);\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG-dst_idx;\n\t\t\t} else {\n\t\t\t\t// 2 source words\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst = comp(d0 << left | d1 >> right, *dst,\n\t\t\t\t\t    first);\n\t\t\t\td0 = d1;\n\t\t\t\tdst++;\n\t\t\t\tn -= BITS_PER_LONG-dst_idx;\n\t\t\t}\n\n\t\t\t// Main chunk\n\t\t\tm = n % BITS_PER_LONG;\n\t\t\tn /= BITS_PER_LONG;\n\t\t\twhile (n >= 4) {\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t\tn -= 4;\n\t\t\t}\n\t\t\twhile (n--) {\n\t\t\t\td1 = *src++;\n\t\t\t\t*dst++ = d0 << left | d1 >> right;\n\t\t\t\td0 = d1;\n\t\t\t}\n\n\t\t\t// Trailing bits\n\t\t\tif (last) {\n\t\t\t\tif (m <= right) {\n\t\t\t\t\t// Single source word\n\t\t\t\t\t*dst = comp(d0 << left, *dst, last);\n\t\t\t\t} else {\n\t\t\t\t\t// 2 source words\n\t\t\t\t\td1 = *src;\n\t\t\t\t\t*dst = comp(d0 << left | d1 >> right,\n\t\t\t\t\t\t    *dst, last);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/**\n * Verify incoming frame is from connected neighbor, prep to pass to WLP client\n *\n * Verification proceeds according to WLP 0.99 [7.3.1]. The source address\n * is used to determine which neighbor is sending the frame and the WSS tag\n * is used to know to which WSS the frame belongs (we only support one WSS\n * so this test is straight forward).\n * With the WSS found we need to ensure that we are connected before\n * allowing the exchange of data frames.\n */\n", "func_signal": "static\nint wlp_verify_prep_rx_frame(struct wlp *wlp, struct sk_buff *skb,\n\t\t\t     struct uwb_dev_addr *src)", "code": "{\n\tstruct device *dev = &wlp->rc->uwb_dev.dev;\n\tint result = -EINVAL;\n\tstruct wlp_eda_node eda_entry;\n\tstruct wlp_frame_std_abbrv_hdr *hdr = (void *) skb->data;\n\n\td_fnstart(6, dev, \"wlp %p, skb %p \\n\", wlp, skb);\n\t/*verify*/\n\tresult = wlp_copy_eda_node(&wlp->eda, src, &eda_entry);\n\tif (result < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(dev, \"WLP: Incoming frame is from unknown \"\n\t\t\t\t\"neighbor %02x:%02x.\\n\", src->data[1],\n\t\t\t\tsrc->data[0]);\n\t\tgoto out;\n\t}\n\tif (hdr->tag != eda_entry.tag) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(dev, \"WLP: Tag of incoming frame from \"\n\t\t\t\t\"%02x:%02x does not match expected tag. \"\n\t\t\t\t\"Received 0x%02x, expected 0x%02x. \\n\",\n\t\t\t\tsrc->data[1], src->data[0], hdr->tag,\n\t\t\t\teda_entry.tag);\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (eda_entry.state != WLP_WSS_CONNECTED) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(dev, \"WLP: Incoming frame from \"\n\t\t\t\t\"%02x:%02x does is not from connected WSS.\\n\",\n\t\t\t\tsrc->data[1], src->data[0]);\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*prep*/\n\tskb_pull(skb, sizeof(*hdr));\nout:\n\td_fnend(6, dev, \"wlp %p, skb %p, result = %d \\n\", wlp, skb, result);\n\treturn result;\n}", "path": "drivers\\uwb\\wlp\\txrx.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/*\n\t * Pan or Wrap the Display\n\t *\n\t * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag\n\t */\n", "func_signal": "static int amifb_pan_display(struct fb_var_screeninfo *var,\n\t\t\t     struct fb_info *info)", "code": "{\n\tif (var->vmode & FB_VMODE_YWRAP) {\n\t\tif (var->yoffset < 0 ||\n\t\t    var->yoffset >= info->var.yres_virtual || var->xoffset)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/*\n\t\t * TODO: There will be problems when xpan!=1, so some columns\n\t\t * on the right side will never be seen\n\t\t */\n\t\tif (var->xoffset+info->var.xres > upx(16<<maxfmode, info->var.xres_virtual) ||\n\t\t    var->yoffset+info->var.yres > info->var.yres_virtual)\n\t\t\treturn -EINVAL;\n\t}\n\tami_pan_var(var);\n\tinfo->var.xoffset = var->xoffset;\n\tinfo->var.yoffset = var->yoffset;\n\tif (var->vmode & FB_VMODE_YWRAP)\n\t\tinfo->var.vmode |= FB_VMODE_YWRAP;\n\telse\n\t\tinfo->var.vmode &= ~FB_VMODE_YWRAP;\n\treturn 0;\n}", "path": "drivers\\video\\amifb.c", "repo_name": "vovan888/p750-kernel", "stars": 5, "license": "other", "language": "c", "size": 75351}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tif ( *yy_cp )\n\t\t\t{\n\t\t\tyy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(*yy_cp)];\n\t\t\t}\n\t\telse\n\t\t\tyy_current_state = yy_NUL_trans[yy_current_state];\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* Scans self, which is expected to be a single line from an Apache error or\n * access log, and returns a Hash of the components of the log message.  The\n * following parts of the log message are returned if they are present:\n * IPv4 address, datetime, HTTP Version used, the browser string given by the\n * client, any absolute or relative URLs, the error level, HTTP response code,\n * HTTP Method (verb), and any other uncategorized strings present. */\n", "func_signal": "VALUE t_scan_apache_logs(VALUE self)", "code": "{\n  KVPAIR kv_result;\n  int scan_complete = 0;\n  int building_words_to_string = 0;\n  VALUE token_hash = rb_hash_new();\n  \n  BEGIN(INITIAL);\n  \n  /* error out on absurdly large strings */\n  raise_error_for_string_too_long(self);\n  /* {:message => self()} */\n  include_message_in_token_hash(self, token_hash);\n  /* {:id => UUID} */\n  add_uuid_to_token_hash(token_hash);\n  apache_logs_yy_scan_string(RSTRING_PTR(self));\n  while (scan_complete == 0) {\n    kv_result = scan_apache_logs();\n    if (kv_result.key == \"EOF\"){\n      scan_complete = 1;\n    }\n    else if (kv_result.key == \"strings\"){\n      /* build a string until we get a non-word */\n      if (building_words_to_string == 0){\n        building_words_to_string = 1;\n        push_kv_pair_to_hash(kv_result, token_hash);\n      }\n      else{\n        concat_word_to_string(kv_result, token_hash);\n      }    \n    }    \n    else {\n      building_words_to_string = 0;\n      push_kv_pair_to_hash(kv_result, token_hash);\n    }\n  }\n  apache_logs_yy_delete_buffer(YY_CURRENT_BUFFER);\n  return rb_obj_dup(token_hash);\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to apache_logs_yylex() will\n * scan from a @e copy of @a bytes.\n * @param bytes the byte buffer to scan\n * @param len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE apache_logs_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n, i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) apache_logs_yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in apache_logs_yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = apache_logs_yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in apache_logs_yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Setup the input buffer state to scan the given bytes. The next call to rails_logs_yylex() will\n * scan from a @e copy of @a bytes.\n * @param bytes the byte buffer to scan\n * @param len the number of bytes in the buffer pointed to by @a bytes.\n * \n * @return the newly allocated buffer state object.\n */\n", "func_signal": "YY_BUFFER_STATE rails_logs_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )", "code": "{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n, i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) rails_logs_yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in rails_logs_yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = rails_logs_yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in rails_logs_yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */\n", "func_signal": "YY_BUFFER_STATE apache_logs_yy_create_buffer  (FILE * file, int  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) apache_logs_yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in apache_logs_yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) apache_logs_yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in apache_logs_yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tapache_logs_yy_init_buffer(b,file );\n\n\treturn b;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* apache_logs_yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int apache_logs_yylex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tapache_logs_yy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tapache_logs_yypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tapache_logs_yyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * apache_logs_yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )", "code": "{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tyy_current_state = yy_NUL_trans[yy_current_state];\n\tyy_is_jam = (yy_current_state == 0);\n\n\tif ( ! yy_is_jam )\n\t\t{\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\t}\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tif ( *yy_cp )\n\t\t\t{\n\t\t\tyy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(*yy_cp)];\n\t\t\t}\n\t\telse\n\t\t\tyy_current_state = yy_NUL_trans[yy_current_state];\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void rails_logs_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\trails_logs_yypop_buffer_state();\n\t *\t\trails_logs_yypush_buffer_state(new_buffer);\n     */\n\trails_logs_yyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\trails_logs_yy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (rails_logs_yywrap()) processing, but the only time this flag\n\t * is looked at is after rails_logs_yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tapache_logs_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tapache_logs_yyrestart(apache_logs_yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) apache_logs_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void rails_logs_yy_flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\trails_logs_yy_load_buffer_state( );\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void rails_logs_yyensure_buffer_stack (void)", "code": "{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)rails_logs_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in rails_logs_yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)rails_logs_yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in rails_logs_yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )", "code": "{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tyy_current_state = yy_NUL_trans[yy_current_state];\n\tyy_is_jam = (yy_current_state == 0);\n\n\tif ( ! yy_is_jam )\n\t\t{\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\t}\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (void)", "code": "{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\trails_logs_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\trails_logs_yyrestart(rails_logs_yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) rails_logs_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void apache_logs_yyrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        apache_logs_yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            apache_logs_yy_create_buffer(apache_logs_yyin,YY_BUF_SIZE );\n\t}\n\n\tapache_logs_yy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tapache_logs_yy_load_buffer_state( );\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE rails_logs_yy_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) rails_logs_yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in rails_logs_yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\trails_logs_yy_switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* rails_logs_yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int rails_logs_yylex_destroy  (void)", "code": "{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\trails_logs_yy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\trails_logs_yypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\trails_logs_yyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * rails_logs_yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void rails_logs_yypop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\trails_logs_yy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\trails_logs_yy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "ext\\scan_rails_logs\\scan_rails_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void apache_logs_yypush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tapache_logs_yyensure_buffer_stack();\n\n\t/* This block is copied from apache_logs_yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from apache_logs_yy_switch_to_buffer. */\n\tapache_logs_yy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void apache_logs_yyensure_buffer_stack (void)", "code": "{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)apache_logs_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in apache_logs_yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)apache_logs_yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in apache_logs_yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "ext\\scan_apache_logs\\scan_apache_logs.yy.c", "repo_name": "danielsdeleo/teeth", "stars": 6, "license": "bsd-3-clause", "language": "c", "size": 532}
{"docstring": "/* forward ref */\n", "func_signal": "void selection_received(GtkWidget *widget, GtkSelectionData *seldata,\n\t\t\tguint time, gpointer data)", "code": "{\n    struct gui_data *inst = (struct gui_data *)data;\n    XTextProperty tp;\n    char **list;\n    char *text;\n    int length, count, ret;\n    int free_list_required = 0;\n    int free_required = 0;\n    int charset;\n\n    if (seldata->target == utf8_string_atom && seldata->length <= 0) {\n\t/*\n\t * Failed to get a UTF-8 selection string. Try compound\n\t * text next.\n\t */\n\tgtk_selection_convert(inst->area, GDK_SELECTION_PRIMARY,\n\t\t\t      compound_text_atom,\n\t\t\t      inst->input_event_time);\n\treturn;\n    }\n\n    if (seldata->target == compound_text_atom && seldata->length <= 0) {\n\t/*\n\t * Failed to get UTF-8 or compound text. Try an ordinary\n\t * string.\n\t */\n\tgtk_selection_convert(inst->area, GDK_SELECTION_PRIMARY,\n\t\t\t      GDK_SELECTION_TYPE_STRING,\n\t\t\t      inst->input_event_time);\n\treturn;\n    }\n\n    /*\n     * If we have data, but it's not of a type we can deal with,\n     * we have to ignore the data.\n     */\n    if (seldata->length > 0 &&\n\tseldata->type != GDK_SELECTION_TYPE_STRING &&\n\tseldata->type != compound_text_atom &&\n\tseldata->type != utf8_string_atom)\n\treturn;\n\n    /*\n     * If we have no data, try looking in a cut buffer.\n     */\n    if (seldata->length <= 0) {\n\ttext = retrieve_cutbuffer(&length);\n\tif (length == 0)\n\t    return;\n\t/* Xterm is rumoured to expect Latin-1, though I havn't checked the\n\t * source, so use that as a de-facto standard. */\n\tcharset = CS_ISO8859_1;\n\tfree_required = 1;\n    } else {\n\t/*\n\t * Convert COMPOUND_TEXT into UTF-8.\n\t */\n\tif (seldata->type == compound_text_atom) {\n\t    tp.value = seldata->data;\n\t    tp.encoding = (Atom) seldata->type;\n\t    tp.format = seldata->format;\n\t    tp.nitems = seldata->length;\n\t    ret = Xutf8TextPropertyToTextList(GDK_DISPLAY(), &tp,\n\t\t\t\t\t      &list, &count);\n\t    if (ret != 0 || count != 1) {\n\t\t/*\n\t\t * Compound text failed; fall back to STRING.\n\t\t */\n\t\tgtk_selection_convert(inst->area, GDK_SELECTION_PRIMARY,\n\t\t\t\t      GDK_SELECTION_TYPE_STRING,\n\t\t\t\t      inst->input_event_time);\n\t\treturn;\n\t    }\n\t    text = list[0];\n\t    length = strlen(list[0]);\n\t    charset = CS_UTF8;\n\t    free_list_required = 1;\n\t} else {\n\t    text = (char *)seldata->data;\n\t    length = seldata->length;\n\t    charset = (seldata->type == utf8_string_atom ?\n\t\t       CS_UTF8 : inst->ucsdata.line_codepage);\n\t}\n    }\n\n    if (inst->pastein_data)\n\tsfree(inst->pastein_data);\n\n    inst->pastein_data = snewn(length, wchar_t);\n    inst->pastein_data_len = length;\n    inst->pastein_data_len =\n\tmb_to_wc(charset, 0, text, length,\n\t\t inst->pastein_data, inst->pastein_data_len);\n\n    term_do_paste(inst->term);\n\n    if (term_paste_pending(inst->term))\n\tinst->term_paste_idle_id = gtk_idle_add(idle_paste_func, inst);\n\n    if (free_list_required)\n\tXFreeStringList(list);\n    if (free_required)\n\tXFree(text);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * This function retrieves the character set encoding of a font. It\n * returns the character set without the X11 hack (in case the user\n * asks to use the font's own encoding).\n */\n", "func_signal": "static int set_font_info(struct gui_data *inst, int fontid)", "code": "{\n    GdkFont *font = inst->fonts[fontid];\n    XFontStruct *xfs = GDK_FONT_XFONT(font);\n    Display *disp = GDK_FONT_XDISPLAY(font);\n    Atom charset_registry, charset_encoding;\n    unsigned long registry_ret, encoding_ret;\n    int retval = CS_NONE;\n\n    charset_registry = XInternAtom(disp, \"CHARSET_REGISTRY\", False);\n    charset_encoding = XInternAtom(disp, \"CHARSET_ENCODING\", False);\n    inst->fontinfo[fontid].charset = CS_NONE;\n    inst->fontinfo[fontid].is_wide = 0;\n    if (XGetFontProperty(xfs, charset_registry, &registry_ret) &&\n\tXGetFontProperty(xfs, charset_encoding, &encoding_ret)) {\n\tchar *reg, *enc;\n\treg = XGetAtomName(disp, (Atom)registry_ret);\n\tenc = XGetAtomName(disp, (Atom)encoding_ret);\n\tif (reg && enc) {\n\t    char *encoding = dupcat(reg, \"-\", enc, NULL);\n\t    retval = inst->fontinfo[fontid].charset =\n\t\tcharset_from_xenc(encoding);\n\t    /* FIXME: when libcharset supports wide encodings fix this. */\n\t    if (!strcasecmp(encoding, \"iso10646-1\")) {\n\t\tinst->fontinfo[fontid].is_wide = 1;\n\t\tretval = CS_UTF8;\n\t    }\n\n\t    /*\n\t     * Hack for X line-drawing characters: if the primary\n\t     * font is encoded as ISO-8859-anything, and has valid\n\t     * glyphs in the first 32 char positions, it is assumed\n\t     * that those glyphs are the VT100 line-drawing\n\t     * character set.\n\t     * \n\t     * Actually, we'll hack even harder by only checking\n\t     * position 0x19 (vertical line, VT100 linedrawing\n\t     * `x'). Then we can check it easily by seeing if the\n\t     * ascent and descent differ.\n\t     */\n\t    if (inst->fontinfo[fontid].charset == CS_ISO8859_1) {\n\t\tint lb, rb, wid, asc, desc;\n\t\tgchar text[2];\n\n\t\ttext[1] = '\\0';\n\t\ttext[0] = '\\x12';\n\t\tgdk_string_extents(inst->fonts[fontid], text,\n\t\t\t\t   &lb, &rb, &wid, &asc, &desc);\n\t\tif (asc != desc)\n\t\t    inst->fontinfo[fontid].charset = CS_ISO8859_1_X11;\n\t    }\n\n\t    sfree(encoding);\n\t}\n    }\n\n    return retval;\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Move the window to the top or bottom of the z-order in response\n * to a server-side request.\n */\n", "func_signal": "void set_zorder(void *frontend, int top)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    if (top)\n\tgdk_window_raise(inst->window->window);\n    else\n\tgdk_window_lower(inst->window->window);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Draw a line of text in the window, at given character\n * coordinates, in given attributes.\n *\n * We are allowed to fiddle with the contents of `text'.\n */\n", "func_signal": "void do_text_internal(Context ctx, int x, int y, wchar_t *text, int len,\n\t\t      unsigned long attr, int lattr)", "code": "{\n    struct draw_ctx *dctx = (struct draw_ctx *)ctx;\n    struct gui_data *inst = dctx->inst;\n    GdkGC *gc = dctx->gc;\n    int ncombining, combining;\n    int nfg, nbg, t, fontid, shadow, rlen, widefactor;\n    int monochrome = gtk_widget_get_visual(inst->area)->depth == 1;\n\n    if (attr & TATTR_COMBINING) {\n\tncombining = len;\n\tlen = 1;\n    } else\n\tncombining = 1;\n\n    nfg = ((monochrome ? ATTR_DEFFG : (attr & ATTR_FGMASK)) >> ATTR_FGSHIFT);\n    nbg = ((monochrome ? ATTR_DEFBG : (attr & ATTR_BGMASK)) >> ATTR_BGSHIFT);\n    if (!!(attr & ATTR_REVERSE) ^ (monochrome && (attr & TATTR_ACTCURS))) {\n\tt = nfg;\n\tnfg = nbg;\n\tnbg = t;\n    }\n    if (inst->cfg.bold_colour && (attr & ATTR_BOLD)) {\n\tif (nfg < 16) nfg |= 8;\n\telse if (nfg >= 256) nfg |= 1;\n    }\n    if (inst->cfg.bold_colour && (attr & ATTR_BLINK)) {\n\tif (nbg < 16) nbg |= 8;\n\telse if (nbg >= 256) nbg |= 1;\n    }\n    if ((attr & TATTR_ACTCURS) && !monochrome) {\n\tnfg = 260;\n\tnbg = 261;\n    }\n\n    fontid = shadow = 0;\n\n    if (attr & ATTR_WIDE) {\n\twidefactor = 2;\n\tfontid |= 2;\n    } else {\n\twidefactor = 1;\n    }\n\n    if ((attr & ATTR_BOLD) && !inst->cfg.bold_colour) {\n\tif (inst->fonts[fontid | 1])\n\t    fontid |= 1;\n\telse\n\t    shadow = 1;\n    }\n\n    if ((lattr & LATTR_MODE) != LATTR_NORM) {\n\tx *= 2;\n\tif (x >= inst->term->cols)\n\t    return;\n\tif (x + len*2*widefactor > inst->term->cols)\n\t    len = (inst->term->cols-x)/2/widefactor;/* trim to LH half */\n\trlen = len * 2;\n    } else\n\trlen = len;\n\n    {\n\tGdkRectangle r;\n\n\tr.x = x*inst->font_width+inst->cfg.window_border;\n\tr.y = y*inst->font_height+inst->cfg.window_border;\n\tr.width = rlen*widefactor*inst->font_width;\n\tr.height = inst->font_height;\n\tgdk_gc_set_clip_rectangle(gc, &r);\n    }\n\n    gdk_gc_set_foreground(gc, &inst->cols[nbg]);\n    gdk_draw_rectangle(inst->pixmap, gc, 1,\n\t\t       x*inst->font_width+inst->cfg.window_border,\n\t\t       y*inst->font_height+inst->cfg.window_border,\n\t\t       rlen*widefactor*inst->font_width, inst->font_height);\n\n    gdk_gc_set_foreground(gc, &inst->cols[nfg]);\n    {\n\tGdkWChar *gwcs;\n\tgchar *gcs;\n\twchar_t *wcs;\n\tint i;\n\n\twcs = snewn(len*ncombining+1, wchar_t);\n\tfor (i = 0; i < len*ncombining; i++) {\n\t    wcs[i] = text[i];\n\t}\n\n\tif (inst->fonts[fontid] == NULL && (fontid & 2)) {\n\t    /*\n\t     * We've been given ATTR_WIDE, but have no wide font.\n\t     * Fall back to the non-wide font.\n\t     */\n\t    fontid &= ~2;\n\t}\n\n\tif (inst->fonts[fontid] == NULL) {\n\t    /*\n\t     * The font for this contingency does not exist. So we\n\t     * display nothing at all; such is life.\n\t     */\n\t} else if (inst->fontinfo[fontid].is_wide) {\n\t    /*\n\t     * At least one version of gdk_draw_text_wc() has a\n\t     * weird bug whereby it reads `len' elements of the\n\t     * input string, but only draws `len/2'. Hence I'm\n\t     * going to make its input array twice as long as it\n\t     * theoretically needs to be, and pass in twice the\n\t     * actual number of characters. If a fixed gdk actually\n\t     * takes the doubled length seriously, then (a) the\n\t     * array will stand scrutiny up to the full length, (b)\n\t     * the spare elements of the array are full of zeroes\n\t     * which will probably be an empty glyph in the font,\n\t     * and (c) the clip rectangle should prevent it causing\n\t     * trouble anyway.\n\t     */\n\t    gwcs = snewn(len*2+1, GdkWChar);\n\t    memset(gwcs, 0, sizeof(GdkWChar) * (len*2+1));\n\t    /*\n\t     * FIXME: when we have a wide-char equivalent of\n\t     * from_unicode, use it instead of this.\n\t     */\n\t    for (combining = 0; combining < ncombining; combining++) {\n\t\tfor (i = 0; i <= len; i++)\n\t\t    gwcs[i] = wcs[i + combining];\n\t\tgdk_draw_text_wc(inst->pixmap, inst->fonts[fontid], gc,\n\t\t\t\t x*inst->font_width+inst->cfg.window_border,\n\t\t\t\t y*inst->font_height+inst->cfg.window_border+inst->fonts[0]->ascent,\n\t\t\t\t gwcs, len*2);\n\t\tif (shadow)\n\t\t    gdk_draw_text_wc(inst->pixmap, inst->fonts[fontid], gc,\n\t\t\t\t     x*inst->font_width+inst->cfg.window_border+inst->cfg.shadowboldoffset,\n\t\t\t\t     y*inst->font_height+inst->cfg.window_border+inst->fonts[0]->ascent,\n\t\t\t\t     gwcs, len*2);\n\t    }\n\t    sfree(gwcs);\n\t} else {\n\t    gcs = snewn(len+1, gchar);\n\t    for (combining = 0; combining < ncombining; combining++) {\n\t\twc_to_mb(inst->fontinfo[fontid].charset, 0,\n\t\t\t wcs + combining, len, gcs, len, \".\", NULL, NULL);\n\t\tgdk_draw_text(inst->pixmap, inst->fonts[fontid], gc,\n\t\t\t      x*inst->font_width+inst->cfg.window_border,\n\t\t\t      y*inst->font_height+inst->cfg.window_border+inst->fonts[0]->ascent,\n\t\t\t      gcs, len);\n\t\tif (shadow)\n\t\t    gdk_draw_text(inst->pixmap, inst->fonts[fontid], gc,\n\t\t\t\t  x*inst->font_width+inst->cfg.window_border+inst->cfg.shadowboldoffset,\n\t\t\t\t  y*inst->font_height+inst->cfg.window_border+inst->fonts[0]->ascent,\n\t\t\t\t  gcs, len);\n\t    }\n\t    sfree(gcs);\n\t}\n\tsfree(wcs);\n    }\n\n    if (attr & ATTR_UNDER) {\n\tint uheight = inst->fonts[0]->ascent + 1;\n\tif (uheight >= inst->font_height)\n\t    uheight = inst->font_height - 1;\n\tgdk_draw_line(inst->pixmap, gc, x*inst->font_width+inst->cfg.window_border,\n\t\t      y*inst->font_height + uheight + inst->cfg.window_border,\n\t\t      (x+len)*widefactor*inst->font_width-1+inst->cfg.window_border,\n\t\t      y*inst->font_height + uheight + inst->cfg.window_border);\n    }\n\n    if ((lattr & LATTR_MODE) != LATTR_NORM) {\n\t/*\n\t * I can't find any plausible StretchBlt equivalent in the\n\t * X server, so I'm going to do this the slow and painful\n\t * way. This will involve repeated calls to\n\t * gdk_draw_pixmap() to stretch the text horizontally. It's\n\t * O(N^2) in time and O(N) in network bandwidth, but you\n\t * try thinking of a better way. :-(\n\t */\n\tint i;\n\tfor (i = 0; i < len * widefactor * inst->font_width; i++) {\n\t    gdk_draw_pixmap(inst->pixmap, gc, inst->pixmap,\n\t\t\t    x*inst->font_width+inst->cfg.window_border + 2*i,\n\t\t\t    y*inst->font_height+inst->cfg.window_border,\n\t\t\t    x*inst->font_width+inst->cfg.window_border + 2*i+1,\n\t\t\t    y*inst->font_height+inst->cfg.window_border,\n\t\t\t    len * widefactor * inst->font_width - i, inst->font_height);\n\t}\n\tlen *= 2;\n\tif ((lattr & LATTR_MODE) != LATTR_WIDE) {\n\t    int dt, db;\n\t    /* Now stretch vertically, in the same way. */\n\t    if ((lattr & LATTR_MODE) == LATTR_BOT)\n\t\tdt = 0, db = 1;\n\t    else\n\t\tdt = 1, db = 0;\n\t    for (i = 0; i < inst->font_height; i+=2) {\n\t\tgdk_draw_pixmap(inst->pixmap, gc, inst->pixmap,\n\t\t\t\tx*inst->font_width+inst->cfg.window_border,\n\t\t\t\ty*inst->font_height+inst->cfg.window_border+dt*i+db,\n\t\t\t\tx*inst->font_width+inst->cfg.window_border,\n\t\t\t\ty*inst->font_height+inst->cfg.window_border+dt*(i+1),\n\t\t\t\tlen * widefactor * inst->font_width, inst->font_height-i-1);\n\t    }\n\t}\n    }\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Report the window's pixel size, for terminal reports.\n */\n", "func_signal": "void get_window_pixels(void *frontend, int *x, int *y)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    /*\n     * I assume that when the GTK version of this call is available\n     * we should use it. Not sure how it differs from the GDK one,\n     * though.\n     */\n#if GTK_CHECK_VERSION(2,0,0)\n    gtk_window_get_size(GTK_WINDOW(inst->window), x, y);\n#else\n    gdk_window_get_size(inst->window->window, x, y);\n#endif\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Refresh the window in response to a server-side request.\n */\n", "func_signal": "void refresh_window(void *frontend)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    term_invalidate(inst->term);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Report the window's position, for terminal reports.\n */\n", "func_signal": "void get_window_pos(void *frontend, int *x, int *y)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    /*\n     * I assume that when the GTK version of this call is available\n     * we should use it. Not sure how it differs from the GDK one,\n     * though.\n     */\n#if GTK_CHECK_VERSION(2,0,0)\n    gtk_window_get_position(GTK_WINDOW(inst->window), x, y);\n#else\n    gdk_window_get_position(inst->window->window, x, y);\n#endif\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * This is still called when mode==BELL_VISUAL, even though the\n * visual bell is handled entirely within terminal.c, because we\n * may want to perform additional actions on any kind of bell (for\n * example, taskbar flashing in Windows).\n */\n", "func_signal": "void do_beep(void *frontend, int mode)", "code": "{\n    if (mode == BELL_DEFAULT)\n\tgdk_beep();\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Move the window in response to a server-side request.\n */\n", "func_signal": "void move_window(void *frontend, int x, int y)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    /*\n     * I assume that when the GTK version of this call is available\n     * we should use it. Not sure how it differs from the GDK one,\n     * though.\n     */\n#if GTK_CHECK_VERSION(2,0,0)\n    gtk_window_move(GTK_WINDOW(inst->window), x, y);\n#else\n    gdk_window_move(inst->window->window, x, y);\n#endif\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Maximise or restore the window in response to a server-side\n * request.\n */\n", "func_signal": "void set_zoomed(void *frontend, int zoomed)", "code": "{\n    /*\n     * GTK 1.2 doesn't know how to do this.\n     */\n#if GTK_CHECK_VERSION(2,0,0)\n    struct gui_data *inst = (struct gui_data *)frontend;\n    if (iconic)\n\tgtk_window_maximize(GTK_WINDOW(inst->window));\n    else\n\tgtk_window_unmaximize(GTK_WINDOW(inst->window));\n#endif\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Minimise or restore the window in response to a server-side\n * request.\n */\n", "func_signal": "void set_iconic(void *frontend, int iconic)", "code": "{\n    /*\n     * GTK 1.2 doesn't know how to do this.\n     */\n#if GTK_CHECK_VERSION(2,0,0)\n    struct gui_data *inst = (struct gui_data *)frontend;\n    if (iconic)\n\tgtk_window_iconify(GTK_WINDOW(inst->window));\n    else\n\tgtk_window_deiconify(GTK_WINDOW(inst->window));\n#endif\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Default settings that are specific to pterm.\n */\n", "func_signal": "FontSpec platform_default_fontspec(const char *name)", "code": "{\n    FontSpec ret;\n    if (!strcmp(name, \"Font\"))\n\tstrcpy(ret.name, \"fixed\");\n    else\n\t*ret.name = '\\0';\n    return ret;\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * set or clear the \"raw mouse message\" mode\n */\n", "func_signal": "void set_raw_mouse_mode(void *frontend, int activate)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    activate = activate && !inst->cfg.no_mouse_rep;\n    send_raw_mouse = activate;\n    update_mouseptr(inst);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/* Ensure that all the cut buffers exist - according to the ICCCM, we must\n * do this before we start using cut buffers.\n */\n", "func_signal": "void init_cutbuffers()", "code": "{\n    unsigned char empty[] = \"\";\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER0, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER1, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER2, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER3, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER4, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER5, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER6, XA_STRING, 8, PropModeAppend, empty, 0);\n    XChangeProperty(GDK_DISPLAY(), GDK_ROOT_WINDOW(),\n\t\t    XA_CUT_BUFFER7, XA_STRING, 8, PropModeAppend, empty, 0);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Translate a raw mouse button designation (LEFT, MIDDLE, RIGHT)\n * into a cooked one (SELECT, EXTEND, PASTE).\n * \n * In Unix, this is not configurable; the X button arrangement is\n * rock-solid across all applications, everyone has a three-button\n * mouse or a means of faking it, and there is no need to switch\n * buttons around at all.\n */\n", "func_signal": "static Mouse_Button translate_button(Mouse_Button button)", "code": "{\n    /* struct gui_data *inst = (struct gui_data *)frontend; */\n\n    if (button == MBT_LEFT)\n\treturn MBT_SELECT;\n    if (button == MBT_MIDDLE)\n\treturn MBT_PASTE;\n    if (button == MBT_RIGHT)\n\treturn MBT_EXTEND;\n    return 0;\t\t\t       /* shouldn't happen */\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Report whether the window is iconic, for terminal reports.\n */\n", "func_signal": "int is_iconic(void *frontend)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    return !gdk_window_is_viewable(inst->window->window);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Return the top-level GtkWindow associated with a particular\n * front end instance.\n */\n", "func_signal": "void *get_window(void *frontend)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    return inst->window;\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/* Store the data in a cut-buffer. */\n", "func_signal": "void store_cutbuffer(char * ptr, int len)", "code": "{\n    /* ICCCM says we must rotate the buffers before storing to buffer 0. */\n    XRotateBuffers(GDK_DISPLAY(), 1);\n    XStoreBytes(GDK_DISPLAY(), ptr, len);\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/*\n * Return the window or icon title.\n */\n", "func_signal": "char *get_window_title(void *frontend, int icon)", "code": "{\n    struct gui_data *inst = (struct gui_data *)frontend;\n    return icon ? inst->icontitle : inst->wintitle;\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "/* Retrieve data from a cut-buffer.\n * Returned data needs to be freed with XFree().\n */\n", "func_signal": "char * retrieve_cutbuffer(int * nbytes)", "code": "{\n    char * ptr;\n    ptr = XFetchBytes(GDK_DISPLAY(), nbytes);\n    if (*nbytes <= 0 && ptr != 0) {\n\tXFree(ptr);\n\tptr = 0;\n    }\n    return ptr;\n}", "path": "engine\\putty\\unix\\gtkwin.c", "repo_name": "liskin/s2putty", "stars": 5, "license": "other", "language": "c", "size": 4537}
{"docstring": "// Interrupt routine - - - - - - - - - -\n", "func_signal": "void interrupt()", "code": "{\n\t\n\t\tserial_handle_tx_isr();\n\t\tserial_handle_rx_isr();\n}", "path": "demos\\serial\\serial_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Configure the packe routines - set up my receiving packet address\n", "func_signal": "void configure_pkt()", "code": "{\n\tuns16 my_addr;\n\tuns16 last_pkt;\n\t\n\tmy_addr = eeprom_read(EE_MY_ADDR_H);\n\tmy_addr <<= 8;\n\tmy_addr |= eeprom_read(EE_MY_ADDR_L);\n\tlast_pkt = eeprom_read(EE_MY_LAST_PKT_ID_H);\n\tlast_pkt <<= 8;\n\tlast_pkt |= eeprom_read(EE_MY_LAST_PKT_ID_L);\n\tserial_print_str(\"My addr: \");\n\tserial_print_int_hex_16bit(my_addr);\n\tserial_print_nl();\n\tserial_print_str(\"Last pkt: \");\n\tserial_print_int_hex_16bit(last_pkt);\n\tserial_print_nl();\n\tpkt_init(my_addr, last_pkt);\n}", "path": "demos\\temp_lcd_packet\\temp_lcd_packet.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// -- getc    \n", "func_signal": "void serial_print_str(char *str)", "code": "{\n\nuns8 count;\n\n\tfor(count = 0 ; str[count] != 0; count++)\n    {\n        serial_putc(str[count]);\n    }\n}", "path": "pic_pack_lib\\pic_serial.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Process_rx\n//\n// Keep adding characters to our input buffer\n// when we enter a command, then act on it\n", "func_signal": "void process_rx()", "code": "{\n\t\n\tuns8 len,\t// length of string\n\t\t rec;\t// received character\n\tuns8 first_char;\n\t\n\trec = serial_getc();\t// get the character from the fifo\n\t\n\tserial_putc(rec);\t// print it out so we can see what we typed\n\n\tif (rec == '\\r') {\t// did we press return?\n\t\tfirst_char = serial_buffer[0];\n\t\tswitch (first_char) {\n\t\t\tcase 'a':\n\t\t\t\tdo_task = 1;\n\t\t\t\tbreak;\n\t\t    case 'x':\n\t\t\t\tdo_task = 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tdo_task = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tdo_task = 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// More complicated example\n\t\t\t\t// Let's set a variable based on input\n\t\t\t\t// You can type:\n\t\t\t\t// s05\n\t\t\t\t// And press enter, it will set \"send_to\" to this (in hex)\n\t\t\t\tif ((first_char == 's') && (strlen(serial_buffer)==3)) {\n\t\t\t\t\tsend_to = atoui_hex(&serial_buffer[1]);\n\t\t\t\t\tserial_print_str(\" Set send_to to \");\n\t\t\t\t\tserial_print_int(send_to);\t// Of course, this could be anything\n\t\t\t\t\tserial_putc('\\n');\n\t\t\t\t};\n\t\t}\t\t\n\t\tserial_buffer[0] = '\\0';\t// clear the buffer\n        serial_putc('\\n');\t// print new line\n        serial_putc('>');\t// print the prompt\n\t} else {\n\t\tlen = strlen(serial_buffer);\t// add the character to our line input\n\t\tserial_buffer[len] = rec;\n\t\tserial_buffer[len+1] = '\\0';\n\t}\n\n}", "path": "demos\\serial\\serial_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// -- getc    \n", "func_signal": "void usb_cdc_handle_tx()", "code": "{\nuns8 cdc_tx_next;\nuns8 count;\nuns16 buffer_size;\nuns8 *buffer;\nbuffer_descriptor *bd;\n\n\tbd = ep_in_bd_location[USB_CDC_DATA_ENDPOINT];\n\tif (test_bit(bd->stat, UOWN)) {\t// if there's already something in play\n\t\treturn;\t// give up\n\t}\n\t\n\tbuffer_size = ep_in_buffer_size[USB_CDC_DATA_ENDPOINT];\n\tbuffer = ep_in_buffer_location[USB_CDC_DATA_ENDPOINT];\n\n\tif (cdc_tx_end == cdc_tx_start) { // anything in the fifo?\n\t   return; // nope\n\t}\n\t#ifdef CDC_DEBUG\n\t\tserial_putc('<');\n\t#endif\n\tstart_crit_sec();\n\t\n\tcount = 0;\n\twhile ((cdc_tx_end != cdc_tx_start) && (count < buffer_size)) {\n\t\t\n\t\tcdc_tx_next = cdc_tx_start + 1;\t// get next position\n\t\tif (cdc_tx_next == USB_CDC_TX_BUFFER_SIZE) {\t// if we're at the end of the buffer\n\t\t\tcdc_tx_next = 0;\t// wrap to the beginning\n\t\t}\n\t\tbuffer[count] = cdc_tx_buffer[cdc_tx_start];\t// transmit the character\n\t\t#ifdef CDC_DEBUG\n\t\t\tserial_putc(buffer[count]);\n\t\t#endif\t\n\t\tcount++;\n\t\tcdc_tx_start = cdc_tx_next;\t// move start position of fifo\n\t} \n\tif (count > 0) {\n\t\tbd->count = count;\n\t\tbd->addr = (uns16)buffer;\n\n\t\ttoggle_bit(bd->stat, DTS);\n\t\tclear_bit(bd->stat, KEN);\t// clear the keep bit\n\t\tclear_bit(bd->stat, INCDIS);\t// clear the increment disable\n\t\tset_bit  (bd->stat, DTSEN);\n\t\tclear_bit(bd->stat, BSTALL);\t// clear stall bit\n\t\tclear_bit(bd->stat, BC9);\n\t\tclear_bit(bd->stat, BC8);\n\n\t\tset_bit  (bd->stat, UOWN);\t// SIE owns the buffer\n\t}\n\tend_crit_sec();\n\t#ifdef CDC_DEBUG\n\t\tserial_putc('>');\n\t\tserial_print_str(\"send=\");\n\t\tserial_print_int(count);\n\t\tserial_putc(' ');\n\t#endif\t\n\n}", "path": "pic_pack_lib\\usb_cdc_class.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// This routine needs to be included if you're doing packet stuff\n// It gets called when the packet subsystem has a real, genuine,\n// payload for you to do something interesting with\n", "func_signal": "void pkt_payload_rx_callback(uns16 source_addr, uns16 pkt_id, uns8 *payload)", "code": "{\n\nuns8 count;\n\n// For the moment, we'll just print it out\n\n\tserial_print_str(\"<<s: \");\n\tserial_print_int_hex(source_addr);\n\tserial_print_str(\"p: \");\n\tfor (count = 0; count < PKT_PAYLOAD_SIZE; count++) {\n\t\tserial_print_int_hex(payload[count]);\n\t\tserial_putc(' ');\n\t}\t\n\tserial_print_str(\">> \");\n\n\tif ((payload[0] == PL_THIS_MY_SENSOR) &&\n\t    (payload[1] == 1 << CAPS_SENSOR_TEMP)) {\n\t    \tint_part = payload[2];\n\t    \tfract_part = payload[3];\n\t    \ttemp_pkt_id = pkt_id;\n\t    \tdo_task = TASK_PRINT_TEMP;\n\t}    \t\n\t    \t\n\n\n}", "path": "demos\\temp_lcd_packet\\temp_lcd_packet.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Handle any command line tasks we need to do\n// Very handy to print out variables, do commands,\n// print out some debug, etc...\n", "func_signal": "void handle_tasks()", "code": "{\n\tswitch (do_task) {\n\t\tcase 1:\n\t\t\tserial_print_str(\"Task 1: send_to=\");\n\t\t\tserial_print_int(send_to);\n\t\t\tserial_print_str(\"\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tserial_print_str(\"You did task 2\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tserial_print_str(\"You did task 3\\n\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tserial_print_str(\"You did task 4. Wow.\\n\");\n\t\t\tbreak;\n\t} // switch\t\t\n\n\tdo_task = 0;\n}", "path": "demos\\serial\\serial_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "/* \\ \\  */\n", "func_signal": "void serial_rx_isr()", "code": "{\n   uns8 rx_next;\n\t\n\n\tif (test_bit(rcsta, OERR)) {\t// overrun error?\n\t\tclear_bit(rcsta, CREN);\t// clear error\n\t\t_asm\t{\t\n\t\t\tMOVF\t_rcreg,W\t// clear any received characters\n\t\t\tMOVF\t_rcreg,W\n\t\t\tMOVF\t_rcreg,W\n\t\t}\n\t\t#ifdef SERIAL_DEBUG\n\t\trx_hard_overflow++;\t// increment error count if in debug mode\n\t\t#endif\n\t\tset_bit(rcsta, CREN);\t// reset error indicator\n\t} else {\n\t\tif (test_bit(rcsta, FERR)) {\t// framing error?\n\t\t\t#ifdef SERIAL_DEBUG\n\t\t\trx_framing_error++;\t// increment error count if in debug mode\n\t\t\t#endif\n\t\t}\t\n\t\trx_next = rx_end + 1;\t// get next buffer position\t\n\t\tif (rx_next == SERIAL_RX_BUFFER_SIZE) {\t// if we're at the end\n\t\t\trx_next = 0;\t// then wrap to the beginning\n\t\t}\n\t\tif (rx_next != rx_start) { // if space in the fifo\n\t\t\trx_buffer[rx_end] = rcreg; // put it in\n\t\t\trx_end = rx_next;  // and move pointer along\n\t\t} else {\t// else, there isn't space\n\t\t\t_asm MOVF\t_rcreg,W // and just clear it, we've lost it\n\t\t\t#ifdef SERIAL_DEBUG\n\t\t\trx_soft_overflow++;\t// increment error count if in debug mode\n\t\t\t#endif\n\t\t}\t// -- no space in the fifo\n\t}\t// -- no overrun error\n}", "path": "pic_pack_lib\\pic_serial.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "//349 38\n", "func_signal": "uns8 pkt_process_rf_data(uns8 *data_in)", "code": "{\n\nuns8 status = 0;\nuns8 count;\nuns16 orig_pkt_id;\nuns8 ack_payload[PKT_PAYLOAD_SIZE] = { 0xff, 0xff };\nsending_item *pitem;\nrf_packet packet;\n\tstart_crit_sec();\n\t\n\tmemcpy(/*dst*/  (void *)&packet, // copy it in\n\t\t   /*src*/  (void *)data_in,\n\t\t   /*len*/  PKT_PACKET_SIZE);\n\tend_crit_sec();\n\n    #ifdef PKT_DEBUG\n\t\tserial_putc('r');\n        pkt_print_packet(&packet);\n    #endif\n    if (!pkt_check_check_byte(&packet)) {\n\t\t#ifdef PKT_DEBUG_HIGH\n\t\t\tserial_print_str(\"CF! \");\n\t\t#endif\n\t\treturn PKT_STATUS_CHECK_FAIL;\n\t}\t\n\n\t// Am I the dest addr?\n\tif ((packet.d.dest_addr == pkt_my_addr) ||\n\t    (packet.d.dest_addr == PKT_BROADCAST_ADDR)) {\n\t\tstatus = PKT_STATUS_PKT_IS_FOR_ME;\n\t\t// It's for me. But is it an ack?\n\t\tif ((packet.d.payload[0] != 0xff) ||\n\t\t\t(packet.d.payload[1] != 0xff)) { // not an ack, so send one\t\t\n\t\t\tack_payload[2] = packet.d.pkt_id & 0xff;\n\t\t\tack_payload[3] = packet.d.pkt_id >> 8;\n\t\t\t#ifndef PKT_DEBUG_NO_TRANSMIT\n\t\t\t\tuns8 send_status = pkt_send_payload(packet.d.source_addr, ack_payload, PKT_FLAG_NO_RESEND);\n\t\t\t\t#ifdef PKT_DEBUG \n\t\t\t\t\tserial_print_str(\"ACKst=\");\n\t\t\t\t\tserial_print_int(send_status);\n\t\t\t\t#endif\n\t\t\t#endif\t\t\n\t\t} else { // We got an ack!\n\t\t\tstatus = PKT_STATUS_PKT_IS_ACK_FOR_ME;\n\t\t\torig_pkt_id = packet.d.payload[3];\n\t\t\torig_pkt_id <<= 8;\n\t\t\torig_pkt_id += packet.d.payload[2];\n\t\t\tfor (count = 0; count < PKT_TX_QUEUE_SIZE; count++) { // Search for a packet\n\t\t\t\tpitem = &pkt_tx_queue[count];\n\t\t\t\tif ((pitem->flag != PKT_FLAG_DELETED) &&\n\t\t\t\t(pitem->packet.d.pkt_id == orig_pkt_id)) {\n\t\t\t\t\tstatus = PKT_STATUS_PKT_IS_FACK_FOR_ME;\t // Found the ack\n\t\t\t\t\t#ifdef PKT_CALLBACK_ON_SEND_SUCCEEDED\n\t\t\t\t\t\tpkt_send_succeeded_callback(pitem->packet.d.dest_addr, pitem->packet.d.pkt_id);\n\t\t\t\t\t#endif\t\n\t\t\t\t\t\n\t\t\t\t\tpitem->flag = PKT_FLAG_DELETED;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t} // [we got an ack]\n\n\t\t\n\t\t// If not seen before, then process\t\t\n\t\tif (!pkt_seen(packet.d.pkt_id, packet.d.source_addr)) {\n\t\t\n\t\t\t// process payload\n\t\t\tif ((status != PKT_STATUS_PKT_IS_FACK_FOR_ME) && \n\t\t\t   (status != PKT_STATUS_PKT_IS_ACK_FOR_ME)) {\n\t\t\t\tpkt_payload_rx_callback(packet.d.source_addr, packet.d.pkt_id, packet.d.payload);\n\t\t\t}\t\n\t\t\t// Add to seen list\n\t\t\tpkt_seen_list_last++;\n\t\t\tif (pkt_seen_list_last == PKT_SEEN_LIST_SIZE) {\n\t\t\t\tpkt_seen_list_last = 0;\n\t\t\t}\n\t\t\tpkt_seen_list[pkt_seen_list_last].pkt_id = packet.d.pkt_id;\n\t\t\tpkt_seen_list[pkt_seen_list_last].source_addr = packet.d.source_addr;\n\t\t} else {\n\t\t\tstatus = PKT_STATUS_PKT_FOR_ME_BUT_SEEN;\n\t\t\t#ifdef PKT_DEBUG_HIGH\n\t\t\t\tserial_print_str(\" seen \");\n\t\t\t#endif\t\n\t\t}\t\n\t}\t\t\n\telse\n\t// Is sender + pkt_id seen?\n\tif (pkt_seen(packet.d.pkt_id, packet.d.source_addr)) {\n\t\t// We've seen this packet before\n\t\tstatus = PKT_STATUS_SEEN_BEFORE;\t\n\t} else \n\t// Am I the sender?\n\tif (packet.d.source_addr == pkt_my_addr) {\n\t\tstatus = PKT_STATUS_I_AM_SENDER;\n\t} else\n\t// Is the r1_addr = 0xffff, meaning direct send?\n\tif (packet.d.r1_addr == PKT_DIRECT_SEND_ADDR) {\n\t\tstatus = PKT_STATUS_DIRECT_SEND;\n\t} else \t \n\t// Am I one of the routers?\n\tif ((packet.d.r1_addr == pkt_my_addr) ||\n\t    (packet.d.r2_addr == pkt_my_addr) ||\n\t    (packet.d.r3_addr == pkt_my_addr)) {\n\t\tstatus = PKT_STATUS_PREVIOUS_ROUTED_VIA_ME;\n\t} else \n\t// Is r3 full?\n\tif (packet.d.r3_addr != 0) {\n\t\tstatus = PKT_STATUS_ROUTING_FULL;\n\t} else {  // I need to re-broadcast this packet\n\t\tstatus = PKT_STATUS_NEED_TO_REBROADCAST;\n\t\t// Add me as a router\n\t\tif (packet.d.r1_addr == 0) {\n\t\t\tpacket.d.r1_addr = pkt_my_addr;\n\t\t} else if (packet.d.r2_addr == 0) {\n\t\t\tpacket.d.r2_addr = pkt_my_addr;\n\t\t} else { \n\t\t\tpacket.d.r3_addr = pkt_my_addr;\n\t\t}\t\t\n\t\t// Update check byte now we've changed packet\n\t\tpkt_calc_check_byte(&packet);\n\t\t// queue packet no resend\n\t\t\n\t\t#ifndef PKT_DEBUG_NO_TRANSMIT\n\t\t\tpkt_queue_packet(&packet, PKT_FLAG_NO_RESEND);\n\t\t#endif\n\t\t// add to seen list?\n\t} // [I need to re-broadcast this packet]\n\n\treturn status;\n}", "path": "pic_pack_lib\\pic_packet.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// configure_system\n//\n// Get the pic ready for everything we want to do\n", "func_signal": "void configure_system()", "code": "{\n\t    \n\tkill_interrupts();\t// turn off interrupts just in case\n\n\tturn_analog_inputs_off();\t// kill those pesky analogue inputs\n\t\n\t\n\tserial_setup(BRGH_HIGH_SPEED, SPBRG_19200);\n\n\tar1000_setup_io();\n\t//ar1000_init();\n\t\n\tturn_peripheral_ints_on();\n\tturn_global_ints_on();\n}", "path": "demos\\ar1000\\ar1000_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Process_rx\n//\n// Keep adding characters to our input buffer\n// when we enter a command, then act on it\n", "func_signal": "void process_rx()", "code": "{\n\t\n\tuns8 len,\t// length of string\n\t\t rec;\t// received character\n\tuns8 first_char;\n\t\n\trec = serial_getc();\t// get the character from the fifo\n\n\t// neat trick to allow one button downloads\n\tif (rec == MAGIC_BOOSTBLOADER_REQUEST) {\n\t\tboostbloader();\n\t}\t\n\t\n\tserial_putc(rec);\t// print it out so we can see what we typed\n\n\tif (rec == '\\r') {\t// did we press return?\n\t\tfirst_char = serial_buffer[0];\n\t\tswitch (first_char) {\n\t\t\tcase 't':\n\t\t\t\tdo_task = 1;\n\t\t\t\tbreak;\n\t\t    case 'x':\n\t\t\t\tdo_task = 2;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tdo_task = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tdo_task = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tdo_task = 5;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tdo_task = 6;\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tdo_task = 7;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tdo_task = 8;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tdo_task = 9;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// More complicated example\n\t\t\t\t// Let's set a variable based on input\n\t\t\t\t// You can type:\n\t\t\t\t// s05\n\t\t\t\t// And press enter, it will set \"send_to\" to this (in hex)\n\t\t\t//\tif ((first_char == 's') && (strlen(serial_buffer)==3)) {\n\t\t\t//\t\tsend_to = atoui_hex(&serial_buffer[1]);\n\t\t\t//\t\tserial_print_str(\" Set send_to to \");\n\t\t\t//\t\tserial_print_int(send_to);\t// Of course, this could be anything\n\t\t\t//\t\tserial_putc('\\n');\n\t\t\t//\t};\n\t\t\t\tif ((first_char == 'v') && (strlen(serial_buffer)==3)) {\n\t\t\t\t\tsend_to = atoui_dec(&serial_buffer[1]);\n\t\t\t\t\tserial_print_str(\"v=\");\n\t\t\t\t\tserial_print_int(send_to);\t// Of course, this could be anything\n\t\t\t\t\tserial_putc('\\n');\n\t\t\t\t};\n\t\t\t\tar1000_set_volume(send_to);\n\t\t\t\t\n\t\t}\t\t\n\t\tserial_buffer[0] = '\\0';\t// clear the buffer\n        serial_putc('\\n');\t// print new line\n        serial_putc('>');\t// print the prompt\n\t} else {\n\t\tlen = strlen(serial_buffer);\t// add the character to our line input\n\t\tserial_buffer[len] = rec;\n\t\tserial_buffer[len+1] = '\\0';\n\t}\n\n}", "path": "demos\\ar1000\\ar1000_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// 269 + 12\n", "func_signal": "void pkt_init(uns16 my_addr, uns16 last_sent_id)", "code": "{\n\t// go through tx queue and set all flags to DELETED\t\nuns8 count;\nuns16 current_tick;\n\n\tpkt_my_addr = my_addr;\t// store my address\n\tpkt_my_next_pkt_id = last_sent_id + 1;\t// get next packet id\n\tfor (count = 0; count < PKT_TX_QUEUE_SIZE; count++) {\n\t\tpkt_tx_queue[count].flag = PKT_FLAG_DELETED;  // deleted\n\t}\t\n\n\tfor (count = 0; count < PKT_SEEN_LIST_SIZE; count++ ) {\n\t\tpkt_seen_list[count].source_addr = 0xffff;\t\n\t}\t\n}", "path": "pic_pack_lib\\pic_packet.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// -- serial_load_rx\n", "func_signal": "uns8 serial_getc(void)", "code": "{\n\tuns8 rx_char, rx_next;\n\t\n\twhile(rx_end == rx_start);\t// wait until there is something received\n\n\tstart_crit_sec();\t// make sure nobody else can muck with the buffer\n\t\n\trx_char = rx_buffer[rx_start];\t// get character from the front of the buffer\n\trx_start++;\t// increment fifo start\n\tif (rx_start == SERIAL_RX_BUFFER_SIZE) {\t// if we're at the end\n\t\trx_start = 0;\t// then wrap to the beginning\n\t}\n    \n    end_crit_sec();\t// now they can muck with the buffer\n    \n    return (rx_char);\t// return the result we first thought of\n\n}", "path": "pic_pack_lib\\pic_serial.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// we'll dump all our class data in here\n", "func_signal": "void usb_handle_class_request_callback(setup_data_packet sdp)", "code": "{\n\n\tswitch (sdp.bRequest) {\n\t\tcase req_SET_LINE_CODING:\n\t\t\t// we now expect the line coding to arrive in the data stage\n\t\t\t\n\t\t\t#ifdef CDC_DEBUG\n\t\t\t\tserial_print_str(\"SET_LINE \");\n\t\t\t#endif\n\t\t\tcontrol_mode = cm_CTRL_WRITE_DATA_STAGE_CLASS;\n\t\t\tbreak;\n\t\tcase req_GET_LINE_CODING:\n\t\t\t#ifdef CDC_DEBUG\n\t\t\t\tserial_print_str(\"GET_LINE \");\n\t\t\t\tserial_print_str(\" len=\");\n\t\t\t\tserial_print_int(sdp.wLength);\n\t\t\t\tserial_putc(' ');\n\t\t\t#endif\n\t\t\t//control_mode = cm_CTRL_READ_DATA_STAGE_CLASS;\n\t\t\tcontrol_mode = cm_CTRL_READ_DATA_STAGE_CLASS;\n\t\t\t//  need to prime ep0 IN with some funky data here\n\t\t\tusb_send_data(/*ep*/ 0, /*data*/ &class_data, /*count*/ 7, /*first*/ 1);\n\t\t\t// actually we know this will be the last packet, so go straight to waiting for the status ack\n\t\t\tcontrol_mode = cm_CTRL_READ_AWAITING_STATUS;\n\t\t\t\n\t\t\tbreak;\n\t\tcase req_SET_CONTROL_LINE_STATE:\n\t\t\t#ifdef CDC_DEBUG\n\t\t\t\tserial_print_str(\"scls=\");//dtr = bit 0, rts = bit 1\n\t\t\t\tserial_print_int_hex(sdp.wValue);\n\t\t\t#endif\n\t\t\t// no data, so just ack the status\n\t\t\tcontrol_mode = cm_CTRL_WRITE_SENDING_STATUS;\n\t\t\tusb_send_status_ack();\n\t\t\t// Could put a callback here for your own code when DTR or RTS change\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t#ifdef CDC_DEBUG\n\t\t\t\tserial_print_str(\"??r=\");\n\t\t\t\tserial_print_int(sdp.bRequest);\n\t\t\t#endif\t\n\t}\n}", "path": "pic_pack_lib\\usb_cdc_class.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Interrupt routine - - - - - - - - - -\n", "func_signal": "void interrupt()", "code": "{\n\t\n\t\tserial_handle_tx_isr();\n\t\tserial_handle_rx_isr();\n}", "path": "demos\\ar1000\\ar1000_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// configure_system\n//\n// Get the pic ready for everything we want to do\n", "func_signal": "void configure_system()", "code": "{\n\t    \n\tkill_interrupts();\t// turn off interrupts just in case\n\n\tturn_analog_inputs_off();\t// kill those pesky analogue inputs\n\t\n\tserial_setup(BRGH_HIGH_SPEED, SPBRG_9600);\n\n\tturn_peripheral_ints_on();\n\tturn_global_ints_on();\n}", "path": "demos\\serial\\serial_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Returns ASCII Decimal and Hex values\n", "func_signal": "inline uns8 bin2Hex(uns8 x)", "code": "{\n   if (x < 10) {\n   \t return '0' + x;\n   } else {\n     return 'A' -10 +  x;\n   }\n}", "path": "pic_pack_lib\\pic_serial.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// pic_rf_send_byte\n", "func_signal": "void pic_rf_send_bytes(char *bytes, uns8 num_bytes)", "code": "{\n\nuns8 byte_counter;\n\tfor(byte_counter = 0 ; byte_counter < num_bytes ; byte_counter++) {\n\t\tpic_rf_send_byte(bytes[byte_counter]);\n\t}\n}", "path": "pic_pack_lib\\pic_rf_2401a.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "/* seek\nSet hmute Bit\nClear TUNE Bit\nSet CHAN Bits\nClear SEEK Bit\nSet SEEKUP/SPACE/BAND/SEEKTH Bits\nEnable SEEK Bit\nWait STC flag (Seek/Tune Complete, in Status register)\nClear hmute Bit\nUpdate Functions (optional, but remember to update CHAN with the seek in\nREADCHAN before next seek)\n*/\n// Handle any command line tasks we need to do\n// Very handy to print out variables, do commands,\n// print out some debug, etc...\n", "func_signal": "inline void handle_tasks()", "code": "{\n\tswitch (do_task) {\n\t\tcase 1:\n\t\t\tserial_print_str(\"S\");\n\t\t\tar1000_seek(761, 1);\n\t\t\tserial_print_str(\"\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tserial_print_str(\"0x\\n\");\n\t\t\tuns16 res = ar1000_read_register(send_to);\n\t\t\tserial_print_int_hex_16bit(res);\n\t\t\tserial_print_nl();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tserial_print_str(\"R\\n\");\n\t\t\tprint_registers();\n\n\n\t\t\t\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tserial_print_str(\"i\\n\");\n\t\t\tar1000_init(); \n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tserial_print_str(\"tst\\n\");\n\t\t\t//ar1000_seek2(); \n\t\t\tar1000_test();\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tserial_print_str(\"S0x\\n\");\n\t\t\tar1000_write_register(0, 0xffff);\n\t\t\tserial_print_nl();\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tserial_print_str(\"s2\\n\");\n\t\t\tar1000_seek2(); \n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tserial_print_str(\"tu\\n\");\n\t\t\tar1000_tune(1009); \n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tserial_print_str(\"m\\n\");\n\t\t\tar1000_seek_more(); \n\t\t\tbreak;\n\t\t\t\n\t\t\t\n\t} // switch\t\t\n\n\tdo_task = 0;\n}", "path": "demos\\ar1000\\ar1000_demo.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "// Setup the rf reception\n", "func_signal": "void configure_rf()", "code": "{\n\trf_config my_config;\n\t\n\tmy_config.payload_width_ch2 = 0;\n\tmy_config.payload_width_ch1 = PKT_PACKET_SIZE * 8;\n\t// ignore ch2 address, since we don't use it\n\tmy_config.address_ch2[0] = 0xf0;\n\tmy_config.address_ch2[1] = 0xf0;\n\tmy_config.address_ch2[2] = 0xf0;\n\tmy_config.address_ch2[3] = 0xf0;\n\tmy_config.address_ch2[4] = 0xf0;\n\n\tmy_config.address_ch1[0] = 0b11100111; // addr starts here\n\tmy_config.address_ch1[1] = 0b11100111;\n\tmy_config.address_ch1[2] = 0b11100111;\n\tmy_config.address_ch1[3] = 0b11100111; // only used three but fill \n\tmy_config.address_ch1[4] = 0b11100111; // ...for the fun of it\n\tmy_config.address_width = 24; // (6 bits valid)\n\tset_bit(my_config.options, OP_LONG_CRC);\n\tset_bit(my_config.options, OP_ENABLE_CRC);\n    clear_bit(my_config.options, OP_ENABLE_CH2);\n\tset_bit(my_config.options, OP_ENABLE_SHOCKBURST); \n\tset_bit(my_config.options, OP_ENABLE_1_MBPS);\n\tmy_config.crystal = 0b011; \t// (3 bits valid) -> 16Mhz\n\tmy_config.output_power = 0b11; \t// (2 bits valid) 11 -> max power!\n\tmy_config.channel = 2; \t// (7 bits valid);\n\tset_bit(my_config.options, OP_ENABLE_RECEIVE);\n\n\tpic_rf_init(&my_config);\n}", "path": "demos\\temp_lcd_packet\\temp_lcd_packet.c", "repo_name": "iharris/picpack", "stars": 7, "license": "None", "language": "c", "size": 1133}
{"docstring": "/*\n==============\nCL_MuzzleFlash\n==============\n*/\n", "func_signal": "void CL_MuzzleFlash (void)", "code": "{\n\tvec3_t\t\tfv, rv, uv;\n\tdlight_t\t*dl;\n\tint\t\t\ti;\n\tplayer_state_t\t*pl;\n\n\ti = MSG_ReadShort ();\n\n\tif ((unsigned)(i-1) >= MAX_CLIENTS)\n\t\treturn;\n\n// GAJA: strip\n// #ifdef GLQUAKE\n// \t// don't draw our own muzzle flash in gl if flashblending\n// \tif (i-1 == cl.playernum && gl_flashblend.value)\n// \t\treturn;\n// #endif\n\n\tpl = &cl.frames[parsecountmod].playerstate[i-1];\n\n\tdl = CL_AllocDlight (i);\n\tVectorCopy (pl->origin,  dl->origin);\n\tAngleVectors (pl->viewangles, fv, rv, uv);\n\t\t\n\tVectorMA (dl->origin, 18, fv, dl->origin);\n\tdl->radius = 200 + (rand()&31);\n\tdl->minlight = 32;\n\tdl->die = cl.time + 0.1;\n\tdl->color[0] = 0.2;\n\tdl->color[1] = 0.1;\n\tdl->color[2] = 0.05;\n\tdl->color[3] = 0.7;\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==================\nCL_ParseClientdata\n\nServer information pertaining to this client only, sent every frame\n==================\n*/\n", "func_signal": "void CL_ParseClientdata (void)", "code": "{\n\tint\t\t\t\ti;\n\tfloat\t\tlatency;\n\tframe_t\t\t*frame;\n\n// calculate simulated time of message\n\toldparsecountmod = parsecountmod;\n\n\ti = cls.netchan.incoming_acknowledged;\n\tcl.parsecount = i;\n\ti &= UPDATE_MASK;\n\tparsecountmod = i;\n\tframe = &cl.frames[i];\n\tparsecounttime = cl.frames[i].senttime;\n\n\tframe->receivedtime = realtime;\n\n// calculate latency\n\tlatency = frame->receivedtime - frame->senttime;\n\n\tif (latency < 0 || latency > 1.0)\n\t{\n//\t\tCon_Printf (\"Odd latency: %5.2f\\n\", latency);\n\t}\n\telse\n\t{\n\t// drift the average latency towards the observed latency\n\t\tif (latency < cls.latency)\n\t\t\tcls.latency = latency;\n\t\telse\n\t\t\tcls.latency += 0.001;\t// drift up, so correction are needed\n\t}\t\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==========\nSkin_Cache\n\nReturns a pointer to the skin bitmap, or NULL to use the default\n==========\n*/\n", "func_signal": "byte\t*Skin_Cache (skin_t *skin)", "code": "{\n\tchar\tname[1024];\n\tbyte\t*raw;\n\tbyte\t*out, *pix;\n\tpcx_t\t*pcx;\n\tint\t\tx, y;\n\tint\t\tdataByte;\n\tint\t\trunLength;\n\n\tif (cls.downloadtype == dl_skin)\n\t\treturn NULL;\t\t// use base until downloaded\n\n\tif (noskins.value==1) // JACK: So NOSKINS > 1 will show skins, but\n\t\treturn NULL;\t  // not download new ones.\n\n\tif (skin->failedload)\n\t\treturn NULL;\n\n\tout = Cache_Check (&skin->cache);\n\tif (out)\n\t\treturn out;\n\n//\n// load the pic from disk\n//\n\tsprintf (name, \"skins/%s.pcx\", skin->name);\n\traw = COM_LoadTempFile (name);\n\tif (!raw)\n\t{\n\t\tCon_Printf (\"Couldn't load skin %s\\n\", name);\n\t\tsprintf (name, \"skins/%s.pcx\", baseskin.string);\n\t\traw = COM_LoadTempFile (name);\n\t\tif (!raw)\n\t\t{\n\t\t\tskin->failedload = true;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n//\n// parse the PCX file\n//\n\tpcx = (pcx_t *)raw;\n\traw = &pcx->data;\n\n\tif (pcx->manufacturer != 0x0a\n\t\t|| pcx->version != 5\n\t\t|| pcx->encoding != 1\n\t\t|| pcx->bits_per_pixel != 8\n\t\t|| pcx->xmax >= 320\n\t\t|| pcx->ymax >= 200)\n\t{\n\t\tskin->failedload = true;\n\t\tCon_Printf (\"Bad skin %s\\n\", name);\n\t\treturn NULL;\n\t}\n\t\n\tout = Cache_Alloc (&skin->cache, 320*200, skin->name);\n\tif (!out)\n\t\tSys_Error (\"Skin_Cache: couldn't allocate\");\n\n\tpix = out;\n\tmemset (out, 0, 320*200);\n\n\tfor (y=0 ; y<pcx->ymax ; y++, pix += 320)\n\t{\n\t\tfor (x=0 ; x<=pcx->xmax ; )\n\t\t{\n\t\t\tif (raw - (byte*)pcx > com_filesize) \n\t\t\t{\n\t\t\t\tCache_Free (&skin->cache);\n\t\t\t\tskin->failedload = true;\n\t\t\t\tCon_Printf (\"Skin %s was malformed.  You should delete it.\\n\", name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdataByte = *raw++;\n\n\t\t\tif((dataByte & 0xC0) == 0xC0)\n\t\t\t{\n\t\t\t\trunLength = dataByte & 0x3F;\n\t\t\t\tif (raw - (byte*)pcx > com_filesize) \n\t\t\t\t{\n\t\t\t\t\tCache_Free (&skin->cache);\n\t\t\t\t\tskin->failedload = true;\n\t\t\t\t\tCon_Printf (\"Skin %s was malformed.  You should delete it.\\n\", name);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tdataByte = *raw++;\n\t\t\t}\n\t\t\telse\n\t\t\t\trunLength = 1;\n\n\t\t\t// skin sanity check\n\t\t\tif (runLength + x > pcx->xmax + 2) {\n\t\t\t\tCache_Free (&skin->cache);\n\t\t\t\tskin->failedload = true;\n\t\t\t\tCon_Printf (\"Skin %s was malformed.  You should delete it.\\n\", name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\twhile(runLength-- > 0)\n\t\t\t\tpix[x++] = dataByte;\n\t\t}\n\n\t}\n\n\tif ( raw - (byte *)pcx > com_filesize)\n\t{\n\t\tCache_Free (&skin->cache);\n\t\tskin->failedload = true;\n\t\tCon_Printf (\"Skin %s was malformed.  You should delete it.\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tskin->failedload = false;\n\n\treturn out;\n}", "path": "client\\TraceBot\\skin.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n===============\nNetchan_OutOfBandPrint\n\nSends a text message in an out-of-band datagram\n================\n*/\n", "func_signal": "void Netchan_OutOfBandPrint (netadr_t adr, char *format, ...)", "code": "{\n\tva_list\t\targptr;\n\tstatic char\t\tstring[8192];\t\t// ??? why static?\n\t\n\tva_start (argptr, format);\n\tvsprintf (string, format,argptr);\n\tva_end (argptr);\n\n\n\tNetchan_OutOfBand (adr, strlen(string), (byte *)string);\n}", "path": "server\\net_chan.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n===============\nNetchan_Transmit\n\ntries to send an unreliable message to a connection, and handles the\ntransmition / retransmition of the reliable messages.\n\nA 0 length will still generate a packet and deal with the reliable messages.\n================\n*/\n", "func_signal": "TM_CALLABLE\nvoid Netchan_Transmit (netchan_t *chan, int length, byte *data)", "code": "{\n\tsizebuf_t\tsend;\n\tbyte\t\tsend_buf[MAX_MSGLEN + PACKET_HEADER];\n\tqboolean\tsend_reliable;\n\tunsigned\tw1, w2;\n\tint\t\t\ti;\n\n// check for message overflow\n\tif (chan->message.overflowed)\n\t{\n\t\tchan->fatal_error = true;\n\t\tCon_Printf (\"%s:Outgoing message overflow\\n\"\n\t\t\t, NET_AdrToString (chan->remote_address));\n\t\treturn;\n\t}\n\n// if the remote side dropped the last reliable message, resend it\n\tsend_reliable = false;\n\n\tif (chan->incoming_acknowledged > chan->last_reliable_sequence\n\t&& chan->incoming_reliable_acknowledged != chan->reliable_sequence)\n\t\tsend_reliable = true;\n\n// if the reliable transmit buffer is empty, copy the current message out\n\tif (!chan->reliable_length && chan->message.cursize)\n\t{\n\t\tQ_memcpy (chan->reliable_buf, chan->message_buf, chan->message.cursize);\n\t\tchan->reliable_length = chan->message.cursize;\n\t\tchan->message.cursize = 0;\n\t\tchan->reliable_sequence ^= 1;\n\t\tsend_reliable = true;\n\t}\n\n// write the packet header\n\tsend.data = send_buf;\n\tsend.maxsize = sizeof(send_buf);\n\tsend.cursize = 0;\n\n\tw1 = chan->outgoing_sequence | (send_reliable<<31);\n\tw2 = chan->incoming_sequence | (chan->incoming_reliable_sequence<<31);\n\n\tchan->outgoing_sequence++;\n\n\tMSG_WriteLong (&send, w1);\n\tMSG_WriteLong (&send, w2);\n\n\t// send the qport if we are a client\n\n\t// copy the reliable message to the packet first\n\tif (send_reliable)\n\t{\n\t\tSZ_Write (&send, chan->reliable_buf, chan->reliable_length);\n\t\tchan->last_reliable_sequence = chan->outgoing_sequence;\n\t}\n\t\n\t// add the unreliable part if space is available\n\tif (send.maxsize - send.cursize >= length)\n\t\tSZ_Write (&send, data, length);\n\n\t// send the datagram\n\ti = chan->outgoing_sequence & (MAX_LATENT-1);\n\tchan->outgoing_size[i] = send.cursize;\n\tchan->outgoing_time[i] = realtime;\n\n\tNET_SendPacket (send.cursize, send.data, chan->remote_address);\n\n\tif (chan->cleartime < realtime)\n\t\tchan->cleartime = realtime + send.cursize*chan->rate;\n\telse\n\t\tchan->cleartime += send.cursize*chan->rate;\n\n\tif (ServerPaused())\n\t\tchan->cleartime = realtime;\n\n\n\tif (showpackets.value)\n\t\tCon_Printf (\"--> s=%i(%i) a=%i(%i) %i\\n\"\n\t\t\t, chan->outgoing_sequence\n\t\t\t, send_reliable\n\t\t\t, chan->incoming_sequence\n\t\t\t, chan->incoming_reliable_sequence\n\t\t\t, send.cursize);\n\n}", "path": "server\\net_chan.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==================\nCL_ParseBaseline\n==================\n*/\n", "func_signal": "void CL_ParseBaseline (entity_state_t *es)", "code": "{\n\tint\t\t\ti;\n\t\n\tes->modelindex = MSG_ReadByte ();\n\tes->frame = MSG_ReadByte ();\n\tes->colormap = MSG_ReadByte();\n\tes->skinnum = MSG_ReadByte();\n\tfor (i=0 ; i<3 ; i++)\n\t{\n\t\tes->origin[i] = MSG_ReadCoord ();\n\t\tes->angles[i] = MSG_ReadAngle ();\n\t}\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=====================\nCL_SetStat\n=====================\n*/\n", "func_signal": "void CL_SetStat (int stat, int value)", "code": "{\n\tint\tj;\n\tif (stat < 0 || stat >= MAX_CL_STATS)\n\t\tSys_Error (\"CL_SetStat: %i is invalid\", stat);\n\n\t//Sbar_Changed ();\n\t\n\tif (stat == STAT_ITEMS)\n\t{\t// set flash times\n\t\t//Sbar_Changed ();\n\t\tfor (j=0 ; j<32 ; j++)\n\t\t\tif ( (value & (1<<j)) && !(cl.stats[stat] & (1<<j)))\n\t\t\t\tcl.item_gettime[j] = cl.time;\n\t}\n\n\tcl.stats[stat] = value;\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=================\nSound_NextDownload\n=================\n*/\n", "func_signal": "void Sound_NextDownload (void)", "code": "{\n\tchar\t*s;\n\tint\t\ti;\n\n\tif (cls.downloadnumber == 0)\n\t{\n\t\tCon_Printf (\"Checking sounds...\\n\");\n\t\tcls.downloadnumber = 1;\n\t}\n\n\tcls.downloadtype = dl_sound;\n\tfor ( \n\t\t; cl.sound_name[cls.downloadnumber][0]\n\t\t; cls.downloadnumber++)\n\t{\n\t\ts = cl.sound_name[cls.downloadnumber];\n\t\tif (!CL_CheckOrDownloadFile(va(\"sound/%s\",s)))\n\t\t\treturn;\t\t// started a download\n\t}\n\n\tfor (i=1 ; i<MAX_SOUNDS ; i++)\n\t{\n\t\tif (!cl.sound_name[i][0])\n\t\t\tbreak;\n\t\t// STRIP cl.sound_precache[i] = S_PrecacheSound (cl.sound_name[i]);\n\t}\n\n\t// done with sounds, request models now\n\tmemset (cl.model_precache, 0, sizeof(cl.model_precache));\n\tcl_playerindex = -1;\n\tcl_spikeindex = -1;\n\tcl_flagindex = -1;\n\tMSG_WriteByte (&cls.netchan.message, clc_stringcmd);\n//\tMSG_WriteString (&cls.netchan.message, va(\"modellist %i 0\", cl.servercount));\n\tMSG_WriteString (&cls.netchan.message, va(modellist_name, cl.servercount, 0));\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=============================================================================\n\nDYNAMIC LIGHTS BLEND RENDERING\n\n=============================================================================\n*/\n", "func_signal": "void AddLightBlend (float r, float g, float b, float a2)", "code": "{\n\tfloat\ta;\n\n\tv_blend[3] = a = v_blend[3] + a2*(1-v_blend[3]);\n\n\ta2 = a2/a;\n\n\tv_blend[0] = v_blend[1]*(1-a2) + r*a2;\n\tv_blend[1] = v_blend[1]*(1-a2) + g*a2;\n\tv_blend[2] = v_blend[2]*(1-a2) + b*a2;\n//Con_Printf(\"AddLightBlend(): %4.2f %4.2f %4.2f %4.6f\\n\", v_blend[0], v_blend[1], v_blend[2], v_blend[3]);\n}", "path": "client\\VideoClient\\gl_rlight.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==========\nSkin_Skins_f\n\nRefind all skins, downloading if needed.\n==========\n*/\n", "func_signal": "void\tSkin_Skins_f (void)", "code": "{\n\tint\t\ti;\n\n\tfor (i=0 ; i<numskins ; i++)\n\t{\n\t\tif (skins[i].cache.data)\n\t\t\tCache_Free (&skins[i].cache);\n\t}\n\tnumskins = 0;\n\n\tcls.downloadnumber = 0;\n\tcls.downloadtype = dl_skin;\n\tSkin_NextDownload ();\n}", "path": "client\\TraceBot\\skin.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=====================\nCL_NewTranslation\n=====================\n*/\n", "func_signal": "void CL_NewTranslation (int slot)", "code": "{\n// GAJA: strip\n// #ifdef GLQUAKE\n\tif (slot > MAX_CLIENTS)\n\t\tSys_Error (\"CL_NewTranslation: slot > MAX_CLIENTS\");\n\n\t//R_TranslatePlayerSkin(slot);\n// #else\n// \n// \tint\t\ti, j;\n// \tint\t\ttop, bottom;\n// \tbyte\t*dest, *source;\n// \tplayer_info_t\t*player;\n// \tchar s[512];\n// \n// \tif (slot > MAX_CLIENTS)\n// \t\tSys_Error (\"CL_NewTranslation: slot > MAX_CLIENTS\");\n// \n// \tplayer = &cl.players[slot];\n// \n// \tstrcpy(s, Info_ValueForKey(player->userinfo, \"skin\"));\n// \tCOM_StripExtension(s, s);\n// \tif (player->skin && !stricmp(s, player->skin->name))\n// \t\tplayer->skin = NULL;\n// \n// \tif (player->_topcolor != player->topcolor ||\n// \t\tplayer->_bottomcolor != player->bottomcolor || !player->skin) {\n// \t\tplayer->_topcolor = player->topcolor;\n// \t\tplayer->_bottomcolor = player->bottomcolor;\n// \n// \t\tdest = player->translations;\n// \t\tsource = vid.colormap;\n// \t\tmemcpy (dest, vid.colormap, sizeof(player->translations));\n// \t\ttop = player->topcolor;\n// \t\tif (top > 13 || top < 0)\n// \t\t\ttop = 13;\n// \t\ttop *= 16;\n// \t\tbottom = player->bottomcolor;\n// \t\tif (bottom > 13 || bottom < 0)\n// \t\t\tbottom = 13;\n// \t\tbottom *= 16;\n// \n// \t\tfor (i=0 ; i<VID_GRADES ; i++, dest += 256, source+=256)\n// \t\t{\n// \t\t\tif (top < 128)\t// the artists made some backwards ranges.  sigh.\n// \t\t\t\tmemcpy (dest + TOP_RANGE, source + top, 16);\n// \t\t\telse\n// \t\t\t\tfor (j=0 ; j<16 ; j++)\n// \t\t\t\t\tdest[TOP_RANGE+j] = source[top+15-j];\n// \t\t\t\t\t\n// \t\t\tif (bottom < 128)\n// \t\t\t\tmemcpy (dest + BOTTOM_RANGE, source + bottom, 16);\n// \t\t\telse\n// \t\t\t\tfor (j=0 ; j<16 ; j++)\n// \t\t\t\t\tdest[BOTTOM_RANGE+j] = source[bottom+15-j];\t\t\n// \t\t}\n// \t}\n// #endif\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==============\nCL_SetInfo\n==============\n*/\n", "func_signal": "void CL_SetInfo (void)", "code": "{\n\tint\t\tslot;\n\tplayer_info_t\t*player;\n\tchar key[MAX_MSGLEN];\n\tchar value[MAX_MSGLEN];\n\n\tslot = MSG_ReadByte ();\n\tif (slot >= MAX_CLIENTS)\n\t\tHost_EndGame (\"CL_ParseServerMessage: svc_setinfo > MAX_SCOREBOARD\");\n\n\tplayer = &cl.players[slot];\n\n\tstrncpy (key, MSG_ReadString(), sizeof(key) - 1);\n\tkey[sizeof(key) - 1] = 0;\n\tstrncpy (value, MSG_ReadString(), sizeof(value) - 1);\n\tkey[sizeof(value) - 1] = 0;\n\n\tCon_DPrintf(\"SETINFO %s: %s=%s\\n\", player->name, key, value);\n\n\tInfo_SetValueForKey (player->userinfo, key, value, MAX_INFO_STRING);\n\n\tCL_ProcessUserInfo (slot, player);\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=====================\nCL_ParseDownload\n\nA download message has been received from the server\n=====================\n*/\n", "func_signal": "void CL_ParseDownload (void)", "code": "{\n\tint\t\tsize, percent;\n\tbyte\tname[1024];\n\tint\t\tr;\n\n\n\t// read the data\n\tsize = MSG_ReadShort ();\n\tpercent = MSG_ReadByte ();\n\n\tif (cls.demoplayback) {\n\t\tif (size > 0)\n\t\t\tmsg_readcount += size;\n\t\treturn; // not in demo playback\n\t}\n\n\tif (size == -1)\n\t{\n\t\tCon_Printf (\"File not found.\\n\");\n\t\tif (cls.download)\n\t\t{\n\t\t\tCon_Printf (\"cls.download shouldn't have been set\\n\");\n\t\t\tfclose (cls.download);\n\t\t\tcls.download = NULL;\n\t\t}\n\t\tCL_RequestNextDownload ();\n\t\treturn;\n\t}\n\n\t// open the file if not opened yet\n\tif (!cls.download)\n\t{\n\t\tif (strncmp(cls.downloadtempname,\"skins/\",6))\n\t\t\tsprintf (name, \"%s/%s\", com_gamedir, cls.downloadtempname);\n\t\telse\n\t\t\tsprintf (name, \"qw/%s\", cls.downloadtempname);\n\n\t\tCOM_CreatePath (name);\n\n\t\tcls.download = fopen (name, \"wb\");\n\t\tif (!cls.download)\n\t\t{\n\t\t\tmsg_readcount += size;\n\t\t\tCon_Printf (\"Failed to open %s\\n\", cls.downloadtempname);\n\t\t\tCL_RequestNextDownload ();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfwrite (net_message.data + msg_readcount, 1, size, cls.download);\n\tmsg_readcount += size;\n\n\tif (percent != 100)\n\t{\n// change display routines by zoid\n\t\t// request next block\n#if 0\n\t\tCon_Printf (\".\");\n\t\tif (10*(percent/10) != cls.downloadpercent)\n\t\t{\n\t\t\tcls.downloadpercent = 10*(percent/10);\n\t\t\tCon_Printf (\"%i%%\", cls.downloadpercent);\n\t\t}\n#endif\n\t\tcls.downloadpercent = percent;\n\n\t\tMSG_WriteByte (&cls.netchan.message, clc_stringcmd);\n\t\tSZ_Print (&cls.netchan.message, \"nextdl\");\n\t}\n\telse\n\t{\n\t\tchar\toldn[MAX_OSPATH];\n\t\tchar\tnewn[MAX_OSPATH];\n\n#if 0\n\t\tCon_Printf (\"100%%\\n\");\n#endif\n\n\t\tfclose (cls.download);\n\n\t\t// rename the temp file to it's final name\n\t\tif (strcmp(cls.downloadtempname, cls.downloadname)) {\n\t\t\tif (strncmp(cls.downloadtempname,\"skins/\",6)) {\n\t\t\t\tsprintf (oldn, \"%s/%s\", com_gamedir, cls.downloadtempname);\n\t\t\t\tsprintf (newn, \"%s/%s\", com_gamedir, cls.downloadname);\n\t\t\t} else {\n\t\t\t\tsprintf (oldn, \"qw/%s\", cls.downloadtempname);\n\t\t\t\tsprintf (newn, \"qw/%s\", cls.downloadname);\n\t\t\t}\n\t\t\tr = rename (oldn, newn);\n\t\t\tif (r)\n\t\t\t\tCon_Printf (\"failed to rename.\\n\");\n\t\t}\n\n\t\tcls.download = NULL;\n\t\tcls.downloadpercent = 0;\n\n\t\t// get another file if needed\n\n\t\tCL_RequestNextDownload ();\n\t}\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==============\nCL_ServerInfo\n==============\n*/\n", "func_signal": "void CL_ServerInfo (void)", "code": "{\n\tint\t\tslot;\n\tplayer_info_t\t*player;\n\tchar key[MAX_MSGLEN];\n\tchar value[MAX_MSGLEN];\n\n\tstrncpy (key, MSG_ReadString(), sizeof(key) - 1);\n\tkey[sizeof(key) - 1] = 0;\n\tstrncpy (value, MSG_ReadString(), sizeof(value) - 1);\n\tkey[sizeof(value) - 1] = 0;\n\n\tCon_DPrintf(\"SERVERINFO: %s=%s\\n\", key, value);\n\n\tInfo_SetValueForKey (cl.serverinfo, key, value, MAX_SERVERINFO_STRING);\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==================\nR_AnimateLight\n==================\n*/\n", "func_signal": "void R_AnimateLight (void)", "code": "{\n\tint\t\t\ti,j,k;\n\t\n//\n// light animations\n// 'm' is normal light, 'a' is no light, 'z' is double bright\n\ti = (int)(cl.time*10);\n\tfor (j=0 ; j<MAX_LIGHTSTYLES ; j++)\n\t{\n\t\tif (!cl_lightstyle[j].length)\n\t\t{\n\t\t\td_lightstylevalue[j] = 256;\n\t\t\tcontinue;\n\t\t}\n\t\tk = i % cl_lightstyle[j].length;\n\t\tk = cl_lightstyle[j].map[k] - 'a';\n\t\tk = k*22;\n\t\td_lightstylevalue[j] = k;\n\t}\t\n}", "path": "client\\VideoClient\\gl_rlight.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=================\nSkin_NextDownload\n=================\n*/\n", "func_signal": "void Skin_NextDownload (void)", "code": "{\n\tplayer_info_t\t*sc;\n\tint\t\t\ti;\n\n\tif (cls.downloadnumber == 0)\n\t\tCon_Printf (\"Checking skins...\\n\");\n\tcls.downloadtype = dl_skin;\n\n\tfor ( \n\t\t; cls.downloadnumber != MAX_CLIENTS\n\t\t; cls.downloadnumber++)\n\t{\n\t\tsc = &cl.players[cls.downloadnumber];\n\t\tif (!sc->name[0])\n\t\t\tcontinue;\n\t\tSkin_Find (sc);\n\t\tif (noskins.value)\n\t\t\tcontinue;\n\t\tif (!CL_CheckOrDownloadFile(va(\"skins/%s.pcx\", sc->skin->name)))\n\t\t\treturn;\t\t// started a download\n\t}\n\n\tcls.downloadtype = dl_none;\n\n\t// now load them in for real\n\tfor (i=0 ; i<MAX_CLIENTS ; i++)\n\t{\n\t\tsc = &cl.players[i];\n\t\tif (!sc->name[0])\n\t\t\tcontinue;\n\t\tSkin_Cache (sc->skin);\n// GAJA: strip\n// #ifdef GLQUAKE\n\t\tsc->skin = NULL;\n// #endif\n\t}\n\n\tif (cls.state != ca_active)\n\t{\t// get next signon phase\n\t\tMSG_WriteByte (&cls.netchan.message, clc_stringcmd);\n\t\tMSG_WriteString (&cls.netchan.message,\n\t\t\tva(\"begin %i\", cl.servercount));\n    printf(\" BEGIN TIME: \");\n    print_time ();      // GAJA: Print the wall clock time of begin event\n\t\tCache_Report ();\t\t// print remaining memory\n\t}\n}", "path": "client\\TraceBot\\skin.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n==================\nCL_ParseServerData\n==================\n*/\n", "func_signal": "void CL_ParseServerData (void)", "code": "{\n\tchar\t*str;\n\tFILE\t*f;\n\tchar\tfn[MAX_OSPATH];\n\tqboolean\tcflag = false;\n\textern\tchar\tgamedirfile[MAX_OSPATH];\n\tint protover;\n\t\n\tCon_DPrintf (\"Serverdata packet received.\\n\");\n//\n// wipe the client_state_t struct\n//\n\tCL_ClearState ();\n\n// parse protocol version number\n// allow 2.2 and 2.29 demos to play\n\tprotover = MSG_ReadLong ();\n\tif (protover != PROTOCOL_VERSION && \n\t\t!(cls.demoplayback && (protover == 26 || protover == 27 || protover == 28)))\n\t\tHost_EndGame (\"Server returned version %i, not %i\\nYou probably need to upgrade.\\nCheck http://www.quakeworld.net/\", protover, PROTOCOL_VERSION);\n\n\tcl.servercount = MSG_ReadLong ();\n\n\t// game directory\n\tstr = MSG_ReadString ();\n\n\tif (stricmp(gamedirfile, str)) {\n\t\t// save current config\n\t\tHost_WriteConfiguration (); \n\t\tcflag = true;\n\t}\n\n\tCOM_Gamedir(str);\n\n\t//ZOID--run the autoexec.cfg in the gamedir\n\t//if it exists\n\tif (cflag) {\n\t\tsprintf(fn, \"%s/%s\", com_gamedir, \"config.cfg\");\n\t\tif ((f = fopen(fn, \"r\")) != NULL) {\n\t\t\tfclose(f);\n\t\t\tCbuf_AddText (\"cl_warncmd 0\\n\");\n\t\t\tCbuf_AddText(\"exec config.cfg\\n\");\n\t\t\tCbuf_AddText(\"exec frontend.cfg\\n\");\n\t\t\tCbuf_AddText (\"cl_warncmd 1\\n\");\n\t\t}\n\t}\n\n\t// parse player slot, high bit means spectator\n\tcl.playernum = MSG_ReadByte ();\n\tif (cl.playernum & 128)\n\t{\n\t\tcl.spectator = true;\n\t\tcl.playernum &= ~128;\n\t}\n\n\t// get the full level name\n\tstr = MSG_ReadString ();\n\tstrncpy (cl.levelname, str, sizeof(cl.levelname)-1);\n\n\t// get the movevars\n\tmovevars.gravity\t\t\t= MSG_ReadFloat();\n\tmovevars.stopspeed          = MSG_ReadFloat();\n\tmovevars.maxspeed           = MSG_ReadFloat();\n\tmovevars.spectatormaxspeed  = MSG_ReadFloat();\n\tmovevars.accelerate         = MSG_ReadFloat();\n\tmovevars.airaccelerate      = MSG_ReadFloat();\n\tmovevars.wateraccelerate    = MSG_ReadFloat();\n\tmovevars.friction           = MSG_ReadFloat();\n\tmovevars.waterfriction      = MSG_ReadFloat();\n\tmovevars.entgravity         = MSG_ReadFloat();\n\n\t// seperate the printfs so the server message can have a color\n\tCon_Printf(\"\\n\\n\\35\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\36\\37\\n\\n\");\n\tCon_Printf (\"%c%s\\n\", 2, str);\n\n\t// ask for the sound list next\n\tmemset(cl.sound_name, 0, sizeof(cl.sound_name));\n\tMSG_WriteByte (&cls.netchan.message, clc_stringcmd);\n//\tMSG_WriteString (&cls.netchan.message, va(\"soundlist %i 0\", cl.servercount));\n\tMSG_WriteString (&cls.netchan.message, va(soundlist_name, cl.servercount, 0));\n\n\t// now waiting for downloads, etc\n\tcls.state = ca_onserver;\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=====================\nCL_ParseStatic\n\nStatic entities are non-interactive world objects\nlike torches\n=====================\n*/\n", "func_signal": "void CL_ParseStatic (void)", "code": "{\n\tentity_t *ent;\n\tint\t\ti;\n\tentity_state_t\tes;\n\n\tCL_ParseBaseline (&es);\n\t\t\n\ti = cl.num_statics;\n\tif (i >= MAX_STATIC_ENTITIES)\n\t\tHost_EndGame (\"Too many static entities\");\n\tent = &cl_static_entities[i];\n\tcl.num_statics++;\n\n// copy it to the current state\n\tent->model = cl.model_precache[es.modelindex];\n\tent->frame = es.frame;\n\t//ent->colormap = vid.colormap;\t\tGAJA STRIP\n\tent->skinnum = es.skinnum;\n\n\tVectorCopy (es.origin, ent->origin);\n\tVectorCopy (es.angles, ent->angles);\n\t\n\t//R_AddEfrags (ent);\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=================\nModel_NextDownload\n=================\n*/\n", "func_signal": "void Model_NextDownload (void)", "code": "{\n\tchar\t*s;\n\tint\t\ti;\n\textern\tchar gamedirfile[];\n\n\tprintf(\"Started models\\n\");\n\n\tif (cls.downloadnumber == 0)\n\t{\n\t\tCon_Printf (\"Checking models...\\n\");\n\t\tcls.downloadnumber = 1;\n\t}\n\n\tcls.downloadtype = dl_model;\n\tfor ( \n\t\t; cl.model_name[cls.downloadnumber][0]\n\t\t; cls.downloadnumber++)\n\t{\n\t\ts = cl.model_name[cls.downloadnumber];\n\t\tif (s[0] == '*')\n\t\t\tcontinue;\t// inline brush model\n\t\tif (!CL_CheckOrDownloadFile(s))\n\t\t\treturn;\t\t// started a download\n\t}\n\n\tfor (i=1 ; i<MAX_MODELS ; i++)\n\t{\n\t\tif (!cl.model_name[i][0])\n\t\t\tbreak;\n\n\t\tcl.model_precache[i] = Mod_ForName (cl.model_name[i], false);\n\n\t\tif (!cl.model_precache[i])\n\t\t{\n\t\t\tCon_Printf (\"\\nThe required model file '%s' could not be found or downloaded.\\n\\n\"\n\t\t\t\t, cl.model_name[i]);\n\t\t\tCon_Printf (\"You may need to download or purchase a %s client \"\n\t\t\t\t\"pack in order to play on this server.\\n\\n\", gamedirfile);\n\t\t\tCL_Disconnect ();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// GAJA: Gracefully exit to avoid segmentation fault which happens sometimes\n\tif (i==1 && !cl.model_precache[i])\n\t{\n\t\tCon_Printf (\"\\nThe model info is corrupted. Exiting to avoid segmentation fault\\n\");\n\t\tCL_Disconnect ();\n\t\treturn;\n\t}\n\n\t// all done\n\tcl.worldmodel = cl.model_precache[1];\t\n\t//R_NewMap ();\n\tHunk_Check ();\t\t// make sure nothing is hurt\n\n\t// done with modellist, request first of static signon messages\n\tMSG_WriteByte (&cls.netchan.message, clc_stringcmd);\n//\tMSG_WriteString (&cls.netchan.message, va(\"prespawn %i 0 %i\", cl.servercount, cl.worldmodel->checksum2));\n\tMSG_WriteString (&cls.netchan.message, va(prespawn_name, cl.servercount, cl.worldmodel->checksum2));\n\n\tprintf(\"Finished models\\n\");\n}", "path": "client\\TraceBot\\cl_parse.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
{"docstring": "/*\n=================\nNetchan_Process\n\ncalled when the current net_message is from remote_address\nmodifies net_message so that it points to the packet payload\n=================\n*/\n", "func_signal": "TM_CALLABLE\nqboolean Netchan_Process (netchan_t *chan, int cl_number)", "code": "{\n\tunsigned\t\tsequence, sequence_ack;\n\tunsigned\t\treliable_ack, reliable_message;\n\tint\t\t\t\tqport;\n\n\tif (!NET_CompareAdr (net_from, chan->remote_address))\n\t\treturn false;\n\t\n\t// get sequence numbers\t\t\n\tMSG_BeginReading ();\n\tsequence = MSG_ReadLong ();\n\tsequence_ack = MSG_ReadLong ();\n\n\t// read the qport if we are a server\n\tqport = MSG_ReadShort ();\n\n\treliable_message = sequence >> 31;\n\treliable_ack = sequence_ack >> 31;\n\n\tsequence &= ~(1<<31);\t\n\tsequence_ack &= ~(1<<31);\t\n\n\tif (showpackets.value)\n\t\tCon_Printf (\"<-- s=%i(%i) a=%i(%i) %i\\n\"\n\t\t\t, sequence\n\t\t\t, reliable_message\n\t\t\t, sequence_ack\n\t\t\t, reliable_ack\n\t\t\t, net_message.cursize);\n\n\t//\n\t// discard stale or duplicated packets\n\t//\n\tif (sequence <= (unsigned)chan->incoming_sequence)\n\t{\n\t\tif (showdrop.value)\n\t\t\tCon_Printf (\"%s:Out of order packet %i at %i\\n\"\n\t\t\t\t, NET_AdrToString (chan->remote_address)\n\t\t\t\t,  sequence\n\t\t\t\t, chan->incoming_sequence);\n\t\treturn false;\n\t}\n\n\t//\n\t// dropped packets don't keep the message from being used\n\t//\n\tnet_drop = sequence - (chan->incoming_sequence+1);\n\tif (net_drop > 0)\n\t{\n\t\tchan->drop_count += 1;\n\n\t\tif (showdrop.value)\n\t\t\tCon_Printf (\"%s:Dropped %i packets at %i\\n\"\n\t\t\t, NET_AdrToString (chan->remote_address)\n\t\t\t, sequence-(chan->incoming_sequence+1)\n\t\t\t, sequence);\n\t}\n\n\t//\n\t// if the current outgoing reliable message has been acknowledged\n\t// clear the buffer to make way for the next\n\t//\n\tif (reliable_ack == (unsigned)chan->reliable_sequence)\n\t{\n  \tchan->reliable_length = 0;\t// it has been received\n    DEBUGPRINT(READ_PACKETS,HIGH) PRINT(\"Thread: %d\\t\\tCLEAR REALIABLE for CL_NUMBER = %d\\n\", ThreadNumber(), cl_number);\n  }\n\t\n\t//\n\t// if this message contains a reliable message, bump incoming_reliable_sequence \n\t//\n\tchan->incoming_sequence = sequence;\n\tchan->incoming_acknowledged = sequence_ack;\n\tchan->incoming_reliable_acknowledged = reliable_ack;\n\tif (reliable_message)\n\t\tchan->incoming_reliable_sequence ^= 1;\n\n\t//\n\t// the message can now be read from the current message pointer\n\t// update statistics counters\n\t//\n\tchan->frame_latency = chan->frame_latency*OLD_AVG\n\t\t+ (chan->outgoing_sequence-sequence_ack)*(1.0-OLD_AVG);\n\tchan->frame_rate = chan->frame_rate*OLD_AVG\n\t\t+ (realtime-chan->last_received)*(1.0-OLD_AVG);\t\t\n\tchan->good_count += 1;\n\n\tchan->last_received = realtime;\n\n\treturn true;\n}", "path": "server\\net_chan.c", "repo_name": "jrk/QuakeTM", "stars": 4, "license": "None", "language": "c", "size": 11276}
