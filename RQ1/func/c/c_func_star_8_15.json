{"docstring": "/******************************************************\n * Add a file to the input source list\n ******************************************************/\n", "func_signal": "void dev_include(char *s)", "code": "{\n  FILE *file;\n\n  file = fopen(s, \"r\");\n\n  if (file)\n  {\n    isp++;\n    input[isp] = file;\n  }\n}", "path": "source\\devices.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Attempt at writing some debugging functionality. This\n * is intended to display the current instruction and\n * the basic stack information as it exists when this\n * instruction is reached.\n *\n * Output takes a form like:\n *   AAAAA:   BBBBB            <C> DDDDD ---- <E> FFFFF\n *\n * Where:\n *   AAAAA   IP Address\n *   BBBBB   Instruction\n *   C       Depth of data stack\n *   DDDDD   Data stack contents\n *   E       Depth of address stack\n *   FFFFF   Address stack contents\n ******************************************************/\n", "func_signal": "void display_instruction(VM *vm)", "code": "{\n  int i;\n  char *names[] = { \"nop\",   \"lit\",   \"dup\",  \"drop\", \"swap\",  \"push\",         \\\n                    \"pop\",   \"call\",  \"jump\", \"ret\",  \">jump\", \"<jump\",        \\\n                    \"!jump\", \"=jump\", \"@\",    \"!\",    \"+\",     \"-\",     \"*\",   \\\n                    \"/mod\",  \"and\",   \"or\",   \"xor\",  \"<<\",    \">>\",    \"0;\",  \\\n                    \"1+\",    \"1-\",    \"in\",   \"out\",  \"wait\" };\n  i = 0;\n\n  /* Display the IP */\n  fprintf(stderr, \"%6i:   \", vm->ip);\n\n  /* And the instruction, finding a name from the lookup table */\n  if(VMOP <= NUM_OPS)\n    fprintf(stderr, \"%5s\", names[VMOP]);\n  else\n    fprintf(stderr, \"??? \");\n\n  /* Some instructions take a following value. Display this if necessary. */\n  if (VMOP == VM_LIT || VMOP == VM_CALL || VMOP == VM_JUMP || \\\n      VMOP == VM_LT_JUMP || VMOP == VM_GT_JUMP || VMOP == VM_EQ_JUMP || \\\n      VMOP == VM_NE_JUMP)\n  {\n    fprintf(stderr, \" %6i\", vm->image[vm->ip+1]);\n    i = 1;\n  }\n\n  /* Padding if following data isn't required. */\n  if (i == 0)\n    fprintf(stderr, \"       \");\n\n  fprintf(stderr, \"\\t\\t\");\n\n  /* Display the data stack */\n  fprintf(stderr, \"<%i> \", vm->sp);\n  for (i = vm->sp; i > 0; i--)\n    fprintf(stderr, \"%i \", vm->data[(vm->sp-i)+1]);\n\n  /* And the address stack */\n  fprintf(stderr, \" ----  <%i> \", vm->rsp);\n  for (i = vm->rsp; i > 0; i--)\n    fprintf(stderr, \"%i \", vm->address[(vm->rsp-i)+1]);\n\n  /* Whew, all done! */\n  fprintf(stderr, \"\\n\\r\");\n}", "path": "source\\disassemble.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| int main(int argc, char **argv)\n *|F|\n ******************************************************/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n  argc--, argv++;\n  if (!argc)\n  {\n    printf(\"Usage:\\n\");\n    printf(\"build <program>\\n\");\n    return 1;\n  }\n  else\n  {\n    while(argc)\n    {\n      make(*argv);\n      argc--;\n      argv++;\n    }\n  }\n  return 0;\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * This is used to load an image to the vm->image[]\n * buffer\n ******************************************************/\n", "func_signal": "int vm_load_image(VM *vm, char *image)", "code": "{\n  FILE *fp;\n  int x;\n\n  if ((fp = fopen(image, \"rb\")) == NULL)\n  {\n    return -1;\n  }\n\n  x = fread(&vm->image, sizeof(int), IMAGE_SIZE, fp);\n  fclose(fp);\n\n  return x;\n}", "path": "source\\loader.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| void make(char *fn)\n *|F| Make an executable\n *|F|\n ******************************************************/\n", "func_signal": "void make(char *fn)", "code": "{\n  char cmd[256];\n  *objs = *libs = *flags = 0;\n  if (build(fn, filedate(fn)))\n  {\n    snprintf(cmd, 256, \"gcc %s %s %s -o %s\", flags, libs, objs, fn);\n    puts(cmd);\n    if (system(cmd))\n      exit(1);\n  }\n  else\n  {\n    printf(\"'%s' is up to date.\\n\", fn);\n  }\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/* compiler initialisation */\n", "func_signal": "void comp_init (int tracemem)", "code": "{\n  /* allocate memory for trace and execution buffers */\n\n  comp_tbuffer = (uint8*) malloc (tracemem);\n  if (comp_tbuffer == NULL) { printf (\"comp_init: E1\\n\"); exit (-1); }\n\n  comp_cbuffer = (function) malloc (tracemem);\n  if (comp_cbuffer == NULL) { printf (\"comp_init: E2\\n\"); exit (-1); }\n\n  /* and for the private stacks */\n\n  comp_dstack = (int*) valloc (CSTACK_DEPTH);\n  comp_rstack = (int*) valloc (CSTACK_DEPTH);\n \n  /* save buffer lenghts */\n\n  comp_clen = tracemem;\n\n  /* correct page flags to make memory managers happy */\n\n  mprotect ((void*) comp_dstack,  CSTACK_DEPTH, PROT_READ | PROT_WRITE);\n  mprotect ((void*) comp_rstack,  CSTACK_DEPTH, PROT_READ | PROT_WRITE);\n  mprotect ((void*) comp_cbuffer, tracemem,     PROT_READ | PROT_WRITE | PROT_EXEC);\n}", "path": "source\\compiler.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Initialize the VM\n * This will clear the memory and stacks, and set the\n * registers to zero.\n ******************************************************/\n", "func_signal": "void init_vm(VM *vm)", "code": "{\n   int a;\n   vm->ip = 0;\n   vm->sp = 0;\n   vm->rsp = 0;\n   for (a = 0; a < STACK_DEPTH; a++)\n      vm->data[a] = 0;\n   for (a = 0; a < ADDRESSES; a++)\n      vm->address[a] = 0;\n   for (a = 0; a < IMAGE_SIZE; a++)\n      vm->image[a] = 0;\n   for (a = 0; a < 1024; a++)\n      vm->ports[a] = 0;\n\n   comp_init (COMP_BUFFER);\n}", "path": "source\\vm.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| void err(char *s, char *s2)\n *|F| Report errors and exit rebuild\n *|F|\n ******************************************************/\n", "func_signal": "void err(char *s, char *s2)", "code": "{\n  printf(\"ERROR: \");\n  printf(s, s2);\n  printf(\"\\n\");\n  exit(2);\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Display a character.\n *\n * Will clear the display if a negative value is passed\n ******************************************************/\n", "func_signal": "void dev_putch(int c)", "code": "{\n  if (c > 0)\n  {\n    putchar((char)c);\n  }\n  else\n  {\n    printf(\"\\033[2J\\033[1;1H\");\n  }\n}", "path": "source\\devices_ioctl.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Read a character from an input source\n ******************************************************/\n", "func_signal": "int dev_getch()", "code": "{\n  int c;\n\n  if ((c = getc(input[isp])) == EOF && input[isp] != stdin)\n  {\n    fclose(input[isp]);\n    isp--;\n    return 0;\n  }\n\n  if (c == EOF && input[isp] == stdin)\n  {\n    exit(0);\n  }\n\n  if (input[isp] != stdin)\n  {\n    if (c == 10 || c == 13 || c == 9)\n      c = 32;\n  }\n\n  if (c == 10)\n    c = 0;\n\n  return c;\n}", "path": "source\\devices.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| build(char *fn, time_t t)\n *|F| Build .o from .c\n *|F|\n ******************************************************/\n", "func_signal": "int build(char *fn, time_t t)", "code": "{\n  /* fn = basename. fno = basename.o. fnc = basename.c */\n  char fno[256];\n  char fnc[256];\n  char cmd[256];\n  int result = 0;\n  time_t tc, to;\n\n  snprintf(fnc, 256, \"%s.c\", fn);\n  snprintf(fno, 256, \"%s.o\", fn);\n  add(objs, fno);\n  tc = filedate(fnc);\n  to = filedate(fno);\n  result = dep(fnc, to) || (tc > to);\n  if (result)\n  {\n    snprintf (cmd, 256, GCC_COMPILE, flags, fnc);\n    puts(cmd);\n    if (system(cmd))\n      exit(1);\n  }\n  return result || (to > t);\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Get input from an input source\n ******************************************************/\n", "func_signal": "int dev_getch()", "code": "{\n  int c;\n\n  if ((c = getc(input[isp])) == EOF && input[isp] != stdin)\n  {\n    fclose(input[isp]);\n    isp--;\n    return 0;\n  }\n  if (c == EOF && input[isp] == stdin)\n  {\n    exit(0);\n  }\n\n  if (input[isp] != stdin)\n  {\n    if (c == 10 || c == 13 || c == 9)\n     c = 32;\n  }\n\n  return c;\n}", "path": "source\\devices_ioctl.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Initialize real hardware devices\n ******************************************************/\n", "func_signal": "void dev_init(int level)", "code": "{\n  if (level == 2)\n  {\n    tcgetattr(0, &old_termios);\n    new_termios = old_termios;\n    new_termios.c_iflag &= ~(BRKINT+ISTRIP+IXON+IXOFF);\n    new_termios.c_iflag |= (IGNBRK+IGNPAR);\n    new_termios.c_lflag &= ~(ICANON+ISIG+IEXTEN+ECHO);\n    new_termios.c_cc[VMIN] = 1;\n    new_termios.c_cc[VTIME] = 0;\n    tcsetattr(0, TCSANOW, &new_termios);\n  }\n  if (level == 1)\n  {\n    isp = 0;\n    input[isp] = stdin;\n  }\n}", "path": "source\\devices_ioctl.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| time_t filedate(char *fn)\n *|F|\n ******************************************************/\n", "func_signal": "time_t filedate(char *fn)", "code": "{\n  struct stat buf;\n  if (-1 == stat(fn, &buf))\n    return 0;\n  return buf.st_mtime;\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Add a file to the input stack\n ******************************************************/\n", "func_signal": "void dev_include(char *s)", "code": "{\n  FILE *file;\n\n  file = fopen(s, \"r\");\n\n  if (file)\n  {\n    isp++;\n    input[isp] = file;\n  }\n}", "path": "source\\devices_ioctl.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| int dep(char *fn, time_t t)\n *|F| Check the dependencies in a .c or .h file\n *|F|\n ******************************************************/\n", "func_signal": "int dep(char *fn, time_t t)", "code": "{\n  char buf[256], *p;\n  char s[256], *q;\n  FILE *f;\n  int result = 0;\n\n  f = fopen(fn, \"r\");\n  if (!f)\n    err(\"Can't open '%s'\", fn);\n  while(fgets(buf, 256, f))\n  {\n    if (!strncasecmp(buf, \"//LIBS\", 6))\n      for(p = buf + 6; *p;)\n      {\n        for(; isspace(*p); p++);\n        for(q = p; !isspace(*q); q++);\n        *q++ = 0;\n        snprintf(s, 256, \"-l%s\", p);\n        p = q;\n        add(libs, s);\n      }\n    else if (!strncasecmp(buf, \"//FLAGS\", 7))\n      for(p = buf + 7; *p;)\n      {\n        for(; isspace(*p); p++);\n        for(q = p; !isspace(*q); q++);\n        *q++ = 0;\n        snprintf(s, 256, \"%s\", p);\n        p = q;\n        add(flags, s);\n      }\n    else if (!strncasecmp(buf, \"//USES\", 6))\n      for (p = buf + 6; *p;)\n      {\n        for(; isspace(*p); p++);\n        for(q = p; !isspace(*q); q++);\n        *q++ = 0;\n        result |= build(p, t);\n        p = q;\n      }\n    else if (!strncasecmp(buf, \"#include\", 8))\n    {\n      for (p = buf + 8; isspace(*p); p++);\n      if (*p++ == '\"')\n      {\n        strtok(p, \"\\\"\");\n        if (filedate(p) > t)\n          result = 1;\n        result |= dep(p, t);\n      }\n    }\n  }\n  fclose(f);\n  return result;\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n *|F| void add(char *dst, char *src)\n *|F| Append src to dst, if it's not already in the list.\n *|F|\n ******************************************************/\n", "func_signal": "void add(char *dst, char *src)", "code": "{\n  char *p = dst;\n  int l = strlen(src);\n\n  /* Search for src in dst (whole word) */\n  while(*p) {\n    if (!strncmp(p, src, l) && !p[l])\n      return;\n    for (; *p && !isspace(*p); p++);   /* skip word */\n    for (; *p && isspace(*p); p++);    /* skip blanks */\n  }\n\n  /* If not found, append src to dst */\n  *p++ = ' ';\n  strcpy(p, src);\n}", "path": "tools\\build.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Prepare real I/O hardware for the emulator\n ******************************************************/\n", "func_signal": "void dev_init(int level)", "code": "{\n  if (level == OUTPUT)\n  {\n    initscr();                /* initialize the curses library */\n    cbreak();                 /* take input chars one at a time, no wait for \\n */\n    scrollok(stdscr, TRUE);   /* Allow the display to scroll */\n  }\n  if (level == INPUT)\n  {\n    isp = 0;\n    input[isp] = stdin;\n  }\n}", "path": "source\\devices.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * Process the entire vm-code image\n ******************************************************/\n", "func_signal": "void vm_process(VM *vm)", "code": "{\n  /* register cache */\n\n  register int a, b;\n  register int acc;\n\n  /* this is a common stream for compiling trace returns on a = 0\n     (see compilation of opcode: 25) */\n\n  int cVM_ZERO_TAKEN = label\n                       tba\n                       pldb                                     \n                       retc\n \n  /* start interpreter loop */\n\n  NEXT;\n\n  /* interpreter primitives */\n\n     \t\t\t\t/***************************************************/\n    \t\t\t\t/* NOP    Does Nothing. Used for padding           */\n    \t\t\t\t/* Opcode: 0        Stack:  -       Address: -     */\n     \t\t\t\t/***************************************************/\n\n  fVM_NOP: vm->ip++; NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* LIT    Push the value in the following cell to  */\n    \t\t\t\t/*        the stack                                */\n    \t\t\t\t/* Opcode: 1 n      Stack: -n       Address: -     */\n     \t\t\t\t/***************************************************/\n\n  fVM_LIT: vm->sp++;\n           vm->ip++;\n           TOS = acc;\n           acc = VMOP;\n\t       vm->ip++;\n           NEXT;\n\n\t\t\t    \t/***************************************************/\n    \t\t\t\t/* DUP    Duplicate the value on the top of the    */\n    \t\t\t\t/*        stack                                    */\n    \t\t\t\t/* Opcode: 2        Stack: n-nn     Address: -     */\n\t\t\t    \t/***************************************************/ \n\n  fVM_DUP: vm->sp++;\n           vm->data[vm->sp] = acc;\n\t       vm->ip++;\n           NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* DROP   Drop the value on the top of the stack   */\n    \t\t\t\t/* Opcode: 3        Stack: n-       Address: -     */\n    \t\t\t\t/***************************************************/\n\n  fVM_DROP: acc = vm->data[vm->sp];\n            vm->sp--;\n            vm->ip++; \n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* SWAP   Exchange the top two values on the stack */\n    \t\t\t\t/* Opcode: 4        Stack: xy-yx    Address: -     */\n    \t\t\t\t/***************************************************/\n\n  fVM_SWAP: a = TOS;\n            TOS = acc;\n            acc = a;\n\t        vm->ip++; \n            NEXT;\n \n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* PUSH   Move the top value on the stack to the   */\n    \t\t\t\t/*        address stack. Remove it from the data   */\n    \t\t\t\t/*        stack.                                   */\n    \t\t\t\t/* Opcode: 5        Stack: n-       Address: -n    */\n    \t\t\t\t/***************************************************/\n\n  fVM_PUSH: vm->rsp++;\n            TORS = acc;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* POP    Move the top value from the address      */\n    \t\t\t\t/*        stack to the data stack. Remove it from  */\n    \t\t\t\t/*        the address stack.                       */\n    \t\t\t\t/* Opcode: 6        Stack: -n       Address: n-    */\n   \t\t\t\t    /***************************************************/\n\n  fVM_POP: vm->sp++;\n           TOS = acc;\n           acc = TORS;\n           vm->rsp--;\n\t       vm->ip++;\n           NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* CALL   Call a subroutine whose address is given */\n    \t\t\t\t/*        in the following cell. Push the address  */\n    \t\t\t\t/*        following this instruction to the address*/\n    \t\t\t\t/*         stack.                                  */\n    \t\t\t\t/* Opcode: 7 a       Stack: -      Address: -a     */\n    \t\t\t\t/***************************************************/\n\n  fVM_CALL: vm->ip++;\n            vm->rsp++;\n            TORS = (vm->ip);\n            vm->ip = vm->image[vm->ip];\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* JUMP   Unconditional jump to the address given  */\n    \t\t\t\t/*        in the following cell.                   */\n    \t\t\t\t/* Opcode: 8 a       Stack: -       Address: -     */\n    \t\t\t\t/***************************************************/\n\n  fVM_JUMP: vm->ip++;\n            vm->ip = VMOP;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* ;      Return from a subroutine. Control is     */\n    \t\t\t\t/*        passed to the address on the top of the  */\n    \t\t\t\t/*        address stack.                           */\n    \t\t\t\t/* Opcode: 9         Stack: -       Address: a-    */\n    \t\t\t\t/***************************************************/\n\n  fVM_RETURN: vm->ip = (TORS+1);\n              vm->rsp--;\n              NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* >JUMP  Jump to the address in the following     */\n    \t\t\t\t/*        cell if NOS > TOS.                       */\n    \t\t\t\t/* Opcode: 10 a      Stack: xy-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n  fVM_GT_JUMP: vm->ip++;\n               if(TOS > acc)\n                 vm->ip = VMOP;\n               else vm->ip++;\n               vm->sp--;\n               acc = vm->data[vm->sp];\n               vm->sp--;\n               NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* <JUMP  Jump to the address in the following     */\n    \t\t\t\t/*        cell if NOS < TOS.                       */\n    \t\t\t\t/* Opcode: 11 a      Stack: xy-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_LT_JUMP: vm->ip++;\n         \t    if(TOS < acc)\n                  vm->ip = VMOP;\n                else vm->ip++;\n                vm->sp--;\n                acc = vm->data[vm->sp];\n                vm->sp--;\n                NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* !JUMP  Jump to the address in the following     */\n    \t\t\t\t/*        cell if NOS <> TOS.                      */\n    \t\t\t\t/* Opcode: 12 a      Stack: xy-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_NE_JUMP: vm->ip++;\n         \t    if(acc != TOS)\n                  vm->ip = VMOP;\n                else vm->ip++;\n                vm->sp--;\n                acc = vm->data[vm->sp];\n                vm->sp--;\n                NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* =JUMP  Jump to the address in the following     */\n    \t\t\t\t/*        cell if NOS = TOS.                       */\n    \t\t\t\t/* Opcode: 13 a      Stack: xy-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_EQ_JUMP: vm->ip++;\n         \t    if(acc == TOS)\n                  vm->ip = VMOP;\n                else vm->ip++;\n                vm->sp--;\n                acc = vm->data[vm->sp];\n                vm->sp--;\n                NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* @      Fetch a value from a memory location     */\n    \t\t\t\t/* Opcode: 14        Stack: a-n     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_FETCH: acc = vm->image[acc];\n\t          vm->ip++;\n              NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* !      Store a value to a memory location       */\n    \t\t\t\t/* Opcode: 15        Stack: na-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_STORE: vm->image[acc] = TOS;\n              vm->sp--;\n              acc = vm->data[vm->sp];\n              vm->sp--;\n\t          vm->ip++;\n              NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* +      Add TOS and NOS, leaving the result      */\n    \t\t\t\t/* Opcode: 16        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_ADD: TOS += acc;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n   \t\t\t \t    /* -      Subtract TOS from NOS, leaving the result*/\n    \t\t\t\t/* Opcode: 17        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_SUB: TOS -= acc;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* *      Multiply TOS by NOS, leaving the result  */\n    \t\t\t\t/* Opcode: 18        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_MUL: TOS *= acc;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* /MOD   Divide NOS by TOS, leaving the quotient  */\n    \t\t\t\t/*        and remainder.                           */\n    \t\t\t\t/* Opcode: 19        Stack: xy-qr   Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_DIVMOD: a = acc;\n               b = TOS;\n               acc = b / a;\n               TOS = b % a;\n\t           vm->ip++;\n               NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* AND    Perform a bitwise and operation on TOS   */\n    \t\t\t\t/*        and NOS.                                 */\n    \t\t\t\t/* Opcode: 20        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_AND: a = acc;\n            b = TOS;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            acc = a & b;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* OR     Perform a bitwise or operation on TOS    */\n    \t\t\t\t/*        and NOS.                                 */\n    \t\t\t\t/* Opcode: 21        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_OR: a = acc;\n           b = TOS;\n           acc = vm->data[vm->sp];\n           vm->sp--;\n           acc = a | b;\n\t       vm->ip++;\n           NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* XOR    Perform a bitwise xor operation on TOS   */\n    \t\t\t\t/*        and NOS.                                 */\n    \t\t\t\t/* Opcode: 22        Stack: xy-z    Address: -     */\n   \t\t\t \t    /***************************************************/\n\n   fVM_XOR: a = acc;\n            b = TOS;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            acc = a ^ b;\n\t        vm->ip++;\n            NEXT;\n\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* <<    Shift NOS left by TOS bits.               */\n    \t\t\t\t/* Opcode: 23        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_SHL: a = acc;\n            b = TOS;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            acc = b << a;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* >>    Shift NOS right by TOS bits.              */\n    \t\t\t\t/* Opcode: 24        Stack: xy-z    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_SHR: a = acc;\n            b = TOS;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            acc = b >>= a;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* 0;    Return from a subroutine if TOS = 0.      */\n    \t\t\t\t/*       If TOS = 0, DROP TOS.                     */\n    \t\t\t\t/*       If TOS <> 0, do nothing                   */\n    \t\t\t\t/* Opcode: 25         Stack: n-     Address: a-    */\n    \t\t\t\t/*                    Stack: n-n    Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_ZERO_EXIT: if (acc == 0)\n         \t      {\n                    acc = vm->data[vm->sp];\n                    vm->sp--;\n           \t        vm->ip = (TORS+1);\n           \t        vm->rsp--;\n                  }\n\t              else vm->ip++;\n         \t      NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* 1+    Increase TOS by 1                         */\n    \t\t\t\t/* Opcode: 26        Stack: x-y     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_INC: acc += 1;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* 1-    Decrease TOS by 1                         */\n   \t\t\t\t    /* Opcode: 27        Stack: x-y     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_DEC: acc -= 1;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* IN    Read a value from an I/O port             */\n    \t\t\t\t/* Opcode: 28        Stack: p-n     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_IN: a = acc;\n           acc = vm->ports[a];\n           vm->ports[a] = 0;\n\t       vm->ip++;\n           NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* OUT   Send a value to an I/O port               */\n    \t\t\t\t/* Opcode: 29        Stack: np-     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_OUT: vm->ports[0] = 0;\n            vm->ports[acc] = TOS;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n            acc = vm->data[vm->sp];\n            vm->sp--;\n\t        vm->ip++;\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* WAIT  Wait for an I/O event to occur.           */\n    \t\t\t\t/* Opcode: 30        Stack: -       Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_WAIT: if (vm->ports[0] == 1)\n             {\n               vm->ip++;\n               NEXT;\n             }\n\n             /* Input */\n             if (vm->ports[0] == 0 && vm->ports[1] == 1)\n             {\n               vm->ports[1] = dev_getch();\n               vm->ports[0] = 1;\n               dev_refresh ();\n             }\n\n             /* Output (character generator) */\n             if (vm->ports[2] == 1)\n             {\n               dev_putch(acc);\n               acc = vm->data[vm->sp];\n               vm->sp--;\n               vm->ports[2] = 0;\n               vm->ports[0] = 1;\n               dev_refresh ();\n             }\n\n             /* Save Image */\n             if (vm->ports[4] == 1)\n             {\n               vm_save_image(vm, vm->filename);\n               vm->ports[4] = 0;\n               vm->ports[0] = 1;\n             }\n\n             /* Capabilities */\n             if (vm->ports[5] == -1)\n             {\n               vm->ports[5] = IMAGE_SIZE;\n               vm->ports[0] = 1;\n             }\n\n             /* The framebuffer related bits aren't supported, so return 0 for them. */\n             if (vm->ports[5] == -2 || vm->ports[5] == -3 || vm->ports[5] == -4)\n             {\n               vm->ports[5] = 0;\n               vm->ports[0] = 1;\n             }\n\n             /* Data & Return Stack Depth */\n             if (vm->ports[5] == -5)\n             {\n               vm->ports[5] = vm->sp;\n               vm->ports[0] = 1;\n             }\n             if (vm->ports[5] == -6)\n             {\n               vm->ports[5] = vm->rsp;\n               vm->ports[0] = 1;\n             }\n\t         vm->ip++;\n             NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* STREAM  Compile stream to trace.                */\n    \t\t\t\t/* Opcode: 31        Stack: - a     Address: -     */\n    \t\t\t\t/***************************************************/\n\n   fVM_STREAM: vm->sp++;\n               TOS = acc;\n               acc = comp_cofs;\n               CNEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* AOT  execute trace                              */\n    \t\t\t\t/* Opcode: 32     Stack: a tos sos - i  Address: - */\n    \t\t\t\t/***************************************************/\n\n   fVM_AOT: vm->ip++;\n            a = vm->data[vm->sp];\n            b = vm->data[vm->sp-1];\n            vm->sp = vm->sp-1;\n            acc = execute (acc, a, b)\n            NEXT;\n\n    \t\t\t\t/***************************************************/\n    \t\t\t\t/* TAIL  return current trace reference            */\n    \t\t\t\t/* Opcode: 33     Stack: a tos sos - i  Address: - */\n    \t\t\t\t/***************************************************/\n\n   fVM_TAIL: vm->ip++;\n             vm->sp++;\n             TOS = acc;\n             acc = comp_cofs;\n             NEXT;\n\n   /* compiler routines */\n\n                    /***************************************************\n                     * compiler routines:                              *\n                     *                                                 *\n                     *         a : first accululator,                  *\n                     *         b : second accumulator,                 *\n                     *         d : current data-stack pointer          *\n                     *         r : current return-stack pointer        *\n                     *                                                 *\n                     *         p : internal program counter            *\n                     *         s : internal return-address stack       *\n                     *         f : internal flag register              *\n                     *                                                 *\n                     * (s+), (r+), (d+) : store register onto TOS and  *\n                     *                    post increment pointer       *\n                     * (-s), (-r), (-d) : decrement pointer and load   *\n                     *                    TOS into register            *\n                     *                                                 *\n                     *          <, >, = : conditional execution        *\n                     *                c : test condition               *\n                     *                m : memory access                *\n                     *                                                 *\n                     *             VMOP : immediate parameter          *\n                     ***************************************************/\n\n   cVM_NOP:     CNEXT;\n\n   cVM_LIT:     vm->ip++;\n                psbd                                   /* (d+) = b    */ \n                tab                                    /*    b = a    */\n                lia  (VMOP)                            /*    a = VMOP */\n                CNEXT;\n\n   cVM_DUP:     psbd                                   /* (d+) = b    */  \n                tab                                    /*    b = a    */\n                CNEXT;\n\n   cVM_DROP:    tba                                    /*    a = b    */\n                pldb                                   /*    b = (-d) */\n                CNEXT;\n\n   cVM_SWAP:    swap                                   /*    a <-> b */\n                CNEXT;\n\n\n   cVM_PUSH:    psar                                   /* (r+) = a    */ \n                tba                                    /*    a = b    */\n                pldb                                   /*    b = (-d) */\n                CNEXT;\n\n   cVM_POP:     psbd                                   /* (d+) = b    */ \n                tab                                    /*    b = a    */\n                plra                                   /*    a = (-r) */\n                CNEXT;\n\n   cVM_CALL:    vm->ip++;\n                ci   (VMOP)                            /* (s+) = p    */\n                CNEXT;                                 /*    p = VMOP */\n\n   cVM_JUMP:    vm->ip++;\n                bi   (VMOP)                            /*    p = VMOP */\n                CNEXT;\n\n   cVM_RETURN:  vm->ip++;\n                retc                                   /*    p = (-s) */\n                NEXT;\n\n   cVM_GT_JUMP: vm->ip++;\n                cmpa                                   /*       f = c.a  */\n                plda                                   /*       a = (-d) */\n                pldb                                   /*       b = (-d) */ \n                bigr (VMOP)                            /* f.> : p = VMOP */\n                CNEXT;                                    \n\n   cVM_LT_JUMP: vm->ip++;\n                cmpa                                   /*       f = c.a  */\n                plda                                   /*       a = (-d) */\n                pldb                                   /*       b = (-d) */ \n                bile (VMOP)                            /* f.< : p = VMOP */\n                CNEXT;                                    \n\n   cVM_NE_JUMP: vm->ip++;\n                cmpa                                   /*       f = c.a  */\n                plda                                   /*       a = (-d) */\n                pldb                                   /*       b = (-d) */ \n                bigr (VMOP)                            /* f.> : p = VMOP */\n                bile (VMOP)                            /* f.< : p = VMOP */\n                CNEXT;                                    \n\n   cVM_EQ_JUMP: vm->ip++;\n                cmpa                                   /*       f = c.a  */\n                plda                                   /*       a = (-d) */\n                pldb                                   /*       b = (-d) */ \n                bieq (VMOP)                            /* f.= : p = VMOP */\n                CNEXT;                                    \n\n   cVM_FETCH:   psbd                                   /* (d+) = b    */  \n                tab                                    /*    b = a    */\n                ldra                                   /*    a = m.b  */\n                pldb                                   /*    b = (-d) */\n                CNEXT;\n\n   cVM_STORE:   stra                                   /*  m.b = a    */\n                plda                                   /*    a = (-d) */\n                pldb                                   /*    b = (-d) */\n                CNEXT;\n\n   cVM_ADD:     adda                                   /*    a = a + b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_SUB:     suba                                   /*    a = a - b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_MUL:     mula                                   /*    a = a * b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_DIVMOD:  diva                                   /*    a = a / b */\n                lib  (0)                               /*    b = 0     */\n                CNEXT;\n\n   cVM_AND:     anda                                   /*    a = a & b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_OR:      gora                                   /*    a = a | b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_XOR:     xora                                   /*    a = a ^ b */\n                pldb                                   /*    b = (-d)  */\n                CNEXT;\n\n   cVM_SHL:     shla                                   /*    a = a << b */\n                pldb                                   /*    b = (-d)   */\n                CNEXT;\n \n   cVM_SHR:     shra                                   /*    a = a >> b */\n                pldb                                   /*    b = (-d)   */\n                CNEXT;\n\n   cVM_INC:     inca                                   /*    a = a + 1 */\n                CNEXT;\n\n   cVM_DEC:     deca                                   /*    a = a - 1 */\n                CNEXT;\n\n   cVM_ZERO_EXIT: biza (cVM_ZERO_TAKEN)                /*  a=0 : p = cVM.. */                 \n                  CNEXT;\n\n   cVM_IN:      printf (\"cVM_IN: illegal stream opcode !\\n\");\n                exit (-1);\n\n   cVM_OUT:     printf (\"cVM_OUT: illegal stream opcode !\\n\");\n                exit (-1);\n\n   cVM_WAIT:    printf (\"cVM_WAIT: illegal stream opcode !\\n\");\n                exit (-1);\n\n   /* compiler routines for the extended-instruction set */\n\n   cVM_LIA:     vm->ip++;\n                lia (VMOP)                             /*    a = VMOP */\n                CNEXT;\n\n   cVM_PSAD:    psad                                   /* (d+) = a    */\n                CNEXT;\n\n   cVM_PSAR:    psar                                   /* (r+) = a    */\n                CNEXT;\n\n   cVM_PLDA:    plda                                   /*    a = (-d) */\n                CNEXT;\n\n   cVM_PLRA:    plra                                   /*    a = (-r) */\n                CNEXT;\n\n   cVM_TDA:     tda                                    /*    a = d    */\n                CNEXT;\n\n   cVM_TRA:     tra                                    /*    a = r    */\n                CNEXT;\n\n   cVM_TAD:     tad                                    /*    d = a    */\n                CNEXT;\n\n   cVM_TAR:     tar                                    /*    r = a    */\n                CNEXT;\n\n   cVM_TAB:     tab                                    /*    b = a    */\n                CNEXT;\n\n   cVM_TBA:     tba                                    /*    a = b    */\n                CNEXT;\n\n   cVM_ADDA:    adda                                   /*    a = a + b */\n                CNEXT;\n\n   cVM_SUBA:    suba                                   /*    a = a - b */\n                CNEXT;\n\n   cVM_DIVA:    diva                                   /*    a = a / b */\n                CNEXT;\n\n   cVM_MULA:    mula                                   /*    a = a * b */\n                CNEXT;\n\n   cVM_INCA:    inca                                   /*    a = a + 1 */\n                CNEXT;\n\n   cVM_DECA:    deca                                   /*    a = a - 1 */\n                CNEXT;\n\n   cVM_ANDA:    anda                                   /*    a = a & b */\n                CNEXT;\n\n   cVM_GORA:    gora                                   /*    a = a | b */\n                CNEXT;\n\n   cVM_XORA:    xora                                   /*    a = a ^ b */\n                CNEXT;\n\n   cVM_SHLA:    shla                                   /*    a = a << b */\n                CNEXT;\n\n   cVM_SHRA:    shra                                   /*    a = a >> b */\n                CNEXT;\n\n   cVM_SLIA:    vm->ip++;\n                slia (VMOP)                            /*    a = a << VMOP */\n                CNEXT;\n\n   cVM_SRIA:    vm->ip++;\n                sria (VMOP)                            /*    a = a >> VMOP */\n                CNEXT;\n\n   cVM_CMPA:    cmpa                                   /*    f = c.a    */\n                CNEXT;\n\n   cVM_LDRA:    ldra                                   /*    a = m.b    */\n                CNEXT;\n\n   cVM_STRA:    stra                                   /*  m.b = a      */\n                CNEXT;\n\n   cVM_LIB:     vm->ip++;\n                lib  (VMOP)                            /*    b = VMOP   */\n                CNEXT;\n\n   cVM_PSBD:    psbd                                   /* (d+) = b      */\n                CNEXT;\n\n   cVM_PSBR:    psbr                                   /* (r+) = b      */\n                CNEXT;\n\n   cVM_PLDB:    pldb                                   /*    b = (-d)   */\n                CNEXT;\n\n   cVM_PLRB:    plrb                                   /*    b = (-r)   */\n                CNEXT;\n\n   cVM_TDB:     tdb                                    /*    b = d      */\n                CNEXT;\n\n   cVM_TRB:     trb                                    /*    b = r      */\n                CNEXT;\n\n   cVM_ADDB:    addb                                   /*    b = b + a  */\n                CNEXT;\n\n   cVM_SUBB:    subb                                   /*    b = b - a  */\n                CNEXT;\n\n   cVM_DIVB:    divb                                   /*    b = b / a  */\n                CNEXT;\n\n   cVM_MULB:    mulb                                   /*    b = b / a  */\n                CNEXT;\n\n   cVM_INCB:    incb                                   /*    b = b + 1  */\n                CNEXT;\n\n   cVM_DECB:    decb                                   /*    b = b - 1  */\n                CNEXT;\n\n   cVM_ANDB:    andb                                   /*    b = b & a  */\n                CNEXT;\n\n   cVM_GORB:    gorb                                   /*    b = b | a  */\n                CNEXT;\n\n   cVM_XORB:    xorb                                   /*    b = b ^ a  */\n                CNEXT;\n\n   cVM_CMPB:    cmpb                                   /*    f = c.b    */\n                CNEXT;\n\n   cVM_SHLB:    shlb                                   /*    b = b << a */\n                CNEXT;\n\n   cVM_SLIB:    vm->ip++;\n                slib (VMOP)                            /*    b = b << VMOP */\n                CNEXT;\n\n   cVM_SHRB:    shrb                                   /*    b = b >> a */\n                CNEXT;\n\n   cVM_SRIB:    vm->ip++;\n                srib (VMOP)                            /*    b = b >> VMOP */\n                CNEXT;\n\n   cVM_LDRB:    ldrb                                   /*    b = m.a   */\n                CNEXT;\n\n   cVM_STRB:    strb                                   /*  m.a = b     */\n                CNEXT;\n\n   cVM_CI:      vm->ip++;\n                ci   (VMOP)                            /* (s+) = p     */\n                CNEXT;                                 /*    p = VMOP  */\n\n   cVM_CIEQ:    vm->ip++;                              \n                cieq (VMOP)                            /*  f.= : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CIGR:    vm->ip++;                              \n                cigr (VMOP)                            /*  f.> : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CILE:    vm->ip++;                              \n                cile (VMOP)                            /*  f.< : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CNZA:    vm->ip++;                              /*           f = c.a  */\n                cnza (VMOP)                            /*  f.! : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CIZA:    vm->ip++;                              /*           f = c.a  */\n                ciza (VMOP)                            /*  f.0 : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CNZB:    vm->ip++;                              /*           f = c.b  */\n                cnzb (VMOP)                            /*  f.! : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CIZB:    vm->ip++;                              /*           f = c.b  */\n                cizb (VMOP)                            /*  f.0 : (s+) = p    */\n                CNEXT;                                 /*           p = VMOP */\n\n   cVM_CRA:     cra                                    /* (s+) = p     */\n                CNEXT;                                 /*    p = a     */\n\n   cVM_CRB:     crb                                    /* (s+) = p     */\n                CNEXT;                                 /*    p = b     */\n\n   cVM_BRA:     bra                                    /*    p = a     */\n                CNEXT;\n\n   cVM_BRB:     brb                                    /*    p = b     */\n                CNEXT;\n\n   cVM_BI:      vm->ip++;                              \n                bi   (VMOP)                            /*    p = VMOP  */\n                CNEXT;\n\n   cVM_BIEQ:    vm->ip++;                              /*        f = c.a   */\n                bieq (VMOP)                            /*  f.= : p = VMOP  */\n                CNEXT;\n\n   cVM_BIGR:    vm->ip++;                              /*        f = c.a   */\n                bigr (VMOP)                            /*  f.> : p = VMOP  */\n                CNEXT;\n\n   cVM_BILE:    vm->ip++;                              /*        f = c.a   */\n                bile (VMOP)                            /*  f.< : p = VMOP  */\n                CNEXT;\n\n   cVM_BNZA:    vm->ip++;                              /*        f = c.a   */\n                bnza (VMOP)                            /*  f.! : p = VMOP  */\n                CNEXT;\n\n   cVM_BIZA:    vm->ip++;                              /*        f = c.a   */\n                biza (VMOP)                            /*  f.= : p = VMOP  */\n                CNEXT;\n\n   cVM_BNZB:    vm->ip++;                              /*        f = c.b   */\n                bnzb (VMOP)                            /*  f.! : p = VMOP  */\n                CNEXT;\n\n   cVM_BIZB:    vm->ip++;                              /*        f = c.b   */\n                bizb (VMOP)                            /*  f.= : p = VMOP  */\n                CNEXT;\n\n   cVM_LID:     vm->ip++;\n                lia (VMOP)                             /*    d = VMOP  */\n                CNEXT;\n\n   cVM_INCD:    incd                                   /*    d = d + 1 */\n                CNEXT;\n\n   cVM_DECD:    decd                                   /*    d = d - 1 */\n                CNEXT;\n\n   cVM_BNZD:    vm->ip++;                              /*        f = c.m.d */\n                bnzd (VMOP)                            /*  f.! : p = VMOP  */\n                CNEXT;\n\n   cVM_BIZD:    vm->ip++;                              /*        f = c.m.d */\n                bizd (VMOP)                            /*  f.= : p = VMOP  */\n                CNEXT;\n\n   cVM_ADIA:    vm->ip++;                              \n                adia (VMOP)                            /*        a = a + VMOP */\n                CNEXT;\n\n   cVM_SBIA:    vm->ip++;                              \n                sbia (VMOP)                            /*        a = a - VMOP */\n                CNEXT;\n\n   cVM_ANIA:    vm->ip++;                              \n                ania (VMOP)                            /*        a = a & VMOP */\n                CNEXT;\n\n   cVM_ORIA:    vm->ip++;                              \n                oria (VMOP)                            /*        a = a | VMOP */\n                CNEXT;\n\n   cVM_XOIA:    vm->ip++;                              \n                xoia (VMOP)                            /*        a = a ^ VMOP */\n                CNEXT;\n\n   cVM_CPIA:    vm->ip++;                              /*        f = c.VMOP.b */\n                cpia (VMOP)                            \n                CNEXT;\n\n   cVM_ADIB:    vm->ip++;                              \n                adib (VMOP)                            /*        b = b + VMOP */\n                CNEXT;\n\n   cVM_SBIB:    vm->ip++;                              \n                sbib (VMOP)                            /*        b = b - VMOP */\n                CNEXT;\n\n   cVM_ANIB:    vm->ip++;                              \n                anib (VMOP)                            /*        b = b & VMOP */\n                CNEXT;\n\n   cVM_ORIB:    vm->ip++;                              \n                orib (VMOP)                            /*        b = b | VMOP */\n                CNEXT;\n\n   cVM_XOIB:    vm->ip++;                              \n                xoib (VMOP)                            /*        b = b ^ VMOP */\n                CNEXT;\n\n   cVM_CPIB:    vm->ip++;                              /*        f = c.VMOP.b */\n                cpib (VMOP)                            \n                CNEXT;\n\n   cVM_LISA:    vm->ip++;\n                lisa (VMOP)                            /*        a = d.VMOP   */\n                CNEXT;\n\n   cVM_LISB:    vm->ip++;\n                lisb (VMOP)                            /*        b = d.VMOP   */\n                CNEXT;\n\n   cVM_SISA:    vm->ip++;\n                sisa (VMOP)                            /*   d.VMOP = a  */\n                CNEXT;\n\n   cVM_SISB:    vm->ip++;\n                sisb (VMOP)                            /*   d.VMOP = b  */\n                CNEXT;\n\n   cVM_INIS:    vm->ip++;\n                inis (VMOP)                            /*   d.VMOP = d.VMOP+1 */\n                CNEXT;\n\n   cVM_DEIS:    vm->ip++;\n                deis (VMOP)                            /*   d.VMOP = d.VMOP-1 */\n                CNEXT;\n\n   cVM_DEFAULT: printf (\"Instruction: %i : \",vm->image[vm->ip]);\n\t\tprintf (\"Illegal opcode in stream detected !\\n\");\n   \n   fVM_DEFAULT: vm->ip = IMAGE_SIZE;\n}", "path": "source\\vm.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/******************************************************\n * This is used to save an image from the vm->image[]\n * buffer\n ******************************************************/\n", "func_signal": "int vm_save_image(VM *vm, char *image)", "code": "{\n  FILE *fp;\n  int x;\n\n  if ((fp = fopen(image, \"wb\")) == NULL)\n  {\n    fprintf(stderr, \"Sorry, but I couldn't open %s\\n\", image);\n    dev_cleanup();\n    exit(-1);\n  }\n\n  x = fwrite(&vm->image, sizeof(int), IMAGE_SIZE, fp);\n  fclose(fp);\n\n  return x;\n}", "path": "source\\loader.c", "repo_name": "Mat2/extended-ngaro", "stars": 8, "license": "other", "language": "c", "size": 309}
{"docstring": "/*\n * Get a list of all interfaces that are present and that we probe okay.\n * Returns -1 on error, 0 otherwise.\n * The list, as returned through \"alldevsp\", may be null if no interfaces\n * were up and could be opened.\n */\n", "func_signal": "int pcap_findalldevs (pcap_if_t **alldevsp, char *errbuf)", "code": "{\n  struct device     *dev;\n  struct sockaddr_ll sa_ll_1, sa_ll_2;\n  struct sockaddr   *addr, *netmask, *broadaddr, *dstaddr;\n  pcap_if_t *devlist = NULL;\n  int       ret = 0;\n  size_t    addr_size = sizeof(struct sockaddr_ll);\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->probe);\n\n    if (!(*dev->probe)(dev))\n       continue;\n\n    PCAP_ASSERT (dev->close);  /* set by probe routine */\n    FLUSHK();\n    (*dev->close) (dev);\n\n    memset (&sa_ll_1, 0, sizeof(sa_ll_1));\n    memset (&sa_ll_2, 0, sizeof(sa_ll_2));\n    sa_ll_1.sll_family = AF_PACKET;\n    sa_ll_2.sll_family = AF_PACKET;\n\n    addr      = (struct sockaddr*) &sa_ll_1;\n    netmask   = (struct sockaddr*) &sa_ll_1;\n    dstaddr   = (struct sockaddr*) &sa_ll_1;\n    broadaddr = (struct sockaddr*) &sa_ll_2;\n    memset (&sa_ll_2.sll_addr, 0xFF, sizeof(sa_ll_2.sll_addr));\n\n    if (pcap_add_if(&devlist, dev->name, dev->flags,\n                    dev->long_name, errbuf) < 0)\n    {\n      ret = -1;\n      break;\n    }\n    if (add_addr_to_iflist(&devlist,dev->name, dev->flags, addr, addr_size,\n                           netmask, addr_size, broadaddr, addr_size,\n                           dstaddr, addr_size, errbuf) < 0)\n    {\n      ret = -1;\n      break;\n    }\n  }\n\n  if (devlist && ret < 0)\n  {\n    pcap_freealldevs (devlist);\n    devlist = NULL;\n  }\n  else\n  if (!devlist)\n     strcpy (errbuf, \"No drivers found\");\n\n  *alldevsp = devlist;\n  return (ret);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * get_rxbuf() routine (in locked code) is called from IRQ handler\n * to request a buffer. Interrupts are disabled and we have a 32kB stack.\n */\n", "func_signal": "BYTE *get_rxbuf (int len)", "code": "{\n  int idx;\n\n  if (len < ETH_MIN || len > ETH_MAX)\n     return (NULL);\n\n  idx = pktq_in_index (&active_dev->queue);\n\n#ifdef DEBUG\n  {\n    static int fan_idx LOCKED_VAR = 0;\n    writew (\"-\\\\|/\"[fan_idx++] | (15 << 8),      /* white on black colour */\n            0xB8000 + 2*79);  /* upper-right corner, 80-col colour screen */\n    fan_idx &= 3;\n  }\n/* writew (idx + '0' + 0x0F00, 0xB8000 + 2*78); */\n#endif\n\n  if (idx != active_dev->queue.out_index)\n  {\n    struct rx_elem *head = pktq_in_elem (&active_dev->queue);\n\n    head->size = len;\n    active_dev->queue.in_index = idx;\n    return (&head->data[0]);\n  }\n\n  /* !!to-do: drop 25% of the oldest element\n   */\n  pktq_clear (&active_dev->queue);\n  return (NULL);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Increment the queue 'out_index' (tail).\n * Check for wraps.\n */\n", "func_signal": "static int pktq_inc_out (struct rx_ringbuf *q)", "code": "{\n  q->out_index++;\n  if (q->out_index >= q->num_elem)\n      q->out_index = 0;\n  return (q->out_index);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Return detailed network/device statistics.\n * May be called after 'dev->close' is called.\n */\n", "func_signal": "int pcap_stats_ex (pcap_t *p, struct pcap_stat_ex *se)", "code": "{\n  struct device *dev = p ? get_device (p->fd) : NULL;\n\n  if (!dev || !dev->get_stats)\n  {\n    strlcpy (p->errbuf, \"detailed device statistics not available\",\n             PCAP_ERRBUF_SIZE);\n    return (-1);\n  }\n\n  if (!strnicmp(dev->name,\"pkt\",3))\n  {\n    strlcpy (p->errbuf, \"pktdrvr doesn't have detailed statistics\",\n             PCAP_ERRBUF_SIZE);\n    return (-1);\n  }             \n  memcpy (se, (*dev->get_stats)(dev), sizeof(*se));\n  return (0);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Return the queue's next 'in_index' (head).\n * Check for wraps.\n */\n", "func_signal": "static int pktq_in_index (struct rx_ringbuf *q)", "code": "{\n  volatile int index = q->in_index + 1;\n\n  if (index >= q->num_elem)\n      index = 0;\n  return (index);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Initialise a named network device.\n */\n", "func_signal": "static struct device *\nopen_driver (const char *dev_name, char *ebuf, int promisc)", "code": "{\n  struct device *dev;\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->name);\n\n    if (strcmp (dev_name,dev->name))\n       continue;\n\n    if (!probed_dev)   /* user didn't call pcap_lookupdev() first */\n    {\n      PCAP_ASSERT (dev->probe);\n\n      if (!(*dev->probe)(dev))    /* call the xx_probe() function */\n      {\n        sprintf (ebuf, \"failed to detect device `%s'\", dev_name);\n        return (NULL);\n      }\n      probed_dev = dev;  /* device is probed okay and may be used */\n    }\n    else if (dev != probed_dev)\n    {\n      goto not_probed;\n    }\n\n    FLUSHK();\n\n    /* Select what traffic to receive\n     */\n    if (promisc)\n         dev->flags |=  (IFF_ALLMULTI | IFF_PROMISC);\n    else dev->flags &= ~(IFF_ALLMULTI | IFF_PROMISC);\n\n    PCAP_ASSERT (dev->open);\n\n    if (!(*dev->open)(dev))\n    {\n      sprintf (ebuf, \"failed to activate device `%s'\", dev_name);\n      if (pktInfo.error && !strncmp(dev->name,\"pkt\",3))\n      {\n        strcat (ebuf, \": \");\n        strcat (ebuf, pktInfo.error);\n      }\n      return (NULL);\n    }\n\n    /* Some devices need this to operate in promiscous mode\n     */\n    if (promisc && dev->set_multicast_list)\n       (*dev->set_multicast_list) (dev);\n\n    active_dev = dev;   /* remember our active device */\n    break;\n  }\n\n  /* 'dev_name' not matched in 'dev_base' list.\n   */\n  if (!dev)\n  {\n    sprintf (ebuf, \"device `%s' not supported\", dev_name);\n    return (NULL);\n  }\n\nnot_probed:\n  if (!probed_dev)\n  {\n    sprintf (ebuf, \"device `%s' not probed\", dev_name);\n    return (NULL);\n  }\n  return (dev);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Supress PRINT message from Watt-32's sock_init()\n */\n", "func_signal": "static void null_print (void)", "code": "{}\n\n/*\n * To use features of Watt-32 (netdb functions and socket etc.)\n * we must call sock_init(). But we set various hooks to prevent\n * using normal PKTDRVR functions in pcpkt.c. This should hopefully\n * make Watt-32 and pcap co-operate.\n */\nstatic int init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf)\n{\n  char *env;\n  int   rc, MTU, has_ip_addr;\n  int   using_pktdrv = 1;\n\n  /* If user called sock_init() first, we need to reinit in\n   * order to open debug/trace-file properly\n   */\n  if (_watt_is_init)\n     sock_exit();\n\n  env = getenv (\"PCAP_DEBUG\");\n  if (env && atoi(env) > 0 &&\n      pcap_pkt_debug < 0)   /* if not already set */\n  {\n    dbug_init();\n    pcap_pkt_debug = atoi (env);\n  }\n\n  _watt_do_exit      = 0;    /* prevent sock_init() calling exit() */\n  prev_post_hook     = _w32_usr_post_init;\n  _w32_usr_post_init = pcap_init_hook;\n  _w32_print_hook    = null_print;\n\n  if (dev_name && strncmp(dev_name,\"pkt\",3))\n     using_pktdrv = FALSE;\n\n  rc = sock_init();\n  has_ip_addr = (rc != 8);  /* IP-address assignment failed */\n\n  /* if pcap is using a 32-bit driver w/o a pktdrvr loaded, we\n   * just pretend Watt-32 is initialised okay.\n   *\n   * !! fix-me: The Watt-32 config isn't done if no pktdrvr\n   *            was found. In that case my_ip_addr + sin_mask\n   *            have default values. Should be taken from another\n   *            ini-file/environment in any case (ref. tcpdump.ini)\n   */\n  _watt_is_init = 1;  \n\n  if (!using_pktdrv || !has_ip_addr)  /* for now .... */\n  {\n    static const char myip[] = \"192.168.0.1\";\n    static const char mask[] = \"255.255.255.0\";\n\n    printf (\"Just guessing, using IP %s and netmask %s\\n\", myip, mask);\n    my_ip_addr    = aton (myip);\n    _w32_sin_mask = aton (mask);\n  }\n  else if (rc && using_pktdrv)\n  {\n    sprintf (err_buf, \"sock_init() failed, code %d\", rc);\n    return (0);\n  }\n\n  /* Set recv-hook for peeking in _eth_arrived().\n   */\n#if (WATTCP_VER >= 0x0224)\n  _eth_recv_hook = pcap_recv_hook;\n  _eth_xmit_hook = pcap_xmit_hook;\n#endif\n\n  /* Free the pkt-drvr handle allocated in pkt_init().\n   * The above hooks should thus use the handle reopened in open_driver()\n   */\n  if (using_pktdrv)\n  {\n    _eth_release();\n/*  _eth_is_init = 1; */  /* hack to get Rx/Tx-hooks in Watt-32 working */\n  }\n\n  memcpy (&pcap_save, pcap, sizeof(pcap_save));\n  MTU = pkt_get_mtu();\n  pcap_save.fcode.bf_insns = NULL;\n  pcap_save.linktype       = _eth_get_hwtype (NULL, NULL);\n  pcap_save.snapshot       = MTU > 0 ? MTU : ETH_MAX; /* assume 1514 */\n\n#if 1\n  /* prevent use of resolve() and resolve_ip()\n   */\n  last_nameserver = 0;\n#endif\n  return (1);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Simply store the filter-code for the pcap_read_dos() callback\n * Some day the filter-code could be handed down to the active\n * device (pkt_rx1.s or 32-bit device interrupt handler).\n */\n", "func_signal": "static int pcap_setfilter_dos (pcap_t *p, struct bpf_program *fp)", "code": "{\n  if (!p)\n     return (-1);\n  p->fcode = *fp;\n  return (0);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Open the pcap device for the first client calling pcap_open_live()\n */\n", "func_signal": "static int first_init (const char *name, char *ebuf, int promisc)", "code": "{\n  struct device *dev;\n\n#ifdef USE_32BIT_DRIVERS\n  rx_pool = k_calloc (RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE);\n  if (!rx_pool)\n  {\n    strcpy (ebuf, \"Not enough memory (Rx pool)\");\n    return (0);\n  }\n#endif\n\n#ifdef __DJGPP__\n  setup_signals (exc_handler);\n#endif\n\n#ifdef USE_32BIT_DRIVERS\n  init_32bit();\n#endif\n\n  dev = open_driver (name, ebuf, promisc);\n  if (!dev)\n  {\n#ifdef USE_32BIT_DRIVERS\n    k_free (rx_pool);\n    rx_pool = NULL;\n#endif\n\n#ifdef __DJGPP__\n    setup_signals (SIG_DFL);\n#endif\n    return (0);\n  }\n\n#ifdef USE_32BIT_DRIVERS\n  /*\n   * If driver is NOT a 16-bit \"pkt/ndis\" driver (having a 'copy_rx_buf'\n   * set in it's probe handler), initialise near-memory ring-buffer for\n   * the 32-bit device.\n   */\n  if (dev->copy_rx_buf == NULL)\n  {\n    dev->get_rx_buf     = get_rxbuf;\n    dev->peek_rx_buf    = peek_rxbuf;\n    dev->release_rx_buf = release_rxbuf;\n    pktq_init (&dev->queue, RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE, rx_pool);\n  }\n#endif\n  return (1);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Deinitialise MAC driver.\n * Set receive mode back to default mode.\n */\n", "func_signal": "static void close_driver (void)", "code": "{\n  /* !!todo: loop over all 'handle_to_device[]' ? */\n  struct device *dev = active_dev;\n\n  if (dev && dev->close)\n  {\n    (*dev->close) (dev);\n    FLUSHK();\n  }\n\n  active_dev = NULL;\n\n#ifdef USE_32BIT_DRIVERS\n  if (rx_pool)\n  {\n    k_free (rx_pool);\n    rx_pool = NULL;\n  }\n  if (dev)\n     pcibios_exit();\n#endif\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * For pcap_offline_read(): wait and yield between printing packets\n * to simulate the pace packets where actually recorded.\n */\n", "func_signal": "void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait)", "code": "{\n  if (p)\n  {\n    p->wait_proc         = yield;\n    p->inter_packet_wait = wait;\n  }\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Return the name of the 1st network interface,\n * or NULL if none can be found.\n */\n", "func_signal": "char *pcap_lookupdev (char *ebuf)", "code": "{\n  struct device *dev;\n\n#ifdef USE_32BIT_DRIVERS\n  init_32bit();\n#endif\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->probe);\n\n    if ((*dev->probe)(dev))\n    {\n      FLUSHK();\n      probed_dev = (struct device*) dev; /* remember last probed device */\n      return (char*) dev->name;\n    }\n  }\n\n  if (ebuf)\n     strcpy (ebuf, \"No driver found\");\n  return (NULL);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Open MAC-driver with name 'device_name' for live capture of\n * network packets.\n */\n", "func_signal": "pcap_t *pcap_open_live (const char *device_name, int snaplen, int promisc,\n                        int timeout_ms, char *errbuf)", "code": "{ \n  struct pcap *pcap;\n\n  if (snaplen < ETH_MIN)\n      snaplen = ETH_MIN;\n\n  if (snaplen > ETH_MAX)   /* silently accept and truncate large MTUs */\n      snaplen = ETH_MAX;\n\n  pcap = calloc (sizeof(*pcap), 1);\n  if (!pcap)\n  {\n    strcpy (errbuf, \"Not enough memory (pcap)\");\n    return (NULL);\n  }\n\n  pcap->snapshot          = max (ETH_MIN+8, snaplen);\n  pcap->linktype          = DLT_EN10MB;  /* !! */\n  pcap->inter_packet_wait = timeout_ms;\n  pcap->close_op          = pcap_close_dos;\n  pcap->read_op           = pcap_read_dos;\n  pcap->stats_op          = pcap_stats_dos;\n  pcap->inject_op         = pcap_sendpacket_dos;\n  pcap->setfilter_op      = pcap_setfilter_dos;\n\tpcap->setdirection_op   = NULL; /* Not implemented.*/\n  pcap->fd                = ++ref_count;\n\n  if (pcap->fd == 1)  /* first time we're called */\n  {\n    if (!init_watt32(pcap, device_name, errbuf) ||\n        !first_init(device_name, errbuf, promisc))\n    {\n      free (pcap);\n      return (NULL);\n    } \n    atexit (close_driver);\n  }\n  else if (stricmp(active_dev->name,device_name))\n  {\n    snprintf (errbuf, PCAP_ERRBUF_SIZE,\n              \"Cannot use different devices simultaneously \"\n              \"(`%s' vs. `%s')\", active_dev->name, device_name);\n    free (pcap);\n    pcap = NULL;\n  }\n  handle_to_device [pcap->fd-1] = active_dev;\n  return (pcap);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Gets localnet & netmask from Watt-32.\n */\n", "func_signal": "int pcap_lookupnet (const char *device, bpf_u_int32 *localnet,\n                    bpf_u_int32 *netmask, char *errbuf)", "code": "{\n  if (!_watt_is_init)\n  {\n    strcpy (errbuf, \"pcap_open_offline() or pcap_open_live() must be \"\n                    \"called first\");\n    return (-1);\n  }\n\n  *netmask  = _w32_sin_mask;\n  *localnet = my_ip_addr & *netmask;\n  if (*localnet == 0)\n  {\n    if (IN_CLASSA(*netmask))\n       *localnet = IN_CLASSA_NET;\n    else if (IN_CLASSB(*netmask))\n       *localnet = IN_CLASSB_NET;\n    else if (IN_CLASSC(*netmask))\n       *localnet = IN_CLASSC_NET;\n    else\n    {\n      sprintf (errbuf, \"inet class for 0x%lx unknown\", *netmask);\n      return (-1);\n    }\n  }\n  ARGSUSED (device);\n  return (0);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * pcap_assert() is mainly used for debugging\n */\n", "func_signal": "void pcap_assert (const char *what, const char *file, unsigned line)", "code": "{\n  FLUSHK();\n  fprintf (stderr, \"%s (%u): Assertion \\\"%s\\\" failed\\n\",\n           file, line, what);\n  close_driver();\n  _exit (-1);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Return network statistics\n */\n", "func_signal": "static int pcap_stats_dos (pcap_t *p, struct pcap_stat *ps)", "code": "{\n  struct net_device_stats *stats;\n  struct device           *dev = p ? get_device(p->fd) : NULL;\n\n  if (!dev)\n  {\n    strcpy (p->errbuf, \"illegal pcap handle\");\n    return (-1);\n  }\n\n  if (!dev->get_stats || (stats = (*dev->get_stats)(dev)) == NULL)\n  {\n    strcpy (p->errbuf, \"device statistics not available\");\n    return (-1);\n  }\n\n  FLUSHK();\n\n  p->md.stat.ps_recv   = stats->rx_packets;\n  p->md.stat.ps_drop  += stats->rx_missed_errors;\n  p->md.stat.ps_ifdrop = stats->rx_dropped +  /* queue full */\n                         stats->rx_errors;    /* HW errors */\n  if (ps)\n     *ps = p->md.stat;\n\n  return (0);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * NDIS device functions\n */\n", "func_signal": "static void ndis_close (struct device *dev)", "code": "{\n#ifdef USE_NDIS2\n  NdisShutdown();\n#endif\n  ARGSUSED (dev);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Release buffer we peeked at above.\n */\n", "func_signal": "int release_rxbuf (BYTE *buf)", "code": "{\n#ifndef NDEBUG\n  struct rx_elem *tail = pktq_out_elem (&active_dev->queue);\n\n  PCAP_ASSERT (&tail->data[0] == buf);\n#else\n  ARGSUSED (buf);\n#endif\n  pktq_inc_out (&active_dev->queue);\n  return (1);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * This function is called by Watt-32 (via _eth_xmit_hook).\n * If dbug_init() was called, we should trace packets sent.\n */\n", "func_signal": "static int pcap_xmit_hook (const void *buf, unsigned len)", "code": "{\n  int rc = 0;\n\n  if (pcap_pkt_debug > 0)\n     dbug_write (\"pcap_xmit_hook: \");\n\n  if (active_dev && active_dev->xmit)\n     if ((*active_dev->xmit) (active_dev, buf, len) > 0)\n        rc = len;\n\n  if (pcap_pkt_debug > 0)\n     dbug_write (rc ? \"ok\\n\" : \"fail\\n\");\n  return (rc);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "/*\n * Poll the receiver queue and call the pcap callback-handler\n * with the packet.\n */\n", "func_signal": "static int\npcap_read_one (pcap_t *p, pcap_handler callback, u_char *data)", "code": "{\n  struct pcap_pkthdr pcap;\n  struct bpf_insn   *fcode = p->fcode.bf_insns;\n  struct timeval     now, expiry;\n  BYTE  *rx_buf;\n  int    rx_len = 0;\n\n  if (p->inter_packet_wait > 0)\n  {\n    gettimeofday2 (&now, NULL);\n    expiry.tv_usec = now.tv_usec + 1000UL * p->inter_packet_wait;\n    expiry.tv_sec  = now.tv_sec;\n    while (expiry.tv_usec >= 1000000L)\n    {\n      expiry.tv_usec -= 1000000L;\n      expiry.tv_sec++;\n    }\n  }\n\n  while (!exc_occured)\n  {\n    volatile struct device *dev; /* might be reset by sig_handler */\n\n    dev = get_device (p->fd);\n    if (!dev)\n       break;\n\n    PCAP_ASSERT (dev->copy_rx_buf || dev->peek_rx_buf);\n    FLUSHK();\n\n    /* If driver has a zero-copy receive facility, peek at the queue,\n     * filter it, do the callback and release the buffer.\n     */\n    if (dev->peek_rx_buf)\n    {\n      PCAP_ASSERT (dev->release_rx_buf);\n      rx_len = (*dev->peek_rx_buf) (&rx_buf);\n    }\n    else\n    {\n      BYTE buf [ETH_MAX+100]; /* add some margin */\n      rx_len = (*dev->copy_rx_buf) (buf, p->snapshot);\n      rx_buf = buf;\n    }\n\n    if (rx_len > 0)  /* got a packet */\n    {\n      mac_count++;\n\n      FLUSHK();\n\n      pcap.caplen = min (rx_len, p->snapshot);\n      pcap.len    = rx_len;\n\n      if (callback &&\n          (!fcode || bpf_filter(fcode, rx_buf, pcap.len, pcap.caplen)))\n      {\n        filter_count++;\n\n        /* Fix-me!! Should be time of arrival. Not time of\n         * capture.\n         */\n        gettimeofday2 (&pcap.ts, NULL);\n        (*callback) (data, &pcap, rx_buf);\n      }\n\n      if (dev->release_rx_buf)\n        (*dev->release_rx_buf) (rx_buf);\n\n      if (pcap_pkt_debug > 0)\n      {\n        if (callback == watt32_recv_hook)\n             dbug_write (\"pcap_recv_hook\\n\");\n        else dbug_write (\"pcap_read_op\\n\");\n      }\n      FLUSHK();\n      return (1);\n    }\n\n    /* If not to wait for a packet or pcap_close() called from\n     * e.g. SIGINT handler, exit loop now.\n     */\n    if (p->inter_packet_wait <= 0 || (volatile int)p->fd <= 0)\n       break;\n\n    gettimeofday2 (&now, NULL);\n\n    if (timercmp(&now, &expiry, >))\n       break;\n\n#ifndef DJGPP\n    kbhit();    /* a real CPU hog */\n#endif\n\n    if (p->wait_proc)\n      (*p->wait_proc)();     /* call yield func */\n  }\n\n  if (rx_len < 0)            /* receive error */\n  {\n    p->md.stat.ps_drop++;\n#ifdef USE_32BIT_DRIVERS\n    if (pcap_pkt_debug > 1)\n       printk (\"pkt-err %s\\n\", pktInfo.error);\n#endif\n    return (-1);\n  }\n  return (0);\n}", "path": "winpcap\\wpcap\\libpcap\\pcap-dos.c", "repo_name": "chongyc/natblaster", "stars": 14, "license": "None", "language": "c", "size": 2282}
{"docstring": "// -----------------------------------------------------------------------------\n//\tMetadataImporterPluginAddRef\n// -----------------------------------------------------------------------------\n//\tImplementation of reference counting for this type. Whenever an interface\n//\tis requested, bump the refCount for the instance. NOTE: returning the\n//\trefcount is a convention but is not required so don't rely on it.\n//\n", "func_signal": "ULONG MetadataImporterPluginAddRef(void *thisInstance)", "code": "{\n    ((MetadataImporterPluginType *)thisInstance )->refCount += 1;\n    return ((MetadataImporterPluginType*) thisInstance)->refCount;\n}", "path": "SpotlightImporter\\main.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** zCode is a string that is the action associated with a rule.  Expand\n** the symbols in this string so that the refer to elements of the parser\n** stack.\n*/\n", "func_signal": "PRIVATE void translate_code(struct lemon *lemp, struct rule *rp)", "code": "{\n  char *cp, *xp;\n  int i;\n  char lhsused = 0;    /* True if the LHS element has been used */\n  char used[MAXRHS];   /* True for each RHS element which is used */\n\n  for(i=0; i<rp->nrhs; i++) used[i] = 0;\n  lhsused = 0;\n\n  if( rp->code==0 ){\n    rp->code = \"\\n\";\n    rp->line = rp->ruleline;\n  }\n\n  append_str(0,0,0,0);\n  for(cp=rp->code; *cp; cp++){\n    if( isalpha(*cp) && (cp==rp->code || (!isalnum(cp[-1]) && cp[-1]!='_')) ){\n      char saved;\n      for(xp= &cp[1]; isalnum(*xp) || *xp=='_'; xp++);\n      saved = *xp;\n      *xp = 0;\n      if( rp->lhsalias && strcmp(cp,rp->lhsalias)==0 ){\n        append_str(\"yygotominor.yy%d\",0,rp->lhs->dtnum,0);\n        cp = xp;\n        lhsused = 1;\n      }else{\n        for(i=0; i<rp->nrhs; i++){\n          if( rp->rhsalias[i] && strcmp(cp,rp->rhsalias[i])==0 ){\n            if( cp!=rp->code && cp[-1]=='@' ){\n              /* If the argument is of the form @X then substituted\n              ** the token number of X, not the value of X */\n              append_str(\"yymsp[%d].major\",-1,i-rp->nrhs+1,0);\n            }else{\n              struct symbol *sp = rp->rhs[i];\n              int dtnum;\n              if( sp->type==MULTITERMINAL ){\n                dtnum = sp->subsym[0]->dtnum;\n              }else{\n                dtnum = sp->dtnum;\n              }\n              append_str(\"yymsp[%d].minor.yy%d\",0,i-rp->nrhs+1, dtnum);\n            }\n            cp = xp;\n            used[i] = 1;\n            break;\n          }\n        }\n      }\n      *xp = saved;\n    }\n    append_str(cp, 1, 0, 0);\n  } /* End loop */\n\n  /* Check to make sure the LHS has been used */\n  if( rp->lhsalias && !lhsused ){\n    ErrorMsg(lemp->filename,rp->ruleline,\n      \"Label \\\"%s\\\" for \\\"%s(%s)\\\" is never used.\",\n        rp->lhsalias,rp->lhs->name,rp->lhsalias);\n    lemp->errorcnt++;\n  }\n\n  /* Generate destructor code for RHS symbols which are not used in the\n  ** reduce code */\n  for(i=0; i<rp->nrhs; i++){\n    if( rp->rhsalias[i] && !used[i] ){\n      ErrorMsg(lemp->filename,rp->ruleline,\n        \"Label %s for \\\"%s(%s)\\\" is never used.\",\n        rp->rhsalias[i],rp->rhs[i]->name,rp->rhsalias[i]);\n      lemp->errorcnt++;\n    }else if( rp->rhsalias[i]==0 ){\n      if( has_destructor(rp->rhs[i],lemp) ){\n        append_str(\"  yy_destructor(yypParser,%d,&yymsp[%d].minor);\\n\", 0,\n           rp->rhs[i]->index,i-rp->nrhs+1);\n      }else{\n        /* No destructor defined for this term */\n      }\n    }\n  }\n  if( rp->code ){\n    cp = append_str(0,0,0,0);\n    rp->code = Strsafe(cp?cp:\"\");\n  }\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** Add the transaction set built up with prior calls to acttab_action()\n** into the current action table.  Then reset the transaction set back\n** to an empty set in preparation for a new round of acttab_action() calls.\n**\n** Return the offset into the action table of the new transaction.\n*/\n", "func_signal": "int acttab_insert(acttab *p)", "code": "{\n  int i, j, k, n;\n  assert( p->nLookahead>0 );\n\n  /* Make sure we have enough space to hold the expanded action table\n  ** in the worst case.  The worst case occurs if the transaction set\n  ** must be appended to the current action table\n  */\n  n = p->mxLookahead + 1;\n  if( p->nAction + n >= p->nActionAlloc ){\n    int oldAlloc = p->nActionAlloc;\n    p->nActionAlloc = p->nAction + n + p->nActionAlloc + 20;\n    p->aAction = realloc( p->aAction,\n                          sizeof(p->aAction[0])*p->nActionAlloc);\n    if( p->aAction==0 ){\n      fprintf(stderr,\"malloc failed\\n\");\n      exit(1);\n    }\n    for(i=oldAlloc; i<p->nActionAlloc; i++){\n      p->aAction[i].lookahead = -1;\n      p->aAction[i].action = -1;\n    }\n  }\n\n  /* Scan the existing action table looking for an offset where we can\n  ** insert the current transaction set.  Fall out of the loop when that\n  ** offset is found.  In the worst case, we fall out of the loop when\n  ** i reaches p->nAction, which means we append the new transaction set.\n  **\n  ** i is the index in p->aAction[] where p->mnLookahead is inserted.\n  */\n  for(i=0; i<p->nAction+p->mnLookahead; i++){\n    if( p->aAction[i].lookahead<0 ){\n      for(j=0; j<p->nLookahead; j++){\n        k = p->aLookahead[j].lookahead - p->mnLookahead + i;\n        if( k<0 ) break;\n        if( p->aAction[k].lookahead>=0 ) break;\n      }\n      if( j<p->nLookahead ) continue;\n      for(j=0; j<p->nAction; j++){\n        if( p->aAction[j].lookahead==j+p->mnLookahead-i ) break;\n      }\n      if( j==p->nAction ){\n        break;  /* Fits in empty slots */\n      }\n    }else if( p->aAction[i].lookahead==p->mnLookahead ){\n      if( p->aAction[i].action!=p->mnAction ) continue;\n      for(j=0; j<p->nLookahead; j++){\n        k = p->aLookahead[j].lookahead - p->mnLookahead + i;\n        if( k<0 || k>=p->nAction ) break;\n        if( p->aLookahead[j].lookahead!=p->aAction[k].lookahead ) break;\n        if( p->aLookahead[j].action!=p->aAction[k].action ) break;\n      }\n      if( j<p->nLookahead ) continue;\n      n = 0;\n      for(j=0; j<p->nAction; j++){\n        if( p->aAction[j].lookahead<0 ) continue;\n        if( p->aAction[j].lookahead==j+p->mnLookahead-i ) n++;\n      }\n      if( n==p->nLookahead ){\n        break;  /* Same as a prior transaction set */\n      }\n    }\n  }\n  /* Insert transaction set at index i. */\n  for(j=0; j<p->nLookahead; j++){\n    k = p->aLookahead[j].lookahead - p->mnLookahead + i;\n    p->aAction[k] = p->aLookahead[j];\n    if( k>=p->nAction ) p->nAction = k+1;\n  }\n  p->nLookahead = 0;\n\n  /* Return the offset that is added to the lookahead in order to get the\n  ** index into yy_action of the action */\n  return i - p->mnLookahead;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** Inputs:\n**   a:       A sorted, null-terminated linked list.  (May be null).\n**   b:       A sorted, null-terminated linked list.  (May be null).\n**   cmp:     A pointer to the comparison function.\n**   offset:  Offset in the structure to the \"next\" field.\n**\n** Return Value:\n**   A pointer to the head of a sorted list containing the elements\n**   of both a and b.\n**\n** Side effects:\n**   The \"next\" pointers for elements in the lists a and b are\n**   changed.\n*/\n", "func_signal": "static char *merge(\n  char *a,\n  char *b,\n  int (*cmp)(const char*,const char*),\n  int offset\n)", "code": "{\n  char *ptr, *head;\n\n  if( a==0 ){\n    head = b;\n  }else if( b==0 ){\n    head = a;\n  }else{\n    if( (*cmp)(a,b)<0 ){\n      ptr = a;\n      a = NEXT(a);\n    }else{\n      ptr = b;\n      b = NEXT(b);\n    }\n    head = ptr;\n    while( a && b ){\n      if( (*cmp)(a,b)<0 ){\n        NEXT(ptr) = a;\n        ptr = a;\n        a = NEXT(a);\n      }else{\n        NEXT(ptr) = b;\n        ptr = b;\n        b = NEXT(b);\n      }\n    }\n    if( a ) NEXT(ptr) = a;\n    else    NEXT(ptr) = b;\n  }\n  return head;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "// -----------------------------------------------------------------------------\n//\tDeallocQuickLookGeneratorPluginType\n// -----------------------------------------------------------------------------\n//\tUtility function that deallocates the instance when\n//\tthe refCount goes to zero.\n//      In the current implementation generator interfaces are never deallocated\n//      but implement this as this might change in the future\n//\n", "func_signal": "void DeallocQuickLookGeneratorPluginType(QuickLookGeneratorPluginType *thisInstance)", "code": "{\n    CFUUIDRef theFactoryID;\n\n    theFactoryID = thisInstance->factoryID;\n        /* Free the conduitInterface table up */\n    free(thisInstance->conduitInterface);\n\n        /* Free the instance structure */\n    free(thisInstance);\n    if (theFactoryID){\n        CFPlugInRemoveInstanceForFactory(theFactoryID);\n        CFRelease(theFactoryID);\n    }\n}", "path": "QuickLookGenerator\\main.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "// -----------------------------------------------------------------------------\n// SampleCMPluginRelease\n// -----------------------------------------------------------------------------\n//\tWhen an interface is released, decrement the refCount.\n//\tIf the refCount goes to zero, deallocate the instance.\n//\n", "func_signal": "ULONG MetadataImporterPluginRelease(void *thisInstance)", "code": "{\n    ((MetadataImporterPluginType*)thisInstance)->refCount -= 1;\n    if (((MetadataImporterPluginType*)thisInstance)->refCount == 0){\n        DeallocMetadataImporterPluginType((MetadataImporterPluginType*)thisInstance );\n        return 0;\n    }else{\n        return ((MetadataImporterPluginType*) thisInstance )->refCount;\n    }\n}", "path": "SpotlightImporter\\main.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Print an action to the given file descriptor.  Return FALSE if\n** nothing was actually printed.\n*/\n", "func_signal": "int PrintAction(struct action *ap, FILE *fp, int indent)", "code": "{\n  int result = 1;\n  switch( ap->type ){\n    case SHIFT:\n      fprintf(fp,\"%*s shift  %d\",indent,ap->sp->name,ap->x.stp->statenum);\n      break;\n    case REDUCE:\n      fprintf(fp,\"%*s reduce %d\",indent,ap->sp->name,ap->x.rp->index);\n      break;\n    case ACCEPT:\n      fprintf(fp,\"%*s accept\",indent,ap->sp->name);\n      break;\n    case ERROR:\n      fprintf(fp,\"%*s error\",indent,ap->sp->name);\n      break;\n    case SRCONFLICT:\n    case RRCONFLICT:\n      fprintf(fp,\"%*s reduce %-3d ** Parsing conflict **\",\n        indent,ap->sp->name,ap->x.rp->index);\n      break;\n    case SSCONFLICT:\n      fprintf(fp,\"%*s shift  %d ** Parsing conflict **\", \n        indent,ap->sp->name,ap->x.stp->statenum);\n      break;\n    case SH_RESOLVED:\n    case RD_RESOLVED:\n    case NOT_USED:\n      result = 0;\n      break;\n  }\n  return result;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Add a new action to the current transaction set\n*/\n", "func_signal": "void acttab_action(acttab *p, int lookahead, int action)", "code": "{\n  if( p->nLookahead>=p->nLookaheadAlloc ){\n    p->nLookaheadAlloc += 25;\n    p->aLookahead = realloc( p->aLookahead,\n                             sizeof(p->aLookahead[0])*p->nLookaheadAlloc );\n    if( p->aLookahead==0 ){\n      fprintf(stderr,\"malloc failed\\n\");\n      exit(1);\n    }\n  }\n  if( p->nLookahead==0 ){\n    p->mxLookahead = lookahead;\n    p->mnLookahead = lookahead;\n    p->mnAction = action;\n  }else{\n    if( p->mxLookahead<lookahead ) p->mxLookahead = lookahead;\n    if( p->mnLookahead>lookahead ){\n      p->mnLookahead = lookahead;\n      p->mnAction = action;\n    }\n  }\n  p->aLookahead[p->nLookahead].lookahead = lookahead;\n  p->aLookahead[p->nLookahead].action = action;\n  p->nLookahead++;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Max width of the prefix on each line */\n", "func_signal": "void ErrorMsg(const char *filename, int lineno, const char *format, ...)", "code": "{\n  char errmsg[ERRMSGSIZE];\n  char prefix[PREFIXLIMIT+10];\n  int errmsgsize;\n  int prefixsize;\n  int availablewidth;\n  va_list ap;\n  int end, restart, base;\n\n  va_start(ap, format);\n  /* Prepare a prefix to be prepended to every output line */\n  if( lineno>0 ){\n    sprintf(prefix,\"%.*s:%d: \",PREFIXLIMIT-10,filename,lineno);\n  }else{\n    sprintf(prefix,\"%.*s: \",PREFIXLIMIT-10,filename);\n  }\n  prefixsize = lemonStrlen(prefix);\n  availablewidth = LINEWIDTH - prefixsize;\n\n  /* Generate the error message */\n  vsprintf(errmsg,format,ap);\n  va_end(ap);\n  errmsgsize = lemonStrlen(errmsg);\n  /* Remove trailing '\\n's from the error message. */\n  while( errmsgsize>0 && errmsg[errmsgsize-1]=='\\n' ){\n     errmsg[--errmsgsize] = 0;\n  }\n\n  /* Print the error message */\n  base = 0;\n  while( errmsg[base]!=0 ){\n    end = restart = findbreak(&errmsg[base],0,availablewidth);\n    restart += base;\n    while( errmsg[restart]==' ' ) restart++;\n    fprintf(stdout,\"%s%.*s\\n\",prefix,end,&errmsg[base]);\n    base = restart;\n  }\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Allocate a new state structure */\n", "func_signal": "struct state *State_new()", "code": "{\n  struct state *new;\n  new = (struct state *)calloc(1, sizeof(struct state) );\n  MemoryCheck(new);\n  return new;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Return an array of pointers to all data in the table.\n** The array is obtained from malloc.  Return NULL if memory allocation\n** problems, or if the array is empty. */\n", "func_signal": "struct symbol **Symbol_arrayof()", "code": "{\n  struct symbol **array;\n  int i,size;\n  if( x2a==0 ) return 0;\n  size = x2a->count;\n  array = (struct symbol **)calloc(size, sizeof(struct symbol *));\n  if( array ){\n    for(i=0; i<size; i++) array[i] = x2a->tbl[i].data;\n  }\n  return array;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "// -----------------------------------------------------------------------------\n//\tAllocMetadataImporterPluginType\n// -----------------------------------------------------------------------------\n//\tUtility function that allocates a new instance.\n//      You can do some initial setup for the importer here if you wish\n//      like allocating globals etc...\n//\n", "func_signal": "MetadataImporterPluginType *AllocMetadataImporterPluginType(CFUUIDRef inFactoryID)", "code": "{\n    MetadataImporterPluginType *theNewInstance;\n\n    theNewInstance = (MetadataImporterPluginType *)malloc(sizeof(MetadataImporterPluginType));\n    memset(theNewInstance,0,sizeof(MetadataImporterPluginType));\n\n        /* Point to the function table */\n    theNewInstance->conduitInterface = &testInterfaceFtbl;\n\n        /*  Retain and keep an open instance refcount for each factory. */\n    theNewInstance->factoryID = CFRetain(inFactoryID);\n    CFPlugInAddInstanceForFactory(inFactoryID);\n\n        /* This function returns the IUnknown interface so set the refCount to one. */\n    theNewInstance->refCount = 1;\n    return theNewInstance;\n}", "path": "SpotlightImporter\\main.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Sort parser actions */\n", "func_signal": "static struct action *Action_sort(\n  struct action *ap\n)", "code": "{\n  ap = (struct action *)msort((char *)ap,(char **)&ap->next,\n                              (int(*)(const char*,const char*))actioncmp);\n  return ap;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* \n** Turn parser tracing on by giving a stream to which to write the trace\n** and a prompt to preface each trace message.  Tracing is turned off\n** by making either argument NULL \n**\n** Inputs:\n** <ul>\n** <li> A FILE* to which trace output should be written.\n**      If NULL, then tracing is turned off.\n** <li> A prefix string written at the beginning of every\n**      line of trace output.  If NULL, then tracing is\n**      turned off.\n** </ul>\n**\n** Outputs:\n** None.\n*/\n", "func_signal": "void ParseTrace(FILE *TraceFILE, char *zTracePrompt)", "code": "{\n  yyTraceFILE = TraceFILE;\n  yyTracePrompt = zTracePrompt;\n  if( yyTraceFILE==0 ) yyTracePrompt = 0;\n  else if( yyTracePrompt==0 ) yyTraceFILE = 0;\n}", "path": "tools\\lempar.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "// -----------------------------------------------------------------------------\n//\tDeallocSGFImporterMDImporterPluginType\n// -----------------------------------------------------------------------------\n//\tUtility function that deallocates the instance when\n//\tthe refCount goes to zero.\n//      In the current implementation importer interfaces are never deallocated\n//      but implement this as this might change in the future\n//\n", "func_signal": "void DeallocMetadataImporterPluginType(MetadataImporterPluginType *thisInstance)", "code": "{\n    CFUUIDRef theFactoryID;\n\n    theFactoryID = thisInstance->factoryID;\n    free(thisInstance);\n    if (theFactoryID){\n        CFPlugInRemoveInstanceForFactory(theFactoryID);\n        CFRelease(theFactoryID);\n    }\n}", "path": "SpotlightImporter\\main.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Return a pointer to the head of the configuration list and\n** reset the list */\n", "func_signal": "struct config *Configlist_return()", "code": "{\n  struct config *old;\n  old = current;\n  current = 0;\n  currentend = 0;\n  return old;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** The following routine is called if the stack overflows.\n*/\n", "func_signal": "static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor)", "code": "{\n   ParseARG_FETCH;\n   yypParser->yyidx--;\n#ifndef NDEBUG\n   if( yyTraceFILE ){\n     fprintf(yyTraceFILE,\"%sStack Overflow!\\n\",yyTracePrompt);\n   }\n#endif\n   while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\n   /* Here code is inserted which will execute if the parser\n   ** stack every overflows */\n%%\n   ParseARG_STORE; /* Suppress warning about unused %extra_argument var */\n}", "path": "tools\\lempar.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** Return the name of a C datatype able to represent values between\n** lwr and upr, inclusive.\n*/\n", "func_signal": "static const char *minimum_size_type(int lwr, int upr)", "code": "{\n  if( lwr>=0 ){\n    if( upr<=255 ){\n      return \"unsigned char\";\n    }else if( upr<65535 ){\n      return \"unsigned short int\";\n    }else{\n      return \"unsigned int\";\n    }\n  }else if( lwr>=-127 && upr<=127 ){\n    return \"signed char\";\n  }else if( lwr>=-32767 && upr<32767 ){\n    return \"short\";\n  }else{\n    return \"int\";\n  }\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* Return a pointer to the head of the configuration list and\n** reset the list */\n", "func_signal": "struct config *Configlist_basis()", "code": "{\n  struct config *old;\n  old = basis;\n  basis = 0;\n  basisend = 0;\n  return old;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/*\n** Append text to a dynamically allocated string.  If zText is 0 then\n** reset the string to be empty again.  Always return the complete text\n** of the string (which is overwritten with each call).\n**\n** n bytes of zText are stored.  If n==0 then all of zText up to the first\n** \\000 terminator is stored.  zText can contain up to two instances of\n** %d.  The values of p1 and p2 are written into the first and second\n** %d.\n**\n** If n==-1, then the previous character is overwritten.\n*/\n", "func_signal": "PRIVATE char *append_str(char *zText, int n, int p1, int p2)", "code": "{\n  static char *z = 0;\n  static int alloced = 0;\n  static int used = 0;\n  int c;\n  char zInt[40];\n\n  if( zText==0 ){\n    used = 0;\n    return z;\n  }\n  if( n<=0 ){\n    if( n<0 ){\n      used += n;\n      assert( used>=0 );\n    }\n    n = lemonStrlen(zText);\n  }\n  if( n+sizeof(zInt)*2+used >= alloced ){\n    alloced = n + sizeof(zInt)*2 + used + 200;\n    z = realloc(z,  alloced);\n  }\n  if( z==0 ) return \"\";\n  while( n-- > 0 ){\n    c = *(zText++);\n    if( c=='%' && n>0 && zText[0]=='d' ){\n      sprintf(zInt, \"%d\", p1);\n      p1 = p2;\n      strcpy(&z[used], zInt);\n      used += lemonStrlen(&z[used]);\n      zText++;\n      n--;\n    }else{\n      z[used++] = c;\n    }\n  }\n  z[used] = 0;\n  return z;\n}", "path": "tools\\lemon.c", "repo_name": "threeve/SGF-Tools", "stars": 9, "license": "mit", "language": "c", "size": 352}
{"docstring": "/* \n * From eggcellrenderkeys.c.\n */\n", "func_signal": "gboolean\nol_keybinder_is_modifier (guint keycode)", "code": "{\n  gint i;\n  gint map_size;\n  XModifierKeymap *mod_keymap;\n  gboolean retval = FALSE;\n\n  mod_keymap = XGetModifierMapping (gdk_display);\n\n  map_size = 8 * mod_keymap->max_keypermod;\n\n  i = 0;\n  while (i < map_size) {\n    if (keycode == mod_keymap->modifiermap[i]) {\n      retval = TRUE;\n      break;\n    }\n    ++i;\n  }\n\n  XFreeModifiermap (mod_keymap);\n\n  return retval;\n}", "path": "src\\ol_keybinder.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/*\n * HTML \u683c\u5f0f\u7f16\u7801\n * \u5bf9 String \u7f16\u7801\u65f6\uff0c\u4f7f\u7528\u4ee5\u4e0b\u89c4\u5219\uff1a\n * \u5b57\u6bcd\u6570\u5b57\u5b57\u7b26 \"a\" \u5230 \"z\"\u3001\"A\" \u5230 \"Z\" \u548c \"0\" \u5230 \"9\" \u4fdd\u6301\u4e0d\u53d8\u3002\n * \u7279\u6b8a\u5b57\u7b26 \".\"\u3001\"-\"\u3001\"*\" \u548c \"_\" \u4fdd\u6301\u4e0d\u53d8\u3002\n * \u5982\u679cspace_cat\u975e0\uff0c\u7a7a\u683c\u5b57\u7b26 \" \" \u8f6c\u6362\u4e3a \"+\"\uff0c\u5426\u5219\u8f6c\u6362\u4e3a\"%20\"\u3002\n * \u6240\u6709\u5176\u4ed6\u5b57\u7b26\u90fd\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u56e0\u6b64\u9996\u5148\u4f7f\u7528\u4e00\u4e9b\u7f16\u7801\u673a\u5236\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u8282\u3002\n * \u7136\u540e\u6bcf\u4e2a\u5b57\u8282\u7528\u4e00\u4e2a\u5305\u542b 3 \u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32 \"%xy\" \u8868\u793a\uff0c\u5176\u4e2d xy \u4e3a\u8be5\u5b57\u8282\u7684\u4e24\u4f4d\u5341\u516d\u8fdb\u5236\u8868\u793a\u5f62\u5f0f\u3002\n * \u63a8\u8350\u7684\u7f16\u7801\u673a\u5236\u662f UTF-8\u3002\u4f46\u662f\uff0c\u51fa\u4e8e\u517c\u5bb9\u6027\u8003\u8651\uff0c\u5982\u679c\u672a\u6307\u5b9a\u4e00\u79cd\u7f16\u7801\uff0c\u5219\u4f7f\u7528\u76f8\u5e94\u5e73\u53f0\u7684\u9ed8\u8ba4\u7f16\u7801\u3002 \n */\n", "func_signal": "int\nurl_encoding(const char *src, const int srclen, char *dest, int destlen, int space_cat)", "code": "{\n  ol_log_func ();\n  int i;\n  int j = 0; \n  char ch;\n\n  /*\n   * convert to GBK, this should be done before this function called\n   *\n   char buf[BUFSZ];\t\n   char *src_copy;\n   iconv_t icv;\n   if(charset != NULL)\n   icv = iconv_open(\"GBK\", charset);\n   else\n   icv = iconv_open(\"GBK\", \"UTF-8\");\n\t\n   if((src_copy = malloc(srclen+1)) == NULL)\n   return -1;\n   memcpy(src_copy, src, srclen);\n   src_copy[srclen] = 0;\n   convert_icv(&icv, src_copy, srclen, buf, BUFSZ);\n   iconv_close(icv);\n   free(src_copy);\n  */\n    \n  if(src == NULL || dest == NULL || srclen < 0 || destlen < 0)\n    return -1;\n\n  for(i=0; ((i<srclen) && j<destlen); i++) {\n    ch = src[i];\n    if((ch>='A') && (ch<='Z'))\n      dest[j++] = ch;\n    else if((ch>='a') && (ch<='z'))\n      dest[j++] = ch;\n    else if((ch>='0') && (ch<='9'))\n      dest[j++] = ch;\n    else if(ch=='.' || ch=='*' || ch=='_' || ch=='-' || ch=='%' || ch=='+')\n      dest[j++] = ch;\n    else if(space_cat && ch==' ')\n    {\n      dest[j++] = '+';\n    }\n    else {\n      if(j+3 < destlen) {\n        sprintf(dest+j, \"%%%02X\", (unsigned char)ch);\n        j += 3;\n      } else\n        return -1;\n    }\n  }\n  dest[j] = '\\0';\n  return 0;\n}", "path": "src\\ol_lrc_fetch_utils.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "//void ol_scroll_module_set_music_info (struct OlDisplayModule *module, OlMusicInfo *music_info);\n//void ol_scroll_module_set_player (struct OlDisplayModule *module, struct OlPlayer *player);\n/*\nvoid ol_osd_module_search_message (struct OlDisplayModule *module, const char *message);\nvoid ol_osd_module_search_fail_message (struct OlDisplayModule *module, const char *message);\nvoid ol_osd_module_download_fail_message (struct OlDisplayModule *module, const char *message);\nvoid ol_osd_module_clear_message (struct OlDisplayModule *module);*/\n", "func_signal": "static void\nol_scroll_module_init_scroll (OlScrollModule *module)", "code": "{\n  ol_assert (module != NULL);\n  module->scroll = OL_SCROLL_WINDOW (ol_scroll_window_new ());\n  g_object_ref_sink(module->scroll);\n  if (module->scroll == NULL)\n  {\n    return;\n  }\n  gtk_widget_show(GTK_WIDGET (module->scroll));\n}", "path": "src\\ol_scroll_module.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Try to lock a file, From APUE */\n", "func_signal": "int64_t\n_lockfile (int fd)", "code": "{\n  struct flock fl;\n  fl.l_type = F_WRLCK;\n  fl.l_start = 0;\n  fl.l_whence = SEEK_SET;\n  fl.l_len = 0;\n  return (fcntl (fd, F_SETLK, &fl));\n}", "path": "src\\ol_singleton.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* General Options */\n", "func_signal": "void\nol_option_display_mode_changed (GtkToggleButton *togglebutton,\n                                gpointer user_data)", "code": "{\n  if (gtk_toggle_button_get_active (togglebutton))\n  {\n    const char *mode = \"OSD\";\n    if (GTK_WIDGET(togglebutton) == options.display_mode_scroll)\n      mode = \"scroll\";\n    ol_config_set_string (ol_config_get_instance (),\n                          \"General\",\n                          \"display-mode\",\n                          mode);\n  }\n}", "path": "src\\ol_option.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/**\n * egg_virtual_accelerator_name:\n * @accelerator_key:  accelerator keyval\n * @accelerator_mods: accelerator modifier mask\n * @returns:          a newly-allocated accelerator name\n * \n * Converts an accelerator keyval and modifier mask\n * into a string parseable by egg_accelerator_parse_virtual().\n * For example, if you pass in #GDK_q and #EGG_VIRTUAL_CONTROL_MASK,\n * this function returns \"&lt;Control&gt;q\".\n *\n * The caller of this function must free the returned string.\n */\n", "func_signal": "gchar*\negg_virtual_accelerator_name (guint                  accelerator_key,\n                              EggVirtualModifierType accelerator_mods)", "code": "{\n  static const gchar text_release[] = \"<Release>\";\n  static const gchar text_shift[] = \"<Shift>\";\n  static const gchar text_control[] = \"<Control>\";\n  static const gchar text_mod1[] = \"<Alt>\";\n  static const gchar text_mod2[] = \"<Mod2>\";\n  static const gchar text_mod3[] = \"<Mod3>\";\n  static const gchar text_mod4[] = \"<Mod4>\";\n  static const gchar text_mod5[] = \"<Mod5>\";\n  static const gchar text_meta[] = \"<Meta>\";\n  static const gchar text_super[] = \"<Super>\";\n  static const gchar text_hyper[] = \"<Hyper>\";\n  guint l;\n  gchar *keyval_name;\n  gchar *accelerator;\n\n  accelerator_mods &= EGG_VIRTUAL_MODIFIER_MASK;\n\n  keyval_name = gdk_keyval_name (gdk_keyval_to_lower (accelerator_key));\n  if (!keyval_name)\n    keyval_name = \"\";\n\n  l = 0;\n  if (accelerator_mods & EGG_VIRTUAL_RELEASE_MASK)\n    l += sizeof (text_release) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_SHIFT_MASK)\n    l += sizeof (text_shift) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_CONTROL_MASK)\n    l += sizeof (text_control) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_ALT_MASK)\n    l += sizeof (text_mod1) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_MOD2_MASK)\n    l += sizeof (text_mod2) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_MOD3_MASK)\n    l += sizeof (text_mod3) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_MOD4_MASK)\n    l += sizeof (text_mod4) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_MOD5_MASK)\n    l += sizeof (text_mod5) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_META_MASK)\n    l += sizeof (text_meta) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_HYPER_MASK)\n    l += sizeof (text_hyper) - 1;\n  if (accelerator_mods & EGG_VIRTUAL_SUPER_MASK)\n    l += sizeof (text_super) - 1;\n  l += strlen (keyval_name);\n\n  accelerator = g_new (gchar, l + 1);\n\n  l = 0;\n  accelerator[l] = 0;\n  if (accelerator_mods & EGG_VIRTUAL_RELEASE_MASK)\n    {\n      strcpy (accelerator + l, text_release);\n      l += sizeof (text_release) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_SHIFT_MASK)\n    {\n      strcpy (accelerator + l, text_shift);\n      l += sizeof (text_shift) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_CONTROL_MASK)\n    {\n      strcpy (accelerator + l, text_control);\n      l += sizeof (text_control) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_ALT_MASK)\n    {\n      strcpy (accelerator + l, text_mod1);\n      l += sizeof (text_mod1) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_MOD2_MASK)\n    {\n      strcpy (accelerator + l, text_mod2);\n      l += sizeof (text_mod2) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_MOD3_MASK)\n    {\n      strcpy (accelerator + l, text_mod3);\n      l += sizeof (text_mod3) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_MOD4_MASK)\n    {\n      strcpy (accelerator + l, text_mod4);\n      l += sizeof (text_mod4) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_MOD5_MASK)\n    {\n      strcpy (accelerator + l, text_mod5);\n      l += sizeof (text_mod5) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_META_MASK)\n    {\n      strcpy (accelerator + l, text_meta);\n      l += sizeof (text_meta) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_HYPER_MASK)\n    {\n      strcpy (accelerator + l, text_hyper);\n      l += sizeof (text_hyper) - 1;\n    }\n  if (accelerator_mods & EGG_VIRTUAL_SUPER_MASK)\n    {\n      strcpy (accelerator + l, text_super);\n      l += sizeof (text_super) - 1;\n    }\n  \n  strcpy (accelerator + l, keyval_name);\n\n  return accelerator;\n}", "path": "src\\ol_eggaccelerators.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Issue 99 */\n", "func_signal": "void begin_with_timestamp_test ()", "code": "{\n  const char *DATAFILE = \"lrc_tail.lrc\";\n  struct OlLrc *lrc = ol_lrc_new (DATAFILE);\n  const struct OlLrcItem *item = ol_lrc_get_item (lrc, 0);\n  ol_test_expect (ol_lrc_item_get_time (item) == 10000);\n  ol_lrc_free (lrc);\n}", "path": "src\\tests\\ol_lrc_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* issue 113 */\n", "func_signal": "void test_no_newline ()", "code": "{\n  const char *FILENAME = \"lrc_no_newline.lrc\";\n  struct OlLrcParser *parser = ol_lrc_parser_new_from_file (FILENAME);\n  union OlLrcToken *token = NULL;\n  while ((token = ol_lrc_parser_next_token (parser)) != NULL)\n  {\n    if (ol_lrc_token_get_type (token) == OL_LRC_TOKEN_TEXT)\n      ol_test_expect (strcmp (token->text.text, \"lyric\") == 0);\n    ol_lrc_token_free (token);\n  }\n  ol_lrc_parser_free (parser);\n}", "path": "src\\tests\\ol_lrc_parser_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Download options */\n", "func_signal": "void\nol_option_download_engine_changed (GtkComboBox *cb,\n                                   gpointer user_data)", "code": "{\n  OlConfig *config = ol_config_get_instance ();\n  const char *engine = ol_lrc_engine_list_get_name (options.download_engine);\n  if (engine != NULL)\n  {\n    ol_config_set_string (config, \n                          \"Download\", \n                          \"download-engine\", \n                          engine);\n  }\n  else\n  {\n    ol_error (\"Failed to get the name of engine\");\n  }\n}", "path": "src\\ol_option.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Issue 70 */\n", "func_signal": "void no_newline_test ()", "code": "{\n  const char *DATAFILE = \"lrc_no_newline.lrc\";\n  struct OlLrc *lrc = ol_lrc_new (DATAFILE);\n  const struct OlLrcItem *item = ol_lrc_get_item (lrc, 0);\n  ol_test_expect (ol_lrc_item_get_lyric (item) != NULL);\n  ol_test_expect (strcmp (ol_lrc_item_get_lyric (item), \"lyric\") == 0);\n  ol_lrc_free (lrc);\n}", "path": "src\\tests\\ol_lrc_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* OSD options */\n", "func_signal": "void\nol_option_font_changed (GtkWidget *widget)", "code": "{\n  GtkFontButton *font = GTK_FONT_BUTTON (widget);\n  if (font != NULL)\n  {\n    OlConfig *config = ol_config_get_instance ();\n    gchar *font_family = NULL;\n    double font_size;\n    ol_option_get_font_info (font, &font_family, &font_size);\n    ol_config_set_string (config,\n                          \"OSD\",\n                          \"font-family\",\n                          font_family);\n    ol_config_set_double (config,\n                          \"OSD\",\n                          \"font-size\",\n                          font_size);\n    g_free (font_family);\n  }\n}", "path": "src\\ol_option.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* VOID:STRING,STRING (marshal:1) */\n", "func_signal": "void\nol_marshal_VOID__STRING_STRING (GClosure     *closure,\n                                GValue       *return_value G_GNUC_UNUSED,\n                                guint         n_param_values,\n                                const GValue *param_values,\n                                gpointer      invocation_hint G_GNUC_UNUSED,\n                                gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer     data1,\n                                                    gpointer     arg_1,\n                                                    gpointer     arg_2,\n                                                    gpointer     data2);\n  register GMarshalFunc_VOID__STRING_STRING callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 3);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_string (param_values + 1),\n            g_marshal_value_peek_string (param_values + 2),\n            data2);\n}", "path": "src\\ol_marshal.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Path options */\n", "func_signal": "void\nol_option_save_path_pattern ()", "code": "{\n  OlConfig *config = ol_config_get_instance ();\n  if (options.lrc_path != NULL)\n  {\n    GtkTreeView *view = GTK_TREE_VIEW (options.lrc_path);\n    char **list = get_list_content (view);\n    if (list)\n    {\n      ol_config_set_str_list (config,\n                              \"General\",\n                              \"lrc-path\",\n                              (const char **)list,\n                              g_strv_length (list));\n      g_strfreev (list);\n    }\n  }\n}", "path": "src\\ol_option.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* bug #1 */\n", "func_signal": "void test_long_url ()", "code": "{\n  printf (\"%s\\n\", __FUNCTION__);\n  int lrc_count;\n  OlMusicInfo music_info;\n  music_info.title = \"Little Lotte/The Mirror (Angel of Music)\";\n  music_info.artist = \"\u6cc9\u3053\u306a\u305f\uff08\u5e73\u91ce\u7dbe\uff09\uff0c\u67ca\u304b\u304c\u307f\uff08\u52a0\u85e4\u82f1\u7f8e\u91cc\uff09\uff0c\u67ca\u3064\u304b\u3055\uff08\u798f\u539f\u9999\u7e54\uff09\uff0c\u9ad8\u826f\u307f\u3086\u304d\uff08\u9060\u85e4\u7dbe\uff09\";\n  OlLrcCandidate *candidates = ol_lrc_fetch_get_engine (enginename)->search (&music_info, &lrc_count, \"UTF-8\");\n}", "path": "src\\tests\\ol_lrc_fetch_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/** \n * @brief download the lrc and store it in the file system\n */\n", "func_signal": "static int\ndummy_download (OlLrcCandidate *candidates,\n                const char *pathname,\n                const char *charset)", "code": "{\n  fprintf (stderr, \"downloading: title: %s, artist: %s, url: %s\\n\",\n           candidates->title, candidates->artist, candidates->url);\n  sleep (2);\n  return TRUE;\n}", "path": "src\\tests\\ol_lrc_fetch_module_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/** \n * Return real position in milliseconds\n * Because Rhythmbox return position only in seconds, which means the position\n * is rounded to 1000, so we need to simulate a timer to get proper time\n * in milliseconds\n * @param time rounded time in milliseconds\n * \n * @return \n */\n", "func_signal": "static int\nol_player_rhythmbox_get_real_ms (int time)", "code": "{\n  if (ol_player_rhythmbox_get_status () != OL_PLAYER_PLAYING)\n  {\n    int real_time = ol_elapse_emulator_get_last_ms (&elapse, time);\n    /* reset timer to current time to avoid error on resume playing */\n    ol_elapse_emulator_init (&elapse, real_time, elapse.accuracy);\n    return real_time;\n  }\n  else\n    return ol_elapse_emulator_get_real_ms (&elapse, time);\n}", "path": "src\\ol_player_rhythmbox.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "///path/to/lrc/no/artist2\";\n", "func_signal": "OlMusicInfo *\nprepare_music ()", "code": "{\n  OlMusicInfo *info = NULL;\n  info = ol_music_info_new ();\n  ol_music_info_set_title (info, TITLE);\n  ol_music_info_set_artist (info, ARTIST);\n  ol_music_info_set_album (info, ALBUM);\n  ol_music_info_set_uri (info, URI);\n  ol_music_info_set_track_number (info, TRACK);\n  return info;\n}", "path": "src\\tests\\ol_lrclib_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* Final wrapup - pad to MD5_DATA_SIZE-byte boundary with the bit\n * pattern 1 0* (64-bit count of bits processed, LSB-first) */\n", "func_signal": "static void\nmd5_final(struct md5_ctx *ctx)", "code": "{\n  guint32 data[MD5_DATA_LENGTH];\n  unsigned i;\n  unsigned words;\n\n  i = ctx->index;\n\n  /* Set the first char of padding to 0x80. This is safe since there\n   * is always at least one byte free */\n  assert(i < MD5_DATA_SIZE);\n  ctx->block[i++] = 0x80;\n\n  /* Fill rest of word */\n  for( ; i & 3; i++)\n    ctx->block[i] = 0;\n\n  /* i is now a multiple of the word size 4 */\n  words = i >> 2;\n  for (i = 0; i < words; i++)\n    data[i] = LE_READ_UINT32(ctx->block + 4*i);\n\n  if (words > (MD5_DATA_LENGTH-2))\n    { /* No room for length in this block. Process it and\n       * pad with another one */\n      for (i = words ; i < MD5_DATA_LENGTH; i++)\n        data[i] = 0;\n      md5_transform(ctx->digest, data);\n      for (i = 0; i < (MD5_DATA_LENGTH-2); i++)\n        data[i] = 0;\n    }\n  else\n    for (i = words ; i < MD5_DATA_LENGTH - 2; i++)\n      data[i] = 0;\n\n  /* There are 512 = 2^9 bits in one block\n   * Little-endian order => Least significant word first */\n\n  data[MD5_DATA_LENGTH-1] = (ctx->count_h << 9) | (ctx->count_l >> 23);\n  data[MD5_DATA_LENGTH-2] = (ctx->count_l << 9) | (ctx->index << 3);\n  md5_transform(ctx->digest, data);\n}", "path": "src\\ol_md5.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* issue 80 */\n", "func_signal": "void test_bom ()", "code": "{\n  const char *FILENAME = \"lrc_bom.lrc\";\n  struct OlLrcParser *parser = ol_lrc_parser_new_from_file (FILENAME);\n  union OlLrcToken *token = NULL;\n  ol_test_expect ((token = ol_lrc_parser_next_token (parser)) != NULL);\n  ol_test_expect (ol_lrc_token_get_type (token) == OL_LRC_TOKEN_TIME);\n  ol_lrc_token_free (token);\n  ol_lrc_parser_free (parser);\n}", "path": "src\\tests\\ol_lrc_parser_test.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/* We have xmmsv_t, so things are easy */\n", "func_signal": "static int\nxmmsv_dict_get_string (xmmsv_t *dict,\n                       const char *key,\n                       const char **val)", "code": "{\n  xmmsv_t *dict_entry;\n  return (xmmsv_dict_get (dict, key, &dict_entry) &&\n          xmmsv_get_string (dict_entry, val));\n}", "path": "src\\ol_player_xmms2.c", "repo_name": "WilliamRen/osd-lyrics", "stars": 13, "license": "gpl-3.0", "language": "c", "size": 1074}
{"docstring": "/*\n * Delete the given node from the list.\n */\n", "func_signal": "lnode_t *list_delete(list_t *list, lnode_t *del)", "code": "{\n    lnode_t *next = del->next;\n    lnode_t *prev = del->prev;\n\n    assert (list_contains(list, del));\n\n    prev->next = next;\n    next->prev = prev;\n    list->nodecount--;\n\n    del->next = del->prev = NULL;\n\n    return del;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Return a node to a node pool. A node must be returned to the pool\n * from which it came.\n */\n", "func_signal": "void lnode_return(lnodepool_t *pool, lnode_t *node)", "code": "{\n    assert (lnode_pool_isfrom(pool, node));\n    assert (!lnode_is_in_a_list(node));\n\n    node->next = pool->fre;\n    node->prev = node;\n    pool->fre = node;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Insert the node ``new'' into the list immediately after ``this'' node.\n */\n", "func_signal": "void list_ins_after(list_t *list, lnode_t *new, lnode_t *this)", "code": "{\n    lnode_t *that = this->next;\n\n    assert (new != NULL);\n    assert (!list_contains(list, new));\n    assert (!lnode_is_in_a_list(new));\n    assert (this == list_nil(list) || list_contains(list, this));\n    assert (list->nodecount + 1 > list->nodecount);\n\n    new->prev = this;\n    new->next = that;\n    that->prev = new;\n    this->next = new;\n    list->nodecount++;\n\n    assert (list->nodecount <= list->maxcount);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Retrieve the node's predecessor. See comment for lnode_next().\n */\n", "func_signal": "lnode_t *list_prev(list_t *list, lnode_t *lnode)", "code": "{\n    assert (list_contains(list, lnode));\n\n    if (lnode->prev == list_nil(list))\n\treturn NULL;\n    return lnode->prev;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Split off a trailing sequence of nodes from the source list and relocate\n * them to the tail of the destination list. The trailing sequence begins\n * with node ``first'' and terminates with the last node of the source\n * list. The nodes are added to the end of the new list in their original\n * order.\n */\n", "func_signal": "void list_transfer(list_t *dest, list_t *source, lnode_t *first)", "code": "{\n    listcount_t moved = 1;\n    lnode_t *last;\n\n    assert (first == NULL || list_contains(source, first));\n\n    if (first == NULL)\n\treturn;\n\n    last = source->nilnode.prev;\n\n    source->nilnode.prev = first->prev;\n    first->prev->next = &source->nilnode;\n\n    last->next = &dest->nilnode;\n    first->prev = dest->nilnode.prev;\n    dest->nilnode.prev->next = first;\n    dest->nilnode.prev = last;\n\n    while (first != last) {\n\tfirst = first->next;\n\tmoved++;\n    }\n    \n    /* assert no overflows */\n    assert (source->nodecount - moved <= source->nodecount);\n    assert (dest->nodecount + moved >= dest->nodecount);\n\n    /* assert no weirdness */\n    assert (moved <= source->nodecount);\n\n    source->nodecount -= moved;\n    dest->nodecount += moved;\n\n    /* assert list sanity */\n    assert (list_verify(source));\n    assert (list_verify(dest));\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Destroy a dynamically allocated node.\n */\n", "func_signal": "void lnode_destroy(lnode_t *lnode)", "code": "{\n    assert (!lnode_is_in_a_list(lnode));\n    free(lnode);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Insert the node ``new'' into the list immediately before ``this'' node.\n */\n", "func_signal": "void list_ins_before(list_t *list, lnode_t *new, lnode_t *this)", "code": "{\n    lnode_t *that = this->prev;\n\n    assert (new != NULL);\n    assert (!list_contains(list, new));\n    assert (!lnode_is_in_a_list(new));\n    assert (this == list_nil(list) || list_contains(list, this));\n    assert (list->nodecount + 1 > list->nodecount);\n\n    new->next = this;\n    new->prev = that;\n    that->next = new;\n    this->prev = new;\n    list->nodecount++;\n\n    assert (list->nodecount <= list->maxcount);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Dynamically allocate a list object using malloc(), and initialize it so that\n * it is a valid empty list. If the list is to be ``unbounded'', the maxcount\n * should be specified as LISTCOUNT_T_MAX, or, alternately, as -1.\n */\n", "func_signal": "list_t *list_create(listcount_t maxcount)", "code": "{\n    list_t *new = malloc(sizeof *new);\n    if (new) {\n\tassert (maxcount != 0);\n\tnew->nilnode.next = &new->nilnode;\n\tnew->nilnode.prev = &new->nilnode;\n\tnew->nodecount = 0;\n\tnew->maxcount = maxcount;\n    }\n    return new;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Determine whether the given pool is from this pool.\n */\n", "func_signal": "int lnode_pool_isfrom(lnodepool_t *pool, lnode_t *node)", "code": "{\n    listcount_t i;\n\n    /* this is carefully coded this way because ANSI C forbids pointers\n       to different objects from being subtracted or compared other\n       than for exact equality */\n\n    for (i = 0; i < pool->size; i++) {\n\tif (pool->pool + i == node)\n\t    return 1;\n    }\n    return 0;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Retrieve the node's successor. If there is no successor, \n * NULL is returned.\n */\n", "func_signal": "lnode_t *list_next(list_t *list, lnode_t *lnode)", "code": "{\n    assert (list_contains(list, lnode));\n\n    if (lnode->next == list_nil(list))\n\treturn NULL;\n    return lnode->next;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Borrow a node from a node pool. Returns a null pointer if the pool\n * is exhausted. \n */\n", "func_signal": "lnode_t *lnode_borrow(lnodepool_t *pool, void *data)", "code": "{\n    lnode_t *new = pool->fre;\n    if (new) {\n\tpool->fre = new->next;\n\tnew->data = data;\n\tnew->next = NULL;\n\tnew->prev = NULL;\n    }\n    return new;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Initialize a node pool object to use a user-supplied set of nodes.\n * The ``nodes'' pointer refers to an array of lnode_t objects, containing\n * ``n'' elements.\n */\n", "func_signal": "lnodepool_t *lnode_pool_init(lnodepool_t *pool, lnode_t *nodes, listcount_t n)", "code": "{\n    listcount_t i;\n\n    assert (n != 0);\n\n    pool->pool = nodes;\n    pool->fre = nodes;\n    pool->size = n;\n    for (i = 0; i < n - 1; i++) {\n\tnodes[i].next = nodes + i + 1;\n    }\n    nodes[i].next = NULL;\n    nodes[i].prev = nodes;\t/* to make sure node is marked ``on list'' */\n    return pool;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Return 1 if the list is in sorted order, 0 otherwise\n */\n", "func_signal": "int list_is_sorted(list_t *list, int compare(const void *, const void *))", "code": "{\n    lnode_t *node, *next, *nil;\n\n    next = nil = list_nil(list);\n    node = list_first_priv(list);\n\n    if (node != nil)\n\tnext = lnode_next(node);\n\n    for (; next != nil; node = next, next = lnode_next(next)) {\n\tif (compare(lnode_get(node), lnode_get(next)) > 0)\n\t    return 0;\n    }\n\n    return 1;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Free all of the nodes of a list. The list must contain only \n * dynamically allocated nodes. After this call, the list\n * is empty.\n */\n", "func_signal": "void list_destroy_nodes(list_t *list)", "code": "{\n    lnode_t *lnode = list_first_priv(list), *nil = list_nil(list), *tmp;\n\n    while (lnode != nil) {\n\ttmp = lnode->next;\n\tlnode->next = NULL;\n\tlnode->prev = NULL;\n\tlnode_destroy(lnode);\n\tlnode = tmp;\n    }\n\n    list_init(list, list->maxcount);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * For each node in the list, execute the given function. The list,\n * current node and the given context pointer are passed on each\n * call to the function.\n */\n", "func_signal": "void list_process(list_t *list, void *context,\n\tvoid (* function)(list_t *list, lnode_t *lnode, void *context))", "code": "{\n    lnode_t *node = list_first_priv(list), *next, *nil = list_nil(list);\n\n    while (node != nil) {\n\t/* check for callback function deleting\t*/\n\t/* the next node from under us\t\t*/\n\tassert (list_contains(list, node));\n\tnext = node->next;\n\tfunction(list, node, context);\n\tnode = next;\n    }\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Retrieve the first node of the list\n */\n", "func_signal": "lnode_t *list_first(list_t *list)", "code": "{\n    if (list->nilnode.next == &list->nilnode)\n\treturn NULL;\n    return list->nilnode.next;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Create a dynamically allocated pool of n nodes.\n */\n", "func_signal": "lnodepool_t *lnode_pool_create(listcount_t n)", "code": "{\n    lnodepool_t *pool;\n    lnode_t *nodes;\n\n    assert (n != 0);\n\n    pool = malloc(sizeof *pool);\n    if (!pool)\n\treturn NULL;\n    nodes = malloc(n * sizeof *nodes);\n    if (!nodes) {\n\tfree(pool);\n\treturn NULL;\n    }\n    lnode_pool_init(pool, nodes, n);\n    return pool;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Dynamically allocate a list node and assign it the given piece of data.\n */\n", "func_signal": "lnode_t *lnode_create(void *data)", "code": "{\n    lnode_t *new = malloc(sizeof *new);\n    if (new) {\n\tnew->data = data;\n\tnew->next = NULL;\n\tnew->prev = NULL;\n    }\n    return new;\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Destroy a dynamically allocated list object.\n * The client must remove the nodes first.\n */\n", "func_signal": "void list_destroy(list_t *list)", "code": "{\n    assert (list_isempty(list));\n    free(list);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/*\n * Return all of the nodes of a list to a node pool. The nodes in\n * the list must all have come from the same pool.\n */\n", "func_signal": "void list_return_nodes(list_t *list, lnodepool_t *pool)", "code": "{\n    lnode_t *lnode = list_first_priv(list), *tmp, *nil = list_nil(list);\n\n    while (lnode != nil) {\n\ttmp = lnode->next;\n\tlnode->next = NULL;\n\tlnode->prev = NULL;\n\tlnode_return(pool, lnode);\n\tlnode = tmp;\n    }\n\n    list_init(list, list->maxcount);\n}", "path": "list.c", "repo_name": "manuel/pool", "stars": 9, "license": "None", "language": "c", "size": 149}
{"docstring": "/**\n * g_option_context_set_summary:\n * @context: a #GOptionContext\n * @summary: a string to be shown in <option>--help</option> output \n *  before the list of options, or %NULL\n * \n * Adds a string to be displayed in <option>--help</option> output\n * before the list of options. This is typically a summary of the\n * program functionality. \n *\n * Note that the summary is translated (see \n * g_option_context_set_translate_func()).\n *\n * Since: 2.12\n */\n", "func_signal": "void\ng_option_context_set_summary (GOptionContext *context,\n\t\t\t      const gchar    *summary)", "code": "{\n  g_return_if_fail (context != NULL);\n\n  g_free (context->summary);\n  context->summary = g_strdup (summary);\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* --- initialization --- */\n", "func_signal": "void\ng_type_init_with_debug_flags (GTypeDebugFlags debug_flags)", "code": "{\n  G_LOCK_DEFINE_STATIC (type_init_lock);\n  const gchar *env_string;\n  GTypeInfo info;\n  TypeNode *node;\n  GType type;\n  \n  G_LOCK (type_init_lock);\n  \n  G_WRITE_LOCK (&type_rw_lock);\n  \n  if (static_quark_type_flags)\n    {\n      G_WRITE_UNLOCK (&type_rw_lock);\n      G_UNLOCK (type_init_lock);\n      return;\n    }\n  \n  /* setup GObject library wide debugging flags */\n  _g_type_debug_flags = debug_flags & G_TYPE_DEBUG_MASK;\n  env_string = g_getenv (\"GOBJECT_DEBUG\");\n  if (env_string != NULL)\n    {\n      static GDebugKey debug_keys[] = {\n\t{ \"objects\", G_TYPE_DEBUG_OBJECTS },\n\t{ \"signals\", G_TYPE_DEBUG_SIGNALS },\n      };\n      \n      _g_type_debug_flags |= g_parse_debug_string (env_string,\n\t\t\t\t\t\t   debug_keys,\n\t\t\t\t\t\t   sizeof (debug_keys) / sizeof (debug_keys[0]));\n      env_string = NULL;\n    }\n  \n  /* quarks */\n  static_quark_type_flags = g_quark_from_static_string (\"-g-type-private--GTypeFlags\");\n  static_quark_iface_holder = g_quark_from_static_string (\"-g-type-private--IFaceHolder\");\n  static_quark_dependants_array = g_quark_from_static_string (\"-g-type-private--dependants-array\");\n  \n  /* type qname hash table */\n  static_type_nodes_ht = g_hash_table_new (g_direct_hash, g_direct_equal);\n  \n  /* invalid type G_TYPE_INVALID (0)\n   */\n  static_fundamental_type_nodes[0] = NULL;\n  \n  /* void type G_TYPE_NONE\n   */\n  node = type_node_fundamental_new_W (G_TYPE_NONE, g_intern_static_string (\"void\"), 0);\n  type = NODE_TYPE (node);\n  g_assert (type == G_TYPE_NONE);\n  \n  /* interface fundamental type G_TYPE_INTERFACE (!classed)\n   */\n  memset (&info, 0, sizeof (info));\n  node = type_node_fundamental_new_W (G_TYPE_INTERFACE, g_intern_static_string (\"GInterface\"), G_TYPE_FLAG_DERIVABLE);\n  type = NODE_TYPE (node);\n  type_data_make_W (node, &info, NULL);\n  g_assert (type == G_TYPE_INTERFACE);\n  \n  G_WRITE_UNLOCK (&type_rw_lock);\n  \n  g_value_c_init ();\n\n  /* G_TYPE_TYPE_PLUGIN\n   */\n  g_type_plugin_get_type ();\n  \n  /* G_TYPE_* value types\n   */\n  g_value_types_init ();\n  \n  /* G_TYPE_ENUM & G_TYPE_FLAGS\n   */\n  g_enum_types_init ();\n  \n  /* G_TYPE_BOXED\n   */\n  g_boxed_type_init ();\n  \n  /* G_TYPE_PARAM\n   */\n  g_param_type_init ();\n  \n  /* G_TYPE_OBJECT\n   */\n  g_object_type_init ();\n  \n  /* G_TYPE_PARAM_* pspec types\n   */\n  g_param_spec_types_init ();\n  \n  /* Value Transformations\n   */\n  g_value_transforms_init ();\n  \n  /* Signal system\n   */\n  g_signal_init ();\n  \n  G_UNLOCK (type_init_lock);\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* _SC_THREAD_STACK_MIN || HAVE_PRIORITIES */\n", "func_signal": "static GMutex *\ng_mutex_new_posix_impl (void)", "code": "{\n  GMutex *result = (GMutex *) g_new (pthread_mutex_t, 1);\n  posix_check_cmd (pthread_mutex_init ((pthread_mutex_t *) result,\n\t\t\t\t       mutexattr_default));\n  return result;\n}", "path": "gthread\\gthread-posix.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_get_main_group:\n * @context: a #GOptionContext\n * \n * Returns a pointer to the main group of @context.\n * \n * Return value: the main group of @context, or %NULL if @context doesn't\n *  have a main group. Note that group belongs to @context and should\n *  not be modified or freed.\n *\n * Since: 2.6\n **/\n", "func_signal": "GOptionGroup *\ng_option_context_get_main_group (GOptionContext *context)", "code": "{\n  g_return_val_if_fail (context != NULL, NULL);\n\n  return context->main_group;\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* This is called to allocate and do the first part of initializing\n * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.\n *\n * A FALSE return indicates that we didn't find an init function for\n * this type/iface pair, so the vtable from the parent type should\n * be used. Note that the write lock is not modified upon a FALSE\n * return.\n */\n", "func_signal": "static gboolean\ntype_iface_vtable_base_init_Wm (TypeNode *iface,\n\t\t\t\tTypeNode *node)", "code": "{\n  IFaceEntry *entry;\n  IFaceHolder *iholder;\n  GTypeInterface *vtable = NULL;\n  TypeNode *pnode;\n  \n  /* type_iface_retrieve_holder_info_Wm() doesn't modify write lock for returning NULL */\n  iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);\n  if (!iholder)\n    return FALSE;\t/* we don't modify write lock upon FALSE */\n\n  type_iface_ensure_dflt_vtable_Wm (iface);\n\n  entry = type_lookup_iface_entry_L (node, iface);\n\n  g_assert (iface->data && entry && entry->vtable == NULL && iholder && iholder->info);\n  \n  entry->init_state = IFACE_INIT;\n\n  pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));\n  if (pnode)\t/* want to copy over parent iface contents */\n    {\n      IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);\n      \n      if (pentry)\n\tvtable = g_memdup (pentry->vtable, iface->data->iface.vtable_size);\n    }\n  if (!vtable)\n    vtable = g_memdup (iface->data->iface.dflt_vtable, iface->data->iface.vtable_size);\n  entry->vtable = vtable;\n  vtable->g_type = NODE_TYPE (iface);\n  vtable->g_instance_type = NODE_TYPE (node);\n  \n  if (iface->data->iface.vtable_init_base)\n    {\n      G_WRITE_UNLOCK (&type_rw_lock);\n      iface->data->iface.vtable_init_base (vtable);\n      G_WRITE_LOCK (&type_rw_lock);\n    }\n  return TRUE;\t/* initialized the vtable */\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_free:\n * @context: a #GOptionContext \n *\n * Frees context and all the groups which have been \n * added to it.\n *\n * Since: 2.6\n */\n", "func_signal": "void g_option_context_free (GOptionContext *context)", "code": "{\n  g_return_if_fail (context != NULL);\n\n  g_list_foreach (context->groups, (GFunc)g_option_group_free, NULL);\n  g_list_free (context->groups);\n\n  if (context->main_group) \n    g_option_group_free (context->main_group);\n\n  free_changes_list (context, FALSE);\n  free_pending_nulls (context, FALSE);\n  \n  g_free (context->parameter_string);\n  g_free (context->summary);\n  g_free (context->description);\n  \n  if (context->translate_notify)\n    (* context->translate_notify) (context->translate_data);\n\n  g_free (context);\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* --- type consistency checks --- */\n", "func_signal": "static gboolean\ncheck_plugin_U (GTypePlugin *plugin,\n\t\tgboolean     need_complete_type_info,\n\t\tgboolean     need_complete_interface_info,\n\t\tconst gchar *type_name)", "code": "{\n  /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U \n   */\n  if (!plugin)\n    {\n      g_warning (\"plugin handle for type `%s' is NULL\",\n\t\t type_name);\n      return FALSE;\n    }\n  if (!G_IS_TYPE_PLUGIN (plugin))\n    {\n      g_warning (\"plugin pointer (%p) for type `%s' is invalid\",\n\t\t plugin, type_name);\n      return FALSE;\n    }\n  if (need_complete_type_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_type_info)\n    {\n      g_warning (\"plugin for type `%s' has no complete_type_info() implementation\",\n\t\t type_name);\n      return FALSE;\n    }\n  if (need_complete_interface_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_interface_info)\n    {\n      g_warning (\"plugin for type `%s' has no complete_interface_info() implementation\",\n\t\t type_name);\n      return FALSE;\n    }\n  return TRUE;\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_group_free:\n * @group: a #GOptionGroup\n * \n * Frees a #GOptionGroup. Note that you must <emphasis>not</emphasis>\n * free groups which have been added to a #GOptionContext.\n *\n * Since: 2.6\n **/\n", "func_signal": "void\ng_option_group_free (GOptionGroup *group)", "code": "{\n  g_return_if_fail (group != NULL);\n\n  g_free (group->name);\n  g_free (group->description);\n  g_free (group->help_description);\n\n  g_free (group->entries);\n  \n  if (group->destroy_notify)\n    (* group->destroy_notify) (group->user_data);\n\n  if (group->translate_notify)\n    (* group->translate_notify) (group->translate_data);\n  \n  g_free (group);\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_set_main_group:\n * @context: a #GOptionContext\n * @group: the group to set as main group\n * \n * Sets a #GOptionGroup as main group of the @context. \n * This has the same effect as calling g_option_context_add_group(), \n * the only difference is that the options in the main group are \n * treated differently when generating <option>--help</option> output.\n *\n * Since: 2.6\n **/\n", "func_signal": "void\ng_option_context_set_main_group (GOptionContext *context,\n\t\t\t\t GOptionGroup   *group)", "code": "{\n  g_return_if_fail (context != NULL);\n  g_return_if_fail (group != NULL);\n\n  if (context->main_group)\n    {\n      g_warning (\"This GOptionContext already has a main group\");\n\n      return;\n    }\n  \n  context->main_group = group;\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_set_translation_domain:\n * @context: a #GOptionContext\n * @domain: the domain to use\n * \n * A convenience function to use gettext() for translating\n * user-visible strings. \n * \n * Since: 2.12\n **/\n", "func_signal": "void\ng_option_context_set_translation_domain (GOptionContext *context,\n\t\t\t\t\t const gchar     *domain)", "code": "{\n  g_return_if_fail (context != NULL);\n\n  g_option_context_set_translate_func (context, \n\t\t\t\t       (GTranslateFunc)dgettext_swapped,\n\t\t\t\t       g_strdup (domain),\n\t\t\t\t       g_free);\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_get_help_enabled:\n * @context: a #GOptionContext\n * \n * Returns whether automatic <option>--help</option> generation\n * is turned on for @context. See g_option_context_set_help_enabled().\n * \n * Returns: %TRUE if automatic help generation is turned on.\n *\n * Since: 2.6\n */\n", "func_signal": "gboolean \ng_option_context_get_help_enabled (GOptionContext *context)", "code": "{\n  g_return_val_if_fail (context != NULL, FALSE);\n  \n  return context->help_enabled;\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_group_set_error_hook:\n * @group: a #GOptionGroup\n * @error_func: a function to call when an error occurs\n * \n * Associates a function with @group which will be called \n * from g_option_context_parse() when an error occurs.\n *\n * Note that the user data to be passed to @pre_parse_func and\n * @post_parse_func can be specified when constructing the group\n * with g_option_group_new().\n *\n * Since: 2.6\n **/\n", "func_signal": "void\ng_option_group_set_error_hook (GOptionGroup     *group,\n\t\t\t       GOptionErrorFunc\t error_func)", "code": "{\n  g_return_if_fail (group != NULL);\n\n  group->error_func = error_func;  \n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* --- implementation details --- */\n", "func_signal": "gboolean\ng_type_test_flags (GType type,\n\t\t   guint flags)", "code": "{\n  TypeNode *node;\n  gboolean result = FALSE;\n  \n  node = lookup_type_node_I (type);\n  if (node)\n    {\n      guint fflags = flags & TYPE_FUNDAMENTAL_FLAG_MASK;\n      guint tflags = flags & TYPE_FLAG_MASK;\n      \n      if (fflags)\n\t{\n\t  GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);\n\t  \n\t  fflags = (finfo->type_flags & fflags) == fflags;\n\t}\n      else\n\tfflags = TRUE;\n      \n      if (tflags)\n\t{\n\t  G_READ_LOCK (&type_rw_lock);\n\t  tflags = (tflags & GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;\n\t  G_READ_UNLOCK (&type_rw_lock);\n\t}\n      else\n\ttflags = TRUE;\n      \n      result = tflags && fflags;\n    }\n  \n  return result;\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_group_set_parse_hooks:\n * @group: a #GOptionGroup\n * @pre_parse_func: a function to call before parsing, or %NULL\n * @post_parse_func: a function to call after parsing, or %NULL\n * \n * Associates two functions with @group which will be called \n * from g_option_context_parse() before the first option is parsed\n * and after the last option has been parsed, respectively.\n *\n * Note that the user data to be passed to @pre_parse_func and\n * @post_parse_func can be specified when constructing the group\n * with g_option_group_new().\n *\n * Since: 2.6\n **/\n", "func_signal": "void\ng_option_group_set_parse_hooks (GOptionGroup     *group,\n\t\t\t\tGOptionParseFunc  pre_parse_func,\n\t\t\t\tGOptionParseFunc  post_parse_func)", "code": "{\n  g_return_if_fail (group != NULL);\n\n  group->pre_parse_func = pre_parse_func;\n  group->post_parse_func = post_parse_func;  \n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* free result */\n", "func_signal": "g_type_interfaces (GType  type,\n\t\t   guint *n_interfaces)", "code": "{\n  TypeNode *node;\n  \n  node = lookup_type_node_I (type);\n  if (node && node->is_instantiatable)\n    {\n      GType *ifaces;\n      guint i;\n      \n      G_READ_LOCK (&type_rw_lock);\n      ifaces = g_new (GType, CLASSED_NODE_N_IFACES (node) + 1);\n      for (i = 0; i < CLASSED_NODE_N_IFACES (node); i++)\n\tifaces[i] = CLASSED_NODE_IFACES_ENTRIES (node)[i].iface_type;\n      ifaces[i] = 0;\n      \n      if (n_interfaces)\n\t*n_interfaces = CLASSED_NODE_N_IFACES (node);\n      G_READ_UNLOCK (&type_rw_lock);\n      \n      return ifaces;\n    }\n  else\n    {\n      if (n_interfaces)\n\t*n_interfaces = 0;\n      \n      return NULL;\n    }\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* pthread_mutex_lock, pthread_mutex_unlock can be taken directly, as\n   signature and semantic are right, but without error check then!!!!,\n   we might want to change this therefore. */\n", "func_signal": "static gboolean\ng_mutex_trylock_posix_impl (GMutex * mutex)", "code": "{\n  int result;\n\n  result = pthread_mutex_trylock ((pthread_mutex_t *) mutex);\n\n#ifdef G_THREADS_IMPL_POSIX\n  if (result == EBUSY)\n    return FALSE;\n#else /* G_THREADS_IMPL_DCE */\n  if (result == 0)\n    return FALSE;\n#endif\n\n  posix_check_err (posix_error (result), \"pthread_mutex_trylock\");\n  return TRUE;\n}", "path": "gthread\\gthread-posix.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* free result */\n", "func_signal": "g_type_children (GType  type,\n\t\t guint *n_children)", "code": "{\n  TypeNode *node;\n  \n  node = lookup_type_node_I (type);\n  if (node)\n    {\n      GType *children;\n      \n      G_READ_LOCK (&type_rw_lock);\t/* ->children is relocatable */\n      children = g_new (GType, node->n_children + 1);\n      memcpy (children, node->children, sizeof (GType) * node->n_children);\n      children[node->n_children] = 0;\n      \n      if (n_children)\n\t*n_children = node->n_children;\n      G_READ_UNLOCK (&type_rw_lock);\n      \n      return children;\n    }\n  else\n    {\n      if (n_children)\n\t*n_children = 0;\n      \n      return NULL;\n    }\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* NOTE: the functions g_private_get and g_private_set may not use\n   functions from gmem.c and gmessages.c */\n", "func_signal": "static void\ng_private_set_posix_impl (GPrivate * private_key, gpointer value)", "code": "{\n  if (!private_key)\n    return;\n  pthread_setspecific (*(pthread_key_t *) private_key, value);\n}", "path": "gthread\\gthread-posix.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/**\n * g_option_context_add_group:\n * @context: a #GOptionContext\n * @group: the group to add\n * \n * Adds a #GOptionGroup to the @context, so that parsing with @context\n * will recognize the options in the group. Note that the group will\n * be freed together with the context when g_option_context_free() is\n * called, so you must not free the group yourself after adding it\n * to a context.\n *\n * Since: 2.6\n **/\n", "func_signal": "void\ng_option_context_add_group (GOptionContext *context,\n\t\t\t    GOptionGroup   *group)", "code": "{\n  GList *list;\n\n  g_return_if_fail (context != NULL);\n  g_return_if_fail (group != NULL);\n  g_return_if_fail (group->name != NULL);\n  g_return_if_fail (group->description != NULL);\n  g_return_if_fail (group->help_description != NULL);\n\n  for (list = context->groups; list; list = list->next)\n    {\n      GOptionGroup *g = (GOptionGroup *)list->data;\n\n      if ((group->name == NULL && g->name == NULL) ||\n\t  (group->name && g->name && strcmp (group->name, g->name) == 0))\n\tg_warning (\"A group named \\\"%s\\\" is already part of this GOptionContext\", \n\t\t   group->name);\n    }\n\n  context->groups = g_list_append (context->groups, group);\n}", "path": "glib\\goption.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/* Assumes type's class already exists\n */\n", "func_signal": "static inline size_t\ntype_total_instance_size_I (TypeNode *node)", "code": "{\n  gsize total_instance_size;\n\n  total_instance_size = node->data->instance.instance_size;\n  if (node->data->instance.private_size != 0)\n    total_instance_size = ALIGN_STRUCT (total_instance_size) + node->data->instance.private_size;\n\n  return total_instance_size;\n}", "path": "gobject\\gtype.c", "repo_name": "prajnashi/glib", "stars": 9, "license": "other", "language": "c", "size": 9755}
{"docstring": "/** \n ** chimera_forward:\n ** is called whenever a message is forwarded toward the destination the func upcall \n ** should be  defined by the user application\n */\n", "func_signal": "void chimera_forward (ChimeraState * state, chimera_forward_upcall_t func)", "code": "{\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\tchglob->forward = func;\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** chimera_check_leafset: runs as a separate thread. \n ** it should send a PING message to each member of the leafset frequently and \n ** sends the leafset to other members of its leafset periodically. \n ** pinging frequecy is LEAFSET_CHECK_PERIOD.\n **\n */\n", "func_signal": "void *chimera_check_leafset (void *chstate)", "code": "{\n\n\tchar s[NETWORK_PACK_SIZE];\n\tMessage *m;\n\tChimeraHost **leafset;\n\tChimeraHost **table;\n\tint i, count = 0;\n\tChimeraState *state = (ChimeraState *) chstate;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\n\twhile (1)\n\t{\n\n\t\tleafset = route_neighbors (state, LEAFSET_SIZE);\n\t\tfor (i = 0; leafset[i] != NULL; i++)\n\t\t{\n\t\t\tif (chimera_ping (state, leafset[i]) == 1)\n\t\t\t{\n\t\t\t\tleafset[i]->failuretime = dtime ();\n\t\t\t\tif (LOGS)\n\t\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\t\"message send to host: %s:%d failed at time: %f!\\n\",\n\t\t\t\t\t\t\tleafset[i]->name, leafset[i]->port,\n\t\t\t\t\t\t\tleafset[i]->failuretime);\n\t\t\t\tif (leafset[i]->success_avg < BAD_LINK)\n\t\t\t\t{\n\t\t\t\t\tif (LOGS)\t\t\t\t  \n\t\t\t\t\t\tprintf (\"Deleting %s:%d \\n\",\n\t\t\t\t\t\t\t\tleafset[i]->name,\n\t\t\t\t\t\t\t\tleafset[i]->port);\n\t\t\t\t\troute_update (state, leafset[i], 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\thost_release (state, leafset[i]);\n\t\t}\n\t\tfree (leafset);\n\n\t\ttable = route_get_table (state);\n\t\tfor (i = 0; table[i] != NULL; i++)\n\t\t{\n\t\t\tif (chimera_ping (state, table[i]) == 1)\n\t\t\t{\n\t\t\t\ttable[i]->failuretime = dtime ();\n\t\t\t\tif (LOGS)\n\t\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\t\"message send to host: %s:%d failed at time: %f!\\n\",\n\t\t\t\t\t\t\ttable[i]->name, table[i]->port,\n\t\t\t\t\t\t\ttable[i]->failuretime);\n\t\t\t\tif (table[i]->success_avg < BAD_LINK)\n\t\t\t\t{\n\t\t\t\t\troute_update (state, table[i], 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\thost_release (state, table[i]);\n\t\t}\n\t\tfree (table);\n\n\t\t/* send leafset exchange data every  3 times that pings the leafset */\n\t\tif (count == 2)\n\t\t{\n\t\t\tcount = 0;\n\t\t\tleafset = route_neighbors (state, LEAFSET_SIZE);\n\t\t\thost_encode (s, NETWORK_PACK_SIZE, chglob->me);\n\t\t\tstrcat (s, \"\\n\");\t/* add a spacer */\n\t\t\tchimera_encodehosts (state->log, s + strlen (s),\n\t\t\t\t\tNETWORK_PACK_SIZE - strlen (s),\n\t\t\t\t\tleafset);\n\n\t\t\tfor (i = 0; leafset[i] != NULL; i++)\n\t\t\t{\n\t\t\t\tm = message_create (leafset[i]->key,\n\t\t\t\t\t\tCHIMERA_PIGGY, strlen (s) + 1,\n\t\t\t\t\t\ts);\n\t\t\t\tif (!message_send (state, leafset[i], m, TRUE))\n\t\t\t\t{\n\t\t\t\t\tif (LOGS)\n\t\t\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\t\t\"sending leafset update to %s:%d failed!\\n\",\n\t\t\t\t\t\t\t\tleafset[i]->name,\n\t\t\t\t\t\t\t\tleafset[i]->port);\n\t\t\t\t\tif (leafset[i]->success_avg < BAD_LINK)\n\t\t\t\t\t{\n\t\t\t\t\t\troute_update (state, leafset[i],\n\t\t\t\t\t\t\t\t0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmessage_free (m);\n\t\t\t\thost_release (state, leafset[i]);\n\t\t\t}\n\n\t\t\tfree (leafset);\n\n\t\t}\n\t\telse\n\t\t\tcount++;\n\n\t\tsleep (LEAFSET_CHECK_PERIOD);\n\t}\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** chimera_init:\n ** Initializes Chimera on port port and returns the ChimeraState * which \n ** contains global state of different chimera modules.\n */\n", "func_signal": "ChimeraState *chimera_init (int port)", "code": "{\n\n\tchar name[256];\n\tstruct hostent *he;\n\tChimeraState *state;\n\tChimeraGlobal *cg;\n\t//  mtrace();\n\tstate = (ChimeraState *) malloc (sizeof (ChimeraState));\n\tcg = (ChimeraGlobal *) malloc (sizeof (ChimeraGlobal));\n\tstate->chimera = (void *) cg;\n\n\tstate->log = log_init ();\n\tlog_direct (state->log, LOG_ERROR, stderr);\n\tkey_init ();\n\n\tstate->message = message_init ((void *) state, port);\n\tif (state->message == NULL)\n\t{\n\t\treturn (NULL);\n\t}\n\n\tstate->host = host_init (state->log, 64);\n\tif (state->host == NULL)\n\t{\n\t\treturn (NULL);\n\t}\n\n\tif (gethostname (name, 256) != 0)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"chimera_init: gethostname: %s\\n\", \n\t\t\t\t\tstrerror (errno));\n\t\treturn (NULL);\n\t}\n\tif ((he = gethostbyname (name)) == NULL)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"chimera_init: gethostbyname: %s\\n\",\n\t\t\t\t\tstrerror (errno));\n\t\treturn (NULL);\n\t}\n\tstrcpy (name, he->h_name);\n\n\tcg->me = host_get (state, name, port);\n\n\tsprintf (name + strlen (name), \":%d\", port);\n\tkey_makehash (state->log, &(cg->me->key), name);\n\tcg->deliver = NULL;\n\tcg->forward = NULL;\n\tcg->update = NULL;\n\n\tstate->route = route_init (cg->me);\n\n\tmessage_handler (state, CHIMERA_JOIN, chimera_message, 1);\n\tmessage_handler (state, CHIMERA_JOIN_ACK, chimera_join_acknowledged, 1);\n\tmessage_handler (state, CHIMERA_UPDATE, chimera_update_message, 1);\n\tmessage_handler (state, CHIMERA_PIGGY, chimera_piggy_message, 1);\n\tmessage_handler (state, CHIMERA_JOIN_NACK, chimera_join_denied, 1);\n\tmessage_handler (state, CHIMERA_PING, chimera_ping_reply, 1);\n\n\t/* more message types can be defined here */\n\n\tpthread_mutex_init (&cg->lock, NULL);\n\tcg->join = sema_create (0);\n\n\treturn (state);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/* Dummy Job 2 */\n", "func_signal": "void count_print (void *in, void *dum)", "code": "{\n    int i, j;\n    i = *(int *) in;\n    printf (\"I is %d\\n\", i);\n\n    for (j = 0; j < i; j++)\n\tprintf (\"%d \", j);\n    printf (\"\\n\\n\");\n}", "path": "test\\job_test.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_check_leafset_init:\n ** initiates a separate thread that constantly checks to see if the leafset members  \n ** and table entries of the node are alive or not. \n **\n */\n", "func_signal": "int chimera_check_leafset_init (ChimeraState * state)", "code": "{\n\n\tpthread_attr_t attr;\n\tpthread_t tid;\n\n\tif (pthread_attr_init (&attr) != 0)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"(CHIMERA)pthread_attr_init: %s\", strerror (errno));\n\t\treturn (0);\n\t}\n\tif (pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM) != 0)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"(CHIMERA)pthread_attr_setscope: %s\",\n\t\t\t\t\tstrerror (errno));\n\t\tgoto out;\n\t}\n\tif (pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) != 0)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"(CHIMERA)pthread_attr_setdetachstate: %s\",\n\t\t\t\t\tstrerror (errno));\n\t\tgoto out;\n\t}\n\n\tif (pthread_create (&tid, &attr, chimera_check_leafset, (void *) state) !=\n\t\t\t0)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, \n\t\t\t\t\tLOG_ERROR, \"(CHIMERA)pthread_create: %s\",\n\t\t\t\t\tstrerror (errno));\n\t\tgoto out;\n\t}\n\n\treturn (1);\n\nout:\n\tpthread_attr_destroy (&attr);\n\treturn (0);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** chimera_send: \n ** Route a message of type to key containing size bytes of data. This will\n ** send data through the Chimera system and deliver it to the host closest to the\n ** key. \n */\n", "func_signal": "void chimera_send (ChimeraState * state, Key key, int type, uint32_t size,\n\t\tchar *data)", "code": "{\n\n\tMessage *message;\n\n\t/*\n\t * XXXPAT: this effectively does nothing right now, and it's unclear\n\t * why it's necessary even if it worked.\n\t */\n#if 0\n\tchar s[NETWORK_PACK_SIZE];\n\tuint32_t realsize;\n\trealsize = htonl ((uint32_t) size);\n\tmemcpy (s, &realsize, sizeof (uint32_t));\n\tmemcpy (s + sizeof (uint32_t), data, size);\n\tsize += sizeof (uint32_t);\n#endif\n\n\tmessage = message_create (key, type, size, data);\n\tchimera_message (state, message);\n\tmessage_free (message);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** chimera_join_denied\n ** internal function that is called when the sender of a JOIN message receives \n ** the JOIN_NACK message type which is join denial from the current key root \n ** in the network.\n */\n", "func_signal": "void chimera_join_denied (ChimeraState * state, Message * message)", "code": "{\n\n\tChimeraHost *host;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\thost = host_decode (state, message->payload);\n\n\tif (LOGS)\n\t\tlog_message (state->log, LOG_WARN, \n\t\t\t\t\"JOIN request rejected from %s:%d !\\n\",\n\t\t\t\thost->name, host->port);\n\n\tsleep (GRACEPERIOD);\n\n\tif (LOGS)\n\t\tlog_message (state->log, LOG_WARN, \n\t\t\t\t\"Re-sending JOIN message to %s:%d !\\n\",\n\t\t\t\tchglob->bootstrap->name, chglob->bootstrap->port);\n\tchimera_join (state, chglob->bootstrap);\n\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_deliver:\n ** is called whenever a message is delivered toward the destination the func upcall \n ** should be  defined by the user application\n */\n", "func_signal": "void chimera_deliver (ChimeraState * state, chimera_deliver_upcall_t func)", "code": "{\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\tchglob->deliver = func;\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** chimera_ping: \n ** sends a PING message to the host. The message is acknowledged in network layer.\n */\n", "func_signal": "int chimera_ping (ChimeraState * state, ChimeraHost * host)", "code": "{\n\n\tchar name[256];\n\tMessage *message;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\thost_encode (name, 256, chglob->me);\n\n\tif (host == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tmessage =\n\t\tmessage_create (chglob->me->key, CHIMERA_PING, strlen (name) + 1,\n\t\t\t\tname);\n\n\tif (!message_send (state, host, message, FALSE))\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_WARN, \"failed to ping host %s:%d\\n\",\n\t\t\t\t\thost->name, host->port);\n\t\tmessage_free (message);\n\t\treturn 1;\n\t}\n\n\tmessage_free (message);\n\treturn 0;\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_join:\n ** sends a JOIN message to bootstrap node and waits forever for the reply\n ** \n */\n", "func_signal": "void chimera_join (ChimeraState * state, ChimeraHost * bootstrap)", "code": "{\n\n\tchar name[256];\n\tMessage *message;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\thost_encode (name, 256, chglob->me);\n\n\tif (bootstrap == NULL)\n\t{\n\t\tif (!(chimera_check_leafset_init (state)))\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\t\"chimera_check_leafset_init FAILED \\n\");\n\t\treturn;\n\t}\n\n\tchglob->bootstrap = host_get (state, bootstrap->name, bootstrap->port);\n\n\tmessage = message_create (chglob->me->key, CHIMERA_JOIN, strlen (name) + 1,\n\t\t\tname);\n\tif (!message_send (state, bootstrap, message, TRUE))\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"chimera_join: failed to contact bootstrap host %s:%d\\n\",\n\t\t\t\t\tbootstrap->name, bootstrap->port);\n\t}\n\n\tsema_p (chglob->join, 0.0);\n\tmessage_free (message);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/* Dummy Job 1 */\n", "func_signal": "void test_print (void *in, void *dum)", "code": "{\n    char *c;\n    c = (char *) in;\n    printf (\" %c \\n\", *c);\n}", "path": "test\\job_test.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** chimera_route:\n ** routes a message one step closer to its destination key. Delivers\n ** the message to its destination if it is the current host through the\n ** deliver upcall, otherwise it makes the route upcall \n */\n", "func_signal": "void chimera_route (ChimeraState * state, Key * key, Message * message,\n\t\tChimeraHost * host)", "code": "{\n\n\tChimeraHost **tmp;\n\t//ChimeraHost **piggy;\n\tMessage *real;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\treal = message;\n\n\ttmp = route_lookup (state, *key, 1, 0);\n\n\t/* this is to avoid sending JOIN request to the node that\n\t ** its information is already in the routing table  ****/\n\n\tif ((tmp[0] != NULL) && (message->type == CHIMERA_JOIN)\n\t\t\t&& (key_equal (tmp[0]->key, *key)))\n\t{\n\t\tfree (tmp);\n\t\ttmp = route_lookup (state, *key, 2, 0);\n\t\tif (tmp[1] != NULL && key_equal (tmp[0]->key, *key))\n\t\t\ttmp[0] = tmp[1];\n\t}\n\tif (host == NULL && tmp[0] != chglob->me)\n\t{\n\t\thost = tmp[0];\n\t}\n\tif (tmp[0] == chglob->me)\n\t{\n\t\thost = NULL;\n\t}\n\tfree (tmp);\n\ttmp = NULL;\n\n\t/* if I am the only host or the closest host is me, deliver the message */\n\tif (host == NULL)\n\t{\n\t\tif (chglob->deliver != NULL)\n\t\t{\n\t\t\tchglob->deliver (key, real);\n\t\t}\n\t\tif (message->type == CHIMERA_JOIN)\n\t\t{\n\t\t\thost = host_decode (state, message->payload);\n\t\t\tchimera_join_complete (state, host);\n\t\t}\n\t}\n\n\t/* otherwise, route it */\n\telse\n\t{\n\t\tif (chglob->forward != NULL)\n\t\t{\n\t\t\tchglob->forward (&key, &real, &host);\n\t\t}\n\t\tmessage = real;\n\n\t\twhile (!message_send (state, host, message, TRUE))\n\t\t{\n\n\t\t\thost->failuretime = dtime ();\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\"message send to host: %s:%d at time: %f failed!\\n\",\n\t\t\t\t\t\thost->name, host->port, host->failuretime);\n\n\t\t\t/* remove the faulty node from the routing table */\n\t\t\tif (host->success_avg < BAD_LINK)\n\t\t\t\troute_update (state, host, 0);\n\n\t\t\tif (tmp != NULL)\n\t\t\t\tfree (tmp);\n\t\t\ttmp = route_lookup (state, *key, 1, 0);\n\t\t\thost = tmp[0];\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\"rerouting through %s:%d!\\n\", host->name,\n\t\t\t\t\t\thost->port);\n\t\t}\n\n\t\t/* in each hop in the way to the key root nodes\n\t\t   send their routing info to the joining node  */\n\n\t\tif (message->type == CHIMERA_JOIN)\n\t\t\tchimera_send_rowinfo (state, message);\n\n\t\tif (tmp != NULL)\n\t\t\tfree (tmp);\n\t}\n\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/* Dummy Job 3 \n * jut burn some CPU cycle */\n", "func_signal": "void busy_cycle (void *in)", "code": "{\n    int *cycle;\n    cycle = (int *) in;\n    // printf(\"CYCLE is %d\\n\", *cycle);\n\n    int i;\n    for (i = 0; i < *cycle; i++)\n\trandom ();\n}", "path": "test\\job_test.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_send_rowinfo:\n ** sends matching row of its table to the joining node while \n ** forwarding the message toward the root of the joining node\n **\n */\n", "func_signal": "void chimera_send_rowinfo (ChimeraState * state, Message * message)", "code": "{\n\tint32_t size;\n\tChimeraHost **rowinfo;\n\tchar s[NETWORK_PACK_SIZE];\n\tChimeraHost *host;\n\tMessage *msg;\n\n\thost = host_decode (state, message->payload);\n\n\t/* send one row of our routing table back to joiner #host# */\n\trowinfo = route_row_lookup (state, host->key);\n\tsize = chimera_encodehosts (state->log, s, NETWORK_PACK_SIZE, rowinfo);\n\tmsg = message_create (host->key, CHIMERA_PIGGY, size, s);\n\tif (!message_send (state, host, msg, TRUE)) {\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"Sending row information to node: %s:%d failed\\n\",\n\t\t\t\t\thost->name, host->port);\n\t}\n\tfree (rowinfo);\n\tmessage_free (msg);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** chimera_join_complete:\n ** internal function that is called at the destination of a JOIN message. This\n ** call encodes the leaf set of the current host and sends it to the joiner.\n ** \n */\n", "func_signal": "void chimera_join_complete (ChimeraState * state, ChimeraHost * host)", "code": "{\n\n\tchar s[NETWORK_PACK_SIZE];\n\tMessage *m;\n\tChimeraHost **leafset;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) (state->chimera);\n\n\t/* copy myself into the reply */\n\thost_encode (s, NETWORK_PACK_SIZE, chglob->me);\n\tstrcat (s, \"\\n\");\t\t/* add a spacer */\n\n\t/* check to see if the node has just left the network or not */\n\tif ((dtime () - host->failuretime) < GRACEPERIOD)\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\"JOIN request from node: %s:%d rejected ,elapsed time since failure = %f sec\\n\",\n\t\t\t\t\thost->name, host->port,\n\t\t\t\t\tdtime () - host->failuretime);\n\n\t\tm = message_create (host->key, CHIMERA_JOIN_NACK, strlen (s) + 1,\n\t\t\t\ts);\n\t\tif (!message_send (state, host, m, TRUE))\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\"message_send NACK failed!\\n\");\n\t\tmessage_free (m);\n\t\treturn;\n\t}\n\n\t/* copy my leaf set into the reply */\n\tleafset = route_neighbors (state, LEAFSET_SIZE);\n\tchimera_encodehosts (state->log, s + strlen (s),\n\t\t\tNETWORK_PACK_SIZE - strlen (s), leafset);\n\tfree (leafset);\n\n\tm = message_create (host->key, CHIMERA_JOIN_ACK, strlen (s) + 1, s);\n\tif (!message_send (state, host, m, TRUE))\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_WARN, \"message_send ACK failed!\\n\");\n\t}\n\tmessage_free (m);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_update:\n ** is called whenever a node joines or leaves the leafset the func upcall \n ** should be  defined by the user application\n */\n", "func_signal": "void chimera_update (ChimeraState * state, chimera_update_upcall_t func)", "code": "{\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\tchglob->update = func;\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n * chimera_join_acknowledge:\n * called when the current host is joining the network and has just revieced\n * its leaf set. This function sends an update message to all nodes in its\n * new leaf set to announce its arrival.\n */\n", "func_signal": "void chimera_join_acknowledged (ChimeraState * state, Message * message)", "code": "{\n\n\tChimeraHost **host;\n\tMessage *m;\n\tchar s[256];\n\tint i;\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\n\thost_encode (s, 256, chglob->me);\n\thost = chimera_decodehosts (state, message->payload);\n\n\t/* announce my arrival to the nodes in my leafset */\n\tfor (i = 0; host[i] != NULL; i++)\n\t{\n\t\troute_update (state, host[i], 1);\n\t\tm = message_create (host[i]->key, CHIMERA_UPDATE, strlen (s) + 1,\n\t\t\t\ts);\n\t\tif (!message_send (state, host[i], m, TRUE))\n\t\t{\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\"chimera_join_acknowledge: failed to update %s:%d\\n\",\n\t\t\t\t\t\thost[i]->name, host[i]->port);\n\t\t}\n\t\tmessage_free (m);\n\t}\n\tfree (host);\n\n\t/* announce my arival to the nodes in my routing table */\n\thost = route_get_table (state);\n\tfor (i = 0; host[i] != NULL; i++)\n\t{\n\t\tm = message_create (host[i]->key, CHIMERA_UPDATE, strlen (s) + 1,\n\t\t\t\ts);\n\t\tif (!message_send (state, host[i], m, TRUE))\n\t\t{\n\t\t\tif (LOGS)\n\t\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\t\"chimera_join_acknowledge: failed to update %s:%d\\n\",\n\t\t\t\t\t\thost[i]->name, host[i]->port);\n\t\t}\n\t\tmessage_free (m);\n\t}\n\tfree (host);\n\n\t/* signal the chimera_join function, which is blocked awaying completion */\n\tsema_v (chglob->join);\n\n\t/* initialize the thread for leafset check and exchange */\n\tif (!(chimera_check_leafset_init (state)))\n\t{\n\t\tif (LOGS)\n\t\t\tlog_message (state->log, LOG_ERROR,\n\t\t\t\t\t\"chimera_check_leafset_init FAILED \\n\");\n\t\treturn;\n\t}\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/**\n ** called by route_update to upcall into the user's system \n */\n", "func_signal": "void chimera_update_upcall (ChimeraState * state, Key * k, ChimeraHost * h,\n\t\tint joined)", "code": "{\n\tChimeraGlobal *chglob = (ChimeraGlobal *) state->chimera;\n\tif (chglob->update != NULL)\n\t{\n\t\tchglob->update (k, h, joined);\n\t}\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/* seconds */\n", "func_signal": "int chimera_encodehosts (void *logs, char *s, int size, ChimeraHost ** host)", "code": "{\n\n\tint i, j;\n\n\ts[0] = 0;\n\tfor (i = 0; host[i] != NULL; i++)\n\t{\n\t\tj = strlen (s);\n\t\thost_encode (s + j, size - j, host[i]);\n\t\tif (LOGS)\n\t\t\tlog_message (logs, LOG_DEBUG, \"ENCODED %d = %s\\n\", i, s + j);\n\t\tstrcat (s, \"\\n\");\t/* add a spacer */\n\t}\n\n\treturn (strlen (s) + 1);\n\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/** \n ** chimera_piggy_message:\n ** message handler for message type PIGGY ;) this used to be a piggy backing function \n ** This function is respopnsible to add the piggy backing node information that is sent along with \n ** other ctrl messages or separately to the routing table. the PIGGY message type is a separate \n ** message type. \n */\n", "func_signal": "void chimera_piggy_message (ChimeraState * state, Message * message)", "code": "{\n\n\tChimeraHost **piggy;\n\tint i;\n\n\tpiggy = chimera_decodehosts (state, message->payload);\n\n\tfor (i = 0; piggy[i] != NULL; i++)\n\t{\n\n\t\tif ((dtime () - piggy[i]->failuretime) > GRACEPERIOD)\n\t\t{\n\t\t\troute_update (state, piggy[i], 1);\n\t\t}\n\n\t\telse if (LOGS)\n\t\t\tlog_message (state->log, LOG_WARN,\n\t\t\t\t\t\"refused to add:%s to routing table\\n\",\n\t\t\t\t\tget_key_string (&piggy[i]->key));\n\t}\n\tfree (piggy);\n}", "path": "src\\chimera.c", "repo_name": "zhaoz/chimera", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 966}
{"docstring": "/*\n** Name: yeti_save_cell\n** Desc: Saves a cell from a ROM based structure.\n*/\n", "func_signal": "void yeti_save_cell(cell_t* src, rom_cell_t* dst)", "code": "{\n  dst->swi = src->swi;\n  dst->ent = src->ent;\n  dst->top = src->top;\n  dst->mid = src->mid;\n  dst->bot = src->bot;\n  dst->wtx = src->wtx;\n  dst->ttx = src->ttx;\n  dst->btx = src->btx;\n  dst->lit = src->lit;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: rgb_convert\n** Desc: Converts a rgb color to another format.\n*/\n", "func_signal": "int rgb_convert(int color, int rmask, int gmask, int bmask)", "code": "{\n  return\n    ((RGB_RED  (color) * rmask / 31) & rmask) |\n    ((RGB_GREEN(color) * gmask / 31) & gmask) |\n    ((RGB_BLUE (color) * bmask / 31) & bmask) ;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/******************************************************************************/\n", "func_signal": "void CODE_IN_IWRAM matrix_rotate_world(matrx_t m, int alp, int bet, int gam)", "code": "{\n  int cosalp = fixcos(alp);\n  int sinalp = fixsin(alp);\n  int cosbet = fixcos(bet);\n  int sinbet = fixsin(bet);\n  int cosgam = fixcos(gam);\n  int singam = fixsin(gam);\n\n  m[0][0] =  fixmul(singam, fixmul(sinbet, sinalp)) + fixmul(cosgam, cosalp);\n  m[0][1] =  fixmul(cosbet, sinalp);\n  m[0][2] =  fixmul(singam, cosalp) - fixmul(cosgam, fixmul(sinbet, sinalp));\n\n  m[1][0] =  fixmul(singam, fixmul(sinbet, cosalp)) - fixmul(cosgam, sinalp);\n  m[1][1] =  fixmul(cosbet, cosalp);\n  m[1][2] = -fixmul(cosgam, fixmul(sinbet, cosalp)) - fixmul(singam, sinalp);\n\n  m[2][0] = -fixmul(singam, cosbet);\n  m[2][1] =  sinbet;\n  m[2][2] =  fixmul(cosgam, cosbet);\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: draw_entity_as_model\n** Desc: Draws a entity 3D model at the given location.\n*/\n", "func_signal": "void CODE_IN_IWRAM draw_entity_as_model(entity_t* entity)", "code": "{\n  s8* model = (s8*)entity->visual.data;\n  yeti_t* yeti = (yeti_t*)entity->yeti;\n  matrx_t m;\n  polyclip_t p;\n  vec3_t verts[100];\n  int i, j, nvertices;\n\n  model++;\n\n  matrix_rotate_object(m, f2i(entity->r), f2i(entity->p), f2i(entity->t));\n  \n  for (nvertices = *model++, i = 0; i < nvertices; i++)\n  {\n    int u = *model++;\n    int v = *model++;\n    int w = *model++;\n    int x = f2i(m[0][0] * u + m[0][1] * v + m[0][2] * w) + entity->x - yeti->camera->x;\n    int y = f2i(m[1][0] * u + m[1][1] * v + m[1][2] * w) + entity->z - yeti->camera->z;\n    int z = f2i(m[2][0] * u + m[2][1] * v + m[2][2] * w) + entity->y - yeti->camera->y;\n    \n    verts[i].x = f2i(yeti->m[0][0] * x + yeti->m[0][1] * y + yeti->m[0][2] * z);\n    verts[i].y = yeti->is2d ? y : f2i(yeti->m[1][0] * x + yeti->m[1][1] * y + yeti->m[1][2] * z);\n    verts[i].z = f2i(yeti->m[2][0] * x + yeti->m[2][1] * y + yeti->m[2][2] * z);\n  }\n  for (i = *model++; i--;)\n  {\n    int npts = *model++;\n    for (j = 0; j < npts; j++)\n    {\n      p[j] = YETI_VERTEX(yeti);\n      *((vec3_t*)&p[j][0]) = verts[*model++];\n      p[j]->u = i2f(*model++);\n      p[j]->v = i2f(*model++);\n      p[j]->l = i2f(48);\n      vertex_project(p[j]);\n    }\n    draw_texture(yeti, p, npts, *model++);\n  }\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/******************************************************************************/\n", "func_signal": "void CODE_IN_IWRAM yeti_draw(yeti_t* yeti)", "code": "{\n  cell_t* cell;\n  Quad_t p;\n  entity_t* e1;\n  entity_t* e2;\n  int i, nrays, ncells, rayangle, raywidth;\n\n  CELL_UNMARK_ALL();\n\n  yeti->is2d = !yeti->camera->p && !yeti->camera->r;\n  \n  matrix_rotate_world(yeti->m,\n    -f2i(yeti->camera->r),\n    -f2i(yeti->camera->p),\n    -f2i(yeti->camera->t));\n\n  raywidth = 16 + (ABS(yeti->camera->p) >> 13);\n\n  rayangle = (YETI_RAY_MAX >> 1) * raywidth + f2i(yeti->camera->t);\n  \n  for (i = YETI_RAY_MAX; i--; rayangle -= raywidth)\n  {\n    yeti->ray_vel[i].x = fixsin(rayangle) >> YETI_RAY_QUALITY;\n    yeti->ray_vel[i].y = fixcos(rayangle) >> YETI_RAY_QUALITY;\n    yeti->ray_pos[i].x = yeti->camera->x;\n    yeti->ray_pos[i].y = yeti->camera->y;\n  }\n  \n  for (nrays = YETI_RAY_MAX, ncells = 0; nrays && ncells < YETI_CELL_MAX;)\n  {\n    for (i = YETI_RAY_MAX; i--;)\n    {    \n      if (yeti->ray_pos[i].x)\n      {\n        cell = &yeti->cells[f2i(yeti->ray_pos[i].y)][f2i(yeti->ray_pos[i].x)];\n                  \n        if (CELL_IS_SOLID(cell))\n        {\n          nrays--;\n          yeti->ray_pos[i].x = 0;\n        }\n        else\n        {\n          if (!CELL_IS_MARKED(cell))\n          {\n            CELL_MARK(cell);\n            cell->entities = 0;\n            yeti->vis[ncells].x = f2i(yeti->ray_pos[i].x);\n            yeti->vis[ncells].y = f2i(yeti->ray_pos[i].y);\n\n            if (++ncells == YETI_CELL_MAX) break;\n          }                           \n          yeti->ray_pos[i].x += yeti->ray_vel[i].x;\n          yeti->ray_pos[i].y += yeti->ray_vel[i].y;\n        }\n      }\n    }\n  }\n  \n  // Merge the entities into the world map.\n  \n  for (i = yeti->nentities; i--;)\n  {\n    e1 = &yeti->entities[i];\n\n    if (e1 != yeti->camera && e1->visual.data)\n    {\n      cell = &yeti->cells[f2i(e1->y)][f2i(e1->x)];\n\n      if (CELL_IS_MARKED(cell))\n      {\n        int x = e1->x - yeti->camera->x;\n        int y = e1->z - yeti->camera->z;\n        int z = e1->y - yeti->camera->y;\n\n        e1->rx = f2i(yeti->m[0][0] * x + yeti->m[0][1] * y + yeti->m[0][2] * z);\n        e1->ry = yeti->is2d ? y : f2i(yeti->m[1][0] * x + yeti->m[1][1] * y + yeti->m[1][2] * z);\n        e1->rz = f2i(yeti->m[2][0] * x + yeti->m[2][1] * y + yeti->m[2][2] * z);\n\n        if (!cell->entities || e1->z < cell->entities->rz)\n        {\n          e1->next = cell->entities; cell->entities = e1;\n        }\n        else\n        {\n          for (e2 = cell->entities; e2->next && e1->rz < e2->next->rz; e2 = e2->next);\n          e1->next = e2->next; e2->next = e1;\n        }\n      }\n    }\n  }\n\n  CELL_UNMARK_ALL();\n  \n  for (i = ncells; i--;)\n  {\n    int x1 = yeti->vis[i].x;\n    int y1 = yeti->vis[i].y;\n\n    cell_t* c0 = &yeti->cells[y1-1][x1];\n    cell_t* c1 = &yeti->cells[y1  ][x1];\n    cell_t* c2 = &yeti->cells[y1+1][x1];\n\n    int top = c1[0].top;\n    int bot = c1[0].bot;\n\n    int x2 = i2f(x1 + 1);\n    int y2 = i2f(y1 + 1);\n    x1 = i2f(x1);\n    y1 = i2f(y1);\n\n    // Render Right Wall\n\n    if (yeti->camera->x < x2)\n    {\n      p[0].x = p[1].x = p[2].x = p[3].x = x2;\n      p[0].z = p[1].z = y1; p[2].z = p[3].z = y2;\n\n      draw_wall(yeti, c1[1].wtx, p, MIN(c1[1].bot, top), bot, YETI_TEXGEN_WALL_LR);\n      draw_wall(yeti, c1[1].wtx, p, top, MAX(c1[1].top, bot), YETI_TEXGEN_WALL_LR);\n    }\n\n    // Render Left Wall\n\n    if (yeti->camera->x > x1)\n    {\n      p[0].x = p[1].x = p[2].x = p[3].x = x1;\n      p[0].z = p[1].z = y2; p[2].z = p[3].z = y1;\n\n      draw_wall(yeti, c1[-1].wtx, p, MIN(c1[-1].bot, top), bot, YETI_TEXGEN_WALL_LR);\n      draw_wall(yeti, c1[-1].wtx, p, top, MAX(c1[-1].top, bot), YETI_TEXGEN_WALL_LR);\n    }\n\n    // Render Front Wall\n\n    if (yeti->camera->y < y2)\n    {\n      p[0].z = p[1].z = p[2].z = p[3].z = y2;\n      p[0].x = p[1].x = x2; p[2].x = p[3].x = x1;\n\n      draw_wall(yeti, c2[0].wtx, p, MIN(c2[0].bot, top), bot, YETI_TEXGEN_WALL_FB);\n      draw_wall(yeti, c2[0].wtx, p, top, MAX(c2[0].top, bot), YETI_TEXGEN_WALL_FB);\n    }\n\n    // Render Back Wall\n\n    if (yeti->camera->y > y1)\n    {\n      p[0].z = p[1].z = p[2].z = p[3].z = y1;\n      p[0].x = p[1].x = x1; p[2].x = p[3].x = x2;\n\n      draw_wall(yeti, c0[0].wtx, p, MIN(c0[0].bot, top), bot, YETI_TEXGEN_WALL_FB);\n      draw_wall(yeti, c0[0].wtx, p, top, MAX(c0[0].top, bot), YETI_TEXGEN_WALL_FB);\n    }\n\n    // Render cell ceiling and floor\n    \n    if (!CELL_IS_SOLID(c1))\n    {\n       p[0].x = p[3].x = x1; p[1].x = p[2].x = x2;\n\n      // Cell Bottom (Floor)\n\n      if (yeti->camera->z > bot)\n      {\n        p[0].y = p[1].y = p[2].y = p[3].y = bot;\n        p[0].z = p[1].z = y2; p[2].z = p[3].z = y1;\n\n        draw_quad(yeti, c1->btx, p, YETI_TEXGEN_FLAT);\n      }\n\n      // Cell Top (Ceiling)\n\n      if (yeti->camera->z < top)\n      {\n        p[0].y = p[1].y = p[2].y = p[3].y = top;\n        p[0].z = p[1].z = y1; p[2].z = p[3].z = y2;\n\n        draw_quad(yeti, c1->ttx, p, YETI_TEXGEN_FLAT);\n      }\n    }\n    for (e1 = c1->entities; e1; e1 = e1->next)\n    {\n      if (e1->ondraw) e1->ondraw(e1); else draw_entity_as_sprite(e1);\n      //draw_entity_as_model(e1);\n    }\n  }\n\n  if (yeti->overlay)\n  {\n    draw_sprite_di(yeti, -i2f(1), i2f(1), i2f(1), -i2f(1), 200, yeti->overlay, 2);\n  }\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/******************************************************************************/\n", "func_signal": "void entity_default(entity_t* e, int isjumping, int iscrawling)", "code": "{\n  yeti_t* yeti = (yeti_t*)e->yeti;\n\n  e->xx = friction(e->xx, 30);\n  e->yy = friction(e->yy, 30);\n  e->tt = friction(e->tt, 80);\n\n  e->r = friction(e->r, 20);\n  e->p = friction(e->p, 20);\n\n  {\n    cell_t* cell = &yeti->cells[f2i(e->y)][f2i(e->x)];\n    int bot = cell->bot + (iscrawling ? yeti->game.crawling : yeti->game.walking);\n    int top = cell->top - yeti->game.ceiling;\n\n    if (e->z <= bot)\n    {\n      e->z  -= ((e->z - bot) >> 2);\n      e->zz -= (e->zz >> 2);\n      if (isjumping && e->z < top)\n      {\n        e->z = bot;\n        e->zz += yeti->game.jumping;\n      }\n    }\n    else\n    {\n      e->zz += yeti->game.gravity;\n    }\n\n    if (e->z >= top)\n    {\n      e->z -= ((e->z - top) >> 2);\n    }\n  }\n  if (e->life < 0) entity_kill(e);\n}", "path": "game.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: yeti_default_lighting\n** Desc: Renders a default lighting setup for maps that dont have lights. This\n**       is currently the only lighting system and is designed to give good\n**       results for all map designs.\n*/\n", "func_signal": "void yeti_default_lighting(yeti_t* yeti)", "code": "{\n  int x, y;\n\n  yeti_ambient_lighting(yeti, i2f(0));\n\n  for (y = 1; y < YETI_MAP_HEIGHT - 1; y++)\n  {\n    for (x = 1; x < YETI_MAP_WIDTH - 1; x++)\n    {\n      cell_t* cell = &yeti->cells[y][x];\n      \n      if (cell->swi & CELL_SWI_LIGHT)\n      {\n        yeti_light(yeti, i2f(x) + FIXHALF, i2f(y) + FIXHALF);\n      }\n    }\n  }\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: rotate_vector\n** Desc: Rotates a cell vector and apply world lighting. Rotated vectors are\n**       cached in map cells so they can be reused. The rotated vertex is\n**       indexed by its un-rotated y position.\n*/\n", "func_signal": "vertex_t* CODE_IN_IWRAM rotate_vector(yeti_t* yeti, vec3_t* v)", "code": "{\n  int x, y, z;\n  vertex_t* rv;\n  cell_t* cell = &yeti->cells[f2i(v->z)][f2i(v->x)];\n\n  if (CELL_IS_MARKED(cell))\n  {\n    for (x = cell->vcache_size; x--;)\n    {\n      if (cell->vcache[x]->i == v->y) return cell->vcache[x];\n    }\n  }\n  else\n  {\n    CELL_MARK(cell);\n    cell->vcache_size = 0;\n  }\n  \n  x = v->x - yeti->camera->x;\n  y = v->y - yeti->camera->z;\n  z = v->z - yeti->camera->y;\n\n  rv    = YETI_VERTEX(yeti);\n  rv->i = v->y;\n  rv->x = f2i(yeti->m[0][0] * x + yeti->m[0][1] * y + yeti->m[0][2] * z);\n  rv->y = yeti->is2d ? y : f2i(yeti->m[1][0] * x + yeti->m[1][1] * y + yeti->m[1][2] * z);\n  rv->z = f2i(yeti->m[2][0] * x + yeti->m[2][1] * y + yeti->m[2][2] * z);\n  rv->l = cell->lit - (rv->z >> 1);\n\n  if (rv->l < YETI_LIGHT_MIN) rv->l = YETI_LIGHT_MIN;\n  if (rv->l > YETI_LIGHT_MAX) rv->l = YETI_LIGHT_MAX;\n\n  vertex_project(rv);\n\n  if (cell->vcache_size < YETI_VCACHE_MAX)\n  {\n    cell->vcache[cell->vcache_size++] = rv;\n  }\n  return rv;\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: yeti_load_cell\n** Desc: Loads a cell from a ROM based structure.\n*/\n", "func_signal": "void yeti_load_cell(cell_t* dst, rom_cell_t* src)", "code": "{\n  dst->swi = src->swi;\n  dst->ent = src->ent;\n  dst->top = src->top;\n  dst->mid = src->mid;\n  dst->bot = src->bot;\n  dst->wtx = src->wtx;\n  dst->ttx = src->ttx;\n  dst->btx = src->btx;\n  dst->lit = src->lit;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: viewport_to_video\n** Desc: The Yeti3D uses 5:5:5 colour, so if your platform uses a different\n**       format, then one solution is to convert the pixels when blitting to\n**       the video buffer.\n*/\n", "func_signal": "void viewport_to_video(rgb555_t* video, int pitch, viewport_t* vp, int rmask, int gmask, int bmask)", "code": "{\n\tint i, y;\n\n\tif (!vp->video_lut_filled)\n\t{\n\t\tvp->video_lut_filled = TRUE;\n\t\tfor (i = RGB_MAX; i--;)\n\t\t{\n\t\t\tvp->video_lut[i] = rgb_convert(i, rmask, gmask, bmask);\n\t\t}\n\t}\n\tfor (y = 0; y < YETI_VIEWPORT_HEIGHT; y++)\n\t{\n\t\trgb555_t* fb = video;\n\t\trgb555_t* tb= vp->back->pixels[y];\n\t\ti = YETI_VIEWPORT_WIDTH;\n#define AFFINE(I) {fb[I] = vp->video_lut[*tb++];}\n    AFFINE_LOOP\n#undef AFFINE\n\t\tvideo = (rgb555_t*)((int)video + pitch);\n\t}\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: stretch_sprite_di\n** Desc: Draws a device independant sprite to the screen. The sprite will be\n**       scaled to match the viewport.\n*/\n", "func_signal": "void CODE_IN_IWRAM stretch_sprite_di(\n  yeti_t* yeti,\n  int x1, int y1, int x2, int y2, int z,\n  YETI_ROM sprite_t sprite,\n  int u1, int v1, int u2, int v2, int mode)", "code": "{\n  if (z > 4)\n  {\n    vertex_t a, b;\n\n    a.x = x1; a.y = y1; a.z = z;\n    b.x = x2; b.y = y2; b.z = z;\n\n    vertex_project(&a);\n    vertex_project(&b);\n\n    draw_sprite(\n      yeti, f2i(a.sx), f2i(a.sy), f2i(b.sx), f2i(b.sy),\n      sprite, u1, v1, u2, v2,\n      YETI_VIEWPORT_X1, YETI_VIEWPORT_Y1, YETI_VIEWPORT_X2, YETI_VIEWPORT_Y2,\n      mode);\n  }\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: yeti_save_map\n** Desc: Saves the current map to a rom based map.\n*/\n", "func_signal": "void yeti_save_map(yeti_t* yeti, rom_map_t* map)", "code": "{\n  int x, y;\n\n  for (y = 0; y < YETI_MAP_HEIGHT; y++)\n  {\n    for (x = 0; x < YETI_MAP_WIDTH; x++)\n    {\n      yeti_save_cell(&yeti->cells[y][x], &map->cells[y][x]);\n    }\n  }\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/******************************************************************************/\n", "func_signal": "void* yeti_memcpy(void* d, void* s, unsigned n)", "code": "{\n  while (n--) ((u8*)d)[n] = ((u8*)s)[n];\n  return d;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: yeti_init\n** Desc: Setup a default map and position the camera.\n*/\n", "func_signal": "void yeti_init(yeti_t* yeti, framebuffer_t* front, framebuffer_t* back, texture_t* textures, palette_t palette,\n               lua_t lua)", "code": "{\n  int i;\n\n  CLEARMEM(yeti);\n\n  for (i = 0; i < YETI_TEXTURE_MAX; i++)\n  {\n    yeti->surfaces[i].xsize = 6;\n    yeti->surfaces[i].ysize = 6;\n  }\n\n  yeti->surfaces[YETI_TEXTURE_SKY].xsize = 5;\n  yeti->surfaces[YETI_TEXTURE_SKY].ysize = 5;\n\n  yeti->surfaces[0].xsize = 4;\n  yeti->surfaces[0].ysize = 4;\n  yeti->surfaces[2].xsize = 5;\n  yeti->surfaces[2].ysize = 5;\n\n  yeti_init_map(yeti);\n  \n  yeti->viewport.front = front;\n  yeti->viewport.back  = back;\n\n  yeti->textures    = textures;\n  yeti->palette     = palette;\n  yeti->lighting[0] = lua;\n  yeti->lighting[1] = lua;\n  yeti->lighting[2] = lua;\n  yeti->lighting[3] = lua;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: vertex_project\n** Desc: Projects a vertex into screen space. (ie: 3D to 2D viewport space)\n*/\n", "func_signal": "void CODE_IN_IWRAM vertex_project(vertex_t* v)", "code": "{\n  if (v->z > YETI_RECIPROCAL_MIN && v->z < YETI_RECIPROCAL_MAX)\n  {\n    int z = reciprocal[v->z];\n\n    v->sx =  (((YETI_VIEWPORT_X2-YETI_VIEWPORT_X1)*v->x*z)>>9)+i2fdiv2(YETI_VIEWPORT_X2+YETI_VIEWPORT_X1);\n    v->sy = -(((YETI_VIEWPORT_Y2-YETI_VIEWPORT_Y1)*v->y*z)>>9)+i2fdiv2(YETI_VIEWPORT_Y2+YETI_VIEWPORT_Y1);\n  }\n  else\n  {\n    v->sx = v->sy = 0;\n  }\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: draw_quad\n** Desc: Renders a single quad/rectangle of a cell using the given texture\n**       mapping mode and texture id. The mapping mode changes depending\n**       of if this is a north-south wall, east-west wall or ceiling/floor.\n*/\n", "func_signal": "void CODE_IN_IWRAM draw_quad(yeti_t* yeti, int tid, Quad_t quad, int texgen)", "code": "{\n  int u, uu, v, vv;\n  polyclip_t p;\n\n  tid = CLAMP(tid, 0, YETI_TEXTURE_MAX - 1); \n\n  p[0] = rotate_vector(yeti, &quad[0]);\n  p[1] = rotate_vector(yeti, &quad[1]);\n  p[2] = rotate_vector(yeti, &quad[2]);\n  p[3] = rotate_vector(yeti, &quad[3]);\n\n  u  = yeti->surfaces[tid].xsize;\n  v  = yeti->surfaces[tid].ysize;\n  uu = yeti->surfaces[tid].xpan;\n  vv = yeti->surfaces[tid].ypan;\n\n  switch (texgen)\n  {\n    case YETI_TEXGEN_WALL_LR:\n    {\n      p[0]->u = (quad[0].z + uu) << u; p[0]->v = (quad[0].y + vv) << v;\n      p[1]->u = (quad[1].z + uu) << u; p[1]->v = (quad[1].y + vv) << v;\n      p[2]->u = (quad[2].z + uu) << u; p[2]->v = (quad[2].y + vv) << v;\n      p[3]->u = (quad[3].z + uu) << u; p[3]->v = (quad[3].y + vv) << v;\n      break;\n    }\n    case YETI_TEXGEN_WALL_FB:\n    {\n      p[0]->u = (quad[0].x + uu) << u; p[0]->v = (quad[0].y + vv) << v;\n      p[1]->u = (quad[1].x + uu) << u; p[1]->v = (quad[1].y + vv) << v;\n      p[2]->u = (quad[2].x + uu) << u; p[2]->v = (quad[2].y + vv) << v;\n      p[3]->u = (quad[3].x + uu) << u; p[3]->v = (quad[3].y + vv) << v;\n      break;\n    }\n    case YETI_TEXGEN_FLAT:\n    {\n      p[0]->u = (quad[0].x + uu) << u; p[0]->v = (quad[0].z + vv) << v;\n      p[1]->u = (quad[1].x + uu) << u; p[1]->v = (quad[1].z + vv) << v;\n      p[2]->u = (quad[2].x + uu) << u; p[2]->v = (quad[2].z + vv) << v;\n      p[3]->u = (quad[3].x + uu) << u; p[3]->v = (quad[3].z + vv) << v;\n      break;\n    }\n    case YETI_TEXGEN_BASIC:\n    {\n      p[0]->u = i2f(64); p[0]->v = i2f(64);\n      p[1]->u = i2f( 0); p[1]->v = i2f(64);\n      p[2]->u = i2f( 0); p[2]->v = i2f( 0);\n      p[3]->u = i2f(64); p[3]->v = i2f( 0);\n      break;\n    }\n  }\n#ifdef __PSONE__\n  texcoord_fixup(p, 4);\n#endif\n\n  draw_texture(yeti, p, 4, tid);\n}", "path": "draw.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: isqrt\n** Desc: Integer square root. Take the square root of an integer.\n*/\n", "func_signal": "int isqrt(int value)", "code": "{\n  int root = 0;\n\n#define STEP(shift) \\\n    if((0x40000000 >> shift) + root <= value)          \\\n    {                                                   \\\n        value -= (0x40000000 >> shift) + root;          \\\n        root = (root >> 1) | (0x40000000 >> shift);     \\\n    }                                                   \\\n    else                                                \\\n    {                                                   \\\n        root >>= 1;                                     \\\n    }\n\n  STEP( 0); STEP( 2); STEP( 4); STEP( 6);\n  STEP( 8); STEP(10); STEP(12); STEP(14);\n  STEP(16); STEP(18); STEP(20); STEP(22);\n  STEP(24); STEP(26); STEP(28); STEP(30);\n\n  // round to the nearest integer, cuts max error in half\n\n  if (root < value) root++;\n\n  return root;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: cell_init\n** Desc: Initialize a yeti cell to its defaults.\n*/\n", "func_signal": "void cell_init(cell_t* cell, int issolid)", "code": "{\n  CLEARMEM(cell);\n  \n  if (issolid)\n  {\n    cell->top = i2f(0);\n    cell->bot = i2f(0);\n  }\n  else\n  {\n    cell->top = i2f(4);\n    cell->bot = i2f(0);\n  }\n#ifdef __YETI_EDITOR__\n  cell->tos = cell->top;\n  cell->bos = cell->bot;\n#endif\n  cell->lit = YETI_LIGHT_MAX;\n  cell->ttx = 7;\n  cell->wtx = 0;\n  cell->btx = 28;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/*\n** Name: yeti_entity\n** Desc: Creates a new entity and returns a entity pointer.\n*/\n", "func_signal": "entity_t* yeti_entity(yeti_t* yeti, int x, int y, int z, entity_behaviour_t behaviour)", "code": "{\n  entity_t* e = &yeti->entities[yeti->nentities++];\n\n  CLEARMEM(e);\n  \n  e->x = x;\n  e->y = y;\n  e->z = z;\n  e->ontick = behaviour;\n  e->radius = i2fdiv2(1);\n  e->life = 100;\n  e->yeti = yeti;\n\n  return e;\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/******************************************************************************/\n", "func_signal": "void yeti_clear_entities(yeti_t* yeti)", "code": "{\n  int i;\n\n  yeti->nentities = 0;\n\n  yeti->camera = yeti_entity(yeti,\n    i2fdiv2(YETI_MAP_WIDTH),\n    i2fdiv2(YETI_MAP_HEIGHT),\n    i2f(0), 0);\n\n  for (i = 0; i < YETI_BULLET_MAX; i++)\n  {\n    yeti->bullets[i] = yeti_entity(yeti, 0, 0, 0, 0);\n  }\n}", "path": "yeti.c", "repo_name": "xobs/chumby-yeti3d", "stars": 13, "license": "None", "language": "c", "size": 368}
{"docstring": "/* These functions say which hand wins */\n", "func_signal": "int is_flush(card h[5])", "code": "{\n\tint i;\n\t\n\tfor (i = 1; i < 5; ++i)\n\t\tif (h[i].suit != h[0].suit)\n\t\t\treturn 0;\n\treturn 1;\n}", "path": "poker.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*********************************/\n/* update_player()               */\n/* updates the player state file */\n/*********************************/\n", "func_signal": "int update_player()", "code": "{\n\tFILE *fp;\n\tchar obuf[256];\n\t\n\tsprintf(obuf,\"%s/users/%s/%s\",BBSDIR,username,PLAYERFILE);\n\tif((fp = fopen(obuf,\"wb\")) == NULL) return -1;\n\tif(fwrite((char *)&player,sizeof(PLAYER),1,fp) != 1) return -2;\n\tfclose(fp);\n\treturn 0;\t\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/********************************/\n/* get_player()                 */\n/* Loads the player information */\n/* from the player status file. */\n/********************************/\n", "func_signal": "int get_player()", "code": "{\n\tFILE *fp;\n\tchar obuf[256];\n\t\n\tsprintf(obuf,\"%s/users/%s/%s\",BBSDIR,username,PLAYERFILE);\n\tif((fp = fopen(obuf,\"rb\")) == NULL) return -1;\n\tif(fread((char *)&player,sizeof(PLAYER),1,fp) != 1) return -2;\n\tfclose(fp);\n\treturn 0;\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/******************************************/\n/* AttackPlayer()                         */\n/*  Attack another player - still need to */\n/*  add a bunch of stuff/features to this */\n/*  -this function is not at all done!!!  */\n/******************************************/\n", "func_signal": "int AttackPlayer(void)", "code": "{\n\tchar obuf[256],ibuf[256];\n\tint i,j,a,b,c;\n\tstruct stat st;\n\tFILE *fp;\n\tPLAYER defender;\n\tsrand(time(NULL));\n\treturn 0;\n\n\tif(player.turns_left < 7) {\n\t\tprintf(\"\\n\\033[1;31mYou don't have enough turns left.\\n\\n\");\n\t\treturn 0;\n\t}\n\tif(player.fighters < 1) {\n\t\tprintf(\"\\n\\033[1;31mYou don't have any fighters left.\\n\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\\033[1;32mPlayer to Attack \\033[0;35m[\\033[0;31mNone\u001b[0;35m]? \");  \n\tGetStrName(obuf,31);\n\tif(strlen(obuf) < 3) {\n\t\tprintf(\"\\n \\033[1;31m\\\"\\033[33mAborting Attack\\033[31m.\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\tif(!strcmp(obuf,get_user_name())) {\n\t\tprintf(\"\\n \\033[1;31m\\\"\\033[33mCaptain, are you nutz\\033[31m?\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\tsprintf(ibuf,\"%s/users/%s/player_state\",BBSDIR,obuf);\n\tstat(ibuf,&st);\n\tif(st.st_size != sizeof(PLAYER)) {\n\t\tprintf(\"\\n \\033[31m\\\"\\033[33mCaptain, that player does not exist\\033[31m!\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\tif((fp = fopen(ibuf,\"rb\")) == NULL) {\n\t\tprintf(\"\\n \\033[1m\\\"Computer Malfunction, Aborting!\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\tif(fread((char *)&defender,sizeof(PLAYER),1,fp) != 1) {\n\t\tprintf(\"\\n \\033[1m\\\"Computer Read Malfunction, Aborting!\\\"\\n\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tfclose(fp);\n\t/* Now we have the defender data */\n\t/* Need to add to this */\n\tibuf[0] = '\\0';\n\tprintf(\"\\n \\033[0;1;31;40m\\\"\\033[33mPreparing Attck on \\033[35m%s's \\033[31m[\\033[35m%s\\033[31m]!\\\"\\n\\n\",obuf,defender.shipname);\n\tprintf(\" \\033[1;31m\\\"\\033[33mThey have \\033[36m%d\\033[33m fighters, we have \\033[36m%d\\033[31m.\\\"\\n\\n\",defender.fighters,player.fighters);\n\tprintf(\"\\033[1;32mHow Many Fighters To Send \\033[31m(\\033[35m%d max)\\033[31m) [\\033[35m0\\033[31m]? \",player.fighters);\n\tGetStr(ibuf,5,0);\n\tfor(i=0;ibuf[i]!='\\0';i++) {\n\t\tif(!isdigit(ibuf[i])) {\n\t\t\tprintf(\"\\n \\033[31m\\\"\\033[33mCaptain, computer can't process data\\033[31m,\\033[33m aborting attack\\033[31m!\\\"\\n\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\t\n\tif(ibuf[0] == '\\0' || ibuf[0] == '0') {\n\t\tprintf(\"\\n \\033[1;31m\\\"\\033[33mZero Fighters Sent\\033[31m,\\033[33m Attack Aborted\\033[31m!\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\t\n\ta = player.fighters;\n\tb = defender.fighters;\n\tc = 1;\n\t\n\tfor(i=atoi(ibuf);i>0;i--) {\n\t\tj = (rand() % 99);\n\t\tif(j<33) if(defender.fighters>1) {defender.fighters--;c++;}\n\t\tif(j>=33 && j<=66) continue;\n\t\tif(j>66) {player.fighters--;i--;}\n\t}\n\tprintf(\"\\n\");\n\tfor(i=0;i<6;i++) PrintSlow(\"\\033[0;41m \\033[0;42m \\033[0;44m \");\n\tprintf(\"\\033[0;40m\\n\\n\");\n\tprintf(\"\\033[0;32;40mGain Score for Attacking \\033[1;36m%d \\033[0;32mPoint\\033[31m(\\033[32ms\\033[31m)\\n\",c);  \t\n\tplayer.score += c;\n\tprintf(\"\\033[0;35m  You lost \\033[36m%d\\033[35m fighters, \\033[1;36m%d\\033[35m remain.\\n\",a-player.fighters,player.fighters);\n\tprintf(\"\\033[0;35m  You destryed \\033[36m%d\\033[35m fighters, \\033[1;36m%d\\033[35m remain.\\n\",b-defender.fighters,defender.fighters);\n\tplayer.turns_left -= 7;\n\tupdate_player();\n\n\tsprintf(ibuf,\"%s/users/%s/player_state\",BBSDIR,obuf);\n\tif((fp = fopen(ibuf,\"wb\")) == NULL) {\n\t\tprintf(\"\\033[1;37m\\n \\\"Captain, there has been an amonmoly,\");\n\t\tprintf(\" a ripple in time some how, the enemy\");\n\t\tprintf(\" ship has returned to this normal form\");\n\t\tprintf(\" just before the battle.\\\"\\n\\n\");\n\t\treturn 0;\n\t}\n\tif(fwrite((char *)&defender,sizeof(PLAYER),1,fp) != 1) {\n\t\tprintf(\"\\033[1;37m\\n \\\"Captain, there has been an amonmoly,\");\n\t\tprintf(\" a ripple in time some how, the enemy\");\n\t\tprintf(\" ship has returned to this normal form\");\n\t\tprintf(\" just before the battle.\\\"\\n\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tfclose(fp);\n\tprintf(\"\\n\");\n\treturn 0;\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* rrd = read reverse direction */\n", "func_signal": "void ReadMsgs(int rrd)", "code": "{\n\tlong msgNo = 0, tmpMsgNo = 0;\n\tint done = FALSE;\n\tchar ch, ibuf[100],obuf[1024];\n\tlong lohi[2],newmsgs;\n\t\n\t\n\tif(rrd) {\n\t\tnewmsgs = NewMsgs(1,lohi);\t \n\t\tif(newmsgs) {\n\t\t\tPrintSlow(\"\\n\\n\\x1b[0mNo Old Messages!\\n\\n\");\n\t\t\treturn;\n\t\t} else done = FALSE;\n\t\n\t} else {\n\t\t/*************************************************/\n\t\t/* in this case, I check the current conference  */\n\t\t/* first, for reading forward new messages, then */\n\t\t/* check from 0 to MAX which is 2 for any new.   */\n\t\t/*************************************************/ \n\t\tnewmsgs = NewMsgs(0,lohi);\n\t\tif(!newmsgs) { \t\t\t\t// nothing in current confernece to read\n\t\t\trNum = 0;\n\t\t\twhile(rNum < maxrooms) {\t// search other conferences\n\t\t\t\tnewmsgs = NewMsgs(0,lohi);\n\t\t\t\tif(rNum == (maxrooms-1) && (!newmsgs)) {\n\t\t\t\t\tPrintSlow(\"\\n\\n\\x1b[0mNo New Messages. (;\\n\\n\");\n\t\t\t\t\trNum=0;\n\t\t\t\t\treturn;\n\t\t\t\t} else if((newmsgs) && (rNum < maxrooms) && (room[rNum].avail != TRUE)) {\n\t\t\t\t\tprintf(\"\\n\\n\");\n\t\t\t\t\tJoinStats();\n\t\t\t\t\tdone = TRUE;\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdone = TRUE;\n\t\t\t\t\trNum++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else done = FALSE;\n\t}\n\n\tif(done) { \n\t\tprintf(\"\\033[1;32m\\nHit the \\033[1;34m[\\033[0;35mSPACE\\033[1;34m] \\033[1;32mbar to read them..\\n\\n\");\n\t\treturn;\n\t} else printf(\"%s..\", GetRoomName());\n\tif(!rrd) userstate.lastmsg[rNum]++;\n\tmsgNo = userstate.lastmsg[rNum];\t\n\tCatMsg(msgNo,lohi[1],rNum);\n\n\t/*********************************************/\n\t/* this is the start of the msg prompt loop. */\n\t/* To support multi-rooms we may have to re- */\n\t/* write the updating of message pointer     */\n\t/* along with adding a room pointer (update) */\n\t/*********************************************/\n\twhile(!done) {\n\t\tif(rNum != 0)\n\t\t\tsprintf(obuf,\"\\x1b[1;31m(\\x1b[33ma\\x1b[31m)\\x1b[0;35mgain\\x1b[34m,\\x1b[1;31m(\\x1b[33mp\\x1b[31m)\\x1b[0;35most\\x1b[34m,\\x1b[1;31m(\\x1b[33mq\\x1b[31m)\\x1b[0;35muit\\x1b[34m,\\x1b[1;31m[\\x1b[1;33m%d \\x1b[0;33mMore\\x1b[1;31m]\\x1b[1;31m[\\033[1;33m?\\033[1;31m]\\033[0;35m=:>\\x1b[0m \", lohi[1]-msgNo);\n\t\telse\n\t\t\tsprintf(obuf,\"\\033[1;31mA\\033[1;34m>\\033[1;32mgain\\033[1;34m, \\033[1;31mQ\\033[1;34m>\\033[1;32muit\\033[1;34m, <\\033[1;31mSPACE\\033[1;34m>=\\033[1;32mnext \\033[0;34m[\\033[1;31m%d \\033[1;32mMore\\033[0;34m]\\033[1;34m?\\033[0m \", lohi[1]-msgNo);\n \n\t\tch = GetKeyPrompt(obuf);\n\t\tswitch(tolower(ch)) {\n\t\t\tcase 'a':\n\t\t\t\tprintf(\"Again\");\n\t\t\t\tCatMsg(msgNo, lohi[1],rNum);\n\t\t\t\tcontinue;\n\t\t\tcase 'l':\n\t\t\t\tprintf(\"Logout\");\n\t\t\t\tlogout();\n\t\t\tcase 's':\n\t\t\t\tprintf(\"Stop\\n\\n\");\n\t\t\t\tdone = TRUE;\n\t\t\t\tcontinue;\n\t\t\tcase 'q':\n\t\t\t\tprintf(\"Quit\\n\\n\");\n\t\t\t\tdone = TRUE;\n\t\t\t\tcontinue;\n\t\t\tcase 'p':\n\t\t\t\tlogact('p');\n\t\t\t\tprintf(\"Post\\n\");\n\t\t\t\twhois_on(5);\n\t\t\t\teditor2(NULL,NULL,0);\n\t\t\t\twhois_on(1);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase 'r':\n\t\t\t\tlogact('p');\n\t\t\t\tprintf(\"\\x1b[1;35mBug! \\033[1;36m[\\x1b[0;35m%s\\x1b[1;36m]\\n\",(char *)GetMsgAuthor(msgNo,rNum));\n\t\t\t\twhois_on(5);\n\t\t\t\teditor2((char *)GetMsgAuthor(msgNo,rNum),\n\t\t\t\t\t(char *)GetMsgSubject(msgNo,rNum),msgNo);\n\t\t\t\twhois_on(1);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase 'd':\n\t\t\t\tif( (!strcmp((char *)get_user_name(),\n\t\t\t\t\t(char *)GetMsgAuthor(msgNo,rNum)) ) \n\t\t\t\t\t|| (!strcmp((char *)get_user_name(),\n\t\t\t\t\tSYSOPNAME)) \n\t\t\t\t\t|| (!strcmp((char *)get_user_name(), \n\t\t\t\t\troom[rNum].owner)) ) {\n\n\t\t\t\t\tprintf(\"Delete! Confirm [Shift-Y]? \");\n\t\t\t\t\tfor(;;) {\n\t\t\t\t\t\tch = GetKey(0);\n\t\t\t\t\t\tif(ch == 'Y') {\n\t\t\t\t\t\t\tDeleteMsg(msgNo,rNum);\n\t\t\t\t\t\t\tprintf(\"\\n\\nMessage no. %ld is Removed.\\n\\n\", msgNo);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"\\n\\nMessage Not Deleted.\\n\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"\\n\\n\\x1b[0;33mYou can't delete this message.\\n\\n\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase 'm':\n\t\t\t\tif(is_sysop(get_user_name())) {\n\t\t\t\t\tprintf(\"Move\\n\");\n\t\t\t\t\tMoveMsg(msgNo, lohi[1], rNum);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"m\\n\\nHmmm..\\n\\n\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase 'u':\n\t\t\t\tprintf(\"\\n\\n\");\n\t\t\t\tUserToProfile();\n\t\t\t\tcontinue;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprintf(\"\\n\");\t\t\t\t\n\t\t\t\tprintf(\"\\nOPTIONS FOR READING MESSAGES\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"  <A>..Again, Read THIS Msg\\n\");\n\t\t\t\tprintf(\"  <->..Back One Msg\\n\");\n\t\t\t\tprintf(\"  <P>..Post A Msg -> here.\\n\");\n\t\t\t\tprintf(\"  <!>..Jump to a Msg\\n\");\n\t\t\t\tprintf(\"  <Q>..Quit Reading Msgs\\n\");\n\t\t\t\tprintf(\"  <R>..Reply to Current Msg\\n\");\n\t\t\t\tprintf(\"  <D>..Delete this Message (n/a)\\n\");\n\t\t\t\tprintf(\"  <^>..Colors help-text\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\" [SPACE]..Goto NEXT msg\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase ' ':\n\t\t\t\t/*********************************************/\n\t\t\t\t/* at this point we should have two choices  */\n\t\t\t\t/* goto the next Message or jump to the next */\n\t\t\t\t/* subboard forum room ......................*/\n\t\t\t\t/*********************************************/\n\t\t\t\tif((msgNo >= lohi[1]) || (msgNo < lohi[0])) {\n\t\t\t\t\tprintf(\"[END]\\n\\n\\x1b[0;33mNo More Msgs In The [%s\\x1b[0;33m] Room.\\n\\n\", GetRoomName());\n\t\t\t\t\tprintf(\"\\x1b[0;34m  Hit [\\x1b[1;34mSPACE\\x1b[0;34m] bar to check the \\x1b[1;34mnext\\x1b[0;34m room..\\n\\n\");\n\t\t\t\t\tdone=TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprintf(\"Next\");\n\t\t\t\tmsgNo++;\n\n\t\t\t\tCatMsg(msgNo, lohi[1], rNum);\n\n\t\t\t\tuserstate.lastmsg[rNum] = msgNo;\n\t\t\t\tupdate_user();\n\t\t\t\tcontinue;\n\t\t\tcase '!':\n\t\t\t\tsprintf(ibuf, \"Jump to Msg [%ld-%ld=:> \", lohi[0]+1, lohi[1]);\n\t\t\t\tprintf(ibuf);\n\t\t\t\tGetStr(ibuf,5,0);\n\t\t\t\tif(!strisdigit(ibuf)) {\n\t\t\t\t\tprintf(\"\\n That string is not digits.\\n\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpMsgNo=atol(ibuf);\n\n\t\t\t\tif((tmpMsgNo <= lohi[1]) && (tmpMsgNo >= lohi[0])) {\n\t\t\t\t\tmsgNo=tmpMsgNo;\n\t\t\t\t\tCatMsg(msgNo,lohi[1],rNum);\n\t\t\t\t\tuserstate.lastmsg[0] = msgNo;\n\t\t\t\t\tupdate_user();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"\\n Msg %ld out of Range.\\n\", tmpMsgNo);\n\t\t\t\t\tprintf(\" Jump range is %ld to %ld.\\n\\n\", lohi[0]+1,lohi[1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tcase '-':\n\t\t\tcase 'b':\n\t\t\t\tif(msgNo < lohi[0]+2) {\n\t\t\t\t\tprintf(\"\\x1b[0m[END]\\n\\nYou have reached the beginning of Room [%s\\x1b[0m].\\n\", GetRoomName());\n\t\t\t\t\tdone=TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprintf(\"Back\");\n\t\t\t\tmsgNo--;\n\t\t\t\tCatMsg(msgNo,lohi[1],rNum);\n\t\t\t\tcontinue;\n\t\t\tcase 'w':\n\t\t\t\tprintf(\"Who's Online\\n\");\n\t\t\t\tsyslog(LOG_INFO,\"%s %s\",username,\"whos online - rmsg\");\n\t\t\t\twhois_on_list();\n\t\t\t\tcontinue;\n\t\t\tcase '^':\n\t\t\t\tprintf(\"Colors Help\\n\\n\");\n\t\t\t\tsprintf(obuf,\"%s/text/colors-help\",BBSDIR);\n\t\t\t\tCatFileDirect(obuf);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tprintf(\"\\n\\n================================\\n\");\n\t\t\t\tprintf(\" Press [\u001b[1;5mSPACEBAR\u001b[0m] for next msg.\\n\\n\");\n\t\t\t\tprintf(\"Hit '?' for more options help.\\n\");\n\t\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t}\n\n\tsyslog(LOG_INFO,\"%s %s %d %s %ld\",\n\t\tusername,\n\t\t\"read\",\n\t\trNum,\n\t\t\"messages, stopped at num\",\n\t\tuserstate.lastmsg[rNum]);\n\treturn;\n}", "path": "rmsg.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/************************************/\n/* function checks if is a straight */\n/* not 100% sure on the bubble sort */\n/* but it seems to work ok......    */\n/************************************/\n", "func_signal": "int is_straight(card h[5])", "code": "{\n\tint i,j;\n\t\n\tfor(i=0;i<5;++i)\n\t\tfor(j=4;j>i;--j)\n\t\t\tif(h[j-1].pips < h[j].pips) \n\t\t\t\tswap(&h[j-1],&h[j]);\n\tfor(i=0;i<5;++i)\n\t\tif(h[i].pips != (h[i+1].pips + 1))\n\t\t\treturn 0;\n\treturn 1;\n}", "path": "poker.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*********************************/\n/* mkplayer()                    */\n/* Initializes a player's record */\n/* Adding a new player           */\n/*********************************/\n", "func_signal": "int mkplayer()", "code": "{\n\tchar obuf[256];\n\tFILE *fp;\n\tstruct stat st;\n\n\tPrintSlow(\"  \\033[0;1;35;44m INCOMMING TRANSMISSION \\033[0;1;33;40m\\n\");\n\tsleep(3);\n\tPrintSlow(\"\\n\");\n\tPrintSlow(\"New Mission Orders\\n\");\n\tsleep(1);\n\tPrintSlow(\"By Star Fleet Command\\n\\n\");\n\tsleep(1); PrintSlow(\"The stardock 5 reporting alien ship of\\n\");\n\tsleep(1); PrintSlow(\"unknown origin found near the Dagaba\\n\");\n\tsleep(1); PrintSlow(\"System. Investigate this anomoly! Warp\\n\");\n\tsleep(1); PrintSlow(\"path being transfered to your ships\\n\");\n\tsleep(1); PrintSlow(\"computer. Proceed with coution.\\n\\n\");\n\tPause3();\n\n\tprintf(\"\\n\");\t\n\tprintf(\"\\033[1;35mA\\033[0mhh, a new captain!\\n\");\n\tprintf(\"\\033[1;35mWel\\033[0mcome..\");\n\tprintf(\"\\033[1;35mCreatin\\033[0mg Ship Fi\\033[1mles..\\n\");\t\n\t\n\tplayer.shipname[0] = '\\0';\n\tstrcpy(player.shipbrand,\"Vaccum Runner\");\n\t\n\tplayer.turns_left = 100;\n\tplayer.max_warps = 8;\n\tplayer.warps_left = 8;\n\tplayer.turns_per_warp = 3;\n\n\tplayer.fighters = 30;\n\tplayer.shields = 5;\n\tplayer.ship_hits = 20;\t\n\tplayer.cargo_bays = 8;\n\t\n\tplayer.max_fighters = 60;\n\tplayer.max_shields = 100;\n\tplayer.max_ship_hits = 20;\n\tplayer.max_cargo_bays = 16;\n\t\n\tplayer.phits = 50;\n\tplayer.max_phits = 50;\n\tplayer.chr = 3;\n\tplayer.str = 5;\n\tplayer.dex = 5;\n\t\n\tplayer.loan = 0;\n\tplayer.credit_chips = 20000;\n\tplayer.score = 0;\n\tplayer.time_lastin = time(NULL);\n\n\t/** below writes the player data **/\t\n\tsprintf(obuf,\"%s/users/%s/%s\",BBSDIR,username,PLAYERFILE);\n\tif((fp = fopen(obuf,\"wb\")) == NULL) return -1;\n\tif(fwrite((char *)&player,sizeof(PLAYER),1,fp) != 1) return -2;\n\tfclose(fp);\t\n\n\treturn 0;\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/******************************************/\n/* printago()                             */\n/* print the time difference up until now */\n/******************************************/\n", "func_signal": "void printago(long cmpTime)", "code": "{\n\ttime_t currentTime, diffTime;\n\tfloat newTime;\n\t\n\ttime(&currentTime);\n\tdiffTime = currentTime - cmpTime;\n\n\tif(diffTime >= 86400) {\n\t\tnewTime = diffTime / 86400.0;\n\t\tprintf(\"%.1f days\", newTime);\n\t} else if(diffTime >= 3600) {\n\t\tnewTime = diffTime / 3600.0;\n\t\tprintf(\"%.1f hours\", newTime);\n\t} else if(diffTime >= 60) {\n\t\tnewTime = diffTime / 60.0;\n\t\tprintf(\"%.1f minutes\", newTime);\n\t} else printf(\"%ld seconds\", diffTime);\n\treturn;\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*******************************************/\n/* tolowerString()                         */\n/* toupperString()                         */\n/* Convert a string to lower or upper case */\n/* turn a character string to lower case   */\n/*******************************************/\n", "func_signal": "void tolowerString(char *s)", "code": "{\n\tfor( ; ((*s != 0) || isspace(*s)) ; s++ ) *s = tolower(*s);\n\treturn;\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/******************************************/\n/* misc. support functions for the editor */\n/******************************************/\n", "func_signal": "void draw_editor_header()", "code": "{\n\tprintf(\"\\x1b[0m\");\n\n\tprintf(\"\u001b[0;31m            .-------------------------.\\n\");\n\tprintf(\"\u001b[1;32m  /|||\\\\\\\\    \u001b[0;31m|\u001b[1mCoMpoSe yOuR MEsSagE HeRe\u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;32m /\u001b[0;31mC^,^C\u001b[1;32m\\\\\\\\   \u001b[0;31m|  \u001b[0;31m=-=-=-=-=-=-=-=-=-=-=  \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;32m \\\\\\\\\\\\\u001b[0;31mo \u001b[1;32m///   \u001b[0;31m|\u001b[1;31m<\u001b[1;33m^\u001b[1;31m> the `\u001b[0;31mcaret\u001b[1;31m` key will \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[0;31m/P  ||      \u001b[0;31m| \u001b[1;31mallow you to change the \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[0;31m\\\\\\\\/\u001b[1;33m(  )\u001b[0;31m\\\\    \u001b[0;31m|\u001b[1;31mcolor of text then hit\u001b[0;31m,  |\\n\");\n\tprintf(\"\u001b[0;31m \\\\/\u001b[1;33m \\\\_\\\\\u001b[0;31m\\\\\\\\   \u001b[0;31m| \u001b[0;34mb\u001b[0;31m,r,\u001b[0;35mm\u001b[0;31m,\u001b[0;32mg\u001b[0;31m,\u001b[0;33my\u001b[0;31m,\u001b[1;34mB\u001b[0;31m,\u001b[1;31mR\u001b[0;31m,\u001b[1;35mM\u001b[0;31m,\u001b[1;32mG\u001b[0;31m, \u001b[1;31mor \u001b[1;33mY\u001b[0;31m.|\\n\");\n\tprintf(\"\u001b[1;33m   /   \\\\\u001b[0;31m\\\\P  \u001b[0;31m|\u001b[1m<\u001b[1;33menter\u001b[1;31m> key twice prompt \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;33m   \\\\___/    \u001b[0;31m| \u001b[1;31myou to save the message\u001b[0;31m.|\\n\");\n\tprintf(\"\u001b[0;31m    \\\\\\\\\\\\\\\\    \u001b[0;31m`-------------------------'\\n\");\n\tprintf(\"\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0m\");\n}", "path": "editor2.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*********************************************/\n/* ResetFiveMsgs()                           */\n/* This function goes throw all the messsage */\n/* rooms and sets the users pointer to the   */\n/* read the last five messages only..        */\n/*********************************************/\n", "func_signal": "void ResetFiveMsgs()", "code": "{\n\tlong lohi[2];\n\tint i;\n\t\n\tfor(i=0;i<maxrooms;i++) {\n\t\tStatMsgs(lohi,i);\n\t\tif(i != 1) {\n\t\t\tif(lohi[1] > 5) userstate.lastmsg[i] = (long) lohi[1] - 5;\n\t\t} else {\n\t\t\tuserstate.lastmsg[i] = 1;\n\t\t}\n\t}\n\tupdate_user_state();\n}", "path": "rmsg.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/******************************************/\n/* misc. support functions for the editor */\n/******************************************/\n", "func_signal": "void draw_editor_header()", "code": "{\n\tprintf(\"\\x1b[0m\");\n\n\tprintf(\"\u001b[0;31m            .-------------------------.\\n\");\n\tprintf(\"\u001b[1;32m  /|||\\\\\\\\   \u001b[0;31m|\u001b[1mCompose your message here\u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;32m /\u001b[0;31mC^,^C\u001b[1;32m\\\\\\\\   \u001b[0;31m|  \u001b[0;33m=-=-=-=-=-=-=-=-=-=-=-  \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;32m \\\\\\\\\\\\\u001b[0;31mo \u001b[1;32m///   \u001b[0;31m|<^> the `caret` key will \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[0;31m/P  ||      \u001b[0;31m| allow you to change the \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[0;31m\\\\\\\\/\u001b[1;33m(  )\u001b[0;31m\\\\    \u001b[0;31m|color of text then punch,\u001b[0;31m|\\n\");\n\tprintf(\"\u001b[0;31m \\\\/\u001b[1;33m \\\\_\\\\\u001b[0;31m\\\\\\\\   \u001b[0;31m| b,r,m,g,y,B,R,M,G, or Y.\u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;33m   /   \\\\\u001b[0;31m\\\\P  \u001b[0;31m|\u001b[1m <\u001b[0;31menter\u001b[1m> key twice prompt \u001b[0;31m|\\n\");\n\tprintf(\"\u001b[1;33m   \\\\___/    \u001b[0;31m| you to save the message.\u001b[0;31m!|\\n\");\n\tprintf(\"\u001b[0;31m    \\\\\\\\\\\\\\\\    \u001b[0;31m`-------------------------'\\n\");\n\tprintf(\"\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0;31m~~~~\\033[1m.\\033[0m\");\n}", "path": "utils\\editor2.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*************************************************/\n/* CatFileDirect()                               */\n/* Print an entire file from exact filepath name */\n/* Does page pausing and more prompts.           */\n/*************************************************/\n", "func_signal": "int CatFileDirect(const char *filename)", "code": "{\n\tFILE *fp;\n\tchar ibuf[128];\n\tint x=0;\n\t\n\tfflush(stdout);\n\tif((fp = fopen(filename,\"rt\")) == NULL) {\n\t\treturn -1;\n\t}\n\tfor(;;) {\n\t\tif(x <= (rows-2)) {\n\t\t\tif(fgets(ibuf, 127, fp) != NULL) {\n\t\t\t\tprintf(\"%s\",ibuf);\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\tfclose(fp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!More2()) {\n\t\t\t\tfclose(fp);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tx=0;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fp);\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*******************************************/\n/* JoinRoom()                              */\n/* This function shows a menu to the user  */\n/* and allows them to join different rooms */\n/*******************************************/\n", "func_signal": "void JoinRoom()", "code": "{\n\tint n;\n\tprintf(\"\\n\\n\\033[0;32mType [\\033[1;33m?\\033[0;32m] to see room list.\\n\");\t\n\tfor(;;) {\n\t  \tprintf(\"\\n\");\n\t\tprintf(\"\\x1b[1;34mYou are in Room #%d\\n\",rNum+1);\n\t\tprintf(\"\\x1b[0m[\\x1b[1;34mENTER\\x1b[0m] to stay here.\\n\\n\");\n\t\n\t\tprintf(\"\\x1b[1;34mR\\x1b[1;35mo\\x1b[1;36mom #\\033[1;35m[\\033[1;34m1-%d\\033[1;35m]\\x1b[36m: \",maxrooms);\n\t\tn = SelectRoom();\n\t\tif(n == -1) {\n\t\t\tbreak;\n\t\t} else if(n == -2) {\n\t\t\tcontinue;\n\t\t} else {\t\n\t\t\trNum = n;\n\t\t\tJoinStats();\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "rmsg.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*******************************/\n/* CatFileNoPause()            */\n/* Print entire file path name */\n/* without pausing for more.   */\n/*******************************/\n", "func_signal": "int CatFileNoPause(const char *filename)", "code": "{\n\tFILE *fp;\n\tchar obuf[200], ibuf[128];\n\tchar ch;\n\n\tfflush(stdout);\t\n\tsprintf(obuf,\"%s/text/%s\",BBSDIR,filename);\n\tif((fp = fopen(obuf, \"rt\")) == NULL) {\n\t\treturn -1;\n\t}\n\twhile(fgets(ibuf, 127, fp) != NULL) {\n\t\tprintf(\"%s\", ibuf);\n\t}\n\t\n\tfflush(stdout);\n\tfclose(fp);\n\treturn 0;\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*******************************************************************/\n/*                                                                 */\n/*   D I C T I O N A R Y  -  O N L I N E  -  F O R  -  W O R D S   */\n/*                                                                 */\n/*******************************************************************/\n", "func_signal": "void DictWord()", "code": "{\n\tchar ibuf[31];\n\tchar tbuf[200];\n\tprintf(\"\\x1b[0mWord to define: \");\n\tGetStr(ibuf, 30,0);\n\n\tif(ibuf[0] == '\\0') {\n\t\tprintf(\"\\nCancelled!\\n\\n\");\n\t\treturn;\n\t}\n\tprintf(\"\\n\\033[0;32mPlease Wait...\");\n\tfflush(stdout);\n\tsleep(1);\n\tsyslog(LOG_INFO,\"%s %s %s\",\n\t\tget_user_name(),\n\t\t\"is looking up the word\",\n\t\tibuf);\n\tsprintf(tbuf,\"dict %s > \\\"%s/users/%s/tmp.dict.txt\\\"\",\n\t\tibuf,\n\t\tBBSDIR,\n\t\tget_user_name());\n\tsystem(tbuf);\n\tsprintf(tbuf,\"%s/users/%s/tmp.dict.txt\",\n\t\tBBSDIR,\n\t\tget_user_name());\n\tCatFileDirect(tbuf);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\treturn;\t\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/**********************************/\n/* exists_player_state()          */\n/* check to see if the playerfile */\n/* exists and is valid size.      */\n/**********************************/\n", "func_signal": "int exists_player_state()", "code": "{\n\tchar obuf[256];\n\tstruct stat st;\n\tsprintf(obuf,\"%s/users/%s/player_state\",BBSDIR,get_user_name(),PLAYERFILE);\n\tstat(obuf,&st);\n\tif(st.st_size != sizeof(PLAYER)) return 0;   /* wrong size */\n\treturn 1;                                    /* right size */\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*******************************************/\n/* strisdigit()                            */\n/* Test to see if the STRING is all digits */\n/*******************************************/\n", "func_signal": "int strisdigit(char *s)", "code": "{\n\tfor( ; ((*s != 0) || isspace(*s)) ; s++ ) if(!isdigit(*s)) return FALSE;\n\treturn TRUE;\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/***************************/\n/* Pauses and More Prompts */\n/***************************/\n", "func_signal": "void Pause(void)", "code": "{\t\n\tint ch;\n\tprintf(\"\\x1b[0;1;31m[\\x1b[34mPaUSed\\x1b[31m] \\x1b[32mhit the SPACEBAR\\x1b[1;31m: \\x1b[0m\");\n\tfor(;;) {\n\t\tch = toupper(GetKey(0));\n\t\tif(ch == ' ' || ch == 'C') break;\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\treturn;\n}", "path": "misc.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/**********************************/\n/* view_player_stat()             */\n/* printout the player statistics */\n/**********************************/\n", "func_signal": "void view_player_stat()", "code": "{\n\tint i;\n\t\n\tprintf(\"\\n\\033[1;34m\");\n\tfor(i=0;i< (16+strlen(username) );i++) printf(\"=\");\n\tprintf(\"\\n\");\n\tprintf(\"\\033[1;32;44mSTATUS: \\033[1;33mCaptain %s\\033[0;40m\",username);\n\tprintf(\"\\n\\033[1;34m\");\n\tfor(i=0;i<(16+strlen(username));i++) printf(\"=\");\n\tprintf(\"\\033[0m\\n\");\n\n\tprintf(\"\\033[35m  Turns Left\\033[32m: \\033[36m%d\\n\",player.turns_left);\n\tprintf(\"\\033[35m  Hit Points\\033[32m: \\033[36m%d \\033[35mof \\033[36m%d\\n\",player.phits,player.max_phits);\n\tprintf(\"\\033[35m       Charm\\033[32m: \\033[36m%d\\n\",player.chr);\n\tprintf(\"\\033[35m    Strength\\033[32m: \\033[36m%d\\n\",player.str);\n\tprintf(\"\\033[35m   Dexterity\\033[32m: \\033[36m%d\\n\",player.dex);\n\tprintf(\"\\033[35mCredit Chips\\033[32m: \\033[36m%ld \\033[32m(\\033[36m%ld \\033[35mloan\\033[32m)\\n\",player.credit_chips,player.loan);\n\tprintf(\"\\033[35m Total Score\\033[32m: \\033[36m%ld \\033[32m(\\033[35mAlingment=\\033[36m%d\\033[32m)\\n\",player.score,player.alingment);\n\t\n\tprintf(\"\\n\\033[1;34m\");\n\tfor(i=0;i<(15+strlen(player.shipname));i++) printf(\"=\");\n\tprintf(\"\\n\");\n\tprintf(\"\\033[1;32;44mSTATUS: \\033[1;33m%s Vessel\\033[0;40m\",player.shipname);\n\tprintf(\"\\n\\033[1;34m\");\n\tfor(i=0;i<(15+strlen(player.shipname));i++) printf(\"=\");\n\tprintf(\"\\033[0m\\n\");\n\t\n\tprintf(\"\\033[35m Ship Class\\033[32m: %s\\n\",player.shipbrand);\n\tprintf(\"\\033[35m Warp Jumps\\033[32m: \\033[36m%d \\033[35mof \\033[36m%d (%d turns)\\n\",player.warps_left,player.max_warps,player.turns_per_warp);\n\tprintf(\"\\033[35mHull Points\\033[32m: \\033[36m%d \\033[35mof \\033[36m%d\\n\",player.ship_hits,player.max_ship_hits);\n\tprintf(\"\\033[35m Cargo Bays\\033[32m: \\033[36m%d\\033[35m/\\033[36m%d\\n\",player.cargo_bays,player.max_cargo_bays);\n\tprintf(\"\\033[35m   Fighters\\033[32m: \\033[36m%d\\033[35m/\\033[36m%d\\n\",player.fighters,player.max_fighters);\n\tprintf(\"\\033[35m    Shields\\033[32m: \\033[36m%d\\033[35m/\\033[36m%d\\n\",player.shields,player.max_shields);\n\tprintf(\"\\n\");\n\tPause3();\n\treturn;\n}", "path": "game.c", "repo_name": "rabbitear/Homebrew-bbs", "stars": 9, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* initialization + set ranges with a given spacing from min to max */\n", "func_signal": "static VALUE rb_gsl_histogram_alloc_with_min_max_step(VALUE klass, VALUE vmin, \n\t\t\t\t\t    VALUE vmax, VALUE ss)", "code": "{\n  gsl_histogram *h = NULL;\n  gsl_vector *v = NULL;\n  double min, max, tmp, step;\n  size_t i, n;\n  Need_Float(vmin); Need_Float(vmax); Need_Float(ss);\n  min = NUM2DBL(vmin);\n  max = NUM2DBL(vmax);\n  step = NUM2DBL(ss);\n  if (min > max) {\n    tmp = min;\n    min = max;\n    max = tmp;\n  }\n  n = (int) ((max - min)/step);\n  h = gsl_histogram_alloc(n);\n  v = gsl_vector_alloc(n + 1);\n  for (i = 0; i < n + 1; i++) gsl_vector_set(v, i, min + step*i);\n  gsl_histogram_set_ranges(h, v->data, v->size);\n  gsl_vector_free(v);\n  return Data_Wrap_Struct(klass, 0, gsl_histogram_free, h);\n}", "path": "ext\\histogram.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* Integrate histogram: the two histograms must have the same range and bins. */\n", "func_signal": "void mygsl_histogram_integrate(const gsl_histogram *h, gsl_histogram *hi,\n\t\t\t       size_t istart, size_t iend)", "code": "{\n  size_t i;\n  if (iend >= istart) {\n    if (istart < 0) istart = 0;\n    if (iend >= h->n) iend = h->n-1;\n    hi->bin[istart] = h->bin[istart];\n    for (i = istart+1; i <= iend; i++) hi->bin[i] = hi->bin[i-1] + h->bin[i];\n  } else {\n    if (istart >= h->n) istart = h->n-1;\n    if (iend < 0) iend = 0;\n    hi->bin[istart] = h->bin[istart];\n    for (i = istart-1; i >= iend; i--) {\n      hi->bin[i] = hi->bin[i+1] + h->bin[i];\n      if (i == 0) break;\n    }\n  }\n}", "path": "ext\\histogram.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* (-infty --- b) */\n", "func_signal": "static VALUE rb_gsl_integration_qagil(int argc, VALUE *argv, VALUE obj)", "code": "{\n  double b, epsabs, epsrel;\n  double result, abserr;\n  size_t limit;\n  gsl_function *F = NULL;\n  gsl_integration_workspace *w = NULL;\n  int status, intervals, flag = 0, itmp;\n  switch (TYPE(obj)) {\n  case T_MODULE:  case T_CLASS:  case T_OBJECT:\n    CHECK_FUNCTION(argv[0]);\n    Data_Get_Struct(argv[0], gsl_function, F);\n    itmp = 1;\n    break;\n  default:\n    Data_Get_Struct(obj, gsl_function, F);\n    itmp = 0;\n    break;\n  }\n  Need_Float(argv[itmp]);\n  b = NUM2DBL(argv[itmp]);\n  flag = get_epsabs_epsrel_limit_workspace(argc, argv, itmp+1, &epsabs, &epsrel,\n\t\t\t\t\t   &limit, &w);\n  Data_Get_Struct(obj, gsl_function, F);\n\n  status = gsl_integration_qagil(F, b, epsabs, epsrel, limit, w, \n\t\t\t\t&result, &abserr);\n  intervals = w->size;\n  if (flag == 1) gsl_integration_workspace_free(w);\n\n  return rb_ary_new3(4, rb_float_new(result), rb_float_new(abserr), \n\t\t     INT2FIX(intervals), INT2FIX(status));\n}", "path": "ext\\integration.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* singleton */\n", "func_signal": "static VALUE rb_gsl_histogram_memcpy(VALUE obj, VALUE vhdest, VALUE vhsrc)", "code": "{\n  gsl_histogram *hdest = NULL, *hsrc = NULL;\n  CHECK_HISTOGRAM(vhdest);\n  CHECK_HISTOGRAM(vhsrc);\n  Data_Get_Struct(vhdest, gsl_histogram, hdest);\n  Data_Get_Struct(vhsrc, gsl_histogram, hsrc);\n  gsl_histogram_memcpy(hdest, hsrc);\n  return vhdest;\n}", "path": "ext\\histogram.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* xx: Numeric, Complex, Vector, Matrix\n   nn: Numeric, Complex\n*/\n", "func_signal": "VALUE rb_gsl_pow(VALUE obj, VALUE xx, VALUE nn)", "code": "{\n  VALUE x, ary, argv[2];\n  size_t i, j, size;\n  double n;\n  gsl_vector *v = NULL, *vnew = NULL;\n  gsl_matrix *m = NULL, *mnew = NULL;\n#ifdef HAVE_NARRAY_H\n  struct NARRAY *na;\n  double *ptr1, *ptr2;\n#endif\n  if (CLASS_OF(xx) == rb_cRange) xx = rb_gsl_range2ary(xx);\n  switch (TYPE(xx)) {\n  case T_FIXNUM:\n  case T_BIGNUM:\n  case T_FLOAT:\n    return rb_float_new(pow(NUM2DBL(xx), NUM2DBL(nn)));\n    break;\n  case T_ARRAY:\n    n = NUM2DBL(nn);\n    size = RARRAY_LEN(xx);\n    ary = rb_ary_new2(size);\n    for (i = 0; i < size; i++) {\n      x = rb_ary_entry(xx, i);\n      Need_Float(x);\n      rb_ary_store(ary, i, rb_float_new(pow(NUM2DBL(x), n)));\n    }\n    return ary;\n    break;\n  default:\n#ifdef HAVE_NARRAY_H\n    if (NA_IsNArray(xx)) {\n      n = NUM2DBL(nn);\n      GetNArray(xx, na);\n      ptr1 = (double*) na->ptr;\n      size = na->total;\n      ary = na_make_object(NA_DFLOAT, na->rank, na->shape, CLASS_OF(xx));\n      ptr2 = NA_PTR_TYPE(ary, double*);\n      for (i = 0; i < size; i++) ptr2[i] = pow(ptr1[i], n);\n      return ary;\n    }\n#endif\n    if (VECTOR_P(xx)) {\n      n = NUM2DBL(nn);\n      Data_Get_Struct(xx, gsl_vector, v);\n      vnew = gsl_vector_alloc(v->size);\n      for (i = 0; i < v->size; i++) {\n\tgsl_vector_set(vnew, i, pow(gsl_vector_get(v, i), n));\n      }\n      return Data_Wrap_Struct(cgsl_vector, 0, gsl_vector_free, vnew);\n    } \n    if (MATRIX_P(xx)) {\n      n = NUM2DBL(nn);\n      Data_Get_Struct(xx, gsl_matrix, m);\n      mnew = gsl_matrix_alloc(m->size1, m->size2);\n      for (i = 0; i < m->size1; i++) {\n\tfor (j = 0; j < m->size2; j++) {\n\t  gsl_matrix_set(mnew, i, j, pow(gsl_matrix_get(m, i, j), n));\n\t}\n      }\n      return Data_Wrap_Struct(cgsl_matrix, 0, gsl_matrix_free, mnew);\n    } \n    if (COMPLEX_P(xx) || VECTOR_COMPLEX_P(xx) || MATRIX_COMPLEX_P(xx)) {\n      argv[0] = xx;\n      argv[1] = nn;\n      return rb_gsl_complex_pow(2, argv, obj);\n    }\n    rb_raise(rb_eTypeError, \"wrong argument type %s (Array or Vector or Matrix expected)\", rb_class2name(CLASS_OF(xx)));\n    break;\n  }\n  /* never reach here */\n  return Qnil;\n}", "path": "ext\\math.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* Create a histogram integrating the given histogram h */\n", "func_signal": "gsl_histogram* mygsl_histogram_calloc_integrate(const gsl_histogram *h,\n\t\t\t\t\t\tsize_t istart, size_t iend)", "code": "{\n  gsl_histogram *hi = NULL;\n  hi = gsl_histogram_calloc_range(h->n, h->range);\n  mygsl_histogram_integrate(h, hi, istart, iend);\n  return hi;\n}", "path": "ext\\histogram.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/*************************************************/\n", "func_signal": "void Init_ool(VALUE module)", "code": "{\n\tVALUE mOOL, mConmin;\n\tVALUE cool_conmin_minimizer;\n\t\n\tmOOL = rb_define_module(\"OOL\");\n\tmConmin = rb_define_module_under(mOOL, \"Conmin\");\n\tcool_conmin_function = rb_define_class_under(mConmin, \"Function\", cgsl_function);\n\tcool_conmin_constraint = rb_define_class_under(mConmin, \"Constraint\", cGSL_Object);\n \tcool_conmin_minimizer = rb_define_class_under(mConmin, \"Minimizer\", cGSL_Object);\n \tcool_conmin_pgrad = rb_define_class_under(cool_conmin_minimizer, \"Pgrad\", cGSL_Object);\n \tcool_conmin_spg = rb_define_class_under(cool_conmin_minimizer, \"Spg\", cGSL_Object);\n \tcool_conmin_gencan = rb_define_class_under(cool_conmin_minimizer, \"Gencan\", cGSL_Object); \t\n\n \tdef_const(mOOL); \t\n \t\n \trb_define_singleton_method(cool_conmin_minimizer, \"alloc\", rb_ool_conmin_minimizer_alloc, -1);\n \trb_define_method(cool_conmin_minimizer, \"set\", rb_ool_conmin_minimizer_set, -1); \t\n \trb_define_method(cool_conmin_minimizer, \"parameters_default\", rb_ool_conmin_minimizer_parameters_default, 0); \t\n \trb_define_method(cool_conmin_minimizer, \"name\", rb_ool_conmin_minimizer_name, 0);\n \trb_define_method(cool_conmin_minimizer, \"size\", rb_ool_conmin_minimizer_size, 0); \t\n \trb_define_method(cool_conmin_minimizer, \"f\", rb_ool_conmin_minimizer_f, 0);\n \trb_define_method(cool_conmin_minimizer, \"x\", rb_ool_conmin_minimizer_x, 0);\n \trb_define_method(cool_conmin_minimizer, \"dx\", rb_ool_conmin_minimizer_dx, 0);\n \trb_define_method(cool_conmin_minimizer, \"gradient\", rb_ool_conmin_minimizer_gradient, 0); \t \t\n \trb_define_method(cool_conmin_minimizer, \"minimum\", rb_ool_conmin_minimizer_minimum, 0); \t \t \t\n \trb_define_method(cool_conmin_minimizer, \"fcount\", rb_ool_conmin_minimizer_fcount, 0); \t\n \trb_define_method(cool_conmin_minimizer, \"gcount\", rb_ool_conmin_minimizer_gcount, 0); \t\n \trb_define_method(cool_conmin_minimizer, \"hcount\", rb_ool_conmin_minimizer_hcount, 0); \t \t \t\n \trb_define_method(cool_conmin_minimizer, \"is_optimal\", rb_ool_conmin_minimizer_is_optimal, 0);\n \trb_define_method(cool_conmin_minimizer, \"is_optimal?\", rb_ool_conmin_minimizer_is_optimal2, 0); \t\n \trb_define_method(cool_conmin_minimizer, \"iterate\", rb_ool_conmin_minimizer_iterate, 0); \t \t \t\n \trb_define_method(cool_conmin_minimizer, \"restart\", rb_ool_conmin_minimizer_restart, 0); \t \t \t\n \trb_define_method(cool_conmin_minimizer, \"parameters_get\", rb_ool_conmin_minimizer_parameters_get, 0);\n \trb_define_method(cool_conmin_minimizer, \"parameters_set\", rb_ool_conmin_minimizer_parameters_set, 1);\n  \t \t\n \trb_define_singleton_method(cool_conmin_function, \"alloc\", rb_ool_conmin_function_alloc, -1);\n \trb_define_method(cool_conmin_function, \"set\", rb_ool_conmin_function_set, -1);\n \trb_define_method(cool_conmin_function, \"set_n\", rb_ool_conmin_function_set_n, 1);\n\trb_define_alias(cool_conmin_function, \"n=\", \"set_n\"); \t\n \trb_define_method(cool_conmin_function, \"n\", rb_ool_conmin_function_n, 0); \t\n \trb_define_method(cool_conmin_function, \"params\", rb_ool_conmin_function_params, 0); \t \t\n \trb_define_method(cool_conmin_function, \"set_params\", rb_ool_conmin_function_set_params, 1);\n\trb_define_alias(cool_conmin_function, \"params=\", \"set_params\"); \t \t\n \trb_define_method(cool_conmin_function, \"set_functions\", rb_ool_conmin_function_set_functions, 1);\n\trb_define_alias(cool_conmin_function, \"functions=\", \"set_functions\"); \t \t\t\n \trb_define_method(cool_conmin_function, \"set_f\", rb_ool_conmin_function_set_f, 1);\n\trb_define_alias(cool_conmin_function, \"f=\", \"set_f\"); \t \t\n \trb_define_method(cool_conmin_function, \"set_df\", rb_ool_conmin_function_set_df, 1);\n\trb_define_alias(cool_conmin_function, \"df=\", \"set_df\"); \t \t\n \trb_define_method(cool_conmin_function, \"set_fdf\", rb_ool_conmin_function_set_fdf, 1);\n\trb_define_alias(cool_conmin_function, \"fdf=\", \"set_fdf\"); \t \t\n \trb_define_method(cool_conmin_function, \"set_Hv\", rb_ool_conmin_function_set_Hv, 1);\n\trb_define_alias(cool_conmin_function, \"Hv=\", \"set_Hv\"); \t \t\t\t\t\t\t\n\n\trb_define_singleton_method(cool_conmin_constraint, \"alloc\", rb_ool_conmin_constraint_alloc,\n\t\t-1);\n\trb_define_method(cool_conmin_constraint, \"set\", rb_ool_conmin_constraint_set, -1);\t\t\n\trb_define_method(cool_conmin_constraint, \"set_n\", rb_ool_conmin_constraint_set_n, 1);\n\trb_define_alias(cool_conmin_constraint, \"n=\", \"set_n\");\n\trb_define_method(cool_conmin_constraint, \"set_L\", rb_ool_conmin_constraint_set_L, 1);\n\trb_define_alias(cool_conmin_constraint, \"L=\", \"set_L\");\t\n\trb_define_method(cool_conmin_constraint, \"set_U\", rb_ool_conmin_constraint_set_U, 1);\n\trb_define_alias(cool_conmin_constraint, \"U=\", \"set_U\");\t\n\trb_define_method(cool_conmin_constraint, \"set_LU\", rb_ool_conmin_constraint_set_LU, 2);\n\trb_define_alias(cool_conmin_constraint, \"LU=\", \"set_LU\");\t\t\n\t\n\tcool_conmin_pgrad_parameters = rb_define_class_under(cool_conmin_pgrad, \"Parameters\",\n\t\t\trb_cArray);\n\tcool_conmin_spg_parameters = rb_define_class_under(cool_conmin_spg, \"Parameters\",\n\t\t\trb_cArray);\n\tcool_conmin_gencan_parameters = rb_define_class_under(cool_conmin_gencan, \"Parameters\",\n\t\t\trb_cArray);\t\t\t\n\trb_define_singleton_method(cool_conmin_pgrad, \"parameters_default\",\n\t\trb_ool_conmin_pgrad_parameters_default, 0);\t\n\trb_define_singleton_method(cool_conmin_spg, \"parameters_default\",\n\t\trb_ool_conmin_spg_parameters_default, 0);\t\n\trb_define_singleton_method(cool_conmin_gencan, \"parameters_default\",\n\t\trb_ool_conmin_gencan_parameters_default, 0);\t\t\t\t\t\t\t\n}", "path": "ext\\ool.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/***** siman_destroy *****/\n", "func_signal": "static void rb_gsl_siman_destroy_t(void *data)", "code": "{\n  siman_solver *ss = NULL;\n  ss = (siman_solver *) data;\n  gsl_siman_solver_free(ss);\n}", "path": "ext\\siman.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* linear fit without weights: y = c0 + c1 x */\n/* This returns 7 elements array */\n", "func_signal": "static VALUE rb_gsl_fit_linear(int argc, VALUE *argv, VALUE obj)", "code": "{\n  double *ptrx, *ptry;\n  double c0, c1, cov00, cov01, cov11, sumsq;\n  int status;\n  size_t n, stridex, stridey;\n  switch (argc) {\n  case 2:\n    ptrx = get_vector_ptr(argv[0], &stridex, &n);\n    ptry = get_vector_ptr(argv[1], &stridey, &n);\n    break;\n  case 3:\n    CHECK_FIXNUM(argv[2]);\n    ptrx = get_vector_ptr(argv[0], &stridex, &n);\n    ptry = get_vector_ptr(argv[1], &stridey, &n);\n    n = FIX2INT(argv[2]);\n    break;\n  default:\n    rb_raise(rb_eArgError, \"wrong number of arguments (%d for 2 or 3)\", argc);\n    break;\n  }\n  status = gsl_fit_linear(ptrx, stridex, ptry, stridey, n, &c0, &c1, &cov00,\n\t\t\t  &cov01, &cov11, &sumsq);\n  return rb_ary_new3(7, rb_float_new(c0), rb_float_new(c1), rb_float_new(cov00),\n\t\t     rb_float_new(cov01), rb_float_new(cov11), rb_float_new(sumsq),\n\t\t     INT2FIX(status));\n}", "path": "ext\\fit.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* linear fit with weights: y = c0 + c1 x */\n", "func_signal": "static VALUE rb_gsl_fit_wlinear(int argc, VALUE *argv, VALUE obj)", "code": "{\n  double *ptrx, *ptry, *ptrw;\n  double c0, c1, cov00, cov01, cov11, sumsq;\n  int status;\n  size_t n, stridex, stridey, stridew;\n  switch (argc) {\n  case 3:\n    ptrx = get_vector_ptr(argv[0], &stridex, &n);\n    ptrw = get_vector_ptr(argv[1], &stridew, &n);\n    ptry = get_vector_ptr(argv[2], &stridey, &n);\n    break;\n  case 4:   \n    CHECK_FIXNUM(argv[3]);\n    ptrx = get_vector_ptr(argv[0], &stridex, &n);\n    ptrw = get_vector_ptr(argv[1], &stridew, &n);\n    ptry = get_vector_ptr(argv[2], &stridey, &n);\n    n = FIX2INT(argv[3]);\n    break;\n  default:\n    rb_raise(rb_eArgError, \"wrong number of arguments (%d for 2 or 3)\", argc);\n    break;\n  }\n  status = gsl_fit_wlinear(ptrx, stridex, ptrw, stridew, ptry, stridey,\n\t\t\t   n,\n\t\t\t   &c0, &c1, &cov00, &cov01, &cov11, &sumsq);\n  return rb_ary_new3(7, rb_float_new(c0), rb_float_new(c1), rb_float_new(cov00),\n\t\t     rb_float_new(cov01), rb_float_new(cov11), rb_float_new(sumsq),\n\t\t     INT2FIX(status));\n}", "path": "ext\\fit.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* singleton */\n", "func_signal": "static VALUE rb_gsl_rng_set_default_seed(VALUE obj, VALUE seed)", "code": "{\n  gsl_rng_default_seed = NUM2UINT(seed);\n  return seed;\n}", "path": "ext\\rng.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/***** solver *****/\n", "func_signal": "static VALUE rb_gsl_siman_solver_solve(VALUE obj, VALUE rng,\n\t\t\t\t       VALUE vx0p, VALUE vefunc,\n\t\t\t\t       VALUE vstep, VALUE vmetric, VALUE vprint,\n\t\t\t\t       VALUE vparams)", "code": "{\n  gsl_rng *r = NULL;\n  siman_solver *ss = NULL;\n  siman_Efunc *efunc = NULL;\n  siman_step *step = NULL;\n  siman_metric *metric = NULL;\n  siman_print *print = NULL;\n  gsl_vector *vtmp = NULL;\n  gsl_siman_params_t *params = NULL, ppp;\n  int flag = 0;\n  /*  Data_Get_Struct(obj, siman_solver, ss);*/\n  CHECK_VECTOR(vx0p);\n  Data_Get_Struct(vx0p, gsl_vector, vtmp);\n\n  switch (TYPE(obj)) {\n  case T_MODULE:\n  case T_CLASS:\n  case T_OBJECT:\n    ss = gsl_siman_solver_alloc(vtmp->size);\n    flag = 1;\n    break;\n  default:\n    Data_Get_Struct(obj, siman_solver, ss);\n  }\n  if (!rb_obj_is_kind_of(rng, cgsl_rng))\n    rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Rng expected)\",\n\t     rb_class2name(CLASS_OF(rng)));\n  if (!rb_obj_is_kind_of(vefunc, cgsl_siman_Efunc))\n    rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Siman::Efunc expected)\",\n\t     rb_class2name(CLASS_OF(vefunc)));\n  if (!rb_obj_is_kind_of(vstep, cgsl_siman_step))\n    rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Siman::Step expected)\",\n\t     rb_class2name(CLASS_OF(vstep)));\n  if (!rb_obj_is_kind_of(vmetric, cgsl_siman_metric))\n    rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Siman::Metric expected)\",\n\t     rb_class2name(CLASS_OF(vmetric)));\n\n  Data_Get_Struct(rng, gsl_rng, r);\n  Data_Get_Struct(vefunc, siman_Efunc, efunc);\n  Data_Get_Struct(vstep, siman_step, step);\n  Data_Get_Struct(vmetric, siman_metric, metric);\n  if (NIL_P(vprint)) {\n    ss->proc_print = Qnil;\n  } else {\n    if (!rb_obj_is_kind_of(vprint, cgsl_siman_print))\n      rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Siman::Print expected)\",\n\t       rb_class2name(CLASS_OF(vprint)));\n    Data_Get_Struct(vprint, siman_print, print);\n    ss->proc_print   = print->proc;\n  }\n  if (!rb_obj_is_kind_of(vparams, cgsl_siman_params))\n    rb_raise(rb_eTypeError, \"wrong argument type %s (GSL::Siman::Params expected)\",\n\t     rb_class2name(CLASS_OF(vparams)));\n\n  Data_Get_Struct(vparams, gsl_siman_params_t, params);\n\n  ss->proc_efunc   = efunc->proc;\n  ss->proc_step    = step->proc;\n  ss->proc_metric  = metric->proc;\n\n  gsl_vector_memcpy(ss->vx, vtmp);\n  ppp = *params;\n\n  if (NIL_P(vprint)) {\n    gsl_siman_solve(r, ss, rb_gsl_siman_Efunc_t, \n\t\t    rb_gsl_siman_step_t, \n\t\t    rb_gsl_siman_metric_t, \n\t\t    NULL,\n\t\t    rb_gsl_siman_copy_t, \n\t\t    rb_gsl_siman_copy_construct_t,\n\t\t    rb_gsl_siman_destroy_t, 0,\n\t\t    *params);\n\n  } else {\n    gsl_siman_solve(r, ss, rb_gsl_siman_Efunc_t, \n\t\t    rb_gsl_siman_step_t, \n\t\t    rb_gsl_siman_metric_t, \n\t\t    rb_gsl_siman_print_t, \n\t\t    rb_gsl_siman_copy_t, \n\t\t    rb_gsl_siman_copy_construct_t,\n\t\t    rb_gsl_siman_destroy_t, 0,\n\t\t    *params);\n  }\n\n  gsl_vector_memcpy(vtmp, ss->vx);\n\n  if (flag == 1) gsl_siman_solver_free(ss);\n\n  return obj;\n}", "path": "ext\\siman.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/*\n  Document-method: <i>GSL::Rng.alloc</i>\n    Constructor.\n*/\n", "func_signal": "static VALUE rb_gsl_rng_alloc(int argc, VALUE *argv, VALUE klass)", "code": "{\n  gsl_rng *r = NULL;\n  const gsl_rng_type *T;\n  unsigned long seed;\n  int itype;\n  gsl_rng_env_setup();\n  if (argc == 0) {\n    T = gsl_rng_default;\n    seed = gsl_rng_default_seed;\n  } else {\n    T = get_gsl_rng_type(argv[0]);    \n    if (argc == 1) {\n      seed = gsl_rng_default_seed;\n    } else if (argc == 2) {\n      itype = TYPE(argv[1]);\n      if (itype == T_FIXNUM || itype == T_BIGNUM) {\n\tseed = FIX2INT(argv[1]);\n      } else {\n\trb_raise(rb_eArgError, \n\t\t \"bad argument 2, seed must be an integer.\");\n      }\n    } else {\n      rb_raise(rb_eArgError, \"too many arguments (%d for 0 or 1)\", argc);\n    }\n  }\n  r = gsl_rng_alloc(T);\n  gsl_rng_set(r, seed);\n  return Data_Wrap_Struct(klass, 0, gsl_rng_free, r);\n}", "path": "ext\\rng.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* initialization + set uniform ranges (equal spacing from min to max) */\n", "func_signal": "static VALUE rb_gsl_histogram_alloc_uniform(int argc, VALUE *argv, VALUE klass)", "code": "{\n  gsl_histogram *h = NULL;\n  double min, max, tmp;\n  size_t n;\n  switch (argc) {\n  case 3:\n    CHECK_FIXNUM(argv[0]);\n    Need_Float(argv[1]); Need_Float(argv[2]);\n    n = FIX2INT(argv[0]);\n    min = NUM2DBL(argv[1]);\n    max = NUM2DBL(argv[2]);\n    break;\n  case 2:\n    CHECK_FIXNUM(argv[0]);\n    n = FIX2INT(argv[0]);\n    Check_Type(argv[1], T_ARRAY);\n    min = NUM2DBL(rb_ary_entry(argv[1], 0));\n    max = NUM2DBL(rb_ary_entry(argv[1], 1));\n    break;\n  default:\n    rb_raise(rb_eArgError, \"wrong number of arguments (%d for 2 or 3)\", argc);\n    break;\n  }\n  if (min > max) {\n    tmp = min;\n    min = max;\n    max = tmp;\n  }\n  h = gsl_histogram_alloc(n);\n  gsl_histogram_set_ranges_uniform(h, min, max);\n  return Data_Wrap_Struct(klass, 0, gsl_histogram_free, h);\n}", "path": "ext\\histogram.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/****************/\n", "func_signal": "static void define_const(VALUE klass1, VALUE klass2)", "code": "{\n  rb_define_const(klass1, \n\t\t  \"CONJUGATE_FR\", INT2FIX(GSL_FDFMINIMIZER_CONJUGATE_FR));\n  rb_define_const(klass1, \n\t\t  \"CONJUGATE_PR\", INT2FIX(GSL_FDFMINIMIZER_CONJUGATE_PR));\n  rb_define_const(klass1, \n\t\t  \"VECTOR_BFGS\", INT2FIX(GSL_FDFMINIMIZER_VECTOR_BFGS));  \n  rb_define_const(klass1, \n\t\t  \"STEEPEST_DESCENT\", INT2FIX(GSL_FDFMINIMIZER_STEEPEST_DESCENT));\n#ifdef GSL_1_3_LATER\n  rb_define_const(klass2, \n\t\t  \"NMSIMPLEX\", INT2FIX(GSL_FMINIMIZER_NMSIMPLEX));\n#endif\n#ifdef GSL_1_9_LATER\n  rb_define_const(klass1, \n\t\t  \"VECTOR_BFGS2\", INT2FIX(GSL_FDFMINIMIZER_VECTOR_BFGS2));\n#endif\n}", "path": "ext\\multimin.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/*\n  Document-method: <i>GSL::Rng#get</i>\n    Returns a random integer from the generator. \n    The minimum and maximum values depend on the algorithm used, \n    but all integers in the range [min,max] are equally likely. \n    The values of min and max can determined using the auxiliary \n    methodss GSL::Rng#max and GSL::Rng#min.\n*/\n", "func_signal": "static VALUE rb_gsl_rng_get(int argc, VALUE *argv, VALUE obj)", "code": "{\n  gsl_rng *r = NULL;\n  gsl_vector_int *v;\n  size_t n, i;\n  Data_Get_Struct(obj, gsl_rng, r);\n  switch (argc) {\n  case 0:\n    return UINT2NUM(gsl_rng_get(r));\n    break;\n  case 1:\n    n = NUM2INT(argv[0]);\n    v = gsl_vector_int_alloc(n);\n    for (i = 0; i < n; i++) gsl_vector_int_set(v, i, (int) gsl_rng_get(r));\n    return Data_Wrap_Struct(cgsl_vector_int, 0, gsl_vector_int_free, v);\n    break;\n  default:\n    rb_raise(rb_eArgError, \"wrong number of arguments (%d for 0 or 1)\", argc);\n    break;\n  }\n}", "path": "ext\\rng.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/***** siman_copy_construct *****/\n", "func_signal": "static void* rb_gsl_siman_copy_construct_t(void *data)", "code": "{\n  siman_solver *ssdest = NULL;\n  siman_solver *sssrc = NULL;\n  sssrc = (siman_solver *) data;\n  ssdest = (siman_solver *) gsl_siman_solver_alloc(sssrc->vx->size);\n  ssdest->proc_efunc = sssrc->proc_efunc;\n  ssdest->proc_step = sssrc->proc_step;\n  ssdest->proc_metric = sssrc->proc_metric;\n  ssdest->proc_print = sssrc->proc_print;\n  gsl_vector_memcpy(ssdest->vx, sssrc->vx);\n  return ssdest;\n}", "path": "ext\\siman.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* get a list of the available generator types */\n/* module function */\n", "func_signal": "static VALUE rb_gsl_rng_types_setup(VALUE obj)", "code": "{\n  const gsl_rng_type **t, **t0;\n  VALUE ary;\n  t0 = gsl_rng_types_setup();\n  ary = rb_ary_new();\n  for (t = t0; *t != 0; t++) rb_ary_push(ary, rb_str_new2((*t)->name));\n  return ary;\n}", "path": "ext\\rng.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/* singleton */\n", "func_signal": "static VALUE rb_gsl_poly_make_rational(VALUE obj, VALUE other)", "code": "{\n  gsl_rational *rnew = NULL;\n  gsl_poly *p, *p2;\n  size_t i;\n  Data_Get_Struct(obj, gsl_poly, p);\n  if (VECTOR_P(other)) {\n    Data_Get_Struct(other, gsl_vector, p2);\n    rnew = gsl_rational_new(p, p2);\n  } else {\n    switch (TYPE(other)) {\n    case T_ARRAY:\n      p2 = gsl_vector_alloc(RARRAY_LEN(other));\n      for (i = 0; i < p2->size; i++)\n\tgsl_vector_set(p2, i, NUM2DBL(rb_ary_entry(other, i)));\n      rnew = gsl_rational_new(p, p2);\n      gsl_vector_free(p2);\n      break;\n    case T_FLOAT:\n    case T_FIXNUM:\n      p2 = make_vector_clone(p);\n      gsl_vector_scale(p2, 1.0/NUM2DBL(other));\n      return Data_Wrap_Struct(cgsl_poly, 0, gsl_vector_free, p2);\n      break;\n    default:\n      rb_raise(rb_eTypeError, \"wrong argument type %s\", \n\t       rb_class2name(CLASS_OF(other)));\n      break;\n    }\n  }\n  return Data_Wrap_Struct(cgsl_rational, gsl_rational_mark, gsl_rational_free, rnew);\n}", "path": "ext\\rational.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/*****/\n", "func_signal": "void Init_gsl_multimin(VALUE module)", "code": "{\n  VALUE mgsl_multimin;\n  VALUE cgsl_multimin_fdfminimizer;\n  VALUE cgsl_multimin_fminimizer;\n\n  mgsl_multimin = rb_define_module_under(module, \"MultiMin\");\n  rb_define_singleton_method(mgsl_multimin, \"test_gradient\", rb_gsl_multimin_test_gradient, 2);\n#ifdef GSL_1_3_LATER\n  rb_define_singleton_method(mgsl_multimin, \"test_size\", rb_gsl_multimin_test_size, 2);\n#endif\n\n  cgsl_multimin_fdfminimizer = rb_define_class_under(mgsl_multimin, \"FdfMinimizer\", cGSL_Object);\n  cgsl_multimin_fminimizer = rb_define_class_under(mgsl_multimin, \"FMinimizer\", cGSL_Object);\n  define_const(cgsl_multimin_fdfminimizer, cgsl_multimin_fminimizer);\n\n  cgsl_multimin_function = rb_define_class_under(mgsl_multimin, \"Function\",\n\t\t\t\t\t\t  cgsl_function);\n  rb_define_singleton_method(cgsl_multimin_function, \"alloc\",\n\t\t\t     rb_gsl_multimin_function_new, -1);\n  rb_define_method(cgsl_multimin_function, \"eval\", rb_gsl_multimin_function_eval, 1);\n  rb_define_alias(cgsl_multimin_function, \"call\", \"eval\");\n  rb_define_method(cgsl_multimin_function, \"set_proc\", rb_gsl_multimin_function_set_f, -1);\n  rb_define_alias(cgsl_multimin_function, \"set_f\", \"set_proc\");\n  rb_define_method(cgsl_multimin_function, \"set_params\", rb_gsl_multimin_function_set_params, -1);\n  rb_define_method(cgsl_multimin_function, \"params\", rb_gsl_multimin_function_params, 0);\n  rb_define_method(cgsl_multimin_function, \"n\", rb_gsl_multimin_function_n, 0);\n\n  cgsl_multimin_function_fdf = rb_define_class_under(mgsl_multimin, \"Function_fdf\",\n\t\t\t\t\t\t     cGSL_Object);\n  rb_define_singleton_method(cgsl_multimin_function_fdf, \"alloc\",\n\t\t\t     rb_gsl_multimin_function_fdf_new, -1);\n\n  rb_define_method(cgsl_multimin_function_fdf, \"set\", rb_gsl_multimin_function_fdf_set, -1);\n  rb_define_method(cgsl_multimin_function_fdf, \"set_params\", rb_gsl_multimin_function_fdf_set_params, -1);\n  rb_define_method(cgsl_multimin_function_fdf, \"set_procs\", rb_gsl_multimin_function_fdf_set_procs, -1);\n  rb_define_method(cgsl_multimin_function_fdf, \"params\", rb_gsl_multimin_function_fdf_params, 0);\n  rb_define_method(cgsl_multimin_function_fdf, \"n\", rb_gsl_multimin_function_fdf_n, 0);\n\n  rb_define_singleton_method(cgsl_multimin_fdfminimizer, \"alloc\", rb_gsl_fdfminimizer_new, 2);\n\n  rb_define_method(cgsl_multimin_fdfminimizer, \"set\", rb_gsl_fdfminimizer_set, 4);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"name\", rb_gsl_fdfminimizer_name, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"iterate\", rb_gsl_fdfminimizer_iterate, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"x\", rb_gsl_fdfminimizer_x, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"f\", rb_gsl_fdfminimizer_f, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"gradient\", rb_gsl_fdfminimizer_gradient, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"minimum\", rb_gsl_fdfminimizer_minimum, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"restart\", rb_gsl_fdfminimizer_restart, 0);\n  rb_define_method(cgsl_multimin_fdfminimizer, \"test_gradient\", rb_gsl_fdfminimizer_test_gradient, 1);\n\n  /*****/\n#ifdef GSL_1_3_LATER\n  rb_define_singleton_method(cgsl_multimin_fminimizer, \"alloc\", rb_gsl_fminimizer_new, 2);\n\n  rb_define_method(cgsl_multimin_fminimizer, \"set\", rb_gsl_fminimizer_set, 3);\n  rb_define_method(cgsl_multimin_fminimizer, \"name\", rb_gsl_fminimizer_name, 0);\n  rb_define_method(cgsl_multimin_fminimizer, \"iterate\", rb_gsl_fminimizer_iterate, 0);\n  rb_define_method(cgsl_multimin_fminimizer, \"x\", rb_gsl_fminimizer_x, 0);\n  rb_define_method(cgsl_multimin_fminimizer, \"fval\", rb_gsl_fminimizer_fval, 0);\n  rb_define_method(cgsl_multimin_fminimizer, \"minimum\", rb_gsl_fminimizer_minimum, 0);  \n    rb_define_method(cgsl_multimin_fminimizer, \"size\", rb_gsl_fminimizer_size, 0);\n  rb_define_method(cgsl_multimin_fminimizer, \"test_size\", rb_gsl_fminimizer_test_size, 1);\n#endif\n\n\n#ifdef HAVE_GSL_GSL_MULTIMIN_FSDF_H\n\tInit_multimin_fsdf(mgsl_multimin);\n#endif\n}", "path": "ext\\multimin.c", "repo_name": "JamesHarrison/rb-gsl", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 949}
{"docstring": "/***********************************************************************************\n * Procedure: PostLog\n * Synopsis:  (void)PostLog(message);\n * Purpose:   Output a message to the session log\n ***********************************************************************************/\n", "func_signal": "void PostLog(char *msg)", "code": "{\n   if (!InitSession())\n   {\n      Write(Sesfh, msg, strlen(msg));\n      Write(Sesfh, \"\\n\", 1);\n   }\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: request\n * Synopsis:  rc = request(nochoice, txtidx, parm, option)\n * Purpose:   Present a requester to the user\n ***********************************************************************************/\n", "func_signal": "int request(int nochoice,\n            int txtidx,\n            char *parm,\n            char *option\n           )", "code": "{\n   int rqrc;\n\n#ifdef PROJECT_VMAKE\n/* VOpts doesn't support REXX - under VMake want to fail with no requester */\n   if (global.inrexx)\n   {\n      global.rexxrc = txtidx; /* rexx RC matches config file text entries  */\n      return 0;               /* equivalent to user clicking \"Cancel\"      */\n   }\n#endif\n\n   if (IntuitionBase->LibNode.lib_Version >= 36)\n   {\n      int i;\n      ULONG iflags;\n      char *args[5];\n      struct EasyStruct RespES = { sizeof(struct EasyStruct), 0, NULL, \"%s\", \"%s|%s\" };\n\n      i = 0;\n      args[i++] = global.text[txtidx];\n      if (parm)\n      {\n         RespES.es_TextFormat = \"%s\\n%s\";\n         args[i++] = parm;\n      }\n\n      if (nochoice)\n      {\n         RespES.es_GadgetFormat = global.text[TEXT_OK];\n      }\n      else\n      {\n         args[i++] = global.text[TEXT_OK];\n         if (option)\n         {\n            RespES.es_GadgetFormat = \"%s|%s|%s\";\n            args[i++] = option;\n         }\n         args[i++] = global.text[TEXT_CANCEL];\n      }\n\n      iflags = IDCMP_DISKINSERTED;\n\n      rqrc = EasyRequestArgs(global.window, &RespES, &iflags, (APTR)args);\n   }\n   else\n   {\n      struct IntuiText body, body1, pos, neg;\n      int width, height;\n\n      body.FrontPen  =\n      body.BackPen   = -1;\n      body.DrawMode  = JAM1;\n      body.LeftEdge  = 6;\n      body.TopEdge   = 4;\n      body.ITextFont = &global.ri.TextAttr;\n      body.IText     = global.text[txtidx];\n      body.NextText  = NULL;\n\n      body1 = body;\n      pos   = body;\n      neg   = body;\n      width = IntuiTextLength(&body);\n      height = 4 * global.iheight;\n      if (parm)\n      {\n         int ewidth;\n         body.NextText = &body1;\n         body1.IText   = parm;\n         body1.TopEdge = global.iheight;\n         height += global.iheight;\n         ewidth = IntuiTextLength(&body1);\n         if (ewidth > width) width = ewidth;\n      }\n      width += 36;  /* margins, resize gadget etc. */\n      pos.IText = global.text[TEXT_OK];\n      if (nochoice)\n      {\n         neg.IText = pos.IText;\n      }\n      else\n      {\n         neg.IText = global.text[TEXT_CANCEL];\n      }\n\n      rqrc = AutoRequest(global.window,\n                         &body, &pos, &neg, 0, 0, width, height);      \n   }\n\n#ifdef PROJECT_VMAKE\n/* VOpts doesn't support ARexx - want VMake to set ARexx return code */\n/* unless user followed a success path from the requester            */\n   if ((rqrc == 0) || nochoice)\n      global.rexxrc = txtidx;\n#endif\n\n   return rqrc;\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: cover_window\n * Synopsis:  (void)cover_window();\n * Purpose:   cover the window with a bool gadget - deactivate other gadgets\n ***********************************************************************************/\n", "func_signal": "void cover_window(void)", "code": "{\n   struct Gadget *gad;\n\n   if (cover == 0) /* is there a cover already? */\n   {\n      gad = (struct Gadget *)get_mem(sizeof(struct Gadget));\n      if (gad)\n      {\n         cover = gad;\n   \n         gad->LeftEdge    = global.ri.WindowLeft;\n         gad->TopEdge     = global.ri.WindowTitle;\n         gad->Width       = global.width;\n         gad->Height      = global.height - global.ri.WindowTitle;\n         gad->Flags       = GADGHNONE;\n         gad->Activation  = 0;\n         gad->GadgetType  = BOOLGADGET;\n   \n         AddGadget(global.window, gad, 0);\n      }\n      cover_count = 0;\n   }\n   else /* one cover is enough - as long as we don't take it off too soon */\n      cover_count++;\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: IssueCommand\n * Synopsis:  rc = IssueCommand(cmd);\n * Purpose:   Execute a given command with the current console\n ***********************************************************************************/\n", "func_signal": "int IssueCommand(char *cmd)", "code": "{\n   int rc;\n   struct TagItem taglist[4];\n\n   rc = InitSession();\n   if (!rc)\n   {\n      if (Outfh)\n      {\n         taglist[0].ti_Tag  = SYS_UserShell;\n         taglist[0].ti_Data = 1;\n         taglist[1].ti_Tag  = SYS_Input;\n         taglist[1].ti_Data = (ULONG)Sesfh;\n         taglist[2].ti_Tag  = SYS_Output;\n         taglist[2].ti_Data = (ULONG)Outfh;\n         taglist[3].ti_Tag  = TAG_DONE;\n\n         rc = SystemTagList(cmd, taglist);\n      }\n      else\n      {\n         rc = Execute(cmd, 0L, Sesfh);\n      }\n   }\n   return(rc);\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: set_busy\n * Synopsis:  (void)set_busy();\n * Purpose:   Mark the window as busy so no input will come into it\n ***********************************************************************************/\n", "func_signal": "void set_busy(void)", "code": "{\n#ifdef WA_BusyPointer\n   if (IntuitionBase->LibNode.lib_Version >= 39)\n   {\n      struct TagItem taglist[3];\n\n      taglist[0].ti_Tag  = WA_BusyPointer;\n      taglist[0].ti_Data = TRUE;\n\n      taglist[1].ti_Tag  = WA_PointerDelay;\n      taglist[1].ti_Data = TRUE;\n\n      taglist[2].ti_Tag  = TAG_DONE;\n      taglist[2].ti_Data = TRUE;\n\n      /* Put up the busy pointer, with pointer-delay */\n      SetWindowPointer( global.window, taglist);\n   }\n   else\n#endif\n   {\n      if (busy_pointer == NULL)\n      {\n         busy_pointer = AllocMem(sizeof(busy_data), MEMF_CHIP);\n         if (busy_pointer)\n         {\n            memcpy(busy_pointer, busy_data, sizeof(busy_data));\n            SetPointer(global.window, busy_pointer,\n                 BUSY_HEIGHT, BUSY_WIDTH, BUSY_XOFFSET, BUSY_YOFFSET);\n         }\n      }\n   }\n   /* We need to create a single gadget that covers the entire screen so that */\n   /* They can not click on any of the gadgets.                               */\n   cover_window();\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: get_mem\n * Synopsis:  mem = get_mem(size);\n * Purpose:   Allocate zeroed memory for use.  If the memory can not be allocated,\n *            an error is indicated in the title bar and NULL is returned.\n ***********************************************************************************/\n", "func_signal": "void *get_mem(int size\n            )", "code": "{\n   void *rslt;\n\n   rslt = malloc(size);\n   if (!rslt)\n   {\n      sprintf(global.title, \"No Memory for %d bytes\\n\", size);\n      if (global.window)\n      {\n         SetWindowTitles(global.window, global.title, NULL);\n      }\n   }\n   else\n   {\n      memset(rslt, 0, size);\n   }\n   return(rslt);\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/*\n *  explicit invocation interface between do_command() and do_rexx\n *  for ARexx macros having ONE argument (i.e., for the \"rx1\" command)\n */\n", "func_signal": "void\ndo_rx1()", "code": "{\n    char macbuf[256];\n\n    strcpy(macbuf, av[1]);\n    strcat(macbuf, \" \");\n    strcat(macbuf, av[2]);\n    do_rexx(macbuf);\n}", "path": "src\\dme\\rexx.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: Alloc_Vec\n * Synopsis:  newvec = Alloc_Vec(size);\n * Purpose:   This code allocates a DOS vector\n * Note:      This storage is NOT automatically freed by the compiler library.\n ***********************************************************************************/\n", "func_signal": "static BPTR Alloc_Vec(int size)", "code": "{\n   long *new;\n\n   size += 4;\n   /* Based on the given size, allocate the right amount of memory */\n   new = (long *)AllocMem(size, MEMF_PUBLIC | MEMF_CLEAR);\n\n   if (new != NULL)\n   {\n      /* Remember to point one past the length longword */\n      *new++ = size;\n   }\n   else\n   {\n      request(1, TEXT_NOMEM, NULL, NULL);\n   }\n   return(MKBADDR(new));\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/*\n *  explicit invocation interface between do_command() and do_rexx\n *  for ARexx macros having TWO arguments (i.e., for the \"rx2\" command)\n */\n", "func_signal": "void\ndo_rx2()", "code": "{\n    char macbuf[256];\n\n    strcpy(macbuf, av[1]);\n    strcat(macbuf, \" \");\n    strcat(macbuf, av[2]);\n    strcat(macbuf, \" \");\n    strcat(macbuf, av[3]);\n    do_rexx(macbuf);\n}", "path": "src\\dme\\rexx.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: SkipAss\n * Synopsis:  p = SkipAss(ptr)\n * Purpose:   Skip whitespace in tooltype assignment\n ***********************************************************************************/\n", "func_signal": "char * SkipAss(const char *ptr)", "code": "{\n   while (*ptr && *ptr != '=')\n      ptr++;\n   if (*ptr == '=')\n   {\n      for (ptr++; *ptr == ' ' || *ptr == '\\t'; ptr++)\n         ;\n   }\n   return(ptr);\n}", "path": "src\\vmake\\VMake.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: set_idle\n * Synopsis:  (void)set_idle();\n * Purpose:   Remove the busy mark on the window\n ***********************************************************************************/\n", "func_signal": "void set_idle(void)", "code": "{\n\n   uncover_window();\n#ifdef WA_BusyPointer\n   if (IntuitionBase->LibNode.lib_Version >= 39)\n   {\n      struct TagItem taglist[1];\n      taglist[0].ti_Tag  = TAG_DONE;\n      taglist[0].ti_Data = TRUE;\n\n      /* Put up the busy pointer, with pointer-delay */\n      SetWindowPointer( global.window, taglist);\n   }\n   else\n#endif\n   {\n      /* Do the 1.3 stuff here */\n   }\n   if (busy_pointer)\n   {\n      ClearPointer(global.window);\n      FreeMem(busy_pointer, sizeof(busy_data));\n   }\n\n   busy_pointer = NULL;\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: setup_cli()\n * Synopsis:  (void)setup_cli();\n * Purpose:   This code sets up a fake CLI structure by copying the appropriate\n *            information from workbench.  It will prepare for that to be\n *            automatically be freed on program termination through freecli.\n ***********************************************************************************/\n", "func_signal": "int setup_cli()", "code": "{\n   struct CommandLineInterface *cli, *wbcli;\n   struct Process *wbproc;\n   struct PathEnt *pathent, *wbent;\n\n   SesProcess = (struct Process *)FindTask(0);\n\n   /* Allocate a CLI structure if we need one                        */\n   if (SesProcess->pr_CLI) return;\n\n   cli = get_mem(sizeof(struct CommandLineInterface));\n   if (cli == NULL) return(1);\n\n   atexit(freecli);\n\n   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n   /* Next we need to go through and copy the workbench path over to      */\n   /* Our process.  The only things we need to duplicate are:             */\n   /*                                                                     */\n   /* We need to copy over the BPTR link list for this one.               */\n   /*    pr_CLI->cli_CommandDir   Head of the path locklist               */\n   /*                                                                     */\n   /* These are buffers which we need to allocate space for and clone     */\n   /*    pr_CLI->cli_SetName      Name of current directory               */\n   /*    pr_CLI->cli_CommandName  Name of current command                 */\n   /*    pr_CLI->cli_Prompt       Current prompt (set by PROMPT)          */\n   /*    pr_CLI->cli_CommandFile  Name of EXECUTE command file            */\n   /*                                                                     */\n   /* These fields are just copied over verbatim                          */\n   /*    pr_CLI->cli_FailLevel    Fail level (set by FAILAT)              */\n   /*    pr_CLI->cli_Interactive  Boolean; True if prompts required       */\n   /*    pr_CLI->cli_Background   Boolean; True if CLI created by RUN     */\n   /*    pr_CLI->cli_DefaultStack Stack size to be obtained in long words */\n   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n   SesProcess->pr_CLI = MKBADDR(cli);\n\n   /* Now we need to find the workbench CLI */\n   if ( ( (wbproc = (struct Process *)FindTask(\"Workbench\")) == NULL) &&\n        ( (wbproc = (struct Process *)FindTask(\"Fastbench\")) == NULL) )\n   {\n      /* For some reason workbench and FastBench are not in the system */\n      /* We need to punt and not let them really do any work           */\n      return(2);\n   }\n   wbcli = BADDR(wbproc->pr_CLI);\n\n   /* Say what??  We have a workbench but it doesn't have a CLI???   */\n   if (wbcli == NULL) return(3);\n\n   /* Do all of the staight copies from the Workbench CLI */\n   cli->cli_FailLevel    = 20;\n   cli->cli_Interactive  = DOSFALSE;\n   cli->cli_Background   = DOSFALSE;\n   cli->cli_DefaultStack = 2048; /* Longwords */\n\n   /* Next we get all of the cloned vector buffers */\n   cli->cli_SetName      = Alloc_Vec( 80);  /* These numbers are truely magic  */\n   cli->cli_CommandName  = Alloc_Vec(104);  /* and CAN NOT be changed for true */\n   cli->cli_Prompt       = Alloc_Vec( 60);  /* compatibility with 1.3.         */\n   cli->cli_CommandFile  = Alloc_Vec( 40);  /* Don't even try to change them   */\n\n   /* Lastly we need to copy over all of the paths from workbench */\n   if (wbcli->cli_CommandDir)\n   {\n      /* Start out the process by copying over the first vector */\n      cli->cli_CommandDir = Alloc_Vec(8);\n      wbent   = BADDR(wbcli->cli_CommandDir);\n      pathent = BADDR(cli->cli_CommandDir);\n\n      /* Now loop through copying over the vector and then replacing everything */\n      /* in place.  This looks a little strange because we are actually counting */\n      /* on creating a structure with a pointer to the other linked list, but  */\n      while(wbent->nextent)\n      {\n         pathent->nextent = Alloc_Vec(8);\n         pathent->lock = DupLock(wbent->lock);\n         if (!pathent->lock)\n         {\n            pathent->nextent = 0;  /* Make sure we terminate the list here */\n            return(4);\n         }\n         wbent   = BADDR(wbent->nextent);\n         pathent = BADDR(pathent->nextent);\n      }\n      pathent->lock = DupLock(wbent->lock);\n      if (!pathent->lock) return(5);\n   }\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: freecli\n * Synopsis:  (void)freecli();\n * Purpose:   This code frees up any CLI allocated structures.\n * Note:      This routine is only called as an autoexit routine when setup_cli\n *            has done some work.  Otherwise we assume that no special work had to\n *            be done to make things happen.\n ***********************************************************************************/\n", "func_signal": "static void freecli()", "code": "{\n   struct CommandLineInterface *cli;\n   BPTR oldent;\n\n   cli = BADDR(SesProcess->pr_CLI);\n\n   if (!cli) return;\n\n   /* We only need to free the 4 vectors we created and all of the */\n   /* locks on the the path list.                                  */\n   Free_Vec(cli->cli_SetName);\n   Free_Vec(cli->cli_CommandName);\n   Free_Vec(cli->cli_Prompt);\n   Free_Vec(cli->cli_CommandFile);\n\n   while((oldent = cli->cli_CommandDir) != 0)\n   {\n      struct PathEnt *pathent;\n\n      /* First we need to remove us from the path list */\n      pathent = BADDR(oldent);\n      cli->cli_CommandDir = pathent->nextent;\n      UnLock(pathent->lock);     /* Free the lock at this entry        */\n      Free_Vec(oldent);          /* Free the storage for the path node */\n   }\n   SesProcess->pr_CLI = 0;\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/*\n *  returns number of extension words added\n */\n", "func_signal": "long\nGenerateEA(short numWords, MachCtx *mc, OpCod *oc, EffAddr *ea, uword *ext)", "code": "{\n    int numBytes = numWords * 2;\n\n    /*\n     *\trelocation\n     */\n\n    {\n\tLabel *lab;\n\n\t/*\n\t *  fixup for local labels, base displacement\n\t */\n\n\tif ((lab = ea->Label2) && lab->l_Type == LT_LOC) {\n\t    ea->Offset2 += lab->l_Offset;\n\n\t    switch(ea->Mode1) {\n\t    case AB_OFFIDXPC:\n\t    case AB_OFFPC:\n\t    case AB_BBRANCH:\n\t    case AB_WBRANCH:\n\t\tif (lab->Sect == CurSection) {\n\t\t    ea->Offset2 -= (mc->m_Addr + numWords*2);\n\t\t    ea->Label2 = NULL;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t/*\n\t *  fixup for local labels, offset or index value (but not outer\n\t *  displacement since it is not PC relative)\n\t */\n\n\tif ((lab = ea->Label1) && lab->l_Type == LT_LOC) {\n\t    ea->Offset1 += lab->l_Offset;\n\n\t    switch(ea->Mode1) {\n\t    case AB_OFFIDXPC:\n\t\tif ((ea->ExtWord & EXTF_ODMASK) == EXTF_ODWORD || (ea->ExtWord & EXTF_ODMASK) == EXTF_ODLONG) {\n\t\t    break;\n\t\t}\n\t    case AB_OFFPC:\n\t    case AB_BBRANCH:\n\t    case AB_WBRANCH:\n\t\tif (lab->Sect == CurSection) {\n\t\t    ea->Offset1 -= (mc->m_Addr + numWords*2);\n\t\t    ea->Label1 = NULL;\n\t\t}\n\t    }\n\t}\n\n    }\n\n    /*\n     *\tmode and extension words\n     */\n\n    switch(ea->Mode1) {\n    case 0:\n    case AB_DN:\n    case AB_AN:\n    case AB_INDAN:\n    case AB_INDPP:\n    case AB_MMIND:\n\tbreak;\n    case AB_OFFAN:\n\tif (ea->Label1)\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 2, RELOC_DATAREL);\n\t++numWords;\n\text[0] = ToMsbOrderShort(ea->Offset1);\n\tif (ea->Offset1 < -32768 || ea->Offset1 > 32767)\n\t    cerror(EERROR_WORD_OFFSET, ea->Offset1);\n\tbreak;\n    case AB_OFFIDX:\n    case AB_OFFIDXPC:\n\tif (ea->ExtWord & EXTF_FULL) {\n\t    int i = 1;\n\n\t    switch(ea->ExtWord & EXTF_BDMASK) {\n\t    case EXTF_BDWORD:\n\t\tif (ea->Label2) {\n\t\t    long reloc_type = (ea->Mode1 == AB_OFFIDXPC) ? RELOC_PCREL : ((ea->ISize & ISF_BDDREL) ? RELOC_DATAREL : 0);\n\n\t\t    HandleInstReloc(mc->Sect, ea->Label2, mc->m_Addr + numBytes + 2, 2, reloc_type);\n\t\t    /*\n\t\t     *\taddress will be relocated relative to label instead\n\t\t     *\tof to extension word, must compensate\n\t\t     */\n\t\t    ea->Offset2 += 2;\n\t\t}\n\t\text[i++] = ToMsbOrderShort(ea->Offset2);\n\t\tbreak;\n\t    case EXTF_BDLONG:\n\t\tif (ea->Label2) {\n\t\t    long reloc_type = (ea->Mode1 == AB_OFFIDXPC) ? RELOC_PCREL : ((ea->ISize & ISF_BDDREL) ? RELOC_DATAREL : 0);\n\n\t\t    HandleInstReloc(mc->Sect, ea->Label2, mc->m_Addr + numBytes + 2, 4, reloc_type);\n\t\t    ea->Offset2 += 2;\n\t\t}\n\t\text[i++] = ToMsbOrderShort(ea->Offset2 >> 16);\n\t\text[i++] = ToMsbOrderShort(ea->Offset2);\n\t\tbreak;\n\t    }\n\t    switch(ea->ExtWord & EXTF_ODMASK) {\n\t    case EXTF_ODWORD:\n\t\tif (ea->Label1) {\n\t\t    long reloc_type = (ea->ISize & ISF_ODDREL) ? RELOC_DATAREL : 0;\n\t\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes + i * 2, 2, reloc_type);\n\t\t}\n\t\text[i++] = ToMsbOrderShort(ea->Offset1);\n\t\tbreak;\n\t    case EXTF_ODLONG:\n\t\tif (ea->Label1) {\n\t\t    long reloc_type = (ea->ISize & ISF_ODDREL) ? RELOC_DATAREL : 0;\n\t\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes + i * 2, 4, reloc_type);\n\t\t}\n\t\text[i++] = ToMsbOrderShort(ea->Offset1 >> 16);\n\t\text[i++] = ToMsbOrderShort(ea->Offset1);\n\t\tbreak;\n\t    }\n\t    numWords += i;\n\t    ext[0] = ToMsbOrderShort(ea->ExtWord);\n\t} else {\n\t    if (ea->Label1)\n\t\tHandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes + 1, 1, 0);\n\t    if (ea->Offset1 < -128 || ea->Offset1 > 127)\n\t\tcerror(EERROR_BYTE_OFFSET, ea->Offset1);\n\t    ext[0] = ToMsbOrderShort(ea->ExtWord | (ea->Offset1 & 0xFF));\n\t    ++numWords;\n\t}\n\tbreak;\n    case AB_ABSW:\n\tif (ea->Label1)\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 2, 0);\n\t++numWords;\n\text[0] = ToMsbOrderShort(ea->Offset1);\n\tbreak;\n    case AB_ABSL:\n\tif (ea->Label1)\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 4, 0);\n\tnumWords += 2;\n\text[0] = ToMsbOrderShort(ea->Offset1 >> 16);\n\text[1] = ToMsbOrderShort(ea->Offset1);\n\tbreak;\n    case AB_OFFPC:\n\tif (ea->Label1)\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 2, RELOC_PCREL);\n\t++numWords;\n\text[0] = ToMsbOrderShort(ea->Offset1);\n\tif (ea->Offset1 < -32768 || ea->Offset1 > 32767)\n\t    cerror(EERROR_WORD_OFFSET, ea->Offset1);\n\tbreak;\n    case AB_IMM:\n\tswitch(oc->Special) {\n\tcase IMM07:\n\t    if (ea->Label1)\n\t\tcerror(EERROR_BAD_RELOC);\n\t    Code[0] |= ToMsbOrderShort((ea->Offset1 & 7) << 9);\n\t    if (ea->Offset1 < 0 || ea->Offset1 > 7)\n\t\tcerror(EERROR_7_OFFSET, ea->Offset1);\n\t    break;\n\tcase IMM18:\n\t    if (ea->Label1)\n\t\tcerror(EERROR_BAD_RELOC);\n\t    Code[0] |= ToMsbOrderShort((ea->Offset1 & 7) << 9);\n\t    if (ea->Offset1 < 1 || ea->Offset1 > 8)\n\t\tcerror(EERROR_8_OFFSET, ea->Offset1);\n\t    break;\n\tcase IMM0F:\n\t    if (ea->Label1)\n\t\tHandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + 1, 1, 0);\n\t    Code[0] |= ToMsbOrderShort(ea->Offset1 & 15);\n\t    if (ea->Offset1 < 0 || ea->Offset1 > 15)\n\t\tcerror(EERROR_15_OFFSET, ea->Offset1);\n\t    break;\n\tcase IMM256:\n\t    if (ea->Label1)\n\t\tHandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + 1, 1, 0);\n\t    Code[0] |= ToMsbOrderShort(ea->Offset1 & 0xFF);\n\t    if (ea->Offset1 < -128 || ea->Offset1 > 127)\n\t\tcerror(EERROR_BYTE_OFFSET, ea->Offset1);\n\t    break;\n\tcase IMMB:\n\t    if (ea->Label1)\n\t\tHandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes + 1, 1, 0);\n\t    ext[0] = ToMsbOrderShort(ea->Offset1 & 0xFF);\n\t    ++numWords;\n\t    break;\n\tdefault:\n\t    if (mc->OpSize == 0) {\n\t\tif (oc->Sizes & S_B)\n\t\t    mc->OpSize = 1;\n\t\tif (oc->Sizes & S_W)\n\t\t    mc->OpSize = 2;\n\t\tif (oc->Sizes & S_L)\n\t\t    mc->OpSize = 4;\n\t    }\n\n\t    switch(mc->OpSize) {\n\t    case 1:\n\t\tif (ea->Label1)\n\t\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes + 1, 1, 0);\n\t\text[0] = ToMsbOrderShort(ea->Offset1 & 0xFF);\n\t\t++numWords;\n\t\tbreak;\n\t    case 2:\n\t\tif (ea->Label1)\n\t\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 2, RELOC_PCREL);\n\t\text[0] = ToMsbOrderShort(ea->Offset1);\n\t\t++numWords;\n\t\tbreak;\n\t    case 4:\n\t\tif (ea->Label1)\n\t\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + numBytes, 4, 0);\n\t\text[0] = ToMsbOrderShort(ea->Offset1 >> 16);\n\t\text[1] = ToMsbOrderShort(ea->Offset1);\n\t\tnumWords += 2;\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n    case AB_REGS:\n\tCode[1] = ToMsbOrderShort(RegMaskForInst(mc->Oper2.Mode1, ea->ExtWord));\n\tbreak;\n    case AB_BBRANCH:\n\t/*\n\t *  since byte branches are relative to the base of the\n\t *  instruction word, NOT the address of the offset, we\n\t *  have to compensate -1\n\t */\n\n\tif (ea->Label1) {\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + 1, 1, 0);\n\t    Code[0] |= ToMsbOrderShort((ea->Offset1 - 1) & 0xFF);\n\t} else {\n\t    Code[0] |= ToMsbOrderShort((ea->Offset1) & 0xFF);\n\t}\n\n\tif (ea->Label1 == NULL && ea->Offset1 == 0)\n\t    cerror(EERROR_SHORT_BRANCH);\n\tif (ea->Offset1 < -128 || ea->Offset1 > 127)\n\t    cerror(EERROR, \"byte branch offset too large\");\n\tbreak;\n    case AB_WBRANCH:\n\tif (ea->Label1)\n\t    HandleInstReloc(mc->Sect, ea->Label1, mc->m_Addr + 2, 2, RELOC_PCREL);\n\n\t++numWords;\n\text[0] = ToMsbOrderShort(ea->Offset1);\n\tif (ea->Offset1 < -32768 || ea->Offset1 > 32767)\n\t    cerror(EERROR_WORD_OFFSET, ea->Offset1);\n\tbreak;\n    case AB_CCR:\n    case AB_SR:\n    case AB_USP:\n\tbreak;\n    default:\n\tcerror(ESOFT_BAD_SRCAB, ea->Mode1);\n\tbreak;\n    }\n    return(numWords);\n}", "path": "src\\das\\passg.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/*\n *  cmd[-1] is valid space and, in fact, must be long word aligned!\n */\n", "func_signal": "long\nExecute_Command(char *cmd, short ignore)", "code": "{\n    register char *ptr;\n\n    for (ptr = cmd; *ptr && *ptr != ' ' && *ptr != '\\t' && *ptr != '\\n'; ++ptr)\n\t;\n\n\n    /*\n     *\tInternal MakeDir because AmigaDOS 2.04's MakeDir is unreliable\n     *\twith RunCommand() (it can crash)\n     *\n     *\tInternal CD because we special case it\n     */\n\n#ifdef AMIGA\n    if (ptr - cmd == 7 && strnicmp(cmd, \"makedir\", 7) == 0) {\n\tlong lock;\n\tshort err = 0;\n\n\twhile (*ptr == ' ' || *ptr == '\\t')\n\t    ++ptr;\n\tif (lock = CreateDir(ptr))\n\t    UnLock(lock);\n\telse {\n\t    printf(\"Unable to makedir %s\\n\", ptr);\n\t    err = 20;\n\t}\n\treturn((ignore) ? 0 : err);\n    } else\n    if (ptr - cmd == 6 && strnicmp(cmd, \"fwrite\", 6) == 0) {\n\tchar *t;\n\tBPTR fh;\n\tshort err = 0;\n\n\twhile (*ptr == ' ' || *ptr == '\\t')\n\t    ++ptr;\n\tfor (t = ptr; *t && *t != ' ' && *t != '\\t'; t++);\n\tif (*t) *t++ = '\\0';\n\tif (fh = Open(ptr, MODE_NEWFILE)) {\n\t    int len;\n\t    len = strlen(t);\n\t    for(ptr = t; *ptr; ptr++) if (*ptr == ' ') *ptr = '\\n';\n\t    t[len] = '\\n';\n\t    Write(fh, t, len+1);\n\t    t[len] = '\\0';\n\t    Close(fh);\n\t    err = 0;\n\t}\n\telse\n\t{\n\t    printf(\"Unable to write %s\\n\", ptr);\n\t    err = 20;\n\t}\n       return((ignore) ? 0 : err);\n    } else\n#endif\n    if (ptr - cmd == 2 && strnicmp(cmd, \"cd\", 2) == 0) {\n\tlong lock;\n\tshort err = 0;\n\n\twhile (*ptr == ' ' || *ptr == '\\t')\n\t    ++ptr;\n\t{\n\t    short len = strlen(ptr);\t/*  XXX HACK HACK */\n\t    if (len && ptr[len-1] == '\\n')\n\t\tptr[len-1] = 0;\n\t}\n#ifdef AMIGA\n\tif (*ptr == 0)\n\t    lock = DupLock(SaveLock);\n\telse\n\t    lock = Lock(ptr, SHARED_LOCK);\n\tif (lock)\n\t    UnLock(CurrentDir(lock));\n\telse {\n\t    printf(\"Unable to cd %s\\n\", ptr);\n\t    err = 20;\n\t}\n#else\n\tif (*ptr == 0)\n\t    err = chdir(RootPath);\n\telse\n\t    err = chdir(ptr);\n\tif (err != 0) {\n\t    err = 20;\n\t    printf(\"Unable to cd %s\\n\", ptr);\n\t}\n#endif\n\treturn((ignore) ? 0 : err);\n    }\n\n    /*\n     * run command cmd\n     *\n     */\n\n#ifdef AMIGA\n    {\n\tshort i;\n\tshort ci;\n\tshort c;\n\tshort err = 0;\n\tshort useSystem = 0;\n\tProcess *proc = FindTask(NULL);\n\tchar *cmdArgs;\n\n\tfor (i = 0; cmd[i] && cmd[i] != ' ' && cmd[i] != 9 && cmd[i] != 10 && cmd[i] != 13; ++i)\n\t    ;\n\tif (strpbrk(cmd + i, \"<>|`\"))\n\t    useSystem = 1;\n\telse\n\t    useSystem = 0;\n\n\tif (c = cmd[ci = i])\n\t    ++ci;\n\tcmd[i] = 0;\n\n\tcmdArgs = malloc(strlen(cmd + ci) + 3);\n\tsprintf(cmdArgs, \"%s\\n\\r\", cmd + ci);\n\tfflush(stdout);\n\n\t/*\n\t *  NOTE: RunCommand() is unreliable if no pr_CLI exists,\n\t *  MUST use system13() in that case.\n\t */\n\n#if INCLUDE_VERSION >= 36\n\tif (SysBase->lib_Version >= 36 && proc->pr_CLI) {\n\t    long seg;\n\t    long stack;\n\t    long lock = 0;\n\t    CLI *cli = (CLI *)BADDR(proc->pr_CLI);\n\t    static char OldCmd[128];\n\t    char dt[4];\n\n\t    if (cli) {\n\t\tGetProgramName(OldCmd, sizeof(OldCmd));\n\t\tSetProgramName(cmd);\n\t\tstack = cli->cli_DefaultStack * 4;\n\t    } else {\n\t\tstack = 8192;\n\t    }\n\n\t    /*\n\t     *\tnote: Running2_04() means V37 or greater\n\t     */\n\n\t    if (useSystem || (Running2_04() && GetVar(cmd, dt, 2, LV_ALIAS | GVF_LOCAL_ONLY) >= 0))\n\t\tgoto dosys;\n\n\t    if ((seg = FindSegment(cmd, 0L, 0)) || (seg = FindSegment(cmd, 0L, 1))) {\n\t\tdbprintf((\"A cmd = '%s' stack = %d\\n\", cmdArgs, stack));\n\t\terr = RunCommand(((long *)seg)[2], stack, cmdArgs, strlen(cmdArgs) - 1);\n\t    } else if ((lock = _SearchPath(cmd)) && (seg = LoadSegLock(lock, \"\"))) {\n\t\tdbprintf((\"B\\n\"));\n\t\terr = RunCommand(seg, stack, cmdArgs, strlen(cmdArgs) - 1);\n\t\tUnLoadSeg(seg);\n\t    } else if ((lock = Lock(\"dcc:bin\", SHARED_LOCK)) && (seg = LoadSegLock(lock, cmd))) {\n\t\tdbprintf((\"C %08x\\n\", seg));\n\t\tdbprintf((\"CMD= %s\", cmdArgs));\n\t\terr = RunCommand(seg, 8192, cmdArgs, strlen(cmdArgs) - 1);\n\t\tUnLoadSeg(seg);\n\t    } else {\ndosys:\n\t\tdbprintf((\"D\\n\"));\n\t\tcmd[i] = c;\n\t\t/*err = system13(cmd);*/\n\t\terr = System(cmd, NULL);\n\t    }\n\t    if (cli)\n\t\tSetProgramName(OldCmd);\n\t    if (lock)\n\t\tUnLock(lock);\n\t} else\n#endif\n\t{\n\t    dbprintf((\"E\\n\"));\n\t    cmd[i] = c;\n\t    err = system13(cmd);\n\t}\n\tfree(cmdArgs);\n\tif (err)\n\t    printf(\"Exit code %d %s\\n\", err, (ignore) ? \"(Ignored)\":\"\");\n\tif (ignore)\n\t    return(0);\n\treturn(err);\n    }\n#else\n    {\n\tint err;\n\n\tif ((err = vfork()) == 0) {\n\t    execlp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, 0);\n\t    exit(30);\n\t} else {\n\t    union wait uwait;\n\n\t    while (wait(&uwait) != err || WIFEXITED(uwait) == 0)\n\t\t;\n\t    err = uwait.w_retcode;\n\t}\n\tif (err)\n\t    printf(\"Exit code %d %s\\n\", err, (ignore) ? \"(Ignored)\":\"\");\n\tif (ignore)\n\t    return(0);\n\treturn(err);\n    }\n#endif\n}", "path": "src\\dmake\\save\\run.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: Free_Vec\n * Synopsis:  (void)FreeVec(vec);\n * Purpose:   This code returns a vector to storage\n ***********************************************************************************/\n", "func_signal": "static void Free_Vec(BPTR orig)", "code": "{\n   long *in;\n\n   in = (long *)BADDR(orig);\n   in--;  /* Back up to the size information for the original allocation */\n\n   /* Based on the given size, allocate the right amount of memory */\n   FreeMem(in, *in);\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: InitSession\n * Synopsis:  rc = InitSession()FreeVec(vec);\n * Purpose:   This code returns a vector to storage\n ***********************************************************************************/\n", "func_signal": "int InitSession()", "code": "{\n   struct FileHandle *handle;\n   struct CommandLineInterface *cli;\n\n   if (!Sesfh)\n   {\nchar cbuf[256];\n      SesProcess = (struct Process *)FindTask(0);\n      cli = BADDR(SesProcess->pr_CLI);\n\n      /* Save the current console and background status information */\n      pr_ConsoleTask = SesProcess->pr_ConsoleTask;\n\n      cli_Interactive    = cli->cli_Interactive;\n      cli_Background     = cli->cli_Background;\n\n      /* Open up our console to do the work */\n      if (!build_command(cbuf, 255, global.text[CONFIG_CONSOLE], 0))\n         /* JAT's usual inverted logic... */\n         Sesfh = Open(cbuf, MODE_OLDFILE);\n      else\n         /* error message (since we don't knowwhat build_command() produced */\n         strcpy(cbuf, global.text[CONFIG_CONSOLE]);\n      if (Sesfh == NULL) \n      {\n         Sesfh = Open(\"Con:0/0/320/100/Vmake_Default/Auto\", MODE_OLDFILE);\n         if (Sesfh == NULL)\n            /* nowhere to put an error message, give up */\n            return(1);\n         else\n         {\n            char buf[256];\n            \n            sprintf(buf, \"Bad Console \\\"%s\\\" from file: %s\\n\", \n                    cbuf, Sym_Lookup(SYM_CONFIG));\n            PostLog(buf);\n         }\n      }\n      handle = (struct FileHandle *)(Sesfh << 2);\n      SesProcess->pr_CIS = SesProcess->pr_COS = Sesfh;\n\n      SesProcess->pr_ConsoleTask = (APTR)handle->fh_Type;\n\n      if (DOSBase->dl_lib.lib_Version >= 36)\n         Outfh = Open(\"*\", MODE_NEWFILE);\n\n      cli->cli_Interactive    = DOSTRUE;\n      cli->cli_Background     = DOSFALSE;\n      atexit(TermSession);\n   }\n   return(0);\n}", "path": "src\\vmake\\process.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: uncover_window\n * Synopsis:  un(void)cover_window();\n * Purpose:   remove bool gadget from window - reactivate other gadgets\n ***********************************************************************************/\n", "func_signal": "void uncover_window(void)", "code": "{\n   if (cover_count == 0) /* is this the last request to remove it? */\n   {\n      if (cover)\n      {\n         RemoveGadget(global.window, cover);\n         free_mem(cover, sizeof(struct Gadget));\n         cover = NULL;\n      }\n   }\n   else /* don't take it off till the fat lady sings */\n      cover_count--;\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/***********************************************************************************\n * Procedure: savestr\n * Synopsis:  copystr = savestr(str);\n * Purpose:   Save a copy of a string for later reference\n ***********************************************************************************/\n", "func_signal": "char *savestr(char *str\n             )", "code": "{\n   char *p;\n\n   if (!*str) return(\"\");\n   p = get_mem(strlen(str)+1);\n   strcpy(p, str);\n   return(p);\n}", "path": "master\\Examples\\Visual\\VCommon\\subs.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/*\n *  init_arexx() sets up an auxillary ARexx port which is unique.  We\n *  pass this port when generating outgoing ARexx commands so ARexx can\n *  find this particular instance of DME again.\n */\n", "func_signal": "void\ninit_arexx()", "code": "{\n    static char AuxName[15];\n    if (RexxSysBase) {\n\tsprintf(AuxName, \"DME.%08lx\", FindTask(NULL));\n\tCreateDiceRexxPort(&AuxRexxPort, AuxName);\n    }\n}", "path": "src\\dme\\rexx.c", "repo_name": "noname22/NeoDICE", "stars": 15, "license": "other", "language": "c", "size": 3900}
{"docstring": "/**\nGet One Packet\n**/\n", "func_signal": "JNIEXPORT jobject JNICALL\nJava_jpcap_JpcapCaptor_getPacket(JNIEnv *env,jobject obj)", "code": "{\n  struct pcap_pkthdr *header;\n  jobject packet;\n  int id=getJpcapID(env,obj);\n  u_char *data;\n  int res;\n\n  res=pcap_next_ex(pcds[id],&header,(const u_char **)&data);\n\n  switch(res){\n\t  case 0: //timeout\n\t\t  return NULL;\n\t  case -1: //error\n\t\t  return NULL;\n\t  case -2:\n\t\t  return GetStaticObjectField(Packet,\"Ljpcap/packet/Packet;\",\"EOF\");\n  }\n  \n  jni_envs[id]=env;\n  if(data==NULL) return NULL;\n  get_packet(*header,data,&packet,id);\n  return packet;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nGet Interface List\n**/\n", "func_signal": "JNIEXPORT jobjectArray JNICALL Java_jpcap_JpcapCaptor_getDeviceList\n  (JNIEnv *env, jclass cl)", "code": "{\n\tpcap_if_t *alldevs;\n\tpcap_if_t *d;\n\tpcap_addr_t *a;\n\tpcap_t *tmp_pcap;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tint i=0,j=0,k=0;\n\tjobjectArray devices=NULL;\n\tjobjectArray addresses=NULL;\n\tjobject device=NULL;\n\tjobject address=NULL;\n\tint linktype;\n\tjstring lname,ldesc;\n#ifdef WIN32\n    u_long size=0;\n\tPIP_INTERFACE_INFO pInfo = NULL;\n\tMIB_IFROW MibIfRow;\n\tchar **devnames;\n\tchar *p1,*p2,*p3;\n#else\n#ifdef SIOCGIFHWADDR // Linux\n    int sd;\n    struct ifreq ifr;\n\tu_char buf[6];\n#else //FreeBSD\n    struct ifaddrs *ifa, *ifa0;\n    struct sockaddr_dl* dl;\n\n    getifaddrs(&ifa0);\n#endif\n#endif\n\n\tInterface=FindClass(\"jpcap/NetworkInterface\");\n\tdeviceConstMID=(*env)->GetMethodID(env,Interface,\"<init>\",\"(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;[B[Ljpcap/NetworkInterfaceAddress;)V\");\n\tIAddress=FindClass(\"jpcap/NetworkInterfaceAddress\");\n\taddressConstMID=(*env)->GetMethodID(env,IAddress,\"<init>\",\"([B[B[B[B)V\");\n\n\t(*env)->ExceptionDescribe(env);\n\n\t/* Retrieve the device list */\n    if (pcap_findalldevs(&alldevs, errbuf) == -1)\n    {\n        fprintf(stderr,\"Error in pcap_findalldevs: %s\\n\", errbuf);\n        return NULL;\n    }\n\n\t//count # of devices\n\tfor(i=0,d=alldevs;d;d=d->next,i++);\n\n\t//create array\n\tdevices=(*env)->NewObjectArray(env,(jsize)i,Interface,NULL);\n\n#ifdef WIN32\n\t//obtain necessary size\n\tGetInterfaceInfo(NULL, &size);\n\t//allocate memory\n\tpInfo = (PIP_INTERFACE_INFO) malloc (size);\n\tif(GetInterfaceInfo(pInfo, &size)!=NO_ERROR){\n\t\tThrow(IOException,\"GetInterfaceInfo failed.\");\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Set Interface data */\n    for(i=0,d=alldevs;d;d=d->next)\n    {\n\t\tjbyteArray mac=(*env)->NewByteArray(env,6);\n\t\t//set mac\n#ifdef WIN32\n\t\t// compare the device names obtained from Pcap and from IP Helper\n\t\t// in order to identify MAC address\n\t\t// since device name differs in 9x and NT/XP, compare name\n\t\t// from the end (not sure if this works in every case. I hope it does..)\n\t\tp1=d->name;\n\t\twhile(*p1!=0) p1++;  //find the end\n\n\t\t//convert wchar to char\n\t\tdevnames=(char **)malloc(sizeof(char *)*pInfo->NumAdapters);\n\t\tfor(j=0;j<pInfo->NumAdapters;j++){\n\t\t\tsize=WideCharToMultiByte(0,0,pInfo->Adapter[j].Name,-1,NULL,0,NULL,NULL);\n\t\t\tdevnames[j]=(char *)malloc(size);\n\t\t\tWideCharToMultiByte(0,0,pInfo->Adapter[j].Name,-1,devnames[j],size,NULL,NULL);\n\t\t\t//printf(\"%s\\n\",devnames[j]);\n\t\t}\n\n\t\tfor(j=0;j<pInfo->NumAdapters;j++){\n\t\t\tp2=p1;\n\t\t\tp3=devnames[j];\n\t\t\twhile(*p3!=0) p3++; //find the end\n\t\t\tk=0;\n\t\t\t//printf(\"%s,%s:%d\\n\",d->name,devnames[j],j);\n\t\t\twhile(*p2==*p3){\n\t\t\t\tp2--; p3--; k++;\n\t\t\t\t//printf(\"%c,%c,%d\\n\",*p2,*p3,k);\n\t\t\t}\n\t\t\tif(k<30) continue;\n\n\t\t\t//found! set MAC address\n\t\t\tMibIfRow.dwIndex=pInfo->Adapter[j].Index;\n\t\t\tGetIfEntry(&MibIfRow);\n\t\t\t(*env)->SetByteArrayRegion(env,mac,0,MibIfRow.dwPhysAddrLen,MibIfRow.bPhysAddr);\n\t\t}\n\n#else\n#ifdef SIOCGIFHWADDR  //Linux\n    /* make socket */\n    sd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sd < 0) {\n\t\tThrow(IOException,\"cannot open socket.\");\n        return NULL; // error: can't create socket.\n    }\n\n    /* set interface name (lo, eth0, eth1,..) */\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy(ifr.ifr_ifrn.ifrn_name,d->name, IFNAMSIZ);\n\n    /* get a Get Interface Hardware Address */\n    ioctl(sd, SIOCGIFHWADDR, &ifr);\n\n    close(sd);\n\n\t(*env)->SetByteArrayRegion(env,mac,0,6,ifr.ifr_ifru.ifru_hwaddr.sa_data);\n#else //FreeBSD\n    for(ifa=ifa0;ifa;ifa=ifa->ifa_next){\n        dl=(struct sockaddr_dl*)ifa->ifa_addr;\n        if(dl->sdl_nlen>0 && strncmp(d->name,dl->sdl_data,dl->sdl_nlen)==0){\n            (*env)->SetByteArrayRegion(env,mac,0,6,LLADDR(dl));\n        }\n    }\n#endif\n#endif\n\n\t\t//count # of addresses\n\t\tfor(j=0,a=d->addresses;a;a=a->next)\n\t\t\tif(getAddressByteArray(env,a->addr)) j++;\n\n\t\t//create array of addresses\n\t\taddresses=(*env)->NewObjectArray(env,(jsize)j,IAddress,NULL);\n\n\t\t//set address data\n\t\tfor(j=0,a=d->addresses;a;a=a->next)\n\t\t{\n\t\t\tjbyteArray addr=getAddressByteArray(env,a->addr);\n\t\t\tif(addr){\n\t\t\t\taddress=(*env)->NewObject(env,IAddress,addressConstMID,\n\t\t\t\t\taddr,getAddressByteArray(env,a->netmask),\n\t\t\t\t\tgetAddressByteArray(env,a->broadaddr),getAddressByteArray(env,a->dstaddr));\n\t\t\t\t(*env)->SetObjectArrayElement(env,addresses,j++,address);\n\t\t\t}\n\t\t}\n\n\t\t//get datalink name\n\t\ttmp_pcap=pcap_open_live(d->name,0,0,1000,errbuf);\n\t\tif(tmp_pcap!=NULL){\n\t\t\tlinktype=pcap_datalink(tmp_pcap);\n\t\t\tlname=NewString(pcap_datalink_val_to_name(linktype));\n\t\t\tldesc=NewString(pcap_datalink_val_to_description(linktype));\n\t\t\tpcap_close(tmp_pcap);\n\t\t}else{\n\t\t\tlname=NewString(\"Unknown\");\n\t\t\tldesc=NewString(\"Unknown\");\n\t\t}\n\n\t\tdevice=(*env)->NewObject(env,Interface,deviceConstMID,NewString(d->name),\n\t\t\tNewString(d->description),(d->flags&PCAP_IF_LOOPBACK?JNI_TRUE:JNI_FALSE),lname,ldesc,mac,addresses);\n\t\t(*env)->SetObjectArrayElement(env,devices,i++,device);\n\n\t\tDeleteLocalRef(device);\n\t\tDeleteLocalRef(mac);\n    }\n    \n    /* We don't need any more the device list. Free it */\n    pcap_freealldevs(alldevs);\n\n\t(*env)->ExceptionDescribe(env);\n\n#ifndef WIN32\n#ifdef SIOCGIFHWADDR\n#else\n    freeifaddrs(ifa0);\n#endif\n#endif\n\n\treturn devices;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/** analyze tcp header **/\n", "func_signal": "u_short analyze_tcp(JNIEnv *env,jobject packet,u_char *data)", "code": "{\n  struct tcphdr *tcp_pkt=(struct tcphdr *)data;\n  u_short hdrlen;\n\n#ifdef DEBUG\n  puts(\"analze tcp\");\n#endif\n\n  // updated by Damien Daspit 5/7/01\n  (*env)->CallVoidMethod(env,packet,setTCPValueMID,\n\t\t\t     (jint)ntohs(tcp_pkt->th_sport),\n\t\t\t     (jint)ntohs(tcp_pkt->th_dport),\n\t\t\t     (jlong)ntohl(tcp_pkt->th_seq),\n\t\t\t     (jlong)ntohl(tcp_pkt->th_ack),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_URG)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_ACK)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_PUSH)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_RST)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_SYN)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_FIN)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_RSV1)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((tcp_pkt->th_flags&TH_RSV2)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t     (jint)ntohs(tcp_pkt->th_win),\n\t\t\t     (jshort)ntohs(tcp_pkt->th_urp));\n  // *******************************\n\n  hdrlen=tcp_pkt->th_off*4;\n\n  /**\n  Handle options\n  **/\n  if(hdrlen>TCPHDRLEN){\n    jbyteArray dataArray=(*env)->NewByteArray(env,hdrlen-TCPHDRLEN);\n    (*env)->SetByteArrayRegion(env,dataArray,0,hdrlen-TCPHDRLEN,data+TCPHDRLEN);\n    (*env)->CallVoidMethod(env,packet,setTCPOptionMID,dataArray);\n    DeleteLocalRef(dataArray);\n  }\n\n  /*if(caplen>hdrlen){\n    jbyteArray dataArray=(*env)->NewByteArray(env,caplen-hdrlen);\n    (*env)->SetByteArrayRegion(env,dataArray,0,\n\t\t\t\t   caplen-hdrlen,data+hdrlen);\n    (*env)->CallVoidMethod(env,packet,setPacketDataMID,dataArray);\n    DeleteLocalRef(dataArray);\n  }else{\n    (*env)->CallVoidMethod(env,packet,setPacketDataMID,\n      (*env)->NewByteArray(env,0));\n  }*/\n  return hdrlen;\n}", "path": "src\\c\\packet_tcp.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nSet Filter\n**/\n", "func_signal": "JNIEXPORT void JNICALL\nJava_jpcap_JpcapCaptor_setFilter(JNIEnv *env,jobject obj,jstring condition,\n\t\t\t   jboolean opt)", "code": "{\n  char *cdt=(char *)GetStringChars(condition);\n  struct bpf_program program;\n  int id=getJpcapID(env,obj);\n  char *err=NULL;\n\n  if(pcap_compile(pcds[id],&program,cdt,(opt==JNI_TRUE?-1:0),netmasks[id])!=0){\n    err = pcap_geterr(pcds[id]);\n    if (err == NULL)\n      err = \"pcap_compile failed\";\n  } else if(pcap_setfilter(pcds[id],&program)!=0){\n    err = pcap_geterr(pcds[id]);\n    if (err == NULL)\n      err = \"pcap_setfilter failed\";\n  }\n\n  ReleaseStringChars(condition,cdt);\n\n\n  if (err != NULL) {\n    char buf[2048];\n#ifdef WIN32\n\tstrcpy_s(buf, 2048,\"Error occurred while compiling or setting filter: \");\n    strncat_s(buf, 2048, err, _TRUNCATE);\n#else\n\tstrcpy(buf, \"Error occurred while compiling or setting filter: \");\n    strncat(buf, err, 2047-strlen(buf));\n#endif\n\tbuf[2047] = 0;\n    Throw(IOException, buf);\n  }\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nSend packet via pcap\n**/\n", "func_signal": "JNIEXPORT void JNICALL\nJava_jpcap_JpcapSender_nativeSendPacket(JNIEnv *env,jobject obj,jobject packet)", "code": "{\n  char buf[MAX_PACKET_SIZE];\n  int length;\n  int id=getJpcapSenderID(env,obj);\n\n  if(pcds[id]==NULL){\n\tThrow(IOException,\"Another JpcapSender instance is being used.\");\n\treturn;\n  }\n\n#ifdef DEBUG\n  puts(\"set packet.\");\n#endif\n  length=set_packet(env,packet,buf,-1);\n  if(length<60){ //include Ethernet trailer\n\t  memset(buf+length,0,60-length+1);\n\t  length=60;\n  }\n\n#ifdef DEBUG\n  puts(\"send packet.\");\n#endif\n  if(pcap_sendpacket(pcds[id],buf,length)<0){\n\t\tThrow(IOException,pcap_errbuf[id]);\n    return;\n  }\n}", "path": "src\\c\\JpcapSender.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nGet Packet Read Timeout (UNIX only)\n**/\n", "func_signal": "JNIEXPORT jint JNICALL Java_jpcap_JpcapCaptor_getPacketReadTimeout\n(JNIEnv *env, jobject obj)", "code": "{\n    jint rval = -1;\n\n#ifndef WIN32\n    jint id = getJpcapID(env, obj);\n    int fd = pcap_fileno(pcds[id]);\n    int s;\n    struct timeval tv;\n    socklen_t len = sizeof(struct timeval);\n\n    s = getsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, &len);\n\n    if (s == 0 && len == sizeof(struct timeval))\n    {\n        rval = (tv.tv_usec / 1000) + (tv.tv_sec * 1000);\n    }\n#endif\n\n    return rval;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nBreak loop\n**/\n", "func_signal": "JNIEXPORT void JNICALL Java_jpcap_JpcapCaptor_breakLoop\n(JNIEnv *env, jobject obj)", "code": "{\n  int id=getJpcapID(env,obj);\n\n  pcap_breakloop(pcds[id]);\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nProcess Packets\n**/\n", "func_signal": "JNIEXPORT jint JNICALL\nJava_jpcap_JpcapCaptor_processPacket(JNIEnv *env,jobject obj,\n\t\t\t       jint cnt,jobject handler)", "code": "{\n  jint pkt_cnt;\n  jint id=getJpcapID(env,obj);\n\n  jni_envs[id]=env;\n  jpcap_handlers[id]=(*env)->NewGlobalRef(env,handler);\n\n  pkt_cnt=pcap_dispatch(pcds[id],cnt,dispatcher_handler,(u_char *)id);\n\n  (*env)->DeleteGlobalRef(env,jpcap_handlers[id]);\n  return pkt_cnt;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nSet Packet Read Timeout (UNIX only)\n**/\n", "func_signal": "JNIEXPORT jboolean JNICALL Java_jpcap_JpcapCaptor_setPacketReadTimeout\n(JNIEnv *env, jobject obj, jint millis)", "code": "{\n    jboolean success = JNI_FALSE;\n\n#ifndef WIN32\n    jint id = getJpcapID(env, obj);\n    int fd = pcap_fileno(pcds[id]);\n    int s;\n    struct timeval tv;\n\n    tv.tv_usec = (millis % 1000) * 1000;\n    tv.tv_sec = millis / 1000;\n    s = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));\n    success = (s==0?JNI_TRUE:JNI_FALSE);\n#endif\n\n    return success;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/** analyze ip header **/\n", "func_signal": "u_short analyze_ip(JNIEnv *env,jobject packet,u_char *data)", "code": "{\n  struct ip *ip_pkt;\n  jbyteArray src_addr,dst_addr;\n  u_short hdrlen;\n\n#ifdef DEBUG\n  puts(\"analyze ip\");\n#endif\n\n  ip_pkt=(struct ip *)data;\n\n  src_addr=(*env)->NewByteArray(env,4);\n  dst_addr=(*env)->NewByteArray(env,4);\n  (*env)->SetByteArrayRegion(env,src_addr,0,4,(char *)&ip_pkt->ip_src);\n  (*env)->SetByteArrayRegion(env,dst_addr,0,4,(char *)&ip_pkt->ip_dst);\n\n  // updated by Damien Daspit 5/7/01\n  (*env)->CallVoidMethod(env,packet,setIPValueMID,\n\t\t\t     (jbyte)4,\n\t\t\t     (jbyte)(ip_pkt->ip_tos>>5),\n\t\t\t\t (jboolean)(((ip_pkt->ip_tos&IPTOS_LOWDELAY)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((ip_pkt->ip_tos&IPTOS_THROUGHPUT)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((ip_pkt->ip_tos&IPTOS_RELIABILITY)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t     (jbyte)(ip_pkt->ip_tos&0x3),\n\t\t\t\t (jboolean)(((ip_pkt->ip_off&IP_RF)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((ip_pkt->ip_off&IP_DF)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t\t (jboolean)(((ip_pkt->ip_off&IP_MF)>0)?JNI_TRUE:JNI_FALSE),\n\t\t\t     (jshort)(ntohs(ip_pkt->ip_off)&IP_OFFMASK),\n\t\t\t     (jshort)ntohs(ip_pkt->ip_len),\n\t\t\t     (jint)ntohs(ip_pkt->ip_id),\n\t\t\t     (jshort)ip_pkt->ip_ttl,\n\t\t\t     (jshort)ip_pkt->ip_p,\n\t\t\t     src_addr,dst_addr);\n  // ********************************\n  DeleteLocalRef(src_addr);\n  DeleteLocalRef(dst_addr);\n\n  // added by Damien Daspit 5/7/01\n  hdrlen = ip_pkt->ip_hl<<2;\n  if(hdrlen > IPv4HDRLEN){\n    jbyteArray dataArray=(*env)->NewByteArray(env,hdrlen-IPv4HDRLEN);\n    (*env)->SetByteArrayRegion(env,dataArray,0,hdrlen-IPv4HDRLEN,data+IPv4HDRLEN);\n    (*env)->CallVoidMethod(env,packet,setIPv4OptionMID,dataArray);\n    DeleteLocalRef(dataArray);\n  }\n  // *****************************\n\n  return ip_pkt->ip_hl<<2;\n}", "path": "src\\c\\packet_ip.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/** analyze datalink layer (ethernet) **/\n", "func_signal": "jobject analyze_datalink(JNIEnv *env,u_char *data,int linktype)", "code": "{\n  struct ether_header *ether_hdr;\n  jobject packet;\n  jbyteArray src_addr,dst_addr;\n\n#ifdef DEBUG\n  puts(\"analyze datalink\");\n#endif\n\n  switch(linktype){\n  case DLT_EN10MB:\n    packet=AllocObject(EthernetPacket);\n    src_addr=(*env)->NewByteArray(env,6);\n    dst_addr=(*env)->NewByteArray(env,6);\n    ether_hdr=(struct ether_header *)data;\n    (*env)->SetByteArrayRegion(env,src_addr,0,6,ether_hdr->ether_src);\n    (*env)->SetByteArrayRegion(env,dst_addr,0,6,ether_hdr->ether_dest);\n    (*env)->CallVoidMethod(env,packet,setEthernetValueMID,dst_addr,src_addr,\n\t\t(jchar)ntohs(ether_hdr->ether_type));\n    DeleteLocalRef(src_addr);\n    DeleteLocalRef(dst_addr);\n    break;\n  default:\n    packet=AllocObject(DatalinkPacket);\n    break;\n  }\n\n  return packet;\n}", "path": "src\\c\\packet_datalink.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nUpdate Statistics\n**/\n", "func_signal": "JNIEXPORT void JNICALL\nJava_jpcap_JpcapCaptor_updateStat(JNIEnv *env,jobject obj)", "code": "{\n  struct pcap_stat stat;\n  jfieldID fid;\n  int id=getJpcapID(env,obj);\n\n  pcap_stats(pcds[id],&stat);\n\n  fid=(*env)->GetFieldID(env,Jpcap,\"received_packets\",\"I\");\n  (*env)->SetIntField(env,obj,fid,(jint)stat.ps_recv);\n  fid=(*env)->GetFieldID(env,Jpcap,\"dropped_packets\",\"I\");\n  (*env)->SetIntField(env,obj,fid,(jint)stat.ps_drop);\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nOpen Dumped File\n**/\n", "func_signal": "JNIEXPORT jstring JNICALL\nJava_jpcap_JpcapCaptor_nativeOpenOffline(JNIEnv *env,jobject obj,jstring filename)", "code": "{\n  char *file;\n  jint id;\n  \n  set_Java_env(env);\n\n  id=getJpcapID(env,obj);\n\n  if(pcds[id]!=NULL){\n\treturn NewString(\"Another Jpcap instance is being used.\");\n  }\n  jni_envs[id]=env;\n\n  file=(char *)GetStringChars(filename);\n\n  pcds[id]=pcap_open_offline(file,pcap_errbuf[id]);\n\n  ReleaseStringChars(filename,file);\n\n  if(pcds[id]==NULL) return NewString(pcap_errbuf[id]);\n\n  //set_info(env,obj,pcds[id]);\n  linktypes[id]=pcap_datalink(pcds[id]);\n  set_Java_env(env);\n  return NULL;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nLoop Packets\n**/\n", "func_signal": "JNIEXPORT jint JNICALL\nJava_jpcap_JpcapCaptor_loopPacket(JNIEnv *env,jobject obj,\n\t\t\t    jint cnt,jobject handler)", "code": "{\n  jint pkt_cnt;\n  jint id=getJpcapID(env,obj);\n\n  jni_envs[id]=env;\n  jpcap_handlers[id]=(*env)->NewGlobalRef(env,handler);\n\n  pkt_cnt=pcap_loop(pcds[id],cnt,dispatcher_handler,(u_char *)id);\n\n  (*env)->DeleteGlobalRef(env,jpcap_handlers[id]);\n  return pkt_cnt;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/*\n * Class:     jpcap_JpcapCaptor\n * Method:    setNonBlockingMode\n * Signature: (Z)V\n */\n", "func_signal": "JNIEXPORT void JNICALL Java_jpcap_JpcapCaptor_setNonBlockingMode\n(JNIEnv *env, jobject obj, jboolean non_blocking)", "code": "{\n\tjint id=getJpcapID(env,obj);\n\tpcap_setnonblock(pcds[id],non_blocking,pcap_errbuf[id]);\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nGet Error Message\n**/\n", "func_signal": "JNIEXPORT jstring JNICALL\nJava_jpcap_JpcapCaptor_getErrorMessage(JNIEnv *env,jobject obj)", "code": "{\n  int id=getJpcapID(env,obj);\n  return NewString(pcap_errbuf[id]);\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/** analyze udp header **/\n", "func_signal": "void analyze_udp(JNIEnv *env,jobject packet,u_char *data)", "code": "{\n  struct udphdr *udp_pkt=(struct udphdr *)data;\n\n#ifdef DEBUG\n  puts(\"analze udp\");\n#endif\n\n  (*env)->CallVoidMethod(env,packet,setUDPValueMID,\n\t\t\t     (jint)ntohs(udp_pkt->uh_sport),\n\t\t\t     (jint)ntohs(udp_pkt->uh_dport),\n\t\t\t     (jint)ntohs(udp_pkt->uh_ulen));\n\n  /*if(caplen>UDPHDRLEN){\n    jbyteArray dataArray=(*env)->NewByteArray(env,caplen-UDPHDRLEN);\n    (*env)->SetByteArrayRegion(env,dataArray,0,\n\t\t\t\t   caplen-UDPHDRLEN,(char *)data+UDPHDRLEN);\n    (*env)->CallVoidMethod(env,packet,setPacketDataMID,dataArray);\n  }*/\n}", "path": "src\\c\\packet_udp.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nOpen Device for Live Capture\n**/\n", "func_signal": "JNIEXPORT jstring JNICALL\nJava_jpcap_JpcapCaptor_nativeOpenLive(JNIEnv *env,jobject obj,jstring device,jint snaplen,\n\t\t\t  jint promisc,jint to_ms)", "code": "{\n  char *dev;\n  jint id;\n\n  set_Java_env(env);\n\n  id=getJpcapID(env,obj);\n\n  if(pcds[id]!=NULL){\n\treturn NewString(\"Another Jpcap instance is being used.\");\n  }\n\n  jni_envs[id]=env;\n\n  if(device==NULL){\n    return NewString(\"Please specify device name.\");\n  }\n  dev=(char *)GetStringChars(device);\n\n  pcds[id]=pcap_open_live(dev,snaplen,promisc,to_ms,pcap_errbuf[id]);\n  if(pcap_lookupnet(dev,&netnums[id],&netmasks[id],pcap_errbuf[id])==-1){\n\tnetmasks[id] = 0; \n  }\n\n  ReleaseStringChars(device,dev);\n\n  if(pcds[id]==NULL) return NewString(pcap_errbuf[id]);\n\n  //set_info(env,obj,pcds[id]);\n  linktypes[id]=pcap_datalink(pcds[id]);\n  return NULL;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\nClose Live Capture Device\n**/\n", "func_signal": "JNIEXPORT void JNICALL\nJava_jpcap_JpcapCaptor_nativeClose(JNIEnv *env,jobject obj)", "code": "{\n  int id=getJpcapID(env,obj);\n  if(pcds[id]!=NULL) pcap_close(pcds[id]);\n  pcds[id]=NULL;\n}", "path": "src\\c\\JpcapCaptor.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/*\n * Class:     jpcap_JpcapSender\n * Method:    nativeOpenDevice\n * Signature: (Ljava/lang/String;)V\n */\n", "func_signal": "JNIEXPORT jstring JNICALL Java_jpcap_JpcapSender_nativeOpenDevice\n(JNIEnv *env, jobject obj, jstring device)", "code": "{\n\tchar *dev;\n\tjint id;\n\t\n\tset_Java_env(env);\n\t\n\tid=getJpcapSenderID(env,obj);\n\n\n\tjni_envs[id]=env;\n\n\tif(pcds[id]!=NULL){\n\t\treturn NewString(\"Another Jpcap instance is being used.\");\n\t}\n\tif(device==NULL){\n\t\treturn NewString(\"Please specify device name.\");\n\t}\n\tdev=(char *)GetStringChars(device);\n\n\tpcds[id]=pcap_open_live(dev,65535,0,1000,pcap_errbuf[id]);\n\n\tReleaseStringChars(device,dev);\n\n\tif(pcds[id]==NULL) return NewString(pcap_errbuf[id]);\n\n\treturn NULL;\n}", "path": "src\\c\\JpcapSender.c", "repo_name": "misnomer/jpcap", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 885}
{"docstring": "/**\n * Generates width table for the specified font\n *\n * The width table will be generated at the given destination\n * address. It has one 32bit-entry per ASCII value so its size\n * is 256*4 bytes.\n */\n", "func_signal": "static void font_gen_width_table(struct tff_file_hdr *tff, s32 *dst_wtab)", "code": "{\n\tu32 i;\n\tfor (i = 0; i < 256; i++)\n\t\tdst_wtab[i] = i2u32(&tff->wtab[i]);\n}", "path": "lib\\conv_tff.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Utility: convert intel 32bit value to host format\n */\n", "func_signal": "static u32 i2u32(u32 *src)", "code": "{\n\tu8 *a = ((u8 *)src);\n\tu8 *b = ((u8 *)src) + 1;\n\tu8 *c = ((u8 *)src) + 2;\n\tu8 *d = ((u8 *)src) + 3;\n\treturn ((u32)(*a))      + (((u32)(*b))<<8)\n\t    + (((u32)(*c))<<16) + (((u32)(*d))<<24);\n}", "path": "lib\\conv_tff.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/************************\n ** Module entry point **\n ************************/\n", "func_signal": "static void build_script_lang(void)", "code": "{\n\tvoid *widtype;\n\n\twidtype = script->reg_widget_type(\"Button\", (void *(*)(void))create);\n\tscript->reg_widget_attrib(widtype, \"string text\", but_get_text, but_set_text, gen_methods.update);\n\tscript->reg_widget_attrib(widtype, \"int padx\", but_get_pad_x, but_set_pad_x, gen_methods.update);\n\tscript->reg_widget_attrib(widtype, \"int pady\", but_get_pad_y, but_set_pad_y, gen_methods.update);\n\twidman->build_script_lang(widtype, &gen_methods);\n}", "path": "lib\\button.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Utility: convert intel 32bit value to host format\n */\n", "func_signal": "static u32 i2u32(u32 *src)", "code": "{\n\tu8 *a = ((u8 *)src);\n\tu8 *b = ((u8 *)src) + 1;\n\tu8 *c = ((u8 *)src) + 2;\n\tu8 *d = ((u8 *)src) + 3;\n\treturn ((u32)(*a))      + (((u32)(*b))<<8)\n\t    + (((u32)(*c))<<16) + (((u32)(*d))<<24);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Get height of font image\n */\n", "func_signal": "static u32 font_get_image_width(struct fntfile_hdr *fnt)", "code": "{\n\tif(intel_format(fnt))\n\t\treturn 8*i2u16(&fnt->form_width);\n\telse\n\t\treturn 8*m2u16(&fnt->form_width);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Utility: convert motorola 16bit value to host format\n */\n", "func_signal": "static u16 m2u16(u16 *src)", "code": "{\n\tu8 *low  = ((u8 *)src)+1;\n\tu8 *high =  (u8 *)src;\n\treturn (((u16)(*high))<<8) + (u16)(*low);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Generates offset table for the specified font\n *\n * The offset table will be generated at the given destination\n * address. Its size is 256*4 bytes.\n */\n", "func_signal": "static void font_gen_offset_table(struct tff_file_hdr *tff, s32 *dst_otab)", "code": "{\n\tu32 i;\n\tu32 offset;\n\tfor (i = 0; i < 256; i++) {\n\t\toffset = i2u32(&tff->otab[i]);\n\t\tdst_otab[i] = offset;\n\t}\n}", "path": "lib\\conv_tff.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/************************\n ** Module entry point **\n ************************/\n", "func_signal": "int init_conv_tff(struct mtk_services *d)", "code": "{\n\td->register_module(\"ConvertTFF 1.0\", &services);\n\treturn 1;\n}", "path": "lib\\conv_tff.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Initialises and probes font\n */\n", "func_signal": "static s16 font_probe(struct fntfile_hdr *fnt)", "code": "{\n\tu32 max_char_w, img_w, img_h, point, first_ade, last_ade, top, bottom;\n\tu16 (*get_u16) (u16 *);\n\tINFO(char *dbg = \"ConvertFNT(probe): \");\n\n\tif(intel_format(fnt)) {\n\t\tINFO(printf(\"%s font is in intel format\\n\", dbg));\n\t\tget_u16 = i2u16;\n\t} else  {\n\t\tINFO(printf(\"%s font is in motorola format\\n\", dbg));\n\t\tget_u16 = m2u16;\n\t}\n\n\tfnt->name[31] = 0;\n\n\tmax_char_w = get_u16(&fnt->max_char_width);\n\timg_w      = get_u16(&fnt->form_width)*8;\n\timg_h      = get_u16(&fnt->form_height);\n\tpoint      = get_u16(&fnt->point);\n\tfirst_ade  = get_u16(&fnt->first_ade);\n\tlast_ade   = get_u16(&fnt->last_ade);\n\ttop        = get_u16(&fnt->top);\n\tbottom     = get_u16(&fnt->bottom);\n\n\tINFO(printf(\"%s image width:  %u\\n\",dbg,img_w));\n\tINFO(printf(\"%s image height: %u\\n\",dbg,img_h));\n\tINFO(printf(\"%s points:       %u\\n\",dbg,point));\n\tINFO(printf(\"%s first_ade:    %u\\n\",dbg,first_ade));\n\tINFO(printf(\"%s last_ade:     %u\\n\",dbg,last_ade));\n\tINFO(printf(\"%s top:          %u\\n\",dbg,top));\n\tINFO(printf(\"%s bottom:       %u\\n\",dbg,bottom));\n\tINFO(printf(\"%s name:         %s\\n\",dbg,fnt->name));\n\n\t/* strange values -> seems not to be a valid fnt */\n\tif(max_char_w > 100 || img_h < 1            || img_h > 100\n\t || img_w < 1        || point > 50           || first_ade > 255\n\t || last_ade > 255   || first_ade > last_ade || top > img_h\n\t || bottom > img_h   || top < bottom) {\n\n\t\tINFO(printf(\"%sthis doesnt seem to be valid fnt data - sorry\\n\",dbg));\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Convert intel 16bit value to host format\n */\n", "func_signal": "static u16 i2u16(u16 *src)", "code": "{\n\tu8 *low  = ((u8 *)src)+1;\n\tu8 *high = (u8 *)src;\n\treturn (((u16)(*low))<<8) + (u16)(*high);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/****************************\n ** General widget methods **\n ****************************/\n", "func_signal": "static int but_draw(BUTTON *b, struct gfx_ds *ds, int x, int y, WIDGET *origin)", "code": "{\n\tint tx = b->bd->tx, ty = b->bd->ty;\n\tint w  = b->wd->w,  h  = b->wd->h;\n\n\t/* we hit the origin, acknowledge visibility request */\n\tif (origin == b) return 1;\n\n\t/* only draw if no origin is specified */\n\tif (origin) return 0;\n\n\tx += b->wd->x;\n\ty += b->wd->y;\n\n\tgfx->push_clipping(ds, x, y, w, h);\n\n\tx += b->bd->pad_x;\n\ty += b->bd->pad_y;\n\tw -= b->bd->pad_x*2;\n\th -= b->bd->pad_y*2;\n\n\t/* draw keyboard focus frame if button is currently selected */\n\tif (b->wd->flags & WID_FLAGS_KFOCUS)\n\t\tdraw_kfocus_frame(ds, x - 1, y - 1, w + 2, h + 2);\n\n\tif (b->wd->flags & WID_FLAGS_MFOCUS) {\n\t\tgfx->draw_img(ds, x, y, w, h, focus_img, 255);\n\n\t\tif (!(b->wd->flags & WID_FLAGS_STATE)) {\n\t\t\tgfx->draw_img(ds, x, y, w, h, focus_img, 255);\n\t\t\tdraw_focus_frame(ds, x, y, w, h);\n\t\t}\n\t} else {\n\t\tif (b->bd->style == 2) {\n\t\t\tgfx->draw_img(ds, x, y, w, h, actwin_img, 255);\n\t\t} else {\n\t\t\tgfx->draw_img(ds, x, y, w, h, normal_img, 255);\n\t\t}\n\t}\n\n\tif (b->wd->flags & WID_FLAGS_STATE) {\n\t\tdraw_pressed_frame(ds, x, y, w, h);\n\t} else {\n\t\tif (!(b->wd->flags & WID_FLAGS_MFOCUS)) {\n\t\t\tdraw_raised_frame(ds, x, y, w, h);\n\t\t}\n\t}\n\n\ttx += x; ty += y;\n\tif (b->wd->flags & WID_FLAGS_MFOCUS) {\n\t\ttx += 1; ty += 1;\n\t}\n\tif (b->wd->flags & WID_FLAGS_STATE) {\n\t\ttx += 2; ty += 2;\n\t}\n\tgfx->push_clipping(ds, x + 2, y + 2, w - 4, h - 4);\n\n\tif (b->bd->text)\n\t\tgfx->draw_string(ds, tx, ty, GFX_RGB(200, 200, 200), 0, b->bd->font_id, b->bd->text);\n\n\tgfx->pop_clipping(ds);\n\tgfx->pop_clipping(ds);\n\n\treturn 1;\n}", "path": "lib\\button.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Get top line of font\n */\n", "func_signal": "static u16 font_get_top(struct fntfile_hdr *fnt)", "code": "{\n\tif(intel_format(fnt))\n\t\treturn i2u16(&fnt->top);\n\telse\n\t\treturn m2u16(&fnt->top);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/***********************\n ** Service functions **\n ***********************/\n", "func_signal": "static BUTTON *create(void)", "code": "{\n\tBUTTON *new = ALLOC_WIDGET(struct button);\n\tSET_WIDGET_DEFAULTS(new, struct button, &but_methods);\n\n\t/* set button specific attributes */\n\tnew->bd->style  = 1;\n\tnew->bd->pad_x  = new->bd->pad_y = 2;\n\tnew->wd->flags |= WID_FLAGS_HIGHLIGHT | WID_FLAGS_SELECTABLE;\n\n\tupdate_text_pos(new);\n\tbut_calc_minmax(new);\n\treturn new;\n}", "path": "lib\\button.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/* http://www.kostis.net/charsets/atarist.htm */\n", "func_signal": "static int iso8859_to_atari(int ch)", "code": "{\n\tswitch(ch) {\n\t\tcase 244: return 147;\n\t\tcase 246: return 148;\n\t\tcase 214: return 153;\n\t\tcase 198: return 146;\n\t\tcase 230: return 145;\n\t\tcase 201: return 144;\n\t\tcase 197: return 143;\n\t\tcase 196: return 142;\n\t\tcase 231: return 135;\n\t\tcase 234: return 136;\n\t\tcase 235: return 137;\n\t\tcase 232: return 138;\n\t\tcase 239: return 139;\n\t\tcase 238: return 140;\n\t\tcase 236: return 141;\n\t\tcase 251: return 150;\n\t\tcase 249: return 151;\n\t\tcase 255: return 152;\n\t\tcase 220: return 154;\n\t\tcase 223: return 158;\n\t\tcase 192: return 182;\n\t\tcase 169: return 189;\n\t\tcase 174: return 190;\n\t\tcase 229: return 134;\n\t\tcase 224: return 133;\n\t\tcase 228: return 132;\n\t\tcase 226: return 131;\n\t\tcase 233: return 130;\n\t\tcase 252: return 129;\n\t\tcase 199: return 128;\n\t\tdefault: return ch;\n\t}\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/*****************************\n ** Button specific methods **\n *****************************/\n", "func_signal": "static void but_set_text(BUTTON *b, char *new_txt)", "code": "{\n\tif (b->bd->text_original) {\n\t\tfree(b->bd->text_original);\n\t}\n\tif (new_txt != NULL)\n\t\tb->bd->text_original = strdup(new_txt);\n\telse\n\t\tb->bd->text_original = NULL;\n\tb->bd->text = (char *)mtk_translate(b->bd->text_original);\n\n\t/*\n\t * If a button's size is completely free, a change\n\t * of the text has no effect on the layout of the\n\t * parent. In this case, it is enough to do a\n\t * refresh instead of giving a MINMAX notification.\n\t */\n\tif (!(b->bd->flags & BUTTON_FLAGS_FREE_W)\n\t || !(b->bd->flags & BUTTON_FLAGS_FREE_H))\n\t\tb->wd->update |= WID_UPDATE_MINMAX;\n\telse\n\t\tb->wd->update |= WID_UPDATE_REFRESH;\n}", "path": "lib\\button.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/************************\n ** Module entry point **\n ************************/\n", "func_signal": "int init_conv_fnt(struct mtk_services *d)", "code": "{\n\td->register_module(\"ConvertFNT 1.0\", &services);\n\treturn 1;\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Generates width table for the specified font\n *\n * The width table will be generated at the given destination\n * adress. It has one 32bit-entry per ASCII value so its size\n * is 256*4 bytes.\n */\n", "func_signal": "static int get_width(struct fntfile_hdr *fnt, int ch)", "code": "{\n\tu16 first_ade, last_ade;\n\tu16 *offsets;\n\tu16 (*get_u16) (u16 *);\n\tu32 (*get_u32) (u32 *);\n\n\tif(intel_format(fnt)) {\n\t\tget_u16 = i2u16;\n\t\tget_u32 = i2u32;\n\t} else {\n\t\tget_u16 = m2u16;\n\t\tget_u32 = m2u32;\n\t}\n\n\tfirst_ade = get_u16(&fnt->first_ade);\n\tlast_ade  = get_u16(&fnt->last_ade);\n\toffsets = (u16 *)((get_u32((u32 *)(&fnt->off_table))) + (int)fnt);\n\t\n\tif((ch >= first_ade) && (ch < last_ade))\n\t\treturn (get_u16(offsets + ch + 1) - get_u16(offsets + ch));\n\telse\n\t\treturn 0;\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Get height of font image\n */\n", "func_signal": "static u32 font_get_image_height(struct fntfile_hdr *fnt)", "code": "{\n\tif(intel_format(fnt))\n\t\treturn i2u16(&fnt->form_height);\n\telse\n\t\treturn m2u16(&fnt->form_height);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Determine min/max size of a button\n *\n * The height and the min width of a Button depend on the used font and\n * the Button text. For the MTK-internal use of Buttons for the window\n * controls there exist the FREE_W and FREE_H flags. When set, the size\n * of a Button is completely free.\n */\n", "func_signal": "static void but_calc_minmax(BUTTON *b)", "code": "{\n\t/* ensure that there is enough padding to draw the focus frame */\n\tif (b->wd->flags & WID_FLAGS_TAKEFOCUS) {\n\t\tif (b->bd->pad_x < 1) b->bd->pad_x++;\n\t\tif (b->bd->pad_y < 1) b->bd->pad_y++;\n\t}\n\n\t/* the min/max height of the button depends on its text */\n\tif (b->bd->text) {\n\t\tb->wd->min_w = font->calc_str_width (b->bd->font_id, b->bd->text)\n\t\t             + b->bd->pad_x * 2 + 6;\n\t\tb->wd->min_h = font->calc_str_height(b->bd->font_id, b->bd->text)\n\t\t             + b->bd->pad_y * 2 + 6;\n\t\tb->wd->max_w = 9999;\n\t\tb->wd->max_h = b->wd->min_h;\n\t} else {\n\t\tb->wd->min_w = b->wd->min_h = 0;\n\t\tb->wd->max_w = b->wd->max_h = 9999;\n\t}\n\n\t/* do not constrain the min/max properties for free buttons */\n\tif (b->bd->flags & BUTTON_FLAGS_FREE_W) {\n\t\tb->wd->min_w = 0;\n\t\tb->wd->max_w = 9999;\n\t}\n\tif (b->bd->flags & BUTTON_FLAGS_FREE_H) {\n\t\tb->wd->min_h = 0;\n\t\tb->wd->max_h = 9999;\n\t}\n}", "path": "lib\\button.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/**\n * Get bottom line of font\n */\n", "func_signal": "static u16 font_get_bottom(struct fntfile_hdr *fnt)", "code": "{\n\tif(intel_format(fnt))\n\t\treturn i2u16(&fnt->bottom);\n\telse\n\t\treturn m2u16(&fnt->bottom);\n}", "path": "lib\\conv_fnt.c", "repo_name": "m-labs/mtk", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 1412}
{"docstring": "/*\n ***************************************************************************\n * Fill the (struct tm) rectime structure with current record's time,\n * based on current record's time data saved in file.\n * The resulting timestamp is expressed in the locale of the file creator\n * or in the user's own locale depending on whether option -t has been used\n * or not.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n *\n * RETURNS:\n * 1 if an error was detected, or 0 otherwise.\n ***************************************************************************\n*/\n", "func_signal": "int sar_get_record_timestamp_struct(int curr)", "code": "{\n\tstruct tm *ltm;\n\n\t/* Check if option -t was specified on the command line */\n\tif (PRINT_TRUE_TIME(flags)) {\n\t\t/* -t */\n\t\trectime.tm_hour = record_hdr[curr].hour;\n\t\trectime.tm_min  = record_hdr[curr].minute;\n\t\trectime.tm_sec  = record_hdr[curr].second;\n\t}\n\telse {\n\t\tif ((ltm = localtime((const time_t *) &record_hdr[curr].ust_time)) == NULL)\n\t\t\t/*\n\t\t\t * An error was detected.\n\t\t\t * The rectime structure has NOT been updated.\n\t\t\t */\n\t\t\treturn 1;\n\t\t\n\t\trectime = *ltm;\n\t}\n\t\n\treturn 0;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read statistics from a system activity data file.\n *\n * IN:\n * @from_file\tInput file name.\n ***************************************************************************\n */\n", "func_signal": "void read_stats_from_file(char from_file[])", "code": "{\n\tstruct file_magic file_magic;\n\tstruct file_activity *file_actlst = NULL;\n\tint curr = 1, i, p;\n\tint ifd, rtype;\n\tint rows, eosaf = TRUE, reset = FALSE;\n\tlong cnt = 1;\n\toff_t fpos;\n\n\t/* Get window size */\n\trows = get_win_height();\n\n\t/* Read file headers and activity list */\n\tcheck_file_actlst(&ifd, from_file, act, &file_magic, &file_hdr,\n\t\t\t  &file_actlst, id_seq, FALSE);\n\n\t/* Perform required allocations */\n\tallocate_structures(act);\n\n\t/* Print report header */\n\tprint_report_hdr(flags, &rectime, &file_hdr,\n\t\t\t act[get_activity_position(act, A_CPU)]->nr);\n\n\t/* Read system statistics from file */\n\tdo {\n\t\t/*\n\t\t * If this record is a special (RESTART or COMMENT) one, print it and\n\t\t * (try to) get another one.\n\t\t */\n\t\tdo {\n\t\t\tif (sa_fread(ifd, &record_hdr[0], RECORD_HEADER_SIZE, SOFT_SIZE))\n\t\t\t\t/* End of sa data file */\n\t\t\t\treturn;\n\n\t\t\trtype = record_hdr[0].record_type;\n\t\t\tif ((rtype == R_RESTART) || (rtype == R_COMMENT)) {\n\t\t\t\tsar_print_special(0, tm_start.use, tm_end.use, rtype, ifd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * OK: Previous record was not a special one.\n\t\t\t\t * So read now the extra fields.\n\t\t\t\t */\n\t\t\t\tread_file_stat_bunch(act, 0, ifd, file_hdr.sa_nr_act,\n\t\t\t\t\t\t     file_actlst);\n\t\t\t\tif (sar_get_record_timestamp_struct(0))\n\t\t\t\t\t/*\n\t\t\t\t\t * An error was detected.\n\t\t\t\t\t * The timestamp hasn't been updated.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\twhile ((rtype == R_RESTART) || (rtype == R_COMMENT) ||\n\t\t       (tm_start.use && (datecmp(&rectime, &tm_start) < 0)) ||\n\t\t       (tm_end.use && (datecmp(&rectime, &tm_end) >=0)));\n\n\t\t/* Save the first stats collected. Will be used to compute the average */\n\t\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t\treset = TRUE;\t/* Set flag to reset last_uptime variable */\n\n\t\t/* Save current file position */\n\t\tif ((fpos = lseek(ifd, 0, SEEK_CUR)) < 0) {\n\t\t\tperror(\"lseek\");\n\t\t\texit(2);\n\t\t}\n\n\t\t/*\n\t\t * Read and write stats located between two possible Linux restarts.\n\t\t * Activities that should be displayed are saved in id_seq[] array.\n\t\t */\n\t\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\t\tif (!id_seq[i])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif ((p = get_activity_position(act, id_seq[i])) < 0) {\n\t\t\t\t/* Should never happen */\n\t\t\t\tPANIC(1);\n\t\t\t}\n\t\t\tif (!IS_SELECTED(act[p]->options))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (!HAS_MULTIPLE_OUTPUTS(act[p]->options)) {\n\t\t\t\thandle_curr_act_stats(ifd, fpos, &curr, &cnt, &eosaf, rows,\n\t\t\t\t\t\t      act[p]->id, &reset, file_actlst);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunsigned int optf, msk;\n\t\t\t\t\n\t\t\t\toptf = act[p]->opt_flags;\n\t\t\t\t\n\t\t\t\tfor (msk = 1; msk < 0x10; msk <<= 1) {\n\t\t\t\t\tif (act[p]->opt_flags & msk) {\n\t\t\t\t\t\tact[p]->opt_flags &= msk;\n\t\t\t\t\t\t\n\t\t\t\t\t\thandle_curr_act_stats(ifd, fpos, &curr, &cnt,\n\t\t\t\t\t\t\t\t      &eosaf, rows, act[p]->id,\n\t\t\t\t\t\t\t\t      &reset, file_actlst);\n\t\t\t\t\t\tact[p]->opt_flags = optf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!cnt) {\n\t\t\t/* Go to next Linux restart, if possible */\n\t\t\tdo {\n\t\t\t\teosaf = sa_fread(ifd, &record_hdr[curr], RECORD_HEADER_SIZE,\n\t\t\t\t\t\t SOFT_SIZE);\n\t\t\t\trtype = record_hdr[curr].record_type;\n\t\t\t\tif (!eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {\n\t\t\t\t\tread_file_stat_bunch(act, curr, ifd, file_hdr.sa_nr_act,\n\t\t\t\t\t\t\t     file_actlst);\n\t\t\t\t}\n\t\t\t\telse if (!eosaf && (rtype == R_COMMENT)) {\n\t\t\t\t\t/* This was a COMMENT record: print it */\n\t\t\t\t\tsar_print_special(curr, tm_start.use, tm_end.use, R_COMMENT, ifd);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!eosaf && (rtype != R_RESTART));\n\t\t}\n\n\t\t/* The last record we read was a RESTART one: Print it */\n\t\tif (!eosaf && (record_hdr[curr].record_type == R_RESTART)) {\n\t\t\tsar_print_special(curr, tm_start.use, tm_end.use, R_RESTART, ifd);\n\t\t}\n\t}\n\twhile (!eosaf);\n\n\tclose(ifd);\n\t\n\tif (file_actlst) {\n\t\tfree(file_actlst);\n\t}\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Determine if a stat header line has to be displayed.\n *\n * RETURNS:\n * TRUE if a header line has to be displayed.\n ***************************************************************************\n*/\n", "func_signal": "int check_line_hdr(void)", "code": "{\n\tint i, rc = FALSE;\n\n\t/* Get number of options entered on the command line */\n\tif (get_activity_nr(act, AO_SELECTED, COUNT_OUTPUTS) > 1)\n\t\treturn TRUE;\n\t\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (IS_SELECTED(act[i]->options)) {\n\t\t\t/* Special processing for activities using a bitmap */\n\t\t\tif (act[i]->bitmap) {\n\t\t\t\tif (count_bits(act[i]->bitmap->b_array,\n\t\t\t\t\t       BITMAP_SIZE(act[i]->bitmap->b_size)) > 1) {\n\t\t\t\t\trc = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (act[i]->nr > 1) {\n\t\t\t\trc = TRUE;\n\t\t\t}\n\t\t\t/* Stop now since we have only one selected activity */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Display a short help message and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\n", "func_signal": "void display_help(char *progname)", "code": "{\n\tprint_usage_title(stdout, progname);\n\tprintf(_(\"Main options and reports:\\n\"));\n\tprintf(_(\"\\t-b\\tI/O and transfer rate statistics\\n\"));\n\tprintf(_(\"\\t-B\\tPaging statistics\\n\"));\n\tprintf(_(\"\\t-d\\tBlock device statistics\\n\"));\n\tprintf(_(\"\\t-H\\tHugepages utilization statistics\\n\"));\n\tprintf(_(\"\\t-I { <int> | SUM | ALL | XALL }\\n\"\n\t\t \"\\t\\tInterrupts statistics\\n\"));\n\tprintf(_(\"\\t-m { <keyword> [,...] | ALL }\\n\"\n\t\t \"\\t\\tPower management statistics\\n\"\n\t\t \"\\t\\tKeywords are:\\n\"\n\t\t \"\\t\\tCPU\\tCPU instantaneous clock frequency\\n\"\n\t\t \"\\t\\tFAN\\tFans speed\\n\"\n\t\t \"\\t\\tFREQ\\tCPU average clock frequency\\n\"\n\t\t \"\\t\\tIN\\tVoltage inputs\\n\"\n\t\t \"\\t\\tTEMP\\tDevices temperature\\n\"));\n\tprintf(_(\"\\t-n { <keyword> [,...] | ALL }\\n\"\n\t\t \"\\t\\tNetwork statistics\\n\"\n\t\t \"\\t\\tKeywords are:\\n\"\n\t\t \"\\t\\tDEV\\tNetwork interfaces\\n\"\n\t\t \"\\t\\tEDEV\\tNetwork interfaces (errors)\\n\"\n\t\t \"\\t\\tNFS\\tNFS client\\n\"\n\t\t \"\\t\\tNFSD\\tNFS server\\n\"\n\t\t \"\\t\\tSOCK\\tSockets\\t(v4)\\n\"\n\t\t \"\\t\\tIP\\tIP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tEIP\\tIP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tICMP\\tICMP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tEICMP\\tICMP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tTCP\\tTCP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tETCP\\tTCP traffic\\t(v4) (errors)\\n\"\n\t\t \"\\t\\tUDP\\tUDP traffic\\t(v4)\\n\"\n\t\t \"\\t\\tSOCK6\\tSockets\\t(v6)\\n\"\n\t\t \"\\t\\tIP6\\tIP traffic\\t(v6)\\n\"\n\t\t \"\\t\\tEIP6\\tIP traffic\\t(v6) (errors)\\n\"\n\t\t \"\\t\\tICMP6\\tICMP traffic\\t(v6)\\n\"\n\t\t \"\\t\\tEICMP6\\tICMP traffic\\t(v6) (errors)\\n\"\n\t\t \"\\t\\tUDP6\\tUDP traffic\\t(v6)\\n\"));\n\tprintf(_(\"\\t-q\\tQueue length and load average statistics\\n\"));\n\tprintf(_(\"\\t-r\\tMemory utilization statistics\\n\"));\n\tprintf(_(\"\\t-R\\tMemory statistics\\n\"));\n\tprintf(_(\"\\t-S\\tSwap space utilization statistics\\n\"));\n\tprintf(_(\"\\t-u [ ALL ]\\n\"\n\t\t \"\\t\\tCPU utilization statistics\\n\"));\n\tprintf(_(\"\\t-v\\tKernel table statistics\\n\"));\n\tprintf(_(\"\\t-w\\tTask creation and system switching statistics\\n\"));\n\tprintf(_(\"\\t-W\\tSwapping statistics\\n\"));\n\tprintf(_(\"\\t-y\\tTTY device statistics\\n\"));\n\texit(0);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read data sent by the data collector.\n *\n * IN:\n * @size\tNumber of bytes of data to read.\n *\n * OUT:\n * @buffer\tBuffer where data will be saved.\n *\n * RETURNS:\n * 1 if end of file has been reached, 0 otherwise.\n ***************************************************************************\n */\n", "func_signal": "int sa_read(void *buffer, int size)", "code": "{\n\tint n;\n\n\twhile (size) {\n\n\t\tif ((n = read(STDIN_FILENO, buffer, size)) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(2);\n\t\t}\n\n\t\tif (!n)\n\t\t\treturn 1;\t/* EOF */\n\n\t\tsize -= n;\n\t\tbuffer = (char *) buffer + n;\n\t}\n\n\treturn 0;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Display stats since system startup.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n", "func_signal": "void write_stats_startup(int curr)", "code": "{\n\tint i;\n\n\t/* Set to 0 previous structures corresponding to boot time */\n\tmemset(&record_hdr[!curr], 0, RECORD_HEADER_SIZE);\n\trecord_hdr[!curr].record_type = R_STATS;\n\trecord_hdr[!curr].hour        = record_hdr[curr].hour;\n\trecord_hdr[!curr].minute      = record_hdr[curr].minute;\n\trecord_hdr[!curr].second      = record_hdr[curr].second;\n\trecord_hdr[!curr].ust_time    = record_hdr[curr].ust_time;\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr > 0)) {\n\t\t\tmemset(act[i]->buf[!curr], 0, act[i]->msize * act[i]->nr * act[i]->nr2);\n\t\t}\n\t}\n\t\n\tflags |= S_F_SINCE_BOOT;\n\tdis = TRUE;\n\t\n\twrite_stats(curr, USE_SADC, &count, NO_TM_START, NO_TM_END, NO_RESET, ALL_ACTIVITIES);\n\t\n\texit(0);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Print system statistics.\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @read_from_file\tSet to TRUE if stats are read from a system activity\n * \t\t\tdata file.\n * @use_tm_start\tSet to TRUE if option -s has been used.\n * @use_tm_end\t\tSet to TRUE if option -e has been used.\n * @reset\t\tSet to TRUE if last_uptime variable should be\n * \t\t\treinitialized (used in next_slice() function).\n * @act_id\t\tActivity that can be displayed or ~0 for all.\n *\t\t\tRemember that when reading stats from a file, only\n *\t\t\tone activity can be displayed at a time.\n *\n * OUT:\n * @cnt\t\t\tNumber of remaining lines to display.\n *\n * RETURNS:\n * 1 if stats have been successfully displayed, and 0 otherwise.\n ***************************************************************************\n */\n", "func_signal": "int write_stats(int curr, int read_from_file, long *cnt, int use_tm_start,\n\t\tint use_tm_end, int reset, unsigned int act_id)", "code": "{\n\tint i;\n\tunsigned long long itv, g_itv;\n\tstatic int cross_day = 0;\n\tstatic __nr_t cpu_nr = -1;\n\n\tif (cpu_nr < 0)\n\t\tcpu_nr = act[get_activity_position(act, A_CPU)]->nr;\n\n\t/* Check time (1) */\n\tif (read_from_file) {\n\t\tif (!next_slice(record_hdr[2].uptime0, record_hdr[curr].uptime0,\n\t\t\t\treset, interval))\n\t\t\t/* Not close enough to desired interval */\n\t\t\treturn 0;\n\t}\n\n\t/* Set previous timestamp */\n\tif (set_record_timestamp_string(!curr, timestamp[!curr], 16))\n\t\treturn 0;\n\t/* Set current timestamp */\n\tif (set_record_timestamp_string(curr,  timestamp[curr],  16))\n\t\treturn 0;\n\n\t/* Check if we are beginning a new day */\n\tif (use_tm_start && record_hdr[!curr].ust_time &&\n\t    (record_hdr[curr].ust_time > record_hdr[!curr].ust_time) &&\n\t    (record_hdr[curr].hour < record_hdr[!curr].hour)) {\n\t\tcross_day = 1;\n\t}\n\n\tif (cross_day) {\n\t\t/*\n\t\t * This is necessary if we want to properly handle something like:\n\t\t * sar -s time_start -e time_end with\n\t\t * time_start(day D) > time_end(day D+1)\n\t\t */\n\t\trectime.tm_hour +=24;\n\t}\n\n\t/* Check time (2) */\n\tif (use_tm_start && (datecmp(&rectime, &tm_start) < 0))\n\t\t/* it's too soon... */\n\t\treturn 0;\n\n\t/* Get interval values */\n\tget_itv_value(&record_hdr[curr], &record_hdr[!curr],\n\t\t      cpu_nr, &itv, &g_itv);\n\n\t/* Check time (3) */\n\tif (use_tm_end && (datecmp(&rectime, &tm_end) > 0)) {\n\t\t/* It's too late... */\n\t\t*cnt = 0;\n\t\treturn 0;\n\t}\n\n\tavg_count++;\n\t\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr > 0)) {\n\t\t\t/* Display current activity statistics */\n\t\t\tif (NEEDS_GLOBAL_ITV(act[i]->options))\n\t\t\t\t(*act[i]->f_print)(act[i], !curr, curr, g_itv);\n\t\t\telse\n\t\t\t\t(*act[i]->f_print)(act[i], !curr, curr, itv);\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Set current record's timestamp string.\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n * @len\t\tMaximum length of timestamp string.\n *\n * OUT:\n * @cur_time\tTimestamp string.\n *\n * RETURNS:\n * 1 if an error was detected, or 0 otherwise.\n ***************************************************************************\n*/\n", "func_signal": "int set_record_timestamp_string(int curr, char *cur_time, int len)", "code": "{\n\t/* Fill timestamp structure */\n\tif (sar_get_record_timestamp_struct(curr))\n\t\t/* Error detected */\n\t\treturn 1;\n\n\t/* Set cur_time date value */\n\tstrftime(cur_time, len, \"%X\", &rectime);\n\n\treturn 0;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Allocate memory for sadc args.\n *\n * IN:\n * @i\t\tArgument number.\n * @ltemp\tArgument value.\n ***************************************************************************\n */\n", "func_signal": "void salloc(int i, char *ltemp)", "code": "{\n\tif ((args[i] = (char *) malloc(strlen(ltemp) + 1)) == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(4);\n\t}\n\tstrcpy(args[i], ltemp);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Init some structures.\n ***************************************************************************\n */\n", "func_signal": "void init_structures(void)", "code": "{\n\tint i;\n\t\n\tfor (i = 0; i < 3; i++)\n\t\tmemset(&record_hdr[i], 0, RECORD_HEADER_SIZE);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Check that every selected activity actually belongs to the sequence list.\n * If not, then the activity should be unselected since it will not be sent\n * by sadc. An activity can be not sent if its number of items is null.\n *\n * IN:\n * @act_nr\tSize of sequence list.\n ***************************************************************************\n */\n", "func_signal": "void reverse_check_act(unsigned int act_nr)", "code": "{\n\tint i, j;\n\t\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\n\t\tif (IS_SELECTED(act[i]->options)) {\n\t\t\t\n\t\t\tfor (j = 0; j < act_nr; j++) {\n\t\t\t\tif (id_seq[j] == act[i]->id)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == act_nr)\n\t\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Main entry to the sar program.\n ***************************************************************************\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tint i, opt = 1, args_idx = 2;\n\tint fd[2];\n\tchar from_file[MAX_FILE_LEN], to_file[MAX_FILE_LEN];\n\tchar ltemp[20];\n\n\t/* Get HZ */\n\tget_HZ();\n\n\t/* Compute page shift in kB */\n\tget_kb_shift();\n\n\tfrom_file[0] = to_file[0] = '\\0';\n\n#ifdef USE_NLS\n\t/* Init National Language Support */\n\tinit_nls();\n#endif\n\n\ttm_start.use = tm_end.use = FALSE;\n\t\n\t/* Allocate and init activity bitmaps */\n\tallocate_bitmaps(act);\n\n\tinit_structures();\n\n\t/* Process options */\n\twhile (opt < argc) {\n\n\t\tif (!strcmp(argv[opt], \"-I\")) {\n\t\t\tif (argv[++opt]) {\n\t\t\t\t/* Parse -I option */\n\t\t\t\tif (parse_sar_I_opt(argv, &opt, act)) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-P\")) {\n\t\t\t/* Parse -P option */\n\t\t\tif (parse_sa_P_opt(argv, &opt, &flags, act)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-o\")) {\n\t\t\t/* Save stats to a file */\n\t\t\tif ((argv[++opt]) && strncmp(argv[opt], \"-\", 1) &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tstrncpy(to_file, argv[opt++], MAX_FILE_LEN);\n\t\t\t\tto_file[MAX_FILE_LEN - 1] = '\\0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrcpy(to_file, \"-\");\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-f\")) {\n\t\t\t/* Read stats from a file */\n\t\t\tif ((argv[++opt]) && strncmp(argv[opt], \"-\", 1) &&\n\t\t\t    (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tstrncpy(from_file, argv[opt++], MAX_FILE_LEN);\n\t\t\t\tfrom_file[MAX_FILE_LEN - 1] = '\\0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset_default_file(&rectime, from_file);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-s\")) {\n\t\t\t/* Get time start */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_start, DEF_TMSTART)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-e\")) {\n\t\t\t/* Get time end */\n\t\t\tif (parse_timestamp(argv, &opt, &tm_end, DEF_TMEND)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-h\")) {\n\t\t\t/* Display help message */\n\t\t\tdisplay_help(argv[0]);\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-i\")) {\n\t\t\tif (!argv[++opt] || (strspn(argv[opt], DIGITS) != strlen(argv[opt]))) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tflags |= S_F_INTERVAL_SET;\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-m\")) {\n\t\t\tif (argv[++opt]) {\n\t\t\t\t/* Parse option -m */\n\t\t\t\tif (parse_sar_m_opt(argv, &opt, act)) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strcmp(argv[opt], \"-n\")) {\n\t\t\tif (argv[++opt]) {\n\t\t\t\t/* Parse option -n */\n\t\t\t\tif (parse_sar_n_opt(argv, &opt, act)) {\n\t\t\t\t\tusage(argv[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse if (!strncmp(argv[opt], \"-\", 1)) {\n\t\t\t/* Other options not previously tested */\n\t\t\tif (parse_sar_opt(argv, &opt, act, &flags, C_SAR)) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\topt++;\n\t\t}\n\n\t\telse if (interval < 0) {\n\t\t\t/* Get interval */\n\t\t\tif (strspn(argv[opt], DIGITS) != strlen(argv[opt])) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tinterval = atol(argv[opt++]);\n\t\t\tif (interval < 0) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t/* Get count value */\n\t\t\tif ((strspn(argv[opt], DIGITS) != strlen(argv[opt])) ||\n\t\t\t    !interval) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\t/* Count parameter already set */\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t\tcount = atol(argv[opt++]);\n\t\t\tif (count < 1) {\n\t\t\t\tusage(argv[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* 'sar' is equivalent to 'sar -f' */\n\tif ((argc == 1) ||\n\t    ((interval < 0) && !from_file[0] && !to_file[0])) {\n\t\tset_default_file(&rectime, from_file);\n\t}\n\n\tif (tm_start.use && tm_end.use && (tm_end.tm_hour < tm_start.tm_hour)) {\n\t\ttm_end.tm_hour += 24;\n\t}\n\n\t/*\n\t * Check option dependencies.\n\t */\n\t/* You read from a file OR you write to it... */\n\tif (from_file[0] && to_file[0]) {\n\t\tfprintf(stderr, _(\"-f and -o options are mutually exclusive\\n\"));\n\t\texit(1);\n\t}\n\t/* Use time start or option -i only when reading stats from a file */\n\tif ((tm_start.use || INTERVAL_SET(flags)) && !from_file[0]) {\n\t\tfprintf(stderr,\n\t\t\t_(\"Not reading from a system activity file (use -f option)\\n\"));\n\t\texit(1);\n\t}\n\t/* Don't print stats since boot time if -o or -f options are used */\n\tif (!interval && (from_file[0] || to_file[0])) {\n\t\tusage(argv[0]);\n\t}\n\n\tif (USE_PRETTY_OPTION(flags)) {\n\t\tdm_major = get_devmap_major();\n\t}\n\t\n\tif (!count) {\n\t\t/*\n\t\t * count parameter not set: Display all the contents of the file\n\t\t * or generate a report continuously.\n\t\t */\n\t\tcount = -1;\n\t}\n\n\t/* Default is CPU activity... */\n\tselect_default_activity(act);\n\t\n\t/* Reading stats from file: */\n\tif (from_file[0]) {\n\t\tif (interval < 0) {\n\t\t\tinterval = 1;\n\t\t}\n\n\t\t/* Read stats from file */\n\t\tread_stats_from_file(from_file);\n\t\t\n\t\t/* Free stuctures and activity bitmaps */\n\t\tfree_bitmaps(act);\n\t\tfree_structures(act);\n\n\t\treturn 0;\n\t}\n\n\t/* Reading stats from sadc: */\n\n\t/* Create anonymous pipe */\n\tif (pipe(fd) == -1) {\n\t\tperror(\"pipe\");\n\t\texit(4);\n\t}\n\n\tswitch (fork()) {\n\n\tcase -1:\n\t\tperror(\"fork\");\n\t\texit(4);\n\t\tbreak;\n\n\tcase 0: /* Child */\n\t\tif (dup2(fd[1], STDOUT_FILENO) < 0) {\n\t\t\tperror(\"dup2\");\n\t\t\texit(4);\n\t\t}\n\t\tCLOSE_ALL(fd);\n\n\t\t/*\n\t\t * Prepare options for sadc.\n\t\t */\n\t\t/* Program name */\n\t\tsalloc(0, SADC);\n\n\t\t/* Interval value */\n\t\tif (interval < 0) {\n\t\t\tusage(argv[0]);\n\t\t}\n\t\telse if (!interval) {\n\t\t\tstrcpy(ltemp, \"1\");\n\t\t}\n\t\telse {\n\t\t\tsprintf(ltemp, \"%ld\", interval);\n\t\t}\n\t\tsalloc(1, ltemp);\n\n\t\t/* Count number */\n\t\tif (count >= 0) {\n\t\t\tsprintf(ltemp, \"%ld\", count + 1);\n\t\t\tsalloc(args_idx++, ltemp);\n\t\t}\n\n\t\t/* Flags to be passed to sadc */\n\t\tsalloc(args_idx++, \"-z\");\n\t\t\n\t\t/* Writing data to a file (option -o) */\n\t\tif (to_file[0]) {\n\t\t\t/* Collect all possible activities (option -S ALL for sadc) */\n\t\t\tsalloc(args_idx++, \"-S\");\n\t\t\tsalloc(args_idx++, K_ALL);\n\t\t\t/* Outfile arg */\n\t\t\tsalloc(args_idx++, to_file);\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * If option -o hasn't been used, then tell sadc\n\t\t\t * to collect only activities that will be displayed.\n\t\t\t */\n\t\t\tint act_id = 0;\n\t\t\t\n\t\t\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\t\tif (IS_SELECTED(act[i]->options)) {\n\t\t\t\t\tact_id |= act[i]->group;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (act_id) {\n\t\t\t\tact_id <<= 8;\n\t\t\t\tsnprintf(ltemp, 19, \"%d\", act_id);\n\t\t\t\tltemp[19] = '\\0';\n\t\t\t\tsalloc(args_idx++, \"-S\");\n\t\t\t\tsalloc(args_idx++, ltemp);\n\t\t\t}\n\t\t}\n\n\t\t/* Last arg is NULL */\n\t\targs[args_idx] = NULL;\n\n\t\t/* Call now the data collector */\n\t\texecv(SADC_PATH, args);\n\t\texecvp(SADC, args);\n\t\t/*\n\t\t * Note: Don't use execl/execlp since we don't have a fixed number of\n\t\t * args to give to sadc.\n\t\t */\n\t\tfprintf(stderr, _(\"Cannot find the data collector (%s)\\n\"), SADC);\n\t\tperror(\"exec\");\n\t\texit(4);\n\t\tbreak;\n\n\tdefault: /* Parent */\n\t\tif (dup2(fd[0], STDIN_FILENO) < 0) {\n\t\t\tperror(\"dup2\");\n\t\t\texit(4);\n\t\t}\n\t\tCLOSE_ALL(fd);\n\n\t\t/* Get now the statistics */\n\t\tread_stats();\n\n\t\tbreak;\n\t}\n\n\t/* Free structures and activity bitmaps */\n\tfree_bitmaps(act);\n\tfree_structures(act);\n\n\treturn 0;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read stats for current activity from file and display them.\n *\n * IN:\n * @ifd\t\tInput file descriptor.\n * @fpos\tPosition in file where reading must start.\n * @curr\tIndex in array for current sample statistics.\n * @rows\tNumber of rows of screen.\n * @act_id\tActivity to display.\n * @file_actlst\tList of activities in file.\n *\n * OUT:\n * @curr\tIndex in array for next sample statistics.\n * @cnt\t\tNumber of remaining lines of stats to write.\n * @eosaf\tSet to TRUE if EOF (end of file) has been reached.\n * @reset\tSet to TRUE if last_uptime variable should be\n * \t\treinitialized (used in next_slice() function).\n ***************************************************************************\n */\n", "func_signal": "void handle_curr_act_stats(int ifd, off_t fpos, int *curr, long *cnt, int *eosaf,\n\t\t\t   int rows, unsigned int act_id, int *reset,\n\t\t\t   struct file_activity *file_actlst)", "code": "{\n\tint p;\n\tunsigned long lines = 0;\n\tunsigned char rtype;\n\tint davg = 0, next, inc = -2;\n\n\tif (lseek(ifd, fpos, SEEK_SET) < fpos) {\n\t\tperror(\"lseek\");\n\t\texit(2);\n\t}\n\n\t/*\n\t * Restore the first stats collected.\n\t * Used to compute the rate displayed on the first line.\n\t */\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\n\t*cnt  = count;\n\n\t/* Assess number of lines printed */\n\tif ((p = get_activity_position(act, act_id)) >= 0) {\n\t\tif (act[p]->bitmap) {\n\t\t\tinc = count_bits(act[p]->bitmap->b_array,\n\t\t\t\t\t BITMAP_SIZE(act[p]->bitmap->b_size));\n\t\t}\n\t\telse {\n\t\t\tinc = act[p]->nr;\n\t\t}\n\t}\n\tif (inc < 0) {\n\t\t/* Should never happen */\n\t\tPANIC(inc);\n\t}\n\n\tdo {\n\t\t/* Display count lines of stats */\n\t\t*eosaf = sa_fread(ifd, &record_hdr[*curr],\n\t\t\t\t  RECORD_HEADER_SIZE, SOFT_SIZE);\n\t\trtype = record_hdr[*curr].record_type;\n\n\t\tif (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {\n\t\t\t/* Read the extra fields since it's not a special record */\n\t\t\tread_file_stat_bunch(act, *curr, ifd, file_hdr.sa_nr_act, file_actlst);\n\t\t}\n\n\t\tif ((lines >= rows) || !lines) {\n\t\t\tlines = 0;\n\t\t\tdis = 1;\n\t\t}\n\t\telse\n\t\t\tdis = 0;\n\n\t\tif (!*eosaf && (rtype != R_RESTART)) {\n\n\t\t\tif (rtype == R_COMMENT) {\n\t\t\t\t/* Display comment */\n\t\t\t\tnext = sar_print_special(*curr, tm_start.use, tm_end.use,\n\t\t\t\t\t\t     R_COMMENT, ifd);\n\t\t\t\tif (next) {\n\t\t\t\t\t/* A line of comment was actually displayed */\n\t\t\t\t\tlines++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* next is set to 1 when we were close enough to desired interval */\n\t\t\tnext = write_stats(*curr, USE_SA_FILE, cnt, tm_start.use, tm_end.use,\n\t\t\t\t\t   *reset, act_id);\n\t\t\tif (next && (*cnt > 0)) {\n\t\t\t\t(*cnt)--;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tdavg++;\n\t\t\t\t*curr ^=1;\n\t\t\t\tlines += inc;\n\t\t\t}\n\t\t\t*reset = FALSE;\n\t\t}\n\t}\n\twhile (*cnt && !*eosaf && (rtype != R_RESTART));\n\n\tif (davg) {\n\t\twrite_stats_avg(!*curr, USE_SA_FILE, act_id);\n\t}\n\n\t*reset = TRUE;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Print statistics average.\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @read_from_file\tSet to TRUE if stats are read from a system activity\n * \t\t\tdata file.\n * @act_id\t\tActivity that can be displayed, or ~0 for all.\n *\t\t\tRemember that when reading stats from a file, only\n *\t\t\tone activity can be displayed at a time.\n ***************************************************************************\n */\n", "func_signal": "void write_stats_avg(int curr, int read_from_file, unsigned int act_id)", "code": "{\n\tint i;\n\tunsigned long long itv, g_itv;\n\tstatic __nr_t cpu_nr = -1;\n\t\n\tif (cpu_nr < 0)\n\t\tcpu_nr = act[get_activity_position(act, A_CPU)]->nr;\n\n\t/* Interval value in jiffies */\n\tg_itv = get_interval(record_hdr[2].uptime, record_hdr[curr].uptime);\n\n\tif (cpu_nr > 1)\n\t\titv = get_interval(record_hdr[2].uptime0, record_hdr[curr].uptime0);\n\telse\n\t\titv = g_itv;\n\n\tstrcpy(timestamp[curr], _(\"Average:\"));\n\tstrcpy(timestamp[!curr], timestamp[curr]);\n\t\n\t/* Test stdout */\n\tTEST_STDOUT(STDOUT_FILENO);\n\t\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\n\t\tif ((act_id != ALL_ACTIVITIES) && (act[i]->id != act_id))\n\t\t\tcontinue;\n\t\t\n\t\tif (IS_SELECTED(act[i]->options) && (act[i]->nr > 0)) {\n\t\t\t/* Display current average activity statistics */\n\t\t\tif (NEEDS_GLOBAL_ITV(act[i]->options))\n\t\t\t\t(*act[i]->f_print_avg)(act[i], 2, curr, g_itv);\n\t\t\telse\n\t\t\t\t(*act[i]->f_print_avg)(act[i], 2, curr, itv);\n\t\t}\n\t}\n\n\tif (read_from_file) {\n\t\t/*\n\t\t * Reset number of lines printed only if we read stats\n\t\t * from a system activity file.\n\t\t */\n\t\tavg_count = 0;\n\t}\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Print a Linux restart message (contents of a RESTART record) or a\n * comment (contents of a COMMENT record).\n *\n * IN:\n * @curr\t\tIndex in array for current sample statistics.\n * @use_tm_start\tSet to TRUE if option -s has been used.\n * @use_tm_end\t\tSet to TRUE if option -e has been used.\n * @rtype\t\tRecord type to display.\n * @ifd\t\t\tInput file descriptor.\n *\n * RETURNS:\n * 1 if the record has been successfully displayed, and 0 otherwise.\n ***************************************************************************\n */\n", "func_signal": "int sar_print_special(int curr, int use_tm_start, int use_tm_end, int rtype, int ifd)", "code": "{\n\tchar cur_time[26];\n\tint dp = 1;\n\n\tif (set_record_timestamp_string(curr, cur_time, 26))\n\t\treturn 0;\n\n\t/* The record must be in the interval specified by -s/-e options */\n\tif ((use_tm_start && (datecmp(&rectime, &tm_start) < 0)) ||\n\t    (use_tm_end && (datecmp(&rectime, &tm_end) > 0))) {\n\t\tdp = 0;\n\t}\n\n\tif (rtype == R_RESTART) {\n\t\tif (dp) {\n\t\t\tprintf(\"\\n%-11s       LINUX RESTART\\n\", cur_time);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (rtype == R_COMMENT) {\n\t\tchar file_comment[MAX_COMMENT_LEN];\n\n\t\t/* Don't forget to read comment record even if it won't be displayed... */\n\t\tsa_fread(ifd, file_comment, MAX_COMMENT_LEN, HARD_SIZE);\n\t\tfile_comment[MAX_COMMENT_LEN - 1] = '\\0';\n\n\t\tif (dp && DISPLAY_COMMENT(flags)) {\n\t\t\tprintf(\"%-11s  COM %s\\n\", cur_time, file_comment);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read statistics sent by sadc, the data collector.\n ***************************************************************************\n */\n", "func_signal": "void read_stats(void)", "code": "{\n\tint curr = 1;\n\tunsigned long lines;\n\tunsigned int rows = 23;\n\tint dis_hdr = 0;\n\n\t/* Don't buffer data if redirected to a pipe... */\n\tsetbuf(stdout, NULL);\n\n\t/* Read stats header */\n\tread_header_data();\n\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES)) {\n\t\tfprintf(stderr, _(\"Requested activities not available\\n\"));\n\t\texit(1);\n\t}\n\n\t/* Determine if a stat line header has to be displayed */\n\tdis_hdr = check_line_hdr();\n\n\tlines = rows = get_win_height();\n\n\t/* Perform required allocations */\n\tallocate_structures(act);\n\n\t/* Print report header */\n\tprint_report_hdr(flags, &rectime, &file_hdr,\n\t\t\t act[get_activity_position(act, A_CPU)]->nr);\n\n\t/* Read system statistics sent by the data collector */\n\tread_sadc_stat_bunch(0);\n\n\tif (!interval) {\n\t\t/* Display stats since boot time and exit */\n\t\twrite_stats_startup(0);\n\t}\n\n\t/* Save the first stats collected. Will be used to compute the average */\n\tcopy_structures(act, id_seq, record_hdr, 2, 0);\n\n\t/* Main loop */\n\tdo {\n\n\t\t/* Get stats */\n\t\tread_sadc_stat_bunch(curr);\n\n\t\t/* Print results */\n\t\tif (!dis_hdr) {\n\t\t\tdis = lines / rows;\n\t\t\tif (dis) {\n\t\t\t\tlines %= rows;\n\t\t\t}\n\t\t\tlines++;\n\t\t}\n\t\twrite_stats(curr, USE_SADC, &count, NO_TM_START, tm_end.use,\n\t\t\t    NO_RESET, ALL_ACTIVITIES);\n\n\t\tif (record_hdr[curr].record_type == R_LAST_STATS) {\n\t\t\t/* File rotation is happening: Re-read header data sent by sadc */\n\t\t\tread_header_data();\n\t\t\tallocate_structures(act);\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t}\n\t\tif (count) {\n\t\t\tcurr ^= 1;\n\t\t}\n\t}\n\twhile (count);\n\n\t/* Print statistics average */\n\tdis = dis_hdr;\n\twrite_stats_avg(curr, USE_SADC, ALL_ACTIVITIES);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read the various statistics sent by the data collector (sadc).\n *\n * IN:\n * @curr\tIndex in array for current sample statistics.\n ***************************************************************************\n */\n", "func_signal": "void read_sadc_stat_bunch(int curr)", "code": "{\n\tint i, p;\n\n\t/* Read record header (type is always R_STATS since it is read from sadc) */\n\tif (sa_read(&record_hdr[curr], RECORD_HEADER_SIZE)) {\n\t\tprint_read_error();\n\t}\n\t\n\tfor (i = 0; i < NR_ACT; i++) {\n\t\t\n\t\tif (!id_seq[i])\n\t\t\tcontinue;\n\t\tif ((p = get_activity_position(act, id_seq[i])) < 0) {\n\t\t\tPANIC(1);\n\t\t}\n\n\t\tif (sa_read(act[p]->buf[curr], act[p]->fsize * act[p]->nr * act[p]->nr2)) {\n\t\t\tprint_read_error();\n\t\t}\n\t}\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Print usage and exit.\n *\n * IN:\n * @progname\tName of sysstat command\n ***************************************************************************\n */\n", "func_signal": "void usage(char *progname)", "code": "{\n\tprint_usage_title(stderr, progname);\n\tfprintf(stderr, _(\"Options are:\\n\"\n\t\t\t  \"[ -A ] [ -b ] [ -B ] [ -C ] [ -d ] [ -h ] [ -H ] [ -p ] [ -q ] [ -r ]\\n\"\n\t\t\t  \"[ -R ] [ -S ] [ -t ] [ -u [ ALL ] ] [ -v ] [ -V ] [ -w ] [ -W ] [ -y ]\\n\"\n\t\t\t  \"[ -I { <int> [,...] | SUM | ALL | XALL } ] [ -P { <cpu> [,...] | ALL } ]\\n\"\n\t\t\t  \"[ -m { <keyword> [,...] | ALL } ] [ -n { <keyword> [,...] | ALL } ]\\n\"\n\t\t\t  \"[ -o [ <filename> ] | -f [ <filename> ] ]\\n\"\n\t\t\t  \"[ -i <interval> ] [ -s [ <hh:mm:ss> ] ] [ -e [ <hh:mm:ss> ] ]\\n\"));\n\texit(1);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Display an error message. Happens when the data collector doesn't send\n * enough data.\n ***************************************************************************\n */\n", "func_signal": "void print_read_error(void)", "code": "{\n\tfprintf(stderr, _(\"End of data collecting unexpected\\n\"));\n\texit(3);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n ***************************************************************************\n * Read header data sent by sadc.\n ***************************************************************************\n */\n", "func_signal": "void read_header_data(void)", "code": "{\n\tstruct file_magic file_magic;\n\tstruct file_activity file_act;\n\tint rc, i, p;\n\tchar version[16];\n\n\t/* Read magic header */\n\trc = sa_read(&file_magic, FILE_MAGIC_SIZE);\n\n\tsprintf(version, \"%d.%d.%d.%d\",\n\t\tfile_magic.sysstat_version,\n\t\tfile_magic.sysstat_patchlevel,\n\t\tfile_magic.sysstat_sublevel,\n\t\tfile_magic.sysstat_extraversion);\n\tif (!file_magic.sysstat_extraversion) {\n\t\tversion[strlen(version) - 2] = '\\0';\n\t}\n\n\tif (rc || (file_magic.sysstat_magic != SYSSTAT_MAGIC) ||\n\t    (file_magic.format_magic != FORMAT_MAGIC) ||\n\t    strcmp(version, VERSION)) {\n\n\t\t/* sar and sadc commands are not consistent */\n\t\tfprintf(stderr, _(\"Invalid data format\\n\"));\n\n\t\tif (!rc && (file_magic.sysstat_magic == SYSSTAT_MAGIC)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Using a wrong data collector from a different sysstat version\\n\"));\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* Read header data */\n\tif (sa_read(&file_hdr, FILE_HEADER_SIZE)) {\n\t\tprint_read_error();\n\t}\n\t\n\t/* Read activity list */\n\tfor (i = 0; i < file_hdr.sa_nr_act; i++) {\n\t\t\n\t\tif (sa_read(&file_act, FILE_ACTIVITY_SIZE)) {\n\t\t\tprint_read_error();\n\t\t}\n\n\t\tp = get_activity_position(act, file_act.id);\n\n\t\tif ((p < 0) || (act[p]->fsize != file_act.size)\n\t\t\t    || !file_act.nr\n\t\t\t    || !file_act.nr2\n\t\t\t    || (act[p]->magic != file_act.magic)) {\n\t\t\t/* Remember that we are reading data from sadc and not from a file... */\n\t\t\tfprintf(stderr, _(\"Inconsistent input data\\n\"));\n\t\t\texit(3);\n\t\t}\n\n\t\tid_seq[i]   = file_act.id;\t/* We necessarily have \"i < NR_ACT\" */\n\t\tact[p]->nr  = file_act.nr;\n\t\tact[p]->nr2 = file_act.nr2;\n\t}\n\n\twhile (i < NR_ACT) {\n\t\tid_seq[i++] = 0;\n\t}\n\t\n\t/* Check that all selected activties are actually sent by sadc */\n\treverse_check_act(file_hdr.sa_nr_act);\n}", "path": "sar.c", "repo_name": "jahrome/sysstat-android", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 438}
{"docstring": "/*\n** Compare two states for sorting purposes.  The smaller state is the\n** one with the most non-terminal actions.  If they have the same number\n** of non-terminal actions, then the smaller is the one with the most\n** token actions.\n*/\n", "func_signal": "static int stateResortCompare(const void *a, const void *b)", "code": "{\n  const struct state *pA = *(const struct state**)a;\n  const struct state *pB = *(const struct state**)b;\n  int n;\n\n  n = pB->nNtAct - pA->nNtAct;\n  if( n==0 ){\n    n = pB->nTknAct - pA->nTknAct;\n  }\n  return n;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new associative array */\n", "func_signal": "void Configtable_init()", "code": "{\n  if( x4a ) return;\n  x4a = (struct s_x4*)malloc( sizeof(struct s_x4) );\n  if( x4a ){\n    x4a->size = 64;\n    x4a->count = 0;\n    x4a->tbl = (x4node*)malloc( \n      (sizeof(x4node) + sizeof(x4node*))*64 );\n    if( x4a->tbl==0 ){\n      free(x4a);\n      x4a = 0;\n    }else{\n      int i;\n      x4a->ht = (x4node**)&(x4a->tbl[64]);\n      for(i=0; i<64; i++) x4a->ht[i] = 0;\n    }\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new set */\n", "func_signal": "char *SetNew()", "code": "{\n  char *s;\n  s = (char*)calloc( size, 1);\n  if( s==0 ){\n    extern void memory_error();\n    memory_error();\n  }\n  return s;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/*\n** zCode is a string that is the action associated with a rule.  Expand\n** the symbols in this string so that the refer to elements of the parser\n** stack.\n*/\n", "func_signal": "PRIVATE void translate_code(struct lemon *lemp, struct rule *rp)", "code": "{\n  char *cp, *xp;\n  int i;\n  char lhsused = 0;    /* True if the LHS element has been used */\n  char used[MAXRHS];   /* True for each RHS element which is used */\n\n  for(i=0; i<rp->nrhs; i++) used[i] = 0;\n  lhsused = 0;\n\n  if( rp->code==0 ){\n    rp->code = \"\\n\";\n    rp->line = rp->ruleline;\n  }\n\n  append_str(0,0,0,0);\n  for(cp=rp->code; *cp; cp++){\n    if( isalpha(*cp) && (cp==rp->code || (!isalnum(cp[-1]) && cp[-1]!='_')) ){\n      char saved;\n      for(xp= &cp[1]; isalnum(*xp) || *xp=='_'; xp++);\n      saved = *xp;\n      *xp = 0;\n      if( rp->lhsalias && strcmp(cp,rp->lhsalias)==0 ){\n        append_str(\"yygotominor.yy%d\",0,rp->lhs->dtnum,0);\n        cp = xp;\n        lhsused = 1;\n      }else{\n        for(i=0; i<rp->nrhs; i++){\n          if( rp->rhsalias[i] && strcmp(cp,rp->rhsalias[i])==0 ){\n            if( cp!=rp->code && cp[-1]=='@' ){\n              /* If the argument is of the form @X then substituted\n              ** the token number of X, not the value of X */\n              append_str(\"yymsp[%d].major\",-1,i-rp->nrhs+1,0);\n            }else{\n              struct symbol *sp = rp->rhs[i];\n              int dtnum;\n              if( sp->type==MULTITERMINAL ){\n                dtnum = sp->subsym[0]->dtnum;\n              }else{\n                dtnum = sp->dtnum;\n              }\n              append_str(\"yymsp[%d].minor.yy%d\",0,i-rp->nrhs+1, dtnum);\n            }\n            cp = xp;\n            used[i] = 1;\n            break;\n          }\n        }\n      }\n      *xp = saved;\n    }\n    append_str(cp, 1, 0, 0);\n  } /* End loop */\n\n  /* Check to make sure the LHS has been used */\n  if( rp->lhsalias && !lhsused ){\n    ErrorMsg(lemp->filename,rp->ruleline,\n      \"Label \\\"%s\\\" for \\\"%s(%s)\\\" is never used.\",\n        rp->lhsalias,rp->lhs->name,rp->lhsalias);\n    lemp->errorcnt++;\n  }\n\n  /* Generate destructor code for RHS symbols which are not used in the\n  ** reduce code */\n  for(i=0; i<rp->nrhs; i++){\n    if( rp->rhsalias[i] && !used[i] ){\n      ErrorMsg(lemp->filename,rp->ruleline,\n        \"Label %s for \\\"%s(%s)\\\" is never used.\",\n        rp->rhsalias[i],rp->rhs[i]->name,rp->rhsalias[i]);\n      lemp->errorcnt++;\n    }else if( rp->rhsalias[i]==0 ){\n      if( has_destructor(rp->rhs[i],lemp) ){\n        append_str(\"  yy_destructor(%d,&yymsp[%d].minor);\\n\", 0,\n           rp->rhs[i]->index,i-rp->nrhs+1);\n      }else{\n        /* No destructor defined for this term */\n      }\n    }\n  }\n  if( rp->code ){\n    cp = append_str(0,0,0,0);\n    rp->code = Strsafe(cp?cp:\"\");\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new plink */\n", "func_signal": "struct plink *Plink_new()", "code": "{\n  struct plink *new;\n\n  if( plink_freelist==0 ){\n    int i;\n    int amt = 100;\n    plink_freelist = (struct plink *)calloc( amt, sizeof(struct plink) );\n    if( plink_freelist==0 ){\n      fprintf(stderr,\n      \"Unable to allocate memory for a new follow-set propagation link.\\n\");\n      exit(1);\n    }\n    for(i=0; i<amt-1; i++) plink_freelist[i].next = &plink_freelist[i+1];\n    plink_freelist[amt-1].next = 0;\n  }\n  new = plink_freelist;\n  plink_freelist = plink_freelist->next;\n  return new;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Return an array of pointers to all data in the table.\n** The array is obtained from malloc.  Return NULL if memory allocation\n** problems, or if the array is empty. */\n", "func_signal": "struct state **State_arrayof()", "code": "{\n  struct state **array;\n  int i,size;\n  if( x3a==0 ) return 0;\n  size = x3a->count;\n  array = (struct state **)malloc( sizeof(struct state *)*size );\n  if( array ){\n    for(i=0; i<size; i++) array[i] = x3a->tbl[i].data;\n  }\n  return array;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/*\n** Inputs:\n**   a:       A sorted, null-terminated linked list.  (May be null).\n**   b:       A sorted, null-terminated linked list.  (May be null).\n**   cmp:     A pointer to the comparison function.\n**   offset:  Offset in the structure to the \"next\" field.\n**\n** Return Value:\n**   A pointer to the head of a sorted list containing the elements\n**   of both a and b.\n**\n** Side effects:\n**   The \"next\" pointers for elements in the lists a and b are\n**   changed.\n*/\n", "func_signal": "static char *merge(\n  char *a,\n  char *b,\n  int (*cmp)(const char*,const char*),\n  int offset\n)", "code": "{\n  char *ptr, *head;\n\n  if( a==0 ){\n    head = b;\n  }else if( b==0 ){\n    head = a;\n  }else{\n    if( (*cmp)(a,b)<0 ){\n      ptr = a;\n      a = NEXT(a);\n    }else{\n      ptr = b;\n      b = NEXT(b);\n    }\n    head = ptr;\n    while( a && b ){\n      if( (*cmp)(a,b)<0 ){\n        NEXT(ptr) = a;\n        ptr = a;\n        a = NEXT(a);\n      }else{\n        NEXT(ptr) = b;\n        ptr = b;\n        b = NEXT(b);\n      }\n    }\n    if( a ) NEXT(ptr) = a;\n    else    NEXT(ptr) = b;\n  }\n  return head;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Sort the configuration list */\n", "func_signal": "void Configlist_sort()", "code": "{\n  current = (struct config *)msort((char *)current,(char **)&(current->next),Configcmp);\n  currentend = 0;\n  return;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new acttab structure */\n", "func_signal": "acttab *acttab_alloc(void)", "code": "{\n  acttab *p = calloc( 1, sizeof(*p) );\n  if( p==0 ){\n    fprintf(stderr,\"Unable to allocate memory for a new acttab.\");\n    exit(1);\n  }\n  memset(p, 0, sizeof(*p));\n  return p;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Initialized the configuration list builder */\n", "func_signal": "void Configlist_init()", "code": "{\n  current = 0;\n  currentend = &current;\n  basis = 0;\n  basisend = &basis;\n  Configtable_init();\n  return;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new associative array */\n", "func_signal": "void Symbol_init()", "code": "{\n  if( x2a ) return;\n  x2a = (struct s_x2*)malloc( sizeof(struct s_x2) );\n  if( x2a ){\n    x2a->size = 128;\n    x2a->count = 0;\n    x2a->tbl = (x2node*)malloc( \n      (sizeof(x2node) + sizeof(x2node*))*128 );\n    if( x2a->tbl==0 ){\n      free(x2a);\n      x2a = 0;\n    }else{\n      int i;\n      x2a->ht = (x2node**)&(x2a->tbl[128]);\n      for(i=0; i<128; i++) x2a->ht[i] = 0;\n    }\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/*\n** Append text to a dynamically allocated string.  If zText is 0 then\n** reset the string to be empty again.  Always return the complete text\n** of the string (which is overwritten with each call).\n**\n** n bytes of zText are stored.  If n==0 then all of zText up to the first\n** \\000 terminator is stored.  zText can contain up to two instances of\n** %d.  The values of p1 and p2 are written into the first and second\n** %d.\n**\n** If n==-1, then the previous character is overwritten.\n*/\n", "func_signal": "PRIVATE char *append_str(char *zText, int n, int p1, int p2)", "code": "{\n  static char *z = 0;\n  static int alloced = 0;\n  static int used = 0;\n  int c;\n  char zInt[40];\n\n  if( zText==0 ){\n    used = 0;\n    return z;\n  }\n  if( n<=0 ){\n    if( n<0 ){\n      used += n;\n      assert( used>=0 );\n    }\n    n = strlen(zText);\n  }\n  if( n+sizeof(zInt)*2+used >= alloced ){\n    alloced = n + sizeof(zInt)*2 + used + 200;\n    z = realloc(z,  alloced);\n  }\n  if( z==0 ) return \"\";\n  while( n-- > 0 ){\n    c = *(zText++);\n    if( c=='%' && n>0 && zText[0]=='d' ){\n      sprintf(zInt, \"%d\", p1);\n      p1 = p2;\n      strcpy(&z[used], zInt);\n      used += strlen(&z[used]);\n      zText++;\n      n--;\n    }else{\n      z[used++] = c;\n    }\n  }\n  z[used] = 0;\n  return z;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Print an action to the given file descriptor.  Return FALSE if\n** nothing was actually printed.\n*/\n", "func_signal": "int PrintAction(struct action *ap, FILE *fp, int indent)", "code": "{\n  int result = 1;\n  switch( ap->type ){\n    case SHIFT:\n      fprintf(fp,\"%*s shift  %d\",indent,ap->sp->name,ap->x.stp->statenum);\n      break;\n    case REDUCE:\n      fprintf(fp,\"%*s reduce %d\",indent,ap->sp->name,ap->x.rp->index);\n      break;\n    case ACCEPT:\n      fprintf(fp,\"%*s accept\",indent,ap->sp->name);\n      break;\n    case ERROR:\n      fprintf(fp,\"%*s error\",indent,ap->sp->name);\n      break;\n    case SRCONFLICT:\n    case RRCONFLICT:\n      fprintf(fp,\"%*s reduce %-3d ** Parsing conflict **\",\n        indent,ap->sp->name,ap->x.rp->index);\n      break;\n    case SSCONFLICT:\n      fprintf(fp,\"%*s shift  %d ** Parsing conflict **\", \n        indent,ap->sp->name,ap->x.stp->statenum);\n      break;\n    case SH_RESOLVED:\n    case RD_RESOLVED:\n    case NOT_USED:\n      result = 0;\n      break;\n  }\n  return result;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Return an array of pointers to all data in the table.\n** The array is obtained from malloc.  Return NULL if memory allocation\n** problems, or if the array is empty. */\n", "func_signal": "struct symbol **Symbol_arrayof()", "code": "{\n  struct symbol **array;\n  int i,size;\n  if( x2a==0 ) return 0;\n  size = x2a->count;\n  array = (struct symbol **)calloc(size, sizeof(struct symbol *));\n  if( array ){\n    for(i=0; i<size; i++) array[i] = x2a->tbl[i].data;\n  }\n  return array;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Compare two symbols for working purposes\n**\n** Symbols that begin with upper case letters (terminals or tokens)\n** must sort before symbols that begin with lower case letters\n** (non-terminals).  Other than that, the order does not matter.\n**\n** We find experimentally that leaving the symbols in their original\n** order (the order they appeared in the grammar file) gives the\n** smallest parser tables in SQLite.\n*/\n", "func_signal": "int Symbolcmpp(struct symbol **a, struct symbol **b)", "code": "{\n  int i1 = (**a).index + 10000000*((**a).name[0]>'Z');\n  int i2 = (**b).index + 10000000*((**b).name[0]>'Z');\n  return i1-i2;\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Max width of the prefix on each line */\n", "func_signal": "void ErrorMsg(const char *filename, int lineno, const char *format, ...)", "code": "{\n  char errmsg[ERRMSGSIZE];\n  char prefix[PREFIXLIMIT+10];\n  int errmsgsize;\n  int prefixsize;\n  int availablewidth;\n  va_list ap;\n  int end, restart, base;\n\n  va_start(ap, format);\n  /* Prepare a prefix to be prepended to every output line */\n  if( lineno>0 ){\n    sprintf(prefix,\"%.*s:%d: \",PREFIXLIMIT-10,filename,lineno);\n  }else{\n    sprintf(prefix,\"%.*s: \",PREFIXLIMIT-10,filename);\n  }\n  prefixsize = strlen(prefix);\n  availablewidth = LINEWIDTH - prefixsize;\n\n  /* Generate the error message */\n  vsprintf(errmsg,format,ap);\n  va_end(ap);\n  errmsgsize = strlen(errmsg);\n  /* Remove trailing '\\n's from the error message. */\n  while( errmsgsize>0 && errmsg[errmsgsize-1]=='\\n' ){\n     errmsg[--errmsgsize] = 0;\n  }\n\n  /* Print the error message */\n  base = 0;\n  while( errmsg[base]!=0 ){\n    end = restart = findbreak(&errmsg[base],0,availablewidth);\n    restart += base;\n    while( errmsg[restart]==' ' ) restart++;\n    fprintf(stdout,\"%s%.*s\\n\",prefix,end,&errmsg[base]);\n    base = restart;\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new associative array */\n", "func_signal": "void Strsafe_init()", "code": "{\n  if( x1a ) return;\n  x1a = (struct s_x1*)malloc( sizeof(struct s_x1) );\n  if( x1a ){\n    x1a->size = 1024;\n    x1a->count = 0;\n    x1a->tbl = (x1node*)malloc( \n      (sizeof(x1node) + sizeof(x1node*))*1024 );\n    if( x1a->tbl==0 ){\n      free(x1a);\n      x1a = 0;\n    }else{\n      int i;\n      x1a->ht = (x1node**)&(x1a->tbl[1024]);\n      for(i=0; i<1024; i++) x1a->ht[i] = 0;\n    }\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Run the proprocessor over the input file text.  The global variables\n** azDefine[0] through azDefine[nDefine-1] contains the names of all defined\n** macros.  This routine looks for \"%ifdef\" and \"%ifndef\" and \"%endif\" and\n** comments them out.  Text in between is also commented out as appropriate.\n*/\n", "func_signal": "static void preprocess_input(char *z)", "code": "{\n  int i, j, k, n;\n  int exclude = 0;\n  int start = 0;\n  int lineno = 1;\n  int start_lineno = 1;\n  for(i=0; z[i]; i++){\n    if( z[i]=='\\n' ) lineno++;\n    if( z[i]!='%' || (i>0 && z[i-1]!='\\n') ) continue;\n    if( strncmp(&z[i],\"%endif\",6)==0 && isspace(z[i+6]) ){\n      if( exclude ){\n        exclude--;\n        if( exclude==0 ){\n          for(j=start; j<i; j++) if( z[j]!='\\n' ) z[j] = ' ';\n        }\n      }\n      for(j=i; z[j] && z[j]!='\\n'; j++) z[j] = ' ';\n    }else if( (strncmp(&z[i],\"%ifdef\",6)==0 && isspace(z[i+6]))\n          || (strncmp(&z[i],\"%ifndef\",7)==0 && isspace(z[i+7])) ){\n      if( exclude ){\n        exclude++;\n      }else{\n        for(j=i+7; isspace(z[j]); j++){}\n        for(n=0; z[j+n] && !isspace(z[j+n]); n++){}\n        exclude = 1;\n        for(k=0; k<nDefine; k++){\n          if( strncmp(azDefine[k],&z[j],n)==0 && strlen(azDefine[k])==n ){\n            exclude = 0;\n            break;\n          }\n        }\n        if( z[i+3]=='n' ) exclude = !exclude;\n        if( exclude ){\n          start = i;\n          start_lineno = lineno;\n        }\n      }\n      for(j=i; z[j] && z[j]!='\\n'; j++) z[j] = ' ';\n    }\n  }\n  if( exclude ){\n    fprintf(stderr,\"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n    exit(1);\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Allocate a new associative array */\n", "func_signal": "void State_init()", "code": "{\n  if( x3a ) return;\n  x3a = (struct s_x3*)malloc( sizeof(struct s_x3) );\n  if( x3a ){\n    x3a->size = 128;\n    x3a->count = 0;\n    x3a->tbl = (x3node*)malloc( \n      (sizeof(x3node) + sizeof(x3node*))*128 );\n    if( x3a->tbl==0 ){\n      free(x3a);\n      x3a = 0;\n    }else{\n      int i;\n      x3a->ht = (x3node**)&(x3a->tbl[128]);\n      for(i=0; i<128; i++) x3a->ht[i] = 0;\n    }\n  }\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/* Free all memory associated with the given acttab */\n", "func_signal": "void acttab_free(acttab *p)", "code": "{\n  free( p->aAction );\n  free( p->aLookahead );\n  free( p );\n}", "path": "software\\lemon.c", "repo_name": "smtlaissezfaire/earing", "stars": 10, "license": "None", "language": "c", "size": 1865}
{"docstring": "/**\n\tInitialises the USB hardware\n\t\t\n\tThis function assumes that the hardware is connected as shown in\n\tsection 10.1 of the LPC2148 data sheet:\n\t* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.\n\t* P0.23 is connected to USB VCC.\n\t\n\tEmbedded artists board: make sure to disconnect P0.23 LED as it\n\tacts as a pull-up and so prevents detection of USB disconnect.\n\t\t\n\t@return TRUE if the hardware was successfully initialised\n */\n", "func_signal": "BOOL USBHwInit(void)", "code": "{\n#ifdef LPC214x\n\t\n\t// configure P0.23 for Vbus sense\n\tPINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);\t// P0.23\n\t// configure P0.31 for CONNECT\n\tPINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);\t// P0.31\n\n\t// enable PUSB\n\tPCONP |= (1 << 31);\t\t\n\n\t// initialise PLL\n\tPLL1CON = 1;\t\t\t// enable PLL\n\tPLL1CFG = (1 << 5) | 3; // P = 2, M = 4\n\tPLL1FEED = 0xAA;\n\tPLL1FEED = 0x55;\n\twhile ((PLL1STAT & (1 << 10)) == 0);\n\n\tPLL1CON = 3;\t\t\t// enable and connect\n\tPLL1FEED = 0xAA;\n\tPLL1FEED = 0x55;\n\n#endif\n\n#ifdef LPC23xx\n#ifdef LPC2378_PORTB\n\tPINSEL1 = (PINSEL1 & ~(3 << 30)) | (1 << 30);\n\tPINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);\n\t/* Due to a bug in the LPC23xx chips, the connection functionality must be\n\t* simulated using GPIO. Hopefully for production this will be fixed and the\n\t* commented out code will work */\n\t//PINSEL0 = (PINSEL0 & ~((3 << 26) | (3 << 28))) | (1 << 26) | (1 << 28); /* Doesn't work due to bug in chip */\n\tPINSEL0 = (PINSEL0 & ~((3 << 26) | (3 << 28))) | (1 << 26);\n\tFIO0DIR |= (1<<14); /* Set pin to output */\n\tFIO0SET = (1<<14); /* Set output high to disconnect */\n#else\n\tPINSEL1 = (PINSEL1 & ~((3 << 26) | (3 << 28))) | (1 << 26) | (1 << 28);\n\tPINSEL3 = (PINSEL3 & ~((3 << 4) | (3 << 28))) | (1 << 4) | (2 << 28);\n\t/* Due to a bug in the LPC23xx chips, the connection functionality must be\n\t* simulated using GPIO. Hopefully for production this will be fixed and the\n\t* commented out code will work */\n\t//PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18); /* Doesn't work due to bug in chip */\n\tPINSEL4 = (PINSEL4 & ~(3 << 18)); /* Use pin as GPIO */\n\tFIO2DIR |= (1<<9); /* Set pin to output */\n\tFIO2SET = (1<<9); /* Set output high to disconnect */\n#endif\n\n\t// enable PUSB\n\tPCONP |= (1 << 31);\t\t\n\n  /* The LPC23xx uses a single PLL, and has multiple clock dividers for each\n   * peripheral. These settings assume a PLL frequency of 288 MHz */\n\n\tUSBCLKCFG = 5; /* 288 MHz / 48 MHz = 6 */\n\n#ifdef LPC2378_PORTB\n\tUSBClkCtrl = (1 << 1) | (1 << 3) | (1 << 4); /* Enable the clocks */\n\twhile (!(USBClkSt & ((1 << 1) | (1 << 3) | (1 << 4))));\n\tUSBPortSel = 0x3; /* Set LPC to use USB Port B pins */\n#else\n\tUSBClkCtrl = (1 << 1) | (1 << 4); /* Enable the clocks */\n\twhile (!(USBClkSt & ((1 << 1) | (1 << 4))));\n#endif\n\n#endif\n\t\n\t// disable/clear all interrupts for now\n\tUSBDevIntEn = 0;\n\tUSBDevIntClr = 0xFFFFFFFF;\n\tUSBDevIntPri = 0;\n\n\tUSBEpIntEn = 0;\n\tUSBEpIntClr = 0xFFFFFFFF;\n\tUSBEpIntPri = 0;\n\n\t// by default, only ACKs generate interrupts\n\tUSBHwNakIntEnable(0);\n\t\n\t// init debug leds\n\tDEBUG_LED_INIT(8);\n\tDEBUG_LED_INIT(9);\n\tDEBUG_LED_INIT(10);\n\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to handle a standard interface request\n\t\t\n\t@param [in]\t\tpSetup\t\tThe setup packet\n\t@param [in,out]\t*piLen\t\tPointer to data length\n\t@param [in]\t\tppbData\t\tData buffer.\n\n\t@return TRUE if the request was handled successfully\n */\n", "func_signal": "static BOOL HandleStdInterfaceReq(TSetupPacket\t*pSetup, int *piLen, U8 **ppbData)", "code": "{\n\tU8\t*pbData = *ppbData;\n\n\tswitch (pSetup->bRequest) {\n\n\tcase REQ_GET_STATUS:\n\t\t// no bits specified\n\t\tpbData[0] = 0;\n\t\tpbData[1] = 0;\n\t\t*piLen = 2;\n\t\tbreak;\n\n\tcase REQ_CLEAR_FEATURE:\n\tcase REQ_SET_FEATURE:\n\t\t// not defined for interface\n\t\treturn FALSE;\n\t\n\tcase REQ_GET_INTERFACE:\t// TODO use bNumInterfaces\n        // there is only one interface, return n-1 (= 0)\n\t\tpbData[0] = 0;\n\t\t*piLen = 1;\n\t\tbreak;\n\t\n\tcase REQ_SET_INTERFACE:\t// TODO use bNumInterfaces\n\t\t// there is only one interface (= 0)\n\t\tif (pSetup->wValue != 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t\t*piLen = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tDBG(\"Illegal interface req %d\\n\", pSetup->bRequest);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbstdreq.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to stall the control endpoint\n\t\n\t@param [in]\tbEPStat\tEndpoint status\n */\n", "func_signal": "static void StallControlPipe(U8 bEPStat)", "code": "{\n\tU8\t*pb;\n\tint\ti;\n\n\tUSBHwEPStall(0x80, TRUE);\n\n// dump setup packet\n\tDBG(\"STALL on [\");\n\tpb = (U8 *)&Setup;\n\tfor (i = 0; i < 8; i++) {\n\t\tDBG(\" %02x\", *pb++);\n\t}\n\tDBG(\"] stat=%x\\n\", bEPStat);\n}", "path": "lpcusb\\target\\usbcontrol.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tWrites data to an endpoint buffer\n\t\t\n\t@param [in]\tbEP\t\tEndpoint number\n\t@param [in]\tpbBuf\tEndpoint data\n\t@param [in]\tiLen\tNumber of bytes to write\n\t\t\t\n\t@return TRUE if the data was successfully written or <0 in case of error.\n*/\n", "func_signal": "int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)", "code": "{\n\tint idx;\n\t\n\tidx = EP2IDX(bEP);\n\t\n\t// set write enable for specific endpoint\n\tUSBCtrl = WR_EN | ((bEP & 0xF) << 2);\n\t\n\t// set packet length\n\tUSBTxPLen = iLen;\n\t\n\t// write data\n\twhile (USBCtrl & WR_EN) {\n\t\tUSBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];\n\t\tpbBuf += 4;\n\t}\n\n\t// select endpoint and validate buffer\n\tUSBHwCmd(CMD_EP_SELECT | idx);\n\tUSBHwCmd(CMD_EP_VALIDATE_BUFFER);\n\t\n\treturn iLen;\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to send a command to the USB protocol engine and read data\n\t\t\n\t@param [in]\tbCmd\t\tCommand to send\n\n\t@return the data\n */\n", "func_signal": "static U8 USBHwCmdRead(U8 bCmd)", "code": "{\n\t// write command code\n\tUSBHwCmd(bCmd);\n\t\n\t// get data\n\tUSBCmdCode = 0x00000200 | (bCmd << 16);\n\tWait4DevInt(CDFULL);\n\treturn USBCmdData;\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tReads data from an endpoint buffer\n\t\t\n\t@param [in]\tbEP\t\tEndpoint number\n\t@param [in]\tpbBuf\tEndpoint data\n\t@param [in]\tiMaxLen\tMaximum number of bytes to read\n\t\t\t\n\t@return the number of bytes available in the EP (possibly more than iMaxLen),\n\tor <0 in case of error.\n */\n", "func_signal": "int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)", "code": "{\n\tint i, idx;\n\tU32\tdwData, dwLen;\n\t\n\tidx = EP2IDX(bEP);\n\t\n\t// set read enable bit for specific endpoint\n\tUSBCtrl = RD_EN | ((bEP & 0xF) << 2);\n\t\n\t// wait for PKT_RDY\n\tdo {\n\t\tdwLen = USBRxPLen;\n\t} while ((dwLen & PKT_RDY) == 0);\n\t\n\t// packet valid?\n\tif ((dwLen & DV) == 0) {\n\t\treturn -1;\n\t}\n\t\n\t// get length\n\tdwLen &= PKT_LNGTH_MASK;\n\t\n\t// get data\n\tdwData = 0;\n\tfor (i = 0; i < dwLen; i++) {\n\t\tif ((i % 4) == 0) {\n\t\t\tdwData = USBRxData;\n\t\t}\n\t\tif ((pbBuf != NULL) && (i < iMaxLen)) {\n\t\t\tpbBuf[i] = dwData & 0xFF;\n\t\t}\n\t\tdwData >>= 8;\n\t}\n\n\t// make sure RD_EN is clear\n\tUSBCtrl = 0;\n\n\t// select endpoint and clear buffer\n\tUSBHwCmd(CMD_EP_SELECT | idx);\n\tUSBHwCmd(CMD_EP_CLEAR_BUFFER);\n\t\n\treturn dwLen;\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tSends next chunk of data (possibly 0 bytes) to host\n */\n", "func_signal": "static void DataIn(void)", "code": "{\n\tint iChunk;\n\n\tiChunk = MIN(MAX_PACKET_SIZE0, iResidue);\n\tUSBHwEPWrite(0x80, pbData, iChunk);\n\tpbData += iChunk;\n\tiResidue -= iChunk;\n}", "path": "lpcusb\\target\\usbcontrol.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\t'Realizes' an endpoint, meaning that buffer space is reserved for\n\tit. An endpoint needs to be realised before it can be used.\n\t\t\n\tFrom experiments, it appears that a USB reset causes USBReEp to\n\tre-initialise to 3 (= just the control endpoints).\n\tHowever, a USB bus reset does not disturb the USBMaxPSize settings.\n\t\t\n\t@param [in]\tidx\t\t\tEndpoint index\n\t@param [in] wMaxPSize\tMaximum packet size for this endpoint\n */\n", "func_signal": "static void USBHwEPRealize(int idx, U16 wMaxPSize)", "code": "{\n\tUSBReEp |= (1 << idx);\n\tUSBEpInd = idx;\n\tUSBMaxPSize = wMaxPSize;\n\tWait4DevInt(EP_RLZED);\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tConfigures an endpoint and enables it\n\t\t\n\t@param [in]\tbEP\t\t\t\tEndpoint number\n\t@param [in]\twMaxPacketSize\tMaximum packet size for this EP\n */\n", "func_signal": "void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)", "code": "{\n\tint idx;\n\t\n\tidx = EP2IDX(bEP);\n\t\n\t// realise EP\n\tUSBHwEPRealize(idx, wMaxPacketSize);\n\n\t// enable EP\n\tUSBHwEPEnable(idx, TRUE);\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to wait for a device interrupt (and clear it)\n\t\t\n\t@param [in]\tdwIntr\t\tBitmask of interrupts to wait for\t\n */\n", "func_signal": "static void Wait4DevInt(U32 dwIntr)", "code": "{\n\t// wait for specific interrupt\n\twhile ((USBDevIntSt & dwIntr) != dwIntr);\n\t// clear the interrupt bits\n\tUSBDevIntClr = dwIntr;\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tRegisters the frame callback\n\t\t\n\t@param [in]\tpfnHandler\tCallback function\n */\n", "func_signal": "void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)", "code": "{\n\t_pfnFrameHandler = pfnHandler;\n\t\n\t// enable device interrupt\n\tUSBDevIntEn |= FRAME;\n\n\tDBG(\"Registered handler for frame\\n\");\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to handle a standard device request\n\t\t\n\t@param [in]\t\tpSetup\t\tThe setup packet\n\t@param [in,out]\t*piLen\t\tPointer to data length\n\t@param [in,out]\tppbData\t\tData buffer.\n\n\t@return TRUE if the request was handled successfully\n */\n", "func_signal": "static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)", "code": "{\n\tU8\t*pbData = *ppbData;\n\n\tswitch (pSetup->bRequest) {\n\t\n\tcase REQ_GET_STATUS:\n\t\t// bit 0: self-powered\n\t\t// bit 1: remote wakeup = not supported\n\t\tpbData[0] = 0;\n\t\tpbData[1] = 0;\n\t\t*piLen = 2;\n\t\tbreak;\n\t\t\n\tcase REQ_SET_ADDRESS:\n\t\tUSBHwSetAddress(pSetup->wValue);\n\t\tbreak;\n\n\tcase REQ_GET_DESCRIPTOR:\n\t\tDBG(\"D%x\", pSetup->wValue);\n\t\treturn USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);\n\n\tcase REQ_GET_CONFIGURATION:\n\t\t// indicate if we are configured\n\t\tpbData[0] = bConfiguration;\n\t\t*piLen = 1;\n\t\tbreak;\n\n\tcase REQ_SET_CONFIGURATION:\n\t\tif (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {\n\t\t\tDBG(\"USBSetConfiguration failed!\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t// configuration successful, update current configuration\n\t\tbConfiguration = pSetup->wValue & 0xFF;\t\n\t\tbreak;\n\n\tcase REQ_CLEAR_FEATURE:\n\tcase REQ_SET_FEATURE:\n\t\tif (pSetup->wValue == FEA_REMOTE_WAKEUP) {\n\t\t\t// put DEVICE_REMOTE_WAKEUP code here\n\t\t}\n\t\tif (pSetup->wValue == FEA_TEST_MODE) {\n\t\t\t// put TEST_MODE code here\n\t\t}\n\t\treturn FALSE;\n\n\tcase REQ_SET_DESCRIPTOR:\n\t\tDBG(\"Device req %d not implemented\\n\", pSetup->bRequest);\n\t\treturn FALSE;\n\n\tdefault:\n\t\tDBG(\"Illegal device req %d\\n\", pSetup->bRequest);\n\t\treturn FALSE;\n\t}\n\t\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbstdreq.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tGets the status from a specific endpoint.\n\t\t\n\t@param [in]\tbEP\t\tEndpoint number\n\t@return Endpoint status byte (containing EP_STATUS_xxx bits)\n */\n", "func_signal": "U8\tUSBHwEPGetStatus(U8 bEP)", "code": "{\n\tint idx = EP2IDX(bEP);\n\n\treturn USBHwCmdRead(CMD_EP_SELECT | idx);\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tUSB reset handler\n\t\n\t@param [in] bDevStatus\tDevice status\n */\n", "func_signal": "static void HandleUsbReset(U8 bDevStatus)", "code": "{\n\tif (bDevStatus & DEV_STATUS_RESET) {\n\t\tDBG(\"\\n!\");\n\t}\n}", "path": "lpcusb\\target\\usbinit.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to send a command to the USB protocol engine\n\t\t\n\t@param [in]\tbCmd\t\tCommand to send\n */\n", "func_signal": "static void USBHwCmd(U8 bCmd)", "code": "{\n\t// clear CDFULL/CCEMTY\n\tUSBDevIntClr = CDFULL | CCEMTY;\n\t// write command code\n\tUSBCmdCode = 0x00000500 | (bCmd << 16);\n\tWait4DevInt(CCEMTY);\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tConnects or disconnects from the USB bus\n\t\t\n\t@param [in]\tfConnect\tIf TRUE, connect, otherwise disconnect\n */\n", "func_signal": "void USBHwConnect(BOOL fConnect)", "code": "{\n#ifdef LPC23xx\n#ifndef LPC2378_PORTB\n  if(fConnect)\n    FIO2CLR = (1<<9);\n  else\n    FIO2SET = (1<<9);\n#else\n  if(fConnect)\n    FIO0CLR = (1<<14);\n  else\n    FIO0SET = (1<<14);\n#endif\n#endif\n\tUSBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tConfigures the device according to the specified configuration index and\n\talternate setting by parsing the installed USB descriptor list.\n\tA configuration index of 0 unconfigures the device.\n\t\t\n\t@param [in]\t\tbConfigIndex\tConfiguration index\n\t@param [in]\t\tbAltSetting\t\tAlternate setting number\n\t\n\t@todo function always returns TRUE, add stricter checking?\n\t\n\t@return TRUE if successfully configured, FALSE otherwise\n */\n", "func_signal": "static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)", "code": "{\n\tU8\t*pab;\n\tU8\tbCurConfig, bCurAltSetting;\n\tU8\tbEP;\n\tU16\twMaxPktSize;\n\t\n\tASSERT(pabDescrip != NULL);\n\n\tif (bConfigIndex == 0) {\n\t\t// unconfigure device\n\t\tUSBHwConfigDevice(FALSE);\n\t}\n\telse {\n\t\t// configure endpoints for this configuration/altsetting\n\t\tpab = (U8 *)pabDescrip;\n\t\tbCurConfig = 0xFF;\n\t\tbCurAltSetting = 0xFF;\n\n\t\twhile (pab[DESC_bLength] != 0) {\n\n\t\t\tswitch (pab[DESC_bDescriptorType]) {\n\n\t\t\tcase DESC_CONFIGURATION:\n\t\t\t\t// remember current configuration index\n\t\t\t\tbCurConfig = pab[CONF_DESC_bConfigurationValue];\n\t\t\t\tbreak;\n\n\t\t\tcase DESC_INTERFACE:\n\t\t\t\t// remember current alternate setting\n\t\t\t\tbCurAltSetting = pab[INTF_DESC_bAlternateSetting];\n\t\t\t\tbreak;\n\n\t\t\tcase DESC_ENDPOINT:\n\t\t\t\tif ((bCurConfig == bConfigIndex) &&\n\t\t\t\t\t(bCurAltSetting == bAltSetting)) {\n\t\t\t\t\t// endpoint found for desired config and alternate setting\n\t\t\t\t\tbEP = pab[ENDP_DESC_bEndpointAddress];\n\t\t\t\t\twMaxPktSize = \t(pab[ENDP_DESC_wMaxPacketSize]) |\n\t\t\t\t\t\t\t\t\t(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);\n\t\t\t\t\t// configure endpoint\n\t\t\t\t\tUSBHwEPConfig(bEP, wMaxPktSize);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// skip to next descriptor\n\t\t\tpab += pab[DESC_bLength];\n\t\t}\n\t\t\n\t\t// configure device\n\t\tUSBHwConfigDevice(TRUE);\n\t}\n\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbstdreq.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tInitialises the USB hardware and sets up the USB stack by\n\tinstalling default callbacks.\n\t\n\t@return TRUE if initialisation was successful\n */\n", "func_signal": "BOOL USBInit(void)", "code": "{\n\t// init hardware\n\tUSBHwInit();\n\t\n\t// register bus reset handler\n\tUSBHwRegisterDevIntHandler(HandleUsbReset);\n\t\n\t// register control transfer handler on EP0\n\tUSBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);\n\tUSBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);\n\t\n\t// setup control endpoints\n\tUSBHwEPConfig(0x00, MAX_PACKET_SIZE0);\n\tUSBHwEPConfig(0x80, MAX_PACKET_SIZE0);\n\t\n\t// register standard request handler\n\tUSBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);\n\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbinit.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tLocal function to handle a standard endpoint request\n\t\t\n\t@param [in]\t\tpSetup\t\tThe setup packet\n\t@param [in,out]\t*piLen\t\tPointer to data length\n\t@param [in]\t\tppbData\t\tData buffer.\n\n\t@return TRUE if the request was handled successfully\n */\n", "func_signal": "static BOOL HandleStdEndPointReq(TSetupPacket\t*pSetup, int *piLen, U8 **ppbData)", "code": "{\n\tU8\t*pbData = *ppbData;\n\n\tswitch (pSetup->bRequest) {\n\tcase REQ_GET_STATUS:\n\t\t// bit 0 = endpointed halted or not\n\t\tpbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;\n\t\tpbData[1] = 0;\n\t\t*piLen = 2;\n\t\tbreak;\n\t\t\n\tcase REQ_CLEAR_FEATURE:\n\t\tif (pSetup->wValue == FEA_ENDPOINT_HALT) {\n\t\t\t// clear HALT by unstalling\n\t\t\tUSBHwEPStall(pSetup->wIndex, FALSE);\n\t\t\tbreak;\n\t\t}\n\t\t// only ENDPOINT_HALT defined for endpoints\n\t\treturn FALSE;\n\t\n\tcase REQ_SET_FEATURE:\n\t\tif (pSetup->wValue == FEA_ENDPOINT_HALT) {\n\t\t\t// set HALT by stalling\n\t\t\tUSBHwEPStall(pSetup->wIndex, TRUE);\n\t\t\tbreak;\n\t\t}\n\t\t// only ENDPOINT_HALT defined for endpoints\n\t\treturn FALSE;\n\n\tcase REQ_SYNCH_FRAME:\n\t\tDBG(\"EP req %d not implemented\\n\", pSetup->bRequest);\n\t\treturn FALSE;\n\n\tdefault:\n\t\tDBG(\"Illegal EP req %d\\n\", pSetup->bRequest);\n\t\treturn FALSE;\n\t}\n\t\n\treturn TRUE;\n}", "path": "lpcusb\\target\\usbstdreq.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/**\n\tUSB interrupt handler\n\t\t\n\t@todo Get all 11 bits of frame number instead of just 8\n\n\tEndpoint interrupts are mapped to the slow interrupt\n */\n", "func_signal": "void USBHwISR(void)", "code": "{\n\tU32\tdwStatus;\n\tU32 dwIntBit;\n\tU8\tbEPStat, bDevStat, bStat;\n\tint i;\n\tU16\twFrame;\n\n// LED9 monitors total time in interrupt routine\nDEBUG_LED_ON(9);\n\n\t// handle device interrupts\n\tdwStatus = USBDevIntSt;\n\t\n\t// frame interrupt\n\tif (dwStatus & FRAME) {\n\t\t// clear int\n\t\tUSBDevIntClr = FRAME;\n\t\t// call handler\n\t\tif (_pfnFrameHandler != NULL) {\n\t\t\twFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);\n\t\t\t_pfnFrameHandler(wFrame);\n\t\t}\n\t}\n\t\n\t// device status interrupt\n\tif (dwStatus & DEV_STAT) {\n\t\t/*\tClear DEV_STAT interrupt before reading DEV_STAT register.\n\t\t\tThis prevents corrupted device status reads, see\n\t\t\tLPC2148 User manual revision 2, 25 july 2006.\n\t\t*/\n\t\tUSBDevIntClr = DEV_STAT;\n\t\tbDevStat = USBHwCmdRead(CMD_DEV_STATUS);\n\t\tif (bDevStat & (CON_CH | SUS_CH | RST)) {\n\t\t\t// convert device status into something HW independent\n\t\t\tbStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |\n\t\t\t\t\t((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |\n\t\t\t\t\t((bDevStat & RST) ? DEV_STATUS_RESET : 0);\n\t\t\t// call handler\n\t\t\tif (_pfnDevIntHandler != NULL) {\nDEBUG_LED_ON(8);\t\t\n\t\t\t\t_pfnDevIntHandler(bStat);\nDEBUG_LED_OFF(8);\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// endpoint interrupt\n\tif (dwStatus & EP_SLOW) {\n\t\t// clear EP_SLOW\n\t\tUSBDevIntClr = EP_SLOW;\n\t\t// check all endpoints\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tdwIntBit = (1 << i);\n\t\t\tif (USBEpIntSt & dwIntBit) {\n\t\t\t\t// clear int (and retrieve status)\n\t\t\t\tUSBEpIntClr = dwIntBit;\n\t\t\t\tWait4DevInt(CDFULL);\n\t\t\t\tbEPStat = USBCmdData;\n\t\t\t\t// convert EP pipe stat into something HW independent\n\t\t\t\tbStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |\n\t\t\t\t\t\t((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |\n\t\t\t\t\t\t((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |\n\t\t\t\t\t\t((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |\n\t\t\t\t\t\t((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);\n\t\t\t\t// call handler\n\t\t\t\tif (_apfnEPIntHandlers[i / 2] != NULL) {\nDEBUG_LED_ON(10);\t\t\n\t\t\t\t\t_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);\nDEBUG_LED_OFF(10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\nDEBUG_LED_OFF(9);\t\t\n}", "path": "lpcusb\\target\\usbhw_lpc.c", "repo_name": "mithris/lpc_jtag", "stars": 8, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n * Some copy_from_user() implementations do not return the exact number of\n * bytes remaining to copy on a fault.  But copy_mount_options() requires that.\n * Note that this function differs from copy_from_user() in that it will oops\n * on bad values of `to', rather than returning a short copy.\n */\n", "func_signal": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)", "code": "{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * recursively change the type of the mountpoint.\n */\n", "func_signal": "static int do_change_type(struct nameidata *nd, int flag)", "code": "{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * do loopback mount.\n */\n", "func_signal": "static int do_loopback(struct nameidata *nd, char *old_name, int recurse)", "code": "{\n\tstruct nameidata old_nd;\n\tstruct vfsmount *mnt = NULL;\n\tint err = mount_is_safe(nd);\n\tif (err)\n\t\treturn err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&namespace_sem);\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old_nd.mnt))\n \t\tgoto out;\n\n\tif (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tif (recurse)\n\t\tmnt = copy_tree(old_nd.mnt, old_nd.dentry, 0);\n\telse\n\t\tmnt = clone_mnt(old_nd.mnt, old_nd.dentry, 0);\n\n\tif (!mnt)\n\t\tgoto out;\n\n\terr = graft_tree(mnt, nd);\n\tif (err) {\n\t\tLIST_HEAD(umount_list);\n\t\tspin_lock(&vfsmount_lock);\n\t\tumount_tree(mnt, 0, &umount_list);\n\t\tspin_unlock(&vfsmount_lock);\n\t\trelease_mounts(&umount_list);\n\t}\n\nout:\n\tup_write(&namespace_sem);\n\tpath_release(&old_nd);\n\treturn err;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * find the first or last mount at @dentry on vfsmount @mnt depending on\n * @dir. If @dir is set return the first mount else return the last mount.\n */\n", "func_signal": "struct vfsmount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t      int dir)", "code": "{\n\tstruct list_head *head = mount_hashtable + hash(mnt, dentry);\n\tstruct list_head *tmp = head;\n\tstruct vfsmount *p, *found = NULL;\n\n\tfor (;;) {\n\t\ttmp = dir ? tmp->next : tmp->prev;\n\t\tp = NULL;\n\t\tif (tmp == head)\n\t\t\tbreak;\n\t\tp = list_entry(tmp, struct vfsmount, mnt_hash);\n\t\tif (p->mnt_parent == mnt && p->mnt_mountpoint == dentry) {\n\t\t\tfound = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/**\n * may_umount_tree - check if a mount tree is busy\n * @mnt: root of mount tree\n *\n * This is called to check if a tree of mounts has any\n * open files, pwds, chroots or sub mounts that are\n * busy.\n */\n", "func_signal": "int may_umount_tree(struct vfsmount *mnt)", "code": "{\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct vfsmount *p;\n\n\tspin_lock(&vfsmount_lock);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += atomic_read(&p->mnt_count);\n\t\tminimum_refs += 2;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * go through the vfsmounts we've just consigned to the graveyard to\n * - check that they're still dead\n * - delete the vfsmount from the appropriate namespace under lock\n * - dispose of the corpse\n */\n", "func_signal": "static void expire_mount_list(struct list_head *graveyard, struct list_head *mounts)", "code": "{\n\tstruct mnt_namespace *ns;\n\tstruct vfsmount *mnt;\n\n\twhile (!list_empty(graveyard)) {\n\t\tLIST_HEAD(umounts);\n\t\tmnt = list_first_entry(graveyard, struct vfsmount, mnt_expire);\n\t\tlist_del_init(&mnt->mnt_expire);\n\n\t\t/* don't do anything if the namespace is dead - all the\n\t\t * vfsmounts from it are going away anyway */\n\t\tns = mnt->mnt_ns;\n\t\tif (!ns || !ns->root)\n\t\t\tcontinue;\n\t\tget_mnt_ns(ns);\n\n\t\tspin_unlock(&vfsmount_lock);\n\t\tdown_write(&namespace_sem);\n\t\texpire_mount(mnt, mounts, &umounts);\n\t\tup_write(&namespace_sem);\n\t\trelease_mounts(&umounts);\n\t\tmntput(mnt);\n\t\tput_mnt_ns(ns);\n\t\tspin_lock(&vfsmount_lock);\n\t}\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * verify the new serial_struct (for TIOCSSERIAL).\n */\n", "func_signal": "static int ks8695uart_verify_port(struct uart_port *port, struct serial_struct *ser)", "code": "{\n\tint ret = 0;\n\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_KS8695)\n\t\tret = -EINVAL;\n\tif (ser->irq != port->irq)\n\t\tret = -EINVAL;\n\tif (ser->baud_base < 9600)\n\t\tret = -EINVAL;\n\treturn ret;\n}", "path": "drivers\\serial\\serial_ks8695.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * the caller must hold vfsmount_lock\n */\n", "func_signal": "static void commit_tree(struct vfsmount *mnt)", "code": "{\n\tstruct vfsmount *parent = mnt->mnt_parent;\n\tstruct vfsmount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\tlist_splice(&head, n->list.prev);\n\n\tlist_add_tail(&mnt->mnt_hash, mount_hashtable +\n\t\t\t\thash(parent, mnt->mnt_mountpoint));\n\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\ttouch_mnt_namespace(n);\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Ripoff of 'select_parent()'\n *\n * search the list of submounts for a given mountpoint, and move any\n * shrinkable submounts to the 'graveyard' list.\n */\n", "func_signal": "static int select_submounts(struct vfsmount *parent, struct list_head *graveyard)", "code": "{\n\tstruct vfsmount *this_parent = parent;\n\tstruct list_head *next;\n\tint found = 0;\n\nrepeat:\n\tnext = this_parent->mnt_mounts.next;\nresume:\n\twhile (next != &this_parent->mnt_mounts) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct vfsmount *mnt = list_entry(tmp, struct vfsmount, mnt_child);\n\n\t\tnext = tmp->next;\n\t\tif (!(mnt->mnt_flags & MNT_SHRINKABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Descend a level if the d_mounts list is non-empty.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_mounts)) {\n\t\t\tthis_parent = mnt;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (!propagate_mount_busy(mnt, 1)) {\n\t\t\tmntget(mnt);\n\t\t\tlist_move_tail(&mnt->mnt_expire, graveyard);\n\t\t\tfound++;\n\t\t}\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search\n\t */\n\tif (this_parent != parent) {\n\t\tnext = this_parent->mnt_child.next;\n\t\tthis_parent = this_parent->mnt_parent;\n\t\tgoto resume;\n\t}\n\treturn found;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Allocate a new namespace structure and populate it with contents\n * copied from the namespace of the passed in task structure.\n */\n", "func_signal": "static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,\n\t\tstruct fs_struct *fs)", "code": "{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL, *altrootmnt = NULL;\n\tstruct vfsmount *p, *q;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&new_ns->count, 1);\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\n\tdown_write(&namespace_sem);\n\t/* First pass: copy the tree topology */\n\tnew_ns->root = copy_tree(mnt_ns->root, mnt_ns->root->mnt_root,\n\t\t\t\t\tCL_COPY_ALL | CL_EXPIRE);\n\tif (!new_ns->root) {\n\t\tup_write(&namespace_sem);\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(-ENOMEM);;\n\t}\n\tspin_lock(&vfsmount_lock);\n\tlist_add_tail(&new_ns->list, &new_ns->root->mnt_list);\n\tspin_unlock(&vfsmount_lock);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = mnt_ns->root;\n\tq = new_ns->root;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (fs) {\n\t\t\tif (p == fs->rootmnt) {\n\t\t\t\trootmnt = p;\n\t\t\t\tfs->rootmnt = mntget(q);\n\t\t\t}\n\t\t\tif (p == fs->pwdmnt) {\n\t\t\t\tpwdmnt = p;\n\t\t\t\tfs->pwdmnt = mntget(q);\n\t\t\t}\n\t\t\tif (p == fs->altrootmnt) {\n\t\t\t\taltrootmnt = p;\n\t\t\t\tfs->altrootmnt = mntget(q);\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, mnt_ns->root);\n\t\tq = next_mnt(q, new_ns->root);\n\t}\n\tup_write(&namespace_sem);\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\tif (altrootmnt)\n\t\tmntput(altrootmnt);\n\n\treturn new_ns;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to\n * be given to the mount() call (ie: read-only, no-dev, no-suid etc).\n *\n * data is a (void *) that can point to any structure up to\n * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent\n * information (or be NULL).\n *\n * Pre-0.97 versions of mount() didn't have a flags word.\n * When the flags word was introduced its top half was required\n * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.\n * Therefore, if this magic number is present, it carries no information\n * and must be discarded.\n */\n", "func_signal": "long do_mount(char *dev_name, char *dir_name, char *type_page,\n\t\t  unsigned long flags, void *data_page)", "code": "{\n\tstruct nameidata nd;\n\tint retval = 0;\n\tint mnt_flags = 0;\n\n\t/* Discard magic */\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\t/* Basic sanity checks */\n\n\tif (!dir_name || !*dir_name || !memchr(dir_name, 0, PAGE_SIZE))\n\t\treturn -EINVAL;\n\tif (dev_name && !memchr(dev_name, 0, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (data_page)\n\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;\n\n\t/* Separate the per-mountpoint flags */\n\tif (flags & MS_NOSUID)\n\t\tmnt_flags |= MNT_NOSUID;\n\tif (flags & MS_NODEV)\n\t\tmnt_flags |= MNT_NODEV;\n\tif (flags & MS_NOEXEC)\n\t\tmnt_flags |= MNT_NOEXEC;\n\tif (flags & MS_NOATIME)\n\t\tmnt_flags |= MNT_NOATIME;\n\tif (flags & MS_NODIRATIME)\n\t\tmnt_flags |= MNT_NODIRATIME;\n\tif (flags & MS_RELATIME)\n\t\tmnt_flags |= MNT_RELATIME;\n\n\tflags &= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE |\n\t\t   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT);\n\n\t/* ... and get the mountpoint */\n\tretval = path_lookup(dir_name, LOOKUP_FOLLOW, &nd);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = security_sb_mount(dev_name, &nd, type_page, flags, data_page);\n\tif (retval)\n\t\tgoto dput_out;\n\n\tif (flags & MS_REMOUNT)\n\t\tretval = do_remount(&nd, flags & ~MS_REMOUNT, mnt_flags,\n\t\t\t\t    data_page);\n\telse if (flags & MS_BIND)\n\t\tretval = do_loopback(&nd, dev_name, flags & MS_REC);\n\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\tretval = do_change_type(&nd, flags);\n\telse if (flags & MS_MOVE)\n\t\tretval = do_move_mount(&nd, dev_name);\n\telse\n\t\tretval = do_new_mount(&nd, type_page, flags, mnt_flags,\n\t\t\t\t      dev_name, data_page);\ndput_out:\n\tpath_release(&nd);\n\treturn retval;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Configure/autoconfigure the port.\n */\n", "func_signal": "static void ks8695uart_config_port(struct uart_port *port, int flags)", "code": "{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_KS8695;\n\t\tks8695uart_request_port(port);\n\t}\n}", "path": "drivers\\serial\\serial_ks8695.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * add a mount into a namespace's mount tree\n * - provide the option of adding the new mount to an expiration list\n */\n", "func_signal": "int do_add_mount(struct vfsmount *newmnt, struct nameidata *nd,\n\t\t int mnt_flags, struct list_head *fslist)", "code": "{\n\tint err;\n\n\tdown_write(&namespace_sem);\n\t/* Something was mounted here while we slept */\n\twhile (d_mountpoint(nd->dentry) && follow_down(&nd->mnt, &nd->dentry))\n\t\t;\n\terr = -EINVAL;\n\tif (!check_mnt(nd->mnt))\n\t\tgoto unlock;\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (nd->mnt->mnt_sb == newmnt->mnt_sb &&\n\t    nd->mnt->mnt_root == nd->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))\n\t\tgoto unlock;\n\n\tnewmnt->mnt_flags = mnt_flags;\n\tif ((err = graft_tree(newmnt, nd)))\n\t\tgoto unlock;\n\n\tif (fslist) {\n\t\t/* add to the specified expiration list */\n\t\tspin_lock(&vfsmount_lock);\n\t\tlist_add_tail(&newmnt->mnt_expire, fslist);\n\t\tspin_unlock(&vfsmount_lock);\n\t}\n\tup_write(&namespace_sem);\n\treturn 0;\n\nunlock:\n\tup_write(&namespace_sem);\n\tmntput(newmnt);\n\treturn err;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Now umount can handle mount points as well as block devices.\n * This is important for filesystems which use unnamed block devices.\n *\n * We now support a flag for forced unmount like the other 'big iron'\n * unixes. Our API is identical to OSF/1 to avoid making a mess of AMD\n */\n", "func_signal": "asmlinkage long sys_umount(char __user * name, int flags)", "code": "{\n\tstruct nameidata nd;\n\tint retval;\n\n\tretval = __user_walk(name, LOOKUP_FOLLOW, &nd);\n\tif (retval)\n\t\tgoto out;\n\tretval = -EINVAL;\n\tif (nd.dentry != nd.mnt->mnt_root)\n\t\tgoto dput_and_out;\n\tif (!check_mnt(nd.mnt))\n\t\tgoto dput_and_out;\n\n\tretval = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto dput_and_out;\n\n\tretval = do_umount(nd.mnt, flags);\ndput_and_out:\n\tpath_release_on_umount(&nd);\nout:\n\treturn retval;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * change filesystem flags. dir should be a physical root of filesystem.\n * If you've mounted a non-root directory somewhere and want to do remount\n * on it - tough luck.\n */\n", "func_signal": "static int do_remount(struct nameidata *nd, int flags, int mnt_flags,\n\t\t      void *data)", "code": "{\n\tint err;\n\tstruct super_block *sb = nd->mnt->mnt_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!check_mnt(nd->mnt))\n\t\treturn -EINVAL;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&sb->s_umount);\n\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err)\n\t\tnd->mnt->mnt_flags = mnt_flags;\n\tup_write(&sb->s_umount);\n\tif (!err)\n\t\tsecurity_sb_post_remount(nd->mnt, flags, data);\n\treturn err;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/* iterator */\n", "func_signal": "static void *m_start(struct seq_file *m, loff_t *pos)", "code": "{\n\tstruct mnt_namespace *n = m->private;\n\n\tdown_read(&namespace_sem);\n\treturn seq_list_start(&n->list, *pos);\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * process a list of expirable mountpoints with the intent of discarding any\n * mountpoints that aren't in use and haven't been touched since last we came\n * here\n */\n", "func_signal": "void mark_mounts_for_expiry(struct list_head *mounts)", "code": "{\n\tstruct vfsmount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tspin_lock(&vfsmount_lock);\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t    atomic_read(&mnt->mnt_count) != 1)\n\t\t\tcontinue;\n\n\t\tmntget(mnt);\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\n\texpire_mount_list(&graveyard, mounts);\n\n\tspin_unlock(&vfsmount_lock);\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * Request the memory region(s) being used by 'port'\n */\n", "func_signal": "static int ks8695uart_request_port(struct uart_port *port)", "code": "{\n\treturn request_mem_region(port->mapbase, UART_PORT_SIZE,\n\t\t\t\"serial_ks8695\") != NULL ? 0 : -EBUSY;\n}", "path": "drivers\\serial\\serial_ks8695.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/*\n * create a new mount for userspace and request it to be added into the\n * namespace's tree\n */\n", "func_signal": "static int do_new_mount(struct nameidata *nd, char *type, int flags,\n\t\t\tint mnt_flags, char *name, void *data)", "code": "{\n\tstruct vfsmount *mnt;\n\n\tif (!type || !memchr(type, 0, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* we need capabilities... */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmnt = do_kern_mount(type, flags, name, data);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\treturn do_add_mount(mnt, nd, mnt_flags, NULL);\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/**\n * may_umount - check if a mount point is busy\n * @mnt: root of mount\n *\n * This is called to check if a mount point has any\n * open files, pwds, chroots or sub mounts. If the\n * mount has sub mounts this will return busy\n * regardless of whether the sub mounts are busy.\n *\n * Doesn't take quota and stuff into account. IOW, in some cases it will\n * give false negatives. The main reason why it's here is that we need\n * a non-destructive way to look for easily umountable filesystems.\n */\n", "func_signal": "int may_umount(struct vfsmount *mnt)", "code": "{\n\tint ret = 1;\n\tspin_lock(&vfsmount_lock);\n\tif (propagate_mount_busy(mnt, 2))\n\t\tret = 0;\n\tspin_unlock(&vfsmount_lock);\n\treturn ret;\n}", "path": "fs\\namespace.c", "repo_name": "leemgs/samsung-s3c6410-android.1.0", "stars": 11, "license": "other", "language": "c", "size": 67697}
{"docstring": "/***************************************************************************\n * CheckBox_SetOnCheckBoxHit()\n *\n * CheckBox message handler.\n * Sets the checkbox specific hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void CheckBox_SetOnHit(struct Box_s *checkbox, void (*pfunc)(struct Box_s *, int))", "code": "{\n\tstruct checkboxdata_s *data = checkbox->boxdata;\n\tdata->OnCheckBoxHit = pfunc;\n}", "path": "box\\checkbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * DragBox_OnLButtonUp()\n *\n * DragBox message handler.\n * \n * if the current state is DRAGGING, hide the drag image, end the drag, and\n * delete the image list.\n * \n ***************************************************************************/\n", "func_signal": "void DragBox_OnLButtonUp(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\t\n\tstruct dragboxdata_s *data = pbox->boxdata;\n\n\tif (data->state == DRAG_DRAGGING && !data->onspecialdrag)\n\t{\n\t\tint x, y;\n\t\tLog_Write(0, \"DragBox end 1 %d\\n\", pbox);\n\t\tBox_DragEnd(pbox);\n\n\t\tBox_GetScreenCoords(pbox, &x, &y);\n\t\tx += xmouse;\n\t\ty += ymouse;\n\t\tBox_HandleDragDrop(pbox, x, y, data->dragid, data->data, data->ondropempty);\n\t}\n\tdata->state = DRAG_NONE;\n\tBox_ReleaseMouse(pbox);\n\n\tBox_OnLButtonUp(pbox, xmouse, ymouse);\n}", "path": "box\\dragbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * DragBox_Create()\n *\n * Allocates and returns a new box and assigns DragBox message handlers.\n * \"x\", \"y\" indicate coordinates relative to parent.\n * \"w\", \"h\" indicate width and height.\n * \"flags\" are a bit field of characteristics of the new box.\n * \n ***************************************************************************/\n", "func_signal": "struct Box_s *DragBox_Create(int x, int y, int w, int h, enum Box_flags flags,\n\tint dragid, void *dragdata, void (*ondropempty)(struct Box_s *psrc,\n\tint xmouse, int ymouse, int id, void *data))", "code": "{\n\tstruct Box_s *pbox = Box_Create(x, y, w, h, flags);\n\tstruct dragboxdata_s *data = (struct dragboxdata_s *)malloc(sizeof(*data));\n\tmemset(data, 0, sizeof(*data));\n\t\n\tdata->state       = DRAG_NONE;\n\tdata->xstart      = 0;\n\tdata->ystart      = 0;\n\tdata->dragid      = dragid;\n\tdata->data        = dragdata;\n\tdata->ondropempty = ondropempty;\n\t\n\tpbox->OnLButtonDown = DragBox_OnLButtonDown;\n\tpbox->OnLButtonUp   = DragBox_OnLButtonUp;\n\tpbox->OnMouseMove   = DragBox_OnMouseMove;\n\tpbox->OnDestroy     = DragBox_OnDestroy;\n\tpbox->OnLoseMouseCapture = DragBox_OnLoseMouseCapture;\n\tpbox->boxdata = data;\n\n\treturn pbox;\n}", "path": "box\\dragbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button_SetOnButtonHit()\n *\n * Button message handler.\n * Sets the button specific hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void Button_SetOnButtonHit(struct Box_s *pbox, void (*pfunc)(struct Box_s *))", "code": "{\n\tstruct buttondata_s *data = pbox->boxdata;\n\tdata->OnButtonHit = pfunc;\n}", "path": "box\\button.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/* SHA1Init - Initialize new context */\n", "func_signal": "void SHA1Init(SHA1_CTX* context)", "code": "{\n    /* SHA1 initialization constants */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xEFCDAB89;\n    context->state[2] = 0x98BADCFE;\n    context->state[3] = 0x10325476;\n    context->state[4] = 0xC3D2E1F0;\n    context->count[0] = context->count[1] = 0;\n}", "path": "sha1.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * DragBox_OnLButtonDown()\n *\n * DragBox message handler.\n * Sets the drag to the LBUTTONDOWN state if the xmouse is within the box's\n * rectangle.\n * \n ***************************************************************************/\n", "func_signal": "void DragBox_OnLButtonDown(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct dragboxdata_s *data = pbox->boxdata;\n\n\tif (data->state == DRAG_DRAGGING)\n\t{\n\t\t/* somehow we're already dragging, so stop the drag */\n\t\tBox_DragEnd(pbox);\n\t\tdata->state = DRAG_NONE;\n\t\tBox_ReleaseMouse(pbox);\n\t\tBox_OnLButtonDown(pbox, xmouse, ymouse);\n\t\treturn;\n\t}\n\t\n\tif (!Box_CaptureMouse(pbox))\n\t{\n\t\treturn;\n\t}\n\n\tdata->state = DRAG_LBUTTONDOWN;\n\tdata->xstart = xmouse;\n\tdata->ystart = ymouse;\n\n\tBox_OnLButtonDown(pbox, xmouse, ymouse);\n}", "path": "box\\dragbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Box_OnMouseMove()\n *\n * DragBox message handler.\n *\n * If the current state is LBUTTONDOWN and the mouse has moved outside a\n * 10x10 square from the initial mouse down, create a hbitmap of the current\n * box, sets it to an image list, use BeginDrag() to start dragging the\n * image, and sets the state to DRAGGING.\n *\n * If the current state is DRAGGING, move the drag image to the cursor's\n * screen position.\n * \n ***************************************************************************/\n", "func_signal": "void DragBox_OnMouseMove(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct dragboxdata_s *data = pbox->boxdata;\n\t\n\tif (data->state == DRAG_LBUTTONDOWN)\n\t{\n\t\t/* Make sure the mouse button is down, in case we missed an lbuttonup. */\n\t\tif (GetAsyncKeyState(VK_LBUTTON) & 0x8000)\n\t\t{\n\t\t\tif (abs(data->xstart - xmouse) + abs(data->ystart - ymouse) > 5)\n\t\t\t{\n\t\t\t\tif (data->onspecialdrag)\n\t\t\t\t{\n\t\t\t\t\t/* special drag override, don't start dragging */\n\t\t\t\t\tBox_ReleaseMouse(pbox);\n\t\t\t\t\tdata->onspecialdrag(pbox, xmouse, ymouse);\n\t\t\t\t\tdata->state = DRAG_NONE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog_Write(0, \"DragBox start %d\\n\", pbox);\n\t\t\t\t\tBox_DragStart(pbox, xmouse, ymouse, data->dragid);\n\t\t\t\t\tdata->state = DRAG_DRAGGING;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata->state = DRAG_NONE;\n\t\t\tBox_ReleaseMouse(pbox);\n\t\t}\n\t}\n\n\tif (data->state == DRAG_DRAGGING && !data->onspecialdrag)\n\t{\n\t\t/* Make sure the mouse button is down, in case we missed an lbuttonup. */\n\t\tif (GetAsyncKeyState(VK_LBUTTON) & 0x8000)\n\t\t{\n\t\t\tint x, y;\n\t\n\t\t\tBox_GetScreenCoords(pbox, &x, &y);\n\t\t\tx += xmouse;\n\t\t\ty += ymouse;\n\n\t\t\tBox_DragMove(pbox, x, y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata->state = DRAG_NONE;\n\t\t\tBox_DragEnd(pbox);\n\t\t\tBox_ReleaseMouse(pbox);\n\t\t}\n\t}\n\n\tBox_OnMouseMove(pbox, xmouse, ymouse);\n}", "path": "box\\dragbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * CheckBox_OnLButtonDown()\n *\n * CheckBox message handler.\n * Records that the left mouse button was clicked here.\n * \n ***************************************************************************/\n", "func_signal": "void CheckBox_OnLButtonDown(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct checkboxdata_s *data = pbox->boxdata;\n\tdata->clicked = TRUE;\n\tCheckBox_SetState(pbox, BUTTON_PRESSED);\n}", "path": "box\\checkbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/* SAK */\n", "func_signal": "void SHAPrintContext(SHA1_CTX *context, char *msg)", "code": "{\n  printf(\"%s (%d,%d) %x %x %x %x %x\\n\",\n\t msg,\n\t context->count[0], context->count[1], \n\t context->state[0],\n\t context->state[1],\n\t context->state[2],\n\t context->state[3],\n\t context->state[4]);\n}", "path": "sha1.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button2_OnLButtonDown()\n *\n * Button2 message handler.\n * Records that the left mouse button2 was clicked here.\n * \n ***************************************************************************/\n", "func_signal": "void Button2_OnLButtonDown(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct button2data_s *data = pbox->boxdata;\n\tif (data->state == BUTTON2_DISABLED)\n\t{\n\t\treturn;\n\t}\n\tdata->clicked = TRUE;\n\tButton2_SetState(pbox, BUTTON2_PRESSED);\n}", "path": "box\\button2.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button2_SetOnButtonHit()\n *\n * Button2 message handler.\n * Sets the button2 specific hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void Button2_SetOnButtonHit(struct Box_s *pbox, void (*pfunc)(struct Box_s *))", "code": "{\n\tstruct button2data_s *data = pbox->boxdata;\n\tdata->OnButtonHit = pfunc;\n}", "path": "box\\button2.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * CheckBox_Create()\n *\n * Allocates and returns a new box and assigns CheckBox message handlers and \n * data.\n * \"x\", \"y\" indicate coordinates relative to parent.\n * \"w\", \"h\" indicate width and height.\n * \"flags\" are a bit field of characteristics of the new box.\n * \n ***************************************************************************/\n", "func_signal": "struct Box_s *CheckBox_Create(int x, int y, enum Box_flags flags)", "code": "{\n\tstruct Box_s *checkbox;\n\tstruct checkboxdata_s *data = malloc(sizeof(*data));\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->enabled = 1;\n\n\tcheckbox = Box_Create(x, y, 13, 13, flags);\n\tcheckbox->OnLButtonDown = CheckBox_OnLButtonDown;\n\tcheckbox->OnMouseMove     = CheckBox_OnMouseMove;\n\tcheckbox->OnLButtonUp   = CheckBox_OnLButtonUp;\n\tcheckbox->boxdata = data;\n\n\tCheckBox_UpdateImages(checkbox);\n\n\treturn checkbox;\n}", "path": "box\\checkbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */\n", "func_signal": "static int fmtint (char *buffer, size_t *currlen, size_t maxlen,\n\t\t   long value, int base, int min, int max, int flags)", "code": "{\n  int signvalue = 0;\n  unsigned long uvalue;\n  char convert[20];\n  int place = 0;\n  int spadlen = 0; /* amount to space pad */\n  int zpadlen = 0; /* amount to zero pad */\n  int caps = 0;\n  int total = 0;\n  \n  if (max < 0)\n    max = 0;\n\n  uvalue = value;\n\n  if(!(flags & DP_F_UNSIGNED))\n  {\n    if( value < 0 ) {\n      signvalue = '-';\n      uvalue = -value;\n    }\n    else\n      if (flags & DP_F_PLUS)  /* Do a sign (+/i) */\n\tsignvalue = '+';\n    else\n      if (flags & DP_F_SPACE)\n\tsignvalue = ' ';\n  }\n  \n  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */\n\n  do {\n    convert[place++] =\n      (caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n      [uvalue % (unsigned)base  ];\n    uvalue = (uvalue / (unsigned)base );\n  } while(uvalue && (place < 20));\n  if (place == 20) place--;\n  convert[place] = 0;\n\n  zpadlen = max - place;\n  spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n  if (zpadlen < 0) zpadlen = 0;\n  if (spadlen < 0) spadlen = 0;\n  if (flags & DP_F_ZERO)\n  {\n    zpadlen = MAX(zpadlen, spadlen);\n    spadlen = 0;\n  }\n  if (flags & DP_F_MINUS) \n    spadlen = -spadlen; /* Left Justifty */\n\n#ifdef DEBUG_SNPRINTF\n  dprint (1, (debugfile, \"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n      zpadlen, spadlen, min, max, place));\n#endif\n\n  /* Spaces */\n  while (spadlen > 0) \n  {\n    total += dopr_outch (buffer, currlen, maxlen, ' ');\n    --spadlen;\n  }\n\n  /* Sign */\n  if (signvalue) \n    total += dopr_outch (buffer, currlen, maxlen, signvalue);\n\n  /* Zeros */\n  if (zpadlen > 0) \n  {\n    while (zpadlen > 0)\n    {\n      total += dopr_outch (buffer, currlen, maxlen, '0');\n      --zpadlen;\n    }\n  }\n\n  /* Digits */\n  while (place > 0) \n    total += dopr_outch (buffer, currlen, maxlen, convert[--place]);\n  \n  /* Left Justified spaces */\n  while (spadlen < 0) {\n    total += dopr_outch (buffer, currlen, maxlen, ' ');\n    ++spadlen;\n  }\n\n  return total;\n}", "path": "common\\snprintf.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * CheckBox_OnLButtonUp()\n *\n * CheckBox message handler.\n * If the checkbox was previously clicked and the mouse is still over the\n * box, call the checkbox hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void CheckBox_OnLButtonUp(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct checkboxdata_s *data = pbox->boxdata;\n\tif (xmouse >= 0 && ymouse >= 0 && xmouse < pbox->w && ymouse < pbox->h\n\t\t&& data->clicked)\n\t{\n\t\tCheckBox_Trigger(pbox);\n\t}\n\tdata->clicked = FALSE;\n\n\tCheckBox_SetState(pbox, BUTTON_NORMAL);\n\tCheckBox_UpdateImages(pbox);\n}", "path": "box\\checkbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button_OnLButtonUp()\n *\n * Button message handler.\n * If the button was previously clicked and the mouse is still over the\n * box, call the button hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void Button_OnLButtonUp(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct buttondata_s *data = pbox->boxdata;\n\n\tif (data->state == BUTTON_DISABLED)\n\t{\n\t\treturn;\n\t}\n\n\tif (xmouse >= 0 && ymouse >= 0 && xmouse < pbox->w && ymouse < pbox->h\n\t\t&& data->clicked)\n\t{\n\t\tButton_Trigger(pbox);\n\t}\n\tdata->clicked = FALSE;\n\tButton_SetState(pbox, BUTTON_NORMAL);\n}", "path": "box\\button.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button_OnLButtonDown()\n *\n * Button message handler.\n * Records that the left mouse button was clicked here.\n * \n ***************************************************************************/\n", "func_signal": "void Button_OnLButtonDown(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct buttondata_s *data = pbox->boxdata;\n\tif (data->state == BUTTON_DISABLED)\n\t{\n\t\treturn;\n\t}\n\tdata->clicked = TRUE;\n\tButton_SetState(pbox, BUTTON_PRESSED);\n}", "path": "box\\button.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/*\nvoid EditCustomTimes_OnSave(struct Box_s *pbox)\n{\n\tstruct Box_s *dialog = Box_GetRoot(pbox);\n\tstruct editcustomtimesdata_s *data = pbox->parent->boxdata;\n\t\n\tif (data->refreshCallback)\n\t{\n\t\tdata->refreshCallback(data->parent);\n\t}\n\n\tBox_Destroy(dialog);\n}\n*/\n", "func_signal": "void EditCustomTimes_OnOK(struct Box_s *pbox)", "code": "{\n\tstruct Box_s *dialog = Box_GetRoot(pbox);\n\tstruct editcustomtimesdata_s *data = dialog->boxdata;\n\n\tBox_Destroy(dialog);\n}", "path": "editcustomtimes.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Box_GetDragState()\n *\n * Returns the current drag state of this DragBox.\n * \n ***************************************************************************/\n", "func_signal": "int DragBox_GetDragState(struct Box_s *pbox)", "code": "{\n\tstruct dragboxdata_s *data = pbox->boxdata;\n\treturn data->state;\n}", "path": "box\\dragbox.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button2_OnLButtonUp()\n *\n * Button2 message handler.\n * If the button2 was previously clicked and the mouse is still over the\n * box, call the button2 hit callback.\n * \n ***************************************************************************/\n", "func_signal": "void Button2_OnLButtonUp(struct Box_s *pbox, int xmouse, int ymouse)", "code": "{\n\tstruct button2data_s *data = pbox->boxdata;\n\n\tif (data->state == BUTTON2_DISABLED)\n\t{\n\t\treturn;\n\t}\n\n\tif (xmouse >= 0 && ymouse >= 0 && xmouse < pbox->w && ymouse < pbox->h\n\t\t&& data->clicked)\n\t{\n\t\tButton2_SetState(pbox, BUTTON2_NORMAL);\n\t\tif (data->OnButtonHit2)\n\t\t{\n\t\t\tdata->OnButtonHit2(pbox, data->userdata);\n\t\t}\n\t\telse if (data->OnButtonHit)\n\t\t{\n\t\t\tdata->OnButtonHit(pbox);\n\t\t}\n\t}\n\tdata->clicked = FALSE;\n}", "path": "box\\button2.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/***************************************************************************\n * Button_Create()\n *\n * Allocates and returns a new box and assigns Button message handlers and \n * data.\n * \"x\", \"y\" indicate coordinates relative to parent.\n * \"w\", \"h\" indicate width and height.\n * \"flags\" are a bit field of characteristics of the new box.\n * \n ***************************************************************************/\n", "func_signal": "struct Box_s *Button_Create(int x, int y, int w, int h, enum Box_flags flags)", "code": "{\n\tstruct Box_s *button;\n\tstruct buttondata_s *data = malloc(sizeof(*data));\n\tmemset(data, 0, sizeof(*data));\n\n\tbutton = Box_Create(x, y, w, h, flags);\n\tbutton->OnLButtonDown = Button_OnLButtonDown;\n\tbutton->OnMouseMove   = Button_OnMouseMove;\n\tbutton->OnLButtonUp   = Button_OnLButtonUp;\n\tbutton->OnDestroy     = Button_OnDestroy;\n\tbutton->boxdata = data;\n\n\treturn button;\n}", "path": "box\\button.c", "repo_name": "twonds/chesspark", "stars": 9, "license": "other", "language": "c", "size": 2488}
{"docstring": "/* xsb_thread_create */\n", "func_signal": "static int xsb_thread_create(th_context *th, int glsize, int tcsize, int complsize,int pdlsize,\n\t\t\t     int is_detached, int is_aliased)", "code": "{\n  Cell goal ;\n  Integer pos ;\n       \n  goal = iso_ptoc_callable(th, 2,\"thread_create/[2,3]\");\n\n  pos = xsb_thread_setup(th,  is_detached, is_aliased);\n  return xsb_thread_create_1(th,goal, glsize, tcsize, complsize,pdlsize,is_detached,pos);\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*----------------------------------------------------------------------*/\n/*  find_independent_scc(ComplStackFrame)\t\t\t\t*/\n/*\tFinds the subgoals in the same SCC as the subgoal that is\t*/\n/*\tgiven as input.  The subgoals are indicated by marking the\t*/\n/*\t\"visited\" field of their completion stack frame.\t\t*/\n/*----------------------------------------------------------------------*/\n", "func_signal": "void find_independent_scc(ComplStackFrame u)", "code": "{\n    EPtr eptr;\n\n    compl_visited(u) = TRUE;\n    for (eptr=compl_DG_edges(u); eptr != NULL; eptr=next_edge(eptr)) {\n      if (!compl_visited(edge_to_node(eptr)))\n\tfind_independent_scc(edge_to_node(eptr));\n    }\n}", "path": "emu\\scc_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* calls _$thread_run/1 in thread.P */\n", "func_signal": "static void *ccall_xsb_thread_run( void *arg )", "code": "{\n        pthread_t tid;\n\tCPtr term_ptr;\n\tth_context *ctxt = (th_context *)arg ;\n        int pos = THREAD_ENTRY(ctxt->tid) ;\n\n\tpthread_mutex_lock( &th_mutex );\n        SYS_MUTEX_INCR( MUTEX_THREADS ) ;\n\ttid = pthread_self();\n/* if the xsb thread id was just created we need to re-initialize \n   thread pthread id on the thread table */\n        th_vec[pos].tid = tid ;\n        th_vec[pos].valid = TRUE ;\n        pthread_mutex_unlock( &th_mutex );\n\n\tpthread_mutex_lock( &ctxt->_xsb_synch_mut ) ;\n\n\tterm_ptr = ctxt->_hreg;\n\tbld_functor((ctxt->_hreg)++,get_ret_psc(0));\n\tbld_cs(((ctxt->_reg)+1), ((Cell)term_ptr));\n\n\temuloop( ctxt, get_ep(c_callloop_psc)) ;\n\t//\tfprintf(stderr,\"exiting emuloop\\n\");\n\n\t//\tprintf(\"exiting thread\\n\");\n\n\treturn NULL ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* Note that this function does not need to check whether a given\n   subgoal is completed -- that has already been checked by\n   add_ascc_edges() in construct_dep_graph() */\n", "func_signal": "static void DFS_DGT_visit(ComplStackFrame u)", "code": "{\n    EPtr eptr;\n\n    compl_visited(u) = TRUE;\n    for (eptr=compl_DGT_edges(u); eptr != NULL; eptr=next_edge(eptr)) {\n      if (!compl_visited(edge_to_node(eptr)))\n\tDFS_DGT_visit(edge_to_node(eptr));\n    }\n}", "path": "emu\\scc_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* Need to make sure that owner is not over-written falsely.  This one\n   is for user mutexes.*/\n", "func_signal": "void unlock_mutex(CTXTdeclc DynMutPtr id)", "code": "{\n\n  Integer rc ;\n\n  if ( id->owner == xsb_thread_id) \n    id->owner = -1;\n  \n  rc = pthread_mutex_unlock( &(id->th_mutex) ) ;\n  if (rc == EINVAL) {\n    xsb_permission_error(CTXTc \"unlock mutex\",\"invalid mutex\",\n\t\t\t xsb_thread_id,\"xsb_mutex_unlock\",2); \n  } else if (rc == EPERM) { \n    xsb_permission_error(CTXTc \"unlock mutex\",\n\t\t\t \"mutex not held by thread\",\n\t\t\t xsb_thread_id,\"xsb_mutex_unlock\",2); \n  } \n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* MULTI_THREAD */\n", "func_signal": "int xsb_thread_self()", "code": "{\n#ifdef MULTI_THREAD\n\tint pos, id;\n        pthread_t tid = pthread_self();\n\n\tif( !threads_initialized )\n\t\treturn 0 ;\n\n        pthread_mutex_lock( &th_mutex );\n        SYS_MUTEX_INCR( MUTEX_THREADS ) ;\n        id = pos = th_find( P_PTHREAD_T_P ) ;\n        pthread_mutex_unlock( &th_mutex );\n\n\tif( pos >= 0 )\n\t\tSET_THREAD_INCARN( id, th_vec[pos].incarn ) ;\n#ifdef DEBUG\n\telse \n\t\traise( SIGSEGV ) ;\n#endif\n\n\treturn id;\n#else\n\treturn 0;\n#endif\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*\n * Restores the state of a trie search to the point from which insertion\n * is to begin.  This includes readying the term stack with the remaining\n * portion of the term set, restandardizing any variables already\n * encountered, and noting these bindings on the trail.\n */\n", "func_signal": "void *stl_restore_variant_cont(CTXTdecl)", "code": "{\n\n  int i;\n\n  TermStack_ResetTOS;\n  TermStack_PushArray(variant_cont.subterms.stack.ptr,\n\t\t      variant_cont.subterms.num);\n\n  Trail_ResetTOS;\n  for (i = 0; i < (int) variant_cont.bindings.num; i++) {\n    Trail_Push(variant_cont.bindings.stack.ptr[i].var);\n    bld_ref(variant_cont.bindings.stack.ptr[i].var,\n\t    variant_cont.bindings.stack.ptr[i].value);\n  }\n  return (variant_cont.last_node_matched);\n}", "path": "emu\\trie_lookup.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* print_inst */\n", "func_signal": "void dis_text(FILE * filedes)", "code": "{\n   pseg   this_seg;\n   pindex index_seg ;\n   CPtr   endaddr, inst_addr2 ;\n   int comma;\n\n   fprintf(filedes, \"\\n/*text below\\t\\t*/\\n\\n\");\n   this_seg = (pseg) inst_begin_gl;\n   while (this_seg) {\t\t/* repeat for all text segment */\n      fprintf(filedes, \"segment([\\n\");\n      endaddr = (CPtr) ((pb) seg_hdr(this_seg) + seg_size(this_seg)) ;\n      inst_addr2 = seg_text(this_seg);\n      comma = 0;\n      while (inst_addr2<endaddr) {\n\tif (comma) \n\t  fprintf(filedes,\", \\n\");\n\tcomma = 1;\n\tinst_addr2 = print_inst(filedes, inst_addr2);\n      }\n      index_seg = seg_index(this_seg);\n      while (index_seg) {\n\tinst_addr2 = i_block(index_seg);\n\tendaddr = (CPtr)((pb)index_seg + i_size(index_seg));\n\tif (cell_opcode(i_block(index_seg)) == try ||\n            cell_opcode(i_block(index_seg)) == tabletry ||\n\t    cell_opcode(i_block(index_seg)) == tabletrysingle) {\t\n\t                                           /* is try/retry/trust */\n\t  while (inst_addr2<endaddr) {\n\t    if (comma) \n\t      fprintf(filedes,\", \\n\");\n\t    comma = 1;\n\t    inst_addr2 = print_inst(filedes, inst_addr2);\n\t  }\n\t} else {\t\t\t\t\t/* is hash table */\n\t  if (comma) \n\t    fprintf(filedes,\", \\n\");\n\t  fprintf(filedes, \"     hash_table([\\n\");\n\t  comma = 0;\n\t  while (inst_addr2<endaddr) {\n\t    if (comma) {\n\t      fprintf(filedes, \", \\n\");\n\t    }\n\t    comma = 1;\n\t    fprintf(filedes, \n\t\t    \"          hash_entry(%p,%lx)\", \n\t\t    inst_addr2, \n\t\t    cell(inst_addr2));\n\t    inst_addr2 ++;\n\t  }\n\t  fprintf(filedes, \"])\");\n\t}\n\tindex_seg = i_next(index_seg);\n      }\n      fprintf(filedes, \"]).\\n\");\n      this_seg = seg_next(this_seg);\n   }  \n}", "path": "emu\\dis.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* This just unlocks the user mutexes held by a thread -- the name\n   comes from the ISO document. */\n", "func_signal": "void mutex_unlock_all(CTXTdecl)", "code": "{\n  DynMutPtr dmp = dynmut_chain_begin;\n  while (dmp != NULL) {\n    if (dmp-> owner == xsb_thread_id) {\n      //      printf(\"unlocking all %p\\n\",dmp);\n      while (dmp->num_locks > 0) {\n\tunlock_mutex(CTXTc dmp);\n\tdmp->num_locks--;\n      }\n    }\n    dmp = dmp->next_dynmut;\n  }\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*\n * Searches a branch of a NON-EMPTY trie for a path which subsumes a\n * given set of terms.  The branch is identified by a non-NULL pointer\n * to a trie node which roots the branch.  The terms, which are stored\n * on the Termstack, are compared against the symbols in the nodes lying\n * BELOW the given node.  If a subsuming path is discovered, then\n * returns a pointer to the leaf identifying the path, otherwise returns\n * NULL.  The last argument describes the relationship between the\n * discovered path, if any, and the given terms.\n *\n * In addition to the TermStack, the following structures should also be\n * primed for use: tstTermStackLog, tstTrail, TrieVarBindings[], and\n * VarEnumerator[].\n */\n", "func_signal": "static BTNptr rec_sub_trie_lookup(CTXTdeclc BTNptr parent, TriePathType *pathType)", "code": "{\n\n  Cell subterm, symbol;\n  BTNptr cur, match, var, leaf;\n  int arity, trievar_index;\n  CPtr args;\n\n\n#ifdef DEBUG_ASSERTIONS\n  if ( IsNULL(parent) )\n    TrieError_InterfaceInvariant(\"rec_sub_trie_lookup\");\n#endif\n\n  /*\n   * Base Case:\n   * ---------\n   * We've paired a subterm with a term in the trie.  How this trie\n   * term relates to the subterm will be set as we unroll the\n   * recursion.  Return a handle for this trie term.\n   */\n  if ( TermStack_IsEmpty ) {\n#ifdef DEBUG_ASSERTIONS\n    if ( ! IsLeafNode(parent) )\n      TrieError_TooFewTerms(\"rec_sub_trie_lookup\");\n    xsb_dbgmsg((LOG_TRIE, \"Base case: empty TermStack\"));\n#endif\n    return parent;\n  }\n\n#ifdef DEBUG_ASSERTIONS\n  if ( IsLeafNode(parent) )\n    TrieError_TooManyTerms(\"rec_sub_trie_lookup\");\n#endif\n\n  /*\n   * Recursive Case:\n   * --------------\n   * Find a pairing of the next subterm on the TermStack with a symbol\n   * in the trie below 'parent.'  If one is found, then recurse.\n   * Otherwise, signal the failure of the exploration of this branch\n   * by returning NULL.\n   */\n  xsb_dbgmsg((LOG_TRIE, \"Recursive case:\"));\n  TermStack_Pop(subterm);\n  TermStackLog_PushFrame;\n  XSB_Deref(subterm);\n  if ( isref(subterm) ) {\n\n    /* Handle Call Variables\n       ===================== */\n\n    if ( IsHashHeader(BTN_Child(parent)) )\n      var = BTHT_BucketArray(BTN_GetHashHdr(parent))[TRIEVAR_BUCKET];\n    else\n      var = BTN_Child(parent);\n\n    if ( ! IsStandardizedVariable(subterm) ) {\n      xsb_dbgmsg((LOG_TRIE,\"  Found new call variable: \"));\n\n      /*\n       * Pair this free call variable with a new trie variable (there is at\n       * most one of these among a set of child nodes).  Mark the call var to\n       * indicate that it has already been seen, in case of repeated\n       * occurrences in the call.  Bind the trie var to the call var and\n       * trail them both.\n       */\n      for ( cur = var;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n\tif ( IsTrieVar(BTN_Symbol(cur)) && IsNewTrieVar(BTN_Symbol(cur)) ) {\n\t  xsb_dbgmsg((LOG_TRIE, \"  Binding it to free trievar\"));\n\t  trievar_index = DecodeTrieVar(BTN_Symbol(cur));\n\t  /*** TrieVar_BindToSubterm(trievar_index,subterm); ***/\n\t  TrieVarBindings[trievar_index] = subterm;\n\t  Trail_Push(&TrieVarBindings[trievar_index]);\n\t  /*** CallVar_MarkIt(subterm,trievar_index); ***/\n\t  StandardizeVariable(subterm,trievar_index);\n\t  Trail_Push(subterm);\n\t  leaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\t  if ( IsNonNULL(leaf) ) {\n\t    if ( *pathType == NO_PATH )\n\t      *pathType = VARIANT_PATH;\n\t    return leaf;\n\t  }\n\t  else {\n\t  xsb_dbgmsg((LOG_TRIE, \n\t\t     \" Binding to free trievar didn't lead to valid path\"));\n\t    Trail_PopAndReset;\n\t    Trail_PopAndReset;\n\t    break;\n\t  }\n\t}\n      xsb_dbgmsg((LOG_TRIE, \"No free trievar here\"));\n    }\n    else {\n      xsb_dbgmsg((LOG_TRIE, \"  Found repeat call variable\\n\"\n\t\t \"  Option #1: Look to pair with repeat trie var\"));\n      /*\n       * Option 1: Look for a nonlinear trie variable which has already been\n       * --------  bound to this nonlinear call variable earlier in the\n       *           search.  There may be more than one.\n       */\n      for ( cur = var;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n\tif ( IsTrieVar(BTN_Symbol(cur)) &&\n\t     ! IsNewTrieVar(BTN_Symbol(cur)) ) {\n\t  trievar_index = DecodeTrieVar(BTN_Symbol(cur));\n\t  /***********************************************\n\t     could just compare\n\t         *(TrieVarBindings[trievar_index]) -to- subterm\n\t\t                  - OR -\n\t\t TrieVarBindings[trievar_index]\n\t\t   -to- TrieVarBindings[IndexOfStdVar(subterm)]\n\t  ***********************************************/\n\t  if ( are_identical_terms(TrieVarBindings[trievar_index],\n\t\t\t\t   subterm) ) {\n\t    xsb_dbgmsg((LOG_TRIE, \"  Found trivar with identical binding\"));\n\t    leaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\t    if ( IsNonNULL(leaf) ) {\n\t      /*\n\t       * This may or may not be a variant path, depending on what has\n\t       * happened higher-up in the trie.  We therefore make a\n\t       * conservative \"guess\" and leave it to be determined at that\n\t       * point during the recursive unrolling.\n\t       */\n\t      if ( *pathType == NO_PATH )\n\t\t*pathType = VARIANT_PATH;\n\t      return leaf;\n\t    }\n\t    else\n\t      xsb_dbgmsg((LOG_TRIE, \n\t\t\t \"  Pairing with identically bound trievar didn't lead\"\n\t\t\t \" to valid path\"));\n\t  }\n\t}\n      /*\n       * Option 2: Bind the nonlinear call variable with an unbound trie\n       * --------  variable.  There is only one of these in a sibling set.\n       */    \n      xsb_dbgmsg((LOG_TRIE, \n\t\t \"  Option #2: Bind new trievar to repeat call var\"));\n      for ( cur = var;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n\tif ( IsTrieVar(BTN_Symbol(cur)) && IsNewTrieVar(BTN_Symbol(cur)) ) {\n\t  xsb_dbgmsg((LOG_TRIE, \"    Found new trievar; binding it\"));\n\t  trievar_index = DecodeTrieVar(BTN_Symbol(cur));\n\t  /*** TrieVar_BindToMarkedCallVar(trievar_index,subterm); ***/\n\t  TrieVarBindings[trievar_index] =\n\t    TrieVarBindings[IndexOfStdVar(subterm)];\n\t  Trail_Push(&TrieVarBindings[trievar_index]);\n\t  leaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\t  if ( IsNonNULL(leaf) ) {\n\t    *pathType = SUBSUMPTIVE_PATH;\n\t    return leaf;\n\t  }\n\t  else {\n      xsb_dbgmsg((LOG_TRIE, \n\t\t \"    Binding new trievar to repeat callvar didn't lead to\"\n\t\t \" valid path\"));\n\t    Trail_PopAndReset;\n\t    break;\n\t  }\n\t}\n    }\n  }\n  else {\n\n    /* Handle NonVariable Subterms\n       =========================== */\n    /*\n     * The following should trie-encode the first symbol of subterm and\n     * record any recursive components of subterm (for reconstitution later,\n     * if needed).\n     */\n    if ( isconstant(subterm) ) {      /* XSB_INT, XSB_FLOAT, XSB_STRING */\n      xsb_dbgmsg((LOG_TRIE, \"  Found constant\"));\n      symbol = EncodeTrieConstant(subterm);\n      arity = 0;\n      args = NULL;\n    }\n    else if ( isconstr(subterm) ) {   /* XSB_STRUCT */\n      xsb_dbgmsg((LOG_TRIE, \"  Found structure\"));\n      symbol = EncodeTrieFunctor(subterm);\n      arity = get_arity((Psc)*clref_val(subterm));\n      args = clref_val(subterm) + 1;\n    }\n    else if ( islist(subterm) ) {     /* XSB_LIST */\n      xsb_dbgmsg((LOG_TRIE, \"  Found list\"));\n      symbol = EncodeTrieList(subterm);\n      arity = 2;\n      args = clref_val(subterm);\n    }\n    else {\n      Trail_Unwind_All;\n      xsb_abort(\"rec_sub_trie_lookup(): bad tag\");\n      *pathType = NO_PATH;\n      return NULL;\n    }\n\n    /*\n     * Determine the node chains below 'parent' where 'symbol' and trie\n     * variables may exist.\n     */\n    if ( IsHashHeader(BTN_Child(parent)) ) {\n      BTNptr *buckets;\n      BTHTptr ht;\n\n      ht = BTN_GetHashHdr(parent);\n      buckets = BTHT_BucketArray(ht);\n      match = buckets[TrieHash(symbol,BTHT_GetHashSeed(ht))];\n      var = buckets[TRIEVAR_BUCKET];\n    }\n    else  /* the children are arranged as a simple chain of nodes */\n      var = match = BTN_Child(parent);\n\n    /*\n     * Option 1: Look for an identical symbol in the trie.  There is at most\n     * --------  one of these among a set of child nodes.\n     */\n    xsb_dbgmsg((LOG_TRIE, \"  Nonvar Option #1: Find matching symbol in trie\"));\n    for ( cur = match;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n      if ( symbol == BTN_Symbol(cur) ) {\n\tint origTermStackTopIndex = TermStack_Top - TermStack_Base;\n\txsb_dbgmsg((LOG_TRIE, \"  Found matching trie symbol\"));\n\tTermStack_PushLowToHighVector(args,arity);\n\tleaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\tif ( IsNonNULL(leaf) ) {\n\t  if ( *pathType == NO_PATH )\n\t    *pathType = VARIANT_PATH;\n\t  return leaf;\n\t}\n\telse {\n\t  /* Could not successfully continue from this match, so try another\n\t     pairing, performed below.  Throw away whatever was pushed onto\n\t     the TermStack above by resetting the top-of-stack pointer. */\n\t  xsb_dbgmsg((LOG_TRIE, \n\t\t     \"  Matching trie symbol didn't lead to valid path\"));\n\t  TermStack_SetTOS(origTermStackTopIndex);\n\t  break;\n\t}\n      }\n\n    /*\n     * Option 2: Look for a trie variable which has already been bound to\n     * --------  an identical symbol during this process.\n     */\n    xsb_dbgmsg((LOG_TRIE, \n\t       \"  Nonvar Option #2: Match with previously bound trievar\"));\n    for ( cur = var;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n      if ( IsTrieVar(BTN_Symbol(cur)) && ! IsNewTrieVar(BTN_Symbol(cur)) ) {\n\ttrievar_index = DecodeTrieVar(BTN_Symbol(cur));\n\tif ( are_identical_terms(TrieVarBindings[trievar_index],\n\t\t\t\t    subterm) ) {\n\t  xsb_dbgmsg((LOG_TRIE, \"  Found trievar bound to matching symbol\"));\n\t  leaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\t  if ( IsNonNULL(leaf) ) {\n\t    *pathType = SUBSUMPTIVE_PATH;\n\t    return leaf;\n\t  }\n\t  else\n\t    xsb_dbgmsg((LOG_TRIE, \"  Bound trievar didn't lead to valid path\"));\n\t}\n      }\n\n    /*\n     * Option 3: Bind the symbol with an unbound trie variable.\n     * --------\n     */\n    xsb_dbgmsg((LOG_TRIE, \"  Nonvar Option #3: Bind free trievar to symbol\"));\n    for ( cur = var;  IsNonNULL(cur);  cur = BTN_Sibling(cur) )\n      if ( IsTrieVar(BTN_Symbol(cur)) && IsNewTrieVar(BTN_Symbol(cur)) ) {\n\txsb_dbgmsg((LOG_TRIE, \"  Binding free trievar to symbol\"));\n\ttrievar_index = DecodeTrieVar(BTN_Symbol(cur));\n\t/*** TrieVar_BindToSubterm(trievar_index,subterm); ***/\n\tTrieVarBindings[trievar_index] = subterm;\n\tTrail_Push(&TrieVarBindings[trievar_index]);\n\tleaf = rec_sub_trie_lookup(CTXTc cur,pathType);\n\tif ( IsNonNULL(leaf) ) {\n\t  *pathType = SUBSUMPTIVE_PATH;\n\t  return leaf;\n\t}\n\telse {\n\t  /* Remove the binding from the variable created above, exit the\n             loop, and drop through to fail; this was our last option.  Note\n             that there is only one unbound trie variable per sibling set. */\n\t  xsb_dbgmsg((LOG_TRIE, \n\t\t     \"Binding free trievar to symbol didn't lead to \"\n\t\t     \"valid path\"));\n\t  Trail_PopAndReset;\n\t  break;\n\t}\n      }\n  }\n\n  /* Nothing worked, so fail.  Make stacks same as when this was called. */\n  xsb_dbgmsg((LOG_TRIE, \"All options failed!\"));\n  TermStackLog_PopAndReset;\n  *pathType = NO_PATH;\n  return NULL;\n}", "path": "emu\\trie_lookup.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*\n * Given a term in the form of an arity and vector of subterms, if the\n * term is present in the given trie, returns a pointer to the leaf\n * representing the term, otherwise returns NULL.\n *\n * If the term is found and if an array (a non-NULL pointer) is supplied\n * in the last argument, then the variables in the term are copied into\n * it, with the 0th element containing the (unencoded) count.  The ith\n * encountered variable is placed in array element i.\n * \n * Routine used in meta-predicates such as get_call()\n */\n", "func_signal": "void *variant_trie_lookup(CTXTdeclc void *trieRoot, int nTerms, CPtr termVector,\n\t\t\t  Cell varArray[])", "code": "{\n\n  BTNptr trieNode;\n  xsbBool wasFound;\n  Cell symbol;\n\n\n#ifdef DEBUG_ASSERTIONS\n  if ( IsNULL(trieRoot) || (nTerms < 0) )\n    TrieError_InterfaceInvariant(\"variant_trie_lookup()\");\n#endif\n\n  if ( IsEmptyTrie((BTNptr)trieRoot) )\n    return NULL;\n\n  if ( nTerms > 0 ) {\n    Trail_ResetTOS;\n    TermStack_ResetTOS;\n    TermStack_PushLowToHighVector(termVector,nTerms);\n    trieNode = var_trie_lookup(CTXTc trieRoot,&wasFound,&symbol);\n    if ( wasFound ) {\n      if ( IsNonNULL(varArray) ) {\n\tint i;\n\n\tfor ( i = 0;  i < (int) Trail_NumBindings;  i++ )\n\t  varArray[i+1] = (Cell)Trail_Base[i];\n\tvarArray[0] = i;\n      }\n    }\n    else\n      trieNode = NULL;\n    Trail_Unwind_All;\n  }\n  else {\n    trieNode = trie_escape_lookup(trieRoot);\n    if ( IsNonNULL(trieNode) && IsNonNULL(varArray) )\n      varArray[0] = 0;\n  }\n  return trieNode;\n}", "path": "emu\\trie_lookup.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*\n * Given a term as an arity and array of subterms, determines whether\n * there exists a subsuming path in the given trie.  A pointer to the\n * leaf of the discovered path, if any, is returned, and a flag is set\n * to indicate how the path relates to the subterm.\n * \n * Used in get_producer_call/3 and other Prolog routines.\n */\n", "func_signal": "void *subsumptive_trie_lookup(CTXTdeclc void *trieRoot, int nTerms, CPtr termVector,\n\t\t\t      TriePathType *path_type, Cell subtermArray[])", "code": "{\n\n  BTNptr leaf;\n\n\n#ifdef DEBUG_ASSERTIONS\n  if ( IsNULL(trieRoot) || (nTerms < 0) )\n    TrieError_InterfaceInvariant(\"subsumptive_trie_lookup()\");\n#endif\n\n  *path_type = NO_PATH;\n  if ( IsEmptyTrie((BTNptr)trieRoot) )\n    return NULL;\n\n  if ( nTerms > 0) {\n    Trail_ResetTOS;\n    TermStackLog_ResetTOS;\n    TermStack_ResetTOS;\n    TermStack_PushLowToHighVector(termVector,nTerms);\n    leaf = rec_sub_trie_lookup(CTXTc trieRoot, path_type);\n    if ( IsNonNULL(leaf) && IsNonNULL(subtermArray) ) {\n      int i;\n      for ( i = 0;\n\t    TrieVarBindings[i] != (Cell) (& TrieVarBindings[i]);\n\t    i++ )\n\tsubtermArray[i+1] = TrieVarBindings[i];\n      subtermArray[0] = i;\n    }\n    Trail_Unwind_All;\n    dbg_printTriePathType(LOG_TRIE, stddbg, *path_type, leaf);\n  }\n  else {\n    leaf = trie_escape_lookup(trieRoot);\n    if ( IsNonNULL(leaf) ) {\n      *path_type = VARIANT_PATH;\n      if ( IsNonNULL(subtermArray) )\n\tsubtermArray[0] = 0;\n    }\n  }\n  return leaf;\n}", "path": "emu\\trie_lookup.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* waiting on message queues */\n/* returns TRUE if thread was signaled */\n", "func_signal": "int wait_on_queue( th_context *th, XSB_MQ_Ptr q, op_type send )", "code": "{\n  int status;\n  pthread_cond_t * cond_var ;\n  char *pred ;\n  Integer iq ;\n\n\tif( send == MESG_SEND )\n\t{\n\t\tcond_var = &q->mq_has_free_cells ;\n\t\tpred = \"thread_send_message\" ;\n\t\t\n\t}\n\telse\n\t{\n\t\tcond_var = &q->mq_has_messages ;\n\t\tpred = \"thread_get_message\" ;\n\t}\n\n\t/* so that the signal handler can wake up the thread */\n\tth->cond_var_ptr = cond_var ;\n\tq->n_threads++ ;\n\tif( !q->deleted ) {\n\t  q->mutex_owner = -1;\n\t  //\t  printf(\"thread %d waiting on condition %s for queue %d\\n\",xsb_thread_entry,pred,q-mq_table);\n\t  status = pthread_cond_wait(cond_var,&q->mq_mutex);\n\t  if (status) printf(\"pthread_cond_wait error in wait_on_queue: %d\\n\",status);\n\t  q->mutex_owner = xsb_thread_entry;\n\t}\n\tq->n_threads-- ;\n        th->cond_var_ptr = NULL ;\n\n\t/* check for thread interrupt */\n       \tif( asynint_val & THREADINT_MARK )\n        {\n\t  //\t  \t  printf(\"warning! Thread signal\\n\");\n\t  pthread_mutex_unlock( &q->mq_mutex ) ;\n\t  return TRUE ;\n\t}\n\tif( q->deleted )\n\t{\n\t  //\t  printf(\"queue %d deleted\\n\",q-mq_table);\n\t\tif( q->n_threads == 0 )\n\t\t{\tpthread_mutex_unlock( &q->mq_mutex ) ;\n\t\t\tqueue_dealloc( q ) ;\n\t\t}\n\t\telse\n\t\t\tpthread_mutex_unlock( &q->mq_mutex ) ;\n  \t\tiq = makeint((Integer)(q)); \n\t\txsb_existence_error( th, \"message queue\", iq, pred, 2, 2 ) ;\n\t}\n\treturn FALSE ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*-------------------------------------------------------------------------*/\n/* System Initialization Stuff */\n", "func_signal": "void init_system_threads( th_context *ctxt )", "code": "{\n  pthread_t tid = pthread_self();\n  int id, pos;\n\n  init_mq_table();\n  /* this should build an invalid thread id */\n  init_thread_table();\n  id = pos = th_new(ctxt, 0, 0) ;\n  th_vec[pos].tid = tid ;\n  th_vec[pos].valid = TRUE ;\n  if( pos != 0 )\n    SET_THREAD_INCARN(id, th_vec[pos].incarn ) ;\n  ctxt->tid = id ;\n  if( id != 0 )\n\txsb_abort( \"[THREAD] Error initializing thread table\" );\n\n\n  max_threads_sofar = 1 ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* cancelling is disabled at first, but re-enabled via thread_run */\n", "func_signal": "static int xsb_thread_create_1(th_context *th, Cell goal, int glsize, int tcsize,\n\t\t\t       int complsize, int pdlsize, int is_detached, int pos)", "code": "{\n  int rc;\n  pthread_t *thr ;\n  th_context *new_th_ctxt = th_vec[pos].ctxt;\n/* the Thread Id needs to be saved because it somehow gets \n   changed in the following function calls */\n  Integer Id = new_th_ctxt->tid ; \n\n  thr = &th_vec[pos].tid ;\n  copy_pflags(new_th_ctxt, th) ;\n  init_machine(new_th_ctxt,glsize,tcsize,complsize,pdlsize);\n  new_th_ctxt->_reg[1] = copy_term_from_thread(new_th_ctxt, th, goal) ;\n  new_th_ctxt->tid = Id ;\n  new_th_ctxt->enable_cancel = FALSE ;\n  new_th_ctxt->to_be_cancelled = FALSE ;\n  new_th_ctxt->cond_var_ptr = NULL ;\n  if (is_detached) { /* set detached */\n    rc = pthread_create(thr, &detached_attr_gl, &xsb_thread_run, \n\t\t\t (void *)new_th_ctxt ) ;\n  }\n  else {\n    rc = pthread_create(thr, &normal_attr_gl, &xsb_thread_run, (void *)new_th_ctxt ) ;\n  }\n  th_vec[pos].valid = TRUE ;\n\n  //  printf(\"creating %p %p\\n\",thr,th_vec[pos].tid);\n  if (rc == EAGAIN) {\n    decrement_thread_nums;\n    cleanup_thread_structures(new_th_ctxt) ;\n    th_delete(pos);\n    mem_dealloc(new_th_ctxt,sizeof(th_context),THREAD_SPACE) ;\n    xsb_resource_error(th,\"system threads\",\"xsb_thread_create\",2);\n  } else {\n    if (rc != 0) {\n      decrement_thread_nums;\n      cleanup_thread_structures(new_th_ctxt) ;\n      th_delete(pos);\n      mem_dealloc(new_th_ctxt,sizeof(th_context),THREAD_SPACE) ;\n      xsb_abort(\"[THREAD] Failure to create thread: error %d\\n\",rc);\n    }\n  }\n\n  return rc ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* Used only for sys mutexes -- I may fold this into mutex statistics\n   at some point.  */\n", "func_signal": "void print_mutex_use()", "code": "{\n  int i;\n\n  printf(\"Mutexes used since last statistics:\\n\");\n  for (i = 0; i < MAX_SYS_MUTEXES; i++) {\n    if (sys_mut[i].num_locks > 0) \n      printf(\"Mutex %s (%d): %d\\n\",mutex_names[i],i,sys_mut[i].num_locks);\n  }\n  for (i = 0; i < MAX_SYS_MUTEXES; i++) {\n    sys_mut[i].num_locks = 0;\n  }\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* calls _$thread_run/1 in thread.P */\n", "func_signal": "static void *xsb_thread_run( void *arg )", "code": "{\n        pthread_t tid;\n\tth_context *ctxt = (th_context *)arg ;\n        int pos = THREAD_ENTRY(ctxt->tid) ;\n\n\t//\tprintf(\"pos %d ctxt %p reg1 %x\\n\",pos,ctxt,ctxt->_reg[1]);\n\n\tpthread_mutex_lock( &th_mutex );\n        SYS_MUTEX_INCR( MUTEX_THREADS ) ;\n\ttid = pthread_self();\n/* if the xsb thread id was just created we need to re-initialize \n   thread pthread id on the thread table */\n        th_vec[pos].tid = tid ;\n        th_vec[pos].valid = TRUE ;\n\tpthread_mutex_unlock( &th_mutex );\n\n\temuloop( ctxt, get_ep((Psc)flags[THREAD_RUN]) ) ;\n\n\t/* execution shouldn't arrive here */\n\txsb_bug( \"emuloop returned from thread\" );\n\n\treturn NULL ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* Unlocks all system and user mutexes held by a thread */\n", "func_signal": "void release_held_mutexes(CTXTdecl)", "code": "{\n  int i;\n\n  //  printf(\"releasing held mutexes\\n\");\n  for( i = 0; i <=  LAST_REC_MUTEX ; i++ ) {\n    if ( MUTARRAY_OWNER(i) == xsb_thread_id) {\n      pthread_mutex_unlock( MUTARRAY_MUTEX(i)) ;\n    }\n  }\n  for( i = LAST_REC_MUTEX + 1 ; i < MAX_SYS_MUTEXES ; i++ ) {\n    if ( MUTARRAY_OWNER(i) == xsb_thread_id) {\n      pthread_mutex_unlock( MUTARRAY_MUTEX(i)) ;\n    }\n    pthread_mutex_unlock( MUTARRAY_MUTEX(i)) ;\n  }\n  for( i = 0; i < MAX_OPEN_FILES; i++ )\n\tif( OPENFILES_MUTEX_OWNER(i) == xsb_thread_id )\n\t\tpthread_mutex_unlock(OPENFILES_MUTEX(i));\n\n  mutex_unlock_all(CTXT);\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/*-------------------*/\n", "func_signal": "call_conv int xsb_ccall_thread_create(th_context *th,th_context **thread_return)", "code": "{\n  int rc ;\n  th_context *new_th_ctxt ;\n  pthread_t *thr ;\n  Integer id, pos ;\n\n  new_th_ctxt = mem_alloc(sizeof(th_context),THREAD_SPACE) ;\n\n  pthread_mutex_lock( &th_mutex );\n  SYS_MUTEX_INCR( MUTEX_THREADS ) ;\n  id = pos = th_new( new_th_ctxt, 0, 0 );\n  if (pos < 0) \n  {     pthread_mutex_unlock( &th_mutex );\n        xsb_resource_error(CTXTc \"threads\",\"thread_create\",3);\n  }\n  flags[NUM_THREADS]++ ;\n  max_threads_sofar = xsb_max( max_threads_sofar, flags[NUM_THREADS] );\n\n  pthread_mutex_unlock( &th_mutex );\n\n  new_th_ctxt->_xsb_ready = 0;  \n  pthread_mutex_init( &new_th_ctxt->_xsb_synch_mut, NULL ) ;\n  pthread_mutex_lock(&(new_th_ctxt->_xsb_synch_mut));\n\n  copy_pflags(new_th_ctxt, th) ;\n\n  init_machine(new_th_ctxt,0,0,0,0);\n  new_th_ctxt->enable_cancel = FALSE ;\n  new_th_ctxt->to_be_cancelled = FALSE ;\n  new_th_ctxt->cond_var_ptr = NULL ;\n\n  SET_THREAD_INCARN(id, th_vec[pos].incarn ) ;\n  new_th_ctxt->tid = id ;\n\n  pthread_cond_init( &new_th_ctxt->_xsb_started_cond, NULL ) ;\n  pthread_cond_init( &new_th_ctxt->_xsb_done_cond, NULL ) ;\n  pthread_mutex_init( &new_th_ctxt->_xsb_ready_mut, NULL ) ;\n  pthread_mutex_init( &new_th_ctxt->_xsb_query_mut, NULL ) ;\n  new_th_ctxt->_xsb_inquery = 0;\n\n  *thread_return = new_th_ctxt;\n\n  thr = &th_vec[pos].tid ;\n  rc = pthread_create(thr, &normal_attr_gl, &ccall_xsb_thread_run, (void *)new_th_ctxt ) ;\n  th_vec[pos].valid = TRUE ;\n\n  if (rc == EAGAIN) {\n    xsb_resource_error(th,\"system threads\",\"xsb_thread_create\",2);\n  } else {\n    if (rc != 0) \n      xsb_abort(\"[THREAD] Failure to create thread: error %d\\n\",rc);\n  }\n\n  while (!(new_th_ctxt->_xsb_ready))\n\tpthread_cond_wait( &new_th_ctxt->_xsb_done_cond, \n\t\t\t   &new_th_ctxt->_xsb_synch_mut  );\n  pthread_mutex_unlock( &new_th_ctxt->_xsb_synch_mut ) ;\n  return rc ;\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* releasing the space for messages from a message queue (as opposed\n   to the queue structure itself)  */\n", "func_signal": "void queue_dealloc( XSB_MQ_Ptr q )", "code": "{\n  //  printf(\"warning! queue_dealloc queue %d\\n\",q-mq_table);\n\n\tMQ_Cell_Ptr p, p1 ;\n\n\tp = q->first_message ; \n\twhile( p != NULL )\n\t{\n\t\tp1 = p->next ;\n\t\tmem_dealloc( p, p->size, THREAD_SPACE ) ;\n\t\tp = p1 ;\n\t}\n/* can't deallocate the memory of the term queue, as there may be\n   references to it from other threads \n\tmem_dealloc( q, sizeof(XSB_MQ), THREAD_SPACE ) ;\n */\n\tif( PUBLIC_MQ(q) )\n        {\n\t\t/* update the public mq lists */\n\n\t\tpthread_mutex_lock( &pub_mq_mutex ) ;\n\t        /* delete from queue list */\n\t        if( q->prev_entry != NULL )\n\t        \tq->prev_entry->next_entry = q->next_entry ;\n\t  \tif( q->next_entry != NULL )\n\t    \t\tq->next_entry->prev_entry = q->prev_entry ;\n\t  \tif( mq_first_queue == q )\n                \tmq_first_queue = q->next_entry ;\n\n\t  \t/* add to free queue list */\n\t  \tif (mq_first_free == NULL ) /* mq_last_free is NULL */\n\t    \t\tmq_first_free = mq_last_free = q;\n\t  \telse \n\t\t{   /* add new hole at tail to minimise re-use of slots */\n\t    \t\tmq_last_free->next_entry = q;\n\t    \t\tmq_last_free = q;\n\t    \t\tmq_last_free->next_entry = NULL;\n\t  \t}\n\t\tpthread_mutex_unlock( &pub_mq_mutex ) ;\n        }\n}", "path": "emu\\thread_xsb.c", "repo_name": "flavioc/XSB", "stars": 13, "license": "other", "language": "c", "size": 17612}
{"docstring": "/* !UNICODE */\n/* Windows 95 */\n/* When using \"Prompt for filename\", suggest previous if same user.\n * The previous username and filename are stored in HKEY_USERS\n * under Software\\Ghostgum\\RedMon\n */\n", "func_signal": "void get_last_filename(REDATA *prd)", "code": "{\n    TCHAR last_user[MAXSTR];\n    HKEY hkey;\n    LONG rc;\n    DWORD cbData;\n    DWORD dwType;\n\n    rc = RegOpenKeyEx(HKEY_CURRENT_USER, REDMONUSERKEY, 0,\n\t    KEY_READ, (PHKEY)&hkey);\n    if (rc == ERROR_SUCCESS) {\n\tcbData = sizeof(last_user)-sizeof(TCHAR);\n\trc = RegQueryValueEx(hkey, LASTUSERKEY, 0, &dwType, \n\t    (PBYTE)(last_user), &cbData);\n    }\n    if ((rc == ERROR_SUCCESS) && (lstrcmp(prd->pUserName, last_user)==0)){\n\tcbData = sizeof(prd->tempname)-sizeof(TCHAR);\n\trc = RegQueryValueEx(hkey, LASTFILEKEY, 0, &dwType, \n\t\t(PBYTE)(prd->tempname), &cbData);\n    }\n\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* return length of env in characters (which may not be bytes) */\n", "func_signal": "int\nenv_length(LPTSTR env)", "code": "{\nLPTSTR p;\n    p = env;\n    while (*p) {\n\twhile (*p)\n\t    p++;\n\tp++;\n    }\n    p++;\n    return (p - env);\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* copy stdout and stderr to log file, if open */\n", "func_signal": "BOOL\nflush_stdout(REDATA *prd)", "code": "{\n    DWORD bytes_available, dwRead, dwWritten;\n    BOOL result;\n    BOOL got_something = FALSE;\n\n    request_mutex(prd);\n\n    /* copy anything on stdout to printer or log file */\n    bytes_available = 0;\n    result = PeekNamedPipe(prd->hChildStdoutRd, NULL, 0, NULL, \n\t    &bytes_available, NULL);\n    while (result && bytes_available) {\n\tif (!ReadFile(prd->hChildStdoutRd, prd->pipe_buf, sizeof(prd->pipe_buf), \n\t    &dwRead, NULL) || dwRead == 0) \n\t    break;\n\tgot_something = TRUE;\n\tif (prd->config.dwOutput == OUTPUT_STDOUT) {\n\t    if (prd->printer != INVALID_HANDLE_VALUE) {\n\t\tif (!redmon_write_printer(prd, prd->pipe_buf, dwRead)) {\n\t\t    redmon_abort_printer(prd);\n\t\t}\n\t    }\n\t}\n\telse if (prd->hLogFile != INVALID_HANDLE_VALUE) {\n\t    WriteFile(prd->hLogFile, prd->pipe_buf, dwRead, &dwWritten, NULL);\n\t    FlushFileBuffers(prd->hLogFile);\n\t}\n\tresult = PeekNamedPipe(prd->hChildStdoutRd, NULL, 0, NULL, \n\t    &bytes_available, NULL);\n    }\n\n    /* copy anything on stderr to log file */\n    bytes_available = 0;\n    result = PeekNamedPipe(prd->hChildStderrRd, NULL, 0, NULL, \n\t    &bytes_available, NULL);\n    while (result && bytes_available) {\n\tif (!ReadFile(prd->hChildStderrRd, prd->pipe_buf, sizeof(prd->pipe_buf), &dwRead, NULL) ||\n\t    dwRead == 0) break;\n\tgot_something = TRUE;\n\tif (prd->hLogFile != INVALID_HANDLE_VALUE) {\n\t    WriteFile(prd->hLogFile, prd->pipe_buf, dwRead, &dwWritten, NULL);\n\t    FlushFileBuffers(prd->hLogFile);\n\t}\n\tresult = PeekNamedPipe(prd->hChildStderrRd, NULL, 0, NULL, \n\t    &bytes_available, NULL);\n    }\n\n    /* copy anything on printer pipe to the printer */\n    if (prd->config.dwOutput == OUTPUT_HANDLE) {\n\tbytes_available = 0;\n\tresult = PeekNamedPipe(prd->hPipeRd, NULL, 0, NULL, \n\t\t&bytes_available, NULL);\n\twhile (result && bytes_available) {\n\t    if (!ReadFile(prd->hPipeRd, prd->pipe_buf, sizeof(prd->pipe_buf), \n\t\t&dwRead, NULL) || dwRead == 0) \n\t\tbreak;\n\t    got_something = TRUE;\n\t    if (prd->printer != INVALID_HANDLE_VALUE) {\n\t\tif (!redmon_write_printer(prd, prd->pipe_buf, dwRead)) {\n\t\t    redmon_abort_printer(prd);\n\t\t}\n\t    }\n\t    result = PeekNamedPipe(prd->hPipeRd, NULL, 0, NULL, \n\t\t&bytes_available, NULL);\n\t}\n    }\n\n    release_mutex(prd);\n    return got_something;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* BETA */\n", "func_signal": "int PASCAL \nWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int cmdShow)", "code": "{\nDWORD version = GetVersion();\n     phInstance = hInstance;\n     if ((HIWORD(version) & 0x8000)==0)\n\t  is_winnt = TRUE;\n     if (LOBYTE(LOWORD(version)) >= 4)\n\t  is_win4 = TRUE;\n\n     if (lstrlen(lpszCmdLine))\n\t  silent = TRUE;\n\n     LoadString(phInstance, IDS_TITLE, title, sizeof(title)/sizeof(TCHAR)-1);\n     LoadString(phInstance, IDS_MONITORNAME, monitorname, \n\tsizeof(monitorname)/sizeof(TCHAR)-1);\n\n#ifdef BETA\n     if (beta_warn())\n\treturn 0;\n#endif\n     mi2.pName = monitorname;\n     mi2.pEnvironment = is_winnt ? MONITORENVNT : MONITORENV95;\n     mi2.pDLLName =     is_winnt ? MONITORDLLNT : MONITORDLL95 ;\n\n     /* Check if already installed */\n     if (EnumMonitors(NULL, 1, (LPBYTE)buffer, sizeof(buffer), \n\t&needed, &returned)) {\n\t  mi = (MONITOR_INFO_1 *)buffer;\n\t  for (i=0; i<returned; i++) {\n\t  if (lstrcmp(mi[i].pName, monitorname) == 0)\n\t       return message(IDS_ALREADY_INSTALLED);\n\t   }\n     }\n     else\n\t  return message(IDS_ENUMMONITORS_FAILED);\n\n     /* Warn user about what we are about to do */\n     if (!silent) {\n         TCHAR buf[256];\n\t LoadString(phInstance, IDS_INTRO, buf, sizeof(buf)/sizeof(TCHAR)-1);\n         if (MessageBox(HWND_DESKTOP, buf, title, MB_YESNO) != IDYES)\n\t     return 0;\n     }\n\n     /* copy files to Windows system directory */\n     if (!GetSystemDirectory(sysdir, sizeof(sysdir)))\n\t  return message(IDS_NOSYSDIR);\n     lstrcat(sysdir, \"\\\\\");\n\n     /* get path to EXE */\n     GetModuleFileName(hInstance, exepath, sizeof(exepath));\n     if ((p = strrchr(exepath,'\\\\')) != (char *)NULL)\n\t  p++;\n     else\n\t  p = exepath;\n     *p = '\\0';\n\n     lstrcpy(destination, sysdir);\n     lstrcat(destination, mi2.pDLLName);\n     lstrcpy(source, exepath);\n     lstrcat(source, mi2.pDLLName);\n     if (!CopyFile(source, destination, FALSE))\n\t  return message(IDS_ERROR_COPY_DLL);\n     lstrcpy(destination, sysdir);\n     lstrcat(destination, MONITORHLP);\n     lstrcpy(source, exepath);\n     lstrcat(source, MONITORHLP);\n     if (!CopyFile(source, destination, FALSE))\n\t  return message(IDS_ERROR_COPY_HELP);\n     lstrcpy(destination, sysdir);\n     lstrcat(destination, REDCONF);\n     lstrcpy(source, exepath);\n     lstrcat(source, REDCONF);\n     if (!CopyFile(source, destination, FALSE))\n         return message(IDS_ERROR_COPY_REDCONF);\n     lstrcpy(destination, sysdir);\n     lstrcat(destination, UNINSTALLPROG);\n     lstrcpy(source, exepath);\n     lstrcat(source, UNINSTALLPROG);\n     if (!CopyFile(source, destination, FALSE))\n\t  return message(IDS_ERROR_COPY_UNINSTALL);\n\n     if (!AddMonitor(NULL, 2, (LPBYTE)&mi2)) {\n\t  return message(IDS_ADDMONITOR_FAILED);\n     }\n\n     /* write registry entries for uninstall */\n     if ((rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UNINSTALLKEY, 0, \n\t  KEY_ALL_ACCESS, &hkey)) != ERROR_SUCCESS) {\n\t/* failed to open key, so try to create it */\n        rc = RegCreateKey(HKEY_LOCAL_MACHINE, UNINSTALLKEY, &hkey);\n     }\n     if (rc == ERROR_SUCCESS) {\n\t  if (RegCreateKey(hkey, MONITORKEY, &hsubkey) == ERROR_SUCCESS) {\n\t       lstrcpy(buffer, title);\n\t       RegSetValueEx(hsubkey, DISPLAYNAMEKEY, 0, REG_SZ,\n\t\t    (CONST BYTE *)buffer, lstrlen(buffer)+1);\n\t       lstrcpy(buffer, sysdir);\n\t       lstrcat(buffer, UNINSTALLPROG);\n\t       RegSetValueEx(hsubkey, UNINSTALLSTRINGKEY, 0, REG_SZ,\n\t\t    (CONST BYTE *)buffer, lstrlen(buffer)+1);\n\t       RegCloseKey(hsubkey);\n\t  }\n\t  RegCloseKey(hkey);\n     }\n\n     /* Disable removing of uninstall program, in case someone \n      * uninstalls then installs again without rebooting Windows.\n      */\n     wsprintf(source, TEXT(\"%s%s\"), sysdir, UNINSTALLPROG);\n     if (is_winnt) {\n#define RENAME_KEY \"PendingFileRenameOperations\"\n\t if ((rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \n\t    \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\",\n\t    0, KEY_ALL_ACCESS, &hkey)) == ERROR_SUCCESS) {\n\t      DWORD dwType = REG_MULTI_SZ;\n\t      DWORD dwLength;\n\t      if ( (rc = RegQueryValueEx(hkey, RENAME_KEY, NULL, &dwType, \n\t\t    buffer, &dwLength)) == ERROR_SUCCESS ) {\n\t\t/* look to see if unredmon.exe is mentioned */\n\t\tLPSTR p = buffer;\n\t\tLPSTR q;\n\t\twhile (*p) {\n\t\t    q = p;\n\t\t    q += strlen(q) + 1;\t/* skip existing name */\n\t\t    q += strlen(q) + 1;\t/* skip new name */\n\t\t    if (lstrcmp(p, source) == 0) {\n\t\t\tMoveMemory(p, q, dwLength - (q - buffer));\n\t\t\tdwLength -= (q-p);\n\t\t    }\n\t\t    else\n\t\t\tp = q;\n\t\t}\n\t\tRegSetValueEx(hkey, RENAME_KEY, 0, dwType, \n\t\t    buffer, dwLength); \n\t      }\n\t }\n#undef RENAME_KEY\n     }\n     else {\n\tchar ini_name[256];\n\tGetWindowsDirectory(ini_name, sizeof(ini_name));\n\tlstrcat(ini_name, \"\\\\wininit.ini\");\n\tGetPrivateProfileString(\"Rename\", \"NUL\", \"\", \n\t    buffer, sizeof(buffer), ini_name);\n\tif (lstrcmp(source, buffer) == 0) {\n\t    WritePrivateProfileString(\"Rename\", \"NUL\", NULL, ini_name);\n\t}\n\tSetLastError(0);\n     }\n\n#ifdef UNUSED\n     if ((rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, \n\t\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce\",\n\t0, KEY_ALL_ACCESS, &hkey)) == ERROR_SUCCESS) {\n\t  RegDeleteValue(hkey, MONITORKEY);\n     }\n#endif\n\n     message(IDS_INSTALL_OK);\n\n     return 0;\n}", "path": "src\\setup.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* This may be called if an error has occurred,\n * to print out the log file as an error report.\n */\n", "func_signal": "BOOL \nredmon_print_error(REDATA *prd)", "code": "{\n    HDC hdc;\n    TCHAR driverbuf[2048];\n    TCHAR *device, *driver, *output, *p;\n    DOCINFO di;\n    HFONT hfont;\n    HANDLE hfile;\n    LOGFONT lf;\n    CHAR line[128];\n    int xdpi, ydpi;\n    int x, y, ymin, ymax, yskip;\n    BOOL error = FALSE;\n    \n\n    /* open printer */\n    device = prd->config.szPrinter;\n    GetProfileString(TEXT(\"Devices\"), device, TEXT(\"\"), driverbuf, \n\tsizeof(driverbuf) / sizeof(TCHAR));\n    p = driverbuf;\n    driver = p;\n    while (*p && *p != ',')\n\tp++;\n    if (*p)\n\t*p++ = '\\0';\n    output = p;\n    while (*p && *p != ',')\n\tp++;\n    if (*p)\n\t*p++ = '\\0';\n \n    if ( (hdc = CreateDC(driver, device, NULL, NULL)) == NULL) {\n\treturn FALSE;\n    }\n\n    SetAbortProc(hdc, AbortProc);\n    di.cbSize = sizeof(di);\n    di.lpszDocName = TEXT(\"RedMon error report\");\n    di.lpszOutput = output;\n    if ((error = (StartDoc(hdc, &di) == SP_ERROR)) != 0) {\n\tTCHAR buf[1024];\n\tDWORD last_error = GetLastError();\n\twsprintf(buf, \n\t    TEXT(\"StartDoc \\042%s\\042,\\042%s\\042,\\042%s\\042 Error=%d\"),\n\t    device, di.lpszDocName, di.lpszOutput, last_error);\n\tMessageBox(HWND_DESKTOP, buf, TEXT(\"RedMon\"), MB_OK);\n    }\n\t\n    if (!error && (StartPage(hdc) != SP_ERROR)) {\n\txdpi = GetDeviceCaps(hdc, LOGPIXELSX);\n\tydpi = GetDeviceCaps(hdc, LOGPIXELSY);\n\tmemset(&lf, 0, sizeof(LOGFONT));\n\tlf.lfHeight = 10 * ydpi / 72;\t/* 10 pts high */\n\tlstrcpy(lf.lfFaceName, TEXT(\"Arial\"));\n\thfont = CreateFontIndirect(&lf);\n\tSelectObject(hdc, hfont);\n\n\tymin = 36 * ydpi / 72;\t/* top of page */\n\tymax = 756 * ydpi / 72;\t/* bottom of page */\n\tyskip = 10 * ydpi / 72;\t/* line spacing */\n\tx = 36 * xdpi / 72;\t\t/* left margin */\n\ty = ymin;\n\n\t/* write RedMon header */\n\tp = TEXT(\"RedMon error report\");\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n\tlstrcpy(driverbuf, copyright);\n\tp = driverbuf + lstrlen(driverbuf) - 1;\n\tif (*p == '\\n')\n\t    *p = '\\0';\n\tp = driverbuf;\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n\tlstrcpy(driverbuf, version);\n\tp = driverbuf + lstrlen(driverbuf) - 1;\n\tif (*p == '\\n')\n\t    *p = '\\0';\n\tp = driverbuf;\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n\tp = driverbuf;\n\twsprintf(driverbuf, TEXT(\"  Port=\\042%s\\042  Printer=\\042%s\\042\"), \n\t    prd->portname, prd->pPrinterName);\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n\twsprintf(driverbuf, TEXT(\"  DocumentName=\\042%s\\042\"), prd->pDocName);\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n/*\n\twsprintf(driverbuf, TEXT(\"  Command=\\042%s\\042), prd->command);\n\tTextOut(hdc, x, y, p, lstrlen(p));\n\ty+=yskip;\n*/\n\ty+=yskip;\n\n\n\tif (prd->config.szLogFileName[0] != '\\0') {\n\t    /* log file was written (but isn't currently open) */\n\t    /* open log file */\n\t    if ((hfile = CreateFile(prd->config.szLogFileName, GENERIC_READ, \n\t\tFILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) \n\t\t!= INVALID_HANDLE_VALUE) {\n\t\t/* copy log file to printer */\n\t\tint i = 0;\n\t\tDWORD dwRead = 0;\n\t\tBOOL eol = FALSE; \n\t\twhile (ReadFile(hfile, &line[i], 1, &dwRead, NULL) &&\n\t\t    (dwRead == 1)) {\n\t\t    eol = FALSE;\n\t\t    switch (line[i]) {\n\t\t\tcase '\\r':\n\t\t\t    /* do nothing */\n\t\t\t    break;\n\t\t\tcase '\\n':\n\t\t\t    /* end of line */\n\t\t\t    eol = TRUE;\n\t\t\t    line[i]='\\0';\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    i++;\n\t\t\t    if (i > 80) {\n\t\t\t\teol = TRUE;\n\t\t\t\tline[i]='\\0';\n\t\t\t    }\n\t\t    }\n\n\t\t    if (eol) {\n\t\t\tif (y >= ymax) {\n\t\t\t    EndPage(hdc);\n\t\t\t    StartPage(hdc);\n\t\t\t    y = ymin;\n\t\t\t}\n\t\t\tTextOutA(hdc, x, y, line, i);\n\t\t\ty+=yskip;\n\t\t\ti = 0;\n\t\t    }\n\t\t    dwRead = 0;\n\t\t}\n\t\tif (i)\n\t\t    TextOutA(hdc, x, y, line, i);\n\t\tCloseHandle(hfile);\n\t    }\n\t}\n\t/* close printer */\n\tEndPage(hdc);\n\tEndDoc(hdc);\n    }\n\n    DeleteDC(hdc);\n    return TRUE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* read the configuration from the registry */\n", "func_signal": "BOOL redmon_get_config(HANDLE hMonitor, LPCTSTR portname, RECONFIG *config)", "code": "{\n    LONG rc = ERROR_SUCCESS;\n    HANDLE hkey;\n    TCHAR buf[MAXSTR];\n    DWORD cbData;\n    DWORD dwType;\n#ifdef DEBUG_REDMON\n    syslog(TEXT(\"redmon_get_config \"));\n    syslog(portname);\n    syslog(TEXT(\"\\r\\n\"));\n    syslog(TEXT(\"  hMonitor=\"));\n    syshex((DWORD)hMonitor);\n    syslog(TEXT(\"\\r\\n\"));\n#endif\n    redmon_init_config(config);\n    lstrcpyn(config->szPortName, portname, sizeof(config->szPortName)-1);\n\n    lstrcpy(buf, PORTSNAME);\n    lstrcat(buf, BACKSLASH);\n    lstrcat(buf, portname);\n    rc = RedMonOpenKey(hMonitor, buf, KEY_READ, &hkey);\n    if (rc != ERROR_SUCCESS) {\n#ifdef DEBUG_REDMON\n\tsyslog(TEXT(\"Failed to open registry key \"));\n\tsyslog(buf);\n\tsyslog(TEXT(\"\\r\\n\"));\n#endif\n\treturn FALSE;\n    }\n\n    cbData = sizeof(config->szDescription)-sizeof(TCHAR);\n    rc = RedMonQueryValue(hMonitor, hkey, DESCKEY, &dwType, \n\t(PBYTE)(config->szDescription), &cbData);\n    cbData = sizeof(config->szCommand)-sizeof(TCHAR);\n    rc = RedMonQueryValue(hMonitor, hkey, COMMANDKEY, &dwType, \n\t(PBYTE)(config->szCommand), &cbData);\n    cbData = sizeof(config->szArguments)-sizeof(TCHAR);\n    rc = RedMonQueryValue(hMonitor, hkey, ARGKEY, &dwType, \n\t(PBYTE)(config->szArguments), &cbData);\n    cbData = sizeof(config->szPrinter)-sizeof(TCHAR);\n    rc = RedMonQueryValue(hMonitor, hkey, PRINTERKEY, &dwType, \n\t(PBYTE)(config->szPrinter), &cbData);\n    cbData = sizeof(config->dwOutput);\n    rc = RedMonQueryValue(hMonitor, hkey, OUTPUTKEY, &dwType, \n\t(PBYTE)(&config->dwOutput), &cbData);\n    if (config->dwOutput > OUTPUT_LAST)\n\tconfig->dwOutput = OUTPUT_SELF;\n    cbData = sizeof(config->dwShow);\n    rc = RedMonQueryValue(hMonitor, hkey, SHOWKEY, &dwType, \n\t(PBYTE)(&config->dwShow), &cbData);\n    cbData = sizeof(config->dwRunUser);\n    rc = RedMonQueryValue(hMonitor, hkey, RUNUSERKEY, &dwType, \n\t(PBYTE)(&config->dwRunUser), &cbData);\n    cbData = sizeof(config->dwDelay);\n    rc = RedMonQueryValue(hMonitor, hkey, DELAYKEY, &dwType, \n\t(PBYTE)(&config->dwDelay), &cbData);\n    cbData = sizeof(config->dwLogFileUse);\n    rc = RedMonQueryValue(hMonitor, hkey, LOGUSEKEY, &dwType, \n\t(PBYTE)(&config->dwLogFileUse), &cbData);\n    cbData = sizeof(config->szLogFileName)-sizeof(TCHAR);\n    rc = RedMonQueryValue(hMonitor, hkey, LOGNAMEKEY, &dwType, \n\t(PBYTE)(config->szLogFileName), &cbData);\n    cbData = sizeof(config->dwLogFileDebug);\n    rc = RedMonQueryValue(hMonitor, hkey, LOGDEBUGKEY, &dwType, \n\t(PBYTE)(&config->dwLogFileDebug), &cbData);\n    cbData = sizeof(config->dwPrintError);\n    rc = RedMonQueryValue(hMonitor, hkey, PRINTERRORKEY, &dwType, \n\t(PBYTE)(&config->dwPrintError), &cbData);\n    RedMonCloseKey(hMonitor, hkey);\n    return TRUE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Check if process is running.  */\n/* Return TRUE if process is running, FALSE otherwise */\n/* Shut down stdin pipe if we find process has terminated */\n", "func_signal": "BOOL check_process(REDATA *prd)", "code": "{\n    DWORD exit_status;\n    if (prd->error)\n\treturn FALSE;\t/* process is not running */\n\n    if (prd->piProcInfo.hProcess == INVALID_HANDLE_VALUE)\n\tprd->error = TRUE;\n    if (!prd->error \n\t&& GetExitCodeProcess(prd->piProcInfo.hProcess, &exit_status)\n\t&& (exit_status != STILL_ACTIVE))\n\tprd->error = TRUE;\n\n    if (prd->error) {\n\tDWORD bytes_available, dwRead;\n\tBOOL result;\n\tBYTE buf[256];\n\tif (prd->config.dwLogFileDebug) {\n\t  write_string_to_log(prd, \n\t    TEXT(\"REDMON check_process: process isn't running.\\r\\n\"));\n\t  write_string_to_log(prd, \n\t    TEXT(\"REDMON check_process: flushing child stdin to unblock WriteThread.\\r\\n\"));\n\t}\n\t/* flush stdin pipe to unblock WriteThread */\n\tbytes_available = 0;\n\tresult = PeekNamedPipe(prd->hChildStdinRd, NULL, 0, NULL, \n\t\t    &bytes_available, NULL);\n\twhile (result && bytes_available) {\n\t    ReadFile(prd->hChildStdinRd, buf, sizeof(buf), &dwRead, NULL);\n\t    result = PeekNamedPipe(prd->hChildStdinRd, NULL, 0, NULL, \n\t\t&bytes_available, NULL);\n\t}\n\n    }\n    return !prd->error;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Append a string to an environment block.\n * It is assumed that the environment block has sufficient\n * space.\n *  env is the environment block.\n *  name is the environment variable name, which includes a trailing '='.\n *  len is the length of name in bytes, including the trailing null.\n *  value is the environment variable value.\n */\n", "func_signal": "void\nappend_env(LPTSTR env, LPTSTR name, int len, LPTSTR value)", "code": "{\nint oldlen;\n  oldlen = env_length(env);\n  env = env + oldlen - 1;\n  MoveMemory(env, name, len);\n  env += len/sizeof(TCHAR) - 1;\n  MoveMemory(env, value, lstrlen(value)*sizeof(TCHAR));\n  env += lstrlen(value) + 1;\n  *env = '\\0';\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Save name obtained from \"Prompt for filename\" */\n", "func_signal": "void save_user_filename(LPTSTR pszSid, LPTSTR pszFileName)", "code": "{\n    LONG rc;\n    HKEY hkey;\n    TCHAR pszKey[256];\n\n    /* Check if we can access the user registry */\n    rc = RegOpenKeyEx(HKEY_USERS, pszSid, 0, KEY_WRITE, (PHKEY)&hkey);\n    if (rc != ERROR_SUCCESS) {\n#ifdef DEBUG_REDMON\n\tif (rc != ERROR_SUCCESS) {\n\t    syslog(TEXT(\"RegOpenKeyEx \"));\n\t    syslog(pszSid);\n\t    syslog(TEXT(\"\\r\\n\"));\n\t    syserror(rc);\n\t}\n#endif\n\t/* Can't access user registry */\n\t/* They probably haven't logged on. */\n\treturn;\n    }\n    RegCloseKey(hkey);\n\n    if (lstrlen(pszSid) + lstrlen(REDMONUSERKEY) + 2 >= \n\tsizeof(pszKey)/sizeof(TCHAR)) {\n#ifdef DEBUG_REDMON\n\tsyslog(TEXT(\"pszKey buffer too small\\r\\n\"));\n#endif\n\treturn;\t/* buffer too small */\n    }\n    lstrcpy(pszKey, pszSid);\n    lstrcat(pszKey, TEXT(\"\\\\\"));\n    lstrcat(pszKey, REDMONUSERKEY);\n    \n    /* Open/Create the RedMon application key for this SID */\n    rc = RegOpenKeyEx(HKEY_USERS, pszKey, 0, KEY_WRITE, (PHKEY)&hkey);\n    if (rc != ERROR_SUCCESS) {\n#ifdef DEBUG_REDMON\n\tsyslog(TEXT(\"RegOpenKeyEx \"));\n\tsyslog(pszKey);\n\tsyslog(TEXT(\"\\r\\n\"));\n\tsyserror(rc);\n#endif\n\trc = RegCreateKeyEx(HKEY_USERS, pszKey, 0, 0, 0, KEY_WRITE, \n\t\tNULL, (PHKEY)&hkey, NULL);\n#ifdef DEBUG_REDMON\n\tif (rc != ERROR_SUCCESS) {\n\t    syslog(TEXT(\"RegCreateKeyEx \"));\n\t    syslog(pszKey);\n\t    syslog(TEXT(\"\\r\\n\"));\n\t    syserror(rc);\n\t}\n#endif\n    }\n\n    if (rc == ERROR_SUCCESS) {\n\trc = RegSetValueEx(hkey, LASTFILEKEY, 0, REG_SZ,\n\t        (PBYTE)(pszFileName), sizeof(TCHAR)*(lstrlen(pszFileName)+1));\n#ifdef DEBUG_REDMON\n\tif (rc != ERROR_SUCCESS) {\n\t    syslog(TEXT(\"RegSetValueEx\\r\\n \"));\n\t    syslog(LASTFILEKEY);\n\t    syslog(TEXT(\"=\"));\n\t    syslog(pszFileName);\n\t    syslog(TEXT(\"\\r\\n\"));\n\t    syserror(rc);\n\t}\n#endif\n\tRegCloseKey(hkey);\n    }\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Suggest a port name and store it in portname.\n * len is the size in characters of portname.\n * nAttempt is the number of times we have attempted\n * to generate a unique port name and can be used\n * to add a numeric suffix.  On first call this will be 1.\n *\n * If we can't generate a unique name then return FALSE.\n * If we only support one possible name then return FALSE when nAttempt > 1.\n */\n", "func_signal": "BOOL redmon_suggest_portname(TCHAR *portname, int len, int nAttempt)", "code": "{\n    TCHAR rname[] = TEXT(\"RPT%d:\");\n#ifdef DEBUG_REDMON\nsyslog(TEXT(\"redmon_suggest_portname\\r\\n\"));\n#endif\n    if (len < sizeof(rname)/sizeof(TCHAR) + 12)\n\treturn FALSE;\n    wsprintf(portname, rname, nAttempt);\n#ifdef DEBUG_REDMON\nsyslog(TEXT(\"attempt=\"));\nsysnum(nAttempt);\nsyslog(TEXT(\"\\r\\nPort=\"));\nsyslog(portname);\nsyslog(TEXT(\"\\r\\n\"));\n#endif\n    return TRUE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* ReadPort can be called within a Start/EndDocPort pair,\n * and also outside this pair.\n */\n", "func_signal": "BOOL redmon_read_port(REDATA *prd, LPBYTE pBuffer, \n        DWORD  cbBuffer, LPDWORD pcbRead)", "code": "{\n    /* we don't support reading */\n    *pcbRead = 0;\n\n    if (prd == (REDATA *)NULL) {\n\tSetLastError(ERROR_INVALID_HANDLE);\n\treturn FALSE;\n    }\n\n    Sleep(1000);\t/* Pause a little */\n\n    if (prd->config.dwLogFileDebug) {\n\tTCHAR buf[MAXSTR];\n\twsprintf(buf, TEXT(\"REDMON ReadPort: returning FALSE. Process %s\\r\\n\"),\n\t   prd->error ? TEXT(\"has an ERROR.\") : TEXT(\"is OK.\"));\n\twrite_string_to_log(prd, buf);\n\twsprintf(buf, TEXT(\"REDMON ReadPort: You must disable bi-directional printer support for this printer\\r\\n\"));\n\twrite_string_to_log(prd, buf);\n    }\n\n    /* We don't support read port */\n    return FALSE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Create another process to get the filename.\n * This is needed to make the SaveAs dialog appear on the WTS client\n * instead of the server.\n */\n", "func_signal": "BOOL get_filename_as_user(REDATA * prd)", "code": "{\n    SECURITY_ATTRIBUTES saAttr;\n    STARTUPINFO siStartInfo;\n    HANDLE hPipeTemp;\n    HANDLE hPipeWrite;\n    HANDLE hPipeRead;\n    LPVOID env;\n    TCHAR command[MAXSTR];\n    BOOL flag = TRUE;\n    HANDLE htoken;\n    TCHAR buf[MAXSTR];\n    DWORD dwBytesRead;\n\n    /* Set the bInheritHandle flag so pipe handles are inherited. */\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n    saAttr.lpSecurityDescriptor = NULL;\n\n    /* Create anonymous inheritable pipes for retrieving filename\n     * from user.  Create a noninheritable duplicate handle\n     * of our end of the pipe, then close the inheritable handle.\n     */\n\n    if (!CreatePipe(&hPipeTemp, &hPipeWrite, &saAttr, 0))\n\treturn FALSE;\t/* cleanup of pipes will occur in caller */\n    if (!DuplicateHandle(GetCurrentProcess(), hPipeTemp,\n            GetCurrentProcess(), &hPipeRead, 0,\n            FALSE,       /* not inherited */\n            DUPLICATE_SAME_ACCESS)) {\n        CloseHandle(hPipeTemp);\n\treturn FALSE;\n    }\n    CloseHandle(hPipeTemp);\n\n\n    wsprintf(command, TEXT(\"redmonfn.exe %lu %s\"), hPipeWrite, prd->tempname);\n    write_string_to_log(prd, command);\n    write_string_to_log(prd, TEXT(\"\\r\\n\"));\n\n    /* Now create the child process. */\n\n    /* Set up members of STARTUPINFO structure. */\n\n    siStartInfo.cb = sizeof(STARTUPINFO);\n    siStartInfo.lpReserved = NULL;\n    siStartInfo.lpDesktop = NULL;\n    siStartInfo.lpTitle = NULL;  /* use executable name as title */\n    siStartInfo.dwX = siStartInfo.dwY = CW_USEDEFAULT;\t\t/* ignored */\n    siStartInfo.dwXSize = siStartInfo.dwYSize = CW_USEDEFAULT;\t/* ignored */\n    siStartInfo.dwXCountChars = 80;\n    siStartInfo.dwYCountChars = 25;\n    siStartInfo.dwFillAttribute = 0;\t\t\t/* ignored */\n    siStartInfo.dwFlags = STARTF_USESTDHANDLES;\n    siStartInfo.wShowWindow = SW_SHOWNORMAL;\t\t/* ignored */\n    siStartInfo.dwFlags |= STARTF_USESHOWWINDOW;\n    siStartInfo.cbReserved2 = 0;\n    siStartInfo.lpReserved2 = NULL;\n    siStartInfo.hStdInput = NULL;\n    siStartInfo.hStdOutput = NULL;\n    siStartInfo.hStdError = NULL;\n\n    if (prd->environment)\n        env = GlobalLock(prd->environment);\n    else\n\tenv = NULL;\n\n    /* Create the child process. */\n\n    /* CreateProcessAsUser is only supported by NT3.51 and later. */\n    /* get impersonation token of current thread */\n    if ( !(flag = OpenThreadToken(GetCurrentThread() , \n\tTOKEN_DUPLICATE | TOKEN_IMPERSONATE, \n\tTRUE, &htoken)) ) {\n\tDWORD err = GetLastError();\n\twsprintf(buf, TEXT(\"OpenThreadToken failed, error code=%d\\r\\n\"),\n\t    err);\n\twrite_string_to_log(prd, buf);\n\twrite_error(prd, err);\n    }\n    /* Duplicate it to create a primary token */\n    if ( !(flag = DuplicateTokenEx(htoken, TOKEN_ALL_ACCESS, NULL, \n\t   SecurityImpersonation, TokenPrimary, &prd->primary_token)) ) {\n\tDWORD err = GetLastError();\n\twsprintf(buf, TEXT(\"DuplicateTokenEx failed, error code=%d\\r\\n\"),\n\t    err);\n\twrite_string_to_log(prd, buf);\n\twrite_error(prd, err);\n    }\n    CloseHandle(htoken);\n\n    /* Be default, the process is created on an invisible desktop.\n     * that can't receive input.\n     * By settings lpDesktop to an empty string, the system will\n     * try to use the existing desktop of the impersonated user.\n     */\n    siStartInfo.lpDesktop = TEXT(\"\");\n    if ( !(flag = CreateProcessAsUser(prd->primary_token, NULL,\n\t    command,  /* command line                       */\n\t    NULL,          /* process security attributes        */\n\t    NULL,          /* primary thread security attributes */\n\t    TRUE,          /* handles are inherited              */\n\t    CREATE_UNICODE_ENVIRONMENT,  /* creation flags       */\n\t    env,           /* environment                        */\n\t    NULL,          /* use parent's current directory     */\n\t    &siStartInfo,  /* STARTUPINFO pointer                */\n\t    &prd->piProcInfo))  /* receives PROCESS_INFORMATION  */\n       ) {\n\tDWORD err = GetLastError();\n\twsprintf(buf, TEXT(\"CreateProcessAsUser failed, error code=%d\\r\\n\"),\n\t    err);\n\twrite_string_to_log(prd, buf);\n\twrite_error(prd, err);\n    }\n\n    /* read pipe to get filename */\n    if (flag)\n\tflag = ReadFile(hPipeRead, buf, sizeof(buf)-1, &dwBytesRead, NULL);\n    if (flag) {\n\n\tif (dwBytesRead < sizeof(prd->tempname))\n\t    CopyMemory(prd->tempname, buf, dwBytesRead);\nwrite_string_to_log(prd, TEXT(\"redmonfn.exe returns '\"));\nwrite_string_to_log(prd, buf);\nwrite_string_to_log(prd, TEXT(\"'\\r\\n\"));\nwsprintf(buf, TEXT(\"  read %d bytes\\r\\n\"), dwBytesRead);\nwrite_string_to_log(prd, buf);\n    }\n\n    if (prd->piProcInfo.hProcess != INVALID_HANDLE_VALUE) {\n\tCloseHandle(prd->piProcInfo.hProcess);\n\tprd->piProcInfo.hProcess = INVALID_HANDLE_VALUE;\n    }\n\n    if (prd->piProcInfo.hThread != INVALID_HANDLE_VALUE) {\n\tCloseHandle(prd->piProcInfo.hThread);\n\tprd->piProcInfo.hThread = INVALID_HANDLE_VALUE;\n    }\n\n    return flag;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Windows NT */\n/* Convert a SID into a text format */\n", "func_signal": "BOOL ConvertSid(PSID pSid, LPTSTR pszSidText, LPDWORD dwBufferLen)", "code": "{\n    PSID_IDENTIFIER_AUTHORITY psia;\n    DWORD dwSubAuthorities;\n    DWORD dwSidRev=SID_REVISION;\n    DWORD dwCounter;\n    DWORD dwSidSize;\n\n    //\n    // test if Sid passed in is valid\n    //\n    if(!IsValidSid(pSid)) return FALSE;\n\n    // obtain SidIdentifierAuthority\n    psia=GetSidIdentifierAuthority(pSid);\n\n    // obtain sidsubauthority count\n    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);\n\n    //\n    // compute buffer length\n    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL\n    //\n    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);\n\n    //\n    // check provided buffer length.\n    // If not large enough, indicate proper size and setlasterror\n    //\n    if (*dwBufferLen < dwSidSize){\n\t*dwBufferLen = dwSidSize;\n\tSetLastError(ERROR_INSUFFICIENT_BUFFER);\n\treturn FALSE;\n    }\n\n    //\n    // prepare S-SID_REVISION-\n    //\n    dwSidSize=wsprintf(pszSidText, TEXT(\"S-%lu-\"), dwSidRev );\n\n    //\n    // prepare SidIdentifierAuthority\n    //\n    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ){\n\tdwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),\n\t\t\t   TEXT(\"0x%02hx%02hx%02hx%02hx%02hx%02hx\"),\n\t\t\t   (USHORT)psia->Value[0],\n\t\t\t   (USHORT)psia->Value[1],\n\t\t\t   (USHORT)psia->Value[2],\n\t\t\t   (USHORT)psia->Value[3],\n\t\t\t   (USHORT)psia->Value[4],\n\t\t\t   (USHORT)psia->Value[5]);\n    }\n    else{\n       dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),\n\t\t\t   TEXT(\"%lu\"),\n\t\t\t   (ULONG)(psia->Value[5]      )   +\n\t\t\t   (ULONG)(psia->Value[4] <<  8)   +\n\t\t\t   (ULONG)(psia->Value[3] << 16)   +\n\t\t\t   (ULONG)(psia->Value[2] << 24)   );\n    }\n\n    //\n    // loop through SidSubAuthorities\n    //\n    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++){\n       dwSidSize+=wsprintf(pszSidText + dwSidSize, TEXT(\"-%lu\"),\n       *GetSidSubAuthority(pSid, dwCounter) );\n    }\n\n    return TRUE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* When using \"Prompt for filename\", suggest previous name used by user.\n * The previous filename is stored in the user registry.  \n * Since we are running as the Local System account and the \n * user registry isn't HKEY_CURRENT_USER, obtaint the SID for\n * the submitter and access the user registry under HKEY_USERS.\n * This only works if the user has logged into the computer interactively\n * once.  This isn't a problem because we don't allow \"Prompt for filename\"\n * unless the job is submitted locally.\n */\n", "func_signal": "void get_user_filename(LPTSTR pszSid, LPTSTR pszFileName, DWORD dwFileNameLen)", "code": "{\n    LONG rc;\n    HKEY hkey;\n    DWORD cbData;\n    DWORD dwType;\n    TCHAR pszKey[256];\n    DWORD dwKeyLen = sizeof(pszKey)/sizeof(TCHAR);\n\n#ifdef DEBUG_REDMON\n    syslog(TEXT(\"get_user_filename  \"));\n    syslog(pszSid);\n    syslog(TEXT(\"\\r\\n\"));\n#endif\n\n    if (lstrlen(pszSid) + lstrlen(REDMONUSERKEY) + 2 >= \n\tsizeof(pszKey)/sizeof(TCHAR)) {\n#ifdef DEBUG_REDMON\n\tsyslog(TEXT(\"pszKey buffer too small\\r\\n\"));\n#endif\n\treturn;\t/* buffer too small */\n    }\n    lstrcpy(pszKey, pszSid);\n    lstrcat(pszKey, TEXT(\"\\\\\"));\n    lstrcat(pszKey, REDMONUSERKEY);\n    \n    /* Open registry key for this SID */\n    /* We assume that the user has logged into this computer,\n     * so their registry hive is loaded under HKEY_USERS.\n     * If they are not logged in, this will fail. */\n    rc = RegOpenKeyEx(HKEY_USERS, pszKey, 0, KEY_READ, (PHKEY)&hkey);\n\n    if (rc == ERROR_SUCCESS) {\n\tcbData = dwFileNameLen;\n\trc = RegQueryValueEx(hkey, LASTFILEKEY, 0, &dwType, \n\t\t(PBYTE)(pszFileName), &cbData);\n#ifdef DEBUG_REDMON\n\tif (rc == ERROR_SUCCESS) {\n\t    syslog(TEXT(\"LastFile=\"));\n\t    syslog(pszFileName);\n\t    syslog(TEXT(\"\\r\\n\"));\n\t}\n\telse {\n\t    syslog(TEXT(\"No LastFile\\r\\n\"));\n\t}\n#endif\n\tRegCloseKey(hkey);\n    }\n#ifdef DEBUG_REDMON\n    else {\n\tsyslog(TEXT(\"RegOpenKeyEx \"));\n\tsyslog(pszKey);\n\tsyslog(TEXT(\"\\r\\n\"));\n\tsyserror(rc);\n    }\n#endif\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Configure Port dialog box */\n", "func_signal": "LRESULT CALLBACK \nConfigDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)", "code": "{\n    switch(message) {\n        case WM_INITDIALOG:\n\t    {\n\t    RECONFIG *config;\n\t    TCHAR buf[MAXSTR];\n\t    TCHAR str[MAXSTR];\n#ifdef OLD\n\t    HKEY hkey;\n\t    DWORD cbData, keytype;\n\t    DWORD show;\n\t    DWORD output;\n\t    DWORD runuser;\n\t    DWORD delay;\n\t    DWORD printerror;\n#endif\n\t    int i;\n\n\t    /* save pointer to configuration data */\n#if defined(_WIN64) || defined(GWLP_USERDATA)\n\t    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam);\n#else\n\t    SetWindowLong(hDlg, GWL_USERDATA, (LONG)lParam);\n#endif\n\t    config = (RECONFIG *)lParam;\n\n\t    SetDlgItemText(hDlg, IDC_COMMAND, config->szCommand);\n\t    SetDlgItemText(hDlg, IDC_ARGS, config->szArguments);\n\n\t    SendDlgItemMessage(hDlg, IDC_OUTPUT, CB_RESETCONTENT,\n\t\t(WPARAM)0, (LPARAM)0);\n\t    for (i=0; i<=OUTPUT_LAST; i++) {\n\t\tLoadString(hdll, IDS_OUTPUTBASE + i, buf, \n\t\t    sizeof(buf)/sizeof(TCHAR) - 1);\n\t\tSendDlgItemMessage(hDlg, IDC_OUTPUT, CB_ADDSTRING,\n\t\t    (WPARAM)0, (LPARAM)buf);\n\t    }\n\t    SendDlgItemMessage(hDlg, IDC_OUTPUT, CB_SETCURSEL,\n\t\t(WPARAM)config->dwOutput, (LPARAM)0);\n\n\t    init_printer_list(hDlg, config->szPortName);\n\t    if (SendDlgItemMessage(hDlg, IDC_PRINTER, CB_SELECTSTRING, -1, \n\t        (LPARAM)(config->szPrinter)) == CB_ERR)\n\t        SendDlgItemMessage(hDlg, IDC_PRINTER, CB_SETCURSEL, 0, 0);\n\n\t    EnableWindow(GetDlgItem(hDlg, IDC_PRINTER), \n\t      ((config->dwOutput == OUTPUT_STDOUT) \n\t\t|| (config->dwOutput == OUTPUT_FILE) \n\t\t|| (config->dwOutput == OUTPUT_HANDLE)) );\n\t    EnableWindow(GetDlgItem(hDlg, IDC_PRINTERTEXT), \n\t      ((config->dwOutput == OUTPUT_STDOUT) \n\t\t|| (config->dwOutput == OUTPUT_FILE) \n\t\t|| (config->dwOutput == OUTPUT_HANDLE)) );\n\n\t    SendDlgItemMessage(hDlg, IDC_SHOW, CB_RESETCONTENT,\n\t\t(WPARAM)0, (LPARAM)0);\n\t    for (i=0; i<=SHOW_HIDE; i++) {\n\t\tLoadString(hdll, IDS_SHOWBASE + i, buf, \n\t\t    sizeof(buf)/sizeof(TCHAR) - 1);\n\t\tSendDlgItemMessage(hDlg, IDC_SHOW, CB_ADDSTRING,\n\t\t    (WPARAM)0, (LPARAM)buf);\n\t    }\n\t    SendDlgItemMessage(hDlg, IDC_SHOW, CB_SETCURSEL,\n\t\t(WPARAM)config->dwShow, (LPARAM)0);\n\n\t    SendDlgItemMessage(hDlg, IDC_RUNUSER, BM_SETCHECK,\n\t\t(WPARAM)config->dwRunUser, (LPARAM)0);\n#ifndef UNICODE\n\t    EnableWindow(GetDlgItem(hDlg, IDC_RUNUSER), FALSE);\n#endif\n#if (defined(NT40) || defined(NT50)) && !defined(__BORLANDC__)\n\t    if (ntver >= 400)\n\t        EnableWindow(GetDlgItem(hDlg, IDC_RUNUSER), TRUE);\n#endif\n\n\t    SetDlgItemInt(hDlg, IDC_DELAY, config->dwDelay, FALSE);\n\n\n\t    SendDlgItemMessage(hDlg, IDC_PRINTERROR, BM_SETCHECK, \n\t\tconfig->dwPrintError, 0);\n\n\t    LoadString(hdll, IDS_CONFIGPROP, str, \n\t\tsizeof(str)/sizeof(TCHAR) - 1);\n\t    wsprintf(buf, str, config->szPortName);\n\t    SetWindowText(hDlg, buf);\n\t    SetForegroundWindow(hDlg);\n\t    }\n            return( TRUE);\n        case WM_COMMAND:\n            switch(LOWORD(wParam)) {\n\t      case IDC_HELPBUTTON:\n\t\t  show_help(hDlg, IDS_HELPCONFIG);\n                  return(TRUE);\n\t      case IDC_BROWSE:\n\t\t  browse(hDlg, IDC_COMMAND, IDS_FILTER_EXE, FALSE);\n                  return(TRUE);\n\t      case IDC_LOGFILE:\n\t\t  DialogBoxParam(hdll, MAKEINTRESOURCE(IDD_CONFIGLOG), hDlg, \n\t\t\tLogfileDlgProc, \n#if defined(_WIN64) || defined(GWLP_USERDATA)\n\t\t\t(LPARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA));\n#else\n\t\t\t(LPARAM)GetWindowLong(hDlg, GWL_USERDATA));\n#endif\n                  return(TRUE);\n\t      case IDC_OUTPUT:\n\t\t  if (HIWORD(wParam) == CBN_SELCHANGE)  {\n\t\t      int i = SendDlgItemMessage(hDlg, IDC_OUTPUT, \n\t\t\tCB_GETCURSEL, (WPARAM)0, (LPARAM)0);\n\t      \t      BOOL enabled = ((i == OUTPUT_STDOUT) || \n\t\t\t    (i == OUTPUT_FILE) || (i == OUTPUT_HANDLE));\n\t\t      EnableWindow(GetDlgItem(hDlg, IDC_PRINTER), enabled); \n\t\t      EnableWindow(GetDlgItem(hDlg, IDC_PRINTERTEXT), enabled); \n\t\t      EnableWindow(GetDlgItem(hDlg, IDC_PRINTERROR), enabled); \n\t\t  }\n                  return(TRUE);\n              case IDC_COMMAND:\n              case IDC_ARGS:\n                    return(TRUE);\n/* should we fall through to IDOK */\n\t      case IDOK:\n\t\t{\n\t\t    BOOL success;\n#if defined(_WIN64) || defined(GWLP_USERDATA)\n\t\t    RECONFIG *config = \n\t\t\t    (RECONFIG *)GetWindowLongPtr(hDlg, GWLP_USERDATA);\n#else\n\t\t    RECONFIG *config = \n\t\t\t    (RECONFIG *)GetWindowLong(hDlg, GWL_USERDATA);\n#endif\n\n\n\t\t    GetDlgItemText(hDlg, IDC_COMMAND, config->szCommand, \n\t\t\tsizeof(config->szCommand)/sizeof(TCHAR) - 1);\n\t\t    GetDlgItemText(hDlg, IDC_ARGS, config->szArguments, \n\t\t\tsizeof(config->szArguments)/sizeof(TCHAR) - 1);\n\t\t    config->dwOutput = SendDlgItemMessage(hDlg, IDC_OUTPUT, \n\t\t\tCB_GETCURSEL, (WPARAM)0, (LPARAM)0);\n\t\t    GetDlgItemText(hDlg, IDC_PRINTER, config->szPrinter, \n\t\t\tsizeof(config->szPrinter)/sizeof(TCHAR) - 1);\n\t\t    config->dwShow = SendDlgItemMessage(hDlg, IDC_SHOW, \n\t\t\tCB_GETCURSEL, (WPARAM)0, (LPARAM)0);\n\t\t    config->dwRunUser = (BOOL)SendDlgItemMessage(hDlg, \n\t\t\tIDC_RUNUSER, BM_GETCHECK, 0, 0);\n\t\t    config->dwDelay = (DWORD)GetDlgItemInt(hDlg, IDC_DELAY, \n\t\t\t&success, FALSE);\n \t\t    if (!success)\n\t\t\tconfig->dwDelay = DEFAULT_DELAY;\n\t\t    if ((config->dwOutput == OUTPUT_STDOUT) \n\t\t\t|| (config->dwOutput == OUTPUT_FILE) \n\t\t\t|| (config->dwOutput == OUTPUT_HANDLE)) {\n\t\t\tconfig->dwPrintError = SendDlgItemMessage(hDlg, \n\t\t\t    IDC_PRINTERROR, BM_GETCHECK, 0, 0);\n\t\t    }\n\t\t}\n\t\tEndDialog(hDlg, TRUE);\n\t\treturn(TRUE);\n\t      case IDCANCEL:\n                EndDialog(hDlg, FALSE);\n                return(TRUE);\n              default:\n                return(FALSE);\n            }\n        default:\n            return(FALSE);\n    }\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* The log file is single byte characters only */\n/* Write a single character or wide character string to the log file,\n * converting it to single byte characters */\n", "func_signal": "void write_string_to_log(REDATA *prd, LPCTSTR buf)", "code": "{\nDWORD cbWritten;\n#ifdef UNICODE\nint count;\nCHAR cbuf[256];\nBOOL UsedDefaultChar;\n#endif\n    if (prd->hLogFile == INVALID_HANDLE_VALUE)\n\treturn;\n\n    request_mutex(prd);\n#ifdef UNICODE\n    while (lstrlen(buf)) {\n\tcount = min(lstrlen(buf), sizeof(cbuf));\n\tWideCharToMultiByte(CP_ACP, 0, buf, count,\n\t\tcbuf, sizeof(cbuf), NULL, &UsedDefaultChar);\n\tbuf += count;\n\tWriteFile(prd->hLogFile, cbuf, count, &cbWritten, NULL);\n    }\n#else\n    WriteFile(prd->hLogFile, buf, lstrlen(buf), &cbWritten, NULL);\n#endif\n    FlushFileBuffers(prd->hLogFile);\n    release_mutex(prd);\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* Get a text format SID, so we can access the local user\n * profile under HKEY_USERS.\n */\n", "func_signal": "BOOL GetSid(LPTSTR pszSidText, LPDWORD dwSidTextLen)", "code": "{\n    BOOL flag = TRUE;\n    HANDLE htoken = INVALID_HANDLE_VALUE;\n    TOKEN_INFORMATION_CLASS tic = TokenUser;\n    TOKEN_USER *ptu = NULL;\n    DWORD dwReturnLength = 0;\n    DWORD dwTokenUserLength = 0;\n\n#ifdef DEBUG_REDMON\n    syslog(TEXT(\"GetSid\\r\\n\"));\n#endif\n\n    /* get impersonation token of current thread */\n    if ( !(flag = OpenThreadToken(GetCurrentThread() , \n        TOKEN_IMPERSONATE | TOKEN_DUPLICATE,\n\tTRUE,\n\t&htoken)) ) {\n\tDWORD err = GetLastError();\n#ifdef DEBUG_REDMON\n\tsyslog(TEXT(\"OpenThreadToken failed\\r\\n\"));\n\tsyserror(err);\n#endif\n    }\n\n    /* duplicate the token so we can query it */\n    if (flag) {\n\tHANDLE hduptoken = INVALID_HANDLE_VALUE;\n\tif ( !(flag = DuplicateTokenEx(htoken, TOKEN_QUERY, NULL, \n\t       SecurityImpersonation, TokenPrimary, &hduptoken)) ) {\n#ifdef DEBUG_REDMON\n\t    DWORD err = GetLastError();\n\t    syslog(TEXT(\"DuplicateTokenEx\\r\\n\"));\n\t    syserror(err);\n#endif\n\t}\n        CloseHandle(htoken);\n\thtoken = hduptoken;\n    }\n\n    if (flag)\n\tGetTokenInformation(htoken, tic, (LPVOID)ptu, \n\t    dwTokenUserLength, &dwReturnLength);\n\n    if (flag  && (dwReturnLength != 0) && \n\t(GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {\n\tHGLOBAL hglobal = GlobalAlloc(GPTR, (DWORD)dwReturnLength);\n\tptu = GlobalLock(hglobal);\n\tif (ptu == NULL) {\n\t    flag = FALSE;\n#ifdef DEBUG_REDMON\n\t    syslog(TEXT(\"Failed to allocate memory for SID\\r\\n\"));\n#endif\n\t}\n\tdwTokenUserLength = dwReturnLength;\n\tdwReturnLength = 0;\n\tif (flag) {\n\t    flag = GetTokenInformation(htoken, tic, (LPVOID)ptu,\n\t\tdwTokenUserLength, &dwReturnLength);\n#ifdef DEBUG_REDMON\n\t    if (!flag) {\t\n\t\tDWORD err = GetLastError();\n\t\tsyslog(TEXT(\"GetTokenInformation\\r\\n\"));\n\t\tsyserror(err);\n\t    }\n#endif\n\t}\n\tif (flag)\n\t    flag = ConvertSid((ptu->User.Sid), pszSidText, dwSidTextLen);\n\tGlobalUnlock(hglobal);\n\tGlobalFree(hglobal);\n    }\n    else\n\tflag = FALSE;\n\n\n    if (htoken != INVALID_HANDLE_VALUE)\n\tCloseHandle(htoken);\n\n#ifdef DEBUG_REDMON\n    if (flag) {\n\tsyslog(TEXT(\" \"));\n\tsyslog(pszSidText);\n\tsyslog(TEXT(\"\\r\\n\"));\n    }\n    else\n\tsyslog(TEXT(\" failed\\r\\n\"));\n#endif\n    if (flag)\n\t*dwSidTextLen = lstrlen(pszSidText);\n    else\n\t*dwSidTextLen = 0;\n    return flag;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* WritePort is normally called between StartDocPort and EndDocPort,\n * but can be called outside this pair for bidirectional printers.\n */\n", "func_signal": "BOOL redmon_write_port(REDATA *prd, LPBYTE  pBuffer, \n        DWORD   cbBuf, LPDWORD pcbWritten)", "code": "{\n    TCHAR buf[MAXSTR];\n    unsigned int sleep_count;\n\n    if (prd == (REDATA *)NULL) {\n\tSetLastError(ERROR_INVALID_HANDLE);\n\treturn FALSE;\n    }\n\n    *pcbWritten = 0;\n\n    if (!prd->started) {\n\tif (prd->config.dwLogFileDebug) {\n\t    wsprintf(buf, \n\t      TEXT(\"REDMON WritePort: called outside Start/EndDocPort.  Returning FALSE\\r\\n\"));\n\t    MessageBox(NULL, buf, MONITORNAME, MB_OK);\n\t}\n\treturn FALSE;\n    }\n\n    /* copy from output pipes to printer or log file */\n    flush_stdout(prd);\n\n    /* Make sure process is still running */\n    check_process(prd);\n\n    if (prd->error) {\n\t/* The process is no longer running, probably due to an error. */\n\t/* If we return an error from WritePort, the spooler crashes.\n\t * To avoid this mess, don't return an error from WritePort.\n\t * Instead carry on as if the error didn't occur.\n\t * The only evidence of an error will be the log file.\n\t */\n\t*pcbWritten = cbBuf;\t/* say we wrote it all */\n\tif (prd->config.dwLogFileDebug \n\t    && (prd->hLogFile != INVALID_HANDLE_VALUE)) {\n\t    wsprintf(buf, \n\t      TEXT(\"\\r\\nREDMON WritePort: Process not running. \\\nReturning TRUE.\\r\\n    Ignoring %d bytes\\r\\n\"), cbBuf);\n\t    write_string_to_log(prd, buf);\n\t}\n\n\t/* Cancel the print job */\n\tredmon_cancel_job(prd);\n\n\treturn TRUE;\t/* say we wrote it all */\n    }\n\n    if (prd->config.dwLogFileDebug && (prd->hLogFile != INVALID_HANDLE_VALUE)) {\n\twsprintf(buf, \n\t TEXT(\"\\r\\nREDMON WritePort: about to write %d bytes to port.\\r\\n\"),\n\t cbBuf);\n\twrite_string_to_log(prd, buf);\n    }\n\n\n    /* write to stdin pipe */\n    prd->write_buffer_length = cbBuf;\n    prd->write_buffer = pBuffer;\n    prd->write_flag = TRUE;\n    prd->write_written = 0;\n    SetEvent(prd->write_event);\n    if (prd->write && prd->write_buffer_length) {\n\tflush_stdout(prd);\n\tcheck_process(prd);\n\tSleep(0);\n    }\n    sleep_count = 0;\n    while (!prd->error && prd->write && prd->write_buffer_length) {\n\t/* wait for it to be written, while flushing stdout */\n\tif (flush_stdout(prd)) {\n\t    /* We succeeded in reading something from one of the\n\t     * pipes and the pipes are now empty.  Give up the\n\t     * remainder of our time slice to allow the\n\t     * other process to write something to the pipes\n\t     * or to read from stdin.\n\t     */\n\t    sleep_count = 0;\n\t    Sleep(0);\n\t}\n\telse if (prd->write_buffer_length) {\n\t    /* The pipes were empty, and the other process\n\t     * hasn't finished reading stdin.\n\t     * Pause a little until something is available or\n\t     * until stdin has been read.\n\t     * If the process is very slow and doesn't read stdin \n\t     * within a reasonable time, sleep for 100ms to avoid \n\t     * wasting CPU.\n\t     */\n\t    if (sleep_count < 10)\n\t\tSleep(sleep_count * 5);\n\t    else\n\t        Sleep(100);\n\t    sleep_count++;\n\t}\n\t/* Make sure process is still running */\n\tcheck_process(prd);\n    }\n    *pcbWritten = prd->write_written;\n\n    if (prd->error)\n        *pcbWritten = cbBuf;\n\n    if (prd->config.dwLogFileDebug && (prd->hLogFile != INVALID_HANDLE_VALUE)) {\n\tDWORD cbWritten;\n\trequest_mutex(prd);\n        WriteFile(prd->hLogFile, pBuffer, cbBuf, &cbWritten, NULL);\n\tFlushFileBuffers(prd->hLogFile);\n\trelease_mutex(prd);\n\twsprintf(buf, \n\t  TEXT(\"\\r\\nREDMON WritePort: %s  count=%d written=%d\\r\\n\"), \n\t      (prd->write_flag ? TEXT(\"OK\") : TEXT(\"Failed\")),\n\t      cbBuf, *pcbWritten);\n\twrite_string_to_log(prd, buf);\n    }\n\n    flush_stdout(prd);\n\n    if (prd->error) {\n\tif (prd->config.dwLogFileDebug \n\t    && (prd->hLogFile != INVALID_HANDLE_VALUE)) {\n\t    wsprintf(buf, \n\t      TEXT(\"\\r\\nREDMON WritePort: Process not running. \\\nReturning TRUE.\\r\\n    Ignoring %d bytes\\r\\n\"), cbBuf);\n\t    write_string_to_log(prd, buf);\n\t}\n\t/* Cancel the print job */\n\tredmon_cancel_job(prd);\n    }\n\n    return TRUE;\t/* returning FALSE crashes Win95 spooler */\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* write contents of the environment block to the log file */\n", "func_signal": "void\ndump_env(REDATA *prd, LPTSTR env)", "code": "{\nLPTSTR name, next;\n    write_string_to_log(prd, TEXT(\"Environment:\\n  \"));\n    next = env;\n    while (*next) {\n        name = next;\n\twhile (*next)\n\t    next++;\n\twrite_string_to_log(prd, name);\n\twrite_string_to_log(prd, TEXT(\"\\n  \"));\n\tnext++;\n    }\n    write_string_to_log(prd, TEXT(\"\\n\"));\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/* True Win32 method, using OpenPrinter, WritePrinter etc. */\n", "func_signal": "int \nredmon_printfile(REDATA * prd, TCHAR *filename)", "code": "{\nHGLOBAL hbuffer;\nBYTE *buffer;\nDWORD cbRead;\nHANDLE hread;\n\n    if (prd->config.szPrinter[0] == '\\0')\n\treturn FALSE;\n\n    /* allocate buffer for reading data */\n    if ((hbuffer = GlobalAlloc(GPTR, (DWORD)PRINT_BUF_SIZE)) == NULL)\n\treturn FALSE;\n    if ((buffer = (BYTE *)GlobalLock(hbuffer)) == (BYTE *)NULL) {\n\tGlobalFree(hbuffer);\n        return FALSE;\n    }\n\t\n    /* open file to print */\n    if ((hread = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, \n\tNULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE) {\n\tif (prd->config.dwLogFileDebug) {\n\t    DWORD err = GetLastError();\n\t    TCHAR buf[256];\n\t    wsprintf(buf, TEXT(\"CreateFile() failed, error code = %d\\r\\n\"), \n\t\terr);\n\t    write_string_to_log(prd, buf);\n\t    write_error(prd, err);\n\t}\n\tGlobalUnlock(hbuffer);\n\tGlobalFree(hbuffer);\n\treturn FALSE;\n    }\n\n    /* open a printer */\n    if (!redmon_open_printer(prd)) {\n\tCloseHandle(hread);\n\tGlobalUnlock(hbuffer);\n\tGlobalFree(hbuffer);\n\treturn FALSE;\n    }\n\n    while (ReadFile(hread, buffer, PRINT_BUF_SIZE, &cbRead, NULL)\n\t\t&& cbRead) {\n\tif (!redmon_write_printer(prd, buffer, cbRead)) {\n\t    CloseHandle(hread);\n\t    redmon_abort_printer(prd);\n\t    return FALSE;\n\t}\n    }\n    CloseHandle(hread);\n    GlobalUnlock(hbuffer);\n    GlobalFree(hbuffer);\n\n    redmon_close_printer(prd);\n\n    return TRUE;\n}", "path": "src\\redmon.c", "repo_name": "jonasoberschweiber/redmon", "stars": 15, "license": "None", "language": "c", "size": 437}
{"docstring": "/////////\n// PPD //\n/////////\n", "func_signal": "static PyObject *\nPPD_new (PyTypeObject *type, PyObject *args, PyObject *kwds)", "code": "{\n  PPD *self;\n  self = (PPD *) type->tp_alloc (type, 0);\n  if (self != NULL) {\n    self->ppd = NULL;\n    self->file = NULL;\n    self->conv_from = NULL;\n    self->conv_to = NULL;\n  }\n\n  return (PyObject *) self;\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "////////////////\n// Constraint // ATTRIBUTES\n////////////////\n", "func_signal": "static PyObject *\nConstraint_getOption1 (Constraint *self, void *closure)", "code": "{\n  if (!self->constraint) {\n    Py_INCREF (Py_None);\n    return Py_None;\n  }\n\n  return make_PyUnicode_from_ppd_string (self->ppd, self->constraint->option1);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/////////\n// PPD // METHODS\n/////////\n", "func_signal": "static PyObject *\nPPD_localize (PPD *self)", "code": "{\n  if (!ppdLocalize (self->ppd))\n    return Py_None;\n  return PyErr_SetFromErrno (PyExc_RuntimeError);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * emit JCL end by writing to a file object.\n */\n", "func_signal": "static PyObject *\nPPD_emitJCLEnd (PPD *self, PyObject *args)", "code": "{\n  PyObject *pyFile;\n  FILE *f;\n\n  if (!PyArg_ParseTuple (args, \"O\", &pyFile))\n    return NULL;\n\n  f = PyFile_AsFile(pyFile);\n  if (!f)\n    return NULL;\n\n  if (!ppdEmitJCLEnd(self->ppd, f))\n    return Py_None;\n  return PyErr_SetFromErrno (PyExc_RuntimeError);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "////////////////\n// Connection //\n////////////////\n", "func_signal": "static PyObject *\nConnection_new (PyTypeObject *type, PyObject *args, PyObject *kwds)", "code": "{\n  Connection *self;\n  self = (Connection *) type->tp_alloc (type, 0);\n  if (self != NULL) {\n    self->http = NULL;\n    self->host = NULL;\n    self->tstate = NULL;\n#ifdef HAVE_CUPS_1_4\n    self->cb_password = NULL;\n#endif /* HAVE_CUPS_1_4 */\n  }\n\n  return (PyObject *) self;\n}", "path": "cupsconnection.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/////////////////////////\n// Encoding conversion //\n/////////////////////////\n", "func_signal": "static int\nppd_encoding_is_utf8 (PPD *ppd)", "code": "{\n  const char *lang_encoding, *from_encoding;\n  iconv_t cdf, cdt;\n  if (ppd->conv_from != NULL)\n    return 0;\n\n  lang_encoding = ppd->ppd->lang_encoding;\n  if (lang_encoding && !strcasecmp (lang_encoding, \"UTF-8\"))\n    return 1;\n\n  if (lang_encoding && !strcasecmp (lang_encoding, \"ISOLatin1\"))\n    from_encoding = \"ISO-8859-1\";\n  else if (lang_encoding && !strcasecmp (lang_encoding, \"ISOLatin2\"))\n    from_encoding = \"ISO-8859-2\";\n  else if (lang_encoding && !strcasecmp (lang_encoding, \"ISOLatin5\"))\n    from_encoding = \"ISO-8859-5\";\n  else if (lang_encoding && !strcasecmp (lang_encoding, \"JIS83-RKSJ\"))\n    from_encoding = \"SHIFT-JIS\";\n  else if (lang_encoding && !strcasecmp (lang_encoding, \"MacStandard\"))\n    from_encoding = \"MACINTOSH\";\n  else if (lang_encoding && !strcasecmp (lang_encoding, \"WindowsANSI\"))\n    from_encoding = \"WINDOWS-1252\";\n  else\n    // Guess\n    from_encoding = \"ISO-8859-1\";\n\n  cdf = iconv_open (\"UTF-8\", from_encoding);\n  if (cdf == (iconv_t) -1)\n    cdf = iconv_open (\"UTF-8\", \"ISO-8859-1\");\n\n  cdt = iconv_open (from_encoding, \"UTF-8\");\n  if (cdt == (iconv_t) -1)\n    cdt = iconv_open (\"ISO-8859-1\", \"UTF-8\");\n\n  ppd->conv_from = malloc (sizeof (iconv_t));\n  *ppd->conv_from = cdf;\n\n  ppd->conv_to = malloc (sizeof (iconv_t));\n  *ppd->conv_to = cdt;\n\n  return 0;\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/* HAVE_CUPS_1_4 */\n", "func_signal": "static PyObject *\ncups_ppdSetConformance (PyObject *self, PyObject *args)", "code": "{\n  int level;\n  if (!PyArg_ParseTuple (args, \"i\", &level))\n    return NULL;\n\n  ppdSetConformance (level);\n  Py_INCREF (Py_None);\n  return Py_None;\n}", "path": "cupsmodule.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/////////\n// PPD // ATTRIBUTES\n/////////\n", "func_signal": "static PyObject *\nPPD_getConstraints (PPD *self, void *closure)", "code": "{\n  PyObject *ret = PyList_New (0);\n  ppd_const_t *c;\n  int i;\n  for (i = 0, c = self->ppd->consts;\n       i < self->ppd->num_consts;\n       i++, c++) {\n    PyObject *args = Py_BuildValue (\"()\");\n    PyObject *kwlist = Py_BuildValue (\"{}\");\n    Constraint *cns = (Constraint *) PyType_GenericNew (&cups_ConstraintType,\n\t\t\t\t\t\t\targs, kwlist);\n    Py_DECREF (args);\n    Py_DECREF (kwlist);\n    cns->constraint = c;\n    cns->ppd = self;\n    Py_INCREF (self);\n    PyList_Append (ret, (PyObject *) cns);\n  }\n\n  return ret;\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * A rudimentary emulation of getline() for systems that dont support it\n * natively.  Since this is used for PPD file reading, it assumes (possibly\n * falsely) that BUFSIZ is big enough.\n */\n", "func_signal": "ssize_t\ngetline(char **line, size_t *linelen, FILE *fp)", "code": "{\n  if (*linelen == 0) {\n    *linelen = BUFSIZ;\n    *line = malloc(*linelen);\n  }\n\n  memset(*line, 0, *linelen);\n  fgets(*line, *linelen, fp);\n\n  return (strlen(*line));\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "//////////////////\n// IPPAttribute //\n//////////////////\n", "func_signal": "static PyObject *\nIPPAttribute_new (PyTypeObject *type, PyObject *args, PyObject *kwds)", "code": "{\n  IPPAttribute *self;\n  self = (IPPAttribute *) type->tp_alloc (type, 0);\n  if (self != NULL) {\n    self->group_tag = IPP_TAG_ZERO;\n    self->value_tag = IPP_TAG_ZERO;\n    self->name = NULL;\n    self->values = NULL;\n  }\n\n  return (PyObject *) self;\n}", "path": "cupsipp.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/* HAVE_CUPS_1_4 */\n", "func_signal": "static PyObject *\nConnection_printTestPage (Connection *self, PyObject *args, PyObject *kwds)", "code": "{\n  PyObject *printerobj;\n  char *printer;\n  PyObject *fileobj = NULL;\n  char *file = NULL;\n  PyObject *titleobj = NULL;\n  char *title = NULL;\n  PyObject *formatobj = NULL;\n  char *format = NULL;\n  PyObject *userobj = NULL;\n  char *user = NULL;\n  const char *datadir;\n  char filename[PATH_MAX];\n  char uri[HTTP_MAX_URI];\n  ipp_t *request, *answer;\n  ipp_attribute_t *attr;\n  char *resource;\n  int jobid = 0;\n  int i;\n  static char *kwlist[] = { \"name\", \"file\", \"title\", \"format\", \"user\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords (args, kwds, \"O|OOOO\", kwlist,\n\t\t\t\t    &printerobj, &fileobj, &titleobj,\n\t\t\t\t    &formatobj, &userobj))\n    return NULL;\n\n  if (UTF8_from_PyObj (&printer, printerobj) == NULL)\n    return NULL;\n\n  if ((fileobj && UTF8_from_PyObj (&file, fileobj) == NULL) ||\n      (titleobj && UTF8_from_PyObj (&title, titleobj) == NULL) ||\n      (formatobj && UTF8_from_PyObj (&format, formatobj) == NULL) ||\n      (userobj && UTF8_from_PyObj (&user, userobj) == NULL)) {\n    free (printer);\n    free (file);\n    free (title);\n    free (format);\n    free (user);\n    return NULL;\n  }\n    \n  if (!fileobj) {\n    const char *testprint[] = { \"%s/data/testprint\",\n\t\t\t\t\"%s/data/testprint.ps\",\n\t\t\t\tNULL };\n    if ((datadir = getenv (\"CUPS_DATADIR\")) != NULL) {\n      const char **pattern;\n      for (pattern = testprint; *pattern != NULL; pattern++) {\n\tsnprintf (filename, sizeof (filename), *pattern, datadir);\n\tif (access (filename, R_OK) == 0)\n\t  break;\n      }\n    } else {\n      const char *const dirs[] = { \"/usr/share/cups\",\n\t\t\t\t   \"/usr/local/share/cups\",\n\t\t\t\t   NULL };\n      int found = 0;\n      int i;\n      for (i = 0; (datadir = dirs[i]) != NULL; i++) {\n\tconst char **pattern;\n\tfor (pattern = testprint; *pattern != NULL; pattern++) {\n\t  snprintf (filename, sizeof (filename), *pattern, datadir);\n\t  if (access (filename, R_OK) == 0) {\n\t    found = 1;\n\t    break;\n\t  }\n\t}\n\n\tif (found)\n\t  break;\n      }\n\n      if (datadir == NULL)\n\t/* We haven't found the testprint.ps file, so just pick a path\n\t * and try it.  This will certainly fail with\n\t * client-error-not-found, but we'll let that happen rather\n\t * than raising an exception so as to be consistent with the\n\t * case where CUPS_DATADIR is set and we trust it. */\n\tsnprintf (filename, sizeof (filename), testprint[0], dirs[0]);\n    }\n\n    file = filename;\n  }\n\n  if (!titleobj)\n    title = \"Test Page\";\n\n  if (!userobj)\n\t  user = (char *) cupsUser();\n\n  snprintf (uri, sizeof (uri), \"ipp://localhost/printers/%s\", printer);\n  resource = uri + strlen (\"ipp://localhost\");\n  for (i = 0; i < 2; i++) {\n    request = ippNewRequest (IPP_PRINT_JOB);\n    ippAddString (request, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\",\n\t\t  NULL, uri);\n    ippAddString (request, IPP_TAG_OPERATION, IPP_TAG_NAME,\n\t\t  \"requesting-user-name\", NULL, user);\n    ippAddString (request, IPP_TAG_OPERATION, IPP_TAG_NAME, \"job-name\",\n\t\t  NULL, title);\n    if (format)\n      ippAddString (request, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format\",\n\t\t    NULL, format);\n\n    Connection_begin_allow_threads (self);\n    answer = cupsDoFileRequest (self->http, request, resource, file);\n    Connection_end_allow_threads (self);\n    if (answer && answer->request.status.status_code == IPP_NOT_POSSIBLE) {\n      ippDelete (answer);\n      // Perhaps it's a class, not a printer.\n      snprintf (uri, sizeof (uri), \"ipp://localhost/classes/%s\", printer);\n    } else break;\n  }\n\n  free (printer);\n  if (fileobj)\n    free (file);\n  if (titleobj)\n    free (title);\n  if (formatobj)\n    free (format);\n  if (userobj)\n    free (user);\n\n  if (!answer || answer->request.status.status_code > IPP_OK_CONFLICT) {\n    set_ipp_error (answer ?\n\t\t   answer->request.status.status_code :\n\t\t   cupsLastError ());\n    if (answer)\n      ippDelete (answer);\n    return NULL;\n  }\n\n  attr = ippFindAttribute (answer, \"job-id\", IPP_TAG_INTEGER);\n  if (attr)\n    jobid = attr->values[0].integer;\n\n  ippDelete (answer);\n  return Py_BuildValue (\"i\", jobid);\n}", "path": "cupsconnection.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * emit marked options by returning a string.\n */\n", "func_signal": "static PyObject *\nPPD_emitString (PPD *self, PyObject *args)", "code": "{\n  ppd_section_t section;\n  float min_order;\n  char *emitted;\n  PyObject *ret;\n\n  if (!PyArg_ParseTuple (args, \"if\", &section, &min_order))\n    return NULL;\n\n  emitted = ppdEmitString(self->ppd, section, min_order);\n\n  if (emitted) {\n    ret = PyString_FromString(emitted);\n    free (emitted);\n  } else {\n    ret = Py_None;\n  }\n\n  Py_INCREF (ret);\n\n  return ret;\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/* !HAVE_CUPS_1_4 */\n", "func_signal": "static PyObject *\ndo_printer_request (Connection *self, PyObject *args, PyObject *kwds,\n\t\t    ipp_op_t op)", "code": "{\n  PyObject *nameobj;\n  PyObject *reasonobj = NULL;\n  char *name;\n  char uri[HTTP_MAX_URI];\n  ipp_t *request, *answer;\n\n  switch (op) {\n  case IPP_PAUSE_PRINTER:\n  case CUPS_REJECT_JOBS:\n    {\n      static char *kwlist[] = { \"name\", \"reason\", NULL };\n      if (!PyArg_ParseTupleAndKeywords (args, kwds, \"O|O\", kwlist,\n\t\t\t\t\t&nameobj, &reasonobj))\n\treturn NULL;\n      break;\n    }\n\n  default:\n    if (!PyArg_ParseTuple (args, \"O\", &nameobj))\n      return NULL;\n    break;\n  }\n\n  if (UTF8_from_PyObj (&name, nameobj) == NULL)\n    return NULL;\n\n  debugprintf (\"-> do_printer_request(op:%d, name:%s)\\n\", (int) op, name);\n\n  request = ippNewRequest (op);\n  snprintf (uri, sizeof (uri), \"ipp://localhost/printers/%s\", name);\n  free (name);\n\n  ippAddString (request, IPP_TAG_OPERATION, IPP_TAG_URI,\n\t\t\"printer-uri\", NULL, uri);\n\n  if (reasonobj) {\n    char *reason;\n    if (UTF8_from_PyObj (&reason, reasonobj) == NULL) {\n      ippDelete (request);\n      return NULL;\n    }\n\n    debugprintf (\"reason: %s\\n\", reason);\n    ippAddString (request, IPP_TAG_OPERATION, IPP_TAG_TEXT,\n\t\t  \"printer-state-message\", NULL, reason);\n    free (reason);\n  }\n\n  debugprintf (\"cupsDoRequest(\\\"/admin/\\\")\\n\");\n  Connection_begin_allow_threads (self);\n  answer = cupsDoRequest (self->http, request, \"/admin/\");\n  Connection_end_allow_threads (self);\n  if (PyErr_Occurred ()) {\n    if (answer)\n      ippDelete (answer);\n    debugprintf(\"<- do_printer_request (error)\\n\");\n    return NULL;\n  }\n\n  if (!answer || answer->request.status.status_code > IPP_OK_CONFLICT) {\n    set_ipp_error (answer ?\n\t\t   answer->request.status.status_code :\n\t\t   cupsLastError ());\n    if (answer)\n      ippDelete (answer);\n    debugprintf(\"<- do_printer_request (error)\\n\");\n    return NULL;\n  }\n\n  ippDelete (answer);\n  Py_INCREF (Py_None);\n  debugprintf(\"<- do_printer_request (None)\\n\");\n  return Py_None;\n}", "path": "cupsconnection.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "//////////////////////////\n// Module-level methods //\n//////////////////////////\n", "func_signal": "static PyObject *\ncups_modelSort (PyObject *self, PyObject *args)", "code": "{\n  PyObject *Oa, *Ob, *a, *b;\n  int len_a, len_b;\n  size_t size_a, size_b;\n  wchar_t *wca, *wcb;\n\n  if (!PyArg_ParseTuple (args, \"OO\", &Oa, &Ob))\n    return NULL;\n\n  a = PyUnicode_FromObject (Oa);\n  b = PyUnicode_FromObject (Ob);\n  if (a == NULL || b == NULL || !PyUnicode_Check (a) || !PyUnicode_Check (b)) {\n    if (a) {\n      Py_DECREF (a);\n    }\n    if (b) {\n      Py_DECREF (b);\n    }\n\n    PyErr_SetString (PyExc_TypeError, \"Unable to convert to Unicode\");\n    return NULL;\n  }\n\n  len_a = 1 + PyUnicode_GetSize (a);\n  size_a = len_a * sizeof (wchar_t);\n  if ((size_a / sizeof (wchar_t)) != len_a) {\n    Py_DECREF (a);\n    Py_DECREF (b);\n    PyErr_SetString (PyExc_RuntimeError, \"String too long\");\n    return NULL;\n  }\n\n  len_b = 1 + PyUnicode_GetSize (b);\n  size_b = len_b * sizeof (wchar_t);\n  if ((size_b / sizeof (wchar_t)) != len_b) {\n    Py_DECREF (a);\n    Py_DECREF (b);\n    PyErr_SetString (PyExc_RuntimeError, \"String too long\");\n    return NULL;\n  }\n\n  wca = malloc (size_a);\n  wcb = malloc (size_b);\n  if (wca == NULL || wcb == NULL) {\n    Py_DECREF (a);\n    Py_DECREF (b);\n    free (wca);\n    free (wcb);\n    PyErr_SetString (PyExc_RuntimeError, \"Insufficient memory\");\n    return NULL;\n  }\n\n  PyUnicode_AsWideChar ((PyUnicodeObject *) a, wca, size_a);\n  PyUnicode_AsWideChar ((PyUnicodeObject *) b, wcb, size_b);\n  Py_DECREF (a);\n  Py_DECREF (b);\n  return Py_BuildValue (\"i\", do_model_compare (wca, wcb));\n}", "path": "cupsmodule.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * emit marked options by writing to a file object.\n */\n", "func_signal": "static PyObject *\nPPD_emit (PPD *self, PyObject *args)", "code": "{\n  PyObject *pyFile;\n  ppd_section_t section;\n  FILE *f;\n\n  if (!PyArg_ParseTuple (args, \"Oi\", &pyFile, &section))\n    return NULL;\n\n  f = PyFile_AsFile(pyFile);\n  if (!f)\n    return NULL;\n\n  if (!ppdEmit(self->ppd, f, section))\n    return Py_None;\n  return PyErr_SetFromErrno (PyExc_RuntimeError);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * emit marked options by writing to a file descriptor.\n */\n", "func_signal": "static PyObject *\nPPD_emitFd (PPD *self, PyObject *args)", "code": "{\n  ppd_section_t section;\n  int f;\n\n  if (!PyArg_ParseTuple (args, \"ii\", &f, &section))\n    return NULL;\n\n  if (!ppdEmitFd(self->ppd, f, section))\n    return Py_None;\n  return PyErr_SetFromErrno (PyExc_RuntimeError);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "///////////////\n// Attribute // ATTRIBUTES\n///////////////\n", "func_signal": "static PyObject *\nAttribute_getName (Attribute *self, void *closure)", "code": "{\n  if (!self->attribute) {\n    Py_INCREF (Py_None);\n    return Py_None;\n  }\n\n  return make_PyUnicode_from_ppd_string (self->ppd, self->attribute->name);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "//////////////////////\n// Worker functions //\n//////////////////////\n", "func_signal": "static void\ndestroy_TLS (void *value)", "code": "{\n  struct TLS *tls = (struct TLS *) value;\n  Py_XDECREF (tls->cups_password_callback);\n\n#if HAVE_CUPS_1_4\n  Py_XDECREF (tls->cups_password_callback_context);\n#endif /* HAVE_CUPS_1_4 */\n\n  free (value);\n}", "path": "cupsmodule.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "///////////\n// Group // ATTRIBUTES\n///////////\n", "func_signal": "static PyObject *\nGroup_getText (Group *self, void *closure)", "code": "{\n  if (!self->group) {\n    Py_INCREF (Py_None);\n    return Py_None;\n  }\n\n  return make_PyUnicode_from_ppd_string (self->ppd, self->group->text);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "/*\n * emit marked options after order dependency by writing to a file object.\n */\n", "func_signal": "static PyObject *\nPPD_emitAfterOrder (PPD *self, PyObject *args)", "code": "{\n  PyObject *pyFile;\n  ppd_section_t section;\n  FILE *f;\n  int limit;\n  float min_order;\n\n  if (!PyArg_ParseTuple (args, \"Oiif\", &pyFile, &section, &limit, &min_order))\n    return NULL;\n\n  f = PyFile_AsFile(pyFile);\n  if (!f)\n    return NULL;\n\n  if (!ppdEmitAfterOrder(self->ppd, f, section, limit, min_order))\n    return Py_None;\n  return PyErr_SetFromErrno (PyExc_RuntimeError);\n}", "path": "cupsppd.c", "repo_name": "narisipalli/pycups", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 440}
{"docstring": "//------------------------------------------------------------------------------\n/// Initializes the PIO interrupt management logic. The desired priority of PIO\n/// interrupts must be provided. Calling this function multiple times result in\n/// the reset of currently configured interrupts.\n/// \\param priority  PIO controller interrupts priority.\n//------------------------------------------------------------------------------\n", "func_signal": "void PIO_InitializeInterrupts(unsigned int priority)", "code": "{\n    TRACE_DEBUG(\"PIO_Initialize()\\n\\r\");\n\n//    SANITY_CHECK((priority & ~AT91C_AIC_PRIOR) == 0);\n\n    // Reset sources\n    numSources = 0;\n\n#ifdef AT91C_ID_PIOA\n    // Configure PIO interrupt sources\n    TRACE_DEBUG(\"PIO_Initialize: Configuring PIOA\\n\\r\");\n    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;\n    AT91C_BASE_PIOA->PIO_ISR;\n    AT91C_BASE_PIOA->PIO_IDR = 0xFFFFFFFF;\n    IRQ_ConfigureIT(AT91C_ID_PIOA, priority, PIO_IT_InterruptHandler);\n    IRQ_EnableIT(AT91C_ID_PIOA);\n#endif\n\n#ifdef AT91C_ID_PIOB\n    TRACE_DEBUG(\"PIO_Initialize: Configuring PIOB\\n\\r\");\n    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOB;\n    AT91C_BASE_PIOB->PIO_ISR;\n    AT91C_BASE_PIOB->PIO_IDR = 0xFFFFFFFF;\n    IRQ_ConfigureIT(AT91C_ID_PIOB, priority, PIO_IT_InterruptHandler);\n    IRQ_EnableIT(AT91C_ID_PIOB);\n#endif\n\n#ifdef AT91C_ID_PIOC\n    TRACE_DEBUG(\"PIO_Initialize: Configuring PIOC\\n\\r\");\n    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOC;\n    AT91C_BASE_PIOC->PIO_ISR;\n    AT91C_BASE_PIOC->PIO_IDR = 0xFFFFFFFF;\n    IRQ_ConfigureIT(AT91C_ID_PIOC, priority, PIO_IT_InterruptHandler);\n    IRQ_EnableIT(AT91C_ID_PIOC);\n#endif\n\n#ifdef AT91C_ID_PIOD\n    TRACE_DEBUG(\"PIO_Initialize: Configuring PIOD\\n\\r\");\n    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOD;\n    AT91C_BASE_PIOC->PIO_ISR;\n    AT91C_BASE_PIOC->PIO_IDR = 0xFFFFFFFF;\n    IRQ_ConfigureIT(AT91C_ID_PIOD, priority, PIO_IT_InterruptHandler);\n    IRQ_EnableIT(AT91C_ID_PIOD);\n#endif\n\n#ifdef AT91C_ID_PIOE\n    TRACE_DEBUG(\"PIO_Initialize: Configuring PIOE\\n\\r\");\n    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOE;\n    AT91C_BASE_PIOC->PIO_ISR;\n    AT91C_BASE_PIOC->PIO_IDR = 0xFFFFFFFF;\n    IRQ_ConfigureIT(AT91C_ID_PIOE, priority, PIO_IT_InterruptHandler);\n    IRQ_EnableIT(AT91C_ID_PIOE);\n#endif\n\n#if defined(AT91C_ID_PIOABCD)\n    // Treat PIOABCD interrupts\n    #if !defined(AT91C_ID_PIOA) \\\n     && !defined(AT91C_ID_PIOB) \\\n     && !defined(AT91C_ID_PIOC) \\\n     && !defined(AT91C_ID_PIOD)\n\n        TRACE_DEBUG(\"PIO_Initialize: Configuring PIOABCD\\n\\r\");\n        AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOABCD;\n        AT91C_BASE_PIOA->PIO_ISR;\n        AT91C_BASE_PIOA->PIO_IDR = 0xFFFFFFFF;\n        IRQ_ConfigureIT(AT91C_ID_PIOABCD, priority, PIO_IT_InterruptHandler);\n        IRQ_EnableIT(AT91C_ID_PIOABCD);\n    #endif\n#endif\n\n#if defined(AT91C_ID_PIOABCDE)\n    // Treat PIOABCDE interrupts\n    #if !defined(AT91C_ID_PIOA) \\\n     && !defined(AT91C_ID_PIOB) \\\n     && !defined(AT91C_ID_PIOC) \\\n     && !defined(AT91C_ID_PIOD) \\\n     && !defined(AT91C_ID_PIOE)\n\n        TRACE_DEBUG(\"PIO_Initialize: Configuring PIOABCDE\\n\\r\");\n        AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOABCDE;\n        AT91C_BASE_PIOA->PIO_ISR;\n        AT91C_BASE_PIOA->PIO_IDR = 0xFFFFFFFF;\n        IRQ_ConfigureIT(AT91C_ID_PIOABCDE, priority, PIO_IT_InterruptHandler);\n        IRQ_EnableIT(AT91C_ID_PIOABCDE);\n    #endif\n#endif\n\n#if defined(AT91C_ID_PIOCDE)\n    // Treat PIOCDE interrupts\n    #if !defined(AT91C_ID_PIOC) \\\n     && !defined(AT91C_ID_PIOD) \\\n     && !defined(AT91C_ID_PIOE)\n\n        TRACE_DEBUG(\"PIO_Initialize: Configuring PIOC\\n\\r\");\n        AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOCDE;\n        AT91C_BASE_PIOC->PIO_ISR;\n        AT91C_BASE_PIOC->PIO_IDR = 0xFFFFFFFF;\n        IRQ_ConfigureIT(AT91C_ID_PIOCDE, priority, PIO_IT_InterruptHandler);\n        IRQ_EnableIT(AT91C_ID_PIOCDE);\n    #endif\n#endif\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio_it.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Configures one or more pin(s) of a PIO controller as being controlled by\n/// peripheral B. Optionally, the corresponding internal pull-up(s) can be\n/// enabled.\n/// \\param pio  Pointer to a PIO controller.\n/// \\param mask  Bitmask of one or more pin(s) to configure.\n/// \\param enablePullUp  Indicates if the pin(s) internal pull-up shall be\n///                      configured.\n//------------------------------------------------------------------------------\n", "func_signal": "static void PIO_SetPeripheralB(\n    AT91S_PIO *pio,\n    unsigned int mask,\n    unsigned char enablePullUp)", "code": "{\n#if !defined(AT91C_PIOA_BSR)\n    unsigned int abmr;\n#endif\n\n    // Disable interrupts on the pin(s)\n    pio->PIO_IDR = mask;\n\n    // Enable the pull-up(s) if necessary\n    if (enablePullUp) {\n\n        pio->PIO_PPUER = mask;\n    }\n    else {\n\n        pio->PIO_PPUDR = mask;\n    }\n\n    // Configure pin\n#if defined(AT91C_PIOA_BSR)\n    pio->PIO_BSR = mask;\n#else\n    abmr = pio->PIO_ABSR;\n    pio->PIO_ABSR = mask | abmr;\n#endif\n    pio->PIO_PDR = mask;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/**\n * Unpack a single header that has been encoded using LOWPAN_NHC\n *  compression \n *\n * NOTE: in order simplify application support, this function does NOT\n *  convert the length field of ip extension headers to the form\n *  required by RFC2460: that is, the length value remains in units of\n *  octets.  It is expected that all software within a 6lowpan network\n *  will expect this to be the case; edge routers communicating with\n *  the outside world should take care to convert the length octet\n *  when such packets are received, including removing any necessary\n *  padding options.\n */\n", "func_signal": "uint8_t *unpack_ipnh(uint8_t *dest, size_t cnt, uint8_t *nxt_hdr, uint8_t *buf)", "code": "{\n  if (((*buf) & LOWPAN_NHC_IPV6_MASK) == LOWPAN_NHC_IPV6_PATTERN) {\n    struct ip6_ext *ext = (struct ip6_ext *)dest;\n    uint8_t length;\n    // decompress an ipv6 extension header\n\n    // fill in the next header field of the previous header\n    switch ((*buf) & LOWPAN_NHC_EID_MASK) {\n    case LOWPAN_NHC_EID_HOP:\n     *nxt_hdr = IPV6_HOP; break;\n    case LOWPAN_NHC_EID_ROUTING:\n      *nxt_hdr = IPV6_ROUTING; break;\n    case LOWPAN_NHC_EID_FRAG:\n      *nxt_hdr = IPV6_FRAG; break;\n    case LOWPAN_NHC_EID_DEST:\n      *nxt_hdr = IPV6_DEST; break;\n    case LOWPAN_NHC_EID_MOBILE:\n      *nxt_hdr = IPV6_MOBILITY; break;\n    case LOWPAN_NHC_EID_IPV6:\n      /* ja if this happens we need to restart compression at the next byte... */\n      *nxt_hdr = IPV6_IPV6; break;\n    default:\n      return NULL;\n    }\n\n    // if the next header value is inline, copy that in.\n    if (!((*buf) & LOWPAN_NHC_NH)) {\n      buf ++;\n      ext->ip6e_nxt = *buf;\n    }\n    buf += 1;\n    length = *buf++;\n\n    if (cnt < length - 2)\n      return NULL;\n\n    // buf now points at the start of the extension header data\n    memcpy(dest + 2, buf, length - 2);\n    ext->ip6e_len = length;\n\n    return buf + length - 2;\n  } else if (((*buf) & LOWPAN_NHC_UDP_MASK) == LOWPAN_NHC_UDP_PATTERN) {\n    // packed UDP header\n    return unpack_udp(dest, nxt_hdr, buf);\n  }\n  return NULL;\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Generic PIO interrupt handler. Single entry point for interrupts coming\n/// from any PIO controller (PIO A, B, C ...). Dispatches the interrupt to\n/// the user-configured handlers.\n//------------------------------------------------------------------------------\n", "func_signal": "void PIO_IT_InterruptHandler(void)", "code": "{\n#if defined(AT91C_ID_PIOA)\n    // Treat PIOA interrupts\n    PioInterruptHandler(AT91C_ID_PIOA, AT91C_BASE_PIOA);\n#endif\n\n#if defined(AT91C_ID_PIOB)\n    // Treat PIOB interrupts\n    PioInterruptHandler(AT91C_ID_PIOB, AT91C_BASE_PIOB);\n#endif\n\n#if defined(AT91C_ID_PIOC)\n    // Treat PIOC interrupts\n    PioInterruptHandler(AT91C_ID_PIOC, AT91C_BASE_PIOC);\n#endif\n\n#if defined(AT91C_ID_PIOD)\n    // Treat PIOD interrupts\n    PioInterruptHandler(AT91C_ID_PIOD, AT91C_BASE_PIOD);\n#endif\n\n#if defined(AT91C_ID_PIOE)\n    // Treat PIOE interrupts\n    PioInterruptHandler(AT91C_ID_PIOE, AT91C_BASE_PIOE);\n#endif\n\n#if defined(AT91C_ID_PIOABCD)\n    // Treat PIOABCD interrupts\n    #if !defined(AT91C_ID_PIOA)\n        PioInterruptHandler(AT91C_ID_PIOABCD, AT91C_BASE_PIOA);\n    #endif\n    #if !defined(AT91C_ID_PIOB)\n        PioInterruptHandler(AT91C_ID_PIOABCD, AT91C_BASE_PIOB);\n    #endif\n    #if !defined(AT91C_ID_PIOC)\n        PioInterruptHandler(AT91C_ID_PIOABCD, AT91C_BASE_PIOC);\n    #endif\n    #if !defined(AT91C_ID_PIOD)\n        PioInterruptHandler(AT91C_ID_PIOABCD, AT91C_BASE_PIOD);\n    #endif\n#endif\n\n#if defined(AT91C_ID_PIOABCDE)\n    // Treat PIOABCDE interrupts\n    #if !defined(AT91C_ID_PIOA)\n        PioInterruptHandler(AT91C_ID_PIOABCDE, AT91C_BASE_PIOA);\n    #endif\n    #if !defined(AT91C_ID_PIOB)\n        PioInterruptHandler(AT91C_ID_PIOABCDE, AT91C_BASE_PIOB);\n    #endif\n    #if !defined(AT91C_ID_PIOC)\n        PioInterruptHandler(AT91C_ID_PIOABCDE, AT91C_BASE_PIOC);\n    #endif\n    #if !defined(AT91C_ID_PIOD)\n        PioInterruptHandler(AT91C_ID_PIOABCDE, AT91C_BASE_PIOD);\n    #endif\n    #if !defined(AT91C_ID_PIOE)\n        PioInterruptHandler(AT91C_ID_PIOABCDE, AT91C_BASE_PIOE);\n    #endif\n#endif\n\n#if defined(AT91C_ID_PIOCDE)\n    // Treat PIOCDE interrupts\n    #if !defined(AT91C_ID_PIOC)\n        PioInterruptHandler(AT91C_ID_PIOCDE, AT91C_BASE_PIOC);\n    #endif\n    #if !defined(AT91C_ID_PIOD)\n        PioInterruptHandler(AT91C_ID_PIOCDE, AT91C_BASE_PIOD);\n    #endif\n    #if !defined(AT91C_ID_PIOE)\n        PioInterruptHandler(AT91C_ID_PIOCDE, AT91C_BASE_PIOE);\n    #endif\n#endif\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio_it.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* @return 0 if all bits in the range [start,end) are zero */\n/*    -1 otherwise */\n", "func_signal": "int bit_range_zero_p(uint8_t *buf, int start, int end)", "code": "{\n  int start_byte = start / 8;\n  int end_byte   = end / 8;\n  int i;\n  uint8_t start_mask = 0xff << (8 - (start % 8));\n  uint8_t end_mask   = 0xff << (8 - (end % 8));\n  // printf(\"start: %i end: %i, (%i, %i)\\n\", start, end, start_byte, end_byte);\n  // printf(\"start mask: 0x%x end mask: 0x%x\\n\", start_mask, end_mask);\n\n  if ((buf[start_byte] & start_mask) != 0) {\n    return -1;\n  }\n  if ((buf[end_byte] & end_mask) != 0) {\n    return -1;\n  }\n  for (i = start_byte; i < end_byte; i++) {\n    if (buf[i] != 0) return -1;\n  }\n  return 0;\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Configures one or more pin(s) or a PIO controller as inputs. Optionally,\n/// the corresponding internal pull-up(s) and glitch filter(s) can be\n/// enabled.\n/// \\param pio  Pointer to a PIO controller.\n/// \\param mask  Bitmask indicating which pin(s) to configure as input(s).\n/// \\param enablePullUp  Indicates if the internal pull-up(s) must be enabled.\n/// \\param enableFilter  Indicates if the glitch filter(s) must be enabled.\n//------------------------------------------------------------------------------\n", "func_signal": "static void PIO_SetInput(\n    AT91S_PIO *pio,\n    unsigned int mask,\n    unsigned char enablePullUp,\n    unsigned char enableFilter)", "code": "{\n    // Disable interrupts\n    pio->PIO_IDR = mask;\n\n    // Enable pull-up(s) if necessary\n    if (enablePullUp) {\n    \n        pio->PIO_PPUER = mask;\n    }\n    else {\n    \n        pio->PIO_PPUDR = mask;\n    }\n\n    // Enable filter(s) if necessary\n    if (enableFilter) {\n    \n        pio->PIO_IFER = mask;\n    }\n    else {\n    \n        pio->PIO_IFDR = mask;\n    }\n\n    // Configure pin as input\n    pio->PIO_ODR = mask;\n    pio->PIO_PER = mask;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Configures a list of Pin instances, each of which can either hold a single\n/// pin or a group of pins, depending on the mask value; all pins are configured\n/// by this function. The size of the array must also be provided and is easily\n/// computed using PIO_LISTSIZE whenever its length is not known in advance.\n/// \\param list  Pointer to a list of Pin instances.\n/// \\param size  Size of the Pin list (calculated using PIO_LISTSIZE).\n/// \\return 1 if the pins have been configured properly; otherwise 0.\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char PIO_Configure(const Pin *list, unsigned int size)", "code": "{\n    // Configure pins\n    while (size > 0) {\n    \n        switch (list->type) {\n    \n            case PIO_PERIPH_A:\n                PIO_SetPeripheralA(list->pio,\n                                   list->mask,\n                                   (list->attribute & PIO_PULLUP) ? 1 : 0);\n                break;\n    \n            case PIO_PERIPH_B:\n                PIO_SetPeripheralB(list->pio,\n                                   list->mask,\n                                   (list->attribute & PIO_PULLUP) ? 1 : 0);\n                break;\n    \n            case PIO_INPUT:\n                AT91C_BASE_PMC->PMC_PCER = 1 << list->id;\n                PIO_SetInput(list->pio,\n                             list->mask,\n                             (list->attribute & PIO_PULLUP) ? 1 : 0,\n                             (list->attribute & PIO_DEGLITCH)? 1 : 0);\n\n                #if defined(AT91C_PIOA_IFDGSR) //PIO3 with Glitch or Debouncing selection\n                //if glitch input filter enabled, set it\n                if(list->attribute & PIO_DEGLITCH)//Glitch input filter enabled\n                    PIO_SetFilter(list->pio,\n                        list->inFilter.filterSel,\n                        list->inFilter.clkDivider);\n                #endif\n                break;\n    \n            case PIO_OUTPUT_0:\n            case PIO_OUTPUT_1:\n                PIO_SetOutput(list->pio,\n                              list->mask,\n                              (list->type == PIO_OUTPUT_1),\n                              (list->attribute & PIO_OPENDRAIN) ? 1 : 0,\n                              (list->attribute & PIO_PULLUP) ? 1 : 0);\n                break;\n    \n            default: return 0;\n        }\n\n        list++;\n        size--;\n    }\n\n    return 1;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Enables the given interrupt source if it has been configured. The status\n/// register of the corresponding PIO controller is cleared prior to enabling\n/// the interrupt.\n/// \\param pPin  Interrupt source to enable.\n//------------------------------------------------------------------------------\n", "func_signal": "void PIO_EnableIt(const Pin *pPin)", "code": "{\n    TRACE_DEBUG(\"PIO_EnableIt()\\n\\r\");\n\n    SANITY_CHECK(pPin);\n\n#ifndef NOASSERT\n    {\n    unsigned int i = 0;\n    unsigned char found = 0;\n    while ((i < numSources) && !found) {\n\n        if (pSources[i].pPin == pPin) {\n\n            found = 1;\n        }\n        i++;\n    }\n    ASSERT(found, \"-F- PIO_EnableIt: Interrupt source has not been configured\\n\\r\");\n    }\n#endif\n\n    pPin->pio->PIO_ISR;\n    pPin->pio->PIO_IER = pPin->mask;\n    \n\n#if defined(AT91C_PIOA_AIMMR)\n    //PIO3 with additional interrupt support\n    //configure additional interrupt mode registers\n    if(pPin->mask&pPin->itMode.itMask) {\n   \n    //enable additional interrupt mode\n    pPin->pio->PIO_AIMER  = pPin->itMode.itMask;\n    \n    if(pPin->mask&pPin->itMode.edgeLvlSel)\n        //if bit field of selected pin is 1, set as Level detection source\n        pPin->pio->PIO_LSR = pPin->itMode.edgeLvlSel;\n    else\n        //if bit field of selected pin is 0, set as Edge detection source\n        pPin->pio->PIO_ESR = ~(pPin->itMode.edgeLvlSel);\n\n    if(pPin->mask&pPin->itMode.lowFallOrRiseHighSel)\n        //if bit field of selected pin is 1, set as Rising Edge/High level detection event\n        pPin->pio->PIO_REHLSR     = pPin->itMode.lowFallOrRiseHighSel;\n    else\n        //if bit field of selected pin is 0, set as Falling Edge/Low level detection event\n        pPin->pio->PIO_FELLSR     = ~(pPin->itMode.lowFallOrRiseHighSel);\n    }\n\n#endif\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio_it.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Returns 1 if one or more PIO of the given Pin are configured to output a\n/// high level (even if they are not output).\n/// To get the actual value of the pin, use PIO_Get() instead.\n/// \\param pin  Pointer to a Pin instance describing one or more pins.\n/// \\return 1 if the Pin instance contains at least one PIO that is configured\n/// to output a high level; otherwise 0.\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char PIO_GetOutputDataStatus(const Pin *pin)", "code": "{\n    if ((pin->pio->PIO_ODSR & pin->mask) == 0) {\n\n        return 0;\n    }\n    else {\n\n        return 1;\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Returns 1 if one or more PIO of the given Pin instance currently have a high\n/// level; otherwise returns 0. This method returns the actual value that is\n/// being read on the pin. To return the supposed output value of a pin, use\n/// PIO_GetOutputDataStatus() instead.\n/// \\param pin  Pointer to a Pin instance describing one or more pins.\n/// \\return 1 if the Pin instance contains at least one PIO that currently has\n/// a high level; otherwise 0.\n//------------------------------------------------------------------------------\n", "func_signal": "unsigned char PIO_Get(const Pin *pin)", "code": "{\n    unsigned int reg;\n    if ((pin->type == PIO_OUTPUT_0) || (pin->type == PIO_OUTPUT_1)) {\n\n        reg = pin->pio->PIO_ODSR;\n    }\n    else {\n\n        reg = pin->pio->PIO_PDSR;\n    }\n\n    if ((reg & pin->mask) == 0) {\n\n        return 0;\n    }\n    else {\n\n        return 1;\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* packs all non-multicast addresses */\n/* @buf output buffer */\n/* @addr the ipv6 address to be compressed */\n/* @context_match_len if a context matches, how long the match is.  must be multiple of 8 */\n/* @l2addr the link-layer address correspoinding to the address (source or destination) */\n/* @pan the destination pan ID */\n/* @flags return argument; which address mode was selected */\n", "func_signal": "uint8_t *pack_address(uint8_t *buf, struct in6_addr *addr, int context_match_len,\n                      ieee154_addr_t *l2addr, ieee154_panid_t pan, uint8_t *flags)", "code": "{\n  *flags = 0;\n  if (IS_LINKLOCAL(addr)) {\n    /* then we use stateless compression */\n    /*     no bits to set, just pack the IID */\n    if (addr->s6_addr16[4] == 0 &&\n        addr->s6_addr16[5] == 0 &&\n        addr->s6_addr16[6] == 0) {\n      // then we use 16-bit mode.  This isn't going to be popular...\n      *flags |= LOWPAN_IPHC_AM_16;\n      memcpy(buf, &addr->s6_addr[14], 2);\n      return buf += 2;\n    } else if (/* maybe it's a 16-bit address with the IID derived from the PANID + address */\n               (addr->s6_addr16[4] == htons(letohs(pan)) &&\n                addr->s6_addr16[5] == htons(0x00ff) &&\n                addr->s6_addr16[6] == htons(0xfe00) &&\n                (((l2addr->ieee_mode == IEEE154_ADDR_SHORT) && \n                  addr->s6_addr16[7] == htons(letohs(l2addr->i_saddr))))) ||\n               /* no?  Maybe it's just a straight-up 64-bit EUI64 */\n                 ((l2addr->ieee_mode == IEEE154_ADDR_EXT) && \n                  (iid_eui_cmp(&addr->s6_addr[8], l2addr->i_laddr.data)))) {\n      /* in either case we can elide the addressing from the packet. */\n      *flags |= LOWPAN_IPHC_AM_0;\n      return buf;\n    } else {\n      *flags |= LOWPAN_IPHC_AM_64;\n      memcpy(buf, &addr->s6_addr[8], 8);\n      return buf + 8;\n    }\n  } else if (context_match_len > 0) {\n    int extra = 0;\n    // then we're using the context\n    *flags |= LOWPAN_IPHC_AC_CONTEXT;\n    if (context_match_len == 128) {\n      *flags |= LOWPAN_IPHC_AM_0;\n    } else if (bit_range_zero_p(&addr->s6_addr[0], context_match_len, 112) == 0) {\n      *flags |= LOWPAN_IPHC_AM_16;\n      memcpy(buf, &addr->s6_addr[14], 2);\n      extra = 2;\n    } else if (bit_range_zero_p(&addr->s6_addr[0], context_match_len, 64) == 0) {\n      *flags |= LOWPAN_IPHC_AM_64;\n      memcpy(buf, &addr->s6_addr[8], 8);\n      extra = 8;\n    } else {\n      *flags |= LOWPAN_IPHC_AM_128;\n      *flags &= ~LOWPAN_IPHC_AC_CONTEXT;\n      memcpy(buf, &addr->s6_addr[0], 16);\n      extra = 16;\n    }\n    return buf + extra;\n  } else if (IS_UNSPECIFIED(addr)) {\n    /* this case doesn't involve any compression */\n    *flags |= LOWPAN_IPHC_AC_CONTEXT | LOWPAN_IPHC_AM_128;\n    return buf;\n  } else {\n    /* otherwise we have to send the whole thing. */\n    *flags |= LOWPAN_IPHC_AM_128;\n    memcpy(buf, addr->s6_addr, 16);\n    return buf + 16;\n  }\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Configures one or more pin(s) of a PIO controller as being controlled by\n/// peripheral A. Optionally, the corresponding internal pull-up(s) can be\n/// enabled.\n/// \\param pio  Pointer to a PIO controller.\n/// \\param mask  Bitmask of one or more pin(s) to configure.\n/// \\param enablePullUp  Indicates if the pin(s) internal pull-up shall be\n///                      configured.\n//------------------------------------------------------------------------------\n", "func_signal": "static void PIO_SetPeripheralA(\n    AT91S_PIO *pio,\n    unsigned int mask,\n    unsigned char enablePullUp)", "code": "{\n#if !defined(AT91C_PIOA_ASR)\n    unsigned int abmr;\n#endif\n\n    // Disable interrupts on the pin(s)\n    pio->PIO_IDR = mask;\n\n    // Enable the pull-up(s) if necessary\n    if (enablePullUp) {\n\n        pio->PIO_PPUER = mask;\n    }\n    else {\n\n        pio->PIO_PPUDR = mask;\n    }\n\n    // Configure pin\n#if defined(AT91C_PIOA_ASR)\n    pio->PIO_ASR = mask;\n#else\n    abmr = pio->PIO_ABSR;\n    pio->PIO_ABSR &= (~mask & abmr);\n#endif\n    pio->PIO_PDR = mask;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Configures one or more pin(s) of a PIO controller as outputs, with the\n/// given default value. Optionally, the multi-drive feature can be enabled\n/// on the pin(s).\n/// \\param pio  Pointer to a PIO controller.\n/// \\param mask  Bitmask indicating which pin(s) to configure.\n/// \\param defaultValue  Default level on the pin(s).\n/// \\param enableMultiDrive  Indicates if the pin(s) shall be configured as\n///                          open-drain.\n/// \\param enablePullUp  Indicates if the pin shall have its pull-up activated.\n//------------------------------------------------------------------------------\n", "func_signal": "static void PIO_SetOutput(\n    AT91S_PIO *pio,\n    unsigned int mask,\n    unsigned char defaultValue,\n    unsigned char enableMultiDrive,\n    unsigned char enablePullUp)", "code": "{\n    // Disable interrupts\n    pio->PIO_IDR = mask;\n\n    // Enable pull-up(s) if necessary\n    if (enablePullUp) {\n    \n        pio->PIO_PPUER = mask;\n    }\n    else {\n    \n        pio->PIO_PPUDR = mask;\n    }\n\n    // Enable multi-drive if necessary\n    if (enableMultiDrive) {\n    \n        pio->PIO_MDER = mask;\n    }\n    else {\n    \n        pio->PIO_MDDR = mask;\n    }\n\n    // Set default value\n    if (defaultValue) {\n\n        pio->PIO_SODR = mask;\n    }\n    else {\n\n        pio->PIO_CODR = mask;\n    }\n\n    // Configure pin(s) as output(s)\n    pio->PIO_OER = mask;\n    pio->PIO_PER = mask;\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* packs the Traffic Class and Flow Label fields as described in the internet draft */\n/* @buf the buffer to write any anyline fields to */\n/* @hdr the IPv6 header being compressed; this function only examines the first four octets */\n/* @dispatch the octet corresponding to the first octet of the IPHC dispatch value */\n/*      modified to reflect the packing of the fields */\n", "func_signal": "inline uint8_t *pack_tcfl(uint8_t *buf, struct ip6_hdr *hdr, uint8_t *dispatch)", "code": "{\n  uint32_t flow = (ntohl(hdr->ip6_flow) & 0x000fffff);\n  uint8_t  tc   = (ntohl(hdr->ip6_flow) >> 20) & 0xff;\n  if (flow == 0 && tc == 0) {\n    // lucky us\n    *dispatch |= LOWPAN_IPHC_TF_NONE;\n  } else if (flow == 0) {\n    *dispatch |= LOWPAN_IPHC_TF_ECN_DSCP;\n    *buf  = (tc >> 2) & 0xff;\n    *buf |= (tc << 6) & 0xff;\n    buf++;\n  } else if ((tc & 0x3) == tc) {\n    *dispatch |= LOWPAN_IPHC_TF_ECN_FL;\n    *buf        = (tc << 6) & 0xff;\n    *buf       |= (flow >> 16) & 0x0f;\n    *(buf + 1)  = (flow >> 8)  & 0xff;\n    *(buf + 2)  = (flow)       & 0xff;\n    buf += 3;\n  } else {\n    *dispatch |= LOWPAN_IPHC_TF_ECN_DSCP_FL;\n    *buf  = (tc >> 2) & 0xff;\n    *buf |= (tc << 6) & 0xff;\n    \n    *(buf + 1)  = (flow >> 16) & 0x0f;\n    *(buf + 2)  = (flow >> 8)  & 0xff;\n    *(buf + 3)  = (flow)       & 0xff;\n    buf += 4;\n  }\n  return buf;\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* Packs a multicast address into the smallest address possible. */\n/*  does not currently implement stateful multicast address compression */\n/*  also does not check to make sure it is a multicast address */\n", "func_signal": "uint8_t *pack_multicast(uint8_t *buf, struct in6_addr *addr, uint8_t *flags)", "code": "{\n  /* no need to set AC since it's zero */\n  *flags = 0;\n  if ((addr->s6_addr16[0] == htons(0xff02)) &&\n      (bit_range_zero_p(addr->s6_addr, 16, 120) == 0)) {\n    *flags |= LOWPAN_IPHC_AM_M_8;\n    *buf = addr->s6_addr[15];\n    return buf + 1;\n  } else if (bit_range_zero_p(addr->s6_addr, 16, 104) == 0) {\n    *flags |= LOWPAN_IPHC_AM_M_32;\n    *buf = addr->s6_addr[1];\n    memcpy(buf + 1, &addr->s6_addr[13], 3);\n    return buf + 4;\n  } else if (bit_range_zero_p(addr->s6_addr, 16, 88) == 0) {\n    *flags |= LOWPAN_IPHC_AM_M_48;\n    *buf = addr->s6_addr[1];\n    memcpy(buf + 1, &addr->s6_addr[11], 5);\n    return buf + 6;\n  } else {\n    *flags += LOWPAN_IPHC_AM_M_128;\n    memcpy(buf, addr->s6_addr, 16);\n    return buf + 16;\n  }\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//Glitch or Debouncing filter selection supported\n//------------------------------------------------------------------------------\n/// Configures Glitch or Debouncing filter for input\n/// \\param pio      Pointer to a PIO controller.\n/// \\param mask   Bitmask for filter selection.\n///                     each of 32 bit field, 0 is Glitch, 1 is Debouncing\n/// \\param clkDiv  Clock divider if Debouncing select, using the lowest 14 bits\n///                     common for all PIO line of selecting deboucing filter\n//------------------------------------------------------------------------------\n", "func_signal": "static void PIO_SetFilter(\n    AT91S_PIO *pio,\n    unsigned int filterSel,\n    unsigned int clkDiv)", "code": "{\n    pio->PIO_DIFSR = filterSel;//set Debouncing, 0 bit field no effect\n    pio->PIO_SCIFSR = ~filterSel;//set Glitch, 0 bit field no effect\n\n    pio->PIO_SCDR = clkDiv & 0x3FFF;//the lowest 14 bits work\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Returns a pointer to the descriptor right after the given one, when\n/// parsing a Configuration descriptor.\n/// \\param descriptor - Pointer to a USBGenericDescriptor instance.\n/// \\return Pointer to the next descriptor.\n//------------------------------------------------------------------------------\n", "func_signal": "USBGenericDescriptor *USBGenericDescriptor_GetNextDescriptor(\n    const USBGenericDescriptor *descriptor)", "code": "{\n    return (USBGenericDescriptor *)\n        (((char *) descriptor) + USBGenericDescriptor_GetLength(descriptor));\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\usb\\common\\core\\USBGenericDescriptor.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Disables a given interrupt source, with no added side effects.\n/// \\param pPin  Interrupt source to disable.\n//------------------------------------------------------------------------------\n", "func_signal": "void PIO_DisableIt(const Pin *pPin)", "code": "{\n    SANITY_CHECK(pPin);\n\n    TRACE_DEBUG(\"PIO_DisableIt()\\n\\r\");\n\n    pPin->pio->PIO_IDR = pPin->mask;\n#if defined(AT91C_PIOA_AIMMR)\n    if(pPin->mask & pPin->itMode.itMask)\n        //disable additional interrupt mode\n        pPin->pio->PIO_AIMDR = pPin->mask & pPin->itMode.itMask;\n#endif\n\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio_it.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "//------------------------------------------------------------------------------\n/// Handles all interrupts on the given PIO controller.\n/// \\param id  PIO controller ID.\n/// \\param pPio  PIO controller base address.\n//------------------------------------------------------------------------------\n", "func_signal": "static void PioInterruptHandler(unsigned int id, AT91S_PIO *pPio)", "code": "{\n    unsigned int status;\n    unsigned int i;\n\n    // Read PIO controller status\n    status = pPio->PIO_ISR;\n    status &= pPio->PIO_IMR;\n\n    // Check pending events\n    if (status != 0) {\n\n        TRACE_DEBUG(\"PIO interrupt on PIO controller #%d\\n\\r\", id);\n\n        // Find triggering source\n        i = 0;\n        while (status != 0) {\n\n            // There cannot be an unconfigured source enabled.\n            SANITY_CHECK(i < numSources);\n\n            // Source is configured on the same controller\n            if (pSources[i].pPin->id == id) {\n\n                // Source has PIOs whose statuses have changed\n                if ((status & pSources[i].pPin->mask) != 0) {\n\n                    TRACE_DEBUG(\"Interrupt source #%d triggered\\n\\r\", i);\n\n                    pSources[i].handler(pSources[i].pPin);\n                    status &= ~(pSources[i].pPin->mask);\n                }\n            }\n            i++;\n        }\n    }\n}", "path": "tos\\chips\\cortex\\m3\\sam3\\u\\usb\\peripherals\\pio\\pio_it.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* never pack the ports */\n", "func_signal": "int pack_udp(uint8_t *buf, size_t cnt, struct ip6_packet *packet, int offset)", "code": "{\n  struct udp_hdr udp;\n\n  if (cnt < 7) {\n    return -1;\n  }\n  \n  if (iov_read(packet->ip6_data, offset, sizeof(struct udp_hdr), (void *)&udp) != \n      sizeof(struct udp_hdr)) {\n    return -1;\n  }\n\n  *buf = LOWPAN_NHC_UDP_PATTERN | LOWPAN_NHC_UDP_PORT_FULL;\n  memcpy(buf + 1, &udp.srcport, 4);\n  memcpy(buf + 5, &udp.chksum, 2);\n  return 7;\n}", "path": "support\\sdk\\c\\blip\\lib6lowpan\\lib6lowpan.c", "repo_name": "phsommer/tinyos-atmega128rfa1", "stars": 10, "license": "None", "language": "c", "size": 28689}
{"docstring": "/* Fill in the MetaPropValue used to get the value of \"property\" */\n", "func_signal": "static void\ninit_prop_value (MetaDisplay   *display,\n                 Atom           property,\n                 MetaPropValue *value)", "code": "{\n  MetaGroupPropHooks *hooks;  \n\n  value->type = META_PROP_VALUE_INVALID;\n  value->atom = None;\n  \n  hooks = find_hooks (display, property);\n  if (hooks && hooks->init_func != NULL)\n    (* hooks->init_func) (display, property, value);\n}", "path": "src\\core\\group-props.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* Grab/ungrab routines taken from fvwm */\n", "func_signal": "void\nmeta_display_grab (MetaDisplay *display)", "code": "{\n  if (display->server_grab_count == 0)\n    {\n      XGrabServer (display->xdisplay);\n    }\n  display->server_grab_count += 1;\n  meta_verbose (\"Grabbing display, grab count now %d\\n\",\n                display->server_grab_count);\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* WITH_VERBOSE_MODE */\n", "func_signal": "MetaWorkspace*\nmeta_workspace_get_neighbor (MetaWorkspace      *workspace,\n                             MetaMotionDirection direction)", "code": "{\n  MetaWorkspaceLayout layout;  \n  int i, current_space, num_workspaces;\n  gboolean ltr;\n\n  current_space = meta_workspace_index (workspace);\n  num_workspaces = meta_screen_get_n_workspaces (workspace->screen);\n  meta_screen_calc_workspace_layout (workspace->screen, num_workspaces,\n                                     current_space, &layout);\n\n  meta_verbose (\"Getting neighbor of %d in direction %s\\n\",\n                current_space, meta_motion_direction_to_string (direction));\n  \n  ltr = meta_ui_get_direction() == META_UI_DIRECTION_LTR;\n\n  switch (direction) \n    {\n    case META_MOTION_LEFT:\n      layout.current_col -= ltr ? 1 : -1;\n      break;\n    case META_MOTION_RIGHT:\n      layout.current_col += ltr ? 1 : -1;\n      break;\n    case META_MOTION_UP:\n      layout.current_row -= 1;\n      break;\n    case META_MOTION_DOWN:\n      layout.current_row += 1;\n      break;\n    }\n\n  if (layout.current_col < 0)\n    layout.current_col = 0;\n  if (layout.current_col >= layout.cols)\n    layout.current_col = layout.cols - 1;\n  if (layout.current_row < 0)\n    layout.current_row = 0;\n  if (layout.current_row >= layout.rows)\n    layout.current_row = layout.rows - 1;\n\n  i = layout.grid[layout.current_row * layout.cols + layout.current_col];\n\n  if (i < 0)\n    i = current_space;\n\n  if (i >= num_workspaces)\n    meta_bug (\"calc_workspace_layout left an invalid (too-high) workspace number %d in the grid\\n\",\n              i);\n    \n  meta_verbose (\"Neighbor workspace is %d at row %d col %d\\n\",\n                i, layout.current_row, layout.current_col);\n\n  meta_screen_free_workspace_layout (&layout);\n  \n  return meta_screen_get_workspace_by_index (workspace->screen, i);\n}", "path": "src\\core\\workspace.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* from fvwm2, Copyright Matthias Clasen, Dominik Vogt */\n", "func_signal": "static void\nprocess_selection_request (MetaDisplay   *display,\n                           XEvent        *event)", "code": "{\n  XSelectionEvent reply;\n  MetaScreen *screen;\n\n  screen = find_screen_for_selection (display,\n                                      event->xselectionrequest.owner,\n                                      event->xselectionrequest.selection);\n\n  if (screen == NULL)\n    {\n      char *str;\n      \n      meta_error_trap_push (display);\n      str = XGetAtomName (display->xdisplay,\n                          event->xselectionrequest.selection);\n      meta_error_trap_pop (display, TRUE);\n      \n      meta_verbose (\"Selection request with selection %s window 0x%lx not a WM_Sn selection we recognize\\n\",\n                    str ? str : \"(bad atom)\", event->xselectionrequest.owner);\n      \n      meta_XFree (str);\n\n      return;\n    }\n  \n  reply.type = SelectionNotify;\n  reply.display = display->xdisplay;\n  reply.requestor = event->xselectionrequest.requestor;\n  reply.selection = event->xselectionrequest.selection;\n  reply.target = event->xselectionrequest.target;\n  reply.property = None;\n  reply.time = event->xselectionrequest.time;\n\n  if (event->xselectionrequest.target == display->atom_MULTIPLE)\n    {\n      if (event->xselectionrequest.property != None)\n        {\n          Atom type, *adata;\n          int i, format;\n          unsigned long num, rest;\n          unsigned char *data;\n\n          meta_error_trap_push_with_return (display);\n          if (XGetWindowProperty (display->xdisplay,\n                                  event->xselectionrequest.requestor,\n                                  event->xselectionrequest.property, 0, 256, False,\n                                  display->atom_ATOM_PAIR,\n                                  &type, &format, &num, &rest, &data) != Success)\n            {\n              meta_error_trap_pop_with_return (display, TRUE);\n              return;\n            }\n          \n          if (meta_error_trap_pop_with_return (display, TRUE) == Success)\n            {              \n              /* FIXME: to be 100% correct, should deal with rest > 0,\n               * but since we have 4 possible targets, we will hardly ever\n               * meet multiple requests with a length > 8\n               */\n              adata = (Atom*)data;\n              i = 0;\n              while (i < (int) num)\n                {\n                  if (!convert_property (display, screen,\n                                         event->xselectionrequest.requestor,\n                                         adata[i], adata[i+1]))\n                    adata[i+1] = None;\n                  i += 2;\n                }\n\n              meta_error_trap_push (display);\n              XChangeProperty (display->xdisplay,\n                               event->xselectionrequest.requestor,\n                               event->xselectionrequest.property,\n                               display->atom_ATOM_PAIR,\n                               32, PropModeReplace, data, num);\n              meta_error_trap_pop (display, FALSE);\n              meta_XFree (data);\n            }\n        }\n    }\n  else\n    {\n      if (event->xselectionrequest.property == None)\n        event->xselectionrequest.property = event->xselectionrequest.target;\n      \n      if (convert_property (display, screen,\n                            event->xselectionrequest.requestor,\n                            event->xselectionrequest.target,\n                            event->xselectionrequest.property))\n        reply.property = event->xselectionrequest.property;\n    }\n\n  XSendEvent (display->xdisplay,\n              event->xselectionrequest.requestor,\n              False, 0L, (XEvent*)&reply);\n\n  meta_verbose (\"Handled selection request\\n\");\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* Return the window this has to do with, if any, rather\n * than the frame or root window that was selecting\n * for substructure\n */\n", "func_signal": "static Window\nevent_get_modified_window (MetaDisplay *display,\n                           XEvent *event)", "code": "{\n  switch (event->type)\n    {\n    case KeyPress:\n    case KeyRelease:\n    case ButtonPress:\n    case ButtonRelease:\n    case MotionNotify:\n    case FocusIn:\n    case FocusOut:\n    case KeymapNotify:\n    case Expose:\n    case GraphicsExpose:\n    case NoExpose:\n    case VisibilityNotify:\n    case ResizeRequest:\n    case PropertyNotify:\n    case SelectionClear:\n    case SelectionRequest:\n    case SelectionNotify:\n    case ColormapNotify:\n    case ClientMessage:\n    case EnterNotify:\n    case LeaveNotify:\n      return event->xany.window;\n      \n    case CreateNotify:\n      return event->xcreatewindow.window;\n      \n    case DestroyNotify:\n      return event->xdestroywindow.window;\n\n    case UnmapNotify:\n      return event->xunmap.window;\n\n    case MapNotify:\n      return event->xmap.window;\n\n    case MapRequest:\n      return event->xmaprequest.window;\n\n    case ReparentNotify:\n     return event->xreparent.window;\n      \n    case ConfigureNotify:\n      return event->xconfigure.window;\n      \n    case ConfigureRequest:\n      return event->xconfigurerequest.window;\n\n    case GravityNotify:\n      return event->xgravity.window;\n\n    case CirculateNotify:\n      return event->xcirculate.window;\n\n    case CirculateRequest:\n      return event->xcirculaterequest.window;\n\n    case MappingNotify:\n      return None;\n\n    default:\n#ifdef HAVE_SHAPE\n      if (META_DISPLAY_HAS_SHAPE (display) && \n          event->type == (display->shape_event_base + ShapeNotify))\n        {\n          XShapeEvent *sev = (XShapeEvent*) event;\n          return sev->window;\n        }\n#endif\n\n      return None;\n    }\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * Opens a new display, sets it up, initialises all the X extensions\n * we will need, and adds it to the list of displays.\n *\n * \\return True if the display was opened successfully, and False\n * otherwise-- that is, if the display doesn't exist or it already\n * has a window manager.\n *\n * \\ingroup main\n */\n", "func_signal": "gboolean\nmeta_display_open (void)", "code": "{\n  Display *xdisplay;\n  GSList *screens;\n  GSList *tmp;\n  int i;\n  guint32 timestamp;\n\n  /* A list of all atom names, so that we can intern them in one go. */\n  char *atom_names[] = {\n#define item(x) #x,\n#include \"atomnames.h\"\n#undef item\n  };\n  Atom atoms[G_N_ELEMENTS(atom_names)];\n  \n  meta_verbose (\"Opening display '%s'\\n\", XDisplayName (NULL));\n\n  xdisplay = meta_ui_get_display ();\n  \n  if (xdisplay == NULL)\n    {\n      meta_warning (_(\"Failed to open X Window System display '%s'\\n\"),\n\t\t    XDisplayName (NULL));\n      return FALSE;\n    }\n\n  if (meta_is_syncing ())\n    XSynchronize (xdisplay, True);\n  \n  g_assert (the_display == NULL);\n  the_display = g_new (MetaDisplay, 1);\n\n  the_display->closing = 0;\n  \n  /* here we use XDisplayName which is what the user\n   * probably put in, vs. DisplayString(display) which is\n   * canonicalized by XOpenDisplay()\n   */\n  the_display->name = g_strdup (XDisplayName (NULL));\n  the_display->xdisplay = xdisplay;\n  the_display->error_trap_synced_at_last_pop = TRUE;\n  the_display->error_traps = 0;\n  the_display->error_trap_handler = NULL;\n  the_display->server_grab_count = 0;\n  the_display->display_opening = TRUE;\n\n  the_display->pending_pings = NULL;\n  the_display->autoraise_timeout_id = 0;\n  the_display->autoraise_window = NULL;\n  the_display->focus_window = NULL;\n  the_display->expected_focus_window = NULL;\n  the_display->grab_old_window_stacking = NULL;\n\n  the_display->mouse_mode = TRUE; /* Only relevant for mouse or sloppy focus */\n  the_display->allow_terminal_deactivation = TRUE; /* Only relevant for when a\n                                                  terminal has the focus */\n\n#ifdef HAVE_XSYNC\n  the_display->grab_sync_request_alarm = None;\n#endif\n  \n  /* FIXME copy the checks from GDK probably */\n  the_display->static_gravity_works = g_getenv (\"METACITY_USE_STATIC_GRAVITY\") != NULL;\n  \n  meta_bell_init (the_display);\n\n  meta_display_init_keys (the_display);\n\n  update_window_grab_modifiers (the_display);\n\n  meta_prefs_add_listener (prefs_changed_callback, the_display);\n\n  meta_verbose (\"Creating %d atoms\\n\", (int) G_N_ELEMENTS (atom_names));\n  XInternAtoms (the_display->xdisplay, atom_names, G_N_ELEMENTS (atom_names),\n                False, atoms);\n  {\n    int i = 0;    \n#define item(x) the_display->atom_##x = atoms[i++];\n#include \"atomnames.h\"\n#undef item\n  }\n\n  the_display->prop_hooks = NULL;\n  meta_display_init_window_prop_hooks (the_display);\n  the_display->group_prop_hooks = NULL;\n  meta_display_init_group_prop_hooks (the_display);\n  \n  /* Offscreen unmapped window used for _NET_SUPPORTING_WM_CHECK,\n   * created in screen_new\n   */\n  the_display->leader_window = None;\n  the_display->timestamp_pinging_window = None;\n\n  the_display->xinerama_cache_invalidated = TRUE;\n\n  the_display->groups_by_leader = NULL;\n\n  the_display->window_with_menu = NULL;\n  the_display->window_menu = NULL;\n  \n  the_display->screens = NULL;\n  the_display->active_screen = NULL;\n  \n#ifdef HAVE_STARTUP_NOTIFICATION\n  the_display->sn_display = sn_display_new (the_display->xdisplay,\n                                        sn_error_trap_push,\n                                        sn_error_trap_pop);\n#endif\n  \n  the_display->events = NULL;\n\n  /* Get events */\n  meta_ui_add_event_func (the_display->xdisplay,\n                          event_callback,\n                          the_display);\n  \n  the_display->window_ids = g_hash_table_new (meta_unsigned_long_hash,\n                                          meta_unsigned_long_equal);\n  \n  i = 0;\n  while (i < N_IGNORED_SERIALS)\n    {\n      the_display->ignored_serials[i] = 0;\n      ++i;\n    }\n  the_display->ungrab_should_not_cause_focus_window = None;\n  \n  the_display->current_time = CurrentTime;\n  the_display->sentinel_counter = 0;\n\n  the_display->grab_resize_timeout_id = 0;\n  the_display->grab_have_keyboard = FALSE;\n  \n#ifdef HAVE_XKB  \n  the_display->last_bell_time = 0;\n#endif\n\n  the_display->grab_op = META_GRAB_OP_NONE;\n  the_display->grab_wireframe_active = FALSE;\n  the_display->grab_window = NULL;\n  the_display->grab_screen = NULL;\n  the_display->grab_resize_popup = NULL;\n\n  the_display->grab_edge_resistance_data = NULL;\n\n#ifdef HAVE_XSYNC\n  {\n    int major, minor;\n\n    the_display->have_xsync = FALSE;\n    \n    the_display->xsync_error_base = 0;\n    the_display->xsync_event_base = 0;\n\n    /* I don't think we really have to fill these in */\n    major = SYNC_MAJOR_VERSION;\n    minor = SYNC_MINOR_VERSION;\n    \n    if (!XSyncQueryExtension (the_display->xdisplay,\n                              &the_display->xsync_event_base,\n                              &the_display->xsync_error_base) ||\n        !XSyncInitialize (the_display->xdisplay,\n                          &major, &minor))\n      {\n        the_display->xsync_error_base = 0;\n        the_display->xsync_event_base = 0;\n      }\n    else\n      the_display->have_xsync = TRUE;\n    \n    meta_verbose (\"Attempted to init Xsync, found version %d.%d error base %d event base %d\\n\",\n                  major, minor,\n                  the_display->xsync_error_base,\n                  the_display->xsync_event_base);\n  }\n#else  /* HAVE_XSYNC */\n  meta_verbose (\"Not compiled with Xsync support\\n\");\n#endif /* !HAVE_XSYNC */\n\n\n#ifdef HAVE_SHAPE\n  {\n    the_display->have_shape = FALSE;\n    \n    the_display->shape_error_base = 0;\n    the_display->shape_event_base = 0;\n    \n    if (!XShapeQueryExtension (the_display->xdisplay,\n                               &the_display->shape_event_base,\n                               &the_display->shape_error_base))\n      {\n        the_display->shape_error_base = 0;\n        the_display->shape_event_base = 0;\n      }\n    else\n      the_display->have_shape = TRUE;\n    \n    meta_verbose (\"Attempted to init Shape, found error base %d event base %d\\n\",\n                  the_display->shape_error_base,\n                  the_display->shape_event_base);\n  }\n#else  /* HAVE_SHAPE */\n  meta_verbose (\"Not compiled with Shape support\\n\");\n#endif /* !HAVE_SHAPE */\n\n#ifdef HAVE_RENDER\n  {\n    the_display->have_render = FALSE;\n    \n    the_display->render_error_base = 0;\n    the_display->render_event_base = 0;\n    \n    if (!XRenderQueryExtension (the_display->xdisplay,\n                                &the_display->render_event_base,\n                                &the_display->render_error_base))\n      {\n        the_display->render_error_base = 0;\n        the_display->render_event_base = 0;\n      }\n    else\n      the_display->have_render = TRUE;\n    \n    meta_verbose (\"Attempted to init Render, found error base %d event base %d\\n\",\n                  the_display->render_error_base,\n                  the_display->render_event_base);\n  }\n#else  /* HAVE_RENDER */\n  meta_verbose (\"Not compiled with Render support\\n\");\n#endif /* !HAVE_RENDER */\n\n#ifdef HAVE_COMPOSITE_EXTENSIONS\n  {\n    the_display->have_composite = FALSE;\n\n    the_display->composite_error_base = 0;\n    the_display->composite_event_base = 0;\n\n    if (!XCompositeQueryExtension (the_display->xdisplay,\n                                   &the_display->composite_event_base,\n                                   &the_display->composite_error_base))\n      {\n        the_display->composite_error_base = 0;\n        the_display->composite_event_base = 0;\n      } \n    else\n      {\n        the_display->composite_major_version = 0;\n        the_display->composite_minor_version = 0;\n        if (XCompositeQueryVersion (the_display->xdisplay,\n                                    &the_display->composite_major_version,\n                                    &the_display->composite_minor_version))\n          {\n            the_display->have_composite = TRUE;\n          }\n        else\n          {\n            the_display->composite_major_version = 0;\n            the_display->composite_minor_version = 0;\n          }\n      }\n\n    meta_verbose (\"Attempted to init Composite, found error base %d event base %d \"\n                  \"extn ver %d %d\\n\",\n                  the_display->composite_error_base, \n                  the_display->composite_event_base,\n                  the_display->composite_major_version,\n                  the_display->composite_minor_version);\n\n    the_display->have_damage = FALSE;\n\n    the_display->damage_error_base = 0;\n    the_display->damage_event_base = 0;\n\n    if (!XDamageQueryExtension (the_display->xdisplay,\n                                &the_display->damage_event_base,\n                                &the_display->damage_error_base))\n      {\n        the_display->damage_error_base = 0;\n        the_display->damage_event_base = 0;\n      } \n    else\n      the_display->have_damage = TRUE;\n\n    meta_verbose (\"Attempted to init Damage, found error base %d event base %d\\n\",\n                  the_display->damage_error_base, \n                  the_display->damage_event_base);\n\n    the_display->have_xfixes = FALSE;\n\n    the_display->xfixes_error_base = 0;\n    the_display->xfixes_event_base = 0;\n\n    if (!XFixesQueryExtension (the_display->xdisplay,\n                               &the_display->xfixes_event_base,\n                               &the_display->xfixes_error_base))\n      {\n        the_display->xfixes_error_base = 0;\n        the_display->xfixes_event_base = 0;\n      } \n    else\n      the_display->have_xfixes = TRUE;\n\n    meta_verbose (\"Attempted to init XFixes, found error base %d event base %d\\n\",\n                  the_display->xfixes_error_base, \n                  the_display->xfixes_event_base);\n  }\n#else /* HAVE_COMPOSITE_EXTENSIONS */\n  meta_verbose (\"Not compiled with Composite support\\n\");\n#endif /* !HAVE_COMPOSITE_EXTENSIONS */\n      \n#ifdef HAVE_XCURSOR\n  {\n    XcursorSetTheme (the_display->xdisplay, meta_prefs_get_cursor_theme ());\n    XcursorSetDefaultSize (the_display->xdisplay, meta_prefs_get_cursor_size ());\n  }\n#else /* HAVE_XCURSOR */\n  meta_verbose (\"Not compiled with Xcursor support\\n\");\n#endif /* !HAVE_XCURSOR */\n\n  /* Create the leader window here. Set its properties and\n   * use the timestamp from one of the PropertyNotify events\n   * that will follow.\n   */\n  {\n    gulong data[1];\n    XEvent event;\n\n    /* We only care about the PropertyChangeMask in the next 30 or so lines of\n     * code.  Note that gdk will at some point unset the PropertyChangeMask for\n     * this window, so we can't rely on it still being set later.  See bug\n     * 354213 for details.\n     */\n    the_display->leader_window =\n      meta_create_offscreen_window (the_display->xdisplay,\n                                    DefaultRootWindow (the_display->xdisplay),\n                                    PropertyChangeMask);\n\n    meta_prop_set_utf8_string_hint (the_display,\n                                    the_display->leader_window,\n                                    the_display->atom__NET_WM_NAME,\n                                    \"Metacity\");\n    \n    meta_prop_set_utf8_string_hint (the_display,\n                                    the_display->leader_window,\n                                    the_display->atom__METACITY_VERSION,\n                                    VERSION);\n\n    data[0] = the_display->leader_window;\n    XChangeProperty (the_display->xdisplay,\n                     the_display->leader_window,\n                     the_display->atom__NET_SUPPORTING_WM_CHECK,\n                     XA_WINDOW,\n                     32, PropModeReplace, (guchar*) data, 1);\n\n    XWindowEvent (the_display->xdisplay,\n                  the_display->leader_window,\n                  PropertyChangeMask,\n                  &event);\n\n    timestamp = event.xproperty.time;\n\n    /* Make it painfully clear that we can't rely on PropertyNotify events on\n     * this window, as per bug 354213.\n     */\n    XSelectInput(the_display->xdisplay,\n                 the_display->leader_window,\n                 NoEventMask);\n  }\n\n  /* Make a little window used only for pinging the server for timestamps; note\n   * that meta_create_offscreen_window already selects for PropertyChangeMask.\n   */\n  the_display->timestamp_pinging_window =\n    meta_create_offscreen_window (the_display->xdisplay,\n                                  DefaultRootWindow (the_display->xdisplay),\n                                  PropertyChangeMask);\n\n  the_display->last_focus_time = timestamp;\n  the_display->last_user_time = timestamp;\n  the_display->compositor = NULL;\n  \n  screens = NULL;\n  \n  i = 0;\n  while (i < ScreenCount (xdisplay))\n    {\n      MetaScreen *screen;\n\n      screen = meta_screen_new (the_display, i, timestamp);\n\n      if (screen)\n        screens = g_slist_prepend (screens, screen);\n      ++i;\n    }\n  \n  the_display->screens = screens;\n  \n  if (screens == NULL)\n    {\n      /* This would typically happen because all the screens already\n       * have window managers.\n       */\n      meta_display_close (the_display, timestamp);\n      return FALSE;\n    }\n\n  /* We don't composite the windows here because they will be composited \n     faster with the call to meta_screen_manage_all_windows further down \n     the code */\n  if (meta_prefs_get_compositing_manager ())\n    enable_compositor (the_display, FALSE);\n   \n  meta_display_grab (the_display);\n  \n  /* Now manage all existing windows */\n  tmp = the_display->screens;\n  while (tmp != NULL)\n    {\n      MetaScreen *screen = tmp->data;\n\t\n      meta_screen_manage_all_windows (screen);\n\n      tmp = tmp->next;\n    }\n\n  {\n    Window focus;\n    int ret_to;\n\n    /* kinda bogus because GetInputFocus has no possible errors */\n    meta_error_trap_push (the_display);\n\n    /* FIXME: This is totally broken; see comment 9 of bug 88194 about this */\n    focus = None;\n    ret_to = RevertToPointerRoot;\n    XGetInputFocus (the_display->xdisplay, &focus, &ret_to);\n\n    /* Force a new FocusIn (does this work?) */\n\n    /* Use the same timestamp that was passed to meta_screen_new(),\n     * as it is the most recent timestamp.\n     */\n    if (focus == None || focus == PointerRoot)\n      /* Just focus the no_focus_window on the first screen */\n      meta_display_focus_the_no_focus_window (the_display,\n                                              the_display->screens->data,\n                                              timestamp);\n    else\n      {\n        MetaWindow * window;\n        window  = meta_display_lookup_x_window (the_display, focus);\n        if (window)\n          meta_display_set_input_focus_window (the_display, window, FALSE, timestamp);\n        else\n          /* Just focus the no_focus_window on the first screen */\n          meta_display_focus_the_no_focus_window (the_display,\n                                                  the_display->screens->data,\n                                                  timestamp);\n      }\n\n    meta_error_trap_pop (the_display, FALSE);\n  }\n  \n  meta_display_ungrab (the_display);  \n\n  /* Done opening new display */\n  the_display->display_opening = FALSE;\n\n  return TRUE;\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* get windows contained on workspace, including workspace->windows\n * and also sticky windows.\n */\n", "func_signal": "GList*\nmeta_workspace_list_windows (MetaWorkspace *workspace)", "code": "{\n  GSList *display_windows;\n  GSList *tmp;\n  GList *workspace_windows;\n  \n  display_windows = meta_display_list_windows (workspace->screen->display);\n\n  workspace_windows = NULL;\n  tmp = display_windows;\n  while (tmp != NULL)\n    {\n      MetaWindow *window = tmp->data;\n\n      if (meta_window_located_on_workspace (window, workspace))\n        workspace_windows = g_list_prepend (workspace_windows,\n                                            window);\n\n      tmp = tmp->next;\n    }\n\n  g_slist_free (display_windows);\n\n  return workspace_windows;\n}", "path": "src\\core\\workspace.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* WITH_VERBOSE_MODE */\n", "func_signal": "void\nmeta_prefs_set_num_workspaces (int n_workspaces)", "code": "{\n#ifdef HAVE_GCONF\n  GError *err;\n  \n  if (default_client == NULL)\n    return;\n\n  if (n_workspaces < 1)\n    n_workspaces = 1;\n  if (n_workspaces > MAX_REASONABLE_WORKSPACES)\n    n_workspaces = MAX_REASONABLE_WORKSPACES;\n  \n  err = NULL;\n  gconf_client_set_int (default_client,\n                        KEY_NUM_WORKSPACES,\n                        n_workspaces,\n                        &err);\n\n  if (err)\n    {\n      meta_warning (_(\"Error setting number of workspaces to %d: %s\\n\"),\n                    num_workspaces,\n                    err->message);\n      g_error_free (err);\n    }\n#endif /* HAVE_GCONF */\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* HAVE_GCONF */\n", "func_signal": "const char*\nmeta_prefs_get_command (int i)", "code": "{\n  g_return_val_if_fail (i >= 0 && i < MAX_COMMANDS, NULL);\n  \n  return commands[i];\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * Special case: give a warning the first time disable_workarounds\n * is turned on.\n */\n", "func_signal": "static void\nmaybe_give_disable_workarounds_warning (void)", "code": "{\n  static gboolean first_disable = TRUE;\n    \n  if (first_disable && disable_workarounds)\n    {\n      first_disable = FALSE;\n\n      meta_warning (_(\"Workarounds for broken applications disabled. \"\n                      \"Some applications may not behave properly.\\n\"));\n    }\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * This is the most important function in the whole program. It is the heart,\n * it is the nexus, it is the Grand Central Station of Metacity's world.\n * When we create a MetaDisplay, we ask GDK to pass *all* events for *all*\n * windows to this function. So every time anything happens that we might\n * want to know about, this function gets called. You see why it gets a bit\n * busy around here. Most of this function is a ginormous switch statement\n * dealing with all the kinds of events that might turn up.\n *\n * \\param event The event that just happened\n * \\param data  The MetaDisplay that events are coming from, cast to a gpointer\n *              so that it can be sent to a callback\n *\n * \\ingroup main\n */\n", "func_signal": "static gboolean\nevent_callback (XEvent   *event,\n                gpointer  data)", "code": "{\n  MetaWindow *window;\n  MetaWindow *property_for_window;\n  MetaDisplay *display;\n  Window modified;\n  gboolean frame_was_receiver;\n  gboolean filter_out_event;\n\n  display = data;\n  \n#ifdef WITH_VERBOSE_MODE\n  if (dump_events)\n    meta_spew_event (display, event);\n#endif\n\n#ifdef HAVE_STARTUP_NOTIFICATION\n  sn_display_process_event (display->sn_display, event);\n#endif\n  \n  filter_out_event = FALSE;\n  display->current_time = event_get_time (display, event);\n  display->xinerama_cache_invalidated = TRUE;\n  \n  modified = event_get_modified_window (display, event);\n  \n  if (event->type == ButtonPress)\n    {\n      /* filter out scrollwheel */\n      if (event->xbutton.button == 4 ||\n\t  event->xbutton.button == 5)\n\treturn FALSE;\n    }\n  else if (event->type == UnmapNotify)\n    {\n      if (meta_ui_window_should_not_cause_focus (display->xdisplay,\n                                                 modified))\n        {\n          add_ignored_serial (display, event->xany.serial);\n          meta_topic (META_DEBUG_FOCUS,\n                      \"Adding EnterNotify serial %lu to ignored focus serials\\n\",\n                      event->xany.serial);\n        }\n    }\n  else if (event->type == LeaveNotify &&\n           event->xcrossing.mode == NotifyUngrab &&\n           modified == display->ungrab_should_not_cause_focus_window)\n    {\n      add_ignored_serial (display, event->xany.serial);\n      meta_topic (META_DEBUG_FOCUS,\n                  \"Adding LeaveNotify serial %lu to ignored focus serials\\n\",\n                  event->xany.serial);\n    }\n\n  if (modified != None)\n    window = meta_display_lookup_x_window (display, modified);\n  else\n    window = NULL;\n\n  /* We only want to respond to _NET_WM_USER_TIME property notify\n   * events on _NET_WM_USER_TIME_WINDOW windows; in particular,\n   * responding to UnmapNotify events is kind of bad.\n   */\n  property_for_window = NULL;\n  if (window && modified == window->user_time_window)\n    {\n      property_for_window = window;\n      window = NULL;\n    }\n    \n\n  frame_was_receiver = FALSE;\n  if (window &&\n      window->frame &&\n      modified == window->frame->xwindow)\n    {\n      /* Note that if the frame and the client both have an\n       * XGrabButton (as is normal with our setup), the event\n       * goes to the frame.\n       */\n      frame_was_receiver = TRUE;\n      meta_topic (META_DEBUG_EVENTS, \"Frame was receiver of event for %s\\n\",\n                  window->desc);\n    }\n\n#ifdef HAVE_XSYNC\n  if (META_DISPLAY_HAS_XSYNC (display) && \n      event->type == (display->xsync_event_base + XSyncAlarmNotify) &&\n      ((XSyncAlarmNotifyEvent*)event)->alarm == display->grab_sync_request_alarm)\n    {\n      filter_out_event = TRUE; /* GTK doesn't want to see this really */\n      \n      if (display->grab_op != META_GRAB_OP_NONE &&\n          display->grab_window != NULL &&\n          grab_op_is_mouse (display->grab_op))\n\tmeta_window_handle_mouse_grab_op_event (display->grab_window, event);\n    }\n#endif /* HAVE_XSYNC */\n\n#ifdef HAVE_SHAPE\n  if (META_DISPLAY_HAS_SHAPE (display) && \n      event->type == (display->shape_event_base + ShapeNotify))\n    {\n      filter_out_event = TRUE; /* GTK doesn't want to see this really */\n      \n      if (window && !frame_was_receiver)\n        {\n          XShapeEvent *sev = (XShapeEvent*) event;\n\n          if (sev->kind == ShapeBounding)\n            {\n              if (sev->shaped && !window->has_shape)\n                {\n                  window->has_shape = TRUE;                  \n                  meta_topic (META_DEBUG_SHAPES,\n                              \"Window %s now has a shape\\n\",\n                              window->desc);\n                }\n              else if (!sev->shaped && window->has_shape)\n                {\n                  window->has_shape = FALSE;\n                  meta_topic (META_DEBUG_SHAPES,\n                              \"Window %s no longer has a shape\\n\",\n                              window->desc);\n                }\n              else\n                {\n                  meta_topic (META_DEBUG_SHAPES,\n                              \"Window %s shape changed\\n\",\n                              window->desc);\n                }\n\n              if (window->frame)\n                {\n                  window->frame->need_reapply_frame_shape = TRUE;\n\t\t  meta_warning(\"from event callback\\n\");\t\t  \n                  meta_window_queue (window, META_QUEUE_MOVE_RESIZE);\n                }\n            }\n        }\n      else\n        {\n          meta_topic (META_DEBUG_SHAPES,\n                      \"ShapeNotify not on a client window (window %s frame_was_receiver = %d)\\n\",\n                      window ? window->desc : \"(none)\",\n                      frame_was_receiver);\n        }\n    }\n#endif /* HAVE_SHAPE */\n\n  if (window && ((event->type == KeyPress) || (event->type == ButtonPress)))\n    {\n      if (CurrentTime == display->current_time)\n        {\n          /* We can't use missing (i.e. invalid) timestamps to set user time,\n           * nor do we want to use them to sanity check other timestamps.\n           * See bug 313490 for more details.\n           */\n          meta_warning (\"Event has no timestamp! You may be using a broken \"\n                        \"program such as xse.  Please ask the authors of that \"\n                        \"program to fix it.\\n\");\n        }\n      else\n        {\n          meta_window_set_user_time (window, display->current_time);\n          sanity_check_timestamps (display, display->current_time);\n        }\n    }\n  \n  switch (event->type)\n    {\n    case KeyPress:\n    case KeyRelease:\n      meta_display_process_key_event (display, window, event);\n      break;\n    case ButtonPress:\n      if ((window &&\n           grab_op_is_mouse (display->grab_op) &&\n           display->grab_button != (int) event->xbutton.button &&\n           display->grab_window == window) ||\n          grab_op_is_keyboard (display->grab_op))\n        {\n          meta_topic (META_DEBUG_WINDOW_OPS,\n                      \"Ending grab op %u on window %s due to button press\\n\",\n                      display->grab_op,\n                      (display->grab_window ?\n                       display->grab_window->desc : \n                       \"none\"));\n          if (GRAB_OP_IS_WINDOW_SWITCH (display->grab_op))\n            {\n              MetaScreen *screen;\n              meta_topic (META_DEBUG_WINDOW_OPS, \n                          \"Syncing to old stack positions.\\n\");\n              screen = \n                meta_display_screen_for_root (display, event->xany.window);\n\n              if (screen!=NULL)\n                meta_stack_set_positions (screen->stack,\n                                          display->grab_old_window_stacking);\n            }\n          meta_display_end_grab_op (display,\n                                    event->xbutton.time);\n        }\n      else if (window && display->grab_op == META_GRAB_OP_NONE)\n        {\n          gboolean begin_move = FALSE;\n          unsigned int grab_mask;\n          gboolean unmodified;\n\n          grab_mask = display->window_grab_modifiers;\n          if (g_getenv (\"METACITY_DEBUG_BUTTON_GRABS\"))\n            grab_mask |= ControlMask;\n\n          /* Two possible sources of an unmodified event; one is a\n           * client that's letting button presses pass through to the\n           * frame, the other is our focus_window_grab on unmodified\n           * button 1.  So for all such events we focus the window.\n           */\n          unmodified = (event->xbutton.state & grab_mask) == 0;\n          \n          if (unmodified ||\n              event->xbutton.button == 1)\n            {\n              /* don't focus if frame received, will be lowered in\n               * frames.c or special-cased if the click was on a\n               * minimize/close button.\n               */\n              if (!frame_was_receiver)\n                {\n                  if (meta_prefs_get_raise_on_click ()) \n                    meta_window_raise (window);\n                  else\n                    meta_topic (META_DEBUG_FOCUS,\n                                \"Not raising window on click due to don't-raise-on-click option\\n\");\n\n                  /* Don't focus panels--they must explicitly request focus.\n                   * See bug 160470\n                   */\n\t\t  if (window->type != META_WINDOW_DOCK)\n                    {\n                      meta_topic (META_DEBUG_FOCUS,\n                                  \"Focusing %s due to unmodified button %u press (display.c)\\n\",\n                                  window->desc, event->xbutton.button);\n                      meta_window_focus (window, event->xbutton.time);\n                    }\n                  else\n                    /* However, do allow terminals to lose focus due to new\n                     * window mappings after the user clicks on a panel.\n                     */\n                    display->allow_terminal_deactivation = TRUE;\n                }\n              \n              /* you can move on alt-click but not on\n               * the click-to-focus\n               */\n              if (!unmodified)\n                begin_move = TRUE;\n            }\n          else if (!unmodified && event->xbutton.button == meta_prefs_get_mouse_button_resize())\n            {\n              if (window->has_resize_func)\n                {\n                  gboolean north, south;\n                  gboolean west, east;\n                  int root_x, root_y;\n                  MetaGrabOp op;\n\n                  meta_window_get_position (window, &root_x, &root_y);\n\n                  west = event->xbutton.x_root <  (root_x + 1 * window->rect.width  / 3);\n                  east = event->xbutton.x_root >  (root_x + 2 * window->rect.width  / 3);\n                  north = event->xbutton.y_root < (root_y + 1 * window->rect.height / 3);\n                  south = event->xbutton.y_root > (root_y + 2 * window->rect.height / 3);\n\n                  if (north && west)\n                    op = META_GRAB_OP_RESIZING_NW;\n                  else if (north && east)\n                    op = META_GRAB_OP_RESIZING_NE;\n                  else if (south && west)\n                    op = META_GRAB_OP_RESIZING_SW;\n                  else if (south && east)\n                    op = META_GRAB_OP_RESIZING_SE;\n                  else if (north)\n                    op = META_GRAB_OP_RESIZING_N;\n                  else if (west)\n                    op = META_GRAB_OP_RESIZING_W;\n                  else if (east)\n                    op = META_GRAB_OP_RESIZING_E;\n                  else if (south)\n                    op = META_GRAB_OP_RESIZING_S;\n                  else /* Middle region is no-op to avoid user triggering wrong action */\n                    op = META_GRAB_OP_NONE;\n                  \n                  if (op != META_GRAB_OP_NONE)\n                    meta_display_begin_grab_op (display,\n                                                window->screen,\n                                                window,\n                                                op,\n                                                TRUE,\n                                                FALSE,\n                                                event->xbutton.button,\n                                                0,\n                                                event->xbutton.time,\n                                                event->xbutton.x_root,\n                                                event->xbutton.y_root);\n                }\n            }\n          else if (event->xbutton.button == meta_prefs_get_mouse_button_menu())\n            {\n              if (meta_prefs_get_raise_on_click ())\n                meta_window_raise (window);\n              meta_window_show_menu (window,\n                                     event->xbutton.x_root,\n                                     event->xbutton.y_root,\n                                     event->xbutton.button,\n                                     event->xbutton.time);\n            }\n\n          if (!frame_was_receiver && unmodified)\n            {\n              /* This is from our synchronous grab since\n               * it has no modifiers and was on the client window\n               */\n              int mode;\n              \n              /* When clicking a different app in click-to-focus\n               * in application-based mode, and the different\n               * app is not a dock or desktop, eat the focus click.\n               */\n              if (meta_prefs_get_focus_mode () == META_FOCUS_MODE_CLICK &&\n                  meta_prefs_get_application_based () &&\n                  !window->has_focus &&\n                  window->type != META_WINDOW_DOCK &&\n                  window->type != META_WINDOW_DESKTOP &&\n                  (display->focus_window == NULL ||\n                   !meta_window_same_application (window,\n                                                  display->focus_window)))\n                mode = AsyncPointer; /* eat focus click */\n              else\n                mode = ReplayPointer; /* give event back */\n\n              meta_verbose (\"Allowing events mode %s time %u\\n\",\n                            mode == AsyncPointer ? \"AsyncPointer\" : \"ReplayPointer\",\n                            (unsigned int)event->xbutton.time);\n              \n              XAllowEvents (display->xdisplay,\n                            mode, event->xbutton.time);\n            }\n\n          if (begin_move && window->has_move_func)\n            {\n              meta_display_begin_grab_op (display,\n                                          window->screen,\n                                          window,\n                                          META_GRAB_OP_MOVING,\n                                          TRUE,\n                                          FALSE,\n                                          event->xbutton.button,\n                                          0,\n                                          event->xbutton.time,\n                                          event->xbutton.x_root,\n                                          event->xbutton.y_root);\n            }\n        }\n      break;\n    case ButtonRelease:\n      if (display->grab_window == window &&\n          grab_op_is_mouse (display->grab_op))\n        meta_window_handle_mouse_grab_op_event (window, event);\n      break;\n    case MotionNotify:\n      if (display->grab_window == window &&\n          grab_op_is_mouse (display->grab_op))\n        meta_window_handle_mouse_grab_op_event (window, event);\n      break;\n    case EnterNotify:\n      if (display->grab_window == window &&\n          grab_op_is_mouse (display->grab_op))\n        {\n          meta_window_handle_mouse_grab_op_event (window, event);\n          break;\n        }\n\n      /* If the mouse switches screens, active the default window on the new\n       * screen; this will make keybindings and workspace-launched items\n       * actually appear on the right screen.\n       */\n      {\n        MetaScreen *new_screen = \n          meta_display_screen_for_root (display, event->xcrossing.root);\n\n        if (new_screen != NULL && display->active_screen != new_screen)\n          meta_workspace_focus_default_window (new_screen->active_workspace, \n                                               NULL,\n                                               event->xcrossing.time);\n      }\n\n      /* Check if we've entered a window; do this even if window->has_focus to\n       * avoid races.\n       */\n      if (window && !serial_is_ignored (display, event->xany.serial) &&\n               event->xcrossing.mode != NotifyGrab && \n               event->xcrossing.mode != NotifyUngrab &&\n               event->xcrossing.detail != NotifyInferior &&\n               meta_display_focus_sentinel_clear (display))\n        {\n          switch (meta_prefs_get_focus_mode ())\n            {\n            case META_FOCUS_MODE_SLOPPY:\n            case META_FOCUS_MODE_MOUSE:\n              display->mouse_mode = TRUE;\n              if (window->type != META_WINDOW_DOCK &&\n                  window->type != META_WINDOW_DESKTOP)\n                {\n                  meta_topic (META_DEBUG_FOCUS,\n                              \"Focusing %s due to enter notify with serial %lu \"\n                              \"at time %lu, and setting display->mouse_mode to \"\n                              \"TRUE.\\n\",\n                              window->desc, \n                              event->xany.serial,\n                              event->xcrossing.time);\n\n                  meta_window_focus (window, event->xcrossing.time);\n\n                  /* stop ignoring stuff */\n                  reset_ignores (display);\n                  \n                  if (meta_prefs_get_auto_raise ()) \n                    {\n                      meta_display_queue_autoraise_callback (display, window);\n                    }\n                  else\n                    {\n                      meta_topic (META_DEBUG_FOCUS,\n                                  \"Auto raise is disabled\\n\");\t\t      \n                    }\n                }\n              /* In mouse focus mode, we defocus when the mouse *enters*\n               * the DESKTOP window, instead of defocusing on LeaveNotify.\n               * This is because having the mouse enter override-redirect\n               * child windows unfortunately causes LeaveNotify events that\n               * we can't distinguish from the mouse actually leaving the\n               * toplevel window as we expect.  But, since we filter out\n               * EnterNotify events on override-redirect windows, this\n               * alternative mechanism works great.\n               */\n              if (window->type == META_WINDOW_DESKTOP &&\n                  meta_prefs_get_focus_mode() == META_FOCUS_MODE_MOUSE &&\n                  display->expected_focus_window != NULL)\n                {\n                  meta_topic (META_DEBUG_FOCUS,\n                              \"Unsetting focus from %s due to mouse entering \"\n                              \"the DESKTOP window\\n\",\n                              display->expected_focus_window->desc);\n                  meta_display_focus_the_no_focus_window (display, \n                                                          window->screen,\n                                                          event->xcrossing.time);\n                }\n              break;\n            case META_FOCUS_MODE_CLICK:\n              break;\n            }\n          \n          if (window->type == META_WINDOW_DOCK)\n            meta_window_raise (window);\n        }\n      break;\n    case LeaveNotify:\n      if (display->grab_window == window &&\n          grab_op_is_mouse (display->grab_op))\n        meta_window_handle_mouse_grab_op_event (window, event);\n      else if (window != NULL)\n        {\n          if (window->type == META_WINDOW_DOCK &&\n              event->xcrossing.mode != NotifyGrab &&\n              event->xcrossing.mode != NotifyUngrab &&\n              !window->has_focus)\n            meta_window_lower (window);\n        }\n      break;\n    case FocusIn:\n    case FocusOut:\n      if (window)\n        {\n          meta_window_notify_focus (window, event);\n        }\n      else if (meta_display_xwindow_is_a_no_focus_window (display,\n                                                          event->xany.window))\n        {\n          meta_topic (META_DEBUG_FOCUS,\n                      \"Focus %s event received on no_focus_window 0x%lx \"\n                      \"mode %s detail %s\\n\",\n                      event->type == FocusIn ? \"in\" :\n                      event->type == FocusOut ? \"out\" :\n                      \"???\",\n                      event->xany.window,\n                      meta_event_mode_to_string (event->xfocus.mode),\n                      meta_event_detail_to_string (event->xfocus.detail));\n        }\n      else\n        {\n          MetaScreen *screen =\n                meta_display_screen_for_root(display,\n                                             event->xany.window);\n          if (screen == NULL)\n            break;\n\n          meta_topic (META_DEBUG_FOCUS,\n                      \"Focus %s event received on root window 0x%lx \"\n                      \"mode %s detail %s\\n\",\n                      event->type == FocusIn ? \"in\" :\n                      event->type == FocusOut ? \"out\" :\n                      \"???\",\n                      event->xany.window,\n                      meta_event_mode_to_string (event->xfocus.mode),\n                      meta_event_detail_to_string (event->xfocus.detail));\n          \n          if (event->type == FocusIn &&\n              event->xfocus.detail == NotifyDetailNone)\n            {\n              meta_topic (META_DEBUG_FOCUS, \n                          \"Focus got set to None, probably due to \"\n                          \"brain-damage in the X protocol (see bug \"\n                          \"125492).  Setting the default focus window.\\n\");\n              meta_workspace_focus_default_window (screen->active_workspace,\n                                                   NULL,\n                                                   meta_display_get_current_time_roundtrip (display));\n            }\n          else if (event->type == FocusIn &&\n              event->xfocus.mode == NotifyNormal &&\n              event->xfocus.detail == NotifyInferior)\n            {\n              meta_topic (META_DEBUG_FOCUS,\n                          \"Focus got set to root window, probably due to \"\n                          \"gnome-session logout dialog usage (see bug \"\n                          \"153220).  Setting the default focus window.\\n\");\n              meta_workspace_focus_default_window (screen->active_workspace,\n                                                   NULL,\n                                                   meta_display_get_current_time_roundtrip (display));\n            }\n\n        }\n      break;\n    case KeymapNotify:\n      break;\n    case Expose:\n      break;\n    case GraphicsExpose:\n      break;\n    case NoExpose:\n      break;\n    case VisibilityNotify:\n      break;\n    case CreateNotify:\n      break;\n      \n    case DestroyNotify:\n      if (window)\n        {\n          /* FIXME: It sucks that DestroyNotify events don't come with\n           * a timestamp; could we do something better here?  Maybe X\n           * will change one day?\n           */\n          guint32 timestamp;\n          timestamp = meta_display_get_current_time_roundtrip (display);\n\n          if (display->grab_op != META_GRAB_OP_NONE &&\n              display->grab_window == window)\n            meta_display_end_grab_op (display, timestamp);\n          \n          if (frame_was_receiver)\n            {\n              meta_warning (\"Unexpected destruction of frame 0x%lx, not sure if this should silently fail or be considered a bug\\n\",\n                            window->frame->xwindow);\n              meta_error_trap_push (display);\n              meta_window_destroy_frame (window->frame->window);\n              meta_error_trap_pop (display, FALSE);\n            }\n          else\n            {\n              /* Unmanage destroyed window */\n              meta_window_free (window, timestamp);\n              window = NULL;\n            }\n        }\n      break;\n    case UnmapNotify:\n      if (window)\n        {\n          /* FIXME: It sucks that UnmapNotify events don't come with\n           * a timestamp; could we do something better here?  Maybe X\n           * will change one day?\n           */\n          guint32 timestamp;\n          timestamp = meta_display_get_current_time_roundtrip (display);\n\n          if (display->grab_op != META_GRAB_OP_NONE &&\n              display->grab_window == window &&\n              ((window->frame == NULL) || !window->frame->mapped))\n            meta_display_end_grab_op (display, timestamp);\n      \n          if (!frame_was_receiver)\n            {\n              if (window->unmaps_pending == 0)\n                {\n                  meta_topic (META_DEBUG_WINDOW_STATE,\n                              \"Window %s withdrawn\\n\",\n                              window->desc);\n\n                  meta_effect_run_close (window, NULL, NULL);\n\n                  /* Unmanage withdrawn window */\t\t  \n                  window->withdrawn = TRUE;\n                  meta_window_free (window, timestamp);\n                  window = NULL;\n                }\n              else\n                {\n                  window->unmaps_pending -= 1;\n                  meta_topic (META_DEBUG_WINDOW_STATE,\n                              \"Received pending unmap, %d now pending\\n\",\n                              window->unmaps_pending);\n                }\n            }\n\n          /* Unfocus on UnmapNotify, do this after the possible\n           * window_free above so that window_free can see if window->has_focus\n           * and move focus to another window\n           */\n          if (window)\n            meta_window_notify_focus (window, event);\n        }\n      break;\n    case MapNotify:\n      break;\n    case MapRequest:\n      if (window == NULL)\n        {\n          window = meta_window_new (display, event->xmaprequest.window,\n                                    FALSE);\n        }\n      /* if frame was receiver it's some malicious send event or something */\n      else if (!frame_was_receiver && window)        \n        {\n          meta_verbose (\"MapRequest on %s mapped = %d minimized = %d\\n\",\n                        window->desc, window->mapped, window->minimized);\n          if (window->minimized)\n            {\n              meta_window_unminimize (window);\n              if (window->workspace != window->screen->active_workspace)\n                {\n                  meta_verbose (\"Changing workspace due to MapRequest mapped = %d minimized = %d\\n\",\n                                window->mapped, window->minimized);\n                  meta_window_change_workspace (window,\n                                                window->screen->active_workspace);\n                }\n            }\n        }\n      break;\n    case ReparentNotify:\n      break;\n    case ConfigureNotify:\n      /* Handle screen resize */\n      {\n\tMetaScreen *screen;\n\n        screen = meta_display_screen_for_root (display,\n                                               event->xconfigure.window);\n\n\tif (screen != NULL)\n          {\n#ifdef HAVE_RANDR\n            /* do the resize the official way */\n            XRRUpdateConfiguration (event);\n#else\n            /* poke around in Xlib */\n            screen->xscreen->width   = event->xconfigure.width;\n            screen->xscreen->height  = event->xconfigure.height;\n#endif\n            \n            meta_screen_resize (screen, \n                                event->xconfigure.width,\n                                event->xconfigure.height);\n          }\n      }\n      break;\n    case ConfigureRequest:\n      /* This comment and code is found in both twm and fvwm */\n      /*\n       * According to the July 27, 1988 ICCCM draft, we should ignore size and\n       * position fields in the WM_NORMAL_HINTS property when we map a window.\n       * Instead, we'll read the current geometry.  Therefore, we should respond\n       * to configuration requests for windows which have never been mapped.\n       */\n      if (window == NULL)\n        {\n          unsigned int xwcm;\n          XWindowChanges xwc;\n          \n          xwcm = event->xconfigurerequest.value_mask &\n            (CWX | CWY | CWWidth | CWHeight | CWBorderWidth);\n\n          xwc.x = event->xconfigurerequest.x;\n          xwc.y = event->xconfigurerequest.y;\n          xwc.width = event->xconfigurerequest.width;\n          xwc.height = event->xconfigurerequest.height;\n          xwc.border_width = event->xconfigurerequest.border_width;\n\n          meta_verbose (\"Configuring withdrawn window to %d,%d %dx%d border %d (some values may not be in mask)\\n\",\n                        xwc.x, xwc.y, xwc.width, xwc.height, xwc.border_width);\n          meta_error_trap_push (display);\n          XConfigureWindow (display->xdisplay, event->xconfigurerequest.window,\n                            xwcm, &xwc);\n          meta_error_trap_pop (display, FALSE);\n        }\n      else\n        {\n          if (!frame_was_receiver)\n            meta_window_configure_request (window, event);\n        }\n      break;\n    case GravityNotify:\n      break;\n    case ResizeRequest:\n      break;\n    case CirculateNotify:\n      break;\n    case CirculateRequest:\n      break;\n    case PropertyNotify:\n      {\n        MetaGroup *group;\n        MetaScreen *screen;\n        \n        if (window && !frame_was_receiver)\n          meta_window_property_notify (window, event);\n        else if (property_for_window && !frame_was_receiver)\n          meta_window_property_notify (property_for_window, event);\n\n        group = meta_display_lookup_group (display,\n                                           event->xproperty.window);\n        if (group != NULL)\n          meta_group_property_notify (group, event);\n        \n        screen = NULL;\n        if (window == NULL &&\n            group == NULL) /* window/group != NULL means it wasn't a root window */\n          screen = meta_display_screen_for_root (display,\n                                                 event->xproperty.window);\n            \n        if (screen != NULL)\n          {\n            if (event->xproperty.atom ==\n                display->atom__NET_DESKTOP_LAYOUT)\n              meta_screen_update_workspace_layout (screen);\n            else if (event->xproperty.atom ==\n                     display->atom__NET_DESKTOP_NAMES)\n              meta_screen_update_workspace_names (screen);\n#if 0\n            else if (event->xproperty.atom ==\n                     display->atom__NET_RESTACK_WINDOW)\n              handle_net_restack_window (display, event);\n#endif\n\n            /* we just use this property as a sentinel to avoid\n             * certain race conditions.  See the comment for the\n             * sentinel_counter variable declaration in display.h\n\t     */\n\t    if (event->xproperty.atom ==\n\t\tdisplay->atom__METACITY_SENTINEL)\n\t      {\n\t\tmeta_display_decrement_focus_sentinel (display);\n\t      }\n          }\n      }\n      break;\n    case SelectionClear:\n      /* do this here instead of at end of function\n       * so we can return\n       */\n\n      /* FIXME: Clearing display->current_time here makes no sense to\n       * me; who put this here and why?\n       */\n      display->current_time = CurrentTime;\n\n      process_selection_clear (display, event);\n      /* Note that processing that may have resulted in\n       * closing the display... so return right away.\n       */\n      return FALSE;\n    case SelectionRequest:\n      process_selection_request (display, event);\n      break;\n    case SelectionNotify:\n      break;\n    case ColormapNotify:\n      if (window && !frame_was_receiver)\n        window->colormap = event->xcolormap.colormap;\n      break;\n    case ClientMessage:\n      if (window)\n        {\n          if (!frame_was_receiver)\n            meta_window_client_message (window, event);\n        }\n      else\n        {\n          MetaScreen *screen;\n\n          screen = meta_display_screen_for_root (display,\n                                                 event->xclient.window);\n          \n          if (screen)\n            {\n              if (event->xclient.message_type ==\n                  display->atom__NET_CURRENT_DESKTOP)\n                {\n                  int space;\n                  MetaWorkspace *workspace;\n                  guint32 time;\n              \n                  space = event->xclient.data.l[0];\n                  time = event->xclient.data.l[1];\n              \n                  meta_verbose (\"Request to change current workspace to %d with \"\n                                \"specified timestamp of %u\\n\",\n                                space, time);\n\n                  workspace =\n                    meta_screen_get_workspace_by_index (screen,\n                                                        space);\n\n                  /* Handle clients using the older version of the spec... */\n                  if (time == 0 && workspace)\n                    {\n                      meta_warning (\"Received a NET_CURRENT_DESKTOP message \"\n                                    \"from a broken (outdated) client who sent \"\n                                    \"a 0 timestamp\\n\");\n                      time = meta_display_get_current_time_roundtrip (display);\n                    }\n\n                  if (workspace)\n                    meta_workspace_activate (workspace, time);\n                  else\n                    meta_verbose (\"Don't know about workspace %d\\n\", space);\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__NET_NUMBER_OF_DESKTOPS)\n                {\n                  int num_spaces;\n              \n                  num_spaces = event->xclient.data.l[0];\n              \n                  meta_verbose (\"Request to set number of workspaces to %d\\n\",\n                                num_spaces);\n\n                  meta_prefs_set_num_workspaces (num_spaces);\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__NET_SHOWING_DESKTOP)\n                {\n                  gboolean showing_desktop;\n                  guint32  timestamp;\n                  \n                  showing_desktop = event->xclient.data.l[0] != 0;\n                  /* FIXME: Braindead protocol doesn't have a timestamp */\n                  timestamp = meta_display_get_current_time_roundtrip (display);\n                  meta_verbose (\"Request to %s desktop\\n\",\n                                showing_desktop ? \"show\" : \"hide\");\n                  \n                  if (showing_desktop)\n                    meta_screen_show_desktop (screen, timestamp);\n                  else\n                    {\n                      meta_screen_unshow_desktop (screen);\n                      meta_workspace_focus_default_window (screen->active_workspace, NULL, timestamp);\n                    }\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__METACITY_RESTART_MESSAGE)\n                {\n                  meta_verbose (\"Received restart request\\n\");\n                  meta_restart ();\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__METACITY_RELOAD_THEME_MESSAGE)\n                {\n                  meta_verbose (\"Received reload theme request\\n\");\n                  meta_ui_set_current_theme (meta_prefs_get_theme (),\n                                             TRUE);\n                  meta_display_retheme_all ();\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__METACITY_SET_KEYBINDINGS_MESSAGE)\n                {\n                  meta_verbose (\"Received set keybindings request = %d\\n\",\n                                (int) event->xclient.data.l[0]);\n                  meta_set_keybindings_disabled (!event->xclient.data.l[0]);\n                }\n              else if (event->xclient.message_type ==\n                       display->atom__METACITY_TOGGLE_VERBOSE)\n                {\n                  meta_verbose (\"Received toggle verbose message\\n\");\n                  meta_set_verbose (!meta_is_verbose ());\n                }\n\t      else if (event->xclient.message_type ==\n\t\t       display->atom_WM_PROTOCOLS) \n\t\t{\n                  meta_verbose (\"Received WM_PROTOCOLS message\\n\");\n                  \n\t\t  if ((Atom)event->xclient.data.l[0] == display->atom__NET_WM_PING)\n                    {\n                      process_pong_message (display, event);\n\n                      /* We don't want ping reply events going into\n                       * the GTK+ event loop because gtk+ will treat\n                       * them as ping requests and send more replies.\n                       */\n                      filter_out_event = TRUE;\n                    }\n\t\t}\n            }\n\n          if (event->xclient.message_type ==\n              display->atom__NET_REQUEST_FRAME_EXTENTS)\n            {\n              meta_verbose (\"Received _NET_REQUEST_FRAME_EXTENTS message\\n\");\n              process_request_frame_extents (display, event);\n            }\n        }\n      break;\n    case MappingNotify:\n      {\n        gboolean ignore_current;\n\n        ignore_current = FALSE;\n        \n        /* Check whether the next event is an identical MappingNotify\n         * event.  If it is, ignore the current event, we'll update\n         * when we get the next one.\n         */\n\tif (XPending (display->xdisplay))\n          {\n            XEvent next_event;\n            \n            XPeekEvent (display->xdisplay, &next_event);\n            \n            if (next_event.type == MappingNotify &&\n                next_event.xmapping.request == event->xmapping.request)\n              ignore_current = TRUE;\n          }\n\n        if (!ignore_current)\n          {\n            /* Let XLib know that there is a new keyboard mapping.\n             */\n            XRefreshKeyboardMapping (&event->xmapping);\n            meta_display_process_mapping_event (display, event);\n          }\n      }\n      break;\n    default:\n#ifdef HAVE_XKB\n      if (event->type == display->xkb_base_event_type) \n\t{\n\t  XkbAnyEvent *xkb_ev = (XkbAnyEvent *) event;\n\t  \n\t  switch (xkb_ev->xkb_type)\n\t    {\n\t    case XkbBellNotify:\n              if (XSERVER_TIME_IS_BEFORE(display->last_bell_time,\n                                         xkb_ev->time - 1000))\n                {\n                  display->last_bell_time = xkb_ev->time;\n                  meta_bell_notify (display, xkb_ev);\n                }\n\t      break;\n\t    }\n\t}\n#endif\n      break;\n    }\n\n  if (display->compositor)\n    {\n      meta_compositor_process_event (display->compositor,\n\t\t\t\t     event,\n\t\t\t\t     window);\n    }\n  \n  display->current_time = CurrentTime;\n  return filter_out_event;\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * A handy way to turn on synchronisation on or off for every display.\n *\n * \\bug Of course there is only one display ever anyway, so this can\n * be rather hugely simplified.\n */\n", "func_signal": "void\nmeta_set_syncing (gboolean setting)", "code": "{\n  if (setting != is_syncing)\n    {\n      is_syncing = setting;\n\n      XSynchronize (meta_get_display ()->xdisplay, is_syncing);\n    }\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* from fvwm2, Copyright Matthias Clasen, Dominik Vogt */\n", "func_signal": "static gboolean\nconvert_property (MetaDisplay *display,\n                  MetaScreen  *screen,\n                  Window       w,\n                  Atom         target,\n                  Atom         property)", "code": "{\n#define N_TARGETS 4\n  Atom conversion_targets[N_TARGETS];\n  long icccm_version[] = { 2, 0 };\n\n  conversion_targets[0] = display->atom_TARGETS;\n  conversion_targets[1] = display->atom_MULTIPLE;\n  conversion_targets[2] = display->atom_TIMESTAMP;\n  conversion_targets[3] = display->atom_VERSION;\n\n  meta_error_trap_push_with_return (display);\n  if (target == display->atom_TARGETS)\n    XChangeProperty (display->xdisplay, w, property,\n\t\t     XA_ATOM, 32, PropModeReplace,\n\t\t     (unsigned char *)conversion_targets, N_TARGETS);\n  else if (target == display->atom_TIMESTAMP)\n    XChangeProperty (display->xdisplay, w, property,\n\t\t     XA_INTEGER, 32, PropModeReplace,\n\t\t     (unsigned char *)&screen->wm_sn_timestamp, 1);\n  else if (target == display->atom_VERSION)\n    XChangeProperty (display->xdisplay, w, property,\n\t\t     XA_INTEGER, 32, PropModeReplace,\n\t\t     (unsigned char *)icccm_version, 2);\n  else\n    {\n      meta_error_trap_pop_with_return (display, FALSE);\n      return FALSE;\n    }\n  \n  if (meta_error_trap_pop_with_return (display, FALSE) != Success)\n    return FALSE;\n\n  /* Be sure the PropertyNotify has arrived so we\n   * can send SelectionNotify\n   */\n  /* FIXME the error trap pop synced anyway, right? */\n  meta_topic (META_DEBUG_SYNC, \"Syncing on %s\\n\", G_STRFUNC);\n  XSync (display->xdisplay, False);\n\n  return TRUE;\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* Return value is TRUE if a preference changed and we need to\n * notify\n */\n", "func_signal": "static gboolean\nfind_and_update_binding (MetaKeyPref *bindings, \n                         const char  *name,\n                         const char  *value)", "code": "{\n  const char *key;\n  int i;\n  \n  if (*name == '/')\n    key = relative_key (name);\n  else\n    key = name;\n\n  i = 0;\n  while (bindings[i].name &&\n         strcmp (key, bindings[i].name) != 0)\n    ++i;\n\n  if (bindings[i].name)\n    return update_binding (&bindings[i], value);\n  else\n    return FALSE;\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* HAVE_GCONF */\n", "func_signal": "const char*\nmeta_prefs_get_workspace_name (int i)", "code": "{\n  g_return_val_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES, NULL);\n\n  g_assert (workspace_names[i] != NULL);\n\n  meta_topic (META_DEBUG_PREFS,\n              \"Getting workspace name for %d: \\\"%s\\\"\\n\",\n              i, workspace_names[i]);\n  \n  return workspace_names[i];\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * Frees every pending ping structure for the given X window on the\n * given display. This means that we also destroy the timeouts.\n *\n * \\param display The display the window appears on\n * \\param xwindow The X ID of the window whose pings we should remove\n *\n * \\ingroup pings\n *\n */\n", "func_signal": "static void\nremove_pending_pings_for_window (MetaDisplay *display, Window xwindow)", "code": "{\n  GSList *tmp;\n  GSList *dead;\n\n  /* could obviously be more efficient, don't care */\n  \n  /* build list to be removed */\n  dead = NULL;\n  for (tmp = display->pending_pings; tmp; tmp = tmp->next)\n    {\n      MetaPingData *ping_data = tmp->data;\n\n      if (ping_data->xwindow == xwindow)\n        dead = g_slist_prepend (dead, ping_data);\n    }\n\n  /* remove what we found */\n  for (tmp = dead; tmp; tmp = tmp->next)\n    {\n      MetaPingData *ping_data = tmp->data;\n\n      display->pending_pings = g_slist_remove (display->pending_pings, ping_data);\n      ping_data_free (ping_data);\n    }\n\n  g_slist_free (dead);\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * Frees the struts list of a workspace.\n *\n * \\param workspace  The workspace.\n */\n", "func_signal": "static void\nworkspace_free_struts (MetaWorkspace *workspace)", "code": "{\n  if (workspace->all_struts == NULL)\n    return;\n    \n  g_slist_foreach (workspace->all_struts, free_this, NULL);\n  g_slist_free (workspace->all_struts);\n  workspace->all_struts = NULL;\n}", "path": "src\\core\\workspace.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* HAVE_GCONF */\n", "func_signal": "const PangoFontDescription*\nmeta_prefs_get_titlebar_font (void)", "code": "{\n  if (use_system_font)\n    return NULL;\n  else\n    return titlebar_font;\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * Destructor for MetaPingData structs. Will destroy the\n * event source for the struct as well.\n *\n * \\ingroup pings\n */\n", "func_signal": "static void\nping_data_free (MetaPingData *ping_data)", "code": "{\n  /* Remove the timeout */\n  if (ping_data->ping_timeout_id != 0)\n    g_source_remove (ping_data->ping_timeout_id);\n\n  g_free (ping_data);\n}", "path": "src\\core\\display.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/* NOT HAVE_GCONF */\n", "func_signal": "static void\ninit_bindings (void)", "code": "{\n#ifdef HAVE_GCONF  \n  int i = 0;\n  GError *err;\n\n  while (key_bindings[i].name)\n    {\n      GSList *list_val, *tmp;\n      char *str_val;\n      char *key;\n \n      key = g_strconcat (key_bindings[i].per_window?\n                         KEY_WINDOW_BINDINGS_PREFIX:\n                         KEY_SCREEN_BINDINGS_PREFIX,\n                         \"/\",\n                         key_bindings[i].name, NULL);\n \n      err = NULL;\n      str_val = gconf_client_get_string (default_client, key, &err);\n      cleanup_error (&err);\n\n      update_binding (&key_bindings[i], str_val);\n\n      g_free (str_val);      \n      g_free (key);\n\n      key = g_strconcat (key_bindings[i].per_window?\n                         KEY_WINDOW_BINDINGS_PREFIX:\n                         KEY_SCREEN_BINDINGS_PREFIX,\n                         \"/\",\n                         key_bindings[i].name,\n                         KEY_LIST_BINDINGS_SUFFIX, NULL);\n\n      err = NULL;\n\n      list_val = gconf_client_get_list (default_client, key, GCONF_VALUE_STRING, &err);\n      cleanup_error (&err);\n \n      update_list_binding (&key_bindings[i], list_val, META_LIST_OF_STRINGS);\n\n      tmp = list_val;\n      while (tmp)\n        {\n          g_free (tmp->data);\n          tmp = tmp->next;\n        }\n      g_slist_free (list_val);\n      g_free (key);\n\n      ++i;\n    }\n#else /* HAVE_GCONF */\n  int i = 0;\n  int which = 0;\n  while (key_string_bindings[i].name)\n    {\n      if (key_string_bindings[i].keybinding == NULL) {\n        ++i;\n        continue;\n      }\n    \n      while (strcmp(key_bindings[which].name, \n                    key_string_bindings[i].name) != 0)\n        which++;\n\n      /* Set the binding */\n      update_binding (&key_bindings[which], \n                      key_string_bindings[i].keybinding);\n\n      ++i;\n    }\n#endif /* HAVE_GCONF */\n}", "path": "src\\core\\prefs.c", "repo_name": "AlexWillisson/metacity-physics", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 2710}
{"docstring": "/**\n * iconv_convert : convert a string, using the current codeset\n * return: a malloc'd string with the converted result\n */\n", "func_signal": "char *\niconv_convert (const char *input)", "code": "{\n#if HAVE_ICONV\n  size_t inputsize = strlen (input) + 1;\n  size_t dummy = 0;\n  size_t length = 0;\n  char *result;\n  char *inptr, *outptr;\n  size_t insize, outsize;\n\n  /* conversion not necessary. save our time. */\n  if (!cd)\n    return strdup (input);\n\n  /* Determine the length we need. */\n  iconv (cd, NULL, NULL, NULL, &dummy);\n  {\n    static char tmpbuf[BUFSIZ];\n    inptr = (char*) input;\n    insize = inputsize;\n    while (insize > 0)\n    {\n      outptr = tmpbuf;\n      outsize = BUFSIZ;\n      if (iconv (cd, &inptr, &insize, &outptr, &outsize) == (size_t) (-1))\n      {\n        /**\n         * if error is EINVAL or EILSEQ, conversion must be stoped,\n         * but if it is E2BIG (not enough space in buffer), we just loop again\n         */\n        if( errno != E2BIG)\n        {\n          perror (\"error iconv\");\n          return NULL;\n        }\n      }\n      length += outptr - tmpbuf;\n    }\n\n    outptr = tmpbuf;\n    outsize = BUFSIZ;\n    if (iconv (cd, NULL, NULL, &outptr, &outsize) == (size_t) (-1))\n    {\n      perror (\"error iconv\");\n      return NULL;\n    }\n    length += outptr - tmpbuf;\n  }\n\n  /* length determined, allocate result space */\n  if ((result = (char*) malloc (length * sizeof (char))) == NULL)\n  {\n    perror (\"error malloc\");\n    return NULL;\n  }\n\n  /* Do the conversion for real. */\n  iconv (cd, NULL, NULL, NULL, &dummy);\n  {\n    inptr = (char*) input;\n    insize = inputsize;\n    outptr = result;\n    outsize = length;\n    while (insize > 0)\n    {\n      if (iconv (cd, &inptr, &insize, &outptr, &outsize) == (size_t) (-1))\n      {\n        if (errno != E2BIG)\n        {\n          perror (\"error iconv\");\n          free (result);\n          return NULL;\n        }\n      }\n    }\n    if (iconv (cd, NULL, NULL, &outptr, &outsize) == (size_t) (-1))\n    {\n      perror (\"error iconv\");\n      free (result);\n      return NULL;\n    }\n\n    if (outsize != 0)\n      abort ();\n  }\n\n  return result;\n#else\n  return strdup (input);\n#endif\n}", "path": "src\\util_iconv.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* free (dealloc) an RB_ENTRY(node) structure - add it onto the front of the list\n** N.B. RB_ENTRY(node) need not have been allocated through rb_alloc()\n*/\n", "func_signal": "static void\nRB_ENTRY(_free)(struct RB_ENTRY(node) *x)", "code": "{\n#ifdef RB_FREE\n \tRB_FREE(ACCESS(x, key));\n#endif /* RB_FREE */\n\tx->up=rbfreep;\n\trbfreep=x;\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Search for a key according to mode (see redblack.h)\n*/\n", "func_signal": "static struct RB_ENTRY(node) *\nRB_ENTRY(_lookup)(int mode, const RB_ENTRY(data_t) *key, struct RB_ENTRY(tree) *rbinfo)", "code": "{\n\tstruct RB_ENTRY(node) *x,*y;\n\tint cmp=0;\n\tint found=0;\n\n\ty=RBNULL; /* points to the parent of x */\n\tx=rbinfo->rb_root;\n\n\tif (mode==RB_LUFIRST)\n\t{\n\t\t/* Keep going left until we hit a NULL */\n\t\twhile(x!=RBNULL)\n\t\t{\n\t\t\ty=x;\n\t\t\tx=x->left;\n\t\t}\n\n\t\treturn(y);\n\t}\n\telse if (mode==RB_LULAST)\n\t{\n\t\t/* Keep going right until we hit a NULL */\n\t\twhile(x!=RBNULL)\n\t\t{\n\t\t\ty=x;\n\t\t\tx=x->right;\n\t\t}\n\n\t\treturn(y);\n\t}\n\n\t/* walk x down the tree */\n\twhile(x!=RBNULL && found==0)\n\t{\n\t\ty=x;\n\t\t/* printf(\"key=%s, RB_GET(x, key)=%s\\n\", key, RB_GET(x, key)); */\n#ifndef RB_CUSTOMIZE\n\t\tcmp=RB_CMP(key, RB_GET(x, key), rbinfo->rb_config);\n#else\n\t\tcmp=RB_CMP(key, RB_GET(x, key));\n#endif /* RB_CUSTOMIZE */\n\n\n\t\tif (cmp<0)\n\t\t\tx=x->left;\n\t\telse if (cmp>0)\n\t\t\tx=x->right;\n\t\telse\n\t\t\tfound=1;\n\t}\n\n\tif (found && (mode==RB_LUEQUAL || mode==RB_LUGTEQ || mode==RB_LULTEQ))\n\t\treturn(x);\n\n\tif (!found && (mode==RB_LUEQUAL || mode==RB_LUNEXT || mode==RB_LUPREV))\n\t\treturn(RBNULL);\n\n\tif (mode==RB_LUGTEQ || (!found && mode==RB_LUGREAT))\n\t{\n\t\tif (cmp>0)\n\t\t\treturn(RB_ENTRY(_successor)(y));\n\t\telse\n\t\t\treturn(y);\n\t}\n\n\tif (mode==RB_LULTEQ || (!found && mode==RB_LULESS))\n\t{\n\t\tif (cmp<0)\n\t\t\treturn(RB_ENTRY(_predecessor)(y));\n\t\telse\n\t\t\treturn(y);\n\t}\n\n\tif (mode==RB_LUNEXT || (found && mode==RB_LUGREAT))\n\t\treturn(RB_ENTRY(_successor)(x));\n\n\tif (mode==RB_LUPREV || (found && mode==RB_LULESS))\n\t\treturn(RB_ENTRY(_predecessor)(x));\n\n\t/* Shouldn't get here */\n\treturn(RBNULL);\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Restore the reb-black properties after a delete */\n", "func_signal": "static void\nRB_ENTRY(_delete_fix)(struct RB_ENTRY(node) **rootp, struct RB_ENTRY(node) *x)", "code": "{\n\tstruct RB_ENTRY(node) *w;\n\n\twhile (x!=*rootp && x->colour==BLACK)\n\t{\n\t\tif (x==x->up->left)\n\t\t{\n\t\t\tw=x->up->right;\n\t\t\tif (w->colour==RED)\n\t\t\t{\n\t\t\t\tw->colour=BLACK;\n\t\t\t\tx->up->colour=RED;\n\t\t\t\trb_left_rotate(rootp, x->up);\n\t\t\t\tw=x->up->right;\n\t\t\t}\n\n\t\t\tif (w->left->colour==BLACK && w->right->colour==BLACK)\n\t\t\t{\n\t\t\t\tw->colour=RED;\n\t\t\t\tx=x->up;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (w->right->colour == BLACK)\n\t\t\t\t{\n\t\t\t\t\tw->left->colour=BLACK;\n\t\t\t\t\tw->colour=RED;\n\t\t\t\t\tRB_ENTRY(_right_rotate)(rootp, w);\n\t\t\t\t\tw=x->up->right;\n\t\t\t\t}\n\n\n\t\t\t\tw->colour=x->up->colour;\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\tw->right->colour = BLACK;\n\t\t\t\tRB_ENTRY(_left_rotate)(rootp, x->up);\n\t\t\t\tx=*rootp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tw=x->up->left;\n\t\t\tif (w->colour==RED)\n\t\t\t{\n\t\t\t\tw->colour=BLACK;\n\t\t\t\tx->up->colour=RED;\n\t\t\t\tRB_ENTRY(_right_rotate)(rootp, x->up);\n\t\t\t\tw=x->up->left;\n\t\t\t}\n\n\t\t\tif (w->right->colour==BLACK && w->left->colour==BLACK)\n\t\t\t{\n\t\t\t\tw->colour=RED;\n\t\t\t\tx=x->up;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (w->left->colour == BLACK)\n\t\t\t\t{\n\t\t\t\t\tw->right->colour=BLACK;\n\t\t\t\t\tw->colour=RED;\n\t\t\t\t\tRB_ENTRY(_left_rotate)(rootp, w);\n\t\t\t\t\tw=x->up->left;\n\t\t\t\t}\n\n\t\t\t\tw->colour=x->up->colour;\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\tw->left->colour = BLACK;\n\t\t\t\tRB_ENTRY(_right_rotate)(rootp, x->up);\n\t\t\t\tx=*rootp;\n\t\t\t}\n\t\t}\n\t}\n\n\tx->colour=BLACK;\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Return a pointer to the smallest key greater than x\n*/\n", "func_signal": "static struct RB_ENTRY(node) *\nRB_ENTRY(_successor)(const struct RB_ENTRY(node) *x)", "code": "{\n\tstruct RB_ENTRY(node) *y;\n\n\tif (x->right!=RBNULL)\n\t{\n\t\t/* If right is not NULL then go right one and\n\t\t** then keep going left until we find a node with\n\t\t** no left pointer.\n\t\t*/\n\t\tfor (y=x->right; y->left!=RBNULL; y=y->left);\n\t}\n\telse\n\t{\n\t\t/* Go up the tree until we get to a node that is on the\n\t\t** left of its parent (or the root) and then return the\n\t\t** parent.\n\t\t*/\n\t\ty=x->up;\n\t\twhile(y!=RBNULL && x==y->right)\n\t\t{\n\t\t\tx=y;\n\t\t\ty=y->up;\n\t\t}\n\t}\n\treturn(y);\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Seperate recursive free() function in order to avoid freeing off\n * the parents child list within the freeing of the first child, as\n * the only entry which is not part of a childs list is the root entry\n */\n", "func_signal": "static void\n_upnp_entry_free (struct upnp_entry_t *entry)", "code": "{\n  struct upnp_entry_t **childs;\n\n  if (!entry)\n    return;\n\n  if (entry->fullpath)\n    free (entry->fullpath);\n  if (entry->title)\n    free (entry->title);\n  if (entry->url)\n    free (entry->url);\n#ifdef HAVE_DLNA\n  if (entry->dlna_profile)\n    entry->dlna_profile = NULL;\n#endif /* HAVE_DLNA */\n\n  for (childs = entry->childs; *childs; childs++)\n    _upnp_entry_free (*childs);\n  free (entry->childs);\n}", "path": "src\\metadata.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Search for and if not found and insert is true, will add a new\n** node in. Returns a pointer to the new node, or the node found\n*/\n", "func_signal": "static struct RB_ENTRY(node) *\nRB_ENTRY(_traverse)(int insert, const RB_ENTRY(data_t) *key, struct RB_ENTRY(tree) *rbinfo)", "code": "{\n\tstruct RB_ENTRY(node) *x,*y,*z;\n\tint cmp;\n\tint found=0;\n\tint cmpmods();\n\n\ty=RBNULL; /* points to the parent of x */\n\tx=rbinfo->rb_root;\n\n\t/* walk x down the tree */\n\twhile(x!=RBNULL && found==0)\n\t{\n\t\ty=x;\n\t\t/* printf(\"key=%s, RB_GET(x, key)=%s\\n\", key, RB_GET(x, key)); */\n#ifndef RB_CUSTOMIZE\n\t\tcmp=RB_CMP(key, RB_GET(x, key), rbinfo->rb_config);\n#else\n\t\tcmp=RB_CMP(key, RB_GET(x, key));\n#endif /* RB_CUSTOMIZE */\n\n\t\tif (cmp<0)\n\t\t\tx=x->left;\n\t\telse if (cmp>0)\n\t\t\tx=x->right;\n\t\telse\n\t\t\tfound=1;\n\t}\n\n\tif (found || !insert)\n\t\treturn(x);\n\n\tif ((z=RB_ENTRY(_alloc)())==NULL)\n\t{\n\t\t/* Whoops, no memory */\n\t\treturn(RBNULL);\n\t}\n\n\tRB_SET(z, key, key);\n\tz->up=y;\n\tif (y==RBNULL)\n\t{\n\t\trbinfo->rb_root=z;\n\t}\n\telse\n\t{\n#ifndef RB_CUSTOMIZE\n\t\tcmp=RB_CMP(RB_GET(z, key), RB_GET(y, key), rbinfo->rb_config);\n#else\n\t\tcmp=RB_CMP(RB_GET(z, key), RB_GET(y, key));\n#endif /* RB_CUSTOMIZE */\n\t\tif (cmp<0)\n\t\t\ty->left=z;\n\t\telse\n\t\t\ty->right=z;\n\t}\n\n\tz->left=RBNULL;\n\tz->right=RBNULL;\n\n\t/* colour this new node red */\n\tz->colour=RED;\n\n\t/* Having added a red node, we must now walk back up the tree balancing\n\t** it, by a series of rotations and changing of colours\n\t*/\n\tx=z;\n\n\t/* While we are not at the top and our parent node is red\n\t** N.B. Since the root node is garanteed black, then we\n\t** are also going to stop if we are the child of the root\n\t*/\n\n\twhile(x != rbinfo->rb_root && (x->up->colour == RED))\n\t{\n\t\t/* if our parent is on the left side of our grandparent */\n\t\tif (x->up == x->up->up->left)\n\t\t{\n\t\t\t/* get the right side of our grandparent (uncle?) */\n\t\t\ty=x->up->up->right;\n\t\t\tif (y->colour == RED)\n\t\t\t{\n\t\t\t\t/* make our parent black */\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\t/* make our uncle black */\n\t\t\t\ty->colour = BLACK;\n\t\t\t\t/* make our grandparent red */\n\t\t\t\tx->up->up->colour = RED;\n\n\t\t\t\t/* now consider our grandparent */\n\t\t\t\tx=x->up->up;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* if we are on the right side of our parent */\n\t\t\t\tif (x == x->up->right)\n\t\t\t\t{\n\t\t\t\t\t/* Move up to our parent */\n\t\t\t\t\tx=x->up;\n\t\t\t\t\tRB_ENTRY(_left_rotate)(&rbinfo->rb_root, x);\n\t\t\t\t}\n\n\t\t\t\t/* make our parent black */\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\t/* make our grandparent red */\n\t\t\t\tx->up->up->colour = RED;\n\t\t\t\t/* right rotate our grandparent */\n\t\t\t\tRB_ENTRY(_right_rotate)(&rbinfo->rb_root, x->up->up);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* everything here is the same as above, but\n\t\t\t** exchanging left for right\n\t\t\t*/\n\n\t\t\ty=x->up->up->left;\n\t\t\tif (y->colour == RED)\n\t\t\t{\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\ty->colour = BLACK;\n\t\t\t\tx->up->up->colour = RED;\n\n\t\t\t\tx=x->up->up;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (x == x->up->left)\n\t\t\t\t{\n\t\t\t\t\tx=x->up;\n\t\t\t\t\tRB_ENTRY(_right_rotate)(&rbinfo->rb_root, x);\n\t\t\t\t}\n\n\t\t\t\tx->up->colour = BLACK;\n\t\t\t\tx->up->up->colour = RED;\n\t\t\t\tRB_ENTRY(_left_rotate)(&rbinfo->rb_root, x->up->up);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the root node black */\n\t(rbinfo->rb_root)->colour = BLACK;\n\n\treturn(z);\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Telnet thread function\n */\n", "func_signal": "static void *\nctrl_telnet_thread (void *a __attribute__ ((unused)))", "code": "{\n  /* fd_set with readable clients */\n  fd_set fd_readable;\n\n  /* Pointer to a client object */\n  ctrl_telnet_client *client;\n\n  int fd_max;\n\n  while (1)\n  {\n    /* Get fds */\n    fd_max = ctrl_telnet_fix_fdset (&fd_readable);\n\n    if (select (fd_max + 1, &fd_readable, NULL, NULL, NULL) == -1)\n    {\n      perror (\"select\");\n      /* FIXME: Close sockets */\n      return NULL;\n    }\n\n    /* Check killer */\n    if (FD_ISSET (ttd.killer[0], &fd_readable))\n    {\n      /* FIXME: TODO: Shut down sockets...  */\n\n      /* Close listener and killer */\n      close (ttd.listener);\n      close (ttd.killer[0]);\n      close (ttd.killer[1]);\n\n      /* Check which fds that had anyhting to say... */\n      client = ttd.clients;\n\n      /* Say goodby to clients */\n      while (client)\n      {\n        ctrl_telnet_client *current = client;\n        ctrl_telnet_client_send (current,\n                                 \"\\nServer is going down, Bye bye\\n\");\n        client = client->next;\n        ctrl_telnet_client_remove (current);\n      }\n\n      pthread_mutex_lock (&functions_lock);\n\n      while (functions)\n      {\n        telnet_function_list *head = functions;\n        functions = functions->next;\n\n        free (head->name);\n        if (head->description)\n          free (head->description);\n\n        free (head);\n      }\n\n      pthread_mutex_unlock (&functions_lock);\n\n      return NULL;\n    }\n\n    /* Check for new connection */\n    if (FD_ISSET (ttd.listener, &fd_readable))\n    {\n      socklen_t sl_addr;\n\n      /* Create client object */\n      client = malloc (sizeof (ctrl_telnet_client));\n\n      if (!client)\n      {\n        perror (\"Failed to create new client\");\n        return NULL;\n      }\n\n      memset (client, '\\0', sizeof (ctrl_telnet_client));\n      sl_addr = sizeof (client->remote_address);\n\n      client->socket = accept (ttd.listener,\n                               (struct sockaddr *) &client->remote_address,\n                               &sl_addr);\n      if (client->socket == -1)\n      {\n        perror (\"accept\");\n        free (client);\n      }\n      else\n      {\n        ctrl_telnet_client_add (client);\n        ctrl_telnet_client_execute_line_safe (client, \"banner\");\n        ctrl_telnet_client_sendf (client, \"For a list of registered commands type \\\"help\\\"\\n\");\n        ctrl_telnet_client_send (client, \"\\n> \");\n      }\n    }\n\n    /* Check which fds that had anyhting to say... */\n    client = ttd.clients;\n\n    /* Run through all clients and check if there's data avalible\n       with FD_ISSET(current->socket) */\n    while (client)\n    {\n      ctrl_telnet_client *current = client;\n      client = client->next;\n\n      if (FD_ISSET (current->socket, &fd_readable))\n      {\n        if (ctrl_telnet_client_recv (current) <= 0)\n        {\n          ctrl_telnet_client_remove (current);\n          continue;\n        }\n\n        if (current->ready)\n        {\n          ctrl_telnet_client_execute (current);\n\n          if (!current->exiting)\n            ctrl_telnet_client_send (current, \"\\n> \");\n          else\n            ctrl_telnet_client_remove (current);\n        }\n      }\n    }\n  }\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Delete the node z, and free up the space\n*/\n", "func_signal": "static void\nRB_ENTRY(_delete)(struct RB_ENTRY(node) **rootp, struct RB_ENTRY(node) *z)", "code": "{\n\tstruct RB_ENTRY(node) *x, *y;\n\n\tif (z->left == RBNULL || z->right == RBNULL)\n\t\ty=z;\n\telse\n\t\ty=RB_ENTRY(_successor)(z);\n\n\tif (y->left != RBNULL)\n\t\tx=y->left;\n\telse\n\t\tx=y->right;\n\n\tx->up = y->up;\n\n\tif (y->up == RBNULL)\n\t{\n\t\t*rootp=x;\n\t}\n\telse\n\t{\n\t\tif (y==y->up->left)\n\t\t\ty->up->left = x;\n\t\telse\n\t\t\ty->up->right = x;\n\t}\n\n\tif (y!=z)\n\t{\n\t\tRB_SET(z, key, RB_GET(y, key));\n\t}\n\n\tif (y->colour == BLACK)\n\t\tRB_ENTRY(_delete_fix)(rootp, x);\n\n\tRB_ENTRY(_free)(y);\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Warning: This WILL edit the input string... use strdup or something\n   if needed, also remember to free() argv as the first array is dynamic */\n/* If *argv != NULL it'll first be free()ed... or realloc,\n   make sure to clear *argv to null on initialization */\n", "func_signal": "static void\nctrl_telnet_tokenize (char *raw, int *argc, char ***argv)", "code": "{\n  int i;\n  int has_backslash = 0;\n  int has_quote = 0;\n  char *pc = raw;\n\n  if (!raw || !argc || !argv)\n  {\n    perror (\"NULL in \" __FILE__ \" at line \" STR (__LINE__));\n    return;\n  }\n\n  /* (1/3) First run is just to count our arguments... */\n  *argc = (raw[0] == '\\0') ? 0 : 1;\n\n  pc = raw;\n  while (*pc)\n  {\n    switch (*pc)\n    {\n    case '\\\\':\n      if (!has_backslash)\n        has_backslash = 2; /* FULHACK */\n      break;\n    case ' ':\n      if (!has_backslash && !has_quote)\n        (*argc)++;\n      break;\n    case '\"':\n      if (!has_backslash)\n        has_quote = !has_quote;\n      \n      break;\n    }\n\n    /* When we get a BS we set it to two, this makes it one,\n       next run it will still be 1, then one after that is zero... FULHACK */\n    if (has_backslash)\n      has_backslash--;\n\n    pc++;\n  }\n\n  /* Create argv */\n  *argv = malloc (sizeof (char **) * ((*argc) + 1));\n\n  /* (2/3) Parse throu one more time, this time filling argv (Pass 2 / 3) */\n  i = 0;\n  pc = raw;\n  has_backslash = 0;\n  has_quote = 0;\n  (*argv)[0] = raw;\n\n  while (*pc)\n  {\n    switch (*pc)\n    {\n    case '\\\\':\n      if (!has_backslash)\n        has_backslash = 2; /* FULHACK */\n      break;\n    case ' ':\n      if (!has_backslash && !has_quote)\n      {\n        *pc = '\\0';\n        (*argv)[++i] = pc+1;\n        pc++;\n        continue;\n      }\n      break;\n    case '\"':\n      if (!has_backslash)\n        has_quote = !has_quote;\n      break;\n    }\n\n    /* When we get a BS we set it to two, this makes it one,\n       next run it will still be 1, then one after that is zero... FULHACK */\n    if (has_backslash)\n      has_backslash--;\n\n    pc++;\n  }\n\n  /* Make last element (argc) point to null... */\n  (*argv)[++i] = NULL;\n\n  /* (3/3) Parse arguments to remove escapings and such */\n  for (i = 0; (*argv)[i]; i++)\n  {\n    /* Set up environment */\n    pc = (*argv)[i];\n    has_backslash = 0;\n    has_quote = 0;\n\n    /* Remove leading and ending quotes, if existing */\n    if (*pc == '\"')\n    {\n      int len = strlen (pc);\n\n      if (len > 0 && pc[len - 1] == '\"')\n        pc[len - 1] = '\\0';\n      memmove (pc, pc + 1, len);\n    }\n\n    /* Remove any special characters */\n    while (*pc)\n    {\n      switch (*pc)\n      {\n      case '\\\\':\n        if (!has_backslash)\n        {\n          has_backslash = 2; /* FULHACK */\n          break;\n        }\n        /* Else: fall through */\n      case ' ':\n      case '\"':\n        if (has_backslash)\n        {\n          pc--;\n          memmove (pc, pc + 1, strlen (pc)); /* FIXME: Not cheap */\n        }\n        break;\n      }\n\n      /* When we get a BS we set it to two, this makes it one,\n         next run it will still be 1, then one after that is zero... */\n      if (has_backslash)\n        has_backslash--;\n      \n      pc++;\n    }\n  }\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/*\n * Destroy all the elements blow us in the tree\n * only useful as part of a complete tree destroy.\n */\n", "func_signal": "static void\nRB_ENTRY(_destroy)(struct RB_ENTRY(node) *x)", "code": "{\n\tif (x!=RBNULL)\n\t{\n\t\tif (x->left!=RBNULL)\n\t\t\tRB_ENTRY(_destroy)(x->left);\n\t\tif (x->right!=RBNULL)\n\t\t\tRB_ENTRY(_destroy)(x->right);\n\t\tRB_ENTRY(_free)(x);\n\t}\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Adds a new client to our list of new ones\n *\n * @note This funtion is only called from a single thread,\n *       as such it won't need to be threadsafe\n * @param client to add\n */\n", "func_signal": "static void\nctrl_telnet_client_add (ctrl_telnet_client *client)", "code": "{\n  client->next = ttd.clients;\n  ttd.clients = client;\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Stops all telnet bound control interfaces\n */\n", "func_signal": "void\nctrl_telnet_stop (void)", "code": "{\n  pthread_mutex_lock (&startstop_lock);\n\n  if (!started)\n  {\n    pthread_mutex_unlock (&startstop_lock);\n    return;\n  }\n\n  /* yes is int, which is bigger then char, so this should be safe */\n  write (ttd.killer[1], &yes, sizeof (char));\n\n  pthread_mutex_unlock (&startstop_lock);\n  pthread_join (ttd.thread, NULL);\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* FIXME: Ulgy non optimised version */\n", "func_signal": "static int\nctrl_telnet_client_execute (ctrl_telnet_client *client)", "code": "{\n  int i = 0;\n\n  /* Check buffer for complete lines and execute them,,, */\n  for (i = 0; i < client->buffer_recv_current; i++)\n  {\n    if (client->buffer_recv[i] == '\\n' || client->buffer_recv[i] == '\\r')\n    {\n      /* Replace newline with null (or \\r) */\n      client->buffer_recv[i] = '\\0';\n\n      /* Send line to execution */\n      ctrl_telnet_client_execute_line_safe (client, client->buffer_recv);\n\n      /* Check if next is either newline or CR, strip that too, if needed */\n      if ((i + 1 < CTRL_CLIENT_RECV_BUFFER_SIZE) &&\n          (client->buffer_recv[i+1]=='\\n' || client->buffer_recv[i+1]=='\\r'))\n        client->buffer_recv[++i] = '\\0';\n\n      /* Remove processed line */\n      memmove (client->buffer_recv, client->buffer_recv + i,\n               client->buffer_recv_current - 1);\n      client->buffer_recv_current -= (i + 1);\n      i = -1;\n    }\n  }\n\n  return 0; /* No syntax error checking yet */\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Removes \"client\" from our list of clients\n *\n * @note This funtion is only called from a single thread,\n *       as such it won't need to be threadsafe\n * @param client to remove\n */\n", "func_signal": "static void\nctrl_telnet_client_remove (ctrl_telnet_client *client)", "code": "{\n  ctrl_telnet_client *tmp;\n\n  /* Start by dealing with our head */\n  if (client == ttd.clients)\n    ttd.clients = client->next;\n  else\n  {\n    for (tmp = ttd.clients; tmp->next; tmp = tmp->next)\n    {\n      if (tmp->next == client)\n      {\n        tmp->next = tmp->next->next;\n        break;\n      }\n    }\n  }\n\n  close (client->socket);\n\n  free (client);\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/*\n * Remove the n'th content (start from 0)\n */\n", "func_signal": "content_list *\ncontent_del(content_list *list, int n)", "code": "{\n  int i;\n\n  if (!list || n >= list->count)\n    return NULL;\n\n  if (n >= list->count)\n    return list;\n\n  if (list->content[n])\n  {\n    free (list->content[n]);\n    for (i = n ; i < list->count - 1 ; i++)\n      list->content[i] = list->content[i+1];\n    list->count--;\n    list->content[list->count] = NULL;\n  }\n\n  return list;\n}", "path": "src\\content.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/*\n** Rotate our tree thus:-\n**\n**             X        rb_left_rotate(X)--->            Y\n**           /   \\                                     /   \\\n**          A     Y     <---rb_right_rotate(Y)        X     C\n**              /   \\                               /   \\\n**             B     C                             A     B\n**\n** N.B. This does not change the ordering.\n**\n** We assume that neither X or Y is NULL\n*/\n", "func_signal": "static void\nRB_ENTRY(_left_rotate)(struct RB_ENTRY(node) **rootp, struct RB_ENTRY(node) *x)", "code": "{\n\tstruct RB_ENTRY(node) *y;\n\n\tassert(x!=RBNULL);\n\tassert(x->right!=RBNULL);\n\n\ty=x->right; /* set Y */\n\n\t/* Turn Y's left subtree into X's right subtree (move B)*/\n\tx->right = y->left;\n\n\t/* If B is not null, set it's parent to be X */\n\tif (y->left != RBNULL)\n\t\ty->left->up = x;\n\n\t/* Set Y's parent to be what X's parent was */\n\ty->up = x->up;\n\n\t/* if X was the root */\n\tif (x->up == RBNULL)\n\t{\n\t\t*rootp=y;\n\t}\n\telse\n\t{\n\t\t/* Set X's parent's left or right pointer to be Y */\n\t\tif (x == x->up->left)\n\t\t{\n\t\t\tx->up->left=y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx->up->right=y;\n\t\t}\n\t}\n\n\t/* Put X on Y's left */\n\ty->left=x;\n\n\t/* Set X's parent to be Y */\n\tx->up = y;\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Return a pointer to the largest key smaller than x\n*/\n", "func_signal": "static struct RB_ENTRY(node) *\nRB_ENTRY(_predecessor)(const struct RB_ENTRY(node) *x)", "code": "{\n\tstruct RB_ENTRY(node) *y;\n\n\tif (x->left!=RBNULL)\n\t{\n\t\t/* If left is not NULL then go left one and\n\t\t** then keep going right until we find a node with\n\t\t** no right pointer.\n\t\t*/\n\t\tfor (y=x->left; y->right!=RBNULL; y=y->right);\n\t}\n\telse\n\t{\n\t\t/* Go up the tree until we get to a node that is on the\n\t\t** right of its parent (or the root) and then return the\n\t\t** parent.\n\t\t*/\n\t\ty=x->up;\n\t\twhile(y!=RBNULL && x==y->left)\n\t\t{\n\t\t\tx=y;\n\t\t\ty=y->up;\n\t\t}\n\t}\n\treturn(y);\n}", "path": "src\\redblack.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Clears readable fd_set and adds every client to it,\n *        returns max fd found\n *\n * @param readable fd_set to update\n * @return Biggest fd\n */\n", "func_signal": "static int\nctrl_telnet_fix_fdset (fd_set *readable)", "code": "{\n  int maxfd;\n  ctrl_telnet_client *client;\n\n  maxfd = MAX (ttd.killer[0], ttd.listener);\n\n  FD_ZERO (readable);\n  FD_SET (ttd.listener, readable);\n  FD_SET (ttd.killer[0], readable);\n\n  client = ttd.clients;\n\n  while (client)\n  {\n    if (client->socket > maxfd)\n      maxfd = client->socket;\n\n    FD_SET (client->socket, readable);\n\n    client = client->next;\n  }\n\n  return maxfd;\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/**\n * @brief Starts a Telnet bound control interface\n *\n * @return 0 on success, -1 on error\n */\n", "func_signal": "int\nctrl_telnet_start (int port)", "code": "{\n  /* Start by making us threadsafe... */\n  pthread_mutex_lock (&startstop_lock);\n\n  /* Create listener socket */\n  ttd.listener = socket (PF_INET, SOCK_STREAM, 0);\n  if (ttd.listener == -1)\n  {\n    perror (\"socket\");\n    pthread_mutex_unlock (&startstop_lock);\n    return -1;\n  }\n\n  /* Clears us from \"address already in use\" errors */\n  if (setsockopt (ttd.listener, SOL_SOCKET, SO_REUSEADDR,\n                  &yes, sizeof (int)) == -1)\n    perror (\"setsockopt\");\n\n  ttd.local_address.sin_family = AF_INET;\n  ttd.local_address.sin_addr.s_addr = INADDR_ANY;\n  ttd.local_address.sin_port = htons (port);\n  memset (&ttd.local_address.sin_zero, '\\0',\n          sizeof (ttd.local_address.sin_zero));\n\n  if (bind (ttd.listener, (struct sockaddr *) &ttd.local_address,\n            sizeof (ttd.local_address)) == -1)\n  {\n    perror (\"bind\");\n    pthread_mutex_unlock (&startstop_lock);\n    return -1;\n  }\n\n  if (listen (ttd.listener, CTRL_TELNET_BACKLOG) == -1)\n  {\n    perror (\"listen\");\n    pthread_mutex_unlock (&startstop_lock);\n    return -1;\n  }\n\n  print_log (ULOG_NORMAL, \"Listening on telnet port %u\\n\", port);\n\n  /* Create killer pipes */\n  if (pipe (ttd.killer))\n  {\n    perror (\"Failed to create killer pipe\");\n    pthread_mutex_unlock (&startstop_lock);\n    return -1; /* FIXME. Kill all sockets... not critical,, but still */\n  }\n\n  if (pthread_create (&ttd.thread, NULL, ctrl_telnet_thread, NULL))\n  {\n    /* FIXME: Killall sockets... */\n    perror (\"Failed to create thread\");\n    pthread_mutex_unlock (&startstop_lock);\n    return -1;\n  }\n\n  started = 1;\n  ctrl_telnet_register_internals ();\n  pthread_mutex_unlock (&startstop_lock);\n\n  return 0;\n}", "path": "src\\ctrl_telnet.c", "repo_name": "jasonmadigan/uShare", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 166}
{"docstring": "/* Linear Filtering Kernel\n * C code */\n", "func_signal": "int camLinearFilter(CamImage *source, CamImage *dest, camLinearFilterKernelPtr params)", "code": "{\n#define CAM_ALIGN 0\n    int i,j,x,y;\n    int width,height;\n    int left,top;\n    int result;\n    CAM_PIXEL *srcptr,*tmpptr,*cpsrcptr;\n    CAM_PIXEL_DST *dstptr,*cpdstptr;\n    unsigned CAM_PIXEL *linesPtr[CAM_LF_NEIGHB_Y];\n    CAM_PIXEL linesBuffer[CAM_LF_NEIGHB_Y][((CAM_MAX_SCANLINE+CAM_LF_NEIGHB_X-1+CAM_ALIGN)&~15)+16];\n    int valmax;\n#ifndef CAM_SOBEL\n    int xp,yp;\n    int value;\n    int nbk;\n    int xpk[CAM_LF_NEIGHB_X*CAM_LF_NEIGHB_Y];\n    int ypk[CAM_LF_NEIGHB_X*CAM_LF_NEIGHB_Y];\n    int valk[CAM_LF_NEIGHB_X*CAM_LF_NEIGHB_Y];\n#else\n    int results[3];\n#endif\n    DECLARE_MASK_MANAGEMENT;\n\n    CamInternalROIPolicyStruct iROI;\n    int acc=0;\n    \n    // ROI (Region Of Interest) management\n    CAM_CHECK(camLinearFilter,camInternalROIPolicy(source, dest, &iROI, 1));\n    CAM_CHECK_ARGS(camLinearFilter,iROI.nChannels==1);\n    CAM_CHECK_ARGS(camLinearFilter,(source->depth&CAM_DEPTH_MASK)<=(sizeof(CAM_PIXEL)*8));\n    CAM_CHECK_ARGS(camLinearFilter,(source->depth&CAM_DEPTH_MASK)>=8);\n    CAM_CHECK_ARGS(camLinearFilter,(dest->depth&CAM_DEPTH_MASK)<=(sizeof(CAM_PIXEL_DST)*8));\n    CAM_CHECK_ARGS(camLinearFilter,(dest->depth&CAM_DEPTH_MASK)>=8);\n\n    // Saturation management\n    valmax=(1<<(dest->depth&CAM_DEPTH_MASK))-1;\n\n    width=iROI.srcroi.width;\n    height=iROI.srcroi.height;\n    if (source->roi) {\n        left=iROI.srcroi.xOffset;\n        top=iROI.srcroi.yOffset;\n        i=left; if (i>CAM_LF_NEIGHB_X/2) i=CAM_LF_NEIGHB_X/2;\n        j=top; if (j>CAM_LF_NEIGHB_Y/2) j=CAM_LF_NEIGHB_Y/2;\n        srcptr=(CAM_PIXEL*)(source->imageData+iROI.srcchoffset+(top-j)*source->widthStep)+(left-i);\n    } else {\n        srcptr=(CAM_PIXEL*)(source->imageData+iROI.srcchoffset);\n        left=0;\n        top=0;\n    }\n    dstptr=(CAM_PIXEL_DST*)iROI.dstptr;\n    CAM_CHECK_ARGS(camLinearFilter,(width>CAM_LF_NEIGHB_X/2));\n    CAM_CHECK_ARGS(camLinearFilter,(height>CAM_LF_NEIGHB_Y/2));    \n    \n    // Mask management\n    INIT_MASK_MANAGEMENT;\n\n    // Initialize algorithm\n    for (i=0;i<CAM_LF_NEIGHB_Y;i++) {\n        linesPtr[i]=linesBuffer[i];\n    }\n    if (dest->depth&CAM_DEPTH_SIGN) {\n        valmax>>=1;\n    }\n    \n    // Initialize compressed kernel\n#ifndef CAM_SOBEL\n    nbk=0;\n    for (yp=0;yp<CAM_LF_NEIGHB_Y;yp++) {\n        for (xp=0;xp<CAM_LF_NEIGHB_X;xp++) {\n            value=params->kernel[yp][xp];\n            if (value) {\n                valk[nbk]=value;\n                xpk[nbk]=xp;\n                ypk[nbk]=yp;\n                nbk++;\n            }\n        }\n    }\n#endif\n    \n    // Initialize neighbourhood\n    \n    // Fill the top lines\n    for (y=0;y+top<CAM_LF_NEIGHB_Y/2;y++) {\n        // Out of frame : fill with border color\n        if (source->borderMode[CAM_SIDE_TOP_INDEX]==CAM_BORDER_REPLICATE) {\n            cpsrcptr=srcptr;\n            for (x=0;x<CAM_LF_NEIGHB_X/2;x++) {\n                linesPtr[y][x+CAM_ALIGN]=*srcptr;\n            }\n            for (;x<width+CAM_LF_NEIGHB_X/2;x++) {\n                linesPtr[y][x+CAM_ALIGN]=*srcptr;\n                srcptr+=iROI.srcinc;\n            }\n            for (;x<width+CAM_LF_NEIGHB_X-1;x++) {\n                linesPtr[y][x+CAM_ALIGN]=*(srcptr-iROI.srcinc);\n            }\n            srcptr=cpsrcptr;\n        } else {\n            for (x=0;x<width+CAM_LF_NEIGHB_X-1;x++) {\n                linesPtr[y][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_TOP_INDEX];\n            }\n        }\n    }\n    \n    // Fill the next lines with image pixels\n    for (;y<CAM_LF_NEIGHB_Y-1;y++) {\n        cpsrcptr=srcptr;\n        for (x=0;x<CAM_LF_NEIGHB_X/2;x++) {\n            if (left+x-CAM_LF_NEIGHB_X/2<0) {\n                // Out of frame : fill with border color\n                if (source->borderMode[CAM_SIDE_LEFT_INDEX]==CAM_BORDER_REPLICATE) {\n                    linesPtr[y][x+CAM_ALIGN]=*srcptr;\n                } else {\n                    linesPtr[y][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_LEFT_INDEX];\n                }\n            } else {\n                // Get border pixels from the source frame\n                linesPtr[y][x+CAM_ALIGN]=*srcptr;\n                srcptr+=iROI.srcinc;\n            }\n        }\n        for (;x<width+CAM_LF_NEIGHB_X/2;x++) {\n            linesPtr[y][x+CAM_ALIGN]=*srcptr;\n            srcptr+=iROI.srcinc;\n        }\n        for (;x<width+CAM_LF_NEIGHB_X-1;x++) {\n            if (left+x-CAM_LF_NEIGHB_X/2<source->width) {\n                // Get border pixels from the source frame\n                linesPtr[y][x+CAM_ALIGN]=*srcptr;\n                srcptr+=iROI.srcinc;\n            } else {\n                // Out of frame : fill with border color\n                if (source->borderMode[CAM_SIDE_RIGHT_INDEX]==CAM_BORDER_REPLICATE) {\n                    linesPtr[y][x+CAM_ALIGN]=*(srcptr-iROI.srcinc);\n                } else {\n                    linesPtr[y][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_RIGHT_INDEX];\n                }\n            }\n        }\n        srcptr=(CAM_PIXEL*)(((char*)cpsrcptr)+source->widthStep);\n    }\n    \n    // Now process the whole image\n    // This is the main loop\n    for (y=0;y<height;y++) {\n        cpsrcptr=srcptr;\n        cpdstptr=dstptr;\n        \n        // Start a new line\n        // Have we reached the bottom of the frame ?\n        if (top+y+CAM_LF_NEIGHB_Y/2>=source->height) {\n            if (source->borderMode[CAM_SIDE_BOTTOM_INDEX]==CAM_BORDER_REPLICATE) {\n                // Go up one line (in order to stay on the last line)\n                cpsrcptr=(CAM_PIXEL*)(((char*)cpsrcptr)-source->widthStep);\n                srcptr=cpsrcptr;\n                for (x=0;x<CAM_LF_NEIGHB_X/2;x++) {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*srcptr;\n                }\n                for (;x<width+CAM_LF_NEIGHB_X/2;x++) {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*srcptr;\n                    srcptr+=iROI.srcinc;\n                }\n                for (;x<width+CAM_LF_NEIGHB_X-1;x++) {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*(srcptr-iROI.srcinc);\n                }\n            } else {\n                for (x=0;x<width+CAM_LF_NEIGHB_X-1;x++) {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_BOTTOM_INDEX];\n                }\n            }\n        } else {\n            for (x=0;x<CAM_LF_NEIGHB_X/2;x++) {\n                if (left+x-CAM_LF_NEIGHB_X/2<0) {\n                    // Out of frame : fill with border color\n                    if (source->borderMode[CAM_SIDE_LEFT_INDEX]==CAM_BORDER_REPLICATE) {\n                        linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*srcptr;\n                    } else {\n                        linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_LEFT_INDEX];\n                    }\n                } else {\n                    // Get border pixels from the source frame\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*srcptr;\n                    srcptr+=iROI.srcinc;\n                }\n            }\n\n            // Fast transfer with memcpy\n            if (iROI.srcinc==1) {\n                memcpy(&linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN],srcptr,((source->width-left+CAM_LF_NEIGHB_X/2-x)<<(sizeof(CAM_PIXEL)-1)));\n                x=source->width-left+CAM_LF_NEIGHB_X/2;\n            } else {\n                for (;x<source->width-left+CAM_LF_NEIGHB_X/2;x++) {\n                    // Get a pixel from the source frame\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*srcptr;\n                    srcptr+=iROI.srcinc;\n                }\n            }\n            for (;x<width+CAM_LF_NEIGHB_X-1;x++) {\n                // Out of frame : fill with border color\n                if (source->borderMode[CAM_SIDE_RIGHT_INDEX]==CAM_BORDER_REPLICATE) {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=*(srcptr+(source->width-1)*iROI.srcinc);\n                } else {\n                    linesPtr[CAM_LF_NEIGHB_Y-1][x+CAM_ALIGN]=source->borderConst[CAM_SIDE_RIGHT_INDEX];\n                }\n            }\n        }\n       \n\tif (source->depth & CAM_DEPTH_SIGN) {\t\n\t    BEGIN_MASK_MANAGEMENT(dstptr=cpdstptr+startx*iROI.dstinc;)\n\n#ifdef CAM_SOBEL\n\t\tif (vertical_edges) {\n\t\t    results[0]=(int)((signed CAM_PIXEL **)linesPtr)[0][startx+CAM_ALIGN]+(((int)((signed CAM_PIXEL **)linesPtr)[1][startx+CAM_ALIGN])<<1)+(int)((signed CAM_PIXEL **)linesPtr)[2][startx+CAM_ALIGN];\n\t\t    results[1]=(int)((signed CAM_PIXEL **)linesPtr)[0][startx+1+CAM_ALIGN]+(((int)((signed CAM_PIXEL **)linesPtr)[1][startx+1+CAM_ALIGN])<<1)+(int)((signed CAM_PIXEL **)linesPtr)[2][startx+1+CAM_ALIGN];\n\t\t} else {\n\t\t    results[0]=-(int)((signed CAM_PIXEL **)linesPtr)[0][startx+CAM_ALIGN]+(int)((signed CAM_PIXEL **)linesPtr)[2][startx+CAM_ALIGN];\n\t\t    results[1]=-(int)((signed CAM_PIXEL **)linesPtr)[0][startx+1+CAM_ALIGN]+(int)((signed CAM_PIXEL **)linesPtr)[2][startx+1+CAM_ALIGN];\n\t\t}\n#endif\n\n\t    // Process all the pixels in the line\n\t    for (x=startx+CAM_LF_NEIGHB_X-1;x<endx+CAM_LF_NEIGHB_X-1;x++) {   \n\n#ifdef CAM_SOBEL\n\t\tif (vertical_edges) {\n\t\t    results[2]=(int)((signed CAM_PIXEL **)linesPtr)[0][x+CAM_ALIGN]+(((int)((signed CAM_PIXEL **)linesPtr)[1][x+CAM_ALIGN])<<1)+(int)((signed CAM_PIXEL **)linesPtr)[2][x+CAM_ALIGN];\n\t\t    result=results[2]-results[0];\n\t\t} else {\n\t\t    results[2]=-(int)((signed CAM_PIXEL **)linesPtr)[0][x+CAM_ALIGN]+(int)((signed CAM_PIXEL **)linesPtr)[2][x+CAM_ALIGN];\n\t\t    result=results[0]+(results[1]<<1)+results[2];\n\t\t}\n\t\tresults[0]=results[1];\n\t\tresults[1]=results[2];\n#else\n\t\t// Now, let's compute the result of the linear filter\n\t\tresult=0;\n\t\ti=x-CAM_LF_NEIGHB_X+1+CAM_ALIGN;\n\t\tfor (j=0;j<nbk;j++) {\n\t\t    result+=((signed CAM_PIXEL **)linesPtr)[ypk[j]][i+xpk[j]]*valk[j];\n\t\t}\n\t\tif (params->coeff1!=1) result*=params->coeff1;\n\t\tif (params->coeff2!=0) result>>=params->coeff2;\n#endif\n\n#ifdef CAM_LF_ABS\n\t\tif (result<0) result=-result;\n\t\t// Saturation :\n\t\tif (result>valmax) result=valmax;\n#else\n\t\tif (dest->depth&CAM_DEPTH_SIGN) {\n\t\t    // Saturation :\n\t\t    if (result<-valmax) result=-valmax; \n\t\t    else if (result>valmax) result=valmax;\n\t\t} else {\n\t\t    // Saturation :\n\t\t    if (result<0) result=0;\n\t\t    else if (result>valmax) result=valmax;\n\t\t}\n#endif\n\n\t\t// Store the result in destination image\n\t\t*dstptr=(CAM_PIXEL_DST)result;\n\t\tdstptr+=iROI.dstinc;\n\t\tacc+=result; // Accumulate\n\t    }\n\n\t    END_MASK_MANAGEMENT;\n\t} else {\n\t    BEGIN_MASK_MANAGEMENT(dstptr=cpdstptr+startx*iROI.dstinc;)\n\n#ifdef CAM_SOBEL\n\t\tif (vertical_edges) {\n\t\t    results[0]=(int)linesPtr[0][startx+CAM_ALIGN]+(((int)linesPtr[1][startx+CAM_ALIGN])<<1)+(int)linesPtr[2][startx+CAM_ALIGN];\n\t\t    results[1]=(int)linesPtr[0][startx+1+CAM_ALIGN]+(((int)linesPtr[1][startx+1+CAM_ALIGN])<<1)+(int)linesPtr[2][startx+1+CAM_ALIGN];\n\t\t} else {\n\t\t    results[0]=-(int)linesPtr[0][startx+CAM_ALIGN]+(int)linesPtr[2][startx+CAM_ALIGN];\n\t\t    results[1]=-(int)linesPtr[0][startx+1+CAM_ALIGN]+(int)linesPtr[2][startx+1+CAM_ALIGN];\n\t\t}\n#endif\n\n\t    // Process all the pixels in the line\n\t    for (x=startx+CAM_LF_NEIGHB_X-1;x<endx+CAM_LF_NEIGHB_X-1;x++) {   \n\n#ifdef CAM_SOBEL\n\t\tif (vertical_edges) {\n\t\t    results[2]=(int)linesPtr[0][x+CAM_ALIGN]+(((int)linesPtr[1][x+CAM_ALIGN])<<1)+(int)linesPtr[2][x+CAM_ALIGN];\n\t\t    result=results[2]-results[0];\n\t\t} else {\n\t\t    results[2]=-(int)linesPtr[0][x+CAM_ALIGN]+(int)linesPtr[2][x+CAM_ALIGN];\n\t\t    result=results[0]+(results[1]<<1)+results[2];\n\t\t}\n\t\tresults[0]=results[1];\n\t\tresults[1]=results[2];\n#else\n\t\t// Now, let's compute the result of the linear filter\n\t\tresult=0;\n\t\ti=x-CAM_LF_NEIGHB_X+1+CAM_ALIGN;\n\t\t/* Original version : full scan of the kernel\n\t\t   for (yp=0;yp<CAM_LF_NEIGHB_Y;yp++) {\n\t\t\tfor (xp=0;xp<CAM_LF_NEIGHB_X;xp++) {\n\t\t\t    value=linesPtr[yp][i+xp];\n\t\t\t    result+=value*params->kernel[yp][xp];\n\t\t\t}\n\t\t   } */\n\t\tfor (j=0;j<nbk;j++) {\n\t\t    result+=linesPtr[ypk[j]][i+xpk[j]]*valk[j];\n\t\t}\n\t\tif (params->coeff1!=1) result*=params->coeff1;\n\t\tif (params->coeff2!=0) result>>=params->coeff2;\n#endif\n\n#ifdef CAM_LF_ABS\n\t\tif (result<0) result=-result;\n\t\t// Saturation :\n\t\tif (result>valmax) result=valmax;\n#else\n\t\tif (dest->depth&CAM_DEPTH_SIGN) {\n\t\t    // Saturation :\n\t\t    if (result<-valmax) result=-valmax; \n\t\t    else if (result>valmax) result=valmax;\n\t\t} else {\n\t\t    // Saturation :\n\t\t    if (result<0) result=0;\n\t\t    else if (result>valmax) result=valmax;\n\t\t}\n#endif\n\n\t\t// Store the result in destination image\n\t\t*dstptr=(CAM_PIXEL_DST)result;\n\t\tdstptr+=iROI.dstinc;\n\t\tacc+=result; // Accumulate\n\t    }\n\n\t    END_MASK_MANAGEMENT;\n\t}\n\n        // Go to next line\n        srcptr=(CAM_PIXEL*)(((char*)cpsrcptr)+source->widthStep);\n        dstptr=(CAM_PIXEL_DST*)(((char*)cpdstptr)+dest->widthStep);\n        \n        // Reset neighborhood line pointers\n        tmpptr=linesPtr[0];\n        for (i=0;i<CAM_LF_NEIGHB_Y-1;i++) {\n            linesPtr[i]=linesPtr[i+1];\n        }\n        linesPtr[CAM_LF_NEIGHB_Y-1]=tmpptr;\n    }\n    \n    camInternalROIPolicyExit(&iROI);\n    return acc;\n}", "path": "src\\cam_linear_filtering_code.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Watershed segmentation example\n", "func_signal": "void example_watershed()", "code": "{\n    CamImage source,watershed;\n    CamTableOfBasins tob;\n    int i,j,c;\n    char filename[4][30]={\"lsun\",\"lsun_32x64e20-bord\",\"lsun_48x80e20\",\"lsun_56x88e20\"};\n    char s[256];\n\n    for (c=0;c<4;c++) {\n        sprintf(s,\"resources/%s.pgm\",filename[c]);\n        camLoadPGM(&source,s);\n        camAllocateImage(&watershed,source.width,source.height,CAM_DEPTH_16S);\n        camHierarchicalWatershed(&source,&watershed,&tob);\n\n        for (i=0;i<tob.nbBasins;i++) {\n            if (tob.tab[i].dynamics<50){\n                tob.tab[i].surface=0;\n            }\n        }\n        for (i=0;i<tob.nbBasins;i++) {\n            if ((tob.tab[i].surface!=0)||(tob.tab[i].dynamics==CAM_NOT_COMPUTED)) {\n                printf(\"\\nBasin #%d : Dynamics = %d, Minimum = %d, Surface = %d, (x,y)=(%d,%d)\\n\",i,tob.tab[i].dynamics,tob.tab[i].minimum,tob.tab[i].accsurface,tob.tab[i].x,tob.tab[i].y);\n                j=i;\n                while (tob.tab[j].dynamics!=CAM_NOT_COMPUTED) {\n                    printf(\"->%d\",tob.tab[j].flooded);\n                    j=tob.tab[j].flooded;\n                }\n            }\n        }\n\n        camHierarchicalWatershedRegions(&watershed,&tob);\n        sprintf(s,\"output/watershed_regions_%s.pgm\",filename[c]);\n        camSavePGM(&watershed,s);\n        \n        camFreeTableOfBasins(&tob);\n        camDeallocateImage(&source);\n        camDeallocateImage(&watershed);\n    }\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Contribution by Winfried Gerhke (Philips Hamburg)\n", "func_signal": "int camSaveBMP(CamImage *image, char *filename)", "code": "{\n    long  width,height;\n    int   h,w,r,g,b;\n    FILE *outfile;\n    char buf1[64];\n      \n    CAM_CHECK_ARGS2(camSaveBMP,image->imageData!=NULL,\"image is not allocated\");\n    CAM_CHECK_ARGS(camSaveBMP,image->dataOrder==CAM_DATA_ORDER_PIXEL);\n    \n    strcpy(buf1, filename);\n    outfile = fopen(buf1, \"wb\");\n    if (outfile == NULL) \n    {\n\tprintf(\"Can't open output file.\\n\");\n\texit(0);\n    }\n    \n    width  = image->width;\n    height = image->height;\n    \n    fputc('B',outfile);\n    fputc('M',outfile);\n    put32(54+width*height*3, outfile);\n    put32(0L, outfile);\n    put32(54, outfile);\n    \n    put32(40L, outfile);\n    put32(width, outfile);\n    put32(height, outfile);\n    put16(1, outfile);\n    put16(24, outfile);\n    put32(0, outfile);\n    put32(width*height*3, outfile);\n    put32(10000, outfile);\n    put32(10000, outfile);\n    put32(0, outfile);\n    put32(0, outfile);\n    \n    if ((image->depth&CAM_DEPTH_MASK)==1) {\n\tfor (h=height-1; h>=0; h--)\n\t{\n\t    for (w=0; w<width; w++)\n\t    {\n\t\tr = b = g = (((*((unsigned char*)image->imageData+(w>>3)+h*image->widthStep))<<(w&0x07))&0x80)?255:0;\n\t\t\n\t\tputc(b,outfile);   /* B */\n\t\tputc(g,outfile);   /* G */\n\t\tputc(r,outfile);   /* R */\n\t    }\n\t    \n\t    switch ((width*3) % 4)\n\t    {\n\t    case 1:  putc(0,outfile);\n\t    case 2:  putc(0,outfile);\n\t    case 3:  putc(0,outfile);\n\t    }\n\t}\n    } else if ((image->depth&CAM_DEPTH_MASK)==8) {\n\tfor (h=height-1; h>=0; h--)\n\t{\n            if (image->nChannels>=3) {\n                if ((image->channelSeq[0]=='R')&&(image->channelSeq[1]=='G')&&(image->channelSeq[2]=='B')) {\n\t\t    for (w=0; w<width; w++)\n                    {\n                        r = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep);\n                        g = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+1);\n                        b = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+2);\n\n                        putc(b,outfile);   /* B */\n                        putc(g,outfile);   /* G */\n                        putc(r,outfile);   /* R */\n                    }\n                } else if ((image->channelSeq[0]=='G')&&(image->channelSeq[1]=='R')&&(image->channelSeq[2]=='B')) {\n\t\t    for (w=0; w<width; w++)\n                    {\n                        g = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep);\n                        r = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+1);\n                        b = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+2);\n\n                        putc(b,outfile);   /* B */\n                        putc(g,outfile);   /* G */\n                        putc(r,outfile);   /* R */\n                    }\n                } else { /* In all other cases, including YUV, records in BGR */\n                    for (w=0; w<width; w++)\n                    {\n                        b = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep);\n                        g = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+1);\n                        r = (int)*((unsigned char*)image->imageData+w*image->nChannels+h*image->widthStep+2);\n\n                        putc(b,outfile);   /* B */\n                        putc(g,outfile);   /* G */\n                        putc(r,outfile);   /* R */\n                    }\n                }\n            } else if (image->nChannels==1) {\n                for (w=0; w<width; w++)\n                {\n                    r = b = g = (int)*((unsigned char*)image->imageData+w+h*image->widthStep);\n                    \n                    putc(b,outfile);   /* B */\n                    putc(g,outfile);   /* G */\n                    putc(r,outfile);   /* R */\n                }\n            }\n\n\t    switch ((width*3) % 4)\n\t    {\n\t    case 1:  putc(0,outfile);\n\t    case 2:  putc(0,outfile);\n\t    case 3:  putc(0,outfile);\n\t    }\n\t}\n    } else if ((image->depth&CAM_DEPTH_MASK)==8) {\n\tcamError(\"camSaveBMP\",\"Can't save 16-bit deep BMP images\");\n    }\n    \n    fclose (outfile);\n    return 1;\n}", "path": "src\\cam_io.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// RLE color labelling example\n", "func_signal": "void example_color_labeling()", "code": "{\n    CamImage source,YUV;\n    CamRLEImage encoded;\n    CamBlobs results;\n    CamTable clusters;\n    int i;\n    const int limits[3*6]={\n    //  Ymin Ymax Umin Umax Vmin Vmax\n        0,   60,  0,   255, 0,   255, // Black\n        230, 255, 0,   255, 0,   255, // White\n        0,   255, 0,   255, 140, 255  // Red\n    };\n    int color[3]={CAM_RGB(0,0,0),CAM_RGB(255,255,255),CAM_RGB(255,0,0)};\n\n    printf(\"\\nColor Image Labeling example : \\n\");    \n\n    camLoadBMP(&source,\"resources/alfa156.bmp\");\n    camAllocateYUVImage(&YUV,source.width,source.height);\n    camRGB2YUV(&source,&YUV);\n\n    // Label the image\n    camRLEAllocate(&encoded,10000);\n    clusters.size=3*6;\n    for (i=0;i<3*6;i++) clusters.t[i]=limits[i];\n    camRLEEncodeColor(&YUV,&encoded,&clusters);\n    printf(\"Number of runs : %d\\n\",encoded.nbRuns);\n    camRLELabeling(&encoded,&results);\n\n    // Print the results \n    for (i=0;i<results.nbBlobs;i++) {\n\tprintf(\"Blob #%2d : Val=%d (%3d,%3d,%3d,%3d) Surface=%d\\n\",\n\t    i,results.blobInfo[i].value,\n            results.blobInfo[i].left, results.blobInfo[i].top,\n\t    results.blobInfo[i].width, results.blobInfo[i].height,\n\t    results.blobInfo[i].surface);\n        camDrawRectangle(&source, results.blobInfo[i].left, results.blobInfo[i].top,\n            results.blobInfo[i].left+results.blobInfo[i].width-1,\n            results.blobInfo[i].top+results.blobInfo[i].height-1,\n            color[results.blobInfo[i].value-1]);\n    }\n    camSaveBMP(&source,\"output/alfa156_color_labeling.bmp\");\n\n    camRLEDeallocate(&encoded);\n    camDeallocateImage(&source);\n    camDeallocateImage(&YUV);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Morphomaths example\n", "func_signal": "void example_morpho()", "code": "{\n    CamImage source,dest;\n    CamMorphoMathsKernel mm_params;\n    int x,y;\n    int t1,t2;\n\n    // Load picture chess.pgm\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    camAllocateImage(&dest,source.width,source.height,source.depth);\n    \n    for (x=0;x<5;x++) {\n\tfor (y=0;y<5;y++) {\n\t    mm_params.dilationStructElt[x][y]=CircleStructElt[x][y];\n\t    mm_params.erosionStructElt[x][y]=CircleStructElt[x][y];;\n\t}\n    }\n    mm_params.operation=CAM_MM_SUBSTRACTION;\n    mm_params.source1=CAM_MM_DILATED;\n    mm_params.source2=CAM_MM_ERODED;\n    t1=camGetTimeMs();\n    camMorphoMaths(&source,&dest,&mm_params);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle outplace morphological gradient = %d ms\\n\",(t2-t1));\n\n    camSavePGM(&dest,\"output/chess_gradient.pgm\");\n\n    for (x=0;x<5;x++) {\n\tfor (y=0;y<5;y++) {\n\t    mm_params.dilationStructElt[x][y]=CircleStructElt[x][y];\n\t    mm_params.erosionStructElt[x][y]=CircleStructElt[x][y];;\n\t}\n    }\n    mm_params.operation=CAM_MM_SUBSTRACTION;\n    mm_params.source1=CAM_MM_DILATED;\n    mm_params.source2=CAM_MM_ERODED;\n    t1=camGetTimeMs();\n    camMorphoMaths(&source,&source,&mm_params);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle inplace morphological gradient  = %d ms\\n\",(t2-t1));\n\n    camDeallocateImage(&source);\n\n    // Reload picture chess.pgm\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    \n    t1=camGetTimeMs();\n    camDilate5x5(&source,&dest,&mm_params);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle outplace dilation               = %d ms\\n\",(t2-t1));\n    \n    t1=camGetTimeMs();\n    camDilate5x5(&source,&source,&mm_params);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle inplace dilation                = %d ms\\n\",(t2-t1));\n    \n    camDeallocateImage(&source);\n\n    // Reload picture chess.pgm\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    \n    t1=camGetTimeMs();\n    camDilateCircle5(&source,&dest);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle outplace dilation               = %d ms\\n\",(t2-t1));\n    \n    t1=camGetTimeMs();\n    camDilateCircle5(&source,&source);\n    t2=camGetTimeMs();\n    printf(\"5x5 Circle inplace dilation                = %d ms\\n\",(t2-t1));\n\n    camSavePGM(&source,\"output/chess_dilate_circle5.pgm\");\n    \n    camDeallocateImage(&source);\n\n    // Reload picture chess.pgm\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    \n    for (y=0;y<7;y++) {\n        for (x=0;x<7;x++) {\n            mm_params.dilationStructElt[y][x]=camCircle7StructElt[y][x];\n        }\n    }\n    t1=camGetTimeMs();\n    camDilate7x7(&source,&dest,&mm_params);\n    t2=camGetTimeMs();\n    printf(\"7x7 Circle unoptimized dilation            = %d ms\\n\",(t2-t1));\n\n    t1=camGetTimeMs();\n    camDilateCircle7(&source,&dest);\n    t2=camGetTimeMs();\n    printf(\"7x7 Circle outplace dilation               = %d ms\\n\",(t2-t1));\n    \n    t1=camGetTimeMs();\n    camDilateCircle7(&source,&source);\n    t2=camGetTimeMs();\n    printf(\"7x7 Circle inplace dilation                = %d ms\\n\",(t2-t1));\n    \n    camSavePGM(&dest,\"output/chess_dilate_circle7.pgm\");\n\n    camDeallocateImage(&source);\n    camDeallocateImage(&dest);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Motion estimation example\n", "func_signal": "void example_me()", "code": "{\n    CamImage image1,image2;\n    CamROI roi1,roi2;\n    CamMotionEstimation3DRSParams params;\n    CamMotionEstimation3DRSResults results;\n    int x,y;\n\n    camLoadPGM(&image1,\"resources/chess.pgm\");\n    camAllocateImage(&image2,image1.width,image1.height,CAM_DEPTH_8U);\n    camSet(&image2,0);\n\n    roi1.width=roi2.width=image1.width-10;\n    roi1.height=roi2.height=image1.height-8;\n    roi1.xOffset=0;\n    roi1.yOffset=0;\n    roi2.xOffset=10;\n    roi2.yOffset=8;\n\n    image1.roi=&roi1;\n    image2.roi=&roi2;\n    camCopy(&image1,&image2);\n    camSavePGM(&image2,\"output/chess_translated.pgm\");\n    camMotionEstimation3DRSInit(&params,0,2,20,16,3,5,0);\n    camMotionEstimation3DRS(&image2,&image1,&params,&results);\n\n    for (y=0;y<image2.height/16;y++) {\n        for (x=0;x<image2.width/16;x++) {\n            printf(\"(%2d,%2d)\",results.vx[x][y],results.vy[x][y]);\n        }\n        printf(\"\\n\");\n    }\n\n    camDeallocateImage(&image1);\n    camDeallocateImage(&image2);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Warping example\n", "func_signal": "void example_warping()", "code": "{\n    CamImage source,resampled,warped,rotated;\n    CamWarpingParams params;\n    int t1,t2;\n    int c;\n\n    // Load picture chess.pgm\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    camAllocateImage(&resampled,source.width/2,source.height/2,source.depth);\n    camAllocateImage(&warped,source.width,source.height,source.depth);\n    camAllocateImage(&rotated,source.width,source.width,source.depth);\n\n    t1=camGetTimeMs();\n    for (c=0;c<1000;c++)\n    {\n\tparams.interpolation=0;\n\t\n\tparams.perspective=0;\n\tparams.p[0].x=0;\n\tparams.p[0].y=0;\n\tparams.p[1].x=(source.width<<16)-1;\n\tparams.p[1].y=0;\n\tparams.p[2].x=(source.width<<16)-1;\n\tparams.p[2].y=(source.height<<16)-1;\n\tparams.p[3].x=0;\n\tparams.p[3].y=(source.height<<16)-1;\n\t\n\tcamWarping(&source,&resampled,&params);\n\t\n\tparams.perspective=1;\n\tparams.p[0].x=((source.width<<16)-1)*1/3;\n\tparams.p[0].y=0;\n\tparams.p[1].x=((source.width<<16)-1)*2/3;\n\tparams.p[1].y=0;\n\tparams.p[2].x=(source.width<<16)-1;\n\tparams.p[2].y=(source.height<<16)-1;\n\tparams.p[3].x=0;\n\tparams.p[3].y=(source.height<<16)-1;\n\t\n\tcamWarping(&source,&warped,&params);\n\t\n\tparams.perspective=0;\n\tparams.p[0].x=(source.width<<16)/2;\n\tparams.p[0].y=-(source.height<<16)/2;\n\tparams.p[1].x=3*(source.width<<16)/2;\n\tparams.p[1].y=(source.height<<16)/2;\n\tparams.p[2].x=(source.width<<16)/2;\n\tparams.p[2].y=3*(source.height<<16)/2;\n\tparams.p[3].x=-(source.width<<16)/2;\n\tparams.p[3].y=(source.height<<16)/2;\n\t\n\tcamWarping(&source,&rotated,&params);\n    }\t\n    t2=camGetTimeMs();\n    printf(\"Nearest neighbour warping = %d us\\n\",t2-t1);\n\n    camSavePGM(&resampled,\"output/chess_resampled_nn.pgm\");\n    camSavePGM(&warped,\"output/chess_warped_nn.pgm\");\n    camSavePGM(&rotated,\"output/chess_rotated_nn.pgm\");\n\n    t1=camGetTimeMs();\n    for (c=0;c<1000;c++)\n    {\n\tparams.interpolation=1;\n\t\n\tparams.perspective=0;\n\tparams.p[0].x=0;\n\tparams.p[0].y=0;\n\tparams.p[1].x=(source.width<<16)-1;\n\tparams.p[1].y=0;\n\tparams.p[2].x=(source.width<<16)-1;\n\tparams.p[2].y=(source.height<<16)-1;\n\tparams.p[3].x=0;\n\tparams.p[3].y=(source.height<<16)-1;\n\t\n\tcamWarping(&source,&resampled,&params);\n\t\n\tparams.perspective=1;\n\tparams.p[0].x=((source.width<<16)-1)*1/3;\n\tparams.p[0].y=0;\n\tparams.p[1].x=((source.width<<16)-1)*2/3;\n\tparams.p[1].y=0;\n\tparams.p[2].x=((source.width<<16)-1);\n\tparams.p[2].y=(source.height<<16)-1;\n\tparams.p[3].x=0;\n\tparams.p[3].y=(source.height<<16)-1;\n\t\n\tcamWarping(&source,&warped,&params);\n\t\n\tparams.perspective=0;\n\tparams.p[0].x=(source.width<<16)/2;\n\tparams.p[0].y=-(source.height<<16)/2;\n\tparams.p[1].x=3*(source.width<<16)/2;\n\tparams.p[1].y=(source.height<<16)/2;\n\tparams.p[2].x=(source.width<<16)/2;\n\tparams.p[2].y=3*(source.height<<16)/2;\n\tparams.p[3].x=-(source.width<<16)/2;\n\tparams.p[3].y=(source.height<<16)/2;\n\t\n\tcamWarping(&source,&rotated,&params);\n    }\n    t2=camGetTimeMs();\n    printf(\"Bilinear interpolation warping = %d us\\n\",(t2-t1));\n\n    camSavePGM(&resampled,\"output/chess_resampled_bilinear.pgm\");\n    camSavePGM(&warped,\"output/chess_warped_bilinear.pgm\");\n    camSavePGM(&rotated,\"output/chess_rotated_bilinear.pgm\");\n\n    camDeallocateImage(&source);\n    camDeallocateImage(&resampled);\n    camDeallocateImage(&warped);\n    camDeallocateImage(&rotated);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "/* Warning : This code is not reentrant. Use only for debugging purpose */\n", "func_signal": "int camLogProfilingData(const char *module, int nbiter)", "code": "{\n    if (camProfilingDataHandle == NULL) {\n\tcamProfilingDataHandle = fopen(\"cam_profiling.txt\",\"wt\");\n    }\n    fprintf(camProfilingDataHandle, \"%s\\t%d\\n\", module, nbiter);\n    return 1;\n}", "path": "src\\cam_utils.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Arithmetic routines\n", "func_signal": "double *camAllocateVector(int nl, int nh)", "code": "{\n    double *v;\n    v=(double *)malloc((unsigned)(nh - nl + 1) * sizeof(double));\n    if (!v) {\n\tcamError(\"camAllocateVector\", \"Memory allocation failure\");\n\treturn NULL;\n    }\n    return v-nl;\n}", "path": "src\\cam_keypoints_matching.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// RLE erosion example\n", "func_signal": "void example_rle_erosion()", "code": "{\n    CamImage source,binary;\n    CamRLEImage encoded,eroded;\n    int i;\n    CamTable LUT;\n\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    camAllocateImage(&binary,source.width,source.height,CAM_DEPTH_8U);\n    camRLEAllocate(&encoded,100000);\n    camRLEAllocate(&eroded,100000);\n\n    for (i=0;i<128;i++) LUT.t[i]=0;\n    for (;i<256;i++) LUT.t[i]=255;\n    \n    camRLEEncodeLUT(&source,&encoded,&LUT);\n    printf(\"Number of runs : %d\\n\",encoded.nbRuns);\n\n    camRLEErodeCross(&encoded,&eroded);\n    printf(\"Number of runs : %d\\n\",eroded.nbRuns);\n    camRLEDecode(&eroded,&binary,&LUT);\n    camSavePGM(&binary,\"output/chess_RLE_eroded_cross.pgm\");\n\n    camRLEErode3x3(&encoded,&eroded);\n    printf(\"Number of runs : %d\\n\",eroded.nbRuns);\n    camRLEDecode(&eroded,&binary,&LUT);\n    camSavePGM(&binary,\"output/chess_RLE_eroded_3x3.pgm\");\n\n    camRLEErode3x2(&encoded,&eroded);\n    printf(\"Number of runs : %d\\n\",eroded.nbRuns);\n    camRLEDecode(&eroded,&binary,&LUT);\n    camSavePGM(&binary,\"output/chess_RLE_eroded_3x2.pgm\");\n\n    camRLEDeallocate(&encoded);\n    camRLEDeallocate(&eroded);\n    camDeallocateImage(&source);\n    camDeallocateImage(&binary);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Takes the list of runs and formats them into a region table,\n// gathering the various statistics we want along the way.\n// Implemented as a single pass over the array of runs.\n", "func_signal": "int camRLEBlobAnalysis(CamRLEImage *src, CamBlobAnalysisResults *results)", "code": "{\n    int x,y,i;\n    int b,n,a;\n    CamRun *r;\n    int nbRuns=src->nbRuns;\n    int width=src->width;\n\n    // Sum of integers over range [x,x+w)\n    #define RANGE_SUM(x,w) (w*(2*x + w-1) / 2)\n    #define MIN(x,y) (((x)<(y))?(x):(y))\n    #define MAX(x,y) (((x)>(y))?(x):(y))\n\n    results->nbBlobs=0; // Just in case it would fail...\n    \n    x = y = n = 0;\n    for (i=1; i<nbRuns; i++) {\n\tr = &src->runs[i];\n\t\n\tif (r->value) {\n\t    if (r->parent == i) {\n\t\t// Add new region if this run is a root (i.e. self parented)\n\t\tsrc->runs[i].parent = b = n;  // Renumber to point to region id\n\t\tresults->blobInfo[b].id = n;\n\t\tresults->blobInfo[b].surface = r->length;\n\t\tresults->blobInfo[b].left = x;\n\t\tresults->blobInfo[b].top = y;\n\t\tresults->blobInfo[b].width = r->length;\n\t\tresults->blobInfo[b].height = 1;\n\t\tresults->blobInfo[b].cx = RANGE_SUM(x, r->length);\n\t\tresults->blobInfo[b].cy = y * r->length;\n\t\tresults->blobInfo[b].value = r->value;\n\t\tresults->blobInfo[b].first = r;\n\t\tresults->blobInfo[b].last = r;\n\t\tn++;\n\t\tif(n >= CAM_LABEL_MAX_BLOBS) return 0;\n\t    } else {\n\t\t// Otherwise update region stats incrementally\n\t\tb = src->runs[r->parent].parent;\n\t\tsrc->runs[i].parent = b; // Update to point to region id\n\t\tresults->blobInfo[b].surface += r->length;\n\t\tif (x < results->blobInfo[b].left) {\n\t\t    results->blobInfo[b].width += results->blobInfo[b].left - x;\n\t\t    results->blobInfo[b].left = x;\n\t\t}   \n\t\tresults->blobInfo[b].width = MAX(x + r->length - results->blobInfo[b].left, results->blobInfo[b].width);\n\t\tresults->blobInfo[b].height = y - results->blobInfo[b].top+1; // Last set by lowest run\n\t\tresults->blobInfo[b].cx += RANGE_SUM(x, r->length);\n\t\tresults->blobInfo[b].cy += y * r->length;\n\t\tresults->blobInfo[b].last = r;\n\t    }\n\t} else r->parent=-1;\n\t\n\t// Step to next location\n\tx = (x + r->length) % width;\n\ty += (x == 0);\n    }\n    \n    // Calculate centroids from stored temporaries\n    for (i=0; i<n; i++) {\n\ta = results->blobInfo[i].surface;\n\tresults->blobInfo[i].cx = results->blobInfo[i].cx / a;\n\tresults->blobInfo[i].cy = results->blobInfo[i].cy / a;\n    }\n    \n    results->nbBlobs=n;\n    return 1;\n}", "path": "src\\cam_RLE_labelling.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Binary image processing example\n", "func_signal": "void example_binary()", "code": "{\n    CamImage source,binary,dilated,inverse,or;\n    CamArithmParams arithm_params;\n    CamRLEImage encoded;\n    CamBlobs results;\n    CamMorphoMathsKernel mm_params;\n    int i,x,y;\n\n    camLoadPGM(&source,\"resources/chess.pgm\");\n    camAllocateImage(&binary,source.width,source.height,CAM_DEPTH_1U);\n    camSet(&binary,0); // Just to make valgrind happy. Not necessary\n    arithm_params.operation=CAM_ARITHM_THRESHOLD;\n    arithm_params.c1=128;\n    arithm_params.c2=0;\n    arithm_params.c3=255;\n    camMonadicArithm(&source,&binary,&arithm_params);\n    camSavePGM(&binary,\"output/chess_binary.pgm\");\n\n    // Dilate that picture\n    camAllocateImage(&dilated,source.width,source.height,CAM_DEPTH_1U);\n    camSet(&dilated,0); // Just to make valgrind happy. Not necessary\n    for (x=0;x<5;x++) {\n\tfor (y=0;y<5;y++) {\n\t    mm_params.dilationStructElt[x][y]=CircleStructElt[x][y];\n\t    mm_params.erosionStructElt[x][y]=0;\n\t}\n    }\n    camDilate5x5(&binary,&dilated,&mm_params);\n    camSavePGM(&dilated,\"output/chess_binary_dilated.pgm\");\n\n    // Inverse the picture\n    camAllocateImage(&inverse,source.width,source.height,CAM_DEPTH_1U);\n    camSet(&inverse,0); // Just to make valgrind happy. Not necessary\n    arithm_params.operation=CAM_ARITHM_INVERSE;\n    camMonadicArithm(&dilated,&inverse,&arithm_params);\n    camSavePGM(&inverse,\"output/chess_binary_inverse.pgm\");\n    \n    // Or with the binary image\n    camAllocateImage(&or,source.width,source.height,CAM_DEPTH_1U);\n    camSet(&or,0); // Just to make valgrind happy. Not necessary\n    arithm_params.operation=CAM_ARITHM_OR;\n    camDyadicArithm(&binary,&inverse,&or,&arithm_params);\n    camSavePGM(&or,\"output/chess_binary_or.pgm\");\n\n    // Label the image\n    camRLEAllocate(&encoded,100000);\n    camRLEEncode(&dilated,&encoded);\n    printf(\"Number of runs : %d\\n\",encoded.nbRuns);\n    camRLELabelling(&encoded,&results);\n\n    // Print the results \n    for (i=0;i<results.nbBlobs;i++) {\n\tprintf(\"Blob #%2d : (%3d,%3d,%3d,%3d) Surface=%d\\n\",\n\t    i,results.blobInfo[i].left,results.blobInfo[i].top,\n\t    results.blobInfo[i].width,results.blobInfo[i].height,\n\t    results.blobInfo[i].surface);\n    }\n\n    camRLEDeallocate(&encoded);\n    camDeallocateImage(&source);\n    camDeallocateImage(&binary);\n    camDeallocateImage(&dilated);\n    camDeallocateImage(&inverse);\n    camDeallocateImage(&or);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Configuration file management functions\n", "func_signal": "int camLoadConfig(const char *filename, CamConfig *config)", "code": "{\n    FILE *handle;\n    char string[1024],*ptr;\n    config->nbEntries=0;\n    if ((handle=fopen(filename,\"rt\"))==NULL) return 0;\n    while (!feof(handle)) {\n        if (fgets(string,1024,handle)==NULL) break;\n        if (string[0]=='#') continue; // Comments in the file\n        if (string[0]=='\\n') continue; // Blank line        \n        if (string[0]=='\\r') continue; // Blank line        \n        if ((ptr=strtok(string,\"=\"))==NULL) break;\n        strcpy(config->parameter[config->nbEntries],ptr);\n        if ((ptr=strtok(NULL,\"\\n\\r#\"))==NULL) break;\n        strcpy(config->value[config->nbEntries],ptr);\n        config->nbEntries++;\n    }\n    fclose(handle);\n    return config->nbEntries;\n}", "path": "src\\cam_utils.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "/* Get the next non-comment line from the PBM file f into the buffer b.\n */\n", "func_signal": "static void pbm_getln(FILE *f, char *b)", "code": "{\n    int i;\n    char c;\n    \n    // Read the next significant line (non-comment) from f into buffer b\n    do\n    {\n\t// Read the next line\n\ti = 0;\n\tdo\n\t{\n\t    fscanf (f, \"%c\", &c);\n\t    b[i++] = c;\n\t    if (c == '\\n') b[i] = '\\0';\n\t} while (c != '\\n');\n    } while (b[0]=='\\n' || b[0] == '#');\n}", "path": "src\\cam_io.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Value of a pixel when it is inserted in the queue\n", "func_signal": "void camInitTableOfBasins(CamTableOfBasins *t)", "code": "{\n    t->sizeMax=CAM_DELTA;\n    if ((t->tab=(CamBasin*)malloc(t->sizeMax*sizeof(CamBasin)))==NULL)\n\texit(0);\n    t->nbBasins=0;\n}", "path": "src\\cam_watershed.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "/* Error management routine\n*/\n", "func_signal": "void camError(char *module, char *error)", "code": "{\n    if (error!=NULL) {\n        camSetErrorStr(error);\n    }\n    errfunct(module,error);\n}", "path": "src\\cam_error.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Warning : this code assumes sizeof(int) of 4\n", "func_signal": "int camWarping(CamImage *source, CamImage *dest, CamWarpingParams *params)", "code": "{\n    int i,x,y,width,height;\n    int xl,yl,xr,yr; // Position on the left and right side (source image)\n    int incxl,incyl,incxr,incyr; // Increment on the left and right sides (source image)\n    int dxl,dyl,dxr,dyr; // Delta for the left and right sides\n    int xp,yp; // Position of the current point\n    int incxp,incyp; // Increment for the current point \n    CAM_PIXEL *dstptr,*cpdstptr,*srcptr,*srcptrref;\n    int xx,yy;\n    int perspective=params->perspective;\n    int zul,zbl,zur,zbr,cl,cr,zl,zr; // Projection parameters\n    int I0,I1,S0,S1,S2,S3; // Bilinear interpolation intermediate results\n    CamPoint I;\n    CamInternalROIPolicyStruct iROI;\n    \n    // ROI (Region Of Interest) management\n    CAM_CHECK(camWarping,camInternalROIPolicy(source, dest, &iROI, CAM_NO_ROI_INTERSECTION));\n    CAM_CHECK_ARGS(camWarping,(source->depth&CAM_DEPTH_MASK)<=(sizeof(CAM_PIXEL)*8));\n    CAM_CHECK_ARGS(camWarping,(source->depth&CAM_DEPTH_MASK)>=8);\n    CAM_CHECK_ARGS(camWarping,(dest->depth&CAM_DEPTH_MASK)<=(sizeof(CAM_PIXEL)*8));\n    CAM_CHECK_ARGS(camWarping,(dest->depth&CAM_DEPTH_MASK)>=8);\n\n    dstptr=(CAM_PIXEL*)iROI.dstptr;\n    srcptrref=(CAM_PIXEL*)iROI.srcptr;\n    width=iROI.dstroi.width;\n    height=iROI.dstroi.height;\n    \n    xl=params->p[0].x;\n    yl=params->p[0].y;\n    xr=params->p[1].x;\n    yr=params->p[1].y;\n    \n    dxl=params->p[3].x-xl;\n    dyl=params->p[3].y-yl;\n    dxr=params->p[2].x-xr;\n    dyr=params->p[2].y-yr;\n    \n    // Perspective warping or not?\n    if (perspective) {\n\tif (!camIntersectionSegments(params->p,&I)) {\n\t    perspective=0;\n\t} else {\n\t    // 32 bits fixed point\n\t    zul=(int)((((CAM_INT64)1)<<48)/(params->p[0].y-I.y));\n\t    zur=(int)((((CAM_INT64)1)<<48)/(params->p[1].y-I.y));\n\t    zbl=(int)((((CAM_INT64)1)<<48)/(params->p[3].y-I.y));\n\t    zbr=(int)((((CAM_INT64)1)<<48)/(params->p[2].y-I.y));\n\t    cl=((zul-zbl)/height)>>1; // 31 bits fixed point\n\t    cr=((zur-zbr)/height)>>1; // Should be positive valued\n\t}\n    }\n    if (!perspective) {\n\tincxl=dxl/height;\n\tincyl=dyl/height;\n\tincxr=dxr/height;\n\tincyr=dyr/height;\n\t// Move the position one half pixel down\n\txl+=(incxl>>1);\n\txr+=(incxr>>1);\n\tyl+=(incyl>>1);\n\tyr+=(incyr>>1);\n    } else {\n\tincxl=(int)((((CAM_INT64)dxl)<<16)/dyl);\n\tincxr=(int)((((CAM_INT64)dxr)<<16)/dyr);\n    }\n\n    // For all destination pixels\n    // Let's go across all the lines\n    for (y=0;y<height;y++) {\n\n\tif (perspective) {\n\t    zl=zul-((y<<1)+1)*cl; // 32 bits fixed points\n\t    zr=zur-((y<<1)+1)*cr;\n\t    yl=I.y+(int)((((CAM_INT64)1)<<48)/zl);\n\t    yr=I.y+(int)((((CAM_INT64)1)<<48)/zr);\n\t    xl=params->p[0].x+(int)(((CAM_INT64)incxl)*(yl-params->p[0].y)>>16);\n\t    xr=params->p[1].x+(int)(((CAM_INT64)incxr)*(yr-params->p[1].y)>>16);\n\t}\n\n\tcpdstptr=dstptr;\n\tincxp=(xr-xl)/width;\n\tincyp=(yr-yl)/width;\n\t// Move the position one half pixel to the right\n\txp=xl+(incxp>>1); yp=yl+(incyp>>1);\n\n\t// And then across each horizontal pixel\n\tfor (x=0;x<width;x++,dstptr+=iROI.dstinc) {\n            // We can compute the interpolation between them\n            switch (params->interpolation) {\n            case 0: // Nearest neighbour nterpolation (fast but crude)\n            default:\n                // Let's retrieve the value of the current pixel in the source image\n                xx=xp>>16;\n                yy=yp>>16;\n                if ((xx>=0)&&(yy>=0)&&(xx<iROI.srcroi.width)&&(yy<iROI.srcroi.height)) {\n                    srcptr=(CAM_PIXEL*)(srcptrref+yy*source->widthStep)+xx*iROI.srcinc;\n                    for (i=0;i<iROI.nChannels;i++) {\n                        // Write the result to the destination image\n                        *(dstptr+i)=*(srcptr+i);\n                    }\n                } else {\n                    for (i=0;i<iROI.nChannels;i++) {\n                        // Blank pixels\n                        *(dstptr+i)=0;\n                    }\n                }\n                break;\n            case 1: // Bilinear interpolation\n                // Let's retrieve the 4 nearest points in the source image\n                xx=(xp-32767)>>16; // Upper left pixel\n                yy=(yp-32767)>>16;\n                if ((xx>=0)&&(yy>=0)&&(xx<iROI.srcroi.width-1)&&(yy<iROI.srcroi.height-1)) {\n                    srcptr=(CAM_PIXEL*)(srcptrref+yy*source->widthStep)+xx*iROI.srcinc;\n                    xx=(xx<<16)+32767;\n                    yy=(yy<<16)+32767; // Center of the upper left pixel\n                    for (i=0;i<iROI.nChannels;i++,srcptr++) {\n                        S0=*srcptr;\n                        S1=*(srcptr+iROI.srcinc);\n                        S2=*(srcptr+iROI.srclinc);\n                        S3=*(srcptr+iROI.srcinc+iROI.srclinc);\n                        I0=(S0<<8)+(((xp-xx)*(S1-S0))>>8); // Horizontal linear interpolation\n                        I1=(S2<<8)+(((xp-xx)*(S3-S2))>>8); // 8 bits fixed point\n                        *(dstptr+i)=(I0+(((yp-yy)*(I1-I0))>>16)+128)>>8; // Vertical linear interpolation                    \n                    }\n                } else {\n                    for (i=0;i<iROI.nChannels;i++) {\n                        // Blank pixels\n                        *(dstptr+i)=0;\n                    }\n                }\n                break;\n            }\n            \n            // Go to the next pixel\n            xp+=incxp;\n            yp+=incyp;\t\n\t}\n\t\n\t// Move the destination pointer\n\tdstptr=(CAM_PIXEL*)(((char*)cpdstptr)+dest->widthStep);\n\n\t// Go to the next line\n\tif (!perspective) {\n\t    xl+=incxl;\n\t    xr+=incxr;\n\t    yl+=incyl;\n\t    yr+=incyr;\n\t}\n    }\n    return 1;\n}", "path": "src\\cam_warping_code.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Watershed segmentation example\n", "func_signal": "void example_watershed2()", "code": "{\n    CamImage source,watershed,gradient;\n    CamTableOfBasins tob;\n    CamRLEImage encoded;\n    CamBlobs results;\n    int i,j;\n\n    camAllocateImage(&source,32,32,CAM_DEPTH_8U);\n    camSet(&source,0);\n    camDrawCircle(&source,16,16,8,128);\n    camFillColor(&source,16,16,255,0);\n        \n/*\n    CamImage color,ds; \n    camLoadBMP(&color,\"obstacles3.bmp\");\n    camAllocateRGBImage(&ds,color.width/2,color.height/2);\n    camDownscaling2x2(&color,&ds);\n    camDeallocateImage(&color);\n    camAllocateImage(&source,ds.width,ds.height,CAM_DEPTH_8U);\n    camRGB2Y(&ds,&source);\n    camDeallocateImage(&ds);\n    camDilateCircle5(&source,&source);\n */\n    \n    // Compute the watershed of the gradient of the picture\n    camAllocateImage(&gradient,source.width,source.height,source.depth);\n    camMorphoGradientCircle5(&source,&gradient);\n    camSavePGM(&gradient,\"output/watershed_source_gradient.pgm\");\n    camAllocateImage(&watershed,source.width,source.height,CAM_DEPTH_16S);\n    camHierarchicalWatershed(&gradient,&watershed,&tob);\n    camSavePGM(&watershed,\"output/watershed_gradient.pgm\");\n    for (i=0;i<tob.nbBasins;i++) {\n\tprintf(\"Basin #%d : Dynamics = %d, Minimum = %d, Surface = %d, (x,y)=(%d,%d)\\n\",i,tob.tab[i].dynamics,tob.tab[i].minimum,tob.tab[i].accsurface,tob.tab[i].x,tob.tab[i].y);\n    }\n    printf(\"\\n\");\n\n    for (i=0;i<tob.nbBasins;i++) {\n        if (tob.tab[i].dynamics<50){\n            tob.tab[i].surface=0;\n        }\n        if (tob.tab[i].accsurface<watershed.height*watershed.width/100) {\n            tob.tab[i].surface=0;\n        }\n    }\n    for (i=0;i<tob.nbBasins;i++) {\n        if ((tob.tab[i].surface!=0)||(tob.tab[i].dynamics==CAM_NOT_COMPUTED)) {\n            printf(\"\\nBasin #%d : Dynamics = %d, Minimum = %d, Surface = %d, (x,y)=(%d,%d)\\n\",i,tob.tab[i].dynamics,tob.tab[i].minimum,tob.tab[i].accsurface,tob.tab[i].x,tob.tab[i].y);\n            j=i;\n\t    while (tob.tab[j].dynamics!=CAM_NOT_COMPUTED) {\n\t\tprintf(\"->%d\",tob.tab[j].flooded);\n\t\tj=tob.tab[j].flooded;\n\t    }\n\t}\n    }\n\n    camHierarchicalWatershedRegions(&watershed,&tob);\n    camSavePGM(&watershed,\"output/watershed_regions.pgm\");\n\n    // Labelling\n    camRLEAllocate(&encoded, 10000);\n    camRLEEncode(&watershed,&encoded);\n    camRLELabelling(&encoded,&results);\n    \n    // Print the results \n    printf(\"\\n\");\n    for (i=0;i<results.nbBlobs;i++) {\n        camRLEBlobMeasures(&results.blobInfo[i], &source);\n\tprintf(\"Blob #%2d : (%3d,%3d,%3d,%3d) Surface=%d\\n Average=%d Min=%d Max=%d\\n\",\n\t    i,results.blobInfo[i].left,results.blobInfo[i].top,\n\t    results.blobInfo[i].width,results.blobInfo[i].height,\n\t    results.blobInfo[i].surface,results.blobInfo[i].value,results.blobInfo[i].min,results.blobInfo[i].max);\n    }\n\n    camRLEDeallocate(&encoded);\n    \n    camFreeTableOfBasins(&tob);\n    camDeallocateImage(&source);\n    camDeallocateImage(&watershed);\n    camDeallocateImage(&gradient);\n}", "path": "cam_demo.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "/* Image allocation utility routine\n */\n", "func_signal": "int camAllocateImageEx(CamImage *image, int width, int height, int depth, int channelseq)", "code": "{\n    switch (channelseq) {\n    case 0:\n    case CAM_CHANNELSEQ_GREY:\n        return camAllocateImage(image, width, height, depth);\n    case 1:\n    case CAM_CHANNELSEQ_RGB:\n        if (depth!=CAM_DEPTH_8U) {\n            image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n        } else return camAllocateRGBImage(image, width, height);\n        break;\n    case 2:\n    case CAM_CHANNELSEQ_RGBA:\n        if (depth!=CAM_DEPTH_8U) {\n            image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n        } else return camAllocateRGBAImage(image, width, height);\n        break;\n    case 3:\n    case CAM_CHANNELSEQ_YUV:\n        if (depth!=CAM_DEPTH_8U) {\n            image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n        } else return camAllocateYUVImage(image, width, height);\n        break;\n    case 4:\n    case CAM_CHANNELSEQ_BGR:\n        if (depth!=CAM_DEPTH_8U) {\n            image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n        } else return camAllocateBGRImage(image, width, height);\n        break;\n    case 5:\n    case CAM_CHANNELSEQ_BGRA:\n        if (depth!=CAM_DEPTH_8U) {\n            image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n        } else return camAllocateBGRAImage(image, width, height);\n        break;\n    default:\n        image->imageData=NULL; image->roi=NULL; image->imageSize=0; image->mask=NULL; image->imageDataOrigin=NULL; image->depth=CAM_DEPTH_8U; image->nChannels=1; \n    }\n    return 0;\n}", "path": "src\\cam_utils.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "// Generate a LUT for cos/sin\n", "func_signal": "void camGenerateSinLUT()", "code": "{\n    int gy;\n    double alpha,res;\n    FILE *handle=fopen(\"cam_LUT.c\",\"wt\");\n    fprintf(handle,\"unsigned char camSinLUT[256]={\");\n    // Let's assume gx=256\n    for (gy=0;gy<256;gy++) {\n        alpha=atan(gy/256.0);\n        res=sin(alpha);\n        fprintf(handle,\"%d\",(int)(res*256+0.5));\n        if (gy!=255) fprintf(handle,\",\");\n    }\n    fprintf(handle,\"};\\n\");\n    fprintf(handle,\"unsigned char camCosLUT[256]={\");\n    // Let's assume gx=256\n    for (gy=0;gy<256;gy++) {\n        alpha=atan(gy/256.0);\n        res=cos(alpha);\n        fprintf(handle,\"%d\",(int)(res*256+0.5)-1);\n        if (gy!=255) fprintf(handle,\",\");\n    }\n    fprintf(handle,\"};\\n\");\n    fclose(handle);\n}", "path": "src\\cam_hough.c", "repo_name": "sigmike/camellia", "stars": 13, "license": "other", "language": "c", "size": 26336}
{"docstring": "/* Emulate alarm() via setitimer() */\n", "func_signal": "unsigned int alarm(unsigned int seconds)", "code": "{\n\tstruct itimerval iv;\n\n\tiv.it_interval.tv_sec = iv.it_interval.tv_usec = 0;\n\tiv.it_value.tv_sec = seconds;\n\tiv.it_value.tv_usec = 0;\n\n\tsetitimer(ITIMER_REAL, &iv, &iv);\n\n\treturn iv.it_value.tv_sec + (iv.it_value.tv_usec ? 1 : 0);\n}", "path": "usr\\klibc\\alarm.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* This is not quite the MIME base64 algorithm: it uses _ instead of /,\n   and instead of padding the output with = characters we just make the\n   output shorter. */\n", "func_signal": "char *mybase64(uint8_t digest[20])", "code": "{\n  static const char charz[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n  uint8_t input[21];\n  static char output[28];\n  int i, j;\n  uint8_t *p;\n  char *q;\n  uint32_t bv;\n\n  memcpy(input, digest, 20);\n  input[20] = 0;\t\t/* Pad to multiple of 3 bytes */\n\n  p = input;  q = output;\n  for ( i = 0 ; i < 7 ; i++ ) {\n    bv = (p[0] << 16) | (p[1] << 8) | p[2];\n    p += 3;\n    for ( j = 0 ; j < 4 ; j++ ) {\n      *q++ = charz[(bv >> 18) & 0x3f];\n      bv <<= 6;\n    }\n  }\n  *--q = '\\0';\t\t\t/* The last character is not significant */\n  return output;\n}", "path": "usr\\klibc\\sha1hash.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* SHA1Init - Initialize new context */\n", "func_signal": "void SHA1Init(SHA1_CTX* context)", "code": "{\n    /* SHA1 initialization constants */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xEFCDAB89;\n    context->state[2] = 0x98BADCFE;\n    context->state[3] = 0x10325476;\n    context->state[4] = 0xC3D2E1F0;\n    context->count[0] = context->count[1] = 0;\n}", "path": "usr\\klibc\\sha1hash.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Load dynamically linked program using host's libdl\n */\n", "func_signal": "EXPORT int dummy_load_so(const char *path)", "code": "{\n\tvoid *__H;\n\tvoid (*so_start)();\n\tvoid **sys_call_gate;\n\tvoid *sys_call;\n\n\t/* open each shared object in a new namespace */\n\t__H = dlmopen(-1, path, RTLD_NOW|RTLD_DEEPBIND);\n\tif (!__H) {\n\t\tfprintf(stderr, \"Init load failed: %s\\n\", dlerror());\n\t\treturn -1;\n\t}\n\n\t/* obtain program's entry point */\n\tso_start = dlsym(__H, \"__libc_init\");\n\tif (!so_start) {\n\t\tfprintf(stderr, \"Init exec failed: %s\\n\", dlerror());\n\t\treturn -1;\n\t}\n\n\t/* in-program address of system call trampoline */\n\tsys_call_gate = dlsym(__H, \"_sys_call\");\n\tif (!sys_call_gate) {\n\t\tfprintf(stderr, \"Init exec failed: %s\\n\", dlerror());\n\t\treturn -1;\n\t}\n\n\t/* obtain kernel's system call gate */\n\tsys_call = dlsym(H, \"sys_call\");\n\tif (!sys_call) {\n\t\tfprintf(stderr, \"Can't find kernel's sys_call_gate.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* patch program's system call entry function to kernel's\n\t * sys_call gate: this requires _sys_call symbol exported\n\t * from the program (assumingly by libc) */\n\t*sys_call_gate = sys_call;\n\n\t/* start the program */\n\tso_start();\n\n\treturn 0;\n}", "path": "arch\\dummy\\loader\\dl_user.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* Note: if environ has been malloc'd, it will be freed on the next\n   setenv() or putenv() */\n", "func_signal": "int clearenv(void)", "code": "{\n\tenviron = (char **)__null_environ;\n\treturn 0;\n}", "path": "usr\\klibc\\clearenv.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * This is an early console in fact, we'll have a proper console\n * once mm is initialized\n */\n", "func_signal": "void __init early_console_init()", "code": "{\n#ifdef OPT_EARLY_SERIAL_CONSOLE\n\tearly_serial_init();\n#endif\n\n#ifdef OPT_EARLY_VGA_CONSOLE\n\tearly_vga_init();\n#endif\n}", "path": "arch\\i386\\console.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Start a new userspace process with the given binary\n * @path -- where the binary is located\n * This is needed for starting processes on kernel's demand,\n * like init.\n */\n", "func_signal": "int spawn(char *path)", "code": "{\n\tstruct thread *thread;\n\tstruct thread_queue tmp_q;\n\tstruct direntry *dent;\n\tstruct inode *inode;\n\tint ret;\n\n\tdent = lookup_path(path);\n\tif (!dent) {\n\t\tDPRINT(\"%s not found.\\n\", path);\n\t\treturn -ENOENT;\n\t}\n\n\tinode = dent->d_inode;\n\n        thread = thread_create_user(&user_thread, path, NULL);\n        if (!thread) {\n                DPRINT(\"failed to create thread\\n\");\n\t\treturn -ENOMEM;\n        }\n\n\tret = thread_exec_new(thread, inode);\n\tif (ret)\n\t\treturn ret;\n\n\ttq_init(&tmp_q);\n\ttq_insert_head(thread, &tmp_q);\n\n        bug_on(!scheduler_enqueue(&tmp_q));\n\treturn 0;\n}", "path": "kernel\\exec.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* omgwtf */\n", "func_signal": "pid_t get_free_pid()", "code": "{\n\tstatic pid_t i = 0;\n\treturn i++;\n}", "path": "kernel\\thread.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Prepare to execute the kernel\n */\n", "func_signal": "void __text32 start_kernel()", "code": "{\n\tunsigned long *src = 0x11000;\n\tunsigned long *dst = 0x100000;\n\tint count = KERNSZ >> 2;\n\n\t/* copy the kernel to 1mb */\n\tfor (count = KERNSZ * 4; count--; *dst++ = *src++);\n\n\tsetup_multiboot();\n\n\t__asm__ __volatile__(\"jmp *%1\" :\n\t\t\t: \"b\"(&multiboot_info), \"r\"(KOS_ENTRY));\n}", "path": "arch\\i386\\loader\\moowaldah.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* omgwtf II */\n", "func_signal": "struct thread *thread_get(pid_t pid)", "code": "{\n\tstruct klist0_node *tmp;\n\tstruct thread *t;\n\n\tklist0_for_each(tmp, &thread_list.threads) {\n\t\tt = klist0_entry(tmp, struct thread, kthreads);\n\t\t\n\t\tif (t->pid == pid)\n\t\t\treturn t;\n\t}\n\n\treturn NULL;\n}", "path": "kernel\\thread.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Execute a binary in the given thread.\n * Most commonly used in the exec* syscall family where thread == CURRENT().\n * @thread -- the thread to be substituted\n * @path   -- path to binary to be executed\n */\n", "func_signal": "int thread_exec(struct thread *thread, char *path)", "code": "{\n\tstruct direntry *dent;\n\tstruct inode *inode;\n\tint i;\n\n\tdent = lookup_path(path);\n\tif (!dent) {\n\t\tDPRINT(\"%s not found.\\n\", path);\n\t\treturn -ENOENT;\n\t}\n\n\tinode = dent->d_inode;\n\n\t/* get rid of current memory areas */\n\tfor (i = 0; i < thread->map->m_nmma; i++) {\n\t\tmem_area_put(thread->map->m_mma[i]);\n\t\tthread->map->m_mma[i] = NULL;\n\t}\n\n\tthread->map->m_nmma = 0;\n\n\ti = thread_exec_new(thread, inode);\n\tif (i) return i;\n\n\t/* rename the thread accordingly */\n\tsnprintf(thread->name, THREAD_NAME_LEN, path);\n\n\tif (thread == CURRENT()) {\n\t\t/* ensure TLB flush since the mapping has changed badly */\n\t\tswitch_map(CURRENT()->map, thread->map);\n\t\tuser_thread(NULL);\n\t} else\n\t\tthread_init_stack(thread, user_thread, NULL);\n\t\n\treturn 0;\n}", "path": "kernel\\exec.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Create and open a communication pipe\n * name -- name of a pipe to be created; its absolute pathname\n *         will be /koowaldah/srv/<name>\n * returns fd number upon success, otherwise\n *         -EBUSY  == entry with this name already exists\n *         -ENOMEM == unable to allocate enough memory\n */\n", "func_signal": "int mpipe_open(char *name)", "code": "{\n\tstruct virtfs_entry *ve;\n\tstruct file *file;\n\tstruct direntry *dent;\n\tchar pathname[FILENAME_MAX];\n\tsize_t name_len = kstrlen_(name);\n\tstruct thread *thread;\n\tstruct mpipe_ctl *mc;\n\n\t/* make sure the entry does not yet exist */\n\t/* XXX: we should be using srv's inode's ->lookup() instead,\n\t * that is, we should reliably make sure the inode's there */\n\tsnprintf(pathname, FILENAME_MAX, \"/koowaldah/srv/%s\", name);\n\tdent = lookup_path(pathname);\n\tif (dent) {\n\t\trelease_direntry(dent);\n\t\treturn -EBUSY;\n\t}\n\n\t/* setup a virtfs_entry for the pipe */\n\tve = new_ve();\n\tif (!ve)\n\t\treturn -ENOMEM;\n\n\tmemory_copy(ve->ve_name, name, name_len);\n\tve->ve_mode = S_IFIFO;\n\tve->ve_dev = NODEV;\n\tve->ve_ops = &veops_nop;\n\n\t/* this is not in open() call path, so we have to do it manually */\n\tfile = new_file();\n\tif (!file) {\n\t\tfree_ve(ve);\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = slice_alloc(mpipe_pool);\n\tif (!mc) {\n\t\tfree_ve(ve);\n\t\tkill_file(file);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* insert our new pipe into virtfs directory */\n\tVE_ADD_SIBLING(&virtfs_srv, ve);\n\n\tthread = CURRENT();\n\tdent = lookup_path(pathname);\n\n\t/* this part could be taken out, it's fairly close to what open()\n\t * does to 'struct file' */\n\tklist0_append(&file->f_tlist, &thread->files);\n\tfile->f_fd = thread->last_fd++;\n\tfile->f_inode = dent->d_inode;\n\tfile->f_sb = dent->d_inode->i_sb;\n\tfile->f_offset = 0;\n\tfile->f_ops = &mpipe_fops;\n\tfile->f_inode->i_size = 1; /* something's broken up there */\n\tfile->f_inode->i_fops = &mpipe_fops; /* for clients */\n\tfile->f_inode->i_ctl = mc;\n\n\t/* initialize the control structure */\n\ttq_init(&mc->tq);\n\tmc->len = 0;\n\tmc->buf = NULL;\n\tmc->state = MC_OPENED;\n\tmutex_init(&mc->mutex);\n\n\treturn file->f_fd;\n}", "path": "kernel\\fs\\mpipe.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* Add padding and return the message digest. */\n", "func_signal": "void SHA1Final(unsigned char digest[20], SHA1_CTX* context)", "code": "{\nuint32_t i;\t/* JHB */\nunsigned char finalcount[8];\n\n    for (i = 0; i < 8; i++) {\n        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]\n         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */\n    }\n    SHA1Update(context, (unsigned char *)\"\\200\", 1);\n    while ((context->count[0] & 504) != 448) {\n        SHA1Update(context, (unsigned char *)\"\\0\", 1);\n    }\n    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform()\n*/\n    for (i = 0; i < 20; i++) {\n        digest[i] = (unsigned char)\n         ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);\n    }\n    /* Wipe variables */\n    i = 0;\t/* JHB */\n    memset(context->buffer, 0, 64);\n    memset(context->state, 0, 20);\n    memset(context->count, 0, 8);\n    memset(finalcount, 0, 8);\t/* SWR */\n#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite it's own static vars */\n    SHA1Transform(context->state, context->buffer);\n#endif\n}", "path": "usr\\klibc\\sha1hash.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Load a binary: stub for trying to load different binary formats\n */\n", "func_signal": "static int binary_load(struct inode *inode, struct mapping *map)", "code": "{\n\tint ret = -ENOEXEC;\n\n\t/*\n\t * dummy doesn't support non-relocatable executables and\n\t * koowaldah doesn't support relocatable aouts\n\t */\n#ifdef OPT_AOUT_SUPPORT\n\tif (ret)\n\t\tret = aout_load(inode, map);\n#endif\n\n\treturn ret;\n}", "path": "kernel\\exec.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Initialize FS and create rootfs\n *\n * ROOTFS:\n *  /dev\n *  /dev/console\n *  /initfs\n *  /mnt\n *  /koowaldah\n */\n", "func_signal": "void __init fs_init()", "code": "{\n\tstruct superblock *sb;\n\tstruct inode *root;\n\tstruct inode *p;\n\n\tfs_init_super();\n\tfs_init_inodes();\n\tfs_init_namespace();\n\tfs_init_mount();\n\n\tsb = get_super(ROOTFSDEV);\n\tsb->s_ops->read_inode = fs_read_inode;\n\tsb->s_ops->write_inode = fs_write_inode;\n\troot = sb->s_root;\n\n\tp = fs_add_entry(root, \"dev\", S_IFDIR, NODEV);\n\tfs_add_entry(p, \"tty0\", S_IFCHR, DEV_DEVICE(4, 0));\n\tfs_add_entry(p, \"pckbd\", S_IFCHR, DEV_DEVICE(13, 128));\n\tfs_add_entry(p, \"serial\", S_IFCHR, DEV_DEVICE(12, 34));\n\tp = fs_add_entry(root, \"initfs\", S_IFDIR, NODEV);\n\tp = fs_add_entry(root, \"mnt\", S_IFDIR, NODEV);\n\tp = fs_add_entry(root, \"koowaldah\", S_IFDIR, NODEV);\n\n\tcpio_read();\n\tdevices_init();\n\tmessaging_init();\n\tfs_init_virtfs();\n}", "path": "kernel\\fs\\fs.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* FIXME: This should look for multiplication overflow */\n", "func_signal": "void *calloc(size_t nmemb, size_t size)", "code": "{\n\tvoid *ptr;\n\n\tsize *= nmemb;\n\tptr = malloc(size);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\n\treturn ptr;\n}", "path": "usr\\klibc\\calloc.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * This function starts in kernel on userspace thread's behalf\n * to prepare stacks and registers and jump to userspace.\n * Clobbers it's own stack frame, never returns.\n */\n", "func_signal": "static void __noreturn user_thread(void *data)", "code": "{\n\tuintptr_t start = CURRENT()->map->m_mma[0]->m_start;\n\t/* disregard everything on the current stack\n\t * as start_user() never returns */\n\treset_stack();\n\tstart_user(start,\n\t\t\tUSERMEM_STACK - 4,\n\t\t\tUSERMEM_STACK - 4,\n\t\t\t0);\n\tbug();\n}", "path": "kernel\\exec.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* OPT_TEST_IRQS */\n", "func_signal": "void test_irqs()", "code": "{\n#ifdef OPT_TEST_IRQS\n        kprintf(\"Registering dummy keyboard interrupt service routine...\");\n        register_irq_handler(1, keyboard_irq_handler);\n        kprintf(\"Done\\n\");\n#endif /* OPT_TEST_IRQS */\n}", "path": "kernel\\init\\test_irqs.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/* SAK */\n", "func_signal": "void SHAPrintContext(SHA1_CTX *context, char *msg)", "code": "{\n  printf(\"%s (%d,%d) %x %x %x %x %x\\n\",\n\t msg,\n\t context->count[0], context->count[1],\n\t context->state[0],\n\t context->state[1],\n\t context->state[2],\n\t context->state[3],\n\t context->state[4]);\n}", "path": "usr\\klibc\\sha1hash.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "/*\n * Load a binary with given path into a thread\n * @thread -- thread to be blessed\n * @inode  -- inode containing the executable\n * Note: it is strongly advised to remove any existing mem_area objects\n *       from the thread's mapping before calling this.\n */\n", "func_signal": "int thread_exec_new(struct thread *thread, struct inode *inode)", "code": "{\n\tstruct mapping *map = thread->map;\n\tint ret;\n\n\t/* load the binary\n\t * this normally allocates 2 mmas: .text and .data [0] [1] */\n\tret = binary_load(inode, map);\n\tif (ret)\n\t\treturn ret;\n\t\n\t/* allocate stack [2] */\n\tmap->m_mma[map->m_nmma] = mem_area_alloc_new(map,\n\t\t\tUSERMEM_STACK, 1, MMA_RW | MMA_STACK);\n\tmap->m_mma[map->m_nmma]->m_sizelim = USERMEM_STACKLIM;\n\tmap->m_nmma++;\n\t\n\t/* allocate heap [3] */\n\tmap->m_mma[map->m_nmma] = mem_area_alloc_new(map,\n\t\t\tUSERMEM_HEAP, 1, MMA_RW | MMA_GROWS);\n\tmap->m_nmma++;\n\n\treturn 0;\n}", "path": "kernel\\exec.c", "repo_name": "virtuoso/koowaldah", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 1938}
{"docstring": "//  >\n", "func_signal": "object *h_greater_than(object *obj_1, object *obj_2)", "code": "{\n  if (obj_1->type != obj_2->type) {\n    error(\"Types must match\");\n  }\n\n  if (obj_1->type == BOOLEAN) {\n    if (obj_1 == obj_2) {return False;}\n    else if (obj_1 == True) {return True;}\n    else if (obj_1 == False) {return False;}\n  }\n\n  else if (obj_1->type == FIXNUM) {\n    return (obj_1->data.fixnum > obj_2->data.fixnum) ?\n            True : False;\n  }\n\n  else if (obj_1->type == FLONUM) {\n    return (obj_1->data.flonum > obj_2->data.flonum) ?\n            True : False;\n  }\n\n  else if (obj_1->type == CHARACTER) {\n    return (obj_1->data.character > obj_2->data.character) ?\n            True : False;\n  }\n  \n  else if (obj_1->type == SYMBOL) {\n    return (strcmp(obj_1->data.symbol, \n                   obj_2->data.symbol) == 1) ?\n            True : False;\n  }\n\n  else if (obj_1->type == STRING) {\n    return (strcmp(obj_1->data.string, \n                   obj_2->data.string) == 1) ?\n            True : False;\n  }\n\n  else if (obj_1->type == PAIR) {\n    if (h_length(obj_1)->data.fixnum == h_length(obj_2)->data.fixnum) {\n      while (obj_1 != the_empty_list) {\n        if (h_equalp(car(obj_1), car(obj_2)) == True) {\n          obj_1 = cdr(obj_1);\n          obj_2 = cdr(obj_2);\n        }\n        else if (h_greater_than(car(obj_1), car(obj_2)) == True) {\n          return True;\n        }\n        else {\n          return False;\n        }\n      }\n      return False;\n    }\n    \n    else if (h_length(obj_1)->data.fixnum > h_length(obj_2)->data.fixnum) {\n      return True;\n    }\n    else {\n      return False;\n    }\n  }\n\n  else if (obj_1->type == VECTOR) {\n    error(\"> on vectors not implemented yet\");\n  }\n\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  rest\n", "func_signal": "object *h_rest(object *seq)", "code": "{\n  switch (seq->type) {\n    case PAIR:\n      return cdr(seq);\n      break;\n    case STRING:\n      return make_string(&seq->data.string[1]);\n      break;\n    case VECTOR:\n      return make_vector_from_vector(seq, 1, seq->data.vector.length);\n      //error(\"rest on vectors not implemented yet\");\n      break;\n    default:\n      error(\"Unsupported type for rest\");\n      break;\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// CHARACTERs\n//___________________________________//\n", "func_signal": "object *make_character(char value)", "code": "{\n  object *obj;\n  \n  obj = alloc_object();\n  obj->type = CHARACTER;\n  obj->data.character = value;\n  return obj;\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// eval\n//___________________________________//\n", "func_signal": "object *eval(object *exp, object *env)", "code": "{\n  object *procedure;\n  object *arguments;\n\ntailcall:\n\n  switch (exp->type) {\n    case BOOLEAN:\n    case FIXNUM:\n    case FLONUM:\n    case CHARACTER:\n    case STRING:\n    case VOID:\n      return exp;\n    case SYMBOL:\n      return lookup_variable_value(exp, env);\n    case PAIR:\n      procedure = car(exp);\n      \n      if (procedure == quote_symbol) {\n        return cadr(exp);\n      }\n      else if (procedure == set_symbol) {\n        set_variable_value(assignment_variable(exp),\n                           eval(assignment_value(exp), env),\n                           env);\n        return Void;\n\n      }\n      else if (procedure == define_symbol) {\n        define_variable(definition_variable(exp),\n                        eval(definition_value(exp), env),\n                        env);\n        return Void;\n      }\n      else if (procedure == if_symbol) {\n        exp = is_true(eval(cadr(exp), env)) ?\n                caddr(exp) :\n                // Handle (if test consequent else alternative)\n                (cadddr(exp) == else_symbol) ?\n                  caddddr(exp) :\n                  cadddr(exp);\n        goto tailcall;\n      }\n      else if (procedure == cond_symbol) {\n        exp = make_cond(cdr(exp));\n        goto tailcall;\n      }\n      else if (procedure == lambda_symbol) {\n        // Check for presence of a docstring\n        if (caddr(exp)->type == STRING) {\n          return make_compound_procedure(cadr(exp), cdddr(exp), env, caddr(exp));\n        }\n        else {\n          return make_compound_procedure(cadr(exp), cddr(exp), env, make_string(\"No docstring\"));\n        }\n      }\n      else if (procedure == begin_symbol) {\n        exp = cdr(exp);\n        while (!is_last_exp(exp)) {\n          eval(car(exp), env);\n          exp = cdr(exp);\n        }\n        exp = car(exp);\n        goto tailcall;\n      }\n      else if (procedure == let_symbol) {\n        exp = make_let(cdr(exp));\n        goto tailcall;\n      }\n      else if (procedure == and_symbol) {\n        object *args = cdr(exp);\n        object *e;\n        while (args != the_empty_list) {\n          e = eval(car(args), env);\n          if (e == False) {\n            return False;\n          }\n          args = cdr(args);\n        }\n        return e;\n      }\n      else if (procedure == or_symbol) {\n        object *result;\n        exp = cdr(exp);\n        while (exp != the_empty_list) {\n          result = eval(car(exp), env);\n          if (result == False) {\n            exp = cdr(exp);\n          }\n          else {\n            return result;\n          }\n        }\n        return False;\n      }\n      else if (procedure == apply_symbol) {\n        exp = cons(cadr(exp), eval(caddr(exp), env));\n        goto tailcall;\n      }\n      else if (procedure == eval_symbol) {\n        if (cddr(exp) != the_empty_list) {\n          env = eval(caddr(exp), env);\n          exp = eval(cadr(exp), env);\n          goto tailcall;\n        }\n        else {\n          exp = eval(cadr(exp), env);\n          goto tailcall;\n        }\n      }\n      else if (procedure == define_macro_symbol) {\n        define_variable(cadr(exp), make_macro(caddr(exp)), env);\n        return Void;\n        \n      }\n      else if (procedure == test_symbol) {\n        return test(cdr(exp));\n        \n      }\n      else if (procedure == list_symbol) {\n        return h_list(cdr(exp), env);\n      }\n      else if (procedure == string_symbol) {\n        return h_string(cdr(exp), env);\n      }\n      else if (procedure == vector_symbol) {\n        return h_vector(cdr(exp), env);\n      }\n      else if (procedure == for_symbol) {\n        return h_for(cdr(exp), env);\n      }\n      else {\n        procedure = eval(procedure, env);\n        switch (procedure->type) {\n          case PRIMITIVE_PROCEDURE:\n            return (procedure->data.primitive_procedure.fn)(list_of_values(cdr(exp), env));\n          case COMPOUND_PROCEDURE:\n            env = extend_environment(procedure->data.compound_procedure.parameters,\n                                    eval_arguments(cdr(exp), env, procedure->data.compound_procedure.parameters),\n                                    procedure->data.compound_procedure.env);\n            \n            // Transform lambda body into begin form\n            exp = cons(begin_symbol, procedure->data.compound_procedure.body);\n            goto tailcall;\n            break;\n          case MACRO:\n            // Expand macro by passing the arguments to the transformer unevaluated\n            exp =  eval(cons(procedure->data.macro.transformer, \n                            cons(quote_macro_arguments(cdr(exp)),\n                                  the_empty_list)),\n                        env);\n            goto tailcall;\n            break;\n        }\n      }\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  display\n", "func_signal": "object *p_display(object *arguments)", "code": "{\n  while (!is_the_empty_list(arguments)) {\n    object *obj;\n    \n    obj = car(arguments);\n    switch (obj->type) {\n      case STRING:\n        printf(\"%s\", obj->data.string);\n        break;\n      case CHARACTER:\n        printf(\"%c\", obj->data.character);\n        break;\n      default:\n        write(obj);\n    }\n    arguments = cdr(arguments);\n  }\n  return Void;\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// REPL\n//___________________________________//\n", "func_signal": "void REPL(void)", "code": "{\n  object *input;\n  object *output;\n  \n  while (1) {\n    printf(\"> \");\n    input = lispy_read(stdin);\n    output = eval(input, the_global_environment);\n    if (output != Void) {\n      write(output);\n      printf(\"\\n\");\n    }\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// eval arguments\n//___________________________________//\n", "func_signal": "object *list_of_values(object *exps, object *env)", "code": "{\n  if (is_the_empty_list(exps)) {\n    return the_empty_list;\n  }\n  else {\n    return cons(eval(car(exps), env),\n                list_of_values(cdr(exps), env));\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  **\n", "func_signal": "object *p_pow(object *args)", "code": "{\n  object *o = car(args);\n  object *p = cadr(args);\n  switch (o->type) {\n    case FIXNUM:\n      switch (p->type) {\n        case FIXNUM:\n          return make_fixnum(pow(o->data.fixnum, p->data.fixnum));\n        case FLONUM:\n          return make_flonum(pow(o->data.fixnum, p->data.flonum));\n      }\n    case FLONUM:\n      switch (p->type) {\n        case FIXNUM:\n          return make_flonum(pow(o->data.flonum, p->data.fixnum));\n        case FLONUM:\n          return make_flonum(pow(o->data.flonum, p->data.flonum));\n      }\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  list\n", "func_signal": "object *h_list_for(object *exp, object *env)", "code": "{\n  object *result_list = the_empty_list;\n  object *var = car(exp);\n  exp = cddr(exp);\n  object *seq = eval(car(exp), env);\n  exp = cdr(exp);\n  object *expression;\n  object *test;\n    \n  // (list for ii in sequence if test expression)\n  if (car(exp) == if_symbol) {\n    test = make_loop_body(cons(cadr(exp), the_empty_list), var);\n    expression = make_loop_body(cddr(exp), var);\n    while (h_emptyp(seq) != True) {\n      if (eval(apply_loop_body(test, h_first(seq)), env) == True) {\n        result_list = cons(eval(apply_loop_body(expression, h_first(seq)), env), \n                           result_list);\n        seq = h_rest(seq);\n      }\n      else {\n        seq = h_rest(seq);\n      }\n    }\n    return h_reverse(result_list);\n  }\n\n  // (list for ii in sequence expression)\n  else {\n    expression = make_loop_body(exp, var);\n    while (h_emptyp(seq) != True) {\n      result_list = cons(eval(apply_loop_body(expression, h_first(seq)), env), \n                          result_list);\n      seq = h_rest(seq);\n    }\n    return h_reverse(result_list);\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// system\n", "func_signal": "object *p_system(object *args)", "code": "{\n  int retval = system(car(args)->data.string);\n  return make_fixnum(retval);\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// Remove Whitespace\n//___________________________________//\n", "func_signal": "void remove_whitespace(FILE *in)", "code": "{\n  int c;\n    \n  while ((c = getc(in)) != EOF) {\n    if (isspace(c)) {\n      continue;\n    }\n    else if (c == ';') { // comments are whitespace also\n      while (((c = getc(in)) != EOF) && (c != '\\n'));\n      continue;\n    }\n    ungetc(c, in);\n    break;\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  m-seconds\n", "func_signal": "object *p_m_seconds(object *arguments)", "code": "{\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  return make_flonum(tv.tv_sec + (tv.tv_usec / 1000000.0));\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// PAIRs\n//___________________________________//\n", "func_signal": "object *cons(object *car, object *cdr)", "code": "{\n  object *obj;\n  \n  obj = alloc_object();\n  obj->type = PAIR;\n  obj->data.pair.car = car;\n  obj->data.pair.cdr = cdr;\n  return obj;\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// VECTORs\n//___________________________________//\n", "func_signal": "object *make_vector_from_list(object *exp)", "code": "{\n  object *obj;\n  long int len = h_length(exp)->data.fixnum;\n  long int count = 0;\n  \n  obj = alloc_object();\n  obj->type = VECTOR;\n  obj->data.vector.length = len;\n  obj->data.vector.vec = GC_MALLOC(len);\n  if (obj->data.vector.vec == NULL) {\n    error(\"out of memory\\n\");\n  }\n\n  while (exp != the_empty_list) {\n    obj->data.vector.vec[count] = car(exp);\n    exp = cdr(exp);\n    count += 1;\n  }\n\n  return obj;\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  index\n", "func_signal": "object *h_index_list(object *lst, int start, int end, int rev)", "code": "{\n  int count = 0;\n  object *sublist = the_empty_list;\n  \n  // Find first index\n  while (count != start) {\n    count += 1;\n    lst = cdr(lst);\n  }\n  \n  // If we're only getting one index\n  if (start == end) {\n    return car(lst);\n  }\n  \n  // If we're getting a sublist\n  else {\n    while (count != end) {\n      sublist = cons(car(lst), sublist);\n      count += 1;\n      lst = cdr(lst);\n    }\n    if (rev) {\n      return sublist;\n    }\n    else {\n      return h_reverse(sublist);\n    }\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "// FLONUMs\n//___________________________________//\n", "func_signal": "object *make_flonum(double value)", "code": "{\n  object *obj;\n\n  obj = alloc_object();\n  obj->type = FLONUM;\n  obj->data.flonum = value;\n  return obj;\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  <\n", "func_signal": "object *h_less_than(object *obj_1, object *obj_2)", "code": "{\n  if (obj_1->type != obj_2->type) {\n    error(\"Types must match\");\n  }\n\n  if (obj_1->type == BOOLEAN) {\n    if (obj_1 == obj_2) {return True;}\n    else if (obj_1 == True) {return False;}\n    else if (obj_1 == False) {return True;}\n  }\n\n  else if (obj_1->type == FIXNUM) {\n    return (obj_1->data.fixnum < obj_2->data.fixnum) ?\n            True : False;\n  }\n\n  else if (obj_1->type == FLONUM) {\n    return (obj_1->data.flonum < obj_2->data.flonum) ?\n            True : False;\n  }\n\n  else if (obj_1->type == CHARACTER) {\n    return (obj_1->data.character < obj_2->data.character) ?\n            True : False;\n  }\n\n  else if (obj_1->type == SYMBOL) {\n    return (strcmp(obj_1->data.symbol, \n                   obj_2->data.symbol) == -1) ?\n            True : False;\n  }\n  \n  else if (obj_1->type == STRING) {\n    return (strcmp(obj_1->data.string, \n                   obj_2->data.string) == -1) ?\n            True : False;\n  }\n  \n  else if (obj_1->type == PAIR) {\n    if (h_length(obj_1)->data.fixnum == h_length(obj_2)->data.fixnum) {\n      while (obj_1 != the_empty_list) {\n        if (h_equalp(car(obj_1), car(obj_2)) == True) {\n          obj_1 = cdr(obj_1);\n          obj_2 = cdr(obj_2);\n        }\n        else if (h_less_than(car(obj_1), car(obj_2)) == True) {\n          return True;\n        }\n        else {\n          return False;\n        }\n      }\n      return False;\n    }\n    \n    else if (h_length(obj_1)->data.fixnum < h_length(obj_2)->data.fixnum) {\n      return True;\n    }\n    else {\n      return False;\n    }\n  }\n\n  else if (obj_1->type == VECTOR) {\n    error(\"< on vectors not implemented yet\");\n  }\n\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  +\n", "func_signal": "object *h_numeric_add(object *obj_1, object *obj_2)", "code": "{\n  switch (obj_1->type) {\n    case FLONUM:\n      switch (obj_2->type) {\n        case FLONUM:\n          return make_flonum(obj_1->data.flonum + obj_2->data.flonum);\n        case FIXNUM:\n          return make_flonum(obj_1->data.flonum + obj_2->data.fixnum);\n      }\n    case FIXNUM:\n      switch (obj_2->type) {\n        case FLONUM:\n          return make_flonum(obj_1->data.fixnum + obj_2->data.flonum);\n        case FIXNUM:\n          return make_fixnum(obj_1->data.fixnum + obj_2->data.fixnum);\n      }\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  equal?\n", "func_signal": "object *h_equalp(object *obj_1, object *obj_2)", "code": "{\n  int count = 0;\n  object *result;\n  object *temp_1;\n  object *temp_2;\n  \n  if (obj_1->type != obj_2->type) {\n    return False;\n  }\n\n  switch (obj_1->type) {\n    case VOID:\n    case THE_EMPTY_LIST:\n      return True;\n      break;\n    \n    case FIXNUM:\n      return (obj_1->data.fixnum == \n              obj_2->data.fixnum) ? \n              True : False;\n      break;\n    \n    case FLONUM:\n      return (obj_1->data.flonum ==\n              obj_2->data.flonum) ?\n              True : False;\n      break;\n      \n    case CHARACTER:\n      return (obj_1->data.character ==\n              obj_2->data.character) ?\n              True : False;\n      break;\n    \n    case SYMBOL:\n      return (obj_1->data.symbol ==\n              obj_2->data.symbol) ?\n              True : False;\n      break;\n    \n    case PRIMITIVE_PROCEDURE:\n    case COMPOUND_PROCEDURE:\n    case BOOLEAN:\n      return (obj_1 == obj_2) ? True : False;\n    \n    case STRING:\n      return !strcmp(obj_1->data.string, obj_2->data.string) ? \n             True : False;\n      break;\n    \n    case PAIR:\n      if (h_length(obj_1)->data.fixnum != \n          h_length(obj_2)->data.fixnum) {\n        return False;}\n      while (obj_1 != the_empty_list) {\n        if (h_equalp(car(obj_1), car(obj_2)) == True) {\n          obj_1 = cdr(obj_1);\n          obj_2 = cdr(obj_2);\n        }\n        else {\n          return False;\n        }\n      }\n      return True;\n\n    //BUG: Equal vectors do not compare equal.\n    case VECTOR:\n      printf(\"Count: %i\\n\", count);\n      if (obj_1->data.vector.length != obj_2->data.vector.length) {\n        return False;\n      }\n      while (count < obj_1->data.vector.length) {\n        if (h_equalp(obj_1->data.vector.vec[count],\n                     obj_2->data.vector.vec[count]) == False) {\n          //printf(\"Vector index %i not equal\\n\", count);\n          printf(\"Vector 1: \"); write(obj_1->data.vector.vec[count]); printf(\"\\n\");\n          printf(\"Vector 2: \"); write(obj_2->data.vector.vec[count]); printf(\"\\n\");\n          return False;\n        }\n        count += 1;\n      }\n      return True;\n      \n    default:\n      error(\"Unsupported types for equal?\");\n  }\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "//  null?\n", "func_signal": "object *p_nullp(object *arguments)", "code": "{\n  if (is_the_empty_list(car(arguments))) {\n    return True;}\n  else {return False;}\n}", "path": "lispy.c", "repo_name": "ellamental/Lispy", "stars": 10, "license": "agpl-3.0", "language": "c", "size": 192}
{"docstring": "/*\n * Emulate the single floating point instruction pointed at by EPC.\n * Two instructions if the instruction is in a branch delay slot.\n */\n", "func_signal": "static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx)", "code": "{\n\tmips_instruction ir;\n\tunsigned long emulpc, contpc;\n\tunsigned int cond;\n\n\tif (get_user(ir, (mips_instruction __user *) xcp->cp0_epc)) {\n\t\tfpuemustats.errors++;\n\t\treturn SIGBUS;\n\t}\n\n\t/* XXX NEC Vr54xx bug workaround */\n\tif ((xcp->cp0_cause & CAUSEF_BD) && !isBranchInstr(&ir))\n\t\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\tif (xcp->cp0_cause & CAUSEF_BD) {\n\t\t/*\n\t\t * The instruction to be emulated is in a branch delay slot\n\t\t * which means that we have to  emulate the branch instruction\n\t\t * BEFORE we do the cop1 instruction.\n\t\t *\n\t\t * This branch could be a COP1 branch, but in that case we\n\t\t * would have had a trap for that instruction, and would not\n\t\t * come through this route.\n\t\t *\n\t\t * Linux MIPS branch emulator operates on context, updating the\n\t\t * cp0_epc.\n\t\t */\n\t\temulpc = xcp->cp0_epc + 4;\t/* Snapshot emulation target */\n\n\t\tif (__compute_return_epc(xcp)) {\n#ifdef CP1DBG\n\t\t\tprintk(\"failed to emulate branch at %p\\n\",\n\t\t\t\t(void *) (xcp->cp0_epc));\n#endif\n\t\t\treturn SIGILL;\n\t\t}\n\t\tif (get_user(ir, (mips_instruction __user *) emulpc)) {\n\t\t\tfpuemustats.errors++;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\t/* __compute_return_epc() will have updated cp0_epc */\n\t\tcontpc = xcp->cp0_epc;\n\t\t/* In order not to confuse ptrace() et al, tweak context */\n\t\txcp->cp0_epc = emulpc - 4;\n\t} else {\n\t\temulpc = xcp->cp0_epc;\n\t\tcontpc = xcp->cp0_epc + 4;\n\t}\n\n      emul:\n\tfpuemustats.emulated++;\n\tswitch (MIPSInst_OPCODE(ir)) {\n\tcase ldc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tfpuemustats.loads++;\n\t\tif (get_user(val, va)) {\n\t\t\tfpuemustats.errors++;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tDITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase sdc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tfpuemustats.stores++;\n\t\tDIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (put_user(val, va)) {\n\t\t\tfpuemustats.errors++;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase lwc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tfpuemustats.loads++;\n\t\tif (get_user(val, va)) {\n\t\t\tfpuemustats.errors++;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tSITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase swc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tfpuemustats.stores++;\n\t\tSIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (put_user(val, va)) {\n\t\t\tfpuemustats.errors++;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase cop1_op:\n\t\tswitch (MIPSInst_RS(ir)) {\n\n#if defined(__mips64)\n\t\tcase dmfc_op:\n\t\t\t/* copregister fs -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tDIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase dmtc_op:\n\t\t\t/* copregister fs <- rt */\n\t\t\tDITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n#endif\n\n\t\tcase mfc_op:\n\t\t\t/* copregister rd -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tSIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase mtc_op:\n\t\t\t/* copregister rd <- rt */\n\t\t\tSITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n\n\t\tcase cfc_op:{\n\t\t\t/* cop control register rd -> gpr[rt] */\n\t\t\tu32 value;\n\n\t\t\tif (ir == CP1UNDEF) {\n\t\t\t\treturn do_dsemulret(xcp);\n\t\t\t}\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n\t\t\t\tvalue = ctx->fcr31;\n\t\t\t\tvalue = (value & ~0x3) | mips_rm[value & 0x3];\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]<-csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\t\t\t}\n\t\t\telse if (MIPSInst_RD(ir) == FPCREG_RID)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t\tif (MIPSInst_RT(ir))\n\t\t\t\txcp->regs[MIPSInst_RT(ir)] = value;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ctc_op:{\n\t\t\t/* copregister rd <- rt */\n\t\t\tu32 value;\n\n\t\t\tif (MIPSInst_RT(ir) == 0)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = xcp->regs[MIPSInst_RT(ir)];\n\n\t\t\t/* we only have one writable control reg\n\t\t\t */\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]->csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\t\t\t\tvalue &= (FPU_CSR_FLUSH | FPU_CSR_ALL_E | FPU_CSR_ALL_S | 0x03);\n\t\t\t\tctx->fcr31 &= ~(FPU_CSR_FLUSH | FPU_CSR_ALL_E | FPU_CSR_ALL_S | 0x03);\n\t\t\t\t/* convert to ieee library modes */\n\t\t\t\tctx->fcr31 |= (value & ~0x3) | ieee_rm[value & 0x3];\n\t\t\t}\n\t\t\tif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\n\t\t\t\treturn SIGFPE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase bc_op:{\n\t\t\tint likely = 0;\n\n\t\t\tif (xcp->cp0_cause & CAUSEF_BD)\n\t\t\t\treturn SIGILL;\n\n#if __mips >= 4\n\t\t\tcond = ctx->fcr31 & fpucondbit[MIPSInst_RT(ir) >> 2];\n#else\n\t\t\tcond = ctx->fcr31 & FPU_CSR_COND;\n#endif\n\t\t\tswitch (MIPSInst_RT(ir) & 3) {\n\t\t\tcase bcfl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bcf_op:\n\t\t\t\tcond = !cond;\n\t\t\t\tbreak;\n\t\t\tcase bctl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bct_op:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* thats an illegal instruction */\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\n\t\t\txcp->cp0_cause |= CAUSEF_BD;\n\t\t\tif (cond) {\n\t\t\t\t/* branch taken: emulate dslot\n\t\t\t\t * instruction\n\t\t\t\t */\n\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\tcontpc = (xcp->cp0_epc +\n\t\t\t\t\t(MIPSInst_SIMM(ir) << 2));\n\n\t\t\t\tif (get_user(ir,\n\t\t\t\t    (mips_instruction __user *) xcp->cp0_epc)) {\n\t\t\t\t\tfpuemustats.errors++;\n\t\t\t\t\treturn SIGBUS;\n\t\t\t\t}\n\n\t\t\t\tswitch (MIPSInst_OPCODE(ir)) {\n\t\t\t\tcase lwc1_op:\n\t\t\t\tcase swc1_op:\n#if (__mips >= 2 || defined(__mips64))\n\t\t\t\tcase ldc1_op:\n\t\t\t\tcase sdc1_op:\n#endif\n\t\t\t\tcase cop1_op:\n#if __mips >= 4 && __mips != 32\n\t\t\t\tcase cop1x_op:\n#endif\n\t\t\t\t\t/* its one of ours */\n\t\t\t\t\tgoto emul;\n#if __mips >= 4\n\t\t\t\tcase spec_op:\n\t\t\t\t\tif (MIPSInst_FUNC(ir) == movc_op)\n\t\t\t\t\t\tgoto emul;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Single step the non-cp1\n\t\t\t\t * instruction in the dslot\n\t\t\t\t */\n\t\t\t\treturn mips_dsemul(xcp, ir, contpc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* branch not taken */\n\t\t\t\tif (likely) {\n\t\t\t\t\t/*\n\t\t\t\t\t * branch likely nullifies\n\t\t\t\t\t * dslot if not taken\n\t\t\t\t\t */\n\t\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\t\tcontpc += 4;\n\t\t\t\t\t/*\n\t\t\t\t\t * else continue & execute\n\t\t\t\t\t * dslot as normal insn\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tif (!(MIPSInst_RS(ir) & 0x10))\n\t\t\t\treturn SIGILL;\n\t\t\t{\n\t\t\t\tint sig;\n\n\t\t\t\t/* a real fpu computation instruction */\n\t\t\t\tif ((sig = fpu_emu(xcp, ctx, ir)))\n\t\t\t\t\treturn sig;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#if __mips >= 4 && __mips != 32\n\tcase cop1x_op:{\n\t\tint sig;\n\n\t\tif ((sig = fpux_emu(xcp, ctx, ir)))\n\t\t\treturn sig;\n\t\tbreak;\n\t}\n#endif\n\n#if __mips >= 4\n\tcase spec_op:\n\t\tif (MIPSInst_FUNC(ir) != movc_op)\n\t\t\treturn SIGILL;\n\t\tcond = fpucondbit[MIPSInst_RT(ir) >> 2];\n\t\tif (((ctx->fcr31 & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))\n\t\t\txcp->regs[MIPSInst_RD(ir)] =\n\t\t\t\txcp->regs[MIPSInst_RS(ir)];\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\t/* we did it !! */\n\txcp->cp0_epc = contpc;\n\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\treturn 0;\n}", "path": "arch\\mips\\math-emu\\cp1emu.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* Interrupt handler may be called before rtlx_init has otherwise had\n   a chance to run.\n*/\n", "func_signal": "static irqreturn_t rtlx_interrupt(int irq, void *dev_id)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < RTLX_CHANNELS; i++) {\n\t\t\twake_up(&channel_wqs[i].lx_queue);\n\t\t\twake_up(&channel_wqs[i].rt_queue);\n\t}\n\n\treturn IRQ_HANDLED;\n}", "path": "arch\\mips\\kernel\\rtlx.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* notifications */\n", "func_signal": "static void starting(int vpe)", "code": "{\n\tint i;\n\tsp_stopping = 0;\n\n\t/* force a reload of rtlx */\n\trtlx=NULL;\n\n\t/* wake up any sleeping rtlx_open's */\n\tfor (i = 0; i < RTLX_CHANNELS; i++)\n\t\twake_up_interruptible(&channel_wqs[i].lx_queue);\n}", "path": "arch\\mips\\kernel\\rtlx.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * Redundant with logic already in kernel/branch.c,\n * embedded in compute_return_epc.  At some point,\n * a single subroutine should be used across both\n * modules.\n */\n", "func_signal": "static int isBranchInstr(mips_instruction * i)", "code": "{\n\tswitch (MIPSInst_OPCODE(*i)) {\n\tcase spec_op:\n\t\tswitch (MIPSInst_FUNC(*i)) {\n\t\tcase jalr_op:\n\t\tcase jr_op:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tcase bcond_op:\n\t\tswitch (MIPSInst_RT(*i)) {\n\t\tcase bltz_op:\n\t\tcase bgez_op:\n\t\tcase bltzl_op:\n\t\tcase bgezl_op:\n\t\tcase bltzal_op:\n\t\tcase bgezal_op:\n\t\tcase bltzall_op:\n\t\tcase bgezall_op:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tcase j_op:\n\tcase jal_op:\n\tcase jalx_op:\n\tcase beq_op:\n\tcase bne_op:\n\tcase blez_op:\n\tcase bgtz_op:\n\tcase beql_op:\n\tcase bnel_op:\n\tcase blezl_op:\n\tcase bgtzl_op:\n\t\treturn 1;\n\n\tcase cop0_op:\n\tcase cop1_op:\n\tcase cop2_op:\n\tcase cop1x_op:\n\t\tif (MIPSInst_RS(*i) == bc_op)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}", "path": "arch\\mips\\math-emu\\cp1emu.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* call when we have the address of the shared structure from the SP side. */\n", "func_signal": "static int rtlx_init(struct rtlx_info *rtlxi)", "code": "{\n\tif (rtlxi->id != RTLX_ID) {\n\t\tprintk(KERN_ERR \"no valid RTLX id at 0x%p 0x%lx\\n\", rtlxi, rtlxi->id);\n\t\treturn -ENOEXEC;\n\t}\n\n\trtlx = rtlxi;\n\n\treturn 0;\n}", "path": "arch\\mips\\kernel\\rtlx.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * disabled_fph_fault() is called when a user-level process attempts to access f32..f127\n * and it doesn't own the fp-high register partition.  When this happens, we save the\n * current fph partition in the task_struct of the fpu-owner (if necessary) and then load\n * the fp-high partition of the current task (if necessary).  Note that the kernel has\n * access to fph by the time we get here, as the IVT's \"Disabled FP-Register\" handler takes\n * care of clearing psr.dfh.\n */\n", "func_signal": "static inline void\ndisabled_fph_fault (struct pt_regs *regs)", "code": "{\n\tstruct ia64_psr *psr = ia64_psr(regs);\n\n\t/* first, grant user-level access to fph partition: */\n\tpsr->dfh = 0;\n\n\t/*\n\t * Make sure that no other task gets in on this processor\n\t * while we're claiming the FPU\n\t */\n\tpreempt_disable();\n#ifndef CONFIG_SMP\n\t{\n\t\tstruct task_struct *fpu_owner\n\t\t\t= (struct task_struct *)ia64_get_kr(IA64_KR_FPU_OWNER);\n\n\t\tif (ia64_is_local_fpu_owner(current)) {\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn;\n\t\t}\n\n\t\tif (fpu_owner)\n\t\t\tia64_flush_fph(fpu_owner);\n\t}\n#endif /* !CONFIG_SMP */\n\tia64_set_local_fpu_owner(current);\n\tif ((current->thread.flags & IA64_THREAD_FPH_VALID) != 0) {\n\t\t__ia64_load_fpu(current->thread.fph);\n\t\tpsr->mfh = 0;\n\t} else {\n\t\t__ia64_init_fpu();\n\t\t/*\n\t\t * Set mfh because the state in thread.fph does not match the state in\n\t\t * the fph partition.\n\t\t */\n\t\tpsr->mfh = 1;\n\t}\n\tpreempt_enable_no_resched();\n}", "path": "arch\\ia64\\kernel\\traps.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_link(vp, dvp, name, crp)\n *\n * FUNCTION:\tcreate a link to <vp> by the name = <name>\n *\t\tin the parent directory <dvp>\n *\n * PARAMETER:\tvp\t- target object\n *\t\tdvp\t- parent directory of new link\n *\t\tname\t- name of new link to target object\n *\t\tcrp\t- credential\n *\n * RETURN:\tErrors from subroutines\n *\n * note:\n * JFS does NOT support link() on directories (to prevent circular\n * path in the directory hierarchy);\n * EPERM: the target object is a directory, and either the caller\n * does not have appropriate privileges or the implementation prohibits\n * using link() on directories [XPG4.2].\n *\n * JFS does NOT support links between file systems:\n * EXDEV: target object and new link are on different file systems and\n * implementation does not support links between file systems [XPG4.2].\n */\n", "func_signal": "static int jfs_link(struct dentry *old_dentry,\n\t     struct inode *dir, struct dentry *dentry)", "code": "{\n\tint rc;\n\ttid_t tid;\n\tstruct inode *ip = old_dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_link: %s %s\", old_dentry->d_name.name,\n\t\t dentry->d_name.name);\n\n\tif (ip->i_nlink == JFS_LINK_MAX)\n\t\treturn -EMLINK;\n\n\tif (ip->i_nlink == 0)\n\t\treturn -ENOENT;\n\n\ttid = txBegin(ip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\t/*\n\t * scan parent directory for entry/freespace\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE)))\n\t\tgoto free_dname;\n\n\t/*\n\t * create entry for new link in parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack)))\n\t\tgoto free_dname;\n\n\t/* update object inode */\n\tinc_nlink(ip);\t\t/* for new link */\n\tip->i_ctime = CURRENT_TIME;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\tatomic_inc(&ip->i_count);\n\n\tiplist[0] = ip;\n\tiplist[1] = dir;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\tif (rc) {\n\t\tip->i_nlink--; /* never instantiated */\n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      free_dname:\n\tfree_UCSname(&dname);\n\n      out:\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\n\tjfs_info(\"jfs_link: rc:%d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tcommitZeroLink()\n *\n * FUNCTION:\tfor non-directory, called by jfs_remove(),\n *\t\ttruncate a regular file, directory or symbolic\n *\t\tlink to zero length. return 0 if type is not\n *\t\tone of these.\n *\n *\t\tif the file is currently associated with a VM segment\n *\t\tonly permanent disk and inode map resources are freed,\n *\t\tand neither the inode nor indirect blocks are modified\n *\t\tso that the resources can be later freed in the work\n *\t\tmap by ctrunc1.\n *\t\tif there is no VM segment on entry, the resources are\n *\t\tfreed in both work and permanent map.\n *\t\t(? for temporary file - memory object is cached even\n *\t\tafter no reference:\n *\t\treference count > 0 -   )\n *\n * PARAMETERS:\tcd\t- pointer to commit data structure.\n *\t\t\t  current inode is the one to truncate.\n *\n * RETURN:\tErrors from subroutines\n */\n", "func_signal": "static s64 commitZeroLink(tid_t tid, struct inode *ip)", "code": "{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_rename\n *\n * FUNCTION:\trename a file or directory\n */\n", "func_signal": "static int jfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)", "code": "{\n\tstruct btstack btstack;\n\tino_t ino;\n\tstruct component_name new_dname;\n\tstruct inode *new_ip;\n\tstruct component_name old_dname;\n\tstruct inode *old_ip;\n\tint rc;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tint ipcount;\n\tstruct inode *iplist[4];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\n\tjfs_info(\"jfs_rename: %s %s\", old_dentry->d_name.name,\n\t\t new_dentry->d_name.name);\n\n\told_ip = old_dentry->d_inode;\n\tnew_ip = new_dentry->d_inode;\n\n\tif ((rc = get_UCSname(&old_dname, old_dentry)))\n\t\tgoto out1;\n\n\tif ((rc = get_UCSname(&new_dname, new_dentry)))\n\t\tgoto out2;\n\n\t/*\n\t * Make sure source inode number is what we think it is\n\t */\n\trc = dtSearch(old_dir, &old_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (rc || (ino != old_ip->i_ino)) {\n\t\trc = -ENOENT;\n\t\tgoto out3;\n\t}\n\n\t/*\n\t * Make sure dest inode number (if any) is what we think it is\n\t */\n\trc = dtSearch(new_dir, &new_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (rc == 0) {\n\t\tif ((new_ip == 0) || (ino != new_ip->i_ino)) {\n\t\t\trc = -ESTALE;\n\t\t\tgoto out3;\n\t\t}\n\t} else if (rc != -ENOENT)\n\t\tgoto out3;\n\telse if (new_ip) {\n\t\t/* no entry exists, but one was expected */\n\t\trc = -ESTALE;\n\t\tgoto out3;\n\t}\n\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tif (new_ip) {\n\t\t\tif (!dtEmpty(new_ip)) {\n\t\t\t\trc = -ENOTEMPTY;\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t} else if ((new_dir != old_dir) &&\n\t\t\t   (new_dir->i_nlink == JFS_LINK_MAX)) {\n\t\t\trc = -EMLINK;\n\t\t\tgoto out3;\n\t\t}\n\t} else if (new_ip) {\n\t\tIWRITE_LOCK(new_ip, RDWRLOCK_NORMAL);\n\t\t/* Init inode for quota operations. */\n\t\tDQUOT_INIT(new_ip);\n\t}\n\n\t/*\n\t * The real work starts here\n\t */\n\ttid = txBegin(new_dir->i_sb, 0);\n\n\t/*\n\t * How do we know the locking is safe from deadlocks?\n\t * The vfs does the hard part for us.  Any time we are taking nested\n\t * commit_mutexes, the vfs already has i_mutex held on the parent.\n\t * Here, the vfs has already taken i_mutex on both old_dir and new_dir.\n\t */\n\tmutex_lock_nested(&JFS_IP(new_dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(old_ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\tif (old_dir != new_dir)\n\t\tmutex_lock_nested(&JFS_IP(old_dir)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_SECOND_PARENT);\n\n\tif (new_ip) {\n\t\tmutex_lock_nested(&JFS_IP(new_ip)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_VICTIM);\n\t\t/*\n\t\t * Change existing directory entry to new inode number\n\t\t */\n\t\tino = new_ip->i_ino;\n\t\trc = dtModify(tid, new_dir, &new_dname, &ino,\n\t\t\t      old_ip->i_ino, JFS_RENAME);\n\t\tif (rc)\n\t\t\tgoto out4;\n\t\tdrop_nlink(new_ip);\n\t\tif (S_ISDIR(new_ip->i_mode)) {\n\t\t\tdrop_nlink(new_ip);\n\t\t\tif (new_ip->i_nlink) {\n\t\t\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t\t\t\tif (old_dir != new_dir)\n\t\t\t\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\t\t\t\tif (!S_ISDIR(old_ip->i_mode) && new_ip)\n\t\t\t\t\tIWRITE_UNLOCK(new_ip);\n\t\t\t\tjfs_error(new_ip->i_sb,\n\t\t\t\t\t  \"jfs_rename: new_ip->i_nlink != 0\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else if (new_ip->i_nlink == 0) {\n\t\t\tassert(!test_cflag(COMMIT_Nolink, new_ip));\n\t\t\t/* free block resources */\n\t\t\tif ((new_size = commitZeroLink(tid, new_ip)) < 0) {\n\t\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\t\trc = new_size;\n\t\t\t\tgoto out4;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else {\n\t\t\tnew_ip->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(new_ip);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Add new directory entry\n\t\t */\n\t\trc = dtSearch(new_dir, &new_dname, &ino, &btstack,\n\t\t\t      JFS_CREATE);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_rename didn't expect dtSearch to fail \"\n\t\t\t\t\"w/rc = %d\", rc);\n\t\t\tgoto out4;\n\t\t}\n\n\t\tino = old_ip->i_ino;\n\t\trc = dtInsert(tid, new_dir, &new_dname, &ino, &btstack);\n\t\tif (rc) {\n\t\t\tif (rc == -EIO)\n\t\t\t\tjfs_err(\"jfs_rename: dtInsert returned -EIO\");\n\t\t\tgoto out4;\n\t\t}\n\t\tif (S_ISDIR(old_ip->i_mode))\n\t\t\tinc_nlink(new_dir);\n\t}\n\t/*\n\t * Remove old directory entry\n\t */\n\n\tino = old_ip->i_ino;\n\trc = dtDelete(tid, old_dir, &old_dname, &ino, JFS_REMOVE);\n\tif (rc) {\n\t\tjfs_err(\"jfs_rename did not expect dtDelete to return rc = %d\",\n\t\t\trc);\n\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\tgoto out4;\n\t}\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tdrop_nlink(old_dir);\n\t\tif (old_dir != new_dir) {\n\t\t\t/*\n\t\t\t * Change inode number of parent for moved directory\n\t\t\t */\n\n\t\t\tJFS_IP(old_ip)->i_dtroot.header.idotdot =\n\t\t\t\tcpu_to_le32(new_dir->i_ino);\n\n\t\t\t/* Linelock header of dtree */\n\t\t\ttlck = txLock(tid, old_ip,\n\t\t\t\t    (struct metapage *) &JFS_IP(old_ip)->bxflag,\n\t\t\t\t      tlckDTREE | tlckBTROOT | tlckRELINK);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\t/*\n\t * Update ctime on changed/moved inodes & mark dirty\n\t */\n\told_ip->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_ip);\n\n\tnew_dir->i_ctime = new_dir->i_mtime = current_fs_time(new_dir->i_sb);\n\tmark_inode_dirty(new_dir);\n\n\t/* Build list of inodes modified by this transaction */\n\tipcount = 0;\n\tiplist[ipcount++] = old_ip;\n\tif (new_ip)\n\t\tiplist[ipcount++] = new_ip;\n\tiplist[ipcount++] = old_dir;\n\n\tif (old_dir != new_dir) {\n\t\tiplist[ipcount++] = new_dir;\n\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;\n\t\tmark_inode_dirty(old_dir);\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\trc = txCommit(tid, ipcount, iplist, commit_flag);\n\n      out4:\n\ttxEnd(tid);\n\tif (new_ip)\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\tif (old_dir != new_dir)\n\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(new_ip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(new_ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, new_ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 1, &new_ip, COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t}\n\tif (new_ip && (new_ip->i_nlink == 0))\n\t\tset_cflag(COMMIT_Nolink, new_ip);\n      out3:\n\tfree_UCSname(&new_dname);\n      out2:\n\tfree_UCSname(&old_dname);\n      out1:\n\tif (new_ip && !S_ISDIR(new_ip->i_mode))\n\t\tIWRITE_UNLOCK(new_ip);\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, old_dir)) {\n\t\tif (old_dir->i_size > 1)\n\t\t\tjfs_truncate_nolock(old_dir, 0);\n\n\t\tclear_cflag(COMMIT_Stale, old_dir);\n\t}\n\n\tjfs_info(\"jfs_rename: returning %d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_create(dip, dentry, mode)\n *\n * FUNCTION:\tcreate a regular file in the parent directory <dip>\n *\t\twith name = <from dentry> and mode = <mode>\n *\n * PARAMETER:\tdip\t- parent directory vnode\n *\t\tdentry\t- dentry of new file\n *\t\tmode\t- create mode (rwxrwxrwx).\n *\t\tnd- nd struct\n *\n * RETURN:\tErrors from subroutines\n *\n */\n", "func_signal": "static int jfs_create(struct inode *dip, struct dentry *dentry, int mode,\n\t\tstruct nameidata *nd)", "code": "{\n\tint rc = 0;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = NULL;\t/* child directory inode */\n\tino_t ino;\n\tstruct component_name dname;\t/* child directory name */\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_create: dip:0x%p name:%s\", dip, dentry->d_name.name);\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we\n\t * block there while holding dtree page, so we allocate the inode &\n\t * begin the transaction before we search the directory.\n\t */\n\tip = ialloc(dip, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_create: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * initialize the child XAD tree root in-line in inode\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * create entry in parent directory for child directory\n\t * (dtInsert() releases parent directory page)\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_create: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\t} else\n\t\t\ttxAbort(tid, 0);\t/* Filesystem full */\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tip->i_fop = &jfs_file_operations;\n\tip->i_mapping->a_ops = &jfs_aops;\n\n\tinsert_inode_hash(ip);\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tip->i_nlink = 0;\n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\n\tjfs_info(\"jfs_create: rc:%d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * Slightly more convenient version of icmpv6_send.\n */\n", "func_signal": "void icmpv6_param_prob(struct sk_buff *skb, int code, int pos)", "code": "{\n\ticmpv6_send(skb, ICMPV6_PARAMPROB, code, pos, skb->dev);\n\tkfree_skb(skb);\n}", "path": "net\\ipv6\\icmp.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* Put this back in when it does something useful */\n", "func_signal": "static int __init uml_gdb_init_setup(char *line, int *add)", "code": "{\n\tgdb_init = uml_strdup(line);\n\treturn 0;\n}", "path": "arch\\um\\kernel\\tt\\gdb.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_unlink(dip, dentry)\n *\n * FUNCTION:\tremove a link to object <vp> named by <name>\n *\t\tfrom parent directory <dvp>\n *\n * PARAMETER:\tdip\t- inode of parent directory\n *\t\tdentry\t- dentry of object to be removed\n *\n * RETURN:\terrors from subroutines\n *\n * note:\n * temporary file: if one or more processes have the file open\n * when the last link is removed, the link will be removed before\n * unlink() returns, but the removal of the file contents will be\n * postponed until all references to the files are closed.\n *\n * JFS does NOT support unlink() on directories.\n *\n */\n", "func_signal": "static int jfs_unlink(struct inode *dip, struct dentry *dentry)", "code": "{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\t/* object name */\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\tjfs_info(\"jfs_unlink: dip:0x%p name:%s\", dip, dentry->d_name.name);\n\n\t/* Init inode for quota operations. */\n\tDQUOT_INIT(ip);\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * delete the entry of target file from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_unlink: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\tIWRITE_UNLOCK(ip);\n\t\tgoto out1;\n\t}\n\n\tASSERT(ip->i_nlink);\n\n\tip->i_ctime = dip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\n\t/* update target's inode */\n\tinode_dec_link_count(ip);\n\n\t/*\n\t *\tcommit zero link count object\n\t */\n\tif (ip->i_nlink == 0) {\n\t\tassert(!test_cflag(COMMIT_Nolink, ip));\n\t\t/* free block resources */\n\t\tif ((new_size = commitZeroLink(tid, ip)) < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\t\tIWRITE_UNLOCK(ip);\n\t\t\trc = new_size;\n\t\t\tgoto out1;\n\t\t}\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= COMMIT_DELETE;\n\t\ttblk->u.ip = ip;\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\t/*\n\t * If xtTruncate was incomplete, commit synchronously to avoid\n\t * timing complications\n\t */\n\trc = txCommit(tid, 2, &iplist[0], commit_flag);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(dip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 2, &iplist[0], COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t}\n\n\tif (ip->i_nlink == 0)\n\t\tset_cflag(COMMIT_Nolink, ip);\n\n\tIWRITE_UNLOCK(ip);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n      out:\n\tjfs_info(\"jfs_unlink: rc:%d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* both return 0 if all ok, else on error */\n", "func_signal": "static int onyx_read_register(struct onyx *onyx, u8 reg, u8 *value)", "code": "{\n\ts32 v;\n\n\tif (reg != ONYX_REG_CONTROL) {\n\t\t*value = onyx->cache[reg-FIRSTREGISTER];\n\t\treturn 0;\n\t}\n\tv = i2c_smbus_read_byte_data(&onyx->i2c, reg);\n\tif (v < 0)\n\t\treturn -1;\n\t*value = (u8)v;\n\tonyx->cache[ONYX_REG_CONTROL-FIRSTREGISTER] = *value;\n\treturn 0;\n}", "path": "sound\\aoa\\codecs\\snd-aoa-codec-onyx.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_rmdir(dip, dentry)\n *\n * FUNCTION:\tremove a link to child directory\n *\n * PARAMETER:\tdip\t- parent inode\n *\t\tdentry\t- child directory dentry\n *\n * RETURN:\t-EINVAL\t- if name is . or ..\n *\t\t-EINVAL - if . or .. exist but are invalid.\n *\t\terrors from subroutines\n *\n * note:\n * if other threads have the directory open when the last link\n * is removed, the \".\" and \"..\" entries, if present, are removed before\n * rmdir() returns and no new entries may be created in the directory,\n * but the directory is not removed until the last reference to\n * the directory is released (cf.unlink() of regular file).\n */\n", "func_signal": "static int jfs_rmdir(struct inode *dip, struct dentry *dentry)", "code": "{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_rmdir: dip:0x%p name:%s\", dip, dentry->d_name.name);\n\n\t/* Init inode for quota operations. */\n\tDQUOT_INIT(ip);\n\n\t/* directory must be empty to be removed */\n\tif (!dtEmpty(ip)) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out;\n\t}\n\n\tif ((rc = get_UCSname(&dname, dentry))) {\n\t\tgoto out;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_DELETE;\n\ttblk->u.ip = ip;\n\n\t/*\n\t * delete the entry of target directory from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_rmdir: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t\tgoto out2;\n\t}\n\n\t/* update parent directory's link count corresponding\n\t * to \"..\" entry of the target directory deleted\n\t */\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tinode_dec_link_count(dip);\n\n\t/*\n\t * OS/2 could have created EA and/or ACL\n\t */\n\t/* free EA from both persistent and working map */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\t/* free EA pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\t}\n\tJFS_IP(ip)->ea.flag = 0;\n\n\t/* free ACL from both persistent and working map */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\t/* free ACL pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\t}\n\tJFS_IP(ip)->acl.flag = 0;\n\n\t/* mark the target directory as deleted */\n\tclear_nlink(ip);\n\tmark_inode_dirty(ip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_rmdir: rc:%d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n *\tHandle icmp messages\n */\n", "func_signal": "static int icmpv6_rcv(struct sk_buff **pskb)", "code": "{\n\tstruct sk_buff *skb = *pskb;\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tstruct in6_addr *saddr, *daddr;\n\tstruct ipv6hdr *orig_hdr;\n\tstruct icmp6hdr *hdr;\n\tint type;\n\n\tICMP6_INC_STATS_BH(idev, ICMP6_MIB_INMSGS);\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\n\t/* Perform checksum. */\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_ICMPV6,\n\t\t\t\t     skb->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(saddr, daddr, skb->len,\n\t\t\t\t\t     IPPROTO_ICMPV6, 0));\n\t\tif (__skb_checksum_complete(skb)) {\n\t\t\tLIMIT_NETDEBUG(KERN_DEBUG \"ICMPv6 checksum failed [\" NIP6_FMT \" > \" NIP6_FMT \"]\\n\",\n\t\t\t\t       NIP6(*saddr), NIP6(*daddr));\n\t\t\tgoto discard_it;\n\t\t}\n\t}\n\n\tif (!pskb_pull(skb, sizeof(struct icmp6hdr)))\n\t\tgoto discard_it;\n\n\thdr = icmp6_hdr(skb);\n\n\ttype = hdr->icmp6_type;\n\n\tif (type >= ICMPV6_DEST_UNREACH && type <= ICMPV6_PARAMPROB)\n\t\tICMP6_INC_STATS_OFFSET_BH(idev, ICMP6_MIB_INDESTUNREACHS, type - ICMPV6_DEST_UNREACH);\n\telse if (type >= ICMPV6_ECHO_REQUEST && type <= NDISC_REDIRECT)\n\t\tICMP6_INC_STATS_OFFSET_BH(idev, ICMP6_MIB_INECHOS, type - ICMPV6_ECHO_REQUEST);\n\n\tswitch (type) {\n\tcase ICMPV6_ECHO_REQUEST:\n\t\ticmpv6_echo_reply(skb);\n\t\tbreak;\n\n\tcase ICMPV6_ECHO_REPLY:\n\t\t/* we couldn't care less */\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t/* BUGGG_FUTURE: if packet contains rthdr, we cannot update\n\t\t   standard destination cache. Seems, only \"advanced\"\n\t\t   destination cache will allow to solve this problem\n\t\t   --ANK (980726)\n\t\t */\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\tgoto discard_it;\n\t\thdr = icmp6_hdr(skb);\n\t\torig_hdr = (struct ipv6hdr *) (hdr + 1);\n\t\trt6_pmtu_discovery(&orig_hdr->daddr, &orig_hdr->saddr, dev,\n\t\t\t\t   ntohl(hdr->icmp6_mtu));\n\n\t\t/*\n\t\t *\tDrop through to notify\n\t\t */\n\n\tcase ICMPV6_DEST_UNREACH:\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_PARAMPROB:\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_SOLICITATION:\n\tcase NDISC_ROUTER_ADVERTISEMENT:\n\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\tcase NDISC_REDIRECT:\n\t\tndisc_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_QUERY:\n\t\tigmp6_event_query(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REPORT:\n\t\tigmp6_event_report(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_NI_QUERY:\n\tcase ICMPV6_NI_REPLY:\n\tcase ICMPV6_MLD2_REPORT:\n\tcase ICMPV6_DHAAD_REQUEST:\n\tcase ICMPV6_DHAAD_REPLY:\n\tcase ICMPV6_MOBILE_PREFIX_SOL:\n\tcase ICMPV6_MOBILE_PREFIX_ADV:\n\t\tbreak;\n\n\tdefault:\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"icmpv6: msg of unknown type\\n\");\n\n\t\t/* informational */\n\t\tif (type & ICMPV6_INFOMSG_MASK)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * error of unknown type.\n\t\t * must pass to upper level\n\t\t */\n\n\t\ticmpv6_notify(skb, type, hdr->icmp6_code, hdr->icmp6_mtu);\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_it:\n\tICMP6_INC_STATS_BH(idev, ICMP6_MIB_INERRORS);\n\tkfree_skb(skb);\n\treturn 0;\n}", "path": "net\\ipv6\\icmp.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/* reset registers of chip, either to initial or to previous values */\n", "func_signal": "static int onyx_register_init(struct onyx *onyx)", "code": "{\n\tint i;\n\tu8 val;\n\tu8 regs[sizeof(initial_values)];\n\n\tif (!onyx->initialised) {\n\t\tmemcpy(regs, initial_values, sizeof(initial_values));\n\t\tif (onyx_read_register(onyx, ONYX_REG_CONTROL, &val))\n\t\t\treturn -1;\n\t\tval &= ~ONYX_SILICONVERSION;\n\t\tval |= initial_values[3];\n\t\tregs[3] = val;\n\t} else {\n\t\tfor (i=0; i<sizeof(register_map); i++)\n\t\t\tregs[i] = onyx->cache[register_map[i]-FIRSTREGISTER];\n\t}\n\n\tfor (i=0; i<sizeof(register_map); i++) {\n\t\tif (onyx_write_register(onyx, register_map[i], regs[i]))\n\t\t\treturn -1;\n\t}\n\tonyx->initialised = 1;\n\treturn 0;\n}", "path": "sound\\aoa\\codecs\\snd-aoa-codec-onyx.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * Handle floating-point assist faults and traps.\n */\n", "func_signal": "static int\nhandle_fpu_swa (int fp_fault, struct pt_regs *regs, unsigned long isr)", "code": "{\n\tlong exception, bundle[2];\n\tunsigned long fault_ip;\n\tstruct siginfo siginfo;\n\n\tfault_ip = regs->cr_iip;\n\tif (!fp_fault && (ia64_psr(regs)->ri == 0))\n\t\tfault_ip -= 16;\n\tif (copy_from_user(bundle, (void __user *) fault_ip, sizeof(bundle)))\n\t\treturn -1;\n\n\tif (!(current->thread.flags & IA64_THREAD_FPEMU_NOPRINT))  {\n\t\tunsigned long count, current_jiffies = jiffies;\n\t\tstruct fpu_swa_msg *cp = &__get_cpu_var(cpulast);\n\n\t\tif (unlikely(current_jiffies > cp->time))\n\t\t\tcp->count = 0;\n\t\tif (unlikely(cp->count < 5)) {\n\t\t\tcp->count++;\n\t\t\tcp->time = current_jiffies + 5 * HZ;\n\n\t\t\t/* minimize races by grabbing a copy of count BEFORE checking last.time. */\n\t\t\tcount = last.count;\n\t\t\tbarrier();\n\n\t\t\t/*\n\t\t\t * Lower 4 bits are used as a count. Upper bits are a sequence\n\t\t\t * number that is updated when count is reset. The cmpxchg will\n\t\t\t * fail is seqno has changed. This minimizes mutiple cpus\n\t\t\t * resetting the count.\n\t\t\t */\n\t\t\tif (current_jiffies > last.time)\n\t\t\t\t(void) cmpxchg_acq(&last.count, count, 16 + (count & ~15));\n\n\t\t\t/* used fetchadd to atomically update the count */\n\t\t\tif ((last.count & 15) < 5 && (ia64_fetchadd(1, &last.count, acq) & 15) < 5) {\n\t\t\t\tlast.time = current_jiffies + 5 * HZ;\n\t\t\t\tprintk(KERN_WARNING\n\t\t       \t\t\t\"%s(%d): floating-point assist fault at ip %016lx, isr %016lx\\n\",\n\t\t       \t\t\tcurrent->comm, current->pid, regs->cr_iip + ia64_psr(regs)->ri, isr);\n\t\t\t}\n\t\t}\n\t}\n\n\texception = fp_emulate(fp_fault, bundle, &regs->cr_ipsr, &regs->ar_fpsr, &isr, &regs->pr,\n\t\t\t       &regs->cr_ifs, regs);\n\tif (fp_fault) {\n\t\tif (exception == 0) {\n\t\t\t/* emulation was successful */\n\t\t\tia64_increment_ip(regs);\n\t\t} else if (exception == -1) {\n\t\t\tprintk(KERN_ERR \"handle_fpu_swa: fp_emulate() returned -1\\n\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t/* is next instruction a trap? */\n\t\t\tif (exception & 2) {\n\t\t\t\tia64_increment_ip(regs);\n\t\t\t}\n\t\t\tsiginfo.si_signo = SIGFPE;\n\t\t\tsiginfo.si_errno = 0;\n\t\t\tsiginfo.si_code = __SI_FAULT;\t/* default code */\n\t\t\tsiginfo.si_addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);\n\t\t\tif (isr & 0x11) {\n\t\t\t\tsiginfo.si_code = FPE_FLTINV;\n\t\t\t} else if (isr & 0x22) {\n\t\t\t\t/* denormal operand gets the same si_code as underflow \n\t\t\t\t* see arch/i386/kernel/traps.c:math_error()  */\n\t\t\t\tsiginfo.si_code = FPE_FLTUND;\n\t\t\t} else if (isr & 0x44) {\n\t\t\t\tsiginfo.si_code = FPE_FLTDIV;\n\t\t\t}\n\t\t\tsiginfo.si_isr = isr;\n\t\t\tsiginfo.si_flags = __ISR_VALID;\n\t\t\tsiginfo.si_imm = 0;\n\t\t\tforce_sig_info(SIGFPE, &siginfo, current);\n\t\t}\n\t} else {\n\t\tif (exception == -1) {\n\t\t\tprintk(KERN_ERR \"handle_fpu_swa: fp_emulate() returned -1\\n\");\n\t\t\treturn -1;\n\t\t} else if (exception != 0) {\n\t\t\t/* raise exception */\n\t\t\tsiginfo.si_signo = SIGFPE;\n\t\t\tsiginfo.si_errno = 0;\n\t\t\tsiginfo.si_code = __SI_FAULT;\t/* default code */\n\t\t\tsiginfo.si_addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);\n\t\t\tif (isr & 0x880) {\n\t\t\t\tsiginfo.si_code = FPE_FLTOVF;\n\t\t\t} else if (isr & 0x1100) {\n\t\t\t\tsiginfo.si_code = FPE_FLTUND;\n\t\t\t} else if (isr & 0x2200) {\n\t\t\t\tsiginfo.si_code = FPE_FLTRES;\n\t\t\t}\n\t\t\tsiginfo.si_isr = isr;\n\t\t\tsiginfo.si_flags = __ISR_VALID;\n\t\t\tsiginfo.si_imm = 0;\n\t\t\tforce_sig_info(SIGFPE, &siginfo, current);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "arch\\ia64\\kernel\\traps.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * NAME:\tjfs_symlink(dip, dentry, name)\n *\n * FUNCTION:\tcreates a symbolic link to <symlink> by name <name>\n *\t\t\tin directory <dip>\n *\n * PARAMETER:\tdip\t- parent directory vnode\n *\t\tdentry\t- dentry of symbolic link\n *\t\tname\t- the path name of the existing object\n *\t\t\t  that will be the source of the link\n *\n * RETURN:\terrors from subroutines\n *\n * note:\n * ENAMETOOLONG: pathname resolution of a symbolic link produced\n * an intermediate result whose length exceeds PATH_MAX [XPG4.2]\n*/\n", "func_signal": "static int jfs_symlink(struct inode *dip, struct dentry *dentry,\n\t\tconst char *name)", "code": "{\n\tint rc;\n\ttid_t tid;\n\tino_t ino = 0;\n\tstruct component_name dname;\n\tint ssize;\t\t/* source pathname size */\n\tstruct btstack btstack;\n\tstruct inode *ip = dentry->d_inode;\n\tunchar *i_fastsymlink;\n\ts64 xlen = 0;\n\tint bmask = 0, xsize;\n\ts64 extent = 0, xaddr;\n\tstruct metapage *mp;\n\tstruct super_block *sb;\n\tstruct tblock *tblk;\n\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_symlink: dip:0x%p name:%s\", dip, name);\n\n\tssize = strlen(name) + 1;\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * allocate on-disk/in-memory inode for symbolic link:\n\t * (iAlloc() returns new, locked inode)\n\t */\n\tip = ialloc(dip, S_IFLNK | 0777);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_security(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\t/* fix symlink access permission\n\t * (dir_create() ANDs in the u.u_cmask,\n\t * but symlinks really need to be 777 access)\n\t */\n\tip->i_mode |= 0777;\n\n\t/*\n\t * write symbolic link target path name\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * write source path name inline in on-disk inode (fast symbolic link)\n\t */\n\n\tif (ssize <= IDATASIZE) {\n\t\tip->i_op = &jfs_symlink_inode_operations;\n\n\t\ti_fastsymlink = JFS_IP(ip)->i_inline;\n\t\tmemcpy(i_fastsymlink, name, ssize);\n\t\tip->i_size = ssize - 1;\n\n\t\t/*\n\t\t * if symlink is > 128 bytes, we don't have the space to\n\t\t * store inline extended attributes\n\t\t */\n\t\tif (ssize > sizeof (JFS_IP(ip)->i_inline))\n\t\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tjfs_info(\"jfs_symlink: fast symlink added  ssize:%d name:%s \",\n\t\t\t ssize, name);\n\t}\n\t/*\n\t * write source path name in a single extent\n\t */\n\telse {\n\t\tjfs_info(\"jfs_symlink: allocate extent ip:0x%p\", ip);\n\n\t\tip->i_op = &page_symlink_inode_operations;\n\t\tip->i_mapping->a_ops = &jfs_aops;\n\n\t\t/*\n\t\t * even though the data of symlink object (source\n\t\t * path name) is treated as non-journaled user data,\n\t\t * it is read/written thru buffer cache for performance.\n\t\t */\n\t\tsb = ip->i_sb;\n\t\tbmask = JFS_SBI(sb)->bsize - 1;\n\t\txsize = (ssize + bmask) & ~bmask;\n\t\txaddr = 0;\n\t\txlen = xsize >> JFS_SBI(sb)->l2bsize;\n\t\tif ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0))) {\n\t\t\ttxAbort(tid, 0);\n\t\t\tgoto out3;\n\t\t}\n\t\textent = xaddr;\n\t\tip->i_size = ssize - 1;\n\t\twhile (ssize) {\n\t\t\t/* This is kind of silly since PATH_MAX == 4K */\n\t\t\tint copy_size = min(ssize, PSIZE);\n\n\t\t\tmp = get_metapage(ip, xaddr, PSIZE, 1);\n\n\t\t\tif (mp == NULL) {\n\t\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\t\trc = -EIO;\n\t\t\t\ttxAbort(tid, 0);\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t\tmemcpy(mp->data, name, copy_size);\n\t\t\tflush_metapage(mp);\n\t\t\tssize -= copy_size;\n\t\t\tname += copy_size;\n\t\t\txaddr += JFS_SBI(sb)->nbperpage;\n\t\t}\n\t}\n\n\t/*\n\t * create entry for symbolic link in parent directory\n\t */\n\trc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE);\n\tif (rc == 0) {\n\t\tino = ip->i_ino;\n\t\trc = dtInsert(tid, dip, &dname, &ino, &btstack);\n\t}\n\tif (rc) {\n\t\tif (xlen)\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\ttxAbort(tid, 0);\n\t\t/* discard new inode */\n\t\tgoto out3;\n\t}\n\n\tinsert_inode_hash(ip);\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\t/*\n\t * commit update of parent directory and link object\n\t */\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tip->i_nlink = 0;\n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\tjfs_info(\"jfs_symlink: rc:%d\", rc);\n\treturn rc;\n}", "path": "fs\\jfs\\namei.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/*\n * Emulate a single COP1 arithmetic instruction.\n */\n", "func_signal": "static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n\tmips_instruction ir)", "code": "{\n\tint rfmt;\t\t/* resulting format */\n\tunsigned rcsr = 0;\t/* resulting csr */\n\tunsigned cond;\n\tunion {\n\t\tieee754dp d;\n\t\tieee754sp s;\n\t\tint w;\n#ifdef __mips64\n\t\ts64 l;\n#endif\n\t} rv;\t\t\t/* resulting value */\n\n\tfpuemustats.cp1ops++;\n\tswitch (rfmt = (MIPSInst_FFMT(ir) & 0xf)) {\n\tcase s_fmt:{\t\t/* 0 */\n\t\tunion {\n\t\t\tieee754sp(*b) (ieee754sp, ieee754sp);\n\t\t\tieee754sp(*u) (ieee754sp);\n\t\t} handler;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\t\t/* binary ops */\n\t\tcase fadd_op:\n\t\t\thandler.b = ieee754sp_add;\n\t\t\tgoto scopbop;\n\t\tcase fsub_op:\n\t\t\thandler.b = ieee754sp_sub;\n\t\t\tgoto scopbop;\n\t\tcase fmul_op:\n\t\t\thandler.b = ieee754sp_mul;\n\t\t\tgoto scopbop;\n\t\tcase fdiv_op:\n\t\t\thandler.b = ieee754sp_div;\n\t\t\tgoto scopbop;\n\n\t\t\t/* unary  ops */\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fsqrt_op:\n\t\t\thandler.u = ieee754sp_sqrt;\n\t\t\tgoto scopuop;\n#endif\n#if __mips >= 4 && __mips != 32\n\t\tcase frsqrt_op:\n\t\t\thandler.u = fpemu_sp_rsqrt;\n\t\t\tgoto scopuop;\n\t\tcase frecip_op:\n\t\t\thandler.u = fpemu_sp_recip;\n\t\t\tgoto scopuop;\n#endif\n#if __mips >= 4\n\t\tcase fmovc_op:\n\t\t\tcond = fpucondbit[MIPSInst_FT(ir) >> 2];\n\t\t\tif (((ctx->fcr31 & cond) != 0) !=\n\t\t\t\t((MIPSInst_FT(ir) & 1) != 0))\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovz_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] != 0)\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovn_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] == 0)\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n#endif\n\t\tcase fabs_op:\n\t\t\thandler.u = ieee754sp_abs;\n\t\t\tgoto scopuop;\n\t\tcase fneg_op:\n\t\t\thandler.u = ieee754sp_neg;\n\t\t\tgoto scopuop;\n\t\tcase fmov_op:\n\t\t\t/* an easy one */\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tgoto copcsr;\n\n\t\t\t/* binary op on handler */\n\t\t      scopbop:\n\t\t\t{\n\t\t\t\tieee754sp fs, ft;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tSPFROMREG(ft, MIPSInst_FT(ir));\n\n\t\t\t\trv.s = (*handler.b) (fs, ft);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      scopuop:\n\t\t\t{\n\t\t\t\tieee754sp fs;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\trv.s = (*handler.u) (fs);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      copcsr:\n\t\t\tif (ieee754_cxtest(IEEE754_INEXACT))\n\t\t\t\trcsr |= FPU_CSR_INE_X | FPU_CSR_INE_S;\n\t\t\tif (ieee754_cxtest(IEEE754_UNDERFLOW))\n\t\t\t\trcsr |= FPU_CSR_UDF_X | FPU_CSR_UDF_S;\n\t\t\tif (ieee754_cxtest(IEEE754_OVERFLOW))\n\t\t\t\trcsr |= FPU_CSR_OVF_X | FPU_CSR_OVF_S;\n\t\t\tif (ieee754_cxtest(IEEE754_ZERO_DIVIDE))\n\t\t\t\trcsr |= FPU_CSR_DIV_X | FPU_CSR_DIV_S;\n\t\t\tif (ieee754_cxtest(IEEE754_INVALID_OPERATION))\n\t\t\t\trcsr |= FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\tbreak;\n\n\t\t\t/* unary conv ops */\n\t\tcase fcvts_op:\n\t\t\treturn SIGILL;\t/* not defined */\n\t\tcase fcvtd_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.d = ieee754dp_fsp(fs);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\t\tcase fcvtw_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.w = ieee754sp_tint(fs);\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fround_op:\n\t\tcase ftrunc_op:\n\t\tcase fceil_op:\n\t\tcase ffloor_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[MIPSInst_FUNC(ir) & 0x3];\n\t\t\trv.w = ieee754sp_tint(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* __mips >= 2 */\n\n#if defined(__mips64)\n\t\tcase fcvtl_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.l = ieee754sp_tlong(fs);\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n\t\tcase froundl_op:\n\t\tcase ftruncl_op:\n\t\tcase fceill_op:\n\t\tcase ffloorl_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[MIPSInst_FUNC(ir) & 0x3];\n\t\t\trv.l = ieee754sp_tlong(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* defined(__mips64) */\n\n\t\tdefault:\n\t\t\tif (MIPSInst_FUNC(ir) >= fcmp_op) {\n\t\t\t\tunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\n\t\t\t\tieee754sp fs, ft;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tSPFROMREG(ft, MIPSInst_FT(ir));\n\t\t\t\trv.w = ieee754sp_cmp(fs, ft,\n\t\t\t\t\tcmptab[cmpop & 0x7], cmpop & 0x8);\n\t\t\t\trfmt = -1;\n\t\t\t\tif ((cmpop & 0x8) && ieee754_cxtest\n\t\t\t\t\t(IEEE754_INVALID_OPERATION))\n\t\t\t\t\trcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\t\telse\n\t\t\t\t\tgoto copcsr;\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase d_fmt:{\n\t\tunion {\n\t\t\tieee754dp(*b) (ieee754dp, ieee754dp);\n\t\t\tieee754dp(*u) (ieee754dp);\n\t\t} handler;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\t\t/* binary ops */\n\t\tcase fadd_op:\n\t\t\thandler.b = ieee754dp_add;\n\t\t\tgoto dcopbop;\n\t\tcase fsub_op:\n\t\t\thandler.b = ieee754dp_sub;\n\t\t\tgoto dcopbop;\n\t\tcase fmul_op:\n\t\t\thandler.b = ieee754dp_mul;\n\t\t\tgoto dcopbop;\n\t\tcase fdiv_op:\n\t\t\thandler.b = ieee754dp_div;\n\t\t\tgoto dcopbop;\n\n\t\t\t/* unary  ops */\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fsqrt_op:\n\t\t\thandler.u = ieee754dp_sqrt;\n\t\t\tgoto dcopuop;\n#endif\n#if __mips >= 4 && __mips != 32\n\t\tcase frsqrt_op:\n\t\t\thandler.u = fpemu_dp_rsqrt;\n\t\t\tgoto dcopuop;\n\t\tcase frecip_op:\n\t\t\thandler.u = fpemu_dp_recip;\n\t\t\tgoto dcopuop;\n#endif\n#if __mips >= 4\n\t\tcase fmovc_op:\n\t\t\tcond = fpucondbit[MIPSInst_FT(ir) >> 2];\n\t\t\tif (((ctx->fcr31 & cond) != 0) !=\n\t\t\t\t((MIPSInst_FT(ir) & 1) != 0))\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovz_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] != 0)\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovn_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] == 0)\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n#endif\n\t\tcase fabs_op:\n\t\t\thandler.u = ieee754dp_abs;\n\t\t\tgoto dcopuop;\n\n\t\tcase fneg_op:\n\t\t\thandler.u = ieee754dp_neg;\n\t\t\tgoto dcopuop;\n\n\t\tcase fmov_op:\n\t\t\t/* an easy one */\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tgoto copcsr;\n\n\t\t\t/* binary op on handler */\n\t\t      dcopbop:{\n\t\t\t\tieee754dp fs, ft;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tDPFROMREG(ft, MIPSInst_FT(ir));\n\n\t\t\t\trv.d = (*handler.b) (fs, ft);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      dcopuop:{\n\t\t\t\tieee754dp fs;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\trv.d = (*handler.u) (fs);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\n\t\t\t/* unary conv ops */\n\t\tcase fcvts_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.s = ieee754sp_fdp(fs);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\t\tcase fcvtd_op:\n\t\t\treturn SIGILL;\t/* not defined */\n\n\t\tcase fcvtw_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.w = ieee754dp_tint(fs);\t/* wrong */\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fround_op:\n\t\tcase ftrunc_op:\n\t\tcase fceil_op:\n\t\tcase ffloor_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[MIPSInst_FUNC(ir) & 0x3];\n\t\t\trv.w = ieee754dp_tint(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif\n\n#if defined(__mips64)\n\t\tcase fcvtl_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.l = ieee754dp_tlong(fs);\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n\t\tcase froundl_op:\n\t\tcase ftruncl_op:\n\t\tcase fceill_op:\n\t\tcase ffloorl_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[MIPSInst_FUNC(ir) & 0x3];\n\t\t\trv.l = ieee754dp_tlong(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* __mips >= 3 */\n\n\t\tdefault:\n\t\t\tif (MIPSInst_FUNC(ir) >= fcmp_op) {\n\t\t\t\tunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\n\t\t\t\tieee754dp fs, ft;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tDPFROMREG(ft, MIPSInst_FT(ir));\n\t\t\t\trv.w = ieee754dp_cmp(fs, ft,\n\t\t\t\t\tcmptab[cmpop & 0x7], cmpop & 0x8);\n\t\t\t\trfmt = -1;\n\t\t\t\tif ((cmpop & 0x8)\n\t\t\t\t\t&&\n\t\t\t\t\tieee754_cxtest\n\t\t\t\t\t(IEEE754_INVALID_OPERATION))\n\t\t\t\t\trcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\t\telse\n\t\t\t\t\tgoto copcsr;\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase w_fmt:{\n\t\tieee754sp fs;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\tcase fcvts_op:\n\t\t\t/* convert word to single precision real */\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.s = ieee754sp_fint(fs.bits);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\tcase fcvtd_op:\n\t\t\t/* convert word to double precision real */\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.d = ieee754dp_fint(fs.bits);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\tdefault:\n\t\t\treturn SIGILL;\n\t\t}\n\t\tbreak;\n\t}\n\n#if defined(__mips64)\n\tcase l_fmt:{\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\tcase fcvts_op:\n\t\t\t/* convert long to single precision real */\n\t\t\trv.s = ieee754sp_flong(ctx->fpr[MIPSInst_FS(ir)]);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\tcase fcvtd_op:\n\t\t\t/* convert long to double precision real */\n\t\t\trv.d = ieee754dp_flong(ctx->fpr[MIPSInst_FS(ir)]);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\tdefault:\n\t\t\treturn SIGILL;\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\t/*\n\t * Update the fpu CSR register for this operation.\n\t * If an exception is required, generate a tidy SIGFPE exception,\n\t * without updating the result register.\n\t * Note: cause exception bits do not accumulate, they are rewritten\n\t * for each op; only the flag/sticky bits accumulate.\n\t */\n\tctx->fcr31 = (ctx->fcr31 & ~FPU_CSR_ALL_X) | rcsr;\n\tif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\n\t\t/*printk (\"SIGFPE: fpu csr = %08x\\n\",ctx->fcr31); */\n\t\treturn SIGFPE;\n\t}\n\n\t/*\n\t * Now we can safely write the result back to the register file.\n\t */\n\tswitch (rfmt) {\n\tcase -1:{\n#if __mips >= 4\n\t\tcond = fpucondbit[MIPSInst_FD(ir) >> 2];\n#else\n\t\tcond = FPU_CSR_COND;\n#endif\n\t\tif (rv.w)\n\t\t\tctx->fcr31 |= cond;\n\t\telse\n\t\t\tctx->fcr31 &= ~cond;\n\t\tbreak;\n\t}\n\tcase d_fmt:\n\t\tDPTOREG(rv.d, MIPSInst_FD(ir));\n\t\tbreak;\n\tcase s_fmt:\n\t\tSPTOREG(rv.s, MIPSInst_FD(ir));\n\t\tbreak;\n\tcase w_fmt:\n\t\tSITOREG(rv.w, MIPSInst_FD(ir));\n\t\tbreak;\n#if defined(__mips64)\n\tcase l_fmt:\n\t\tDITOREG(rv.l, MIPSInst_FD(ir));\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\treturn 0;\n}", "path": "arch\\mips\\math-emu\\cp1emu.c", "repo_name": "neuros/linux-davinci-2.6", "stars": 13, "license": "other", "language": "c", "size": 189962}
{"docstring": "/***************************************************************************n\n *\n * combcol record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "combcol *combcol_new()", "code": "{\n\tcombcol *x;\n\n\t/* allocate memory */\n\tx = (combcol *)xmalloc(sizeof(combcol));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\tcombcol_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* NEW as of July 5, 98 */\n", "func_signal": "void warning(char *format, ...)", "code": "{\n\tva_list args;\n\tchar buf[BUFSIZ];\n\n\tva_start(args, format);\n\tvsprintf(buf, format, args);\n\tva_end(args);\n\n\tLog_write(LOG_DEBUG,\"*\",\"[WARNING] %s\", buf);\n\tprintf(\"WARNING: %s\\n\", buf);\n}", "path": "src\\grufti.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record combcol low-level data-specific function definitions. */\n", "func_signal": "void combcol_init(combcol *cc)", "code": "{\n\t/* initialize */\n\tcc->elements = NULL;\n\tcc->last = NULL;\n\tcc->num_elements = 0;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * combo record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "combo *combo_new()", "code": "{\n\tcombo *x;\n\n\t/* allocate memory */\n\tx = (combo *)xmalloc(sizeof(combo));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\tcombo_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record combo low-level data-specific function definitions. */\n", "func_signal": "void combo_init(combo *c)", "code": "{\n\t/* initialize */\n\tc->name = NULL;\n\tc->columns = NULL;\n\tc->last = NULL;\n\tc->num_columns = 0;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * Response object definitions.\n *\n ****************************************************************************/\n", "func_signal": "static struct resprec_history *resprec_history_new()", "code": "{\n\tstruct resprec_history *l;\n\n\tl = (struct resprec_history *)xmalloc(sizeof(struct resprec_history));\n\n\tl->info = NULL;\n\tl->date = 0L;\n\tl->who = NULL;\n\n\treturn l;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* low-level rtype structure function definitions. */\n", "func_signal": "void Response_appendtype(rtype *rt)", "code": "{\n\trtype_append(&Response->rtypes, &Response->last, rt);\n\tResponse->num_rtypes++;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* 100 lines of text should be enough */\n", "func_signal": "u_long gruftiaux_sizeof()", "code": "{\n\tu_long\ttot = 0L;\n\n\ttot += sizeof(say_buf);\n\ttot += sizeof(sendmsg_buf);\n\ttot += sizeof(sayf_buf);\n\n\treturn tot;\n}", "path": "src\\gruftiaux.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * machrec record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "machrec *machrec_new()", "code": "{\n\tmachrec *x;\n\n\t/* allocate memory */\n\tx = (machrec *)xmalloc(sizeof(machrec));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\tmachrec_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record machrec low-level data-specific function definitions. */\n", "func_signal": "void machrec_init(machrec *mr)", "code": "{\n\t/* initialize */\n\tmr->match = NULL;\n\tmr->flags = 0;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* ASDF */\n/****************************************************************************\n *\n * rtype record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "rtype *rtype_new()", "code": "{\n\trtype *x;\n\n\t/* allocate memory */\n\tx = (rtype *)xmalloc(sizeof(rtype));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\trtype_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* Looking at event#, when, contact */\n", "func_signal": "void webcmd_putevent()", "code": "{\n\tevntrec\t*event;\n\tattnrec\t*a;\n\tint\tnum;\n\tchar\ttmp[BUFSIZ], ident[BUFSIZ];\n\n\tcontext;\n\tif(!Web->istok1)\n\t\treturn;\n\n\tif(!(Web->d->flags & STAT_DONTSHOWPROMPT))\n\t{\n\t\t/* Turn off prompt until we get entire form. */\n\t\tWeb->d->flags |= STAT_DONTSHOWPROMPT;\n\t}\n\n\tcontext;\n\t/* Get ident of command */\n\tsplit(ident,Web->cmdparam);\n\n\tcontext;\n\t/* Get event number */\n\tsplit(tmp,Web->cmdparam);\n\tnum = atoi(tmp);\n\tevent = Event_event(num);\n\tif(event == NULL)\n\t\treturn;\n\n\tcontext;\n\t/* Now we can start processing */\n\tif(isequal(ident,\"<EOF>\"))\n\t{\n\t\t/* ok we're done. */\n\t\tWeb->d->flags &= ~STAT_DONTSHOWPROMPT;\n\t\tEvent->flags |= EVENT_NEEDS_WRITE;\n\n\t\t/* Pass control to 'showevent' */\n\t\tsprintf(Web->cmdparam,\"%d\",event->id);\n\t\tsprintf(Web->tok1,\"%d\",event->id);\n\n\t\twebcmd_showevent();\n\t\treturn;\n\t}\n\n\tcontext;\n\t/* If they're not an attendee, add them */\n\ta = Event_attendee(event,Web->user->acctname);\n\tif(a == NULL)\n\t\ta = Event_addnewattendee(event,Web->user->acctname);\n\n\tcontext;\n\t/* Now we can update their when and contact info */\n\tif(isequal(ident,\"when\"))\n\t{\n\tcontext;\n\t\tstrcpy(tmp,Web->cmdparam);\n\t\tif(isequal(tmp,\"none\"))\n\t\t{\n\tcontext;\n\t\t\txfree(a->when);\n\t\t\ta->when = NULL;\n\t\t}\n\t\telse\n\t\t{\n\tcontext;\n\t\t\tif(strlen(tmp) > 14)\n\t\t\t\ttmp[14] = 0;\n\t\t\tattnrec_setwhen(a,tmp);\n\t\t}\n\tcontext;\n\t}\n\n\t/* Set Contact info */\n\telse if(isequal(ident,\"contact\"))\n\t{\n\t\tstrcpy(tmp,Web->cmdparam);\n\t\tif(isequal(tmp,\"none\"))\n\t\t{\n\t\t\txfree(a->contact);\n\t\t\ta->contact = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(strlen(tmp) > 40)\n\t\t\t\ttmp[40] = 0;\n\t\t\t\tattnrec_setcontact(a,tmp);\n\t\t}\n\t}\n}", "path": "src\\webcmd.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* -------------------------------------------------------------------------\n * TESTING\n *\n * Verify that our hostname is what it should be, and that our IP is also\n * what it should be.\n *\n * All tests should perform OK, and no warnings should occur.  Compile with\n *    gcc -o net net.c -DTEST -DDEBUG\n * ------------------------------------------------------------------------- */\n", "func_signal": "static void debug_to_stderr(char *fmt, ...)", "code": "{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \"\\n\");\n\tva_end(args);\n}", "path": "src\\net.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record rline low-level data-specific function definitions. */\n", "func_signal": "void rline_init(rline *rl)", "code": "{\n\t/* initialize */\n\trl->text = NULL;\n\trl->flags = 0;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record resprec low-level data-specific function definitions. */\n", "func_signal": "void resprec_init(resprec *r)", "code": "{\n\t/* initialize */\n\tr->name = NULL;\n\tr->matches = NULL;\n\tr->last_matches = NULL;\n\tr->num_matches = 0;\n\tr->except = NULL;\n\tr->last_except = NULL;\n\tr->num_excepts = 0;\n\tr->lines = NULL;\n\tr->last_line = NULL;\n\tr->num_lines = 0;\n\tr->flags = 0;\n\tr->order = 0;\n\tr->nick = NULL;\n\tr->last = 0L;\n\tr->history = NULL;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * rline record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "rline *rline_new()", "code": "{\n\trline *x;\n\n\t/* allocate memory */\n\tx = (rline *)xmalloc(sizeof(rline));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\trline_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * combelm record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "combelm *combelm_new()", "code": "{\n\tcombelm *x;\n\n\t/* allocate memory */\n\tx = (combelm *)xmalloc(sizeof(combelm));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\tcombelm_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/****************************************************************************/\n/* record rtype low-level data-specific function definitions. */\n", "func_signal": "void rtype_init(rtype *rt)", "code": "{\n\t/* initialize */\n\trt->name = NULL;\n\trt->type = 0;\n\trt->level = 0L;\n\trt->matches = NULL;\n\trt->last_matches = NULL;\n\trt->num_matches = 0;\n\trt->except = NULL;\n\trt->last_except = NULL;\n\trt->num_excepts = 0;\n\trt->responses = NULL;\n\trt->last_response = NULL;\n\trt->num_responses = 0;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * Grufti object definitions\n *\n ****************************************************************************/\n", "func_signal": "void Grufti_new()", "code": "{\n\tint\ti;\n\n\t/* already in use? */\n\tif(Grufti != NULL)\n\t\tGrufti_freeall();\n\n\t/* allocate memory */\n\tGrufti = (Grufti_ob *)xmalloc(sizeof(Grufti_ob));\n\n\t/* initialize char */\n\tstrcpy(Grufti->botnick,\"\");\t\t/* bot nick (mandatory) */\n\tstrcpy(Grufti->botusername,\"\");\t\t/* bot username (mandatory) */\n\tstrcpy(Grufti->botrealname,\"A Grufti\");\t/* bot finger info */\n\tstrcpy(Grufti->maintainer,\"\");\t\t/* optional maintainer info */\n\tstrcpy(Grufti->bothostname,\"\");\t\t/* bot hostname (set by gb) */\n\tstrcpy(Grufti->virtual_hostname,\"\");\t/* virtual hostname */\n\tstrcpy(Grufti->homepage,\"\");\t\t/* optional homepage */\n\tstrcpy(Grufti->userfile,\"userlist\");\t/* userlist file */\n\tstrcpy(Grufti->tmpdir,\"/tmp\");\t\t/* tmp directory */\n\tstrcpy(Grufti->respfile,\"response\");\t/* Response file */\n\tstrcpy(Grufti->helpfile,\"help\");\t/* help file */\n\tstrcpy(Grufti->locafile,\"locations\");\t/* locations file */\n\tstrcpy(Grufti->webfile,\"webcatches\");\t/* web catches */\n\tstrcpy(Grufti->statsfile,\"stats\");\t/* statistics */\n\tstrcpy(Grufti->banlist,\"banlist\");\t/* banlist */\n\tstrcpy(Grufti->eventfile,\"events\");\t/* Event list */\n\tstrcpy(Grufti->xfer_incoming,\"incoming\");\t/* incoming files */\n\tstrcpy(Grufti->xfer_files,\"files\");\t/* outgoing files */\n\tstrcpy(Grufti->backupdir,\"backup\");\t/* backup */\n\tstrcpy(Grufti->botdir,\"bot\");\t\t/* bot */\n\tstrcpy(Grufti->admindir,\"etc\");\t\t/* etc */\n\tstrcpy(Grufti->logdir,\"logs\");\t\t/* logs */\n\tstrcpy(Grufti->motd_dcc,\"motd-dcc\");\t/* dcc motd file */\n\tstrcpy(Grufti->motd_telnet,\"motd-telnet\");\t/* telnet motd file */\n\tstrcpy(Grufti->welcome_dcc,\"welcome-dcc\");\t/* dcc welcome file */\n\tstrcpy(Grufti->telnet_banner,\"banner\");\t/* telnet banner */\n\tstrcpy(Grufti->combofile,\"combos\");\t\t/* combo file */\n\tstrcpy(Grufti->pidfile,\"grufti.pid\");\t/* pidfile */\n\tstrcpy(Grufti->alt_name1,\"\");\t\t/* alternate name 1 */\n\tstrcpy(Grufti->alt_name2,\"\");\t\t/* alternate name 2 */\n\tstrcpy(Grufti->ctcp_version,\"mIRC32 v5.02 K.Mardam-Bey\");\n\tstrcpy(Grufti->ctcp_clientinfo,\"ACCEPT ACTION CLIENTINFO DCC ECHO FINGER PING RESUME SOUND TIME USERINFO VERSION\");\n\tstrcpy(Grufti->ctcp_finger,\"You're gonna lose that finger!\");\n\tstrcpy(Grufti->shitlist_message,\"You're not wanted here!\");\n\tstrcpy(Grufti->mymode_on_IRC_join,\"+i-ws\");\n\tstrcpy(Grufti->takeover_in_progress_msg,\"*** Takeover on #gothic in progress, join #grufti ***\");\n\tstrcpy(Grufti->smtp_gateway,\"\");\n\tstrcpy(Grufti->idlekick_message,\"** No idling **\");\n\n\n\t/* initialize int */\n\tGrufti->irc = 1;\t\t\t/* Do we connect to irc or no */\n\tGrufti->server_timeout = 15;\t\t/* how long before next server*/\n\tGrufti->server_ping_timeout = 180;\t/* jump if no pong in 3 mins */\n\tGrufti->server_quit_timeout = 30;\t/* close manually if no QUIT */\n\tGrufti->chat_login_timeout = 180;\t/* user logging in */\n\tGrufti->chat_ident_timeout = 10;\t/* waiting for ident reply */\n\tGrufti->smtp_timeout = 180;\t\t/* smtp timeout */\n\tGrufti->chat_timeout = 43200;\t\t/* normal chat. (12 hrs) */\n\tGrufti->establish_dcc_timeout = 180;\t/* waiting for DCC connect */\n\tGrufti->serverpossible_timeout = 120;\t/* server possible timeout */\n\tGrufti->max_dcc_connections = 20;\t/* max dcc connections */\n\tGrufti->reqd_telnet_port = 9000;\t/* port we want for telnet */\n\tGrufti->reqd_gateway_port = 8888;\t/* port we want for gateway */\n\tGrufti->chat_port = 7900;\t\t/* chat port low end */\n\tGrufti->num_ports_to_try = 1000;\t/* chat port high end. */\n\tGrufti->max_nicks = 5;\t\t\t/* num nicks allowed */\n\tGrufti->max_greets = 5;\t\t\t/* num greets allowed */\n\tGrufti->login_attempts = 3;\t\t/* num attempts we'll allow */\n\tGrufti->dequeuenotes_freq = 120;\t/* how often to dequeue notes */\n\tGrufti->radiate_freq = 180;\t\t/* how often to userhost */\n\tGrufti->ping_freq = 60;\t\t\t/* how often to ping */\n\tGrufti->join_freq = 10;\t\t\t/* how often to try joining */\n\tGrufti->nick_freq = 10;\t\t\t/* how often to try our nick */\n\tGrufti->luser_freq = 300;\t\t/* how often to LUSERS */\n\tGrufti->netsplit_timeout = 180;\t\t/* hot long before jumping */\n\tGrufti->memberissplit_timeout = 1200;\t/* remove member if split */\n\tGrufti->radiate_timeout = 600;\t\t/* no 302 has been received */\n\tGrufti->min_servers = 5;\t\t/* min servers before jumping */\n\tGrufti->welcome_newdcc = 1;\t\t/* welcome new dcc's? */\n\tGrufti->show_motd_on_dcc_chat = 1;\t/* show motd on dcc chat? */\n\tGrufti->show_motd_on_telnet = 1;\t/* show motd on telnet */\n\tGrufti->show_motd_onlywhenchanged = 1;\t/* show motd only when changed*/\n\tGrufti->show_telnet_banner = 1;\t\t/* show telnet banner */\n\tGrufti->background = 1;\t\t\t/* fork into background */\n\tGrufti->console = 0;\t\t\t/* do console mode */\n\tGrufti->show_internal_ports = 1;\t/* show intr ports in dccinfo */\n\tGrufti->max_saved_notes = 10;\t\t/* max number of saved notes */\n\tGrufti->location_changetime = 3600;\t/* location change time */\n\tGrufti->max_urls = 50;\t\t\t/* max or URL's to catch */\n\tGrufti->wait_to_greet = 600;\t\t/* wait before greeting again */\n\tGrufti->wait_to_informofnotes = 600;\t/* wait before saying notes */\n\tGrufti->write_freq = 3600;\t\t/* write every hour */\n\tGrufti->public_flood_num = 10;\t\t/* num msgs is a flood */\n\tGrufti->public_flood_interval = 120;\t/* in number of seconds */\n\tGrufti->public_flood_timeout = 120;\t/* wait 2 mins */\n\tGrufti->xfer_maxfilesize = 2048;\t/* maxfilesize (in kb) */\n\tGrufti->xfer_remove_incomplete = 1;\t/* remove incomplete files */\n\tGrufti->xfer_blocksize = 512;\t\t/* blocksize to send */\n\tGrufti->timeout_accounts = 30;\t\t/* when accounts are deleted */\n\tGrufti->timeout_notes = 30;\t\t/* when notes are deleted */\n\tGrufti->timeout_notices = 7;\t\t/* when notices are deleted */\n\tGrufti->timeout_users = 90;\t\t/* when users are deleted */\n\tGrufti->notify_of_notes_on_signon = 1;\t/* Notify of notes on signon */\n\tGrufti->auto_detect_takeover = 1;\n\tGrufti->takeover_in_progress = 0;\n\tGrufti->keep_tmpfiles = 1;\t\t/* Keep tmp files? */\n\tGrufti->backup_userlist = 1;\t\t/* write backup userlist */\n\tGrufti->backup_response = 1;\t\t/* write backup response */\n\tGrufti->backup_locations = 1;\t\t/* write backup locations */\n\tGrufti->backup_banlist = 1;\t\t/* write backup banlist */\n\tGrufti->backup_events = 1;\t\t/* write backup events */\n\tGrufti->unban_protected_users = 1;\t/* unban those with +p, +f */\n\tGrufti->kick_those_who_ban_prot = 1;\t/* kick the banner */\n\tGrufti->respond_to_haveyouseen = 1;\t/* respond to have you seen */\n\tGrufti->respond_to_url = 1;\t\t/* respond to url */\n\tGrufti->respond_to_bday = 1;\t\t/* respond to bday */\n\tGrufti->respond_to_showbdays = 1;\t/* respond to bday */\n\tGrufti->respond_to_email = 1;\t\t/* respond to email */\n\tGrufti->respond_to_stat = 1;\t\t/* respond to stat */\n\tGrufti->send_notice_nightly_report = 1;\t/* send notice */\n\tGrufti->send_notice_die = 1;\t\t/* send notice */\n\tGrufti->send_notice_level_plus = 1;\t/* send notice */\n\tGrufti->send_notice_level_minus = 1;\t/* send notice */\n\tGrufti->send_notice_DCC_receive = 1;\t/* send notice */\n\tGrufti->send_notice_user_created = 1;\t/* send notice */\n\tGrufti->send_notice_user_deleted = 1;\t/* send notice */\n\tGrufti->send_notice_response_created = 1; /* send notice */\n\tGrufti->send_notice_response_deleted = 1; /* send notice */\n\tGrufti->send_notice_location_created = 1; /* send notice */\n\tGrufti->send_notice_location_deleted = 1; /* send notice */\n\tGrufti->send_notice_event_created = 1;\t/* send notice */\n\tGrufti->send_notice_event_deleted = 1;\t/* send notice */\n\tGrufti->send_notice_event_signsup = 1;\t/* send notice */\n\tGrufti->send_notice_event_removes = 1;\t/* send notice */\n\tGrufti->default_leave_timeout = 300;\t/* default leave timeout */\n\tGrufti->max_leave_timeout = 3600;\t/* max leave timeout */\n\tGrufti->default_hush_timeout = 300;\t/* default hush timeout */\n\tGrufti->max_hush_timeout = 3600;\t/* max hush timeout */\n\tGrufti->sing_1015 = 0;\t\t\t/* sing \"10:15\" by the Cure */\n\tGrufti->allow_dcc_send = 1;\t\t/* allow dcc send requests */\n\tGrufti->kick_channel_idlers = 0;\t/* Kick channel idlers */\n\tGrufti->idlekick_timeout = 60;\t\t/* How often to kick idlers */\n\tGrufti->kick_idle_opers = 1;\t\t/* Kick idle opers? */\n\tGrufti->plus_i_idlekick_timeout = 4;\t/* Timer for +i reversal */\n\tGrufti->idle_time = 3600;\t\t/* When user considered idle */\n\tGrufti->quit_port_request_failed = 1;\t/* If port request failed */\n\tGrufti->require_dcc_for_pass_cmd = 1;\t/* require dcc for pass cmd */\n\tGrufti->pending_command_timeout = 30;\t/* Time until command is invalid */\n\n\n\t/* initialize u_int */\n\n\n\t/* Initialize misc  (No config file entry) */\n\tstrcpy(Grufti->configfile,DEFAULT_CONFIGFILE);\n\tstrcpy(Grufti->build,\"1.0.17\");\t\t/* build # */\n\tsprintf(Grufti->copyright, \"Grufti %s (c) 2000 Steve Rider (stever@area23.org)\", Grufti->build);\n\tGrufti->online_since = 0L;\t\t/* Time when GB was started */\n\tstrcpy(Grufti->botuh,\"\");\n\tGrufti->actual_telnet_port = 0;\t\t/* the port we got for telnet */\n\tGrufti->actual_gateway_port = 0;\t/* the port we got for gw */\n\tGrufti->die = 0;\t\t\t/* signal when we want to die */\n\tGrufti->last_day_online = 0L;\t\t/* set at midnight */\n\tGrufti->last_write = 0L;\t\t/* last write to disk */\n\tGrufti->users_deleted = 0;\t\t/* cleanup */\n\tGrufti->accts_deleted = 0;\t\t/* cleanup */\n\tGrufti->notes_deleted = 0;\t\t/* cleanup */\n\tGrufti->notes_forwarded = 0;\n\tfor(i=0; i<24; i++)\n\t\tGrufti->bot_cmds[i] = 0;\n\tGrufti->cleanup_time = 0L;\t\t/* cleanup */\n\tGrufti->stats_active = 0;\n\tGrufti->motd_modify_date = 0L;\n\tstrcpy(Grufti->virtual_hostname,\"\");\n}", "path": "src\\grufti.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/***************************************************************************n\n *\n * resprec record definitions.  No changes should be made to new(), freeall(),\n * append(), delete(), or movetofront().\n *\n ****************************************************************************/\n", "func_signal": "resprec *resprec_new()", "code": "{\n\tresprec *x;\n\n\t/* allocate memory */\n\tx = (resprec *)xmalloc(sizeof(resprec));\n\n\t/* initialize */\n\tx->next = NULL;\n\n\tresprec_init(x);\n\n\treturn x;\n}", "path": "src\\response.c", "repo_name": "otterley/grufti", "stars": 9, "license": "None", "language": "c", "size": 536}
{"docstring": "/* Unregisters the windowclass registered in SDL_RegisterApp above. */\n", "func_signal": "void\nSDL_UnregisterApp()", "code": "{\n    WNDCLASS class;\n\n    /* SDL_RegisterApp might not have been called before */\n    if (!app_registered) {\n        return;\n    }\n    --app_registered;\n    if (app_registered == 0) {\n        /* Check for any registered window classes. */\n        if (GetClassInfo(SDL_Instance, SDL_Appname, &class)) {\n            UnregisterClass(SDL_Appname, SDL_Instance);\n        }\n        SDL_free(SDL_Appname);\n        SDL_Appname = NULL;\n    }\n}", "path": "src\\SDL\\src\\video\\win32\\SDL_win32events.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Free the mutex */\n", "func_signal": "void\nSDL_DestroyMutex(SDL_mutex * mutex)", "code": "{\n    if (mutex) {\n        if (mutex->sem) {\n            SDL_DestroySemaphore(mutex->sem);\n        }\n        SDL_free(mutex);\n    }\n}", "path": "src\\SDL\\src\\thread\\generic\\SDL_sysmutex.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* darkens or lightens color, so that rows can be grouped in the list\n * esp. useful for alternating dark/light in lists\n */\n", "func_signal": "void clist_edit_shift_color(GtkStyle *style)", "code": "{\n    if (!style) return;\n\n    shift_color(&style->base[GTK_STATE_NORMAL]);\n    shift_color(&style->bg[GTK_STATE_SELECTED]);\n}", "path": "src\\Mupen64Plus\\main\\gui_gtk\\debugger\\ui_clist_edit.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* adjusts highlights (for use when highlighting a right-clicked row when showing the pop-menu) */\n", "func_signal": "void clist_edit_set_highlight(GtkWidget *clist, gint row, gint set)", "code": "{\n    if (row < 0) return;\n\n    if (set)\n        {\n        gtk_clist_set_background(GTK_CLIST(clist), row,\n            &GTK_WIDGET(clist)->style->bg[GTK_STATE_ACTIVE]);\n        gtk_clist_set_foreground(GTK_CLIST(clist), row,\n            &GTK_WIDGET(clist)->style->fg[GTK_STATE_ACTIVE]);\n        }\n    else\n        {\n        gtk_clist_set_background(GTK_CLIST(clist), row, NULL);\n        gtk_clist_set_foreground(GTK_CLIST(clist), row, NULL);\n        }\n}", "path": "src\\Mupen64Plus\\main\\gui_gtk\\debugger\\ui_clist_edit.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\n", "func_signal": "static void\nquit(int rc)", "code": "{\n    CommonQuit(state);\n    exit(rc);\n}", "path": "src\\SDL\\test\\testwm2.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* This is a way of telling whether or not to use hardware surfaces */\n", "func_signal": "Uint32\nFastestFlags(Uint32 flags, int width, int height, int bpp)", "code": "{\n    const SDL_VideoInfo *info;\n\n    /* Hardware acceleration is only used in fullscreen mode */\n    flags |= SDL_FULLSCREEN;\n\n    /* Check for various video capabilities */\n    info = SDL_GetVideoInfo();\n    if (info->blit_hw_CC && info->blit_fill) {\n        /* We use accelerated colorkeying and color filling */\n        flags |= SDL_HWSURFACE;\n    }\n    /* If we have enough video memory, and will use accelerated\n       blits directly to it, then use page flipping.\n     */\n    if ((flags & SDL_HWSURFACE) == SDL_HWSURFACE) {\n        /* Direct hardware blitting without double-buffering\n           causes really bad flickering.\n         */\n        if (info->video_mem * 1024 > (height * width * bpp / 8)) {\n            flags |= SDL_DOUBLEBUF;\n        } else {\n            flags &= ~SDL_HWSURFACE;\n        }\n    }\n\n    /* Return the flags */\n    return (flags);\n}", "path": "src\\SDL\\test\\testsprite.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* 32 bit atomic operations */\n", "func_signal": "SDL_bool\nSDL_AtomicTestThenSet32(volatile Uint32 * ptr)", "code": "{\n#ifdef nativeTestThenSet32\n  long volatile * p = (long volatile *)ptr;\n  Uint32 new = 1;\n\n  return 0 == InterlockedExchange(p, new);\n#else\n   SDL_bool result = SDL_FALSE;\n\n   privateWaitLock(ptr);\n   result = (*ptr == 0);\n   if (result)\n   {\n      *ptr = 1;\n   }\n   privateUnlock(ptr);\n\n   return result;\n#endif\n}", "path": "src\\SDL\\src\\atomic\\win32\\SDL_atomic.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Create a mutex */\n", "func_signal": "SDL_mutex *\nSDL_CreateMutex(void)", "code": "{\n    SDL_mutex *mutex;\n\n    /* Allocate mutex memory */\n    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));\n    if (mutex) {\n        /* Create the mutex semaphore, with initial value 1 */\n        mutex->sem = SDL_CreateSemaphore(1);\n        mutex->recursive = 0;\n        mutex->owner = 0;\n        if (!mutex->sem) {\n            SDL_free(mutex);\n            mutex = NULL;\n        }\n    } else {\n        SDL_OutOfMemory();\n    }\n    return mutex;\n}", "path": "src\\SDL\\src\\thread\\generic\\SDL_sysmutex.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/*\n  Native spinlock routines. Because this is the dummy implementation\n  these will always call SDL_SetError() and do nothing.\n*/\n", "func_signal": "void \nSDL_AtomicLock(SDL_SpinLock *lock)", "code": "{\n  long volatile * l = (long volatile *)lock;\n  Uint32 old = 0;\n  Uint32 new = 1;\n\n  old = InterlockedExchange(l, new);\n  while(1 == old)\n    {\n      old = InterlockedExchange(l, new);\n    }\n}", "path": "src\\SDL\\src\\atomic\\win32\\SDL_atomic.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "//]=-=-=-=-=-=-=-=[ Initialisation of RDRAM Interface Display ]=-=-=-=-=-=-=-=[\n", "func_signal": "void init_regRI()", "code": "{\n    int i;\n\n    frRegRI = gtk_frame_new(\"RDRAM Interface\");\n\n    //=== Creation of Registers Value Display ==========/\n    clRegRI = (GtkWidget *) init_hwreg_clist(5, mnemonicRI);\n    gtk_container_add(GTK_CONTAINER(frRegRI), clRegRI);\n    gtk_clist_set_selection_mode(GTK_CLIST(clRegRI), GTK_SELECTION_SINGLE);\n\n    //=== Fantom Registers Initialisation ============/\n    for( i=0; i<5; i++)\n    {\n        gui_fantom_reg_RI[i] = 0x12345678;\n    }\n}", "path": "src\\Mupen64Plus\\main\\gui_gtk\\debugger\\regRI.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Unlock the mutex */\n", "func_signal": "int\nSDL_mutexV(SDL_mutex * mutex)", "code": "{\n#if SDL_THREADS_DISABLED\n    return 0;\n#else\n    if (mutex == NULL) {\n        SDL_SetError(\"Passed a NULL mutex\");\n        return -1;\n    }\n\n    /* If we don't own the mutex, we can't unlock it */\n    if (SDL_ThreadID() != mutex->owner) {\n        SDL_SetError(\"mutex not owned by this thread\");\n        return -1;\n    }\n\n    if (mutex->recursive) {\n        --mutex->recursive;\n    } else {\n        /* The order of operations is important.\n           First reset the owner so another thread doesn't lock\n           the mutex and set the ownership before we reset it,\n           then release the lock semaphore.\n         */\n        mutex->owner = 0;\n        SDL_SemPost(mutex->sem);\n    }\n    return 0;\n#endif /* SDL_THREADS_DISABLED */\n}", "path": "src\\SDL\\src\\thread\\generic\\SDL_sysmutex.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Lock the semaphore */\n", "func_signal": "int\nSDL_mutexP(SDL_mutex * mutex)", "code": "{\n#if SDL_THREADS_DISABLED\n    return 0;\n#else\n    Uint32 this_thread;\n\n    if (mutex == NULL) {\n        SDL_SetError(\"Passed a NULL mutex\");\n        return -1;\n    }\n\n    this_thread = SDL_ThreadID();\n    if (mutex->owner == this_thread) {\n        ++mutex->recursive;\n    } else {\n        /* The order of operations is important.\n           We set the locking thread id after we obtain the lock\n           so unlocks from other threads will fail.\n         */\n        SDL_SemWait(mutex->sem);\n        mutex->owner = this_thread;\n        mutex->recursive = 0;\n    }\n\n    return 0;\n#endif /* SDL_THREADS_DISABLED */\n}", "path": "src\\SDL\\src\\thread\\generic\\SDL_sysmutex.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Register the class for this application */\n", "func_signal": "int\nSDL_RegisterApp(char *name, Uint32 style, void *hInst)", "code": "{\n    WNDCLASS class;\n\n    /* Only do this once... */\n    if (app_registered) {\n        ++app_registered;\n        return (0);\n    }\n    if (!name && !SDL_Appname) {\n        name = \"SDL_app\";\n        SDL_Appstyle = (CS_BYTEALIGNCLIENT | CS_OWNDC);\n        SDL_Instance = hInst ? hInst : GetModuleHandle(NULL);\n    }\n\n    if (name) {\n        SDL_Appname = WIN_UTF8ToString(name);\n        SDL_Appstyle = style;\n        SDL_Instance = hInst ? hInst : GetModuleHandle(NULL);\n    }\n\n    /* Register the application class */\n    class.hCursor = NULL;\n    class.hIcon =\n        LoadImage(SDL_Instance, SDL_Appname, IMAGE_ICON, 0, 0,\n                  LR_DEFAULTCOLOR);\n    class.lpszMenuName = NULL;\n    class.lpszClassName = SDL_Appname;\n    class.hbrBackground = NULL;\n    class.hInstance = SDL_Instance;\n    class.style = SDL_Appstyle;\n    class.lpfnWndProc = DefWindowProc;\n    class.cbWndExtra = 0;\n    class.cbClsExtra = 0;\n    if (!RegisterClass(&class)) {\n        SDL_SetError(\"Couldn't register application class\");\n        return (-1);\n    }\n\n    app_registered = 1;\n    return (0);\n}", "path": "src\\SDL\\src\\video\\win32\\SDL_win32events.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* the pressure reported by the tablet */\n", "func_signal": "static WPARAM\nRemapVKEY(WPARAM wParam, LPARAM lParam)", "code": "{\n    int i;\n    BYTE scancode = (BYTE) ((lParam >> 16) & 0xFF);\n\n    /* Windows remaps alphabetic keys based on current layout.\n       We try to provide USB scancodes, so undo this mapping.\n     */\n    if (wParam >= 'A' && wParam <= 'Z') {\n        if (scancode != alpha_scancodes[wParam - 'A']) {\n            for (i = 0; i < SDL_arraysize(alpha_scancodes); ++i) {\n                if (scancode == alpha_scancodes[i]) {\n                    wParam = 'A' + i;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* Keypad keys are a little trickier, we always scan for them. */\n    for (i = 0; i < SDL_arraysize(keypad_scancodes); ++i) {\n        if (scancode == keypad_scancodes[i]) {\n            wParam = VK_NUMPAD0 + i;\n            break;\n        }\n    }\n\n    return wParam;\n}", "path": "src\\SDL\\src\\video\\win32\\SDL_win32events.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* Sets an error message based on GetLastError() */\n", "func_signal": "void\nWIN_SetError(const char *prefix)", "code": "{\n    TCHAR buffer[1024];\n    char *message;\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,\n                  buffer, SDL_arraysize(buffer), NULL);\n    message = WIN_StringToUTF8(buffer);\n    SDL_SetError(\"%s%s%s\", prefix ? prefix : \"\", prefix ? \":\" : \"\", message);\n    SDL_free(message);\n}", "path": "src\\SDL\\src\\video\\win32\\SDL_win32events.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* *INDENT-OFF* */\n", "func_signal": "static SDLKey\nX11_KeyCodeToSDLKey(Display *display, KeyCode keycode)", "code": "{\n    KeySym keysym;\n    unsigned int ucs4;\n    int i;\n\n    keysym = XKeycodeToKeysym(display, keycode, 0);\n    if (keysym == NoSymbol) {\n        return SDLK_UNKNOWN;\n    }\n\n    ucs4 = X11_KeySymToUcs4(keysym);\n    if (ucs4) {\n        return (SDLKey) ucs4;\n    }\n\n    for (i = 0; i < SDL_arraysize(KeySymToSDLKey); ++i) {\n        if (keysym == KeySymToSDLKey[i].keysym) {\n            return KeySymToSDLKey[i].sdlkey;\n        }\n    }\n    return SDLK_UNKNOWN;\n}", "path": "src\\SDL\\src\\video\\x11\\SDL_x11keyboard.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "//]=-=-=-=-=-=-=-=-=-=[ Mise-a-jour RDRAM Interface Display ]=-=-=-=-=-=-=-=-=-[\n", "func_signal": "void update_regRI()", "code": "{\n    char txt[24];\n    int i;\n    \n    gtk_clist_freeze(GTK_CLIST(clRegRI));\n\n    for (i=0; i<5; i++) {\n        if (gui_fantom_reg_RI[i] != (uint32)(*regptrsRI[i])) {\n            gui_fantom_reg_RI[i] = (uint32)(*regptrsRI[i]);\n            sprintf(txt, \"%.8X\", *regptrsRI[i]);\n            gtk_clist_set_text(GTK_CLIST(clRegRI), i, 1, txt);\n            gtk_clist_set_background(GTK_CLIST(clRegRI), i, &color_modif);\n        } else {\n            gtk_clist_set_background(GTK_CLIST(clRegRI), i, &color_ident);\n        }\n    }\n    \n    gtk_clist_thaw(GTK_CLIST(clRegRI));\n}", "path": "src\\Mupen64Plus\\main\\gui_gtk\\debugger\\regRI.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* same */\n", "func_signal": "static void clist_edit_get_geom(ClistEditData *ced, gint *x, gint *y, gint *w, gint *h)", "code": "{\n    *x = GTK_CLIST(ced->clist)->column[(ced->column)].area.x + GTK_CLIST(ced->clist)->hoffset - COLUMN_SPACING - COLUMN_PADDING;\n    *y = GTK_CLIST(ced->clist)->row_height * (ced->row) + (((ced->row) + 1) * 1) + GTK_CLIST(ced->clist)->voffset;\n\n    *w = GTK_CLIST(ced->clist)->column[(ced->column)].area.width + (COLUMN_SPACING + COLUMN_PADDING) * 2;\n    *h = GTK_CLIST(ced->clist)->row_height;\n}", "path": "src\\Mupen64Plus\\main\\gui_gtk\\debugger\\ui_clist_edit.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* This function waits until it is possible to write a full sound buffer */\n", "func_signal": "static void\nARTS_WaitDevice(_THIS)", "code": "{\n    Sint32 ticks;\n\n    /* Check to see if the thread-parent process is still alive */\n    {\n        static int cnt = 0;\n        /* Note that this only works with thread implementations\n           that use a different process id for each thread.\n         */\n        /* Check every 10 loops */\n        if (this->hidden->parent && (((++cnt) % 10) == 0)) {\n            if (kill(this->hidden->parent, 0) < 0 && errno == ESRCH) {\n                this->enabled = 0;\n            }\n        }\n    }\n\n    /* Use timer for general audio synchronization */\n    ticks =\n        ((Sint32) (this->hidden->next_frame - SDL_GetTicks())) - FUDGE_TICKS;\n    if (ticks > 0) {\n        SDL_Delay(ticks);\n    }\n}", "path": "src\\SDL\\src\\audio\\arts\\SDL_artsaudio.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/* The Win32 callback for filling the WAVE device */\n", "func_signal": "static void CALLBACK\nFillSound(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dwInstance,\n          DWORD dwParam1, DWORD dwParam2)", "code": "{\n    SDL_AudioDevice *this = (SDL_AudioDevice *) dwInstance;\n\n    /* Only service \"buffer done playing\" messages */\n    if (uMsg != WOM_DONE)\n        return;\n\n    /* Signal that we are done playing a buffer */\n#if defined(_WIN32_WCE) && (_WIN32_WCE < 300)\n    ReleaseSemaphoreCE(this->hidden->audio_sem, 1, NULL);\n#else\n    ReleaseSemaphore(this->hidden->audio_sem, 1, NULL);\n#endif\n}", "path": "src\\SDL\\src\\audio\\windib\\SDL_dibaudio.c", "repo_name": "zodttd/n64iphone", "stars": 13, "license": "None", "language": "c", "size": 9675}
{"docstring": "/*\n * Function obex_response_to_string(rsp)\n *\n *    Return a string of an OBEX-response\n *\n */\n", "func_signal": "char *obex_response_to_string(int rsp)", "code": "{\n\tswitch (rsp) {\n\tcase OBEX_RSP_CONTINUE:\n\t\treturn \"Continue\";\n\tcase OBEX_RSP_SWITCH_PRO:\n\t\treturn \"Switching protocols\";\n\tcase OBEX_RSP_SUCCESS:\n\t\treturn \"OK, Success\";\n\tcase OBEX_RSP_CREATED:\n\t\treturn \"Created\";\n\tcase OBEX_RSP_ACCEPTED:\n\t\treturn \"Accepted\";\n\tcase OBEX_RSP_NO_CONTENT:\n\t\treturn \"No Content\";\n\tcase OBEX_RSP_BAD_REQUEST:\n\t\treturn \"Bad Request\";\n\tcase OBEX_RSP_UNAUTHORIZED:\n\t\treturn \"Unauthorized\";\n\tcase OBEX_RSP_PAYMENT_REQUIRED:\n\t\treturn \"Payment required\";\n\tcase OBEX_RSP_FORBIDDEN:\n\t\treturn \"Forbidden\";\n\tcase OBEX_RSP_NOT_FOUND:\n\t\treturn \"Not found\";\n\tcase OBEX_RSP_METHOD_NOT_ALLOWED:\n\t\treturn \"Method not allowed\";\n\tcase OBEX_RSP_CONFLICT:\n\t\treturn \"Conflict\";\n\tcase OBEX_RSP_INTERNAL_SERVER_ERROR:\n\t\treturn \"Internal server error\";\n\tcase OBEX_RSP_NOT_IMPLEMENTED:\n\t\treturn \"Not implemented!\";\n\tcase OBEX_RSP_DATABASE_FULL:\n\t\treturn \"Database full\";\n\tcase OBEX_RSP_DATABASE_LOCKED:\n\t\treturn \"Database locked\";\n\tdefault:\n\t\treturn \"Unknown response\";\n\t}\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "//\n//\n//\n", "func_signal": "void server_request(obex_t *handle, obex_object_t *object, int event, int cmd)", "code": "{\n\tswitch(cmd)\t{\n\tcase OBEX_CMD_CONNECT:\n\t\tconnect_server(handle, object);\n\t\tbreak;\n\tcase OBEX_CMD_DISCONNECT:\n\t\tprintf(\"We got a disconnect-request\\n\");\n\t\tOBEX_ObjectSetRsp(object, OBEX_RSP_SUCCESS, OBEX_RSP_SUCCESS);\n\t\tbreak;\n\tcase OBEX_CMD_GET:\n\t\t/* A Get always fits one package */\n\t\tget_server(handle, object);\n\t\tbreak;\n\tcase OBEX_CMD_PUT:\n\t\tOBEX_ObjectSetRsp(object, OBEX_RSP_CONTINUE, OBEX_RSP_SUCCESS);\n\t\tput_server(handle, object);\n\t\tbreak;\n\tcase OBEX_CMD_SETPATH:\n\t\tprintf(\"Got a SETPATH request\\n\");\n\t\tOBEX_ObjectSetRsp(object, OBEX_RSP_CONTINUE, OBEX_RSP_SUCCESS);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s() Denied %02x request\\n\", __FUNCTION__, cmd);\n\t\tOBEX_ObjectSetRsp(object, OBEX_RSP_NOT_IMPLEMENTED, OBEX_RSP_NOT_IMPLEMENTED);\n\t\tbreak;\n\t}\n\treturn;\n}", "path": "apps\\obex_test_server.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "//\n//\n//\n", "func_signal": "void server_do(obex_t *handle)", "code": "{\n        int ret;\n\tstruct context *gt;\n\tgt = OBEX_GetUserData(handle);\n\n\tgt->serverdone = FALSE;\n\twhile(!gt->serverdone) {\n\t        ret = OBEX_HandleInput(handle, 10);\n\t\tif(ret < 0) {\n\t\t\tprintf(\"Error while doing OBEX_HandleInput()\\n\");\n\t\t\tbreak;\n\t\t} else if (ret == 0) {\n\t\t\tprintf(\"Timeout while doing OBEX_HandleInput()\\n\");\n\t\t\tbreak;\n\t\t} else {\n\t\t\tprintf(\"OBEX_HandleInput() returned %d\\n\",ret);\n\t\t}\n\t}\n}", "path": "apps\\obex_test_server.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_read ()\n *\n *    Do the reading\n *\n */\n", "func_signal": "int obex_transport_read(obex_t *self, int max, uint8_t *buf, int buflen)", "code": "{\n\tint actual = -1;\n\tbuf_t *msg = self->rx_msg;\n#if defined(HAVE_USB) && defined(HAVE_USB1)\n\tint usberror;\n#endif\n\n\tDEBUG(4, \"Request to read max %d bytes\\n\", max);\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n#endif /*HAVE_IRDA*/\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_INET:\n\t\tactual = recv(self->fd, buf_reserve_end(msg, max), max, 0);\n\t\tif (actual > 0)\n\t\t\tbuf_remove_end(msg, max - actual);\n\t\tbreak;\n\tcase OBEX_TRANS_FD:\n#ifdef _WIN32\n\t\tactual = _read(self->fd, buf_reserve_end(msg, max), max);\n#else\n\t\tactual = read(self->fd, buf_reserve_end(msg, max), max);\n#endif\n\t\tif (actual > 0)\n\t\t\tbuf_remove_end(msg, max - actual);\n\t\tbreak;\n#ifdef HAVE_USB\n\tcase OBEX_TRANS_USB:\n\t\tif (self->trans.connected != TRUE)\n\t\t\tbreak;\n\t\tDEBUG(4, \"Endpoint %d\\n\", self->trans.self.usb.data_endpoint_read);\n#ifdef HAVE_USB1\n\t\tusberror = libusb_bulk_transfer(self->trans.self.usb.dev,\n\t\t\t\t\tself->trans.self.usb.data_endpoint_read,\n\t\t\t\t\tbuf_reserve_end(msg, self->mtu_rx),\n\t\t\t\t\tself->mtu_rx, &actual,\n\t\t\t\t\tUSB_OBEX_TIMEOUT);\n\t\tif (usberror)\n\t\t\tactual = usberror;\n#else\n\t\tactual = usb_bulk_read(self->trans.self.usb.dev,\n\t\t\t\t\tself->trans.self.usb.data_endpoint_read,\n\t\t\t\t\tbuf_reserve_end(msg, self->mtu_rx),\n\t\t\t\t\tself->mtu_rx, USB_OBEX_TIMEOUT);\n#endif\n\t\tbuf_remove_end(msg, self->mtu_rx - actual);\n\t\tbreak;\n#endif /*HAVE_USB*/\n\tcase OBEX_TRANS_CUSTOM:\n\t\tif (buflen > max) {\n\t\t\tmemcpy(buf_reserve_end(msg, max), buf, max);\n\t\t\tactual = max;\n\t\t} else {\n\t\t\tmemcpy(buf_reserve_end(msg, buflen), buf, buflen);\n\t\t\tactual = buflen;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDEBUG(4, \"Transport not implemented!\\n\");\n\t\tbreak;\n\t}\n\n\treturn actual;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "//\n//\n//\n", "func_signal": "void server_done(obex_t *handle, obex_object_t *object, int obex_cmd, int obex_rsp)", "code": "{\n\tstruct context *gt;\n\tgt = OBEX_GetUserData(handle);\n\n\tprintf(\"Server request finished!\\n\");\n\n\tswitch (obex_cmd) {\n\tcase OBEX_CMD_DISCONNECT:\n\t\tprintf(\"Disconnect done!\\n\");\n\t\tOBEX_TransportDisconnect(handle);\n\t\tgt->serverdone = TRUE;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s() Command (%02x) has now finished\\n\", __FUNCTION__, obex_cmd);\n\t\tbreak;\n\t}\n}", "path": "apps\\obex_test_server.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_data_request (self, opcode, cmd)\n *\n *    Send response or command code along with optional headers/data.\n *\n */\n", "func_signal": "int obex_data_request(obex_t *self, buf_t *msg, int opcode)", "code": "{\n\tobex_common_hdr_t *hdr;\n\tint actual = 0;\n\n\tobex_return_val_if_fail(self != NULL, -1);\n\tobex_return_val_if_fail(msg != NULL, -1);\n\n\t/* Insert common header */\n\thdr = (obex_common_hdr_t *) buf_reserve_begin(msg, sizeof(obex_common_hdr_t));\n\n\thdr->opcode = opcode;\n\thdr->len = htons((uint16_t)msg->data_size);\n\n\tDUMPBUFFER(1, \"Tx\", msg);\n\tDEBUG(1, \"len = %d bytes\\n\", msg->data_size);\n\n\tactual = obex_transport_write(self, msg);\n\treturn actual;\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "//\n//\n//\n", "func_signal": "static void connect_server(obex_t *handle, obex_object_t *object)", "code": "{\n\tobex_headerdata_t hv;\n\tuint8_t hi;\n\tuint32_t hlen;\n\n\tconst uint8_t *who = NULL;\n\tint who_len = 0;\n\tprintf(\"%s()\\n\", __FUNCTION__);\n\n\twhile (OBEX_ObjectGetNextHeader(handle, object, &hi, &hv, &hlen))\t{\n\t\tif(hi == OBEX_HDR_WHO)\t{\n\t\t\twho = hv.bs;\n\t\t\twho_len = hlen;\n\t\t}\n\t\telse\t{\n\t\t\tprintf(\"%s() Skipped header %02x\\n\", __FUNCTION__, hi);\n\t\t}\n\t}\n\tif (who_len == 6)\t{\n\t\tif(memcmp(\"Linux\", who, 6) == 0)\t{\n\t\t\tprintf(\"Weeeha. I'm talking to the coolest OS ever!\\n\");\n\t\t}\n\t}\n\tOBEX_ObjectSetRsp(object, OBEX_RSP_SUCCESS, OBEX_RSP_SUCCESS);\n}", "path": "apps\\obex_test_server.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_handle_input(self, timeout)\n *\n *    Used when working in synchronous mode.\n *\n */\n", "func_signal": "int obex_transport_handle_input(obex_t *self, int timeout)", "code": "{\n\tint ret;\n\n\tif (self->trans.type == OBEX_TRANS_CUSTOM) {\n\t\tif (self->ctrans.handleinput)\n\t\t\tret = self->ctrans.handleinput(self, self->ctrans.customdata, timeout);\n\t\telse {\n\t\t\tDEBUG(4, \"No handleinput-callback exist!\\n\");\n\t\t\tret = -1;\n\t\t}\n\t} else if (self->trans.type == OBEX_TRANS_USB)\n\t\tret = obex_data_indication(self, NULL, 0);\n\telse {\n\t\tstruct timeval time;\n\t\tfd_set fdset;\n\t\tsocket_t highestfd = 0;\n\n\t\tDEBUG(4, \"\\n\");\n\t\tobex_return_val_if_fail(self != NULL, -1);\n\n\t\t/* Check of we have any fd's to do select on. */\n\t\tif (self->fd == INVALID_SOCKET\n\t\t\t\t && self->serverfd == INVALID_SOCKET) {\n\t\t\tDEBUG(0, \"No valid socket is open\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ttime.tv_sec = timeout;\n\t\ttime.tv_usec = 0;\n\n\t\t/* Add the fd's to the set. */\n\t\tFD_ZERO(&fdset);\n\t\tif (self->fd != INVALID_SOCKET) {\n\t\t\tFD_SET(self->fd, &fdset);\n\t\t\tif (self->fd > highestfd)\n\t\t\t\thighestfd = self->fd;\n\t\t}\n\n\t\tif (self->serverfd != INVALID_SOCKET) {\n\t\t\tFD_SET(self->serverfd, &fdset);\n\t\t\tif (self->serverfd > highestfd)\n\t\t\t\thighestfd = self->serverfd;\n\t\t}\n\n\t\t/* Wait for input */\n\t\tret = select((int)highestfd+1, &fdset, NULL, NULL, &time);\n\n\t\t/* Check if this is a timeout (0) or error (-1) */\n\t\tif (ret < 1)\n\t\t\treturn ret;\n\n\t\tif (self->fd != INVALID_SOCKET && FD_ISSET(self->fd, &fdset)) {\n\t\t\tDEBUG(4, \"Data available on client socket\\n\");\n\t\t\tret = obex_data_indication(self, NULL, 0);\n\t\t} else if (self->serverfd != INVALID_SOCKET && FD_ISSET(self->serverfd, &fdset)) {\n\t\t\tDEBUG(4, \"Data available on server socket\\n\");\n\t\t\t/* Accept : create the connected socket */\n\t\t\tret = obex_transport_accept(self);\n\n\t\t\t/* Tell the app to perform the OBEX_Accept() */\n\t\t\tif (self->keepserver)\n\t\t\t\tobex_deliver_event(self, OBEX_EV_ACCEPTHINT,\n\t\t\t\t\t\t   0, 0, FALSE);\n\t\t\t/* Otherwise, just disconnect the server */\n\t\t\tif (ret >= 0 && !self->keepserver)\n\t\t\t\tobex_transport_disconnect_server(self);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_data_indication (self)\n *\n *    Read/Feed some input from device and find out which packet it is\n *\n */\n", "func_signal": "int obex_data_indication(obex_t *self, uint8_t *buf, int buflen)", "code": "{\n\tobex_common_hdr_t *hdr;\n\tbuf_t *msg;\n\tint final;\n\tint actual = 0;\n\tunsigned int size;\n\tint ret;\n\t\n\tDEBUG(4, \"\\n\");\n\n\tobex_return_val_if_fail(self != NULL, -1);\n\n\tmsg = self->rx_msg;\n\t\n\t/* First we need 3 bytes to be able to know how much data to read */\n\tif(msg->data_size < 3)  {\n\t\tactual = obex_transport_read(self, 3 - (msg->data_size), buf, buflen);\n\t\t\n\t\tDEBUG(4, \"Got %d bytes\\n\", actual);\n\n\t\t/* Check if we are still connected */\n\t\t/* do not error if the data is from non-empty but partial buffer (custom transport) */\n\t\tif (buf == NULL && buflen == 0 && actual <= 0)\t{\n\t\t\tobex_deliver_event(self, OBEX_EV_LINKERR, 0, 0, TRUE);\n\t\t\treturn actual;\n\t\t}\n\t\tbuf += actual;\n\t\tbuflen -= actual;\n\t}\n\n\t/* If we have 3 bytes data we can decide how big the packet is */\n\tif(msg->data_size >= 3) {\n\t\thdr = (obex_common_hdr_t *) msg->data;\n\t\tsize = ntohs(hdr->len);\n\n\t\tactual = 0;\n\t\tif(msg->data_size < (int) ntohs(hdr->len)) {\n\n\t\t\tactual = obex_transport_read(self, size - msg->data_size, buf,\n\t\t\t\tbuflen);\n\n\t\t\t/* Check if we are still connected */\n\t\t\t/* do not error if the data is from non-empty but partial buffer (custom transport) */\n\t\t\tif (buf == NULL && buflen == 0 && actual <= 0)\t{\n\t\t\t\tobex_deliver_event(self, OBEX_EV_LINKERR, 0, 0, TRUE);\n\t\t\t\treturn actual;\n\t\t\t}\n\t\t}\n\t}\n        else {\n\t\t/* Wait until we have at least 3 bytes data */\n\t\tDEBUG(3, \"Need at least 3 bytes got only %d!\\n\", msg->data_size);\n\t\treturn actual;\n        }\n\n\n\t/* New data has been inserted at the end of message */\n\tDEBUG(1, \"Got %d bytes msg len=%d\\n\", actual, msg->data_size);\n\n\t/*\n\t * Make sure that the buffer we have, actually has the specified\n\t * number of bytes. If not the frame may have been fragmented, and\n\t * we will then need to read more from the socket.  \n\t */\n\n\t/* Make sure we have a whole packet */\n\tif (size > msg->data_size) {\n\t\tDEBUG(3, \"Need more data, size=%d, len=%d!\\n\",\n\t\t      size, msg->data_size);\n\n\t\t/* I'll be back! */\n\t\treturn msg->data_size;\n\t}\n\n\tDUMPBUFFER(2, \"Rx\", msg);\n\n\tactual = msg->data_size;\n\tfinal = hdr->opcode & OBEX_FINAL; /* Extract final bit */\n\n\t/* Dispatch to the mode we are in */\n\tif(self->state & MODE_SRV) {\n\t\tret = obex_server(self, msg, final);\n\t\tbuf_reuse(msg);\n\t\t\n\t}\n\telse\t{\n\t\tret = obex_client(self, msg, final);\n\t\tbuf_reuse(msg);\n\t}\n\t/* Check parse errors */\n\tif(ret < 0)\n\t\tactual = ret;\n\treturn actual;\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_disconnect_request (self)\n *\n *    Disconnect transport\n *\n */\n", "func_signal": "void obex_transport_disconnect_request(obex_t *self)", "code": "{\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n\t\tirobex_disconnect_request(self);\n\t\tbreak;\n#endif /*HAVE_IRDA*/\n\tcase OBEX_TRANS_INET:\n\t\tinobex_disconnect_request(self);\n\t\tbreak;\n\tcase OBEX_TRANS_CUSTOM:\n\t\tDEBUG(4, \"Custom disconnect\\n\");\n\t\tif (self->ctrans.disconnect)\n\t\t\tself->ctrans.disconnect(self, self->ctrans.customdata);\n\t\telse {\n\t\t\tDEBUG(4, \"No disconnect-callback exist!\\n\");\n\t\t}\n\t\tbreak;\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n\t\tbtobex_disconnect_request(self);\n\t\tbreak;\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_FD:\n\t\t/* no real disconnect on a file */\n\t\tself->fd = self->writefd = INVALID_SOCKET;\n\t\tbreak;\n#ifdef HAVE_USB\n\tcase OBEX_TRANS_USB:\n\t\tusbobex_disconnect_request(self);\n\t\tbreak;\n#endif /*HAVE_USB*/\n\tdefault:\n\t\tDEBUG(4, \"Transport not implemented!\\n\");\n\t\tbreak;\n\t}\n\tself->trans.connected = FALSE;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_listen (self)\n *\n *    Prepare for incomming connections\n *\n */\n", "func_signal": "int obex_transport_listen(obex_t *self)", "code": "{\n\tint ret = -1;\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n\t\tret = irobex_listen(self);\n\t\tbreak;\n#endif /*HAVE_IRDA*/\n\tcase OBEX_TRANS_INET:\n\t\tret = inobex_listen(self);\n\t\tbreak;\n\tcase OBEX_TRANS_CUSTOM:\n\t\tDEBUG(4, \"Custom listen\\n\");\n\t\tif (self->ctrans.listen)\n\t\t\tret = self->ctrans.listen(self, self->ctrans.customdata);\n\t\telse {\n\t\t\tDEBUG(4, \"No listen-callback exist!\\n\");\n\t\t}\n\t\tbreak;\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n\t\tret = btobex_listen(self);\n\t\tbreak;\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_FD:\n\tcase OBEX_TRANS_USB:\n\t\t/* no real listen on the file or USB */\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG(4, \"Transport %d not implemented!\\n\", self->trans.type);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_write ()\n *\n *    Do the writing\n *\n */\n", "func_signal": "int obex_transport_write(obex_t *self, buf_t *msg)", "code": "{\n\tint actual = -1;\n#if defined(HAVE_USB) && defined(HAVE_USB1)\n\tint usberror;\n#endif\n\n\tDEBUG(4, \"\\n\");\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n#endif /*HAVE_IRDA*/\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_INET:\n\t\tactual = do_write(self->fd, msg, self->trans.mtu, &send_wrap);\n\t\tbreak;\n\tcase OBEX_TRANS_FD:\n\t\tactual = do_write(self->writefd, msg, self->trans.mtu, &write_wrap);\n\t\tbreak;\n#ifdef HAVE_USB\n\tcase OBEX_TRANS_USB:\n\t\tif (self->trans.connected != TRUE)\n\t\t\tbreak;\n\t\tDEBUG(4, \"Endpoint %d\\n\", self->trans.self.usb.data_endpoint_write);\n#ifdef HAVE_USB1\n\t\tusberror = libusb_bulk_transfer(self->trans.self.usb.dev,\n\t\t\t\t\tself->trans.self.usb.data_endpoint_write,\n\t\t\t\t\t(unsigned char *) msg->data, msg->data_size,\n\t\t\t\t\t&actual, USB_OBEX_TIMEOUT);\n\t\tif (usberror)\n\t\t\tactual = usberror;\n#else\n\t\tactual = usb_bulk_write(self->trans.self.usb.dev,\n\t\t\t\t\tself->trans.self.usb.data_endpoint_write,\n\t\t\t\t\t(char *) msg->data, msg->data_size,\n\t\t\t\t\tUSB_OBEX_TIMEOUT);\n#endif\n\t\tbreak;\n#endif /*HAVE_USB*/\n\tcase OBEX_TRANS_CUSTOM:\n\t\tDEBUG(4, \"Custom write\\n\");\n\t\tif (self->ctrans.write)\n\t\t\tactual = self->ctrans.write(self, self->ctrans.customdata, msg->data, msg->data_size);\n\t\telse {\n\t\t\tDEBUG(4, \"No write-callback exist!\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDEBUG(4, \"Transport not implemented!\\n\");\n\t\tbreak;\n\t}\n\n\treturn actual;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_delete_socket()\n *\n *    Close socket if opened.\n *\n */\n", "func_signal": "int obex_delete_socket(obex_t *self, socket_t fd)", "code": "{\n\tint ret;\n\n\tDEBUG(4, \"\\n\");\n\n\tif(fd == INVALID_SOCKET)\n\t\treturn fd;\n\n#ifdef _WIN32\n\tret = closesocket(fd);\n#else /* _WIN32 */\n\tret = close(fd);\n#endif /* _WIN32 */\n\treturn ret;\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_create_socket()\n *\n *    Create socket if needed.\n *\n */\n", "func_signal": "socket_t obex_create_socket(obex_t *self, int domain)", "code": "{\n\tsocket_t fd;\n\tint proto;\n\tDEBUG(4, \"\\n\");\n\n\tproto = 0;\n\n#ifdef HAVE_BLUETOOTH\n\tif (domain == AF_BLUETOOTH)\n\t\tproto = BTPROTO_RFCOMM;\n#endif /*HAVE_BLUETOOTH*/\n\n\tfd = socket(domain, SOCK_STREAM, proto);\n\treturn fd;\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_connect_request (self, service)\n *\n *    Try to connect transport\n *\n */\n", "func_signal": "int obex_transport_connect_request(obex_t *self)", "code": "{\n\tint ret = -1;\n\n\tif (self->trans.connected)\n\t\treturn 1;\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n\t\tret = irobex_connect_request(self);\n\t\tbreak;\n#endif /*HAVE_IRDA*/\n\tcase OBEX_TRANS_INET:\n\t\t/* needed as compat for apps that call OBEX_TransportConnect\n\t\t * instead of InOBEX_TransportConnect (e.g. obexftp)\n\t\t */\n\t\tif (self->trans.peer.inet6.sin6_family == AF_INET)\n\t\t\tinobex_prepare_connect(self,\n\t\t\t\t\t       (struct sockaddr*) &self->trans.peer.inet6,\n\t\t\t\t\t       sizeof(self->trans.peer.inet6));\n\t\tret = inobex_connect_request(self);\n\t\tbreak;\n\tcase OBEX_TRANS_CUSTOM:\n\t\tDEBUG(4, \"Custom connect\\n\");\n\t\tif (self->ctrans.connect)\n\t\t\tret = self->ctrans.connect(self, self->ctrans.customdata);\n\t\telse {\n\t\t\tDEBUG(4, \"No connect-callback exist!\\n\");\n\t\t}\n\t\tDEBUG(4, \"ret=%d\\n\", ret);\n\t\tbreak;\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n\t\tret = btobex_connect_request(self);\n\t\tbreak;\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_FD:\n\t\t/* no real connect on the file */\n\t\tif (self->fd != INVALID_SOCKET && self->writefd != INVALID_SOCKET)\n\t\t\tret = 0;\n\t\tbreak;\n#ifdef HAVE_USB\n\tcase OBEX_TRANS_USB:\n\t\tret = usbobex_connect_request(self);\n\t\tbreak;\n#endif /*HAVE_USB*/\n\tdefault:\n\t\tDEBUG(4, \"Transport not implemented!\\n\");\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tself->trans.connected = TRUE;\n\n\treturn ret;\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_response_request (self, opcode)\n *\n *    Send a response to peer device\n *\n */\n", "func_signal": "void obex_response_request(obex_t *self, uint8_t opcode)", "code": "{\n\tbuf_t *msg;\n\n\tobex_return_if_fail(self != NULL);\n\n\tmsg = buf_reuse(self->tx_msg);\n\n\tobex_data_request(self, msg, opcode | OBEX_FINAL);\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_cancel_request ()\n *\n *    Cancel an ongoing request\n *\n */\n", "func_signal": "int obex_cancelrequest(obex_t *self, int nice)", "code": "{\n\t/* If we have no ongoing request do nothing */\n\tif(self->object == NULL)\n\t\treturn 0;\n\n\t/* Abort request without sending abort */\n\tif (!nice) {\n\t\t/* Deliver event will delete the object */\n\t\tobex_deliver_event(self, OBEX_EV_ABORT, 0, 0, TRUE);\n\t\tbuf_reuse(self->tx_msg);\n\t\tbuf_reuse(self->rx_msg);\n\t\t/* Since we didn't send ABORT to peer we are out of sync\n\t\t   and need to disconnect transport immediately, so we signal\n\t\t   link error to app */\n\t\tobex_deliver_event(self, OBEX_EV_LINKERR, 0, 0, FALSE);\n\t\treturn 1;\n\t} else {\n\t\tobex_object_t *object;\n\n\t\tobject = obex_object_new();\n\t\tif (object == NULL)\n\t\t\treturn -1;\n\n\t\tobex_object_setcmd(object, OBEX_CMD_ABORT, OBEX_CMD_ABORT);\n\n\t\tif (obex_object_send(self, object, TRUE, TRUE) < 0) {\n\t\t\tobex_object_delete(object);\n\t\t\treturn -1;\n\t\t}\n\n\t\tobex_object_delete(object);\n\n\t\tself->object->abort = TRUE;\n\t\tself->state = STATE_REC;\n\n\t\treturn 0;\n\t}\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_insert_connectframe ()\n *\n *    Add the data needed to send/reply to a connect\n *\n */\n", "func_signal": "int obex_insert_connectframe(obex_t *self, obex_object_t *object)", "code": "{\n\tobex_connect_hdr_t *conn_hdr;\n\n\tDEBUG(4, \"\\n\");\n\n\tobject->tx_nonhdr_data = buf_new(4);\n\tif (!object->tx_nonhdr_data)\n\t\treturn -1;\n\tconn_hdr = (obex_connect_hdr_t *) buf_reserve_end(object->tx_nonhdr_data, 4);\n\tconn_hdr->version = OBEX_VERSION;\n\tconn_hdr->flags = 0x00;              /* Flags */\n\tconn_hdr->mtu = htons(self->mtu_rx); /* Max packet size */\n\treturn 0;\n}", "path": "lib\\obex_connect.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_deliver_event ()\n *\n *    Deliver an event to app.\n *\n */\n", "func_signal": "void obex_deliver_event(obex_t *self, int event, int cmd, int rsp, int del)", "code": "{\n\tobex_object_t *object = self->object;\n\n\tif (del == TRUE)\n\t\tself->object = NULL;\n\n\tif (self->state & MODE_SRV)\n\t\tself->eventcb(self, object, OBEX_MODE_SERVER, event, cmd, rsp);\n\telse\n\t\tself->eventcb(self, object, OBEX_MODE_CLIENT, event, cmd, rsp);\n\t\n\tif (del == TRUE)\n\t\tobex_object_delete(object);\n}", "path": "lib\\obex_main.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * Function obex_transport_disconnect_server (self)\n *\n *    Disconnect the listening server\n *\n * Used either after an accept, or directly at client request (app. exits)\n * Note : obex_delete_socket() will catch the case when the socket\n * doesn't exist (-1)...\n */\n", "func_signal": "void obex_transport_disconnect_server(obex_t *self)", "code": "{\n\n\tswitch (self->trans.type) {\n#ifdef HAVE_IRDA\n\tcase OBEX_TRANS_IRDA:\n\t\tirobex_disconnect_server(self);\n\t\tbreak;\n#endif /*HAVE_IRDA*/\n\tcase OBEX_TRANS_INET:\n\t\tinobex_disconnect_server(self);\n\t\tbreak;\n\tcase OBEX_TRANS_CUSTOM:\n\t\tDEBUG(4, \"Custom disconnect\\n\");\n\t\tbreak;\n#ifdef HAVE_BLUETOOTH\n\tcase OBEX_TRANS_BLUETOOTH:\n\t\tbtobex_disconnect_server(self);\n\t\tbreak;\n#endif /*HAVE_BLUETOOTH*/\n\tcase OBEX_TRANS_FD:\n\tcase OBEX_TRANS_USB:\n\t\t/* no real server on a file or USB */;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG(4, \"Transport not implemented!\\n\");\n\t\tbreak;\n\t}\n}", "path": "lib\\obex_transport.c", "repo_name": "zuckschwerdt/openobex", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 916}
{"docstring": "/*\n * PQendcopy\n *\t\tAfter completing the data transfer portion of a copy in/out,\n *\t\tthe application must call this routine to finish the command protocol.\n *\n * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult\n * to get the transfer status.\tNote however that when using 2.0 protocol,\n * recovering from a copy failure often requires a PQreset.  PQendcopy will\n * take care of that, PQgetResult won't.\n *\n * RETURNS:\n *\t\t0 on success\n *\t\t1 on failure\n */\n", "func_signal": "int\nPQendcopy(PGconn *conn)", "code": "{\n\tif (!conn)\n\t\treturn 0;\n\n\tif (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)\n\t\treturn pqEndcopy3(conn);\n\telse\n\t\treturn pqEndcopy2(conn);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQgetline - gets a newline-terminated string from the backend.\n *\n * Chiefly here so that applications can use \"COPY <rel> to stdout\"\n * and read the output string.\tReturns a null-terminated string in s.\n *\n * XXX this routine is now deprecated, because it can't handle binary data.\n * If called during a COPY BINARY we return EOF.\n *\n * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips\n * the terminating \\n (like gets(3)).\n *\n * CAUTION: the caller is responsible for detecting the end-of-copy signal\n * (a line containing just \"\\.\") when using this routine.\n *\n * RETURNS:\n *\t\tEOF if error (eg, invalid arguments are given)\n *\t\t0 if EOL is reached (i.e., \\n has been read)\n *\t\t\t\t(this is required for backward-compatibility -- this\n *\t\t\t\t routine used to always return EOF or 0, assuming that\n *\t\t\t\t the line ended within maxlen bytes.)\n *\t\t1 in other cases (i.e., the buffer was filled before \\n is reached)\n */\n", "func_signal": "int\nPQgetline(PGconn *conn, char *s, int maxlen)", "code": "{\n\tif (!s || maxlen <= 0)\n\t\treturn EOF;\n\t*s = '\\0';\n\t/* maxlen must be at least 3 to hold the \\. terminator! */\n\tif (maxlen < 3)\n\t\treturn EOF;\n\n\tif (!conn)\n\t\treturn EOF;\n\n\tif (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)\n\t\treturn pqGetline3(conn, s, maxlen);\n\telse\n\t\treturn pqGetline2(conn, s, maxlen);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQsendQueryParams\n *\t\tLike PQsendQuery, but use protocol 3.0 so we can pass parameters\n */\n", "func_signal": "int\nPQsendQueryParams(PGconn *conn,\n\t\t\t\t  const char *command,\n\t\t\t\t  int nParams,\n\t\t\t\t  const Oid *paramTypes,\n\t\t\t\t  const char *const * paramValues,\n\t\t\t\t  const int *paramLengths,\n\t\t\t\t  const int *paramFormats,\n\t\t\t\t  int resultFormat)", "code": "{\n\tif (!PQsendQueryStart(conn))\n\t\treturn 0;\n\n\tif (!command)\n\t{\n\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\tlibpq_gettext(\"command string is a null pointer\\n\"));\n\t\treturn 0;\n\t}\n\n\treturn PQsendQueryGuts(conn,\n\t\t\t\t\t\t   command,\n\t\t\t\t\t\t   \"\",\t/* use unnamed statement */\n\t\t\t\t\t\t   nParams,\n\t\t\t\t\t\t   paramTypes,\n\t\t\t\t\t\t   paramValues,\n\t\t\t\t\t\t   paramLengths,\n\t\t\t\t\t\t   paramFormats,\n\t\t\t\t\t\t   resultFormat);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQgetvalue:\n *\treturn the value of field 'field_num' of row 'tup_num'\n */\n", "func_signal": "char *\nPQgetvalue(const PGresult *res, int tup_num, int field_num)", "code": "{\n\tif (!check_tuple_field_number(res, tup_num, field_num))\n\t\treturn NULL;\n\treturn res->tuples[tup_num][field_num].value;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQoidStatus -\n *\tif the last command was an INSERT, return the oid string\n *\tif not, return \"\"\n */\n", "func_signal": "char *\nPQoidStatus(const PGresult *res)", "code": "{\n\t/*\n\t * This must be enough to hold the result. Don't laugh, this is better\n\t * than what this function used to do.\n\t */\n\tstatic char buf[24];\n\n\tsize_t\t\tlen;\n\n\tif (!res || !res->cmdStatus || strncmp(res->cmdStatus, \"INSERT \", 7) != 0)\n\t\treturn \"\";\n\n\tlen = strspn(res->cmdStatus + 7, \"0123456789\");\n\tif (len > 23)\n\t\tlen = 23;\n\tstrncpy(buf, res->cmdStatus + 7, len);\n\tbuf[len] = '\\0';\n\n\treturn buf;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * Escaping arbitrary strings to get valid SQL literal strings.\n *\n * Replaces \"'\" with \"''\", and if not std_strings, replaces \"\\\" with \"\\\\\".\n *\n * length is the length of the source string.  (Note: if a terminating NUL\n * is encountered sooner, PQescapeString stops short of \"length\"; the behavior\n * is thus rather like strncpy.)\n *\n * For safety the buffer at \"to\" must be at least 2*length + 1 bytes long.\n * A terminating NUL character is added to the output string, whether the\n * input is NUL-terminated or not.\n *\n * Returns the actual length of the output (not counting the terminating NUL).\n */\n", "func_signal": "static size_t\nPQescapeStringInternal(PGconn *conn,\n\t\t\t\t\t   char *to, const char *from, size_t length,\n\t\t\t\t\t   int *error,\n\t\t\t\t\t   int encoding, bool std_strings)", "code": "{\n\tconst char *source = from;\n\tchar\t   *target = to;\n\tsize_t\t\tremaining = length;\n\n\tif (error)\n\t\t*error = 0;\n\n\twhile (remaining > 0 && *source != '\\0')\n\t{\n\t\tchar\t\tc = *source;\n\t\tint\t\t\tlen;\n\t\tint\t\t\ti;\n\n\t\t/* Fast path for plain ASCII */\n\t\tif (!IS_HIGHBIT_SET(c))\n\t\t{\n\t\t\t/* Apply quoting if needed */\n\t\t\tif (SQL_STR_DOUBLE(c, !std_strings))\n\t\t\t\t*target++ = c;\n\t\t\t/* Copy the character */\n\t\t\t*target++ = c;\n\t\t\tsource++;\n\t\t\tremaining--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Slow path for possible multibyte characters */\n\t\tlen = pg_encoding_mblen(encoding, source);\n\n\t\t/* Copy the character */\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tif (remaining == 0 || *source == '\\0')\n\t\t\t\tbreak;\n\t\t\t*target++ = *source++;\n\t\t\tremaining--;\n\t\t}\n\n\t\t/*\n\t\t * If we hit premature end of string (ie, incomplete multibyte\n\t\t * character), try to pad out to the correct length with spaces. We\n\t\t * may not be able to pad completely, but we will always be able to\n\t\t * insert at least one pad space (since we'd not have quoted a\n\t\t * multibyte character).  This should be enough to make a string that\n\t\t * the server will error out on.\n\t\t */\n\t\tif (i < len)\n\t\t{\n\t\t\tif (error)\n\t\t\t\t*error = 1;\n\t\t\tif (conn)\n\t\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"incomplete multibyte character\\n\"));\n\t\t\tfor (; i < len; i++)\n\t\t\t{\n\t\t\t\tif (((size_t) (target - to)) / 2 >= length)\n\t\t\t\t\tbreak;\n\t\t\t\t*target++ = ' ';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Write the terminating NUL character. */\n\t*target = '\\0';\n\n\treturn target - to;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * parseInput: if appropriate, parse input data from backend\n * until input is exhausted or a stopping state is reached.\n * Note that this function will NOT attempt to read more data from the backend.\n */\n", "func_signal": "static void\nparseInput(PGconn *conn)", "code": "{\n\tif (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)\n\t\tpqParseInput3(conn);\n\telse\n\t\tpqParseInput2(conn);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQcmdTuples -\n *\tIf the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return\n *\ta string containing the number of inserted/affected tuples. If not,\n *\treturn \"\".\n *\n *\tXXX: this should probably return an int\n */\n", "func_signal": "char *\nPQcmdTuples(PGresult *res)", "code": "{\n\tchar\t   *p,\n\t\t\t   *c;\n\n\tif (!res)\n\t\treturn \"\";\n\n\tif (strncmp(res->cmdStatus, \"INSERT \", 7) == 0)\n\t{\n\t\tp = res->cmdStatus + 7;\n\t\t/* INSERT: skip oid and space */\n\t\twhile (*p && *p != ' ')\n\t\t\tp++;\n\t\tif (*p == 0)\n\t\t\tgoto interpret_error;\t\t/* no space? */\n\t\tp++;\n\t}\n\telse if (strncmp(res->cmdStatus, \"SELECT \", 7) == 0 ||\n\t\t\t strncmp(res->cmdStatus, \"DELETE \", 7) == 0 ||\n\t\t\t strncmp(res->cmdStatus, \"UPDATE \", 7) == 0)\n\t\tp = res->cmdStatus + 7;\n\telse if (strncmp(res->cmdStatus, \"FETCH \", 6) == 0)\n\t\tp = res->cmdStatus + 6;\n\telse if (strncmp(res->cmdStatus, \"MOVE \", 5) == 0 ||\n\t\t\t strncmp(res->cmdStatus, \"COPY \", 5) == 0)\n\t\tp = res->cmdStatus + 5;\n\telse\n\t\treturn \"\";\n\n\t/* check that we have an integer (at least one digit, nothing else) */\n\tfor (c = p; *c; c++)\n\t{\n\t\tif (!isdigit((unsigned char) *c))\n\t\t\tgoto interpret_error;\n\t}\n\tif (c == p)\n\t\tgoto interpret_error;\n\n\treturn p;\n\ninterpret_error:\n\tpqInternalNotice(&res->noticeHooks,\n\t\t\t\t\t \"could not interpret result from server: %s\",\n\t\t\t\t\t res->cmdStatus);\n\treturn \"\";\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * parseInput: if appropriate, parse input data from backend\n * until input is exhausted or a stopping state is reached.\n * Note that this function will NOT attempt to read more data from the backend.\n */\n", "func_signal": "void\npqParseInput2(PGconn *conn)", "code": "{\n\tchar\t\tid;\n\n\t/*\n\t * Loop to parse successive complete messages available in the buffer.\n\t */\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * Quit if in COPY_OUT state: we expect raw data from the server until\n\t\t * PQendcopy is called.  Don't try to parse it according to the normal\n\t\t * protocol.  (This is bogus.  The data lines ought to be part of the\n\t\t * protocol and have identifying leading characters.)\n\t\t */\n\t\tif (conn->asyncStatus == PGASYNC_COPY_OUT)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK to try to read a message type code.\n\t\t */\n\t\tconn->inCursor = conn->inStart;\n\t\tif (pqGetc(&id, conn))\n\t\t\treturn;\n\n\t\t/*\n\t\t * NOTIFY and NOTICE messages can happen in any state besides COPY\n\t\t * OUT; always process them right away.\n\t\t *\n\t\t * Most other messages should only be processed while in BUSY state.\n\t\t * (In particular, in READY state we hold off further parsing until\n\t\t * the application collects the current PGresult.)\n\t\t *\n\t\t * However, if the state is IDLE then we got trouble; we need to deal\n\t\t * with the unexpected message somehow.\n\t\t */\n\t\tif (id == 'A')\n\t\t{\n\t\t\tif (getNotify(conn))\n\t\t\t\treturn;\n\t\t}\n\t\telse if (id == 'N')\n\t\t{\n\t\t\tif (pqGetErrorNotice2(conn, false))\n\t\t\t\treturn;\n\t\t}\n\t\telse if (conn->asyncStatus != PGASYNC_BUSY)\n\t\t{\n\t\t\t/* If not IDLE state, just wait ... */\n\t\t\tif (conn->asyncStatus != PGASYNC_IDLE)\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Unexpected message in IDLE state; need to recover somehow.\n\t\t\t * ERROR messages are displayed using the notice processor;\n\t\t\t * anything else is just dropped on the floor after displaying a\n\t\t\t * suitable warning notice.  (An ERROR is very possibly the\n\t\t\t * backend telling us why it is about to close the connection, so\n\t\t\t * we don't want to just discard it...)\n\t\t\t */\n\t\t\tif (id == 'E')\n\t\t\t{\n\t\t\t\tif (pqGetErrorNotice2(conn, false /* treat as notice */ ))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpqInternalNotice(&conn->noticeHooks,\n\t\t\t\t\t\t\"message type 0x%02x arrived from server while idle\",\n\t\t\t\t\t\t\t\t id);\n\t\t\t\t/* Discard the unexpected message; good idea?? */\n\t\t\t\tconn->inStart = conn->inEnd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In BUSY state, we can process everything.\n\t\t\t */\n\t\t\tswitch (id)\n\t\t\t{\n\t\t\t\tcase 'C':\t\t/* command complete */\n\t\t\t\t\tif (pqGets(&conn->workBuffer, conn))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (conn->result == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn->result = PQmakeEmptyPGresult(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PGRES_COMMAND_OK);\n\t\t\t\t\t\tif (!conn->result)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tstrncpy(conn->result->cmdStatus, conn->workBuffer.data,\n\t\t\t\t\t\t\tCMDSTATUS_LEN);\n\t\t\t\t\tcheckXactStatus(conn, conn->workBuffer.data);\n\t\t\t\t\tconn->asyncStatus = PGASYNC_READY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\t\t/* error return */\n\t\t\t\t\tif (pqGetErrorNotice2(conn, true))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tconn->asyncStatus = PGASYNC_READY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Z':\t\t/* backend is ready for new query */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_IDLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\t\t/* empty query */\n\t\t\t\t\t/* read and throw away the closing '\\0' */\n\t\t\t\t\tif (pqGetc(&id, conn))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (id != '\\0')\n\t\t\t\t\t\tpqInternalNotice(&conn->noticeHooks,\n\t\t\t\t\t\t\t\t\t\t \"unexpected character %c following empty query response (\\\"I\\\" message)\",\n\t\t\t\t\t\t\t\t\t\t id);\n\t\t\t\t\tif (conn->result == NULL)\n\t\t\t\t\t\tconn->result = PQmakeEmptyPGresult(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PGRES_EMPTY_QUERY);\n\t\t\t\t\tconn->asyncStatus = PGASYNC_READY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\t\t/* secret key data from the backend */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * This is expected only during backend startup, but it's\n\t\t\t\t\t * just as easy to handle it as part of the main loop.\n\t\t\t\t\t * Save the data and continue processing.\n\t\t\t\t\t */\n\t\t\t\t\tif (pqGetInt(&(conn->be_pid), 4, conn))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (pqGetInt(&(conn->be_key), 4, conn))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\t\t/* synchronous (normal) portal */\n\t\t\t\t\tif (pqGets(&conn->workBuffer, conn))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t/* We pretty much ignore this message type... */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* row descriptions (start of query results) */\n\t\t\t\t\tif (conn->result == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* First 'T' in a query sequence */\n\t\t\t\t\t\tif (getRowDescriptions(conn))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A new 'T' message is treated as the start of\n\t\t\t\t\t\t * another PGresult.  (It is not clear that this is\n\t\t\t\t\t\t * really possible with the current backend.) We stop\n\t\t\t\t\t\t * parsing until the application accepts the current\n\t\t\t\t\t\t * result.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconn->asyncStatus = PGASYNC_READY;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\t\t/* ASCII data tuple */\n\t\t\t\t\tif (conn->result != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read another tuple of a normal query response */\n\t\t\t\t\t\tif (getAnotherTuple(conn, FALSE))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpqInternalNotice(&conn->noticeHooks,\n\t\t\t\t\t\t\t\t\t\t \"server sent data (\\\"D\\\" message) without prior row description (\\\"T\\\" message)\");\n\t\t\t\t\t\t/* Discard the unexpected message; good idea?? */\n\t\t\t\t\t\tconn->inStart = conn->inEnd;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\t\t/* Binary data tuple */\n\t\t\t\t\tif (conn->result != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read another tuple of a normal query response */\n\t\t\t\t\t\tif (getAnotherTuple(conn, TRUE))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpqInternalNotice(&conn->noticeHooks,\n\t\t\t\t\t\t\t\t\t\t \"server sent binary data (\\\"B\\\" message) without prior row description (\\\"T\\\" message)\");\n\t\t\t\t\t\t/* Discard the unexpected message; good idea?? */\n\t\t\t\t\t\tconn->inStart = conn->inEnd;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\t\t/* Start Copy In */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_COPY_IN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'H':\t\t/* Start Copy Out */\n\t\t\t\t\tconn->asyncStatus = PGASYNC_COPY_OUT;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't need to process CopyBothResponse here because it\n\t\t\t\t\t * never arrives from the server during protocol 2.0.\n\t\t\t\t\t */\n\t\t\t\tdefault:\n\t\t\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t\t\t  libpq_gettext(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unexpected response from server; first received character was \\\"%c\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t  id);\n\t\t\t\t\t/* build an error result holding the error message */\n\t\t\t\t\tpqSaveErrorResult(conn);\n\t\t\t\t\t/* Discard the unexpected message; good idea?? */\n\t\t\t\t\tconn->inStart = conn->inEnd;\n\t\t\t\t\tconn->asyncStatus = PGASYNC_READY;\n\t\t\t\t\treturn;\n\t\t\t}\t\t\t\t\t/* switch on protocol character */\n\t\t}\n\t\t/* Successfully consumed this message */\n\t\tconn->inStart = conn->inCursor;\n\t}\n}", "path": "src\\interfaces\\libpq\\fe-protocol2.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n *\t\tPQescapeBytea\t- converts from binary string to the\n *\t\tminimal encoding necessary to include the string in an SQL\n *\t\tINSERT statement with a bytea type column as the target.\n *\n *\t\tWe can use either hex or escape (traditional) encoding.\n *\t\tIn escape mode, the following transformations are applied:\n *\t\t'\\0' == ASCII  0 == \\000\n *\t\t'\\'' == ASCII 39 == ''\n *\t\t'\\\\' == ASCII 92 == \\\\\n *\t\tanything < 0x20, or > 0x7e ---> \\ooo\n *\t\t\t\t\t\t\t\t\t\t(where ooo is an octal expression)\n *\n *\t\tIf not std_strings, all backslashes sent to the output are doubled.\n */\n", "func_signal": "static unsigned char *\nPQescapeByteaInternal(PGconn *conn,\n\t\t\t\t\t  const unsigned char *from, size_t from_length,\n\t\t\t\t\t  size_t *to_length, bool std_strings, bool use_hex)", "code": "{\n\tconst unsigned char *vp;\n\tunsigned char *rp;\n\tunsigned char *result;\n\tsize_t\t\ti;\n\tsize_t\t\tlen;\n\tsize_t\t\tbslash_len = (std_strings ? 1 : 2);\n\n\t/*\n\t * empty string has 1 char ('\\0')\n\t */\n\tlen = 1;\n\n\tif (use_hex)\n\t{\n\t\tlen += bslash_len + 1 + 2 * from_length;\n\t}\n\telse\n\t{\n\t\tvp = from;\n\t\tfor (i = from_length; i > 0; i--, vp++)\n\t\t{\n\t\t\tif (*vp < 0x20 || *vp > 0x7e)\n\t\t\t\tlen += bslash_len + 3;\n\t\t\telse if (*vp == '\\'')\n\t\t\t\tlen += 2;\n\t\t\telse if (*vp == '\\\\')\n\t\t\t\tlen += bslash_len + bslash_len;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\t*to_length = len;\n\trp = result = (unsigned char *) malloc(len);\n\tif (rp == NULL)\n\t{\n\t\tif (conn)\n\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t\t  libpq_gettext(\"out of memory\\n\"));\n\t\treturn NULL;\n\t}\n\n\tif (use_hex)\n\t{\n\t\tif (!std_strings)\n\t\t\t*rp++ = '\\\\';\n\t\t*rp++ = '\\\\';\n\t\t*rp++ = 'x';\n\t}\n\n\tvp = from;\n\tfor (i = from_length; i > 0; i--, vp++)\n\t{\n\t\tunsigned char c = *vp;\n\n\t\tif (use_hex)\n\t\t{\n\t\t\t*rp++ = hextbl[(c >> 4) & 0xF];\n\t\t\t*rp++ = hextbl[c & 0xF];\n\t\t}\n\t\telse if (c < 0x20 || c > 0x7e)\n\t\t{\n\t\t\tif (!std_strings)\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t*rp++ = '\\\\';\n\t\t\t*rp++ = (c >> 6) + '0';\n\t\t\t*rp++ = ((c >> 3) & 07) + '0';\n\t\t\t*rp++ = (c & 07) + '0';\n\t\t}\n\t\telse if (c == '\\'')\n\t\t{\n\t\t\t*rp++ = '\\'';\n\t\t\t*rp++ = '\\'';\n\t\t}\n\t\telse if (c == '\\\\')\n\t\t{\n\t\t\tif (!std_strings)\n\t\t\t{\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t}\n\t\t\t*rp++ = '\\\\';\n\t\t\t*rp++ = '\\\\';\n\t\t}\n\t\telse\n\t\t\t*rp++ = c;\n\t}\n\t*rp = '\\0';\n\n\treturn result;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQsendDescribe\n *\t Common code to send a Describe command\n *\n * Available options for desc_type are\n *\t 'S' to describe a prepared statement; or\n *\t 'P' to describe a portal.\n * Returns 1 on success and 0 on failure.\n */\n", "func_signal": "static int\nPQsendDescribe(PGconn *conn, char desc_type, const char *desc_target)", "code": "{\n\t/* Treat null desc_target as empty string */\n\tif (!desc_target)\n\t\tdesc_target = \"\";\n\n\tif (!PQsendQueryStart(conn))\n\t\treturn 0;\n\n\t/* This isn't gonna work on a 2.0 server */\n\tif (PG_PROTOCOL_MAJOR(conn->pversion) < 3)\n\t{\n\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t libpq_gettext(\"function requires at least protocol version 3.0\\n\"));\n\t\treturn 0;\n\t}\n\n\t/* construct the Describe message */\n\tif (pqPutMsgStart('D', false, conn) < 0 ||\n\t\tpqPutc(desc_type, conn) < 0 ||\n\t\tpqPuts(desc_target, conn) < 0 ||\n\t\tpqPutMsgEnd(conn) < 0)\n\t\tgoto sendFailed;\n\n\t/* construct the Sync message */\n\tif (pqPutMsgStart('S', false, conn) < 0 ||\n\t\tpqPutMsgEnd(conn) < 0)\n\t\tgoto sendFailed;\n\n\t/* remember we are doing a Describe */\n\tconn->queryclass = PGQUERY_DESCRIBE;\n\n\t/* reset last-query string (not relevant now) */\n\tif (conn->last_query)\n\t{\n\t\tfree(conn->last_query);\n\t\tconn->last_query = NULL;\n\t}\n\n\t/*\n\t * Give the data a push.  In nonblock mode, don't complain if we're unable\n\t * to send it all; PQgetResult() will do any additional flushing needed.\n\t */\n\tif (pqFlush(conn) < 0)\n\t\tgoto sendFailed;\n\n\t/* OK, it's launched! */\n\tconn->asyncStatus = PGASYNC_BUSY;\n\treturn 1;\n\nsendFailed:\n\tpqHandleSendFailure(conn);\n\treturn 0;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * parseInput subroutine to read a 'B' or 'D' (row data) message.\n * We add another tuple to the existing PGresult structure.\n * Returns: 0 if completed message, EOF if error or not enough data yet.\n *\n * Note that if we run out of data, we have to suspend and reprocess\n * the message after more data is received.  We keep a partially constructed\n * tuple in conn->curTuple, and avoid reallocating already-allocated storage.\n */\n", "func_signal": "static int\ngetAnotherTuple(PGconn *conn, bool binary)", "code": "{\n\tPGresult   *result = conn->result;\n\tint\t\t\tnfields = result->numAttributes;\n\tPGresAttValue *tup;\n\n\t/* the backend sends us a bitmap of which attributes are null */\n\tchar\t\tstd_bitmap[64]; /* used unless it doesn't fit */\n\tchar\t   *bitmap = std_bitmap;\n\tint\t\t\ti;\n\tsize_t\t\tnbytes;\t\t\t/* the number of bytes in bitmap  */\n\tchar\t\tbmap;\t\t\t/* One byte of the bitmap */\n\tint\t\t\tbitmap_index;\t/* Its index */\n\tint\t\t\tbitcnt;\t\t\t/* number of bits examined in current byte */\n\tint\t\t\tvlen;\t\t\t/* length of the current field value */\n\n\tresult->binary = binary;\n\n\t/* Allocate tuple space if first time for this data message */\n\tif (conn->curTuple == NULL)\n\t{\n\t\tconn->curTuple = (PGresAttValue *)\n\t\t\tpqResultAlloc(result, nfields * sizeof(PGresAttValue), TRUE);\n\t\tif (conn->curTuple == NULL)\n\t\t\tgoto outOfMemory;\n\t\tMemSet(conn->curTuple, 0, nfields * sizeof(PGresAttValue));\n\n\t\t/*\n\t\t * If it's binary, fix the column format indicators.  We assume the\n\t\t * backend will consistently send either B or D, not a mix.\n\t\t */\n\t\tif (binary)\n\t\t{\n\t\t\tfor (i = 0; i < nfields; i++)\n\t\t\t\tresult->attDescs[i].format = 1;\n\t\t}\n\t}\n\ttup = conn->curTuple;\n\n\t/* Get the null-value bitmap */\n\tnbytes = (nfields + BITS_PER_BYTE - 1) / BITS_PER_BYTE;\n\t/* malloc() only for unusually large field counts... */\n\tif (nbytes > sizeof(std_bitmap))\n\t{\n\t\tbitmap = (char *) malloc(nbytes);\n\t\tif (!bitmap)\n\t\t\tgoto outOfMemory;\n\t}\n\n\tif (pqGetnchar(bitmap, nbytes, conn))\n\t\tgoto EOFexit;\n\n\t/* Scan the fields */\n\tbitmap_index = 0;\n\tbmap = bitmap[bitmap_index];\n\tbitcnt = 0;\n\n\tfor (i = 0; i < nfields; i++)\n\t{\n\t\tif (!(bmap & 0200))\n\t\t{\n\t\t\t/* if the field value is absent, make it a null string */\n\t\t\ttup[i].value = result->null_field;\n\t\t\ttup[i].len = NULL_LEN;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* get the value length (the first four bytes are for length) */\n\t\t\tif (pqGetInt(&vlen, 4, conn))\n\t\t\t\tgoto EOFexit;\n\t\t\tif (!binary)\n\t\t\t\tvlen = vlen - 4;\n\t\t\tif (vlen < 0)\n\t\t\t\tvlen = 0;\n\t\t\tif (tup[i].value == NULL)\n\t\t\t{\n\t\t\t\ttup[i].value = (char *) pqResultAlloc(result, vlen + 1, binary);\n\t\t\t\tif (tup[i].value == NULL)\n\t\t\t\t\tgoto outOfMemory;\n\t\t\t}\n\t\t\ttup[i].len = vlen;\n\t\t\t/* read in the value */\n\t\t\tif (vlen > 0)\n\t\t\t\tif (pqGetnchar((char *) (tup[i].value), vlen, conn))\n\t\t\t\t\tgoto EOFexit;\n\t\t\t/* we have to terminate this ourselves */\n\t\t\ttup[i].value[vlen] = '\\0';\n\t\t}\n\t\t/* advance the bitmap stuff */\n\t\tbitcnt++;\n\t\tif (bitcnt == BITS_PER_BYTE)\n\t\t{\n\t\t\tbitmap_index++;\n\t\t\tbmap = bitmap[bitmap_index];\n\t\t\tbitcnt = 0;\n\t\t}\n\t\telse\n\t\t\tbmap <<= 1;\n\t}\n\n\t/* Success!  Store the completed tuple in the result */\n\tif (!pqAddTuple(result, tup))\n\t\tgoto outOfMemory;\n\t/* and reset for a new message */\n\tconn->curTuple = NULL;\n\n\tif (bitmap != std_bitmap)\n\t\tfree(bitmap);\n\treturn 0;\n\noutOfMemory:\n\t/* Replace partially constructed result with an error result */\n\n\t/*\n\t * we do NOT use pqSaveErrorResult() here, because of the likelihood that\n\t * there's not enough memory to concatenate messages...\n\t */\n\tpqClearAsyncResult(conn);\n\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t  libpq_gettext(\"out of memory for query result\\n\"));\n\n\t/*\n\t * XXX: if PQmakeEmptyPGresult() fails, there's probably not much we can\n\t * do to recover...\n\t */\n\tconn->result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);\n\tconn->asyncStatus = PGASYNC_READY;\n\t/* Discard the failed message --- good idea? */\n\tconn->inStart = conn->inEnd;\n\nEOFexit:\n\tif (bitmap != NULL && bitmap != std_bitmap)\n\t\tfree(bitmap);\n\treturn EOF;\n}", "path": "src\\interfaces\\libpq\\fe-protocol2.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n *\t\tPQunescapeBytea - converts the null terminated string representation\n *\t\tof a bytea, strtext, into binary, filling a buffer. It returns a\n *\t\tpointer to the buffer (or NULL on error), and the size of the\n *\t\tbuffer in retbuflen. The pointer may subsequently be used as an\n *\t\targument to the function PQfreemem.\n *\n *\t\tThe following transformations are made:\n *\t\t\\\\\t == ASCII 92 == \\\n *\t\t\\ooo == a byte whose value = ooo (ooo is an octal number)\n *\t\t\\x\t == x (x is any character not matched by the above transformations)\n */\n", "func_signal": "unsigned char *\nPQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)", "code": "{\n\tsize_t\t\tstrtextlen,\n\t\t\t\tbuflen;\n\tunsigned char *buffer,\n\t\t\t   *tmpbuf;\n\tsize_t\t\ti,\n\t\t\t\tj;\n\n\tif (strtext == NULL)\n\t\treturn NULL;\n\n\tstrtextlen = strlen((const char *) strtext);\n\n\tif (strtext[0] == '\\\\' && strtext[1] == 'x')\n\t{\n\t\tconst unsigned char *s;\n\t\tunsigned char *p;\n\n\t\tbuflen = (strtextlen - 2) / 2;\n\t\t/* Avoid unportable malloc(0) */\n\t\tbuffer = (unsigned char *) malloc(buflen > 0 ? buflen : 1);\n\t\tif (buffer == NULL)\n\t\t\treturn NULL;\n\n\t\ts = strtext + 2;\n\t\tp = buffer;\n\t\twhile (*s)\n\t\t{\n\t\t\tchar\t\tv1,\n\t\t\t\t\t\tv2;\n\n\t\t\t/*\n\t\t\t * Bad input is silently ignored.  Note that this includes\n\t\t\t * whitespace between hex pairs, which is allowed by byteain.\n\t\t\t */\n\t\t\tv1 = get_hex(*s++);\n\t\t\tif (!*s || v1 == (char) -1)\n\t\t\t\tcontinue;\n\t\t\tv2 = get_hex(*s++);\n\t\t\tif (v2 != (char) -1)\n\t\t\t\t*p++ = (v1 << 4) | v2;\n\t\t}\n\n\t\tbuflen = p - buffer;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Length of input is max length of output, but add one to avoid\n\t\t * unportable malloc(0) if input is zero-length.\n\t\t */\n\t\tbuffer = (unsigned char *) malloc(strtextlen + 1);\n\t\tif (buffer == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = j = 0; i < strtextlen;)\n\t\t{\n\t\t\tswitch (strtext[i])\n\t\t\t{\n\t\t\t\tcase '\\\\':\n\t\t\t\t\ti++;\n\t\t\t\t\tif (strtext[i] == '\\\\')\n\t\t\t\t\t\tbuffer[j++] = strtext[i++];\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((ISFIRSTOCTDIGIT(strtext[i])) &&\n\t\t\t\t\t\t\t(ISOCTDIGIT(strtext[i + 1])) &&\n\t\t\t\t\t\t\t(ISOCTDIGIT(strtext[i + 2])))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\tbyte;\n\n\t\t\t\t\t\t\tbyte = OCTVAL(strtext[i++]);\n\t\t\t\t\t\t\tbyte = (byte << 3) + OCTVAL(strtext[i++]);\n\t\t\t\t\t\t\tbyte = (byte << 3) + OCTVAL(strtext[i++]);\n\t\t\t\t\t\t\tbuffer[j++] = byte;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: if we see '\\' followed by something that isn't a\n\t\t\t\t\t * recognized escape sequence, we loop around having done\n\t\t\t\t\t * nothing except advance i.  Therefore the something will\n\t\t\t\t\t * be emitted as ordinary data on the next cycle. Corner\n\t\t\t\t\t * case: '\\' at end of string will just be discarded.\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbuffer[j++] = strtext[i++];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuflen = j;\t\t\t\t/* buflen is the length of the dequoted data */\n\t}\n\n\t/* Shrink the buffer to be no larger than necessary */\n\t/* +1 avoids unportable behavior when buflen==0 */\n\ttmpbuf = realloc(buffer, buflen + 1);\n\n\t/* It would only be a very brain-dead realloc that could fail, but... */\n\tif (!tmpbuf)\n\t{\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\n\t*retbuflen = buflen;\n\treturn tmpbuf;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQnotifies\n *\t  returns a PGnotify* structure of the latest async notification\n * that has not yet been handled\n *\n * returns NULL, if there is currently\n * no unhandled async notification from the backend\n *\n * the CALLER is responsible for FREE'ing the structure returned\n */\n", "func_signal": "PGnotify *\nPQnotifies(PGconn *conn)", "code": "{\n\tPGnotify   *event;\n\n\tif (!conn)\n\t\treturn NULL;\n\n\t/* Parse any available data to see if we can extract NOTIFY messages. */\n\tparseInput(conn);\n\n\tevent = conn->notifyHead;\n\tif (event)\n\t{\n\t\tconn->notifyHead = event->next;\n\t\tif (!conn->notifyHead)\n\t\t\tconn->notifyTail = NULL;\n\t\tevent->next = NULL;\t\t/* don't let app see the internal state */\n\t}\n\treturn event;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQexecPrepared\n *\t\tLike PQexec, but execute a previously prepared statement,\n *\t\tusing protocol 3.0 so we can pass parameters\n */\n", "func_signal": "PGresult *\nPQexecPrepared(PGconn *conn,\n\t\t\t   const char *stmtName,\n\t\t\t   int nParams,\n\t\t\t   const char *const * paramValues,\n\t\t\t   const int *paramLengths,\n\t\t\t   const int *paramFormats,\n\t\t\t   int resultFormat)", "code": "{\n\tif (!PQexecStart(conn))\n\t\treturn NULL;\n\tif (!PQsendQueryPrepared(conn, stmtName,\n\t\t\t\t\t\t\t nParams, paramValues, paramLengths,\n\t\t\t\t\t\t\t paramFormats, resultFormat))\n\t\treturn NULL;\n\treturn PQexecFinish(conn);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * Common startup code for PQsendQuery and sibling routines\n */\n", "func_signal": "static bool\nPQsendQueryStart(PGconn *conn)", "code": "{\n\tif (!conn)\n\t\treturn false;\n\n\t/* clear the error string */\n\tresetPQExpBuffer(&conn->errorMessage);\n\n\t/* Don't try to send if we know there's no live connection. */\n\tif (conn->status != CONNECTION_OK)\n\t{\n\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t\t  libpq_gettext(\"no connection to the server\\n\"));\n\t\treturn false;\n\t}\n\t/* Can't send while already busy, either. */\n\tif (conn->asyncStatus != PGASYNC_IDLE)\n\t{\n\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t  libpq_gettext(\"another command is already in progress\\n\"));\n\t\treturn false;\n\t}\n\n\t/* initialize async result-accumulation state */\n\tconn->result = NULL;\n\tconn->curTuple = NULL;\n\n\t/* ready to send command message */\n\treturn true;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/* PQgetlength:\n *\treturns the actual length of a field value in bytes.\n */\n", "func_signal": "int\nPQgetlength(const PGresult *res, int tup_num, int field_num)", "code": "{\n\tif (!check_tuple_field_number(res, tup_num, field_num))\n\t\treturn 0;\n\tif (res->tuples[tup_num][field_num].len != NULL_LEN)\n\t\treturn res->tuples[tup_num][field_num].len;\n\telse\n\t\treturn 0;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * Common code for PQexec and sibling routines: prepare to send command\n */\n", "func_signal": "static bool\nPQexecStart(PGconn *conn)", "code": "{\n\tPGresult   *result;\n\n\tif (!conn)\n\t\treturn false;\n\n\t/*\n\t * Silently discard any prior query result that application didn't eat.\n\t * This is probably poor design, but it's here for backward compatibility.\n\t */\n\twhile ((result = PQgetResult(conn)) != NULL)\n\t{\n\t\tExecStatusType resultStatus = result->resultStatus;\n\n\t\tPQclear(result);\t\t/* only need its status */\n\t\tif (resultStatus == PGRES_COPY_IN)\n\t\t{\n\t\t\tif (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)\n\t\t\t{\n\t\t\t\t/* In protocol 3, we can get out of a COPY IN state */\n\t\t\t\tif (PQputCopyEnd(conn,\n\t\t\t\t\t\t libpq_gettext(\"COPY terminated by new PQexec\")) < 0)\n\t\t\t\t\treturn false;\n\t\t\t\t/* keep waiting to swallow the copy's failure message */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* In older protocols we have to punt */\n\t\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t  libpq_gettext(\"COPY IN state must be terminated first\\n\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (resultStatus == PGRES_COPY_OUT)\n\t\t{\n\t\t\tif (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In protocol 3, we can get out of a COPY OUT state: we just\n\t\t\t\t * switch back to BUSY and allow the remaining COPY data to be\n\t\t\t\t * dropped on the floor.\n\t\t\t\t */\n\t\t\t\tconn->asyncStatus = PGASYNC_BUSY;\n\t\t\t\t/* keep waiting to swallow the copy's completion message */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* In older protocols we have to punt */\n\t\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t libpq_gettext(\"COPY OUT state must be terminated first\\n\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (resultStatus == PGRES_COPY_BOTH)\n\t\t{\n\t\t\t/* We don't allow PQexec during COPY BOTH */\n\t\t\tprintfPQExpBuffer(&conn->errorMessage,\n\t\t\t\t\t libpq_gettext(\"PQexec not allowed during COPY BOTH\\n\"));\n\t\t\treturn false;\n\t\t}\n\t\t/* check for loss of connection, too */\n\t\tif (conn->status == CONNECTION_BAD)\n\t\t\treturn false;\n\t}\n\n\t/* OK to send a command */\n\treturn true;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQisBusy\n *\t Return TRUE if PQgetResult would block waiting for input.\n */\n", "func_signal": "int\nPQisBusy(PGconn *conn)", "code": "{\n\tif (!conn)\n\t\treturn FALSE;\n\n\t/* Parse any available data, if our state permits. */\n\tparseInput(conn);\n\n\t/* PQgetResult will return immediately in all states except BUSY. */\n\treturn conn->asyncStatus == PGASYNC_BUSY;\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/*\n * PQprepare\n *\t  Creates a prepared statement by issuing a v3.0 parse message.\n *\n * If the query was not even sent, return NULL; conn->errorMessage is set to\n * a relevant message.\n * If the query was sent, a new PGresult is returned (which could indicate\n * either success or failure).\n * The user is responsible for freeing the PGresult via PQclear()\n * when done with it.\n */\n", "func_signal": "PGresult *\nPQprepare(PGconn *conn,\n\t\t  const char *stmtName, const char *query,\n\t\t  int nParams, const Oid *paramTypes)", "code": "{\n\tif (!PQexecStart(conn))\n\t\treturn NULL;\n\tif (!PQsendPrepare(conn, stmtName, query, nParams, paramTypes))\n\t\treturn NULL;\n\treturn PQexecFinish(conn);\n}", "path": "src\\interfaces\\libpq\\fe-exec.c", "repo_name": "decision-labs/libpq-ios", "stars": 12, "license": "other", "language": "c", "size": 4124}
{"docstring": "/**\n *\tsil_set_dma_mode\t-\tset host controller for DMA mode\n *\t@drive: drive\n *\t@speed: DMA mode\n *\n *\tTune the SiI chipset for the desired DMA mode.\n */\n", "func_signal": "static void sil_set_dma_mode(ide_drive_t *drive, const u8 speed)", "code": "{\n\tstatic const u8 ultra6[] = { 0x0F, 0x0B, 0x07, 0x05, 0x03, 0x02, 0x01 };\n\tstatic const u8 ultra5[] = { 0x0C, 0x07, 0x05, 0x04, 0x02, 0x01 };\n\tstatic const u16 dma[]\t = { 0x2208, 0x10C2, 0x10C1 };\n\n\tide_hwif_t *hwif\t= drive->hwif;\n\tstruct pci_dev *dev\t= to_pci_dev(hwif->dev);\n\tunsigned long base\t= (unsigned long)hwif->hwif_data;\n\tu16 ultra = 0, multi\t= 0;\n\tu8 mode = 0, unit\t= drive->dn & 1;\n\tu8 mmio\t\t\t= (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;\n\tu8 scsc = 0, addr_mask\t= hwif->channel ? (mmio ? 0xF4 : 0x84)\n\t\t\t\t\t\t: (mmio ? 0xB4 : 0x80);\n\tunsigned long ma\t= siimage_seldev(drive, 0x08);\n\tunsigned long ua\t= siimage_seldev(drive, 0x0C);\n\n\tscsc  = sil_ioread8 (dev, base + (mmio ? 0x4A : 0x8A));\n\tmode  = sil_ioread8 (dev, base + addr_mask);\n\tmulti = sil_ioread16(dev, ma);\n\tultra = sil_ioread16(dev, ua);\n\n\tmode  &= ~(unit ? 0x30 : 0x03);\n\tultra &= ~0x3F;\n\tscsc = ((scsc & 0x30) == 0x00) ? 0 : 1;\n\n\tscsc = is_sata(hwif) ? 1 : scsc;\n\n\tif (speed >= XFER_UDMA_0) {\n\t\tmulti  = dma[2];\n\t\tultra |= scsc ? ultra6[speed - XFER_UDMA_0] :\n\t\t\t\tultra5[speed - XFER_UDMA_0];\n\t\tmode  |= unit ? 0x30 : 0x03;\n\t} else {\n\t\tmulti = dma[speed - XFER_MW_DMA_0];\n\t\tmode |= unit ? 0x20 : 0x02;\n\t}\n\n\tsil_iowrite8 (dev, mode, base + addr_mask);\n\tsil_iowrite16(dev, multi, ma);\n\tsil_iowrite16(dev, ultra, ua);\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tinit_chipset_siimage\t-\tset up an SI device\n *\t@dev: PCI device\n *\n *\tPerform the initial PCI set up for this device. Attempt to switch\n *\tto 133 MHz clocking if the system isn't already set up to do it.\n */\n", "func_signal": "static int init_chipset_siimage(struct pci_dev *dev)", "code": "{\n\tstruct ide_host *host = pci_get_drvdata(dev);\n\tvoid __iomem *ioaddr = host->host_priv;\n\tunsigned long base, scsc_addr;\n\tu8 rev = dev->revision, tmp;\n\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, rev ? 1 : 255);\n\n\tif (ioaddr)\n\t\tpci_set_master(dev);\n\n\tbase = (unsigned long)ioaddr;\n\n\tif (ioaddr && pdev_is_sata(dev)) {\n\t\tu32 tmp32, irq_mask;\n\n\t\t/* make sure IDE0/1 interrupts are not masked */\n\t\tirq_mask = (1 << 22) | (1 << 23);\n\t\ttmp32 = readl(ioaddr + 0x48);\n\t\tif (tmp32 & irq_mask) {\n\t\t\ttmp32 &= ~irq_mask;\n\t\t\twritel(tmp32, ioaddr + 0x48);\n\t\t\treadl(ioaddr + 0x48); /* flush */\n\t\t}\n\t\twritel(0, ioaddr + 0x148);\n\t\twritel(0, ioaddr + 0x1C8);\n\t}\n\n\tsil_iowrite8(dev, 0, base ? (base + 0xB4) : 0x80);\n\tsil_iowrite8(dev, 0, base ? (base + 0xF4) : 0x84);\n\n\tscsc_addr = base ? (base + 0x4A) : 0x8A;\n\ttmp = sil_ioread8(dev, scsc_addr);\n\n\tswitch (tmp & 0x30) {\n\tcase 0x00:\n\t\t/* On 100 MHz clocking, try and switch to 133 MHz */\n\t\tsil_iowrite8(dev, tmp | 0x10, scsc_addr);\n\t\tbreak;\n\tcase 0x30:\n\t\t/* Clocking is disabled, attempt to force 133MHz clocking. */\n\t\tsil_iowrite8(dev, tmp & ~0x20, scsc_addr);\n\tcase 0x10:\n\t\t/* On 133Mhz clocking. */\n\t\tbreak;\n\tcase 0x20:\n\t\t/* On PCIx2 clocking. */\n\t\tbreak;\n\t}\n\n\ttmp = sil_ioread8(dev, scsc_addr);\n\n\tsil_iowrite8 (dev,       0x72, base + 0xA1);\n\tsil_iowrite16(dev,     0x328A, base + 0xA2);\n\tsil_iowrite32(dev, 0x62DD62DD, base + 0xA4);\n\tsil_iowrite32(dev, 0x43924392, base + 0xA8);\n\tsil_iowrite32(dev, 0x40094009, base + 0xAC);\n\tsil_iowrite8 (dev,       0x72, base ? (base + 0xE1) : 0xB1);\n\tsil_iowrite16(dev,     0x328A, base ? (base + 0xE2) : 0xB2);\n\tsil_iowrite32(dev, 0x62DD62DD, base ? (base + 0xE4) : 0xB4);\n\tsil_iowrite32(dev, 0x43924392, base ? (base + 0xE8) : 0xB8);\n\tsil_iowrite32(dev, 0x40094009, base ? (base + 0xEC) : 0xBC);\n\n\tif (base && pdev_is_sata(dev)) {\n\t\twritel(0xFFFF0000, ioaddr + 0x108);\n\t\twritel(0xFFFF0000, ioaddr + 0x188);\n\t\twritel(0x00680000, ioaddr + 0x148);\n\t\twritel(0x00680000, ioaddr + 0x1C8);\n\t}\n\n\t/* report the clocking mode of the controller */\n\tif (!pdev_is_sata(dev)) {\n\t\tstatic const char *clk_str[] =\n\t\t\t{ \"== 100\", \"== 133\", \"== 2X PCI\", \"DISABLED!\" };\n\n\t\ttmp >>= 4;\n\t\tprintk(KERN_INFO DRV_NAME \" %s: BASE CLOCK %s\\n\",\n\t\t\tpci_name(dev), clk_str[tmp & 3]);\n\t}\n\n\treturn 0;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsiimage_mmio_dma_test_irq\t-\tcheck we caused an IRQ\n *\t@drive: drive we are testing\n *\n *\tCheck if we caused an IDE DMA interrupt. We may also have caused\n *\tSATA status interrupts, if so we clean them up and continue.\n */\n", "func_signal": "static int siimage_mmio_dma_test_irq(ide_drive_t *drive)", "code": "{\n\tide_hwif_t *hwif\t= drive->hwif;\n\tvoid __iomem *sata_error_addr\n\t\t= (void __iomem *)hwif->sata_scr[SATA_ERROR_OFFSET];\n\n\tif (sata_error_addr) {\n\t\tunsigned long base\t= (unsigned long)hwif->hwif_data;\n\t\tu32 ext_stat\t\t= readl((void __iomem *)(base + 0x10));\n\t\tu8 watchdog\t\t= 0;\n\n\t\tif (ext_stat & ((hwif->channel) ? 0x40 : 0x10)) {\n\t\t\tu32 sata_error = readl(sata_error_addr);\n\n\t\t\twritel(sata_error, sata_error_addr);\n\t\t\twatchdog = (sata_error & 0x00680000) ? 1 : 0;\n\t\t\tprintk(KERN_WARNING \"%s: sata_error = 0x%08x, \"\n\t\t\t\t\"watchdog = %d, %s\\n\",\n\t\t\t\tdrive->name, sata_error, watchdog, __func__);\n\t\t} else\n\t\t\twatchdog = (ext_stat & 0x8000) ? 1 : 0;\n\n\t\text_stat >>= 16;\n\t\tif (!(ext_stat & 0x0404) && !watchdog)\n\t\t\treturn 0;\n\t}\n\n\t/* return 1 if INTR asserted */\n\tif (readb((void __iomem *)(hwif->dma_base + ATA_DMA_STATUS)) & 4)\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsiimage_selreg\t\t-\treturn register base\n *\t@hwif: interface\n *\t@r: config offset\n *\n *\tTurn a config register offset into the right address in either\n *\tPCI space or MMIO space to access the control register in question\n *\tThankfully this is a configuration operation, so isn't performance\n *\tcritical.\n */\n", "func_signal": "static unsigned long siimage_selreg(ide_hwif_t *hwif, int r)", "code": "{\n\tunsigned long base = (unsigned long)hwif->hwif_data;\n\n\tbase += 0xA0 + r;\n\tif (hwif->host_flags & IDE_HFLAG_MMIO)\n\t\tbase += hwif->channel << 6;\n\telse\n\t\tbase += hwif->channel << 4;\n\treturn base;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tinit_mmio_iops_siimage\t-\tset up the iops for MMIO\n *\t@hwif: interface to set up\n *\n *\tThe basic setup here is fairly simple, we can use standard MMIO\n *\toperations. However we do have to set the taskfile register offsets\n *\tby hand as there isn't a standard defined layout for them this time.\n *\n *\tThe hardware supports buffered taskfiles and also some rather nice\n *\textended PRD tables. For better SI3112 support use the libata driver\n */\n", "func_signal": "static void __devinit init_mmio_iops_siimage(ide_hwif_t *hwif)", "code": "{\n\tstruct pci_dev *dev\t= to_pci_dev(hwif->dev);\n\tstruct ide_host *host\t= pci_get_drvdata(dev);\n\tvoid *addr\t\t= host->host_priv;\n\tu8 ch\t\t\t= hwif->channel;\n\tstruct ide_io_ports *io_ports = &hwif->io_ports;\n\tunsigned long base;\n\n\t/*\n\t *\tFill in the basic hwif bits\n\t */\n\thwif->host_flags |= IDE_HFLAG_MMIO;\n\n\thwif->hwif_data\t= addr;\n\n\t/*\n\t *\tNow set up the hw. We have to do this ourselves as the\n\t *\tMMIO layout isn't the same as the standard port based I/O.\n\t */\n\tmemset(io_ports, 0, sizeof(*io_ports));\n\n\tbase = (unsigned long)addr;\n\tif (ch)\n\t\tbase += 0xC0;\n\telse\n\t\tbase += 0x80;\n\n\t/*\n\t *\tThe buffered task file doesn't have status/control, so we\n\t *\tcan't currently use it sanely since we want to use LBA48 mode.\n\t */\n\tio_ports->data_addr\t= base;\n\tio_ports->error_addr\t= base + 1;\n\tio_ports->nsect_addr\t= base + 2;\n\tio_ports->lbal_addr\t= base + 3;\n\tio_ports->lbam_addr\t= base + 4;\n\tio_ports->lbah_addr\t= base + 5;\n\tio_ports->device_addr\t= base + 6;\n\tio_ports->status_addr\t= base + 7;\n\tio_ports->ctl_addr\t= base + 10;\n\n\tif (pdev_is_sata(dev)) {\n\t\tbase = (unsigned long)addr;\n\t\tif (ch)\n\t\t\tbase += 0x80;\n\t\thwif->sata_scr[SATA_STATUS_OFFSET]\t= base + 0x104;\n\t\thwif->sata_scr[SATA_ERROR_OFFSET]\t= base + 0x108;\n\t\thwif->sata_scr[SATA_CONTROL_OFFSET]\t= base + 0x100;\n\t}\n\n\thwif->irq = dev->irq;\n\n\thwif->dma_base = (unsigned long)addr + (ch ? 0x08 : 0x00);\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/* CONFIG_DEBUG_BOOT_PARAMS */\n", "func_signal": "static int __init arch_kdebugfs_init(void)", "code": "{\n\tint error = 0;\n\n\tarch_debugfs_dir = debugfs_create_dir(\"x86\", NULL);\n\tif (!arch_debugfs_dir)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DEBUG_BOOT_PARAMS\n\terror = boot_params_kdebugfs_init();\n#endif\n\n\treturn error;\n}", "path": "Kernel\\arch\\x86\\kernel\\kdebugfs.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_cable_detect\t-\tcable detection\n *\t@hwif: interface to check\n *\n *\tCheck for the presence of an ATA66 capable cable on the interface.\n */\n", "func_signal": "static u8 sil_cable_detect(ide_hwif_t *hwif)", "code": "{\n\tstruct pci_dev *dev\t= to_pci_dev(hwif->dev);\n\tunsigned long addr\t= siimage_selreg(hwif, 0);\n\tu8 ata66\t\t= sil_ioread8(dev, addr);\n\n\treturn (ata66 & 0x01) ? ATA_CBL_PATA80 : ATA_CBL_PATA40;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsiimage_init_one\t-\tPCI layer discovery entry\n *\t@dev: PCI device\n *\t@id: ident table entry\n *\n *\tCalled by the PCI code when it finds an SiI680 or SiI3112 controller.\n *\tWe then use the IDE PCI generic helper to do most of the work.\n */\n", "func_signal": "static int __devinit siimage_init_one(struct pci_dev *dev,\n\t\t\t\t      const struct pci_device_id *id)", "code": "{\n\tvoid __iomem *ioaddr = NULL;\n\tresource_size_t bar5 = pci_resource_start(dev, 5);\n\tunsigned long barsize = pci_resource_len(dev, 5);\n\tint rc;\n\tstruct ide_port_info d;\n\tu8 idx = id->driver_data;\n\tu8 BA5_EN;\n\n\td = siimage_chipsets[idx];\n\n\tif (idx) {\n\t\tstatic int first = 1;\n\n\t\tif (first) {\n\t\t\tprintk(KERN_INFO DRV_NAME \": For full SATA support you \"\n\t\t\t\t\"should use the libata sata_sil module.\\n\");\n\t\t\tfirst = 0;\n\t\t}\n\n\t\td.host_flags |= IDE_HFLAG_NO_ATAPI_DMA;\n\t}\n\n\trc = pci_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_read_config_byte(dev, 0x8A, &BA5_EN);\n\tif ((BA5_EN & 0x01) || bar5) {\n\t\t/*\n\t\t* Drop back to PIO if we can't map the MMIO. Some systems\n\t\t* seem to get terminally confused in the PCI spaces.\n\t\t*/\n\t\tif (!request_mem_region(bar5, barsize, d.name)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME \" %s: MMIO ports not \"\n\t\t\t\t\"available\\n\", pci_name(dev));\n\t\t} else {\n\t\t\tioaddr = pci_ioremap_bar(dev, 5);\n\t\t\tif (ioaddr == NULL)\n\t\t\t\trelease_mem_region(bar5, barsize);\n\t\t}\n\t}\n\n\trc = ide_pci_init_one(dev, &d, ioaddr);\n\tif (rc) {\n\t\tif (ioaddr) {\n\t\t\tiounmap(ioaddr);\n\t\t\trelease_mem_region(bar5, barsize);\n\t\t}\n\t\tpci_disable_device(dev);\n\t}\n\n\treturn rc;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsiimage_seldev\t\t-\treturn register base\n *\t@hwif: interface\n *\t@r: config offset\n *\n *\tTurn a config register offset into the right address in either\n *\tPCI space or MMIO space to access the control register in question\n *\tincluding accounting for the unit shift.\n */\n", "func_signal": "static inline unsigned long siimage_seldev(ide_drive_t *drive, int r)", "code": "{\n\tide_hwif_t *hwif\t= drive->hwif;\n\tunsigned long base\t= (unsigned long)hwif->hwif_data;\n\tu8 unit\t\t\t= drive->dn & 1;\n\n\tbase += 0xA0 + r;\n\tif (hwif->host_flags & IDE_HFLAG_MMIO)\n\t\tbase += hwif->channel << 6;\n\telse\n\t\tbase += hwif->channel << 4;\n\tbase |= unit << unit;\n\treturn base;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_quirkproc\t\t-\tpost probe fixups\n *\t@drive: drive\n *\n *\tCalled after drive probe we use this to decide whether the\n *\tSeagate fixup must be applied. This used to be in init_iops but\n *\tthat can occur before we know what drives are present.\n */\n", "func_signal": "static void sil_quirkproc(ide_drive_t *drive)", "code": "{\n\tide_hwif_t *hwif = drive->hwif;\n\n\t/* Try and rise the rqsize */\n\tif (!is_sata(hwif) || !is_dev_seagate_sata(drive))\n\t\thwif->rqsize = 128;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tinit_iops_siimage\t-\tset up iops\n *\t@hwif: interface to set up\n *\n *\tDo the basic setup for the SIIMAGE hardware interface\n *\tand then do the MMIO setup if we can. This is the first\n *\tlook in we get for setting up the hwif so that we\n *\tcan get the iops right before using them.\n */\n", "func_signal": "static void __devinit init_iops_siimage(ide_hwif_t *hwif)", "code": "{\n\tstruct pci_dev *dev = to_pci_dev(hwif->dev);\n\tstruct ide_host *host = pci_get_drvdata(dev);\n\n\thwif->hwif_data = NULL;\n\n\t/* Pessimal until we finish probing */\n\thwif->rqsize = 15;\n\n\tif (host->host_priv)\n\t\tinit_mmio_iops_siimage(hwif);\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_sata_pre_reset\t-\treset hook\n *\t@drive: IDE device being reset\n *\n *\tFor the SATA devices we need to handle recalibration/geometry\n *\tdifferently\n */\n", "func_signal": "static void sil_sata_pre_reset(ide_drive_t *drive)", "code": "{\n\tif (drive->media == ide_disk) {\n\t\tdrive->special_flags &=\n\t\t\t~(IDE_SFLAG_SET_GEOMETRY | IDE_SFLAG_RECALIBRATE);\n\t}\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tpdev_is_sata\t\t-\tcheck if device is SATA\n *\t@pdev:\tPCI device to check\n *\n *\tReturns true if this is a SATA controller\n */\n", "func_signal": "static int pdev_is_sata(struct pci_dev *pdev)", "code": "{\n#ifdef CONFIG_BLK_DEV_IDE_SATA\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SII_3112:\n\tcase PCI_DEVICE_ID_SII_1210SA:\n\t\treturn 1;\n\tcase PCI_DEVICE_ID_SII_680:\n\t\treturn 0;\n\t}\n\tBUG();\n#endif\n\treturn 0;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_udma_filter\t\t-\tcompute UDMA mask\n *\t@drive: IDE device\n *\n *\tCompute the available UDMA speeds for the device on the interface.\n *\n *\tFor the CMD680 this depends on the clocking mode (scsc), for the\n *\tSI3112 SATA controller life is a bit simpler.\n */\n", "func_signal": "static u8 sil_pata_udma_filter(ide_drive_t *drive)", "code": "{\n\tide_hwif_t *hwif\t= drive->hwif;\n\tstruct pci_dev *dev\t= to_pci_dev(hwif->dev);\n\tunsigned long base\t= (unsigned long)hwif->hwif_data;\n\tu8 scsc, mask\t\t= 0;\n\n\tbase += (hwif->host_flags & IDE_HFLAG_MMIO) ? 0x4A : 0x8A;\n\n\tscsc = sil_ioread8(dev, base);\n\n\tswitch (scsc & 0x30) {\n\tcase 0x10:\t/* 133 */\n\t\tmask = ATA_UDMA6;\n\t\tbreak;\n\tcase 0x20:\t/* 2xPCI */\n\t\tmask = ATA_UDMA6;\n\t\tbreak;\n\tcase 0x00:\t/* 100 */\n\t\tmask = ATA_UDMA5;\n\t\tbreak;\n\tdefault: \t/* Disabled ? */\n\t\tBUG();\n\t}\n\n\treturn mask;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/*****************************************************************************/\n/*\n * paging_init() continues the virtual memory environment setup which\n * was begun by the code in arch/head.S.\n * The parameters are pointers to where to stick the starting and ending\n * addresses  of available kernel virtual memory.\n */\n", "func_signal": "void __init paging_init(void)", "code": "{\n\tunsigned long zones_size[MAX_NR_ZONES] = {0, };\n\n\t/* allocate some pages for kernel housekeeping tasks */\n\tempty_bad_page_table\t= (unsigned long) alloc_bootmem_pages(PAGE_SIZE);\n\tempty_bad_page\t\t= (unsigned long) alloc_bootmem_pages(PAGE_SIZE);\n\tempty_zero_page\t\t= (unsigned long) alloc_bootmem_pages(PAGE_SIZE);\n\n\tmemset((void *) empty_zero_page, 0, PAGE_SIZE);\n\n#ifdef CONFIG_HIGHMEM\n\tif (num_physpages - num_mappedpages) {\n\t\tpgd_t *pge;\n\t\tpud_t *pue;\n\t\tpmd_t *pme;\n\n\t\tpkmap_page_table = alloc_bootmem_pages(PAGE_SIZE);\n\n\t\tpge = swapper_pg_dir + pgd_index_k(PKMAP_BASE);\n\t\tpue = pud_offset(pge, PKMAP_BASE);\n\t\tpme = pmd_offset(pue, PKMAP_BASE);\n\t\t__set_pmd(pme, virt_to_phys(pkmap_page_table) | _PAGE_TABLE);\n\t}\n#endif\n\n\t/* distribute the allocatable pages across the various zones and pass them to the allocator\n\t */\n\tzones_size[ZONE_NORMAL]  = max_low_pfn - min_low_pfn;\n#ifdef CONFIG_HIGHMEM\n\tzones_size[ZONE_HIGHMEM] = num_physpages - num_mappedpages;\n#endif\n\n\tfree_area_init(zones_size);\n\n#ifdef CONFIG_MMU\n\t/* initialise init's MMU context */\n\tinit_new_context(&init_task, &init_mm);\n#endif\n\n}", "path": "Kernel\\arch\\frv\\mm\\init.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/*****************************************************************************/\n/*\n * free the memory that was only required for initialisation\n */\n", "func_signal": "void free_initmem(void)", "code": "{\n#if defined(CONFIG_RAMKERNEL) && !defined(CONFIG_PROTECT_KERNEL)\n\tunsigned long start, end, addr;\n\n\tstart = PAGE_ALIGN((unsigned long) &__init_begin);\t/* round up */\n\tend   = ((unsigned long) &__init_end) & PAGE_MASK;\t/* round down */\n\n\t/* next to check that the page we free is not a partial page */\n\tfor (addr = start; addr < end; addr += PAGE_SIZE) {\n\t\tClearPageReserved(virt_to_page(addr));\n\t\tinit_page_count(virt_to_page(addr));\n\t\tfree_page(addr);\n\t\ttotalram_pages++;\n\t}\n\n\tprintk(\"Freeing unused kernel memory: %ldKiB freed (0x%lx - 0x%lx)\\n\",\n\t       (end - start) >> 10, start, end);\n#endif\n}", "path": "Kernel\\arch\\frv\\mm\\init.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_set_pio_mode\t-\tset host controller for PIO mode\n *\t@drive: drive\n *\t@pio: PIO mode number\n *\n *\tLoad the timing settings for this device mode into the\n *\tcontroller.\n */\n", "func_signal": "static void sil_set_pio_mode(ide_drive_t *drive, u8 pio)", "code": "{\n\tstatic const u16 tf_speed[]   = { 0x328a, 0x2283, 0x1281, 0x10c3, 0x10c1 };\n\tstatic const u16 data_speed[] = { 0x328a, 0x2283, 0x1104, 0x10c3, 0x10c1 };\n\n\tide_hwif_t *hwif\t= drive->hwif;\n\tstruct pci_dev *dev\t= to_pci_dev(hwif->dev);\n\tide_drive_t *pair\t= ide_get_pair_dev(drive);\n\tu32 speedt\t\t= 0;\n\tu16 speedp\t\t= 0;\n\tunsigned long addr\t= siimage_seldev(drive, 0x04);\n\tunsigned long tfaddr\t= siimage_selreg(hwif,\t0x02);\n\tunsigned long base\t= (unsigned long)hwif->hwif_data;\n\tu8 tf_pio\t\t= pio;\n\tu8 mmio\t\t\t= (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;\n\tu8 addr_mask\t\t= hwif->channel ? (mmio ? 0xF4 : 0x84)\n\t\t\t\t\t\t: (mmio ? 0xB4 : 0x80);\n\tu8 mode\t\t\t= 0;\n\tu8 unit\t\t\t= drive->dn & 1;\n\n\t/* trim *taskfile* PIO to the slowest of the master/slave */\n\tif (pair) {\n\t\tu8 pair_pio = ide_get_best_pio_mode(pair, 255, 4);\n\n\t\tif (pair_pio < tf_pio)\n\t\t\ttf_pio = pair_pio;\n\t}\n\n\t/* cheat for now and use the docs */\n\tspeedp = data_speed[pio];\n\tspeedt = tf_speed[tf_pio];\n\n\tsil_iowrite16(dev, speedp, addr);\n\tsil_iowrite16(dev, speedt, tfaddr);\n\n\t/* now set up IORDY */\n\tspeedp = sil_ioread16(dev, tfaddr - 2);\n\tspeedp &= ~0x200;\n\n\tmode = sil_ioread8(dev, base + addr_mask);\n\tmode &= ~(unit ? 0x30 : 0x03);\n\n\tif (ide_pio_need_iordy(drive, pio)) {\n\t\tspeedp |= 0x200;\n\t\tmode |= unit ? 0x10 : 0x01;\n\t}\n\n\tsil_iowrite16(dev, speedp, tfaddr - 2);\n\tsil_iowrite8(dev, mode, base + addr_mask);\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/*----------------------------------------------------------------------*/\n", "func_signal": "static inline void\nsetsck(struct spi_device *spi, int is_on)", "code": "{\n\tstruct butterfly\t*pp = spidev_to_pp(spi);\n\tu8\t\t\tbit, byte = pp->lastbyte;\n\n\tbit = spi_sck_bit;\n\n\tif (is_on)\n\t\tbyte |= bit;\n\telse\n\t\tbyte &= ~bit;\n\tparport_write_data(pp->port, byte);\n\tpp->lastbyte = byte;\n}", "path": "Kernel\\drivers\\spi\\spi_butterfly.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/*****************************************************************************/\n/*\n *\n */\n", "func_signal": "void __init mem_init(void)", "code": "{\n\tunsigned long npages = (memory_end - memory_start) >> PAGE_SHIFT;\n\tunsigned long tmp;\n#ifdef CONFIG_MMU\n\tunsigned long loop, pfn;\n\tint datapages = 0;\n#endif\n\tint codek = 0, datak = 0;\n\n\t/* this will put all memory onto the freelists */\n\ttotalram_pages = free_all_bootmem();\n\n#ifdef CONFIG_MMU\n\tfor (loop = 0 ; loop < npages ; loop++)\n\t\tif (PageReserved(&mem_map[loop]))\n\t\t\tdatapages++;\n\n#ifdef CONFIG_HIGHMEM\n\tfor (pfn = num_physpages - 1; pfn >= num_mappedpages; pfn--) {\n\t\tstruct page *page = &mem_map[pfn];\n\n\t\tClearPageReserved(page);\n\t\tinit_page_count(page);\n\t\t__free_page(page);\n\t\ttotalram_pages++;\n\t}\n#endif\n\n\tcodek = ((unsigned long) &_etext - (unsigned long) &_stext) >> 10;\n\tdatak = datapages << (PAGE_SHIFT - 10);\n\n#else\n\tcodek = (_etext - _stext) >> 10;\n\tdatak = 0; //(_ebss - _sdata) >> 10;\n#endif\n\n\ttmp = nr_free_pages() << PAGE_SHIFT;\n\tprintk(\"Memory available: %luKiB/%luKiB RAM, %luKiB/%luKiB ROM (%dKiB kernel code, %dKiB data)\\n\",\n\t       tmp >> 10,\n\t       npages << (PAGE_SHIFT - 10),\n\t       (rom_length > 0) ? ((rom_length >> 10) - codek) : 0,\n\t       rom_length >> 10,\n\t       codek,\n\t       datak\n\t       );\n\n}", "path": "Kernel\\arch\\frv\\mm\\init.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/**\n *\tsil_sata_reset_poll\t-\twait for SATA reset\n *\t@drive: drive we are resetting\n *\n *\tPoll the SATA phy and see whether it has come back from the dead\n *\tyet.\n */\n", "func_signal": "static int sil_sata_reset_poll(ide_drive_t *drive)", "code": "{\n\tide_hwif_t *hwif = drive->hwif;\n\tvoid __iomem *sata_status_addr\n\t\t= (void __iomem *)hwif->sata_scr[SATA_STATUS_OFFSET];\n\n\tif (sata_status_addr) {\n\t\t/* SATA Status is available only when in MMIO mode */\n\t\tu32 sata_stat = readl(sata_status_addr);\n\n\t\tif ((sata_stat & 0x03) != 0x03) {\n\t\t\tprintk(KERN_WARNING \"%s: reset phy dead, status=0x%08x\\n\",\n\t\t\t\t\t    hwif->name, sata_stat);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "Kernel\\drivers\\ide\\siimage.c", "repo_name": "mrwrx/SDX-Froyo-M900", "stars": 10, "license": "None", "language": "c", "size": 113713}
{"docstring": "/*\n================\nClientEvents\n\nEvents will be passed on to the clients for presentation,\nbut any server game effects are handled here\n================\n*/\n", "func_signal": "void ClientEvents( gentity_t *ent, int oldEventSequence )", "code": "{\n\tint\t\ti, j;\n\tint\t\tevent;\n\tgclient_t *client;\n\tint\t\tdamage;\n\tvec3_t\tdir;\n\tvec3_t\torigin, angles;\n//\tqboolean\tfired;\n\tgitem_t *item;\n\tgentity_t *drop;\n\n\tclient = ent->client;\n\n\tif ( oldEventSequence < client->ps.eventSequence - MAX_PS_EVENTS ) {\n\t\toldEventSequence = client->ps.eventSequence - MAX_PS_EVENTS;\n\t}\n\tfor ( i = oldEventSequence ; i < client->ps.eventSequence ; i++ ) {\n\t\tevent = client->ps.events[ i & (MAX_PS_EVENTS-1) ];\n\n\t\tswitch ( event ) {\n\t\tcase EV_FALL_MEDIUM:\n\t\tcase EV_FALL_FAR:\n\t\t\tif ( ent->s.eType != ET_PLAYER ) {\n\t\t\t\tbreak;\t\t// not in the player model\n\t\t\t}\n\t\t\tif ( g_dmflags.integer & DF_NO_FALLING ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( event == EV_FALL_FAR ) {\n\t\t\t\tdamage = 10;\n\t\t\t} else {\n\t\t\t\tdamage = 5;\n\t\t\t}\n\t\t\tVectorSet (dir, 0, 0, 1);\n\t\t\tent->pain_debounce_time = level.time + 200;\t// no normal pain sound\n\t\t\tG_Damage (ent, NULL, NULL, NULL, NULL, damage, 0, MOD_FALLING);\n\t\t\tbreak;\n\n\t\tcase EV_FIRE_WEAPON:\n\t\t\tFireWeapon( ent );\n\t\t\tbreak;\n\n\t\tcase EV_USE_ITEM1:\t\t// teleporter\n\t\t\t// drop flags in CTF\n\t\t\titem = NULL;\n\t\t\tj = 0;\n\n\t\t\tif ( ent->client->ps.powerups[ PW_REDFLAG ] ) {\n\t\t\t\titem = BG_FindItemForPowerup( PW_REDFLAG );\n\t\t\t\tj = PW_REDFLAG;\n\t\t\t} else if ( ent->client->ps.powerups[ PW_BLUEFLAG ] ) {\n\t\t\t\titem = BG_FindItemForPowerup( PW_BLUEFLAG );\n\t\t\t\tj = PW_BLUEFLAG;\n\t\t\t} else if ( ent->client->ps.powerups[ PW_NEUTRALFLAG ] ) {\n\t\t\t\titem = BG_FindItemForPowerup( PW_NEUTRALFLAG );\n\t\t\t\tj = PW_NEUTRALFLAG;\n\t\t\t}\n\n\t\t\tif ( item ) {\n\t\t\t\tdrop = Drop_Item( ent, item, 0 );\n\t\t\t\t// decide how many seconds it has left\n\t\t\t\tdrop->count = ( ent->client->ps.powerups[ j ] - level.time ) / 1000;\n\t\t\t\tif ( drop->count < 1 ) {\n\t\t\t\t\tdrop->count = 1;\n\t\t\t\t}\n\n\t\t\t\tent->client->ps.powerups[ j ] = 0;\n\t\t\t}\n\n#ifdef MISSIONPACK\n\t\t\tif ( g_gametype.integer == GT_HARVESTER ) {\n\t\t\t\tif ( ent->client->ps.generic1 > 0 ) {\n\t\t\t\t\tif ( ent->client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\t\t\titem = BG_FindItem( \"Blue Cube\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem = BG_FindItem( \"Red Cube\" );\n\t\t\t\t\t}\n\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\tfor ( j = 0; j < ent->client->ps.generic1; j++ ) {\n\t\t\t\t\t\t\tdrop = Drop_Item( ent, item, 0 );\n\t\t\t\t\t\t\tif ( ent->client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\t\t\t\t\tdrop->spawnflags = TEAM_BLUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdrop->spawnflags = TEAM_RED;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tent->client->ps.generic1 = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tSelectSpawnPoint( ent->client->ps.origin, origin, angles );\n\t\t\tTeleportPlayer( ent, origin, angles );\n\t\t\tbreak;\n\n\t\tcase EV_USE_ITEM2:\t\t// medkit\n\t\t\tent->health = ent->client->ps.stats[STAT_MAX_HEALTH] + 25;\n\n\t\t\tbreak;\n\n#ifdef MISSIONPACK\n\t\tcase EV_USE_ITEM3:\t\t// kamikaze\n\t\t\t// make sure the invulnerability is off\n\t\t\tent->client->invulnerabilityTime = 0;\n\t\t\t// start the kamikze\n\t\t\tG_StartKamikaze( ent );\n\t\t\tbreak;\n\n\t\tcase EV_USE_ITEM4:\t\t// portal\n\t\t\tif( ent->client->portalID ) {\n\t\t\t\tDropPortalSource( ent );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDropPortalDestination( ent );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EV_USE_ITEM5:\t\t// invulnerability\n\t\t\tent->client->invulnerabilityTime = level.time + 10000;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==============\nClientImpacts\n==============\n*/\n", "func_signal": "void ClientImpacts( gentity_t *ent, pmove_t *pm )", "code": "{\n\tint\t\ti, j;\n\ttrace_t\ttrace;\n\tgentity_t\t*other;\n\n\tmemset( &trace, 0, sizeof( trace ) );\n\tfor (i=0 ; i<pm->numtouch ; i++) {\n\t\tfor (j=0 ; j<i ; j++) {\n\t\t\tif (pm->touchents[j] == pm->touchents[i] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j != i) {\n\t\t\tcontinue;\t// duplicated\n\t\t}\n\t\tother = &g_entities[ pm->touchents[i] ];\n\n\t\tif ( ( ent->r.svFlags & SVF_BOT ) && ( ent->touch ) ) {\n\t\t\tent->touch( ent, other, &trace );\n\t\t}\n\n\t\tif ( !other->touch ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tother->touch( other, ent, &trace );\n\t}\n\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==============\nStuckInOtherClient\n==============\n*/\n", "func_signal": "static int StuckInOtherClient(gentity_t *ent)", "code": "{\n\tint i;\n\tgentity_t\t*ent2;\n\n\tent2 = &g_entities[0];\n\tfor ( i = 0; i < MAX_CLIENTS; i++, ent2++ ) {\n\t\tif ( ent2 == ent ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !ent2->inuse ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !ent2->client ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( ent2->health <= 0 ) {\n\t\t\tcontinue;\n\t\t}\n\t\t//\n\t\tif (ent2->r.absmin[0] > ent->r.absmax[0])\n\t\t\tcontinue;\n\t\tif (ent2->r.absmin[1] > ent->r.absmax[1])\n\t\t\tcontinue;\n\t\tif (ent2->r.absmin[2] > ent->r.absmax[2])\n\t\t\tcontinue;\n\t\tif (ent2->r.absmax[0] < ent->r.absmin[0])\n\t\t\tcontinue;\n\t\tif (ent2->r.absmax[1] < ent->r.absmin[1])\n\t\t\tcontinue;\n\t\tif (ent2->r.absmax[2] < ent->r.absmin[2])\n\t\t\tcontinue;\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n=================\nMain_MenuEvent\n=================\n*/\n", "func_signal": "void Main_MenuEvent (void* ptr, int event)", "code": "{\n\tif( event != QM_ACTIVATED ) {\n\t\treturn;\n\t}\n\n\tswitch( ((menucommon_s*)ptr)->id ) {\n\tcase ID_SINGLEPLAYER:\n\t\tUI_SPLevelMenu();\n\t\tbreak;\n\n\tcase ID_MULTIPLAYER:\n\t\tUI_ArenaServersMenu();\n\t\tbreak;\n\n\tcase ID_SETUP:\n\t\tUI_SetupMenu();\n\t\tbreak;\n\n\tcase ID_DEMOS:\n\t\tUI_DemosMenu();\n\t\tbreak;\n\n\tcase ID_CINEMATICS:\n\t\tUI_CinematicsMenu();\n\t\tbreak;\n\n\tcase ID_MODS:\n\t\tUI_ModsMenu();\n\t\tbreak;\n\n\tcase ID_TEAMARENA:\n\t\ttrap_Cvar_Set( \"fs_game\", \"missionpack\");\n\t\ttrap_Cmd_ExecuteText( EXEC_APPEND, \"vid_restart;\" );\n\t\tbreak;\n\n\tcase ID_EXIT:\n\t\tUI_ConfirmMenu( \"EXIT GAME?\", 0, MainMenu_ExitAction );\n\t\tbreak;\n\t}\n}", "path": "libs\\ioq3\\code\\q3_ui\\ui_menu.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/* bittree - construct tree for l [& | ^ %] r */\n", "func_signal": "Tree bittree(int op, Tree l, Tree r)", "code": "{\n\tType ty = inttype;\n\n\tif (isint(l->type) && isint(r->type)) {\n \t\tty = binary(l->type, r->type);\n\t\tl = cast(l, ty);\n\t\tr = cast(r, ty);\t\t\n\t} else\n\t\ttypeerror(op, l, r);\n\treturn simplify(op, ty, l, r);\n}", "path": "libs\\ioq3\\code\\tools\\lcc\\src\\enode.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==============\nClientEndFrame\n\nCalled at the end of each server frame for each connected client\nA fast client will have multiple ClientThink for each ClientEdFrame,\nwhile a slow client may have multiple ClientEndFrame between ClientThink.\n==============\n*/\n", "func_signal": "void ClientEndFrame( gentity_t *ent )", "code": "{\n\tint\t\t\ti;\n\tclientPersistant_t\t*pers;\n\n\tif ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {\n\t\tSpectatorClientEndFrame( ent );\n\t\treturn;\n\t}\n\n\tpers = &ent->client->pers;\n\n\t// turn off any expired powerups\n\tfor ( i = 0 ; i < MAX_POWERUPS ; i++ ) {\n\t\tif ( ent->client->ps.powerups[ i ] < level.time ) {\n\t\t\tent->client->ps.powerups[ i ] = 0;\n\t\t}\n\t}\n\n#ifdef MISSIONPACK\n\t// set powerup for player animation\n\tif( bg_itemlist[ent->client->ps.stats[STAT_PERSISTANT_POWERUP]].giTag == PW_GUARD ) {\n\t\tent->client->ps.powerups[PW_GUARD] = level.time;\n\t}\n\tif( bg_itemlist[ent->client->ps.stats[STAT_PERSISTANT_POWERUP]].giTag == PW_SCOUT ) {\n\t\tent->client->ps.powerups[PW_SCOUT] = level.time;\n\t}\n\tif( bg_itemlist[ent->client->ps.stats[STAT_PERSISTANT_POWERUP]].giTag == PW_DOUBLER ) {\n\t\tent->client->ps.powerups[PW_DOUBLER] = level.time;\n\t}\n\tif( bg_itemlist[ent->client->ps.stats[STAT_PERSISTANT_POWERUP]].giTag == PW_AMMOREGEN ) {\n\t\tent->client->ps.powerups[PW_AMMOREGEN] = level.time;\n\t}\n\tif ( ent->client->invulnerabilityTime > level.time ) {\n\t\tent->client->ps.powerups[PW_INVULNERABILITY] = level.time;\n\t}\n#endif\n\n\t// save network bandwidth\n#if 0\n\tif ( !g_synchronousClients->integer && ent->client->ps.pm_type == PM_NORMAL ) {\n\t\t// FIXME: this must change eventually for non-sync demo recording\n\t\tVectorClear( ent->client->ps.viewangles );\n\t}\n#endif\n\n\t//\n\t// If the end of unit layout is displayed, don't give\n\t// the player any normal movement attributes\n\t//\n\tif ( level.intermissiontime ) {\n\t\treturn;\n\t}\n\n\t// burn from lava, etc\n\tP_WorldEffects (ent);\n\n\t// apply all the damage taken this frame\n\tP_DamageFeedback (ent);\n\n\t// add the EF_CONNECTION flag if we haven't gotten commands recently\n\tif ( level.time - ent->client->lastCmdTime > 1000 ) {\n\t\tent->s.eFlags |= EF_CONNECTION;\n\t} else {\n\t\tent->s.eFlags &= ~EF_CONNECTION;\n\t}\n\n\tent->client->ps.stats[STAT_HEALTH] = ent->health;\t// FIXME: get rid of ent->health...\n\n\tG_SetClientSound (ent);\n\n\t// set the latest infor\n\tif (g_smoothClients.integer) {\n\t\tBG_PlayerStateToEntityStateExtraPolate( &ent->client->ps, &ent->s, ent->client->ps.commandTime, qtrue );\n\t}\n\telse {\n\t\tBG_PlayerStateToEntityState( &ent->client->ps, &ent->s, qtrue );\n\t}\n\tSendPendingPredictableEvents( &ent->client->ps );\n\n\t// set the bit for the reachability area the client is currently in\n//\ti = trap_AAS_PointReachabilityAreaIndex( ent->client->ps.origin );\n//\tent->client->areabits[i >> 3] |= 1 << (i & 7);\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n====================\nClientIntermissionThink\n====================\n*/\n", "func_signal": "void ClientIntermissionThink( gclient_t *client )", "code": "{\n\tclient->ps.eFlags &= ~EF_TALK;\n\tclient->ps.eFlags &= ~EF_FIRING;\n\n\t// the level will exit when everyone wants to or after timeouts\n\n\t// swap and latch button actions\n\tclient->oldbuttons = client->buttons;\n\tclient->buttons = client->pers.cmd.buttons;\n\tif ( client->buttons & ( BUTTON_ATTACK | BUTTON_USE_HOLDABLE ) & ( client->oldbuttons ^ client->buttons ) ) {\n\t\t// this used to be an ^1 but once a player says ready, it should stick\n\t\tclient->readyToExit = 1;\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "// Note the C space function AsmCall is never actually called, and is in fact\n// arbitrarily named (though this is not true for the MSC version).  When a vm\n// makes a system call, control jumps straight to the doAsmCall label.\n", "func_signal": "void AsmCall( void )", "code": "{\n\tasm( CMANG(doAsmCall) \":\t\t\t\t\\n\\t\" \\\n\t\t\"\tmovl (%%edi),%%eax\t\t\t\\n\\t\" \\\n\t\t\"\tsubl $4,%%edi\t\t\t\t\\n\\t\" \\\n\t\t\"\torl %%eax,%%eax\t\t\t\t\\n\\t\" \\\n\t\t\"\tjl systemCall\t\t\t\t\\n\\t\" \\\n\t\t\"\tshll $2,%%eax\t\t\t\t\\n\\t\" \\\n\t\t\"\taddl %3,%%eax\t\t\t\t\\n\\t\" \\\n\t\t\"\tcall *(%%eax)\t\t\t\t\\n\\t\" \\\n\t\t\"\tmovl (%%edi),%%eax\t\t\t\\n\\t\" \\\n\t\t\"\tandl \" CMANG(callMask) \", %%eax\t\t\\n\\t\" \\\n\t\t\"\tjmp doret\t\t\t\t\\n\\t\" \\\n\t\t\"systemCall:\t\t\t\t\t\\n\\t\" \\\n\t\t\"\tnegl %%eax\t\t\t\t\\n\\t\" \\\n\t\t\"\tdecl %%eax\t\t\t\t\\n\\t\" \\\n\t\t\"\tmovl %%eax,%0\t\t\t\t\\n\\t\" \\\n\t\t\"\tmovl %%esi,%1\t\t\t\t\\n\\t\" \\\n\t\t\"\tmovl %%edi,%2\t\t\t\t\\n\\t\" \\\n\t\t\"\tpushl %%ecx\t\t\t\t\\n\\t\" \\\n\t\t\"\tpushl %%esi\t\t\t\t\\n\\t\" \\\n\t\t\"\tpushl %%edi\t\t\t\t\\n\\t\" \\\n\t\t\"\tcall \" CMANG(callAsmCall) \"\t\t\\n\\t\" \\\n\t\t\"\tpopl %%edi\t\t\t\t\\n\\t\" \\\n\t\t\"\tpopl %%esi\t\t\t\t\\n\\t\" \\\n\t\t\"\tpopl %%ecx\t\t\t\t\\n\\t\" \\\n\t\t\"\taddl $4,%%edi\t\t\t\t\\n\\t\" \\\n\t\t\"doret:\t\t\t\t\t\t\\n\\t\" \\\n\t\t\"\tret\t\t\t\t\t\\n\\t\" \\\n\t\t: \"=rm\" (callSyscallNum), \"=rm\" (callProgramStack), \"=rm\" (callOpStack) \\\n\t\t: \"m\" (instructionPointers) \\\n\t\t: \"ax\", \"di\", \"si\", \"cx\" \\\n\t);\n}", "path": "libs\\ioq3\\code\\qcommon\\vm_x86.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n=================\nMainMenu_ExitAction\n=================\n*/\n", "func_signal": "static void MainMenu_ExitAction( qboolean result )", "code": "{\n\tif( !result ) {\n\t\treturn;\n\t}\n\tUI_PopMenu();\n\tUI_CreditMenu();\n}", "path": "libs\\ioq3\\code\\q3_ui\\ui_menu.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n============\nG_TouchTriggers\n\nFind all trigger entities that ent's current position touches.\nSpectators will only interact with teleporters.\n============\n*/\n", "func_signal": "void\tG_TouchTriggers( gentity_t *ent )", "code": "{\n\tint\t\t\ti, num;\n\tint\t\t\ttouch[MAX_GENTITIES];\n\tgentity_t\t*hit;\n\ttrace_t\t\ttrace;\n\tvec3_t\t\tmins, maxs;\n\tstatic vec3_t\trange = { 40, 40, 52 };\n\n\tif ( !ent->client ) {\n\t\treturn;\n\t}\n\n\t// dead clients don't activate triggers!\n\tif ( ent->client->ps.stats[STAT_HEALTH] <= 0 ) {\n\t\treturn;\n\t}\n\n\tVectorSubtract( ent->client->ps.origin, range, mins );\n\tVectorAdd( ent->client->ps.origin, range, maxs );\n\n\tnum = trap_EntitiesInBox( mins, maxs, touch, MAX_GENTITIES );\n\n\t// can't use ent->absmin, because that has a one unit pad\n\tVectorAdd( ent->client->ps.origin, ent->r.mins, mins );\n\tVectorAdd( ent->client->ps.origin, ent->r.maxs, maxs );\n\n\tfor ( i=0 ; i<num ; i++ ) {\n\t\thit = &g_entities[touch[i]];\n\n\t\tif ( !hit->touch && !ent->touch ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !( hit->r.contents & CONTENTS_TRIGGER ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// ignore most entities if a spectator\n\t\tif ( ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {\n\t\t\tif ( hit->s.eType != ET_TELEPORT_TRIGGER &&\n\t\t\t\t// this is ugly but adding a new ET_? type will\n\t\t\t\t// most likely cause network incompatibilities\n\t\t\t\thit->touch != Touch_DoorTrigger) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// use seperate code for determining if an item is picked up\n\t\t// so you don't have to actually contact its bounding box\n\t\tif ( hit->s.eType == ET_ITEM ) {\n\t\t\tif ( !BG_PlayerTouchesItem( &ent->client->ps, &hit->s, level.time ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( !trap_EntityContact( mins, maxs, hit ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmemset( &trace, 0, sizeof(trace) );\n\n\t\tif ( hit->touch ) {\n\t\t\thit->touch (hit, ent, &trace);\n\t\t}\n\n\t\tif ( ( ent->r.svFlags & SVF_BOT ) && ( ent->touch ) ) {\n\t\t\tent->touch( ent, hit, &trace );\n\t\t}\n\t}\n\n\t// if we didn't touch a jump pad this pmove frame\n\tif ( ent->client->ps.jumppad_frame != ent->client->ps.pmove_framecount ) {\n\t\tent->client->ps.jumppad_frame = 0;\n\t\tent->client->ps.jumppad_ent = 0;\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/* addrof - address of p */\n", "func_signal": "Tree addrof(Tree p)", "code": "{\n\tTree q = p;\n\n\tfor (;;)\n\t\tswitch (generic(q->op)) {\n\t\tcase RIGHT:\n\t\t\tassert(q->kids[0] || q->kids[1]);\n\t\t\tq = q->kids[1] ? q->kids[1] : q->kids[0];\n\t\t\tcontinue;\n\t\tcase ASGN:\n\t\t\tq = q->kids[1];\n\t\t\tcontinue;\n\t\tcase COND: {\n\t\t\tSymbol t1 = q->u.sym;\n\t\t\tq->u.sym = 0;\n\t\t\tq = idtree(t1);\n\t\t\t/* fall thru */\n\t\t\t}\n\t\tcase INDIR:\n\t\t\tif (p == q)\n\t\t\t\treturn q->kids[0];\n\t\t\tq = q->kids[0];\n\t\t\treturn tree(RIGHT, q->type, root(p), q);\n\t\tdefault:\n\t\t\terror(\"addressable object required\\n\");\n\t\t\treturn value(p);\n\t\t}\n}", "path": "libs\\ioq3\\code\\tools\\lcc\\src\\enode.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/* typeerror - issue \"operands of op have illegal types `l' and `r'\" */\n", "func_signal": "void typeerror(int op, Tree l, Tree r)", "code": "{\n\tint i;\n\tstatic struct { int op; char *name; } ops[] = {\n\t\t{ASGN, \"=\"},\t{INDIR, \"*\"},\t{NEG,  \"-\"},\n\t\t{ADD,  \"+\"},\t{SUB,   \"-\"},\t{LSH,  \"<<\"},\n\t\t{MOD,  \"%\"},\t{RSH,   \">>\"},\t{BAND, \"&\"},\n\t\t{BCOM, \"~\"},\t{BOR,   \"|\"},\t{BXOR, \"^\"},\n\t\t{DIV,  \"/\"},\t{MUL,   \"*\"},\t{EQ,   \"==\"},\n\t\t{GE,   \">=\"},\t{GT,    \">\"},\t{LE,   \"<=\"},\n\t\t{LT,   \"<\"},\t{NE,    \"!=\"},\t{AND,  \"&&\"},\n\t\t{NOT,  \"!\"},\t{OR,    \"||\"},\t{COND, \"?:\"},\n\t\t{0, 0}\n\t};\n\n\top = generic(op);\n\tfor (i = 0; ops[i].op; i++)\n\t\tif (op == ops[i].op)\n\t\t\tbreak;\n\tassert(ops[i].name);\n\tif (r)\n\t\terror(\"operands of %s have illegal types `%t' and `%t'\\n\",\n\t\t\tops[i].name, l->type, r->type);\n\telse\n\t\terror(\"operand of unary %s has illegal type `%t'\\n\", ops[i].name,\n\t\t\tl->type);\n}", "path": "libs\\ioq3\\code\\tools\\lcc\\src\\enode.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==============\nSendPendingPredictableEvents\n==============\n*/\n", "func_signal": "void SendPendingPredictableEvents( playerState_t *ps )", "code": "{\n\tgentity_t *t;\n\tint event, seq;\n\tint extEvent, number;\n\n\t// if there are still events pending\n\tif ( ps->entityEventSequence < ps->eventSequence ) {\n\t\t// create a temporary entity for this event which is sent to everyone\n\t\t// except the client who generated the event\n\t\tseq = ps->entityEventSequence & (MAX_PS_EVENTS-1);\n\t\tevent = ps->events[ seq ] | ( ( ps->entityEventSequence & 3 ) << 8 );\n\t\t// set external event to zero before calling BG_PlayerStateToEntityState\n\t\textEvent = ps->externalEvent;\n\t\tps->externalEvent = 0;\n\t\t// create temporary entity for event\n\t\tt = G_TempEntity( ps->origin, event );\n\t\tnumber = t->s.number;\n\t\tBG_PlayerStateToEntityState( ps, &t->s, qtrue );\n\t\tt->s.number = number;\n\t\tt->s.eType = ET_EVENTS + event;\n\t\tt->s.eFlags |= EF_PLAYER_EVENT;\n\t\tt->s.otherEntityNum = ps->clientNum;\n\t\t// send to everyone except the client who generated the event\n\t\tt->r.svFlags |= SVF_NOTSINGLECLIENT;\n\t\tt->r.singleClient = ps->clientNum;\n\t\t// set back external event\n\t\tps->externalEvent = extEvent;\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==============\nVM_CallCompiled\n\nThis function is called directly by the generated code\n==============\n*/\n", "func_signal": "int\tVM_CallCompiled( vm_t *vm, int *args )", "code": "{\n\tint\t\tstack[1024];\n\tint\t\tprogramCounter;\n\tint\t\tprogramStack;\n\tint\t\tstackOnEntry;\n\tbyte\t*image;\n\tvoid\t*entryPoint;\n\tvoid\t*opStack;\n\tint\t\t*oldInstructionPointers;\n\n\toldInstructionPointers = instructionPointers;\n\n\tcurrentVM = vm;\n\tinstructionPointers = vm->instructionPointers;\n\n\t// interpret the code\n\tvm->currentlyInterpreting = qtrue;\n\n\tcallMask = vm->dataMask;\n\n\t// we might be called recursively, so this might not be the very top\n\tprogramStack = vm->programStack;\n\tstackOnEntry = programStack;\n\n\t// set up the stack frame \n\timage = vm->dataBase;\n\n\tprogramCounter = 0;\n\n\tprogramStack -= 48;\n\n\t*(int *)&image[ programStack + 44] = args[9];\n\t*(int *)&image[ programStack + 40] = args[8];\n\t*(int *)&image[ programStack + 36] = args[7];\n\t*(int *)&image[ programStack + 32] = args[6];\n\t*(int *)&image[ programStack + 28] = args[5];\n\t*(int *)&image[ programStack + 24] = args[4];\n\t*(int *)&image[ programStack + 20] = args[3];\n\t*(int *)&image[ programStack + 16] = args[2];\n\t*(int *)&image[ programStack + 12] = args[1];\n\t*(int *)&image[ programStack + 8 ] = args[0];\n\t*(int *)&image[ programStack + 4 ] = 0;\t// return stack\n\t*(int *)&image[ programStack ] = -1;\t// will terminate the loop on return\n\n\t// off we go into generated code...\n\tentryPoint = vm->codeBase;\n\topStack = &stack;\n\n#ifdef _MSC_VER\n\t__asm  {\n\t\tpushad\n\t\tmov\t\tesi, programStack;\n\t\tmov\t\tedi, opStack\n\t\tcall\tentryPoint\n\t\tmov\t\tprogramStack, esi\n\t\tmov\t\topStack, edi\n\t\tpopad\n\t}\n#else\n\t{\n\t\tstatic int memProgramStack;\n\t\tstatic void *memOpStack;\n\t\tstatic void *memEntryPoint;\n\n\t\tmemProgramStack\t= programStack;\n\t\tmemOpStack      = opStack;     \n\t\tmemEntryPoint   = entryPoint;  \n\t\t\n\t\t__asm__(\"\tpushal\t\t\t\t\\n\" \\\n\t\t\t\t\"\tmovl %0,%%esi\t\t\\n\" \\\n\t\t\t\t\"\tmovl %1,%%edi\t\t\\n\" \\\n\t\t\t\t\"\tcall *%2\t\t\t\\n\" \\\n\t\t\t\t\"\tmovl %%esi,%0\t\t\\n\" \\\n\t\t\t\t\"\tmovl %%edi,%1\t\t\\n\" \\\n\t\t\t\t\"\tpopal\t\t\t\t\\n\" \\\n\t\t\t\t: \"=m\" (memProgramStack), \"=m\" (memOpStack) \\\n\t\t\t\t: \"m\" (memEntryPoint), \"m\" (memProgramStack), \"m\" (memOpStack) \\\n\t\t\t\t: \"si\", \"di\" \\\n\t\t);\n\n\t\tprogramStack = memProgramStack;\n\t\topStack      = memOpStack;\n\t}\n#endif\n\n\tif ( opStack != &stack[1] ) {\n\t\tCom_Error( ERR_DROP, \"opStack corrupted in compiled code\" );\n\t}\n\tif ( programStack != stackOnEntry - 48 ) {\n\t\tCom_Error( ERR_DROP, \"programStack corrupted in compiled code\" );\n\t}\n\n\tvm->programStack = stackOnEntry;\n\n\t// in case we were recursively called by another vm\n\tinstructionPointers = oldInstructionPointers;\n\n\treturn *(int *)opStack;\n}", "path": "libs\\ioq3\\code\\qcommon\\vm_x86.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n=============\nP_WorldEffects\n\nCheck for lava / slime contents and drowning\n=============\n*/\n", "func_signal": "void P_WorldEffects( gentity_t *ent )", "code": "{\n\tqboolean\tenvirosuit;\n\tint\t\t\twaterlevel;\n\n\tif ( ent->client->noclip ) {\n\t\tent->client->airOutTime = level.time + 12000;\t// don't need air\n\t\treturn;\n\t}\n\n\twaterlevel = ent->waterlevel;\n\n\tenvirosuit = ent->client->ps.powerups[PW_BATTLESUIT] > level.time;\n\n\t//\n\t// check for drowning\n\t//\n\tif ( waterlevel == 3 ) {\n\t\t// envirosuit give air\n\t\tif ( envirosuit ) {\n\t\t\tent->client->airOutTime = level.time + 10000;\n\t\t}\n\n\t\t// if out of air, start drowning\n\t\tif ( ent->client->airOutTime < level.time) {\n\t\t\t// drown!\n\t\t\tent->client->airOutTime += 1000;\n\t\t\tif ( ent->health > 0 ) {\n\t\t\t\t// take more damage the longer underwater\n\t\t\t\tent->damage += 2;\n\t\t\t\tif (ent->damage > 15)\n\t\t\t\t\tent->damage = 15;\n\n\t\t\t\t// play a gurp sound instead of a normal pain sound\n\t\t\t\tif (ent->health <= ent->damage) {\n\t\t\t\t\tG_Sound(ent, CHAN_VOICE, G_SoundIndex(\"*drown.wav\"));\n\t\t\t\t} else if (rand()&1) {\n\t\t\t\t\tG_Sound(ent, CHAN_VOICE, G_SoundIndex(\"sound/player/gurp1.wav\"));\n\t\t\t\t} else {\n\t\t\t\t\tG_Sound(ent, CHAN_VOICE, G_SoundIndex(\"sound/player/gurp2.wav\"));\n\t\t\t\t}\n\n\t\t\t\t// don't play a normal pain sound\n\t\t\t\tent->pain_debounce_time = level.time + 200;\n\n\t\t\t\tG_Damage (ent, NULL, NULL, NULL, NULL, \n\t\t\t\t\tent->damage, DAMAGE_NO_ARMOR, MOD_WATER);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tent->client->airOutTime = level.time + 12000;\n\t\tent->damage = 2;\n\t}\n\n\t//\n\t// check for sizzle damage (move to pmove?)\n\t//\n\tif (waterlevel && \n\t\t(ent->watertype&(CONTENTS_LAVA|CONTENTS_SLIME)) ) {\n\t\tif (ent->health > 0\n\t\t\t&& ent->pain_debounce_time <= level.time\t) {\n\n\t\t\tif ( envirosuit ) {\n\t\t\t\tG_AddEvent( ent, EV_POWERUP_BATTLESUIT, 0 );\n\t\t\t} else {\n\t\t\t\tif (ent->watertype & CONTENTS_LAVA) {\n\t\t\t\t\tG_Damage (ent, NULL, NULL, NULL, NULL, \n\t\t\t\t\t\t30*waterlevel, 0, MOD_LAVA);\n\t\t\t\t}\n\n\t\t\t\tif (ent->watertype & CONTENTS_SLIME) {\n\t\t\t\t\tG_Damage (ent, NULL, NULL, NULL, NULL, \n\t\t\t\t\t\t10*waterlevel, 0, MOD_SLIME);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/* andtree - construct tree for l [&& ||] r */\n", "func_signal": "static Tree andtree(int op, Tree l, Tree r)", "code": "{\n\tif (!isscalar(l->type) || !isscalar(r->type))\n\t\ttypeerror(op, l, r);\n\treturn simplify(op, inttype, cond(l), cond(r));\n}", "path": "libs\\ioq3\\code\\tools\\lcc\\src\\enode.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==================\nSpectatorClientEndFrame\n\n==================\n*/\n", "func_signal": "void SpectatorClientEndFrame( gentity_t *ent )", "code": "{\n\tgclient_t\t*cl;\n\n\t// if we are doing a chase cam or a remote view, grab the latest info\n\tif ( ent->client->sess.spectatorState == SPECTATOR_FOLLOW ) {\n\t\tint\t\tclientNum, flags;\n\n\t\tclientNum = ent->client->sess.spectatorClient;\n\n\t\t// team follow1 and team follow2 go to whatever clients are playing\n\t\tif ( clientNum == -1 ) {\n\t\t\tclientNum = level.follow1;\n\t\t} else if ( clientNum == -2 ) {\n\t\t\tclientNum = level.follow2;\n\t\t}\n\t\tif ( clientNum >= 0 ) {\n\t\t\tcl = &level.clients[ clientNum ];\n\t\t\tif ( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR ) {\n\t\t\t\tflags = (cl->ps.eFlags & ~(EF_VOTED | EF_TEAMVOTED)) | (ent->client->ps.eFlags & (EF_VOTED | EF_TEAMVOTED));\n\t\t\t\tent->client->ps = cl->ps;\n\t\t\t\tent->client->ps.pm_flags |= PMF_FOLLOW;\n\t\t\t\tent->client->ps.eFlags = flags;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// drop them to free spectators unless they are dedicated camera followers\n\t\t\t\tif ( ent->client->sess.spectatorClient >= 0 ) {\n\t\t\t\t\tent->client->sess.spectatorState = SPECTATOR_FREE;\n\t\t\t\t\tClientBegin( ent->client - level.clients );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ent->client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {\n\t\tent->client->ps.pm_flags |= PMF_SCOREBOARD;\n\t} else {\n\t\tent->client->ps.pm_flags &= ~PMF_SCOREBOARD;\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n=================\nSpectatorThink\n=================\n*/\n", "func_signal": "void SpectatorThink( gentity_t *ent, usercmd_t *ucmd )", "code": "{\n\tpmove_t\tpm;\n\tgclient_t\t*client;\n\n\tclient = ent->client;\n\n\tif ( client->sess.spectatorState != SPECTATOR_FOLLOW ) {\n\t\tclient->ps.pm_type = PM_SPECTATOR;\n\t\tclient->ps.speed = 400;\t// faster than normal\n\n\t\t// set up for pmove\n\t\tmemset (&pm, 0, sizeof(pm));\n\t\tpm.ps = &client->ps;\n\t\tpm.cmd = *ucmd;\n\t\tpm.tracemask = MASK_PLAYERSOLID & ~CONTENTS_BODY;\t// spectators can fly through bodies\n\t\tpm.trace = trap_Trace;\n\t\tpm.pointcontents = trap_PointContents;\n\n\t\t// perform a pmove\n\t\tPmove (&pm);\n\t\t// save results of pmove\n\t\tVectorCopy( client->ps.origin, ent->s.origin );\n\n\t\tG_TouchTriggers( ent );\n\t\ttrap_UnlinkEntity( ent );\n\t}\n\n\tclient->oldbuttons = client->buttons;\n\tclient->buttons = ucmd->buttons;\n\n\t// attack button cycles through spectators\n\tif ( ( client->buttons & BUTTON_ATTACK ) && ! ( client->oldbuttons & BUTTON_ATTACK ) ) {\n\t\tCmd_FollowCycle_f( ent, 1 );\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n==================\nClientThink\n\nA new command has arrived from the client\n==================\n*/\n", "func_signal": "void ClientThink( int clientNum )", "code": "{\n\tgentity_t *ent;\n\n\tent = g_entities + clientNum;\n\ttrap_GetUsercmd( clientNum, &ent->client->pers.cmd );\n\n\t// mark the time we got info, so we can display the\n\t// phone jack if they don't get any for a while\n\tent->client->lastCmdTime = level.time;\n\n\tif ( !(ent->r.svFlags & SVF_BOT) && !g_synchronousClients.integer ) {\n\t\tClientThink_real( ent );\n\t}\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n=================\nClientInactivityTimer\n\nReturns qfalse if the client is dropped\n=================\n*/\n", "func_signal": "qboolean ClientInactivityTimer( gclient_t *client )", "code": "{\n\tif ( ! g_inactivity.integer ) {\n\t\t// give everyone some time, so if the operator sets g_inactivity during\n\t\t// gameplay, everyone isn't kicked\n\t\tclient->inactivityTime = level.time + 60 * 1000;\n\t\tclient->inactivityWarning = qfalse;\n\t} else if ( client->pers.cmd.forwardmove || \n\t\tclient->pers.cmd.rightmove || \n\t\tclient->pers.cmd.upmove ||\n\t\t(client->pers.cmd.buttons & BUTTON_ATTACK) ) {\n\t\tclient->inactivityTime = level.time + g_inactivity.integer * 1000;\n\t\tclient->inactivityWarning = qfalse;\n\t} else if ( !client->pers.localClient ) {\n\t\tif ( level.time > client->inactivityTime ) {\n\t\t\ttrap_DropClient( client - level.clients, \"Dropped due to inactivity\" );\n\t\t\treturn qfalse;\n\t\t}\n\t\tif ( level.time > client->inactivityTime - 10000 && !client->inactivityWarning ) {\n\t\t\tclient->inactivityWarning = qtrue;\n\t\t\ttrap_SendServerCommand( client - level.clients, \"cp \\\"Ten seconds until inactivity drop!\\n\\\"\" );\n\t\t}\n\t}\n\treturn qtrue;\n}", "path": "libs\\ioq3\\code\\game\\g_active.c", "repo_name": "br0k3/urban-terror-hack", "stars": 8, "license": "None", "language": "c", "size": 4380}
{"docstring": "/*\n * name\n *      grow_unpack_stack\n *\n * description\n *      grow the stack to have space for return values\n *      when unpacking using simple const increment\n *\n * paramenters\n *      l - lua state\n *      state - unpack state passed between invocations\n */\n", "func_signal": "static void grow_unpack_stack(lua_State *l, UNPACK_STATE *state)", "code": "{\n    if(state->return_count % 32 == 1)\n    {\n        int result = lua_checkstack(l, 32);\n        if(!result)\n        {\n            luaL_error(l, \"too many elements to unpack (%d)\", state->return_count);\n        }\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      basic_pack_int\n *\n * description\n *      pack integer into result buffer\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      value - value to pack\n *      state - pack state and intermediate results that are passed between\n *              invocations\n *\n * returns\n *      the function collects the result in buffer member of state parameter\n *\n * rationale\n *      The function splits handling into different cases of bit alignment in\n *      input and in result buffer. see comments in the body of the function\n */\n", "func_signal": "static void basic_pack_int(lua_State *l, ELEMENT_DESCRIPTION *elem, lua_Integer value, PACK_STATE *state)", "code": "{\n    size_t count_packed_bits = elem->size;\n    unsigned char val_buff[sizeof(lua_Integer) + 1];\n    /* start clean */\n    memset(val_buff, 0, sizeof(val_buff));\n    /* change the endianess and explicitely represent the value as buffer of bytes */\n    size_t count_bytes = \n        change_endianess(\n                l, \n                clear_unused_bits(value, elem->size), \n                elem->size, elem->endianess, \n                val_buff, \n                sizeof(val_buff));\n\n    /* number of least significant bits in the result buffer that are over byte bounds */\n    size_t bit_offset = state->current_bit % CHAR_BIT;\n    /* number of most significant bits in the input value that are over byte bounds */\n    size_t source_bit_offset = elem->size % CHAR_BIT;\n    /* bit_gap can be CHAR_BIT */\n    /* if bit_offset would be assigned to a byte and ORed with source_bit_offset */\n    /* there would be some bits inside the byte that wouldn't be set, or would overlap */\n    /* or it would be a perfect match. this is the bit_gap */\n    int bit_gap = ((int)CHAR_BIT - (int)bit_offset - (int)source_bit_offset) % CHAR_BIT; \n\n    /* current byte in the result buffer */\n    unsigned char *current_byte = state->prep_buffer + state->current_bit / CHAR_BIT;\n\n    /* whenever the temporary prep_buffer is full flush it into result buffer */\n    /* leave one spare byte for code that zeroes a byte ahead */\n    if(state->current_bit + elem->size >= state->result_bits)\n    {\n        size_t size = current_byte - state->prep_buffer;\n        /* save the unfinished byte for next prep_buffer */\n        unsigned char tmp = *current_byte;\n        luaL_addsize(state->buffer, size);\n\n        state->prep_buffer = (unsigned char *)luaL_prepbuffer(state->buffer);\n        state->current_bit = bit_offset;\n        current_byte = state->prep_buffer;\n        *current_byte = tmp;\n    }\n\n    if(bit_offset == 0 && source_bit_offset == 0)\n    {\n        /* simple copy */\n        size_t i;\n        for(i = 0; i < count_bytes; ++i)\n        {\n            *current_byte = val_buff[i];\n            ++current_byte;\n        }\n        *current_byte = 0;\n    }\n    else if(bit_offset == 0 && source_bit_offset != 0)\n    {\n        /* result string u - used bits*/\n        /* uuuu uuuu  uuuu uuuu  uuuu uuuu  0000 0000  0000 0000 */\n        /* input value in a char buffer */\n        /* 0000 0uuu uuuu uuuu */ \n        /* moved left and ORed with result buffer */\n        /* uuuu uuuu uuu0 0000 */ \n         \n        size_t i;\n        for(i = 0; i < count_bytes - 1; ++i)\n        {\n            *current_byte = (val_buff[i] << (CHAR_BIT - source_bit_offset)) & 0xff;\n            *current_byte |= (val_buff[i + 1] >> source_bit_offset) & 0xff;\n            ++current_byte;\n            *current_byte = 0;\n        }\n        *current_byte = (val_buff[i] << (CHAR_BIT - source_bit_offset)) & 0xff;\n    }\n    else if(bit_offset != 0 && source_bit_offset == 0)\n    {\n        /* result string u - used bits*/\n        /* uuuu uuuu  uuuu uuuu  uuuu uuuu  uuu0 0000  0000 0000 */\n        /* input value in a char buffer */\n        /* uuuu uuuu  uuuu uuuu */ \n        /* moved right and ORed with result buffer */\n        /* 000u uuuu uuuu  uuuu uuu0 0000 */ \n        size_t i;\n        unsigned char tmp = 0;\n        for(i = 0; i < count_bytes; ++i)\n        {\n            *current_byte |= ((val_buff[i] >> bit_offset) | tmp) & 0xff;\n            tmp = (val_buff[i] << (CHAR_BIT - bit_offset)) & 0xff; \n            ++current_byte;\n            *current_byte = 0;\n        }\n        *current_byte |= tmp;\n    }\n    else\n    {\n        if(bit_gap < 0)\n        {\n            /* result string u - used bits*/\n            /* uuuu uuuu  uuuu uuuu  uuuu uuuu  uuu0 0000  0000 0000 */\n            /* input value in a char buffer */\n            /* 0uuu uuuu  uuuu uuuu */ \n\n            bit_gap = abs(bit_gap);\n            /* move right */\n            size_t i;\n            unsigned char tmp = 0;\n            for(i = 0; i < count_bytes; ++i)\n            {\n                *current_byte |= ((val_buff[i] >> bit_gap) | tmp) & 0xff;\n                tmp = (val_buff[i] << (CHAR_BIT - bit_gap)) & 0xff; \n                ++current_byte;\n                *current_byte = 0;\n            }\n            *current_byte |= tmp & 0xff; \n        }\n        else if(bit_gap > 0)\n        {\n            /* result string u - used bits*/\n            /* uuuu uuuu  uuuu uuuu  uuuu uuuu  uuu0 0000  0000 0000 */\n            /* input value in a char buffer */\n            /* 0000 uuuu  uuuu uuuu */ \n\n            size_t i;\n            for(i = 0; i < count_bytes - 1; ++i)\n            {\n                *current_byte |= (val_buff[i] << bit_gap) & 0xff;\n                *current_byte |= (val_buff[i + 1] >> (CHAR_BIT - bit_gap)) & 0xff;\n                ++current_byte;\n                *current_byte = 0;\n            }\n            *current_byte |= (val_buff[i] << bit_gap) & 0xff;\n        }\n        else\n        {\n            /* result string u - used bits*/\n            /* uuuu uuuu  uuuu uuuu  uuuu uuuu  uuu0 0000  0000 0000 */\n            /* input value in a char buffer */\n            /* 000u uuuu  uuuu uuuu */ \n\n            size_t i;\n            for(i = 0; i < count_bytes; ++i)\n            {\n                *current_byte |= val_buff[i];\n                ++current_byte;\n                *current_byte = 0;\n            }\n        }\n    }\n    state->current_bit += count_packed_bits;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      pack_bin\n *\n * description\n *      validate size and call basic_pack_bin\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      bin - input binary string\n *      len - input length\n *      state - pack state and intermediate results that are passed between\n *              invocations\n *\n * returns\n *      the function collects the result in buffer member of state parameter\n *\n * throws\n *      size error - element size exceeds input size for binary strings\n */\n", "func_signal": "static void pack_bin(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, PACK_STATE *state)", "code": "{\n    size_t len = 0;\n    const unsigned char *bin = (const unsigned char *)luaL_checklstring(l, arg_index, &len);\n    if(elem->size != ALL)\n    {\n        if(elem->size > len)\n        {\n            luaL_error(l, \n                    \"size error: argument %d size (%d bytes) exceeds the length of input stirng (%d bytes)\", \n                    arg_index, elem->size, len);\n        }\n        len = elem->size;\n    }\n\n    basic_pack_bin(l, elem, bin, len, state);\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      compare_token\n *\n * description\n *      compare zero terminated keyword with token that is\n *      not zero terminated\n *\n * paramenters\n *      keyword - zero terminated keyword\n *      token - token obtained from parsing the format string\n *      len - length of the token\n */\n", "func_signal": "static int compare_token(const char *keyword, const char *token, size_t len)", "code": "{\n    if(strlen(keyword) == len && memcmp(keyword, token, len) == 0)\n    {\n        return 1;\n    }\n    return 0;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      parse\n *\n * description\n *      dispatch for actual parsing by input type\n *\n * paramenters\n *      l - lua state\n *      handler - element handler\n *      arg - agument passed between invocations\n *\n * throws\n *      argcheck error - when input is not string or bitmatch\n */\n", "func_signal": "static void parse(lua_State *l, ELEM_HANDLER handler, void *arg)", "code": "{\n    if(lua_isstring(l, 1))\n    {\n        parse_format(l, handler, arg);\n    }\n    else if(lua_isuserdata(l, 1) && get_bitmatch(l, 1) != NULL)\n    {\n        parse_bitmatch(l, handler, arg);\n    }\n    else\n    {\n        char message[255];\n#ifdef WIN32\n        _snprintf_s(\n#else\n\t\tsnprintf(\n#endif\n\t\t\tmessage, sizeof(message), \n                \"bitstring.bitmatch or string expected, got %s\",\n                lua_typename(l, lua_type(l, 1)));\n        message[sizeof(message) - 1] = '\\0';\n\n        luaL_argcheck (l, 0, 1, message);\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      l_pack\n *\n * description\n *      lua_CFunction for packing\n *\n * paramenters\n *      l - lua state\n *\n * returns\n *      pushes the result string onto lua stack and\n *      returns 1\n */\n", "func_signal": "static int l_pack(lua_State *l)", "code": "{\n    luaL_Buffer b; \n    luaL_buffinit(l, &b);\n\n    PACK_STATE state;\n    state.buffer = &b;\n    state.prep_buffer = (unsigned char *)luaL_prepbuffer(&b);\n    state.current_bit = 0;\n    state.result_bits = LUAL_BUFFERSIZE * CHAR_BIT;\n\n    parse(l, pack_elem, (void *)&state);\n    luaL_addsize(&b, state.current_bit / CHAR_BIT);\n    luaL_pushresult(&b);\n    return 1;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      realloc_bitmatch\n *\n * description\n *      allocate a new buffer for bitmatch and copy to it\n *      contents of previous bitmatch if not NULL\n *\n * paramenters\n *      l - lua state\n *      state - compile state\n *\n * returns\n *      pointer to new BITMATCH\n */\n", "func_signal": "static BITMATCH *realloc_bitmatch(\n        lua_State *l, \n        COMPILE_STATE *state)", "code": "{\n    BITMATCH *current_bitmatch = state->bitmatch;\n    size_t current_element_count = state->element_count;\n    /* if reallocating existing bitmatch double number of elements */\n    size_t new_element_count = current_bitmatch ? \n        current_element_count * 2 : current_element_count;\n    size_t udata_size = sizeof(BITMATCH) + sizeof(ELEMENT_DESCRIPTION) * (new_element_count - 1);\n    BITMATCH *new_bitmatch = (BITMATCH *)lua_newuserdata(l, udata_size);\n    luaL_getmetatable(l, \"bitstring.bitmatch\");\n    lua_setmetatable(l, -2);\n\n    if(current_bitmatch != NULL)\n    {\n        size_t current_udata_size = \n            sizeof(BITMATCH) + sizeof(ELEMENT_DESCRIPTION) * (current_element_count - 1);\n        memcpy(new_bitmatch, current_bitmatch, current_udata_size);\n        /* remove the previous bitmatch from stack */\n        lua_remove(l, -2);\n    }\n    state->bitmatch = new_bitmatch;\n    state->bitmatch->element_count = 0;\n    state->element_count = new_element_count;\n    return new_bitmatch;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      unpack_bin\n *\n * description\n *      unpack binary string from input buffer and push it onto lua stack. \n *      update the number of return values\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      arg_index - number of element in format string. starts from 1 \n *      state - unpack state passed between invocations\n *\n * throws\n *      wrong format - using rest length specifier for incomplete bytes\n *      size error - requested length is greater then remaining part of input\n *\n * rationale\n *      the function unpacks stream of bytes as array of integers \n *      packed at arbitrary bit positions.\n *\n * future work\n *      optimize for most common usage pattern\n */\n", "func_signal": "static void unpack_bin(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, UNPACK_STATE *state)", "code": "{\n    if(elem->size == REST)\n    {\n        if(state->current_bit % CHAR_BIT != 0)\n        {\n            luaL_error(l, \"wrong format: using rest length specifier for incomplete bytes at element %d\", arg_index);\n        }\n\n        elem->size = (state->source_end - state->source) - state->current_bit / CHAR_BIT;\n    }\n\n    if(elem->size > state->source_bits / CHAR_BIT)\n    {\n        luaL_error(l, \"size error: requested length for element %d is greater then remaining part of input\", arg_index);\n    }\n\n    luaL_Buffer b; \n    luaL_buffinit(l, &b);\n\n    size_t i = 0;\n    while(i < elem->size)\n    {\n        unsigned char *result = (unsigned char *)luaL_prepbuffer(&b);\n        size_t j = 0;\n        while(i < elem->size && j < LUAL_BUFFERSIZE)\n        {\n            ELEMENT_DESCRIPTION tmp_elem;\n            tmp_elem.size = CHAR_BIT;\n            tmp_elem.endianess = EE_BIG;\n            tmp_elem.type = ET_INTEGER; \n            result[j] = unpack_int_no_push(l, &tmp_elem, arg_index, state);\n            ++i;\n            ++j;\n        }\n        luaL_addsize(&b, j);\n    }\n    ++state->return_count;\n    grow_unpack_stack(l, state);\n    luaL_pushresult(&b);\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      clear_unused_bits\n *\n * description\n *      clear unused bits in input value\n *\n * paramenters\n *      value - input from which unused bits will be cleared\n *      used_bits - number of bits that are in use\n *\n * returns\n *      the input value with all unused bits set to zero\n */\n", "func_signal": "static lua_Integer clear_unused_bits(lua_Integer value, size_t used_bits)", "code": "{\n    if(used_bits >= sizeof(value) * CHAR_BIT)\n    {\n        return value;\n    }\n    lua_Integer mask = (((~0) << used_bits) ^ (~0)); \n    return value & mask;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      unpack_elem\n *\n * description\n *      unpack element from input buffer \n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      arg_index - number of element in format string. starts from 1 \n *      state - unpack state passed between invocations\n *\n * throws\n *      wrong format - unexpected type\n *\n * future work\n *      add more types\n */\n", "func_signal": "static void unpack_elem(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, void *arg)", "code": "{\n    UNPACK_STATE *state = (UNPACK_STATE *)arg;\n    if(elem->type == ET_INTEGER)\n    {\n        unpack_int(l, elem, arg_index, state);\n    }\n    else if(elem->type == ET_BINARY)\n    {\n        unpack_bin(l, elem, arg_index, state);\n    }\n    else if(elem->type == ET_FLOAT)\n    {\n        unpack_float(l, elem, arg_index, state);\n    }\n    else\n    {\n        luaL_error(l, \"wrong format: unexpected type %d\", elem->type);\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      basic_pack_bin\n *\n * description\n *      pack binary into result buffer\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      bin - input binary string\n *      len - input length\n *      state - pack state and intermediate results that are passed between\n *              invocations\n *\n * returns\n *      the function collects the result in buffer member of state parameter\n *\n * rationale\n *      The function handles the binary string as sequence of integers\n *      to allow packing strings of arbitrary length on arbitrary bit\n *      positions.\n *\n */\n", "func_signal": "static void basic_pack_bin(lua_State *l, ELEMENT_DESCRIPTION *elem, const unsigned char *bin, size_t len, PACK_STATE *state)", "code": "{\n    if(state->current_bit % CHAR_BIT == 0)\n    {\n        pack_aligned_bin(l, elem, bin, len, state);\n    }\n    else\n    {\n        size_t i;\n        for(i = 0; i < len; ++i)\n        {\n            ELEMENT_DESCRIPTION elem;\n            elem.size = CHAR_BIT;\n            elem.endianess = EE_BIG;\n            elem.type = ET_INTEGER; \n            basic_pack_int(l, &elem, bin[i], state);\n        }\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      unpack_int_no_push \n *\n * description\n *      unpack integer from input buffer without pushing it onto lua\n *      stack\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      arg_index - number of element in format string. starts from 1 \n *      state - unpack state passed between invocations\n *\n * returns\n *      the unpacked integer in host byte order\n *\n * throws\n *      size error - element size exceeds the size of input reminder\n *      size error - element size exceeds the size of lua_Integer\n *      size error - element size is zero\n *\n * rationale\n *      handling different usage patterns separately provides opportunities\n *      for optimization\n *\n * future work\n *      optimize for most common usage pattern\n */\n", "func_signal": "static lua_Integer unpack_int_no_push(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, UNPACK_STATE *state)", "code": "{\n    /*\n     * check space\n     */\n    if(state->source_bits < elem->size)\n    {\n        luaL_error(l, \"size error: element %d size (%d bits) exceeds the size of input reminder (%d bits)\",\n                arg_index, elem->size, state->source_bits);\n    }\n\n    if(elem->size > sizeof(lua_Integer) * CHAR_BIT)\n    {\n        luaL_error(l, \"size error: argument %d size (%d bits) exceeds the lua_Integer size (%d bits)\", \n                arg_index, elem->size, sizeof(lua_Integer) * CHAR_BIT);\n    }\n\n    if(elem->size == 0)\n    {\n        luaL_error(l, \"size error: argument %d size must be greater then 0 bits\", arg_index);\n    }\n\n\n    /* number of most significant unprossed bits in the input buffer that are over byte bounds */\n    size_t bit_offset = state->current_bit % CHAR_BIT;\n    /* number of most significant bits in the result value that are over byte bounds */\n    size_t result_bit_offset = elem->size % CHAR_BIT;\n    /* current byte in the input buffer */\n    const unsigned char *current_byte = state->source + state->current_bit / CHAR_BIT;\n\n    lua_Integer result = 0xdeadbeef;\n\n    if(bit_offset == 0 && result_bit_offset == 0)\n    {\n        /* input buffer p - processed bits, u - unprocessed bits*/\n        /* pppp pppp  pppp pppp uuuu uuuu uuuu uuuu */\n        size_t bytes_to_copy = elem->size / CHAR_BIT;\n        unsigned char result_buffer[255];\n        memcpy(result_buffer, current_byte, bytes_to_copy);\n        result = toint(l, elem, arg_index, result_buffer, bytes_to_copy); \n    }\n    else\n    {\n        /* check for source end */\n        size_t end_bit = state->current_bit + elem->size;\n        const unsigned char *end_byte = state->source + end_bit / CHAR_BIT;\n\n        size_t bytes_to_copy = bits_to_bytes(elem->size);\n        unsigned char result_buffer[255];\n        memset(result_buffer, 0, bytes_to_copy);\n\n        /* copy bits to result_buffer while adjusting on byte bounds */\n        size_t right_shift = CHAR_BIT - end_bit % CHAR_BIT;\n        size_t left_shift = CHAR_BIT - right_shift;\n        int i;\n        for(i = bytes_to_copy - 1; i >= 0 && end_byte > current_byte; --i)\n        {\n            result_buffer[i] = (*end_byte >> right_shift) & 0xff; \n            --end_byte;\n            result_buffer[i] |= (*end_byte << left_shift) & 0xff;\n        }\n        if(i >= 0)\n        {\n            /* there are still some bits to copy from end_byte */\n            result_buffer[0] |= (*end_byte >> right_shift) & 0xff; \n        }\n\n        result = toint(l, elem, arg_index, result_buffer, bytes_to_copy); \n        result = clear_unused_bits(result, elem->size);\n    }\n    state->current_bit += elem->size;\n    state->source_bits -= elem->size;\n    return result;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      toendianess\n *\n * description\n *      convert endianess token to endianess enum value\n *\n * paramenters\n *      l - lua state\n *      token - token obtained from parsing the format string\n *      token_len - length of the token\n */\n", "func_signal": "static ELEMENT_ENDIANESS toendianess(lua_State *l, const char *token, size_t token_len)", "code": "{\n    int i = 1;\n    while(ENDIANESSES[i])\n    {\n        if(compare_token(ENDIANESSES[i], token, token_len))\n        {\n            return (ELEMENT_ENDIANESS)i;\n        } \n        ++i;\n    }\n    return (ELEMENT_ENDIANESS)luaL_error(l, \"wrong format: unexpected endianess token (%s)\", token); \n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      tosize\n *\n * description\n *      convert size token to size value\n *\n * paramenters\n *      l - lua state\n *      token - token obtained from parsing the format string\n *      token_len - length of the token\n */\n", "func_signal": "static size_t tosize(lua_State *l, const char *token, size_t token_len)", "code": "{\n    size_t size = -1;\n    if(compare_token(ALL_SPECIFIER, token, token_len))\n    {\n        size = ALL;\n    }\n    else if(compare_token(REST_SPECIFIER, token, token_len))\n    {\n        size = REST;\n    }\n    else\n    {\n        // strtol\n        size = atoi(token);\n    }\n    return size;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      pack_float\n *\n * description\n *      pack floating point number into result buffer\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      arg_index - number of element in format string. starts from 1 \n *      arg - pack state and intermediate results that are passed between\n *              invocations\n *\n * returns\n *      the function collects the result in buffer member of state parameter\n *\n * throws\n *      size error - element size is greater then sizeof lua_Number\n *      size error - unsupported element size. currently only single (32 bit) \n *                   and double (64 bit) precision is supported\n *\n * future work\n *      add half precision and other representation formats if somebody will\n *      find it useful\n */\n", "func_signal": "static void pack_float(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, PACK_STATE *state)", "code": "{\n    lua_Number value = luaL_checknumber(l, arg_index);\n    if(elem->size > sizeof(lua_Number) * CHAR_BIT)\n    {\n        luaL_error(l, \"size error: argument %d size (%d bits) exceeds the lua_Number size (%d bits)\", \n                arg_index, elem->size, sizeof(lua_Integer) * CHAR_BIT);\n    }\n\n    if(elem->endianess != EE_DEFAULT)\n    {\n        luaL_error(l, \"wrong format: unsupported endianess in argument %d\", arg_index);\n    }\n\n    if(elem->size == sizeof(float) * CHAR_BIT)\n    {\n        float tmp = (float)value;\n        basic_pack_bin(l, elem, (unsigned char *)&tmp, sizeof(tmp), state);\n    }\n    else if(elem->size == sizeof(double) * CHAR_BIT)\n    {\n        double tmp = value;\n        basic_pack_bin(l, elem, (unsigned char *)&tmp, sizeof(tmp), state);\n    }\n    else\n    {\n        luaL_error(l, \"size error: unsupported size %d for argument %d\", \n                elem->size, arg_index);\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      parse_bitmatch\n *\n * description\n *      iterate over array of elements and call handler for each\n *\n * paramenters\n *      l - lua state\n *      handler - handler for the element (un/pack_elem)\n *      arg - opaque argument passed between handlers\n */\n", "func_signal": "static void parse_bitmatch(lua_State *l, ELEM_HANDLER handler, void *arg)", "code": "{\n    BITMATCH *bitmatch = get_bitmatch(l, 1);\n    size_t i;\n    for(i = 0; i < bitmatch->element_count; ++i)\n    {\n        handler(l, &bitmatch->elements[i], i + 2, arg);\n    }\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      unpack_int\n *\n * description\n *      unpack integer from input buffer and push it onto lua stack. \n *      update the number of return values\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      arg_index - number of element in format string. starts from 1 \n *      state - unpack state passed between invocations\n *\n */\n", "func_signal": "static void unpack_int(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, UNPACK_STATE *state)", "code": "{\n    lua_Integer result = unpack_int_no_push(l, elem, arg_index, state);\n    ++state->return_count;\n    grow_unpack_stack(l, state);\n    lua_pushinteger(l, result);\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      l_unpack\n *\n * description\n *      lua_CFunction for unpacking\n *\n * paramenters\n *      l - lua state\n *\n * returns\n *      number of return values\n */\n", "func_signal": "static int l_unpack(lua_State *l)", "code": "{\n    size_t source_len = 0;\n    const unsigned char *source = get_substring(l, &source_len, 2, 3, 4);\n\n    UNPACK_STATE state;\n    state.return_count = 0;\n    state.current_bit = 0;\n    state.source_bits = source_len * CHAR_BIT;\n    state.source = source;\n    state.source_end = source + source_len;\n    parse(l, unpack_elem, (void *)&state);\n    return state.return_count;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      pack_int\n *\n * description\n *      validate size and call basic_pack_int\n *\n * paramenters\n *      l - lua state\n *      elem - element description\n *      value - value to pack\n *      state - pack state and intermediate results that are passed between\n *              invocations\n *\n * returns\n *      the function collects the result in buffer member of state parameter\n *\n * throws\n *      size error - element size exceeds lua_Integer size\n */\n", "func_signal": "static void pack_int(lua_State *l, ELEMENT_DESCRIPTION *elem, int arg_index, PACK_STATE *state)", "code": "{\n    lua_Integer value = luaL_checkinteger(l, arg_index);\n    if(elem->size > sizeof(lua_Integer) * CHAR_BIT)\n    {\n        luaL_error(l, \n                \"size error: argument %d size (%d bits) exceeds the lua_Integer size (%d bits)\", \n                arg_index, elem->size, sizeof(lua_Integer) * CHAR_BIT);\n    }\n    basic_pack_int(l, elem, value, state);\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/*\n * name\n *      l_compile\n *\n * description\n *      lua_CFunction for compiling format string to bitmatch array\n *\n * paramenters\n *      l - lua state\n *\n * returns\n *      1\n */\n", "func_signal": "static int l_compile(lua_State *l)", "code": "{\n    size_t default_element_count = 32;\n    COMPILE_STATE state;\n    state.current = 0;\n    state.element_count = default_element_count;\n    state.bitmatch = NULL;\n    realloc_bitmatch(l, &state);\n    parse(l, compile_elem, (void *)&state);\n    state.bitmatch->element_count = state.current;\n    return 1;\n}", "path": "bitstring\\src\\bitstring\\lbitstring.c", "repo_name": "luaforge/bitstring", "stars": 13, "license": "None", "language": "c", "size": 689}
{"docstring": "/* int disk_read */\n", "func_signal": "void module_register (void)", "code": "{\n  plugin_register_config (\"disk\", disk_config,\n      config_keys, config_keys_num);\n  plugin_register_init (\"disk\", disk_init);\n  plugin_register_read (\"disk\", disk_read);\n}", "path": "src\\disk.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* collectd_stop */\n", "func_signal": "static void sig_int_term_handler (int __attribute__((unused)) signo)", "code": "{\n\t++loop;\n\treturn;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int cow_read_ds2409 */\n", "func_signal": "static int cow_read_bus (const char *path)", "code": "{\n  char *buffer;\n  size_t buffer_size;\n  int status;\n\n  char *buffer_ptr;\n  char *dummy;\n  char *saveptr;\n  char subpath[4096];\n\n  status = OW_get (path, &buffer, &buffer_size);\n  if (status < 0)\n  {\n    ERROR (\"onewire plugin: OW_get (%s) failed. status = %#x;\",\n        path, status);\n    return (-1);\n  }\n  DEBUG (\"onewire plugin: OW_get (%s) returned: %s\",\n      path, buffer);\n\n  dummy = buffer;\n  saveptr = NULL;\n  while ((buffer_ptr = strtok_r (dummy, \",/\", &saveptr)) != NULL)\n  {\n    int i;\n\n    dummy = NULL;\n\n    if (strcmp (\"/\", path) == 0)\n      status = ssnprintf (subpath, sizeof (subpath), \"/%s\", buffer_ptr);\n    else\n      status = ssnprintf (subpath, sizeof (subpath), \"%s/%s\",\n          path, buffer_ptr);\n    if ((status <= 0) || (status >= sizeof (subpath)))\n      continue;\n\n    for (i = 0; i < ow_family_features_num; i++)\n    {\n      if (strncmp (ow_family_features[i].family, buffer_ptr,\n            strlen (ow_family_features[i].family)) != 0)\n        continue;\n\n      cow_read_values (subpath,\n          buffer_ptr + strlen (ow_family_features[i].family),\n          ow_family_features + i);\n      break;\n    }\n    if (i < ow_family_features_num)\n      continue;\n\n    /* DS2409 */\n    if (strncmp (\"1F.\", buffer_ptr, strlen (\"1F.\")) == 0)\n    {\n      cow_read_ds2409 (subpath);\n      continue;\n    }\n  } /* while (strtok_r) */\n\n  free (buffer);\n  return (0);\n}", "path": "src\\onewire.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* HAVE_IOKIT_IOKITLIB_H */\n", "func_signal": "static int disk_read (void)", "code": "{\n#if HAVE_IOKIT_IOKITLIB_H\n\tio_registry_entry_t\tdisk;\n\tio_registry_entry_t\tdisk_child;\n\tio_iterator_t\t\tdisk_list;\n\tCFDictionaryRef\t\tprops_dict;\n\tCFDictionaryRef\t\tstats_dict;\n\tCFDictionaryRef\t\tchild_dict;\n\tkern_return_t           status;\n\n\tsigned long long read_ops;\n\tsigned long long read_byt;\n\tsigned long long read_tme;\n\tsigned long long write_ops;\n\tsigned long long write_byt;\n\tsigned long long write_tme;\n\n\tint  disk_major;\n\tint  disk_minor;\n\tchar disk_name[64];\n\n\t/* Get the list of all disk objects. */\n\tif (IOServiceGetMatchingServices (io_master_port,\n\t\t\t\tIOServiceMatching (kIOBlockStorageDriverClass),\n\t\t\t\t&disk_list) != kIOReturnSuccess)\n\t{\n\t\tERROR (\"disk plugin: IOServiceGetMatchingServices failed.\");\n\t\treturn (-1);\n\t}\n\n\twhile ((disk = IOIteratorNext (disk_list)) != 0)\n\t{\n\t\tprops_dict = NULL;\n\t\tstats_dict = NULL;\n\t\tchild_dict = NULL;\n\n\t\t/* `disk_child' must be released */\n\t\tif ((status = IORegistryEntryGetChildEntry (disk, kIOServicePlane, &disk_child))\n\t\t\t       \t!= kIOReturnSuccess)\n\t\t{\n\t\t\t/* This fails for example for DVD/CD drives.. */\n\t\t\tDEBUG (\"IORegistryEntryGetChildEntry (disk) failed: 0x%08x\", status);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We create `props_dict' => we need to release it later */\n\t\tif (IORegistryEntryCreateCFProperties (disk,\n\t\t\t\t\t(CFMutableDictionaryRef *) &props_dict,\n\t\t\t\t\tkCFAllocatorDefault,\n\t\t\t\t\tkNilOptions)\n\t\t\t\t!= kIOReturnSuccess)\n\t\t{\n\t\t\tERROR (\"disk-plugin: IORegistryEntryCreateCFProperties failed.\");\n\t\t\tIOObjectRelease (disk_child);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (props_dict == NULL)\n\t\t{\n\t\t\tDEBUG (\"IORegistryEntryCreateCFProperties (disk) failed.\");\n\t\t\tIOObjectRelease (disk_child);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstats_dict = (CFDictionaryRef) CFDictionaryGetValue (props_dict,\n\t\t\t\tCFSTR (kIOBlockStorageDriverStatisticsKey));\n\n\t\tif (stats_dict == NULL)\n\t\t{\n\t\t\tDEBUG (\"CFDictionaryGetValue (%s) failed.\",\n\t\t\t\t       \tkIOBlockStorageDriverStatisticsKey);\n\t\t\tCFRelease (props_dict);\n\t\t\tIOObjectRelease (disk_child);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IORegistryEntryCreateCFProperties (disk_child,\n\t\t\t\t\t(CFMutableDictionaryRef *) &child_dict,\n\t\t\t\t\tkCFAllocatorDefault,\n\t\t\t\t\tkNilOptions)\n\t\t\t\t!= kIOReturnSuccess)\n\t\t{\n\t\t\tDEBUG (\"IORegistryEntryCreateCFProperties (disk_child) failed.\");\n\t\t\tIOObjectRelease (disk_child);\n\t\t\tCFRelease (props_dict);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* kIOBSDNameKey */\n\t\tdisk_major = (int) dict_get_value (child_dict,\n\t\t\t       \tkIOBSDMajorKey);\n\t\tdisk_minor = (int) dict_get_value (child_dict,\n\t\t\t       \tkIOBSDMinorKey);\n\t\tread_ops  = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsReadsKey);\n\t\tread_byt  = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsBytesReadKey);\n\t\tread_tme  = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsTotalReadTimeKey);\n\t\twrite_ops = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsWritesKey);\n\t\twrite_byt = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsBytesWrittenKey);\n\t\t/* This property describes the number of nanoseconds spent\n\t\t * performing writes since the block storage driver was\n\t\t * instantiated. It is one of the statistic entries listed\n\t\t * under the top-level kIOBlockStorageDriverStatisticsKey\n\t\t * property table. It has an OSNumber value. */\n\t\twrite_tme = dict_get_value (stats_dict,\n\t\t\t\tkIOBlockStorageDriverStatisticsTotalWriteTimeKey);\n\n\t\tif (ssnprintf (disk_name, sizeof (disk_name),\n\t\t\t\t\"%i-%i\", disk_major, disk_minor) >= sizeof (disk_name))\n\t\t{\n\t\t\tDEBUG (\"snprintf (major, minor) failed.\");\n\t\t\tCFRelease (child_dict);\n\t\t\tIOObjectRelease (disk_child);\n\t\t\tCFRelease (props_dict);\n\t\t\tIOObjectRelease (disk);\n\t\t\tcontinue;\n\t\t}\n\t\tDEBUG (\"disk_name = %s\", disk_name);\n\n\t\tif ((read_byt != -1LL) || (write_byt != -1LL))\n\t\t\tdisk_submit (disk_name, \"disk_octets\", read_byt, write_byt);\n\t\tif ((read_ops != -1LL) || (write_ops != -1LL))\n\t\t\tdisk_submit (disk_name, \"disk_ops\", read_ops, write_ops);\n\t\tif ((read_tme != -1LL) || (write_tme != -1LL))\n\t\t\tdisk_submit (disk_name, \"disk_time\",\n\t\t\t\t\tread_tme / 1000,\n\t\t\t\t\twrite_tme / 1000);\n\n\t\tCFRelease (child_dict);\n\t\tIOObjectRelease (disk_child);\n\t\tCFRelease (props_dict);\n\t\tIOObjectRelease (disk);\n\t}\n\tIOObjectRelease (disk_list);\n/* #endif HAVE_IOKIT_IOKITLIB_H */\n\n#elif KERNEL_LINUX\n\tFILE *fh;\n\tchar buffer[1024];\n\t\n\tchar *fields[32];\n\tint numfields;\n\tint fieldshift = 0;\n\n\tint major = 0;\n\tint minor = 0;\n\n\tcounter_t read_sectors  = 0;\n\tcounter_t write_sectors = 0;\n\n\tcounter_t read_ops      = 0;\n\tcounter_t read_merged   = 0;\n\tcounter_t read_time     = 0;\n\tcounter_t write_ops     = 0;\n\tcounter_t write_merged  = 0;\n\tcounter_t write_time    = 0;\n\tint is_disk = 0;\n\n\tdiskstats_t *ds, *pre_ds;\n\n\tif ((fh = fopen (\"/proc/diskstats\", \"r\")) == NULL)\n\t{\n\t\tfh = fopen (\"/proc/partitions\", \"r\");\n\t\tif (fh == NULL)\n\t\t{\n\t\t\tERROR (\"disk plugin: fopen (/proc/{diskstats,partitions}) failed.\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/* Kernel is 2.4.* */\n\t\tfieldshift = 1;\n\t}\n\n\twhile (fgets (buffer, sizeof (buffer), fh) != NULL)\n\t{\n\t\tchar *disk_name;\n\n\t\tnumfields = strsplit (buffer, fields, 32);\n\n\t\tif ((numfields != (14 + fieldshift)) && (numfields != 7))\n\t\t\tcontinue;\n\n\t\tmajor = atoll (fields[0]);\n\t\tminor = atoll (fields[1]);\n\n\t\tdisk_name = fields[2 + fieldshift];\n\n\t\tfor (ds = disklist, pre_ds = disklist; ds != NULL; pre_ds = ds, ds = ds->next)\n\t\t\tif (strcmp (disk_name, ds->name) == 0)\n\t\t\t\tbreak;\n\n\t\tif (ds == NULL)\n\t\t{\n\t\t\tif ((ds = (diskstats_t *) calloc (1, sizeof (diskstats_t))) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif ((ds->name = strdup (disk_name)) == NULL)\n\t\t\t{\n\t\t\t\tfree (ds);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pre_ds == NULL)\n\t\t\t\tdisklist = ds;\n\t\t\telse\n\t\t\t\tpre_ds->next = ds;\n\t\t}\n\n\t\tis_disk = 0;\n\t\tif (numfields == 7)\n\t\t{\n\t\t\t/* Kernel 2.6, Partition */\n\t\t\tread_ops      = atoll (fields[3]);\n\t\t\tread_sectors  = atoll (fields[4]);\n\t\t\twrite_ops     = atoll (fields[5]);\n\t\t\twrite_sectors = atoll (fields[6]);\n\t\t}\n\t\telse if (numfields == (14 + fieldshift))\n\t\t{\n\t\t\tread_ops  =  atoll (fields[3 + fieldshift]);\n\t\t\twrite_ops =  atoll (fields[7 + fieldshift]);\n\n\t\t\tread_sectors  = atoll (fields[5 + fieldshift]);\n\t\t\twrite_sectors = atoll (fields[9 + fieldshift]);\n\n\t\t\tif ((fieldshift == 0) || (minor == 0))\n\t\t\t{\n\t\t\t\tis_disk = 1;\n\t\t\t\tread_merged  = atoll (fields[4 + fieldshift]);\n\t\t\t\tread_time    = atoll (fields[6 + fieldshift]);\n\t\t\t\twrite_merged = atoll (fields[8 + fieldshift]);\n\t\t\t\twrite_time   = atoll (fields[10+ fieldshift]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG (\"numfields = %i; => unknown file format.\", numfields);\n\t\t\tcontinue;\n\t\t}\n\n\t\t{\n\t\t\tcounter_t diff_read_sectors;\n\t\t\tcounter_t diff_write_sectors;\n\n\t\t/* If the counter wraps around, it's only 32 bits.. */\n\t\t\tif (read_sectors < ds->read_sectors)\n\t\t\t\tdiff_read_sectors = 1 + read_sectors\n\t\t\t\t\t+ (UINT_MAX - ds->read_sectors);\n\t\t\telse\n\t\t\t\tdiff_read_sectors = read_sectors - ds->read_sectors;\n\t\t\tif (write_sectors < ds->write_sectors)\n\t\t\t\tdiff_write_sectors = 1 + write_sectors\n\t\t\t\t\t+ (UINT_MAX - ds->write_sectors);\n\t\t\telse\n\t\t\t\tdiff_write_sectors = write_sectors - ds->write_sectors;\n\n\t\t\tds->read_bytes += 512 * diff_read_sectors;\n\t\t\tds->write_bytes += 512 * diff_write_sectors;\n\t\t\tds->read_sectors = read_sectors;\n\t\t\tds->write_sectors = write_sectors;\n\t\t}\n\n\t\t/* Calculate the average time an io-op needs to complete */\n\t\tif (is_disk)\n\t\t{\n\t\t\tcounter_t diff_read_ops;\n\t\t\tcounter_t diff_write_ops;\n\t\t\tcounter_t diff_read_time;\n\t\t\tcounter_t diff_write_time;\n\n\t\t\tif (read_ops < ds->read_ops)\n\t\t\t\tdiff_read_ops = 1 + read_ops\n\t\t\t\t\t+ (UINT_MAX - ds->read_ops);\n\t\t\telse\n\t\t\t\tdiff_read_ops = read_ops - ds->read_ops;\n\t\t\tDEBUG (\"disk plugin: disk_name = %s; read_ops = %llu; \"\n\t\t\t\t\t\"ds->read_ops = %llu; diff_read_ops = %llu;\",\n\t\t\t\t\tdisk_name,\n\t\t\t\t\tread_ops, ds->read_ops, diff_read_ops);\n\n\t\t\tif (write_ops < ds->write_ops)\n\t\t\t\tdiff_write_ops = 1 + write_ops\n\t\t\t\t\t+ (UINT_MAX - ds->write_ops);\n\t\t\telse\n\t\t\t\tdiff_write_ops = write_ops - ds->write_ops;\n\n\t\t\tif (read_time < ds->read_time)\n\t\t\t\tdiff_read_time = 1 + read_time\n\t\t\t\t\t+ (UINT_MAX - ds->read_time);\n\t\t\telse\n\t\t\t\tdiff_read_time = read_time - ds->read_time;\n\n\t\t\tif (write_time < ds->write_time)\n\t\t\t\tdiff_write_time = 1 + write_time\n\t\t\t\t\t+ (UINT_MAX - ds->write_time);\n\t\t\telse\n\t\t\t\tdiff_write_time = write_time - ds->write_time;\n\n\t\t\tif (diff_read_ops != 0)\n\t\t\t\tds->avg_read_time += (diff_read_time\n\t\t\t\t\t\t+ (diff_read_ops / 2))\n\t\t\t\t\t/ diff_read_ops;\n\t\t\tif (diff_write_ops != 0)\n\t\t\t\tds->avg_write_time += (diff_write_time\n\t\t\t\t\t\t+ (diff_write_ops / 2))\n\t\t\t\t\t/ diff_write_ops;\n\n\t\t\tds->read_ops = read_ops;\n\t\t\tds->read_time = read_time;\n\t\t\tds->write_ops = write_ops;\n\t\t\tds->write_time = write_time;\n\t\t} /* if (is_disk) */\n\n\t\t/* Don't write to the RRDs if we've just started.. */\n\t\tds->poll_count++;\n\t\tif (ds->poll_count <= 2)\n\t\t{\n\t\t\tDEBUG (\"disk plugin: (ds->poll_count = %i) <= \"\n\t\t\t\t\t\"(min_poll_count = 2); => Not writing.\",\n\t\t\t\t\tds->poll_count);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((read_ops == 0) && (write_ops == 0))\n\t\t{\n\t\t\tDEBUG (\"disk plugin: ((read_ops == 0) && \"\n\t\t\t\t\t\"(write_ops == 0)); => Not writing.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((ds->read_bytes != 0) || (ds->write_bytes != 0))\n\t\t\tdisk_submit (disk_name, \"disk_octets\",\n\t\t\t\t\tds->read_bytes, ds->write_bytes);\n\n\t\tif ((ds->read_ops != 0) || (ds->write_ops != 0))\n\t\t\tdisk_submit (disk_name, \"disk_ops\",\n\t\t\t\t\tread_ops, write_ops);\n\n\t\tif ((ds->avg_read_time != 0) || (ds->avg_write_time != 0))\n\t\t\tdisk_submit (disk_name, \"disk_time\",\n\t\t\t\t\tds->avg_read_time, ds->avg_write_time);\n\n\t\tif (is_disk)\n\t\t{\n\t\t\tdisk_submit (disk_name, \"disk_merged\",\n\t\t\t\t\tread_merged, write_merged);\n\t\t} /* if (is_disk) */\n\t} /* while (fgets (buffer, sizeof (buffer), fh) != NULL) */\n\n\tfclose (fh);\n/* #endif defined(KERNEL_LINUX) */\n\n#elif HAVE_LIBKSTAT\n# if HAVE_KSTAT_IO_T_WRITES && HAVE_KSTAT_IO_T_NWRITES && HAVE_KSTAT_IO_T_WTIME\n#  define KIO_ROCTETS reads\n#  define KIO_WOCTETS writes\n#  define KIO_ROPS    nreads\n#  define KIO_WOPS    nwrites\n#  define KIO_RTIME   rtime\n#  define KIO_WTIME   wtime\n# elif HAVE_KSTAT_IO_T_NWRITTEN && HAVE_KSTAT_IO_T_WRITES && HAVE_KSTAT_IO_T_WTIME\n#  define KIO_ROCTETS nread\n#  define KIO_WOCTETS nwritten\n#  define KIO_ROPS    reads\n#  define KIO_WOPS    writes\n#  define KIO_RTIME   rtime\n#  define KIO_WTIME   wtime\n# else\n#  error \"kstat_io_t does not have the required members\"\n# endif\n\tstatic kstat_io_t kio;\n\tint i;\n\n\tif (kc == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; i < numdisk; i++)\n\t{\n\t\tif (kstat_read (kc, ksp[i], &kio) == -1)\n\t\t\tcontinue;\n\n\t\tif (strncmp (ksp[i]->ks_class, \"disk\", 4) == 0)\n\t\t{\n\t\t\tdisk_submit (ksp[i]->ks_name, \"disk_octets\",\n\t\t\t\t\tkio.KIO_ROCTETS, kio.KIO_WOCTETS);\n\t\t\tdisk_submit (ksp[i]->ks_name, \"disk_ops\",\n\t\t\t\t\tkio.KIO_ROPS, kio.KIO_WOPS);\n\t\t\t/* FIXME: Convert this to microseconds if necessary */\n\t\t\tdisk_submit (ksp[i]->ks_name, \"disk_time\",\n\t\t\t\t\tkio.KIO_RTIME, kio.KIO_WTIME);\n\t\t}\n\t\telse if (strncmp (ksp[i]->ks_class, \"partition\", 9) == 0)\n\t\t{\n\t\t\tdisk_submit (ksp[i]->ks_name, \"disk_octets\",\n\t\t\t\t\tkio.KIO_ROCTETS, kio.KIO_WOCTETS);\n\t\t\tdisk_submit (ksp[i]->ks_name, \"disk_ops\",\n\t\t\t\t\tkio.KIO_ROPS, kio.KIO_WOPS);\n\t\t}\n\t}\n/* #endif defined(HAVE_LIBKSTAT) */\n\n#elif defined(HAVE_LIBSTATGRAB)\n\tsg_disk_io_stats *ds;\n\tint disks, counter;\n\tchar name[DATA_MAX_NAME_LEN];\n\t\n\tif ((ds = sg_get_disk_io_stats(&disks)) == NULL)\n\t\treturn (0);\n\t\t\n\tfor (counter=0; counter < disks; counter++) {\n\t\tstrncpy(name, ds->disk_name, sizeof(name));\n\t\tname[sizeof(name)-1] = '\\0'; /* strncpy doesn't terminate longer strings */\n\t\tdisk_submit (name, \"disk_octets\", ds->read_bytes, ds->write_bytes);\n\t\tds++;\n\t}\n#endif /* defined(HAVE_LIBSTATGRAB) */\n\n\treturn (0);\n}", "path": "src\\disk.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int disk_init */\n", "func_signal": "static void disk_submit (const char *plugin_instance,\n\t\tconst char *type,\n\t\tcounter_t read, counter_t write)", "code": "{\n\tvalue_t values[2];\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\n\t/* Both `ignorelist' and `plugin_instance' may be NULL. */\n\tif (ignorelist_match (ignorelist, plugin_instance) != 0)\n\t  return;\n\n\tvalues[0].counter = read;\n\tvalues[1].counter = write;\n\n\tvl.values = values;\n\tvl.values_len = 2;\n\tsstrncpy (vl.host, hostname_g, sizeof (vl.host));\n\tsstrncpy (vl.plugin, \"disk\", sizeof (vl.plugin));\n\tsstrncpy (vl.plugin_instance, plugin_instance,\n\t\t\tsizeof (vl.plugin_instance));\n\tsstrncpy (vl.type, type, sizeof (vl.type));\n\n\tplugin_dispatch_values (&vl);\n}", "path": "src\\disk.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int disk_config */\n", "func_signal": "static int disk_init (void)", "code": "{\n#if HAVE_IOKIT_IOKITLIB_H\n\tkern_return_t status;\n\t\n\tif (io_master_port != MACH_PORT_NULL)\n\t{\n\t\tmach_port_deallocate (mach_task_self (),\n\t\t\t\tio_master_port);\n\t\tio_master_port = MACH_PORT_NULL;\n\t}\n\n\tstatus = IOMasterPort (MACH_PORT_NULL, &io_master_port);\n\tif (status != kIOReturnSuccess)\n\t{\n\t\tERROR (\"IOMasterPort failed: %s\",\n\t\t\t\tmach_error_string (status));\n\t\tio_master_port = MACH_PORT_NULL;\n\t\treturn (-1);\n\t}\n/* #endif HAVE_IOKIT_IOKITLIB_H */\n\n#elif KERNEL_LINUX\n\t/* do nothing */\n/* #endif KERNEL_LINUX */\n\n#elif HAVE_LIBKSTAT\n\tkstat_t *ksp_chain;\n\n\tnumdisk = 0;\n\n\tif (kc == NULL)\n\t\treturn (-1);\n\n\tfor (numdisk = 0, ksp_chain = kc->kc_chain;\n\t\t\t(numdisk < MAX_NUMDISK) && (ksp_chain != NULL);\n\t\t\tksp_chain = ksp_chain->ks_next)\n\t{\n\t\tif (strncmp (ksp_chain->ks_class, \"disk\", 4)\n\t\t\t\t&& strncmp (ksp_chain->ks_class, \"partition\", 9))\n\t\t\tcontinue;\n\t\tif (ksp_chain->ks_type != KSTAT_TYPE_IO)\n\t\t\tcontinue;\n\t\tksp[numdisk++] = ksp_chain;\n\t}\n#endif /* HAVE_LIBKSTAT */\n\n\treturn (0);\n}", "path": "src\\disk.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* exit_usage */\n", "func_signal": "static int pidfile_create (void)", "code": "{\n\tFILE *file = NULL;\n\n\tif (NULL == pidfile)\n\t\tpidfile = COLLECTDMON_PIDFILE;\n\n\tif (NULL == (file = fopen (pidfile, \"w\"))) {\n\t\tsyslog (LOG_ERR, \"Error: couldn't open PID-file (%s) for writing: %s\",\n\t\t\t\tpidfile, strerror (errno));\n\t\treturn -1;\n\t}\n\n\tfprintf (file, \"%i\\n\", (int)getpid ());\n\tfclose (file);\n\treturn 0;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* sig_int_term_handler */\n", "func_signal": "static void sig_hup_handler (int __attribute__((unused)) signo)", "code": "{\n\t++restart;\n\treturn;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* pidfile_create */\n", "func_signal": "static int pidfile_delete (void)", "code": "{\n\tassert (NULL != pidfile);\n\n\tif (0 != unlink (pidfile)) {\n\t\tsyslog (LOG_ERR, \"Error: couldn't delete PID-file (%s): %s\",\n\t\t\t\tpidfile, strerror (errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* check_respawn */\n", "func_signal": "int main (int argc, char **argv)", "code": "{\n\tint    collectd_argc = 0;\n\tchar  *collectd      = NULL;\n\tchar **collectd_argv = NULL;\n\n\tstruct sigaction sa;\n\n\tint i = 0;\n\n\t/* parse command line options */\n\twhile (42) {\n\t\tint c = getopt (argc, argv, \"hc:P:\");\n\n\t\tif (-1 == c)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\t\tcase 'c':\n\t\t\t\tcollectd = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tpidfile = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tdefault:\n\t\t\t\texit_usage (argv[0]);\n\t\t}\n\t}\n\n\tfor (i = optind; i < argc; ++i)\n\t\tif (0 == strcmp (argv[i], \"-f\"))\n\t\t\tbreak;\n\n\t/* i < argc => -f already present */\n\tcollectd_argc = 1 + argc - optind + ((i < argc) ? 0 : 1);\n\tcollectd_argv = (char **)calloc (collectd_argc + 1, sizeof (char *));\n\n\tif (NULL == collectd_argv) {\n\t\tfprintf (stderr, \"Out of memory.\");\n\t\treturn 3;\n\t}\n\n\tcollectd_argv[0] = (NULL == collectd) ? \"collectd\" : collectd;\n\n\tif (i == argc)\n\t\tcollectd_argv[collectd_argc - 1] = \"-f\";\n\n\tfor (i = optind; i < argc; ++i)\n\t\tcollectd_argv[i - optind + 1] = argv[i];\n\n\tcollectd_argv[collectd_argc] = NULL;\n\n\topenlog (\"collectdmon\", LOG_CONS | LOG_PID, LOG_DAEMON);\n\n\tif (-1 == daemonize ())\n\t\treturn 1;\n\n\tsa.sa_handler = sig_int_term_handler;\n\tsa.sa_flags   = 0;\n\tsigemptyset (&sa.sa_mask);\n\n\tif (0 != sigaction (SIGINT, &sa, NULL)) {\n\t\tsyslog (LOG_ERR, \"Error: sigaction() failed: %s\", strerror (errno));\n\t\treturn 1;\n\t}\n\n\tif (0 != sigaction (SIGTERM, &sa, NULL)) {\n\t\tsyslog (LOG_ERR, \"Error: sigaction() failed: %s\", strerror (errno));\n\t\treturn 1;\n\t}\n\n\tsa.sa_handler = sig_hup_handler;\n\n\tif (0 != sigaction (SIGHUP, &sa, NULL)) {\n\t\tsyslog (LOG_ERR, \"Error: sigaction() failed: %s\", strerror (errno));\n\t\treturn 1;\n\t}\n\n\twhile (0 == loop) {\n\t\tint status = 0;\n\n\t\tif (0 != collectd_start (collectd_argv)) {\n\t\t\tsyslog (LOG_ERR, \"Error: failed to start collectd.\");\n\t\t\tbreak;\n\t\t}\n\n\t\tassert (0 < collectd_pid);\n\t\twhile ((collectd_pid != waitpid (collectd_pid, &status, 0))\n\t\t\t\t&& (EINTR == errno))\n\t\t\tif ((0 != loop) || (0 != restart))\n\t\t\t\tcollectd_stop ();\n\n\t\tcollectd_pid = 0;\n\n\t\tlog_status (status);\n\t\tcheck_respawn ();\n\n\t\tif (0 != restart) {\n\t\t\tsyslog (LOG_INFO, \"Info: restarting collectd\");\n\t\t\trestart = 0;\n\t\t}\n\t\telse if (0 == loop)\n\t\t\tsyslog (LOG_WARNING, \"Warning: restarting collectd\");\n\t}\n\n\tsyslog (LOG_INFO, \"Info: shutting down collectdmon\");\n\n\tpidfile_delete ();\n\tcloselog ();\n\n\tfree (collectd_argv);\n\treturn 0;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* pidfile_remove */\n", "func_signal": "static int daemonize (void)", "code": "{\n\tstruct rlimit rl;\n\n\tpid_t pid = 0;\n\tint   i   = 0;\n\n\tif (0 != chdir (\"/\")) {\n\t\tfprintf (stderr, \"Error: chdir() failed: %s\\n\", strerror (errno));\n\t\treturn -1;\n\t}\n\n\tif (0 != getrlimit (RLIMIT_NOFILE, &rl)) {\n\t\tfprintf (stderr, \"Error: getrlimit() failed: %s\\n\", strerror (errno));\n\t\treturn -1;\n\t}\n\n\tif (0 > (pid = fork ())) {\n\t\tfprintf (stderr, \"Error: fork() failed: %s\\n\", strerror (errno));\n\t\treturn -1;\n\t}\n\telse if (pid != 0) {\n\t\texit (0);\n\t}\n\n\tif (0 != pidfile_create ())\n\t\treturn -1;\n\n\tsetsid ();\n\n\tif (RLIM_INFINITY == rl.rlim_max)\n\t\trl.rlim_max = 1024;\n\n\tfor (i = 0; i < (int)rl.rlim_max; ++i)\n\t\tclose (i);\n\n\terrno = 0;\n\tif (open (\"/dev/null\", O_RDWR) != 0) {\n\t\tsyslog (LOG_ERR, \"Error: couldn't connect STDIN to /dev/null: %s\",\n\t\t\t\tstrerror (errno));\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tif (dup (0) != 1) {\n\t\tsyslog (LOG_ERR, \"Error: couldn't connect STDOUT to /dev/null: %s\",\n\t\t\t\tstrerror (errno));\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tif (dup (0) != 2) {\n\t\tsyslog (LOG_ERR, \"Error: couldn't connect STDERR to /dev/null: %s\",\n\t\t\t\tstrerror (errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* sig_hup_handler */\n", "func_signal": "static void log_status (int status)", "code": "{\n\tif (WIFEXITED (status)) {\n\t\tif (0 == WEXITSTATUS (status))\n\t\t\tsyslog (LOG_INFO, \"Info: collectd terminated with exit status %i\",\n\t\t\t\t\tWEXITSTATUS (status));\n\t\telse\n\t\t\tsyslog (LOG_WARNING,\n\t\t\t\t\t\"Warning: collectd terminated with exit status %i\",\n\t\t\t\t\tWEXITSTATUS (status));\n\t}\n\telse if (WIFSIGNALED (status)) {\n\t\tsyslog (LOG_WARNING, \"Warning: collectd was terminated by signal %i%s\",\n\t\t\t\tWTERMSIG (status), WCOREDUMP (status) ? \" (core dumped)\" : \"\");\n\t}\n\treturn;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/*\n * cow_read_ds2409\n *\n * Handles:\n * - DS2409 - MicroLAN Coupler\n */\n", "func_signal": "static int cow_read_ds2409 (const char *path)", "code": "{\n  char subpath[4096];\n  int status;\n\n  status = ssnprintf (subpath, sizeof (subpath), \"%s/main\", path);\n  if ((status > 0) && (status < sizeof (subpath)))\n    cow_read_bus (subpath);\n\n  status = ssnprintf (subpath, sizeof (subpath), \"%s/aux\", path);\n  if ((status > 0) && (status < sizeof (subpath)))\n    cow_read_bus (subpath);\n\n  return (0);\n}", "path": "src\\onewire.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int cow_shutdown */\n", "func_signal": "static int cow_init (void)", "code": "{\n  int status;\n  struct timespec cb_interval;\n\n  if (device_g == NULL)\n  {\n    ERROR (\"onewire plugin: cow_init: No device configured.\");\n    return (-1);\n  }\n\n  status = (int) OW_init (device_g);\n  if (status != 0)\n  {\n    ERROR (\"onewire plugin: OW_init(%s) failed: %i.\", device_g, status);\n    return (1);\n  }\n\n  memset (&cb_interval, 0, sizeof (cb_interval));\n  if (ow_interval > 0)\n    cb_interval.tv_sec = (time_t) ow_interval;\n\n  plugin_register_complex_read (\"onewire\", cow_read,\n      &cb_interval, /* user data = */ NULL);\n  plugin_register_shutdown (\"onewire\", cow_shutdown);\n\n  return (0);\n}", "path": "src\\onewire.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* }}} int tr_invoke */\n", "func_signal": "void module_register (void)", "code": "{\n\ttarget_proc_t tproc;\n\n\tmemset (&tproc, 0, sizeof (tproc));\n\ttproc.create  = tr_create;\n\ttproc.destroy = tr_destroy;\n\ttproc.invoke  = tr_invoke;\n\tfc_register_target (\"replace\", tproc);\n}", "path": "src\\target_replace.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int cow_read */\n", "func_signal": "static int cow_shutdown (void)", "code": "{\n  OW_finish ();\n  ignorelist_free (sensor_list);\n  return (0);\n}", "path": "src\\onewire.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* daemonize */\n", "func_signal": "static int collectd_start (char **argv)", "code": "{\n\tpid_t pid = 0;\n\n\tif (0 > (pid = fork ())) {\n\t\tsyslog (LOG_ERR, \"Error: fork() failed: %s\", strerror (errno));\n\t\treturn -1;\n\t}\n\telse if (pid != 0) {\n\t\tcollectd_pid = pid;\n\t\treturn 0;\n\t}\n\n\texecvp (argv[0], argv);\n\tsyslog (LOG_ERR, \"Error: execvp(%s) failed: %s\",\n\t\t\targv[0], strerror (errno));\n\texit (-1);\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* collectd_start */\n", "func_signal": "static int collectd_stop (void)", "code": "{\n\tif (0 == collectd_pid)\n\t\treturn 0;\n\n\tif (0 != kill (collectd_pid, SIGTERM)) {\n\t\tsyslog (LOG_ERR, \"Error: kill() failed: %s\", strerror (errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* int cow_init */\n", "func_signal": "void module_register (void)", "code": "{\n  plugin_register_init (\"onewire\", cow_init);\n  plugin_register_config (\"onewire\", cow_load_config,\n    config_keys, config_keys_num);\n}", "path": "src\\onewire.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/* log_status */\n", "func_signal": "static void check_respawn (void)", "code": "{\n\ttime_t t = time (NULL);\n\n\tstatic time_t timestamp = 0;\n\tstatic int    counter   = 0;\n\n\tif ((t - 120) < timestamp)\n\t\t++counter;\n\telse {\n\t\ttimestamp = t;\n\t\tcounter   = 0;\n\t}\n\n\tif (10 < counter) {\n\t\tunsigned int time_left = 300;\n\n\t\tsyslog (LOG_ERR, \"Error: collectd is respawning too fast - \"\n\t\t\t\t\"disabled for %i seconds\", time_left);\n\n\t\twhile ((0 < (time_left = sleep (time_left))) && (0 == loop));\n\t}\n\treturn;\n}", "path": "src\\collectdmon.c", "repo_name": "astro/collectd", "stars": 13, "license": "gpl-2.0", "language": "c", "size": 3736}
{"docstring": "/*\n * hash deletion function\n *\n * similarly to hash insertion function, accepts the callback parameter, \n * which specifies whether it can delete or not\n *\n * returns the data pointer that has been deleted or marked for deletion.\n * The \"do_delete\" callback is called when the item is indeed deleted.\n * The \"did_delete\" variable gets updated with the info if the item was really\n * deleted or only marked for deletion.\n *\n * NULL if not found or not deleted\n */\n", "func_signal": "void *hdelete(htable_t *ht, void *key, int key_len, hcallback_func_t *can_delete, hcallback_func_t *do_delete, int *did_delete)", "code": "{\n  uint32_t index;\n  hash_entry_t *hen;\n  void *data_old;\n\n  null_if_null(ht);\n  \n  index = h_index(ht, key, key_len);\n  hen = h_entry(ht, index, key, key_len);\n  if (hen == NULL) {\n    if (did_delete) { *did_delete = 0; }\n    return NULL;\n  } else {\n    if(can_delete == NULL || can_delete(key, key_len, hen->data, NULL)) {\n      data_old = hen->data;\n      h_try_delete(ht, hen, do_delete, did_delete);\n      return data_old;\n    } else {\n      // aren't going to delete anything even though found - not allowed.\n      if (did_delete) { *did_delete = 0; }\n      return NULL;\n    }\n  }\n}", "path": "supp_src\\lib_hash.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* Variable values are always passed as a pair (ptr, length). */\n", "func_signal": "int Variable2_UDP(const u8t *val, int length, u8t* data, int *i, int datasz)", "code": "{\n    if(*i + length + 2 >= datasz) {\n      return -1;\n    }\n    if (length >= 0 && length <= 65535) {\n      data[*i + 0] = (u8t) (length % 256);\n      data[*i + 1] = (u8t) (length / 256);\n      *i+=2;\n      memcpy(&data[*i], val, length);\n      *i+=length;\n    } else {\n      assert(0 == \"Length of Variable2 is illegal\");\n    }\n    return 0;\n}", "path": "fmv_src\\sta_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/*\n * Hash find function\n */\n", "func_signal": "void *hfind(htable_t *ht, void *key, int key_len)", "code": "{\n  uint32_t index;\n  hash_entry_t *hen;\n\n  null_if_null(ht);\n\n  index = h_index(ht, key, key_len);\n  hen = h_entry(ht, index, key, key_len);\n  return hen ? hen->data : NULL;\n}", "path": "supp_src\\lib_hash.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/**\n * For now, we interpolates the Z coordinate using a simple algorithm:\n *\n *  - take the x-y square with the center in the middle, \n *    that contains our x-y coordinates. \n *  - put a dot in the middle of it.\n *  - use that dot as a means to split the square into 3 triangles\n *  - select the triangle that the user's supplied coordinates fall into.\n *  - return Z coordinate for the user's point on that respective plane.\n * \n *  As we probably would need the normal vector too in the near future,\n *  split the calculation of the plane coefficient into a separate function.\n *\n **/\n", "func_signal": "static void calc_abcmd(float x, float y, float *A, float *B, float *C, float *MD)", "code": "{\n  float x1, x2, x3, y1, y2, y3, z1, z2, z3;\n  int x0, y0;\n\n\n  // will use in indices and as a base. It's truncated x,y.\n  x0 = (int)(x); y0 = (int)(y); \n\n  // 3rd point is the average of all 4 points of the bounding x-y square.\n\n  x3 = 0.5 + x0; \n  y3 = 0.5 + y0;\n  z3 = 0.25 * ( H(x0, y0) + H(x0+1, y0) + H(x0, y0+1) + H(x0+1, y0+1) );\n\n  /* \n   * Now we need to find which triangle we're in. Let's imagine this \n   * x/y square being a postcard, with the (x0,y0) its \n   * left-top corner. Then (x3,y3) divides it into four triangles.\n   * Let's number them from 1 to 4:\n   *\n   * (x0,y0)  (x0+1, y0)\n   *  |      /\n   *  v     v\n   *  +-----+---> X\n   *  |\\ 1 /| \n   *  | \\ / |\n   *  |4 + 2|\n   *  | / \\ |\n   *  |/ 3 \\|\n   *  +-----+ <-- (x0+1, y0+1)\n   *  |\n   *  v\n   *  Y\n   * \n   * To figure out which of the triangles holds the (x,y) we need to find the position\n   * of that dot reative to two diagonals.\n   *\n   * First - if x - x0> y - y0 then we're either in 1 or 2, else if \n   * x < y then we're in either 3 or 4. If we just use that to fix the x1/y1 pair to \n   * the common point, I think we will get the \"flipover\" effect. So we'll assign \n   * the coordinates for x1, x2 always in pairs.\n   * \n   * Second bisection - if (x0+1-x > y-y0) then it is either in 1 or 4, otherwise \n   * it is in 2 or 3. \n   * \n   * The border where the strict inequality does not hold - can be calculated\n   * using either of the plane equations. So we save some typing.\n   *\n   * Intuitively, the direction of the normal vector, should be dependant on the \n   * \"rotation\" of the points - so we can't \"optimize\" by using one condition to \n   * assign the common value. We assign the coords for points \"clockwise\",\n   * taking into the account that (x3, y3) is already assigned.\n   *\n   * (x0,y0)  (x0+1, y0)\n   *  |      /\n   *  v     v\n   *  +-----+---> X\n   *  |\\ 1 /| \n   *  | \\ / |\n   *  |4 + 2|\n   *  | / \\ |\n   *  |/ 3 \\|\n   *  +-----+ <-- (x0+1, y0+1)\n   *  | \\\n   *  v  (x0, y0+1)\n   *  Y\n   * \n   */\n\n  if(x0+1-x > y-y0) { // either #1 or #4\n    // and according to gnuplot I mixed 1 and 4... odd.\n    if(x-x0 > y-y0) { // #1\n      x1 = x0; y1 = y0; z1 = H(x0,y0);\n      x2 = x0+1.0; y2 = y0; z2 = H(x0+1,y0);\n    } else { // #4\n      x1 = x0; y1 = y0+1; z1 = H(x0,y0+1);\n      x2 = x0; y2 = y0; z2 = H(x0,y0);\n    }\n  } else { // either #2 or #3\n    // hmm on the graph looks like I mixed 2 and 3, yet I miss it...\n    if(x-x0 > y-y0) { // #2\n      x1 = x0+1.0; y1 = y0; z1 = H(x0+1,y0);\n      x2 = x0+1.0; y2 = y0+1.0; z2 = H(x0+1,y0+1);\n    } else { // #3\n      x1 = x0+1.0; y1 = y0+1.0; z1 = H(x0+1,y0+1);\n      x2 = x0; y2 = y0+1.0; z2 = H(x0,y0+1);\n    }\n  }\n\n  /*\n   * now we have the three points. Calculate the coefficients\n   * for the equation of the plane in the form:\n   * \"Ax + By + Cz = MD\" (MD == minus D)\n   */\n\n  *A = y1 * (z2 - z3) + y2 * (z3 - z1) + y3 * (z1 - z2);\n  *B = z1 * (x2 - x3) + z2 * (x3 - x1) + z3 * (x1 - x2);\n  *C = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);\n  *MD = x1 * (y2*z3 - y3*z2) + x2 * (y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1);\n}", "path": "pktsmv_src\\pktsmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/**\n * return the symbolic name of the function pointer, the caller needs to free the memory!\n * param fptr function pointer\n */\n", "func_signal": "char *get_symbol_name(void *fptr)", "code": "{\n  char **strings;\n  char *str;\n  strings = backtrace_symbols(&fptr, 1);\n  str = strdup(strings[0]);\n  free(strings);\n  return str;\n}", "path": "supp_src\\lib_debug.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* Function is called with the single parameter - the session table for \nthe session that needs to receive the layer data */\n", "func_signal": "int\nlua_fn_SendLayerData(lua_State *L)", "code": "{\n  uint16_t patches[16];\n  int i;\n  int done = 0;\n  dbuf_t *pkt;\n\n  int x, y;\n\n  for(x=0; x<256; x++) {\n    for(y=0; y<256; y++) {\n      my_height_map[y*256 + x] = 30 * cos(((float)x - 128.0)/64.0) * cos(((float)y - 128.0)/64.0);\n      // Flat terrain\n      //my_height_map[y*256 + x] = 0.3;\n    }\n  }\n  \n\n\n  for(i=0;i<=15;i++) {\n    patches[i] = 0xFFFF;\n  }\n  while(!done) {\n    pkt = MakeLayerPatches(patches, patches); \n    assert(pkt->dsize < pkt->size);\n    lua_getglobal(L, \"smv_send_then_unlock\");\n    lua_pushvalue(L, -2); // the sess entry\n    lua_pushlightuserdata(L, pkt);\n    lua_pcall_with_debug(L, 2, 0, DBG_GLOBAL, 0);\n\n    done = 1;\n    for(i=0;i<=15;i++) {\n      if(patches[i]) done = 0;\n    }\n  }\n  return 0;\n}", "path": "pktsmv_src\\pktsmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/*\nvoid\nlua_pushx_ipaddr(lua_State *L, u32t ipaddr) {\n  struct in_addr in_addr;\n  in_addr.s_addr = ipaddr;\n  lua_pushstring(L, inet_ntoa(in_addr));\n}\n\nu32t\nluaL_checkx_ipaddr(lua_State *L, int narg) {\n  struct in_addr in_addr;\n  const char *s = luaL_checkstring(L, narg);\n  if(0 == inet_aton(s, &in_addr)) {\n    luaL_error(L, \"Expected IP Address as arg %d, got: '%s'\", narg, s);\n  }\n  return in_addr.s_addr;\n}\n*/\n", "func_signal": "void *luaL_checkuserdata(lua_State *L, int n)", "code": "{\n  if(lua_isuserdata(L, n)) {\n    return lua_touserdata(L, n);\n  } else {\n    luaL_error(L, \"parameter %d should be a dbuf \", n);\n    return NULL;\n  }\n}", "path": "fmv_src\\lua_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/**\n * Obtain a backtrace and print it to stdout. \n * Borrowed from http://www.gnu.org/software/libtool/manual/libc/Backtraces.html \n */\n", "func_signal": "void\nprint_backtrace_t(int debugtype, int debuglevel, backtrace_t * bt)", "code": "{\n  char **strings;\n  size_t i;\n\n  strings = backtrace_symbols(bt->addresses, bt->size);\n  debug(debugtype, debuglevel, \"backtrace of %zd stack frames.\", bt->size);\n  for(i = 0; i < bt->size; i++)\n    debug(debugtype, debuglevel, \"%d: %s\", i, strings[i]);\n  free(strings);\n}", "path": "supp_src\\lib_debug.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* return right data (without popping it out) */\n", "func_signal": "void *\nrpeek(listitem_t ** li)", "code": "{\n  if(li == NULL || *li == NULL) {\n    return NULL;\n  }\n  assert((*li)->prev != NULL);  /* if (*li) is not null the ->prev must be also valid. */\n  listitem_checksig(*li);\n  return (*li)->prev->data;\n}", "path": "supp_src\\lib_lists.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* return length of data only, not advancing in case val is NULL */\n", "func_signal": "int UDP_Variable1(u8t *val, int maxlen, u8t* data, int *i, int datasz)", "code": "{\n    int length = (int) data[*i];\n    int copylength = length;\n    if (val != NULL) {\n      if (copylength > maxlen - 1) {\n        copylength = maxlen - 1;\n      }\n      *i+=1;\n      memcpy(val, &data[*i], copylength);\n      *i+=length;\n      val[copylength]='\\0'; /* make this a C string */\n    }\n    return length;\n}", "path": "fmv_src\\sta_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* Variable values are passed always as (ptr, length) pair */\n", "func_signal": "int Variable1_UDP(const u8t *val, int length, u8t* data, int *i, int datasz)", "code": "{\n    if(*i + length + 1 >= datasz) {\n      return -1;\n    }\n    if (length >= 0 && length <= 255) {\n      data[*i] = (u8t) length;\n      *i+=1;\n      memcpy(&data[*i], val, length);\n      *i+=length;\n    } else {\n      assert(0 == \"Length of the Variable1 is illegal\");\n    }\n    return 0;\n}", "path": "fmv_src\\sta_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* return the length, and make the value also a C string, just in case */\n", "func_signal": "int UDP_Variable2(u8t *val, int maxlen, u8t* data, int *i, int datasz)", "code": "{\n    int length = (int) (data[*i + 0] + data[*i + 1] * 256);\n    int copylength = length;\n    if(val != NULL) {\n      if (copylength > maxlen - 1) {\n        copylength = maxlen - 1;\n      }\n      *i+=2;\n      memcpy(val, &data[*i], copylength);\n      *i+=length;\n      val[copylength]='\\0'; /* make this a C string */\n    }\n    return length;\n}", "path": "fmv_src\\sta_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/**\n * Routine to print the debug messages with timestamp.\n *\n * @param type the type of the debug\n * @param level and the level of the debug message (0=always shown)\n * @param fmt printf-style format string, followed by additional parameter\n *\n * @return the number of characters printed from the debug message\n * @see debug_dump\n */\n", "func_signal": "int\ndebug(int type, int level, const char *fmt, ...)", "code": "{\n  va_list ap;\n  int result = 0;\n  //struct tm *tm;\n  struct timeval tv;\n  char date_buf[256];\n\n  if(is_debug_on(type, level)) {\n\n    gettimeofday(&tv, NULL);\n    asctime_r(localtime(&tv.tv_sec), date_buf);\n    date_buf[strlen(date_buf) - 6] = 0;\n\n\n    fprintf(stderr, \"%s.%06d LOG-%04d-%04d: \", date_buf, (int) tv.tv_usec,\n            type, level);\n    va_start(ap, fmt);\n    result = vfprintf(stderr, fmt, ap);\n    /* CONSOLEXXX\n\n    if(need_console_debugs()) {\n      console_printf(\"\\n%s.%06d LOG-%04d-%04d: \", date_buf, (int) tv.tv_usec,\n                     type, level);\n      console_vprintf(fmt, ap);\n      console_putstr(\"\\n\");\n    }\n    */\n    va_end(ap);\n    fprintf(stderr, \"\\n\");\n  }\n  return result;\n}", "path": "supp_src\\lib_debug.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* return left data (without popping it out) */\n", "func_signal": "void *\nlpeek(listitem_t ** li)", "code": "{\n  if(li == NULL || *li == NULL) {\n    return NULL;\n  }\n  listitem_checksig(*li);\n  return (*li)->data;\n}", "path": "supp_src\\lib_lists.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/**\n * Simplistic error check function for fatal errors - checks \n * the supplied value to be nonzero. \n * If it is negative, print the supplied message, \n * current string for errno,and die.\n *\n * @param x the value to test to be nonnegative\n * @param msg the error message to print\n */\n", "func_signal": "void\nnotminus(int x, char *msg)", "code": "{\n  if(x < 0) {\n    debug(DBG_GLOBAL, 0, \"ERROR: %s, system error: %s\", msg, strerror(errno));\n    exit(1);\n  }\n}", "path": "supp_src\\lib_debug.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* \n * Short helper function which should allow to \n * avoid boundary checks in the getter below.\n * The edges of the heightmap are simply assumed to be stretching \n * into infinity - for now.\n * Later if there's ever \"direct neighbourships\" - \n * this could go and poke into the neighbouring heightmap as well.\n */\n", "func_signal": "static float H(int x, int y)", "code": "{\n  if (x < 0) { x = 0; } if (x > 255) { x = 255; }\n  if (y < 0) { y = 0; } if (y > 255) { y = 255; }\n  return my_height_map[y*256 + x];\n}", "path": "pktsmv_src\\pktsmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/*\n * A fancy insertion function.\n *\n * It takes the key+key length, the data pointer,\n * and a callback pointer to a function which \n * dictates whether the replacement in the hash\n * for a given key is OK or not, and also \n * can output some diagnostic information if needed.\n *\n * The return of this function is the data value \n * that got \"purged\" - obviously, in case of no collision \n * it is NULL, and in case of inability to insert, it might be\n * the original data pointer!\n *\n * So, the success of the function is when the return is != data\n */\n", "func_signal": "void *\nhinsert(htable_t *ht, void *key, int key_len, void *data, hcallback_func_t *destructor, \n                      hcallback_func_t *can_replace, hcallback_func_t *do_delete, int *did_delete)", "code": "{\n  uint32_t index;\n  hash_entry_t *hen;\n  hash_entry_t *hen_old;\n  void *data_old = NULL;\n\n  null_if_null(ht);\n  \n  index = h_index(ht, key, key_len);\n  hen = h_entry(ht, index, key, key_len);\n\n  hen_old = hen;\n  data_old = hen ? hen->data : NULL;\n\n  if (did_delete) { *did_delete = 0; }\n\n  if(can_replace != NULL && !can_replace(key, key_len, data_old, data)) {\n    return data;\n  }\n  if (NULL == (hen = h_alloc_hen(key_len))) {\n    return data;\n  }\n  if (hen_old) {\n    /*\n     * entry already exists - we are about to replace it.\n     *\n     * If not for the iterators, we'd be all fine and dandy.\n     *\n     * But there can be iterators referencing this item\n     * (hence, can't wipe out key/data).\n     */\n    h_try_delete(ht, hen_old, do_delete, did_delete);\n  } else {\n    if (did_delete) { *did_delete = 0; }\n  }\n\n  /* \n   * fill in the new hen\n   */\n\n  memcpy(hen->key, key, key_len);\n  hen->data = data;\n  hen->destructor = destructor;\n  LIST_INSERT_HEAD(&ht->buckets[index], hen, entries);\n  // inserting in the head of all entries ensures we don't have\n  // to mess with the iterators\n  LIST_INSERT_HEAD(&ht->all_entries, hen, all_entries);\n  // successfully inserted \n  return data_old;\n}", "path": "supp_src\\lib_hash.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* push an item onto list from right side (tail) */\n", "func_signal": "listitem_t *\nrpush(listitem_t ** li, void *data)", "code": "{\n  listitem_t *li2;\n\n  if(li == NULL) {\n    return NULL;\n  }\n  li2 = malloc(sizeof(listitem_t));\n  if(li2 == NULL) {\n    return NULL;\n  }\n  li2->listitem_sig = LISTITEM_SIG;\n\n\n  if(*li == NULL) {\n    li2->next = NULL;\n    li2->prev = li2;            /* point to self - since this is the first and only one */\n    li2->data = data;\n    *li = li2;\n  } else {\n    /*\n       this is not the first element, so we add from the right (tail) \n     */\n    assert((*li)->prev->next == NULL);  /* this has to be the last element */\n    listitem_checksig(*li);\n    listitem_checksig((*li)->prev);\n    (*li)->prev->next = li2;\n    li2->prev = (*li)->prev;\n    (*li)->prev = li2;\n    li2->next = NULL;\n    li2->data = data;\n  }\n  return li2;\n}", "path": "supp_src\\lib_lists.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/* pop an item from the list from the left side: nb: this frees up the element,\n * so it is the responsibility of those receiving the pointer to free it up!\n */\n", "func_signal": "void *\nlpop(listitem_t ** li)", "code": "{\n  listitem_t *li2;\n  void *ret;\n\n  if(li == NULL || *li == NULL) {\n    return NULL;\n  }\n\n  listitem_checksig(*li);\n  li2 = (*li);\n  ret = li2->data;\n  (*li) = li2->next;\n  if(*li) {\n    (*li)->prev = li2->prev;    /* fix the \"last element\" pointer */\n  }\n  li2->listitem_sig = 0;\n  free(li2);\n  return ret;\n}", "path": "supp_src\\lib_lists.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/*\n#define APPENDED_ACKS 0x10\n#define RESENT 0x20\n#define RELIABLE 0x40\n#define ZEROCODED 0x80\n#define Low 1\n#define Medium 2\n#define High 3\n*/\n", "func_signal": "void GetAcks(int* count, u32t* acks, int maxAcks, u8t* udpMessage, int udpMessageLength)", "code": "{\n    int i;\n    if(HasAcks(udpMessage))\n    {\n        *count = udpMessage[udpMessageLength--];\n\n        for (i = 0; i < *count && i<maxAcks; i++)\n        {\n            acks[i] = (u32t)(\n                    (udpMessage[(udpMessageLength - i * 4) - 3] << 24) |\n                    (udpMessage[(udpMessageLength - i * 4) - 2] << 16) |\n                    (udpMessage[(udpMessageLength - i * 4) - 1] <<  8) |\n                    (udpMessage[(udpMessageLength - i * 4)    ]));\n        }\n    }\n    else\n    {\n        *count=0;\n    }\n}", "path": "fmv_src\\sta_fmv.c", "repo_name": "ayourtch/cosimus", "stars": 8, "license": "other", "language": "c", "size": 13381}
{"docstring": "/*\n * Convert to string.\n *\n * This method only uses JavaScript-modifiable properties name, message.  It\n * is left to the host to check for private data and report filename and line\n * number information along with this message.\n */\n", "func_signal": "static JSBool\nexn_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval v;\n    JSString *name, *message, *result;\n    jschar *chars, *cp;\n    size_t name_length, message_length, length;\n\n    if (!OBJ_GET_PROPERTY(cx, obj,\n                          ATOM_TO_JSID(cx->runtime->atomState.nameAtom),\n                          &v)) {\n        return JS_FALSE;\n    }\n    name = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v) : cx->runtime->emptyString;\n    *rval = STRING_TO_JSVAL(name);\n\n    if (!JS_GetProperty(cx, obj, js_message_str, &v))\n        return JS_FALSE;\n    message = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v)\n                                 : cx->runtime->emptyString;\n\n    if (JSSTRING_LENGTH(message) != 0) {\n        name_length = JSSTRING_LENGTH(name);\n        message_length = JSSTRING_LENGTH(message);\n        length = (name_length ? name_length + 2 : 0) + message_length;\n        cp = chars = (jschar*) JS_malloc(cx, (length + 1) * sizeof(jschar));\n        if (!chars)\n            return JS_FALSE;\n\n        if (name_length) {\n            js_strncpy(cp, JSSTRING_CHARS(name), name_length);\n            cp += name_length;\n            *cp++ = ':'; *cp++ = ' ';\n        }\n        js_strncpy(cp, JSSTRING_CHARS(message), message_length);\n        cp += message_length;\n        *cp = 0;\n\n        result = js_NewString(cx, chars, length, 0);\n        if (!result) {\n            JS_free(cx, chars);\n            return JS_FALSE;\n        }\n    } else {\n        result = name;\n    }\n\n    *rval = STRING_TO_JSVAL(result);\n    return JS_TRUE;\n}", "path": "spidermonkey\\jsexn.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Python-esque sequence operations.\n */\n", "func_signal": "static JSBool\narray_concat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval *vp, v;\n    JSObject *nobj, *aobj;\n    jsuint length, alength, slot;\n    uintN i;\n    jsid id, id2;\n\n    /* Hoist the explicit local root address computation. */\n    vp = argv + argc;\n\n    /* Treat obj as the first argument; see ECMA 15.4.4.4. */\n    --argv;\n    JS_ASSERT(obj == JSVAL_TO_OBJECT(argv[0]));\n\n    /* Create a new Array object and store it in the rval local root. */\n    nobj = js_NewArrayObject(cx, 0, NULL);\n    if (!nobj)\n        return JS_FALSE;\n    *rval = OBJECT_TO_JSVAL(nobj);\n\n    /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */\n    length = 0;\n    for (i = 0; i <= argc; i++) {\n        v = argv[i];\n        if (JSVAL_IS_OBJECT(v)) {\n            aobj = JSVAL_TO_OBJECT(v);\n            if (aobj && OBJ_GET_CLASS(cx, aobj) == &js_ArrayClass) {\n                if (!OBJ_GET_PROPERTY(cx, aobj,\n                                      ATOM_TO_JSID(cx->runtime->atomState\n                                                   .lengthAtom),\n                                      vp)) {\n                    return JS_FALSE;\n                }\n                if (!ValueIsLength(cx, *vp, &alength))\n                    return JS_FALSE;\n                for (slot = 0; slot < alength; slot++) {\n                    if (!IndexToExistingId(cx, aobj, slot, &id))\n                        return JS_FALSE;\n                    if (id == JSID_HOLE) {\n                        /*\n                         * Per ECMA 262, 15.4.4.4, step 9, ignore non-existent\n                         * properties.\n                         */\n                        continue;\n                    }\n                    if (!OBJ_GET_PROPERTY(cx, aobj, id, vp))\n                        return JS_FALSE;\n\n                    /* Get id after value to avoid nested GC hazards. */\n                    if (!IndexToId(cx, length + slot, &id2))\n                        return JS_FALSE;\n                    if (!OBJ_SET_PROPERTY(cx, nobj, id2, vp))\n                        return JS_FALSE;\n                }\n                length += alength;\n                continue;\n            }\n        }\n\n        *vp = v;\n        if (!IndexToId(cx, length, &id))\n            return JS_FALSE;\n        if (!OBJ_SET_PROPERTY(cx, nobj, id, vp))\n            return JS_FALSE;\n        length++;\n    }\n\n    return js_SetLengthProperty(cx, nobj, length);\n}", "path": "spidermonkey\\jsarray.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/**\n * Convert between a C string and the XDR representation:\n * leading 32-bit count, then counted vector of chars,\n * then possibly \\0 padding to multiple of 4.\n */\n", "func_signal": "JS_PUBLIC_API(JSBool)\nJS_XDRCString(JSXDRState *xdr, char **sp)", "code": "{\n    uint32 len;\n\n    if (xdr->mode == JSXDR_ENCODE)\n        len = strlen(*sp);\n    JS_XDRUint32(xdr, &len);\n    if (xdr->mode == JSXDR_DECODE) {\n        if (!(*sp = (char *) JS_malloc(xdr->cx, len + 1)))\n            return JS_FALSE;\n    }\n    if (!JS_XDRBytes(xdr, *sp, len)) {\n        if (xdr->mode == JSXDR_DECODE)\n            JS_free(xdr->cx, *sp);\n        return JS_FALSE;\n    }\n    if (xdr->mode == JSXDR_DECODE) {\n        (*sp)[len] = '\\0';\n    } else if (xdr->mode == JSXDR_FREE) {\n        JS_free(xdr->cx, *sp);\n        *sp = NULL;\n    }\n    return JS_TRUE;\n}", "path": "spidermonkey\\jsxdrapi.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Inline expansion of Iterator, with extra logic to constrain the result of\n * ToObject(v).__iterator__.\n */\n", "func_signal": "JSObject *\njs_ValueToIterator(JSContext *cx, jsval v, uintN flags)", "code": "{\n    JSObject *obj, *iterobj;\n    JSTempValueRooter tvr;\n    jsval arg, fval, rval;\n    JSString *str;\n    JSFunction *fun;\n    const JSAtom *atom = cx->runtime->atomState.iteratorAtom;\n\n    /* XXX work around old valueOf call hidden beneath js_ValueToObject */\n    if (!JSVAL_IS_PRIMITIVE(v)) {\n        obj = JSVAL_TO_OBJECT(v);\n    } else {\n        obj = js_ValueToNonNullObject(cx, v);\n        if (!obj)\n            return NULL;\n    }\n\n    arg = BOOLEAN_TO_JSVAL((flags & JSITER_FOREACH) == 0);\n\n    JS_PUSH_SINGLE_TEMP_ROOT(cx, obj, &tvr);\n    if (!JS_GetMethodById(cx, obj, ATOM_TO_JSID(atom), &obj, &fval))\n        goto bad;\n    if (JSVAL_IS_VOID(fval)) {\n        /* Fail over to the default native iterator, called directly. */\n        if (!js_DefaultIterator(cx, obj, 1, &arg, &rval))\n            goto bad;\n        if (JSVAL_IS_PRIMITIVE(rval))\n            goto bad_iterator;\n        iterobj = JSVAL_TO_OBJECT(rval);\n        JS_ASSERT(OBJ_GET_CLASS(cx, iterobj) == &js_IteratorClass);\n        iterobj->slots[JSSLOT_ITER_FLAGS] |= INT_TO_JSVAL(JSITER_HIDDEN);\n        goto out;\n    }\n\n    if (!js_InternalInvoke(cx, obj, fval, JSINVOKE_ITERATOR, 1, &arg, &rval))\n        goto bad;\n\n    if (JSVAL_IS_PRIMITIVE(rval))\n        goto bad_iterator;\n\n    iterobj = JSVAL_TO_OBJECT(rval);\n\n    /*\n     * If __iterator__ is the default native method, the native iterator it\n     * returns can be flagged as hidden from script access.  This flagging is\n     * predicated on js_ValueToIterator being called only by the for-in loop\n     * code -- the js_CloseNativeIteration early-finalization optimization\n     * based on it will break badly if script can reach iterobj.\n     */\n    if (OBJ_GET_CLASS(cx, iterobj) == &js_IteratorClass &&\n        VALUE_IS_FUNCTION(cx, fval)) {\n        fun = (JSFunction *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(fval));\n        if (!FUN_INTERPRETED(fun) && fun->u.n.native == js_DefaultIterator)\n            iterobj->slots[JSSLOT_ITER_FLAGS] |= INT_TO_JSVAL(JSITER_HIDDEN);\n    }\n\nout:\n    JS_POP_TEMP_ROOT(cx, &tvr);\n    return iterobj;\n\nbad:\n    iterobj = NULL;\n    goto out;\n\nbad_iterator:\n    str = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);\n    if (str) {\n        JS_ReportErrorNumberUC(cx, js_GetErrorMessage, NULL,\n                               JSMSG_BAD_ITERATOR_RETURN,\n                               JSSTRING_CHARS(str),\n                               JSSTRING_CHARS(ATOM_TO_STRING(atom)));\n    }\n    goto bad;\n}", "path": "spidermonkey\\jsiter.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Perl-inspired join, reverse, and sort.\n */\n", "func_signal": "static JSBool\narray_join(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    JSString *str;\n\n    if (JSVAL_IS_VOID(argv[0])) {\n        str = NULL;\n    } else {\n        str = js_ValueToString(cx, argv[0]);\n        if (!str)\n            return JS_FALSE;\n        argv[0] = STRING_TO_JSVAL(str);\n    }\n    return array_join_sub(cx, obj, TO_STRING, str, rval);\n}", "path": "spidermonkey\\jsarray.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Return a string that may eval to something similar to the original object.\n */\n", "func_signal": "static JSBool\nexn_toSource(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval *vp;\n    JSString *name, *message, *filename, *lineno_as_str, *result;\n    uint32 lineno;\n    size_t lineno_length, name_length, message_length, filename_length, length;\n    jschar *chars, *cp;\n\n    vp = argv + argc;   /* beginning of explicit local roots */\n\n    if (!OBJ_GET_PROPERTY(cx, obj,\n                          ATOM_TO_JSID(cx->runtime->atomState.nameAtom),\n                          rval)) {\n        return JS_FALSE;\n    }\n    name = js_ValueToString(cx, *rval);\n    if (!name)\n        return JS_FALSE;\n    *rval = STRING_TO_JSVAL(name);\n\n    if (!JS_GetProperty(cx, obj, js_message_str, &vp[0]) ||\n        !(message = js_ValueToSource(cx, vp[0]))) {\n        return JS_FALSE;\n    }\n    vp[0] = STRING_TO_JSVAL(message);\n\n    if (!JS_GetProperty(cx, obj, js_filename_str, &vp[1]) ||\n        !(filename = js_ValueToSource(cx, vp[1]))) {\n        return JS_FALSE;\n    }\n    vp[1] = STRING_TO_JSVAL(filename);\n\n    if (!JS_GetProperty(cx, obj, js_lineno_str, &vp[2]) ||\n        !js_ValueToECMAUint32 (cx, vp[2], &lineno)) {\n        return JS_FALSE;\n    }\n\n    if (lineno != 0) {\n        lineno_as_str = js_ValueToString(cx, vp[2]);\n        if (!lineno_as_str)\n            return JS_FALSE;\n        lineno_length = JSSTRING_LENGTH(lineno_as_str);\n    } else {\n        lineno_as_str = NULL;\n        lineno_length = 0;\n    }\n\n    /* Magic 8, for the characters in ``(new ())''. */\n    name_length = JSSTRING_LENGTH(name);\n    message_length = JSSTRING_LENGTH(message);\n    length = 8 + name_length + message_length;\n\n    filename_length = JSSTRING_LENGTH(filename);\n    if (filename_length != 0) {\n        /* append filename as ``, {filename}'' */\n        length += 2 + filename_length;\n        if (lineno_as_str) {\n            /* append lineno as ``, {lineno_as_str}'' */\n            length += 2 + lineno_length;\n        }\n    } else {\n        if (lineno_as_str) {\n            /*\n             * no filename, but have line number,\n             * need to append ``, \"\", {lineno_as_str}''\n             */\n            length += 6 + lineno_length;\n        }\n    }\n\n    cp = chars = (jschar*) JS_malloc(cx, (length + 1) * sizeof(jschar));\n    if (!chars)\n        return JS_FALSE;\n\n    *cp++ = '('; *cp++ = 'n'; *cp++ = 'e'; *cp++ = 'w'; *cp++ = ' ';\n    js_strncpy(cp, JSSTRING_CHARS(name), name_length);\n    cp += name_length;\n    *cp++ = '(';\n    if (message_length != 0) {\n        js_strncpy(cp, JSSTRING_CHARS(message), message_length);\n        cp += message_length;\n    }\n\n    if (filename_length != 0) {\n        /* append filename as ``, {filename}'' */\n        *cp++ = ','; *cp++ = ' ';\n        js_strncpy(cp, JSSTRING_CHARS(filename), filename_length);\n        cp += filename_length;\n    } else {\n        if (lineno_as_str) {\n            /*\n             * no filename, but have line number,\n             * need to append ``, \"\", {lineno_as_str}''\n             */\n            *cp++ = ','; *cp++ = ' '; *cp++ = '\"'; *cp++ = '\"';\n        }\n    }\n    if (lineno_as_str) {\n        /* append lineno as ``, {lineno_as_str}'' */\n        *cp++ = ','; *cp++ = ' ';\n        js_strncpy(cp, JSSTRING_CHARS(lineno_as_str), lineno_length);\n        cp += lineno_length;\n    }\n\n    *cp++ = ')'; *cp++ = ')'; *cp = 0;\n\n    result = js_NewString(cx, chars, length, 0);\n    if (!result) {\n        JS_free(cx, chars);\n        return JS_FALSE;\n    }\n    *rval = STRING_TO_JSVAL(result);\n    return JS_TRUE;\n}", "path": "spidermonkey\\jsexn.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Shared code to close iterator's state either through an explicit call or\n * when GC detects that the iterator is no longer reachable.\n */\n", "func_signal": "void\njs_CloseIteratorState(JSContext *cx, JSObject *iterobj)", "code": "{\n    jsval *slots;\n    jsval state, parent;\n    JSObject *iterable;\n\n    JS_ASSERT(JS_InstanceOf(cx, iterobj, &js_IteratorClass, NULL));\n    slots = iterobj->slots;\n\n    /* Avoid double work if js_CloseNativeIterator was called on obj. */\n    state = slots[JSSLOT_ITER_STATE];\n    if (JSVAL_IS_NULL(state))\n        return;\n\n    /* Protect against failure to fully initialize obj. */\n    parent = slots[JSSLOT_PARENT];\n    if (!JSVAL_IS_PRIMITIVE(parent)) {\n        iterable = JSVAL_TO_OBJECT(parent);\n#if JS_HAS_XML_SUPPORT\n        if ((JSVAL_TO_INT(slots[JSSLOT_ITER_FLAGS]) & JSITER_FOREACH) &&\n            OBJECT_IS_XML(cx, iterable)) {\n            ((JSXMLObjectOps *) iterable->map->ops)->\n                enumerateValues(cx, iterable, JSENUMERATE_DESTROY, &state,\n                                NULL, NULL);\n        } else\n#endif\n            OBJ_ENUMERATE(cx, iterable, JSENUMERATE_DESTROY, &state, NULL);\n    }\n    slots[JSSLOT_ITER_STATE] = JSVAL_NULL;\n}", "path": "spidermonkey\\jsiter.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * When op is TO_STRING or TO_LOCALE_STRING sep indicates a separator to use\n * or \",\" when sep is NULL.\n * When op is TO_SOURCE sep must be NULL.\n */\n", "func_signal": "static JSBool\narray_join_sub(JSContext *cx, JSObject *obj, enum ArrayToStringOp op,\n               JSString *sep, jsval *rval)", "code": "{\n    JSBool ok;\n    jsuint length, index;\n    jschar *chars, *ochars;\n    size_t nchars, growth, seplen, tmplen, extratail;\n    const jschar *sepstr;\n    jsid id;\n    JSString *str;\n    JSHashEntry *he;\n    JSObject *obj2;\n    int stackDummy;\n\n    if (!JS_CHECK_STACK_SIZE(cx, stackDummy)) {\n        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_OVER_RECURSED);\n        return JS_FALSE;\n    }\n\n    ok = js_GetLengthProperty(cx, obj, &length);\n    if (!ok)\n        return JS_FALSE;\n\n    he = js_EnterSharpObject(cx, obj, NULL, &chars);\n    if (!he)\n        return JS_FALSE;\n#ifdef DEBUG\n    growth = (size_t) -1;\n#endif\n\n    if (op == TO_SOURCE) {\n        if (IS_SHARP(he)) {\n#if JS_HAS_SHARP_VARS\n            nchars = js_strlen(chars);\n#else\n            chars[0] = '[';\n            chars[1] = ']';\n            chars[2] = 0;\n            nchars = 2;\n#endif\n            goto make_string;\n        }\n\n        /*\n         * Always allocate 2 extra chars for closing ']' and terminating 0\n         * and then preallocate 1 + extratail to include starting '['.\n         */\n        extratail = 2;\n        growth = (1 + extratail) * sizeof(jschar);\n        if (!chars) {\n            nchars = 0;\n            chars = (jschar *) malloc(growth);\n            if (!chars)\n                goto done;\n        } else {\n            MAKE_SHARP(he);\n            nchars = js_strlen(chars);\n            growth += nchars * sizeof(jschar);\n            chars = (jschar *)realloc((ochars = chars), growth);\n            if (!chars) {\n                free(ochars);\n                goto done;\n            }\n        }\n        chars[nchars++] = '[';\n        JS_ASSERT(sep == NULL);\n        sepstr = NULL;  /* indicates to use \", \" as separator */\n        seplen = 2;\n    } else {\n        /*\n         * Free any sharp variable definition in chars.  Normally, we would\n         * MAKE_SHARP(he) so that only the first sharp variable annotation is\n         * a definition, and all the rest are references, but in the current\n         * case of (op != TO_SOURCE), we don't need chars at all.\n         */\n        if (chars)\n            JS_free(cx, chars);\n        chars = NULL;\n        nchars = 0;\n        extratail = 1;  /* allocate extra char for terminating 0 */\n\n        /* Return the empty string on a cycle as well as on empty join. */\n        if (IS_BUSY(he) || length == 0) {\n            js_LeaveSharpObject(cx, NULL);\n            *rval = JS_GetEmptyStringValue(cx);\n            return ok;\n        }\n\n        /* Flag he as BUSY so we can distinguish a cycle from a join-point. */\n        MAKE_BUSY(he);\n\n        if (sep) {\n            sepstr = JSSTRING_CHARS(sep);\n            seplen = JSSTRING_LENGTH(sep);\n        } else {\n            sepstr = NULL;      /* indicates to use \",\" as separator */\n            seplen = 1;\n        }\n    }\n\n    /* Use rval to locally root each element value as we loop and convert. */\n#define v (*rval)\n\n    for (index = 0; index < length; index++) {\n        if (op != TO_SOURCE) {\n            ok = JS_GetElement(cx, obj, index, &v);\n        } else {\n            ok = IndexToExistingId(cx, obj, index, &id);\n            if (!ok)\n                goto done;\n            if (id == JSID_HOLE) {\n                str = cx->runtime->emptyString;\n                /* For tail holes always append single \",\" and not \", \". */\n                if (index + 1 == length)\n                    seplen = 1;\n                goto got_str;\n            }\n            ok = OBJ_GET_PROPERTY(cx, obj, id, &v);\n        }\n\n        if (!ok)\n            goto done;\n\n        if (op != TO_SOURCE && (JSVAL_IS_VOID(v) || JSVAL_IS_NULL(v))) {\n            str = cx->runtime->emptyString;\n        } else {\n            if (op == TO_LOCALE_STRING) {\n                if (!js_ValueToObject(cx, v, &obj2) ||\n                    !js_TryMethod(cx, obj2,\n                                  cx->runtime->atomState.toLocaleStringAtom,\n                                  0, NULL, &v)) {\n                    str = NULL;\n                } else {\n                    str = js_ValueToString(cx, v);\n                }\n            } else if (op == TO_STRING) {\n                str = js_ValueToString(cx, v);\n            } else {\n                JS_ASSERT(op == TO_SOURCE);\n                str = js_ValueToSource(cx, v);\n            }\n            if (!str) {\n                ok = JS_FALSE;\n                goto done;\n            }\n        }\n\n        /* Do not append separator after the last element. */\n        if (index + 1 == length)\n            seplen = 0;\n\n      got_str:\n        /* Allocate 1 at end for closing bracket and zero. */\n        tmplen = JSSTRING_LENGTH(str);\n        growth = nchars + tmplen + seplen + extratail;\n        if (nchars > growth || tmplen > growth ||\n            growth > (size_t)-1 / sizeof(jschar)) {\n            if (chars) {\n                free(chars);\n                chars = NULL;\n            }\n            goto done;\n        }\n        growth *= sizeof(jschar);\n        if (!chars) {\n            chars = (jschar *) malloc(growth);\n            if (!chars)\n                goto done;\n        } else {\n            chars = (jschar *) realloc((ochars = chars), growth);\n            if (!chars) {\n                free(ochars);\n                goto done;\n            }\n        }\n\n        js_strncpy(&chars[nchars], JSSTRING_CHARS(str), tmplen);\n        nchars += tmplen;\n\n        if (seplen) {\n            if (sepstr) {\n                js_strncpy(&chars[nchars], sepstr, seplen);\n            } else {\n                JS_ASSERT(seplen == 1 || seplen == 2);\n                chars[nchars] = ',';\n                if (seplen == 2)\n                    chars[nchars + 1] = ' ';\n            }\n            nchars += seplen;\n        }\n    }\n\n  done:\n    if (op == TO_SOURCE) {\n        if (chars)\n            chars[nchars++] = ']';\n    } else {\n        CLEAR_BUSY(he);\n    }\n    js_LeaveSharpObject(cx, NULL);\n    if (!ok) {\n        if (chars)\n            free(chars);\n        return ok;\n    }\n\n#undef v\n\n  make_string:\n    if (!chars) {\n        JS_ReportOutOfMemory(cx);\n        return JS_FALSE;\n    }\n    chars[nchars] = 0;\n    JS_ASSERT(growth == (size_t)-1 || (nchars + 1) * sizeof(jschar) == growth);\n    str = js_NewString(cx, chars, nchars, 0);\n    if (!str) {\n        free(chars);\n        return JS_FALSE;\n    }\n    *rval = STRING_TO_JSVAL(str);\n    return JS_TRUE;\n}", "path": "spidermonkey\\jsarray.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Undo all the damage done by exn_newPrivate.\n */\n", "func_signal": "static void\nexn_destroyPrivate(JSContext *cx, JSExnPrivate *privateData)", "code": "{\n    JSErrorReport *report;\n    const jschar **args;\n\n    if (!privateData)\n        return;\n    report = privateData->errorReport;\n    if (report) {\n        if (report->uclinebuf)\n            JS_free(cx, (void *)report->uclinebuf);\n        if (report->filename)\n            JS_free(cx, (void *)report->filename);\n        if (report->ucmessage)\n            JS_free(cx, (void *)report->ucmessage);\n        if (report->messageArgs) {\n            args = report->messageArgs;\n            while (*args)\n                JS_free(cx, (void *)*args++);\n            JS_free(cx, (void *)report->messageArgs);\n        }\n        JS_free(cx, report);\n    }\n    JS_free(cx, privateData);\n}", "path": "spidermonkey\\jsexn.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Convert between a JS (Unicode) string and the XDR representation.\n */\n", "func_signal": "JS_PUBLIC_API(JSBool)\nJS_XDRString(JSXDRState *xdr, JSString **strp)", "code": "{\n    uint32 nchars;\n    jschar *chars;\n\n    if (xdr->mode == JSXDR_ENCODE)\n        nchars = JSSTRING_LENGTH(*strp);\n    if (!JS_XDRUint32(xdr, &nchars))\n        return JS_FALSE;\n\n    if (xdr->mode == JSXDR_DECODE) {\n        chars = (jschar *) JS_malloc(xdr->cx, (nchars + 1) * sizeof(jschar));\n        if (!chars)\n            return JS_FALSE;\n    } else {\n        chars = JSSTRING_CHARS(*strp);\n    }\n\n    if (!XDRChars(xdr, chars, nchars))\n        goto bad;\n    if (xdr->mode == JSXDR_DECODE) {\n        chars[nchars] = 0;\n        *strp = JS_NewUCString(xdr->cx, chars, nchars);\n        if (!*strp)\n            goto bad;\n    }\n    return JS_TRUE;\n\nbad:\n    if (xdr->mode == JSXDR_DECODE)\n        JS_free(xdr->cx, chars);\n    return JS_FALSE;\n}", "path": "spidermonkey\\jsxdrapi.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n** Compute the log of the least power of 2 greater than or equal to n\n*/\n", "func_signal": "JS_PUBLIC_API(JSIntn) JS_CeilingLog2(JSUint32 n)", "code": "{\n    JSIntn log2;\n\n    JS_CEILING_LOG2(log2, n);\n    return log2;\n}", "path": "spidermonkey\\jslog2.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "// TODO: generate from header files.\n", "func_signal": "JSObject* makeCGSize (JSContext* cx, const CGSize* p)", "code": "{\n\tJSObject* obj = JS_NewObject(cx, NULL, NULL, NULL);\n\tSET_NUMBER_PROP(cx, obj, p, width);\n\tSET_NUMBER_PROP(cx, obj, p, height);\n\treturn obj;\n}", "path": "Classes\\converters.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Determine if the id represents an array index or an XML property index.\n *\n * An id is an array index according to ECMA by (15.4):\n *\n * \"Array objects give special treatment to a certain class of property names.\n * A property name P (in the form of a string value) is an array index if and\n * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n * to 2^32-1.\"\n *\n * In our implementation, it would be sufficient to check for JSVAL_IS_INT(id)\n * except that by using signed 32-bit integers we miss the top half of the\n * valid range. This function checks the string representation itself; note\n * that calling a standard conversion routine might allow strings such as\n * \"08\" or \"4.0\" as array indices, which they are not.\n */\n", "func_signal": "JSBool\njs_IdIsIndex(jsval id, jsuint *indexp)", "code": "{\n    JSString *str;\n    jschar *cp;\n\n    if (JSVAL_IS_INT(id)) {\n        jsint i;\n        i = JSVAL_TO_INT(id);\n        if (i < 0)\n            return JS_FALSE;\n        *indexp = (jsuint)i;\n        return JS_TRUE;\n    }\n\n    /* NB: id should be a string, but jsxml.c may call us with an object id. */\n    if (!JSVAL_IS_STRING(id))\n        return JS_FALSE;\n\n    str = JSVAL_TO_STRING(id);\n    cp = JSSTRING_CHARS(str);\n    if (JS7_ISDEC(*cp) && JSSTRING_LENGTH(str) < sizeof(MAXSTR)) {\n        jsuint index = JS7_UNDEC(*cp++);\n        jsuint oldIndex = 0;\n        jsuint c = 0;\n        if (index != 0) {\n            while (JS7_ISDEC(*cp)) {\n                oldIndex = index;\n                c = JS7_UNDEC(*cp);\n                index = 10*index + c;\n                cp++;\n            }\n        }\n\n        /* Ensure that all characters were consumed and we didn't overflow. */\n        if (*cp == 0 &&\n             (oldIndex < (MAXINDEX / 10) ||\n              (oldIndex == (MAXINDEX / 10) && c < (MAXINDEX % 10))))\n        {\n            *indexp = index;\n            return JS_TRUE;\n        }\n    }\n    return JS_FALSE;\n}", "path": "spidermonkey\\jsarray.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Perl-inspired push, pop, shift, unshift, and splice methods.\n */\n", "func_signal": "static JSBool\narray_push(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsuint length;\n    uintN i;\n    jsid id;\n\n    if (!js_GetLengthProperty(cx, obj, &length))\n        return JS_FALSE;\n    for (i = 0; i < argc; i++) {\n        if (!IndexToId(cx, length + i, &id))\n            return JS_FALSE;\n        if (!OBJ_SET_PROPERTY(cx, obj, id, &argv[i]))\n            return JS_FALSE;\n    }\n\n    /* Per ECMA-262, return the new array length. */\n    length += argc;\n    if (!IndexToValue(cx, length, rval))\n        return JS_FALSE;\n    return js_SetLengthProperty(cx, obj, length);\n}", "path": "spidermonkey\\jsarray.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n** Compute the log of the greatest power of 2 less than or equal to n.\n** This really just finds the highest set bit in the word.\n*/\n", "func_signal": "JS_PUBLIC_API(JSIntn) JS_FloorLog2(JSUint32 n)", "code": "{\n    JSIntn log2;\n\n    JS_FLOOR_LOG2(log2, n);\n    return log2;\n}", "path": "spidermonkey\\jslog2.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/* JS_HAS_GENERATORS */\n", "func_signal": "JSBool\njs_NewNativeIterator(JSContext *cx, JSObject *obj, uintN flags, jsval *vp)", "code": "{\n    JSObject *iterobj;\n    jsval state;\n    JSBool ok;\n\n    /*\n     * Create iterobj with a NULL parent to ensure that we use the correct\n     * scope chain to lookup the iterator's constructor. Since we use the\n     * parent slot to keep track of the iterable, we must fix it up later.\n     */\n    iterobj = js_NewObject(cx, &js_IteratorClass, NULL, NULL);\n    if (!iterobj)\n        return JS_FALSE;\n\n    /* Store iterobj in *vp to protect it from GC (callers must root vp). */\n    *vp = OBJECT_TO_JSVAL(iterobj);\n\n    /* Initialize iterobj in case of enumerate hook failure. */\n    iterobj->slots[JSSLOT_PARENT] = OBJECT_TO_JSVAL(obj);\n    iterobj->slots[JSSLOT_ITER_STATE] = JSVAL_NULL;\n    iterobj->slots[JSSLOT_ITER_FLAGS] = INT_TO_JSVAL(flags);\n    if (!js_RegisterCloseableIterator(cx, iterobj))\n        return JS_FALSE;\n\n    ok =\n#if JS_HAS_XML_SUPPORT\n         ((flags & JSITER_FOREACH) && OBJECT_IS_XML(cx, obj))\n         ? ((JSXMLObjectOps *) obj->map->ops)->\n               enumerateValues(cx, obj, JSENUMERATE_INIT, &state, NULL, NULL)\n         :\n#endif\n           OBJ_ENUMERATE(cx, obj, JSENUMERATE_INIT, &state, NULL);\n    if (!ok)\n        return JS_FALSE;\n\n    iterobj->slots[JSSLOT_ITER_STATE] = state;\n    return JS_TRUE;\n}", "path": "spidermonkey\\jsiter.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/*\n * Copy everything interesting about an error into allocated memory.\n */\n", "func_signal": "static JSExnPrivate *\nexn_newPrivate(JSContext *cx, JSErrorReport *report)", "code": "{\n    intN i;\n    JSExnPrivate *newPrivate;\n    JSErrorReport *newReport;\n    size_t capacity;\n\n    newPrivate = (JSExnPrivate *)JS_malloc(cx, sizeof (JSExnPrivate));\n    if (!newPrivate)\n        return NULL;\n    memset(newPrivate, 0, sizeof (JSExnPrivate));\n\n    /* Copy the error report */\n    newReport = (JSErrorReport *)JS_malloc(cx, sizeof (JSErrorReport));\n    if (!newReport)\n        goto error;\n    memset(newReport, 0, sizeof (JSErrorReport));\n    newPrivate->errorReport = newReport;\n\n    if (report->filename) {\n        newReport->filename = JS_strdup(cx, report->filename);\n        if (!newReport->filename)\n            goto error;\n    } else {\n        newReport->filename = NULL;\n    }\n\n    newReport->lineno = report->lineno;\n\n    /*\n     * We don't need to copy linebuf and tokenptr, because they\n     * point into the deflated string cache.  (currently?)\n     */\n    newReport->linebuf = report->linebuf;\n    newReport->tokenptr = report->tokenptr;\n\n    /*\n     * But we do need to copy uclinebuf, uctokenptr, because they're\n     * pointers into internal tokenstream structs, and may go away.\n     */\n    if (report->uclinebuf) {\n        capacity = js_strlen(report->uclinebuf) + 1;\n        newReport->uclinebuf =\n            (const jschar *)JS_malloc(cx, capacity * sizeof(jschar));\n        if (!newReport->uclinebuf)\n            goto error;\n        js_strncpy((jschar *)newReport->uclinebuf, report->uclinebuf, capacity);\n        newReport->uctokenptr = newReport->uclinebuf + (report->uctokenptr -\n                                                        report->uclinebuf);\n    } else {\n        newReport->uclinebuf = newReport->uctokenptr = NULL;\n    }\n\n    if (report->ucmessage) {\n        capacity = js_strlen(report->ucmessage) + 1;\n        newReport->ucmessage = (const jschar *)\n            JS_malloc(cx, capacity * sizeof(jschar));\n        if (!newReport->ucmessage)\n            goto error;\n        js_strncpy((jschar *)newReport->ucmessage, report->ucmessage, capacity);\n\n        if (report->messageArgs) {\n            for (i = 0; report->messageArgs[i]; i++)\n                continue;\n            JS_ASSERT(i);\n            newReport->messageArgs =\n                (const jschar **)JS_malloc(cx, (i + 1) * sizeof(jschar *));\n            if (!newReport->messageArgs)\n                goto error;\n            for (i = 0; report->messageArgs[i]; i++) {\n                capacity = js_strlen(report->messageArgs[i]) + 1;\n                newReport->messageArgs[i] =\n                    (const jschar *)JS_malloc(cx, capacity * sizeof(jschar));\n                if (!newReport->messageArgs[i])\n                    goto error;\n                js_strncpy((jschar *)(newReport->messageArgs[i]),\n                           report->messageArgs[i], capacity);\n            }\n            newReport->messageArgs[i] = NULL;\n        } else {\n            newReport->messageArgs = NULL;\n        }\n    } else {\n        newReport->ucmessage = NULL;\n        newReport->messageArgs = NULL;\n    }\n    newReport->errorNumber = report->errorNumber;\n\n    /* Note that this is before it gets flagged with JSREPORT_EXCEPTION */\n    newReport->flags = report->flags;\n\n    return newPrivate;\nerror:\n    exn_destroyPrivate(cx, newPrivate);\n    return NULL;\n}", "path": "spidermonkey\\jsexn.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/************************************************************************/\n", "func_signal": "static ptrdiff_t\nGetJumpOffset(jsbytecode *pc, jsbytecode *pc2)", "code": "{\n    uint32 type;\n\n    type = (js_CodeSpec[*pc].format & JOF_TYPEMASK);\n    if (JOF_TYPE_IS_EXTENDED_JUMP(type))\n        return GET_JUMPX_OFFSET(pc2);\n    return GET_JUMP_OFFSET(pc2);\n}", "path": "spidermonkey\\jsopcode.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/* JS_HAS_GENERATORS */\n", "func_signal": "JSObject *\njs_InitIteratorClasses(JSContext *cx, JSObject *obj)", "code": "{\n    JSObject *proto, *stop;\n\n    /* Idempotency required: we initialize several things, possibly lazily. */\n    if (!js_GetClassObject(cx, obj, JSProto_StopIteration, &stop))\n        return NULL;\n    if (stop)\n        return stop;\n\n#if JS_HAS_GENERATORS\n    /* Expose Iterator and initialize the generator internals if configured. */\n    proto = JS_InitClass(cx, obj, NULL, &js_IteratorClass, Iterator, 2,\n                         NULL, iterator_methods, NULL, NULL);\n    if (!proto)\n        return NULL;\n    proto->slots[JSSLOT_ITER_STATE] = JSVAL_NULL;\n\n    if (!JS_InitClass(cx, obj, NULL, &js_GeneratorClass.base, NULL, 0,\n                      NULL, generator_methods, NULL, NULL)) {\n        return NULL;\n    }\n#endif\n\n    /*\n     * Always initialize StopIteration, it's used by for-in loop interpreter\n     * code even if iterators and generators are deconfigured.\n     */\n    if (!js_GetClassPrototype(cx, NULL, INT_TO_JSID(JSProto_Error), &proto))\n        return NULL;\n\n#if JS_HAS_GENERATORS\n    if (!JS_InitClass(cx, obj, proto, &js_GeneratorExitClass, NULL, 0,\n                      exception_props, NULL, NULL, NULL)) {\n        return NULL;\n    }\n#endif\n\n    return JS_InitClass(cx, obj, proto, &js_StopIterationClass, NULL, 0,\n                        exception_props, NULL, NULL, NULL);\n}", "path": "spidermonkey\\jsiter.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/* DEBUG */\n", "func_signal": "JSBool\njs_ErrorToException(JSContext *cx, const char *message, JSErrorReport *reportp)", "code": "{\n    JSErrNum errorNumber;\n    JSExnType exn;\n    JSBool ok;\n    JSObject *errProto, *errObject;\n    JSString *messageStr, *filenameStr;\n    uintN lineno;\n    JSExnPrivate *privateData;\n    const JSErrorFormatString *errorString;\n\n    /*\n     * Tell our caller to report immediately if cx has no active frames, or if\n     * this report is just a warning.\n     */\n    JS_ASSERT(reportp);\n    if (!cx->fp || JSREPORT_IS_WARNING(reportp->flags))\n        return JS_FALSE;\n\n    /* Find the exception index associated with this error. */\n    errorNumber = (JSErrNum) reportp->errorNumber;\n    errorString = js_GetLocalizedErrorMessage(cx, NULL, NULL, errorNumber);\n    exn = errorString ? errorString->exnType : JSEXN_NONE;\n    JS_ASSERT(exn < JSEXN_LIMIT);\n\n#if defined( DEBUG_mccabe ) && defined ( PRINTNAMES )\n    /* Print the error name and the associated exception name to stderr */\n    fprintf(stderr, \"%s\\t%s\\n\",\n            errortoexnname[errorNumber].name,\n            errortoexnname[errorNumber].exception);\n#endif\n\n    /*\n     * Return false (no exception raised) if no exception is associated\n     * with the given error number.\n     */\n    if (exn == JSEXN_NONE)\n        return JS_FALSE;\n\n    /*\n     * Prevent runaway recursion, just as the Exception native constructor\n     * must do, via cx->creatingException.  If an out-of-memory error occurs,\n     * no exception object will be created, but we don't assume that OOM is\n     * the only kind of error that subroutines of this function called below\n     * might raise.\n     */\n    if (cx->creatingException)\n        return JS_FALSE;\n    cx->creatingException = JS_TRUE;\n\n    /* Protect the newly-created strings below from nesting GCs. */\n    ok = js_EnterLocalRootScope(cx);\n    if (!ok)\n        goto out;\n\n    /*\n     * Try to get an appropriate prototype by looking up the corresponding\n     * exception constructor name in the scope chain of the current context's\n     * top stack frame, or in the global object if no frame is active.\n     */\n    ok = js_GetClassPrototype(cx, NULL, INT_TO_JSID(exceptions[exn].key),\n                              &errProto);\n    if (!ok)\n        goto out;\n\n    errObject = js_NewObject(cx, &js_ErrorClass, errProto, NULL);\n    if (!errObject) {\n        ok = JS_FALSE;\n        goto out;\n    }\n\n    /*\n     * Set the generated Exception object early, so it won't be GC'd by a last\n     * ditch attempt to collect garbage, or a GC that otherwise nests or races\n     * under any of the following calls.  If one of the following calls fails,\n     * it will overwrite this exception object with one of its own (except in\n     * case of OOM errors, of course).\n     */\n    JS_SetPendingException(cx, OBJECT_TO_JSVAL(errObject));\n\n    messageStr = JS_NewStringCopyZ(cx, message);\n    if (!messageStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n\n    filenameStr = JS_NewStringCopyZ(cx, reportp->filename);\n    if (!filenameStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    lineno = reportp->lineno;\n\n    ok = InitExceptionObject(cx, errObject, messageStr, filenameStr, lineno);\n    if (!ok)\n        goto out;\n\n    /*\n     * Construct a new copy of the error report struct, and store it in the\n     * exception object's private data.  We can't use the error report struct\n     * that was passed in, because it's stack-allocated, and also because it\n     * may point to transient data in the JSTokenStream.\n     */\n    privateData = exn_newPrivate(cx, reportp);\n    if (!privateData) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    OBJ_SET_SLOT(cx, errObject, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(privateData));\n\n    /* Flag the error report passed in to indicate an exception was raised. */\n    reportp->flags |= JSREPORT_EXCEPTION;\n\nout:\n    js_LeaveLocalRootScope(cx);\n    cx->creatingException = JS_FALSE;\n    return ok;\n}", "path": "spidermonkey\\jsexn.c", "repo_name": "ku/uimonkey", "stars": 9, "license": "None", "language": "c", "size": 989}
{"docstring": "/* initialize pwr928 encoding table */\n", "func_signal": "void init928(void)", "code": "{\n\tint i, j, v;\n\tint cw[7];\n\tcw[6] = 1L;\n\tfor (i = 5; i >= 0; i--)\n\t\tcw[i] = 0;\n\t\n\tfor (i = 0; i < 7; i++)\n\t\tpwr928[0][i] = cw[i];\n\tfor (j = 1; j < 69; j++) {\n\t\tfor (v = 0, i = 6; i >= 1; i--) {\n\t\t\tv = (2 * cw[i]) + (v / 928);\n\t\t\tpwr928[j][i] = cw[i] = v % 928;\n\t\t}\n\t\tpwr928[j][0] = cw[0] = (2 * cw[0]) + (v / 928);\n\t}\n\treturn;\n}", "path": "backend\\composite.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/**********************************************************************\n* getRSSwidths\n* routine to generate widths for RSS elements for a given value.#\n*\n* Calling arguments:\n* val = required value\n* n = number of modules\n* elements = elements in a set (RSS-14 & Expanded = 4; RSS Limited = 7)\n* maxWidth = maximum module width of an element\n* noNarrow = 0 will skip patterns without a one module wide element\n*\n* Return:\n* static int widths[] = element widths\n**********************************************************************/\n", "func_signal": "void getRSSwidths(int val, int n, int elements, int maxWidth, int noNarrow)", "code": "{\n\tint bar;\n\tint elmWidth;\n\tint mxwElement;\n\tint subVal, lessVal;\n\tint narrowMask = 0;\n\tfor (bar = 0; bar < elements-1; bar++)\n\t{\n\t\tfor(elmWidth = 1, narrowMask |= (1<<bar);\n\t\t\t\t  ;\n\t\t\t\t  elmWidth++, narrowMask &= ~(1<<bar))\n\t\t{\n\t\t\t/* get all combinations */\n\t\t\tsubVal = combins(n-elmWidth-1, elements-bar-2);\n\t\t\t/* less combinations with no single-module element */\n\t\t\tif ((!noNarrow) && (!narrowMask) &&\n\t\t\t\t\t\t   (n-elmWidth-(elements-bar-1) >= elements-bar-1))\n\t\t\t{\n\t\t\t\tsubVal -= combins(n-elmWidth-(elements-bar), elements-bar-2);\n\t\t\t}\n\t\t\t/* less combinations with elements > maxVal */\n\t\t\tif (elements-bar-1 > 1)\n\t\t\t{\n\t\t\t\tlessVal = 0;\n\t\t\t\tfor (mxwElement = n-elmWidth-(elements-bar-2);\n\t\t\t\t\t\t\t\t mxwElement > maxWidth;\n\t\t\t\t\t\t\t\t mxwElement--)\n\t\t\t\t{\n\t\t\t\t\tlessVal += combins(n-elmWidth-mxwElement-1, elements-bar-3);\n\t\t\t\t}\n\t\t\t\tsubVal -= lessVal * (elements-1-bar);\n\t\t\t}\n\t\t\telse if (n-elmWidth > maxWidth)\n\t\t\t{\n\t\t\t\tsubVal--;\n\t\t\t}\n\t\t\tval -= subVal;\n\t\t\tif (val < 0) break;\n\t\t}\n\t\tval += subVal;\n\t\tn -= elmWidth;\n\t\twidths[bar] = elmWidth;\n\t}\n\twidths[bar] = n;\n\treturn;\n}", "path": "backend\\rss.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* NOTE: From this point forward concerns Micro QR Code only */\n", "func_signal": "int micro_qr_intermediate(char binary[], int jisdata[], char mode[], int length, int *kanji_used, int *alphanum_used, int *byte_used)", "code": "{\n\t/* Convert input data to an \"intermediate stage\" where data is binary encoded but\n\t   control information is not */\n\tint position = 0, debug = 0;\n\tint short_data_block_length, i;\n\tchar data_block;\n\tchar buffer[2];\n\t\n\tstrcpy(binary, \"\");\n\t\n\tif(debug) { \n\t\tfor(i = 0; i < length; i++) {\n\t\t\tprintf(\"%c\", mode[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\n\tdo {\n\t\tif(strlen(binary) > 128) {\n\t\t\treturn ERROR_TOO_LONG;\n\t\t}\n\t\t\n\t\tdata_block = mode[position];\n\t\tshort_data_block_length = 0;\n\t\tdo {\n\t\t\tshort_data_block_length++;\n\t\t} while (((short_data_block_length + position) < length) && (mode[position + short_data_block_length] == data_block));\n\t\t\n\t\tswitch(data_block) {\n\t\t\tcase 'K':\n\t\t\t\t/* Kanji mode */\n\t\t\t\t/* Mode indicator */\n\t\t\t\tconcat(binary, \"K\");\n\t\t\t\t*kanji_used = 1;\n\t\t\t\t\n\t\t\t\t/* Character count indicator */\n\t\t\t\tbuffer[0] = short_data_block_length;\n\t\t\t\tbuffer[1] = '\\0';\n\t\t\t\tconcat(binary, buffer);\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"Kanji block (length %d)\\n\\t\", short_data_block_length); }\n\t\t\t\t\n\t\t\t\t/* Character representation */\n\t\t\t\tfor(i = 0; i < short_data_block_length; i++) {\n\t\t\t\t\tint jis = jisdata[position + i];\n\t\t\t\t\tint msb, lsb, prod;\n\t\t\t\t\t\n\t\t\t\t\tif(jis > 0x9fff) { jis -= 0xc140; }\n\t\t\t\t\tmsb = (jis & 0xff00) >> 4;\n\t\t\t\t\tlsb = (jis & 0xff);\n\t\t\t\t\tprod = (msb * 0xc0) + lsb;\n\t\t\t\t\n\t\t\t\t\tqr_bscan(binary, prod, 0x1000);\n\t\t\t\t\t\n\t\t\t\t\tif(debug) { printf(\"0x%4X \", prod); }\n\t\t\t\t\t\n\t\t\t\t\tif(strlen(binary) > 128) {\n\t\t\t\t\t\treturn ERROR_TOO_LONG;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"\\n\"); }\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\t/* Byte mode */\n\t\t\t\t/* Mode indicator */\n\t\t\t\tconcat(binary, \"B\");\n\t\t\t\t*byte_used = 1;\n\t\t\t\t\n\t\t\t\t/* Character count indicator */\n\t\t\t\tbuffer[0] = short_data_block_length;\n\t\t\t\tbuffer[1] = '\\0';\n\t\t\t\tconcat(binary, buffer);\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"Byte block (length %d)\\n\\t\", short_data_block_length); }\n\t\t\t\t\n\t\t\t\t/* Character representation */\n\t\t\t\tfor(i = 0; i < short_data_block_length; i++) {\n\t\t\t\t\tint byte = jisdata[position + i];\n\t\t\t\t\t\n\t\t\t\t\tqr_bscan(binary, byte, 0x80);\n\t\t\t\t\t\n\t\t\t\t\tif(debug) { printf(\"0x%4X \", byte); }\n\t\t\t\t\t\n\t\t\t\t\tif(strlen(binary) > 128) {\n\t\t\t\t\t\treturn ERROR_TOO_LONG;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"\\n\"); }\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\t/* Alphanumeric mode */\n\t\t\t\t/* Mode indicator */\n\t\t\t\tconcat(binary, \"A\");\n\t\t\t\t*alphanum_used = 1;\n\t\t\t\t\n\t\t\t\t/* Character count indicator */\n\t\t\t\tbuffer[0] = short_data_block_length;\n\t\t\t\tbuffer[1] = '\\0';\n\t\t\t\tconcat(binary, buffer);\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"Alpha block (length %d)\\n\\t\", short_data_block_length); }\n\t\t\t\t\n\t\t\t\t/* Character representation */\n\t\t\t\ti = 0; \n\t\t\t\twhile ( i < short_data_block_length ) {\n\t\t\t\t\tint count;\n\t\t\t\t\tint first = 0, second = 0, prod;\n\t\t\t\t\t\n\t\t\t\t\tfirst = posn(RHODIUM, (char) jisdata[position + i]);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tprod = first;\n\t\t\t\t\t\n\t\t\t\t\tif(mode[position + i + 1] == 'A') {\n\t\t\t\t\t\tsecond = posn(RHODIUM, (char) jisdata[position + i + 1]);\n\t\t\t\t\t\tcount = 2;\n\t\t\t\t\t\tprod = (first * 45) + second;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tqr_bscan(binary, prod, 1 << (5 * count)); /* count = 1..2 */\n\t\t\t\t\t\n\t\t\t\t\tif(debug) { printf(\"0x%4X \", prod); }\n\t\t\t\t\t\n\t\t\t\t\tif(strlen(binary) > 128) {\n\t\t\t\t\t\treturn ERROR_TOO_LONG;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ti += 2;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"\\n\"); }\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t/* Numeric mode */\n\t\t\t\t/* Mode indicator */\n\t\t\t\tconcat(binary, \"N\");\n\t\t\t\t\n\t\t\t\t/* Character count indicator */\n\t\t\t\tbuffer[0] = short_data_block_length;\n\t\t\t\tbuffer[1] = '\\0';\n\t\t\t\tconcat(binary, buffer);\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"Number block (length %d)\\n\\t\", short_data_block_length); }\n\t\t\t\t\n\t\t\t\t/* Character representation */\n\t\t\t\ti = 0; \n\t\t\t\twhile ( i < short_data_block_length ) {\n\t\t\t\t\tint count;\n\t\t\t\t\tint first = 0, second = 0, third = 0, prod;\n\t\t\t\t\t\n\t\t\t\t\tfirst = posn(NEON, (char) jisdata[position + i]);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tprod = first;\n\t\t\t\t\t\n\t\t\t\t\tif(mode[position + i + 1] == 'N') {\n\t\t\t\t\t\tsecond = posn(NEON, (char) jisdata[position + i + 1]);\n\t\t\t\t\t\tcount = 2;\n\t\t\t\t\t\tprod = (prod * 10) + second;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(mode[position + i + 2] == 'N') {\n\t\t\t\t\t\tthird = posn(NEON, (char) jisdata[position + i + 2]);\n\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\tprod = (prod * 10) + third;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tqr_bscan(binary, prod, 1 << (3 * count)); /* count = 1..3 */\n\t\t\t\t\t\n\t\t\t\t\tif(debug) { printf(\"0x%4X (%d)\", prod, prod); }\n\t\t\t\t\t\n\t\t\t\t\tif(strlen(binary) > 128) {\n\t\t\t\t\t\treturn ERROR_TOO_LONG;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ti += 3;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif(debug) { printf(\"\\n\"); }\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tposition += short_data_block_length;\n\t} while (position < length - 1) ;\n\t\n\treturn 0;\n}", "path": "backend\\qr.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 671 */\n", "func_signal": "void byteprocess(int *chainemc, int *mclength, unsigned char chaine[], int start, int length, int block)", "code": "{\n\tint\t\tdebug\t  = 0;\n\tint\t\tlen       = 0;\n\tunsigned int\tchunkLen  = 0;\n\tuint64_t\tmantisa   = 0ULL;\n\tuint64_t\ttotal     = 0ULL;\n\t\n\tif(debug) printf(\"\\nEntering byte mode at position %d\\n\", start);\n\n\tif(length == 1) {\n\t\tchainemc[(*mclength)++] = 913;\n\t\tchainemc[(*mclength)++] = chaine[start];\n\t\tif(debug) { printf(\"913 %d\\n\", chainemc[*mclength - 1]); }\n\t} else {\n\t\t/* select the switch for multiple of 6 bytes */\n\t\tif (length % 6 == 0) {\n\t\t\tchainemc[(*mclength)++] = 924;\n\t\t\tif(debug) printf(\"924 \");\n\t\t} else {\n\t\t\tchainemc[(*mclength)++] = 901;\n\t\t\tif(debug) printf(\"901 \");\n\t\t}\n\t\t\n\t\twhile (len < length)\n\t\t{\n\t\t\tchunkLen = length - len;\n\t\t\tif (6 <= chunkLen)  /* Take groups of 6 */\n\t\t\t{\n\t\t\t\tchunkLen\t= 6;\n\t\t\t\tlen\t\t+= chunkLen;\n\t\t\t\ttotal\t\t= 0ULL;\n\n\t\t\t\twhile (chunkLen--)\n\t\t\t\t{\n\t\t\t\t\tmantisa = chaine[start++];\n\t\t\t\t\ttotal   |= mantisa << (uint64_t)(chunkLen * 8ULL);\n\t\t\t\t}\n\n\t\t\t\tchunkLen = 5;\n\n\t\t\t\twhile (chunkLen--)\n\t\t\t\t{\n\t\t\t\t\tchainemc[*mclength + chunkLen] = (int)(total % 900ULL);\n\t\t\t\t\ttotal /= 900ULL;\n\t\t\t\t}\n\t\t\t\t*mclength += 5;\n\t\t\t}\n\t\t\telse\t/*  If it remain a group of less than 6 bytes   */\n\t\t\t{\n\t\t\t\tlen += chunkLen;\n\t\t\t\twhile (chunkLen--)\n\t\t\t\t{\n\t\t\t\t\tchainemc[(*mclength)++] = chaine[start++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* ******************** CODE 93 ******************* */\n", "func_signal": "int c93(struct zint_symbol *symbol, unsigned char source[], int length)", "code": "{ /* Code 93 is an advancement on Code 39 and the definition is a lot tighter */\n\n  /* SILVER includes the extra characters a, b, c and d to represent Code 93 specific\n     shift characters 1, 2, 3 and 4 respectively. These characters are never used by\n     c39() and ec39() */\n\n\tint i;\n\tint h, weight, c, k, values[128], error_number;\n\tchar buffer[220];\n\tchar dest[670];\n\tchar set_copy[] = SILVER;\n\t\n\terror_number = 0;\n    strcpy(buffer, \"\");\n\t\n\tif(length > 107) {\n\t\tstrcpy(symbol->errtxt, \"Input too long\");\n\t\treturn ERROR_TOO_LONG;\n\t}\n\t\n\t/* Message Content */\n\tfor (i = 0; i < length; i++) {\n\t\tif (source[i] > 127) {\n\t\t\t/* Cannot encode extended ASCII */\n\t\t\tstrcpy(symbol->errtxt, \"Invalid characters in input data\");\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t\tconcat(buffer, C93Ctrl[source[i]]);\n\t\tsymbol->text[i] = source[i] ? source[i] : ' ';\n\t}\n\t\n\t/* Now we can check the true length of the barcode */\n\th = strlen(buffer);\n\tif (h > 107) {\n\t\tstrcpy(symbol->errtxt, \"Input too long\");\n\t\treturn ERROR_TOO_LONG;\n\t}\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tvalues[i] = posn(SILVER, buffer[i]);\n\t}\n\n\t/* Putting the data into dest[] is not done until after check digits are calculated */\n\n\t/* Check digit C */\n\tc = 0;\n\tweight = 1;\n\tfor (i = h - 1; i >= 0; i--) {\n\t\tc += values[i] * weight;\n\t\tweight++;\n\t\tif (weight == 21)\n\t\t\tweight = 1;\n\t}\n\tc = c % 47;\n\tvalues[h] = c;\n\tbuffer[h] = set_copy[c];\n\n\t/* Check digit K */\n\tk = 0;\n\tweight = 1;\n\tfor (i = h; i >= 0; i--) {\n\t\tk += values[i] * weight;\n\t\tweight++;\n\t\tif(weight == 16)\n\t\t\tweight = 1;\n\t}\n\tk = k % 47;\n\tbuffer[++h] = set_copy[k];\n\tbuffer[++h] = '\\0';\n\n\t/* Start character */\n\tstrcpy(dest, \"111141\");\n\n\tfor(i = 0; i < h; i++) {\n\t\tlookup(SILVER, C93Table, buffer[i], dest);\n\t}\n\n\t/* Stop character */\n\tconcat(dest, \"1111411\");\n\texpand(symbol, dest);\n\n\tsymbol->text[length] = set_copy[c];\n\tsymbol->text[length + 1] = set_copy[k];\n\tsymbol->text[length + 2] = '\\0';\n\n\treturn error_number;\n}", "path": "backend\\code.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 366 */\n", "func_signal": "int pdf417(struct zint_symbol *symbol, unsigned char chaine[], int length)", "code": "{\n\tint i, k, j, indexchaine, indexliste, mode, longueur, loop, mccorrection[520], offset;\n\tint total, chainemc[2700], mclength, c1, c2, c3, dummy[35], codeerr;\n\tchar codebarre[100], pattern[580];\n\tint debug = 0;\n\n\tcodeerr = 0;\n\n\t/* 456 */\n\tindexliste = 0;\n\tindexchaine = 0;\n\t\n\tmode = quelmode(chaine[indexchaine]);\n\t\n\tfor(i = 0; i < 1000; i++) {\n\t\tliste[0][i] = 0;\n\t}\n\t\n\t/* 463 */\n\tdo {\n\t\tliste[1][indexliste] = mode;\n\t\twhile ((liste[1][indexliste] == mode) && (indexchaine < length)) {\n\t\t\tliste[0][indexliste]++;\n\t\t\tindexchaine++;\n\t\t\tmode = quelmode(chaine[indexchaine]);\n\t\t}\n\t\tindexliste++;\n\t} while (indexchaine < length);\n\t\n\t/* 474 */\n\tpdfsmooth(&indexliste);\n\n\tif(debug) {\n\t\tprintf(\"Initial block pattern:\\n\");\n\t\tfor(i = 0; i < indexliste; i++) {\n\t\t\tprintf(\"Len: %d  Type: \", liste[0][i]);\n\t\t\tswitch(liste[1][i]) {\n\t\t\t\tcase TEX: printf(\"Text\\n\"); break;\n\t\t\t\tcase BYT: printf(\"Byte\\n\"); break;\n\t\t\t\tcase NUM: printf(\"Number\\n\"); break;\n\t\t\t\tdefault: printf(\"ERROR\\n\"); break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* 541 - now compress the data */\n\tindexchaine = 0;\n\tmclength = 0;\n\tif(symbol->output_options & READER_INIT) {\n\t\tchainemc[mclength] = 921; /* Reader Initialisation */\n\t\tmclength++;\n\t}\n\tfor(i = 0; i < indexliste; i++) {\n\t\tswitch(liste[1][i]) {\n\t\t\tcase TEX: /* 547 - text mode */\n\t\t\t\ttextprocess(chainemc, &mclength, (char*)chaine, indexchaine, liste[0][i], i);\n\t\t\t\tbreak;\n\t\t\tcase BYT: /* 670 - octet stream mode */\n\t\t\t\tbyteprocess(chainemc, &mclength, chaine, indexchaine, liste[0][i], i);\n\t\t\t\tbreak;\n\t\t\tcase NUM: /* 712 - numeric mode */\n\t\t\t\tnumbprocess(chainemc, &mclength, (char*)chaine, indexchaine, liste[0][i], i);\n\t\t\t\tbreak;\n\t\t}\n\t\tindexchaine = indexchaine + liste[0][i];\n\t}\n\n\tif(debug) {\n\t\tprintf(\"\\nCompressed data stream:\\n\");\n\t\tfor(i = 0; i < mclength; i++) {\n\t\t\tprintf(\"%d \", chainemc[i]);\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t}\n\n\t/* 752 - Now take care of the number of CWs per row */\n\tif (symbol->option_1 < 0) {\n\t\t/* note that security level 8 is never used automatically */\n\t\tsymbol->option_1 = 7;\n\t\tif(mclength <= 1280) { symbol->option_1 = 6; }\n\t\tif(mclength <= 640) { symbol->option_1 = 5; }\n\t\tif(mclength <= 320) { symbol->option_1 = 4; }\n\t\tif(mclength <= 160) { symbol->option_1 = 3; }\n\t\tif(mclength <= 40) { symbol->option_1 = 2; }\n\t}\n\tk = 1;\n\tfor(loop = 1; loop <= (symbol->option_1 + 1); loop++)\n\t{\n\t\tk *= 2;\n\t}\n\tlongueur = mclength;\n\tif(symbol->option_2 > 30) { symbol->option_2 = 30; }\n\tif(symbol->option_2 < 1) {\n\t\t/* This is a much more simple formula to Grand Zebu's - \n\t\t   it does not try to make the symbol square */\n\t\tsymbol->option_2 = 0.5 + sqrt((longueur + k) / 3.0);\n\t}\n\tif(((longueur + k) / symbol->option_2) > 90) {\n\t\t/* stop the symbol from becoming too high */\n\t\tsymbol->option_2 = symbol->option_2 + 1;\n\t}\n\n\t/* Reduce the correction level if there isn't room */\n\t/* while((longueur + k > PDF_MAX) && (symbol->option_1 > 0)) {\n\t\tsymbol->option_1 = symbol->option_1 - 1\n\t\tfor(loop = 0; loop <= (symbol->option_1 + 1); loop++)\n\t\t{\n\t\t\tk *= 2;\n\t\t}\n\t} */\n\t/* this bit of the code would allow Zint to happily encode 2698 code words with\n\tonly 2 check digits, so I have abandoned it! - Zint now insists on a proportional\n\tamount of check data unless overruled by the user */\n\t\n\tif(longueur + k > symbol->option_3) {\n\t\treturn 2;\n\t}\n\tif(((longueur + k) / symbol->option_2) > 90) {\n\t\treturn 4;\n\t}\n\t\n\t/* 781 - Padding calculation */\n\tlongueur = mclength + 1 + k;\n\ti = 0;\n\tif ((longueur / symbol->option_2) < 3) {\n\t\ti = (symbol->option_2 * 3) - longueur; /* A bar code must have at least three rows */\n\t} else {\n\t\tif((longueur % symbol->option_2) > 0) { i = symbol->option_2 - (longueur % symbol->option_2); }\n\t}\n\t/* We add the padding */\n\twhile (i > 0) {\n\t\tchainemc[mclength] = 900;\n\t\tmclength++;\n\t\ti--;\n\t}\n\t/* we add the length descriptor */\n\tfor(i = mclength; i > 0; i--) {\n\t\tchainemc[i] = chainemc[i - 1];\n\t}\n\tchainemc[0] = mclength + 1;\n\tmclength++;\n\n\t/* 796 - we now take care of the Reed Solomon codes */\n\tswitch(symbol->option_1) {\n\t\tcase 1: offset = 2; break;\n\t\tcase 2: offset = 6; break;\n\t\tcase 3: offset = 14; break;\n\t\tcase 4: offset = 30; break;\n\t\tcase 5: offset = 62; break;\n\t\tcase 6: offset = 126; break;\n\t\tcase 7: offset = 254; break;\n\t\tcase 8: offset = 510; break;\n\t\tdefault: offset = 0; break;\n\t}\n\n\tlongueur = mclength;\n\tfor(loop = 0; loop < 520; loop++) {\n\t\tmccorrection[loop] = 0;\n\t}\n\ttotal = 0;\n\tfor(i = 0; i < longueur; i++) {\n\t\ttotal = (chainemc[i] + mccorrection[k - 1]) % 929;\n\t\tfor(j = k - 1; j > 0; j--) {\n\t\t\tmccorrection[j] = (mccorrection[j - 1] + 929 - (total * coefrs[offset + j]) % 929) % 929;\n\t\t}\n\t\tmccorrection[0] = (929 - (total * coefrs[offset + j]) % 929) % 929;\n\t}\n\t\n\t/* we add these codes to the string */\n\tfor(i = k - 1; i >= 0; i--) {\n\t\tchainemc[mclength++] = mccorrection[i] ? 929 - mccorrection[i] : 0;\n\t}\n\t\n\t/* 818 - The CW string is finished */\n\tc1 = (mclength / symbol->option_2 - 1) / 3;\n\tc2 = symbol->option_1 * 3 + (mclength / symbol->option_2 - 1) % 3;\n\tc3 = symbol->option_2 - 1;\n\t\n\t/* we now encode each row */\n\tfor(i = 0; i <= (mclength / symbol->option_2) - 1; i++) {\n\t\tfor(j = 0; j < symbol->option_2 ; j++) {\n\t\t\tdummy[j + 1] = chainemc[i * symbol->option_2 + j];\n\t\t}\n\t\tk = (i / 3) * 30;\n\t\tswitch(i % 3) {\n\t\t\t\t/* follows this pattern from US Patent 5,243,655: \n\t\t\tRow 0: L0 (row #, # of rows)         R0 (row #, # of columns)\n\t\t\tRow 1: L1 (row #, security level)    R1 (row #, # of rows)\n\t\t\tRow 2: L2 (row #, # of columns)      R2 (row #, security level)\n\t\t\tRow 3: L3 (row #, # of rows)         R3 (row #, # of columns)\n\t\t\t\tetc. */\n\t\t\tcase 0:\n\t\t\t\tdummy[0] = k + c1;\n\t\t\t\tdummy[symbol->option_2 + 1] = k + c3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdummy[0] = k + c2;\n\t\t\t\tdummy[symbol->option_2 + 1] = k + c1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdummy[0] = k + c3;\n\t\t\t\tdummy[symbol->option_2 + 1] = k + c2;\n\t\t\t\tbreak;\n\t\t}\n\t\tstrcpy(codebarre, \"+*\"); /* Start with a start char and a separator */\n\t\tif(symbol->symbology == BARCODE_PDF417TRUNC) {\n\t\t\t/* truncated - so same as before except knock off the last 5 chars */\n\t\t\tfor(j = 0; j <= symbol->option_2;  j++) {\n\t\t\t\tswitch(i % 3) {\n\t\t\t\t\tcase 1: offset = 929; break;\n\t\t\t\t\tcase 2: offset = 1858; break;\n\t\t\t\t\tdefault: offset = 0; break;\n\t\t\t\t}\n\t\t\t\tconcat(codebarre, codagemc[offset + dummy[j]]);\n\t\t\t\tconcat(codebarre, \"*\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* normal PDF417 symbol */\n\t\t\tfor(j = 0; j <= symbol->option_2 + 1;  j++) {\n\t\t\t\tswitch(i % 3) {\n\t\t\t\t\tcase 1: offset = 929; /* cluster(3) */ break;\n\t\t\t\t\tcase 2: offset = 1858; /* cluster(6) */ break;\n\t\t\t\t\tdefault: offset = 0; /* cluster(0) */ break;\n\t\t\t\t}\n\t\t\t\tconcat(codebarre, codagemc[offset + dummy[j]]);\n\t\t\t\tconcat(codebarre, \"*\");\n\t\t\t}\n\t\t\tconcat(codebarre, \"-\");\n\t\t}\n\t\t\n\t\tstrcpy(pattern, \"\");\n\t\tfor(loop = 0; loop < strlen(codebarre); loop++) {\n\t\t\tlookup(BRSET, PDFttf, codebarre[loop], pattern);\n\t\t}\n\t\tfor(loop = 0; loop < strlen(pattern); loop++) {\n\t\t\tif(pattern[loop] == '1') { set_module(symbol, i, loop); }\n\t\t}\n\t\tif(symbol->height == 0) {\n\t\t\tsymbol->row_height[i] = 3;\n\t\t}\n\t}\n\tsymbol->rows = (mclength / symbol->option_2);\n\tsymbol->width = strlen(pattern);\n\t\n\t/* 843 */\n\treturn codeerr;\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* NextS() and NextB() are from ANSI/AIM BC12-1998 and are Copyright (c) AIM 1997 */\n/* Their are used here on the understanding that they form part of the specification\n   for Channel Code and therefore their use is permitted under the following terms\n   set out in that document:\n   \n   \"It is the intent and understanding of AIM [t]hat the symbology presented in this\n   specification is entirely in the public domain and free of all use restrictions,\n   licenses and fees. AIM USA, its memer companies, or individual officers\n   assume no liability for the use of this document.\" */\n", "func_signal": "void CheckCharacter()", "code": "{\n\tint i;\n\tchar part[3];\n\t\n\tif(value == target_value) {\n\t\t/* Target reached - save the generated pattern */\n\t\tstrcpy(pattern, \"11110\");\n\t\tfor(i = 0; i < 11; i++) {\n\t\t\tpart[0] = itoc(S[i]);\n\t\t\tpart[1] = itoc(B[i]);\n\t\t\tpart[2] = '\\0';\n\t\t\tconcat(pattern, part);\n\t\t}\n\t}\n}", "path": "backend\\code.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "// rs_init_gf(poly) initialises the parameters for the Galois Field.\n// The symbol size is determined from the highest bit set in poly\n// This implementation will support sizes up to 30 bits (though that\n// will result in very large log/antilog tables) - bit sizes of\n// 8 or 4 are typical\n//\n// The poly is the bit pattern representing the GF characteristic\n// polynomial.  e.g. for ECC200 (8-bit symbols) the polynomial is\n// a**8 + a**5 + a**3 + a**2 + 1, which translates to 0x12d.\n", "func_signal": "void rs_init_gf(int poly)", "code": "{\n\tint m, b, p, v;\n\n\t// Find the top bit, and hence the symbol size\n\tfor (b = 1, m = 0; b <= poly; b <<= 1)\n\t\tm++;\n\tb >>= 1;\n\tm--;\n\tgfpoly = poly;\n\tsymsize = m;\n\n\t// Calculate the log/alog tables\n\tlogmod = (1 << m) - 1;\n\tlogt = (int *)malloc(sizeof(int) * (logmod + 1));\n\talog = (int *)malloc(sizeof(int) * logmod);\n\n\tfor (p = 1, v = 0; v < logmod; v++) {\n\t\talog[v] = p;\n\t\tlogt[p] = v;\n\t\tp <<= 1;\n\t\tif (p & b)\n\t\t\tp ^= poly;\n\t}\n}", "path": "backend\\reedsol.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "// rs_init_code(nsym, index) initialises the Reed-Solomon encoder\n// nsym is the number of symbols to be generated (to be appended\n// to the input data).  index is usually 1 - it is the index of\n// the constant in the first term (i) of the RS generator polynomial:\n// (x + 2**i)*(x + 2**(i+1))*...   [nsym terms]\n// For ECC200, index is 1.\n", "func_signal": "void rs_init_code(int nsym, int index)", "code": "{\n\tint i, k;\n\n\trspoly = (int *)malloc(sizeof(int) * (nsym + 1));\n\n\trlen = nsym;\n\n\trspoly[0] = 1;\n\tfor (i = 1; i <= nsym; i++) {\n\t\trspoly[i] = 1;\n\t\tfor (k = i - 1; k > 0; k--) {\n\t\t\tif (rspoly[k])\n\t\t\t\trspoly[k] = alog[(logt[rspoly[k]] + index) % logmod];\n\t\t\trspoly[k] ^= rspoly[k - 1];\n\t\t}\n\t\trspoly[0] = alog[(logt[rspoly[0]] + index) % logmod];\n\t\tindex++;\n\t}\n}", "path": "backend\\reedsol.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* ************** EXTENDED CODE 39 *************** */\n", "func_signal": "int ec39(struct zint_symbol *symbol, unsigned char source[], int length)", "code": "{ /* Extended Code 39 - ISO/IEC 16388:2007 Annex A */\n\n\tunsigned char buffer[150] = { 0 };\n\tunsigned int i;\n\tint error_number;\n\n\terror_number = 0;\n\n\tif(length > 74) {\n\t\tstrcpy(symbol->errtxt, \"Input too long\");\n\t\treturn ERROR_TOO_LONG;\n\t}\n\t\n\t/* Creates a buffer string and places control characters into it */\n\tfor(i = 0; i < length; i++) {\n\t\tif(source[i] > 127) {\n\t\t\t/* Cannot encode extended ASCII */\n\t\t\tstrcpy(symbol->errtxt, \"Invalid characters in input data\");\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t\tconcat((char*)buffer, EC39Ctrl[source[i]]);\t\t\n\t}\n\n\t/* Then sends the buffer to the C39 function */\n\terror_number = c39(symbol, buffer, ustrlen(buffer));\n\t\n\tfor(i = 0; i < length; i++)\n\t\tsymbol->text[i] = source[i] ? source[i] : ' ';\n\tsymbol->text[length] = '\\0';\n\n\treturn error_number;\n}", "path": "backend\\code.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* converts bit string to base 928 values, codeWords[0] is highest order */\n", "func_signal": "int encode928(UINT bitString[], UINT codeWords[], int bitLng)", "code": "{\n\tint i, j, b, bitCnt, cwNdx, cwCnt, cwLng;\n\tfor (cwNdx = cwLng = b = 0; b < bitLng; b += 69, cwNdx += 7) {\n\t\tbitCnt = _min(bitLng-b, 69);\n\t\tcwLng += cwCnt = bitCnt/10 + 1;\n\t\tfor (i = 0; i < cwCnt; i++)\n\t\t\tcodeWords[cwNdx+i] = 0; /* init 0 */\n\t\tfor (i = 0; i < bitCnt; i++) {\n\t\t\tif (getBit(bitString, b+bitCnt-i-1)) {\n\t\t\t\tfor (j = 0; j < cwCnt; j++)\n\t\t\t\t\tcodeWords[cwNdx+j] += pwr928[i][j+7-cwCnt];\n\t\t\t}\n\t\t}\n\t\tfor (i = cwCnt-1; i > 0; i--) {\n\t\t\t/* add \"carries\" */\n\t\t\tcodeWords[cwNdx+i-1] += codeWords[cwNdx+i]/928L;\n\t\t\tcodeWords[cwNdx+i] %= 928L;\n\t\t}\n\t}\n\treturn (cwLng);\n}", "path": "backend\\composite.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 844 */\n", "func_signal": "void regroupe(int *indexliste)", "code": "{\n\tint i, j;\n\t\n\t/* bring together same type blocks */\n\tif(*(indexliste) > 1) {\n\t\ti = 1;\n\t\twhile(i < *(indexliste)) {\n\t\t\tif(liste[1][i - 1] == liste[1][i]) {\n\t\t\t\t/* bring together */\n\t\t\t\tliste[0][i - 1] = liste[0][i - 1] + liste[0][i];\n\t\t\t\tj = i + 1;\n\t\t\t\t\n\t\t\t\t/* decreace the list */\n\t\t\t\twhile(j < *(indexliste)) {\n\t\t\t\t\tliste[0][j - 1] = liste[0][j];\n\t\t\t\t\tliste[1][j - 1] = liste[1][j];\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t*(indexliste) = *(indexliste) - 1;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\t/* 865 */\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* ************************ EAN-13 ****************** */\n", "func_signal": "char ean_check(char source[])", "code": "{ /* Calculate the correct check digit for a EAN-13 barcode */\n\tint i;\n\tunsigned int h, count, check_digit;\n\n\tcount = 0;\n\n\th = strlen(source);\n\tfor (i = h - 1; i >= 0; i--) {\n\t\tcount += ctoi(source[i]);\n\n\t\tif (i & 1) {\n\t\t\tcount += 2 * ctoi(source[i]);\n\t\t}\n\t}\n\tcheck_digit = 10 - (count%10);\n\tif (check_digit == 10) { check_digit = 0; }\n\treturn itoc(check_digit);\n}", "path": "backend\\upcean.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 712 */\n", "func_signal": "void numbprocess(int *chainemc, int *mclength, char chaine[], int start, int length, int block)", "code": "{\n\tint j, loop, longueur, dummy[100], dumlength, diviseur, nombre;\n\tchar chainemod[50], chainemult[100], temp;\n\t\n\tstrcpy(chainemod, \"\");\n\tfor(loop = 0; loop <= 50; loop++) {\n\t\tdummy[loop] = 0;\n\t}\n\t\n\tchainemc[*(mclength)] = 902;\n\t*(mclength) = *(mclength) + 1;\n\n\tj = 0;\n\twhile(j < length) {\n\t\tdumlength = 0;\n\t\tstrcpy(chainemod, \"\");\n\t\tlongueur = length - j;\n\t\tif(longueur > 44) { longueur = 44; }\n\t\tconcat(chainemod, \"1\");\n\t\tfor(loop = 1; loop <= longueur; loop++) {\n\t\t\tchainemod[loop] = chaine[start + loop + j - 1];\n\t\t}\n\t\tchainemod[longueur + 1] = '\\0';\n\t\tdo {\n\t\t\tdiviseur = 900;\n\t\t\t\n\t\t\t/* 877 - gosub Modulo */\n\t\t\tstrcpy(chainemult, \"\");\n\t\t\tnombre = 0;\n\t\t\twhile(strlen(chainemod) != 0) {\n\t\t\t\tnombre *= 10;\n\t\t\t\tnombre += ctoi(chainemod[0]);\n\t\t\t\tfor(loop = 0; loop < strlen(chainemod); loop++) {\n\t\t\t\t\tchainemod[loop] = chainemod[loop + 1];\n\t\t\t\t}\n\t\t\t\tif (nombre < diviseur) {\n\t\t\t\t\tif (strlen(chainemult) != 0) { concat(chainemult, \"0\"); }\n\t\t\t\t} else {\n\t\t\t\t\ttemp = (nombre / diviseur) + '0';\n\t\t\t\t\tchainemult[strlen(chainemult) + 1] = '\\0';\n\t\t\t\t\tchainemult[strlen(chainemult)] = temp;\n\t\t\t\t}\n\t\t\t\tnombre = nombre % diviseur;\n\t\t\t}\n\t\t\tdiviseur = nombre;\n\t\t\t/* return to 723 */\n\t\t\t\n\t\t\tfor(loop = dumlength; loop > 0; loop--) {\n\t\t\t\tdummy[loop] = dummy[loop - 1];\n\t\t\t}\n\t\t\tdummy[0] = diviseur;\n\t\t\tdumlength++;\n\t\t\tstrcpy(chainemod, chainemult);\n\t\t} while(strlen(chainemult) != 0);\n\t\tfor(loop = 0; loop < dumlength; loop++) {\n\t\t\tchainemc[*(mclength)] = dummy[loop];\n\t\t\t*(mclength) = *(mclength) + 1;\n\t\t}\n\t\tj += longueur;\n\t}\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 866 */\n", "func_signal": "int quelmode(char codeascii)", "code": "{\n\tint mode = BYT;\n\tif ((codeascii == '\\t') || (codeascii == '\\n') || (codeascii == '\\r') || ((codeascii >= ' ') && (codeascii <= '~'))) { mode = TEX; }\n\telse if((codeascii >= '0') && (codeascii <= '9')) { mode = NUM; }\n\t/* 876 */\n\n\treturn mode;\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 478 */\n", "func_signal": "void pdfsmooth(int *indexliste)", "code": "{\n\tint i, crnt, last, next, length;\n\t\n\tfor(i = 0; i < *(indexliste); i++) {\n\t\tcrnt = liste[1][i];\n\t\tlength = liste[0][i];\n\t\tif(i != 0) { last = liste[1][i - 1]; } else { last = FALSE; }\n\t\tif(i != *(indexliste) - 1) { next = liste[1][i + 1]; } else { next = FALSE; }\n\t\t\n\t\tif(crnt == NUM) {\n\t\t\tif(i == 0) { /* first block */\n\t\t\t\tif(*(indexliste) > 1) { /* and there are others */\n\t\t\t\t\tif((next == TEX) && (length < 8)) { liste[1][i] = TEX;}\n\t\t\t\t\tif((next == BYT) && (length == 1)) { liste[1][i] = BYT; }\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(i == *(indexliste) - 1) { /* last block */\n\t\t\t\t\tif((last == TEX) && (length < 7)) { liste[1][i] = TEX; }\n\t\t\t\t\tif((last == BYT) && (length == 1)) { liste[1][i] = BYT; }\n\t\t\t\t} else { /* not first or last block */\n\t\t\t\t\tif(((last == BYT) && (next == BYT)) && (length < 4)) { liste[1][i] = BYT; }\n\t\t\t\t\tif(((last == BYT) && (next == TEX)) && (length < 4)) { liste[1][i] = TEX; }\n\t\t\t\t\tif(((last == TEX) && (next == BYT)) && (length < 5)) { liste[1][i] = TEX; }\n\t\t\t\t\tif(((last == TEX) && (next == TEX)) && (length < 8)) { liste[1][i] = TEX; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tregroupe(indexliste);\n\t/* 520 */\n\tfor(i = 0; i < *(indexliste); i++) {\n\t\tcrnt = liste[1][i];\n\t\tlength = liste[0][i];\n\t\tif(i != 0) { last = liste[1][i - 1]; } else { last = FALSE; }\n\t\tif(i != *(indexliste) - 1) { next = liste[1][i + 1]; } else { next = FALSE; }\n\t\t\n\t\tif((crnt == TEX) && (i > 0)) { /* not the first */\n\t\t\tif(i == *(indexliste) - 1) { /* the last one */\n\t\t\t\tif((last == BYT) && (length == 1)) { liste[1][i] = BYT; }\n\t\t\t} else { /* not the last one */\n\t\t\t\tif(((last == BYT) && (next == BYT)) && (length < 5)) { liste[1][i] = BYT; }\n\t\t\t\tif((((last == BYT) && (next != BYT)) || ((last != BYT) && (next == BYT))) && (length < 3)) {\n\t\t\t\t\tliste[1][i] = BYT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* 540 */\n\tregroupe(indexliste);\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* 345 */\n", "func_signal": "int pdf417enc(struct zint_symbol *symbol, unsigned char source[], int length)", "code": "{\n\tint codeerr, error_number;\n\n\terror_number = 0;\n\t\n\tif((symbol->option_1 < -1) || (symbol->option_1 > 8)) {\n\t\tstrcpy(symbol->errtxt, \"Security value out of range\");\n\t\tsymbol->option_1 = -1;\n\t\terror_number = WARN_INVALID_OPTION;\n\t}\n\tif((symbol->option_2 < 0) || (symbol->option_2 > 30)) {\n\t\tstrcpy(symbol->errtxt, \"Number of columns out of range\");\n\t\tsymbol->option_2 = 0;\n\t\terror_number = WARN_INVALID_OPTION;\n\t}\n\n\t/* 349 */\n\tcodeerr = pdf417(symbol, source, length);\n\t\n\t/* 352 */\n\tif(codeerr != 0) {\n\t\tswitch(codeerr) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy(symbol->errtxt, \"No such file or file unreadable\");\n\t\t\t\terror_number = ERROR_INVALID_OPTION;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy(symbol->errtxt, \"Input string too long\");\n\t\t\t\terror_number = ERROR_TOO_LONG;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tstrcpy(symbol->errtxt, \"Number of codewords per row too small\");\n\t\t\t\terror_number = WARN_INVALID_OPTION;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tstrcpy(symbol->errtxt, \"Data too long for specified number of columns\");\n\t\t\t\terror_number = ERROR_TOO_LONG;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(symbol->errtxt, \"Something strange happened\");\n\t\t\t\terror_number = ERROR_ENCODING_PROBLEM;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/* 364 */\n\treturn error_number;\n}", "path": "backend\\pdf417.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* NO_PNG */\n", "func_signal": "int bmp_pixel_plot(struct zint_symbol *symbol, int image_height, int image_width, char *pixelbuf, int rotate_angle)", "code": "{\n\tunsigned long rowbytes;\n\tint i, row, column, errno;\n\tint fgred, fggrn, fgblu, bgred, bggrn, bgblu;\n\t\n\tswitch(rotate_angle) {\n\t\tcase 0:\n\t\tcase 180:\n\t\t\tsymbol->bitmap_width = image_width;\n\t\t\tsymbol->bitmap_height = image_height;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 270:\t\t\t\n\t\t\tsymbol->bitmap_width = image_height;\n\t\t\tsymbol->bitmap_height = image_width;\n\t\t\tbreak;\n\t}\n\t\n\tif (symbol->bitmap != NULL)\n\t\tfree(symbol->bitmap);\n\n    symbol->bitmap = (char *) malloc(image_width * image_height * 3);\n\n\t\n\t/* sort out colour options */\n\tto_upper((unsigned char*)symbol->fgcolour);\n\tto_upper((unsigned char*)symbol->bgcolour);\n\t\n\tif(strlen(symbol->fgcolour) != 6) {\n\t\tstrcpy(symbol->errtxt, \"Malformed foreground colour target\");\n\t\treturn ERROR_INVALID_OPTION;\n\t}\n\tif(strlen(symbol->bgcolour) != 6) {\n\t\tstrcpy(symbol->errtxt, \"Malformed background colour target\");\n\t\treturn ERROR_INVALID_OPTION;\n\t}\n\terrno = is_sane(SSET, (unsigned char*)symbol->fgcolour, strlen(symbol->fgcolour));\n\tif (errno == ERROR_INVALID_DATA) {\n\t\tstrcpy(symbol->errtxt, \"Malformed foreground colour target\");\n\t\treturn ERROR_INVALID_OPTION;\n\t}\n\terrno = is_sane(SSET, (unsigned char*)symbol->bgcolour, strlen(symbol->fgcolour));\n\tif (errno == ERROR_INVALID_DATA) {\n\t\tstrcpy(symbol->errtxt, \"Malformed background colour target\");\n\t\treturn ERROR_INVALID_OPTION;\n\t}\n\t\n\tfgred = (16 * ctoi(symbol->fgcolour[0])) + ctoi(symbol->fgcolour[1]);\n\tfggrn = (16 * ctoi(symbol->fgcolour[2])) + ctoi(symbol->fgcolour[3]);\n\tfgblu = (16 * ctoi(symbol->fgcolour[4])) + ctoi(symbol->fgcolour[5]);\n\tbgred = (16 * ctoi(symbol->bgcolour[0])) + ctoi(symbol->bgcolour[1]);\n\tbggrn = (16 * ctoi(symbol->bgcolour[2])) + ctoi(symbol->bgcolour[3]);\n\tbgblu = (16 * ctoi(symbol->bgcolour[4])) + ctoi(symbol->bgcolour[5]);\n\n\t/* set rowbytes - depends on picture depth */\n\trowbytes = symbol->bitmap_width * 3;\n\n\t/* Pixel Plotting */\n\ti = 0;\t\n\tswitch(rotate_angle) {\n\t\tcase 0: /* Plot the right way up */\n\t\t\tfor(row = 0; row < image_height; row++) {\n\t\t\t\tfor(column = 0; column < image_width; column++) {\n\t\t\t\t\tswitch(*(pixelbuf + (image_width * row) + column))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 90: /* Plot 90 degrees clockwise */\t\t\t\n\t\t\tfor(row = 0; row < image_width; row++) {\n\t\t\t\tfor(column = 0; column < image_height; column++) {\n\t\t\t\t\tswitch(*(pixelbuf + (image_width * (image_height - column - 1)) + row))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 180: /* Plot upside down */\n\t\t\tfor(row = 0; row < image_height; row++) {\n\t\t\t\tfor(column = 0; column < image_width; column++) {\n\t\t\t\t\tswitch(*(pixelbuf + (image_width * (image_height - row - 1)) + (image_width - column - 1)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 270: /* Plot 90 degrees anti-clockwise */\n\t\t\tfor(row = 0; row < image_width; row++) {\n\t\t\t\tfor(column = 0; column < image_height; column++) {\n\t\t\t\t\tswitch(*(pixelbuf + (image_width * column) + (image_width - row - 1)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = fgblu;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgred;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bggrn;\n\t\t\t\t\t\t\tsymbol->bitmap[i++] = bgblu;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}", "path": "backend\\png.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/* NO_PNG */\n", "func_signal": "int bmp_handle(struct zint_symbol *symbol, int rotate_angle)", "code": "{\n\tint error;\n\t\n\tif(symbol->symbology == BARCODE_MAXICODE) {\n\t\terror = maxi_png_plot(symbol, rotate_angle, BMP_DATA);\n\t} else {\n\t\terror = png_plot(symbol, rotate_angle, BMP_DATA);\n\t}\n\t\n\treturn error;\n}", "path": "backend\\png.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "/**********************************************************************\n* combins(n,r): returns the number of Combinations of r selected from n:\n*   Combinations = n! / ((n - r)! * r!)\n**********************************************************************/\n", "func_signal": "int combins(int n, int r)", "code": "{\n\tint i, j;\n\tint maxDenom, minDenom;\n\tint val;\n\t\n\tif (n-r > r) {\n\t\tminDenom = r;\n\t\tmaxDenom = n-r;\n\t}\n\telse {\n\t\tminDenom = n-r;\n\t\tmaxDenom = r;\n\t}\n\tval = 1;\n\tj = 1;\n\tfor (i = n; i > maxDenom; i--) {\n\t\tval *= i;\n\t\tif (j <= minDenom) {\n\t\t\tval /= j;\n\t\t\tj++;\n\t\t}\n\t}\n\tfor (; j <= minDenom; j++) {\n\t\tval /= j;\n\t}\n\treturn(val);\n}", "path": "backend\\rss.c", "repo_name": "samlown/zint", "stars": 15, "license": "gpl-3.0", "language": "c", "size": 1690}
{"docstring": "//===== CP (mem),R\n", "func_signal": "void srcCPmR()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0: generic_SUB_B(loadB(mem), regB(R));\t\tbreak;\n\tcase 1: generic_SUB_W(loadW(mem), regW(R));\t\tbreak;\n\tcase 2: generic_SUB_L(loadL(mem), regL(R));\t\tbreak;\n\t}\n\t\n\tcycles = 6;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== ADD (mem),#\n", "func_signal": "void srcADDi()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\tstoreB(mem, generic_ADD_B(loadB(mem), FETCH8)); cycles = 7;break;\n\tcase 1:\tstoreW(mem, generic_ADD_W(loadW(mem), fetch16())); cycles = 8;break;\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== ADC (mem),#\n", "func_signal": "void srcADCi()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\tstoreB(mem, generic_ADC_B(loadB(mem), FETCH8)); cycles = 7;break;\n\tcase 1:\tstoreW(mem, generic_ADC_W(loadW(mem), fetch16())); cycles = 8;break;\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== LDIR\n", "func_signal": "void srcLDIR()", "code": "{\n\t_u8 dst = 2/*XDE*/, src = 3/*XHL*/;\n\tif ((first & 0xF) == 5) { dst = 4/*XIX*/; src = 5/*XIY*/; }\n\n\tcycles = 10;\n\n\tdo\n\t{\n\t\tswitch(size)\n\t\t{\n\t\tcase 0:\tif (debug_abort_memory == FALSE)\n\t\t\t\t\tstoreB(regL(dst), loadB(regL(src)));\n\t\t\tregL(dst) += 1;\n\t\t\tregL(src) += 1;\n\t\t\tbreak;\n\n\t\tcase 1:\tif (debug_abort_memory == FALSE)\n\t\t\t\t\tstoreW(regL(dst), loadW(regL(src)));\n\t\t\tregL(dst) += 2;\n\t\t\tregL(src) += 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tREGBC --;\n\t\tSETFLAG_V(REGBC);\n\n\t\tcycles += 14;\n\t}\n\twhile (FLAG_V);\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//=============================================================================\n", "func_signal": "static void rom_hack(void)", "code": "{\n\tgfx_hack = FALSE;\n\n\t//=============================\n\t// GRAPHICS HACKS\n\t//=============================\n\tif (MATCH_CATALOG(89, 5) ||\t\t//Sonic\n\t\tMATCH_CATALOG(149, 36) ||\t//LastBlade(US)\n\t\tMATCH_CATALOG(100, 31) ||\t//LastBlade(J)\n\t\tMATCH_CATALOG(2, 8) ||\t\t//NG.Cup\n\t\tMATCH_CATALOG(57, 14) ||\t//NG.Cup+Colour\n\t\tMATCH_CATALOG(133, 8) ||\t//Ogre\n\t\tMATCH_CATALOG(148, 4) ||\t//Rockman\n\t\tMATCH_CATALOG(105, 21) ||\t//SNKvsCAPCOM\n\t\tMATCH_CATALOG(48, 26) ||\t//Sam.Shodown2\n\t\tMATCH_CATALOG(102, 241) ||\t//Wrestle-Beta\n\t\tMATCH_CATALOG(102, 2) ||\t//Pro-Wrestle\n\t\tMATCH_CATALOG(1, 10) ||\t\t//KOF-R1\n\t\tMATCH_CATALOG(35, 21))\t\t//KOF-R2\n\t{\n\t\tgfx_hack = TRUE;\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: Graphics Timing\");\n#endif\n\t}\n\n\t//### Quick way of displaying the rom information\n//\tsystem_message(\"%d %d\", le16toh(rom_header->catalog),\n//\t\t       rom_header->subCatalog); \n//\tgfx_hack = TRUE;\n\n\t//=============================\n\t// SPECIFIC ROM HACKS !\n\t//=============================\n\n\t//\"Neo-Neo! V1.0 (PD)\"\n\tif (MATCH_CATALOG(0, 16))\n\t{\n\t\trom.data[0x23] = 0x10;\t// Fix rom header\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Neo-Neo! V1.0 (PD)\\\"\");\n#endif\n\t}\n\n\t//\"Cool Cool Jam SAMPLE (U)\"\n\tif (MATCH_CATALOG(4660, 161))\n\t{\n\t\trom.data[0x23] = 0x10;\t// Fix rom header\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Cool Cool Jam SAMPLE (U)\\\"\");\n#endif\n\t}\n\n\t//\"Dokodemo Mahjong (J)\"\n\tif (MATCH_CATALOG(51, 33))\n\t{\n\t\trom.data[0x23] = 0x00;\t// Fix rom header\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Dokodemo Mahjong (J)\\\"\");\n#endif\n\t}\n\n\t//\"Puyo Pop (V05) (JUE)\"\n\tif (MATCH_CATALOG(65, 5))\n\t{\n\t\tint i;\n\t\tfor (i = 0x8F0; i < 0x8FC; i++)\n\t\t\trom.data[i] = 0;\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Puyo Pop (V05) (JUE)\\\"\");\n#endif\n\t}\n\n\t//\"Puyo Pop (V06) (JUE)\"\n\tif (MATCH_CATALOG(65, 6))\n\t{\n\t\tint i;\n\t\tfor (i = 0x8F0; i < 0x8FC; i++)\n\t\t\trom.data[i] = 0;\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Puyo Pop (V06) (JUE)\\\"\");\n#endif\n\t}\n\n\t//\"Metal Slug - 2nd Mission (JUE) [!]\"\n\t//\"Metal Slug - 2nd Mission (JUE) [h1]\"\n\tif (MATCH_CATALOG(97, 4))\n\t{\n\t\t//Enable dev-kit code path, because otherwise it doesn't\n\t\t//allow jumping or firing (for some reason!)\n\t\t\n\t\trom.data[0x1f] = 0xFF;\n\n\t\t//Enables in-game voices (\"Pineapple\", etc.)\n\t\t//that were aren't supposed to be available in Dev-kit mode.\n\t\trom.data[0x8DDF8] = 0xF0;\t//28DDF7: \"RET NZ\" -> \"RET F\"\n\n#ifdef NEOPOP_DEBUG\n\t\tsystem_debug_message(\"HACK: \\\"Metal Slug - 2nd Mission (JUE)\\\"\");\n#endif\n\t}\n}", "path": "Core\\rom.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//-----------------------------------------------------------------------------\n// flash_commit()\n//-----------------------------------------------------------------------------\n", "func_signal": "void flash_commit(void)", "code": "{\n\tint i;\n\tFlashFileHeader header;\n\t_u8 *flashdata, *fileptr;\n\n\t//No flash data?\n\tif (block_count == 0)\n\t\treturn;\n\n\t//Optimise before writing\n\toptimise_blocks();\n\n\t//Build a header;\n\theader.valid_flash_id = FLASH_VALID_ID;\n\theader.block_count = block_count;\n\theader.total_file_length = sizeof(FlashFileHeader);\n\tfor (i = 0; i < block_count; i++)\n\t{\n\t\theader.total_file_length += sizeof(FlashFileBlockHeader);\n\t\theader.total_file_length += blocks[i].data_length;\n\t}\n\n\t//Write the flash data\n\tflashdata = (_u8*)malloc(header.total_file_length * sizeof(_u8));\n\n\t//Copy header\n\tmemcpy(flashdata, &header, sizeof(FlashFileHeader));\n\tfileptr = flashdata + sizeof(FlashFileHeader);\n\n\t//Copy blocks\n\tfor (i = 0; i < block_count; i++)\n\t{\n\t\t_u32 j;\n\n\t\tmemcpy(fileptr, &blocks[i], sizeof(FlashFileBlockHeader));\n\t\tfileptr += sizeof(FlashFileBlockHeader);\n\n\t\t//Copy data\n\t\tfor (j = 0; j < blocks[i].data_length; j++)\n\t\t{\n\t\t\t*fileptr = loadB(blocks[i].start_address + j);\n\t\t\tfileptr++;\n\t\t}\n\t}\n\n\t//Try to Write flash buffer\n\tsystem_io_flash_write(flashdata, header.total_file_length);\n\n\tfree(flashdata);\n}", "path": "Core\\flash.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== INC #3,(mem)\n", "func_signal": "void srcINC()", "code": "{\n\t_u8 val = R;\n\tif (val == 0)\n\t\tval = 8;\n\n\tswitch(size)\n\t{\n\tcase 0: {\t_u8 dst = loadB(mem);\n\t\t\t\t_u32 resultC = dst + val;\n\t\t\t\t_u8 half = (dst & 0xF) + val;\n\t\t\t\t_u8 result = (_u8)(resultC & 0xFF);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_H(half > 0xF);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tSETFLAG_N0;\n\n\t\t\t\tif (((_s8)dst >= 0) && ((_s8)result < 0))\n\t\t\t\t{SETFLAG_V1} else {SETFLAG_V0}\n\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tbreak; }\n\n\tcase 1: {\t_u16 dst = loadW(mem);\n\t\t\t\t_u32 resultC = dst + val;\n\t\t\t\t_u8 half = (dst & 0xF) + val;\n\t\t\t\t_u16 result = (_u16)(resultC & 0xFFFF);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_H(half > 0xF);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tSETFLAG_N0;\n\n\t\t\t\tif (((_s16)dst >= 0) && ((_s16)result < 0))\n\t\t\t\t{SETFLAG_V1} else {SETFLAG_V0}\n\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tbreak; }\n\t}\n\n\tcycles = 6;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== XOR R,(mem)\n", "func_signal": "void srcXORRm()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\t{\t_u8 result = regB(R) ^ loadB(mem);\n\t\t\t\tregB(R) = result;\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tparityB(result);\n\t\t\t\tcycles = 4;\n\t\t\t\tbreak; }\n\t\n\tcase 1: {\t_u16 result = regW(R) ^ loadW(mem);\n\t\t\t\tregW(R) = result;\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tparityW(result);\n\t\t\t\tcycles = 4;\n\t\t\t\tbreak; }\n\n\tcase 2:\t{\t_u32 result = regL(R) ^ loadL(mem);\n\t\t\t\tregL(R) = result;\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x80000000);\n\t\t\t\tcycles = 6;\n\t\t\t\tbreak; }\n\t}\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n\tSETFLAG_C0;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== LDD\n", "func_signal": "void srcLDD()", "code": "{\n\t_u8 dst = 2/*XDE*/, src = 3/*XHL*/;\n\tif ((first & 0xF) == 5) { dst = 4/*XIX*/; src = 5/*XIY*/; }\n\n\tswitch(size)\n\t{\n\tcase 0:\n\t\tstoreB(regL(dst), loadB(regL(src)));\n\t\tregL(dst) -= 1;\n\t\tregL(src) -= 1;\n\t\tbreak;\n\n\tcase 1:\n\t\tstoreW(regL(dst), loadW(regL(src)));\n\t\tregL(dst) -= 2;\n\t\tregL(src) -= 2;\n\t\tbreak;\n\t}\n\n\tREGBC --;\n\tSETFLAG_V(REGBC);\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n\tcycles = 10;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== OR (mem),#\n", "func_signal": "void srcORi()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0: {\t_u8 result = loadB(mem) | FETCH8;\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityB(result);\n\t\t\t\tcycles = 7;\n\t\t\t\tbreak; }\n\n\tcase 1: {\t_u16 result = loadW(mem) | fetch16();\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityW(result);\n\t\t\t\tcycles = 8;\n\t\t\t\tbreak; }\n\t}\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n\tSETFLAG_C0;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== CPIR\n", "func_signal": "void srcCPIR()", "code": "{\n\t_u8 R = first & 7;\n\n\tcycles = 10;\n\n\tdo\n\t{\n\t\tswitch(size)\n\t\t{\n\t\tcase 0:\tif (debug_abort_memory == FALSE)\n\t\t\t\t\tgeneric_SUB_B(REGA, loadB(regL(R)));\n\t\t\t\tregL(R) ++; break;\n\n\t\tcase 1:\tif (debug_abort_memory == FALSE)\n\t\t\t\t\tgeneric_SUB_W(REGWA, loadW(regL(R)));\n\t\t\t\tregL(R) += 2; break;\n\t\t}\n\n\t\tREGBC --;\n\t\tSETFLAG_V(REGBC);\n\n\t\tcycles += 14;\n\t}\n\twhile (FLAG_V && (FLAG_Z == FALSE));\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== XOR (mem),#\n", "func_signal": "void srcXORi()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0: {\t_u8 result = loadB(mem) ^ FETCH8;\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityB(result);\n\t\t\t\tcycles = 7;\n\t\t\t\tbreak; }\n\n\tcase 1: {\t_u16 result = loadW(mem) ^ fetch16();\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityW(result);\n\t\t\t\tcycles = 8;\n\t\t\t\tbreak; }\n\t}\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n\tSETFLAG_C0;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== AND (mem),R\n", "func_signal": "void srcANDmR()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\t{\t_u8 result = regB(R) & loadB(mem);\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tparityB(result);\n\t\t\t\tcycles = 6;\n\t\t\t\tbreak; }\n\t\n\tcase 1: {\t_u16 result = regW(R) & loadW(mem);\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tparityW(result);\n\t\t\t\tcycles = 6;\n\t\t\t\tbreak; }\n\n\tcase 2:\t{\t_u32 result = regL(R) & loadL(mem);\n\t\t\t\tstoreL(mem, result);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tSETFLAG_S(result & 0x80000000);\n\t\t\t\tcycles = 10;\n\t\t\t\tbreak; }\n\t}\n\n\tSETFLAG_H1;\n\tSETFLAG_N0;\n\tSETFLAG_C0;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== CP R,(mem)\n", "func_signal": "void srcCPRm()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0: generic_SUB_B(regB(R), loadB(mem)); cycles = 4; break;\n\tcase 1: generic_SUB_W(regW(R), loadW(mem)); cycles = 4; break;\n\tcase 2: generic_SUB_L(regL(R), loadL(mem)); cycles = 6; break;\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//-----------------------------------------------------------------------------\n// flash_write()\n//-----------------------------------------------------------------------------\n", "func_signal": "void flash_write(_u32 start_address, _u16 length)", "code": "{\n\t_u16 i;\n\n\t//Now we need a new flash command before the next flash write will work!\n\tmemory_flash_command = FALSE;\n\n//\tsystem_debug_message(\"flash write: %06X, %d bytes\", start_address, length);\n\n\tfor (i = 0; i < block_count; i++)\n\t{\n\t\t//Got this block with enough bytes to cover it\n\t\tif (blocks[i].start_address == start_address &&\n\t\t\tblocks[i].data_length >= length)\n\t\t{\n\t\t\treturn; //Nothing to do, block already registered.\n\t\t}\n\n\t\t//Got this block with but it's length is too short\n\t\tif (blocks[i].start_address == start_address &&\n\t\t\tblocks[i].data_length < length)\n\t\t{\n\t\t\tblocks[i].data_length = length;\t//Enlarge block updating.\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// New block needs to be added\n\tblocks[block_count].start_address = start_address;\n\tblocks[block_count].data_length = length;\n\tblock_count++;\n}", "path": "Core\\flash.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== ADC R,(mem)\n", "func_signal": "void srcADCRm()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0: regB(R) = generic_ADC_B(regB(R), loadB(mem)); cycles = 4;break;\n\tcase 1: regW(R) = generic_ADC_W(regW(R), loadW(mem)); cycles = 4;break;\n\tcase 2: regL(R) = generic_ADC_L(regL(R), loadL(mem)); cycles = 6;break;\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== DIVS RR,(mem)\n", "func_signal": "void srcDIVS()", "code": "{\n\t_u8 target = get_RR_Target();\n\tif (target == 0x80)\n\t{\n\t\tinstruction_error(\"src: DIVS bad \\'RR\\' dst code\");\n\t\treturn;\n\t}\n\n\tswitch(size)\n\t{\n\tcase 0: {\trCodeW(target) = generic_DIVS_B(rCodeW(target), loadB(mem));\n\t\t\t\tcycles = 24;\n\t\t\t\tbreak;\t}\n\n\tcase 1: {\trCodeL(target) = generic_DIVS_W(rCodeL(target), loadW(mem));\n\t\t\t\tcycles = 32;\n\t\t\t\tbreak;\t}\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== RLC (mem)\n", "func_signal": "void srcRLC()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\t{\t_u8 result = loadB(mem);\n\t\t\t\tSETFLAG_C(result & 0x80);\n\t\t\t\tresult <<= 1;\n\t\t\t\tif (FLAG_C) result |= 1;\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityB(result);\n\t\t\t\tbreak; }\n\t\t\n\tcase 1:\t{\t_u16 result = loadW(mem);\n\t\t\t\tSETFLAG_C(result & 0x8000);\n\t\t\t\tresult <<= 1;\n\t\t\t\tif (FLAG_C) result |= 1;\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityW(result);\n\t\t\t\tbreak; }\n\t}\n\n\tSETFLAG_H0;\n\tSETFLAG_N0;\n\n\tcycles = 8;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== RR (mem)\n", "func_signal": "void srcRR()", "code": "{\n\tBOOL tempC;\n\n\tswitch(size)\n\t{\n\tcase 0:\t{\t_u8 result = loadB(mem);\n\t\t\t\ttempC = FLAG_C;\n\t\t\t\tSETFLAG_C(result & 1);\n\t\t\t\tresult >>= 1;\n\t\t\t\tif (tempC) result |= 0x80;\n\t\t\t\tstoreB(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x80);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityB(result);\n\t\t\t\tbreak; }\n\t\t\n\tcase 1:\t{\t_u16 result = loadW(mem);\n\t\t\t\ttempC = FLAG_C;\n\t\t\t\tSETFLAG_C(result & 1);\n\t\t\t\tresult >>= 1;\n\t\t\t\tif (tempC) result |= 0x8000;\n\t\t\t\tstoreW(mem, result);\n\t\t\t\tSETFLAG_S(result & 0x8000);\n\t\t\t\tSETFLAG_Z(result == 0);\n\t\t\t\tparityW(result);\n\t\t\t\tbreak; }\n\t}\n\n\tcycles = 8;\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "//===== SBC (mem),R\n", "func_signal": "void srcSBCmR()", "code": "{\n\tswitch(size)\n\t{\n\tcase 0:\tstoreB(mem, generic_SBC_B(loadB(mem), regB(R))); cycles = 6;break;\n\tcase 1:\tstoreW(mem, generic_SBC_W(loadW(mem), regW(R))); cycles = 6;break;\n\tcase 2:\tstoreL(mem, generic_SBC_L(loadL(mem), regL(R))); cycles = 10;break;\n\t}\n}", "path": "Core\\TLCS-900h\\TLCS900h_interpret_src.c", "repo_name": "Cpasjuste/neopop-sdl", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 936}
{"docstring": "/* set up the application parameters - read in from command line*/\n", "func_signal": "static int init( int argc, char *argv[] )", "code": "{\n    char     cparaname[256];\n    char     odataname[256];\n    ARParam  wparam;\n    int      i;\n\n    /* copy in name of the camera parameter file, the hmd parameter file \n       and the object data file */\n    strcpy( cparaname, \"Data/camera_para.dat\" );\n    strcpy( odataname, \"Data/object_data\" );\n    \n    /* read in the parameters from the various files */\n    for( i = 1; i < argc; i++ ) {\n        if( strcmp(argv[i],\"-c\") == 0 ) {\n            if( i < argc-1 && argv[i+1][0] != '-' ) {\n                strcpy( cparaname, argv[i+1] );\n                i++;\n            }\n            else usage( argv[0] );\n        }\n        else if( strcmp(argv[i],\"-o\") == 0 ) {\n            if( i < argc-1 && argv[i+1][0] != '-' ) {\n                strcpy( odataname, argv[i+1] );\n                i++;\n            }\n            else usage( argv[0] );\n        }\n        else usage( argv[0] );\n    }\n\n    /* load in the object data - trained markers and associated bitmap files */\n    if( (object=read_objectdata(odataname,&objectnum)) == NULL ) exit(0);\n\n    /* open the video path */\n    if( arVideoOpen( vconf ) < 0 ) exit(0);\n    /* find the size of the window */\n    if( arVideoInqSize(&xsize, &ysize) < 0 ) exit(0);\n    printf(\"Image size (x,y) = (%d,%d)\\n\", xsize, ysize);\n\n    /* set the initial camera parameters */\n    if( arParamLoad(cparaname, 1, &wparam) < 0 ) {\n       printf(\"Camera parameter load error !!\\n\");\n        exit(0);\n    }\n    arParamChangeSize( &wparam, xsize, ysize, &cparam );\n\n    arInitCparam( &cparam );\n    printf(\"*** Camera Parameter ***\\n\");\n    arParamDisp( &cparam );\n\n    /* open the graphics window */\n    argInit( &cparam, 1.0, 0, 2, 1, 0 );\n\n    dispMode();\n\n    return 0;\n}", "path": "examples\\modeTest\\modeTest.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "//\n// This function is called when the window needs redrawing.\n//\n", "func_signal": "static void Display(void)", "code": "{\n\t// Select correct buffer for this context.\n\tglDrawBuffer(GL_BACK);\n\tglClear(GL_COLOR_BUFFER_BIT); // Clear the buffers for new frame.\n\t\n\targlDispImage(gARTImage, &gARTCparam, 1.0, gArglSettings);\t// zoom = 1.0.\n\tarVideoCapNext();\n\tgARTImage = NULL; // Image data is no longer valid after calling arVideoCapNext().\n\n\tif (gTarget != NULL) {\n\t\tglDisable(GL_DEPTH_TEST);\n\t\tglDisable(GL_LIGHTING);\n\t\tglDisable(GL_TEXTURE_2D);\n\t\tbeginOrtho2D(gARTCparam.xsize, gARTCparam.ysize);\n        glLineWidth(2.0f);\n        glColor3d(0.0, 1.0, 0.0);\n        lineSeg(gTarget->vertex[0][0], gTarget->vertex[0][1],\n\t\t\t\tgTarget->vertex[1][0], gTarget->vertex[1][1], gArglSettings, gARTCparam, 1.0);\n        lineSeg(gTarget->vertex[3][0], gTarget->vertex[3][1],\n\t\t\t\tgTarget->vertex[0][0], gTarget->vertex[0][1], gArglSettings, gARTCparam, 1.0);\n        glColor3d(1.0, 0.0, 0.0);\n        lineSeg(gTarget->vertex[1][0], gTarget->vertex[1][1],\n\t\t\t\tgTarget->vertex[2][0], gTarget->vertex[2][1], gArglSettings, gARTCparam, 1.0);\n        lineSeg(gTarget->vertex[2][0], gTarget->vertex[2][1],\n\t\t\t\tgTarget->vertex[3][0], gTarget->vertex[3][1], gArglSettings, gARTCparam, 1.0);\n\t\tendOrtho2D();\n    }\n\n\tglutSwapBuffers();\n}", "path": "util\\mk_patt\\mk_patt.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "//\n//\tThis function is called when the\n//\tGLUT window is resized.\n//\n", "func_signal": "static void Reshape(int w, int h)", "code": "{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglViewport(0, 0, (GLsizei) w, (GLsizei) h);\n\t\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\t\n\t// Call through to anyone else who needs to know about window sizing here.\n}", "path": "util\\mk_patt\\mk_patt.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* cleanup function called when program exits */\n", "func_signal": "static void cleanup(void)", "code": "{\n    arVideoCapStop();\n    arVideoClose();\n    argCleanup();\n}", "path": "examples\\multi\\multiTest.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* draw the user object */\n", "func_signal": "static int  draw_object( char *name, double gl_para[16] )", "code": "{\n    argDrawMode3D();\n    argDraw3dCamera( 0, 0 );\n    glDepthFunc(GL_LEQUAL);\n    glEnable(GL_DEPTH_TEST);\n    \n    /* load the camera transformation matrix */\n    glMatrixMode(GL_MODELVIEW);\n    glLoadMatrixd( gl_para );\n    init_lights();\n\n\n    /* draw the user object here \n       - using the object name to select the object */\n    if( strcmp(name, \"torus\") == 0 ) {\n      /* set object color */\n      glEnable(GL_LIGHTING);\n      glEnable(GL_LIGHT0);\n      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_flash1);\n      glMaterialfv(GL_FRONT, GL_SHININESS, mat_flash_shiny1);\t\n      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient1);\n   \n      /* draw a simple torus */\n      glMatrixMode(GL_MODELVIEW);\n      glTranslatef( 0.0, 0.0, 10.0 );\n      glutSolidTorus(10.0, 40.0, 24, 24);\n      glDisable( GL_LIGHTING );\n    }\n    else if( strcmp(name, \"sphere\") == 0 ) {\n      glEnable(GL_LIGHTING);\n      glEnable(GL_LIGHT0);\n      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_flash1);\n      glMaterialfv(GL_FRONT, GL_SHININESS, mat_flash_shiny1);\t\n      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient1);\n      \n      /* draw a sphere */ \n      glMatrixMode(GL_MODELVIEW);\n      glTranslatef( 0.0, 0.0, 40.0 );\n      glutSolidSphere(40.0, 24, 24);\n      glDisable( GL_LIGHTING );\n    }\n    else if( strcmp(name, \"cube\") == 0 ) {\n      glEnable(GL_LIGHTING);\n      glEnable(GL_LIGHT0);\n      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_flash2);\n      glMaterialfv(GL_FRONT, GL_SHININESS, mat_flash_shiny2);\t\n      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient2);\n          \n      glMatrixMode(GL_MODELVIEW);\n      glTranslatef( 0.0, 0.0, 25.0 );\n      glutSolidCube(50.0);\n      glDisable( GL_LIGHTING );\n    }\n    else if( strcmp(name, \"cone\") == 0 ) {\n      glEnable(GL_LIGHTING);\n      glEnable(GL_LIGHT0);\n      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_flash1);\n      glMaterialfv(GL_FRONT, GL_SHININESS, mat_flash_shiny1);\t\n      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient1);\n      \n      glMatrixMode(GL_MODELVIEW);\n      glutSolidCone(25.0, 50.0, 20, 24);\n      glDisable( GL_LIGHTING );\n    }\n    else {\n      printf(\"unknown object type!!\\n\");\n    }\n\n    glDisable( GL_DEPTH_TEST );\n\n    return 0;\n}", "path": "examples\\modeTest\\draw_object.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "AR2VideoParamT* \nar2VideoOpen(char *config_in )", "code": "{\n\n\tAR2VideoParamT *vid = 0;\n\tGError *error = 0;\n\tint i;\n\tGstPad *pad, *peerpad;\n\tGstXML *xml;\n\tGstStateChangeReturn _ret;\n\tchar *config;\n\n\t/* If no config string is supplied, we should use the environment variable, otherwise set a sane default */\n\tif (!config_in || !(config_in[0])) {\n\t\t/* None suppplied, lets see if the user supplied one from the shell */\n\t\tchar *envconf = getenv (\"ARTOOLKIT_CONFIG\");\n\t\tif (envconf && envconf[0]) {\n\t\t\tconfig = envconf;\n\t\t\tg_printf (\"Using config string from environment [%s].\\n\", envconf);\n\t\t} else {\n\t\t\tconfig = NULL;\n\t\t\tg_printf (\"No video config string supplied, using defaults.\\n\");\n\t\t}\n\t} else {\n\t\tconfig = config_in;\n\t\tg_printf (\"Using supplied video config string [%s].\\n\", config_in);\n\t}\n\n\t/* initialise GStreamer */\n\tgst_init(0,0);\t\n\t\n\t/* init ART structure */\n    arMalloc( vid, AR2VideoParamT, 1 );\n\n\t/* initialise buffer */\n\tvid->videoBuffer = 0;\n\t\n\t/* report the current version and features */\n\tg_print (\"libARvideo: %s\\n\", gst_version_string());\n\n#if 0\t\n\txml = gst_xml_new();\n\t\n\t/* first check if config contains an xml file */\n\tif (gst_xml_parse_file(xml,config,NULL)) \n\t{\n\t\t/* parse the pipe definition */\n\t\t\n\t} else \n\t{\n\t\tvid->pipeline = gst_xml_get_element(xml,\"pipeline\");\n\t}\n\t\n#endif\n\n\tvid->pipeline = gst_parse_launch (config, &error);\n\t\n\tif (!vid->pipeline) {\n\t\tg_print (\"Parse error: %s\\n\", error->message);\n\t\treturn 0;\n\t};\n\n\t/* get the video sink */\n\tvid->probe = gst_bin_get_by_name(GST_BIN(vid->pipeline), \"artoolkit\");\n\n\tif (!vid->probe) {\n\t\tg_print(\"Pipeline has no element named 'artoolkit'!\\n\");\n\t\treturn 0;\t\n\t};\n\t\t\n\t/* get the pad from the probe (the source pad seems to be more flexible) */\t\n\tpad = gst_element_get_pad (vid->probe, \"src\");\n\n\t\t\n\t/* install the probe callback for capturing */\n\tgst_pad_add_buffer_probe (pad, G_CALLBACK (cb_have_data), vid);\t\n\t\n\t\n\n#if 0\n\t/* request ready state */\n\tgst_element_set_state (vid->pipeline, GST_STATE_READY);\n\t\n\t/* check if stream is ready */\n\tif (gst_element_get_state (vid->pipeline, NULL, NULL, -1) == GST_STATE_CHANGE_FAILURE) {\n    \tg_error (\"libARvideo: failed to put GStreamer into READY state!\\n\");\n    } else {\n    \tg_print (\"libARvideo: GStreamer pipeline is READY!\\n\");\n    }\n#endif\n\n\t/* Needed to fill the information for ARVidInfo */\n\tgst_element_set_state (vid->pipeline, GST_STATE_PAUSED);\n\n\tpeerpad = gst_pad_get_peer(pad);\n\t\n\ttesting_pad(peerpad);\n\n\t/* dismiss the pad */\n\tgst_object_unref (pad);\n\t\n\t/* wait until it's up and running or failed */\n\tif (gst_element_get_state (vid->pipeline, NULL, NULL, -1) == GST_STATE_CHANGE_FAILURE) {\n    \tg_error (\"libARvideo: failed to put GStreamer into PAUSE state!\\n\");\n    } else {\n    \tg_print (\"libARvideo: GStreamer pipeline is PAUSED!\\n\");\n    }\n\n\t/* now preroll for V4L v2 interfaces */\n\tif ((strstr(config, \"v4l2src\") != 0) ||\n\t\t(strstr(config, \"dv1394src\") != 0))\n\t{\n\t\t/* set playing state of the pipeline */\n\t\tgst_element_set_state (vid->pipeline, GST_STATE_PLAYING);\n\t\t\n\t\t/* wait until it's up and running or failed */\n\t\tif (gst_element_get_state (vid->pipeline, NULL, NULL, -1) == GST_STATE_CHANGE_FAILURE) {\n\t    \tg_error (\"libARvideo: failed to put GStreamer into PLAYING state!\\n\");\n\t    } else {\n\t    \tg_print (\"libARvideo: GStreamer pipeline is PLAYING!\\n\");\n\t    }\n\t\t\n\t\t/* set playing state of the pipeline */\n\t\tgst_element_set_state (vid->pipeline, GST_STATE_PAUSED);\n\t\t\n\t\t/* wait until it's up and running or failed */\n\t\tif (gst_element_get_state (vid->pipeline, NULL, NULL, -1) == GST_STATE_CHANGE_FAILURE) {\n\t    \tg_error (\"libARvideo: failed to put GStreamer into PAUSED state!\\n\");\n\t    } else {\n\t    \tg_print (\"libARvideo: GStreamer pipeline is PAUSED!\\n\");\n\t    }\n\t}\n\t\t\n#if 0\n\t/* write the bin to stdout */\n\tgst_xml_write_file (GST_ELEMENT (vid->pipeline), stdout);\n#endif\n\t\n\t/* return the video handle */\n\treturn vid;\n}", "path": "lib\\SRC\\VideoGStreamer\\video.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* cleanup function called when program exits */\n", "func_signal": "static void cleanup(void)", "code": "{\n    arVideoCapStop();\n    arVideoClose();\n    argCleanup();\n}", "path": "examples\\modeTest\\modeTest.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "//\n//\tThis function is called when the\n//\tGLUT window is resized.\n//\n", "func_signal": "static void Reshape(int w, int h)", "code": "{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglViewport(0, 0, (GLsizei) w, (GLsizei) h);\n\t\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\t\n\t// Call through to anyone else who needs to know about window sizing here.\n}", "path": "util\\calib_cparam\\calib_cparam.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/**********************************************************************\n *\n *  CONVERSION FUNCTIONS TO UYVY \n *\n **********************************************************************/\n", "func_signal": "void\nyuyv2uyvy(unsigned char *src, unsigned char *dest, unsigned long long int NumPixels)", "code": "{\n#ifdef YUYV\n  swab(src, dest, NumPixels << 1);\n#else\n  memcpy(dest,src, NumPixels<<1);\n#endif\n}", "path": "lib\\SRC\\VideoLinux1394Cam\\conversions.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "// change a 16bit stereo image (8bit/channel) into two 8bit images on top\n// of each other\n", "func_signal": "void\nStereoDecode(unsigned char *src, unsigned char *dest, unsigned long long int NumPixels)", "code": "{\n  register int i = NumPixels-1;\n  register int j = (NumPixels>>1)-1;\n  register int k = NumPixels-1;\n\n  while (i > 0) {\n    dest[k--] = src[i--];\n    dest[j--] = src[i--];\n  }\n}", "path": "lib\\SRC\\VideoLinux1394Cam\\conversions.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/********************************/\n/*                              */\n/*    MATRIX inverse function   */\n/*                              */\n/********************************/\n", "func_signal": "static double *minv( double *ap, int dimen, int rowa )", "code": "{\n        double *wap, *wcp, *wbp;/* work pointer                 */\n        int i,j,n,ip,nwork;\n        int nos[50];\n        double epsl;\n        double p,pbuf,work;\n        double  fabs();\n\n        epsl = 1.0e-10;         /* Threshold value      */\n\n        switch (dimen) {\n                case (0): return(NULL);                 /* check size */\n                case (1): *ap = 1.0 / (*ap);\n                          return(ap);                   /* 1 dimension */\n        }\n\n        for(n = 0; n < dimen ; n++)\n                nos[n] = n;\n\n        for(n = 0; n < dimen ; n++) {\n                wcp = ap + n * rowa;\n\n                for(i = n, wap = wcp, p = 0.0; i < dimen ; i++, wap += rowa)\n                        if( p < ( pbuf = fabs(*wap)) ) {\n                                p = pbuf;\n                                ip = i;\n                        }\n                if (p <= epsl)\n                        return(NULL);\n\n                nwork = nos[ip];\n                nos[ip] = nos[n];\n                nos[n] = nwork;\n\n                for(j = 0, wap = ap + ip * rowa, wbp = wcp; j < dimen ; j++) {\n                        work = *wap;\n                        *wap++ = *wbp;\n                        *wbp++ = work;\n                }\n\n                for(j = 1, wap = wcp, work = *wcp; j < dimen ; j++, wap++)\n                        *wap = *(wap + 1) / work;\n                *wap = 1.0 / work;\n\n                for(i = 0; i < dimen ; i++) {\n                        if(i != n) {\n                                wap = ap + i * rowa;\n                                for(j = 1, wbp = wcp, work = *wap;\n                                                j < dimen ; j++, wap++, wbp++)\n                                        *wap = *(wap + 1) - work * (*wbp);\n                                *wap = -work * (*wbp);\n                        }\n                }\n        }\n\n        for(n = 0; n < dimen ; n++) {\n                for(j = n; j < dimen ; j++)\n                        if( nos[j] == n) break;\n                nos[j] = nos[n];\n                for(i = 0, wap = ap + j, wbp = ap + n; i < dimen ;\n                                        i++, wap += rowa, wbp += rowa) {\n                        work = *wap;\n                        *wap = *wbp;\n                        *wbp = work;\n                }\n        }\n        return(ap);\n}", "path": "lib\\SRC\\AR\\mSelfInv.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* main loop */\n", "func_signal": "static void mainLoop(void)", "code": "{\n    ARUint8         *dataPtr;\n    ARMarkerInfo    *marker_info;\n    int             marker_num;\n    double          err;\n    int             i;\n\n    /* grab a vide frame */\n    if( (dataPtr = (ARUint8 *)arVideoGetImage()) == NULL ) {\n        arUtilSleep(2);\n        return;\n    }\n    if( count == 0 ) arUtilTimerReset();\n    count++;\n\n    /* detect the markers in the video frame */\n    if( arDetectMarkerLite(dataPtr, thresh, &marker_info, &marker_num) < 0 ) {\n        cleanup();\n        exit(0);\n    }\n\n    argDrawMode2D();\n    if( !arDebug ) {\n        argDispImage( dataPtr, 0,0 );\n    }\n    else {\n        argDispImage( dataPtr, 1, 1 );\n        if( arImageProcMode == AR_IMAGE_PROC_IN_HALF )\n            argDispHalfImage( arImage, 0, 0 );\n        else\n            argDispImage( arImage, 0, 0);\n\n        glColor3f( 1.0, 0.0, 0.0 );\n        glLineWidth( 1.0 );\n        for( i = 0; i < marker_num; i++ ) {\n            argDrawSquare( marker_info[i].vertex, 0, 0 );\n        }\n        glLineWidth( 1.0 );\n    }\n\n    arVideoCapNext();\n\n    if( (err=arMultiGetTransMat(marker_info, marker_num, config)) < 0 ) {\n        argSwapBuffers();\n        return;\n    }\n    printf(\"err = %f\\n\", err);\n    if(err > 100.0 ) {\n        argSwapBuffers();\n        return;\n    }\n/*\n    for(i=0;i<3;i++) {\n        for(j=0;j<4;j++) printf(\"%10.5f \", config->trans[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n*/\n    argDrawMode3D();\n    argDraw3dCamera( 0, 0 );\n    glClearDepth( 1.0 );\n    glClear(GL_DEPTH_BUFFER_BIT);\n    for( i = 0; i < config->marker_num; i++ ) {\n        if( config->marker[i].visible >= 0 ) draw( config->trans, config->marker[i].trans, 0 );\n        else                                 draw( config->trans, config->marker[i].trans, 1 );\n    }\n    argSwapBuffers();\n}", "path": "examples\\multi\\multiTest.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "//\n//\tThis function is called on events when the visibility of the\n//\tGLUT window changes (including when it first becomes visible).\n//\n", "func_signal": "static void Visibility(int visible)", "code": "{\n\tif (visible == GLUT_VISIBLE) {\n\t\tglutIdleFunc(Idle);\n\t} else {\n\t\tglutIdleFunc(NULL);\n\t}\n}", "path": "util\\mk_patt\\mk_patt.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* initialize the lights in the scene */\n", "func_signal": "static void init_lights( void )", "code": "{\n    GLfloat light_position[] = {0.0,-200.0,0.0,0.0};\n    GLfloat ambi[] = {0.1, 0.1, 0.1, 0.1};\n    GLfloat lightZeroColor[]    = {0.9, 0.9, 0.9, 0.1};\n\n    glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n    glLightfv(GL_LIGHT0, GL_AMBIENT, ambi);\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightZeroColor);\n}", "path": "examples\\modeTest\\draw_object.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* main loop */\n", "func_signal": "static void mainLoop(void)", "code": "{\n    ARUint8         *dataPtr;\n    ARMarkerInfo    *marker_info;\n    int             marker_num;\n    int             i, j, k;\n\n    if( count == 0 ) arUtilTimerReset();\n\n    /* grab a vide frame */\n    while( (dataPtr = (ARUint8 *)arVideoGetImage()) == NULL ) arUtilSleep(2);\n\n    argDrawMode2D();\n    argDispImage( dataPtr, 0, 0 );\n\n    /* detect the markers in the video frame */\n    if( arDetectMarker(dataPtr, thresh, &marker_info, &marker_num) < 0 ) {\n        cleanup();\n        exit(0);\n    }\n\n    /* if the debug mode is on draw squares \n       around the detected squares in the video image */\n    if( arDebug ) {\n        argDispImage( dataPtr, 1, 1 );\n        if( arImageProcMode == AR_IMAGE_PROC_IN_HALF )\n            argDispHalfImage( arImage, 2, 1 );\n        else\n            argDispImage( arImage, 2, 1);\n\n        glColor3f( 1.0, 0.0, 0.0 );\n        glLineWidth( 3.0 );\n        for( i = 0; i < marker_num; i++ ) {\n            if( marker_info[i].id < 0 ) continue;\n            argDrawSquare( marker_info[i].vertex, 2, 1 );\n        }\n        glLineWidth( 1.0 );\n    }\n    arVideoCapNext();\n\n    /* check for object visibility */\n    for( i = 0; i < objectnum; i++ ) {\n        object[i].visible = 0;\n        k = -1;\n        for( j = 0; j < marker_num; j++ ) {\n            if( object[i].id == marker_info[j].id ) {\n                if( k == -1 ) k = j;\n                else {\n                    if( marker_info[k].cf < marker_info[j].cf ) k = j;\n                }\n            }\n        }\n        if( k == -1 ) continue;\n\n        /* get the transformation between the marker and the real camera */\n        arGetTransMat(&marker_info[k], object_center, object[i].marker_width, object[i].trans);\n        object[i].visible = 1;\n    }\n\n    /* draw the virtual objects attached to the cards */\n    glClearDepth( 1.0 );\n    glClear(GL_DEPTH_BUFFER_BIT);\n    draw( object, objectnum );\n\n    count++;\n    if( count == 30 ) {\n        printf(\"*** %f (frame/sec)\\n\", (double)count/arUtilTimer());\n        count = 0;\n    }\n\n    argSwapBuffers();\n}", "path": "examples\\modeTest\\modeTest.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "//\n//\tThis function is called on events when the visibility of the\n//\tGLUT window changes (including when it first becomes visible).\n//\n", "func_signal": "static void Visibility(int visible)", "code": "{\n\tif (visible == GLUT_VISIBLE) {\n\t\tglutIdleFunc(Idle);\n\t} else {\n\t\tglutIdleFunc(NULL);\n\t}\n}", "path": "util\\calib_cparam\\calib_cparam.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "// ============================================================================\n//\tFunctions\n// ============================================================================\n", "func_signal": "void lineSeg(double x1, double y1, double x2, double y2, ARGL_CONTEXT_SETTINGS_REF contextSettings, ARParam cparam, double zoom)", "code": "{\n\tint enable;\n    float   ox, oy;\n    double  xx1, yy1, xx2, yy2;\n\t\n\tif (!contextSettings) return;\n\targlDistortionCompensationGet(contextSettings, &enable);\n    if (arglDrawModeGet(contextSettings) == AR_DRAW_BY_TEXTURE_MAPPING && enable) {\n        xx1 = x1;  yy1 = y1;\n        xx2 = x2;  yy2 = y2;\n    } else {\n        arParamIdeal2Observ(cparam.dist_factor, x1, y1, &xx1, &yy1);\n        arParamIdeal2Observ(cparam.dist_factor, x2, y2, &xx2, &yy2);\n    }\n\t\n    xx1 *= zoom; yy1 *= zoom;\n    xx2 *= zoom; yy2 *= zoom;\n\t\n\tox = 0;\n\toy = cparam.ysize - 1;\n\tglBegin(GL_LINES);\n\tglVertex2f(ox + xx1, oy - yy1);\n\tglVertex2f(ox + xx2, oy - yy2);\n\tglEnd();\n    glFlush();\n}", "path": "util\\mk_patt\\mk_patt.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/* draw the user object */\n", "func_signal": "static int  draw_object( char *name, double gl_para[16], int xwin, int ywin )", "code": "{\n    argDrawMode3D();\n    argDraw3dCamera( xwin, ywin );\n\n    glDepthFunc(GL_LEQUAL);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_NORMALIZE);\n    /* load the camera transformation matrix */\n    glMatrixMode(GL_PROJECTION);\n    glMultMatrixd( gl_para );\n\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    setup_light();\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n\n    if( strcmp(name, \"target\") == 0 ) {\n        draw_axis();\n    }\n    else {\n        printf(\"unknown object type!!\\n\");\n    }\n\n    glDisable( GL_LIGHTING );\n    glDisable( GL_NORMALIZE );\n    glDisable( GL_DEPTH_TEST );\n    argDrawMode2D();\n\n    return 0;\n}", "path": "examples\\exview\\draw_object.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/*****************************************************************\n *     Color conversion functions for cameras that can           * \n * output raw-Bayer pattern images, such as some Basler and      *\n * Point Grey camera. Most of the algos presented here come from *\n * http://ise0.Stanford.EDU/~tingchen/main.htm and have been     *\n * converted from Matlab to C and extended to all elementary     *\n * patterns.                                                     *\n *****************************************************************/\n", "func_signal": "void\nBayerNearestNeighbor( unsigned char *src, \n\t\t      unsigned char *dest, \n\t\t      int sx, \n\t\t      int sy, \n\t\t      bayer_pattern_t type)", "code": "{\n  unsigned char *outR, *outG, *outB;\n  register int i,j;\n\n  // sx and sy should be even\n  switch (type) {\n  case BAYER_PATTERN_GRBG:\n  case BAYER_PATTERN_BGGR:\n    outR=&dest[0];\n    outG=&dest[1];\n    outB=&dest[2];\n    break;\n  case BAYER_PATTERN_GBRG:\n  case BAYER_PATTERN_RGGB:\n    outR=&dest[2];\n    outG=&dest[1];\n    outB=&dest[0];\n    break;\n  default:\n    outR=NULL;outG=NULL;outB=NULL;\n    break;\n  }\n  \n  switch (type) {\n  case BAYER_PATTERN_GRBG: //-------------------------------------------\n  case BAYER_PATTERN_GBRG:\n    // copy original RGB data to output images\n    for (i=0;i<sy;i+=2) {\n      for (j=0;j<sx;j+=2) {\n\toutG[(i*sx+j)*3]=src[i*sx+j];\n\toutG[((i+1)*sx+(j+1))*3]=src[(i+1)*sx+(j+1)];\n\toutR[(i*sx+j+1)*3]=src[i*sx+j+1];\n\toutB[((i+1)*sx+j)*3]=src[(i+1)*sx+j];\n      }\n    }\n    // R channel\n    for (i=0;i<sy;i+=2) {\n      for (j=0;j<sx-1;j+=2) {\n\toutR[(i*sx+j)*3]=outR[(i*sx+j+1)*3];\n\toutR[((i+1)*sx+j+1)*3]=outR[(i*sx+j+1)*3];\n\toutR[((i+1)*sx+j)*3]=outR[(i*sx+j+1)*3];\n      }\n    }\n      // B channel\n    for (i=0;i<sy-1;i+=2)  { //every two lines\n      for (j=0;j<sx-1;j+=2) {\n\toutB[(i*sx+j)*3]=outB[((i+1)*sx+j)*3];\n\toutB[(i*sx+j+1)*3]=outB[((i+1)*sx+j)*3];\n\toutB[((i+1)*sx+j+1)*3]=outB[((i+1)*sx+j)*3];\n      }\n    }\n    // using lower direction for G channel\n      \n    // G channel\n    for (i=0;i<sy-1;i+=2)//every two lines\n      for (j=1;j<sx;j+=2)\n\toutG[(i*sx+j)*3]=outG[((i+1)*sx+j)*3];\n      \n    for (i=1;i<sy-2;i+=2)//every two lines\n      for (j=0;j<sx-1;j+=2)\n\toutG[(i*sx+j)*3]=outG[((i+1)*sx+j)*3];\n    \n    // copy it for the next line\n    for (j=0;j<sx-1;j+=2)\n      outG[((sy-1)*sx+j)*3]=outG[((sy-2)*sx+j)*3];\n    \n    break;\n  case BAYER_PATTERN_BGGR: //-------------------------------------------\n  case BAYER_PATTERN_RGGB:\n    // copy original data\n    for (i=0;i<sy;i+=2) {\n      for (j=0;j<sx;j+=2) {\n\toutB[(i*sx+j)*3]=src[i*sx+j];\n\toutR[((i+1)*sx+(j+1))*3]=src[(i+1)*sx+(j+1)];\n\toutG[(i*sx+j+1)*3]=src[i*sx+j+1];\n\toutG[((i+1)*sx+j)*3]=src[(i+1)*sx+j];\n      }\n    }\n    // R channel\n    for (i=0;i<sy;i+=2){\n      for (j=0;j<sx-1;j+=2) {\n\toutR[(i*sx+j)*3]=outR[((i+1)*sx+j+1)*3];\n\toutR[(i*sx+j+1)*3]=outR[((i+1)*sx+j+1)*3];\n\toutR[((i+1)*sx+j)*3]=outR[((i+1)*sx+j+1)*3];\n      }\n    }\n    // B channel\n    for (i=0;i<sy-1;i+=2) { //every two lines\n      for (j=0;j<sx-1;j+=2) {\n\toutB[((i+1)*sx+j)*3]=outB[(i*sx+j)*3];\n\toutB[(i*sx+j+1)*3]=outB[(i*sx+j)*3];\n\toutB[((i+1)*sx+j+1)*3]=outB[(i*sx+j)*3];\n      }\n    }\n    // using lower direction for G channel\n    \n    // G channel\n    for (i=0;i<sy-1;i+=2)//every two lines\n      for (j=0;j<sx-1;j+=2)\n\toutG[(i*sx+j)*3]=outG[((i+1)*sx+j)*3];\n    \n    for (i=1;i<sy-2;i+=2)//every two lines\n      for (j=0;j<sx-1;j+=2)\n\toutG[(i*sx+j+1)*3]=outG[((i+1)*sx+j+1)*3];\n    \n    // copy it for the next line\n    for (j=0;j<sx-1;j+=2)\n      outG[((sy-1)*sx+j+1)*3]=outG[((sy-2)*sx+j+1)*3];\n    \n    break;\n    \n  default:  //-------------------------------------------\n    break;\n  }\n}", "path": "lib\\SRC\\VideoLinux1394Cam\\conversions.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/**********************************************************************\n *\n *  CONVERSION FUNCTIONS TO RGB 24bpp \n *\n **********************************************************************/\n", "func_signal": "void\nrgb482rgb (unsigned char *src, unsigned char *dest, unsigned long long int NumPixels)", "code": "{\n  register int i = ((NumPixels + ( NumPixels << 1 )) << 1)-1;\n  register int j = NumPixels + ( NumPixels << 1 ) -1;\n\n  while (i > 0) {\n    i--;\n    dest[j--]=src[i--];\n    i--;\n    dest[j--]=src[i--];\n    i--;\n    dest[j--]=src[i--];\n  }\n}", "path": "lib\\SRC\\VideoLinux1394Cam\\conversions.c", "repo_name": "Moutarde/ARToolKit", "stars": 9, "license": "gpl-2.0", "language": "c", "size": 18241}
{"docstring": "/**\n * usb_hcd_ppc_soc_probe - initialize On-Chip HCDs\n * Context: !in_interrupt()\n *\n * Allocates basic resources for this USB host controller.\n *\n * Store this function in the HCD's struct pci_driver as probe().\n */\n", "func_signal": "static int usb_hcd_ppc_soc_probe(const struct hc_driver *driver,\n\t\t\t  struct platform_device *pdev)", "code": "{\n\tint retval;\n\tstruct usb_hcd *hcd;\n\tstruct ohci_hcd\t*ohci;\n\tstruct resource *res;\n\tint irq;\n\n\tpr_debug(\"initializing PPC-SOC USB Controller\\n\");\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tpr_debug(\"%s: no irq\\n\", __FILE__);\n\t\treturn -ENODEV;\n\t}\n\tirq = res->start;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tpr_debug(\"%s: no reg addr\\n\", __FILE__);\n\t\treturn -ENODEV;\n\t}\n\n\thcd = usb_create_hcd(driver, &pdev->dev, \"PPC-SOC USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = res->end - res->start + 1;\n\n\tif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\n\t\tpr_debug(\"%s: request_mem_region failed\\n\", __FILE__);\n\t\tretval = -EBUSY;\n\t\tgoto err1;\n\t}\n\n\thcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\n\tif (!hcd->regs) {\n\t\tpr_debug(\"%s: ioremap failed\\n\", __FILE__);\n\t\tretval = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tohci = hcd_to_ohci(hcd);\n\tohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;\n\n#ifdef CONFIG_PPC_MPC52xx\n\t/* MPC52xx doesn't need frame_no shift */\n\tohci->flags |= OHCI_QUIRK_FRAME_NO;\n#endif\n\tohci_hcd_init(ohci);\n\n\tretval = usb_add_hcd(hcd, irq, IRQF_DISABLED);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tpr_debug(\"Removing PPC-SOC USB Controller\\n\");\n\n\tiounmap(hcd->regs);\n err2:\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\n err1:\n\tusb_put_hcd(hcd);\n\treturn retval;\n}", "path": "drivers\\usb\\host\\ohci-ppc-soc.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* We have to create a fake left and right HP mixers because\n * the codec only has a single control that is shared by both channels.\n * This makes it impossible to determine the audio path.\n */\n", "func_signal": "static int mixer_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *k, int event)", "code": "{\n\tu16 l, r, beep, line, phone, mic, pcm, aux;\n\n\tl = ac97_read(w->codec, HPL_MIXER);\n\tr = ac97_read(w->codec, HPR_MIXER);\n\tbeep = ac97_read(w->codec, AC97_PC_BEEP);\n\tmic = ac97_read(w->codec, AC97_VIDEO);\n\tphone = ac97_read(w->codec, AC97_PHONE);\n\tline = ac97_read(w->codec, AC97_LINE);\n\tpcm = ac97_read(w->codec, AC97_PCM);\n\taux = ac97_read(w->codec, AC97_CD);\n\n\tif (l & 0x1 || r & 0x1)\n\t\tac97_write(w->codec, AC97_VIDEO, mic & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_VIDEO, mic | 0x8000);\n\n\tif (l & 0x2 || r & 0x2)\n\t\tac97_write(w->codec, AC97_PCM, pcm & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_PCM, pcm | 0x8000);\n\n\tif (l & 0x4 || r & 0x4)\n\t\tac97_write(w->codec, AC97_LINE, line & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_LINE, line | 0x8000);\n\n\tif (l & 0x8 || r & 0x8)\n\t\tac97_write(w->codec, AC97_PHONE, phone & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_PHONE, phone | 0x8000);\n\n\tif (l & 0x10 || r & 0x10)\n\t\tac97_write(w->codec, AC97_CD, aux & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_CD, aux | 0x8000);\n\n\tif (l & 0x20 || r & 0x20)\n\t\tac97_write(w->codec, AC97_PC_BEEP, beep & 0x7fff);\n\telse\n\t\tac97_write(w->codec, AC97_PC_BEEP, beep | 0x8000);\n\n\treturn 0;\n}", "path": "sound\\soc\\codecs\\wm9712.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* sun3_map_test(addr, val) -- Reads a byte from addr, storing to val,\n * trapping the potential read fault.  Returns 0 if the access faulted,\n * 1 on success.\n *\n * This function is primarily used to check addresses on the VME bus.\n *\n * Mucking with the page fault handler seems a little hackish to me, but\n * SunOS, NetBSD, and Mach all implemented this check in such a manner,\n * so I figure we're allowed.\n */\n", "func_signal": "int sun3_map_test(unsigned long addr, char *val)", "code": "{\n\tint ret = 0;\n\n\t__asm__ __volatile__\n\t\t(\".globl _sun3_map_test_start\\n\"\n\t\t \"_sun3_map_test_start:\\n\"\n\t\t \"1: moveb (%2), (%0)\\n\"\n\t\t \"   moveq #1, %1\\n\"\n\t\t \"2:\\n\"\n\t\t \".section .fixup,\\\"ax\\\"\\n\"\n\t\t \".even\\n\"\n\t\t \"3: moveq #0, %1\\n\"\n\t\t \"   jmp 2b\\n\"\n\t\t \".previous\\n\"\n\t\t \".section __ex_table,\\\"a\\\"\\n\"\n\t\t \".align 4\\n\"\n\t\t \".long 1b,3b\\n\"\n\t\t \".previous\\n\"\n\t\t \".globl _sun3_map_test_end\\n\"\n\t\t \"_sun3_map_test_end:\\n\"\n\t\t : \"=a\"(val), \"=r\"(ret)\n\t\t : \"a\"(addr));\n\n\treturn ret;\n}", "path": "arch\\m68k\\mm\\sun3kmap.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* 2166136261 */\n", "func_signal": "static unsigned int fnvhash32(const void *buf, size_t buflen)", "code": "{\n\tconst unsigned char *p, *end = (const unsigned char *)buf + buflen;\n\tunsigned int hash = FNV_1_32;\n\n\tfor (p = buf; p < end; p++) {\n\t\thash *= FNV_P_32;\n\t\thash ^= (unsigned int)*p;\n\t}\n\n\treturn hash;\n}", "path": "fs\\nfs\\idmap.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* Initialize the UCC for Slow operations\n *\n * The caller should initialize the following us_info\n */\n", "func_signal": "int ucc_slow_init(struct ucc_slow_info * us_info, struct ucc_slow_private ** uccs_ret)", "code": "{\n\tstruct ucc_slow_private *uccs;\n\tu32 i;\n\tstruct ucc_slow __iomem *us_regs;\n\tu32 gumr;\n\tstruct qe_bd *bd;\n\tu32 id;\n\tu32 command;\n\tint ret = 0;\n\n\tif (!us_info)\n\t\treturn -EINVAL;\n\n\t/* check if the UCC port number is in range. */\n\tif ((us_info->ucc_num < 0) || (us_info->ucc_num > UCC_MAX_NUM - 1)) {\n\t\tprintk(KERN_ERR \"%s: illegal UCC number\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Set mrblr\n\t * Check that 'max_rx_buf_length' is properly aligned (4), unless\n\t * rfw is 1, meaning that QE accepts one byte at a time, unlike normal\n\t * case when QE accepts 32 bits at a time.\n\t */\n\tif ((!us_info->rfw) &&\n\t\t(us_info->max_rx_buf_length & (UCC_SLOW_MRBLR_ALIGNMENT - 1))) {\n\t\tprintk(KERN_ERR \"max_rx_buf_length not aligned.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tuccs = kzalloc(sizeof(struct ucc_slow_private), GFP_KERNEL);\n\tif (!uccs) {\n\t\tprintk(KERN_ERR \"%s: Cannot allocate private data\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Fill slow UCC structure */\n\tuccs->us_info = us_info;\n\t/* Set the PHY base address */\n\tuccs->us_regs = ioremap(us_info->regs, sizeof(struct ucc_slow));\n\tif (uccs->us_regs == NULL) {\n\t\tprintk(KERN_ERR \"%s: Cannot map UCC registers\\n\", __func__);\n\t\tkfree(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\tuccs->saved_uccm = 0;\n\tuccs->p_rx_frame = 0;\n\tus_regs = uccs->us_regs;\n\tuccs->p_ucce = (u16 *) & (us_regs->ucce);\n\tuccs->p_uccm = (u16 *) & (us_regs->uccm);\n#ifdef STATISTICS\n\tuccs->rx_frames = 0;\n\tuccs->tx_frames = 0;\n\tuccs->rx_discarded = 0;\n#endif\t\t\t\t/* STATISTICS */\n\n\t/* Get PRAM base */\n\tuccs->us_pram_offset =\n\t\tqe_muram_alloc(UCC_SLOW_PRAM_SIZE, ALIGNMENT_OF_UCC_SLOW_PRAM);\n\tif (IS_ERR_VALUE(uccs->us_pram_offset)) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate MURAM for PRAM\", __func__);\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\tid = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);\n\tqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, id, us_info->protocol,\n\t\t     uccs->us_pram_offset);\n\n\tuccs->us_pram = qe_muram_addr(uccs->us_pram_offset);\n\n\t/* Set UCC to slow type */\n\tret = ucc_set_type(us_info->ucc_num, UCC_SPEED_TYPE_SLOW);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: cannot set UCC type\", __func__);\n\t\tucc_slow_free(uccs);\n\t\treturn ret;\n\t}\n\n\tout_be16(&uccs->us_pram->mrblr, us_info->max_rx_buf_length);\n\n\tINIT_LIST_HEAD(&uccs->confQ);\n\n\t/* Allocate BDs. */\n\tuccs->rx_base_offset =\n\t\tqe_muram_alloc(us_info->rx_bd_ring_len * sizeof(struct qe_bd),\n\t\t\t\tQE_ALIGNMENT_OF_BD);\n\tif (IS_ERR_VALUE(uccs->rx_base_offset)) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate %u RX BDs\\n\", __func__,\n\t\t\tus_info->rx_bd_ring_len);\n\t\tuccs->rx_base_offset = 0;\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\tuccs->tx_base_offset =\n\t\tqe_muram_alloc(us_info->tx_bd_ring_len * sizeof(struct qe_bd),\n\t\t\tQE_ALIGNMENT_OF_BD);\n\tif (IS_ERR_VALUE(uccs->tx_base_offset)) {\n\t\tprintk(KERN_ERR \"%s: cannot allocate TX BDs\", __func__);\n\t\tuccs->tx_base_offset = 0;\n\t\tucc_slow_free(uccs);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Init Tx bds */\n\tbd = uccs->confBd = uccs->tx_bd = qe_muram_addr(uccs->tx_base_offset);\n\tfor (i = 0; i < us_info->tx_bd_ring_len - 1; i++) {\n\t\t/* clear bd buffer */\n\t\tout_be32(&bd->buf, 0);\n\t\t/* set bd status and length */\n\t\tout_be32((u32 *) bd, 0);\n\t\tbd++;\n\t}\n\t/* for last BD set Wrap bit */\n\tout_be32(&bd->buf, 0);\n\tout_be32((u32 *) bd, cpu_to_be32(T_W));\n\n\t/* Init Rx bds */\n\tbd = uccs->rx_bd = qe_muram_addr(uccs->rx_base_offset);\n\tfor (i = 0; i < us_info->rx_bd_ring_len - 1; i++) {\n\t\t/* set bd status and length */\n\t\tout_be32((u32*)bd, 0);\n\t\t/* clear bd buffer */\n\t\tout_be32(&bd->buf, 0);\n\t\tbd++;\n\t}\n\t/* for last BD set Wrap bit */\n\tout_be32((u32*)bd, cpu_to_be32(R_W));\n\tout_be32(&bd->buf, 0);\n\n\t/* Set GUMR (For more details see the hardware spec.). */\n\t/* gumr_h */\n\tgumr = us_info->tcrc;\n\tif (us_info->cdp)\n\t\tgumr |= UCC_SLOW_GUMR_H_CDP;\n\tif (us_info->ctsp)\n\t\tgumr |= UCC_SLOW_GUMR_H_CTSP;\n\tif (us_info->cds)\n\t\tgumr |= UCC_SLOW_GUMR_H_CDS;\n\tif (us_info->ctss)\n\t\tgumr |= UCC_SLOW_GUMR_H_CTSS;\n\tif (us_info->tfl)\n\t\tgumr |= UCC_SLOW_GUMR_H_TFL;\n\tif (us_info->rfw)\n\t\tgumr |= UCC_SLOW_GUMR_H_RFW;\n\tif (us_info->txsy)\n\t\tgumr |= UCC_SLOW_GUMR_H_TXSY;\n\tif (us_info->rtsm)\n\t\tgumr |= UCC_SLOW_GUMR_H_RTSM;\n\tout_be32(&us_regs->gumr_h, gumr);\n\n\t/* gumr_l */\n\tgumr = us_info->tdcr | us_info->rdcr | us_info->tenc | us_info->renc |\n\t\tus_info->diag | us_info->mode;\n\tif (us_info->tci)\n\t\tgumr |= UCC_SLOW_GUMR_L_TCI;\n\tif (us_info->rinv)\n\t\tgumr |= UCC_SLOW_GUMR_L_RINV;\n\tif (us_info->tinv)\n\t\tgumr |= UCC_SLOW_GUMR_L_TINV;\n\tif (us_info->tend)\n\t\tgumr |= UCC_SLOW_GUMR_L_TEND;\n\tout_be32(&us_regs->gumr_l, gumr);\n\n\t/* Function code registers */\n\n\t/* if the data is in cachable memory, the 'global' */\n\t/* in the function code should be set. */\n\tuccs->us_pram->tbmr = UCC_BMR_BO_BE;\n\tuccs->us_pram->rbmr = UCC_BMR_BO_BE;\n\n\t/* rbase, tbase are offsets from MURAM base */\n\tout_be16(&uccs->us_pram->rbase, uccs->rx_base_offset);\n\tout_be16(&uccs->us_pram->tbase, uccs->tx_base_offset);\n\n\t/* Mux clocking */\n\t/* Grant Support */\n\tucc_set_qe_mux_grant(us_info->ucc_num, us_info->grant_support);\n\t/* Breakpoint Support */\n\tucc_set_qe_mux_bkpt(us_info->ucc_num, us_info->brkpt_support);\n\t/* Set Tsa or NMSI mode. */\n\tucc_set_qe_mux_tsa(us_info->ucc_num, us_info->tsa);\n\t/* If NMSI (not Tsa), set Tx and Rx clock. */\n\tif (!us_info->tsa) {\n\t\t/* Rx clock routing */\n\t\tif (ucc_set_qe_mux_rxtx(us_info->ucc_num, us_info->rx_clock,\n\t\t\t\t\tCOMM_DIR_RX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for RX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_slow_free(uccs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Tx clock routing */\n\t\tif (ucc_set_qe_mux_rxtx(us_info->ucc_num, us_info->tx_clock,\n\t\t\t\t\tCOMM_DIR_TX)) {\n\t\t\tprintk(KERN_ERR \"%s: illegal value for TX clock\\n\",\n\t\t\t       __func__);\n\t\t\tucc_slow_free(uccs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Set interrupt mask register at UCC level. */\n\tout_be16(&us_regs->uccm, us_info->uccm_mask);\n\n\t/* First, clear anything pending at UCC level,\n\t * otherwise, old garbage may come through\n\t * as soon as the dam is opened. */\n\n\t/* Writing '1' clears */\n\tout_be16(&us_regs->ucce, 0xffff);\n\n\t/* Issue QE Init command */\n\tif (us_info->init_tx && us_info->init_rx)\n\t\tcommand = QE_INIT_TX_RX;\n\telse if (us_info->init_tx)\n\t\tcommand = QE_INIT_TX;\n\telse\n\t\tcommand = QE_INIT_RX;\t/* We know at least one is TRUE */\n\n\tqe_issue_cmd(command, id, us_info->protocol, 0);\n\n\t*uccs_ret = uccs;\n\treturn 0;\n}", "path": "arch\\powerpc\\sysdev\\qe_lib\\ucc_slow.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_write_pm - Write Other LPM control registers.\n */\n", "func_signal": "void ps3_write_pm(u32 cpu, enum pm_reg_name reg, u32 val)", "code": "{\n\tint result = 0;\n\tu64 dummy;\n\n\tswitch (reg) {\n\tcase group_control:\n\t\tif (val != lpm_priv->shadow.group_control)\n\t\t\tresult = lv1_set_lpm_group_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t   val,\n\t\t\t\t\t\t\t   PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t   &dummy);\n\t\tlpm_priv->shadow.group_control = val;\n\t\tbreak;\n\tcase debug_bus_control:\n\t\tif (val != lpm_priv->shadow.debug_bus_control)\n\t\t\tresult = lv1_set_lpm_debug_bus_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t      val,\n\t\t\t\t\t\t\t      PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t      &dummy);\n\t\tlpm_priv->shadow.debug_bus_control = val;\n\t\tbreak;\n\tcase pm_control:\n\t\tif (use_start_stop_bookmark)\n\t\t\tval |= (PS3_PM_CONTROL_PPU_TH0_BOOKMARK |\n\t\t\t\tPS3_PM_CONTROL_PPU_TH1_BOOKMARK);\n\t\tif (val != lpm_priv->shadow.pm_control)\n\t\t\tresult = lv1_set_lpm_general_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t     val,\n\t\t\t\t\t\t\t     PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t     0, 0, &dummy,\n\t\t\t\t\t\t\t     &dummy);\n\t\tlpm_priv->shadow.pm_control = val;\n\t\tbreak;\n\tcase pm_interval:\n\t\tresult = lv1_set_lpm_interval(lpm_priv->lpm_id, val,\n\t\t\t\t\t      PS3_WRITE_PM_MASK, &dummy);\n\t\tbreak;\n\tcase pm_start_stop:\n\t\tif (val != lpm_priv->shadow.pm_start_stop)\n\t\t\tresult = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,\n\t\t\t\t\t\t\t     val,\n\t\t\t\t\t\t\t     PS3_WRITE_PM_MASK,\n\t\t\t\t\t\t\t     &dummy);\n\t\tlpm_priv->shadow.pm_start_stop = val;\n\t\tbreak;\n\tcase trace_address:\n\tcase ext_tr_timer:\n\tcase pm_status:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sbd_core(), \"%s:%u: unknown reg: %d\\n\", __func__,\n\t\t\t__LINE__, reg);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1 set_control failed: \"\n\t\t\t\"reg %u, %s\\n\", __func__, __LINE__, reg,\n\t\t\tps3_result(result));\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_disable_pm - Disable the entire performance monitoring unit.\n */\n", "func_signal": "void ps3_disable_pm(u32 cpu)", "code": "{\n\tint result;\n\tu64 tmp;\n\n\tps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_STOP);\n\n\tresult = lv1_stop_lpm(lpm_priv->lpm_id, &tmp);\n\n\tif (result) {\n\t\tif(result != LV1_WRONG_STATE)\n\t\t\tdev_err(sbd_core(), \"%s:%u: lv1_stop_lpm failed: %s\\n\",\n\t\t\t\t__func__, __LINE__, ps3_result(result));\n\t\treturn;\n\t}\n\n\tlpm_priv->tb_count = tmp;\n\n\tdev_dbg(sbd_core(), \"%s:%u: tb_count %llu (%llxh)\\n\", __func__, __LINE__,\n\t\tlpm_priv->tb_count, lpm_priv->tb_count);\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/*\n * ID -> Name\n */\n", "func_signal": "static int\nnfs_idmap_name(struct idmap *idmap, struct idmap_hashtable *h,\n\t\t__u32 id, char *name)", "code": "{\n\tstruct rpc_pipe_msg msg;\n\tstruct idmap_msg *im;\n\tstruct idmap_hashent *he;\n\tDECLARE_WAITQUEUE(wq, current);\n\tint ret = -EIO;\n\tunsigned int len;\n\n\tim = &idmap->idmap_im;\n\n\tmutex_lock(&idmap->idmap_lock);\n\tmutex_lock(&idmap->idmap_im_lock);\n\n\the = idmap_lookup_id(h, id);\n\tif (he) {\n\t\tmemcpy(name, he->ih_name, he->ih_namelen);\n\t\tret = he->ih_namelen;\n\t\tgoto out;\n\t}\n\n\tmemset(im, 0, sizeof(*im));\n\tim->im_type = h->h_type;\n\tim->im_conv = IDMAP_CONV_IDTONAME;\n\tim->im_id = id;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = im;\n\tmsg.len = sizeof(*im);\n\n\tadd_wait_queue(&idmap->idmap_wq, &wq);\n\n\tif (rpc_queue_upcall(idmap->idmap_dentry->d_inode, &msg) < 0) {\n\t\tremove_wait_queue(&idmap->idmap_wq, &wq);\n\t\tgoto out;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tmutex_unlock(&idmap->idmap_im_lock);\n\tschedule();\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&idmap->idmap_wq, &wq);\n\tmutex_lock(&idmap->idmap_im_lock);\n\n\tif (im->im_status & IDMAP_STATUS_SUCCESS) {\n\t\tif ((len = strnlen(im->im_name, IDMAP_NAMESZ)) == 0)\n\t\t\tgoto out;\n\t\tmemcpy(name, im->im_name, len);\n\t\tret = len;\n\t}\n\n out:\n\tmemset(im, 0, sizeof(*im));\n\tmutex_unlock(&idmap->idmap_im_lock);\n\tmutex_unlock(&idmap->idmap_lock);\n\treturn ret;\n}", "path": "fs\\nfs\\idmap.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_write_ctr - Write counter.\n *\n * Write 16 or 32 bits depending on the current size of the counter.\n * Counters 4, 5, 6 & 7 are always 16 bit.\n */\n", "func_signal": "void ps3_write_ctr(u32 cpu, u32 ctr, u32 val)", "code": "{\n\tu32 phys_ctr;\n\tu32 phys_val;\n\n\tphys_ctr = ctr & (NR_PHYS_CTRS - 1);\n\n\tif (ps3_get_ctr_size(cpu, phys_ctr) == 16) {\n\t\tphys_val = ps3_read_phys_ctr(cpu, phys_ctr);\n\n\t\tif (ctr < NR_PHYS_CTRS)\n\t\t\tval = (val << 16) | (phys_val & 0xffff);\n\t\telse\n\t\t\tval = (val & 0xffff) | (phys_val & 0xffff0000);\n\t}\n\n\tps3_write_phys_ctr(cpu, phys_ctr, val);\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_read_ctr - Read counter.\n *\n * Read 16 or 32 bits depending on the current size of the counter.\n * Counters 4, 5, 6 & 7 are always 16 bit.\n */\n", "func_signal": "u32 ps3_read_ctr(u32 cpu, u32 ctr)", "code": "{\n\tu32 val;\n\tu32 phys_ctr = ctr & (NR_PHYS_CTRS - 1);\n\n\tval = ps3_read_phys_ctr(cpu, phys_ctr);\n\n\tif (ps3_get_ctr_size(cpu, phys_ctr) == 16)\n\t\tval = (ctr < NR_PHYS_CTRS) ? (val >> 16) : (val & 0xffff);\n\n\treturn val;\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_read_phys_ctr - Read physical counter registers.\n *\n * Each physical counter can act as one 32 bit counter or as two 16 bit\n * counters.\n */\n", "func_signal": "u32 ps3_read_phys_ctr(u32 cpu, u32 phys_ctr)", "code": "{\n\tint result;\n\tu64 counter0415;\n\tu64 counter2637;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn 0;\n\t}\n\n\tresult = lv1_set_lpm_counter(lpm_priv->lpm_id, 0, 0, 0, 0, &counter0415,\n\t\t\t\t     &counter2637);\n\tif (result) {\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_set_lpm_counter failed: \"\n\t\t\t\"phys_ctr %u, %s\\n\", __func__, __LINE__, phys_ctr,\n\t\t\tps3_result(result));\n\t\treturn 0;\n\t}\n\n\tswitch (phys_ctr) {\n\tcase 0:\n\t\treturn counter0415 >> 32;\n\tcase 1:\n\t\treturn counter0415 & PS3_PM_COUNTER_MASK_LO;\n\tcase 2:\n\t\treturn counter2637 >> 32;\n\tcase 3:\n\t\treturn counter2637 & PS3_PM_COUNTER_MASK_LO;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_lpm_open - Open the logical performance monitor device.\n * @tb_type: Specifies the type of trace buffer lv1 should use for this lpm\n *  instance, specified by one of enum ps3_lpm_tb_type.\n * @tb_cache: Optional user supplied buffer to use as the trace buffer cache.\n *  If NULL, the driver will allocate and manage an internal buffer.\n *  Unused when when @tb_type is PS3_LPM_TB_TYPE_NONE.\n * @tb_cache_size: The size in bytes of the user supplied @tb_cache buffer.\n *  Unused when @tb_cache is NULL or @tb_type is PS3_LPM_TB_TYPE_NONE.\n */\n", "func_signal": "int ps3_lpm_open(enum ps3_lpm_tb_type tb_type, void *tb_cache,\n\tu64 tb_cache_size)", "code": "{\n\tint result;\n\tu64 tb_size;\n\n\tBUG_ON(!lpm_priv);\n\tBUG_ON(tb_type != PS3_LPM_TB_TYPE_NONE\n\t\t&& tb_type != PS3_LPM_TB_TYPE_INTERNAL);\n\n\tif (tb_type == PS3_LPM_TB_TYPE_NONE && tb_cache)\n\t\tdev_dbg(sbd_core(), \"%s:%u: bad in vals\\n\", __func__, __LINE__);\n\n\tif (!atomic_add_unless(&lpm_priv->open, 1, 1)) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: busy\\n\", __func__, __LINE__);\n\t\treturn -EBUSY;\n\t}\n\n\t/* Note tb_cache needs 128 byte alignment. */\n\n\tif (tb_type == PS3_LPM_TB_TYPE_NONE) {\n\t\tlpm_priv->tb_cache_size = 0;\n\t\tlpm_priv->tb_cache_internal = NULL;\n\t\tlpm_priv->tb_cache = NULL;\n\t} else if (tb_cache) {\n\t\tif (tb_cache != (void *)_ALIGN_UP((unsigned long)tb_cache, 128)\n\t\t\t|| tb_cache_size != _ALIGN_UP(tb_cache_size, 128)) {\n\t\t\tdev_err(sbd_core(), \"%s:%u: unaligned tb_cache\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto fail_align;\n\t\t}\n\t\tlpm_priv->tb_cache_size = tb_cache_size;\n\t\tlpm_priv->tb_cache_internal = NULL;\n\t\tlpm_priv->tb_cache = tb_cache;\n\t} else {\n\t\tlpm_priv->tb_cache_size = PS3_LPM_DEFAULT_TB_CACHE_SIZE;\n\t\tlpm_priv->tb_cache_internal = kzalloc(\n\t\t\tlpm_priv->tb_cache_size + 127, GFP_KERNEL);\n\t\tif (!lpm_priv->tb_cache_internal) {\n\t\t\tdev_err(sbd_core(), \"%s:%u: alloc internal tb_cache \"\n\t\t\t\t\"failed\\n\", __func__, __LINE__);\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto fail_malloc;\n\t\t}\n\t\tlpm_priv->tb_cache = (void *)_ALIGN_UP(\n\t\t\t(unsigned long)lpm_priv->tb_cache_internal, 128);\n\t}\n\n\tresult = lv1_construct_lpm(lpm_priv->node_id, tb_type, 0, 0,\n\t\t\t\tps3_mm_phys_to_lpar(__pa(lpm_priv->tb_cache)),\n\t\t\t\tlpm_priv->tb_cache_size, &lpm_priv->lpm_id,\n\t\t\t\t&lpm_priv->outlet_id, &tb_size);\n\n\tif (result) {\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_construct_lpm failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\t\tresult = -EINVAL;\n\t\tgoto fail_construct;\n\t}\n\n\tlpm_priv->shadow.pm_control = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.pm_start_stop = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.group_control = PS3_LPM_SHADOW_REG_INIT;\n\tlpm_priv->shadow.debug_bus_control = PS3_LPM_SHADOW_REG_INIT;\n\n\tdev_dbg(sbd_core(), \"%s:%u: lpm_id 0x%llx, outlet_id 0x%llx, \"\n\t\t\"tb_size 0x%llx\\n\", __func__, __LINE__, lpm_priv->lpm_id,\n\t\tlpm_priv->outlet_id, tb_size);\n\n\treturn 0;\n\nfail_construct:\n\tkfree(lpm_priv->tb_cache_internal);\n\tlpm_priv->tb_cache_internal = NULL;\nfail_malloc:\nfail_align:\n\tatomic_dec(&lpm_priv->open);\n\treturn result;\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * usb_hcd_ppc_soc_remove - shutdown processing for On-Chip HCDs\n * @pdev: USB Host Controller being removed\n * Context: !in_interrupt()\n *\n * Reverses the effect of usb_hcd_ppc_soc_probe().\n * It is always called from a thread\n * context, normally \"rmmod\", \"apmd\", or something similar.\n *\n */\n", "func_signal": "static void usb_hcd_ppc_soc_remove(struct usb_hcd *hcd,\n\t\tstruct platform_device *pdev)", "code": "{\n\tusb_remove_hcd(hcd);\n\n\tpr_debug(\"stopping PPC-SOC USB Controller\\n\");\n\n\tiounmap(hcd->regs);\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\n\tusb_put_hcd(hcd);\n}", "path": "drivers\\usb\\host\\ohci-ppc-soc.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* Must be called with fan_data->lock held, except during initialization. */\n", "func_signal": "static void set_fan_speed(struct gpio_fan_data *fan_data, int speed_index)", "code": "{\n\tif (fan_data->speed_index == speed_index)\n\t\treturn;\n\n\t__set_fan_ctrl(fan_data, fan_data->speed[speed_index].ctrl_val);\n\tfan_data->speed_index = speed_index;\n}", "path": "drivers\\hwmon\\gpio-fan.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_enable_pm - Enable the entire performance monitoring unit.\n *\n * When we enable the LPM, all pending writes to counters get committed.\n */\n", "func_signal": "void ps3_enable_pm(u32 cpu)", "code": "{\n\tint result;\n\tu64 tmp;\n\tint insert_bookmark = 0;\n\n\tlpm_priv->tb_count = 0;\n\n\tif (use_start_stop_bookmark) {\n\t\tif (!(lpm_priv->shadow.pm_start_stop &\n\t\t\t(PS3_PM_START_STOP_START_MASK\n\t\t\t| PS3_PM_START_STOP_STOP_MASK))) {\n\t\t\tresult = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,\n\t\t\t\t(PS3_PM_START_STOP_PPU_TH0_BOOKMARK_START |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH1_BOOKMARK_START |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH0_BOOKMARK_STOP |\n\t\t\t\tPS3_PM_START_STOP_PPU_TH1_BOOKMARK_STOP),\n\t\t\t\t0xFFFFFFFFFFFFFFFFULL, &tmp);\n\n\t\t\tif (result)\n\t\t\t\tdev_err(sbd_core(), \"%s:%u: \"\n\t\t\t\t\t\"lv1_set_lpm_trigger_control failed: \"\n\t\t\t\t\t\"%s\\n\", __func__, __LINE__,\n\t\t\t\t\tps3_result(result));\n\n\t\t\tinsert_bookmark = !result;\n\t\t}\n\t}\n\n\tresult = lv1_start_lpm(lpm_priv->lpm_id);\n\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_start_lpm failed: %s\\n\",\n\t\t\t__func__, __LINE__, ps3_result(result));\n\n\tif (use_start_stop_bookmark && !result && insert_bookmark)\n\t\tps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_START);\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* Name -> ID */\n", "func_signal": "static int nfs_idmap_lookup_id(const char *name, size_t namelen,\n\t\t\t\tconst char *type, __u32 *id)", "code": "{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tlong id_long;\n\tssize_t data_size;\n\tint ret = 0;\n\n\tdata_size = nfs_idmap_request_key(name, namelen, type, id_str, NFS_UINT_MAXLEN);\n\tif (data_size <= 0) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = strict_strtol(id_str, 10, &id_long);\n\t\t*id = (__u32)id_long;\n\t}\n\treturn ret;\n}", "path": "fs\\nfs\\idmap.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/* ID -> Name */\n", "func_signal": "static ssize_t nfs_idmap_lookup_name(__u32 id, const char *type, char *buf, size_t buflen)", "code": "{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tint id_len;\n\tssize_t ret;\n\n\tid_len = snprintf(id_str, sizeof(id_str), \"%u\", id);\n\tret = nfs_idmap_request_key(id_str, id_len, type, buf, buflen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn ret;\n}", "path": "fs\\nfs\\idmap.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/*\n * Alarm GPIO.\n */\n", "func_signal": "static void fan_alarm_notify(struct work_struct *ws)", "code": "{\n\tstruct gpio_fan_data *fan_data =\n\t\tcontainer_of(ws, struct gpio_fan_data, alarm_work);\n\n\tsysfs_notify(&fan_data->pdev->dev.kobj, NULL, \"fan1_alarm\");\n\tkobject_uevent(&fan_data->pdev->dev.kobj, KOBJ_CHANGE);\n}", "path": "drivers\\hwmon\\gpio-fan.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_write_phys_ctr - Write physical counter registers.\n *\n * Each physical counter can act as one 32 bit counter or as two 16 bit\n * counters.\n */\n", "func_signal": "void ps3_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val)", "code": "{\n\tu64 counter0415;\n\tu64 counter0415_mask;\n\tu64 counter2637;\n\tu64 counter2637_mask;\n\tint result;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn;\n\t}\n\n\tswitch (phys_ctr) {\n\tcase 0:\n\t\tcounter0415 = (u64)val << 32;\n\t\tcounter0415_mask = PS3_PM_COUNTER_MASK_HI;\n\t\tcounter2637 = 0x0;\n\t\tcounter2637_mask = 0x0;\n\t\tbreak;\n\tcase 1:\n\t\tcounter0415 = (u64)val;\n\t\tcounter0415_mask = PS3_PM_COUNTER_MASK_LO;\n\t\tcounter2637 = 0x0;\n\t\tcounter2637_mask = 0x0;\n\t\tbreak;\n\tcase 2:\n\t\tcounter0415 = 0x0;\n\t\tcounter0415_mask = 0x0;\n\t\tcounter2637 = (u64)val << 32;\n\t\tcounter2637_mask = PS3_PM_COUNTER_MASK_HI;\n\t\tbreak;\n\tcase 3:\n\t\tcounter0415 = 0x0;\n\t\tcounter0415_mask = 0x0;\n\t\tcounter2637 = (u64)val;\n\t\tcounter2637_mask = PS3_PM_COUNTER_MASK_LO;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tresult = lv1_set_lpm_counter(lpm_priv->lpm_id,\n\t\t\t\t     counter0415, counter0415_mask,\n\t\t\t\t     counter2637, counter2637_mask,\n\t\t\t\t     &counter0415, &counter2637);\n\tif (result)\n\t\tdev_err(sbd_core(), \"%s:%u: lv1_set_lpm_counter failed: \"\n\t\t\t\"phys_ctr %u, val %u, %s\\n\", __func__, __LINE__,\n\t\t\tphys_ctr, val, ps3_result(result));\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/**\n * ps3_get_ctr_size - Get the size of a physical counter.\n *\n * Returns either 16 or 32.\n */\n", "func_signal": "u32 ps3_get_ctr_size(u32 cpu, u32 phys_ctr)", "code": "{\n\tu32 pm_ctrl;\n\n\tif (phys_ctr >= NR_PHYS_CTRS) {\n\t\tdev_dbg(sbd_core(), \"%s:%u: phys_ctr too big: %u\\n\", __func__,\n\t\t\t__LINE__, phys_ctr);\n\t\treturn 0;\n\t}\n\n\tpm_ctrl = ps3_read_pm(cpu, pm_control);\n\treturn (pm_ctrl & CBE_PM_16BIT_CTR(phys_ctr)) ? 16 : 32;\n}", "path": "drivers\\ps3\\ps3-lpm.c", "repo_name": "psomas/lguest64", "stars": 12, "license": "other", "language": "c", "size": 429693}
{"docstring": "/*\n * helper routines to debug output of parser stage\n */\n", "func_signal": "static void\nstmt_out(StringInfo ds, Plpsm_stmt *stmt, int nested_level)", "code": "{\n\tchar *ident = pstrdup(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\");\n\n\tif (stmt == NULL)\n\t\treturn;\n\tident[nested_level] = '\\0';\n\n\tappendStringInfo(ds, \"%s+--------------------------------------------------\\n\", ident);\n\tappendStringInfo(ds, \"%s| debug for <<%s>>\\n\", ident, parser_stmt_name(stmt->typ));\n\tappendStringInfo(ds, \"%s+--------------------------------------------------\\n\", ident);\n\tappendStringInfo(ds, \"%s| Name: %s\\n\", ident, stmt->name);\n\tappendStringInfo(ds, \"%s| Target: \", ident);\n\tpqualid_out(ds, stmt->target);\n\n\tif (stmt->typ == PLPSM_STMT_SET && stmt->subscripts != NULL)\n\t{\n\t\tint\ti = 0;\n\t\twhile (i < MAXDIM && stmt->subscripts[i] != NULL)\n\t\t{\n\t\t\tappendStringInfoChar(ds, '[');\n\t\t\tesql_out(ds, stmt->subscripts[i]);\n\t\t\tappendStringInfoChar(ds, ']');\n\t\t\ti++;\n\t\t}\n\t}\n\n\tappendStringInfoChar(ds, '\\n');\n\tappendStringInfo(ds, \"%s| Compound target: \", ident);\n\tpqualid_list_out(ds,stmt->compound_target);\n\tappendStringInfoChar(ds,'\\n');\n\tappendStringInfo(ds, \"%s| Variables: \", ident);\n\tpqualid_list_out(ds, stmt->variables);\n\tappendStringInfoChar(ds, '\\n');\n\tif (stmt->typ == PLPSM_STMT_SIGNAL)\n\t\tappendStringInfo(ds, \"%s| Option: %s\\n\", ident, unpack_sql_state(stmt->option));\n\telse\n\t\tappendStringInfo(ds, \"%s| Option: %d\\n\", ident, stmt->option);\n\tappendStringInfo(ds, \"%s| ESQL: \", ident);\n\tesql_out(ds, stmt->esql);\n\tappendStringInfoChar(ds, '\\n');\n\tappendStringInfo(ds, \"%s| ESQL list: \", ident);\n\tesql_list_out(ds, stmt->esql_list);\n\tappendStringInfoChar(ds, '\\n');\n\n\tswitch (stmt->typ)\n\t{\n\t\tcase PLPSM_STMT_FOR:\n\t\t\t{\n\t\t\t\tappendStringInfo(ds, \"%s| Data: loopvar:%s, cursor:%s\\n\", ident,\n\t\t\t\t\t\t\t\t\t\tstmt->stmtfor.loopvar_name,\n\t\t\t\t\t\t\t\t\t\tstmt->stmtfor.cursor_name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PLPSM_STMT_DECLARE_HANDLER:\n\t\t\t{\n\t\t\t\tPlpsm_condition_value *condition = (Plpsm_condition_value *) stmt->data;\n\t\t\t\tappendStringInfo(ds, \"%s| condtions:\", ident);\n\t\t\t\twhile (condition != NULL)\n\t\t\t\t{\n\t\t\t\t\tswitch (condition->typ)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase PLPSM_SQLSTATE:\n\t\t\t\t\t\t\tappendStringInfo(ds, \" %s\", unpack_sql_state(condition->sqlstate));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PLPSM_SQLEXCEPTION:\n\t\t\t\t\t\t\tappendStringInfoString(ds, \" SQLEXCEPTION\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PLPSM_SQLWARNING:\n\t\t\t\t\t\t\tappendStringInfoString(ds, \" SQLWARNING\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PLPSM_CONDITION_NAME:\n\t\t\t\t\t\t\tappendStringInfo(ds, \" %s\", condition->condition_name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcondition = condition->next;\n\t\t\t\t}\n\t\t\t\tappendStringInfoChar(ds, '\\n');\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PLPSM_STMT_SIGNAL:\n\t\tcase PLPSM_STMT_RESIGNAL:\n\t\t\t{\n\t\t\t\tPlpsm_signal_info *sinfo = (Plpsm_signal_info *) stmt->data;\n\t\t\t\tif (sinfo != NULL)\n\t\t\t\t{\n\t\t\t\t\tappendStringInfo(ds, \"%s| info:\", ident);\n\t\t\t\t\twhile (sinfo != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (sinfo->typ)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase PLPSM_SINFO_DETAIL:\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" DETAIL=\");\n\t\t\t\t\t\t\t\tif (sinfo->var != NULL)\n\t\t\t\t\t\t\t\t\tpqualid_out(ds, sinfo->var);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tappendStringInfoString(ds, sinfo->value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_SINFO_HINT:\n\t\t\t\t\t\t\t\tappendStringInfo(ds, \" HINT=\");\n\t\t\t\t\t\t\t\tif (sinfo->var != NULL)\n\t\t\t\t\t\t\t\t\tpqualid_out(ds, sinfo->var);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tappendStringInfoString(ds, sinfo->value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_SINFO_MESSAGE:\n\t\t\t\t\t\t\t\tappendStringInfo(ds, \" MESSAGE=\");\n\t\t\t\t\t\t\t\tif (sinfo->var != NULL)\n\t\t\t\t\t\t\t\t\tpqualid_out(ds, sinfo->var);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tappendStringInfoString(ds, sinfo->value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsinfo = sinfo->next;\n\t\t\t\t\t}\n\t\t\t\t\tappendStringInfoChar(ds, '\\n');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PLPSM_STMT_GET_DIAGNOSTICS:\n\t\t\t{\n\t\t\t\tPlpsm_gd_info *gdinfo = (Plpsm_gd_info *) stmt->data;\n\t\t\t\tif (gdinfo != NULL)\n\t\t\t\t{\n\t\t\t\t\tpqualid_out(ds, gdinfo->target);\n\t\t\t\t\tappendStringInfo(ds, \"%s| info:\", ident);\n\t\t\t\t\twhile (gdinfo != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (gdinfo->typ)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_DETAIL:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = DETAIL_TEXT\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_HINT:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = HINT_TEXT\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_MESSAGE:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = MESSAGE_TEXT\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_SQLSTATE:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = SQLSTATE\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_SQLCODE:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = SQLCODE\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_ROW_COUNT:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = ROW_COUNT\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLPSM_GDINFO_CONDITION_IDENTIFIER:\n\t\t\t\t\t\t\t\tappendStringInfoString(ds, \" = CONDITION_IDENTIFIER\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t/* be compiler quite */;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgdinfo = gdinfo->next;\n\t\t\t\t\t}\n\t\t\t\t\tappendStringInfoChar(ds, '\\n');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t/* do nothing */ ;\n\t}\n\n\tappendStringInfo(ds, \"%s| Inner left:\\n\", ident);\n\tstmt_out(ds, stmt->inner_left, nested_level + 1);\n\tappendStringInfo(ds, \"%s| Inner right:\\n\", ident);\n\tstmt_out(ds, stmt->inner_right, nested_level + 1);\n\tif (stmt->next != NULL)\n\t{\n\t\tappendStringInfo(ds, \"%s\\n\", ident);\n\t\tstmt_out(ds, stmt->next, nested_level);\n\t}\n\telse\n\t\tappendStringInfo(ds, \"%s+-------------------------------\\n\", ident);\n\n\tpfree(ident);\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * when optional_endtoken is true, then expression can be finished\n * without identification of any until_tokens.\n */\n", "func_signal": "static Plpsm_ESQL *\nread_embeded_sql(int until1,\n\t\t\tint until2,\n\t\t\tint until3,\n\t\t\tconst char *expected,\n\t\t\tPlpsm_esql_type expected_type,\n\t\t\tbool valid_sql,\n\t\t\tint *endtoken,\n\t\t\tint startlocation,\n\t\t\tOid *typoid,\n\t\t\tint32 *typmod)", "code": "{\n\tint\t\t\t\tparenlevel = 0;\n\tint tok;\n\tStringInfoData\t\tds;\n\tPlpsm_ESQL\t*esql = palloc(sizeof(Plpsm_ESQL));\n\tbool\tfirst_token = true;\n\n\tesql->typ = expected_type;\n\n\tinitStringInfo(&ds);\n\n\tfor (;;)\n\t{\n\t\t/* read a current location before you read a next tag */\n\t\ttok = yylex();\n\n\t\tif (first_token && tok == SELECT)\n\t\t{\n\t\t\t/* comma isn't separator in end tag in this case */\n\t\t\tuntil2 = -1;\n\t\t\tfirst_token = false;\n\t\t\tesql->typ = PLPSM_ESQL_QUERY;\n\t\t}\n\t\telse\n\t\t\tfirst_token = false;\n\n\t\tif (startlocation < 0)\n\t\t\tstartlocation = yylloc;\n\n\t\t/* \n\t\t * When until1 is semicolon, then endtag is optional.\n\t\t * Any lists, or SQLs must not contains a zero tag and must not\n\t\t * contains a semicolon - but, parenlevel must be zero for\n\t\t * leaving cycle.\n\t\t */\n\t\tif (tok == until1 || tok == until2 || tok == until3 || (until1 == ';' && tok == 0))\n\t\t{\n\t\t\t/* don't want to leave early - etc SET a = (10,20), b = .. */\n\t\t\tif (tok == ';' || tok == 0 || parenlevel == 0 || \n\t\t\t\t\t(tok == ')' && parenlevel == 0) ||\n\t\t\t\t\t(tok == ']' && parenlevel == 0) ||\n\t\t\t\t\t(tok == ',' && parenlevel == 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tok == '(' || tok == '[')\n\t\t\tparenlevel++;\n\t\telse if (tok == ')' || tok == ']')\n\t\t{\n\t\t\tparenlevel--;\n\t\t\tif (parenlevel < 0)\n\t\t\t\tyyerror(\"mismatched parentheses\");\n\t\t}\n\n\t\t/* special rules for plpgsql users. Datatype cannot to contain '=' */\n\t\tif (tok == '=' && expected_type == PLPSM_ESQL_DATATYPE)\n\t\t{\n\t\t\tplpsm_push_back_token(tok);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* PSM keywords without a few exceptions are prohibited */\n\t\tswitch (tok)\n\t\t{\n\t\t\tcase BEGIN:\n\t\t\tcase CLOSE:\n\t\t\tcase CONDITION:\n\t\t\tcase CURSOR:\n\t\t\tcase DECLARE:\n\t\t\tcase DEFAULT:\n\t\t\tcase DO:\n\t\t\tcase ELSEIF:\n\t\t\tcase EXIT:\n\t\t\tcase FETCH:\n\t\t\tcase FOR:\n\t\t\tcase HANDLER:\n\t\t\tcase IF:\n\t\t\tcase ITERATE:\n\t\t\tcase LEAVE:\n\t\t\tcase LOOP:\n\t\t\tcase OPEN:\n\t\t\tcase PREPARE:\n\t\t\tcase PRINT:\n\t\t\tcase REPEAT:\n\t\t\tcase RETURN:\n\t\t\tcase SIGNAL:\n\t\t\tcase WHILE:\n\t\t\tcase UNTIL:\n\t\t\tcase GET:\n\t\t\t\tyyerror(\"using not allowed PLPSM keyword\");\n\t\t}\n\n\t\t/* expression, or query, or dataype must not contains a semicolon ever */\n\t\tif (tok == ';')\n\t\t{\n\t\t\tplpsm_push_back_token(tok);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tok == 0)\n\t\t{\n\t\t\tif (parenlevel != 0)\n\t\t\t\tyyerror(\"mismatched parentheses\");\n\n\t\t\t/*\n\t\t\t * Probably there can be a missing token, if object is\n\t\t\t * SQL expression, then try to verify expression first, there\n\t\t\t * can be more early detected missing symbol.\n\t\t\t */\n\t\t\tif (esql->typ == PLPSM_ESQL_EXPR)\n\t\t\t{\n\t\t\t\tStringInfoData\tbexpr;\n\n\t\t\t\tif (startlocation >= yylloc)\n\t\t\t\t\tyyerror(\"missing expression\");\n\n\t\t\t\tinitStringInfo(&bexpr);\n\t\t\t\tappendStringInfoString(&bexpr, \"SELECT (\");\n\t\t\t\tplpsm_append_source_text(&bexpr, startlocation, yylloc);\n\t\t\t\tcheck_sql_expr(bexpr.data, startlocation, strlen(\"SELECT (\"));\n\t\t\t\tpfree(bexpr.data);\n\t\t\t}\n\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"missing \\\"%s\\\" at end of SQL expression\",\n\t\t\t\t\t\t\t\t\t\t    expected),\n\t\t\t\t\t parser_errposition(yylloc)));\n\t\t}\n\t}\n\n\tif (parenlevel != 0)\n\t\tyyerror(\"mismatched parentheses\");\n\n\tif (endtoken)\n\t\t*endtoken = tok;\n\n\tif (esql->typ == PLPSM_ESQL_EXPR)\n\t{\n\t\tStringInfoData\tbexpr;\n\n\t\tif (startlocation >= yylloc)\n\t\t\tyyerror(\"missing expression\");\n\t\t\n\t\tplpsm_append_source_text(&ds, startlocation, yylloc);\n\n\t\tif (valid_sql)\n\t\t{\n\t\t\tinitStringInfo(&bexpr);\n\t\t\tappendStringInfoString(&bexpr, \"SELECT (\");\n\t\t\tplpsm_append_source_text(&bexpr, startlocation, yylloc);\n\t\t\tappendStringInfoChar(&bexpr, ')');\n\t\t\tcheck_sql_expr(bexpr.data, startlocation, strlen(\"SELECT (\"));\n\t\t\tpfree(bexpr.data);\n\t\t}\n\t}\n\telse if (esql->typ == PLPSM_ESQL_DATATYPE)\n\t{\n\t\tif (startlocation >= yylloc)\n\t\t\tyyerror(\"missing data type\");\n\n\t\tplpsm_append_source_text(&ds, startlocation, yylloc);\n\t\tparse_datatype(ds.data, startlocation, typoid, typmod);\n\t}\n\telse\n\t{\n\t\tplpsm_append_source_text(&ds, startlocation, yylloc);\n\n\t\tif (valid_sql)\n\t\t\tcheck_sql_expr(ds.data, startlocation, 0);\n\t}\n\n\tesql->location = startlocation;\n\tesql->lineno = plpsm_location_to_lineno(startlocation);\n\tesql->sqlstr = ds.data;\n\n\t/* try to truncate from right a returned string */\n\twhile (isspace(ds.data[ds.len - 1]))\n\t\tds.data[--ds.len] = '\\0';\n\n\t/* semicolon is usually returned back */\n\tif (tok == ';' || tok == ',')\n\t\tplpsm_push_back_token(tok);\n\n\treturn esql;\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Internal yylex function.  This wraps the core lexer and adds one feature:\n * a token pushback stack.\tWe also make a couple of trivial single-token\n * translations from what the core lexer does to what we want, in particular\n * interfacing from the core_YYSTYPE to YYSTYPE union.\n */\n", "func_signal": "static int\ninternal_yylex(TokenAuxData *auxdata)", "code": "{\n\tint\t\t\ttoken;\n\tconst char *yytext;\n\n\tif (num_pushbacks > 0)\n\t{\n\t\tnum_pushbacks--;\n\t\ttoken = pushback_token[num_pushbacks];\n\t\t*auxdata = pushback_auxdata[num_pushbacks];\n\t}\n\telse\n\t{\n\t\ttoken = core_yylex(&auxdata->lval.core_yystype,\n\t\t\t\t\t\t   &auxdata->lloc,\n\t\t\t\t\t\t   yyscanner);\n\n\t\t/* remember the length of yytext before it gets changed */\n\t\tyytext = core_yy.scanbuf + auxdata->lloc;\n\t\tauxdata->leng = strlen(yytext);\n\t}\n\n\treturn token;\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * ensure so end label is same as begin label\n */\n", "func_signal": "static void\ncheck_labels(const char *label1, const char *label2)", "code": "{\n\tif (label2 != NULL && label1 == NULL)\n\t\tyyerror(\"syntax error, missing begin label\");\n\tif (label2 == NULL || label1 == NULL)\n\t\treturn;\n\tif (strcmp(label1, label2) != 0)\n\t\tyyerror(\"end label is defferent than begin label\");\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * plpsm_scanner_errposition\n *\t\tReport an error cursor position, if possible.\n *\n * This is expected to be used within an ereport() call.  The return value\n * is a dummy (always 0, in fact).\n *\n * Note that this can only be used for messages emitted during initial\n * parsing of a plpgsql function, since it requires the scanorig string\n * to still be available.\n */\n", "func_signal": "int\nplpsm_scanner_errposition(int location)", "code": "{\n\tint\t\t\tpos;\n\n\tif (location < 0 || scanorig == NULL)\n\t\treturn 0;\t\t\t\t/* no-op if location is unknown */\n\n\t/* Convert byte offset to character number */\n\tpos = pg_mbstrlen_with_len(scanorig, location) + 1;\n\t/* And pass it to the ereport mechanism */\n\t(void) internalerrposition(pos);\n\t/* Also pass the function body string */\n\treturn internalerrquery(scanorig);\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Parse a SQL datatype name.\n *\n * The heavy lifting is done elsewhere.  Here we are only concerned\n * with setting up an errcontext link that will let us give an error\n * cursor pointing into the plpgsql function source, if necessary.\n * This is handled the same as in check_sql_expr(), and we likewise\n * expect that the given string is a copy from the source text.\n */\n", "func_signal": "static void\nparse_datatype(const char *string, int location, Oid *typoid, int32 *typmod)", "code": "{\n\tPlpsm_sql_error_callback_arg cbarg;\n\tErrorContextCallback  syntax_errcontext;\n\n\tcbarg.location = location;\n\tcbarg.leaderlen = 0;\n\n\tsyntax_errcontext.callback = plpsm_sql_error_callback;\n\tsyntax_errcontext.arg = &cbarg;\n\tsyntax_errcontext.previous = error_context_stack;\n\terror_context_stack = &syntax_errcontext;\n\n\t/* Let the main parser try to parse it under standard SQL rules */\n\tparseTypeString(string, typoid, typmod);\n\n\t/* Restore former ereport callback */\n\terror_context_stack = syntax_errcontext.previous;\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Because I would to see a parser by the most simply, then\n * a parsing of declaratin part is handy written. This section needs\n * a relative large prefetch lookup.\n */\n", "func_signal": "static Plpsm_stmt *\ndeclare_prefetch(void)", "code": "{\n\tDeclareParsingState state = Initial;\n\tPlpsm_stmt *result;\n\tint tok;\n\tList\t*varnames = NIL;\n\tint\toption;\n\tint\t\tstartlocation = -1;\n\n\tresult = plpsm_new_stmt(PLPSM_STMT_UNKNOWN, -1);\n\n\tfor (;;)\n\t{\n\t\tif (state == EXPECTED_DATATYPE)\n\t\t{\n\t\t\tint endtok;\n\t\t\tPlpsm_ESQL *datatype;\n\t\t\tOid\ttypoid;\n\t\t\tint32\ttypmod;\n\t\t\tint16\t\ttyplen;\n\t\t\tbool\t\ttypbyval;\n\n\t\t\tresult->typ = PLPSM_STMT_DECLARE_VARIABLE;\n\t\t\tresult->compound_target = varnames;\n\n\t\t\t/* \n\t\t\t * ToDo: better to use a special function than read_until,\n\t\t\t * because it raise a error to late. Datatype must not contains\n\t\t\t * a keywords, special chars etc\n\t\t\t */\n\t\t\tdatatype = read_embeded_sql(';', DEFAULT, AS, \"; or \\\"DEFAULT\\\" or \\\"AS\\\"\", PLPSM_ESQL_DATATYPE, false, &endtok, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    startlocation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&typmod);\n\n\t\t\tget_typlenbyval(typoid, &typlen, &typbyval);\n\n\t\t\tresult->datum.typoid = typoid;\n\t\t\tresult->datum.typmod = typmod;\n\t\t\tresult->datum.typname = datatype->sqlstr;\n\t\t\tresult->datum.typlen = typlen;\n\t\t\tresult->datum.typbyval = typbyval;\n\n\t\t\tif (endtok == ';')\n\t\t\t{\n\t\t\t\tresult->option = PLPSM_LOCAL_VARIABLE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (endtok == DEFAULT)\n\t\t\t{\n\t\t\t\t/* when DEFAULT value is specified, then read a expression until semicolon */\n\t\t\t\tresult->option = PLPSM_LOCAL_VARIABLE;\n\t\t\t\tresult->esql = read_expr_until_semi();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (endtok == AS)\n\t\t\t{\n\t\t\t\t/* only one variable is allowed with trigger variable mark */\n\t\t\t\tif (list_length(varnames) != 1)\n\t\t\t\t\tyyerror(\"cannot use trigger variable mark for more than one variable\");\n\n\t\t\t\t/* next token should be OLD or NEW */\n\t\t\t\ttok = yylex();\n\t\t\t\tif (tok == OLD)\n\t\t\t\t{\n\t\t\t\t\tresult->option = PLPSM_TRIGGER_VARIABLE_OLD;\n\t\t\t\t\tpstate->has_trigger_variable_old = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (tok == NEW)\n\t\t\t\t{\n\t\t\t\t\tresult->option = PLPSM_TRIGGER_VARIABLE_NEW;\n\t\t\t\t\tpstate->has_trigger_variable_new = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tyyerror(\"expected \\\"OLD\\\" or \\\"NEW\\\"\");\n\t\t\t}\n\t\t}\n\n\t\tif (state == EXPECTED_CURSOR)\n\t\t{\n\t\t\tint tok = yylex();\n\n\t\t\tAssert(tok == CURSOR);\n\n\t\t\tresult->typ = PLPSM_STMT_DECLARE_CURSOR;\n\n\t\t\tresult->target = linitial(varnames);\n\t\t\tresult->option = option;\n\n\t\t\tplpsm_push_back_token(tok);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((tok = yylex()) == 0)\n\t\t\tyyerror(\"unpexpected end of function definition\");\n\n\t\tif (state == Initial)\n\t\t{\n\t\t\tif (tok == WORD)\n\t\t\t{\n\t\t\t\t/* store identifier */\n\t\t\t\tvarnames = list_make1(new_qualid(list_make1(yylval.word.ident), yylloc));\n\t\t\t\tstate = Unknown;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tok == CONTINUE || tok == EXIT || tok == UNDO)\n\t\t\t{\n\t\t\t\tint tok1;\n\t\t\t\tconst char *varname = yylval.keyword;\t\t/* store pointer for possible later usage */\n\n\t\t\t\t/* \n\t\t\t\t * recheck next symbol, when next token is HANDLER,\n\t\t\t\t * then we found a handler's declaration, otherwise\n\t\t\t\t * it's variable declaration.\n\t\t\t\t */\n\t\t\t\tif ((tok1 = yylex()) == HANDLER)\n\t\t\t\t{\n\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\tresult->typ = PLPSM_STMT_DECLARE_HANDLER;\n\t\t\t\t\tswitch (tok)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\tresult->option = PLPSM_HANDLER_CONTINUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EXIT:\n\t\t\t\t\t\t\tresult->option = PLPSM_HANDLER_EXIT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase UNDO:\n\t\t\t\t\t\t\tresult->option = PLPSM_HANDLER_UNDO;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* store identifier */\n\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\tvarnames = list_make1(new_qualid(list_make1(pstrdup(varname)), yylloc));\n\t\t\t\t\tstate = Unknown;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (is_unreserved_keyword(tok))\n\t\t\t{\n\t\t\t\tvarnames = list_make1(new_qualid(list_make1(yylval.word.ident), yylloc));\n\t\t\t\tstate = Unknown;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (state == Unknown)\n\t\t{\n\t\t\tif (tok == ',')\n\t\t\t{\n\t\t\t\t/* store identificator */\n\t\t\t\tstate = EXPECTED_VARIABLE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tok == CONDITION)\n\t\t\t{\n\t\t\t\tresult->typ = PLPSM_STMT_DECLARE_CONDITION;\n\t\t\t\tresult->target = linitial(varnames);\n\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tok == CURSOR)\n\t\t\t{\n\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\toption = PLPSM_CURSOR_NOSCROLL;\n\t\t\t\tstate = EXPECTED_CURSOR;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tok == SCROLL)\n\t\t\t{\n\t\t\t\tint tok1;\n\n\t\t\t\tstartlocation = yylloc;\n\t\t\t\ttok1 = yylex();\n\t\t\t\tif (tok1 == CURSOR)\n\t\t\t\t{\n\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\toption = PLPSM_CURSOR_SCROLL;\n\t\t\t\t\tstate = EXPECTED_CURSOR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\t\tstate = EXPECTED_DATATYPE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tok == NO)\n\t\t\t{\n\t\t\t\tint tok1;\n\n\t\t\t\tstartlocation = yylloc;\n\t\t\t\ttok1 = yylex();\n\t\t\t\tif (tok1 != SCROLL)\n\t\t\t\t{\n\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\t\tstate = EXPECTED_DATATYPE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint tok2 = yylex();\n\n\t\t\t\t\tif (tok2 != CURSOR)\n\t\t\t\t\t{\n\t\t\t\t\t\tplpsm_push_back_token(tok2);\n\t\t\t\t\t\tplpsm_push_back_token(tok1);\n\t\t\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\t\t\tstate = EXPECTED_DATATYPE;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tplpsm_push_back_token(tok2);\n\t\t\t\t\t\toption = PLPSM_CURSOR_NOSCROLL;\n\t\t\t\t\t\tstate = EXPECTED_CURSOR;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tok == WORD || is_unreserved_keyword(tok))\n\t\t\t{\n\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\tstate = EXPECTED_DATATYPE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (state == EXPECTED_VARIABLE)\n\t\t{\n\t\t\n\t\t\tif (tok != WORD && !is_unreserved_keyword(tok))\n\t\t\t\tyyerror(\"missing a variable identifier\");\n\t\t\tvarnames = lappend(varnames, new_qualid(list_make1(yylval.word.ident), yylloc));\n\t\t\tstate = COMPLETE_LIST_OF_VARIABLES;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state == COMPLETE_LIST_OF_VARIABLES)\n\t\t{\n\t\t\tif (tok == ',')\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t\tstate = EXPECTED_VARIABLE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplpsm_push_back_token(tok);\n\t\t\t\tstate = EXPECTED_DATATYPE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tyyerror(\"syntax error\");\n\t}\n\n\treturn result;\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Returns a addr of relevant handler or release all nested transaction and\n * returns zero.\n */\n", "func_signal": "static int\nsearch_handler(Plpsm_module *mod, char *condition_name, int sqlstate, ResourceOwner *ROstack, int *ROP,\n\t\t\t\t\t\t\t\t    int htnum, Plpsm_handler_type *htyp,\n\t\t\t\t\t\t\t\t    DiagnosticsInfoData *DInfoStack, DiagnosticsInfo first_area, int *DID)", "code": "{\n\tint handler_addr = 0;\n\n\tif (htnum > 0 && sqlstate != ERRCODE_QUERY_CANCELED)\n\t{\n\t\tint\tht_addr = htnum;\n\t\tPlpsm_pcode *ht_item = &mod->ht_table->code[ht_addr];\n\n\t\tAssert(ht_item->typ == PCODE_HT);\n\t\twhile (ht_item->HT_field.typ != PLPSM_HT_STOP)\n\t\t{\n\t\t\tPlpsm_ht_type typ = ht_item->HT_field.typ;\n\n\t\t\tif (typ == PLPSM_HT_CONDITION_NAME && condition_name != NULL)\n\t\t\t{\n\t\t\t\tif (strcmp(ht_item->HT_field.condition_name, condition_name) == 0)\n\t\t\t\t{\n\t\t\t\t\thandler_addr = ht_item->HT_field.addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_SQLCODE)\n\t\t\t{\n\t\t\t\tif (ht_item->HT_field.sqlcode == sqlstate)\n\t\t\t\t{\n\t\t\t\t\thandler_addr = ht_item->HT_field.addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_SQLCLASS)\n\t\t\t{\n\t\t\t\tif (ht_item->HT_field.sqlclass == ERRCODE_TO_CATEGORY(sqlstate))\n\t\t\t\t{\n\t\t\t\t\thandler_addr = ht_item->HT_field.addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_SQLEXCEPTION)\n\t\t\t{\n\t\t\t\tint\teclass = ERRCODE_TO_CATEGORY(sqlstate);\n\n\t\t\t\tif (eclass != MAKE_SQLSTATE('0','2','0','0','0') &&\n\t\t\t\t\teclass != MAKE_SQLSTATE('0','1','0','0','0'))\n\t\t\t\t{\n\t\t\t\t\thandler_addr = ht_item->HT_field.addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_SQLWARNING)\n\t\t\t{\n\t\t\t\tint\teclass = ERRCODE_TO_CATEGORY(sqlstate);\n\n\t\t\t\tif (eclass == MAKE_SQLSTATE('0','2','0','0','0') ||\n\t\t\t\t\teclass == MAKE_SQLSTATE('0','1','0','0','0'))\n\t\t\t\t{\n\t\t\t\t\thandler_addr = ht_item->HT_field.addr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_PARENT)\n\t\t\t{\n\t\t\t\tht_addr = ht_item->HT_field.parent_HT_addr;\n\t\t\t\tht_item = &mod->ht_table->code[--ht_addr];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_RELEASE_SUBTRANSACTION)\n\t\t\t{\n\t\t\t\tRollbackAndReleaseCurrentSubTransaction();\n\t\t\t\tCurrentResourceOwner = ROstack[(*ROP)--];\n\t\t\t\tSPI_restore_connection();\n\t\t\t}\n\t\t\telse if (typ == PLPSM_HT_DIAGNOSTICS_POP)\n\t\t\t{\n\t\t\t\t\tif (*DID == -1)\n\t\t\t\t\t\telog(ERROR, \"runtime error, diagnostics stack is empty\");\n\n\t\t\t\tfirst_area->level = DInfoStack[*DID].level;\n\t\t\t\tfirst_area->sqlstate = DInfoStack[*DID].sqlstate;\n\t\t\t\tfirst_area->message_text = DInfoStack[*DID].message_text;\n\t\t\t\tfirst_area->detail_text = DInfoStack[*DID].detail_text;\n\t\t\t\tfirst_area->hint_text = DInfoStack[*DID].hint_text;\n\t\t\t\tfirst_area->condition_identifier = DInfoStack[*DID].condition_identifier;\n\n\t\t\t\t(*DID)--;\n\t\t\t}\n\n\t\t\tht_item = &mod->ht_table->code[--ht_addr];\n\t\t}\n\n\t\tif (handler_addr > 0)\n\t\t{\n\t\t\tif (ht_item->HT_field.htyp == PLPSM_HANDLER_UNDO)\n\t\t\t{\n\t\t\t\tRollbackAndReleaseCurrentSubTransaction();\n\t\t\t\tCurrentResourceOwner = ROstack[(*ROP)--];\n\t\t\t\tSPI_restore_connection();\n\t\t\t}\n\n\t\t\tif (htyp != NULL)\n\t\t\t\t*htyp = ht_item->HT_field.htyp;\n\n\t\t\treturn handler_addr;\n\t\t}\n\t}\n\n\t/*\n\t * We didn't find a handler, so now rollback all handlers\n\t */\n\twhile (*ROP >= 0)\n\t{\n\t\t/* rollback all nested transaction */\n\t\tRollbackAndReleaseCurrentSubTransaction();\n\t\tCurrentResourceOwner = ROstack[(*ROP)--];\n\t\tSPI_restore_connection();\n\t}\n\treturn 0;\n\n}", "path": "executor.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * _PG_init()\t\t\t- library load-time initialization\n *\n * DO NOT make this static nor change its name!\n */\n", "func_signal": "void\n_PG_init(void)", "code": "{\n\t/* Be sure we do initialization only once (should be redundant now) */\n\tstatic bool inited = false;\n\n\tif (inited)\n\t\treturn;\n\n\tDefineCustomBoolVariable(\"plpsm.debug_parser\",\n\t\t\t\t\t\t\"when is true, then parser output is raised\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&plpsm_debug_parser,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tPGC_SUSET, 0,\n\t\t\t\t\t\tNULL, NULL, NULL);\n\n\tDefineCustomBoolVariable(\"plpsm.debug_compiler\",\n\t\t\t\t\t\t\"when is true, then compiler output is raised\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&plpsm_debug_compiler,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tPGC_SUSET, 0,\n\t\t\t\t\t\tNULL, NULL, NULL);\n\n\tDefineCustomBoolVariable(\"plpsm.debug_info\",\n\t\t\t\t\t\t\"when is true, then debug data is attached\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&plpsm_debug_info,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tPGC_SUSET, 0,\n\t\t\t\t\t\tNULL, NULL, NULL);\n\n\tplpsm_HashTableInit();\n\n\tinited = true;\n}", "path": "handler.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * collect a variables info\n */\n", "func_signal": "static void\ncollect_vars_info(StringInfo ds, Plpsm_object *scope, FmgrInfo *flinfo, Datum *values, char *nulls)", "code": "{\n\tPlpsm_object *iterator;\n\tStringInfoData\t\tlds;\n\tbool append = false;\n\n\tif (scope == NULL)\n\t\treturn;\n\n\tinitStringInfo(&lds);\n\n\titerator = scope->inner;\n\n\tappendStringInfo(&lds, \"\\n  ==== %s: frame ====\\n\", scope->name != NULL ? scope->name : \"unnamed\");\n\n\twhile (iterator != NULL)\n\t{\n\t\tif (iterator->typ == PLPSM_STMT_DECLARE_VARIABLE)\n\t\t{\n\t\t\tchar *value;\n\n\t\t\tif (nulls[iterator->offset] != 'n')\n\t\t\t\tvalue = OutputFunctionCall(&flinfo[iterator->offset], values[iterator->offset]);\n\t\t\telse\n\t\t\t\tvalue = \"NULL\";\n\n\t\t\tif (iterator->typ == PLPSM_STMT_DECLARE_VARIABLE)\n\t\t\t\tappendStringInfo(&lds, \"  %3d\\t%s = %s\\n\", iterator->offset, \n\t\t\t\t\t\t\t\t\t\t\t\titerator->name,\n\t\t\t\t\t\t\t\t\t\t\t\tvalue);\n\t\t\tappend = true;\n\t\t}\n\t\telse if (iterator->typ == PLPSM_STMT_DECLARE_CURSOR)\n\t\t{\n\t\t\t\tappendStringInfo(&lds, \"  %3d\\t%s cursor\\n\", iterator->offset, \n\t\t\t\t\t\t\t\t\t\t\t\titerator->name);\n\t\t\t\tappend = true;\n\t\t}\n\t\titerator = iterator->next;\n\t}\n\n\tif (append)\n\t\tappendStringInfoString(ds, lds.data);\n\n\tcollect_vars_info(ds, scope->outer, flinfo, values, nulls);\n}", "path": "executor.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Push back a single token to be re-read by next plpsm_yylex() call.\n *\n * NOTE: this does not cause yylval or yylloc to \"back up\".  Also, it\n * is not a good idea to push back a token code other than what you read.\n */\n", "func_signal": "void\nplpsm_push_back_token(int token)", "code": "{\n\tTokenAuxData auxdata;\n\n\tauxdata.lval = plpsm_yylval;\n\tauxdata.lloc = plpsm_yylloc;\n\tauxdata.leng = plpsm_yyleng;\n\tpush_back_token(token, &auxdata);\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * This is the yylex routine called from the PL/PSM grammar.\n * It is a wrapper around the core lexer. It returns a\n * T_WORD or T_CWORD, or as an unreserved keyword if it\n * matches one of those.\n */\n", "func_signal": "int\nplpsm_yylex(void)", "code": "{\n\tint\t\t\ttok1;\n\tTokenAuxData aux1;\n\tconst ScanKeyword *kw;\n\n\ttok1 = internal_yylex(&aux1);\n\tif (tok1 == IDENT)\n\t{\n\t\tint\t\t\ttok2;\n\t\tTokenAuxData aux2;\n\n\t\ttok2 = internal_yylex(&aux2);\n\t\tif (tok2 == '.')\n\t\t{\n\t\t\tint\t\t\ttok3;\n\t\t\tTokenAuxData aux3;\n\n\t\t\ttok3 = internal_yylex(&aux3);\n\t\t\tif (tok3 == IDENT)\n\t\t\t{\n\t\t\t\tint\t\t\ttok4;\n\t\t\t\tTokenAuxData aux4;\n\n\t\t\t\ttok4 = internal_yylex(&aux4);\n\t\t\t\tif (tok4 == '.')\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttok5;\n\t\t\t\t\tTokenAuxData aux5;\n\n\t\t\t\t\ttok5 = internal_yylex(&aux5);\n\t\t\t\t\tif (tok5 == IDENT)\n\t\t\t\t\t{\n\t\t\t\t\t\taux1.lval.cword.idents = list_make3(makeString(aux1.lval.str),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmakeString(aux3.lval.str),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmakeString(aux5.lval.str));\n\t\t\t\t\t\ttok1 = CWORD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not A.B.C, so just process A.B */\n\t\t\t\t\t\tpush_back_token(tok5, &aux5);\n\t\t\t\t\t\tpush_back_token(tok4, &aux4);\n\n\t\t\t\t\t\taux1.lval.cword.idents = list_make2(makeString(aux1.lval.str),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmakeString(aux3.lval.str));\n\t\t\t\t\t\ttok1 = CWORD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* not A.B.C, so just process A.B */\n\t\t\t\t\tpush_back_token(tok4, &aux4);\n\t\t\t\t\taux1.lval.cword.idents = list_make2(makeString(aux1.lval.str),\n\t\t\t\t\t\t\t\t\t\t\t\t\tmakeString(aux3.lval.str));\n\t\t\t\t\ttok1 = CWORD;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not A.B, so just process A */\n\t\t\t\tpush_back_token(tok3, &aux3);\n\t\t\t\tpush_back_token(tok2, &aux2);\n\n\t\t\t\tparse_word(aux1.lval.str, core_yy.scanbuf + aux1.lloc,  &aux1.lval.word);\n\t\t\t\tif (!aux1.lval.word.quoted &&\n\t\t\t\t\t\t (kw = ScanKeywordLookup(aux1.lval.word.ident,\n\t\t\t\t\t\t\t\t\t\t\t\t unreserved_keywords,\n\t\t\t\t\t\t\t\t\t\t\t\t num_unreserved_keywords)))\n\t\t\t\t{\n\t\t\t\t\taux1.lval.keyword = kw->name;\n\t\t\t\t\ttok1 = kw->value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttok1 = WORD;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not A.B, so just process A */\n\t\t\tpush_back_token(tok2, &aux2);\n\n\t\t\tparse_word(aux1.lval.str, core_yy.scanbuf + aux1.lloc,  &aux1.lval.word);\n\t\t\tif (!aux1.lval.word.quoted &&\n\t\t\t\t\t (kw = ScanKeywordLookup(aux1.lval.word.ident,\n\t\t\t\t\t\t\t\t\t\t\t unreserved_keywords,\n\t\t\t\t\t\t\t\t\t\t\t num_unreserved_keywords)))\n\t\t\t{\n\t\t\t\taux1.lval.keyword = kw->name;\n\t\t\t\ttok1 = kw->value;\n\t\t\t}\n\t\t\telse\n\t\t\t\ttok1 = WORD;\n\t\t}\n\t}\n\n\tplpsm_yylval = aux1.lval;\n\tplpsm_yylloc = aux1.lloc;\n\tplpsm_yyleng = aux1.leng;\n\treturn tok1;\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Set a ErrorCallback and exeute a module\n */\n", "func_signal": "Datum\nplpsm_func_execute(Plpsm_module *mod, FunctionCallInfo fcinfo)", "code": "{\n\tErrorContextCallback plerrcontext;\n\tDebugInfoData\tdinfo;\n\tDatum\tresult;\n\n\tplerrcontext.callback = plpsm_exec_error_callback;\n\tplerrcontext.arg = &dinfo;\n\tplerrcontext.previous = error_context_stack;\n\terror_context_stack = &plerrcontext;\n\n\tresult = execute_module(mod, fcinfo, &dinfo);\n\tif (CALLED_AS_TRIGGER(fcinfo))\n\t{\n\t\t/* process a result */\n\t\tif (fcinfo->isnull)\n\t\t{\n\t\t\tfcinfo->isnull = false;\n\t\t\tresult = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHeapTupleData\t\ttuple;\n\t\t\tHeapTupleHeader\t\ttd;\n\n\t\t\ttd = DatumGetHeapTupleHeader(result);\n\n\t\t\t/* Build a temporary HeapTuple control structure */\n\t\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(td);\n\t\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\t\ttuple.t_tableOid = InvalidOid;\n\t\t\ttuple.t_data = td;\n\n\t\t\tresult = PointerGetDatum(SPI_copytuple(&tuple));\n\t\t}\n\t}\n\n\terror_context_stack = plerrcontext.previous;\n\n\treturn result;\n}", "path": "executor.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Push back a token to be re-read by next internal_yylex() call.\n */\n", "func_signal": "static void\npush_back_token(int token, TokenAuxData *auxdata)", "code": "{\n\tif (num_pushbacks >= MAX_PUSHBACKS)\n\t\telog(ERROR, \"too many tokens pushed back\");\n\tpushback_token[num_pushbacks] = token;\n\tpushback_auxdata[num_pushbacks] = *auxdata;\n\tnum_pushbacks++;\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/* Copy into YYRESULT an error message about the unexpected token\n   YYCHAR while in state YYSTATE.  Return the number of bytes copied,\n   including the terminating null byte.  If YYRESULT is null, do not\n   copy anything; just return the number of bytes that would be\n   copied.  As a special case, return 0 if an ordinary \"syntax error\"\n   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during\n   size calculation.  */\n", "func_signal": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)", "code": "{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*----\n * Debug out routines \n *\n */\n", "func_signal": "static void\nesql_out(StringInfo ds, Plpsm_ESQL *esql)", "code": "{\n\tif (esql == NULL)\n\t\treturn;\n\n\tswitch (esql->typ)\n\t{\n\t\tcase PLPSM_ESQL_EXPR:\n\t\t\tappendStringInfo(ds, \"EXPR: %s\", esql->sqlstr);\n\t\t\tbreak;\n\t\tcase PLPSM_ESQL_QUERY:\n\t\t\tappendStringInfo(ds, \"QUERY: %s\", esql->sqlstr);\n\t\t\tbreak;\n\t\tcase PLPSM_ESQL_DATATYPE:\n\t\t\tappendStringInfo(ds, \"DATATYPE: %s\", esql->sqlstr);\n\t\t\tbreak;\n\t}\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * Given a location (a byte offset in the function source text),\n * return a line number.\n *\n * We expect that this is typically called for a sequence of increasing\n * location values, so optimize accordingly by tracking the endpoints\n * of the \"current\" line.\n */\n", "func_signal": "int\nplpsm_location_to_lineno(int location)", "code": "{\n\tconst char *loc;\n\n\tif (location < 0 || scanorig == NULL)\n\t\treturn 0;\t\t\t\t/* garbage in, garbage out */\n\tloc = scanorig + location;\n\n\t/* be correct, but not fast, if input location goes backwards */\n\tif (loc < cur_line_start)\n\t\tlocation_lineno_init();\n\n\twhile (cur_line_end != NULL && loc > cur_line_end)\n\t{\n\t\tcur_line_start = cur_line_end + 1;\n\t\tcur_line_num++;\n\t\tcur_line_end = strchr(cur_line_start, '\\n');\n\t}\n\n\treturn cur_line_num;\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/* initialize or reset the state for plpgsql_location_to_lineno */\n", "func_signal": "static void\nlocation_lineno_init(void)", "code": "{\n\tcur_line_start = scanorig;\n\tcur_line_num = 1;\n\n\tcur_line_end = strchr(cur_line_start, '\\n');\n}", "path": "scanner.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}", "path": "gram.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/*\n * set a context to let us supply a call-stack traceback\n */\n", "func_signal": "static void\nplpsm_exec_error_callback(void *arg)", "code": "{\n\tDebugInfo dinfo = (DebugInfo) arg;\n\tPlpsm_pcode *pcode;\n\tStringInfoData\tds;\n\n\tif (dinfo->is_signal)\n\t\treturn;\n\n\tinitStringInfo(&ds);\n\n\tpcode = &dinfo->module->code->code[*(dinfo->PC)];\n\n\tif (pcode->lineno != -1 && *dinfo->src != NULL)\n\t{\n\t\tint\tlineno = pcode->lineno;\n\t\tchar\t*src = *dinfo->src;\n\t\tint\tcurline = 0;\n\t\t\n\t\tint maxl = 0;\n\n\t\tappendStringInfo(&ds, \"PLPSM function \\\"%s\\\"  Oid %d line %d\\n\\n\", dinfo->module->code->name, \n\t\t\t\t\t\t\t\t\t\t\t    dinfo->module->oid,\n\t\t\t\t\t\t\t\t\t\t\t    pcode->lineno); \n\n\t\twhile (*src != '\\0')\n\t\t{\n\t\t\tif (maxl++ == 100)\n\t\t\t\tbreak;\n\t\t\tif (curline < lineno - 3)\n\t\t\t{\n\t\t\t\t/* skip line */\n\t\t\t\twhile (*src != '\\0')\n\t\t\t\t\tif (*src++ == '\\n')\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (curline < lineno + 2)\n\t\t\t{\n\t\t\t\tappendStringInfo(&ds, \"%4d\\t\", curline + 1);\n\t\t\t\twhile (*src != '\\0')\n\t\t\t\t{\n\t\t\t\t\tappendStringInfoChar(&ds, *src);\n\t\t\t\t\tif (*src++ == '\\n')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tcurline++;\n\t\t}\n\t}\n\telse if (pcode->lineno != -1)\n\t{\n\t\tappendStringInfo(&ds, \"PLPSM function \\\"%s\\\"  Oid %d line %d\", dinfo->module->code->name, \n\t\t\t\t\t\t\t\t\t\t    dinfo->module->oid,\n\t\t\t\t\t\t\t\t\t\t    pcode->lineno); \n\t}\n\telse\n\t\tappendStringInfo(&ds, \"PLPSM function \\\"%s\\\"  Oid %d\", dinfo->module->code->name, dinfo->module->oid); \n\n\tif (pcode->cframe != NULL)\n\t{\n\t\tcollect_vars_info(&ds, pcode->cframe, dinfo->out_funcs, dinfo->values, dinfo->nulls);\n\t}\n\n\terrcontext(\"%s\", ds.data);\n\tpfree(ds.data);\n}", "path": "executor.c", "repo_name": "okbob/plpsm0", "stars": 8, "license": "None", "language": "c", "size": 388}
{"docstring": "/* Map from Palette to Palette */\n", "func_signal": "static Uint8 *Map1to1(SDL_Palette *src, SDL_Palette *dst, int *identical)", "code": "{\n\tUint8 *map;\n\tint i;\n\n\tif ( identical ) {\n\t\tif ( src->ncolors <= dst->ncolors ) {\n\t\t\t/* If an identical palette, no need to map */\n\t\t\tif ( SDL_memcmp(src->colors, dst->colors, src->ncolors*\n\t\t\t\t\t\tsizeof(SDL_Color)) == 0 ) {\n\t\t\t\t*identical = 1;\n\t\t\t\treturn(NULL);\n\t\t\t}\n\t\t}\n\t\t*identical = 0;\n\t}\n\tmap = (Uint8 *)SDL_malloc(src->ncolors);\n\tif ( map == NULL ) {\n\t\tSDL_OutOfMemory();\n\t\treturn(NULL);\n\t}\n\tfor ( i=0; i<src->ncolors; ++i ) {\n\t\tmap[i] = SDL_FindColor(dst,\n\t\t\tsrc->colors[i].r, src->colors[i].g, src->colors[i].b);\n\t}\n\treturn(map);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Ack!  XPending() actually performs a blocking read if no events available */\n", "func_signal": "int X11_Pending(Display *display)", "code": "{\n\t/* Flush the display connection and look to see if events are queued */\n\tXFlush(display);\n\tif ( XEventsQueued(display, QueuedAlready) ) {\n\t\treturn(1);\n\t}\n\n\t/* More drastic measures are required -- see if X is ready to talk */\n\t{\n\t\tstatic struct timeval zero_time;\t/* static == 0 */\n\t\tint x11_fd;\n\t\tfd_set fdset;\n\n\t\tx11_fd = ConnectionNumber(display);\n\t\tFD_ZERO(&fdset);\n\t\tFD_SET(x11_fd, &fdset);\n\t\tif ( select(x11_fd+1, &fdset, NULL, NULL, &zero_time) == 1 ) {\n\t\t\treturn(XPending(display));\n\t\t}\n\t}\n\n\t/* Oh well, nothing is ready .. */\n\treturn(0);\n}", "path": "src\\video\\x11\\SDL_x11events.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Thread running events */\n", "func_signal": "static void *RunThread(void *data)", "code": "{\n\tSDL_RunThread(data);\n\tpthread_exit((void*)0);\n\treturn((void *)0);\t\t/* Prevent compiler warning */\n}", "path": "src\\thread\\riscos\\SDL_systhread.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* This is only called if the event thread is not running */\n", "func_signal": "int SDL_SYS_TimerInit(void)", "code": "{\n        timer_alive = 1;\n        timer = SDL_CreateThread(RunTimer, NULL);\n        if ( timer == NULL )\n                return(-1);\n        return(SDL_SetTimerThreaded(1));\n}", "path": "src\\timer\\os2\\SDL_systimer.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n * Free a previously allocated format structure\n */\n", "func_signal": "void SDL_FreeFormat(SDL_PixelFormat *format)", "code": "{\n\tif ( format ) {\n\t\tif ( format->palette ) {\n\t\t\tif ( format->palette->colors ) {\n\t\t\t\tSDL_free(format->palette->colors);\n\t\t\t}\n\t\t\tSDL_free(format->palette);\n\t\t}\n\t\tSDL_free(format);\n\t}\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Get the translated SDL virtual keysym */\n", "func_signal": "SDLKey X11_TranslateKeycode(Display *display, KeyCode kc)", "code": "{\n\tKeySym xsym;\n\tSDLKey key;\n\n\txsym = XKeycodeToKeysym(display, kc, 0);\n#ifdef DEBUG_KEYS\n\tfprintf(stderr, \"Translating key code %d -> 0x%.4x\\n\", kc, xsym);\n#endif\n\tkey = SDLK_UNKNOWN;\n\tif ( xsym ) {\n\t\tswitch (xsym>>8) {\n\t\t    case 0x1005FF:\n#ifdef SunXK_F36\n\t\t\tif ( xsym == SunXK_F36 )\n\t\t\t\tkey = SDLK_F11;\n#endif\n#ifdef SunXK_F37\n\t\t\tif ( xsym == SunXK_F37 )\n\t\t\t\tkey = SDLK_F12;\n#endif\n\t\t\tbreak;\n\t\t    case 0x00:\t/* Latin 1 */\n\t\t\tkey = (SDLKey)(xsym & 0xFF);\n\t\t\tbreak;\n\t\t    case 0x01:\t/* Latin 2 */\n\t\t    case 0x02:\t/* Latin 3 */\n\t\t    case 0x03:\t/* Latin 4 */\n\t\t    case 0x04:\t/* Katakana */\n\t\t    case 0x05:\t/* Arabic */\n\t\t    case 0x06:\t/* Cyrillic */\n\t\t    case 0x07:\t/* Greek */\n\t\t    case 0x08:\t/* Technical */\n\t\t    case 0x0A:\t/* Publishing */\n\t\t    case 0x0C:\t/* Hebrew */\n\t\t    case 0x0D:\t/* Thai */\n\t\t\t/* These are wrong, but it's better than nothing */\n\t\t\tkey = (SDLKey)(xsym & 0xFF);\n\t\t\tbreak;\n\t\t    case 0xFE:\n\t\t\tkey = ODD_keymap[xsym&0xFF];\n\t\t\tbreak;\n\t\t    case 0xFF:\n\t\t\tkey = MISC_keymap[xsym&0xFF];\n\t\t\tbreak;\n\t\t    default:\n\t\t\t/*\n\t\t\tfprintf(stderr, \"X11: Unhandled xsym, sym = 0x%04x\\n\",\n\t\t\t\t\t(unsigned int)xsym);\n\t\t\t*/\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* X11 doesn't know how to translate the key! */\n\t\tswitch (kc) {\n\t\t    /* Caution:\n\t\t       These keycodes are from the Microsoft Keyboard\n\t\t     */\n\t\t    case 115:\n\t\t\tkey = SDLK_LSUPER;\n\t\t\tbreak;\n\t\t    case 116:\n\t\t\tkey = SDLK_RSUPER;\n\t\t\tbreak;\n\t\t    case 117:\n\t\t\tkey = SDLK_MENU;\n\t\t\tbreak;\n\t\t    default:\n\t\t\t/*\n\t\t\t * no point in an error message; happens for\n\t\t\t * several keys when we get a keymap notify\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn key;\n}", "path": "src\\video\\x11\\SDL_x11events.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Find the pixel value corresponding to an RGBA quadruple */\n", "func_signal": "Uint32 SDL_MapRGBA\n(const SDL_PixelFormat * const format,\n const Uint8 r, const Uint8 g, const Uint8 b, const Uint8 a)", "code": "{\n\tif ( format->palette == NULL ) {\n\t        return (r >> format->Rloss) << format->Rshift\n\t\t    | (g >> format->Gloss) << format->Gshift\n\t\t    | (b >> format->Bloss) << format->Bshift\n\t\t    | ((a >> format->Aloss) << format->Ashift & format->Amask);\n\t} else {\n\t\treturn SDL_FindColor(format->palette, r, g, b);\n\t}\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n * This function is semi-official; it is not officially exported and should\n * not be considered part of the SDL API, but may be used by client code\n * that *really* needs it (including legacy code).\n * It is slow, though, and should be avoided if possible.\n *\n * Note that it isn't completely accurate either; in particular, multi-key\n * sequences (dead accents, compose key sequences) will not work since the\n * state has been irrevocably lost.\n */\n", "func_signal": "Uint16 X11_KeyToUnicode(SDLKey keysym, SDLMod modifiers)", "code": "{\n\tstruct SDL_VideoDevice *this = current_video;\n\tchar keybuf[32];\n\tint i;\n\tKeySym xsym = 0;\n\tXKeyEvent xkey;\n\tUint16 unicode;\n\n\tif ( !this || !SDL_Display ) {\n\t\treturn 0;\n\t}\n\n\tSDL_memset(&xkey, 0, sizeof(xkey));\n\txkey.display = SDL_Display;\n\n\txsym = keysym;\t\t/* last resort if not found */\n\tfor (i = 0; i < 256; ++i) {\n\t\tif ( MISC_keymap[i] == keysym ) {\n\t\t\txsym = 0xFF00 | i;\n\t\t\tbreak;\n\t\t} else if ( ODD_keymap[i] == keysym ) {\n\t\t\txsym = 0xFE00 | i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txkey.keycode = XKeysymToKeycode(xkey.display, xsym);\n\n\tget_modifier_masks(SDL_Display);\n\tif(modifiers & KMOD_SHIFT)\n\t\txkey.state |= ShiftMask;\n\tif(modifiers & KMOD_CAPS)\n\t\txkey.state |= LockMask;\n\tif(modifiers & KMOD_CTRL)\n\t\txkey.state |= ControlMask;\n\tif(modifiers & KMOD_MODE)\n\t\txkey.state |= mode_switch_mask;\n\tif(modifiers & KMOD_LALT)\n\t\txkey.state |= alt_l_mask;\n\tif(modifiers & KMOD_RALT)\n\t\txkey.state |= alt_r_mask;\n\tif(modifiers & KMOD_LMETA)\n\t\txkey.state |= meta_l_mask;\n\tif(modifiers & KMOD_RMETA)\n\t\txkey.state |= meta_r_mask;\n\tif(modifiers & KMOD_NUM)\n\t\txkey.state |= num_mask;\n\n\tunicode = 0;\n\tif ( XLookupString(&xkey, keybuf, sizeof(keybuf), NULL, NULL) )\n\t\tunicode = (unsigned char)keybuf[0];\n\treturn(unicode);\n}", "path": "src\\video\\x11\\SDL_x11events.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Check to see if this is a repeated key.\n   (idea shamelessly lifted from GII -- thanks guys! :)\n */\n", "func_signal": "static int X11_KeyRepeat(Display *display, XEvent *event)", "code": "{\n\tXEvent peekevent;\n\tint repeated;\n\n\trepeated = 0;\n\tif ( XPending(display) ) {\n\t\tXPeekEvent(display, &peekevent);\n\t\tif ( (peekevent.type == KeyPress) &&\n\t\t     (peekevent.xkey.keycode == event->xkey.keycode) &&\n\t\t     ((peekevent.xkey.time-event->xkey.time) < 2) ) {\n\t\t\trepeated = 1;\n\t\t\tXNextEvent(display, &peekevent);\n\t\t}\n\t}\n\treturn(repeated);\n}", "path": "src\\video\\x11\\SDL_x11events.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* \n * Calculate the pad-aligned scanline width of a surface\n */\n", "func_signal": "Uint16 SDL_CalculatePitch(SDL_Surface *surface)", "code": "{\n\tUint16 pitch;\n\n\t/* Surface should be 4-byte aligned for speed */\n\tpitch = surface->w*surface->format->BytesPerPixel;\n\tswitch (surface->format->BitsPerPixel) {\n\t\tcase 1:\n\t\t\tpitch = (pitch+7)/8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpitch = (pitch+1)/2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tpitch = (pitch + 3) & ~3;\t/* 4-byte aligning */\n\treturn(pitch);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* FIXME: The cursor stuff isn't implemented yet! */\n", "func_signal": "WMcursor * PG_CreateWMCursor (_THIS,Uint8 * data, Uint8 * mask, \n\t\t\t      int w, int h, int hot_x, int hot_y)", "code": "{\n        static WMcursor dummy;\n        return &dummy;\n}", "path": "src\\video\\picogui\\SDL_pgvideo.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Note:  If we are terminated, this could be called in the middle of\n   another SDL video routine -- notably UpdateRects.\n*/\n", "func_signal": "void PG_VideoQuit(_THIS)", "code": "{\n\tif (this->screen->pixels != NULL)\n\t{\n\t\tshmdt(this->screen->pixels);\n\t\tthis->screen->pixels = NULL;\n\t\tpgDelete(this->hidden->bitmap);\n\t}\n\tpgDelete(this->hidden->wCanvas);\n\tpgDelete(this->hidden->wApp);\n}", "path": "src\\video\\picogui\\SDL_pgvideo.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Map from BitField to Dithered-Palette to Palette */\n", "func_signal": "static Uint8 *MapNto1(SDL_PixelFormat *src, SDL_PixelFormat *dst, int *identical)", "code": "{\n\t/* Generate a 256 color dither palette */\n\tSDL_Palette dithered;\n\tSDL_Color colors[256];\n\tSDL_Palette *pal = dst->palette;\n\t\n\t/* SDL_DitherColors does not initialize the 'unused' component of colors,\n\t   but Map1to1 compares it against pal, so we should initialize it. */  \n\tSDL_memset(colors, 0, sizeof(colors));\n\n\tdithered.ncolors = 256;\n\tSDL_DitherColors(colors, 8);\n\tdithered.colors = colors;\n\treturn(Map1to1(&dithered, pal, identical));\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Apply gamma to a set of colors - this is easy. :) */\n", "func_signal": "void SDL_ApplyGamma(Uint16 *gamma, SDL_Color *colors, SDL_Color *output,\n\t\t\t\t\t\t\tint ncolors)", "code": "{\n\tint i;\n\n\tfor ( i=0; i<ncolors; ++i ) {\n\t\toutput[i].r = gamma[0*256 + colors[i].r] >> 8;\n\t\toutput[i].g = gamma[1*256 + colors[i].g] >> 8;\n\t\toutput[i].b = gamma[2*256 + colors[i].b] >> 8;\n\t}\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n * Match an RGB value to a particular palette index\n */\n", "func_signal": "Uint8 SDL_FindColor(SDL_Palette *pal, Uint8 r, Uint8 g, Uint8 b)", "code": "{\n\t/* Do colorspace distance matching */\n\tunsigned int smallest;\n\tunsigned int distance;\n\tint rd, gd, bd;\n\tint i;\n\tUint8 pixel=0;\n\t\t\n\tsmallest = ~0;\n\tfor ( i=0; i<pal->ncolors; ++i ) {\n\t\trd = pal->colors[i].r - r;\n\t\tgd = pal->colors[i].g - g;\n\t\tbd = pal->colors[i].b - b;\n\t\tdistance = (rd*rd)+(gd*gd)+(bd*bd);\n\t\tif ( distance < smallest ) {\n\t\t\tpixel = i;\n\t\t\tif ( distance == 0 ) { /* Perfect match! */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsmallest = distance;\n\t\t}\n\t}\n\treturn(pixel);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Audio driver bootstrap functions */\n", "func_signal": "static int Audio_Available(void)", "code": "{\n\tint fd;\n\tint available;\n\n\tavailable = 0;\n\tfd = SDL_OpenAudioPath(NULL, 0, OPEN_FLAGS, 0);\n\tif ( fd >= 0 ) {\n\t\tavailable = 1;\n\t\tclose(fd);\n\t}\n\treturn(available);\n}", "path": "src\\audio\\dsp\\SDL_dspaudio.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Helper functions */\n/*\n * Allocate a pixel format structure and fill it according to the given info.\n */\n", "func_signal": "SDL_PixelFormat *SDL_AllocFormat(int bpp,\n\t\t\tUint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)", "code": "{\n\tSDL_PixelFormat *format;\n\tUint32 mask;\n\n\t/* Allocate an empty pixel format structure */\n\tformat = SDL_malloc(sizeof(*format));\n\tif ( format == NULL ) {\n\t\tSDL_OutOfMemory();\n\t\treturn(NULL);\n\t}\n\tSDL_memset(format, 0, sizeof(*format));\n\tformat->alpha = SDL_ALPHA_OPAQUE;\n\n\t/* Set up the format */\n\tformat->BitsPerPixel = bpp;\n\tformat->BytesPerPixel = (bpp+7)/8;\n\tif ( Rmask || Bmask || Gmask ) { /* Packed pixels with custom mask */\n\t\tformat->palette = NULL;\n\t\tformat->Rshift = 0;\n\t\tformat->Rloss = 8;\n\t\tif ( Rmask ) {\n\t\t\tfor ( mask = Rmask; !(mask&0x01); mask >>= 1 )\n\t\t\t\t++format->Rshift;\n\t\t\tfor ( ; (mask&0x01); mask >>= 1 )\n\t\t\t\t--format->Rloss;\n\t\t}\n\t\tformat->Gshift = 0;\n\t\tformat->Gloss = 8;\n\t\tif ( Gmask ) {\n\t\t\tfor ( mask = Gmask; !(mask&0x01); mask >>= 1 )\n\t\t\t\t++format->Gshift;\n\t\t\tfor ( ; (mask&0x01); mask >>= 1 )\n\t\t\t\t--format->Gloss;\n\t\t}\n\t\tformat->Bshift = 0;\n\t\tformat->Bloss = 8;\n\t\tif ( Bmask ) {\n\t\t\tfor ( mask = Bmask; !(mask&0x01); mask >>= 1 )\n\t\t\t\t++format->Bshift;\n\t\t\tfor ( ; (mask&0x01); mask >>= 1 )\n\t\t\t\t--format->Bloss;\n\t\t}\n\t\tformat->Ashift = 0;\n\t\tformat->Aloss = 8;\n\t\tif ( Amask ) {\n\t\t\tfor ( mask = Amask; !(mask&0x01); mask >>= 1 )\n\t\t\t\t++format->Ashift;\n\t\t\tfor ( ; (mask&0x01); mask >>= 1 )\n\t\t\t\t--format->Aloss;\n\t\t}\n\t\tformat->Rmask = Rmask;\n\t\tformat->Gmask = Gmask;\n\t\tformat->Bmask = Bmask;\n\t\tformat->Amask = Amask;\n\t} else if ( bpp > 8 ) {\t\t/* Packed pixels with standard mask */\n\t\t/* R-G-B */\n\t\tif ( bpp > 24 )\n\t\t\tbpp = 24;\n\t\tformat->Rloss = 8-(bpp/3);\n\t\tformat->Gloss = 8-(bpp/3)-(bpp%3);\n\t\tformat->Bloss = 8-(bpp/3);\n\t\tformat->Rshift = ((bpp/3)+(bpp%3))+(bpp/3);\n\t\tformat->Gshift = (bpp/3);\n\t\tformat->Bshift = 0;\n\t\tformat->Rmask = ((0xFF>>format->Rloss)<<format->Rshift);\n\t\tformat->Gmask = ((0xFF>>format->Gloss)<<format->Gshift);\n\t\tformat->Bmask = ((0xFF>>format->Bloss)<<format->Bshift);\n\t} else {\n\t\t/* Palettized formats have no mask info */\n\t\tformat->Rloss = 8;\n\t\tformat->Gloss = 8;\n\t\tformat->Bloss = 8;\n\t\tformat->Aloss = 8;\n\t\tformat->Rshift = 0;\n\t\tformat->Gshift = 0;\n\t\tformat->Bshift = 0;\n\t\tformat->Ashift = 0;\n\t\tformat->Rmask = 0;\n\t\tformat->Gmask = 0;\n\t\tformat->Bmask = 0;\n\t\tformat->Amask = 0;\n\t}\n\tif ( bpp <= 8 ) {\t\t\t/* Palettized mode */\n\t\tint ncolors = 1<<bpp;\n#ifdef DEBUG_PALETTE\n\t\tfprintf(stderr,\"bpp=%d ncolors=%d\\n\",bpp,ncolors);\n#endif\n\t\tformat->palette = (SDL_Palette *)SDL_malloc(sizeof(SDL_Palette));\n\t\tif ( format->palette == NULL ) {\n\t\t\tSDL_FreeFormat(format);\n\t\t\tSDL_OutOfMemory();\n\t\t\treturn(NULL);\n\t\t}\n\t\t(format->palette)->ncolors = ncolors;\n\t\t(format->palette)->colors = (SDL_Color *)SDL_malloc(\n\t\t\t\t(format->palette)->ncolors*sizeof(SDL_Color));\n\t\tif ( (format->palette)->colors == NULL ) {\n\t\t\tSDL_FreeFormat(format);\n\t\t\tSDL_OutOfMemory();\n\t\t\treturn(NULL);\n\t\t}\n\t\tif ( Rmask || Bmask || Gmask ) {\n\t\t\t/* create palette according to masks */\n\t\t\tint i;\n\t\t\tint Rm=0,Gm=0,Bm=0;\n\t\t\tint Rw=0,Gw=0,Bw=0;\n#ifdef ENABLE_PALETTE_ALPHA\n\t\t\tint Am=0,Aw=0;\n#endif\n\t\t\tif(Rmask)\n\t\t\t{\n\t\t\t\tRw=8-format->Rloss;\n\t\t\t\tfor(i=format->Rloss;i>0;i-=Rw)\n\t\t\t\t\tRm|=1<<i;\n\t\t\t}\n#ifdef DEBUG_PALETTE\n\t\t\tfprintf(stderr,\"Rw=%d Rm=0x%02X\\n\",Rw,Rm);\n#endif\n\t\t\tif(Gmask)\n\t\t\t{\n\t\t\t\tGw=8-format->Gloss;\n\t\t\t\tfor(i=format->Gloss;i>0;i-=Gw)\n\t\t\t\t\tGm|=1<<i;\n\t\t\t}\n#ifdef DEBUG_PALETTE\n\t\t\tfprintf(stderr,\"Gw=%d Gm=0x%02X\\n\",Gw,Gm);\n#endif\n\t\t\tif(Bmask)\n\t\t\t{\n\t\t\t\tBw=8-format->Bloss;\n\t\t\t\tfor(i=format->Bloss;i>0;i-=Bw)\n\t\t\t\t\tBm|=1<<i;\n\t\t\t}\n#ifdef DEBUG_PALETTE\n\t\t\tfprintf(stderr,\"Bw=%d Bm=0x%02X\\n\",Bw,Bm);\n#endif\n#ifdef ENABLE_PALETTE_ALPHA\n\t\t\tif(Amask)\n\t\t\t{\n\t\t\t\tAw=8-format->Aloss;\n\t\t\t\tfor(i=format->Aloss;i>0;i-=Aw)\n\t\t\t\t\tAm|=1<<i;\n\t\t\t}\n# ifdef DEBUG_PALETTE\n\t\t\tfprintf(stderr,\"Aw=%d Am=0x%02X\\n\",Aw,Am);\n# endif\n#endif\n\t\t\tfor(i=0; i < ncolors; ++i) {\n\t\t\t\tint r,g,b;\n\t\t\t\tr=(i&Rmask)>>format->Rshift;\n\t\t\t\tr=(r<<format->Rloss)|((r*Rm)>>Rw);\n\t\t\t\tformat->palette->colors[i].r=r;\n\n\t\t\t\tg=(i&Gmask)>>format->Gshift;\n\t\t\t\tg=(g<<format->Gloss)|((g*Gm)>>Gw);\n\t\t\t\tformat->palette->colors[i].g=g;\n\n\t\t\t\tb=(i&Bmask)>>format->Bshift;\n\t\t\t\tb=(b<<format->Bloss)|((b*Bm)>>Bw);\n\t\t\t\tformat->palette->colors[i].b=b;\n\n#ifdef ENABLE_PALETTE_ALPHA\n\t\t\t\ta=(i&Amask)>>format->Ashift;\n\t\t\t\ta=(a<<format->Aloss)|((a*Am)>>Aw);\n\t\t\t\tformat->palette->colors[i].unused=a;\n#else\n\t\t\t\tformat->palette->colors[i].unused=0;\n#endif\n\t\t\t}\n\t\t} else if ( ncolors == 2 ) {\n\t\t\t/* Create a black and white bitmap palette */\n\t\t\tformat->palette->colors[0].r = 0xFF;\n\t\t\tformat->palette->colors[0].g = 0xFF;\n\t\t\tformat->palette->colors[0].b = 0xFF;\n\t\t\tformat->palette->colors[1].r = 0x00;\n\t\t\tformat->palette->colors[1].g = 0x00;\n\t\t\tformat->palette->colors[1].b = 0x00;\n\t\t} else {\n\t\t\t/* Create an empty palette */\n\t\t\tSDL_memset((format->palette)->colors, 0,\n\t\t\t\t(format->palette)->ncolors*sizeof(SDL_Color));\n\t\t}\n\t}\n\treturn(format);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/* Map from Palette to BitField */\n", "func_signal": "static Uint8 *Map1toN(SDL_PixelFormat *src, SDL_PixelFormat *dst)", "code": "{\n\tUint8 *map;\n\tint i;\n\tint  bpp;\n\tunsigned alpha;\n\tSDL_Palette *pal = src->palette;\n\n\tbpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n\tmap = (Uint8 *)SDL_malloc(pal->ncolors*bpp);\n\tif ( map == NULL ) {\n\t\tSDL_OutOfMemory();\n\t\treturn(NULL);\n\t}\n\n\talpha = dst->Amask ? src->alpha : 0;\n\t/* We memory copy to the pixel map so the endianness is preserved */\n\tfor ( i=0; i<pal->ncolors; ++i ) {\n\t\tASSEMBLE_RGBA(&map[i*bpp], dst->BytesPerPixel, dst,\n\t\t\t      pal->colors[i].r, pal->colors[i].g,\n\t\t\t      pal->colors[i].b, alpha);\n\t}\n\treturn(map);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n * Change any previous mappings from/to the new surface format\n */\n", "func_signal": "void SDL_FormatChanged(SDL_Surface *surface)", "code": "{\n\tstatic int format_version = 0;\n\t++format_version;\n\tif ( format_version < 0 ) { /* It wrapped... */\n\t\tformat_version = 1;\n\t}\n\tsurface->format_version = format_version;\n\tSDL_InvalidateMap(surface->map);\n}", "path": "src\\video\\SDL_pixels.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n * Called when focus is regained, to read the keyboard state and generate\n * synthetic keypress/release events.\n * key_vec is a bit vector of keycodes (256 bits)\n */\n", "func_signal": "void X11_SetKeyboardState(Display *display, const char *key_vec)", "code": "{\n\tchar keys_return[32];\n\tint i;\n\tUint8 *kstate = SDL_GetKeyState(NULL);\n\tSDLMod modstate;\n\tWindow junk_window;\n\tint x, y;\n\tunsigned int mask;\n\n\t/* The first time the window is mapped, we initialize key state */\n\tif ( ! key_vec ) {\n\t\tXQueryKeymap(display, keys_return);\n\t\tkey_vec = keys_return;\n\t}\n\n\t/* Get the keyboard modifier state */\n\tmodstate = 0;\n\tget_modifier_masks(display);\n\tif ( XQueryPointer(display, DefaultRootWindow(display),\n\t\t&junk_window, &junk_window, &x, &y, &x, &y, &mask) ) {\n\t\tif ( mask & LockMask ) {\n\t\t\tmodstate |= KMOD_CAPS;\n\t\t}\n\t\tif ( mask & mode_switch_mask ) {\n\t\t\tmodstate |= KMOD_MODE;\n\t\t}\n\t\tif ( mask & num_mask ) {\n\t\t\tmodstate |= KMOD_NUM;\n\t\t}\n\t}\n\n\t/* Zero the new keyboard state and generate it */\n\tSDL_memset(kstate, 0, SDLK_LAST);\n\t/*\n\t * An obvious optimisation is to check entire longwords at a time in\n\t * both loops, but we can't be sure the arrays are aligned so it's not\n\t * worth the extra complexity\n\t */\n\tfor ( i = 0; i < 32; i++ ) {\n\t\tint j;\n\t\tif ( !key_vec[i] )\n\t\t\tcontinue;\n\t\tfor ( j = 0; j < 8; j++ ) {\n\t\t\tif ( key_vec[i] & (1 << j) ) {\n\t\t\t\tSDLKey key;\n\t\t\t\tKeyCode kc = (i << 3 | j);\n\t\t\t\tkey = X11_TranslateKeycode(display, kc);\n\t\t\t\tif ( key == SDLK_UNKNOWN ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tkstate[key] = SDL_PRESSED;\n\t\t\t\tswitch (key) {\n\t\t\t\t    case SDLK_LSHIFT:\n\t\t\t\t\tmodstate |= KMOD_LSHIFT;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_RSHIFT:\n\t\t\t\t\tmodstate |= KMOD_RSHIFT;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_LCTRL:\n\t\t\t\t\tmodstate |= KMOD_LCTRL;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_RCTRL:\n\t\t\t\t\tmodstate |= KMOD_RCTRL;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_LALT:\n\t\t\t\t\tmodstate |= KMOD_LALT;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_RALT:\n\t\t\t\t\tmodstate |= KMOD_RALT;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_LMETA:\n\t\t\t\t\tmodstate |= KMOD_LMETA;\n\t\t\t\t\tbreak;\n\t\t\t\t    case SDLK_RMETA:\n\t\t\t\t\tmodstate |= KMOD_RMETA;\n\t\t\t\t\tbreak;\n\t\t\t\t    default:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Hack - set toggle key state */\n\tif ( modstate & KMOD_CAPS ) {\n\t\tkstate[SDLK_CAPSLOCK] = SDL_PRESSED;\n\t} else {\n\t\tkstate[SDLK_CAPSLOCK] = SDL_RELEASED;\n\t}\n\tif ( modstate & KMOD_NUM ) {\n\t\tkstate[SDLK_NUMLOCK] = SDL_PRESSED;\n\t} else {\n\t\tkstate[SDLK_NUMLOCK] = SDL_RELEASED;\n\t}\n\n\t/* Set the final modifier state */\n\tSDL_SetModState(modstate);\n}", "path": "src\\video\\x11\\SDL_x11events.c", "repo_name": "eugenis/sdl-nacl", "stars": 10, "license": "lgpl-2.1", "language": "c", "size": 4480}
{"docstring": "/*\n */\n", "func_signal": "static\nint \np_rl_free(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  IDTYPE id;\n  RL_Tree* tree;\n  \n  // Check args\n  if (YAP_IsVarTerm(t1)) \n    return(FALSE);\n\n  id=YAP_IntOfTerm(t1);\n  tree=ID2PTR(id);\n#ifdef STATS  \n  FREE_MEM_USAGE(tree);\n#endif\n\n  free_rl(tree);\n\n  return (TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n  minimum: min(x,y)\n*/\n", "func_signal": "static Term\np_min(Term t1, Term t2)", "code": "{\n  switch (ETypeOfTerm(t1)) {\n  case long_int_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i1 = IntegerOfTerm(t1);\n\tInt i2 = IntegerOfTerm(t2);\n\treturn((i1 < i2 ? t1 : t2));\n      }\n    case double_e:\n      {\n\t/* integer, double */\n\tInt i = IntegerOfTerm(t1);\n\tFloat fl = FloatOfTerm(t2);\n\tif (i <= fl) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tInt i = IntegerOfTerm(t1);\n\tMP_INT *b = Yap_BigIntOfTerm(t2);\n\n\tif (mpz_cmp_si(b,i) < 0) {\n\t  return t2;\n\t}\n\treturn t1;\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case double_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      /* float / integer */\n      {\n\tInt i = IntegerOfTerm(t2);\n\tFloat fl = FloatOfTerm(t1);\n\tif (i <= fl) {\n\t  return t2;\n\t}\n\treturn t1;\n      }\n    case double_e:\n      {\n\tFloat fl1 = FloatOfTerm(t1);\n\tFloat fl2 = FloatOfTerm(t2);\n\tif (fl1 <= fl2) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tFloat fl1 = FloatOfTerm(t1);\n\tFloat fl2 = mpz_get_d(Yap_BigIntOfTerm(t2));\n\tif (fl1 <= fl2) {\n\t  return t1;\n\t} else {\n\t  return t2;\n\t}\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case big_int_e:\n#ifdef USE_GMP\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i = IntegerOfTerm(t2);\n\tMP_INT *b = Yap_BigIntOfTerm(t1);\n\n\tif (mpz_cmp_si(b,i) < 0) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n      /* two bignums */\n      {\n\tMP_INT *b1 = Yap_BigIntOfTerm(t1);\n\tMP_INT *b2 = Yap_BigIntOfTerm(t2);\n\n\tif (mpz_cmp(b1,b2) < 0) {\n\t  return t1;\n\t} else {\n\t  return t2;\n\t}\n      }\n    case double_e:\n      {\n\tFloat fl1 = FloatOfTerm(t2);\n\tFloat fl2 = mpz_get_d(Yap_BigIntOfTerm(t1));\n\tif (fl1 <= fl2) {\n\t  return t2;\n\t} else {\n\t  return t1;\n\t}\n      }\n    default:\n      RERROR();\n    }\n#endif\n  default:\n    RERROR();\n  }\n  RERROR();\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_freeze(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  IDTYPE id;\n  RL_Tree *tree;\n\n  // Check args\n  if (YAP_IsVarTerm(t1) )\n    return(FALSE);\n\n  id = YAP_IntOfTerm(t1);\n  tree=ID2PTR(id);\n  \n\n#ifdef STATS\n  STORE_TREE_SIZE(tree);\n  freeze_rl(tree);\n  UPDATE_MEM_USAGE(tree);\n#else\n  freeze_rl(tree);\n#endif\n\n  return (TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/* itrie_close_all() */\n", "func_signal": "static int p_itrie_close_all(void)", "code": "{\n  itrie_close_all();\n  return TRUE;\n}", "path": "library\\tries\\itries.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/* -------------------------- */\n", "func_signal": "void init_itries(void)", "code": "{\n  itrie_init_module();\n\n  YAP_UserCPredicate(\"itrie_open\", p_itrie_open, 1);\n  YAP_UserCPredicate(\"itrie_close\", p_itrie_close, 1);\n  YAP_UserCPredicate(\"itrie_close_all\", p_itrie_close_all, 0);\n  YAP_UserCPredicate(\"itrie_mode\", p_itrie_mode, 2);\n  YAP_UserCPredicate(\"itrie_timestamp\", p_itrie_timestamp, 2);\n  YAP_UserCPredicate(\"itrie_put_entry\", p_itrie_put_entry, 2);\n  YAP_UserCPredicate(\"itrie_update_entry\", p_itrie_update_entry, 2);\n  YAP_UserCPredicate(\"itrie_check_entry\", p_itrie_check_entry, 3);\n  YAP_UserCPredicate(\"itrie_get_entry\", p_itrie_get_entry, 2);\n  YAP_UserCPredicate(\"itrie_get_data\", p_itrie_get_data, 2);\n  YAP_UserBackCPredicate(\"itrie_traverse\", p_itrie_traverse_init, p_itrie_traverse_cont, 2, 0);\n  YAP_UserCPredicate(\"itrie_remove_entry\", p_itrie_remove_entry, 1);\n  YAP_UserCPredicate(\"itrie_remove_subtree\", p_itrie_remove_subtree, 1);\n  YAP_UserCPredicate(\"itrie_add\", p_itrie_add, 2);\n  YAP_UserCPredicate(\"itrie_subtract\", p_itrie_subtract, 2);\n  YAP_UserCPredicate(\"itrie_join\", p_itrie_join, 2);\n  YAP_UserCPredicate(\"itrie_intersect\", p_itrie_intersect, 2);\n  YAP_UserCPredicate(\"itrie_count_join\", p_itrie_count_join, 3);\n  YAP_UserCPredicate(\"itrie_count_intersect\", p_itrie_count_intersect, 3);\n  YAP_UserCPredicate(\"itrie_save\", p_itrie_save, 2);\n  YAP_UserCPredicate(\"itrie_save_as_trie\", p_itrie_save_as_trie, 2);\n  YAP_UserCPredicate(\"itrie_load\", p_itrie_load, 2);\n  YAP_UserCPredicate(\"itrie_save2stream\", p_itrie_save2stream, 2);\n  YAP_UserCPredicate(\"itrie_loadFromstream\", p_itrie_loadFromStream, 2);\n  YAP_UserCPredicate(\"itrie_stats\", p_itrie_stats, 4);\n  YAP_UserCPredicate(\"itrie_max_stats\", p_itrie_max_stats, 4);\n  YAP_UserCPredicate(\"itrie_usage\", p_itrie_usage, 4);\n  YAP_UserCPredicate(\"itrie_print\", p_itrie_print, 1);\n  return;\n}", "path": "library\\tries\\itries.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_size(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1),t_size;\n  IDTYPE id;\n  RL_Tree* tree;\n  unsigned int size;\n\n  if (YAP_IsVarTerm(t1))\n    return(FALSE);\n\n  id = YAP_IntOfTerm(t1);\n  tree=ID2PTR(id);\n  \n  size=tree->size*sizeof(RL_Node)+sizeof(RL_Tree);\n  t_size=YAP_MkIntTerm(size);\n  if(!YAP_Unify(YAP_ARG2,t_size) )   \n    return (FALSE);\n  \n  return(TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/* next function is adapted from:\n   Inline C++ integer exponentiation routines \n   Version 1.01\n   Copyright (C) 1999-2004 John C. Bowman <bowman@math.ualberta.ca>\n*/\n", "func_signal": "static inline Int\nipow(Int x, Int p)", "code": "{\n  Int r;\n\n  if (p == 0) return 1L;\n  if (x == 0 && p > 0) return 0L;\n  if(p < 0) \n    return (-p % 2) ? x : 1L;\n\t\n  r = 1L;\n  for(;;) {\n    if(p & 1) {\n      if (mul_overflow((r*x), r, x)) {\n\treturn 0;\n      }\n      r *= x;\n    }\n    if((p >>= 1) == 0)\treturn r;\n    if (mul_overflow((x*x), x, x)) {\n      return 0;\n    }\n    x *= x;\n  }\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_in(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  YAP_Term t2=YAP_Deref(YAP_ARG2);\n  IDTYPE id;\n  NUM val;\n  RL_Tree *tree;\n\n  // Check args\n  if (YAP_IsVarTerm(t1) || YAP_IsVarTerm(t2) )\n    return(FALSE);\n\n  id = YAP_IntOfTerm(t1);\n  val = YAP_IntOfTerm(t2);\n\n  tree=ID2PTR(id);\n\n  if ( in_rl(tree,val) ) \n    return (TRUE);\n  return (FALSE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_set_in(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  YAP_Term t2=YAP_Deref(YAP_ARG2);\n  IDTYPE id;\n  NUM val;\n  RL_Tree *tree;\n\n  // Check args\n  if (YAP_IsVarTerm(t1) || YAP_IsVarTerm(t2) )\n    return(FALSE);\n\n  id = YAP_IntOfTerm(t1);\n  val = YAP_IntOfTerm(t2);\n\n  tree=ID2PTR(id);\n\n#ifdef STATS\n  STORE_TREE_SIZE(tree);\n  set_in_rl(tree,val,IN);\n  UPDATE_MEM_USAGE(tree);\n#else\n  set_in_rl(tree,val,IN);\n#endif\n  return (TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_copy(void)", "code": "{\n  YAP_Term t1=YAP_Deref(YAP_ARG1); // src\n  YAP_Term t2=YAP_Deref(YAP_ARG2); // dest\n  RL_Tree* new_tree;\n  IDTYPE  id1,newid;\n  RL_Tree* tree;\n\n  // Check args\n  if (!YAP_IsIntTerm(t1))\n    return(FALSE);\n  if (!YAP_IsVarTerm(t2)) \n    return(FALSE);\n  //\n  id1=YAP_IntOfTerm(t1);\n  tree=ID2PTR(id1);\n  new_tree=copy_rl(tree);\n\n  if(new_tree==NULL) {\n    fprintf(stderr,\"Error creating new rl.\");\n    return (FALSE);\n  }\n  //\n#ifdef STATS\n  ADD_MEM_USAGE(new_tree);\n#endif\n\n  // return list reference\n  newid=YAP_MkIntTerm(PTR2ID(new_tree));\n  if(!YAP_Unify(YAP_Deref(YAP_ARG2),newid)) \n    return (FALSE);  \n  return(TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/* -------------------------- **\n**      Global functions      **\n** -------------------------- */\n", "func_signal": "void make_root_choice_point(void)", "code": "{\n  if (worker_id == 0) {\n    LOCAL_top_cp = GLOBAL_root_cp = OrFr_node(GLOBAL_root_or_fr) = B;\n  } else {\n    B = LOCAL_top_cp = GLOBAL_root_cp;\n    B->cp_tr = TR = ((choiceptr) (worker_offset(0) + (CELL)(B)))->cp_tr;\n  }\n  B->cp_h = H0;\n  B->cp_ap = GETWORK;\n  B->cp_or_fr = GLOBAL_root_or_fr;\n  LOCAL_top_or_fr = GLOBAL_root_or_fr;\n  LOCAL_load = 0;\n  Set_LOCAL_prune_request(NULL);\n  BRANCH(worker_id, 0) = 0;\n#ifdef TABLING_INNER_CUTS\n  LOCAL_pruning_scope = NULL;\n#endif /* TABLING_INNER_CUTS */\n#ifdef TABLING\n  LOCAL_top_cp_on_stack = LOCAL_top_cp;\n  adjust_freeze_registers();\n#endif /* TABLING */\n  return;\n}", "path": "OPTYap\\or.engine.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_mem_usage(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n\n  if(!YAP_Unify(t1,YAP_MkIntTerm(memory_usage)) )   \n    return (FALSE);\n  \n  return(TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n  maximum: max(x,y)\n*/\n", "func_signal": "static Term\np_max(Term t1, Term t2)", "code": "{\n  switch (ETypeOfTerm(t1)) {\n  case long_int_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i1 = IntegerOfTerm(t1);\n\tInt i2 = IntegerOfTerm(t2);\n\treturn((i1 > i2 ? t1 : t2));\n      }\n    case double_e:\n      {\n\t/* integer, double */\n\tInt i = IntegerOfTerm(t1);\n\tFloat fl = FloatOfTerm(t2);\n\tif (i >= fl) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tInt i = IntegerOfTerm(t1);\n\tMP_INT *b = Yap_BigIntOfTerm(t2);\n\n\tif (mpz_cmp_si(b,i) > 0) {\n\t  return t2;\n\t}\n\treturn t1;\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case double_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      /* float / integer */\n      {\n\tInt i = IntegerOfTerm(t2);\n\tFloat fl = FloatOfTerm(t1);\n\tif (i >= fl) {\n\t  return t2;\n\t}\n\treturn t1;\n      }\n    case double_e:\n      {\n\tFloat fl1 = FloatOfTerm(t1);\n\tFloat fl2 = FloatOfTerm(t2);\n\tif (fl1 >= fl2) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tFloat fl1 = FloatOfTerm(t1);\n\tFloat fl2 = mpz_get_d(Yap_BigIntOfTerm(t2));\n\tif (fl1 >= fl2) {\n\t  return t1;\n\t} else {\n\t  return t2;\n\t}\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case big_int_e:\n#ifdef USE_GMP\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i = IntegerOfTerm(t2);\n\tMP_INT *b = Yap_BigIntOfTerm(t1);\n\n\tif (mpz_cmp_si(b,i) > 0) {\n\t  return t1;\n\t}\n\treturn t2;\n      }\n    case big_int_e:\n      /* two bignums */\n      {\n\tMP_INT *b1 = Yap_BigIntOfTerm(t1);\n\tMP_INT *b2 = Yap_BigIntOfTerm(t2);\n\n\tif (mpz_cmp(b1,b2) > 0) {\n\t  return t1;\n\t} else {\n\t  return t2;\n\t}\n      }\n    case double_e:\n      {\n\tFloat fl1 = FloatOfTerm(t2);\n\tFloat fl2 = mpz_get_d(Yap_BigIntOfTerm(t1));\n\tif (fl1 >= fl2) {\n\t  return t2;\n\t} else {\n\t  return t1;\n\t}\n      }\n    default:\n      RERROR();\n    }\n#endif\n  default:\n    RERROR();\n  }\n  RERROR();\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n */\n", "func_signal": "static\nint \np_rl_new(void)", "code": "{\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  YAP_Term t2=YAP_Deref(YAP_ARG2);\n  RL_Tree* new_tree;\n  IDTYPE  newid;\n\n  // Check args\n  if (!YAP_IsIntTerm(t1) || !YAP_IsVarTerm(t2)) {\n    fprintf(stderr,\"Error in rl_new arguments\\n\");\n    return(FALSE);\n  }\n  //\n  new_tree=new_rl(YAP_IntOfTerm(t1));\n  if(new_tree==NULL) {\n    fprintf(stderr,\"Error creating new rl.\");\n    return (FALSE);\n  }\n  //printf(\"New rl %d %p--%u\\n\",PTR2ID(new_tree),new_tree,(int)new_tree,YAP_IntOfTerm(t1));\n  // return reference\n  newid=YAP_MkIntTerm(PTR2ID(new_tree));\n  if(!YAP_Unify(YAP_Deref(YAP_ARG2),newid)) \n    return (FALSE);\n  \n  return(TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_b_in2(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  IDTYPE id;\n  NUM val;\n  RL_Tree *tree;\n\n  YAP_PRESERVED_DATA(back_data,yap_back_data_type);\n  id = YAP_IntOfTerm(t1);\n  tree=ID2PTR(id);\n  val=YAP_IntOfTerm(back_data->last_solution);\n  val=rl_next_in_bigger(tree,val);\n  if ( val > 0 && YAP_Unify(YAP_Deref(YAP_ARG2),YAP_MkIntTerm(val))) {\n    back_data->last_solution=YAP_MkIntTerm(val);\n    return TRUE;\n  }\n  YAP_cut_fail();\n  return (FALSE); \n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_print(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  IDTYPE id;\n  RL_Tree *tree;\n\n  // Check args\n  if (YAP_IsVarTerm(t1) ) {\n    fprintf(stderr,\"Error printing tree..\");\n    return(FALSE);\n  }\n  id = YAP_IntOfTerm(t1);\n  tree=ID2PTR(id);\n  \n  display_tree(tree);\n  \n  return (TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n  power: x^y\n*/\n", "func_signal": "static Term\np_power(Term t1, Term t2)", "code": "{\n  switch (ETypeOfTerm(t1)) {\n  case long_int_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i2 = IntegerOfTerm(t2);\n\n\t/* two integers */\n\tRFLOAT(pow(IntegerOfTerm(t1),i2));\n      }\n    case double_e:\n      {\n\t/* integer, double */\n\tFloat fl1 = (Float)IntegerOfTerm(t1);\n\tFloat fl2 = FloatOfTerm(t2);\n\tRFLOAT(pow(fl1,fl2));\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tInt i1 = IntegerOfTerm(t1);\n\tFloat f2 = mpz_get_d(Yap_BigIntOfTerm(t2));\n\tRFLOAT(pow(i1,f2));\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case double_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      /* float / integer */\n      {\n\tInt i2 = IntegerOfTerm(t2);\n\tRFLOAT(pow(FloatOfTerm(t1),i2));\n      }\n    case double_e:\n      {\n\tFloat f2 = FloatOfTerm(t2);\n\tRFLOAT(pow(FloatOfTerm(t1),f2));\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tRFLOAT(pow(FloatOfTerm(t1),mpz_get_d(Yap_BigIntOfTerm(t2))));\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case big_int_e:\n#ifdef USE_GMP\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i = IntegerOfTerm(t2);\n\tRFLOAT(pow(mpz_get_d(Yap_BigIntOfTerm(t1)),i));\n      }\n    case big_int_e:\n      /* two bignums */\n      RFLOAT(pow(mpz_get_d(Yap_BigIntOfTerm(t1)),mpz_get_d(Yap_BigIntOfTerm(t2))));\n    case double_e:\n      {\n\tFloat dbl = FloatOfTerm(t2);\n\tRFLOAT(pow(mpz_get_d(Yap_BigIntOfTerm(t1)),dbl));\n      }\n    default:\n      RERROR();\n    }\n#endif\n  default:\n    RERROR();\n  }\n  RERROR();\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n  Floating point division: /\n*/\n", "func_signal": "static Term\np_fdiv(Term t1, Term t2)", "code": "{\n  switch (ETypeOfTerm(t1)) {\n  case long_int_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i2 = IntegerOfTerm(t2);\n\n\t/* two integers */\n\tRFLOAT((((Float)IntegerOfTerm(t1))/(Float)i2));\n      }\n    case double_e:\n      {\n\t/* integer, double */\n\tFloat fl1 = (Float)IntegerOfTerm(t1);\n\tFloat fl2 = FloatOfTerm(t2);\n\tRFLOAT(fl1/fl2);\n      }\n    case (CELL)big_int_e:\n#ifdef USE_GMP\n      {\n\tInt i1 = IntegerOfTerm(t1);\n\tFloat f2 = mpz_get_d(Yap_BigIntOfTerm(t2));\n\tRFLOAT(((Float)i1/f2));\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case double_e:\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      /* float / integer */\n      {\n\tInt i2 = IntegerOfTerm(t2);\n\tRFLOAT(FloatOfTerm(t1)/(Float)i2);\n      }\n    case double_e:\n      {\n\tFloat f2 = FloatOfTerm(t2);\n\tRFLOAT(FloatOfTerm(t1)/f2);\n      }\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tRFLOAT(FloatOfTerm(t1)/mpz_get_d(Yap_BigIntOfTerm(t2)));\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case big_int_e:\n#ifdef USE_GMP\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tInt i = IntegerOfTerm(t2);\n\tRFLOAT(mpz_get_d(Yap_BigIntOfTerm(t1))/(Float)i);\n      }\n    case big_int_e:\n      /* two bignums*/\n      RFLOAT(fdiv_bigint(Yap_BigIntOfTerm(t1),Yap_BigIntOfTerm(t2)));\n      //      RFLOAT(mpz_get_d(Yap_BigIntOfTerm(t1))/mpz_get_d(Yap_BigIntOfTerm(t2)));\n    case double_e:\n      {\n\tFloat dbl = FloatOfTerm(t2);\n\tRFLOAT(mpz_get_d(Yap_BigIntOfTerm(t1))/dbl);\n      }\n    default:\n      RERROR();\n    }\n#endif\n  default:\n    RERROR();\n  }\n  RERROR();\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n *\n *\n */\n", "func_signal": "static\nint \np_rl_set_out(void)", "code": "{\n\n  YAP_Term t1=YAP_Deref(YAP_ARG1);\n  YAP_Term t2=YAP_Deref(YAP_ARG2);\n  IDTYPE id;\n  NUM val;\n  RL_Tree *tree;\n\n  // Check args\n  if (YAP_IsVarTerm(t1) || YAP_IsVarTerm(t2) )\n    return(FALSE);\n\n  id = YAP_IntOfTerm(t1);\n  val = YAP_IntOfTerm(t2);\n\n  tree=ID2PTR(id);\n#ifdef STATS\n  STORE_TREE_SIZE(tree);\n  set_in_rl(tree,val,OUT);\n  UPDATE_MEM_USAGE(tree);\n#else\n  set_in_rl(tree,val,OUT);\n#endif\n  return (TRUE);\n}", "path": "library\\rltree\\yap_rl.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/*\n  xor #\n*/\n", "func_signal": "static Term\np_xor(Term t1, Term t2)", "code": "{\n  switch (ETypeOfTerm(t1)) {\n  case long_int_e:\n    \n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      /* two integers */\n      RINT(IntegerOfTerm(t1) ^ IntegerOfTerm(t2));\n    case double_e:\n      return Yap_ArithError(TYPE_ERROR_INTEGER, t2, \"#/2\");\n    case big_int_e:\n#ifdef USE_GMP\n      {\n\tMP_INT new;\n\n\tmpz_init_set_si(&new,IntegerOfTerm(t1));\n\tmpz_xor(&new, &new, Yap_BigIntOfTerm(t2));\n\tRBIG(&new);\n      }\n#endif\n    default:\n      RERROR();\n    }\n    break;\n  case double_e:\n    return Yap_ArithError(TYPE_ERROR_INTEGER, t1, \"#/2\");\n  case big_int_e:\n#ifdef USE_GMP\n    switch (ETypeOfTerm(t2)) {\n    case long_int_e:\n      {\n\tMP_INT new;\n\n\tmpz_init_set_si(&new,IntegerOfTerm(t2));\n\tmpz_xor(&new, Yap_BigIntOfTerm(t1), &new);\n\tRBIG(&new);\n      }\n    case big_int_e:\n      /* two bignums */\n      {\n\tMP_INT new;\n\n\tmpz_init_set(&new, Yap_BigIntOfTerm(t1));\n\tmpz_xor(&new, &new, Yap_BigIntOfTerm(t2));\n\tRBIG(&new);\n      }\n    case double_e:\n      return Yap_ArithError(TYPE_ERROR_INTEGER, t2, \"#/2\");\n    default:\n      RERROR();\n    }\n#endif\n  default:\n    RERROR();\n  }\n  RERROR();\n}", "path": "C\\arith2.c", "repo_name": "flavioc/yap", "stars": 9, "license": "other", "language": "c", "size": 14588}
{"docstring": "/* remove the root of the heap, and put it on out */\n", "func_signal": "static huffman_tree *heap_rm(heap *heap)", "code": "{\n    huffman_tree *res;\n    unsigned int i, min, l, r;\n\n    res = heap->array[0];\n    heap->size--;\n    heap->array[0] = heap->array[heap->size];\n    heap->array[heap->size] = NULL;\n    i = 0;\n    while (i < heap->size)\n    {\n\tmin = i;\n\tl = (i * 2) + 1;\n\tr = (i * 2) + 2;\n\tif (l < heap->size &&\n\t\theap->array[i]->occurrence > heap->array[l]->occurrence)\n\t    min = l;\n\tif (r < heap->size &&\n\t\theap->array[min]->occurrence > heap->array[r]->occurrence)\n\t    min = r;\n\tif (min != i)\n\t{\n\t    swap(heap->array[i], heap->array[min]);\n\t    i = min;\n\t}\n\telse\n\t    i = heap->size; /* force the loop to end */\n    };\n    return res;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* build the huffman tree, and return it */\n", "func_signal": "static huffman_tree *build_huffman(const void *varray, const size_t n)", "code": "{\n    unsigned int i;\n    huffman_tree **tree;\n    huffman_tree *father;\n    int8_t *array = (int8_t *)varray;\n    heap H;\n\n    tree = malloc(256 * sizeof(huffman_tree *));\n    for (i = 0; i < 256; i++)\n    {\n\ttree[i] = malloc(sizeof(huffman_tree));\n\ttree[i]->letter = i;\n\ttree[i]->occurrence = 0;\n\ttree[i]->fd = NULL;\n\ttree[i]->fg = NULL;\n    };\n    for (i = 0; i < n; i++)\n\ttree[(unsigned char) array[i]]->occurrence++;\n\n    /* put in the heap */\n    H.size = 0;\n    H.array = malloc(256 * sizeof(huffman_tree *));\n    for (i = 0; i < 256; i++)\n\theap_add(&H, tree[i]);\n\n    /* build the huffman tree */\n    while (H.size > 1)\n    {\n\tfather = malloc(sizeof(huffman_tree));\n\tfather->fd = heap_rm(&H);\n\tfather->fg = heap_rm(&H);\n\tfather->occurrence = father->fd->occurrence + father->fg->occurrence;\n\theap_add(&H, father);\n    }\n    father = heap_rm(&H);\n    free(tree);\n    free(H.array);\n    return father;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* encode the data\n * n is the size of varray and will be, when the function returns, the\n * size of the array returned\n */\n", "func_signal": "uint8_t *huffman_encode(const void *varray, size_t *n)", "code": "{\n    struct huffman_code code[256], letter_code;\n    uint8_t *res = malloc(*n * 2 * sizeof(uint8_t)); /* should be enough */\n    uint8_t *sentry = res;\n    uint8_t *array = (uint8_t *)varray;\n    unsigned int i, j, shift;\n    uint8_t to_write;\n    huffman_tree *H;\n\n    H = build_huffman(varray, *n);\n    put_code_on_huffman(H, 0, 0);\n    build_code(H, code);\n    /*\n    *((size_t *)res) = *n;\n    sentry += sizeof(size_t);\n    */\n    huffman_write_tree(H, &sentry);\n    shift = 0;\n    to_write = 0;\n    for (i = 0; i < *n; i++)\n    {\n\t/* get the code associated with the letter array[i] */\n\tletter_code = code[array[i]];\n\tfor (j = 0; j < letter_code.length; j++)\n\t{\n\t    /* write bit per bit on to_write, which is \"a buffer\" */\n\t    to_write |= (ith_bit(letter_code.code, letter_code.length - j)\n\t\t\t<< (7 - shift));\n\t    shift++;\n\t    /* if to_write is full, write it to the array */\n\t    if (shift == 8)\n\t    {\n\t\t*sentry = to_write;\n\t\tsentry++;\n\t\tshift = 0;\n\t\tto_write = 0;\n\t    }\n\t}\n    }\n    /* write the last letter to the array, in case of... */\n    if (shift != 0)\n    {\n\t*sentry = to_write << (7 - shift);\n\tsentry++;\n    }\n    *n = (sentry - res);\n    res = realloc(res, *n);\n    destroy_huffman(H);\n    return res;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* just call the wavelets, defined in OCaml */\n", "func_signal": "static value wavelets_direct_fun(const value array)", "code": "{\n    static value *func_ptr = NULL;\n    value res;\n\n    if (!func_ptr)\n\tfunc_ptr = caml_named_value(\"Haar_Direct\");\n    res = callback(*func_ptr, array);\n    return res;\n}", "path": "src\\cli\\compression\\wavelet.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* seems OK */\n", "func_signal": "static void *encode(int *x, const size_t n, const int nb_bits, size_t *size)", "code": "{\n    void *res;\n    char *tab;\n    size_t i;\n    int j;\n    char buf;\n    int offset;\n\n    *size = ((nb_bits * n) / 8) + 1;\n    res = malloc(*size);\n    tab = res;\n    offset = 0;\n    buf = 0;\n    for (i = 0; i < n; i++)\n    {\n\t/* sign */\n\tif (x[i] < 0)\n\t    x[i] = (~x[i] + 1) | ith_bit(x[i], 8 * sizeof(int)) << (nb_bits-1);\n\tfor (j = 0; j < nb_bits; j++)\n\t{\n\t    buf |= ith_bit(x[i], nb_bits - j) << (7 - offset++);\n\t    if (offset == 8)\n\t    {\n\t\t*tab = buf;\n\t\tbuf = 0;\n\t\ttab++;\n\t\toffset = 0;\n\t    }\n\t}\n    }\n    *tab = buf;\n    return res;\n}", "path": "src\\cli\\compression\\quantization.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* just fill the necessary 0 at the end of the chunk */\n", "func_signal": "static float *fill_zero(const float *chunk, const size_t nb)", "code": "{\n    float *res;\n\n    res = calloc(nb * 2, sizeof(float));\n    memcpy(res, chunk, nb * sizeof(float));\n\n    return res;\n}", "path": "src\\cli\\compression\\wavelet.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* transform a C array to a OCaml bigarray */\n", "func_signal": "static value c_array_to_caml(float *array, const size_t dim)", "code": "{\n    return alloc_bigarray_dims(BIGARRAY_FLOAT32 | BIGARRAY_C_LAYOUT,\n\t    1, array, dim);\n}", "path": "src\\cli\\compression\\wavelet.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* return the device, to play sound in streaming */\n", "func_signal": "ao_device *ao_init_device(int BitsPerSample, int NumChannels, int SampleRate)", "code": "{\n    ao_device *res;\n    ao_sample_format format;\n    int driver;\n\n    ao_initialize();\n\n#ifdef linux\n    driver = ao_driver_id(\"alsa\");\n#else\n# ifdef __FreeBSD__ /* cpp main.c -dM | grep BSD */\n    driver = ao_driver_id(\"oss\");\n# else\n    driver = ao_default_driver_id();\n# endif\n#endif\n    format.bits = BitsPerSample;\n    format.channels = NumChannels;\n    format.rate = SampleRate;\n    format.byte_format = AO_FMT_NATIVE;\n    res = ao_open_live(driver, &format, NULL);\n    if (!res)\n\texit(0);\n    return res;\n}", "path": "src\\cli\\audio_output\\ao.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* return the next elem, this is thread-safe */\n", "func_signal": "void *buffer_get(t_buffer buf)", "code": "{\n    void *res;\n\n    pthread_mutex_lock(&buf->lock);\n    res = queue_dequeue(buf->queue);\n    pthread_mutex_unlock(&buf->lock);\n    return res;\n}", "path": "src\\cli\\utils\\buffer.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* release the memory used by a huffman tree */\n", "func_signal": "void destroy_huffman(huffman_tree *B)", "code": "{\n    if (B)\n    {\n\tdestroy_huffman(B->fd);\n\tdestroy_huffman(B->fg);\n\tfree(B);\n    }\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* decode the data\n * n is the uncompressed size\n */\n", "func_signal": "void *huffman_decode(const void *varray, const size_t n)", "code": "{\n    int shift = 0;\n    uint8_t *array, *res;\n    huffman_tree *H;\n    /*const size_t uncompressed_size = *((size_t *)varray);*/\n    unsigned int index = 0;\n\n    array = (uint8_t *)varray;\n    /*\n    array += sizeof(size_t);\n    */\n    res = malloc(n);\n    H = huffman_read_tree(&array);\n    while (index < n)\n    {\n\tres[index] = get_next_letter(&array, &shift, H);\n\tindex++;\n    };\n    destroy_huffman(H);\n    /**n = uncompressed_size;*/\n    return (void *)res;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* write the huffman tree, before the encoded values */\n", "func_signal": "static void huffman_write_tree(huffman_tree *H, uint8_t **pos)", "code": "{\n    t_queue F;\n    huffman_tree *tmp;\n\n    F = queue_create();\n    queue_enqueue(H, F);\n    while (!queue_isempty(F))\n    {\n\ttmp = queue_dequeue(F);\n\tif (tmp->fg)\n\t{\n\t    **pos = 0; /* this is not a leaf */\n\t    (*pos)++;\n\t    queue_enqueue(tmp->fg, F);\n\t    queue_enqueue(tmp->fd, F);\n\t}\n\telse\n\t{\n\t    **pos = 1; /* this is a leaf */\n\t    (*pos)++;\n\t    **pos = tmp->letter;\n\t    (*pos)++;\n\t}\n    }\n    queue_destroy(F);\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* add elem to buf, only if buf is not full.\n * This function is thread-safe and blocking,\n * it means that it will wait until elem has\n * been added to the buffer.\n */\n", "func_signal": "void buffer_add(void *elem, t_buffer buf)", "code": "{\n    while (queue_nbelement(buf->queue) == buf->max_size)\n\tusleep(100000); /* do nothing for 100ms */\n    pthread_mutex_lock(&buf->lock);\n    queue_enqueue(elem, buf->queue);\n    pthread_mutex_unlock(&buf->lock);\n}", "path": "src\\cli\\utils\\buffer.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* compute the result of the OCaml function \"Haar_Reverse\"\n * uncompress the data and fill out\n * assuming out->BitsPerSample == 16\n */\n", "func_signal": "void wavelets_inverse(float *chunk,\n\t\t      const size_t nbelmts,\n\t\t      const uint8_t nbChannels,\n\t\t      int8_t *out)", "code": "{\n    value camlArray;\n    int16_t val;\n    float *valf;\n    unsigned int i, j, k;\n\n    for (k = 0; k < nbChannels; k++)\n    {\n\tvalf = fill_zero(chunk + k * (nbelmts / nbChannels),\n\t\t\t\t\t\t\t(nbelmts / nbChannels));\n\tcamlArray = c_array_to_caml(valf, (nbelmts / nbChannels));\n\tcamlArray = wavelets_reverse_fun(camlArray);\n\tfree(valf);\n\n\tj = k;\n\tvalf = (float *)(Data_bigarray_val(camlArray));\n\tfor (i = 0; i < nbelmts / nbChannels; i++)\n\t{\n\t    val = valf[i];\n\t    *(int16_t *)(out + (j * nbChannels)) = val;\n\t    j = j + sizeof(int16_t) * 2;\n\t}\n    }\n}", "path": "src\\cli\\compression\\wavelet.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* close the device, and do some cleaning */\n", "func_signal": "void ao_close_device(ao_device *device)", "code": "{\n    ao_close(device);\n    ao_shutdown();\n}", "path": "src\\cli\\audio_output\\ao.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* add an element to the heap, on the right place */\n", "func_signal": "static void heap_add(heap *heap, huffman_tree *B)", "code": "{\n    int i;\n\n    i = heap->size;\n    heap->array[i] = B;\n    while (i > 0 &&\n\t    heap->array[i]->occurrence < heap->array[(i - 1) / 2]->occurrence)\n    {\n\tswap(heap->array[i], heap->array[(i - 1) / 2]);\n\ti = (i - 1) / 2;\n    };\n    heap->size++;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* Function creating a gui_straming_data based on some ihy data */\n", "func_signal": "t_playdata create_gui_streaming(ihy_data *ihy)", "code": "{\n    t_playdata res;\n    struct s_filling_thread_data *ft_data;\n    struct s_playing_thread_data *pt_data;\n\n    res = malloc(sizeof(struct gui_streaming_data));\n    res->buffer = buffer_init(20);\n    res->ihy = ihy;\n    res->current_offset = 0;\n    ft_data = malloc(sizeof(struct s_filling_thread_data));\n    ft_data->buffer = res->buffer;\n    ft_data->status = &(res->stop_status);\n    ft_data->current_offset = &(res->current_offset);\n    ft_data->ihy = ihy;\n    pt_data = malloc(sizeof(struct s_playing_thread_data));\n    pt_data->buffer = res->buffer;\n    pt_data->status = &(res->pause_status);\n    pt_data->ihy = ihy;\n    pt_data->percentage = &res->percentage;\n    res->pause_status = 1;\n    res->stop_status = 0;\n    res->percentage = 0.;\n    pthread_create(&res->filling_thread, NULL, &filling_thread_action, ft_data);\n    pthread_create(&res->playing_thread, NULL, &playing_thread_action, pt_data);\n\n    return res;\n}", "path": "src\\cli\\audio_output\\gui_streaming.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* read an build the tree */\n", "func_signal": "static huffman_tree *huffman_read_tree(uint8_t **array)", "code": "{\n    huffman_tree *tmp, *res = malloc(sizeof(huffman_tree));\n    t_queue F;\n\n    F = queue_create();\n    queue_enqueue(res, F);\n    while (!queue_isempty(F))\n    {\n\ttmp = queue_dequeue(F);\n\tif (!**array) /* a node */\n\t{\n\t    tmp->fg = malloc(sizeof(huffman_tree));\n\t    tmp->fd = malloc(sizeof(huffman_tree));\n\t    (*array)++;\n\t    queue_enqueue(tmp->fg, F);\n\t    queue_enqueue(tmp->fd, F);\n\t}\n\telse /* a leaf */\n\t{\n\t    (*array)++;\n\t    tmp->letter = **array;\n\t    tmp->fg = NULL;\n\t    tmp->fd = NULL;\n\t    (*array)++;\n\t}\n    }\n    queue_destroy(F);\n    return res;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* just a simple swap */\n", "func_signal": "static void swap(huffman_tree *a, huffman_tree *b)", "code": "{\n    huffman_tree c;\n    c = *a;\n    *a = *b;\n    *b = c;\n}", "path": "src\\cli\\compression\\huffman.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/* play the wav in streaming */\n", "func_signal": "void play_wav_streaming(wav_data *wav)", "code": "{\n    t_buffer buffer; /* contains int8_t */\n    pthread_t playing_thread, filling_buffer_thread;\n    struct wav_streaming_data data;\n\n    buffer = buffer_init(10); /* max 10 elements */\n    data.wav = wav;\n    data.buffer = buffer;\n    pthread_create(&filling_buffer_thread, NULL, &wav_filling_buffer, &data);\n    pthread_create(&playing_thread, NULL, &wav_playing, &data);\n    pthread_join(filling_buffer_thread, NULL);\n    pthread_join(playing_thread, NULL);\n}", "path": "src\\cli\\audio_output\\wav_streaming.c", "repo_name": "xavierd/ihy", "stars": 11, "license": "None", "language": "c", "size": 887}
{"docstring": "/*\nFUNCTION pm_enable_counter\n\nDESCRIPTION  Enable the counter with the index passed.\n\nDEPENDENCIES\n\nRETURN VALUE\nnone.\n\nSIDE EFFECTS\n*/\n", "func_signal": "void pm_enable_counter(int index)", "code": "{\n  /*\n   * Range check\n   */\n  if (index > pm_max_events)\n\t\treturn;\n  WCP15_PMCNTENSET(1<<index);\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n * Count leaf blocks given a range of extent records originally\n * in btree format.\n */\n", "func_signal": "STATIC void\nxfs_bmap_disk_count_leaves(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)", "code": "{\n\tint\t\tb;\n\txfs_bmbt_rec_t\t*frp;\n\n\tfor (b = 1; b <= numrecs; b++) {\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, b);\n\t\t*count += xfs_bmbt_disk_get_blockcount(frp);\n\t}\n}", "path": "fs\\xfs\\xfs_bmap.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION pm_cycle_overflow_action\n\nDESCRIPTION  Action to take for an overflow of the cycle counter.\n\nDEPENDENCIES\n\nRETURN VALUE\nNone\n\nSIDE EFFECTS\nModify the state actions for overflow\n*/\n", "func_signal": "void pm_cycle_overflow_action(int action)", "code": "{\n\tunsigned long reg = 0;\n\n\tif ((action > PM_OVERFLOW_SKIP) || (action < 0))\n\t\treturn;\n\n\tRCP15_PMACTLR(reg);\n\treg &= ~(1<<30);   /*clear it*/\n\tWCP15_PMACTLR(reg | (action<<30));\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n * ib_umad_open() does not need the BKL:\n *\n *  - umad_port[] accesses are protected by port_lock, the\n *    ib_umad_port structures are properly reference counted, and\n *    everything else is purely local to the file being created, so\n *    races against other open calls are not a problem;\n *  - the ioctl method does not affect any global state outside of the\n *    file structure being operated on;\n *  - the port is added to umad_port[] as the last part of module\n *    initialization so the open method will either immediately run\n *    -ENXIO, or all required initialization will be done.\n */\n", "func_signal": "static int ib_umad_open(struct inode *inode, struct file *filp)", "code": "{\n\tstruct ib_umad_port *port;\n\tstruct ib_umad_file *file;\n\tint ret = 0;\n\n\tspin_lock(&port_lock);\n\tport = umad_port[iminor(inode) - IB_UMAD_MINOR_BASE];\n\tif (port)\n\t\tkref_get(&port->umad_dev->ref);\n\tspin_unlock(&port_lock);\n\n\tif (!port)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&port->file_mutex);\n\n\tif (!port->ib_dev) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tfile = kzalloc(sizeof *file, GFP_KERNEL);\n\tif (!file) {\n\t\tkref_put(&port->umad_dev->ref, ib_umad_release_dev);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_init(&file->mutex);\n\tspin_lock_init(&file->send_lock);\n\tINIT_LIST_HEAD(&file->recv_list);\n\tINIT_LIST_HEAD(&file->send_list);\n\tinit_waitqueue_head(&file->recv_wait);\n\n\tfile->port = port;\n\tfilp->private_data = file;\n\n\tlist_add_tail(&file->port_list, &port->file_list);\n\nout:\n\tmutex_unlock(&port->file_mutex);\n\treturn ret;\n}", "path": "drivers\\infiniband\\core\\user_mad.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/* This one is for stuff that can't sleep.. irq handlers, etc.. */\n", "func_signal": "void ivtv_api_get_data(struct ivtv_mailbox_data *mbdata, int mb, u32 data[])", "code": "{\n\tint i;\n\n\tfor (i = 0; i < CX2341X_MBOX_MAX_DATA; i++)\n\t\tdata[i] = readl(&mbdata->mbox[mb].data[i]);\n}", "path": "drivers\\media\\video\\ivtv\\ivtv-mailbox.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION  pm_get_cycle_overflow\n\nDESCRIPTION\nReturns if the cycle counter has overflowed or not.\n\nDEPENDENCIES\n\nRETURN VALUE\n0 no overflow\n!0 (anything else) overflow;\n\nSIDE EFFECTS\n*/\n", "func_signal": "unsigned long pm_get_cycle_overflow(void)", "code": "{\n  unsigned long overflow = 0;\n\n  RCP15_PMOVSR(overflow);\n  return overflow & PM_COUNT_ENABLE;\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION pm_initialize\n\nDESCRIPTION  Initialize the performanca monitoring for the v7 processor.\n  Ensures the cycle count is running and the event counters are enabled.\n\nDEPENDENCIES\n\nRETURN VALUE\n  NONE\n\nSIDE EFFECTS\n*/\n", "func_signal": "void pm_initialize(void)", "code": "{\n  unsigned long reg = 0;\n  unsigned char imp;\n  unsigned char id;\n  unsigned char num;\n  unsigned long enables = 0;\n  static int initialized;\n\n  if (initialized)\n\t\treturn;\n  initialized = 1;\n\n\t#ifdef CONFIG_ARCH_QSD8X50\n\t\tirqid = INT_ARM11_PM;\n\t#endif\n\t#ifdef CONFIG_ARCH_MSM7X30\n\t\tirqid = INT_ARM11_PM;\n\t#endif\n  RCP15_PMCR(reg);\n  imp = (reg>>24) & 0xFF;\n  id  = (reg>>16) & 0xFF;\n  pm_max_events = num = (reg>>11)  & 0xFF;\n  PRINT(\"V7Performance Monitor Capabilities\\n\");\n  PRINT(\"  Implementor %c(%d)\\n\", imp, imp);\n  PRINT(\"  Id %d %x\\n\", id, id);\n  PRINT(\"  Num Events %d %x\\n\", num, num);\n  PRINT(\"\\nCycle counter enabled by default...\\n\");\n\n  /*\n   * Global enable, ensure the global enable is set so all\n   * subsequent actions take effect.  Also resets the counts\n   */\n  RCP15_PMCR(enables);\n  WCP15_PMCR(enables | PM_GLOBAL_ENABLE | PM_EVENT_RESET |\n      PM_CYCLE_RESET | PM_CLKDIV);\n\n  /*\n   * Enable access from user space\n   */\n  WCP15_SDER(3);\n  WCP15_PMUSERENR(1);\n\n  /*\n   * Install interrupt handler and the enable the interrupts\n   */\n  pm_reset_cycle_overflow();\n  pm_reset_overflow(0);\n  pm_reset_overflow(1);\n  pm_reset_overflow(2);\n  pm_reset_overflow(3);\n\n\tif (0 != request_irq(irqid, pm_isr, 0, \"perfmon\", 0))\n\t\tprintk(KERN_ERR \"%s:%d request_irq returned error\\n\",\n\t\t__FILE__, __LINE__);\n  WCP15_PMINTENSET(PM_ALL_ENABLE);\n  /*\n   * Enable the cycle counter.  Default, count 1:1 no divisor.\n   */\n  pm_enable_cycle_counter();\n\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/* the CONTROL inode is made without asking attributes from Venus */\n", "func_signal": "int coda_cnode_makectl(struct inode **inode, struct super_block *sb)", "code": "{\n\tint error = -ENOMEM;\n\n\t*inode = new_inode(sb);\n\tif (*inode) {\n\t\t(*inode)->i_ino = CTL_INO;\n\t\t(*inode)->i_op = &coda_ioctl_inode_operations;\n\t\t(*inode)->i_fop = &coda_ioctl_operations;\n\t\t(*inode)->i_mode = 0444;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}", "path": "fs\\coda\\cnode.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION  pm_cycle_div_64\n\nDESCRIPTION  Set the cycle counter to count every 64th cycle instead of\nevery cycle when the value passed is 1, otherwise counts every cycle.\n\nDEPENDENCIES\n\nRETURN VALUE\nnone\n\nSIDE EFFECTS\nChanges the rate at which cycles are counted.  Anything that is reading\nthe cycle count (pmGetCyucleCount) may get different results.\n*/\n", "func_signal": "void pm_cycle_div_64(int enable)", "code": "{\n\tunsigned long enables = 0;\n\n\tRCP15_PMCR(enables);\n\tif (enable)\n\t\tWCP15_PMCR(enables | PM_CLKDIV);\n\telse\n\t\tWCP15_PMCR(enables & ~PM_CLKDIV);\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION pm_set_count\n\nDESCRIPTION  Set the number of events in a register, used for resets\npassed.\n\nDEPENDENCIES\n\nRETURN VALUE\n-1 if the index is out of range\n\nSIDE EFFECTS\n*/\n", "func_signal": "int pm_set_count(int index, unsigned long new_value)", "code": "{\n  unsigned long reg = 0;\n\n/*\n* Range check\n*/\n  if (index > pm_max_events)\n\t\treturn -1;\n\n/*\n* Lock, select the index and read the count...unlock\n*/\n  PM_LOCK();\n  WCP15_PMSELR(index);\n  WCP15_PMXEVCNTR(new_value);\n  PM_UNLOCK();\n  return reg;\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n * Validate that the bmbt_irecs being returned from bmapi are valid\n * given the callers original parameters.  Specifically check the\n * ranges of the returned irecs to ensure that they only extent beyond\n * the given parameters if the XFS_BMAPI_ENTIRE flag was set.\n */\n", "func_signal": "STATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)", "code": "{\n\tint\t\t\ti;\t\t/* index to map values */\n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tif ((flags & XFS_BMAPI_WRITE) && !(flags & XFS_BMAPI_DELAY))\n\t\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}", "path": "fs\\xfs\\xfs_bmap.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION pm_get_count\n\nDESCRIPTION  Return the number of events that have happened for the index\npassed.\n\nDEPENDENCIES\n\nRETURN VALUE\n-1 if the index is out of range\nThe number of events if inrange\n\nSIDE EFFECTS\n*/\n", "func_signal": "unsigned long pm_get_count(int index)", "code": "{\n  unsigned long reg = 0;\n\n/*\n* Range check\n*/\n  if (index > pm_max_events)\n\t\treturn -1;\n\n/*\n* Lock, select the index and read the count...unlock\n*/\n  PM_LOCK();\n  WCP15_PMSELR(index);\n  RCP15_PMXEVCNTR(reg);\n  PM_UNLOCK();\n  return reg;\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n * Count leaf blocks given a range of extent records.\n */\n", "func_signal": "STATIC void\nxfs_bmap_count_leaves(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)", "code": "{\n\tint\t\tb;\n\n\tfor (b = 0; b < numrecs; b++) {\n\t\txfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\n\t\t*count += xfs_bmbt_get_blockcount(frp);\n\t}\n}", "path": "fs\\xfs\\xfs_bmap.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION pm_disable_counter\n\nDESCRIPTION  Disable a single counter based on the index passed.\n\nDEPENDENCIES\n\nRETURN VALUE\nnone\n\nSIDE EFFECTS\nAny triggers that are based on the stoped counter may not trigger...\n*/\n", "func_signal": "void pm_disable_counter(int index)", "code": "{\n  /*\n   * Range check\n   */\n  if (index > pm_max_events)\n\t\treturn;\n  WCP15_PMCNTENCLR(1<<index);\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/* this is effectively coda_iget:\n   - get attributes (might be cached)\n   - get the inode for the fid using vfs iget\n   - link the two up if this is needed\n   - fill in the attributes\n*/\n", "func_signal": "int coda_cnode_make(struct inode **inode, struct CodaFid *fid, struct super_block *sb)", "code": "{\n        struct coda_vattr attr;\n        int error;\n        \n\t/* We get inode numbers from Venus -- see venus source */\n\terror = venus_getattr(sb, fid, &attr);\n\tif ( error ) {\n\t    *inode = NULL;\n\t    return error;\n\t} \n\n\t*inode = coda_iget(sb, fid, &attr);\n\tif ( IS_ERR(*inode) ) {\n\t\tprintk(\"coda_cnode_make: coda_iget failed\\n\");\n                return PTR_ERR(*inode);\n        }\n\treturn 0;\n}", "path": "fs\\coda\\cnode.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n * Register the input device; print a message.\n * Configure the input layer interface\n * Read all reports and initialize the absolute field values.\n */\n", "func_signal": "int hidinput_connect(struct hid_device *hid, unsigned int force)", "code": "{\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = NULL;\n\tstruct input_dev *input_dev;\n\tint i, j, k;\n\tint max_report_type = HID_OUTPUT_REPORT;\n\n\tINIT_LIST_HEAD(&hid->inputs);\n\n\tif (!force) {\n\t\tfor (i = 0; i < hid->maxcollection; i++) {\n\t\t\tstruct hid_collection *col = &hid->collection[i];\n\t\t\tif (col->type == HID_COLLECTION_APPLICATION ||\n\t\t\t\t\tcol->type == HID_COLLECTION_PHYSICAL)\n\t\t\t\tif (IS_INPUT_APPLICATION(col->usage))\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == hid->maxcollection)\n\t\t\treturn -1;\n\t}\n\n\tif (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)\n\t\tmax_report_type = HID_INPUT_REPORT;\n\n\tfor (k = HID_INPUT_REPORT; k <= max_report_type; k++)\n\t\tlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\n\n\t\t\tif (!report->maxfield)\n\t\t\t\tcontinue;\n\n\t\t\tif (!hidinput) {\n\t\t\t\thidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);\n\t\t\t\tinput_dev = input_allocate_device();\n\t\t\t\tif (!hidinput || !input_dev) {\n\t\t\t\t\tkfree(hidinput);\n\t\t\t\t\tinput_free_device(input_dev);\n\t\t\t\t\terr_hid(\"Out of memory during hid input probe\");\n\t\t\t\t\tgoto out_unwind;\n\t\t\t\t}\n\n\t\t\t\tinput_set_drvdata(input_dev, hid);\n\t\t\t\tinput_dev->event =\n\t\t\t\t\thid->ll_driver->hidinput_input_event;\n\t\t\t\tinput_dev->open = hidinput_open;\n\t\t\t\tinput_dev->close = hidinput_close;\n\t\t\t\tinput_dev->setkeycode = hidinput_setkeycode;\n\t\t\t\tinput_dev->getkeycode = hidinput_getkeycode;\n\n\t\t\t\tinput_dev->name = hid->name;\n\t\t\t\tinput_dev->phys = hid->phys;\n\t\t\t\tinput_dev->uniq = hid->uniq;\n\t\t\t\tinput_dev->id.bustype = hid->bus;\n\t\t\t\tinput_dev->id.vendor  = hid->vendor;\n\t\t\t\tinput_dev->id.product = hid->product;\n\t\t\t\tinput_dev->id.version = hid->version;\n\t\t\t\tinput_dev->dev.parent = hid->dev.parent;\n\t\t\t\thidinput->input = input_dev;\n\t\t\t\tlist_add_tail(&hidinput->list, &hid->inputs);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < report->maxfield; i++)\n\t\t\t\tfor (j = 0; j < report->field[i]->maxusage; j++)\n\t\t\t\t\thidinput_configure_usage(hidinput, report->field[i],\n\t\t\t\t\t\t\t\t report->field[i]->usage + j);\n\n\t\t\tif (hid->quirks & HID_QUIRK_MULTI_INPUT) {\n\t\t\t\t/* This will leave hidinput NULL, so that it\n\t\t\t\t * allocates another one if we have more inputs on\n\t\t\t\t * the same interface. Some devices (e.g. Happ's\n\t\t\t\t * UGCI) cram a lot of unrelated inputs into the\n\t\t\t\t * same interface. */\n\t\t\t\thidinput->report = report;\n\t\t\t\tif (input_register_device(hidinput->input))\n\t\t\t\t\tgoto out_cleanup;\n\t\t\t\thidinput = NULL;\n\t\t\t}\n\t\t}\n\n\tif (hidinput && input_register_device(hidinput->input))\n\t\tgoto out_cleanup;\n\n\treturn 0;\n\nout_cleanup:\n\tinput_free_device(hidinput->input);\n\tkfree(hidinput);\nout_unwind:\n\t/* unwind the ones we already registered */\n\thidinput_disconnect(hid);\n\n\treturn -1;\n}", "path": "drivers\\hid\\hid-input.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\n* Update the record referred to by cur to the value given\n * by [off, bno, len, state].\n * This either works (return 0) or gets an EFSCORRUPTED error.\n */\n", "func_signal": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)", "code": "{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}", "path": "fs\\xfs\\xfs_bmap.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION   pm_get_overflow\n\nDESCRIPTION  Return the overflow condition for the index passed.\n\nDEPENDENCIES\n\nRETURN VALUE\n0 no overflow\n!0 (anything else) overflow;\n\nSIDE EFFECTS\n*/\n", "func_signal": "unsigned long pm_get_overflow(int index)", "code": "{\n  unsigned long overflow = 0;\n\n/*\n* Range check\n*/\n  if (index > pm_max_events)\n\treturn -1;\n  RCP15_PMOVSR(overflow);\n\n  return overflow & (1<<index);\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/* Try to find a free mailbox. Note mailbox 0 is reserved for DMA and so is not\n   attempted here. */\n", "func_signal": "static int get_mailbox(struct ivtv *itv, struct ivtv_mailbox_data *mbdata, int flags)", "code": "{\n\tunsigned long then = jiffies;\n\tint i, mb;\n\tint max_mbox = mbdata->max_mbox;\n\tint retries = 100;\n\n\t/* All slow commands use the same mailbox, serializing them and also\n\t   leaving the other mailbox free for simple fast commands. */\n\tif ((flags & API_FAST_RESULT) == API_RESULT)\n\t\tmax_mbox = 1;\n\n\t/* find free non-DMA mailbox */\n\tfor (i = 0; i < retries; i++) {\n\t\tfor (mb = 1; mb <= max_mbox; mb++)\n\t\t\tif (try_mailbox(itv, mbdata, mb))\n\t\t\t\treturn mb;\n\n\t\t/* Sleep before a retry, if not atomic */\n\t\tif (!(flags & API_NO_WAIT_MB)) {\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       then + msecs_to_jiffies(10*retries)))\n\t\t\t       break;\n\t\t\tivtv_msleep_timeout(10, 0);\n\t\t}\n\t}\n\treturn -ENODEV;\n}", "path": "drivers\\media\\video\\ivtv\\ivtv-mailbox.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/*\nFUNCTION  pm_isr\n\nDESCRIPTION:\n  Performance Monitor interrupt service routine to capture overflows\n\nDEPENDENCIES\n\nRETURN VALUE\n\nSIDE EFFECTS\n*/\n", "func_signal": "static irqreturn_t pm_isr(int irq, void *d)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < PM_NUM_COUNTERS; i++) {\n\t\tif (pm_get_overflow(i)) {\n\t\t\tpm_overflow_count[i]++;\n\t\t\tpm_reset_overflow(i);\n\t\t}\n\t}\n\n\tif (pm_get_cycle_overflow()) {\n\t\tpm_cycle_overflow_count++;\n\t\tpm_reset_cycle_overflow();\n\t}\n\n\treturn IRQ_HANDLED;\n}", "path": "arch\\arm\\perfmon\\perf-v7.c", "repo_name": "zefie/thunderc_kernel_xionia", "stars": 11, "license": "other", "language": "c", "size": 128794}
{"docstring": "/**\n * Advance the BDD iterator, taking into account that some assignments\n * need to be expanded twice.\n */\n", "func_signal": "static void\nadvance_assignment(ipset_iterator_t *iterator)", "code": "{\n    /*\n     * Check the current state of the iterator to determine how to\n     * advance.\n     */\n\n    /*\n     * In most cases, the assignment we just finished only needed to\n     * be expanded once.  So we move on to the next assignment and\n     * process it.\n     */\n\n    if (G_LIKELY(iterator->multiple_expansion_state ==\n                 IPSET_ITERATOR_NORMAL))\n    {\n        ipset_bdd_iterator_advance(iterator->bdd_iterator);\n        process_assignment(iterator);\n        return;\n    }\n\n    /*\n     * If the assignment needs to be expanded twice, we'll do the IPv4\n     * expansion first.  If that's what we've just finished, do the\n     * IPv6 expansion next.\n     */\n\n    if (iterator->multiple_expansion_state ==\n        IPSET_ITERATOR_MULTIPLE_IPV4)\n    {\n        g_d_debug(\"Expanding IPv6 second\");\n\n        iterator->multiple_expansion_state =\n            IPSET_ITERATOR_MULTIPLE_IPV6;\n        ipset_assignment_set\n            (iterator->bdd_iterator->assignment,\n             0, IPSET_FALSE);\n        expand_ipv6(iterator);\n        return;\n    }\n\n    /*\n     * If we've just finished the IPv6 expansion, then we've finished\n     * with this assignment.  Before moving on to the next one, we\n     * have to reset variable 0 to EITHER (which it was before we\n     * started this whole mess).\n     */\n\n    if (iterator->multiple_expansion_state ==\n        IPSET_ITERATOR_MULTIPLE_IPV6)\n    {\n        g_d_debug(\"Finished both expansions\");\n\n        ipset_assignment_set\n            (iterator->bdd_iterator->assignment,\n             0, IPSET_EITHER);\n        ipset_bdd_iterator_advance(iterator->bdd_iterator);\n        process_assignment(iterator);\n        return;\n    }\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Memory size\n */\n", "func_signal": "START_TEST(test_bdd_size_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    /*\n     * Create a BDD representing\n     *   f(x) = (x[0] \u2227 x[1]) \u2228 (\u00acx[0] \u2227 x[2])\n     */\n\n    ipset_node_id_t  n_false =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  t0 =\n        ipset_node_cache_nonterminal(cache, 0, n_false, n_true);\n    ipset_node_id_t  f0 =\n        ipset_node_cache_nonterminal(cache, 0, n_true, n_false);\n    ipset_node_id_t  t1 =\n        ipset_node_cache_nonterminal(cache, 1, n_false, n_true);\n    ipset_node_id_t  t2 =\n        ipset_node_cache_nonterminal(cache, 2, n_false, n_true);\n\n    ipset_node_id_t  n1 =\n        ipset_node_cache_and(cache, t0, t1);\n    ipset_node_id_t  n2 =\n        ipset_node_cache_and(cache, f0, t2);\n    ipset_node_id_t  node =\n        ipset_node_cache_or(cache, n1, n2);\n\n    /*\n     * And verify how big it is.\n     */\n\n    fail_unless(ipset_node_reachable_count(node) == 3u,\n                \"BDD has wrong number of nodes\");\n\n    fail_unless(ipset_node_memory_size(node) ==\n                3u * sizeof(ipset_node_t),\n                \"BDD takes up wrong amount of space\");\n\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Perform an actual trinary operation, checking the cache first.\n */\n", "func_signal": "static ipset_node_id_t\ncached_ite(ipset_node_cache_t *cache,\n           ipset_node_id_t f,\n           ipset_node_id_t g,\n           ipset_node_id_t h)", "code": "{\n    g_d_debug(\"Applying ITE(%p,%p,%p)\", f, g, h);\n\n    /*\n     * Some trivial cases first.\n     */\n\n    /*\n     * If F is a terminal, then we're in one of the following two\n     * cases:\n     *\n     *   ITE(1,G,H) = G\n     *   ITE(0,G,H) = H\n     */\n\n    if (ipset_node_get_type(f) == IPSET_TERMINAL_NODE)\n    {\n        ipset_range_t  f_value = ipset_terminal_value(f);\n        ipset_node_id_t  result = (f_value == 0)? h: g;\n        g_d_debug(\"Trivial result = %p\", result);\n        return result;\n    }\n\n    /*\n     * ITE(F,G,G) == G\n     */\n\n    if (g == h)\n    {\n        g_d_debug(\"Trivial result = %p\", g);\n        return g;\n    }\n\n    /*\n     * ITE(F,1,0) = F\n     */\n\n    if ((ipset_node_get_type(g) == IPSET_TERMINAL_NODE) &&\n        (ipset_node_get_type(h) == IPSET_TERMINAL_NODE))\n    {\n        ipset_range_t  g_value = ipset_terminal_value(g);\n        ipset_range_t  h_value = ipset_terminal_value(h);\n\n        if ((g_value == 1) && (h_value == 0))\n        {\n            g_d_debug(\"Trivial result = %p\", f);\n            return f;\n        }\n    }\n\n    /*\n     * Check to see if we've already performed the operation on these\n     * operands.\n     */\n\n    ipset_trinary_key_t  search_key;\n    ipset_trinary_key_init(&search_key, f, g, h);\n\n    gpointer  found_key;\n    gpointer  found_result;\n    gboolean  node_exists =\n        g_hash_table_lookup_extended(cache->ite_cache,\n                                     &search_key,\n                                     &found_key,\n                                     &found_result);\n\n    if (node_exists)\n    {\n        /*\n         * There's a result in the cache, so return it.\n         */\n\n        g_d_debug(\"Existing result = %p\", found_result);\n        return found_result;\n    } else {\n        /*\n         * This result doesn't exist yet.  Allocate a permanent copy\n         * of the key.  Apply the operator, add the result to the\n         * cache, and then return it.\n         */\n\n        ipset_trinary_key_t  *real_key =\n            g_slice_new(ipset_trinary_key_t);\n        memcpy(real_key, &search_key, sizeof(ipset_trinary_key_t));\n\n        ipset_node_id_t  result =\n            apply_ite(cache, f, g, h);\n        g_d_debug(\"NEW result = %p\", result);\n\n        g_hash_table_insert(cache->ite_cache, real_key, result);\n        return result;\n    }\n}", "path": "src\\libipset\\bdd\\trinary-operators.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Testing harness\n */\n", "func_signal": "static Suite *\ntest_suite()", "code": "{\n    Suite  *s = suite_create(\"bdd\");\n\n    TCase  *tc_bits = tcase_create(\"bits\");\n    tcase_add_test(tc_bits, test_bit_get);\n    tcase_add_test(tc_bits, test_bit_set);\n    suite_add_tcase(s, tc_bits);\n\n    TCase  *tc_terminals = tcase_create(\"terminals\");\n    tcase_add_test(tc_terminals, test_bdd_false_terminal);\n    tcase_add_test(tc_terminals, test_bdd_true_terminal);\n    tcase_add_test(tc_terminals, test_bdd_terminal_reduced_1);\n    suite_add_tcase(s, tc_terminals);\n\n    TCase  *tc_nonterminals = tcase_create(\"nonterminals\");\n    tcase_add_test(tc_nonterminals, test_bdd_nonterminal_1);\n    tcase_add_test(tc_nonterminals, test_bdd_nonterminal_reduced_1);\n    tcase_add_test(tc_nonterminals, test_bdd_nonterminal_reduced_2);\n    suite_add_tcase(s, tc_nonterminals);\n\n    TCase  *tc_evaluation = tcase_create(\"evaluation\");\n    tcase_add_test(tc_evaluation, test_bdd_evaluate_1);\n    tcase_add_test(tc_evaluation, test_bdd_evaluate_2);\n    suite_add_tcase(s, tc_evaluation);\n\n    TCase  *tc_operators = tcase_create(\"operators\");\n    tcase_add_test(tc_operators, test_bdd_and_reduced_1);\n    tcase_add_test(tc_operators, test_bdd_and_evaluate_1);\n    tcase_add_test(tc_operators, test_bdd_or_reduced_1);\n    tcase_add_test(tc_operators, test_bdd_or_evaluate_1);\n    tcase_add_test(tc_operators, test_bdd_ite_reduced_1);\n    tcase_add_test(tc_operators, test_bdd_ite_evaluate_1);\n    suite_add_tcase(s, tc_operators);\n\n    TCase  *tc_size = tcase_create(\"size\");\n    tcase_add_test(tc_size, test_bdd_size_1);\n    suite_add_tcase(s, tc_size);\n\n    TCase  *tc_serialization = tcase_create(\"serialization\");\n    tcase_add_test(tc_serialization, test_bdd_save_1);\n    tcase_add_test(tc_serialization, test_bdd_save_2);\n    tcase_add_test(tc_serialization, test_bdd_bad_save_1);\n    tcase_add_test(tc_serialization, test_bdd_load_1);\n    tcase_add_test(tc_serialization, test_bdd_load_2);\n    suite_add_tcase(s, tc_serialization);\n\n    TCase  *tc_iteration = tcase_create(\"iteration\");\n    tcase_add_test(tc_iteration, test_bdd_iterate_1);\n    tcase_add_test(tc_iteration, test_bdd_iterate_2);\n    suite_add_tcase(s, tc_iteration);\n\n    return s;\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Expand the current assignment as IPv4 addresses.\n */\n", "func_signal": "static void\nexpand_ipv6(ipset_iterator_t *iterator)", "code": "{\n    guint  last_bit;\n\n    if (iterator->summarize)\n    {\n        last_bit = find_last_non_either_bit\n            (iterator->bdd_iterator->assignment,\n             IPV6_BIT_SIZE);\n\n        g_d_debug(\"Last non-either bit is %u\", last_bit);\n    } else {\n        last_bit = IPV6_BIT_SIZE;\n    }\n\n    iterator->assignment_iterator =\n        ipset_assignment_expand\n        (iterator->bdd_iterator->assignment,\n         last_bit + 1);\n    iterator->netmask = last_bit;\n\n    process_expanded_assignment(iterator);\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Perform an actual binary operation, checking the cache first.\n */\n", "func_signal": "static ipset_node_id_t\ncached_op(ipset_node_cache_t *cache,\n          GHashTable *op_cache,\n          operator_func_t op,\n          const char *op_name,\n          ipset_node_id_t lhs,\n          ipset_node_id_t rhs)", "code": "{\n    /*\n     * Check to see if we've already performed the operation on these\n     * operands.\n     */\n\n    g_d_debug(\"Applying %s(%p, %p)\", op_name, lhs, rhs);\n\n    ipset_binary_key_t  search_key;\n    ipset_binary_key_commutative(&search_key, lhs, rhs);\n\n    gpointer  found_key;\n    gpointer  found_result;\n    gboolean  node_exists =\n        g_hash_table_lookup_extended(op_cache,\n                                     &search_key,\n                                     &found_key,\n                                     &found_result);\n\n    if (node_exists)\n    {\n        /*\n         * There's a result in the cache, so return it.\n         */\n\n        g_d_debug(\"Existing result = %p\", found_result);\n        return found_result;\n    } else {\n        /*\n         * This result doesn't exist yet.  Allocate a permanent copy\n         * of the key.  Apply the operator, add the result to the\n         * cache, and then return it.\n         */\n\n        ipset_binary_key_t  *real_key =\n            g_slice_new(ipset_binary_key_t);\n        memcpy(real_key, &search_key, sizeof(ipset_binary_key_t));\n\n        ipset_node_id_t  result =\n            apply_op(cache, op_cache, op, op_name, lhs, rhs);\n        g_d_debug(\"NEW result = %p\", result);\n\n        g_hash_table_insert(op_cache, real_key, result);\n        return result;\n    }\n}", "path": "src\\libipset\\bdd\\binary-operators.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Expand the current assignment as IPv4 addresses.\n */\n", "func_signal": "static void\nexpand_ipv4(ipset_iterator_t *iterator)", "code": "{\n    guint  last_bit;\n\n    if (iterator->summarize)\n    {\n        last_bit = find_last_non_either_bit\n            (iterator->bdd_iterator->assignment,\n             IPV4_BIT_SIZE);\n\n        g_d_debug(\"Last non-either bit is %u\", last_bit);\n    } else {\n        last_bit = IPV4_BIT_SIZE;\n    }\n\n    iterator->assignment_iterator =\n        ipset_assignment_expand\n        (iterator->bdd_iterator->assignment,\n         last_bit + 1);\n    iterator->netmask = last_bit;\n\n    process_expanded_assignment(iterator);\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Recurse down both subtrees simultaneously.\n */\n", "func_signal": "static ipset_node_id_t\nrecurse_both(ipset_node_cache_t *cache,\n             GHashTable *op_cache,\n             operator_func_t op,\n             const char *op_name,\n             ipset_node_t *lhs_node,\n             ipset_node_t *rhs_node)", "code": "{\n    ipset_node_id_t  result_low =\n        cached_op(cache, op_cache, op, op_name,\n                  lhs_node->low, rhs_node->low);\n    ipset_node_id_t  result_high =\n        cached_op(cache, op_cache, op, op_name,\n                  lhs_node->high, rhs_node->high);\n\n    return ipset_node_cache_nonterminal\n        (cache, lhs_node->variable, result_low, result_high);\n}", "path": "src\\libipset\\bdd\\binary-operators.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Create a generic IP address object from the current expanded\n * assignment.\n */\n", "func_signal": "static void\ncreate_ip_address(ipset_iterator_t *iterator)", "code": "{\n    ipset_ip_t  *addr = &iterator->addr;\n    ipset_expanded_assignment_t  *exp =\n        iterator->assignment_iterator;\n\n    /*\n     * Check variable 0 to see if this is an IPv4 or IPv6 address.\n     */\n\n    addr->is_ipv4 = IPSET_BIT_GET(exp->values->data, 0);\n\n    /*\n     * Initialize the address to all 0 bits.\n     */\n\n    memset(addr->addr, 0, sizeof(guint32) * 4);\n\n    /*\n     * Copy bits from the expanded assignment.  The number of bits to\n     * copy is given as the current netmask.  We'll have calculated\n     * that already based on the non-expanded assignment.\n     */\n\n    guint  i;\n    for (i = 0; i < iterator->netmask; i++)\n    {\n        IPSET_BIT_SET(addr->addr, i,\n                      IPSET_BIT_GET(exp->values->data, i+1));\n    }\n\n    g_d_debug(\"Current IP address is %s/%u\",\n              ipset_ip_to_string(addr), iterator->netmask);\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Serialization\n */\n", "func_signal": "START_TEST(test_bdd_save_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    /*\n     * Create a BDD representing\n     *   f(x) = TRUE\n     */\n\n    ipset_node_id_t  node =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    /*\n     * Serialize the BDD into a string.\n     */\n\n    GOutputStream  *stream =\n        g_memory_output_stream_new(NULL, 0, g_realloc, g_free);\n    GMemoryOutputStream  *mstream =\n        G_MEMORY_OUTPUT_STREAM(stream);\n\n    ipset_node_cache_save(stream, cache, node, NULL);\n\n    const char  *raw_expected =\n        \"IP set\"                             // magic number\n        \"\\x00\\x01\"                           // version\n        \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\"   // length\n        \"\\x00\\x00\\x00\\x00\"                   // node count\n        \"\\x00\\x00\\x00\\x01\"                   // terminal value\n        ;\n    const size_t  expected_length = 24;\n\n    gpointer  buf = g_memory_output_stream_get_data(mstream);\n    gsize  len = g_memory_output_stream_get_data_size(mstream);\n\n    fail_unless(expected_length == len,\n                \"Serialized BDD has wrong length \"\n                \"(expected %zu, got %zu)\",\n                expected_length, len);\n\n    fail_unless(memcmp(raw_expected, buf, expected_length) == 0,\n                \"Serialized BDD has incorrect data\");\n\n    g_object_unref(stream);\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Recurse down one subtree (the LHS).\n */\n", "func_signal": "static ipset_node_id_t\nrecurse_left(ipset_node_cache_t *cache,\n             GHashTable *op_cache,\n             operator_func_t op,\n             const char *op_name,\n             ipset_node_t *lhs_node,\n             ipset_node_id_t rhs)", "code": "{\n    ipset_node_id_t  result_low =\n        cached_op(cache, op_cache, op, op_name,\n                  lhs_node->low, rhs);\n    ipset_node_id_t  result_high =\n        cached_op(cache, op_cache, op, op_name,\n                  lhs_node->high, rhs);\n\n    return ipset_node_cache_nonterminal\n        (cache, lhs_node->variable, result_low, result_high);\n}", "path": "src\\libipset\\bdd\\binary-operators.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Evaluation\n */\n", "func_signal": "START_TEST(test_bdd_evaluate_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    /*\n     * Create a BDD representing\n     *   f(x) = \u00acx[0]\n     */\n\n    ipset_node_id_t  n_false =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  node =\n        ipset_node_cache_nonterminal(cache, 0, n_true, n_false);\n\n    /*\n     * And test we can get the right results out of it.\n     */\n\n    guint8  input1[] = { 0x80 }; /* { TRUE } */\n    gboolean  expected1 = FALSE;\n\n    fail_unless(ipset_node_evaluate(node,\n                                    ipset_bit_array_assignment,\n                                    input1)\n                == expected1,\n                \"BDD evaluates to wrong value\");\n\n    guint8  input2[] = { 0x00 }; /* { FALSE } */\n    gboolean  expected2 = TRUE;\n\n    fail_unless(ipset_node_evaluate(node,\n                                    ipset_bit_array_assignment,\n                                    input2)\n                == expected2,\n                \"BDD evaluates to wrong value\");\n\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * BDD non-terminals\n */\n", "func_signal": "START_TEST(test_bdd_nonterminal_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    ipset_node_id_t  n_false =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  node =\n        ipset_node_cache_nonterminal(cache, 0, n_false, n_true);\n\n    fail_unless(ipset_node_get_type(node) == IPSET_NONTERMINAL_NODE,\n                \"Nonterminal has wrong type\");\n\n    ipset_node_t  *n =\n        ipset_nonterminal_node(node);\n\n    fail_unless(n->variable == 0,\n                \"Nonterminal has wrong variable\");\n    fail_unless(n->low == n_false,\n                \"Nonterminal has wrong low pointer\");\n    fail_unless(n->high == n_true,\n                \"Nonterminal has wrong high pointer\");\n\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * BDD terminals\n */\n", "func_signal": "START_TEST(test_bdd_false_terminal)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    ipset_node_id_t  n_false =\n        ipset_node_cache_terminal(cache, FALSE);\n\n    fail_unless(ipset_node_get_type(n_false) == IPSET_TERMINAL_NODE,\n                \"False terminal has wrong type\");\n\n    fail_unless(ipset_terminal_value(n_false) == FALSE,\n                \"False terminal has wrong value\");\n\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Process the current expanded assignment in the current BDD\n * assignment.\n */\n", "func_signal": "static void\nprocess_expanded_assignment(ipset_iterator_t *iterator)", "code": "{\n    if (iterator->assignment_iterator->finished)\n    {\n        /*\n         * If there isn't anything in the expanded assignment, advance\n         * to the next BDD assignment.\n         */\n\n        g_d_debug(\"Expanded assignment is finished\");\n\n        ipset_expanded_assignment_free(iterator->assignment_iterator);\n        iterator->assignment_iterator = NULL;\n\n        advance_assignment(iterator);\n    } else {\n        /*\n         * Otherwise, we've found a fully expanded assignment, so\n         * create an IP address for it and return.\n         */\n\n        create_ip_address(iterator);\n    }\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Process the current assignment in the BDD iterator.\n */\n", "func_signal": "static void\nprocess_assignment(ipset_iterator_t *iterator)", "code": "{\n    while (!iterator->bdd_iterator->finished)\n    {\n        if (iterator->bdd_iterator->value ==\n            iterator->desired_value)\n        {\n            /*\n             * If the BDD iterator hasn't finished, and the result of\n             * the function with this assignment matches what the\n             * caller wants, then we've found an assignment to\n             * generate IP addresses from.\n             *\n             * Try to expand this assignment, and process the first\n             * expanded assignment.  We want 32 + 1 variables if the\n             * current address is IPv4; 128 + 1 if it's IPv6.\n             */\n\n            g_d_debug(\"Got a matching BDD assignment\");\n\n            ipset_tribool_t  address_type = ipset_assignment_get\n                (iterator->bdd_iterator->assignment, 0);\n\n            if (address_type == IPSET_FALSE)\n            {\n                /*\n                 * FALSE means IPv6\n                 */\n\n                g_d_debug(\"Assignment is IPv6\");\n                iterator->multiple_expansion_state =\n                    IPSET_ITERATOR_NORMAL;\n                expand_ipv6(iterator);\n                return;\n            } else if (address_type == IPSET_TRUE) {\n                /*\n                 * TRUE means IPv4\n                 */\n\n                g_d_debug(\"Assignment is IPv4\");\n                iterator->multiple_expansion_state =\n                    IPSET_ITERATOR_NORMAL;\n                expand_ipv4(iterator);\n                return;\n            } else {\n                /*\n                 * EITHER means that this assignment contains both\n                 * IPv4 and IPv6 addresses.  Expand it as IPv4 first.\n                 */\n\n                g_d_debug(\"Assignment is both IPv4 and IPv6\");\n                g_d_debug(\"Expanding IPv4 first\");\n\n                iterator->multiple_expansion_state =\n                    IPSET_ITERATOR_MULTIPLE_IPV4;\n                ipset_assignment_set\n                    (iterator->bdd_iterator->assignment,\n                     0, IPSET_TRUE);\n                expand_ipv4(iterator);\n                return;\n            }\n        }\n\n        /*\n         * The BDD iterator has a value, but it doesn't match the one\n         * we want.  Advance the BDD iterator and try again.\n         */\n\n        g_d_debug(\"Value is %d, skipping\",\n                  iterator->bdd_iterator->value);\n        ipset_bdd_iterator_advance(iterator->bdd_iterator);\n    }\n\n    /*\n     * If we fall through, then the BDD iterator has finished.  That\n     * means there's nothing left for the set iterator.\n     */\n\n    g_d_debug(\"Set iterator is finished\");\n\n    ipset_expanded_assignment_free(iterator->assignment_iterator);\n    iterator->assignment_iterator = NULL;\n\n    ipset_bdd_iterator_free(iterator->bdd_iterator);\n    iterator->bdd_iterator = NULL;\n\n    iterator->finished = TRUE;\n}", "path": "src\\libipset\\set\\iterator.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Operators\n */\n", "func_signal": "START_TEST(test_bdd_and_reduced_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    /*\n     * Create a BDD representing\n     *   f(x) = x[0] \u2227 x[1]\n     */\n\n    ipset_node_id_t  n_false0 =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true0 =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  node00 =\n        ipset_node_cache_nonterminal(cache, 0, n_false0, n_true0);\n    ipset_node_id_t  node01 =\n        ipset_node_cache_nonterminal(cache, 1, n_false0, n_true0);\n    ipset_node_id_t  node0 =\n        ipset_node_cache_and(cache, node00, node01);\n\n    /*\n     * And then do it again.\n     */\n\n    ipset_node_id_t  n_false1 =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true1 =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  node10 =\n        ipset_node_cache_nonterminal(cache, 0, n_false1, n_true1);\n    ipset_node_id_t  node11 =\n        ipset_node_cache_nonterminal(cache, 1, n_false1, n_true1);\n    ipset_node_id_t  node1 =\n        ipset_node_cache_and(cache, node10, node11);\n\n    /*\n     * Verify that we get the same physical node both times.\n     */\n\n    fail_unless(node0 == node1,\n                \"AND operator result isn't reduced\");\n\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/**\n * Perform an actual binary operation.\n */\n", "func_signal": "static ipset_node_id_t\napply_op(ipset_node_cache_t *cache,\n         GHashTable *op_cache,\n         operator_func_t op,\n         const char *op_name,\n         ipset_node_id_t lhs,\n         ipset_node_id_t rhs)", "code": "{\n    if (ipset_node_get_type(lhs) == IPSET_TERMINAL_NODE)\n    {\n        if (ipset_node_get_type(rhs) == IPSET_TERMINAL_NODE)\n        {\n            /*\n             * When both nodes are terminal, we apply the operator to\n             * the terminals' values, and construct a new terminal\n             * from the result.  Note that we do not verify that the\n             * operator returns a positive value.\n             */\n\n            ipset_range_t  lhs_value = ipset_terminal_value(lhs);\n            ipset_range_t  rhs_value = ipset_terminal_value(rhs);\n            ipset_range_t  new_value = op(lhs_value, rhs_value);\n\n            return ipset_node_cache_terminal(cache, new_value);\n        } else {\n            /*\n             * When one node is terminal, and the other is\n             * nonterminal, we recurse down the subtrees of the\n             * nonterminal, combining the results with the terminal.\n             */\n\n            ipset_node_t  *rhs_node = ipset_nonterminal_node(rhs);\n            return recurse_left(cache, op_cache, op, op_name,\n                                rhs_node, lhs);\n        }\n    } else {\n        if (ipset_node_get_type(rhs) == IPSET_TERMINAL_NODE)\n        {\n            /*\n             * When one node is terminal, and the other is\n             * nonterminal, we recurse down the subtrees of the\n             * nonterminal, combining the results with the terminal.\n             */\n\n            ipset_node_t  *lhs_node = ipset_nonterminal_node(lhs);\n            return recurse_left(cache, op_cache, op, op_name,\n                                lhs_node, rhs);\n        } else {\n            /*\n             * When both nodes are nonterminal, the way we recurse\n             * depends on the variables of the nonterminals.  We\n             * always recurse down the nonterminal with the smaller\n             * variable index.  This ensures that our BDDs remain\n             * ordered.\n             */\n\n            ipset_node_t  *lhs_node = ipset_nonterminal_node(lhs);\n            ipset_node_t  *rhs_node = ipset_nonterminal_node(rhs);\n\n            if (lhs_node->variable == rhs_node->variable)\n            {\n                return recurse_both(cache, op_cache, op, op_name,\n                                    lhs_node, rhs_node);\n            } else if (lhs_node->variable < rhs_node->variable) {\n                return recurse_left(cache, op_cache, op, op_name,\n                                    lhs_node, rhs);\n            } else {\n                return recurse_left(cache, op_cache, op, op_name,\n                                    rhs_node, lhs);\n            }\n        }\n    }\n}", "path": "src\\libipset\\bdd\\binary-operators.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Iteration\n */\n", "func_signal": "START_TEST(test_bdd_iterate_1)", "code": "{\n    ipset_node_cache_t  *cache = ipset_node_cache_new();\n\n    /*\n     * Create a BDD representing\n     *   f(x) = \u00acx[0]\n     */\n\n    ipset_node_id_t  n_false =\n        ipset_node_cache_terminal(cache, FALSE);\n    ipset_node_id_t  n_true =\n        ipset_node_cache_terminal(cache, TRUE);\n\n    ipset_node_id_t  node =\n        ipset_node_cache_nonterminal(cache, 0, n_true, n_false);\n\n    /*\n     * And test that iterating the BDD gives us the expected results.\n     */\n\n    ipset_assignment_t  *expected;\n    expected = ipset_assignment_new();\n\n    ipset_bdd_iterator_t  *it = ipset_node_iterate(node);\n\n    fail_if(it->finished,\n            \"Iterator should not be empty\");\n    ipset_assignment_clear(expected);\n    ipset_assignment_set(expected, 0, IPSET_FALSE);\n    fail_unless(ipset_assignment_equal(expected, it->assignment),\n                \"Iterator assignment 0 doesn't match\");\n    fail_unless(TRUE == it->value,\n                \"Iterator value 0 doesn't match\");\n\n    ipset_bdd_iterator_advance(it);\n    fail_if(it->finished,\n            \"Iterator should have more than 1 element\");\n    ipset_assignment_clear(expected);\n    ipset_assignment_set(expected, 0, IPSET_TRUE);\n    fail_unless(ipset_assignment_equal(expected, it->assignment),\n                \"Iterator assignment 1 doesn't match\");\n    fail_unless(FALSE == it->value,\n                \"Iterator value 1 doesn't match (%u)\", it->value);\n\n    ipset_bdd_iterator_advance(it);\n    fail_unless(it->finished,\n                \"Iterator should have 2 elements\");\n\n    ipset_assignment_free(expected);\n    ipset_bdd_iterator_free(it);\n    ipset_node_cache_free(cache);\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/*-----------------------------------------------------------------------\n * Bit arrays\n */\n", "func_signal": "START_TEST(test_bit_get)", "code": "{\n    guint16  a = GUINT16_TO_BE(0x6012); /* 0110 0000 0001 0010 */\n\n    fail_unless(IPSET_BIT_GET(&a,  0) == 0,\n                \"Bit 0 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  1) == 1,\n                \"Bit 1 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  2) == 1,\n                \"Bit 2 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  3) == 0,\n                \"Bit 3 is incorrect\");\n\n    fail_unless(IPSET_BIT_GET(&a,  4) == 0,\n                \"Bit 4 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  5) == 0,\n                \"Bit 5 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  6) == 0,\n                \"Bit 6 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  7) == 0,\n                \"Bit 7 is incorrect\");\n\n    fail_unless(IPSET_BIT_GET(&a,  8) == 0,\n                \"Bit 8 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a,  9) == 0,\n                \"Bit 9 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a, 10) == 0,\n                \"Bit 10 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a, 11) == 1,\n                \"Bit 11 is incorrect\");\n\n    fail_unless(IPSET_BIT_GET(&a, 12) == 0,\n                \"Bit 12 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a, 13) == 0,\n                \"Bit 13 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a, 14) == 1,\n                \"Bit 14 is incorrect\");\n    fail_unless(IPSET_BIT_GET(&a, 15) == 0,\n                \"Bit 15 is incorrect\");\n}", "path": "tests\\test-bdd.c", "repo_name": "janies/ipset", "stars": 12, "license": "bsd-3-clause", "language": "c", "size": 696}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_have_end(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->end_fn != NULL)\n      (*(png_ptr->end_fn))(png_ptr, info_ptr);\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_sig(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   png_size_t num_checked = png_ptr->sig_bytes,\n             num_to_check = 8 - num_checked;\n\n   if (png_ptr->buffer_size < num_to_check)\n   {\n      num_to_check = png_ptr->buffer_size;\n   }\n\n   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),\n      num_to_check);\n   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes+num_to_check);\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   else\n   {\n      if (png_ptr->sig_bytes >= 8)\n      {\n         png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n      }\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place zTXt\");\n         info_ptr = info_ptr; /* to quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   /* We can't handle zTXt chunks > 64K, since we don't have enough space\n    * to be able to store the uncompressed data.  Actually, the threshold\n    * is probably around 32K, but it isn't as definite as 64K is.\n    */\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"zTXt chunk too large to fit in memory\");\n      png_push_crc_skip(png_ptr, length);\n      return;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n       (png_uint_32)(length+1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_zTXt_MODE;\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/*\n * Extract color map from a GIF file.\n */\n", "func_signal": "LOCAL(void)\nread_gif_map (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  int header[13];\n  int i, colormaplen;\n  int R, G, B;\n\n  /* Initial 'G' has already been read by read_color_map */\n  /* Read the rest of the GIF header and logical screen descriptor */\n  for (i = 1; i < 13; i++) {\n    if ((header[i] = getc(infile)) == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n  }\n\n  /* Verify GIF Header */\n  if (header[1] != 'I' || header[2] != 'F')\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* There must be a global color map. */\n  if ((header[10] & 0x80) == 0)\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* OK, fetch it. */\n  colormaplen = 2 << (header[10] & 0x07);\n\n  for (i = 0; i < colormaplen; i++) {\n    R = getc(infile);\n    G = getc(infile);\n    B = getc(infile);\n    if (R == EOF || G == EOF || B == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    add_map_entry(cinfo,\n\t\t  R << (BITS_IN_JSAMPLE-8),\n\t\t  G << (BITS_IN_JSAMPLE-8),\n\t\t  B << (BITS_IN_JSAMPLE-8));\n  }\n}", "path": "third_party\\jpeg\\rdcolmap.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place tEXt\");\n         info_ptr = info_ptr; /* to quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   png_ptr->skip_length = 0;  /* This may not be necessary */\n\n   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */\n   {\n      png_warning(png_ptr, \"tEXt chunk too large to fit in memory\");\n      png_ptr->skip_length = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n         (png_uint_32)(length+1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_tEXt_MODE;\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_save_buffer(png_structp png_ptr)", "code": "{\n   if (png_ptr->save_buffer_size)\n   {\n      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)\n      {\n         png_size_t i,istop;\n         png_bytep sp;\n         png_bytep dp;\n\n         istop = png_ptr->save_buffer_size;\n         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;\n            i < istop; i++, sp++, dp++)\n         {\n            *dp = *sp;\n         }\n      }\n   }\n   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >\n      png_ptr->save_buffer_max)\n   {\n      png_size_t new_max;\n      png_bytep old_buffer;\n\n      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -\n         (png_ptr->current_buffer_size + 256))\n      {\n        png_error(png_ptr, \"Potential overflow of save_buffer\");\n      }\n      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;\n      old_buffer = png_ptr->save_buffer;\n      png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr,\n         (png_uint_32)new_max);\n      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);\n      png_free(png_ptr, old_buffer);\n      png_ptr->save_buffer_max = new_max;\n   }\n   if (png_ptr->current_buffer_size)\n   {\n      png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,\n         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);\n      png_ptr->save_buffer_size += png_ptr->current_buffer_size;\n      png_ptr->current_buffer_size = 0;\n   }\n   png_ptr->save_buffer_ptr = png_ptr->save_buffer;\n   png_ptr->buffer_size = 0;\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/*\n * Main entry point from djpeg.c.\n *  Input: opened input file (from file name argument on command line).\n *  Output: colormap and actual_number_of_colors fields are set in cinfo.\n */\n", "func_signal": "GLOBAL(void)\nread_color_map (j_decompress_ptr cinfo, FILE * infile)", "code": "{\n  /* Allocate space for a color map of maximum supported size. */\n  cinfo->colormap = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n     (JDIMENSION) (MAXJSAMPLE+1), (JDIMENSION) 3);\n  cinfo->actual_number_of_colors = 0; /* initialize map to empty */\n\n  /* Read first byte to determine file format */\n  switch (getc(infile)) {\n  case 'G':\n    read_gif_map(cinfo, infile);\n    break;\n  case 'P':\n    read_ppm_map(cinfo, infile);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    break;\n  }\n}", "path": "third_party\\jpeg\\rdcolmap.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n      else\n         text_size = png_ptr->current_text_left;\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp text;\n      png_charp key;\n      int ret;\n      png_size_t text_size, key_size;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n      key = png_ptr->current_text;\n\n      for (text = key; *text; text++)\n         /* empty loop */ ;\n\n      /* zTXt can't have zero text */\n      if (text == key + png_ptr->current_text_size)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* check compression byte */\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         return;\n      }\n\n      text++;\n\n      png_ptr->zstream.next_in = (png_bytep )text;\n      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -\n         (text - key));\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n      key_size = text - key;\n      text_size = 0;\n      text = NULL;\n      ret = Z_STREAM_END;\n\n      while (png_ptr->zstream.avail_in)\n      {\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END)\n         {\n            inflateReset(&png_ptr->zstream);\n            png_ptr->zstream.avail_in = 0;\n            png_ptr->current_text = NULL;\n            png_free(png_ptr, key);\n            png_free(png_ptr, text);\n            return;\n         }\n         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)\n         {\n            if (text == NULL)\n            {\n               text = (png_charp)png_malloc(png_ptr,\n                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out\n                     + key_size + 1));\n               png_memcpy(text + key_size, png_ptr->zbuf,\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n               png_memcpy(text, key, key_size);\n               text_size = key_size + png_ptr->zbuf_size -\n                  png_ptr->zstream.avail_out;\n               *(text + text_size) = '\\0';\n            }\n            else\n            {\n               png_charp tmp;\n\n               tmp = text;\n               text = (png_charp)png_malloc(png_ptr, text_size +\n                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out\n                   + 1));\n               png_memcpy(text, tmp, text_size);\n               png_free(png_ptr, tmp);\n               png_memcpy(text + text_size, png_ptr->zbuf,\n                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);\n               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n               *(text + text_size) = '\\0';\n            }\n            if (ret != Z_STREAM_END)\n            {\n               png_ptr->zstream.next_out = png_ptr->zbuf;\n               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            }\n         }\n         else\n         {\n            break;\n         }\n\n         if (ret == Z_STREAM_END)\n            break;\n      }\n\n      inflateReset(&png_ptr->zstream);\n      png_ptr->zstream.avail_in = 0;\n\n      if (ret != Z_STREAM_END)\n      {\n         png_ptr->current_text = NULL;\n         png_free(png_ptr, key);\n         png_free(png_ptr, text);\n         return;\n      }\n\n      png_ptr->current_text = NULL;\n      png_free(png_ptr, key);\n      key = text;\n      text += key_size;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n          (png_uint_32)png_sizeof(png_text));\n      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;\n      text_ptr->key = key;\n#ifdef PNG_iTXt_SUPPORTED\n      text_ptr->lang = NULL;\n      text_ptr->lang_key = NULL;\n#endif\n      text_ptr->text = text;\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_free(png_ptr, key);\n      png_free(png_ptr, text_ptr);\n\n      if (ret)\n        png_warning(png_ptr, \"Insufficient memory to store text chunk.\");\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_crc_finish(png_structp png_ptr)", "code": "{\n   if (png_ptr->skip_length && png_ptr->save_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->skip_length < (png_uint_32)png_ptr->save_buffer_size)\n         save_size = (png_size_t)png_ptr->skip_length;\n      else\n         save_size = png_ptr->save_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);\n\n      png_ptr->skip_length -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->save_buffer_size -= save_size;\n      png_ptr->save_buffer_ptr += save_size;\n   }\n   if (png_ptr->skip_length && png_ptr->current_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->skip_length < (png_uint_32)png_ptr->current_buffer_size)\n         save_size = (png_size_t)png_ptr->skip_length;\n      else\n         save_size = png_ptr->current_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);\n\n      png_ptr->skip_length -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->current_buffer_size -= save_size;\n      png_ptr->current_buffer_ptr += save_size;\n   }\n   if (!png_ptr->skip_length)\n   {\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_crc_finish(png_ptr, 0);\n      png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32\n   length)", "code": "{\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))\n      {\n         png_error(png_ptr, \"Out of place iTXt\");\n         info_ptr = info_ptr; /* to quiet some compiler warnings */\n      }\n\n#ifdef PNG_MAX_MALLOC_64K\n   png_ptr->skip_length = 0;  /* This may not be necessary */\n\n   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */\n   {\n      png_warning(png_ptr, \"iTXt chunk too large to fit in memory\");\n      png_ptr->skip_length = length - (png_uint_32)65535L;\n      length = (png_uint_32)65535L;\n   }\n#endif\n\n   png_ptr->current_text = (png_charp)png_malloc(png_ptr,\n         (png_uint_32)(length+1));\n   png_ptr->current_text[length] = '\\0';\n   png_ptr->current_text_ptr = png_ptr->current_text;\n   png_ptr->current_text_size = (png_size_t)length;\n   png_ptr->current_text_left = (png_size_t)length;\n   png_ptr->process_mode = PNG_READ_iTXt_MODE;\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/******************************************************************************\n* Routine to insert a new Item into the HashTable. The data is assumed to be  *\n* new one.\t\t\t\t\t\t\t\t      *\n******************************************************************************/\n", "func_signal": "void _InsertHashTable(GifHashTableType *HashTable, UINT32 Key, int Code)", "code": "{\n    int HKey = KeyItem(Key);\n    UINT32 *HTable = HashTable -> HTable;\n\n#ifdef DEBUG_HIT_RATE\n\tNumberOfTests++;\n\tNumberOfMisses++;\n#endif /* DEBUG_HIT_RATE */\n\n    while (HT_GET_KEY(HTable[HKey]) != 0xFFFFFL) {\n#ifdef DEBUG_HIT_RATE\n\t    NumberOfMisses++;\n#endif /* DEBUG_HIT_RATE */\n\tHKey = (HKey + 1) & HT_KEY_MASK;\n    }\n    HTable[HKey] = HT_PUT_KEY(Key) | HT_PUT_CODE(Code);\n}", "path": "third_party\\giflib\\lib\\gif_hash.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_IDAT(png_structp png_ptr)", "code": "{\n#ifdef PNG_USE_LOCAL_ARRAYS\n   PNG_CONST PNG_IDAT;\n#endif\n   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))\n   {\n      png_byte chunk_length[4];\n\n      if (png_ptr->buffer_size < 8)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_fill_buffer(png_ptr, chunk_length, 4);\n      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);\n      png_reset_crc(png_ptr);\n      png_crc_read(png_ptr, png_ptr->chunk_name, 4);\n      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;\n\n      if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))\n      {\n         png_ptr->process_mode = PNG_READ_CHUNK_MODE;\n         if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n            png_error(png_ptr, \"Not enough compressed data\");\n         return;\n      }\n\n      png_ptr->idat_size = png_ptr->push_length;\n   }\n   if (png_ptr->idat_size && png_ptr->save_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)\n      {\n         save_size = (png_size_t)png_ptr->idat_size;\n         /* check for overflow */\n         if((png_uint_32)save_size != png_ptr->idat_size)\n            png_error(png_ptr, \"save_size overflowed in pngpread\");\n      }\n      else\n         save_size = png_ptr->save_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);\n      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n         png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);\n      png_ptr->idat_size -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->save_buffer_size -= save_size;\n      png_ptr->save_buffer_ptr += save_size;\n   }\n   if (png_ptr->idat_size && png_ptr->current_buffer_size)\n   {\n      png_size_t save_size;\n\n      if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)\n      {\n         save_size = (png_size_t)png_ptr->idat_size;\n         /* check for overflow */\n         if((png_uint_32)save_size != png_ptr->idat_size)\n            png_error(png_ptr, \"save_size overflowed in pngpread\");\n      }\n      else\n         save_size = png_ptr->current_buffer_size;\n\n      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);\n      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n        png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);\n\n      png_ptr->idat_size -= save_size;\n      png_ptr->buffer_size -= save_size;\n      png_ptr->current_buffer_size -= save_size;\n      png_ptr->current_buffer_ptr += save_size;\n   }\n   if (!png_ptr->idat_size)\n   {\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_crc_finish(png_ptr, 0);\n      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;\n      png_ptr->mode |= PNG_AFTER_IDAT;\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/**\n * art_svp_from_vpath: Convert a vpath to a sorted vector path.\n * @vpath: #ArtVPath to convert.\n *\n * Converts a vector path into sorted vector path form. The svp form is\n * more efficient for rendering and other vector operations.\n *\n * Basically, the implementation is to traverse the vector path,\n * generating a new segment for each \"run\" of points in the vector\n * path with monotonically increasing Y values. All the resulting\n * values are then sorted.\n *\n * Note: I'm not sure that the sorting rule is correct with respect\n * to numerical stability issues.\n *\n * Return value: Resulting sorted vector path.\n **/\n", "func_signal": "ArtSVP *\nart_svp_from_vpath (ArtVpath *vpath)", "code": "{\n  int n_segs, n_segs_max;\n  ArtSVP *svp;\n  int dir;\n  int new_dir;\n  int i;\n  ArtPoint *points;\n  int n_points, n_points_max;\n  double x, y;\n  double x_min, x_max;\n\n  n_segs = 0;\n  n_segs_max = 16;\n  svp = (ArtSVP *)art_alloc (sizeof(ArtSVP) +\n\t\t\t     (n_segs_max - 1) * sizeof(ArtSVPSeg));\n\n  dir = 0;\n  n_points = 0;\n  n_points_max = 0;\n  points = NULL;\n  i = 0;\n\n  x = y = 0; /* unnecessary, given \"first code must not be LINETO\" invariant,\n\t\tbut it makes gcc -Wall -ansi -pedantic happier */\n  x_min = x_max = 0; /* same */\n\n  while (vpath[i].code != ART_END) {\n    if (vpath[i].code == ART_MOVETO || vpath[i].code == ART_MOVETO_OPEN)\n      {\n\tif (points != NULL && n_points >= 2)\n\t  {\n\t    if (n_segs == n_segs_max)\n\t      {\n\t\tn_segs_max <<= 1;\n\t\tsvp = (ArtSVP *)art_realloc (svp, sizeof(ArtSVP) +\n\t\t\t\t\t     (n_segs_max - 1) *\n\t\t\t\t\t     sizeof(ArtSVPSeg));\n\t      }\n\t    svp->segs[n_segs].n_points = n_points;\n\t    svp->segs[n_segs].dir = (dir > 0);\n\t    if (dir < 0)\n\t      reverse_points (points, n_points);\n\t    svp->segs[n_segs].points = points;\n\t    svp->segs[n_segs].bbox.x0 = x_min;\n\t    svp->segs[n_segs].bbox.x1 = x_max;\n\t    svp->segs[n_segs].bbox.y0 = points[0].y;\n\t    svp->segs[n_segs].bbox.y1 = points[n_points - 1].y;\n\t    n_segs++;\n\t    points = NULL;\n\t  }\n\n\tif (points == NULL)\n\t  {\n\t    n_points_max = 4;\n\t    points = art_new (ArtPoint, n_points_max);\n\t  }\n\n\tn_points = 1;\n\tpoints[0].x = x = vpath[i].x;\n\tpoints[0].y = y = vpath[i].y;\n\tx_min = x;\n\tx_max = x;\n\tdir = 0;\n      }\n    else /* must be LINETO */\n      {\n\tnew_dir = (vpath[i].y > y ||\n\t\t   (vpath[i].y == y && vpath[i].x > x)) ? 1 : -1;\n\tif (dir && dir != new_dir)\n\t  {\n\t    /* new segment */\n\t    x = points[n_points - 1].x;\n\t    y = points[n_points - 1].y;\n\t    if (n_segs == n_segs_max)\n\t      {\n\t\tn_segs_max <<= 1;\n\t\tsvp = (ArtSVP *)art_realloc (svp, sizeof(ArtSVP) +\n\t\t\t\t\t     (n_segs_max - 1) *\n\t\t\t\t\t     sizeof(ArtSVPSeg));\n\t      }\n\t    svp->segs[n_segs].n_points = n_points;\n\t    svp->segs[n_segs].dir = (dir > 0);\n\t    if (dir < 0)\n\t      reverse_points (points, n_points);\n\t    svp->segs[n_segs].points = points;\n\t    svp->segs[n_segs].bbox.x0 = x_min;\n\t    svp->segs[n_segs].bbox.x1 = x_max;\n\t    svp->segs[n_segs].bbox.y0 = points[0].y;\n\t    svp->segs[n_segs].bbox.y1 = points[n_points - 1].y;\n\t    n_segs++;\n\n\t    n_points = 1;\n\t    n_points_max = 4;\n\t    points = art_new (ArtPoint, n_points_max);\n\t    points[0].x = x;\n\t    points[0].y = y;\n\t    x_min = x;\n\t    x_max = x;\n\t  }\n\n\tif (points != NULL)\n\t  {\n\t    if (n_points == n_points_max)\n\t      art_expand (points, ArtPoint, n_points_max);\n\t    points[n_points].x = x = vpath[i].x;\n\t    points[n_points].y = y = vpath[i].y;\n\t    if (x < x_min) x_min = x;\n\t    else if (x > x_max) x_max = x;\n\t    n_points++;\n\t  }\n\tdir = new_dir;\n      }\n    i++;\n  }\n\n  if (points != NULL)\n    {\n      if (n_points >= 2)\n\t{\n\t  if (n_segs == n_segs_max)\n\t    {\n\t      n_segs_max <<= 1;\n\t      svp = (ArtSVP *)art_realloc (svp, sizeof(ArtSVP) +\n\t\t\t\t\t   (n_segs_max - 1) *\n\t\t\t\t\t   sizeof(ArtSVPSeg));\n\t    }\n\t  svp->segs[n_segs].n_points = n_points;\n\t  svp->segs[n_segs].dir = (dir > 0);\n\t  if (dir < 0)\n\t    reverse_points (points, n_points);\n\t  svp->segs[n_segs].points = points;\n\t  svp->segs[n_segs].bbox.x0 = x_min;\n\t  svp->segs[n_segs].bbox.x1 = x_max;\n\t  svp->segs[n_segs].bbox.y0 = points[0].y;\n\t  svp->segs[n_segs].bbox.y1 = points[n_points - 1].y;\n\t  n_segs++;\n\t}\n      else\n\tart_free (points);\n    }\n\n  svp->n_segs = n_segs;\n\n  qsort (&svp->segs, n_segs, sizeof (ArtSVPSeg), art_svp_seg_compare);\n\n  return svp;\n}", "path": "third_party\\libart_lgpl\\art_svp_vpath.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/******************************************************************************\n* Debugging routine to print the hit ratio - number of times the hash table   *\n* was tested per operation. This routine was used to test the KeyItem routine *\n******************************************************************************/\n", "func_signal": "void HashTablePrintHitRatio(void)", "code": "{\n    printf(\"Hash Table Hit Ratio is %ld/%ld = %ld%%.\\n\",\n\tNumberOfMisses, NumberOfTests,\n\tNumberOfMisses * 100 / NumberOfTests);\n}", "path": "third_party\\giflib\\lib\\gif_hash.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_crc_skip(png_structp png_ptr, png_uint_32 skip)", "code": "{\n   png_ptr->process_mode = PNG_SKIP_MODE;\n   png_ptr->skip_length = skip;\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_push_finish_row(png_structp png_ptr)", "code": "{\n#ifdef PNG_USE_LOCAL_ARRAYS\n   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* start of interlace block */\n   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* offset to next interlace block */\n   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* start of interlace block in the y direction */\n   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* offset to next interlace block in the y direction */\n   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};\n\n   /* Height of interlace block.  This is not currently used - if you need\n    * it, uncomment it here and in png.h\n   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};\n   */\n#endif\n\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n   if (png_ptr->interlaced)\n   {\n      png_ptr->row_number = 0;\n      png_memset_check(png_ptr, png_ptr->prev_row, 0,\n         png_ptr->rowbytes + 1);\n      do\n      {\n         png_ptr->pass++;\n         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||\n             (png_ptr->pass == 3 && png_ptr->width < 3) ||\n             (png_ptr->pass == 5 && png_ptr->width < 2))\n           png_ptr->pass++;\n\n         if (png_ptr->pass > 7)\n            png_ptr->pass--;\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,\n            png_ptr->iwidth) + 1;\n\n         if (png_ptr->transformations & PNG_INTERLACE)\n            break;\n\n         png_ptr->num_rows = (png_ptr->height +\n            png_pass_yinc[png_ptr->pass] - 1 -\n            png_pass_ystart[png_ptr->pass]) /\n            png_pass_yinc[png_ptr->pass];\n\n      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/******************************************************************************\n* Initialize HashTable - allocate the memory needed and clear it.\t      *\n******************************************************************************/\n", "func_signal": "GifHashTableType *_InitHashTable(void)", "code": "{\n    GifHashTableType *HashTable;\n\n    if ((HashTable = (GifHashTableType *) malloc(sizeof(GifHashTableType)))\n\t== NULL)\n\treturn NULL;\n\n    _ClearHashTable(HashTable);\n\n    return HashTable;\n}", "path": "third_party\\giflib\\lib\\gif_hash.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)", "code": "{\n\n   if (png_ptr->buffer_size && png_ptr->current_text_left)\n   {\n      png_size_t text_size;\n\n      if (png_ptr->buffer_size < png_ptr->current_text_left)\n         text_size = png_ptr->buffer_size;\n      else\n         text_size = png_ptr->current_text_left;\n      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);\n      png_ptr->current_text_left -= text_size;\n      png_ptr->current_text_ptr += text_size;\n   }\n   if (!(png_ptr->current_text_left))\n   {\n      png_textp text_ptr;\n      png_charp key;\n      int comp_flag;\n      png_charp lang;\n      png_charp lang_key;\n      png_charp text;\n      int ret;\n\n      if (png_ptr->buffer_size < 4)\n      {\n         png_push_save_buffer(png_ptr);\n         return;\n      }\n\n      png_push_crc_finish(png_ptr);\n\n#if defined(PNG_MAX_MALLOC_64K)\n      if (png_ptr->skip_length)\n         return;\n#endif\n\n      key = png_ptr->current_text;\n\n      for (lang = key; *lang; lang++)\n         /* empty loop */ ;\n\n      if (lang != key + png_ptr->current_text_size)\n         lang++;\n\n      comp_flag = *lang++;\n      lang++;     /* skip comp_type, always zero */\n\n      for (lang_key = lang; *lang_key; lang_key++)\n         /* empty loop */ ;\n      lang_key++;        /* skip NUL separator */\n\n      for (text = lang_key; *text; text++)\n         /* empty loop */ ;\n\n      if (text != key + png_ptr->current_text_size)\n         text++;\n\n      text_ptr = (png_textp)png_malloc(png_ptr,\n         (png_uint_32)png_sizeof(png_text));\n      text_ptr->compression = comp_flag + 2;\n      text_ptr->key = key;\n      text_ptr->lang = lang;\n      text_ptr->lang_key = lang_key;\n      text_ptr->text = text;\n      text_ptr->text_length = 0;\n      text_ptr->itxt_length = png_strlen(text);\n\n      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n      png_ptr->current_text = NULL;\n\n      png_free(png_ptr, text_ptr);\n      if (ret)\n        png_warning(png_ptr, \"Insufficient memory to store iTXt chunk.\");\n   }\n}", "path": "third_party\\libpng\\pngpread.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* reverse a list of points in place */\n", "func_signal": "static void\nreverse_points (ArtPoint *points, int n_points)", "code": "{\n  int i;\n  ArtPoint tmp_p;\n\n  for (i = 0; i < (n_points >> 1); i++)\n    {\n      tmp_p = points[i];\n      points[i] = points[n_points - (i + 1)];\n      points[n_points - (i + 1)] = tmp_p;\n    }\n}", "path": "third_party\\libart_lgpl\\art_svp_vpath.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/*\n * Add a (potentially) new color to the color map.\n */\n", "func_signal": "LOCAL(void)\nadd_map_entry (j_decompress_ptr cinfo, int R, int G, int B)", "code": "{\n  JSAMPROW colormap0 = cinfo->colormap[0];\n  JSAMPROW colormap1 = cinfo->colormap[1];\n  JSAMPROW colormap2 = cinfo->colormap[2];\n  int ncolors = cinfo->actual_number_of_colors;\n  int index;\n\n  /* Check for duplicate color. */\n  for (index = 0; index < ncolors; index++) {\n    if (GETJSAMPLE(colormap0[index]) == R &&\n\tGETJSAMPLE(colormap1[index]) == G &&\n\tGETJSAMPLE(colormap2[index]) == B)\n      return;\t\t\t/* color is already in map */\n  }\n\n  /* Check for map overflow. */\n  if (ncolors >= (MAXJSAMPLE+1))\n    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, (MAXJSAMPLE+1));\n\n  /* OK, add color to map. */\n  colormap0[ncolors] = (JSAMPLE) R;\n  colormap1[ncolors] = (JSAMPLE) G;\n  colormap2[ncolors] = (JSAMPLE) B;\n  cinfo->actual_number_of_colors++;\n}", "path": "third_party\\jpeg\\rdcolmap.c", "repo_name": "Skiles/aseprite", "stars": 8, "license": "gpl-2.0", "language": "c", "size": 9950}
{"docstring": "/* dest on static area */\n", "func_signal": "static UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, int capa)", "code": "{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* else USE_ST_LIBRARY */\n", "func_signal": "static int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)", "code": "{\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n#ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(5);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);  return ONIGERR_MEMORY;\n    }\n    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                          (HashDataType )e);\n\n    e->name_len   = name_end - name;\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n#else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n\txfree(t);\n\treturn ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n\n      alloc = t->alloc * 2;\n      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(t->e);\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n\tt->e[i].name       = NULL;\n\tt->e[i].name_len   = 0;\n\tt->e[i].back_num   = 0;\n\tt->e[i].back_alloc = 0;\n\tt->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n#endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n\t\t\t\t    name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n\talloc = e->back_alloc * 2;\n\te->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(e->back_refs);\n\te->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/*\n  def: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\n", "func_signal": "static int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)", "code": "{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n\tis_num = 1;\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n\tis_num = 2;\n\tsign = -1;\n\tpnum_head = p;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\t\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH(c);\n      if (c == end_code || c == ')') {\n\tif (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n\tbreak;\n      }\n\n      if (is_num != 0) {\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\t  is_num = 1;\n\t}\n\telse {\n\t  if (!ONIGENC_IS_CODE_WORD(enc, c))\n\t    r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  else\n\t    r = ONIGERR_INVALID_GROUP_NAME;\n\n\t  is_num = 0;\n\t}\n      }\n      else {\n\tif (!ONIGENC_IS_CODE_WORD(enc, c)) {\n\t  r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t}\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tgoto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH(c);\n      if (c == end_code || c == ')')\n\tbreak;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* fixed size pattern node only */\n", "func_signal": "static int\nget_char_length_tree1(Node* node, regex_t* reg, int* len, int level)", "code": "{\n  int tlen;\n  int r = 0;\n\n  level++;\n  *len = 0;\n  switch (NTYPE(node)) {\n  case NT_LIST:\n    do {\n      r = get_char_length_tree1(NCAR(node), reg, &tlen, level);\n      if (r == 0)\n\t*len = distance_add(*len, tlen);\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  case NT_ALT:\n    {\n      int tlen2;\n      int varlen = 0;\n\n      r = get_char_length_tree1(NCAR(node), reg, &tlen, level);\n      while (r == 0 && IS_NOT_NULL(node = NCDR(node))) {\n\tr = get_char_length_tree1(NCAR(node), reg, &tlen2, level);\n\tif (r == 0) {\n\t  if (tlen != tlen2)\n\t    varlen = 1;\n\t}\n      }\n      if (r == 0) {\n\tif (varlen != 0) {\n\t  if (level == 1)\n\t    r = GET_CHAR_LEN_TOP_ALT_VARLEN;\n\t  else\n\t    r = GET_CHAR_LEN_VARLEN;\n\t}\n\telse\n\t  *len = tlen;\n      }\n    }\n    break;\n\n  case NT_STR:\n    {\n      StrNode* sn = NSTR(node);\n      UChar *s = sn->s;\n      while (s < sn->end) {\n\ts += enclen(reg->enc, s);\n\t(*len)++;\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    {\n      QtfrNode* qn = NQTFR(node);\n      if (qn->lower == qn->upper) {\n\tr = get_char_length_tree1(qn->target, reg, &tlen, level);\n\tif (r == 0)\n\t  *len = distance_multiply(tlen, qn->lower);\n      }\n      else\n\tr = GET_CHAR_LEN_VARLEN;\n    }\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n    if (! IS_CALL_RECURSION(NCALL(node)))\n      r = get_char_length_tree1(NCALL(node)->target, reg, len, level);\n    else\n      r = GET_CHAR_LEN_VARLEN;\n    break;\n#endif\n\n  case NT_CTYPE:\n    *len = 1;\n    break;\n\n  case NT_CCLASS:\n  case NT_CANY:\n    *len = 1;\n    break;\n\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      switch (en->type) {\n      case ENCLOSE_MEMORY:\n#ifdef USE_SUBEXP_CALL\n\tif (IS_ENCLOSE_CLEN_FIXED(en))\n\t  *len = en->char_len;\n\telse {\n\t  r = get_char_length_tree1(en->target, reg, len, level);\n\t  if (r == 0) {\n\t    en->char_len = *len;\n\t    SET_ENCLOSE_STATUS(node, NST_CLEN_FIXED);\n\t  }\n\t}\n\tbreak;\n#endif\n      case ENCLOSE_OPTION:\n      case ENCLOSE_STOP_BACKTRACK:\n\tr = get_char_length_tree1(en->target, reg, len, level);\n\tbreak;\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_ANCHOR:\n    break;\n\n  default:\n    r = GET_CHAR_LEN_VARLEN;\n    break;\n  }\n\n  return r;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* x is not included y ==>  1 : 0 */\n", "func_signal": "static int\nis_not_included(Node* x, Node* y, regex_t* reg)", "code": "{\n  int i, len;\n  OnigCodePoint code;\n  UChar *p, c;\n  int ytype;\n\n retry:\n  ytype = NTYPE(y);\n  switch (NTYPE(x)) {\n  case NT_CTYPE:\n    {\n      switch (ytype) {\n      case NT_CTYPE:\n\tif (NCTYPE(y)->ctype == NCTYPE(x)->ctype &&\n\t    NCTYPE(y)->not   != NCTYPE(x)->not)\n\t  return 1;\n\telse\n\t  return 0;\n\tbreak;\n\n      case NT_CCLASS:\n      swap:\n\t{\n\t  Node* tmp;\n\t  tmp = x; x = y; y = tmp;\n\t  goto retry;\n\t}\n\tbreak;\n\n      case NT_STR:\n\tgoto swap;\n\tbreak;\n\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* xc = NCCLASS(x);\n      switch (ytype) {\n      case NT_CTYPE:\n\tswitch (NCTYPE(y)->ctype) {\n\tcase ONIGENC_CTYPE_WORD:\n\t  if (NCTYPE(y)->not == 0) {\n\t    if (IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) {\n\t      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t\tif (BITSET_AT(xc->bs, i)) {\n\t\t  if (IS_CODE_SB_WORD(reg->enc, i)) return 0;\n\t\t}\n\t      }\n\t      return 1;\n\t    }\n\t    return 0;\n\t  }\n\t  else {\n\t    for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t      if (! IS_CODE_SB_WORD(reg->enc, i)) {\n\t\tif (!IS_NCCLASS_NOT(xc)) {\n\t\t  if (BITSET_AT(xc->bs, i))\n\t\t    return 0;\n\t\t}\n\t\telse {\n\t\t  if (! BITSET_AT(xc->bs, i))\n\t\t    return 0;\n\t\t}\n\t      }\n\t    }\n\t    return 1;\n\t  }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n\n      case NT_CCLASS:\n\t{\n\t  int v;\n\t  CClassNode* yc = NCCLASS(y);\n\n\t  for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t    v = BITSET_AT(xc->bs, i);\n\t    if ((v != 0 && !IS_NCCLASS_NOT(xc)) ||\n                (v == 0 && IS_NCCLASS_NOT(xc))) {\n\t      v = BITSET_AT(yc->bs, i);\n\t      if ((v != 0 && !IS_NCCLASS_NOT(yc)) ||\n                  (v == 0 && IS_NCCLASS_NOT(yc)))\n\t\treturn 0;\n\t    }\n\t  }\n\t  if ((IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) ||\n\t      (IS_NULL(yc->mbuf) && !IS_NCCLASS_NOT(yc)))\n\t    return 1;\n\t  return 0;\n\t}\n\tbreak;\n\n      case NT_STR:\n\tgoto swap;\n\tbreak;\n\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_STR:\n    {\n      StrNode* xs = NSTR(x);\n      if (NSTRING_LEN(x) == 0)\n\tbreak;\n\n      c = *(xs->s);\n      switch (ytype) {\n      case NT_CTYPE:\n\tswitch (NCTYPE(y)->ctype) {\n\tcase ONIGENC_CTYPE_WORD:\n\t  if (ONIGENC_IS_MBC_WORD(reg->enc, xs->s, xs->end))\n\t    return NCTYPE(y)->not;\n\t  else\n\t    return !(NCTYPE(y)->not);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n\n      case NT_CCLASS:\n\t{\n\t  CClassNode* cc = NCCLASS(y);\n\n\t  code = ONIGENC_MBC_TO_CODE(reg->enc, xs->s,\n\t\t\t\t     xs->s + ONIGENC_MBC_MAXLEN(reg->enc));\n\t  return (onig_is_code_in_cc(reg->enc, code, cc) != 0 ? 0 : 1);\n\t}\n\tbreak;\n\n      case NT_STR:\n\t{\n\t  UChar *q;\n\t  StrNode* ys = NSTR(y);\n\t  len = NSTRING_LEN(x);\n\t  if (len > NSTRING_LEN(y)) len = NSTRING_LEN(y);\n\t  if (NSTRING_IS_AMBIG(x) || NSTRING_IS_AMBIG(y)) {\n            /* tiny version */\n            return 0;\n\t  }\n\t  else {\n\t    for (i = 0, p = ys->s, q = xs->s; i < len; i++, p++, q++) {\n\t      if (*p != *q) return 1;\n\t    }\n\t  }\n\t}\n\tbreak;\n\t\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return 0;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* Property management */\n", "func_signal": "static int\nresize_property_list(int new_size, const OnigCodePoint*** plist, int* psize)", "code": "{\n  int size;\n  const OnigCodePoint **list = *plist;\n\n  size = sizeof(OnigCodePoint*) * new_size;\n  if (IS_NULL(list)) {\n    list = (const OnigCodePoint** )xmalloc(size);\n  }\n  else {\n    list = (const OnigCodePoint** )xrealloc((void* )list, size);\n  }\n\n  if (IS_NULL(list)) return ONIGERR_MEMORY;\n\n  *plist = list;\n  *psize = new_size;\n\n  return 0;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regenc.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\n", "func_signal": "static int\npopular_quantifier_num(QtfrNode* q)", "code": "{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 5;\n    }\n  }\n  return -1;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* ONIG_DEBUG */\n", "func_signal": "extern void\nonig_free_body(regex_t* reg)", "code": "{\n  if (IS_NOT_NULL(reg)) {\n    if (IS_NOT_NULL(reg->p))                xfree(reg->p);\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->int_map))          xfree(reg->int_map);\n    if (IS_NOT_NULL(reg->int_map_backward)) xfree(reg->int_map_backward);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->chain))            onig_free(reg->chain);\n\n#ifdef USE_NAMED_GROUP\n    onig_names_free(reg);\n#endif\n  }\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\n", "func_signal": "static int\nnew_code_range(BBuf** pbuf)", "code": "{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* ONIG_DEBUG */\n", "func_signal": "static int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)", "code": "{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* set skip map for Boyer-Moor search */\n", "func_signal": "static int\nset_bm_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t    UChar skip[], int** int_skip)", "code": "{\n  int i, len;\n\n  len = end - s;\n  if (len < ONIG_CHAR_TABLE_SIZE) {\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) skip[i] = len;\n\n    for (i = 0; i < len - 1; i++)\n      skip[s[i]] = len - 1 - i;\n  }\n  else {\n    if (IS_NULL(*int_skip)) {\n      *int_skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n      if (IS_NULL(*int_skip)) return ONIGERR_MEMORY;\n    }\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) (*int_skip)[i] = len;\n\n    for (i = 0; i < len - 1; i++)\n      (*int_skip)[s[i]] = len - 1 - i;\n  }\n  return 0;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* else USE_NAMED_GROUP */\n", "func_signal": "extern int\nonig_noname_group_capture_is_active(regex_t* reg)", "code": "{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\n", "func_signal": "static int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)", "code": "{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) return r;\n\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  return r;\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* setup_tree does the following work.\n 1. check empty loop. (set qn->target_empty_info)\n 2. expand ignore-case in char class.\n 3. set memory status bit flags. (reg->mem_stats)\n 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].\n 5. find invalid patterns in look-behind.\n 6. expand repeated string.\n */\n", "func_signal": "static int\nsetup_tree(Node* node, regex_t* reg, int state, ScanEnv* env)", "code": "{\n  int type;\n  int r = 0;\n\n  type = NTYPE(node);\n  switch (type) {\n  case NT_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n\tr = setup_tree(NCAR(node), reg, state, env);\n\tif (IS_NOT_NULL(prev) && r == 0) {\n\t  r = next_setup(prev, NCAR(node), reg);\n\t}\n\tprev = NCAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    }\n    break;\n\n  case NT_ALT:\n    do {\n      r = setup_tree(NCAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  case NT_CCLASS:\n    break;\n\n  case NT_STR:\n    if (IS_IGNORECASE(reg->options) && !NSTRING_IS_RAW(node)) {\n      r = expand_case_fold_string(node, reg);\n    }\n    break;\n\n  case NT_CTYPE:\n  case NT_CANY:\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n    break;\n#endif\n\n  case NT_BREF:\n    {\n      int i;\n      int* p;\n      Node** nodes = SCANENV_MEM_NODES(env);\n      BRefNode* br = NBREF(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n\tif (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n\tBIT_STATUS_ON_AT(env->backrefed_mem, p[i]);\n\tBIT_STATUS_ON_AT(env->bt_mem_start, p[i]);\n#ifdef USE_BACKREF_WITH_LEVEL\n\tif (IS_BACKREF_NEST_LEVEL(br)) {\n\t  BIT_STATUS_ON_AT(env->bt_mem_end, p[i]);\n\t}\n#endif\n\tSET_ENCLOSE_STATUS(nodes[p[i]], NST_MEM_BACKREFED);\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    {\n      OnigDistance d;\n      QtfrNode* qn = NQTFR(node);\n      Node* target = qn->target;\n\n      if ((state & IN_REPEAT) != 0) {\n        qn->state |= NST_IN_REPEAT;\n      }\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 1) {\n\tr = get_min_match_length(target, &d, env);\n\tif (r) break;\n\tif (d == 0) {\n\t  qn->target_empty_info = NQ_TARGET_IS_EMPTY;\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n\t  r = quantifiers_memory_node_info(target);\n\t  if (r < 0) break;\n\t  if (r > 0) {\n\t    qn->target_empty_info = r;\n\t  }\n#endif\n#if 0\n\t  r = get_max_match_length(target, &d, env);\n\t  if (r == 0 && d == 0) {\n\t    /*  ()* ==> ()?, ()+ ==> ()  */\n\t    qn->upper = 1;\n\t    if (qn->lower > 1) qn->lower = 1;\n\t    if (NTYPE(target) == NT_STR) {\n\t      qn->upper = qn->lower = 0;  /* /(?:)+/ ==> // */\n\t    }\n\t  }\n#endif\n\t}\n      }\n\n      state |= IN_REPEAT;\n      if (qn->lower != qn->upper)\n\tstate |= IN_VAR_REPEAT;\n      r = setup_tree(target, reg, state, env);\n      if (r) break;\n\n      /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n      if (NTYPE(target) == NT_STR) {\n\tif (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&\n\t    qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n\t  int len = NSTRING_LEN(target);\n\t  StrNode* sn = NSTR(target);\n\n\t  if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n\t    int i, n = qn->lower;\n\t    onig_node_conv_to_str_node(node, NSTR(target)->flag);\n\t    for (i = 0; i < n; i++) {\n\t      r = onig_node_str_cat(node, sn->s, sn->end);\n\t      if (r) break;\n\t    }\n\t    onig_node_free(target);\n\t    break; /* break case NT_QTFR: */\n\t  }\n\t}\n      }\n\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (qn->greedy && (qn->target_empty_info != 0)) {\n\tif (NTYPE(target) == NT_QTFR) {\n\t  QtfrNode* tqn = NQTFR(target);\n\t  if (IS_NOT_NULL(tqn->head_exact)) {\n\t    qn->head_exact  = tqn->head_exact;\n\t    tqn->head_exact = NULL;\n\t  }\n\t}\n\telse {\n\t  qn->head_exact = get_head_value_node(qn->target, 1, reg);\n\t}\n      }\n#endif\n    }\n    break;\n\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n\n      switch (en->type) {\n      case ENCLOSE_OPTION:\n\t{\n\t  OnigOptionType options = reg->options;\n\t  reg->options = NENCLOSE(node)->option;\n\t  r = setup_tree(NENCLOSE(node)->target, reg, state, env);\n\t  reg->options = options;\n\t}\n\tbreak;\n\n      case ENCLOSE_MEMORY:\n\tif ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {\n\t  BIT_STATUS_ON_AT(env->bt_mem_start, en->regnum);\n\t  /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */\n\t}\n        r = setup_tree(en->target, reg, state, env);\n        break;\n\n      case ENCLOSE_STOP_BACKTRACK:\n\t{\n\t  Node* target = en->target;\n\t  r = setup_tree(target, reg, state, env);\n\t  if (NTYPE(target) == NT_QTFR) {\n\t    QtfrNode* tqn = NQTFR(target);\n\t    if (IS_REPEAT_INFINITE(tqn->upper) && tqn->lower <= 1 &&\n\t\ttqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n\t      int qtype = NTYPE(tqn->target);\n\t      if (IS_NODE_TYPE_SIMPLE(qtype))\n\t\tSET_ENCLOSE_STATUS(node, NST_STOP_BT_SIMPLE_REPEAT);\n\t    }\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_ANCHOR:\n    {\n      AnchorNode* an = NANCHOR(node);\n\n      switch (an->type) {\n      case ANCHOR_PREC_READ:\n\tr = setup_tree(an->target, reg, state, env);\n\tbreak;\n      case ANCHOR_PREC_READ_NOT:\n\tr = setup_tree(an->target, reg, (state | IN_NOT), env);\n\tbreak;\n\n/* allowed node types in look-behind */\n#define ALLOWED_TYPE_IN_LB  \\\n  ( BIT_NT_LIST | BIT_NT_ALT | BIT_NT_STR | BIT_NT_CCLASS | BIT_NT_CTYPE | \\\n    BIT_NT_CANY | BIT_NT_ANCHOR | BIT_NT_ENCLOSE | BIT_NT_QTFR | BIT_NT_CALL )\n\n#define ALLOWED_ENCLOSE_IN_LB       ( ENCLOSE_MEMORY )\n#define ALLOWED_ENCLOSE_IN_LB_NOT   0\n\n#define ALLOWED_ANCHOR_IN_LB \\\n( ANCHOR_LOOK_BEHIND | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION )\n#define ALLOWED_ANCHOR_IN_LB_NOT \\\n( ANCHOR_LOOK_BEHIND | ANCHOR_LOOK_BEHIND_NOT | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION )\n\n      case ANCHOR_LOOK_BEHIND:\n\t{\n\t  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,\n\t\t\t      ALLOWED_ENCLOSE_IN_LB, ALLOWED_ANCHOR_IN_LB);\n\t  if (r < 0) return r;\n\t  if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n\t  r = setup_look_behind(node, reg, env);\n\t  if (r != 0) return r;\n\t  r = setup_tree(an->target, reg, state, env);\n\t}\n\tbreak;\n\n      case ANCHOR_LOOK_BEHIND_NOT:\n\t{\n\t  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,\n\t\t      ALLOWED_ENCLOSE_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB_NOT);\n\t  if (r < 0) return r;\n\t  if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n\t  r = setup_look_behind(node, reg, env);\n\t  if (r != 0) return r;\n\t  r = setup_tree(an->target, reg, (state | IN_NOT), env);\n\t}\n\tbreak;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* USE_SUBEXP_CALL */\n", "func_signal": "static int\nadd_opcode(regex_t* reg, int opcode)", "code": "{\n  BBUF_ADD1(reg, opcode);\n  return 0;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\n", "func_signal": "static int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)", "code": "{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\tis_num = 1;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      PFETCH(c);\n      if (c == end_code)\n\tgoto end;\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* USE_COMBINATION_EXPLOSION_CHECK */\n", "func_signal": "static int\ncompile_length_option_node(EncloseNode* node, regex_t* reg)", "code": "{\n  int tlen;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->option;\n  tlen = compile_length_tree(node->target, reg);\n  reg->options = prev;\n\n  if (tlen < 0) return tlen;\n\n  if (IS_DYNAMIC_OPTION(prev ^ node->option)) {\n    return SIZE_OP_SET_OPTION_PUSH + SIZE_OP_SET_OPTION + SIZE_OP_FAIL\n           + tlen + SIZE_OP_SET_OPTION;\n  }\n  else\n    return tlen;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* divide different length alternatives in look-behind.\n  (?<=A|B) ==> (?<=A)|(?<=B)\n  (?<!A|B) ==> (?<!A)(?<!B)\n*/\n", "func_signal": "static int\ndivide_look_behind_alternatives(Node* node)", "code": "{\n  Node *head, *np, *insert_node;\n  AnchorNode* an = NANCHOR(node);\n  int anc_type = an->type;\n\n  head = an->target;\n  np = NCAR(head);\n  swap_node(node, head);\n  NCAR(node) = head;\n  NANCHOR(head)->target = np;\n\n  np = node;\n  while ((np = NCDR(np)) != NULL_NODE) {\n    insert_node = onig_node_new_anchor(anc_type);\n    CHECK_NULL_RETURN_MEMERR(insert_node);\n    NANCHOR(insert_node)->target = NCAR(np);\n    NCAR(np) = insert_node;\n  }\n\n  if (anc_type == ANCHOR_LOOK_BEHIND_NOT) {\n    np = node;\n    do {\n      SET_NTYPE(np, NT_LIST);  /* alt -> list */\n    } while ((np = NCDR(np)) != NULL_NODE);\n  }\n  return 0;\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regcomp.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* USE_NAMED_GROUP */\n", "func_signal": "static void\nCC_ESC_WARN(ScanEnv* env, UChar *c)", "code": "{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n                (UChar* )\"character class has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}", "path": "Classes\\CocoaOniguruma\\oniguruma\\regparse.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* for single byte encodings */\n", "func_signal": "extern int\nonigenc_ascii_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED, const UChar** p,\n\t    const UChar*end ARG_UNUSED, UChar* lower)", "code": "{\n  *lower = ONIGENC_ASCII_CODE_TO_LOWER_CASE(**p);\n\n  (*p)++;\n  return 1; /* return byte length of converted char to lower */\n}", "path": "build\\Release\\clojure.sugar\\Contents\\Resources\\Classes\\CocoaOniguruma\\oniguruma\\regenc.c", "repo_name": "meric/clojure", "stars": 8, "license": "None", "language": "c", "size": 6003}
{"docstring": "/* Rename a file.  */\n", "func_signal": "int\n__gnat_rename (char *from, char *to)", "code": "{\n#if defined (__MINGW32__) && ! defined (__vxworks) && ! defined (IS_CROSS)\n  {\n    TCHAR wfrom[GNAT_MAX_PATH_LEN], wto[GNAT_MAX_PATH_LEN];\n\n    S2WSC (wfrom, from, GNAT_MAX_PATH_LEN);\n    S2WSC (wto, to, GNAT_MAX_PATH_LEN);\n    return _trename (wfrom, wto);\n  }\n#else\n  return rename (from, to);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return the current working directory.  */\n", "func_signal": "void\n__gnat_get_current_dir (char *dir, int *length)", "code": "{\n#if defined (__MINGW32__)\n  TCHAR wdir[GNAT_MAX_PATH_LEN];\n\n  _tgetcwd (wdir, *length);\n\n  WS2SC (dir, wdir, GNAT_MAX_PATH_LEN);\n\n#elif defined (VMS)\n   /* Force Unix style, which is what GNAT uses internally.  */\n   getcwd (dir, *length, 0);\n#else\n   getcwd (dir, *length);\n#endif\n\n   *length = strlen (dir);\n\n   if (dir [*length - 1] != DIR_SEPARATOR)\n     {\n       dir [*length] = DIR_SEPARATOR;\n       ++(*length);\n     }\n   dir[*length] = '\\0';\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return nonzero if file names are case sensitive.  */\n", "func_signal": "int\n__gnat_get_file_names_case_sensitive (void)", "code": "{\n#if defined (__EMX__) || defined (MSDOS) || defined (VMS) || defined (WINNT)\n  return 0;\n#else\n  return 1;\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return a GNAT time stamp given a file descriptor.  */\n", "func_signal": "OS_Time\n__gnat_file_time_fd (int fd)", "code": "{\n  /* The following workaround code is due to the fact that under EMX and\n     DJGPP fstat attempts to convert time values to GMT rather than keep the\n     actual OS timestamp of the file. By using the OS2/DOS functions directly\n     the GNAT timestamp are independent of this behavior, which is desired to\n     facilitate the distribution of GNAT compiled libraries.  */\n\n#if defined (__EMX__) || defined (MSDOS)\n#ifdef __EMX__\n\n  FILESTATUS fs;\n  int ret = DosQueryFileInfo (fd, 1, (unsigned char *) &fs,\n                                sizeof (FILESTATUS));\n\n  unsigned file_year  = fs.fdateLastWrite.year;\n  unsigned file_month = fs.fdateLastWrite.month;\n  unsigned file_day   = fs.fdateLastWrite.day;\n  unsigned file_hour  = fs.ftimeLastWrite.hours;\n  unsigned file_min   = fs.ftimeLastWrite.minutes;\n  unsigned file_tsec  = fs.ftimeLastWrite.twosecs;\n\n#else\n  struct ftime fs;\n  int ret = getftime (fd, &fs);\n\n  unsigned file_year  = fs.ft_year;\n  unsigned file_month = fs.ft_month;\n  unsigned file_day   = fs.ft_day;\n  unsigned file_hour  = fs.ft_hour;\n  unsigned file_min   = fs.ft_min;\n  unsigned file_tsec  = fs.ft_tsec;\n#endif\n\n  /* Calculate the seconds since epoch from the time components. First count\n     the whole days passed.  The value for years returned by the DOS and OS2\n     functions count years from 1980, so to compensate for the UNIX epoch which\n     begins in 1970 start with 10 years worth of days and add days for each\n     four year period since then.  */\n\n  time_t tot_secs;\n  int cum_days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n  int days_passed = 3652 + (file_year / 4) * 1461;\n  int years_since_leap = file_year % 4;\n\n  if (years_since_leap == 1)\n    days_passed += 366;\n  else if (years_since_leap == 2)\n    days_passed += 731;\n  else if (years_since_leap == 3)\n    days_passed += 1096;\n\n  if (file_year > 20)\n    days_passed -= 1;\n\n  days_passed += cum_days[file_month - 1];\n  if (years_since_leap == 0 && file_year != 20 && file_month > 2)\n    days_passed++;\n\n  days_passed += file_day - 1;\n\n  /* OK - have whole days.  Multiply -- then add in other parts.  */\n\n  tot_secs  = days_passed * 86400;\n  tot_secs += file_hour * 3600;\n  tot_secs += file_min * 60;\n  tot_secs += file_tsec * 2;\n  return (OS_Time) tot_secs;\n\n#elif defined (_WIN32) && !defined (RTX)\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  time_t ret = win32_filetime (h);\n  return (OS_Time) ret;\n\n#else\n  STRUCT_STAT statbuf;\n\n  if (FSTAT (fd, &statbuf) != 0) {\n     return (OS_Time) -1;\n  } else {\n#ifdef VMS\n     /* VMS has file versioning.  */\n     return (OS_Time) statbuf.st_ctime;\n#else\n     return (OS_Time) statbuf.st_mtime;\n#endif\n  }\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* This function returns the major version number of GCC being used.  */\n", "func_signal": "int\nget_gcc_version (void)", "code": "{\n#ifdef IN_RTS\n  return __GNUC__;\n#else\n  return (int) (version_string[0] - '0');\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return the number of bytes in the specified named file.  */\n", "func_signal": "long\n__gnat_named_file_length (char *name)", "code": "{\n  int ret;\n  STRUCT_STAT statbuf;\n\n  ret = __gnat_stat (name, &statbuf);\n  if (ret || !S_ISREG (statbuf.st_mode))\n    return 0;\n\n  /* st_size may be 32 bits, or 64 bits which is converted to long. We\n     don't return a useful value for files larger than 2 gigabytes in\n     either case. */\n\n  return (statbuf.st_size);\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Make newfd be the copy of oldfd, closing newfd first if necessary.\n   Return -1 if an error occurred.  */\n", "func_signal": "int\n__gnat_dup2 (int oldfd, int newfd)", "code": "{\n#if defined (__vxworks) && !defined (__RTP__)\n  /* Not supported on VxWorks 5.x, but supported on VxWorks 6.0 when using\n     RTPs.  */\n  return -1;\n#else\n  return dup2 (oldfd, newfd);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return the maximum file name length.  */\n", "func_signal": "int\n__gnat_get_maximum_file_name_length (void)", "code": "{\n#if defined (MSDOS)\n  return 8;\n#elif defined (VMS)\n  if (getenv (\"GNAT$EXTENDED_FILE_SPECIFICATIONS\"))\n    return -1;\n  else\n    return 39;\n#else\n  return -1;\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Translate a Unix syntax path spec into a VMS style (comma separated list of\n   directories.  */\n", "func_signal": "static char *\nto_host_path_spec (char *pathspec)", "code": "{\n  char *curr, *next, buff [MAXPATH];\n\n  if (pathspec == 0)\n    return pathspec;\n\n  /* Can't very well test for colons, since that's the Unix separator!  */\n  if (strchr (pathspec, ']') || strchr (pathspec, ','))\n    return pathspec;\n\n  new_host_pathspec[0] = 0;\n  curr = pathspec;\n\n  for (;;)\n    {\n      next = strchr (curr, ':');\n      if (next == 0)\n        next = strchr (curr, 0);\n\n      strncpy (buff, curr, next - curr);\n      buff[next - curr] = 0;\n\n      strncat (new_host_pathspec, __gnat_to_host_dir_spec (buff, 0), MAXPATH);\n      if (*next == 0)\n        break;\n      strncat (new_host_pathspec, \",\", MAXPATH);\n      curr = next + 1;\n    }\n\n  new_host_pathspec [MAXPATH - 1] = (char) 0;\n\n  return new_host_pathspec;\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Returns the same constant as GetDriveType but takes a pathname as\n   argument. */\n", "func_signal": "static UINT\nGetDriveTypeFromPath (TCHAR *wfullpath)", "code": "{\n  TCHAR wdrv[MAX_PATH];\n  TCHAR wpath[MAX_PATH];\n  TCHAR wfilename[MAX_PATH];\n  TCHAR wext[MAX_PATH];\n\n  _tsplitpath (wfullpath, wdrv, wpath, wfilename, wext);\n\n  if (_tcslen (wdrv) != 0)\n    {\n      /* we have a drive specified. */\n      _tcscat (wdrv, _T(\"\\\\\"));\n      return GetDriveType (wdrv);\n    }\n  else\n    {\n      /* No drive specified. */\n\n      /* Is this a relative path, if so get current drive type. */\n      if (wpath[0] != _T('\\\\') ||\n\t  (_tcslen (wpath) > 2 && wpath[0] == _T('\\\\') && wpath[1] != _T('\\\\')))\n\treturn GetDriveType (NULL);\n\n      UINT result = GetDriveType (wpath);\n\n      /* Cannot guess the drive type, is this \\\\.\\ ? */\n\n      if (result == DRIVE_NO_ROOT_DIR &&\n\t _tcslen (wpath) >= 4 && wpath[0] == _T('\\\\') && wpath[1] == _T('\\\\')\n\t  && wpath[2] == _T('.') && wpath[3] == _T('\\\\'))\n\t{\n\t  if (_tcslen (wpath) == 4)\n\t    _tcscat (wpath, wfilename);\n\n\t  LPTSTR p = &wpath[4];\n\t  LPTSTR b = _tcschr (p, _T('\\\\'));\n\n\t  if (b != NULL)\n\t    { /* logical drive \\\\.\\c\\dir\\file */\n\t      *b++ = _T(':');\n\t      *b++ = _T('\\\\');\n\t      *b = _T('\\0');\n\t    }\n\t  else\n\t    _tcscat (p, _T(\":\\\\\"));\n\n\t  return GetDriveType (p);\n\t}\n\n      return result;\n    }\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Translate a wildcard VMS file spec into a list of Unix file specs. First do\n   full translation and copy the results into a list (_init), then return them\n   one at a time (_next). If onlydirs set, only expand directory files.  */\n", "func_signal": "int\n__gnat_to_canonical_file_list_init (char *filespec, int onlydirs)", "code": "{\n  int len;\n  char buff [MAXPATH];\n\n  len = strlen (filespec);\n  strncpy (buff, filespec, MAXPATH);\n\n  /* Only look for directories */\n  if (onlydirs && !strstr (&buff [len-5], \"*.dir\"))\n    strncat (buff, \"*.dir\", MAXPATH);\n\n  buff [MAXPATH - 1] = (char) 0;\n\n  decc$from_vms (buff, wildcard_translate_unix, 1);\n\n  /* Remove the .dir extension.  */\n  if (onlydirs)\n    {\n      int i;\n      char *ext;\n\n      for (i = 0; i < new_canonical_filelist_in_use; i++)\n\t{\n\t  ext = strstr (new_canonical_filelist[i], \".dir\");\n\t  if (ext)\n\t    *ext = 0;\n\t}\n    }\n\n  return new_canonical_filelist_in_use;\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* defined (_WIN32) && !defined (RTX) */\n", "func_signal": "int\n__gnat_is_readable_file (char *name)", "code": "{\n#if defined (_WIN32) && !defined (RTX)\n  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n  GENERIC_MAPPING GenericMapping;\n\n  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n\n  if (__gnat_can_use_acl (wname))\n    {\n      ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n      GenericMapping.GenericRead = GENERIC_READ;\n\n      return __gnat_check_OWNER_ACL (wname, FILE_READ_DATA, GenericMapping);\n    }\n  else\n    return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n\n#else\n  int ret;\n  int mode;\n  STRUCT_STAT statbuf;\n\n  ret = STAT (name, &statbuf);\n  mode = statbuf.st_mode & S_IRUSR;\n  return (!ret && mode);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Create a temporary filename and put it in string pointed to by\n   TMP_FILENAME.  */\n", "func_signal": "void\n__gnat_tmp_name (char *tmp_filename)", "code": "{\n#ifdef RTX\n  /* Variable used to create a series of unique names */\n  static int counter = 0;\n\n  /* RTX in RTSS mode does not support tempnam nor tmpnam so we emulate it */\n  strcpy (tmp_filename, \"c:\\\\WINDOWS\\\\Temp\\\\gnat-\");\n  sprintf (&tmp_filename[strlen (tmp_filename)], \"%d\\0\", counter++);\n\n#elif defined (__MINGW32__)\n  {\n    char *pname;\n\n    /* tempnam tries to create a temporary file in directory pointed to by\n       TMP environment variable, in c:\\temp if TMP is not set, and in\n       directory specified by P_tmpdir in stdio.h if c:\\temp does not\n       exist. The filename will be created with the prefix \"gnat-\".  */\n\n    pname = (char *) tempnam (\"c:\\\\temp\", \"gnat-\");\n\n    /* if pname is NULL, the file was not created properly, the disk is full\n       or there is no more free temporary files */\n\n    if (pname == NULL)\n      *tmp_filename = '\\0';\n\n    /* If pname start with a back slash and not path information it means that\n       the filename is valid for the current working directory.  */\n\n    else if (pname[0] == '\\\\')\n      {\n\tstrcpy (tmp_filename, \".\\\\\");\n\tstrcat (tmp_filename, pname+1);\n      }\n    else\n      strcpy (tmp_filename, pname);\n\n    free (pname);\n  }\n\n#elif defined (linux) || defined (__FreeBSD__) || defined (__NetBSD__) \\\n  || defined (__OpenBSD__) || defined(__GLIBC__)\n#define MAX_SAFE_PATH 1000\n  char *tmpdir = getenv (\"TMPDIR\");\n\n  /* If tmpdir is longer than MAX_SAFE_PATH, revert to default value to avoid\n     a buffer overflow.  */\n  if (tmpdir == NULL || strlen (tmpdir) > MAX_SAFE_PATH)\n    strcpy (tmp_filename, \"/tmp/gnat-XXXXXX\");\n  else\n    sprintf (tmp_filename, \"%s/gnat-XXXXXX\", tmpdir);\n\n  close (mkstemp(tmp_filename));\n#else\n  tmpnam (tmp_filename);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Read the next entry in a directory.  The returned string points somewhere\n   in the buffer.  */\n", "func_signal": "char *\n__gnat_readdir (DIR *dirp, char *buffer, int *len)", "code": "{\n#if defined (RTX)\n  /* Not supported in RTX */\n\n  return NULL;\n\n#elif defined (__MINGW32__)\n  struct _tdirent *dirent = _treaddir ((_TDIR*)dirp);\n\n  if (dirent != NULL)\n    {\n      WS2SC (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n      *len = strlen (buffer);\n\n      return buffer;\n    }\n  else\n    return NULL;\n\n#elif defined (HAVE_READDIR_R)\n  /* If possible, try to use the thread-safe version.  */\n  if (readdir_r (dirp, buffer) != NULL)\n    {\n      *len = strlen (((struct dirent*) buffer)->d_name);\n      return ((struct dirent*) buffer)->d_name;\n    }\n  else\n    return NULL;\n\n#else\n  struct dirent *dirent = (struct dirent *) readdir (dirp);\n\n  if (dirent != NULL)\n    {\n      strcpy (buffer, dirent->d_name);\n      *len = strlen (buffer);\n      return buffer;\n    }\n  else\n    return NULL;\n\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Creates a symbolic link named NEWPATH which contains the string OLDPATH.\n   If NEWPATH exists it will NOT be overwritten.\n   For systems not supporting symbolic links, always return -1.  */\n", "func_signal": "int\n__gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,\n\t\tchar *newpath ATTRIBUTE_UNUSED)", "code": "{\n#if defined (MSDOS) || defined (_WIN32) || defined (__EMX__) \\\n  || defined (VMS) || defined(__vxworks) || defined (__nucleus__)\n  return -1;\n#else\n  return symlink (oldpath, newpath);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Translate a VMS syntax file specification into Unix syntax.\n   If no indicators of VMS syntax found, check if it's an uppercase\n   alphanumeric_ name and if so try it out as an environment\n   variable (logical name). If all else fails return the\n   input string.  */\n", "func_signal": "char *\n__gnat_to_canonical_file_spec (char *filespec)", "code": "{\n  char *filespec1;\n\n  strncpy (new_canonical_filespec, \"\", MAXPATH);\n\n  if (strchr (filespec, ']') || strchr (filespec, ':'))\n    {\n      char *tspec = (char *) __gnat_translate_vms (filespec);\n\n      if (tspec != (char *) -1)\n\tstrncpy (new_canonical_filespec, tspec, MAXPATH);\n    }\n  else if ((strlen (filespec) == strspn (filespec,\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"))\n\t&& (filespec1 = getenv (filespec)))\n    {\n      char *tspec = (char *) __gnat_translate_vms (filespec1);\n\n      if (tspec != (char *) -1)\n\tstrncpy (new_canonical_filespec, tspec, MAXPATH);\n    }\n  else\n    {\n      strncpy (new_canonical_filespec, filespec, MAXPATH);\n    }\n\n  new_canonical_filespec [MAXPATH - 1] = (char) 0;\n\n  return new_canonical_filespec;\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Delete a file.  */\n", "func_signal": "int\n__gnat_unlink (char *path)", "code": "{\n#if defined (__MINGW32__) && ! defined (__vxworks) && ! defined (IS_CROSS)\n  {\n    TCHAR wpath[GNAT_MAX_PATH_LEN];\n\n    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n    return _tunlink (wpath);\n  }\n#else\n  return unlink (path);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/*  Open directory and returns a DIR pointer.  */\n", "func_signal": "DIR* __gnat_opendir (char *name)", "code": "{\n#if defined (RTX)\n  /* Not supported in RTX */\n\n  return NULL;\n\n#elif defined (__MINGW32__)\n  TCHAR wname[GNAT_MAX_PATH_LEN];\n\n  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n  return (DIR*)_topendir (wname);\n\n#else\n  return opendir (name);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Close a directory entry.  */\n", "func_signal": "int __gnat_closedir (DIR *dirp)", "code": "{\n#if defined (RTX)\n  /* Not supported in RTX */\n\n  return 0;\n\n#elif defined (__MINGW32__)\n  return _tclosedir ((_TDIR*)dirp);\n\n#else\n  return closedir (dirp);\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/* Return a GNAT time stamp given a file name.  */\n", "func_signal": "OS_Time\n__gnat_file_time_name (char *name)", "code": "{\n\n#if defined (__EMX__) || defined (MSDOS)\n  int fd = open (name, O_RDONLY | O_BINARY);\n  time_t ret = __gnat_file_time_fd (fd);\n  close (fd);\n  return (OS_Time)ret;\n\n#elif defined (_WIN32) && !defined (RTX)\n  time_t ret = -1;\n  TCHAR wname[GNAT_MAX_PATH_LEN];\n\n  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n\n  HANDLE h = CreateFile\n    (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n\n  if (h != INVALID_HANDLE_VALUE)\n    {\n      ret = win32_filetime (h);\n      CloseHandle (h);\n    }\n  return (OS_Time) ret;\n#else\n  STRUCT_STAT statbuf;\n  if (__gnat_stat (name, &statbuf) != 0) {\n     return (OS_Time)-1;\n  } else {\n#ifdef VMS\n     /* VMS has file versioning.  */\n     return (OS_Time)statbuf.st_ctime;\n#else\n     return (OS_Time)statbuf.st_mtime;\n#endif\n  }\n#endif\n}", "path": "src\\ada\\adaint.c", "repo_name": "eocallaghan/GNAT-LLVM", "stars": 12, "license": "gpl-2.0", "language": "c", "size": 8748}
{"docstring": "/*\n * sys_execve() executes a new program.\n */\n", "func_signal": "asmlinkage int sys_execve(char __user *name, char __user * __user *argv, char __user * __user *envp)", "code": "{\n\tint error;\n\tchar * filename;\n\tstruct pt_regs *regs = (struct pt_regs *) &name;\n\n\tlock_kernel();\n\tfilename = getname(name);\n\terror = PTR_ERR(filename);\n\tif (IS_ERR(filename))\n\t\tgoto out;\n\terror = do_execve(filename, argv, envp, regs);\n\tputname(filename);\nout:\n\tunlock_kernel();\n\treturn error;\n}", "path": "arch\\m68k\\kernel\\process.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/* Arch code calls this early on, or if not, just before other parsing. */\n", "func_signal": "void __init parse_early_param(void)", "code": "{\n\tstatic __initdata int done = 0;\n\tstatic __initdata char tmp_cmdline[COMMAND_LINE_SIZE];\n\n\tif (done)\n\t\treturn;\n\n\t/* All fall through to do_early_param. */\n\tstrlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);\n\tparse_args(\"early options\", tmp_cmdline, NULL, 0, do_early_param);\n\tdone = 1;\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/* Called by boot processor to activate the rest. */\n", "func_signal": "static void __init smp_init(void)", "code": "{\n\tunsigned int cpu;\n\n\t/* FIXME: This should be done in userspace --RR */\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu);\n\t}\n\n\t/* Any cleanup work */\n\tprintk(KERN_INFO \"Brought up %ld CPUs\\n\", (long)num_online_cpus());\n\tsmp_cpus_done(max_cpus);\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * IQ80331 PCI.\n */\n", "func_signal": "static int __init\niq80331_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)", "code": "{\n\tint irq;\n\n\tif (slot == 1 && pin == 1) {\n\t\t/* PCI-X Slot INTA */\n\t\tirq = IRQ_IOP33X_XINT1;\n\t} else if (slot == 1 && pin == 2) {\n\t\t/* PCI-X Slot INTB */\n\t\tirq = IRQ_IOP33X_XINT2;\n\t} else if (slot == 1 && pin == 3) {\n\t\t/* PCI-X Slot INTC */\n\t\tirq = IRQ_IOP33X_XINT3;\n\t} else if (slot == 1 && pin == 4) {\n\t\t/* PCI-X Slot INTD */\n\t\tirq = IRQ_IOP33X_XINT0;\n\t} else if (slot == 2) {\n\t\t/* GigE */\n\t\tirq = IRQ_IOP33X_XINT2;\n\t} else {\n\t\tprintk(KERN_ERR \"iq80331_pci_map_irq() called for unknown \"\n\t\t\t\"device PCI:%d:%d:%d\\n\", dev->bus->number,\n\t\t\tPCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));\n\t\tirq = -1;\n\t}\n\n\treturn irq;\n}", "path": "arch\\arm\\mach-iop33x\\iq80331.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * We need to store the untouched command line for future reference.\n * We also need to store the touched command line since the parameter\n * parsing is performed in place, and we should allow a component to\n * store reference of name/value for future reference.\n */\n", "func_signal": "static void __init setup_command_line(char *command_line)", "code": "{\n\tsaved_command_line = alloc_bootmem(strlen (boot_command_line)+1);\n\tstatic_command_line = alloc_bootmem(strlen (command_line)+1);\n\tstrcpy (saved_command_line, boot_command_line);\n\tstrcpy (static_command_line, command_line);\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n *\tActivate the first processor.\n */\n", "func_signal": "static void __init boot_cpu_init(void)", "code": "{\n\tint cpu = smp_processor_id();\n\t/* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */\n\tcpu_set(cpu, cpu_online_map);\n\tcpu_set(cpu, cpu_present_map);\n\tcpu_set(cpu, cpu_possible_map);\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * fill in the user structure for a core dump..\n */\n", "func_signal": "void dump_thread(struct pt_regs * regs, struct user * dump)", "code": "{\n\tstruct switch_stack *sw;\n\n/* changed the size calculations - should hopefully work better. lbt */\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = rdusp() & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk +\n\t\t\t\t\t  (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\n\tif (dump->start_stack < TASK_SIZE)\n\t\tdump->u_ssize = ((unsigned long) (TASK_SIZE - dump->start_stack)) >> PAGE_SHIFT;\n\n\tdump->u_ar0 = (struct user_regs_struct *)((int)&dump->regs - (int)dump);\n\tsw = ((struct switch_stack *)regs) - 1;\n\tdump->regs.d1 = regs->d1;\n\tdump->regs.d2 = regs->d2;\n\tdump->regs.d3 = regs->d3;\n\tdump->regs.d4 = regs->d4;\n\tdump->regs.d5 = regs->d5;\n\tdump->regs.d6 = sw->d6;\n\tdump->regs.d7 = sw->d7;\n\tdump->regs.a0 = regs->a0;\n\tdump->regs.a1 = regs->a1;\n\tdump->regs.a2 = regs->a2;\n\tdump->regs.a3 = sw->a3;\n\tdump->regs.a4 = sw->a4;\n\tdump->regs.a5 = sw->a5;\n\tdump->regs.a6 = sw->a6;\n\tdump->regs.d0 = regs->d0;\n\tdump->regs.orig_d0 = regs->orig_d0;\n\tdump->regs.stkadj = regs->stkadj;\n\tdump->regs.sr = regs->sr;\n\tdump->regs.pc = regs->pc;\n\tdump->regs.fmtvec = (regs->format << 12) | regs->vector;\n\t/* dump floating point stuff */\n\tdump->u_fpvalid = dump_fpu (regs, &dump->m68kfp);\n}", "path": "arch\\m68k\\kernel\\process.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * XXX: This part is probably common to i386 and x86-64. Don't create a common\n * file for now, do that when implementing x86-64 support.\n */\n", "func_signal": "static int __init __setup_host_supports_tls(void)", "code": "{\n\tcheck_host_supports_tls(&host_supports_tls, &host_gdt_entry_tls_min);\n\tif (host_supports_tls) {\n\t\tprintk(KERN_INFO \"Host TLS support detected\\n\");\n\t\tprintk(KERN_INFO \"Detected host type: \");\n\t\tswitch (host_gdt_entry_tls_min) {\n\t\t\tcase GDT_ENTRY_TLS_MIN_I386:\n\t\t\t\tprintk(\"i386\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GDT_ENTRY_TLS_MIN_X86_64:\n\t\t\t\tprintk(\"x86_64\\n\");\n\t\t\t\tbreak;\n\t\t}\n\t} else\n\t\tprintk(KERN_ERR \"  Host TLS support NOT detected! \"\n\t\t\t\t\"TLS support inside UML will not work\\n\");\n\treturn 0;\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * sys_get_thread_area: get a yet unused TLS descriptor index.\n * XXX: Consider leaving one free slot for glibc usage at first place. This must\n * be done here (and by changing GDT_ENTRY_TLS_* macros) and nowhere else.\n *\n * Also, this must be tested when compiling in SKAS mode with dynamic linking\n * and running against NPTL.\n */\n", "func_signal": "static int get_free_idx(struct task_struct* task)", "code": "{\n\tstruct thread_struct *t = &task->thread;\n\tint idx;\n\n\tif (!t->arch.tls_array)\n\t\treturn GDT_ENTRY_TLS_MIN;\n\n\tfor (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)\n\t\tif (!t->arch.tls_array[idx].present)\n\t\t\treturn idx + GDT_ENTRY_TLS_MIN;\n\treturn -ESRCH;\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * Perform set_thread_area on behalf of the traced child.\n * Note: error handling is not done on the deferred load, and this differ from\n * i386. However the only possible error are caused by bugs.\n */\n", "func_signal": "int ptrace_set_thread_area(struct task_struct *child, int idx,\n\t\tstruct user_desc __user *user_desc)", "code": "{\n\tstruct user_desc info;\n\n\tif (!host_supports_tls)\n\t\treturn -EIO;\n\n\tif (copy_from_user(&info, user_desc, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn set_tls_entry(child, &info, idx, 0);\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * On a newly forked process, the TLS descriptors haven't yet been flushed. So\n * we mark them as such and the first switch_to will do the job.\n */\n", "func_signal": "void clear_flushed_tls(struct task_struct *task)", "code": "{\n\tint i;\n\n\tfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\n\t\tstruct uml_tls_struct* curr =\n\t\t\t&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\n\n\t\t/*\n\t\t * Still correct to do this, if it wasn't present on the host it\n\t\t * will remain as flushed as it was.\n\t\t */\n\t\tif (!curr->present)\n\t\t\tcontinue;\n\n\t\tcurr->flushed = 0;\n\t}\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * Verify if we need to do a flush for the new process, i.e. if there are any\n * present desc's, only if they haven't been flushed.\n */\n", "func_signal": "static inline int needs_TLS_update(struct task_struct *task)", "code": "{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = GDT_ENTRY_TLS_MIN; i < GDT_ENTRY_TLS_MAX; i++) {\n\t\tstruct uml_tls_struct* curr =\n\t\t\t&task->thread.arch.tls_array[i - GDT_ENTRY_TLS_MIN];\n\n\t\t/*\n\t\t * Can't test curr->present, we may need to clear a descriptor\n\t\t * which had a value.\n\t\t */\n\t\tif (curr->flushed)\n\t\t\tcontinue;\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * We need to finalize in a non-__init function or else race conditions\n * between the root thread and the init thread may cause start_kernel to\n * be reaped by free_initmem before the root thread has proceeded to\n * cpu_idle.\n *\n * gcc-3.4 accidentally inlines this function, so use noinline.\n */\n", "func_signal": "static void noinline __init_refok rest_init(void)\n\t__releases(kernel_lock)", "code": "{\n\tint pid;\n\n\tkernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);\n\tnuma_default_policy();\n\tpid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n\tkthreadd_task = find_task_by_pid(pid);\n\tunlock_kernel();\n\n\t/*\n\t * The boot idle thread must execute schedule()\n\t * at least once to get things moving:\n\t */\n\tinit_idle_bootup_task(current);\n\tpreempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n\n\t/* Call into cpu_idle with preempt disabled */\n\tcpu_idle();\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * The idle loop on an m68k..\n */\n", "func_signal": "static void default_idle(void)", "code": "{\n\tif (!need_resched())\n#if defined(MACH_ATARI_ONLY) && !defined(CONFIG_HADES)\n\t\t/* block out HSYNC on the atari (falcon) */\n\t\t__asm__(\"stop #0x2200\" : : : \"cc\");\n#else\n\t\t__asm__(\"stop #0x2000\" : : : \"cc\");\n#endif\n}", "path": "arch\\m68k\\kernel\\process.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/* XXX: use do_get_thread_area to read the host value? I'm not at all sure! */\n", "func_signal": "static int get_tls_entry(struct task_struct* task, struct user_desc *info, int idx)", "code": "{\n\tstruct thread_struct *t = &task->thread;\n\n\tif (!t->arch.tls_array)\n\t\tgoto clear;\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tif (!t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].present)\n\t\tgoto clear;\n\n\t*info = t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].tls;\n\nout:\n\t/*\n\t * Temporary debugging check, to make sure that things have been\n\t * flushed. This could be triggered if load_TLS() failed.\n\t */\n\tif (unlikely(task == current &&\n\t\t     !t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed)) {\n\t\tprintk(KERN_ERR \"get_tls_entry: task with pid %d got here \"\n\t\t\t\t\"without flushed TLS.\", current->pid);\n\t}\n\n\treturn 0;\nclear:\n\t/*\n\t * When the TLS entry has not been set, the values read to user in the\n\t * tls_array are 0 (because it's cleared at boot, see\n\t * arch/i386/kernel/head.S:cpu_gdt_table). Emulate that.\n\t */\n\tclear_user_desc(info);\n\tinfo->entry_number = idx;\n\tgoto out;\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * Unknown boot options get handed to init, unless they look like\n * failed parameters\n */\n", "func_signal": "static int __init unknown_bootoption(char *param, char *val)", "code": "{\n\t/* Change NUL term back to \"=\", to make \"param\" the whole string. */\n\tif (val) {\n\t\t/* param=val or param=\"val\"? */\n\t\tif (val == param+strlen(param)+1)\n\t\t\tval[-1] = '=';\n\t\telse if (val == param+strlen(param)+2) {\n\t\t\tval[-2] = '=';\n\t\t\tmemmove(val-1, val, strlen(val)+1);\n\t\t\tval--;\n\t\t} else\n\t\t\tBUG();\n\t}\n\n\t/* Handle obsolete-style parameters */\n\tif (obsolete_checksetup(param))\n\t\treturn 0;\n\n\t/*\n\t * Preemptive maintenance for \"why didn't my misspelled command\n\t * line work?\"\n\t */\n\tif (strchr(param, '.') && (!val || strchr(param, '.') < val)) {\n\t\tprintk(KERN_ERR \"Unknown boot option `%s': ignoring\\n\", param);\n\t\treturn 0;\n\t}\n\n\tif (panic_later)\n\t\treturn 0;\n\n\tif (val) {\n\t\t/* Environment option */\n\t\tunsigned int i;\n\t\tfor (i = 0; envp_init[i]; i++) {\n\t\t\tif (i == MAX_INIT_ENVS) {\n\t\t\t\tpanic_later = \"Too many boot env vars at `%s'\";\n\t\t\t\tpanic_param = param;\n\t\t\t}\n\t\t\tif (!strncmp(param, envp_init[i], val - param))\n\t\t\t\tbreak;\n\t\t}\n\t\tenvp_init[i] = param;\n\t} else {\n\t\t/* Command line option */\n\t\tunsigned int i;\n\t\tfor (i = 0; argv_init[i]; i++) {\n\t\t\tif (i == MAX_INIT_ARGS) {\n\t\t\t\tpanic_later = \"Too many boot init vars at `%s'\";\n\t\t\t\tpanic_param = param;\n\t\t\t}\n\t\t}\n\t\targv_init[i] = param;\n\t}\n\treturn 0;\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/* Check for early params. */\n", "func_signal": "static int __init do_early_param(char *param, char *val)", "code": "{\n\tstruct obs_kernel_param *p;\n\n\tfor (p = __setup_start; p < __setup_end; p++) {\n\t\tif ((p->early && strcmp(param, p->str) == 0) ||\n\t\t    (strcmp(param, \"console\") == 0 &&\n\t\t     strcmp(p->str, \"earlycon\") == 0)\n\t\t) {\n\t\t\tif (p->setup_func(val) != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Malformed early option '%s'\\n\", param);\n\t\t}\n\t}\n\t/* We accept everything at this stage. */\n\treturn 0;\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/* This is a non __init function. Force it to be noinline otherwise gcc\n * makes it inline to init() and it becomes part of init.text section\n */\n", "func_signal": "static int noinline init_post(void)", "code": "{\n\tfree_initmem();\n\tunlock_kernel();\n\tmark_rodata_ro();\n\tsystem_state = SYSTEM_RUNNING;\n\tnuma_default_policy();\n\n\tif (sys_open((const char __user *) \"/dev/console\", O_RDWR, 0) < 0)\n\t\tprintk(KERN_WARNING \"Warning: unable to open an initial console.\\n\");\n\n\t(void) sys_dup(0);\n\t(void) sys_dup(0);\n\n\tif (ramdisk_execute_command) {\n\t\trun_init_process(ramdisk_execute_command);\n\t\tprintk(KERN_WARNING \"Failed to execute %s\\n\",\n\t\t\t\tramdisk_execute_command);\n\t}\n\n\t/*\n\t * We try each of these until one succeeds.\n\t *\n\t * The Bourne shell can be used instead of init if we are\n\t * trying to recover a really broken machine.\n\t */\n\tif (execute_command) {\n\t\trun_init_process(execute_command);\n\t\tprintk(KERN_WARNING \"Failed to execute %s.  Attempting \"\n\t\t\t\t\t\"defaults...\\n\", execute_command);\n\t}\n\trun_init_process(\"/sbin/init\");\n\trun_init_process(\"/etc/init\");\n\trun_init_process(\"/bin/init\");\n\trun_init_process(\"/bin/sh\");\n\n\tpanic(\"No init found.  Try passing init= option to kernel.\");\n}", "path": "init\\main.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * Create a kernel thread\n */\n", "func_signal": "int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)", "code": "{\n\tint pid;\n\tmm_segment_t fs;\n\n\tfs = get_fs();\n\tset_fs (KERNEL_DS);\n\n\t{\n\tregister long retval __asm__ (\"d0\");\n\tregister long clone_arg __asm__ (\"d1\") = flags | CLONE_VM | CLONE_UNTRACED;\n\n\tretval = __NR_clone;\n\t__asm__ __volatile__\n\t  (\"clrl %%d2\\n\\t\"\n\t   \"trap #0\\n\\t\"\t\t/* Linux/m68k system call */\n\t   \"tstl %0\\n\\t\"\t\t/* child or parent */\n\t   \"jne 1f\\n\\t\"\t\t\t/* parent - jump */\n\t   \"lea %%sp@(%c7),%6\\n\\t\"\t/* reload current */\n\t   \"movel %6@,%6\\n\\t\"\n\t   \"movel %3,%%sp@-\\n\\t\"\t/* push argument */\n\t   \"jsr %4@\\n\\t\"\t\t/* call fn */\n\t   \"movel %0,%%d1\\n\\t\"\t\t/* pass exit value */\n\t   \"movel %2,%%d0\\n\\t\"\t\t/* exit */\n\t   \"trap #0\\n\"\n\t   \"1:\"\n\t   : \"+d\" (retval)\n\t   : \"i\" (__NR_clone), \"i\" (__NR_exit),\n\t     \"r\" (arg), \"a\" (fn), \"d\" (clone_arg), \"r\" (current),\n\t     \"i\" (-THREAD_SIZE)\n\t   : \"d2\");\n\n\tpid = retval;\n\t}\n\n\tset_fs (fs);\n\treturn pid;\n}", "path": "arch\\m68k\\kernel\\process.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n * In SKAS0 mode, currently, multiple guest threads sharing the same ->mm have a\n * common host process. So this is needed in SKAS0 too.\n *\n * However, if each thread had a different host process (and this was discussed\n * for SMP support) this won't be needed.\n *\n * And this will not need be used when (and if) we'll add support to the host\n * SKAS patch.\n */\n", "func_signal": "int arch_switch_tls(struct task_struct *from, struct task_struct *to)", "code": "{\n\tif (!host_supports_tls)\n\t\treturn 0;\n\n\t/*\n\t * We have no need whatsoever to switch TLS for kernel threads; beyond\n\t * that, that would also result in us calling os_set_thread_area with\n\t * userspace_pid[cpu] == 0, which gives an error.\n\t */\n\tif (likely(to->mm))\n\t\treturn load_TLS(O_FORCE, to);\n\n\treturn 0;\n}", "path": "arch\\um\\sys-i386\\tls.c", "repo_name": "sumitn/linux-2.6.24", "stars": 9, "license": "other", "language": "c", "size": 66422}
{"docstring": "/*\n================\nCG_ParseServerinfo\n\nThis is called explicitly when the gamestate is first received,\nand whenever the server updates any serverinfo flagged cvars\n================\n*/\n", "func_signal": "void CG_ParseServerinfo( void )", "code": "{\n\tconst char\t*info;\n\tchar\t*mapname;\n\n\tinfo = CG_ConfigString( CS_SERVERINFO );\n\tcgs.gametype = atoi( Info_ValueForKey( info, \"g_gametype\" ) );\n\ttrap_Cvar_Set(\"g_gametype\", va(\"%i\", cgs.gametype));\n\tcgs.dmflags = atoi( Info_ValueForKey( info, \"dmflags\" ) );\n\tcgs.teamflags = atoi( Info_ValueForKey( info, \"teamflags\" ) );\n\tcgs.fraglimit = atoi( Info_ValueForKey( info, \"fraglimit\" ) );\n\tcgs.capturelimit = atoi( Info_ValueForKey( info, \"capturelimit\" ) );\n\tcgs.timelimit = atoi( Info_ValueForKey( info, \"timelimit\" ) );\n\tcgs.maxclients = atoi( Info_ValueForKey( info, \"sv_maxclients\" ) );\n\tmapname = Info_ValueForKey( info, \"mapname\" );\n\tCom_sprintf( cgs.mapname, sizeof( cgs.mapname ), \"maps/%s.bsp\", mapname );\n\tQ_strncpyz( cgs.redTeam, Info_ValueForKey( info, \"g_redTeam\" ), sizeof(cgs.redTeam) );\n\ttrap_Cvar_Set(\"g_redTeam\", cgs.redTeam);\n\tQ_strncpyz( cgs.blueTeam, Info_ValueForKey( info, \"g_blueTeam\" ), sizeof(cgs.blueTeam) );\n\ttrap_Cvar_Set(\"g_blueTeam\", cgs.blueTeam);\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=================\nCG_RemoveChatEscapeChar\n=================\n*/\n", "func_signal": "static void CG_RemoveChatEscapeChar( char *text )", "code": "{\n\tint i, l;\n\n\tl = 0;\n\tfor ( i = 0; text[i]; i++ ) {\n\t\tif (text[i] == '\\x19')\n\t\t\tcontinue;\n\t\ttext[l++] = text[i];\n\t}\n\ttext[l] = '\\0';\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=====================\nCG_PlayBufferedVoieChats\n=====================\n*/\n", "func_signal": "void CG_PlayBufferedVoiceChats( void )", "code": "{\n#ifdef MISSIONPACK\n\tif ( cg.voiceChatTime < cg.time ) {\n\t\tif (cg.voiceChatBufferOut != cg.voiceChatBufferIn && voiceChatBuffer[cg.voiceChatBufferOut].snd) {\n\t\t\t//\n\t\t\tCG_PlayVoiceChat(&voiceChatBuffer[cg.voiceChatBufferOut]);\n\t\t\t//\n\t\t\tcg.voiceChatBufferOut = (cg.voiceChatBufferOut + 1) % MAX_VOICECHATBUFFER;\n\t\t\tcg.voiceChatTime = cg.time + 1000;\n\t\t}\n\t}\n#endif\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n================\nCG_SetConfigValues\n\nCalled on load to set the initial values from configure strings\n================\n*/\n", "func_signal": "void CG_SetConfigValues( void )", "code": "{\n\tconst char *s;\n\n\tcgs.scores1 = atoi( CG_ConfigString( CS_SCORES1 ) );\n\tcgs.scores2 = atoi( CG_ConfigString( CS_SCORES2 ) );\n\tcgs.levelStartTime = atoi( CG_ConfigString( CS_LEVEL_START_TIME ) );\n\tif( cgs.gametype == GT_CTF ) {\n\t\ts = CG_ConfigString( CS_FLAGSTATUS );\n\t\tcgs.redflag = s[0] - '0';\n\t\tcgs.blueflag = s[1] - '0';\n\t}\n#ifdef MISSIONPACK\n\telse if( cgs.gametype == GT_1FCTF ) {\n\t\ts = CG_ConfigString( CS_FLAGSTATUS );\n\t\tcgs.flagStatus = s[0] - '0';\n\t}\n#endif\n\tcg.warmup = atoi( CG_ConfigString( CS_WARMUP ) );\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n================\nSV_Status_f\n================\n*/\n", "func_signal": "static void SV_Status_f( void )", "code": "{\n\tint\t\t\ti, j, l;\n\tclient_t\t*cl;\n\tplayerState_t\t*ps;\n\tconst char\t\t*s;\n\tint\t\t\tping;\n\n\t// make sure server is running\n\tif ( !com_sv_running->integer ) {\n\t\tCom_Printf( \"Server is not running.\\n\" );\n\t\treturn;\n\t}\n\n\tCom_Printf (\"map: %s\\n\", sv_mapname->string );\n\n\tCom_Printf (\"num score ping name            lastmsg address               qport rate\\n\");\n\tCom_Printf (\"--- ----- ---- --------------- ------- --------------------- ----- -----\\n\");\n\tfor (i=0,cl=svs.clients ; i < sv_maxclients->integer ; i++,cl++)\n\t{\n\t\tif (!cl->state)\n\t\t\tcontinue;\n\t\tCom_Printf (\"%3i \", i);\n\t\tps = SV_GameClientNum( i );\n\t\tCom_Printf (\"%5i \", ps->persistant[PERS_SCORE]);\n\n\t\tif (cl->state == CS_CONNECTED)\n\t\t\tCom_Printf (\"CNCT \");\n\t\telse if (cl->state == CS_ZOMBIE)\n\t\t\tCom_Printf (\"ZMBI \");\n\t\telse\n\t\t{\n\t\t\tping = cl->ping < 9999 ? cl->ping : 9999;\n\t\t\tCom_Printf (\"%4i \", ping);\n\t\t}\n\n\t\tCom_Printf (\"%s\", cl->name);\n    // TTimo adding a ^7 to reset the color\n    // NOTE: colored names in status breaks the padding (WONTFIX)\n    Com_Printf (\"^7\");\n\t\tl = 16 - strlen(cl->name);\n\t\tfor (j=0 ; j<l ; j++)\n\t\t\tCom_Printf (\" \");\n\n\t\tCom_Printf (\"%7i \", svs.time - cl->lastPacketTime );\n\n\t\ts = NET_AdrToString( cl->netchan.remoteAddress );\n\t\tCom_Printf (\"%s\", s);\n\t\tl = 22 - strlen(s);\n\t\tfor (j=0 ; j<l ; j++)\n\t\t\tCom_Printf (\" \");\n\t\t\n\t\tCom_Printf (\"%5i\", cl->netchan.qport);\n\n\t\tCom_Printf (\" %5i\", cl->rate);\n\n\t\tCom_Printf (\"\\n\");\n\t}\n\tCom_Printf (\"\\n\");\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n===============\nCG_MapRestart\n\nThe server has issued a map_restart, so the next snapshot\nis completely new and should not be interpolated to.\n\nA tournement restart will clear everything, but doesn't\nrequire a reload of all the media\n===============\n*/\n", "func_signal": "static void CG_MapRestart( void )", "code": "{\n\tif ( cg_showmiss.integer ) {\n\t\tCG_Printf( \"CG_MapRestart\\n\" );\n\t}\n\n\tCG_InitLocalEntities();\n\tCG_InitMarkPolys();\n\tCG_ClearParticles ();\n\n\t// make sure the \"3 frags left\" warnings play again\n\tcg.fraglimitWarnings = 0;\n\n\tcg.timelimitWarnings = 0;\n\n\tcg.intermissionStarted = qfalse;\n\n\tcgs.voteTime = 0;\n\n\tcg.mapRestart = qtrue;\n\n\tCG_StartMusic();\n\n\ttrap_S_ClearLoopingSounds(qtrue);\n\n\t// we really should clear more parts of cg here and stop sounds\n\n\t// play the \"fight\" sound if this is a restart without warmup\n\tif ( cg.warmup == 0 /* && cgs.gametype == GT_TOURNAMENT */) {\n\t\ttrap_S_StartLocalSound( cgs.media.countFightSound, CHAN_ANNOUNCER );\n\t\tCG_CenterPrint( \"FIGHT!\", 120, GIANTCHAR_WIDTH*2 );\n\t}\n#ifdef MISSIONPACK\n\tif (cg_singlePlayerActive.integer) {\n\t\ttrap_Cvar_Set(\"ui_matchStartTime\", va(\"%i\", cg.time));\n\t\tif (cg_recordSPDemo.integer && cg_recordSPDemoName.string && *cg_recordSPDemoName.string) {\n\t\t\ttrap_SendConsoleCommand(va(\"set g_synchronousclients 1 ; record %s \\n\", cg_recordSPDemoName.string));\n\t\t}\n\t}\n#endif\n\ttrap_Cvar_Set(\"cg_thirdPerson\", \"0\");\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n===========\nSV_Serverinfo_f\n\nExamine the serverinfo string\n===========\n*/\n", "func_signal": "static void SV_Serverinfo_f( void )", "code": "{\n\tCom_Printf (\"Server info settings:\\n\");\n\tInfo_Print ( Cvar_InfoString( CVAR_SERVERINFO ) );\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n================\nCG_ConfigStringModified\n\n================\n*/\n", "func_signal": "static void CG_ConfigStringModified( void )", "code": "{\n\tconst char\t*str;\n\tint\t\tnum;\n\n\tnum = atoi( CG_Argv( 1 ) );\n\n\t// get the gamestate from the client system, which will have the\n\t// new configstring already integrated\n\ttrap_GetGameState( &cgs.gameState );\n\n\t// look up the individual string that was modified\n\tstr = CG_ConfigString( num );\n\n\t// do something with it if necessary\n\tif ( num == CS_MUSIC ) {\n\t\tCG_StartMusic();\n\t} else if ( num == CS_SERVERINFO ) {\n\t\tCG_ParseServerinfo();\n\t} else if ( num == CS_WARMUP ) {\n\t\tCG_ParseWarmup();\n\t} else if ( num == CS_SCORES1 ) {\n\t\tcgs.scores1 = atoi( str );\n\t} else if ( num == CS_SCORES2 ) {\n\t\tcgs.scores2 = atoi( str );\n\t} else if ( num == CS_LEVEL_START_TIME ) {\n\t\tcgs.levelStartTime = atoi( str );\n\t} else if ( num == CS_VOTE_TIME ) {\n\t\tcgs.voteTime = atoi( str );\n\t\tcgs.voteModified = qtrue;\n\t} else if ( num == CS_VOTE_YES ) {\n\t\tcgs.voteYes = atoi( str );\n\t\tcgs.voteModified = qtrue;\n\t} else if ( num == CS_VOTE_NO ) {\n\t\tcgs.voteNo = atoi( str );\n\t\tcgs.voteModified = qtrue;\n\t} else if ( num == CS_VOTE_STRING ) {\n\t\tQ_strncpyz( cgs.voteString, str, sizeof( cgs.voteString ) );\n#ifdef MISSIONPACK\n\t\ttrap_S_StartLocalSound( cgs.media.voteNow, CHAN_ANNOUNCER );\n#endif //MISSIONPACK\n\t} else if ( num >= CS_TEAMVOTE_TIME && num <= CS_TEAMVOTE_TIME + 1) {\n\t\tcgs.teamVoteTime[num-CS_TEAMVOTE_TIME] = atoi( str );\n\t\tcgs.teamVoteModified[num-CS_TEAMVOTE_TIME] = qtrue;\n\t} else if ( num >= CS_TEAMVOTE_YES && num <= CS_TEAMVOTE_YES + 1) {\n\t\tcgs.teamVoteYes[num-CS_TEAMVOTE_YES] = atoi( str );\n\t\tcgs.teamVoteModified[num-CS_TEAMVOTE_YES] = qtrue;\n\t} else if ( num >= CS_TEAMVOTE_NO && num <= CS_TEAMVOTE_NO + 1) {\n\t\tcgs.teamVoteNo[num-CS_TEAMVOTE_NO] = atoi( str );\n\t\tcgs.teamVoteModified[num-CS_TEAMVOTE_NO] = qtrue;\n\t} else if ( num >= CS_TEAMVOTE_STRING && num <= CS_TEAMVOTE_STRING + 1) {\n\t\tQ_strncpyz( cgs.teamVoteString[num-CS_TEAMVOTE_STRING], str, sizeof( cgs.teamVoteString ) );\n#ifdef MISSIONPACK\n\t\ttrap_S_StartLocalSound( cgs.media.voteNow, CHAN_ANNOUNCER );\n#endif\n\t} else if ( num == CS_INTERMISSION ) {\n\t\tcg.intermissionStarted = atoi( str );\n\t} else if ( num >= CS_MODELS && num < CS_MODELS+MAX_MODELS ) {\n\t\tcgs.gameModels[ num-CS_MODELS ] = trap_R_RegisterModel( str );\n\t} else if ( num >= CS_SOUNDS && num < CS_SOUNDS+MAX_MODELS ) {\n\t\tif ( str[0] != '*' ) {\t// player specific sounds don't register here\n\t\t\tcgs.gameSounds[ num-CS_SOUNDS] = trap_S_RegisterSound( str, qfalse );\n\t\t}\n\t} else if ( num >= CS_PLAYERS && num < CS_PLAYERS+MAX_CLIENTS ) {\n\t\tCG_NewClientInfo( num - CS_PLAYERS );\n\t\tCG_BuildSpectatorString();\n\t} else if ( num == CS_FLAGSTATUS ) {\n\t\tif( cgs.gametype == GT_CTF ) {\n\t\t\t// format is rb where its red/blue, 0 is at base, 1 is taken, 2 is dropped\n\t\t\tcgs.redflag = str[0] - '0';\n\t\t\tcgs.blueflag = str[1] - '0';\n\t\t}\n#ifdef MISSIONPACK\n\t\telse if( cgs.gametype == GT_1FCTF ) {\n\t\t\tcgs.flagStatus = str[0] - '0';\n\t\t}\n#endif\n\t}\n\telse if ( num == CS_SHADERSTATE ) {\n\t\tCG_ShaderStateChanged();\n\t}\n\t\t\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=====================\nCG_ShaderStateChanged\n=====================\n*/\n", "func_signal": "void CG_ShaderStateChanged(void)", "code": "{\n\tchar originalShader[MAX_QPATH];\n\tchar newShader[MAX_QPATH];\n\tchar timeOffset[16];\n\tconst char *o;\n\tchar *n,*t;\n\n\to = CG_ConfigString( CS_SHADERSTATE );\n\twhile (o && *o) {\n\t\tn = strstr(o, \"=\");\n\t\tif (n && *n) {\n\t\t\tstrncpy(originalShader, o, n-o);\n\t\t\toriginalShader[n-o] = 0;\n\t\t\tn++;\n\t\t\tt = strstr(n, \":\");\n\t\t\tif (t && *t) {\n\t\t\t\tstrncpy(newShader, n, t-n);\n\t\t\t\tnewShader[t-n] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt++;\n\t\t\to = strstr(t, \"@\");\n\t\t\tif (o) {\n\t\t\t\tstrncpy(timeOffset, t, o-t);\n\t\t\t\ttimeOffset[o-t] = 0;\n\t\t\t\to++;\n\t\t\t\ttrap_R_RemapShader( originalShader, newShader, timeOffset );\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=================\nCG_HeadModelVoiceChats\n=================\n*/\n", "func_signal": "int CG_HeadModelVoiceChats( char *filename )", "code": "{\n\tint\tlen, i;\n\tfileHandle_t f;\n\tchar buf[MAX_VOICEFILESIZE];\n\tchar **p, *ptr;\n\tchar *token;\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\tif ( !f ) {\n\t\t//trap_Print( va( \"voice chat file not found: %s\\n\", filename ) );\n\t\treturn -1;\n\t}\n\tif ( len >= MAX_VOICEFILESIZE ) {\n\t\ttrap_Print( va( S_COLOR_RED \"voice chat file too large: %s is %i, max allowed is %i\", filename, len, MAX_VOICEFILESIZE ) );\n\t\ttrap_FS_FCloseFile( f );\n\t\treturn -1;\n\t}\n\n\ttrap_FS_Read( buf, len, f );\n\tbuf[len] = 0;\n\ttrap_FS_FCloseFile( f );\n\n\tptr = buf;\n\tp = &ptr;\n\n\ttoken = COM_ParseExt(p, qtrue);\n\tif (!token || token[0] == 0) {\n\t\treturn -1;\n\t}\n\n\tfor ( i = 0; i < MAX_VOICEFILES; i++ ) {\n\t\tif ( !Q_stricmp(token, voiceChatLists[i].name) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t//FIXME: maybe try to load the .voice file which name is stored in token?\n\n\treturn -1;\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n==================\nSV_Map_f\n\nRestart the server on a different map\n==================\n*/\n", "func_signal": "static void SV_Map_f( void )", "code": "{\n\tchar\t\t*cmd;\n\tchar\t\t*map;\n\tqboolean\tkillBots, cheat;\n\tchar\t\texpanded[MAX_QPATH];\n\tchar\t\tmapname[MAX_QPATH];\n\n\tmap = Cmd_Argv(1);\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\t// make sure the level exists before trying to change, so that\n\t// a typo at the server console won't end the game\n\tCom_sprintf (expanded, sizeof(expanded), \"maps/%s.bsp\", map);\n\tif ( FS_ReadFile (expanded, NULL) == -1 ) {\n\t\tCom_Printf (\"Can't find map %s\\n\", expanded);\n\t\treturn;\n\t}\n\n\t// force latched values to get set\n\tCvar_Get (\"g_gametype\", \"0\", CVAR_SERVERINFO | CVAR_USERINFO | CVAR_LATCH );\n\n\tcmd = Cmd_Argv(0);\n\tif( Q_stricmpn( cmd, \"sp\", 2 ) == 0 ) {\n\t\tCvar_SetValue( \"g_gametype\", GT_SINGLE_PLAYER );\n\t\tCvar_SetValue( \"g_doWarmup\", 0 );\n\t\t// may not set sv_maxclients directly, always set latched\n\t\tCvar_SetLatched( \"sv_maxclients\", \"8\" );\n\t\tcmd += 2;\n\t\tcheat = qfalse;\n\t\tkillBots = qtrue;\n\t}\n\telse {\n\t\tif ( !Q_stricmp( cmd, \"devmap\" ) || !Q_stricmp( cmd, \"spdevmap\" ) ) {\n\t\t\tcheat = qtrue;\n\t\t\tkillBots = qtrue;\n\t\t} else {\n\t\t\tcheat = qfalse;\n\t\t\tkillBots = qfalse;\n\t\t}\n\t\tif( sv_gametype->integer == GT_SINGLE_PLAYER ) {\n\t\t\tCvar_SetValue( \"g_gametype\", GT_FFA );\n\t\t}\n\t}\n\n\t// save the map name here cause on a map restart we reload the q3config.cfg\n\t// and thus nuke the arguments of the map command\n\tQ_strncpyz(mapname, map, sizeof(mapname));\n\n\t// start up the map\n\tSV_SpawnServer( mapname, killBots );\n\n\t// set the cheat value\n\t// if the level was started with \"map <levelname>\", then\n\t// cheats will not be allowed.  If started with \"devmap <levelname>\"\n\t// then cheats will be allowed\n\tif ( cheat ) {\n\t\tCvar_Set( \"sv_cheats\", \"1\" );\n\t} else {\n\t\tCvar_Set( \"sv_cheats\", \"0\" );\n\t}\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n==================\nCG_ParseWarmup\n==================\n*/\n", "func_signal": "static void CG_ParseWarmup( void )", "code": "{\n\tconst char\t*info;\n\tint\t\t\twarmup;\n\n\tinfo = CG_ConfigString( CS_WARMUP );\n\n\twarmup = atoi( info );\n\tcg.warmupCount = -1;\n\n\tif ( warmup == 0 && cg.warmup ) {\n\n\t} else if ( warmup > 0 && cg.warmup <= 0 ) {\n#ifdef MISSIONPACK\n\t\tif (cgs.gametype >= GT_CTF && cgs.gametype <= GT_HARVESTER) {\n\t\t\ttrap_S_StartLocalSound( cgs.media.countPrepareTeamSound, CHAN_ANNOUNCER );\n\t\t} else\n#endif\n\t\t{\n\t\t\ttrap_S_StartLocalSound( cgs.media.countPrepareSound, CHAN_ANNOUNCER );\n\t\t}\n\t}\n\n\tcg.warmup = warmup;\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n==================\nSV_AddOperatorCommands\n==================\n*/\n", "func_signal": "void SV_AddOperatorCommands( void )", "code": "{\n\tstatic qboolean\tinitialized;\n\n\tif ( initialized ) {\n\t\treturn;\n\t}\n\tinitialized = qtrue;\n\n\tCmd_AddCommand (\"heartbeat\", SV_Heartbeat_f);\n\tCmd_AddCommand (\"kick\", SV_Kick_f);\n\tCmd_AddCommand (\"banUser\", SV_Ban_f);\n\tCmd_AddCommand (\"banClient\", SV_BanNum_f);\n\tCmd_AddCommand (\"clientkick\", SV_KickNum_f);\n\tCmd_AddCommand (\"status\", SV_Status_f);\n\tCmd_AddCommand (\"serverinfo\", SV_Serverinfo_f);\n\tCmd_AddCommand (\"systeminfo\", SV_Systeminfo_f);\n\tCmd_AddCommand (\"dumpuser\", SV_DumpUser_f);\n\tCmd_AddCommand (\"map_restart\", SV_MapRestart_f);\n\tCmd_AddCommand (\"sectorlist\", SV_SectorList_f);\n\tCmd_AddCommand (\"map\", SV_Map_f);\n#ifndef PRE_RELEASE_DEMO\n\tCmd_AddCommand (\"devmap\", SV_Map_f);\n\tCmd_AddCommand (\"spmap\", SV_Map_f);\n\tCmd_AddCommand (\"spdevmap\", SV_Map_f);\n#endif\n\tCmd_AddCommand (\"killserver\", SV_KillServer_f);\n\tif( com_dedicated->integer ) {\n\t\tCmd_AddCommand (\"say\", SV_ConSay_f);\n\t}\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n===========\nSV_Systeminfo_f\n\nExamine or change the serverinfo string\n===========\n*/\n", "func_signal": "static void SV_Systeminfo_f( void )", "code": "{\n\tCom_Printf (\"System info settings:\\n\");\n\tInfo_Print ( Cvar_InfoString( CVAR_SYSTEMINFO ) );\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=================\nCG_VoiceChatLocal\n=================\n*/\n", "func_signal": "void CG_VoiceChatLocal( int mode, qboolean voiceOnly, int clientNum, int color, const char *cmd )", "code": "{\n#ifdef MISSIONPACK\n\tchar *chat;\n\tvoiceChatList_t *voiceChatList;\n\tclientInfo_t *ci;\n\tsfxHandle_t snd;\n\tbufferedVoiceChat_t vchat;\n\n\t// if we are going into the intermission, don't start any voices\n\tif ( cg.intermissionStarted ) {\n\t\treturn;\n\t}\n\n\tif ( clientNum < 0 || clientNum >= MAX_CLIENTS ) {\n\t\tclientNum = 0;\n\t}\n\tci = &cgs.clientinfo[ clientNum ];\n\n\tcgs.currentVoiceClient = clientNum;\n\n\tvoiceChatList = CG_VoiceChatListForClient( clientNum );\n\n\tif ( CG_GetVoiceChat( voiceChatList, cmd, &snd, &chat ) ) {\n\t\t//\n\t\tif ( mode == SAY_TEAM || !cg_teamChatsOnly.integer ) {\n\t\t\tvchat.clientNum = clientNum;\n\t\t\tvchat.snd = snd;\n\t\t\tvchat.voiceOnly = voiceOnly;\n\t\t\tQ_strncpyz(vchat.cmd, cmd, sizeof(vchat.cmd));\n\t\t\tif ( mode == SAY_TELL ) {\n\t\t\t\tCom_sprintf(vchat.message, sizeof(vchat.message), \"[%s]: %c%c%s\", ci->name, Q_COLOR_ESCAPE, color, chat);\n\t\t\t}\n\t\t\telse if ( mode == SAY_TEAM ) {\n\t\t\t\tCom_sprintf(vchat.message, sizeof(vchat.message), \"(%s): %c%c%s\", ci->name, Q_COLOR_ESCAPE, color, chat);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCom_sprintf(vchat.message, sizeof(vchat.message), \"%s: %c%c%s\", ci->name, Q_COLOR_ESCAPE, color, chat);\n\t\t\t}\n\t\t\tCG_AddBufferedVoiceChat(&vchat);\n\t\t}\n\t}\n#endif\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=================\nCG_LoadVoiceChats\n=================\n*/\n", "func_signal": "void CG_LoadVoiceChats( void )", "code": "{\n\tint size;\n\n\tsize = trap_MemoryRemaining();\n\tCG_ParseVoiceChats( \"scripts/female1.voice\", &voiceChatLists[0], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/female2.voice\", &voiceChatLists[1], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/female3.voice\", &voiceChatLists[2], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/male1.voice\", &voiceChatLists[3], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/male2.voice\", &voiceChatLists[4], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/male3.voice\", &voiceChatLists[5], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/male4.voice\", &voiceChatLists[6], MAX_VOICECHATS );\n\tCG_ParseVoiceChats( \"scripts/male5.voice\", &voiceChatLists[7], MAX_VOICECHATS );\n\tCG_Printf(\"voice chat memory size = %d\\n\", size - trap_MemoryRemaining());\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n=====================\nCG_AddBufferedVoiceChat\n=====================\n*/\n", "func_signal": "void CG_AddBufferedVoiceChat( bufferedVoiceChat_t *vchat )", "code": "{\n#ifdef MISSIONPACK\n\t// if we are going into the intermission, don't start any voices\n\tif ( cg.intermissionStarted ) {\n\t\treturn;\n\t}\n\n\tmemcpy(&voiceChatBuffer[cg.voiceChatBufferIn], vchat, sizeof(bufferedVoiceChat_t));\n\tcg.voiceChatBufferIn = (cg.voiceChatBufferIn + 1) % MAX_VOICECHATBUFFER;\n\tif (cg.voiceChatBufferIn == cg.voiceChatBufferOut) {\n\t\tCG_PlayVoiceChat( &voiceChatBuffer[cg.voiceChatBufferOut] );\n\t\tcg.voiceChatBufferOut++;\n\t}\n#endif\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n==================\nSV_BanNum_f\n\nBan a user from being able to play on this server through the auth\nserver\n==================\n*/\n", "func_signal": "static void SV_BanNum_f( void )", "code": "{\n\tclient_t\t*cl;\n\n\t// make sure server is running\n\tif ( !com_sv_running->integer ) {\n\t\tCom_Printf( \"Server is not running.\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf (\"Usage: banClient <client number>\\n\");\n\t\treturn;\n\t}\n\n\tcl = SV_GetPlayerByNum();\n\tif ( !cl ) {\n\t\treturn;\n\t}\n\tif( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {\n\t\tSV_SendServerCommand(NULL, \"print \\\"%s\\\"\", \"Cannot kick host player\\n\");\n\t\treturn;\n\t}\n\n\t// look up the authorize server's IP\n\tif ( !svs.authorizeAddress.ip[0] && svs.authorizeAddress.type != NA_BAD ) {\n\t\tCom_Printf( \"Resolving %s\\n\", AUTHORIZE_SERVER_NAME );\n\t\tif ( !NET_StringToAdr( AUTHORIZE_SERVER_NAME, &svs.authorizeAddress ) ) {\n\t\t\tCom_Printf( \"Couldn't resolve address\\n\" );\n\t\t\treturn;\n\t\t}\n\t\tsvs.authorizeAddress.port = BigShort( PORT_AUTHORIZE );\n\t\tCom_Printf( \"%s resolved to %i.%i.%i.%i:%i\\n\", AUTHORIZE_SERVER_NAME,\n\t\t\tsvs.authorizeAddress.ip[0], svs.authorizeAddress.ip[1],\n\t\t\tsvs.authorizeAddress.ip[2], svs.authorizeAddress.ip[3],\n\t\t\tBigShort( svs.authorizeAddress.port ) );\n\t}\n\n\t// otherwise send their ip to the authorize server\n\tif ( svs.authorizeAddress.type != NA_BAD ) {\n\t\tNET_OutOfBandPrint( NS_SERVER, svs.authorizeAddress,\n\t\t\t\"banUser %i.%i.%i.%i\", cl->netchan.remoteAddress.ip[0], cl->netchan.remoteAddress.ip[1], \n\t\t\t\t\t\t\t\t   cl->netchan.remoteAddress.ip[2], cl->netchan.remoteAddress.ip[3] );\n\t\tCom_Printf(\"%s was banned from coming back\\n\", cl->name);\n\t}\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "// bk001204\n", "func_signal": "static int CG_ValidOrder(const char *p)", "code": "{\n\tint i;\n\tfor (i = 0; i < numValidOrders; i++) {\n\t\tif (Q_stricmp(p, validOrders[i].order) == 0) {\n\t\t\treturn validOrders[i].taskNum;\n\t\t}\n\t}\n\treturn -1;\n}", "path": "code\\cgame\\cg_servercmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/*\n==================\nSV_KickNum_f\n\nKick a user off of the server  FIXME: move to game\n==================\n*/\n", "func_signal": "static void SV_KickNum_f( void )", "code": "{\n\tclient_t\t*cl;\n\n\t// make sure server is running\n\tif ( !com_sv_running->integer ) {\n\t\tCom_Printf( \"Server is not running.\\n\" );\n\t\treturn;\n\t}\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf (\"Usage: kicknum <client number>\\n\");\n\t\treturn;\n\t}\n\n\tcl = SV_GetPlayerByNum();\n\tif ( !cl ) {\n\t\treturn;\n\t}\n\tif( cl->netchan.remoteAddress.type == NA_LOOPBACK ) {\n\t\tSV_SendServerCommand(NULL, \"print \\\"%s\\\"\", \"Cannot kick host player\\n\");\n\t\treturn;\n\t}\n\n\tSV_DropClient( cl, \"was kicked\" );\n\tcl->lastPacketTime = svs.time;\t// in case there is a funny zombie\n}", "path": "code\\server\\sv_ccmds.c", "repo_name": "Cpasjuste/quake3_pandora_gles", "stars": 10, "license": "gpl-2.0", "language": "c", "size": 2395}
{"docstring": "/**\n *  e1000e_wait_autoneg - Wait for auto-neg completion\n *  @hw: pointer to the HW structure\n *\n *  Waits for auto-negotiation to complete or for the auto-negotiation time\n *  limit to expire, which ever happens first.\n **/\n", "func_signal": "s32 e1000e_wait_autoneg(struct e1000_hw *hw)", "code": "{\n\ts32 ret_val = E1000_SUCCESS;\n\tu16 i, phy_status;\n\n\tif (!(hw->phy.ops.read_reg))\n\t\treturn E1000_SUCCESS;\n\n\t/* Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */\n\tfor (i = PHY_AUTO_NEG_LIMIT; i > 0; i--) {\n\t\tret_val = e1e_rphy(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tret_val = e1e_rphy(hw, PHY_STATUS, &phy_status);\n\t\tif (ret_val)\n\t\t\tbreak;\n\t\tif (phy_status & MII_SR_AUTONEG_COMPLETE)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\t/*\n\t * PHY_AUTO_NEG_TIME expiration doesn't guarantee auto-negotiation\n\t * has completed.\n\t */\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_get_cable_length_m88 - Determine cable length for m88 PHY\n *  @hw: pointer to the HW structure\n *\n *  Reads the PHY specific status register to retrieve the cable length\n *  information.  The cable length is determined by averaging the minimum and\n *  maximum values to get the \"average\" cable length.  The m88 PHY has four\n *  possible cable length values, which are:\n *\tRegister Value\t\tCable Length\n *\t0\t\t\t< 50 meters\n *\t1\t\t\t50 - 80 meters\n *\t2\t\t\t80 - 110 meters\n *\t3\t\t\t110 - 140 meters\n *\t4\t\t\t> 140 meters\n **/\n", "func_signal": "s32 e1000e_get_cable_length_m88(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, index;\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tindex = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>\n\t        M88E1000_PSSR_CABLE_LENGTH_SHIFT;\n\tif (index >= M88E1000_CABLE_LENGTH_TABLE_SIZE - 1) {\n\t\tret_val = -E1000_ERR_PHY;\n\t\tgoto out;\n\t}\n\n\tphy->min_cable_length = e1000_m88_cable_length_table[index];\n\tphy->max_cable_length = e1000_m88_cable_length_table[index + 1];\n\n\tphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *      sis190_init_rxfilter - Initialize the Rx filter\n *      @dev: network device to initialize\n *\n *      Set receive filter address to our MAC address\n *      and enable packet filtering.\n */\n", "func_signal": "static inline void sis190_init_rxfilter(struct net_device *dev)", "code": "{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid *ioaddr = tp->mmio_addr;\n\tu16 ctl;\n\tint i;\n\n\tctl = SIS_R16(RxMacControl);\n\t/*\n\t * Disable packet filtering before setting filter.\n\t * Note: SiS's driver writes 32 bits but RxMacControl is 16 bits\n\t * only and followed by RxMacAddr (6 bytes). Strange. -- FR\n\t */\n\tSIS_W16(RxMacControl, ctl & ~0x0f00);\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tSIS_W8(RxMacAddr + i, dev->ll_addr[i]);\n\n\tSIS_W16(RxMacControl, ctl);\n\tSIS_PCI_COMMIT();\n}", "path": "src\\drivers\\net\\sis190.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_get_phy_info_82577 - Retrieve I82577 PHY information\n *  @hw: pointer to the HW structure\n *\n *  Read PHY status to determine if link is up.  If link is up, then\n *  set/determine 10base-T extended distance and polarity correction.  Read\n *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,\n *  determine on the cable length, local and remote receiver.\n **/\n", "func_signal": "s32 e1000e_get_phy_info_82577(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\tbool link;\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tphy->polarity_correction = true;\n\n\tret_val = e1000e_check_polarity_82577(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1e_rphy(hw, I82577_PHY_STATUS_2, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->is_mdix = (data & I82577_PHY_STATUS2_MDIX) ? true : false;\n\n\tif ((data & I82577_PHY_STATUS2_SPEED_MASK) ==\n\t    I82577_PHY_STATUS2_SPEED_1000MBPS) {\n#if 0\n\t\tret_val = e1000e_get_cable_length(hw);\n#endif\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tif (ret_val)\n\t\t\tgoto out;\n#if 0\n\t\tret_val = e1e_rphy(hw, PHY_1000T_STATUS, &data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->local_rx = (data & SR_1000T_LOCAL_RX_STATUS)\n\t\t                ? e1000_1000t_rx_status_ok\n\t\t                : e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (data & SR_1000T_REMOTE_RX_STATUS)\n\t\t                 ? e1000_1000t_rx_status_ok\n\t\t                 : e1000_1000t_rx_status_not_ok;\n#endif\n\t} else {\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  __e1000e_write_kmrn_reg - Write kumeran register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to write to\n *  @data: data to write at register offset\n *  @locked: semaphore has already been acquired or not\n *\n *  Acquires semaphore, if necessary.  Then write the data to PHY register\n *  at the offset using the kumeran interface.  Release any acquired semaphores\n *  before exiting.\n **/\n", "func_signal": "static s32 __e1000e_write_kmrn_reg(struct e1000_hw *hw, u32 offset, u16 data,\n                                  bool locked)", "code": "{\n\tu32 kmrnctrlsta;\n\ts32 ret_val = E1000_SUCCESS;\n\n\tif (!locked) {\n\t\tif (!(hw->phy.ops.acquire))\n\t\t\tgoto out;\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\n\t               E1000_KMRNCTRLSTA_OFFSET) | data;\n\tew32(KMRNCTRLSTA, kmrnctrlsta);\n\n\tudelay(2);\n\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_get_phy_info_m88 - Retrieve PHY information\n *  @hw: pointer to the HW structure\n *\n *  Valid for only copper links.  Read the PHY status register (sticky read)\n *  to verify that link is up.  Read the PHY special control register to\n *  determine the polarity and 10base-T extended distance.  Read the PHY\n *  special status register to determine MDI/MDIx and current speed.  If\n *  speed is 1000, then determine cable length, local and remote receiver.\n **/\n", "func_signal": "s32 e1000e_get_phy_info_m88(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32  ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tif (phy->media_type != e1000_media_type_copper) {\n\t\te_dbg(\"Phy info is only valid for copper media\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tret_val = e1000e_phy_has_link_generic(hw, 1, 0, &link);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif (!link) {\n\t\te_dbg(\"Phy info is only valid if link is up\\n\");\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tgoto out;\n\t}\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->polarity_correction = (phy_data & M88E1000_PSCR_POLARITY_REVERSAL)\n\t                           ? true : false;\n\n\tret_val = e1000e_check_polarity_m88(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy->is_mdix = (phy_data & M88E1000_PSSR_MDIX) ? true : false;\n\n\tif ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {\n#if 0\n\t\tret_val = e1000e_get_cable_length(hw);\n#endif\n\t\tret_val = -E1000_ERR_CONFIG;\n\t\tif (ret_val)\n\t\t\tgoto out;\n#if 0\n\t\tret_val = e1e_rphy(hw, PHY_1000T_STATUS, &phy_data);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tphy->local_rx = (phy_data & SR_1000T_LOCAL_RX_STATUS)\n\t\t                ? e1000_1000t_rx_status_ok\n\t\t                : e1000_1000t_rx_status_not_ok;\n\n\t\tphy->remote_rx = (phy_data & SR_1000T_REMOTE_RX_STATUS)\n\t\t                 ? e1000_1000t_rx_status_ok\n\t\t                 : e1000_1000t_rx_status_not_ok;\n#endif\n\t} else {\n\t\t/* Set values to \"undefined\" */\n\t\tphy->cable_length = E1000_CABLE_LENGTH_UNDEFINED;\n\t\tphy->local_rx = e1000_1000t_rx_status_undefined;\n\t\tphy->remote_rx = e1000_1000t_rx_status_undefined;\n\t}\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_write_phy_reg_bm2 - Write BM PHY register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to write to\n *  @data: data to write at register offset\n *\n *  Acquires semaphore, if necessary, then writes the data to PHY register\n *  at the offset.  Release any acquired semaphores before exiting.\n **/\n", "func_signal": "s32 e1000e_write_phy_reg_bm2(struct e1000_hw *hw, u32 offset, u16 data)", "code": "{\n\ts32 ret_val;\n\tu16 page = (u16)(offset >> IGP_PAGE_SHIFT);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t/* Page 800 works differently than the rest so it has its own func */\n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000e_access_phy_wakeup_reg_bm(hw, offset, &data,\n\t\t                                         false);\n\t\tgoto out;\n\t}\n\n\thw->phy.addr = 1;\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\t/* Page is shifted left, PHY expects (page x 32) */\n\t\tret_val = e1000e_write_phy_reg_mdic(hw, BM_PHY_PAGE_SELECT,\n\t\t                                   page);\n\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t                                   data);\n\nout:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  __e1000e_write_phy_reg_hv - Write HV PHY register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to write to\n *  @data: data to write at register offset\n *  @locked: semaphore has already been acquired or not\n *\n *  Acquires semaphore, if necessary, then writes the data to PHY register\n *  at the offset.  Release any acquired semaphores before exiting.\n **/\n", "func_signal": "static s32 __e1000e_write_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 data,\n                                    bool locked)", "code": "{\n\ts32 ret_val;\n\tu16 page = BM_PHY_REG_PAGE(offset);\n\tu16 reg = BM_PHY_REG_NUM(offset);\n\tbool in_slow_mode = false;\n\n\tif (!locked) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t/* Workaround failure in MDIO access while cable is disconnected */\n\tif ((hw->phy.type == e1000_phy_82577) &&\n\t    !(er32(STATUS) & E1000_STATUS_LU)) {\n\t\tret_val = e1000e_set_mdio_slow_mode_hv(hw, true);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tin_slow_mode = true;\n\t}\n\n\t/* Page 800 works differently than the rest so it has its own func */\n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000e_access_phy_wakeup_reg_bm(hw, offset,\n\t\t                                         &data, false);\n\t\tgoto out;\n\t}\n\n\tif (page > 0 && page < HV_INTC_FC_PAGE_START) {\n\t\tret_val = e1000e_access_phy_debug_regs_hv(hw, offset,\n\t\t                                         &data, false);\n\t\tgoto out;\n\t}\n\n\thw->phy.addr = e1000e_get_phy_addr_for_hv_page(page);\n\n\tif (page == HV_INTC_FC_PAGE_START)\n\t\tpage = 0;\n\n\t/*\n\t * Workaround MDIO accesses being disabled after entering IEEE Power\n\t * Down (whenever bit 11 of the PHY Control register is set)\n\t */\n\tif ((hw->phy.type == e1000_phy_82578) &&\n\t    (hw->phy.revision >= 1) &&\n\t    (hw->phy.addr == 2) &&\n\t    ((MAX_PHY_REG_ADDRESS & reg) == 0) &&\n\t    (data & (1 << 11))) {\n\t\tu16 data2 = 0x7EFF;\n\t\tret_val = e1000e_access_phy_debug_regs_hv(hw, (1 << 6) | 0x3,\n\t\t                                         &data2, false);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tif (reg > MAX_PHY_MULTI_PAGE_REG) {\n\t\tu32 phy_addr = hw->phy.addr;\n\n\t\thw->phy.addr = 1;\n\n\t\t/* Page is shifted left, PHY expects (page x 32) */\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t     IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t     (page << IGP_PAGE_SHIFT));\n\t\thw->phy.addr = phy_addr;\n\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & reg,\n\t                                  data);\n\nout:\n\t/* Revert to MDIO fast mode, if applicable */\n\tif ((hw->phy.type == e1000_phy_82577) && in_slow_mode)\n\t\tret_val |= e1000e_set_mdio_slow_mode_hv(hw, false);\n\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**************************************************************************\nPOLL - Wait for a frame\n***************************************************************************/\n", "func_signal": "static int sundance_poll(struct nic *nic, int retreive)", "code": "{\n\t/* return true if there's an ethernet packet ready to read */\n\t/* nic->packet should contain data on return */\n\t/* nic->packetlen should contain length of data */\n\tint entry = sdc->cur_rx % RX_RING_SIZE;\n\tu32 frame_status = le32_to_cpu(rx_ring[entry].status);\n\tint intr_status;\n\tint pkt_len = 0;\n\n\tif (!(frame_status & DescOwn))\n\t\treturn 0;\n\n\t/* There is a packet ready */\n\tif(!retreive)\n\t\treturn 1;\n\n\tintr_status = inw(nic->ioaddr + IntrStatus);\n\toutw(intr_status, nic->ioaddr + IntrStatus);\n\n\tpkt_len = frame_status & 0x1fff;\n\n\tif (frame_status & 0x001f4000) {\n\t\tDBG ( \"Polling frame_status error\\n\" );\t/* Do we really care about this */\n\t} else {\n\t\tif (pkt_len < rx_copybreak) {\n\t\t\t/* FIXME: What should happen Will this ever occur */\n\t\t\tprintf(\"Poll Error: pkt_len < rx_copybreak\");\n\t\t} else {\n\t\t\tnic->packetlen = pkt_len;\n\t\t\tmemcpy(nic->packet, rxb +\n\t\t\t       (sdc->cur_rx * PKT_BUF_SZ), nic->packetlen);\n\n\t\t}\n\t}\n\trx_ring[entry].length = cpu_to_le32(PKT_BUF_SZ | LastFrag);\n\trx_ring[entry].status = 0;\n\tentry++;\n\tsdc->cur_rx = entry % RX_RING_SIZE;\n\toutw(DEFAULT_INTR & ~(IntrRxDone|IntrRxDMADone), \n\t\tnic->ioaddr + IntrStatus);\n\treturn 1;\n}", "path": "src\\drivers\\net\\sundance.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_read_phy_reg_bm - Read BM PHY register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to be read\n *  @data: pointer to the read data\n *\n *  Acquires semaphore, if necessary, then reads the PHY register at offset\n *  and storing the retrieved information in data.  Release any acquired\n *  semaphores before exiting.\n **/\n", "func_signal": "s32 e1000e_read_phy_reg_bm(struct e1000_hw *hw, u32 offset, u16 *data)", "code": "{\n\ts32 ret_val;\n\tu32 page_select = 0;\n\tu32 page = offset >> IGP_PAGE_SHIFT;\n\tu32 page_shift = 0;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t/* Page 800 works differently than the rest so it has its own func */\n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000e_access_phy_wakeup_reg_bm(hw, offset, data,\n\t\t                                         true);\n\t\tgoto out;\n\t}\n\n\thw->phy.addr = e1000e_get_phy_addr_for_bm_page(page, offset);\n\n\tif (offset > MAX_PHY_MULTI_PAGE_REG) {\n\t\t/*\n\t\t * Page select is register 31 for phy address 1 and 22 for\n\t\t * phy address 2 and 3. Page select is shifted only for\n\t\t * phy address 1.\n\t\t */\n\t\tif (hw->phy.addr == 1) {\n\t\t\tpage_shift = IGP_PAGE_SHIFT;\n\t\t\tpage_select = IGP01E1000_PHY_PAGE_SELECT;\n\t\t} else {\n\t\t\tpage_shift = 0;\n\t\t\tpage_select = BM_PHY_PAGE_SELECT;\n\t\t}\n\n\t\t/* Page is shifted left, PHY expects (page x 32) */\n\t\tret_val = e1000e_write_phy_reg_mdic(hw, page_select,\n\t\t                                   (page << page_shift));\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t                                  data);\nout:\n\thw->phy.ops.release(hw);\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_check_polarity_ife - Check cable polarity for IFE PHY\n *  @hw: pointer to the HW structure\n *\n *  Polarity is determined on the polarity reversal feature being enabled.\n **/\n", "func_signal": "s32 e1000e_check_polarity_ife(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data, offset, mask;\n\n\t/*\n\t * Polarity is determined based on the reversal feature being enabled.\n\t */\n\tif (phy->polarity_correction) {\n\t\toffset = IFE_PHY_EXTENDED_STATUS_CONTROL;\n\t\tmask = IFE_PESC_POLARITY_REVERSED;\n\t} else {\n\t\toffset = IFE_PHY_SPECIAL_CONTROL;\n\t\tmask = IFE_PSC_FORCE_POLARITY;\n\t}\n\n\tret_val = e1e_rphy(hw, offset, &phy_data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (phy_data & mask)\n\t\t                       ? e1000_rev_polarity_reversed\n\t\t                       : e1000_rev_polarity_normal;\n\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**************************************************************************\nIRQ - Wait for a frame\n***************************************************************************/\n", "func_signal": "static void sundance_irq ( struct nic *nic, irq_action_t action )", "code": "{\n        unsigned int intr_status;\n\n\tswitch ( action ) {\n\tcase DISABLE :\n\tcase ENABLE :\n\t\tintr_status = inw(nic->ioaddr + IntrStatus);\n\t\tintr_status = intr_status & ~DEFAULT_INTR;\n\t\tif ( action == ENABLE ) \n\t\t\tintr_status = intr_status | DEFAULT_INTR;\n\t\toutw(intr_status, nic->ioaddr + IntrEnable);\n\t\tbreak;\n        case FORCE :\n\t\toutw(0x0200, BASE + ASICCtrl);\n\t\tbreak;\n        }\n}", "path": "src\\drivers\\net\\sundance.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**************************************************************************\n *  RESET - Reset Adapter\n * ***********************************************************************/\n", "func_signal": "static void sundance_reset(struct nic *nic)", "code": "{\n\tint i;\n\n\tinit_ring(nic);\n\n\toutl(virt_to_le32desc(&rx_ring[0]), BASE + RxListPtr);\n\t/* The Tx List Pointer is written as packets are queued */\n\n\t/* Initialize other registers. */\n\t/* __set_mac_addr(dev); */\n\t{\n\t\tu16 addr16;\n\n\t\taddr16 = (nic->node_addr[0] | (nic->node_addr[1] << 8));\n\t\toutw(addr16, BASE + StationAddr);\n\t\taddr16 = (nic->node_addr[2] | (nic->node_addr[3] << 8));\n\t\toutw(addr16, BASE + StationAddr + 2);\n\t\taddr16 = (nic->node_addr[4] | (nic->node_addr[5] << 8));\n\t\toutw(addr16, BASE + StationAddr + 4);\n\t}\n\n\toutw(sdc->mtu + 14, BASE + MaxFrameSize);\n\tif (sdc->mtu > 2047)\t/* this will never happen with default options */\n\t\toutl(inl(BASE + ASICCtrl) | 0x0c, BASE + ASICCtrl);\n\n\tset_rx_mode(nic);\n\n\toutw(0, BASE + DownCounter);\n\t/* Set the chip to poll every N*30nsec */\n\toutb(100, BASE + RxDMAPollPeriod);\n\n\t/* Fix DFE-580TX packet drop issue */\n\tif (sdc->pci_rev_id >= 0x14)\n\t\twriteb(0x01, BASE + DebugCtrl1);\n\n\toutw(RxEnable | TxEnable, BASE + MACCtrl1);\n\n\t/* Construct a perfect filter frame with the mac address as first match\n\t * and broadcast for all others */\n\tfor (i = 0; i < 192; i++)\n\t\ttxb[i] = 0xFF;\n\n\ttxb[0] = nic->node_addr[0];\n\ttxb[1] = nic->node_addr[1];\n\ttxb[2] = nic->node_addr[2];\n\ttxb[3] = nic->node_addr[3];\n\ttxb[4] = nic->node_addr[4];\n\ttxb[5] = nic->node_addr[5];\n\n\tDBG ( \"%s: Done sundance_reset, status: Rx %hX Tx %hX \"\n\t      \"MAC Control %hX, %hX %hX\\n\",\n\t      sdc->nic_name, (int) inl(BASE + RxStatus),\n\t      (int) inw(BASE + TxStatus), (int) inl(BASE + MACCtrl0),\n\t      (int) inw(BASE + MACCtrl1), (int) inw(BASE + MACCtrl0) );\n}", "path": "src\\drivers\\net\\sundance.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  __e1000e_read_phy_reg_hv -  Read HV PHY register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to be read\n *  @data: pointer to the read data\n *  @locked: semaphore has already been acquired or not\n *\n *  Acquires semaphore, if necessary, then reads the PHY register at offset\n *  and stores the retrieved information in data.  Release any acquired\n *  semaphore before exiting.\n **/\n", "func_signal": "static s32 __e1000e_read_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 *data,\n                                   bool locked)", "code": "{\n\ts32 ret_val;\n\tu16 page = BM_PHY_REG_PAGE(offset);\n\tu16 reg = BM_PHY_REG_NUM(offset);\n\tbool in_slow_mode = false;\n\n\tif (!locked) {\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\t/* Workaround failure in MDIO access while cable is disconnected */\n\tif ((hw->phy.type == e1000_phy_82577) &&\n\t    !(er32(STATUS) & E1000_STATUS_LU)) {\n\t\tret_val = e1000e_set_mdio_slow_mode_hv(hw, true);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tin_slow_mode = true;\n\t}\n\n\t/* Page 800 works differently than the rest so it has its own func */\n\tif (page == BM_WUC_PAGE) {\n\t\tret_val = e1000e_access_phy_wakeup_reg_bm(hw, offset,\n\t\t                                         data, true);\n\t\tgoto out;\n\t}\n\n\tif (page > 0 && page < HV_INTC_FC_PAGE_START) {\n\t\tret_val = e1000e_access_phy_debug_regs_hv(hw, offset,\n\t\t                                         data, true);\n\t\tgoto out;\n\t}\n\n\thw->phy.addr = e1000e_get_phy_addr_for_hv_page(page);\n\n\tif (page == HV_INTC_FC_PAGE_START)\n\t\tpage = 0;\n\n\tif (reg > MAX_PHY_MULTI_PAGE_REG) {\n\t\tu32 phy_addr = hw->phy.addr;\n\n\t\thw->phy.addr = 1;\n\n\t\t/* Page is shifted left, PHY expects (page x 32) */\n\t\tret_val = e1000e_write_phy_reg_mdic(hw,\n\t\t\t\t\t     IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t     (page << IGP_PAGE_SHIFT));\n\t\thw->phy.addr = phy_addr;\n\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\n\tret_val = e1000e_read_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & reg,\n\t                                  data);\nout:\n\t/* Revert to MDIO fast mode, if applicable */\n\tif ((hw->phy.type == e1000_phy_82577) && in_slow_mode)\n\t\tret_val |= e1000e_set_mdio_slow_mode_hv(hw, false);\n\n\tif (!locked)\n\t\thw->phy.ops.release(hw);\n\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_phy_force_speed_duplex_setup - Configure forced PHY speed/duplex\n *  @hw: pointer to the HW structure\n *  @phy_ctrl: pointer to current value of PHY_CONTROL\n *\n *  Forces speed and duplex on the PHY by doing the following: disable flow\n *  control, force speed/duplex on the MAC, disable auto speed detection,\n *  disable auto-negotiation, configure duplex, configure speed, configure\n *  the collision distance, write configuration to CTRL register.  The\n *  caller must write to the PHY_CONTROL register for these settings to\n *  take affect.\n **/\n", "func_signal": "void e1000e_phy_force_speed_duplex_setup(struct e1000_hw *hw, u16 *phy_ctrl)", "code": "{\n\tstruct e1000_mac_info *mac = &hw->mac;\n\tu32 ctrl;\n\n\t/* Turn off flow control when forcing speed/duplex */\n\thw->fc.current_mode = e1000_fc_none;\n\n\t/* Force speed/duplex on the mac */\n\tctrl = er32(CTRL);\n\tctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\n\tctrl &= ~E1000_CTRL_SPD_SEL;\n\n\t/* Disable Auto Speed Detection */\n\tctrl &= ~E1000_CTRL_ASDE;\n\n\t/* Disable autoneg on the phy */\n\t*phy_ctrl &= ~MII_CR_AUTO_NEG_EN;\n\n\t/* Forcing Full or Half Duplex? */\n\tif (mac->forced_speed_duplex & E1000_ALL_HALF_DUPLEX) {\n\t\tctrl &= ~E1000_CTRL_FD;\n\t\t*phy_ctrl &= ~MII_CR_FULL_DUPLEX;\n\t\te_dbg(\"Half Duplex\\n\");\n\t} else {\n\t\tctrl |= E1000_CTRL_FD;\n\t\t*phy_ctrl |= MII_CR_FULL_DUPLEX;\n\t\te_dbg(\"Full Duplex\\n\");\n\t}\n\n\t/* Forcing 10mb or 100mb? */\n\tif (mac->forced_speed_duplex & E1000_ALL_100_SPEED) {\n\t\tctrl |= E1000_CTRL_SPD_100;\n\t\t*phy_ctrl |= MII_CR_SPEED_100;\n\t\t*phy_ctrl &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);\n\t\te_dbg(\"Forcing 100mb\\n\");\n\t} else {\n\t\tctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);\n\t\t*phy_ctrl |= MII_CR_SPEED_10;\n\t\t*phy_ctrl &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);\n\t\te_dbg(\"Forcing 10mb\\n\");\n\t}\n\n\te1000e_config_collision_dist(hw);\n\n\tew32(CTRL, ctrl);\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_write_phy_reg_m88 - Write m88 PHY register\n *  @hw: pointer to the HW structure\n *  @offset: register offset to write to\n *  @data: data to write at register offset\n *\n *  Acquires semaphore, if necessary, then writes the data to PHY register\n *  at the offset.  Release any acquired semaphores before exiting.\n **/\n", "func_signal": "s32 e1000e_write_phy_reg_m88(struct e1000_hw *hw, u32 offset, u16 data)", "code": "{\n\ts32 ret_val = E1000_SUCCESS;\n\n\tif (!(hw->phy.ops.acquire))\n\t\tgoto out;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto out;\n\n\tret_val = e1000e_write_phy_reg_mdic(hw, MAX_PHY_REG_ADDRESS & offset,\n\t                                   data);\n\n\thw->phy.ops.release(hw);\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_check_polarity_82577 - Checks the polarity.\n *  @hw: pointer to the HW structure\n *\n *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)\n *\n *  Polarity is determined based on the PHY specific status register.\n **/\n", "func_signal": "s32 e1000e_check_polarity_82577(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data;\n\n\tret_val = e1e_rphy(hw, I82577_PHY_STATUS_2, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (data & I82577_PHY_STATUS2_REV_POLARITY)\n\t\t                      ? e1000_rev_polarity_reversed\n\t\t                      : e1000_rev_polarity_normal;\n\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_check_polarity_igp - Checks the polarity.\n *  @hw: pointer to the HW structure\n *\n *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)\n *\n *  Polarity is determined based on the PHY port status register, and the\n *  current speed (since there is no polarity at 100Mbps).\n **/\n", "func_signal": "s32 e1000e_check_polarity_igp(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 data, offset, mask;\n\n\t/*\n\t * Polarity is determined based on the speed of\n\t * our connection.\n\t */\n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_STATUS, &data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tif ((data & IGP01E1000_PSSR_SPEED_MASK) ==\n\t    IGP01E1000_PSSR_SPEED_1000MBPS) {\n\t\toffset\t= IGP01E1000_PHY_PCS_INIT_REG;\n\t\tmask\t= IGP01E1000_PHY_POLARITY_MASK;\n\t} else {\n\t\t/*\n\t\t * This really only applies to 10Mbps since\n\t\t * there is no polarity for 100Mbps (always 0).\n\t\t */\n\t\toffset\t= IGP01E1000_PHY_PORT_STATUS;\n\t\tmask\t= IGP01E1000_PSSR_POLARITY_REVERSED;\n\t}\n\n\tret_val = e1e_rphy(hw, offset, &data);\n\n\tif (!ret_val)\n\t\tphy->cable_polarity = (data & mask)\n\t\t                      ? e1000_rev_polarity_reversed\n\t\t                      : e1000_rev_polarity_normal;\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_phy_sw_reset - PHY software reset\n *  @hw: pointer to the HW structure\n *\n *  Does a software reset of the PHY by reading the PHY control register and\n *  setting/write the control register reset bit to the PHY.\n **/\n", "func_signal": "s32 e1000e_phy_sw_reset(struct e1000_hw *hw)", "code": "{\n\ts32 ret_val = E1000_SUCCESS;\n\tu16 phy_ctrl;\n\n\tif (!(hw->phy.ops.read_reg))\n\t\tgoto out;\n\n\tret_val = e1e_rphy(hw, PHY_CONTROL, &phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_ctrl |= MII_CR_RESET;\n\tret_val = e1e_wphy(hw, PHY_CONTROL, phy_ctrl);\n\tif (ret_val)\n\t\tgoto out;\n\n\tudelay(1);\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n *  e1000e_phy_force_speed_duplex_igp - Force speed/duplex for igp PHY\n *  @hw: pointer to the HW structure\n *\n *  Calls the PHY setup function to force speed and duplex.  Clears the\n *  auto-crossover to force MDI manually.  Waits for link and returns\n *  successful if link up is successful, else -E1000_ERR_PHY (-2).\n **/\n", "func_signal": "s32 e1000e_phy_force_speed_duplex_igp(struct e1000_hw *hw)", "code": "{\n\tstruct e1000_phy_info *phy = &hw->phy;\n\ts32 ret_val;\n\tu16 phy_data;\n\tbool link;\n\n\tret_val = e1e_rphy(hw, PHY_CONTROL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\te1000e_phy_force_speed_duplex_setup(hw, &phy_data);\n\n\tret_val = e1e_wphy(hw, PHY_CONTROL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\t/*\n\t * Clear Auto-Crossover to force MDI manually.  IGP requires MDI\n\t * forced whenever speed and duplex are forced.\n\t */\n\tret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\tphy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;\n\tphy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;\n\n\tret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);\n\tif (ret_val)\n\t\tgoto out;\n\n\te_dbg(\"IGP PSCR: %X\\n\", phy_data);\n\n\tudelay(1);\n\n\tif (phy->autoneg_wait_to_complete) {\n\t\te_dbg(\"Waiting for forced speed/duplex link on IGP phy.\\n\");\n\n\t\tret_val = e1000e_phy_has_link_generic(hw,\n\t\t                                     PHY_FORCE_LIMIT,\n\t\t                                     100000,\n\t\t                                     &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\n\t\tif (!link)\n\t\t\te_dbg(\"Link taking longer than expected.\\n\");\n\n\t\t/* Try once more */\n\t\tret_val = e1000e_phy_has_link_generic(hw,\n\t\t                                     PHY_FORCE_LIMIT,\n\t\t                                     100000,\n\t\t                                     &link);\n\t\tif (ret_val)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret_val;\n}", "path": "src\\drivers\\net\\e1000e\\e1000e_phy.c", "repo_name": "myri/myri-gPXE", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 7196}
{"docstring": "/**\n * Evaluate the adaptive impulse response.\n */\n", "func_signal": "static void eval_ir(const float *Az, int pitch_lag, float *freq,\n                    float pitch_sharp_factor)", "code": "{\n    float tmp1[SUBFR_SIZE+1], tmp2[LP_FILTER_ORDER+1];\n    int i;\n\n    tmp1[0] = 1.;\n    for (i = 0; i < LP_FILTER_ORDER; i++) {\n        tmp1[i+1] = Az[i] * ff_pow_0_55[i];\n        tmp2[i  ] = Az[i] * ff_pow_0_7 [i];\n    }\n    memset(tmp1 + 11, 0, 37 * sizeof(float));\n\n    ff_celp_lp_synthesis_filterf(freq, tmp2, tmp1, SUBFR_SIZE,\n                                 LP_FILTER_ORDER);\n\n    pitch_sharpening(pitch_lag, pitch_sharp_factor, freq);\n}", "path": "libavcodec\\sipr.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/* ---------------- public code */\n", "func_signal": "static PayloadContext *h264_new_context(void)", "code": "{\n    PayloadContext *data =\n        av_mallocz(sizeof(PayloadContext) +\n                   FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (data) {\n        data->cookie = MAGIC_COOKIE;\n    }\n\n    return data;\n}", "path": "libavformat\\rtpdec_h264.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Check whether the DIRECTMB bitplane is present */\n", "func_signal": "static inline int vc1_has_DIRECTMB_bitplane(VC1Context *v)", "code": "{\n    if (v->dmb_is_raw)\n        return 0;\n    return v->s.pict_type == FF_B_TYPE && !v->bi_type;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/* ---------------- private code */\n", "func_signal": "static int sdp_parse_fmtp_config_h264(AVStream * stream,\n                                      PayloadContext * h264_data,\n                                      char *attr, char *value)", "code": "{\n    AVCodecContext *codec = stream->codec;\n    assert(codec->codec_id == CODEC_ID_H264);\n    assert(h264_data != NULL);\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n           Packetization Mode:\n           0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n           1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n           2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A), and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(codec, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6) {\n            char buffer[3];\n            // 6 characters=3 bytes, in hex.\n            uint8_t profile_idc;\n            uint8_t profile_iop;\n            uint8_t level_idc;\n\n            buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\\0';\n            profile_idc = strtol(buffer, NULL, 16);\n            buffer[0] = value[2]; buffer[1] = value[3];\n            profile_iop = strtol(buffer, NULL, 16);\n            buffer[0] = value[4]; buffer[1] = value[5];\n            level_idc = strtol(buffer, NULL, 16);\n\n            // set the parameters...\n            av_log(codec, AV_LOG_DEBUG,\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n                   profile_idc, profile_iop, level_idc);\n            h264_data->profile_idc = profile_idc;\n            h264_data->profile_iop = profile_iop;\n            h264_data->level_idc = level_idc;\n        }\n    } else  if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        uint8_t start_sequence[]= { 0, 0, 1 };\n        codec->extradata_size= 0;\n        codec->extradata= NULL;\n\n        while (*value) {\n            char base64packet[1024];\n            uint8_t decoded_packet[1024];\n            int packet_size;\n            char *dst = base64packet;\n\n            while (*value && *value != ','\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n                *dst++ = *value++;\n            }\n            *dst++ = '\\0';\n\n            if (*value == ',')\n                value++;\n\n            packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet));\n            if (packet_size > 0) {\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n                                         codec->extradata_size +\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n                if(dest)\n                {\n                    if(codec->extradata_size)\n                    {\n                        // av_realloc?\n                        memcpy(dest, codec->extradata, codec->extradata_size);\n                        av_free(codec->extradata);\n                    }\n\n                    memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence));\n                    memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size);\n                    memset(dest+codec->extradata_size+sizeof(start_sequence)+\n                           packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    codec->extradata= dest;\n                    codec->extradata_size+= sizeof(start_sequence)+packet_size;\n                } else {\n                    av_log(codec, AV_LOG_ERROR, \"Unable to allocate memory for extradata!\");\n                    return AVERROR(ENOMEM);\n                }\n            }\n        }\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\", codec->extradata, codec->extradata_size);\n    }\n    return 0;\n}", "path": "libavformat\\rtpdec_h264.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Reconstruct bitstream PTYPE (7.1.1.4, index into Table-35) */\n", "func_signal": "static int vc1_get_PTYPE(VC1Context *v)", "code": "{\n    MpegEncContext * const s = &v->s;\n    switch (s->pict_type) {\n    case FF_I_TYPE: return 0;\n    case FF_P_TYPE: return v->p_frame_skipped ? 4 : 1;\n    case FF_B_TYPE: return v->bi_type         ? 3 : 2;\n    }\n    return 0;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "//#define DEBUG\n", "func_signal": "static void yuv_a_to_rgba(const uint8_t *ycbcr, const uint8_t *alpha, uint32_t *rgba, int num_values)", "code": "{\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    uint8_t r, g, b;\n    int i, y, cb, cr;\n    int r_add, g_add, b_add;\n\n    for (i = num_values; i > 0; i--) {\n        y = *ycbcr++;\n        cb = *ycbcr++;\n        cr = *ycbcr++;\n        YUV_TO_RGB1_CCIR(cb, cr);\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n        *rgba++ = (*alpha++ << 24) | (r << 16) | (g << 8) | b;\n    }\n}", "path": "libavcodec\\dvdsubdec.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "// return 0 on packet, no more left, 1 on packet, 1 on partial packet...\n", "func_signal": "static int h264_handle_packet(AVFormatContext *ctx,\n                              PayloadContext *data,\n                              AVStream *st,\n                              AVPacket * pkt,\n                              uint32_t * timestamp,\n                              const uint8_t * buf,\n                              int len, int flags)", "code": "{\n    uint8_t nal = buf[0];\n    uint8_t type = (nal & 0x1f);\n    int result= 0;\n    uint8_t start_sequence[]= {0, 0, 1};\n\n#ifdef DEBUG\n    assert(data);\n    assert(data->cookie == MAGIC_COOKIE);\n#endif\n    assert(buf);\n\n    if (type >= 1 && type <= 23)\n        type = 1;              // simplify the case. (these are all the nal types used internally by the h264 codec)\n    switch (type) {\n    case 0:                    // undefined;\n        result= -1;\n        break;\n\n    case 1:\n        av_new_packet(pkt, len+sizeof(start_sequence));\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n        memcpy(pkt->data+sizeof(start_sequence), buf, len);\n#ifdef DEBUG\n        data->packet_types_received[nal & 0x1f]++;\n#endif\n        break;\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n        // consume the STAP-A NAL\n        buf++;\n        len--;\n        // first we are going to figure out the total size....\n        {\n            int pass= 0;\n            int total_length= 0;\n            uint8_t *dst= NULL;\n\n            for(pass= 0; pass<2; pass++) {\n                const uint8_t *src= buf;\n                int src_len= len;\n\n                do {\n                    uint16_t nal_size = AV_RB16(src); // this going to be a problem if unaligned (can it be?)\n\n                    // consume the length of the aggregate...\n                    src += 2;\n                    src_len -= 2;\n\n                    if (nal_size <= src_len) {\n                        if(pass==0) {\n                            // counting...\n                            total_length+= sizeof(start_sequence)+nal_size;\n                        } else {\n                            // copying\n                            assert(dst);\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n                            dst+= sizeof(start_sequence);\n                            memcpy(dst, src, nal_size);\n#ifdef DEBUG\n                            data->packet_types_received[*src & 0x1f]++;\n#endif\n                            dst+= nal_size;\n                        }\n                    } else {\n                        av_log(ctx, AV_LOG_ERROR,\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n                    }\n\n                    // eat what we handled...\n                    src += nal_size;\n                    src_len -= nal_size;\n\n                    if (src_len < 0)\n                        av_log(ctx, AV_LOG_ERROR,\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n                } while (src_len > 2);      // because there could be rtp padding..\n\n                if(pass==0) {\n                    // now we know the total size of the packet (with the start sequences added)\n                    av_new_packet(pkt, total_length);\n                    dst= pkt->data;\n                } else {\n                    assert(dst-pkt->data==total_length);\n                }\n            }\n        }\n        break;\n\n    case 25:                   // STAP-B\n    case 26:                   // MTAP-16\n    case 27:                   // MTAP-24\n    case 29:                   // FU-B\n        av_log(ctx, AV_LOG_ERROR,\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n               type);\n        result= -1;\n        break;\n\n    case 28:                   // FU-A (fragmented nal)\n        buf++;\n        len--;                  // skip the fu_indicator\n        {\n            // these are the same as above, we just redo them here for clarity...\n            uint8_t fu_indicator = nal;\n            uint8_t fu_header = *buf;   // read the fu_header.\n            uint8_t start_bit = fu_header >> 7;\n//            uint8_t end_bit = (fu_header & 0x40) >> 6;\n            uint8_t nal_type = (fu_header & 0x1f);\n            uint8_t reconstructed_nal;\n\n            // reconstruct this packet's true nal; only the data follows..\n            reconstructed_nal = fu_indicator & (0xe0);  // the original nal forbidden bit and NRI are stored in this packet's nal;\n            reconstructed_nal |= nal_type;\n\n            // skip the fu_header...\n            buf++;\n            len--;\n\n#ifdef DEBUG\n            if (start_bit)\n                data->packet_types_received[nal_type]++;\n#endif\n            if(start_bit) {\n                // copy in the start sequence, and the reconstructed nal....\n                av_new_packet(pkt, sizeof(start_sequence)+sizeof(nal)+len);\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n                pkt->data[sizeof(start_sequence)]= reconstructed_nal;\n                memcpy(pkt->data+sizeof(start_sequence)+sizeof(nal), buf, len);\n            } else {\n                av_new_packet(pkt, len);\n                memcpy(pkt->data, buf, len);\n            }\n        }\n        break;\n\n    case 30:                   // undefined\n    case 31:                   // undefined\n    default:\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\", type);\n        result= -1;\n        break;\n    }\n\n    pkt->stream_index = st->index;\n\n    return result;\n}", "path": "libavformat\\rtpdec_h264.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Reconstruct bitstream MVMODE2 (7.1.1.33) */\n", "func_signal": "static inline VAMvModeVC1 vc1_get_MVMODE2(VC1Context *v)", "code": "{\n    if (v->s.pict_type == FF_P_TYPE && v->mv_mode == MV_PMODE_INTENSITY_COMP)\n        return get_VAMvModeVC1(v->mv_mode2);\n    return 0;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/**\n * Extract decoding parameters from the input bitstream.\n * @param parms          parameters structure\n * @param pgb            pointer to initialized GetBitContext structure\n */\n", "func_signal": "static void decode_parameters(SiprParameters* parms, GetBitContext *pgb,\n                              const SiprModeParam *p)", "code": "{\n    int i, j;\n\n    parms->ma_pred_switch           = get_bits(pgb, p->ma_predictor_bits);\n\n    for (i = 0; i < 5; i++)\n        parms->vq_indexes[i]        = get_bits(pgb, p->vq_indexes_bits[i]);\n\n    for (i = 0; i < p->subframe_count; i++) {\n        parms->pitch_delay[i]       = get_bits(pgb, p->pitch_delay_bits[i]);\n        parms->gp_index[i]          = get_bits(pgb, p->gp_index_bits);\n\n        for (j = 0; j < p->number_of_fc_indexes; j++)\n            parms->fc_indexes[i][j] = get_bits(pgb, p->fc_index_bits[j]);\n\n        parms->gc_index[i]          = get_bits(pgb, p->gc_index_bits);\n    }\n}", "path": "libavcodec\\sipr.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/* returns modified base_value */\n", "func_signal": "static inline int wnv1_get_code(WNV1Context *w, int base_value)", "code": "{\n    int v = get_vlc2(&w->gb, code_vlc.table, CODE_VLC_BITS, 1);\n\n    if(v==15)\n        return av_reverse[ get_bits(&w->gb, 8 - w->shift) ];\n    else\n        return base_value + ((v - 7)<<w->shift);\n}", "path": "libavcodec\\wnv1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Check whether the OVERFLAGS bitplane is present */\n", "func_signal": "static inline int vc1_has_OVERFLAGS_bitplane(VC1Context *v)", "code": "{\n    if (v->overflg_is_raw)\n        return 0;\n    return (v->profile == PROFILE_ADVANCED &&\n            (v->s.pict_type == FF_I_TYPE ||\n             (v->s.pict_type == FF_B_TYPE && v->bi_type)) &&\n            (v->overlap && v->pq <= 8) &&\n            v->condover == CONDOVER_SELECT);\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Check whether the SKIPMB bitplane is present */\n", "func_signal": "static inline int vc1_has_SKIPMB_bitplane(VC1Context *v)", "code": "{\n    if (v->skip_is_raw)\n        return 0;\n    return (v->s.pict_type == FF_P_TYPE ||\n            (v->s.pict_type == FF_B_TYPE && !v->bi_type));\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Translate FFmpeg MV modes to VA API */\n", "func_signal": "static int get_VAMvModeVC1(enum MVModes mv_mode)", "code": "{\n    switch (mv_mode) {\n    case MV_PMODE_1MV_HPEL_BILIN: return VAMvMode1MvHalfPelBilinear;\n    case MV_PMODE_1MV:            return VAMvMode1Mv;\n    case MV_PMODE_1MV_HPEL:       return VAMvMode1MvHalfPel;\n    case MV_PMODE_MIXED_MV:       return VAMvModeMixedMv;\n    case MV_PMODE_INTENSITY_COMP: return VAMvModeIntensityCompensation;\n    }\n    return 0;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/**\n * Evaluate the convolution of a vector with a sparse vector.\n */\n", "func_signal": "static void convolute_with_sparse(float *out, const AMRFixed *pulses,\n                                  const float *shape, int length)", "code": "{\n    int i, j;\n\n    memset(out, 0, length*sizeof(float));\n    for (i = 0; i < pulses->n; i++)\n        for (j = pulses->x[i]; j < length; j++)\n            out[j] += pulses->y[i] * shape[j - pulses->x[i]];\n}", "path": "libavcodec\\sipr.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Apply pitch lag to the fixed vector (AMR section 6.1.2). */\n", "func_signal": "static void pitch_sharpening(int pitch_lag_int, float beta,\n                             float *fixed_vector)", "code": "{\n    int i;\n\n    for (i = pitch_lag_int; i < SUBFR_SIZE; i++)\n        fixed_vector[i] += beta * fixed_vector[i - pitch_lag_int];\n}", "path": "libavcodec\\sipr.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/**\n * Apply postfilter, very similar to AMR one.\n */\n", "func_signal": "static void postfilter_5k0(SiprContext *ctx, const float *lpc, float *samples)", "code": "{\n    float buf[SUBFR_SIZE + LP_FILTER_ORDER];\n    float *pole_out = buf + LP_FILTER_ORDER;\n    float lpc_n[LP_FILTER_ORDER];\n    float lpc_d[LP_FILTER_ORDER];\n    int i;\n\n    for (i = 0; i < LP_FILTER_ORDER; i++) {\n        lpc_d[i] = lpc[i] * ff_pow_0_75[i];\n        lpc_n[i] = lpc[i] * ff_pow_0_5 [i];\n    };\n\n    memcpy(pole_out - LP_FILTER_ORDER, ctx->postfilter_mem,\n           LP_FILTER_ORDER*sizeof(float));\n\n    ff_celp_lp_synthesis_filterf(pole_out, lpc_d, samples, SUBFR_SIZE,\n                                 LP_FILTER_ORDER);\n\n    memcpy(ctx->postfilter_mem, pole_out + SUBFR_SIZE - LP_FILTER_ORDER,\n           LP_FILTER_ORDER*sizeof(float));\n\n    ff_tilt_compensation(&ctx->tilt_mem, 0.4, pole_out, SUBFR_SIZE);\n\n    memcpy(pole_out - LP_FILTER_ORDER, ctx->postfilter_mem5k0,\n           LP_FILTER_ORDER*sizeof(*pole_out));\n\n    memcpy(ctx->postfilter_mem5k0, pole_out + SUBFR_SIZE - LP_FILTER_ORDER,\n           LP_FILTER_ORDER*sizeof(*pole_out));\n\n    ff_celp_lp_zero_synthesis_filterf(samples, lpc_n, pole_out, SUBFR_SIZE,\n                                      LP_FILTER_ORDER);\n\n}", "path": "libavcodec\\sipr.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/* return 0 if empty rectangle, 1 if non empty */\n", "func_signal": "static int find_smallest_bounding_rectangle(AVSubtitle *s)", "code": "{\n    uint8_t transp_color[256];\n    int y1, y2, x1, x2, y, w, h, i;\n    uint8_t *bitmap;\n\n    if (s->num_rects == 0 || s->rects == NULL || s->rects[0]->w <= 0 || s->rects[0]->h <= 0)\n        return 0;\n\n    memset(transp_color, 0, 256);\n    for(i = 0; i < s->rects[0]->nb_colors; i++) {\n        if ((((uint32_t*)s->rects[0]->pict.data[1])[i] >> 24) == 0)\n            transp_color[i] = 1;\n    }\n    y1 = 0;\n    while (y1 < s->rects[0]->h && is_transp(s->rects[0]->pict.data[0] + y1 * s->rects[0]->pict.linesize[0],\n                                  1, s->rects[0]->w, transp_color))\n        y1++;\n    if (y1 == s->rects[0]->h) {\n        av_freep(&s->rects[0]->pict.data[0]);\n        s->rects[0]->w = s->rects[0]->h = 0;\n        return 0;\n    }\n\n    y2 = s->rects[0]->h - 1;\n    while (y2 > 0 && is_transp(s->rects[0]->pict.data[0] + y2 * s->rects[0]->pict.linesize[0], 1,\n                               s->rects[0]->w, transp_color))\n        y2--;\n    x1 = 0;\n    while (x1 < (s->rects[0]->w - 1) && is_transp(s->rects[0]->pict.data[0] + x1, s->rects[0]->pict.linesize[0],\n                                        s->rects[0]->h, transp_color))\n        x1++;\n    x2 = s->rects[0]->w - 1;\n    while (x2 > 0 && is_transp(s->rects[0]->pict.data[0] + x2, s->rects[0]->pict.linesize[0], s->rects[0]->h,\n                                  transp_color))\n        x2--;\n    w = x2 - x1 + 1;\n    h = y2 - y1 + 1;\n    bitmap = av_malloc(w * h);\n    if (!bitmap)\n        return 1;\n    for(y = 0; y < h; y++) {\n        memcpy(bitmap + w * y, s->rects[0]->pict.data[0] + x1 + (y1 + y) * s->rects[0]->pict.linesize[0], w);\n    }\n    av_freep(&s->rects[0]->pict.data[0]);\n    s->rects[0]->pict.data[0] = bitmap;\n    s->rects[0]->pict.linesize[0] = w;\n    s->rects[0]->w = w;\n    s->rects[0]->h = h;\n    s->rects[0]->x += x1;\n    s->rects[0]->y += y1;\n    return 1;\n}", "path": "libavcodec\\dvdsubdec.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Pack FFmpeg bitplanes into a VABitPlaneBuffer element */\n", "func_signal": "static inline void vc1_pack_bitplanes(uint8_t *bitplane, int n, const uint8_t *ff_bp[3], int x, int y, int stride)", "code": "{\n    const int bitplane_index = n / 2;\n    const int ff_bp_index = y * stride + x;\n    uint8_t v = 0;\n    if (ff_bp[0])\n        v = ff_bp[0][ff_bp_index];\n    if (ff_bp[1])\n        v |= ff_bp[1][ff_bp_index] << 1;\n    if (ff_bp[2])\n        v |= ff_bp[2][ff_bp_index] << 2;\n    bitplane[bitplane_index] = (bitplane[bitplane_index] << 4) | v;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/** Reconstruct bitstream MVMODE (7.1.1.32) */\n", "func_signal": "static inline VAMvModeVC1 vc1_get_MVMODE(VC1Context *v)", "code": "{\n    if (v->s.pict_type == FF_P_TYPE ||\n        (v->s.pict_type == FF_B_TYPE && !v->bi_type))\n        return get_VAMvModeVC1(v->mv_mode);\n    return 0;\n}", "path": "libavcodec\\vaapi_vc1.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "//CONFIG_ENCODERS\n", "func_signal": "static av_cold int adpcm_decode_init(AVCodecContext * avctx)", "code": "{\n    ADPCMContext *c = avctx->priv_data;\n    unsigned int max_channels = 2;\n\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3:\n        max_channels = 6;\n        break;\n    }\n    if(avctx->channels > max_channels){\n        return -1;\n    }\n\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_CT:\n        c->status[0].step = c->status[1].step = 511;\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->bits_per_coded_sample != 4) {\n            av_log(avctx, AV_LOG_ERROR, \"Only 4-bit ADPCM IMA WAV files are supported\\n\");\n            return -1;\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n        }\n        break;\n    default:\n        break;\n    }\n    avctx->sample_fmt = SAMPLE_FMT_S16;\n    return 0;\n}", "path": "libavcodec\\adpcm.c", "repo_name": "justinruggles/FFmpeg-alsenc", "stars": 8, "license": "other", "language": "c", "size": 33356}
{"docstring": "/*\n** inserts a new key into a hash table; first, check whether key's main \n** position is free. If not, check whether colliding node is in its main \n** position or not: if it is not, move colliding node to an empty place and \n** put new key in its main position; otherwise (colliding node is in its main \n** position), new key goes to an empty position. \n*/\n", "func_signal": "static TValue *newkey (lua_State *L, Table *t, const TValue *key)", "code": "{\n  Node *mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || mp == dummynode) {\n    Node *othern;\n    Node *n = getfreepos(t);  /* get a free place */\n    if (n == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      return luaH_set(L, t, key);  /* re-insert key into grown table */\n    }\n    lua_assert(n != dummynode);\n    othern = mainposition(t, key2tval(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */\n      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */\n      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      gnext(mp) = NULL;  /* now `mp' is free */\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      gnext(n) = gnext(mp);  /* chain new position */\n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;\n  luaC_barriert(L, t, key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** hash for lua_Numbers\n*/\n", "func_signal": "static Node *hashnum (const Table *t, lua_Number n)", "code": "{\n  unsigned int a[numints];\n  int i;\n  if (luai_numeq(n, 0))  /* avoid problems with -0 */\n    return gnode(t, 0);\n  memcpy(a, &n, sizeof(a));\n  for (i = 1; i < numints; i++) a[0] += a[i];\n  return hashmod(t, a[0]);\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\n", "func_signal": "static const char *generic_reader (lua_State *L, void *ud, size_t *size)", "code": "{\n  (void)ud;  /* to avoid warnings */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    *size = 0;\n    return NULL;\n  }\n  else if (lua_isstring(L, -1)) {\n    lua_replace(L, 3);  /* save string in a reserved stack slot */\n    return lua_tolstring(L, 3, size);\n  }\n  else luaL_error(L, \"reader function must return a string\");\n  return NULL;  /* to avoid warnings */\n}", "path": "src\\lua\\src\\lbaselib.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** returns the index of a `key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signalled by -1.\n*/\n", "func_signal": "static int findindex (lua_State *L, Table *t, StkId key)", "code": "{\n  int i;\n  if (ttisnil(key)) return -1;  /* first iteration */\n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */\n    return i-1;  /* yes; that's the index (corrected to C) */\n  else {\n    Node *n = mainposition(t, key);\n    do {  /* check whether `key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in `next' */\n      if (luaO_rawequalObj(key2tval(n), key) ||\n            (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&\n             gcvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n    } while (n);\n    luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));  /* key not found */\n    return 0;  /* to avoid warnings */\n  }\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\n", "func_signal": "static int gctm (lua_State *L)", "code": "{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}", "path": "src\\lua\\src\\loadlib.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** generic allocation routine.\n*/\n", "func_signal": "void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize)", "code": "{\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  block = (*g->frealloc)(g->ud, block, osize, nsize);\n  if (block == NULL && nsize > 0)\n    luaD_throw(L, LUA_ERRMEM);\n  lua_assert((nsize == 0) == (block == NULL));\n  g->totalbytes = (g->totalbytes - osize) + nsize;\n  return block;\n}", "path": "src\\lua\\src\\lmem.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getnum (Table *t, int key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** If your system does not support `stdout', you can just remove this function.\n** If you need, you can define your own `print' function, following this\n** model but changing `fputs' to put the strings at a proper place\n** (a console window or a log file, for instance).\n*/\n", "func_signal": "static int luaB_print (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  lua_getglobal(L, \"tostring\");\n  for (i=1; i<=n; i++) {\n    const char *s;\n    lua_pushvalue(L, -1);  /* function to be called */\n    lua_pushvalue(L, i);   /* value to print */\n    lua_call(L, 1, 1);\n    s = lua_tostring(L, -1);  /* get result */\n    if (s == NULL)\n      return luaL_error(L, LUA_QL(\"tostring\") \" must return a string to \"\n                           LUA_QL(\"print\"));\n    if (i>1) fputs(\"\\t\", stdout);\n    fputs(s, stdout);\n    lua_pop(L, 1);  /* pop result */\n  }\n  fputs(\"\\n\", stdout);\n  return 0;\n}", "path": "src\\lua\\src\\lbaselib.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** returns the `main' position of an element in a table (that is, the index\n** of its hash value)\n*/\n", "func_signal": "static Node *mainposition (const Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TSTRING:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/* converts back */\n", "func_signal": "int luaO_fb2int (int x)", "code": "{\n  int e = (x >> 3) & 31;\n  if (e == 0) return x;\n  else return ((x & 7)+8) << (e - 1);\n}", "path": "src\\lua\\src\\lobject.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/* }====================================================================== */\n", "func_signal": "static void parlist (LexState *ls)", "code": "{\n  /* parlist -> [ param { `,' param } ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  f->is_vararg = 0;\n  if (ls->t.token != ')') {  /* is `parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {  /* param -> NAME */\n          new_localvar(ls, str_checkname(ls), nparams++);\n          break;\n        }\n        case TK_DOTS: {  /* param -> `...' */\n          luaX_next(ls);\n#if defined(LUA_COMPAT_VARARG)\n          /* use `arg' as default name */\n          new_localvarliteral(ls, \"arg\", nparams++);\n          f->is_vararg = VARARG_HASARG | VARARG_NEEDSARG;\n#endif\n          f->is_vararg |= VARARG_ISVARARG;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or \" LUA_QL(\"...\") \" expected\");\n      }\n    } while (!f->is_vararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */\n}", "path": "src\\lua\\src\\lparser.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void auxopen (lua_State *L, const char *name,\n                     lua_CFunction f, lua_CFunction u)", "code": "{\n  lua_pushcfunction(L, u);\n  lua_pushcclosure(L, f, 1);\n  lua_setfield(L, -2, name);\n}", "path": "src\\lua\\src\\lbaselib.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** check whether, in an assignment to a local variable, the local variable\n** is needed in a previous assignment (to a table). If so, save original\n** local value in a safe place and use this safe copy in the previous\n** assignment.\n*/\n", "func_signal": "static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {\n    if (lh->v.k == VINDEXED) {\n      if (lh->v.u.s.info == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.info = extra;  /* previous assignment will use safe copy */\n      }\n      if (lh->v.u.s.aux == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.aux = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */\n    luaK_reserveregs(fs, 1);\n  }\n}", "path": "src\\lua\\src\\lparser.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** returns the index for `key' if `key' is an appropriate key to live in\n** the array part of the table, -1 otherwise.\n*/\n", "func_signal": "static int arrayindex (const TValue *key)", "code": "{\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;  /* `key' did not match some condition */\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n", "func_signal": "static void field (LexState *ls, expdesc *v)", "code": "{\n  /* field -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyreg(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}", "path": "src\\lua\\src\\lparser.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** search function for strings\n*/\n", "func_signal": "const TValue *luaH_getstr (Table *t, TString *key)", "code": "{\n  Node *n = hashstr(t, key);\n  do {  /* check whether `key' is somewhere in the chain */\n    if (ttisstring(gkey(n)) && rawtsvalue(gkey(n)) == key)\n      return gval(n);  /* that's it */\n    else n = gnext(n);\n  } while (n);\n  return luaO_nilobject;\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** main search function\n*/\n", "func_signal": "const TValue *luaH_get (Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));\n    case LUA_TNUMBER: {\n      int k;\n      lua_Number n = nvalue(key);\n      lua_number2int(k, n);\n      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */\n        return luaH_getnum(t, k);  /* use specialized version */\n      /* else go through */\n    }\n    default: {\n      Node *n = mainposition(t, key);\n      do {  /* check whether `key' is somewhere in the chain */\n        if (luaO_rawequalObj(key2tval(n), key))\n          return gval(n);  /* that's it */\n        else n = gnext(n);\n      } while (n);\n      return luaO_nilobject;\n    }\n  }\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** }=============================================================\n*/\n", "func_signal": "Table *luaH_new (lua_State *L, int narray, int nhash)", "code": "{\n  Table *t = luaM_new(L, Table);\n  luaC_link(L, obj2gco(t), LUA_TTABLE);\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  /* temporary values (kept only if some malloc fails) */\n  t->array = NULL;\n  t->sizearray = 0;\n  t->lsizenode = 0;\n  t->node = cast(Node *, dummynode);\n  setarrayvector(L, t, narray);\n  setnodevector(L, t, nhash);\n  return t;\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/* this function handles only `%d', `%c', %f, %p, and `%s' formats */\n", "func_signal": "const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp)", "code": "{\n  int n = 1;\n  pushstr(L, \"\");\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));\n    incr_top(L);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s);\n        break;\n      }\n      case 'c': {\n        char buff[2];\n        buff[0] = cast(char, va_arg(argp, int));\n        buff[1] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n      case 'd': {\n        setnvalue(L->top, cast_num(va_arg(argp, int)));\n        incr_top(L);\n        break;\n      }\n      case 'f': {\n        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));\n        incr_top(L);\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */\n        sprintf(buff, \"%p\", va_arg(argp, void *));\n        pushstr(L, buff);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\");\n        break;\n      }\n      default: {\n        char buff[3];\n        buff[0] = '%';\n        buff[1] = *(e+1);\n        buff[2] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  pushstr(L, fmt);\n  luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);\n  L->top -= n;\n  return svalue(L->top - 1);\n}", "path": "src\\lua\\src\\lobject.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "int luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (t->node == dummynode)  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "src\\lua\\src\\ltable.c", "repo_name": "sole/luisita", "stars": 8, "license": "None", "language": "c", "size": 1116}
{"docstring": "/*\n * Read a block from a pool and print it out.  The syntax of the\n * block descriptor is:\n *\n *\tpool:vdev_specifier:offset:size[:flags]\n *\n *\tpool           - The name of the pool you wish to read from\n *\tvdev_specifier - Which vdev (see comment for zdb_vdev_lookup)\n *\toffset         - offset, in hex, in bytes\n *\tsize           - Amount of data to read, in hex, in bytes\n *\tflags          - A string of characters specifying options\n *\t\t b: Decode a blkptr at given offset within block\n *\t\t*c: Calculate and display checksums\n *\t\t d: Decompress data before dumping\n *\t\t e: Byteswap data before dumping\n *\t\t g: Display data as a gang block header\n *\t\t i: Display as an indirect block\n *\t\t p: Do I/O to physical offset\n *\t\t r: Dump raw data to stdout\n *\n *              * = not yet implemented\n */\n", "func_signal": "static void\nzdb_read_block(char *thing, spa_t *spa)", "code": "{\n\tblkptr_t blk, *bp = &blk;\n\tdva_t *dva = bp->blk_dva;\n\tint flags = 0;\n\tuint64_t offset = 0, size = 0, psize = 0, lsize = 0, blkptr_offset = 0;\n\tzio_t *zio;\n\tvdev_t *vd;\n\tvoid *pbuf, *lbuf, *buf;\n\tchar *s, *p, *dup, *vdev, *flagstr;\n\tint i, error;\n\n\tdup = strdup(thing);\n\ts = strtok(dup, \":\");\n\tvdev = s ? s : \"\";\n\ts = strtok(NULL, \":\");\n\toffset = strtoull(s ? s : \"\", NULL, 16);\n\ts = strtok(NULL, \":\");\n\tsize = strtoull(s ? s : \"\", NULL, 16);\n\ts = strtok(NULL, \":\");\n\tflagstr = s ? s : \"\";\n\n\ts = NULL;\n\tif (size == 0)\n\t\ts = \"size must not be zero\";\n\tif (!IS_P2ALIGNED(size, DEV_BSIZE))\n\t\ts = \"size must be a multiple of sector size\";\n\tif (!IS_P2ALIGNED(offset, DEV_BSIZE))\n\t\ts = \"offset must be a multiple of sector size\";\n\tif (s) {\n\t\t(void) printf(\"Invalid block specifier: %s  - %s\\n\", thing, s);\n\t\tfree(dup);\n\t\treturn;\n\t}\n\n\tfor (s = strtok(flagstr, \":\"); s; s = strtok(NULL, \":\")) {\n\t\tfor (i = 0; flagstr[i]; i++) {\n\t\t\tint bit = flagbits[(uchar_t)flagstr[i]];\n\n\t\t\tif (bit == 0) {\n\t\t\t\t(void) printf(\"***Invalid flag: %c\\n\",\n\t\t\t\t    flagstr[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflags |= bit;\n\n\t\t\t/* If it's not something with an argument, keep going */\n\t\t\tif ((bit & (ZDB_FLAG_CHECKSUM |\n\t\t\t    ZDB_FLAG_PRINT_BLKPTR)) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tp = &flagstr[i + 1];\n\t\t\tif (bit == ZDB_FLAG_PRINT_BLKPTR)\n\t\t\t\tblkptr_offset = strtoull(p, &p, 16);\n\t\t\tif (*p != ':' && *p != '\\0') {\n\t\t\t\t(void) printf(\"***Invalid flag arg: '%s'\\n\", s);\n\t\t\t\tfree(dup);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvd = zdb_vdev_lookup(spa->spa_root_vdev, vdev);\n\tif (vd == NULL) {\n\t\t(void) printf(\"***Invalid vdev: %s\\n\", vdev);\n\t\tfree(dup);\n\t\treturn;\n\t} else {\n\t\tif (vd->vdev_path)\n\t\t\t(void) fprintf(stderr, \"Found vdev: %s\\n\",\n\t\t\t    vd->vdev_path);\n\t\telse\n\t\t\t(void) fprintf(stderr, \"Found vdev type: %s\\n\",\n\t\t\t    vd->vdev_ops->vdev_op_type);\n\t}\n\n\tpsize = size;\n\tlsize = size;\n\n\tpbuf = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\tlbuf = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\n\tBP_ZERO(bp);\n\n\tDVA_SET_VDEV(&dva[0], vd->vdev_id);\n\tDVA_SET_OFFSET(&dva[0], offset);\n\tDVA_SET_GANG(&dva[0], !!(flags & ZDB_FLAG_GBH));\n\tDVA_SET_ASIZE(&dva[0], vdev_psize_to_asize(vd, psize));\n\n\tBP_SET_BIRTH(bp, TXG_INITIAL, TXG_INITIAL);\n\n\tBP_SET_LSIZE(bp, lsize);\n\tBP_SET_PSIZE(bp, psize);\n\tBP_SET_COMPRESS(bp, ZIO_COMPRESS_OFF);\n\tBP_SET_CHECKSUM(bp, ZIO_CHECKSUM_OFF);\n\tBP_SET_TYPE(bp, DMU_OT_NONE);\n\tBP_SET_LEVEL(bp, 0);\n\tBP_SET_DEDUP(bp, 0);\n\tBP_SET_BYTEORDER(bp, ZFS_HOST_BYTEORDER);\n\n\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\tzio = zio_root(spa, NULL, NULL, 0);\n\n\tif (vd == vd->vdev_top) {\n\t\t/*\n\t\t * Treat this as a normal block read.\n\t\t */\n\t\tzio_nowait(zio_read(zio, spa, bp, pbuf, psize, NULL, NULL,\n\t\t    ZIO_PRIORITY_SYNC_READ,\n\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW, NULL));\n\t} else {\n\t\t/*\n\t\t * Treat this as a vdev child I/O.\n\t\t */\n\t\tzio_nowait(zio_vdev_child_io(zio, bp, vd, offset, pbuf, psize,\n\t\t    ZIO_TYPE_READ, ZIO_PRIORITY_SYNC_READ,\n\t\t    ZIO_FLAG_DONT_CACHE | ZIO_FLAG_DONT_QUEUE |\n\t\t    ZIO_FLAG_DONT_PROPAGATE | ZIO_FLAG_DONT_RETRY |\n\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW, NULL, NULL));\n\t}\n\n\terror = zio_wait(zio);\n\tspa_config_exit(spa, SCL_STATE, FTAG);\n\n\tif (error) {\n\t\t(void) printf(\"Read of %s failed, error: %d\\n\", thing, error);\n\t\tgoto out;\n\t}\n\n\tif (flags & ZDB_FLAG_DECOMPRESS) {\n\t\t/*\n\t\t * We don't know how the data was compressed, so just try\n\t\t * every decompress function at every inflated blocksize.\n\t\t */\n\t\tenum zio_compress c;\n\t\tvoid *pbuf2 = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\t\tvoid *lbuf2 = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\n\t\tbcopy(pbuf, pbuf2, psize);\n\n\t\tVERIFY(random_get_pseudo_bytes((uint8_t *)pbuf + psize,\n\t\t    SPA_MAXBLOCKSIZE - psize) == 0);\n\n\t\tVERIFY(random_get_pseudo_bytes((uint8_t *)pbuf2 + psize,\n\t\t    SPA_MAXBLOCKSIZE - psize) == 0);\n\n\t\tfor (lsize = SPA_MAXBLOCKSIZE; lsize > psize;\n\t\t    lsize -= SPA_MINBLOCKSIZE) {\n\t\t\tfor (c = 0; c < ZIO_COMPRESS_FUNCTIONS; c++) {\n\t\t\t\tif (zio_decompress_data(c, pbuf, lbuf,\n\t\t\t\t    psize, lsize) == 0 &&\n\t\t\t\t    zio_decompress_data(c, pbuf2, lbuf2,\n\t\t\t\t    psize, lsize) == 0 &&\n\t\t\t\t    bcmp(lbuf, lbuf2, lsize) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c != ZIO_COMPRESS_FUNCTIONS)\n\t\t\t\tbreak;\n\t\t\tlsize -= SPA_MINBLOCKSIZE;\n\t\t}\n\n\t\tumem_free(pbuf2, SPA_MAXBLOCKSIZE);\n\t\tumem_free(lbuf2, SPA_MAXBLOCKSIZE);\n\n\t\tif (lsize <= psize) {\n\t\t\t(void) printf(\"Decompress of %s failed\\n\", thing);\n\t\t\tgoto out;\n\t\t}\n\t\tbuf = lbuf;\n\t\tsize = lsize;\n\t} else {\n\t\tbuf = pbuf;\n\t\tsize = psize;\n\t}\n\n\tif (flags & ZDB_FLAG_PRINT_BLKPTR)\n\t\tzdb_print_blkptr((blkptr_t *)(void *)\n\t\t    ((uintptr_t)buf + (uintptr_t)blkptr_offset), flags);\n\telse if (flags & ZDB_FLAG_RAW)\n\t\tzdb_dump_block_raw(buf, size, flags);\n\telse if (flags & ZDB_FLAG_INDIRECT)\n\t\tzdb_dump_indirect((blkptr_t *)buf, size / sizeof (blkptr_t),\n\t\t    flags);\n\telse if (flags & ZDB_FLAG_GBH)\n\t\tzdb_dump_gbh(buf, flags);\n\telse\n\t\tzdb_dump_block(thing, buf, size, flags);\n\nout:\n\tumem_free(pbuf, SPA_MAXBLOCKSIZE);\n\tumem_free(lbuf, SPA_MAXBLOCKSIZE);\n\tfree(dup);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * zn may be NULL; if not specified, it will be computed if needed.\n * See also the comment above zap_entry_normalization_conflict().\n */\n", "func_signal": "static boolean_t\nmzap_normalization_conflict(zap_t *zap, zap_name_t *zn, mzap_ent_t *mze)", "code": "{\n\tmzap_ent_t *other;\n\tint direction = AVL_BEFORE;\n\tboolean_t allocdzn = B_FALSE;\n\n\tif (zap->zap_normflags == 0)\n\t\treturn (B_FALSE);\n\nagain:\n\tfor (other = avl_walk(&zap->zap_m.zap_avl, mze, direction);\n\t    other && other->mze_hash == mze->mze_hash;\n\t    other = avl_walk(&zap->zap_m.zap_avl, other, direction)) {\n\n\t\tif (zn == NULL) {\n\t\t\tzn = zap_name_alloc(zap, MZE_PHYS(zap, mze)->mze_name,\n\t\t\t    MT_FIRST);\n\t\t\tallocdzn = B_TRUE;\n\t\t}\n\t\tif (zap_match(zn, MZE_PHYS(zap, other)->mze_name)) {\n\t\t\tif (allocdzn)\n\t\t\t\tzap_name_free(zn);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tif (direction == AVL_BEFORE) {\n\t\tdirection = AVL_AFTER;\n\t\tgoto again;\n\t}\n\n\tif (allocdzn)\n\t\tzap_name_free(zn);\n\treturn (B_FALSE);\n}", "path": "src\\lib\\libzpool\\zfs\\zap_micro.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\ndump_bpobj_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)", "code": "{\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tASSERT(bp->blk_birth != 0);\n\tsprintf_blkptr_compact(blkbuf, bp);\n\t(void) printf(\"\\t%s\\n\", blkbuf);\n\treturn (0);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * print uid or gid information.\n * For normal POSIX id just the id is printed in decimal format.\n * For CIFS files with FUID the fuid is printed in hex followed by\n * the doman-rid string.\n */\n", "func_signal": "static void\nprint_idstr(uint64_t id, const char *id_type)", "code": "{\n\tif (FUID_INDEX(id)) {\n\t\tchar *domain;\n\n\t\tdomain = zfs_fuid_idx_domain(&idx_tree, FUID_INDEX(id));\n\t\t(void) printf(\"\\t%s     %llx [%s-%d]\\n\", id_type,\n\t\t    (u_longlong_t)id, domain, (int)FUID_RID(id));\n\t} else {\n\t\t(void) printf(\"\\t%s     %llu\\n\", id_type, (u_longlong_t)id);\n\t}\n\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\nvdev_missing(uint64_t state, uint64_t aux, uint64_t errs)", "code": "{\n\treturn (state == VDEV_STATE_CANT_OPEN &&\n\t    aux == VDEV_AUX_OPEN_FAILED);\n}", "path": "src\\lib\\libzfs\\libzfs_status.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_dsl_dir(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tdsl_dir_phys_t *dd = data;\n\ttime_t crtime;\n\tchar nice[32];\n\n\tif (dd == NULL)\n\t\treturn;\n\n\tASSERT3U(size, >=, sizeof (dsl_dir_phys_t));\n\n\tcrtime = dd->dd_creation_time;\n\t(void) printf(\"\\t\\tcreation_time = %s\", ctime(&crtime));\n\t(void) printf(\"\\t\\thead_dataset_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_head_dataset_obj);\n\t(void) printf(\"\\t\\tparent_dir_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_parent_obj);\n\t(void) printf(\"\\t\\torigin_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_origin_obj);\n\t(void) printf(\"\\t\\tchild_dir_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_child_dir_zapobj);\n\tzdb_nicenum(dd->dd_used_bytes, nice);\n\t(void) printf(\"\\t\\tused_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_compressed_bytes, nice);\n\t(void) printf(\"\\t\\tcompressed_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_uncompressed_bytes, nice);\n\t(void) printf(\"\\t\\tuncompressed_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_quota, nice);\n\t(void) printf(\"\\t\\tquota = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_reserved, nice);\n\t(void) printf(\"\\t\\treserved = %s\\n\", nice);\n\t(void) printf(\"\\t\\tprops_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_props_zapobj);\n\t(void) printf(\"\\t\\tdeleg_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_deleg_zapobj);\n\t(void) printf(\"\\t\\tflags = %llx\\n\",\n\t    (u_longlong_t)dd->dd_flags);\n\n#define\tDO(which) \\\n\tzdb_nicenum(dd->dd_used_breakdown[DD_USED_ ## which], nice); \\\n\t(void) printf(\"\\t\\tused_breakdown[\" #which \"] = %s\\n\", nice)\n\tDO(HEAD);\n\tDO(SNAP);\n\tDO(CHILD);\n\tDO(CHILD_RSRV);\n\tDO(REFRSRV);\n#undef DO\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * Active pool health status.\n *\n * To determine the status for a pool, we make several passes over the config,\n * picking the most egregious error we find.  In order of importance, we do the\n * following:\n *\n *\t- Check for a complete and valid configuration\n *\t- Look for any faulted or missing devices in a non-replicated config\n *\t- Check for any data errors\n *\t- Check for any faulted or missing devices in a replicated config\n *\t- Look for any devices showing errors\n *\t- Check for any resilvering devices\n *\n * There can obviously be multiple errors within a single pool, so this routine\n * only picks the most damaging of all the current errors to report.\n */\n", "func_signal": "static zpool_status_t\ncheck_status(nvlist_t *config, boolean_t isimport)", "code": "{\n\tnvlist_t *nvroot;\n\tvdev_stat_t *vs;\n\tpool_scan_stat_t *ps = NULL;\n\tuint_t vsc, psc;\n\tuint64_t nerr;\n\tuint64_t version;\n\tuint64_t stateval;\n\tuint64_t suspended;\n\tuint64_t hostid = 0;\n\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t    &version) == 0);\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\tverify(nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &vsc) == 0);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t    &stateval) == 0);\n\n\t/*\n\t * Currently resilvering a vdev\n\t */\n\t(void) nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_SCAN_STATS,\n\t    (uint64_t **)&ps, &psc);\n\tif (ps && ps->pss_func == POOL_SCAN_RESILVER &&\n\t    ps->pss_state == DSS_SCANNING)\n\t\treturn (ZPOOL_STATUS_RESILVERING);\n\n\t/*\n\t * Pool last accessed by another system.\n\t */\n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_HOSTID, &hostid);\n\tif (hostid != 0 && (unsigned long)hostid != gethostid() &&\n\t    stateval == POOL_STATE_ACTIVE)\n\t\treturn (ZPOOL_STATUS_HOSTID_MISMATCH);\n\n\t/*\n\t * Newer on-disk version.\n\t */\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_VERSION_NEWER)\n\t\treturn (ZPOOL_STATUS_VERSION_NEWER);\n\n\t/*\n\t * Check that the config is complete.\n\t */\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_BAD_GUID_SUM)\n\t\treturn (ZPOOL_STATUS_BAD_GUID_SUM);\n\n\t/*\n\t * Check whether the pool has suspended due to failed I/O.\n\t */\n\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_SUSPENDED,\n\t    &suspended) == 0) {\n\t\tif (suspended == ZIO_FAILURE_MODE_CONTINUE)\n\t\t\treturn (ZPOOL_STATUS_IO_FAILURE_CONTINUE);\n\t\treturn (ZPOOL_STATUS_IO_FAILURE_WAIT);\n\t}\n\n\t/*\n\t * Could not read a log.\n\t */\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_BAD_LOG) {\n\t\treturn (ZPOOL_STATUS_BAD_LOG);\n\t}\n\n\t/*\n\t * Bad devices in non-replicated config.\n\t */\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_faulted))\n\t\treturn (ZPOOL_STATUS_FAULTED_DEV_NR);\n\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_missing))\n\t\treturn (ZPOOL_STATUS_MISSING_DEV_NR);\n\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_broken))\n\t\treturn (ZPOOL_STATUS_CORRUPT_LABEL_NR);\n\n\t/*\n\t * Corrupted pool metadata\n\t */\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_CORRUPT_DATA)\n\t\treturn (ZPOOL_STATUS_CORRUPT_POOL);\n\n\t/*\n\t * Persistent data errors.\n\t */\n\tif (!isimport) {\n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_ERRCOUNT,\n\t\t    &nerr) == 0 && nerr != 0)\n\t\t\treturn (ZPOOL_STATUS_CORRUPT_DATA);\n\t}\n\n\t/*\n\t * Missing devices in a replicated config.\n\t */\n\tif (find_vdev_problem(nvroot, vdev_faulted))\n\t\treturn (ZPOOL_STATUS_FAULTED_DEV_R);\n\tif (find_vdev_problem(nvroot, vdev_missing))\n\t\treturn (ZPOOL_STATUS_MISSING_DEV_R);\n\tif (find_vdev_problem(nvroot, vdev_broken))\n\t\treturn (ZPOOL_STATUS_CORRUPT_LABEL_R);\n\n\t/*\n\t * Devices with errors\n\t */\n\tif (!isimport && find_vdev_problem(nvroot, vdev_errors))\n\t\treturn (ZPOOL_STATUS_FAILING_DEV);\n\n\t/*\n\t * Offlined devices\n\t */\n\tif (find_vdev_problem(nvroot, vdev_offlined))\n\t\treturn (ZPOOL_STATUS_OFFLINE_DEV);\n\n\t/*\n\t * Removed device\n\t */\n\tif (find_vdev_problem(nvroot, vdev_removed))\n\t\treturn (ZPOOL_STATUS_REMOVED_DEV);\n\n\t/*\n\t * Outdated, but usable, version\n\t */\n\tif (version < SPA_VERSION)\n\t\treturn (ZPOOL_STATUS_VERSION_OLDER);\n\n\treturn (ZPOOL_STATUS_OK);\n}", "path": "src\\lib\\libzfs\\libzfs_status.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\nzdb_ddt_add_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    arc_buf_t *pbuf, const zbookmark_t *zb, const dnode_phys_t *dnp, void *arg)", "code": "{\n\tavl_tree_t *t = arg;\n\tavl_index_t where;\n\tzdb_ddt_entry_t *zdde, zdde_search;\n\n\tif (bp == NULL)\n\t\treturn (0);\n\n\tif (dump_opt['S'] > 1 && zb->zb_level == ZB_ROOT_LEVEL) {\n\t\t(void) printf(\"traversing objset %llu, %llu objects, \"\n\t\t    \"%lu blocks so far\\n\",\n\t\t    (u_longlong_t)zb->zb_objset,\n\t\t    (u_longlong_t)bp->blk_fill,\n\t\t    avl_numnodes(t));\n\t}\n\n\tif (BP_IS_HOLE(bp) || BP_GET_CHECKSUM(bp) == ZIO_CHECKSUM_OFF ||\n\t    BP_GET_LEVEL(bp) > 0 || dmu_ot[BP_GET_TYPE(bp)].ot_metadata)\n\t\treturn (0);\n\n\tddt_key_fill(&zdde_search.zdde_key, bp);\n\n\tzdde = avl_find(t, &zdde_search, &where);\n\n\tif (zdde == NULL) {\n\t\tzdde = umem_zalloc(sizeof (*zdde), UMEM_NOFAIL);\n\t\tzdde->zdde_key = zdde_search.zdde_key;\n\t\tavl_insert(t, zdde, where);\n\t}\n\n\tzdde->zdde_ref_blocks += 1;\n\tzdde->zdde_ref_lsize += BP_GET_LSIZE(bp);\n\tzdde->zdde_ref_psize += BP_GET_PSIZE(bp);\n\tzdde->zdde_ref_dsize += bp_get_dsize_sync(spa, bp);\n\n\treturn (0);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_sa_attrs(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = \", attr.za_name);\n\t\tif (attr.za_num_integers == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t(void) printf(\" %llx : [%d:%d:%d]\\n\",\n\t\t    (u_longlong_t)attr.za_first_integer,\n\t\t    (int)ATTR_LENGTH(attr.za_first_integer),\n\t\t    (int)ATTR_BSWAP(attr.za_first_integer),\n\t\t    (int)ATTR_NUM(attr.za_first_integer));\n\t}\n\tzap_cursor_fini(&zc);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_znode(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tchar path[MAXPATHLEN * 2];\t/* allow for xattr and failure prefix */\n\tsa_handle_t *hdl;\n\tuint64_t xattr, rdev, gen;\n\tuint64_t uid, gid, mode, fsize, parent, links;\n\tuint64_t pflags;\n\tuint64_t acctm[2], modtm[2], chgtm[2], crtm[2];\n\ttime_t z_crtime, z_atime, z_mtime, z_ctime;\n\tsa_bulk_attr_t bulk[12];\n\tint idx = 0;\n\tint error;\n\n\tif (!sa_loaded) {\n\t\tuint64_t sa_attrs = 0;\n\t\tuint64_t version;\n\n\t\tVERIFY(zap_lookup(os, MASTER_NODE_OBJ, ZPL_VERSION_STR,\n\t\t    8, 1, &version) == 0);\n\t\tif (version >= ZPL_VERSION_SA) {\n\t\t\tVERIFY(zap_lookup(os, MASTER_NODE_OBJ, ZFS_SA_ATTRS,\n\t\t\t    8, 1, &sa_attrs) == 0);\n\t\t}\n\t\tif ((error = sa_setup(os, sa_attrs, zfs_attr_table,\n\t\t    ZPL_END, &sa_attr_table)) != 0) {\n\t\t\t(void) printf(\"sa_setup failed errno %d, can't \"\n\t\t\t    \"display znode contents\\n\", error);\n\t\t\treturn;\n\t\t}\n\t\tsa_loaded = B_TRUE;\n\t}\n\n\tif (sa_handle_get(os, object, NULL, SA_HDL_PRIVATE, &hdl)) {\n\t\t(void) printf(\"Failed to get handle for SA znode\\n\");\n\t\treturn;\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_UID], NULL, &uid, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_GID], NULL, &gid, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_LINKS], NULL,\n\t    &links, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_GEN], NULL, &gen, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_MODE], NULL,\n\t    &mode, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_PARENT],\n\t    NULL, &parent, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_SIZE], NULL,\n\t    &fsize, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_ATIME], NULL,\n\t    acctm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_MTIME], NULL,\n\t    modtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_CRTIME], NULL,\n\t    crtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_CTIME], NULL,\n\t    chgtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_FLAGS], NULL,\n\t    &pflags, 8);\n\n\tif (sa_bulk_lookup(hdl, bulk, idx)) {\n\t\t(void) sa_handle_destroy(hdl);\n\t\treturn;\n\t}\n\n\terror = zfs_obj_to_path(os, object, path, sizeof (path));\n\tif (error != 0) {\n\t\t(void) snprintf(path, sizeof (path), \"\\?\\?\\?<object#%llu>\",\n\t\t    (u_longlong_t)object);\n\t}\n\tif (dump_opt['d'] < 3) {\n\t\t(void) printf(\"\\t%s\\n\", path);\n\t\t(void) sa_handle_destroy(hdl);\n\t\treturn;\n\t}\n\n\tz_crtime = (time_t)crtm[0];\n\tz_atime = (time_t)acctm[0];\n\tz_mtime = (time_t)modtm[0];\n\tz_ctime = (time_t)chgtm[0];\n\n\t(void) printf(\"\\tpath\t%s\\n\", path);\n\tdump_uidgid(os, uid, gid);\n\t(void) printf(\"\\tatime\t%s\", ctime(&z_atime));\n\t(void) printf(\"\\tmtime\t%s\", ctime(&z_mtime));\n\t(void) printf(\"\\tctime\t%s\", ctime(&z_ctime));\n\t(void) printf(\"\\tcrtime\t%s\", ctime(&z_crtime));\n\t(void) printf(\"\\tgen\t%llu\\n\", (u_longlong_t)gen);\n\t(void) printf(\"\\tmode\t%llo\\n\", (u_longlong_t)mode);\n\t(void) printf(\"\\tsize\t%llu\\n\", (u_longlong_t)fsize);\n\t(void) printf(\"\\tparent\t%llu\\n\", (u_longlong_t)parent);\n\t(void) printf(\"\\tlinks\t%llu\\n\", (u_longlong_t)links);\n\t(void) printf(\"\\tpflags\t%llx\\n\", (u_longlong_t)pflags);\n\tif (sa_lookup(hdl, sa_attr_table[ZPL_XATTR], &xattr,\n\t    sizeof (uint64_t)) == 0)\n\t\t(void) printf(\"\\txattr\t%llu\\n\", (u_longlong_t)xattr);\n\tif (sa_lookup(hdl, sa_attr_table[ZPL_RDEV], &rdev,\n\t    sizeof (uint64_t)) == 0)\n\t\t(void) printf(\"\\trdev\t0x%016llx\\n\", (u_longlong_t)rdev);\n\tsa_handle_destroy(hdl);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_sa_layouts(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tuint16_t *layout_attrs;\n\tint i;\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = [\", attr.za_name);\n\t\tif (attr.za_num_integers == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVERIFY(attr.za_integer_length == 2);\n\t\tlayout_attrs = umem_zalloc(attr.za_num_integers *\n\t\t    attr.za_integer_length, UMEM_NOFAIL);\n\n\t\tVERIFY(zap_lookup(os, object, attr.za_name,\n\t\t    attr.za_integer_length,\n\t\t    attr.za_num_integers, layout_attrs) == 0);\n\n\t\tfor (i = 0; i != attr.za_num_integers; i++)\n\t\t\t(void) printf(\" %d \", (int)layout_attrs[i]);\n\t\t(void) printf(\"]\\n\");\n\t\tumem_free(layout_attrs,\n\t\t    attr.za_num_integers * attr.za_integer_length);\n\t}\n\tzap_cursor_fini(&zc);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * Detect if any leaf devices that have seen errors or could not be opened.\n */\n", "func_signal": "static boolean_t\nfind_vdev_problem(nvlist_t *vdev, int (*func)(uint64_t, uint64_t, uint64_t))", "code": "{\n\tnvlist_t **child;\n\tvdev_stat_t *vs;\n\tuint_t c, children;\n\tchar *type;\n\n\t/*\n\t * Ignore problems within a 'replacing' vdev, since we're presumably in\n\t * the process of repairing any such errors, and don't want to call them\n\t * out again.  We'll pick up the fact that a resilver is happening\n\t * later.\n\t */\n\tverify(nvlist_lookup_string(vdev, ZPOOL_CONFIG_TYPE, &type) == 0);\n\tif (strcmp(type, VDEV_TYPE_REPLACING) == 0)\n\t\treturn (B_FALSE);\n\n\tif (nvlist_lookup_nvlist_array(vdev, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (find_vdev_problem(child[c], func))\n\t\t\t\treturn (B_TRUE);\n\t} else {\n\t\tverify(nvlist_lookup_uint64_array(vdev, ZPOOL_CONFIG_VDEV_STATS,\n\t\t    (uint64_t **)&vs, &c) == 0);\n\n\t\tif (func(vs->vs_state, vs->vs_aux,\n\t\t    vs->vs_read_errors +\n\t\t    vs->vs_write_errors +\n\t\t    vs->vs_checksum_errors))\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}", "path": "src\\lib\\libzfs\\libzfs_status.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * Called for usage errors that are discovered after a call to spa_open(),\n * dmu_bonus_hold(), or pool_match().  abort() is called for other errors.\n */\n", "func_signal": "static void\nfatal(const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void) fprintf(stderr, \"%s: \", cmdname);\n\t(void) vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\t(void) fprintf(stderr, \"\\n\");\n\n\texit(1);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_indirect(dnode_t *dn)", "code": "{\n\tdnode_phys_t *dnp = dn->dn_phys;\n\tint j;\n\tzbookmark_t czb;\n\n\t(void) printf(\"Indirect blocks:\\n\");\n\n\tSET_BOOKMARK(&czb, dmu_objset_id(dn->dn_objset),\n\t    dn->dn_object, dnp->dn_nlevels - 1, 0);\n\tfor (j = 0; j < dnp->dn_nblkptr; j++) {\n\t\tczb.zb_blkid = j;\n\t\t(void) visit_indirect(dmu_objset_spa(dn->dn_objset), dnp,\n\t\t    &dnp->dn_blkptr[j], &czb);\n\t}\n\n\t(void) printf(\"\\n\");\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_zpldir(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tconst char *typenames[] = {\n\t\t/* 0 */ \"not specified\",\n\t\t/* 1 */ \"FIFO\",\n\t\t/* 2 */ \"Character Device\",\n\t\t/* 3 */ \"3 (invalid)\",\n\t\t/* 4 */ \"Directory\",\n\t\t/* 5 */ \"5 (invalid)\",\n\t\t/* 6 */ \"Block Device\",\n\t\t/* 7 */ \"7 (invalid)\",\n\t\t/* 8 */ \"Regular File\",\n\t\t/* 9 */ \"9 (invalid)\",\n\t\t/* 10 */ \"Symbolic Link\",\n\t\t/* 11 */ \"11 (invalid)\",\n\t\t/* 12 */ \"Socket\",\n\t\t/* 13 */ \"Door\",\n\t\t/* 14 */ \"Event Port\",\n\t\t/* 15 */ \"15 (invalid)\",\n\t};\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = %lld (type: %s)\\n\",\n\t\t    attr.za_name, ZFS_DIRENT_OBJ(attr.za_first_integer),\n\t\t    typenames[ZFS_DIRENT_TYPE(attr.za_first_integer)]);\n\t}\n\tzap_cursor_fini(&zc);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*\n * Routines for manipulating attributes.\n */\n", "func_signal": "int\nzap_lookup(objset_t *os, uint64_t zapobj, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf)", "code": "{\n\treturn (zap_lookup_norm(os, zapobj, name, integer_size,\n\t    num_integers, buf, MT_EXACT, NULL, 0, NULL));\n}", "path": "src\\lib\\libzpool\\zfs\\zap_micro.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndump_dsl_dataset(objset_t *os, uint64_t object, void *data, size_t size)", "code": "{\n\tdsl_dataset_phys_t *ds = data;\n\ttime_t crtime;\n\tchar used[32], compressed[32], uncompressed[32], unique[32];\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tif (ds == NULL)\n\t\treturn;\n\n\tASSERT(size == sizeof (*ds));\n\tcrtime = ds->ds_creation_time;\n\tzdb_nicenum(ds->ds_used_bytes, used);\n\tzdb_nicenum(ds->ds_compressed_bytes, compressed);\n\tzdb_nicenum(ds->ds_uncompressed_bytes, uncompressed);\n\tzdb_nicenum(ds->ds_unique_bytes, unique);\n\tsprintf_blkptr(blkbuf, &ds->ds_bp);\n\n\t(void) printf(\"\\t\\tdir_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_dir_obj);\n\t(void) printf(\"\\t\\tprev_snap_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_prev_snap_obj);\n\t(void) printf(\"\\t\\tprev_snap_txg = %llu\\n\",\n\t    (u_longlong_t)ds->ds_prev_snap_txg);\n\t(void) printf(\"\\t\\tnext_snap_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_next_snap_obj);\n\t(void) printf(\"\\t\\tsnapnames_zapobj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_snapnames_zapobj);\n\t(void) printf(\"\\t\\tnum_children = %llu\\n\",\n\t    (u_longlong_t)ds->ds_num_children);\n\t(void) printf(\"\\t\\tuserrefs_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_userrefs_obj);\n\t(void) printf(\"\\t\\tcreation_time = %s\", ctime(&crtime));\n\t(void) printf(\"\\t\\tcreation_txg = %llu\\n\",\n\t    (u_longlong_t)ds->ds_creation_txg);\n\t(void) printf(\"\\t\\tdeadlist_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_deadlist_obj);\n\t(void) printf(\"\\t\\tused_bytes = %s\\n\", used);\n\t(void) printf(\"\\t\\tcompressed_bytes = %s\\n\", compressed);\n\t(void) printf(\"\\t\\tuncompressed_bytes = %s\\n\", uncompressed);\n\t(void) printf(\"\\t\\tunique = %s\\n\", unique);\n\t(void) printf(\"\\t\\tfsid_guid = %llu\\n\",\n\t    (u_longlong_t)ds->ds_fsid_guid);\n\t(void) printf(\"\\t\\tguid = %llu\\n\",\n\t    (u_longlong_t)ds->ds_guid);\n\t(void) printf(\"\\t\\tflags = %llx\\n\",\n\t    (u_longlong_t)ds->ds_flags);\n\t(void) printf(\"\\t\\tnext_clones_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_next_clones_obj);\n\t(void) printf(\"\\t\\tprops_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_props_obj);\n\t(void) printf(\"\\t\\tbp = %s\\n\", blkbuf);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static int\ndump_one_dir(const char *dsname, void *arg)", "code": "{\n\tint error;\n\tobjset_t *os;\n\n\terror = dmu_objset_own(dsname, DMU_OST_ANY, B_TRUE, FTAG, &os);\n\tif (error) {\n\t\t(void) printf(\"Could not open %s, error %d\\n\", dsname, error);\n\t\treturn (0);\n\t}\n\tdump_dir(os);\n\tdmu_objset_disown(os, FTAG);\n\tfuid_table_destroy();\n\tsa_loaded = B_FALSE;\n\treturn (0);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\nzdb_blkptr_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp, arc_buf_t *pbuf,\n    const zbookmark_t *zb, const dnode_phys_t *dnp, void *arg)", "code": "{\n\tzdb_cb_t *zcb = arg;\n\tchar blkbuf[BP_SPRINTF_LEN];\n\tdmu_object_type_t type;\n\tboolean_t is_metadata;\n\n\tif (bp == NULL)\n\t\treturn (0);\n\n\ttype = BP_GET_TYPE(bp);\n\n\tzdb_count_block(zcb, zilog, bp, type);\n\n\tis_metadata = (BP_GET_LEVEL(bp) != 0 || dmu_ot[type].ot_metadata);\n\n\tif (dump_opt['c'] > 1 || (dump_opt['c'] && is_metadata)) {\n\t\tint ioerr;\n\t\tsize_t size = BP_GET_PSIZE(bp);\n\t\tvoid *data = malloc(size);\n\t\tint flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SCRUB | ZIO_FLAG_RAW;\n\n\t\t/* If it's an intent log block, failure is expected. */\n\t\tif (zb->zb_level == ZB_ZIL_LEVEL)\n\t\t\tflags |= ZIO_FLAG_SPECULATIVE;\n\n\t\tioerr = zio_wait(zio_read(NULL, spa, bp, data, size,\n\t\t    NULL, NULL, ZIO_PRIORITY_ASYNC_READ, flags, zb));\n\n\t\tfree(data);\n\n\t\tif (ioerr && !(flags & ZIO_FLAG_SPECULATIVE)) {\n\t\t\tzcb->zcb_haderrors = 1;\n\t\t\tzcb->zcb_errors[ioerr]++;\n\n\t\t\tif (dump_opt['b'] >= 2)\n\t\t\t\tsprintf_blkptr(blkbuf, bp);\n\t\t\telse\n\t\t\t\tblkbuf[0] = '\\0';\n\n\t\t\t(void) printf(\"zdb_blkptr_cb: \"\n\t\t\t    \"Got error %d reading \"\n\t\t\t    \"<%llu, %llu, %lld, %llx> %s -- skipping\\n\",\n\t\t\t    ioerr,\n\t\t\t    (u_longlong_t)zb->zb_objset,\n\t\t\t    (u_longlong_t)zb->zb_object,\n\t\t\t    (u_longlong_t)zb->zb_level,\n\t\t\t    (u_longlong_t)zb->zb_blkid,\n\t\t\t    blkbuf);\n\t\t}\n\t}\n\n\tzcb->zcb_readfails = 0;\n\n\tif (dump_opt['b'] >= 4) {\n\t\tsprintf_blkptr(blkbuf, bp);\n\t\t(void) printf(\"objset %llu object %llu \"\n\t\t    \"level %lld offset 0x%llx %s\\n\",\n\t\t    (u_longlong_t)zb->zb_objset,\n\t\t    (u_longlong_t)zb->zb_object,\n\t\t    (longlong_t)zb->zb_level,\n\t\t    (u_longlong_t)blkid2offset(dnp, bp, zb),\n\t\t    blkbuf);\n\t}\n\n\treturn (0);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\ncount_block_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)", "code": "{\n\tzdb_cb_t *zcb = arg;\n\n\tif (dump_opt['b'] >= 4) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tsprintf_blkptr(blkbuf, bp);\n\t\t(void) printf(\"[%s] %s\\n\",\n\t\t    \"deferred free\", blkbuf);\n\t}\n\tzdb_count_block(zcb, NULL, bp, ZDB_OT_DEFERRED);\n\treturn (0);\n}", "path": "src\\cmd\\zdb\\zdb.c", "repo_name": "s3thi/zfs-haiku", "stars": 10, "license": "None", "language": "c", "size": 1728}
{"docstring": "/**\n * ca_proplist_setf:\n * @p: The property list to add this key/value pair to\n * @key: The key for this key/value pair\n * @format: The format string for the value for this key/value pair\n * @...: The parameters for the format string\n *\n * Much like ca_proplist_sets(): add a new string key/value pair to\n * the property list. Takes a standard C format string plus arguments\n * and formats a string of it.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_proplist_setf(ca_proplist *p, const char *key, const char *format, ...)", "code": "{\n    int ret;\n    char *k;\n    ca_prop *prop;\n    size_t size = 100;\n    unsigned h;\n\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n    ca_return_val_if_fail(key, CA_ERROR_INVALID);\n    ca_return_val_if_fail(format, CA_ERROR_INVALID);\n\n    if (!(k = ca_strdup(key)))\n        return CA_ERROR_OOM;\n\n    for (;;) {\n        va_list ap;\n        int r;\n\n        if (!(prop = ca_malloc(CA_ALIGN(sizeof(ca_prop)) + size))) {\n            ca_free(k);\n            return CA_ERROR_OOM;\n        }\n\n\n        va_start(ap, format);\n        r = vsnprintf(CA_PROP_DATA(prop), size, format, ap);\n        va_end(ap);\n\n        ((char*) CA_PROP_DATA(prop))[size-1] = 0;\n\n        if (r > -1 && (size_t) r < size) {\n            prop->nbytes = (size_t) r+1;\n            break;\n        }\n\n        if (r > -1)    /* glibc 2.1 */\n            size = (size_t) r+1;\n        else           /* glibc 2.0 */\n            size *= 2;\n\n        ca_free(prop);\n    }\n\n    prop->key = k;\n\n    ca_mutex_lock(p->mutex);\n\n    if ((ret = _unset(p, key)) < 0) {\n        ca_free(prop);\n        ca_free(k);\n        goto finish;\n    }\n\n    h = calc_hash(key) % N_HASHTABLE;\n\n    prop->next_in_slot = p->prop_hashtable[h];\n    p->prop_hashtable[h] = prop;\n\n    prop->prev_item = NULL;\n    if ((prop->next_item = p->first_item))\n        prop->next_item->prev_item = prop;\n    p->first_item = prop;\n\nfinish:\n\n    ca_mutex_unlock(p->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\proplist.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/* Not exported, not self-locking */\n", "func_signal": "ca_prop* ca_proplist_get_unlocked(ca_proplist *p, const char *key)", "code": "{\n    ca_prop *prop;\n    unsigned i;\n\n    ca_return_val_if_fail(p, NULL);\n    ca_return_val_if_fail(key, NULL);\n\n    i = calc_hash(key) % N_HASHTABLE;\n\n    for (prop = p->prop_hashtable[i]; prop; prop = prop->next_in_slot)\n        if (strcmp(prop->key, key) == 0)\n            return prop;\n\n    return NULL;\n}", "path": "libcanberra-0.13\\src\\proplist.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/* Not exported, not self-locking */\n", "func_signal": "const char* ca_proplist_gets_unlocked(ca_proplist *p, const char *key)", "code": "{\n    ca_prop *prop;\n\n    ca_return_val_if_fail(p, NULL);\n    ca_return_val_if_fail(key, NULL);\n\n    if (!(prop = ca_proplist_get_unlocked(p, key)))\n        return NULL;\n\n    if (!memchr(CA_PROP_DATA(prop), 0, prop->nbytes))\n        return NULL;\n\n    return CA_PROP_DATA(prop);\n}", "path": "libcanberra-0.13\\src\\proplist.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_proplist_set:\n * @p: The property list to add this key/value pair to\n * @key: The key for this key/value pair\n * @data: The binary value for this key value pair\n * @nbytes: The size of thebinary value for this key value pair.\n *\n * Add a new binary key/value pair to the property list.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_proplist_set(ca_proplist *p, const char *key, const void *data, size_t nbytes)", "code": "{\n    int ret;\n    char *k;\n    ca_prop *prop;\n    unsigned h;\n\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n    ca_return_val_if_fail(key, CA_ERROR_INVALID);\n    ca_return_val_if_fail(!nbytes || data, CA_ERROR_INVALID);\n\n    if (!(k = ca_strdup(key)))\n        return CA_ERROR_OOM;\n\n    if (!(prop = ca_malloc(CA_ALIGN(sizeof(ca_prop)) + nbytes))) {\n        ca_free(k);\n        return CA_ERROR_OOM;\n    }\n\n    prop->key = k;\n    prop->nbytes = nbytes;\n    memcpy(CA_PROP_DATA(prop), data, nbytes);\n\n    ca_mutex_lock(p->mutex);\n\n    if ((ret = _unset(p, key)) < 0) {\n        ca_free(prop);\n        ca_free(k);\n        goto finish;\n    }\n\n    h = calc_hash(key) % N_HASHTABLE;\n\n    prop->next_in_slot = p->prop_hashtable[h];\n    p->prop_hashtable[h] = prop;\n\n    prop->prev_item = NULL;\n    if ((prop->next_item = p->first_item))\n        prop->next_item->prev_item = prop;\n    p->first_item = prop;\n\nfinish:\n\n    ca_mutex_unlock(p->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\proplist.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_open:\n * @c: the context to connect.\n *\n * Connect the context to the sound system. This call is implicitly\n * called in ca_context_play() or ca_context_cache() if not called\n * explicitly. It is recommended to initialize application properties\n * with ca_context_change_props() before calling this function.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_open(ca_context *c)", "code": "{\n    int ret;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_mutex_lock(c->mutex);\n    ca_return_val_if_fail_unlock(!c->opened, CA_ERROR_STATE, c->mutex);\n\n    ret = context_open_unlocked(c);\n\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_gtk_proplist_set_for_event:\n * @p: The proplist to store these sound event properties in\n * @e: The Gdk event to base these sound event properties on\n *\n * Fill in a ca_proplist object for a sound event that is being\n * triggered by the specified Gdk Event. This will fill in properties\n * like %CA_PROP_EVENT_MOUSE_X or %CA_PROP_EVENT_MOUSE_BUTTON for\n * you. This will internally also cal ca_gtk_proplist_set_for_widget()\n * on the widget this event belongs to.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_gtk_proplist_set_for_event(ca_proplist *p, GdkEvent *e)", "code": "{\n    gdouble x, y;\n    GdkWindow *gw;\n    GtkWidget *w = NULL;\n    int ret;\n\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n    ca_return_val_if_fail(e, CA_ERROR_INVALID);\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n\n    if ((gw = e->any.window)) {\n        gdk_window_get_user_data(gw, (gpointer*) &w);\n\n        if (w)\n            if ((ret = ca_gtk_proplist_set_for_widget(p, w)) < 0)\n                return ret;\n    }\n\n    if (gdk_event_get_root_coords(e, &x, &y)) {\n\n        if ((ret = ca_proplist_setf(p, CA_PROP_EVENT_MOUSE_X, \"%0.0f\", x)) < 0)\n            return ret;\n\n        if ((ret = ca_proplist_setf(p, CA_PROP_EVENT_MOUSE_Y, \"%0.0f\", y)) < 0)\n            return ret;\n\n        if (w)  {\n            int width, height;\n\n            width = gdk_screen_get_width(gtk_widget_get_screen(w));\n            height = gdk_screen_get_height(gtk_widget_get_screen(w));\n\n            /* We use these strange format strings here to avoid that\n             * libc applies locale information on the formatting of\n             * floating numbers. */\n\n            if ((ret = ca_proplist_setf(p, CA_PROP_EVENT_MOUSE_HPOS, \"%i.%03i\", (int) (x/width), (int) (1000.0*x/width) % 1000)) < 0)\n                return ret;\n\n            if ((ret = ca_proplist_setf(p, CA_PROP_EVENT_MOUSE_VPOS, \"%i.%03i\", (int) (y/height), (int) (1000.0*y/height) % 1000)) < 0)\n                return ret;\n        }\n    }\n\n    if (e->type == GDK_BUTTON_PRESS ||\n        e->type == GDK_2BUTTON_PRESS ||\n        e->type == GDK_3BUTTON_PRESS ||\n        e->type == GDK_BUTTON_RELEASE) {\n\n        if ((ret = ca_proplist_setf(p, CA_PROP_EVENT_MOUSE_BUTTON, \"%u\", e->button.button)) < 0)\n            return ret;\n    }\n\n    return CA_SUCCESS;\n}", "path": "libcanberra-0.13\\src\\canberra-gtk.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_destroy:\n * @c: the context to destroy.\n *\n * Destroy a (connected or unconnected) context object.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_destroy(ca_context *c)", "code": "{\n    int ret = CA_SUCCESS;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n\n    /* There's no locking necessary here, because the application is\n     * broken anyway if it destructs this object in one thread and\n     * still is calling a method of it in another. */\n\n    if (c->opened)\n        ret = driver_destroy(c);\n\n    if (c->props)\n        ca_assert_se(ca_proplist_destroy(c->props) == CA_SUCCESS);\n\n    if (c->mutex)\n        ca_mutex_free(c->mutex);\n\n    ca_free(c->driver);\n    ca_free(c->device);\n    ca_free(c);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_cache:\n * @c: The context to use for uploading.\n * @...: The properties for this event sound. Terminated with NULL.\n *\n * Upload the specified sample into the audio server and attach the\n * specified properties to it. This function will only return after\n * the sample upload was finished.\n *\n * The sound to cache is found with the same algorithm that is used to\n * find the sounds for ca_context_play().\n *\n * If the backend doesn't support caching sound samples this function\n * will return %CA_ERROR_NOTSUPPORTED.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_cache(ca_context *c, ...)", "code": "{\n    int ret;\n    va_list ap;\n    ca_proplist *p = NULL;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n\n    va_start(ap, c);\n    ret = ca_proplist_from_ap(&p, ap);\n    va_end(ap);\n\n    if (ret < 0)\n        return ret;\n\n    ret = ca_context_cache_full(c, p);\n\n    ca_assert_se(ca_proplist_destroy(p) == 0);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_gtk_play_for_event:\n * @e: The Gdk event to base these sound event properties on\n * @id: The event id that can later be used to cancel this event sound\n * using ca_context_cancel(). This can be any integer and shall be\n * chosen be the client program. It is a good idea to pass 0 here if\n * cancelling the sound later is not needed. If the same id is passed\n * to multiple sounds they can be canceled with a single\n * ca_context_cancel() call.\n * @...: additional event properties as pairs of strings, terminated by NULL.\n *\n * Play a sound event for the specified event. This will internally\n * call ca_gtk_proplist_set_for_event() and then merge them with the\n * properties passed in via the NULL terminated argument\n * list. Finally, it will call ca_context_play_full() to actually play\n * the event sound.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_gtk_play_for_event(GdkEvent *e, uint32_t id, ...)", "code": "{\n    va_list ap;\n    int ret;\n    ca_proplist *p;\n    GdkScreen *s;\n\n    ca_return_val_if_fail(e, CA_ERROR_INVALID);\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n\n    if ((ret = ca_proplist_create(&p)) < 0)\n        return ret;\n\n    if ((ret = ca_gtk_proplist_set_for_event(p, e)) < 0)\n        goto fail;\n\n    va_start(ap, id);\n    ret = ca_proplist_merge_ap(p, ap);\n    va_end(ap);\n\n    if (ret < 0)\n        goto fail;\n\n    s = gdk_drawable_get_screen(GDK_DRAWABLE(e->any.window));\n    ret = ca_context_play_full(ca_gtk_context_get_for_screen(s), id, p, NULL, NULL);\n\nfail:\n\n    ca_assert_se(ca_proplist_destroy(p) == 0);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\canberra-gtk.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_proplist_sets:\n * @p: The property list to add this key/value pair to\n * @key: The key for this key/value pair\n * @value: The value for this key/value pair\n *\n * Add a new string key/value pair to the property list.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_proplist_sets(ca_proplist *p, const char *key, const char *value)", "code": "{\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n    ca_return_val_if_fail(key, CA_ERROR_INVALID);\n    ca_return_val_if_fail(value, CA_ERROR_INVALID);\n\n    return ca_proplist_set(p, key, value, strlen(value)+1);\n}", "path": "libcanberra-0.13\\src\\proplist.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_change_device:\n * @c: the context to change the backend device for\n * @device: the backend device to use, in a format that is specific to the backend.\n *\n * Specify the backend device to use. This function may be called not be called after\n * ca_context_open() suceeded. This function might suceed even when\n * the specified driver backend is not available. Use\n * ca_context_open() to find out whether the backend is available\n *\n * Depending on the backend use this might or might not cause all\n * currently playing event sounds to be moved to the new device..\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_change_device(ca_context *c, const char *device)", "code": "{\n    char *n;\n    int ret;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_mutex_lock(c->mutex);\n\n    if (!device)\n        n = NULL;\n    else if (!(n = ca_strdup(device))) {\n        ret = CA_ERROR_OOM;\n        goto fail;\n    }\n\n    ret = c->opened ? driver_change_device(c, n) : CA_SUCCESS;\n\n    if (ret == CA_SUCCESS) {\n        ca_free(c->device);\n        c->device = n;\n    } else\n        ca_free(n);\n\nfail:\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/* Not exported */\n", "func_signal": "int ca_parse_cache_control(ca_cache_control_t *control, const char *c)", "code": "{\n    ca_return_val_if_fail(control, CA_ERROR_INVALID);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n\n    if (ca_streq(c, \"never\"))\n        *control = CA_CACHE_CONTROL_NEVER;\n    else if (ca_streq(c, \"permanent\"))\n        *control = CA_CACHE_CONTROL_PERMANENT;\n    else if (ca_streq(c, \"volatile\"))\n        *control = CA_CACHE_CONTROL_VOLATILE;\n    else\n        return CA_ERROR_INVALID;\n\n    return CA_SUCCESS;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_cache_full:\n * @c: The context to use for uploading.\n * @p: The property list for this event sound.\n *\n * Upload the specified sample into the server and attach the\n * specified properties to it. Similar to ca_context_cache() but takes\n * a ca_proplist instead of a variable number of arguments.\n *\n * If the backend doesn't support caching sound samples this function\n * will return CA_ERROR_NOTSUPPORTED.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_cache_full(ca_context *c, ca_proplist *p)", "code": "{\n    int ret;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n\n    ca_mutex_lock(c->mutex);\n\n    ca_return_val_if_fail_unlock(ca_proplist_contains(p, CA_PROP_EVENT_ID) ||\n                                 ca_proplist_contains(c->props, CA_PROP_EVENT_ID), CA_ERROR_INVALID, c->mutex);\n\n    if ((ret = context_open_unlocked(c)) < 0)\n        goto finish;\n\n    ca_assert(c->opened);\n\n    ret = driver_cache(c, p);\n\nfinish:\n\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_change_props:\n * @c: the context to set the properties on.\n * @...: the list of string pairs for the properties. Needs to be a NULL terminated list.\n *\n * Write one or more string properties to the context object. Requires\n * final NULL sentinel. Properties set like this will be attached to\n * both the client object of the sound server and to all event sounds\n * played or cached. It is recommended to call this function at least\n * once before calling ca_context_open(), so that the initial\n * application properties are set properly before the initial\n * connection to the sound system. This function can be called both\n * before and after the ca_context_open() call. Properties that have\n * already been set before will be overwritten.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_change_props(ca_context *c, ...)", "code": "{\n    va_list ap;\n    int ret;\n    ca_proplist *p = NULL;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n\n    va_start(ap, c);\n    ret = ca_proplist_from_ap(&p, ap);\n    va_end(ap);\n\n    if (ret < 0)\n        return ret;\n\n    ret = ca_context_change_props_full(c, p);\n\n    ca_assert_se(ca_proplist_destroy(p) == 0);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_set_driver:\n * @c: the context to change the backend driver for\n * @driver: the backend driver to use (e.g. \"alsa\", \"pulse\", \"null\", ...)\n *\n * Specify the backend driver used. This function may not be called again after\n * ca_context_open() suceeded. This function might suceed even when\n * the specified driver backend is not available. Use\n * ca_context_open() to find out whether the backend is available.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_set_driver(ca_context *c, const char *driver)", "code": "{\n    char *n;\n    int ret;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_mutex_lock(c->mutex);\n    ca_return_val_if_fail_unlock(!c->opened, CA_ERROR_STATE, c->mutex);\n\n    if (!driver)\n        n = NULL;\n    else if (!(n = ca_strdup(driver))) {\n        ret = CA_ERROR_OOM;\n        goto fail;\n    }\n\n    ca_free(c->driver);\n    c->driver = n;\n\n    ret = CA_SUCCESS;\n\nfail:\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * SECTION:canberra-gtk\n * @short_description: Gtk+ libcanberra Bindings\n *\n * libcanberra-gtk provides a few functions that simplify libcanberra\n * usage from Gtk+ programs. It maintains a single ca_context object\n * per #GdkScreen that is made accessible via\n * ca_gtk_context_get_for_screen(), with a shortcut ca_gtk_context_get()\n * to get the context for the default screen. More importantly, it provides\n * a few functions\n * to compile event sound property lists based on GtkWidget objects or\n * GdkEvent events.\n */\n", "func_signal": "static void read_sound_theme_name(ca_context *c, GtkSettings *s)", "code": "{\n    gchar *theme_name = NULL;\n\n    g_object_get(G_OBJECT(s), \"gtk-sound-theme-name\", &theme_name, NULL);\n\n    if (theme_name) {\n        ca_context_change_props(c, CA_PROP_CANBERRA_XDG_THEME_NAME, theme_name, NULL);\n        g_free(theme_name);\n    }\n}", "path": "libcanberra-0.13\\src\\canberra-gtk.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_play_full:\n * @c: the context to play the event sound on\n * @id: an integer id this sound can be later be identified with when calling ca_context_cancel() or when the callback is called.\n * @p: A property list of properties for this event sound\n * @cb: A callback to call when this sound event sucessfully finished playing or when an error occured during playback.\n *\n * Play one event sound, and call the specified callback function when\n * completed. See ca_finish_callback_t for the semantics the callback\n * is called in. Also see ca_context_play().\n *\n * It is guaranteed that the callback is called exactly once if\n * ca_context_play_full() returns CA_SUCCESS. You thus may safely pass\n * allocated memory to the callback and assume that it is freed\n * properly.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_play_full(ca_context *c, uint32_t id, ca_proplist *p, ca_finish_callback_t cb, void *userdata)", "code": "{\n    int ret;\n    const char *t;\n    ca_bool_t enabled = TRUE;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n    ca_return_val_if_fail(!userdata || cb, CA_ERROR_INVALID);\n\n    ca_mutex_lock(c->mutex);\n\n    ca_return_val_if_fail_unlock(ca_proplist_contains(p, CA_PROP_EVENT_ID) ||\n                                 ca_proplist_contains(c->props, CA_PROP_EVENT_ID) ||\n                                 ca_proplist_contains(p, CA_PROP_MEDIA_FILENAME) ||\n                                 ca_proplist_contains(c->props, CA_PROP_MEDIA_FILENAME), CA_ERROR_INVALID, c->mutex);\n\n    ca_mutex_lock(c->props->mutex);\n    if ((t = ca_proplist_gets_unlocked(c->props, CA_PROP_CANBERRA_ENABLE)))\n        enabled = !ca_streq(t, \"0\");\n    ca_mutex_unlock(c->props->mutex);\n\n    ca_mutex_lock(p->mutex);\n    if ((t = ca_proplist_gets_unlocked(p, CA_PROP_CANBERRA_ENABLE)))\n        enabled = !ca_streq(t, \"0\");\n    ca_mutex_unlock(p->mutex);\n\n    ca_return_val_if_fail_unlock(enabled, CA_ERROR_DISABLED, c->mutex);\n\n    if ((ret = context_open_unlocked(c)) < 0)\n        goto finish;\n\n    ca_assert(c->opened);\n\n    ret = driver_play(c, id, p, cb, userdata);\n\t\n\tvizaudio_display(p);\nfinish:\n\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_context_change_props_full:\n * @c: the context to set the properties on.\n * @p: the property list to set.\n *\n * Similar to ca_context_change_props(), but takes a ca_proplist\n * instead of a variable list of properties. Can be used to set binary\n * properties such as %CA_PROP_APPLICATION_ICON.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_context_change_props_full(ca_context *c, ca_proplist *p)", "code": "{\n    int ret;\n    ca_proplist *merged;\n\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n    ca_return_val_if_fail(c, CA_ERROR_INVALID);\n    ca_return_val_if_fail(p, CA_ERROR_INVALID);\n\n    ca_mutex_lock(c->mutex);\n\n    if ((ret = ca_proplist_merge(&merged, c->props, p)) < 0)\n        goto finish;\n\n    ret = c->opened ? driver_change_props(c, p, merged) : CA_SUCCESS;\n\n    if (ret == CA_SUCCESS) {\n        ca_assert_se(ca_proplist_destroy(c->props) == CA_SUCCESS);\n        c->props = merged;\n    } else\n        ca_assert_se(ca_proplist_destroy(merged) == CA_SUCCESS);\n\nfinish:\n\n    ca_mutex_unlock(c->mutex);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\common.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_gtk_play_for_widget:\n * @w: The Gtk widget to base these sound event properties on\n * @id: The event id that can later be used to cancel this event sound\n * using ca_context_cancel(). This can be any integer and shall be\n * chosen be the client program. It is a good idea to pass 0 here if\n * cancelling the sound later is not needed. If the same id is passed\n * to multiple sounds they can be canceled with a single\n * ca_context_cancel() call.\n * @...: additional event properties as pairs of strings, terminated by NULL.\n *\n * Play a sound event for the specified widget. This will internally\n * call ca_gtk_proplist_set_for_widget() and then merge them with the\n * properties passed in via the NULL terminated argument\n * list. Finally, it will call ca_context_play_full() to actually play\n * the event sound.\n *\n * Returns: 0 on success, negative error code on error.\n */\n", "func_signal": "int ca_gtk_play_for_widget(GtkWidget *w, uint32_t id, ...)", "code": "{\n    va_list ap;\n    int ret;\n    ca_proplist *p;\n    GdkScreen *s;\n\n    ca_return_val_if_fail(w, CA_ERROR_INVALID);\n    ca_return_val_if_fail(!ca_detect_fork(), CA_ERROR_FORKED);\n\n    if ((ret = ca_proplist_create(&p)) < 0)\n        return ret;\n\n    if ((ret = ca_gtk_proplist_set_for_widget(p, w)) < 0)\n        goto fail;\n\n    va_start(ap, id);\n    ret = ca_proplist_merge_ap(p, ap);\n    va_end(ap);\n\n    if (ret < 0)\n        goto fail;\n\n    s = gtk_widget_get_screen(w);\n    ret = ca_context_play_full(ca_gtk_context_get_for_screen(s), id, p, NULL, NULL);\n\nfail:\n\n    ca_assert_se(ca_proplist_destroy(p) == 0);\n\n    return ret;\n}", "path": "libcanberra-0.13\\src\\canberra-gtk.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * ca_gtk_widget_disable_sounds:\n * @w: The Gtk widget to disable automatic event sounds for.\n * @enable: Boolean specifying whether sound events shall be enabled or disabled for this widget.\n *\n * By default sound events are automatically generated for all kinds\n * of input events. Use this function to disable this. This is\n * intended to be used for widgets which directly generate sound\n * events.\n */\n", "func_signal": "void ca_gtk_widget_disable_sounds(GtkWidget *w, gboolean enable)", "code": "{\n    static GQuark disable_sound_quark = 0;\n\n    /* This is the same quark used by libgnomeui! */\n    if (!disable_sound_quark)\n        disable_sound_quark = g_quark_from_static_string(\"gnome_disable_sound_events\");\n\n    g_object_set_qdata(G_OBJECT(w), disable_sound_quark, GINT_TO_POINTER(!!enable));\n}", "path": "libcanberra-0.13\\src\\canberra-gtk.c", "repo_name": "rgee/VizAudio", "stars": 14, "license": "other", "language": "c", "size": 2179}
{"docstring": "/**\n * \\brief Create a new buffer\n *\n * This routine is called when we need to create a new buffer. The caller\n * should have already verified that this doesn't already exist. The\n * routine returns the address of the new buffer, or NULL if there is a\n * problem of some sort.\n */\n", "func_signal": "struct buff_header *\nbuff_create( char *name, char internal_flag )", "code": "{\nregister struct buff_header *bp;\nregister struct buff_header *obp;\nregister struct buff_line *lbp;\nregister int i = 0;\n\n    PREAMBLE();\n\n    if(buff_find(name)) return(NULL);\n\n/*\n * Create the buffer header itself.\n */\n    bp = (struct buff_header *)tec_alloc(\n\tTYPE_C_BHDR,\n\tsizeof(struct buff_header)\n    );\n\n    if(bp == NULL) return(NULL);\n    bp->buf_magic = MAGIC_BUFFER;\n    bp->buf_hash = stringHash( name );\n\n    bp->name = tec_alloc(TYPE_C_CBUFF,strlen(name)+1);\n    if(bp->name == NULL){\n\tbp->buf_magic = 0;\n\ttec_release(TYPE_C_BHDR,(char *)bp);\n\treturn(NULL);\n    }/* End IF */\n    (void) strcpy(bp->name,name);\n\n    obp = buffer_headers;\n    if(obp) i = obp->buffer_number;\n    while(obp){\n\tif(internal_flag){\n\t    if(obp->buffer_number < i) i = obp->buffer_number;\n\t}\n\telse {\n\t    if(obp->buffer_number > i) i = obp->buffer_number;\n\t}\n\tobp = obp->next_header;\n    }/* End While */\t    \n\n    if(internal_flag) bp->buffer_number = i - 1;\n    else bp->buffer_number = i + 1;\n\n    bp->ismodified = NO;\n    bp->isreadonly = NO;\n    bp->isbackedup = NO;\n    bp->dot = 0;\n    bp->zee = 0;\n\n/*\n * Create the first line buffer structure\n */\n    lbp = allocate_line_buffer(1);\n    if(lbp == NULL){\n\tbp->buf_magic = 0;\n\ttec_release(TYPE_C_CBUFF,bp->name);\n\ttec_release(TYPE_C_BHDR,(char *)bp);\n\treturn((struct buff_header *)NULL);\n    }/* End IF */\n    bp->first_line = lbp;\n/*\n * Initialize the rest of the special locations\n */\n    bp->pos_cache.lbp = NULL;\n    bp->pos_cache.base = 0;\n\n/*\n * Link it into the list of buffer headers, in order by buffer number\n */\n    obp = buffer_headers;\n    while(obp){\n\tif(obp->next_header == NULL) break;\n\tif(obp->next_header->buffer_number > bp->buffer_number) break;\n\tobp = obp->next_header;\n    }/* End While */\n\n    if(obp == NULL || buffer_headers->buffer_number > bp->buffer_number){\n\tbp->next_header = buffer_headers;\n\tbuffer_headers = bp;\n    }/* End IF */\n\n    else {\n\tbp->next_header = obp->next_header;\n\tobp->next_header = bp;\n    }/* End Else */\n\n    return(bp);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Insert a list of line buffer structures\n *\n * This routine is used to insert a list of line buffer structures at\n * the specified position in the buffer.\n */\n", "func_signal": "void\nbuff_bulk_insert(\tstruct buff_header *hbp,\n\t\t\t\t\tint position,\n\t\t\t\t\tint count,\n\t\t\t\t\tstruct buff_line *lbp )", "code": "{\nregister struct buff_line *olbp;\nint offset;\n\n    PREAMBLE();\n/*\n * If this will modify the buffer for the first time, it needs to be displayed\n * in the label line.\n */\n    if(hbp->ismodified == NO){\n\thbp->ismodified = YES;\n\tif(hbp == curbuf){\n\t    screen_label_line(hbp,\"(modified)\",LABEL_C_MODIFIED);\n\t}/* End IF */\n    }/* End IF */\n\n    checkpoint_modified = YES;\n\n/*\n * We special case position zero because this is an easy case, and is common\n * when HK is being used a lot\n */\n    if(position == 0){\n\tif((olbp = hbp->first_line) != NULL){\n\t    if(olbp->byte_count == 0){\n\t\tolbp = olbp->next_line;\n\t\tbuff_free_line_buffer(hbp->first_line);\n\t    }/* End IF */\n\t}/* End IF */\t    \n\thbp->first_line = lbp;\n\twhile(lbp->next_line) lbp = lbp->next_line;\n\tlbp->next_line = olbp;\n\tif(olbp) olbp->prev_line = lbp;\n\thbp->zee += count;\n\thbp->dot += count;\n\thbp->pos_cache.lbp = NULL;\n\treturn;\n    }/* End IF */\n\n/*\n * Also special check for position zee since this is also an easy case\n */\n    if(position == hbp->zee){\n\tolbp = hbp->first_line;\n\tif(hbp->pos_cache.lbp) olbp = hbp->pos_cache.lbp;\n\twhile(olbp->next_line) olbp = olbp->next_line;\n\tif(olbp->byte_count == 0){\n\t    olbp = olbp->prev_line;\n\t    buff_free_line_buffer(olbp->next_line);\n\t}/* End IF */\n\tolbp->next_line = lbp;\n\tlbp->prev_line = olbp;\n\tif(hbp->dot == hbp->zee) hbp->dot += count;\n\thbp->zee += count;\n\thbp->pos_cache.lbp = NULL;\n\treturn;\n    }/* End IF */\n\n/*\n * Ok, if the insertion is not at the begining or the end of the buffer, then\n * we just have to do it the hard way...\n */\n    olbp = buff_find_line(hbp,position);\n    offset = buff_find_offset(hbp,olbp,position);\n\n/*\n * Bulk inserts should always be guarenteed aligned.\n */\n    if(offset){\n\terror_message(\"BULK_INSERT: internal error! non-aligned bulk insert\");\n\treturn;\n    }/* End IF */\n\n    if(olbp->prev_line) olbp->prev_line->next_line = lbp;\n    lbp->prev_line = olbp->prev_line;\n\n    while(lbp->next_line) lbp = lbp->next_line;\n    lbp->next_line = olbp;\n    olbp->prev_line = lbp;\n\n    if(hbp->dot >= position) hbp->dot += count;\n    if(hbp->pos_cache.base >= position) hbp->pos_cache.base += count;\n    hbp->zee += count;\n\n    return;\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Insert a single char with undo capability\n *\n * This is an envelope routine which guarentees that the character\n * to be input can be undone if necessary.\n */\n", "func_signal": "int\nbuff_insert_char_with_undo(\tstruct cmd_token *ct,\n\t\t\t\t\t\t\tstruct buff_header *hbp,\n\t\t\t\t\t\t\tint position,\n\t\t\t\t\t\t\tchar data )", "code": "{\nstruct undo_token *ut;\n\n    PREAMBLE();\n\n    ut = allocate_undo_token(ct);\n    if(ut == NULL) return(FAIL);\n    ut->opcode = UNDO_C_DELETE;\n    ut->carg1 = (char *)hbp;\n    ut->iarg1 = position;\n    ut->iarg2 = 1;\n\n    if(buff_insert_char(hbp,position,data) == FAIL){\n\tut->iarg2 = 0;\n\treturn(FAIL);\n    }/* End IF */\n\n    return(SUCCESS);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Continue the parse with the supplied character\n *\n * We re-enter the parser with a new character at this point. We jump back\n * to the state we left before.\n */\n", "func_signal": "void\nparse_input_character( struct cmd_token *ct, struct cmd_token *uct )", "code": "{\nchar tmp_message[LINE_BUFFER_SIZE];\nregister struct cmd_token *oct = NULL;\n\n    PREAMBLE();\n\n    switch(ct->ctx.state){\n/*\n * Here on initial command state. This is the begining of a command, so we are\n * looking for arguments that might go with a command. If there are no args,\n * we just transfer into the main command loop.\n */\n\tcase STATE_C_INITIALSTATE:\n\t    ct->ctx.flags &= ~(CTOK_M_COLON_SEEN | CTOK_M_ATSIGN_SEEN);\n\t    ct->flags |= TOK_M_WORDBOUNDARY;\n\tcase STATE_C_ACCEPT_ARGS:\n\t    ct->ctx.carg = NULL;\n\t    switch(ct->input_byte){\n/*\n * If it looks like an argument, then transfer into a subexpression parser to\n * get the value of the expression. ARG1 will stuff the result into iarg1 and\n * also check for a comma (',') incase he is specifing a twin argument command\n */\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\tcase 'Q': case 'q': case '%':\n#ifdef CLASSIC_B_BEHAVIOR\n\t\tcase 'B': case 'b':\n#endif\n\t\tcase 'Z': case 'z':\n\t\tcase '\\\\':\n\t\tcase '.':\n\t\tcase '-':\n\t\tcase '(':\n\t\tcase '^':\n\t\t    ct->ctx.flags &= ~CTOK_M_STATUS_PASSED;\n\t\t    ct->ctx.iarg1_flag = ct->ctx.iarg2_flag = NO;\n\t\t    ct->ctx.state = STATE_C_EXPRESSION;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_ARG1;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n/*\n * H is a special case, since the single argument actually implies two args.\n * (H actually is the same as 0,z<cmd>)\n */\n\t\tcase 'H': case 'h':\n\t\t    ct->ctx.flags &= ~CTOK_M_STATUS_PASSED;\n\t\t    ct->ctx.iarg1_flag = ct->ctx.iarg2_flag = YES;\n\t\t    ct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t    ct->execute_state = EXEC_C_HVALUE;\n\t\t    return;\n/*\n * Here on the @ command. This says to use user specified delimeters for\n * strings, rather than just terminating with escape.\n */\n\t\tcase '@':\n\t\t    ct->ctx.flags |= CTOK_M_ATSIGN_SEEN;\n\t\t    ct->ctx.state = STATE_C_ACCEPT_ARGS;\n\t\t    return;\n/*\n * Here on the : command. This is just a flag to many commands to tell them\n * to work in a slightly different way. The most common usage is to mean that\n * the command should return a value which says whether it worked or not.\n */\n\t\tcase ':':\n\t\t    ct->ctx.flags |= CTOK_M_COLON_SEEN;\n\t\t    ct->ctx.state = STATE_C_ACCEPT_ARGS;\n\t\t    return;\n/*\n * Well, it doesn't look like he is going to be specifying any arguments, so we\n * just go and decode the command.\n */\n\t\tdefault:\n\t\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){\n\t\t\tct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t\tct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t\tct->ctx.flags &= ~CTOK_M_STATUS_PASSED;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t    ct->ctx.iarg1_flag = ct->ctx.iarg2_flag = NO;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\n\t    }/* End Switch */\n/*\n * Here to parse the major commands (i.e., ones that have no lead-in)\n */\n\tcase STATE_C_MAINCOMMANDS:\n\t    switch(ct->input_byte){\n/*\n * Space is a nop so that it can be used to make macros more readable\n */\n\t\tcase ' ':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    return;\n/*\n * Carriage Return is a nop so that it can be used in a macro to avoid\n * extremely long lines wrapping.\n */\n\t\tcase '\\n':\n\t\t    ct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t    return;\n/*\n * Here on an escape. First of all, we have to remember that we have seen an\n * escape since two in a row will terminate the command. Also, escape has the\n * effect of blocking arguments from commands i.e. 2L will move two lines, but\n * 2$L will only move one since the escape eats the argument.\n */\n\t\tcase ESCAPE:\n\t\t    ct->ctx.iarg1_flag = ct->ctx.iarg2_flag = NO;\n\t\t    ct->ctx.state = STATE_C_ESCAPESEEN;\n\t\t    return;\t\t    \n/*\n * Here on an Asterisk command. This causes the last double-escaped command\n * sequence to be saved in the named q-register.\n */\n\t\tcase '*':\n\t\t    if(parse_any_arguments(ct,\"*\")) return;\n\t\t    ct->ctx.state = STATE_C_SAVECOMMAND;\n\t\t    return;\n/*\n * Here on the @ command. This says to use user specified delimeters for\n * strings, rather than just terminating with escape.\n */\n\t\tcase '@':\n\t\t    ct->ctx.flags |= CTOK_M_ATSIGN_SEEN;\n\t\t    return;\n/*\n * Here on the : command. This is just a flag to many commands to tell them\n * to work in a slightly different way. The most common usage is to mean that\n * the command should return a value which says whether it worked or not.\n */\n\t\tcase ':':\n\t\t    ct->ctx.flags |= CTOK_M_COLON_SEEN;\n\t\t    return;\n/*\n * Here on the [ command. This causes the specified Q register to be pushed\n * onto the Q register pushdown stack.\n */\n\t\tcase '[':\n\t\t    ct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    ct->ctx.state = STATE_C_PUSH_QREGISTER;\n\t\t    return;\n\n/*\n * Here on the ] command. This causes a Q register to be popped off of the\n * Q register pushdown stack, and replaces the specified Q register.\n */\n\t\tcase ']':\n\t\t    ct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    ct->ctx.state = STATE_C_POP_QREGISTER;\n\t\t    return;\n/*\n * The B command moves backwards by lines. It is strictly a Video TECO\n * enhancement. In normal TECO, the B command returns the address of the\n * begining of the buffer, i.e. 0.\n */\n\t\tcase 'B': case 'b':\n\t\t    if(parse_more_than_one_arg(ct,\"B\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_RLINE;\n\t\t    return;\n/*\n * Here on the C command. The C command is a relative move command, i.e., the\n * argument says how many spaces from the current position to move.\n */\n\t\tcase 'C': case 'c':\n\t\t    if(parse_more_than_one_arg(ct,\"C\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_CHAR;\n\t\t    return;\n/*\n * The D command deletes the specified number of characters in the indicated\n * direction.\n */\n\t\tcase 'D': case 'd':\n\t\t    if(parse_more_than_one_arg(ct,\"D\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_DELETE;\n\t\t    return;\n/*\n * Here on an E command. This is simply the lead-in to any one of the many\n * E commands.\n */\n\t\tcase 'E': case 'e':\n\t\t    ct->ctx.state = STATE_C_ECOMMAND;\n\t\t    return;\n/*\n * Here on an F command. This is a lead-in to one of the F? commands.\n */\n\t\tcase 'F': case 'f':\n\t\t    ct->ctx.state = STATE_C_FCOMMAND;\n\t\t    return;\n/*\n * The G command copies the contents of the specified q-register into the\n * edit buffer at the current position.\n */\n\t\tcase 'G': case 'g':\n\t\t    if(parse_any_arguments(ct,\"G\")) return;\n\t\t    ct->ctx.state = STATE_C_GQREGISTER;\n\t\t    return;\n/*\n * The I command inserts characters until an escape is input. If this is\n * entered with the tab command, not only do we enter insert mode, we also\n * insert the tab itself.\n */\n\t\tcase '\\t':\n\t\t    if(ct->ctx.iarg1_flag == NO) ct->flags &= ~TOK_M_EAT_TOKEN;\n\n\n\t\tcase 'I': case 'i':\n\t\t    if(parse_more_than_one_arg(ct,\"I\")) return;\n\n\t\t    if(ct->ctx.iarg1_flag == YES){\n\t\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\t\tct->execute_state = EXEC_C_INSERT;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    if(ct->ctx.flags & CTOK_M_ATSIGN_SEEN){\n\t\t\tct->ctx.state = STATE_C_ATINSERT;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_INSERT;\n\t\t    return;\n/*\n * Here on the J command. The J command jumps to an absolute position in the\n * buffer.\n */\n\t\tcase 'J': case 'j':\n\t\t    if(parse_more_than_one_arg(ct,\"J\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_JUMP;\n\t\t    return;\n/*\n * The K command acts just like the L command except that it deletes instead\n * of moving over. Also, it is legal to specify an a,b range to K\n */\n\t\tcase 'K': case 'k':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_KILL;\n\t\t    return;\n/*\n * The L command moves over the specified number of new-line characters. An\n * argument of zero means get to the begining of the current line.\n */\n\t\tcase 'L': case 'l':\n\t\t    if(parse_more_than_one_arg(ct,\"L\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_LINE;\n\t\t    return;\n/*\n * The M command executes the contents of the specified Q register as a macro.\n */\n\t\tcase 'M': case 'm':\n\t\t    ct->ctx.state = STATE_C_MQREGISTER;\n\t\t    return;\n/*\n * The N command will search for the specified string across multiple edit\n * buffers.\n */\n\t\tcase 'N': case 'n':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_NSEARCH;\n\t\t    return;\n/*\n * The O command goes to the specified label\n */\n\t\tcase 'O': case 'o':\n\t\t    if(parse_any_arguments(ct,\"O\")) return;\n\t\t    ct->ctx.state = STATE_C_GOTO;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_GOTO_BEGIN;\n\t\t    return;\n/*\n * The P command selects the next window\n */\n\t\tcase 'P': case 'p':\n\t\t    if(parse_more_than_one_arg(ct,\"P\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_NEXT_WINDOW;\n\t\t    return;\n/*\n * The R command is exactly like the C command, except that the direction\n * is reversed.\n */\n\t\tcase 'R': case 'r':\n\t\t    if(parse_more_than_one_arg(ct,\"R\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_RCHAR;\n\t\t    return;\n/*\n * The S command will search for the specified string\n */\n\t\tcase 'S': case 's':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_SEARCH;\n\t\t    return;\n/*\n * The ^L command is temporarily used to redraw the screen\n */\n\t\tcase '\\f':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_REDRAW_SCREEN;\n\t\t    return;\n/*\n * The U command loads the argument into the specified Q register\n */\n\t\tcase 'U': case 'u':\n\t\t    if(parse_more_than_one_arg(ct,\"U\")) return;\n\t\t    ct->ctx.state = STATE_C_UQREGISTER;\n\t\t    return;\n/*\n * The V command deletes words. This is a Vido TECO enhancement. In normal\n * TECO, the V command was equivalent to 0TT\n */\n\t\tcase 'V': case 'v':\n\t\t    if(parse_more_than_one_arg(ct,\"V\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_DELWORD;\n\t\t    return;\n/*\n * The W command moves by words\n */\n\t\tcase 'W': case 'w':\n\t\t    if(parse_more_than_one_arg(ct,\"W\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_WORD;\n\t\t    return;\n/*\n * The X command moves a block of characters from the edit buffer into\n * the specified q register.\n */\n\t\tcase 'X': case 'x':\n\t\t    ct->ctx.state = STATE_C_XQREGISTER;\n\t\t    return;\n/*\n * The Y command deletes words in reverse direction. This is a Video TECO\n * enhancement. In classic TECO, the Y command 'yanked' input data into the\n * edit buffer.\n */\n\t\tcase 'Y': case 'y':\n\t\t    if(parse_more_than_one_arg(ct,\"Y\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_RDELWORD;\n\t\t    return;\n/*\n * The ^A command allows you to print a message to the message line\n */\n\t\tcase CNTRL_A:\n\t\t    if(parse_any_arguments(ct,\"^A\")) return;\n\t\t    ct->ctx.state = STATE_C_MESSAGE;\n\t\t    ct->execute_state = EXEC_C_RESET_MESSAGE;\n\t\t    return;\n/*\n * The < command opens an iteration\n */\n\t\tcase '<':\n\t\t    if(parse_more_than_one_arg(ct,\"<\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_ITERATION_BEGIN;\n\t\t    ct->ctx.inest += 1;\n\t\t    ct->execute_state = EXEC_C_ITERATION_BEGIN;\n\t\t    return;\n/*\n * The > command closes an iteration\n */\n\t\tcase '>':\n\t\t    if(parse_more_than_one_arg(ct,\">\")) return;\n\t\t    if(ct->ctx.inest == 0){\n\t\t\terror_message(\"?No Iteration Present\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_ITERATION_END;\n\t\t    while((oct = oct->prev_token)){\n\t\t\tif(oct->opcode != TOK_C_ITERATION_BEGIN) continue;\n\t\t\tif(oct->ctx.inest != ct->ctx.inest) continue;\n\t\t\tct->ctx.caller_token = oct;\n\t\t\tbreak;\n\t\t    }/* End While */\n/*\n * Preserve the arguments so that if the loop gets undone, it will get redone\n * the correct number of iterations when the > is typed again.\n */\n\t\t    {\n\t\t    register struct undo_token *ut;\n\t\t    ut = allocate_undo_token(ct);\n\t\t    if(ut == NULL){\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ut->opcode = UNDO_C_PRESERVEARGS;\n\t\t    ut->iarg1 = oct->ctx.iarg1;\n\t\t    ut->iarg2 = oct->ctx.iarg2;\n\t\t    ut->carg1 = (char *)oct;\n\n\t\t    ct->ctx.inest -= 1;\n\t\t    ct->execute_state = EXEC_C_ITERATION_END;\n\t\t    ct = allocate_cmd_token(ct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_COPYTOKEN;\n\t\t    return;\n\t\t    }\n/*\n * The ; command terminates an iteration if the argument is >= 0.\n * If there is no argument supplied, it uses the state of the last\n * search operation performed as a value.\n */\n\t\tcase ';':\n\t\t    if(parse_more_than_one_arg(ct,\";\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_SEMICOLON;\n\t\t    return;\n/*\n * The = command prints out the value of the supplied expression.\n * A single = prints out in decimal, == prints in octal and === in hex.\n */\n\t\tcase '=':\n\t\t    if(parse_more_than_one_arg(ct,\"=\")) return;\n\t\t    ct->ctx.state = STATE_C_ONE_EQUALS;\n\t\t    ct->execute_state = EXEC_C_EQUALS;\n\t\t    return;\n/*\n * The \" command is the conditional 'IF' operator. The following commands only\n * get executed if the condition is satisfied.\n */\n\t\tcase '\"':\n\t\t    if(parse_more_than_one_arg(ct,\"\\\"\")) return;\n\t\t    ct->ctx.state = STATE_C_CONDITIONALS;\n\t\t    ct->ctx.cnest += 1;\n\t\t    return;\n/*\n * The | command provides an else clause to a conditional expression\n */\n\t\tcase '|':\n\t\t    if(parse_any_arguments(ct,\"|\")) return;\n\t\t    if(ct->ctx.cnest <= 0){\n\t\t\terror_message(\"?Not in a conditional\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_SKIP_ELSE;\n\t\t    ct->execute_state = EXEC_C_SKIP_ELSE;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n/*\n * The ' command ends a conditional expression.\n */\n\t\tcase '\\'':\n\t\t    if(parse_any_arguments(ct,\"'\")) return;\n\t\t    if(ct->ctx.cnest <= 0){\n\t\t\terror_message(\"?Not in a conditional\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_CONDITIONAL_END;\n\t\t    ct->ctx.cnest -= 1;\n\t\t    return;\n/*\n * The Label command allows you to set a tag which can be jumped to with\n * the 'O' command. It also provides a way to comment macros.\n */\n\t\tcase '!':\n\t\t    if(parse_any_arguments(ct,\"!\")) return;\n\t\t    ct->ctx.state = STATE_C_LABEL;\n\t\t    ct->execute_state = EXEC_C_SKIPLABEL;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_LABEL_BEGIN;\n\t\t    return;\n/*\n * The backslash command with an argument inserts the decimal\n * representation of the argument into the buffer at the current position.\n */\n\t\tcase '\\\\':\n\t\t    if(ct->ctx.iarg2_flag == NO){\n\t\t\tct->ctx.iarg2 = 10;\n\t\t\tct->flags |= TOK_M_PARSELOAD_IARG2;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_BACKSLASH;\n\t\t    return;\n/*\n * The open-brace command copies the current command string into a special\n * Q-register and places the user there so he can edit it.\n */\n\t\tcase '{':\n\t\t    if(parse_any_arguments(ct,\"{\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_OPENBRACE;\n\t\t    return;\n\n/*\n * The close-brace command replaces the command string with the string in\n * the special Q-register.\n */\n\t\tcase '}':\n\t\t    if(parse_any_arguments(ct,\"}\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_CLOSEBRACE;\n\t\t    return;\n\n/*\n * Here on a system which doesn't really do suspend correctly\n */\n\t\tcase CNTRL_Z:\n\t\t    if(suspend_is_okay_flag == YES){\n\t\t\tcmd_suspend();\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    return;\n\n/*\n * Here to toggle trace mode. This inserts information into q-register ?\n * to help us track execution.\n */\n\t\tcase '?':\n\t\t    trace_mode_flag = !trace_mode_flag;\n\t\t\t{\n\t\t\t\tchar traceString[ 64 ];\n\t\t\t\tif( trace_mode_flag ) strcpy( traceString, \"Trace Mode ON\" );\n\t\t\t\telse strcpy( traceString, \"Trace Mode OFF\" );\n\t\t\t    screen_message( traceString );\n\t\t\t}\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    return;\n\n/*\n * We only get here on an error, since we should never dispatch a command that\n * does not have a corresponding case statement.\n */\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\n\t\t\t\"?MAINCOMMANDS: unknown command <%c>\",\n\t\t\tUPCASE((int)ct->input_byte));\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here when we have seen the begining of a conditional '\"'. Now we have to\n * look at the next character to determine what the actual condition test is.\n */\n\tcase STATE_C_CONDITIONALS:\n\t    switch(ct->input_byte){\n\t\tcase 'G': case 'g':\n\t\tcase '>':\n\t\t    ct->execute_state = EXEC_C_COND_GT;\n\t\t    break;\n\t\tcase 'L': case 'l':\n\t\tcase 'T': case 't':\n\t\tcase 'S': case 's':\n\t\tcase '<':\n\t\t    ct->execute_state = EXEC_C_COND_LT;\n\t\t    break;\n\t\tcase 'E': case 'e':\n\t\tcase 'F': case 'f':\n\t\tcase 'U': case 'u':\n\t\tcase '=':\n\t\t    ct->execute_state = EXEC_C_COND_EQ;\n\t\t    break;\n\t\tcase 'N': case 'n':\n\t\tcase '!':\n\t\t    ct->execute_state = EXEC_C_COND_NE;\n\t\t    break;\n\t\tcase 'C': case 'c':\n\t\t    ct->execute_state = EXEC_C_COND_SYMBOL;\n\t\t    break;\n\t\tcase 'D': case 'd':\n\t\t    ct->execute_state = EXEC_C_COND_DIGIT;\n\t\t    break;\n\t\tcase 'A': case 'a':\n\t\t    ct->execute_state = EXEC_C_COND_ALPHA;\n\t\t    break;\n\t\tcase 'V': case 'v':\n\t\t    ct->execute_state = EXEC_C_COND_LOWER;\n\t\t    break;\n\t\tcase 'W': case 'w':\n\t\t    ct->execute_state = EXEC_C_COND_UPPER;\n\t\t    break;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\n\t\t\t\"?Unknown conditional command '%c'\",\n\t\t\tUPCASE((int)ct->input_byte));\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    return;\n/*\n * Here to watch for the end of a label\n */\n\tcase STATE_C_LABEL:\n\t    switch(ct->input_byte){\n\t\tcase '!':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_LABEL_END;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_LABEL;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here to eat the characters in a GOTO command\n */\n\tcase STATE_C_GOTO:\n\t    switch(ct->input_byte){\n\t\tcase ESCAPE:\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_GOTO_END;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->execute_state = EXEC_C_GOTO;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_GOTO;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here if we have seen an escape. If we see another, then he wants us to\n * complete the parse and execute any remaining commands.\n */\n\tcase STATE_C_ESCAPESEEN:\n\t    switch(ct->input_byte){\n\t\tcase ESCAPE:\n\t\t    if(ct->ctx.inest){\n\t\t\terror_message(\"?Unterminated Iteration\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    if(ct->ctx.cnest){\n\t\t\terror_message(\"?Unterminated Conditional\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_FINALSTATE;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->opcode = TOK_C_FINALTOKEN;\n\t\t    return;\n\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here if we have seen an E as a lead-in to one of the E commands.\n */\n\tcase STATE_C_ECOMMAND:\n\t    switch(ct->input_byte){\n/*\n * The EB command creates a new edit buffer and reads the specified file in.\n * If the command is given an argument, then this is a shorthand switch to\n * the buffer that has that number.\n */\n\t\tcase 'B': case 'b':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    if(ct->ctx.iarg1_flag == YES){\n\t\t\tct->execute_state = EXEC_C_EDITBUF;\n\t\t\tif(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\t    oct = ct;\n\t\t\t    ct = allocate_cmd_token(oct);\n\t\t\t    if(ct == NULL){\n\t\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\t\treturn;\n\t\t\t    }/* End IF */\n\t\t\t    ct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\t\t    ct->execute_state = EXEC_C_STORE1;\n\t\t\t}/* End IF */\n\t\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_EDITBUF;\n\t\t    return;\n/*\n * The EC command allows you to execute a command, and the output is placed\n * into the edit buffer.\n */\n\t\tcase 'C': case 'c':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_ECCOMMAND;\n\t\t    return;\n/*\n * The EF command closes the current edit buffer. If the current buffer\n * is modified, the command will fail unless the user specifies an argument\n * to the command.\n */\n\t\tcase 'F': case 'f':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->execute_state = EXEC_C_CLOSEBUF;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\toct = ct;\n\t\t\tct = allocate_cmd_token(oct);\n\t\t\tif(ct == NULL){\n\t\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\t    return;\n\t\t\t}/* End IF */\n\t\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\t\tct->execute_state = EXEC_C_STORE1;\n\t\t    }/* End IF */\n\t\t    return;\n/*\n * The EI command allows you to alter immediate execution mode. With no\n * argument, execute mode is turned off for the remainder of the current\n * command. An argument of 0 turns it off until further notice and an\n * argument of 1 turns it back on.\n */\n\t\tcase 'I': case 'i':\n\t\t    if(parse_more_than_one_arg(ct,\"EI\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\n\t\t    if(ct->ctx.iarg1_flag == NO){\n\t\t\tct->ctx.go_flag = NO;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->execute_state = EXEC_C_SET_IMMEDIATE_MODE;\n\t\t    return;\n/*\n * The EJ command allows you to load runtime options into TECO.\n */\n\t\tcase 'J': case 'j':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_SETOPTIONS;\n\t\t    return;\n\t\t    \n/*\n * The EP command splits the current window in half. If an argument is\n * supplied, the command deletes the current window.\n */\n\t\tcase 'P': case 'p':\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_WINDOW_CONTROL;\n\t\t    return;\n/*\n * The EV command works exactly like the EB command except that the buffer\n * which is created is 'readonly'. Thus this command stands for 'VIEW' file.\n */\n\t\tcase 'V': case 'v':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    if(ct->ctx.iarg1_flag == YES){\n\t\t\tct->execute_state = EXEC_C_VIEWBUF;\n\t\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_VIEWBUF;\n\t\t    return;\n/*\n * The EQ command reads a file into the specified Q-register.\n */\n\t\tcase 'Q': case 'q':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    if(parse_any_arguments(ct,\"EQ\")) return;\n\t\t    ct->ctx.state = STATE_C_EQQREGISTER1;\n\t\t    return;\n/*\n * The ER command reads the specified file into the current buffer location.\n */\n\t\tcase 'R': case 'r':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_READFILE;\n\t\t    return;\n/*\n * The ES command causes the screen to scroll\n */\n\t\tcase 'S': case 's':\n\t\t    if(parse_more_than_one_arg(ct,\"ES\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_SCROLL;\n\t\t    return;\n/*\n * The ET command causes the screen to update\n */\n\t\tcase 'T': case 't':\n\t\t    if(parse_any_arguments(ct,\"ET\")) return;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_UPDATE_SCREEN;\n\t\t    return;\n/*\n * The EW command writes out the current buffer\n */\n\t\tcase 'W': case 'w':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_WRITEFILE;\n\t\t    return;\n/*\n * The EX command causes the editor to exit\n */\n\t\tcase 'X': case 'x':\n\t\t    ct->execute_state = EXEC_C_EXITCOMMAND;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->ctx.go_flag = NO;\n\t\t    return;\n\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\n\t\t\t\"?Unknown command E%c\",UPCASE((int)ct->input_byte));\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here if we have seen an F as a lead-in to one of the F commands.\n */\n\tcase STATE_C_FCOMMAND:\n\t    switch(ct->input_byte){\n/*\n * The FD command finds the string and deletes it.\n */\n\t\tcase 'D': case 'd':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_FDCOMMAND;\n\t\t    return;\n/*\n * The FK command clears the text between the current position and the position\n * of the searched for text. The searched for text is left unmodified.\n */\n\t\tcase 'K': case 'k':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_FKCOMMAND;\n\t\t    return;\n/*\n * The FS command finds the first string and replaces it with the second\n */\n\t\tcase 'S': case 's':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_FSPART1;\n\t\t    return;\n/*\n * The FT command is a Video TECO extension to read & use a unix style\n * tags file.\n */\n\t\tcase 'T': case 't':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->ctx.state = STATE_C_STRING;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_FTAGS;\n\t\t    return;\n\n/*\n * The FR command acts like the FS command except that if the second argument\n * is NULL, the string is replaced with the last replace value.\n */\n\t\tcase 'R': case 'r':\n\t\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\t\tct->ctx.flags |= CTOK_M_STATUS_PASSED;\n\t\t    }/* End IF */\n\t\t    ct->execute_state = EXEC_C_SEARCH;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->execute_state = EXEC_C_FRREPLACE;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){  /* mch */\n\t\t\tct = allocate_cmd_token(ct);\n\t\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\t\tct->execute_state = EXEC_C_STORE1;\n\t\t    }/* End IF */\n\n\t\t    return;\n/*\n * Here when we have an 'F' command with an unknown second character. This\n * makes it an illegal command, and we don't waste any time letting the user\n * know about it.\n */\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\n\t\t\t\"?Unknown command F%c\",UPCASE((int)ct->input_byte));\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n/*\n * The following state is the return-state from STRING when the first part\n * of an FS command has been parsed.\n */\n\tcase STATE_C_FSPART1:\n\t    ct->ctx.state = STATE_C_FSPART2;\n\t    ct->execute_state = EXEC_C_SEARCH;\n\t    oct = ct;\n\t    ct = allocate_cmd_token(oct);\n\t    if(ct == NULL){\n\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->execute_state = EXEC_C_FSREPLACE1;\n\t    return;\n\n\tcase STATE_C_FSPART2:\n\t    ct->flags |= TOK_M_WORDBOUNDARY;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_FSPART3;\n\t    return;\n\n\tcase STATE_C_FSPART3:\n\t    if(ct->ctx.flags & CTOK_M_ATSIGN_SEEN){\n\t\tif(ct->input_byte == ct->ctx.delimeter){\n\t\t    ct->ctx.state = STATE_C_ESCAPESEEN;\n\t\t    ct->execute_state = EXEC_C_FSREPLACE3;\n\t\t    return;\n\t\t}\n\n\t\telse {\n\t\t    ct->ctx.state = STATE_C_FSPART3;\n\t\t    ct->execute_state = EXEC_C_FSREPLACE2;\n\t\t    return;\n\n\t\t}\n\t    }\n\n\t    if(ct->input_byte == ESCAPE){\n\t\tct->ctx.state = STATE_C_ESCAPESEEN;\n\t\tct->execute_state = EXEC_C_FSREPLACE3;\n\t\tif(ct->ctx.flags & CTOK_M_STATUS_PASSED){  /* mch */\n\t\t    ct = allocate_cmd_token(ct);\n\t\t    ct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\t    ct->execute_state = EXEC_C_STORE1;\n\t\t}/* End IF */\n\t\treturn;\n\t    }\n\n\t    else {\n\t\tct->ctx.state = STATE_C_FSPART3;\n\t\tct->execute_state = EXEC_C_FSREPLACE2;\n\t\treturn;\n\n\t    }\n\n#ifdef WIMPY_CODER_WHO_HAS_NOT_HANDLED_THIS_YET\n\t\tcase CNTRL_V:\n\t\t    ct->ctx.state = STATE_C_QUOTED_INSERT;\n\t\t    return;\n#endif /* WIMPY_CODER_WHO_HAS_NOT_HANDLED_THIS_YET */\n\n/*\n * This state is the return state from STRING and the TAGS command is\n * ready to execute.\n */\n\tcase STATE_C_FTAGS:\n\t    ct->execute_state = EXEC_C_FTAGS;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n\n/*\n * The following state is the return-state from STRING when a search string\n * has been completely specified.\n */\n\tcase STATE_C_SEARCH:\n\t    ct->execute_state = EXEC_C_SEARCH;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is the return-state from STRING when a search string\n * has been completely specified for the 'N' search command.\n */\n\tcase STATE_C_NSEARCH:\n\t    ct->execute_state = EXEC_C_NSEARCH;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is the return-state from STRING when the search part\n * of an FD command has been parsed.\n */\n\tcase STATE_C_FDCOMMAND:\n\t    ct->execute_state = EXEC_C_SEARCH;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    oct = ct;\n\t    ct = allocate_cmd_token(oct);\n\t    if(ct == NULL){\n\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->ctx.carg = NULL;\n\t    ct->execute_state = EXEC_C_FDCOMMAND;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){  /* mch */\n\t\tct = allocate_cmd_token(ct);\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is the return-state from STRING when the search part\n * of an FK command has been parsed.\n */\n\tcase STATE_C_FKCOMMAND:\n\t    ct->execute_state = EXEC_C_REMEMBER_DOT;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    oct = ct;\n\t    ct = allocate_cmd_token(oct);\n\t    if(ct == NULL){\n\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->execute_state = EXEC_C_SEARCH;\n\t    oct = ct;\n\t    ct = allocate_cmd_token(oct);\n\t    if(ct == NULL){\n\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->ctx.carg = NULL;\n\t    ct->execute_state = EXEC_C_FKCOMMAND;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){  /* mch */\n\t\tct = allocate_cmd_token(ct);\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\n\t    return;\n/*\n * The following state is a return-state from STRING when we have seen an\n * escape terminated string which in this case is the name of the file to\n * write.\n */\n\tcase STATE_C_WRITEFILE:\n\t    ct->execute_state = EXEC_C_WRITEFILE;\n\t    ct->ctx.go_flag = NO;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is a return-state from STRING when we have seen an\n * escape terminated string which in this case is the name of the file to\n * read into the current buffer location.\n */\n\tcase STATE_C_READFILE:\n\t    ct->execute_state = EXEC_C_READFILE;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is a return-state from STRING when we have seen an\n * escape terminated string which in this case is the name of the file which\n * we want to create a buffer for and load.\n */\n\tcase STATE_C_EDITBUF:\n\t    ct->execute_state = EXEC_C_EDITBUF;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(ct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is a return-state from STRING when we have seen an\n * escape terminated string which in this case is the name of the file which\n * we want to create a readonly buffer for and load.\n */\n\tcase STATE_C_VIEWBUF:\n\t    ct->execute_state = EXEC_C_VIEWBUF;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(ct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state is a return-state from STRING when we have seen an\n * escape terminated string which in this case is the command the user wants\n * to execute.\n */\n\tcase STATE_C_ECCOMMAND:\n\t    ct->execute_state = EXEC_C_ECCOMMAND;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    if(ct->input_byte == ESCAPE) ct->ctx.state = STATE_C_ESCAPESEEN;\n\t    if(ct->ctx.flags & CTOK_M_STATUS_PASSED){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state gets entered when the user has typed ^A\n * to print out a message.\n */\n\tcase STATE_C_MESSAGE:\n\t    switch(ct->input_byte){\n\t\tcase CNTRL_A:\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    ct->execute_state = EXEC_C_OUTPUT_MESSAGE;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->execute_state = EXEC_C_MESSAGE;\n\t\t    ct->ctx.state = STATE_C_MESSAGE;\n\t\t    return;\n\t    }/* End Switch */\n\n/*\n * The following state is a return-state from EXPRESSION when we have seen\n * what appears to be a first argument. It stashes the argument and tests if\n * there is a second argument available (indicated by a comma).\n */\n\tcase STATE_C_ARG1:\n\t    ct->ctx.iarg1_flag = YES;\n\t    ct->execute_state = EXEC_C_STORE1;\n\t    switch(ct->input_byte){\n\t\tcase ',':\n\t\t    ct->ctx.state = STATE_C_EXPRESSION;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_ARG2;\n\t\t    return;\n\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here if the first argument was followed by a comma. This indicates that a\n * second argument is being specified. Only certain commands accept a double\n * argument.\n */\n\tcase STATE_C_ARG2:\n\t    ct->ctx.iarg2_flag = YES;\n\t    ct->execute_state = EXEC_C_STORE2;\n\t    switch(ct->input_byte){\n\t\tcase ',':\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    error_message(\"?Maximum of two arguments exceeded\");\n\t\t    return;\n\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_MAINCOMMANDS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * The next state is the expression substate. States outside of the expression\n * parser call through here so that pnest (the current nesting level of\n * parentheses) gets set to zero. Then it calls the expression parser's own\n * internal sub-expression state.\n */\n\tcase STATE_C_EXPRESSION:\n\t    ct->ctx.pnest = 0;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_SUBEXPRESSION;\n\t    return;\n/*\n * This is the sub-expression state. It gets called from within the expression\n * parser when we want to recursively parse an expression. This lets us handle\n * precedence and parenthesis correctly.\n */\n\tcase STATE_C_SUBEXPRESSION:\n\t    switch(ct->input_byte){\n/*\n * When we see an open parenthesis, we want to recursively call the\n * subexpression state to parse the contents of the parenthesis. Since the open\n * parenthesis always occurs in place of an operand, we set that to be the next\n * state to call.\n */\n\t\tcase '(':\n\t\t    ct->ctx.pnest += 1;\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_OPERATOR;\n\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_OPERATOR;\n\t\t    return;\n/*\n * If we see a minus sign here, it is a unary minus. The difference between\n * the unary minus and the normal minus is one of precedence. The unary minus\n * is very high precedence.\n */\n\t\tcase '-':\n\t\t    ct->ctx.state = STATE_C_MINUSSEEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_UMINUS;\n\t\t    return;\n/*\n * Here on a leading % command. This just means he is going to default to\n * incrementing the queue register by one.\n */\n\t\tcase '%':\n\t\t    ct->ctx.tmpval = 1;\n\t\t    ct->flags |= TOK_M_PARSELOAD_TMPVAL;\n/* ;;; the following line shouldn't be required, but is. A bug. */\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.state = STATE_C_PERCENT_OPERAND;\n\t\t    return;\n/*\n * Well, not much exciting going on here, so we just call the normal operand\n * state to parse the current token.\n */\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_OPERATOR;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here if we saw a unary minus. The reason for calling this state at all is to\n * catch constructs like -L which really implies -1L. In a case like this,\n * the OPERAND state will not see anything it understands, and will return.\n * So as to make the defaulting work correctly, we catch that case here and\n * default so that we get our -1.\n */\n\tcase STATE_C_MINUSSEEN:\n\t    switch(ct->input_byte){\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\tcase 'Q': case 'q': case '%':\n\t\tcase '.':\n#ifdef CLASSIC_B_BEHAVIOR\n\t\tcase 'B': case 'b':\n#endif\n\t\tcase 'Z': case 'z':\n\t\tcase '(':\n\t\tcase '^':\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\n\t\tdefault:\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = 1;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here on the return from the OPERAND state. Whatever it parsed, we want to\n * make it minus.\n */\n\tcase STATE_C_UMINUS:\n\t    ct->execute_state = EXEC_C_UMINUS;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    return;\n/*\n * Here when we are expecting an operator like + = * /. Note that ')' also gets\n * handled here since it always appears in the place an operator would be\n * expected to appear.\n */\n\tcase STATE_C_OPERATOR:\n\t    switch(ct->input_byte){\n/*\n * Here on an a-b case. Note that since minus is a low precedence operator,\n * we stash the temporary value, and call subexpression to parse the rest\n * of the expression. In that way, if the next operator was * or /, it will\n * get processed first.\n */\n\t\tcase '-':\n\t\t    ct->execute_state = EXEC_C_STORE2;\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_MINUS;\n\t\t    return;\n/*\n * Here on an a+b case. This is similar to the case above in that we want to\n * just stash the first value, and then recursively call the parser to handle\n * the rest of the expression first. Note that this causes a+b+c to actually\n * get handled as a+(b+c) which is a little weird, but works out ok.\n */\n\t\tcase '+':\n\t\t    ct->execute_state = EXEC_C_STORE2;\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_PLUS;\n\t\t    return;\n/*\n * Here on the a*b case. Unlike the above two cases, we want to immediately\n * handle this case since it is the highest precedence of the four operators.\n */\n\t\tcase '*':\n\t\t    ct->execute_state = EXEC_C_STORE1;\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_TIMES;\n\t\t    return;\n/*\n * Here on the a/b case. This is just like the multiply state\n */\n\t\tcase '/':\n\t\t    ct->execute_state = EXEC_C_STORE1;\n\t\t    ct->ctx.state = STATE_C_OPERAND;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_DIVIDE;\n\t\t    return;\n\n/*\n * Here on the n%q case. This just collapses to the value of the Q-register\n * after it has been incremented by 'n'\n */\n\t\tcase '%':\n\t\t    ct->ctx.state = STATE_C_PERCENT_OPERAND;\n\t\t    return;\n/*\n * Here on the 'A' command which returns a value\n */\n\t\tcase 'A': case 'a':\n\t\t    ct->execute_state = EXEC_C_ACOMMAND;\n\t\t    ct->ctx.state = STATE_C_OPERATOR;\n\t\t    return;\n/*\n * Here on a close parenthesis. This will force the end of a subexpression\n * parse even though it would not normally have terminated yet. Note the check\n * for the guy typing too many of these.\n */\n\t\tcase ')':\n\t\t    if(ct->ctx.pnest == 0){\n\t\t\terror_message(\"?No Matching Open Parenthesis\");\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.pnest -= 1;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n/*\n * If this is not an operator character, it must be the end of the expression.\n * In this case, we must be back at the zero level for parenthesis nesting.\n */\n\t\tdefault:\n\t\t    if(ct->ctx.pnest > 0){\n\t\t\tsprintf(tmp_message,\"?Missing %d Close Parenthesis\",\n\t\t\t    ct->ctx.pnest);\n\t\t\terror_message(tmp_message);\n\t\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here when we have the 'b' part of an a+b expression. This happens either\n * when the end of the expression has been completed, or a parenthesis has\n * forced a temporary end as in: (a+b)\n */\n\tcase STATE_C_PLUS:\n\t    switch(ct->input_byte){\n\t\tcase '-':\n\t\tcase '+':\n\t\tcase ')':\n\t\t    ct->execute_state = EXEC_C_PLUS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_OPERATOR;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_OPERATOR;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_DELAYED_PLUS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n\n\tcase STATE_C_DELAYED_PLUS:\n\t    ct->execute_state = EXEC_C_PLUS;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    return;\n\n/*\n * Here when we have the 'b' part of an a-b expression. This happens either\n * when the end of the expression has been completed, or a parenthesis has\n * forced a temporary end as in: (a-b)\n */\n\tcase STATE_C_MINUS:\n\t    switch(ct->input_byte){\n\t\tcase '-':\n\t\tcase '+':\n\t\tcase ')':\n\t\t    ct->execute_state = EXEC_C_MINUS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_OPERATOR;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_OPERATOR;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    oct = ct;\n\t\t    ct = allocate_cmd_token(oct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->ctx.caller_token = oct;\n\t\t    ct->ctx.return_state = STATE_C_DELAYED_MINUS;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n\t    }/* End Switch */\n\n\tcase STATE_C_DELAYED_MINUS:\n\t    ct->execute_state = EXEC_C_MINUS;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    return;\n\n/*\n * Here when we have both arguments to a multiply. Because multiply is a higher\n * precedence operator than +-, it happens immediately unless parenthesis get\n * involved.\n */\n\tcase STATE_C_TIMES:\n\t    ct->execute_state = EXEC_C_TIMES;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    return;\n/*\n * Here when we have both arguments to a divide. Because division is a higher\n * precedence operator than -+, it generally happens immediately. Note that we\n * check to be sure that the divisor is non-zero.\n */\n\tcase STATE_C_DIVIDE:\n\t    ct->execute_state = EXEC_C_DIVIDE;\n\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    return;\n/*\n * Here to parse any legal TECO operand. These would include numbers and\n * commands that return values. Since open parenthesis occur in the same place\n * as operands, we also catch them here.\n */\n\tcase STATE_C_OPERAND:\n\t    switch(ct->input_byte){\n/*\n * If we see a numeric digit, call a substate which will continue eating bytes\n * until a non-digit is seen.\n */\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t    ct->ctx.state = STATE_C_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->input_byte - '0';\n\t\t    return;\n/*\n * Here if he wants to input in a different radix\n */\n\t\tcase '^':\n\t\t    ct->ctx.state = STATE_C_RADIX;\n\t\t    ct->ctx.tmpval = 0;\n\t\t    return;\n/*\n * Here if he is specifying the numeric value of a q-register. We have to go\n * to another state to determine which q-register he wants to access.\n */\n\t\tcase 'Q': case 'q':\n\t\t    ct->ctx.state = STATE_C_QOPERAND;\n\t\t    return;\n/*\n * Here when he has specified <dot>. This will return as a value the current\n * position in the edit buffer.\n */\n\t\tcase '.':\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    ct->execute_state = EXEC_C_DOTVALUE;\n\t\t    return;\n#ifdef CLASSIC_B_BEHAVIOR\n/*\n * B is a special operand which returns the address of the first character\n * in the buffer. This is currently always 0, but may change if some really\n * obscure features get put in one of these days.\n */\n\t\tcase 'B': case 'b':\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = 0;\n\t\t    return;\n#endif\n/*\n * Z is a special operand which is the number of characters currently in the\n * edit buffer.\n */\n\t\tcase 'Z': case 'z':\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    ct->execute_state = EXEC_C_ZEEVALUE;\n\t\t    return;\n/*\n * BACKSLASH with no argument actually looks in the buffer at the current\n * position and eats numeric digits until it hits a non-digit. It then\n * returns the number as a value.\n */\n\t\tcase '\\\\':\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_BACKSLASH;\n\t\t    ct->ctx.tmpval = 10;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct = allocate_cmd_token(ct);\n\t\t    if(ct == NULL){\n\t\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\t\treturn;\n\t\t    }/* End IF */\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->execute_state = EXEC_C_STORE1;\n\t\t    return;\n/*\n * If we see a parenthesis in place of an operand, we want to parse it as\n * a complete expression of its own until a matching close parenthesis.\n */\n\t\tcase '(':\n\t\t    ct->ctx.state = STATE_C_SUBEXPRESSION;\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    return;\n/*\n * We really should not get here if the guy is typing good syntax, so we\n * tell him it is junk and we don't allow it.\n */\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\n\t\t\t\"?Unexpected character <%c> in operand\",\n\t\t\tct->input_byte);\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n/*\n * The following is a substate to parse a number. It will continue until\n * it sees a non-digit, and then return to the calling state.\n */\n\tcase STATE_C_NUMBER_SUBSTATE:\n\t    switch(ct->input_byte){\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t    ct->ctx.state = STATE_C_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->ctx.tmpval * 10 + ct->input_byte - '0';\n\t\t    return;\n\t\tdefault:\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n\t    }/* End Switch*/\n/*\n * The following is a substate to parse a hex number. It will continue until\n * it sees a non hex digit, and then return to the calling state.\n */\n\tcase STATE_C_HEX_NUMBER_SUBSTATE:\n\t    switch(ct->input_byte){\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval *= 16;\n\t\t    ct->ctx.tmpval += ct->input_byte - '0';\n\t\t    return;\n\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\tcase 'f':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval *= 16;\n\t\t    ct->ctx.tmpval += ct->input_byte - 'a' + 10;\n\t\t    return;\n\t\tcase 'A': case 'B': case 'C': case 'D': case 'E':\n\t\tcase 'F':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval *= 16;\n\t\t    ct->ctx.tmpval += ct->input_byte - 'A' + 10;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n\t    }/* End Switch*/\n/*\n * The following is a substate to parse a octal number. It will continue until\n * it sees a non octal digit, and then return to the calling state.\n */\n\tcase STATE_C_OCTAL_NUMBER_SUBSTATE:\n\t    switch(ct->input_byte){\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7':\n\t\t    ct->ctx.state = STATE_C_OCTAL_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval *= 8;\n\t\t    ct->ctx.tmpval += ct->input_byte - '0';\n\t\t    return;\n\t\tcase '8': case '9':\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\"?Illegal octal digit <%c> in operand\",\n\t\t\tct->input_byte);\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t\tdefault:\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_RETURN;\n\t\t    return;\n\t    }/* End Switch*/\n/*\n * The following state gets the value of the specified q-register\n */\n\tcase STATE_C_QOPERAND:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_RETURN;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_QVALUE;\n\t    return;\n/*\n * This is just like QOPERAND except the execute state is different\n */\n\tcase STATE_C_PERCENT_OPERAND:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_OPERATOR;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_PERCENT_VALUE;\n\t    return;\n/*\n * Here on a input radix character\n */\n\tcase STATE_C_RADIX:\n\t    switch(ct->input_byte){\n\t\tcase 'X': case 'x':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    return;\n\t\tcase 'O': case 'o':\n\t\t    ct->ctx.state = STATE_C_OCTAL_NUMBER;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\"?Unknown radix ^<%c> in operand\",\n\t\t\tct->input_byte);\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch */\n\n\tcase STATE_C_HEX_NUMBER:\n\t    switch(ct->input_byte){\n\t\tcase '\\\\':\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_BACKSLASH;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = 16;\n\t\t    return;\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->input_byte - '0';\n\t\t    return;\n\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\tcase 'f':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->input_byte - 'a' + 10;\n\t\t    return;\n\t\tcase 'A': case 'B': case 'C': case 'D': case 'E':\n\t\tcase 'F':\n\t\t    ct->ctx.state = STATE_C_HEX_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->input_byte - 'A' + 10;\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\"?Illegal hex digit <%c> in operand\",\n\t\t\tct->input_byte);\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t}/* End Switch */\n\n\tcase STATE_C_OCTAL_NUMBER:\n\t    switch(ct->input_byte){\n\t\tcase '\\\\':\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_BACKSLASH;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = 8;\n\t\t    return;\n\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\tcase '5': case '6': case '7':\n\t\t    ct->ctx.state = STATE_C_OCTAL_NUMBER_SUBSTATE;\n\t\t    ct->execute_state = EXEC_C_STOREVAL;\n\t\t    ct->ctx.tmpval = ct->input_byte - '0';\n\t\t    return;\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    sprintf(tmp_message,\"?Illegal octal digit <%c> in operand\",\n\t\t\tct->input_byte);\n\t\t    error_message(tmp_message);\n\t\t    return;\n\t    }/* End Switch*/\n\n/*\n * The next state is the string substate. Outside states call in through here\n * which does the initial tec_alloc of the string storage. Strings are limited\n * to PARSER_STRING_MAX bytes at this time.\n */\n\tcase STATE_C_STRING:\n\t    if((ct->ctx.flags & CTOK_M_ATSIGN_SEEN) == 0){\n\t\tct->ctx.delimeter = ESCAPE;\n\t\tct->flags &= ~TOK_M_EAT_TOKEN;\n\t    }\n\t    else {\n\t\tct->ctx.delimeter = ct->input_byte;\n\t    }\n\t    ct->ctx.state = STATE_C_STRING1;\n\t    return;\n\n\tcase STATE_C_STRING1:\n/*\n * First, check if this is the termination character. This would normally be\n * an escape, but could be another character if the user used the @ form.\n */\n\t    if( ( (ct->input_byte == ESCAPE) &&\n\t\t  (!(ct->ctx.flags & CTOK_M_ATSIGN_SEEN))\n\t\t) ||\n\t\t( (ct->ctx.flags & CTOK_M_ATSIGN_SEEN) &&\n\t\t  (ct->input_byte == ct->ctx.delimeter) &&\n\t\t  (ct->ctx.carg != NULL)\n\t\t)\n\t      ){\n\t\tct->flags &= ~TOK_M_EAT_TOKEN;\n\t\tct->ctx.state = STATE_C_RETURN;\n\t\treturn;\n\t    }/* End IF */\n\n/*\n * Here when we see a normal character inside of the string. Note that we\n * have to do the undo stuff to manage the string since it gets stored in\n * a regular string array rather than being spread through the command\n * tokens.\n */\n\t    {/* Local Block */\n\t    register char *cp;\n\t    register struct undo_token *ut;\n/*\n * Get the address of the string\n */\n\t    cp = ct->ctx.carg;\n/*\n * If there is no string allocated yet, then we have to allocate one.\n * Also, if an @ was seen, then record the delimeter character.\n */\n\t    if(cp == NULL){\n\t\tct->ctx.carg = cp = tec_alloc(TYPE_C_CBUFF,PARSER_STRING_MAX);\n\t\tif(cp == NULL){\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\t*cp = '\\0';\n\t\tut = allocate_undo_token(uct);\n\t\tif(ut == NULL){\n\t\t    ct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tut->opcode = UNDO_C_MEMFREE;\n\t\tut->carg1 = cp;\n\t    }/* End IF */\n/*\n * Each time we append a character to the string, we also have to allocate\n * an undo token which will shorten the string if the input character gets\n * rubbed out.\n */\n\t    ut = allocate_undo_token(uct);\n\t    if(ut == NULL){\n\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ut->opcode = UNDO_C_SHORTEN_STRING;\n\t    ut->carg1 = cp;\n\t    ut->iarg1 = 0;\n\t    while(*cp){\n\t\tut->iarg1 += 1;\n\t\tcp++;\n\t    }/* End While */\n\t    if(ut->iarg1 >= (PARSER_STRING_MAX-1)){\n\t\tsprintf(tmp_message,\"?Exceeded maximum string length of %d\",\n\t\t    PARSER_STRING_MAX-1);\n\t\terror_message(tmp_message);\n\t\tct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n/*\n * Finally, we append the input byte to the string\n */\n\t    *cp++ = ct->input_byte;\n\t    *cp++ = '\\0';\n\t    ct->ctx.state = STATE_C_STRING1;\n\t    return;\n\t    }/* End Local Block */\n/*\n * The following state gets the Q register that will be used with the\n * G command.\n */\n\tcase STATE_C_GQREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_GQREGISTER;\n\t    return;\n/*\n * The following state gets the Q register that will be used with the\n * M command.\n */\n\tcase STATE_C_MQREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_MQREGISTER;\n\t    return;\n/*\n * The following two states implement the EQ command which reads a file into\n * the specified Q-register.\n */\n\tcase STATE_C_EQQREGISTER1:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->execute_state = EXEC_C_STOREVAL;\n\t    ct->ctx.tmpval = ct->input_byte;\n\t    ct->ctx.state = STATE_C_STRING;\n\n\t    oct = ct;\n\t    ct = allocate_cmd_token(oct);\n\t    if(ct == NULL){\n\t\toct->ctx.state = STATE_C_ERRORSTATE;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->ctx.caller_token = oct;\n\t    ct->ctx.return_state = STATE_C_EQQREGISTER2;\n\t    return;\n\tcase STATE_C_EQQREGISTER2:\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->execute_state = EXEC_C_EQQREGISTER;\n\t    if(ct->ctx.flags & CTOK_M_COLON_SEEN){\n\t\toct = ct;\n\t\tct = allocate_cmd_token(oct);\n\t\tif(ct == NULL){\n\t\t    oct->ctx.state = STATE_C_ERRORSTATE;\n\t\t    return;\n\t\t}/* End IF */\n\t\tct->ctx.iarg1_flag = YES; ct->ctx.iarg2_flag = NO;\n\t\tct->execute_state = EXEC_C_STORE1;\n\t    }/* End IF */\n\t    return;\n/*\n * The following state gets the Q register that will be loaded with the\n * U command.\n */\n\tcase STATE_C_UQREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_UQREGISTER;\n\t    return;\n/*\n * The following state gets the Q register that will be loaded with the\n * X command.\n */\n\tcase STATE_C_XQREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_XQREGISTER;\n\t    return;\n/*\n * The following state gets the Q register that will be loaded with the\n * previous command line in response to the '*' command.\n */\n\tcase STATE_C_SAVECOMMAND:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_SAVECOMMAND;\n\t    return;\n/*\n * The following state gets the Q register which will be pushed onto the\n * Q register stack.\n */\n\tcase STATE_C_PUSH_QREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_PUSH_QREGISTER;\n\t    return;\n/*\n * The following state gets the Q register which will be popped from the\n * Q register stack.\n */\n\tcase STATE_C_POP_QREGISTER:\n\t    if(!parse_check_qname(ct,ct->input_byte)) return;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->q_register = ct->input_byte;\n\t    ct->execute_state = EXEC_C_POP_QREGISTER;\n\t    return;\n\n/*\n * Here to insert characters. The insert state continues until an escape\n * is seen. Escapes can also be quoted if they are to be inserted into the\n * buffer. If there are many escapes to be inserted, it may be easier to use\n * the @ insert command...\n */\n\tcase STATE_C_INSERT:\n\t    switch(ct->input_byte){\n/*\n * Here when we see a non-quoted escape. This terminates the insert.\n */\n\t\tcase ESCAPE:\n\t\t    ct->flags &= ~TOK_M_EAT_TOKEN;\n\t\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t\t    return;\n/*\n * Here to enter a quote character. This lets you insert characters that would\n * normally be handled otherwise. ESCAPE is a good example of this.\n */\n\t\tcase CNTRL_V:\n\t\t    ct->ctx.state = STATE_C_QUOTED_INSERT;\n\t\t    return;\n/*\n * Here to handle a normal character. It will simply be inserted into the\n * edit buffer.\n */\n\t\tdefault:\n\t\t    ct->ctx.state = STATE_C_INSERT;\n\t\t    ct->execute_state = EXEC_C_INSERT;\n\t\t    return;\n\t    }/* End Switch */\n/*\n * Here to insert a character directly following the quote character. If\n * this is a special character such as an escape, it will be inserted and\n * will not terminate the insert command.\n */\n\tcase STATE_C_QUOTED_INSERT:\n\t    ct->ctx.state = STATE_C_INSERT;\n\t    ct->execute_state = EXEC_C_INSERT;\n\t    return;\n\n/*\n * Here for the alternate form of insert, @I/text/\n */\n\tcase STATE_C_ATINSERT:\n\t    ct->ctx.tmpval = ct->input_byte;\n\t    ct->execute_state = EXEC_C_STOREVAL;\n\t    ct->ctx.state = STATE_C_ATINSERT_PART2;\n\t    return;\n\n\tcase STATE_C_ATINSERT_PART2:\n\t    if(ct->input_byte == ct->ctx.tmpval){\n\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\treturn;\n\t    }/* End IF */\n\n\t    ct->ctx.state = STATE_C_ATINSERT_PART2;\n\t    ct->execute_state = EXEC_C_INSERT;\n\t    return;\n/*\n * Here after seeing an equals command. This lets us test for two or three\n * in a row which output in octal and hex respectively.\n */\n\tcase STATE_C_ONE_EQUALS:\n\t    if(ct->input_byte != '='){\n\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\tct->flags &= ~TOK_M_EAT_TOKEN;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->ctx.state = STATE_C_TWO_EQUALS;\n\t    ct->execute_state = EXEC_C_TWO_EQUALS;\n\t    return;\n\tcase STATE_C_TWO_EQUALS:\n\t    if(ct->input_byte != '='){\n\t\tct->ctx.state = STATE_C_INITIALSTATE;\n\t\tct->flags &= ~TOK_M_EAT_TOKEN;\n\t\treturn;\n\t    }/* End IF */\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    ct->execute_state = EXEC_C_THREE_EQUALS;\n\t    return;\n\n/*\n * Here when we have seen a vertical bar. We have to put a mark here so\n * that if the condition is not met, the else clause can be found.\n */\n\tcase STATE_C_SKIP_ELSE:\n\t    ct->opcode = TOK_C_CONDITIONAL_ELSE;\n\t    ct->ctx.state = STATE_C_INITIALSTATE;\n\t    return;\n\n\tcase STATE_C_BACKSLASH:\n\t    ct->ctx.state = STATE_C_RETURN;\n\t    ct->execute_state = EXEC_C_BACKSLASHARG;\n\t    return;\n\n\tdefault:\n\t    sprintf(tmp_message,\"?Dispatched unknown state %d\",ct->ctx.state);\n\t    error_message(tmp_message);\n\t    return;\n    }/* End Switch */\n\n}", "path": "tecstate.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Test if this is our label\n *\n * This routine is called by the GOTO function to compare labels\n * to see if they match.\n */\n", "func_signal": "int\ncompare_label( struct cmd_token *goto_ptr, struct cmd_token *label_ptr )", "code": "{\nchar string1[PARSER_STRING_MAX],string2[PARSER_STRING_MAX];\nchar *cp1;\n\n    PREAMBLE();\n\n    cp1 = string1;\n\n    *cp1 = '\\0';\n    while(goto_ptr){\n\tif(cp1 >= &string1[PARSER_STRING_MAX-1]) break;\n\tif(goto_ptr->opcode == TOK_C_INPUTCHAR){\n\t    if(goto_ptr->input_byte == ESCAPE) break;\n\t    *cp1++ = goto_ptr->input_byte;\n\t    *cp1 = '\\0';\n\t}/* End IF */\n\tif(goto_ptr->opcode == TOK_C_GOTO_END) break;\n\tgoto_ptr = goto_ptr->next_token;\n    }/* End While */\n\n    cp1 = string2;\n\n    *cp1 = '\\0';\n    while(label_ptr){\n\tif(cp1 >= &string2[PARSER_STRING_MAX-1]) break;\n\tif(label_ptr->opcode == TOK_C_INPUTCHAR){\n\t    if(label_ptr->input_byte == '!') break;\n\t    *cp1++ = label_ptr->input_byte;\n\t    *cp1 = '\\0';\n\t}/* End IF */\n\tif(label_ptr->opcode == TOK_C_LABEL_END) break;\n\tlabel_ptr = label_ptr->next_token;\n    }/* End While */\n\n    if(strcmp(string1,string2) == 0) return(YES);\n\n    return(NO);\n\n}", "path": "tecexec.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Routine to initialize the buffer routines\n *\n * This routine is called before the first buffer operations to\n * initialize the buffer routines.\n */\n", "func_signal": "int\nbuff_init()", "code": "{\n    register struct buff_header *hbp;\n    char tmp_buffer[LINE_BUFFER_SIZE];\n\n    PREAMBLE();\n/*\n * Create the buffer map buffer\n */\n    (void) strcpy(tmp_buffer,TECO_INTERNAL_BUFFER_NAME);\n    (void) strcat(tmp_buffer,\"BUFFER-MAP\");\n    hbp = buff_create(tmp_buffer,1);\n    if(hbp == NULL) return(FAIL);\n    hbp->buffer_number = 0;\n\n/*\n * Create a default edit buffer\n */\n    (void) strcpy(tmp_buffer,TECO_INTERNAL_BUFFER_NAME);\n    (void) strcat(tmp_buffer,\"Main\");\n    curbuf = hbp = buff_create(tmp_buffer,1);\n    if(hbp == NULL) return(FAIL);\n\n    return(SUCCESS);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Copy the specified number of bytes\n *\n * This routine copies 'n' bytes from the source to the\n * destination.\n */\n", "func_signal": "void\nmovc3( char *source, char *dest, int count )", "code": "{\n\n    PREAMBLE();\n    while(count-- > 0) *dest++ = *source++;\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Called by undo to re-create an edit buffer\n *\n * This routine is called to place a buffer back onto the buffer\n * list.\n */\n", "func_signal": "void\nbuff_reopenbuff( struct buff_header *bp )", "code": "{\nregister struct buff_header *obp;\n\n    PREAMBLE();\n/*\n * Make sure there isn't another buffer of this name already here. The\n * way this can happen is automatically created Q-registers like the\n * search string and rubout string Q-registers might be created. Since\n * they don't get undone, they would stick around and then we might\n * try to undo the removal of an earlier copy of one of them. This way,\n * we make sure that any earlier copy replaces any more recent copy.\n */\n    obp = buffer_headers;\n    while(obp){\n\tif(strcmp(obp->name,bp->name) == 0){\n\t    buff_destroy(obp);\n\t    break;\n\t}/* End IF */\n\tobp = obp->next_header;\n    }/* End While */\n/*\n * Insert this buffer in the proper place on the buffer list.\n */\n    obp = buffer_headers;\n    while(obp){\n\tif(obp->next_header == NULL) break;\n\tif(obp->next_header->buffer_number > bp->buffer_number) break;\n\tobp = obp->next_header;\n    }/* End While */\n\n    if(obp == NULL || buffer_headers->buffer_number > bp->buffer_number){\n\tbp->next_header = buffer_headers;\n\tbuffer_headers = bp;\n    }/* End IF */\n\n    else {\n\tbp->next_header = obp->next_header;\n\tobp->next_header = bp;\n    }/* End Else */\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Delete the character at the current position\n *\n * This routine is called to delete the single character which is at\n * the current buffer position.\n */\n", "func_signal": "int\nbuff_delete_char(\tstruct buff_header *hbp,\n\t\t\t\t\tint position )", "code": "{\nregister struct buff_line *lbp;\nstruct buff_line *nlbp;\nregister char *cp,*ocp;\nregister int i,j;\n\n    PREAMBLE();\n/*\n * Insure that the specified position is legal\n */\n    if(position >= hbp->zee){\n\tchar tmp_message[LINE_BUFFER_SIZE];\n\tsprintf(tmp_message,\"buff_delete_char: bad position %d %s Z = %d\\n\",\n\t    position,hbp->name,hbp->zee);\n\ttec_panic(tmp_message);\n    }/* End IF */\n/*\n * Call buff_find_line to find the line structure that the specified\n * position resides on.\n */\n    lbp = buff_find_line(hbp,position);\n    i = buff_find_offset(hbp,lbp,position);\n/*\n * If there is a format_line structure associated with this line, we make it\n * go away so that the screen display routine will rebuild the display contents\n * of this line.\n */\n    if(lbp->format_line){\n\tscreen_free_format_lines(lbp->format_line);\n\tlbp->format_line = NULL;\n    }/* End IF */\n/*\n * Get a pointer to the character that is about to be deleted\n */\n    cp = lbp->buffer + i;\n/*\n * Depending on whether or not the specified position precedes dot or not, we\n * may have to decrement dot.\n */\n    if(position < hbp->dot) hbp->dot -= 1;\n    hbp->zee -= 1;\n/*\n * If this has modified the buffer for the first time, it needs to be displayed\n * in the label line.\n */\n    if(hbp->ismodified == NO){\n\thbp->ismodified = YES;\n\tif(hbp == curbuf){\n\t    screen_label_line(hbp,\"(modified)\",LABEL_C_MODIFIED);\n\t}/* End IF */\n    }/* End IF */\n\n    checkpoint_modified = YES;\n\n/*\n * If we are deleting a character before the position cache, it will\n * shift our cached position up by one, so we adjust the cache.\n */\n    if(position < hbp->pos_cache.base){\n\thbp->pos_cache.base -= 1;\n    }/* End IF */\n/*\n * If this is not a newline, then things are pretty simple. Just\n * make the character go away...\n */\n    if(*cp != '\\n'){\n\tmovc3(cp+1,cp,lbp->byte_count-i-1);\n\tlbp->byte_count -= 1;\n\treturn(SUCCESS);\n    }/* End IF */\n\n/*\n * If this is a newline, we do things a little differently because this\n * actually causes the two lines to become concatenated (unless this is the\n * final line in the buffer). If the buffer area is not big enough to hold\n * both lines, we have to create a bigger area.\n */\n    nlbp = lbp->next_line;\n    if(nlbp == NULL){\n\tlbp->byte_count -= 1;\n\treturn(SUCCESS);\n    }/* End IF */\n\n/*\n * If there is a format_line structure associated with the second line, we make\n * it go away since this line is about to be trashed.\n */\n    if(nlbp->format_line){\n\tscreen_free_format_lines(nlbp->format_line);\n\tnlbp->format_line = NULL;\n    }/* End IF */\n\n/*\n * Test whether or not the buffer is big enough to hold the data from both\n * lines.\n */\n    j = lbp->byte_count + nlbp->byte_count - 1;\n    if(lbp->buffer_size < j){\n\ti = j + INCREMENTAL_LINE_BUFFER_SIZE - 1;\n\ti -= i % INCREMENTAL_LINE_BUFFER_SIZE;\n\tcp = tec_alloc(TYPE_C_LINEBUF,i);\n\tif(cp == NULL) return(FAIL);\n\tmovc3(lbp->buffer,cp,lbp->buffer_size);\n\ttec_release(TYPE_C_LINEBUF,lbp->buffer);\n\tlbp->buffer = cp;\n\tlbp->buffer_size = i;\n    }/* End IF */\n\n/*\n * Ok, now concatenate the two line buffers by copying the second line\n * into the first. Because we copy on top of the newline, it effectively\n * goes away, so we have to decrement the line count by one.\n */\n    lbp->byte_count -= 1;\n    cp = lbp->buffer + lbp->byte_count;\n    ocp = nlbp->buffer;\n    i = nlbp->byte_count;\n    while(i--){\n\t*cp++ = *ocp++;\n\tlbp->byte_count++;\n    }/* End While */\n\n/*\n * Fixup the next and previous pointers so that they point around the\n * line that we are about to remove.\n */\n    lbp->next_line = nlbp->next_line;\n    if(nlbp->next_line) nlbp->next_line->prev_line = lbp;\n\n    if(hbp->pos_cache.lbp == nlbp) hbp->pos_cache.lbp = NULL;\n    buff_free_line_buffer(nlbp);\n\n    return(SUCCESS);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Routine to read a file into a TECO edit buffer\n *\n * This routine is called to load a file into the named buffer. If the\n * buffer already exists, we simply switch to it and don't modify it.\n */\n", "func_signal": "int\nbuff_openbuffer(\tchar *name, int buffer_number, int readonly_flag )", "code": "{\n    register struct buff_header *hbp = NULL;\n\n    PREAMBLE();\n/*\n * If no name is supplied then the buffer_number argument is significant,\n * otherwise we ignore it.\n */\n    if(name == NULL){\n\thbp = buffer_headers;\n\twhile(hbp){\n\t    if(hbp->buffer_number == buffer_number){\n\t\tname = hbp->name;\n\t\tbreak;\n\t    }/* End IF */\n\t    hbp = hbp->next_header;\n\t}/* End While */\n    }/* End IF */\n/*\n * If no name is supplied, the buffer_number argument must already exist\n * or an error is declared.\n */\n    if(name == NULL){\n\terror_message(\"?No such buffer number exists\");\n\treturn(FAIL);\n    }/* End IF */\n/*\n * First determine if a buffer of that name already exists\n */\n    if(hbp == NULL){\n\thbp = buff_find(name);\n    }/* End IF */\n\n    if(hbp){\n\tbuff_switch(hbp,1);\n \treturn(SUCCESS);\n    }/* End IF */\n\n/*\n * If there is not such buffer in existence, we need to create one\n */\n    hbp = buff_create(name,0);\n    if(hbp == NULL) return(FAIL);\n    if(readonly_flag == YES) hbp->isreadonly = YES;\n\n/*\n * Ignore possible open error, since he may be creating a new file\n */\n    buff_read(hbp,name);\n\n    hbp->dot = 0;\n    hbp->ismodified = NO;\n\n    buff_switch(hbp,1);\n\n    return(SUCCESS);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Release a whole list of line buffers\n *\n * This routine will delete an entire list of line buffers\n */\n", "func_signal": "void\nbuff_free_line_buffer_list(\tstruct buff_line *lbp )", "code": "{\nregister struct buff_line *olbp;\n\n    PREAMBLE();\n\n    while((olbp = lbp)){\n\tlbp = lbp->next_line;\n\tbuff_free_line_buffer(olbp);\n    }/* End While */\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Free up lookaside list\n *\n * This routine frees up any format_lines we've cached on our local\n * lookaside list.\n */\n", "func_signal": "void\nbuff_deallocate_line_buffer_lookaside_list()", "code": "{\nregister struct buff_line *lbp;\n\n    PREAMBLE();\n\n    while((lbp = line_buffer_lookaside_list) != NULL){\n\tline_buffer_lookaside_list = lbp->next_line;\n\tlbp->lin_magic = 0;\n\ttec_release(TYPE_C_LINEBUF,lbp->buffer);\n\ttec_release(TYPE_C_LINE,(char *)lbp);\n    }/* End While */\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Build a string with the contents of the label in it\n *\n * This routine is called to build a string with the label name\n * in it. The current use is for error messages.\n */\n", "func_signal": "void\nextract_label( struct cmd_token *label_ptr, char *string1 )", "code": "{\nregister char *cp1;\n\n    cp1 = string1;\n    *cp1 = '\\0';\n    while(label_ptr){\n\tif(cp1 >= &string1[PARSER_STRING_MAX-1]) break;\n\tif(label_ptr->opcode == TOK_C_INPUTCHAR){\n\t    if(label_ptr->input_byte == '!') break;\n\t    *cp1++ = label_ptr->input_byte;\n\t    *cp1 = '\\0';\n\t}/* End IF */\n\tif(label_ptr->opcode == TOK_C_LABEL_END) break;\n\tlabel_ptr = label_ptr->next_token;\n    }/* End While */\n\n}", "path": "tecexec.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Make a duplicate of a buffer\n *\n * This routine is called to duplicate the specified buffer and return\n * a pointer to the duplicate. The current requirement for this is for\n * the push Q register command ('[').\n */\n", "func_signal": "struct buff_header *\nbuff_duplicate( struct buff_header *sbp )", "code": "{\nregister struct buff_header *dbp;\nregister struct buff_line *slp;\nregister struct buff_line *dlp;\n\n    PREAMBLE();\n/*\n * Create the buffer header itself.\n */\n    dbp = (struct buff_header *)\n\ttec_alloc(TYPE_C_BHDR,sizeof(struct buff_header));\n    if(dbp == NULL){\n\treturn((struct buff_header *)NULL);\n    }/* End IF */\n\n    dbp->name = tec_alloc(TYPE_C_CBUFF,strlen(sbp->name)+1);\n    if(dbp->name == NULL){\n\ttec_release(TYPE_C_BHDR,(char *)dbp);\n\treturn((struct buff_header *)NULL);\n    }/* End IF */\n\n    (void) strcpy(dbp->name,sbp->name);\n\n    dbp->buf_magic = MAGIC_BUFFER;\n    dbp->ismodified = sbp->ismodified;\n    dbp->isreadonly = sbp->isreadonly;\n    dbp->isbackedup = sbp->isbackedup;\n    dbp->dot = sbp->dot;\n    dbp->zee = sbp->zee;\n    dbp->ivalue = sbp->ivalue;\n    dbp->pos_cache.lbp = NULL;\n    dbp->pos_cache.base = 0;\n    dbp->first_line = NULL;\n\n/*\n * Copy the line buffer structures. If an allocation error occurs, we\n * have to return all the allocated memory, and return an error.\n */\n    slp = sbp->first_line;\n\n    if(slp){\n\tdbp->first_line = dlp = allocate_line_buffer(slp->byte_count);\n\tif(dlp == NULL){\n\t    buff_destroy(dbp);\n\t    return((struct buff_header *)NULL);\n\t}/* End IF */\n\tmovc3(slp->buffer,dlp->buffer,slp->byte_count);\n\tdlp->byte_count = slp->byte_count;\n\n\twhile((slp = slp->next_line)){\n\t    dlp->next_line = allocate_line_buffer(slp->byte_count);\n\t    if(dlp->next_line == NULL){\n\t\tbuff_destroy(dbp);\n\t\treturn((struct buff_header *)NULL);\n\t    }/* End IF */\n\t    dlp->next_line->prev_line = dlp;\n\t    dlp = dlp->next_line;\n\t    movc3(slp->buffer,dlp->buffer,slp->byte_count);\n\t    dlp->byte_count = slp->byte_count;\n\t}/* End While */\n\n    }/* End IF */\n\n    return(dbp);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Delete an existing buffer\n *\n * This routine is called to delete an existing buffer. The routine is\n * supplied the address of the buffer structure. We have to clean up\n * all the lines in the buffer, all the display lines, etc.\n */\n", "func_signal": "void\nbuff_destroy( struct buff_header *hbp )", "code": "{\nregister struct buff_header *bp;\nregister struct buff_line *lbp;\n\n    PREAMBLE();\n/*\n * There are certain buffers we don't allow to be destroyed\n */\n    if(strcmp(hbp->name,\"TECO_INTERNAL-Main\") == 0){\n\treturn;\n    }/* End IF */\n/*\n * Clean up all the data in the buffer first\n */\n    lbp = hbp->first_line;\n    hbp->pos_cache.lbp = NULL;\n    hbp->first_line = NULL;\n    buff_free_line_buffer_list(lbp);\n\n/*\n * Now unlink this buffer header from the header list.\n * Check to see if it is at the head of the list.\n */\n    bp = buffer_headers;\n    if(bp == hbp){\n\tbuffer_headers = bp->next_header;\n    }/* End IF */\n\n/*\n * If not at the head of the list, we have to search the list till\n * we find it's father. Then we make it's father's child be it's\n * child.\n */\n    else {\n\twhile(bp){\n\t    if(bp->next_header == hbp){\n\t\tbp->next_header =  hbp->next_header;\n\t\tbreak;\n\t    }/* End IF */\n\t    bp = bp->next_header;\n\t}/* End While */\n\n    }/* End Else */\n\n/*\n * Now give back the storage for the name, and for the structure itself.\n */\n    if(hbp->name) tec_release(TYPE_C_CBUFF,(char *)hbp->name);\n    tec_release(TYPE_C_BHDR,(char *)hbp);\n\n    return;\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Check that the specified Q-register name is ok\n *\n * This routine is called when a parse state wants to verify that the\n * specified Q-register name is syntactically correct. It does not\n * verify that the Q-register exists, because the execute phase may just\n * not have got around to that yet.\n */\n", "func_signal": "int\nparse_check_qname( struct cmd_token *ct, char name )", "code": "{\nchar tmp_message[LINE_BUFFER_SIZE];\n\n    PREAMBLE();\n\n    switch(name){\n\tcase '*':\n\tcase '_':\n\tcase '-':\n\tcase '@':\n\tcase '?':\n\t    return(SUCCESS);\n    }/* End Switch */\n\n    if(isalnum((int)name)) return(SUCCESS);\n\n    sprintf(tmp_message,\"?Illegal Q-register Name <%c>\",name);\n    error_message(tmp_message);\n    ct->ctx.state = STATE_C_ERRORSTATE;\n    return(FAIL);\n\n}", "path": "tecstate.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Return the character at the specified position\n *\n * This routine is called to fetch the single character which is at\n * the specified buffer position. This routine is generally called\n * by routines which are low frequence or only handle a small number\n * of characters at any one time.\n */\n", "func_signal": "int\nbuff_contents( struct buff_header *hbp, int position )", "code": "{\nregister struct buff_line *lbp;\nregister int i;\n\n    PREAMBLE();\n/*\n * Insure that the specified position is legal\n */\n    if(position > hbp->zee || position < 0){\n\tchar panic_string[LINE_BUFFER_SIZE];\n\tsprintf(panic_string,\n\t    \"buff_contents: illegal position %d specified in buffer %s\",\n\t    position,hbp->name);\n\ttec_panic(panic_string);\n    }/* End IF */\n\n/*\n * Call buff_find_line to find the line structure that the specified\n * position resides on.\n */\n    lbp = buff_find_line(hbp,position);\n    i = buff_find_offset(hbp,lbp,position);\n    if(i == -1) return(-1);\n\n    return(lbp->buffer[i] & 0xFF);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Delete specified number of characters\n *\n * This routine is called to delete the specified number of characters\n * at the specified location in the buffer.\n */\n", "func_signal": "void\nbuff_delete(\tstruct buff_header *hbp,\n\t\t\t\tint position,\n\t\t\t\tint count )", "code": "{\n\n    PREAMBLE();\n/*\n * Insure that there are that many character in the buffer after the specified\n * position.\n */\n    if((position + count) > hbp->zee){\n\tchar tmp_message[LINE_BUFFER_SIZE];\n\tsprintf(tmp_message,\"buff_delete: illegal range %d-%d %s Z = %d\\n\",\n\t    position,position+count,hbp->name,hbp->zee);\n\ttec_panic(tmp_message);\n    }/* End IF */\n/*\n * For now we are cheap and just repeatedly call the single character delete\n * routine, because this is simple. It is also very expensive and will have to\n * be fixed eventually.\n */\n    while(count){\n\tbuff_delete_char(hbp,position);\n\tcount -= 1;\n    }/* End While */\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Find the named buffer\n *\n * This routine is called with the name of the buffer that we want to\n * find. It searches all the buffer headers until it finds the name.\n * It will either return the address of the buffer header, or null if\n * it could not find one with the proper name.\n */\n", "func_signal": "struct buff_header *\nbuff_find( char *name )", "code": "{\nregister struct buff_header *bp;\nregister char *cp1,*cp2;\nunsigned int hash = stringHash( name );\n\n    PREAMBLE();\n    for(bp = buffer_headers; bp != NULL; bp = bp->next_header){\n\tif( hash != bp->buf_hash )\n\t{\n//\t    printf(\"skipping because hash 0x%08x != 0x%08x %s %s\\n\",\n//\t\thash, bp->buf_hash, name, bp->name);\n\t    continue;\n\t}\n\n//\tprintf(\"hash match! %s %s\\n\",name,bp->name);\n/*\n * This loop implements the equivalent of strcmp, except that in the\n * case of VMS, it is case insensitive.\n */\n\tfor(cp1 = name, cp2 = bp->name;;cp1++,cp2++){\n#ifdef VMS\n\t    if(UPCASE(*cp1) != UPCASE(*cp2)) break;\n#else\n\t    if(*cp1 != *cp2) break;\n#endif\n\t    if(*cp1 == '\\0') return(bp);\n\t}/* End FOR */\n\n    }/* End FOR */\n\n    return(NULL);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/**\n * \\brief Reads the file descriptor into the specified buffer\n *\n * This routine is called with a buffer and a file descriptor. The\n * entire contents of the file descriptor are read into the specified\n * buffer.\n */\n", "func_signal": "int\nbuff_readfd( struct buff_header *hbp, char *name, int iochan )", "code": "{\n    char iobuf[IO_BUFFER_SIZE];\n    char linebuf[IO_BUFFER_SIZE];\n    int linebuf_cnt;\n    char tmp_message[LINE_BUFFER_SIZE];\n    register int bcount;\n    register char *cp,*iop = 0;\n    register int i;\n    register struct buff_line *lbp;\n    struct buff_line *olbp;\n    int original_zee = hbp->zee;\n    int error_status = SUCCESS;\n\n    PREAMBLE();\n/*\n * Read the file and insert the characters into the buffer\n */\n    cp = linebuf;\n    linebuf_cnt = bcount = 0;\n\n    while(1){\n\tif(bcount <= 0){\n\t    bcount = read(iochan,iobuf,sizeof(iobuf));\n\t    iop = iobuf;\n\t    if(bcount == 0) break;\n\t    if(bcount < 0){\n\t\tsprintf(tmp_message,\"?Error reading <%s>: %s\",\n\t\t  name,error_text(errno));\n\t\terror_message(tmp_message);\n\t\terror_status = FAIL;\n\t\tbreak;\n\t    }/* End IF */\n\t}/* End IF */\n\n\tlinebuf_cnt += 1;\n\tbcount -= 1;\n\tif((*cp++ = *iop++) == '\\n' || (unsigned)linebuf_cnt >= sizeof(linebuf)){\n\t    lbp = buff_find_line(hbp,hbp->dot);\n\t    if(lbp == NULL){\n\t\terror_status = FAIL;\n\t\tbreak;\n\t    }/* End IF */\n\t    i = buff_find_offset(hbp,lbp,hbp->dot);\n\t    if(i == -1){\n\t\terror_status = FAIL;\n\t\tbreak;\n\t    }/* End IF */\n\t    if(i == 0){\n\t\tolbp = lbp;\n\t\tlbp = allocate_line_buffer(linebuf_cnt);\n\t\tif(lbp == NULL){\n\t\t    error_status = FAIL;\n\t\t    break;\n\t\t}/* End IF */\n\n\t\tlbp->next_line = olbp;\n\t\tlbp->prev_line = olbp->prev_line;\n\t\tolbp->prev_line = lbp;\n\t\tif(lbp->prev_line) lbp->prev_line->next_line = lbp;\n\t\tif(hbp->first_line == olbp) hbp->first_line = lbp;\n\t\tmovc3(linebuf,lbp->buffer,linebuf_cnt);\n\t\tlbp->byte_count = linebuf_cnt;\n\t\thbp->pos_cache.lbp = lbp;\n\t\thbp->pos_cache.base = hbp->dot;\n\t\thbp->dot += linebuf_cnt;\n\t\thbp->zee += linebuf_cnt;\n\t    }/* End IF */\n\n\t    else {\n\t\tif(buff_insert(hbp,hbp->dot,linebuf,linebuf_cnt) == FAIL){\n\t\t    error_status = FAIL;\n\t\t    break;\n\t\t}/* End IF */\n\t    }/* End Else */\n\n\t    cp = linebuf;\n\t    linebuf_cnt = 0;\n\t    continue;\n\t}/* End IF */\n\n    }/* End While */\n\n    if(error_status == SUCCESS && linebuf_cnt != 0){\n\tif(buff_insert(hbp,hbp->dot,linebuf,linebuf_cnt) == FAIL){\n\t    error_status = FAIL;\n\t}/* End IF */\n    }/* End IF */\n\n/*\n * If the buffer just became modified for the first time, we need to change the\n * label line to reflect this.\n */\n    if(hbp->ismodified == NO && hbp->zee != original_zee){\n\tif(hbp == curbuf){\n\t    if(screen_label_line(hbp,\"(modified)\",LABEL_C_MODIFIED) == FAIL){\n\t\terror_status = FAIL;\n\t    }/* End IF */\n\t}/* End IF */\n\thbp->ismodified = YES;\n    }/* End IF */\n\n    checkpoint_modified = YES;\n\n    return(error_status);\n\n}", "path": "tecbuf.c", "repo_name": "rhaberkorn/videoteco-fork", "stars": 8, "license": "None", "language": "c", "size": 310}
{"docstring": "/*\n * Ok, this interrupt is called after a DMA read/write has succeeded,\n * so we check the results, and copy any buffers.\n */\n", "func_signal": "static void rw_interrupt(void)", "code": "{\n\tif (result() != 7 || (ST0 & 0xf8) || (ST1 & 0xbf) || (ST2 & 0x73)) {\n\t\tif (ST1 & 0x02) {\n\t\t\tprintk(\"Drive %d is write protected\\n\\r\",current_drive);\n\t\t\tfloppy_deselect(current_drive);\n\t\t\tend_request(0);\n\t\t} else\n\t\t\tbad_flp_intr();\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tif (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)\n\t\tcopy_buffer(tmp_floppy_area,CURRENT->buffer);\n\tfloppy_deselect(current_drive);\n\tend_request(1);\n\tdo_fd_request();\n}", "path": "kernel\\blk_drv\\floppy.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * reset is done by pulling bit 2 of DOR low for a while.\n */\n", "func_signal": "static void reset_floppy(void)", "code": "{\n\tint i;\n\n\treset = 0;\n\tcur_spec1 = -1;\n\tcur_rate = -1;\n\trecalibrate = 1;\n\tprintk(\"Reset-floppy called\\n\\r\");\n\tcli();\n\tdo_floppy = reset_interrupt;\n\toutb_p(current_DOR & ~0x04,FD_DOR);\n\tfor (i=0 ; i<100 ; i++)\n\t\t__asm__(\"nop\");\n\toutb(current_DOR,FD_DOR);\n\tsti();\n}", "path": "kernel\\blk_drv\\floppy.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tpermission()\n *\n * is used to check for read/write/execute permissions on a file.\n * I don't know if we should look at just the euid or both euid and\n * uid, but that should be easily changed.\n */\n", "func_signal": "static int permission(struct m_inode * inode,int mask)", "code": "{\n\tint mode = inode->i_mode;\n\n/* special case: not even root can read/write a deleted file */\n\tif (inode->i_dev && !inode->i_nlinks)\n\t\treturn 0;\n\telse if (current->euid==inode->i_uid)\n\t\tmode >>= 6;\n\telse if (current->egid==inode->i_gid)\n\t\tmode >>= 3;\n\tif (((mode & mask & 0007) == mask) || suser())\n\t\treturn 1;\n\treturn 0;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tadd_entry()\n *\n * adds a file entry to the specified directory, using the same\n * semantics as find_entry(). It returns NULL if it failed.\n *\n * NOTE!! The inode part of 'de' is left at 0 - which means you\n * may not sleep between calling this and putting something into\n * the entry, as someone else might have used it while you slept.\n */\n", "func_signal": "static struct buffer_head * add_entry(struct m_inode * dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\t*res_dir = NULL;\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tif (!namelen)\n\t\treturn NULL;\n\tif (!(block = dir->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread(dir->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tblock = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block)\n\t\t\t\treturn NULL;\n\t\t\tif (!(bh = bread(dir->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (i*sizeof(struct dir_entry) >= dir->i_size) {\n\t\t\tde->inode=0;\n\t\t\tdir->i_size = (i+1)*sizeof(struct dir_entry);\n\t\t\tdir->i_dirt = 1;\n\t\t\tdir->i_ctime = CURRENT_TIME;\n\t\t}\n\t\tif (!de->inode) {\n\t\t\tdir->i_mtime = CURRENT_TIME;\n\t\t\tfor (i=0; i < NAME_LEN ; i++)\n\t\t\t\tde->name[i]=(i<namelen)?get_fs_byte(name+i):0;\n\t\t\tbh->b_dirt = 1;\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\n", "func_signal": "int open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir, *inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif ((flag & O_TRUNC) && !(flag & O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &= 0777 & ~current->umask;\n\tmode |= I_REGULAR;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\t\t\t/* special case: '/usr/' etc */ /*\u5982\u679c\u9577\u5ea6\u662f\u96f6\u4ee3\u8868\u662fopen\u4e00\u500b\u76ee\u9304*/\n\t\tif (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\treturn 0;\n\t\t}\n\t\tiput(dir);\n\t\treturn -EISDIR;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) { /*\u5982\u679c\u5728\u9ad8\u901f\u7de9\u885d\u5340\u627e\u4e0d\u5230\u9019\u500b\u6a94\u6848\u7684entry\uff0c\u4ee3\u8868\u662fcreate\u4e00\u500b\u65b0\u7684file*/\n\t\tif (!(flag & O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOENT; /*\u5982\u679c\u4e0d\u662fcreate\u4e00\u500bfile\u5247\u56de\u50b3\u932f\u8aa4*/\n\t\t}\n\t\tif (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tinode = new_inode(dir->i_dev);\n\t\tif (!inode) { /*\u65b0\u7684node=null\u4ee3\u8868\u7a7a\u9593\u4e0d\u8db3*/\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinode->i_uid = current->euid;\n\t\tinode->i_mode = mode;\n\t\tinode->i_dirt = 1;\n\t\tbh = add_entry(dir,basename,namelen,&de);\n\t\tif (!bh) {\n\t\t\tinode->i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tde->inode = inode->i_num;\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\treturn 0;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tif (flag & O_EXCL)\n\t\treturn -EEXIST;\n\tif (!(inode=iget(dev,inr)))\n\t\treturn -EACCES;\n\tif ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\treturn -EPERM;\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\tif (flag & O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\treturn 0;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * 'copy_string()' copies argument/envelope strings from user\n * memory to free pages in kernel mem. These are in a format ready\n * to be put directly into the top of new user memory.\n *\n * Modified by TYT, 11/24/91 to add the from_kmem argument, which specifies\n * whether the string and the string array are from user or kernel segments:\n * \n * from_kmem     argv *        argv **\n *    0          user space    user space\n *    1          kernel space  user space\n *    2          kernel space  kernel space\n * \n * We do this by playing games with the fs segment register.  Since it\n * it is expensive to load a segment register, we try to avoid calling\n * set_fs() unless we absolutely have to.\n */\n", "func_signal": "static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,\n\t\tunsigned long p, int from_kmem)", "code": "{\n\tchar *tmp, *pag=NULL;\n\tint len, offset = 0;\n\tunsigned long old_fs, new_fs;\n\n\tif (!p)\n\t\treturn 0;\t/* bullet-proofing */\n\tnew_fs = get_ds();\n\told_fs = get_fs();\n\tif (from_kmem==2)\n\t\tset_fs(new_fs);\n\twhile (argc-- > 0) {\n\t\tif (from_kmem == 1)\n\t\t\tset_fs(new_fs);\n\t\tif (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))\n\t\t\tpanic(\"argc is wrong\");\n\t\tif (from_kmem == 1)\n\t\t\tset_fs(old_fs);\n\t\tlen=0;\t\t/* remember zero-padding */\n\t\tdo {\n\t\t\tlen++;\n\t\t} while (get_fs_byte(tmp++));\n\t\tif (p-len < 0) {\t/* this shouldn't happen - 128kB */\n\t\t\tset_fs(old_fs);\n\t\t\treturn 0;\n\t\t}\n\t\twhile (len) {\n\t\t\t--p; --tmp; --len;\n\t\t\tif (--offset < 0) {\n\t\t\t\toffset = p % PAGE_SIZE;\n\t\t\t\tif (from_kmem==2)\n\t\t\t\t\tset_fs(old_fs);\n\t\t\t\tif (!(pag = (char *) page[p/PAGE_SIZE]) &&\n\t\t\t\t    !(pag = (char *) page[p/PAGE_SIZE] =\n\t\t\t\t      (unsigned long *) get_free_page())) \n\t\t\t\t\treturn 0;\n\t\t\t\tif (from_kmem==2)\n\t\t\t\t\tset_fs(new_fs);\n\n\t\t\t}\n\t\t\t*(pag + offset) = get_fs_byte(tmp);\n\t\t}\n\t}\n\tif (from_kmem==2)\n\t\tset_fs(old_fs);\n\treturn p;\n}", "path": "fs\\exec.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * count() counts the number of arguments/envelopes\n */\n", "func_signal": "static int count(char ** argv)", "code": "{\n\tint i=0;\n\tchar ** tmp;\n\n\tif ((tmp = argv))\n\t\twhile (get_fs_long((unsigned long *) (tmp++)))\n\t\t\ti++;\n\n\treturn i;\n}", "path": "fs\\exec.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller. Note that the \"unexpected interrupt\" routine\n * also does a recalibrate, but doesn't come here.\n */\n", "func_signal": "static void seek_interrupt(void)", "code": "{\n/* sense drive status */\n\toutput_byte(FD_SENSEI);\n\tif (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {\n\t\tbad_flp_intr();\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tcurrent_track = ST1;\n\tsetup_rw_floppy();\n}", "path": "kernel\\blk_drv\\floppy.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tnamei()\n *\n * is used by most simple commands to get the inode of a specified name.\n * Open, link etc use their own routines, but this is enough for things\n * like 'chmod' etc.\n */\n", "func_signal": "struct m_inode * namei(const char * pathname)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn NULL;\n\tif (!namelen)\t\t\t/* special case: '/usr/' etc */\n\t\treturn dir;\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn NULL;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tdir=iget(dev,inr);\n\tif (dir) {\n\t\tdir->i_atime=CURRENT_TIME;\n\t\tdir->i_dirt=1;\n\t}\n\treturn dir;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * add-request adds a request to the linked list.\n * It disables interrupts so that it can muck with the\n * request-lists in peace.\n */\n", "func_signal": "static void add_request(struct blk_dev_struct * dev, struct request * req)", "code": "{\n\tstruct request * tmp;\n\n\treq->next = NULL;\n\tcli();\n\tif (req->bh)\n\t\treq->bh->b_dirt = 0;\n\tif (!(tmp = dev->current_request)) {\n\t\tdev->current_request = req;\n\t\tsti();\n\t\t(dev->request_fn)();\n\t\treturn;\n\t}\n\tfor ( ; tmp->next ; tmp=tmp->next)\n\t\tif ((IN_ORDER(tmp,req) || \n\t\t    !IN_ORDER(tmp,tmp->next)) &&\n\t\t    IN_ORDER(req,tmp->next))\n\t\t\tbreak;\n\treq->next=tmp->next;\n\ttmp->next=req;\n\tsti();\n}", "path": "kernel\\blk_drv\\ll_rw_blk.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * floppy-change is never called from an interrupt, so we can relax a bit\n * here, sleep etc. Note that floppy-on tries to set current_DOR to point\n * to the desired drive, but it will probably not survive the sleep if\n * several floppies are used at the same time: thus the loop.\n */\n", "func_signal": "int floppy_change(unsigned int nr)", "code": "{\nrepeat:\n\tfloppy_on(nr);\n\twhile ((current_DOR & 3) != nr && selected)\n\t\tinterruptible_sleep_on(&wait_on_floppy_select);\n\tif ((current_DOR & 3) != nr)\n\t\tgoto repeat;\n\tif (inb(FD_DIR) & 0x80) {\n\t\tfloppy_off(nr);\n\t\treturn 1;\n\t}\n\tfloppy_off(nr);\n\treturn 0;\n}", "path": "kernel\\blk_drv\\floppy.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * Here is the free routine.  If you know the size of the object that you\n * are freeing, then free_s() will use that information to speed up the\n * search for the bucket descriptor.\n * \n * We will #define a macro so that \"free(x)\" is becomes \"free_s(x, 0)\"\n */\n", "func_signal": "void free_s(void *obj, int size)", "code": "{\n\tvoid\t\t*page;\n\tstruct _bucket_dir\t*bdir;\n\tstruct bucket_desc\t*bdesc, *prev;\n\tbdesc = prev = 0;\n\t/* Calculate what page this object lives in */\n\tpage = (void *)  ((unsigned long) obj & 0xfffff000);\n\t/* Now search the buckets looking for that page */\n\tfor (bdir = bucket_dir; bdir->size; bdir++) {\n\t\tprev = 0;\n\t\t/* If size is zero then this conditional is always false */\n\t\tif (bdir->size < size)\n\t\t\tcontinue;\n\t\tfor (bdesc = bdir->chain; bdesc; bdesc = bdesc->next) {\n\t\t\tif (bdesc->page == page) \n\t\t\t\tgoto found;\n\t\t\tprev = bdesc;\n\t\t}\n\t}\n\tpanic(\"Bad address passed to kernel free_s()\");\nfound:\n\tcli(); /* To avoid race conditions */\n\t*((void **)obj) = bdesc->freeptr;\n\tbdesc->freeptr = obj;\n\tbdesc->refcnt--;\n\tif (bdesc->refcnt == 0) {\n\t\t/*\n\t\t * We need to make sure that prev is still accurate.  It\n\t\t * may not be, if someone rudely interrupted us....\n\t\t */\n\t\tif ((prev && (prev->next != bdesc)) ||\n\t\t    (!prev && (bdir->chain != bdesc)))\n\t\t\tfor (prev = bdir->chain; prev; prev = prev->next)\n\t\t\t\tif (prev->next == bdesc)\n\t\t\t\t\tbreak;\n\t\tif (prev)\n\t\t\tprev->next = bdesc->next;\n\t\telse {\n\t\t\tif (bdir->chain != bdesc)\n\t\t\t\tpanic(\"malloc bucket chains corrupted\");\n\t\t\tbdir->chain = bdesc->next;\n\t\t}\n\t\tfree_page((unsigned long) bdesc->page);\n\t\tbdesc->next = free_bucket_desc;\n\t\tfree_bucket_desc = bdesc;\n\t}\n\tsti();\n\treturn;\n}", "path": "lib\\malloc.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * routine to check that the specified directory is empty (for rmdir)\n */\n", "func_signal": "static int empty_dir(struct m_inode * inode)", "code": "{\n\tint nr,block;\n\tint len;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tlen = inode->i_size / sizeof (struct dir_entry);\n\tif (len<2 || !inode->i_zone[0] ||\n\t    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tde = (struct dir_entry *) bh->b_data;\n\tif (de[0].inode != inode->i_num || !de[1].inode || \n\t    strcmp(\".\",de[0].name) || strcmp(\"..\",de[1].name)) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tnr = 2;\n\tde += 2;\n\twhile (nr<len) {\n\t\tif ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {\n\t\t\tbrelse(bh);\n\t\t\tblock=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block) {\n\t\t\t\tnr += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\t\treturn 0;\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (de->inode) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\tde++;\n\t\tnr++;\n\t}\n\tbrelse(bh);\n\treturn 1;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tdir_namei()\n *\n * dir_namei() returns the inode of the directory of the\n * specified name, and the name within that directory.\n */\n", "func_signal": "static struct m_inode * dir_namei(const char * pathname,\n\tint * namelen, const char ** name)", "code": "{\n\tchar c;\n\tconst char * basename;\n\tstruct m_inode * dir;\n\n\tif (!(dir = get_dir(pathname)))\n\t\treturn NULL;\n\tbasename = pathname;\n\twhile ((c=get_fs_byte(pathname++)))\n\t\tif (c=='/')\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename-1;\n\t*name = basename;\n\treturn dir;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tfind_entry()\n *\n * finds an entry in the specified directory with the wanted name. It\n * returns the cache buffer in which the entry was found, and the entry\n * itself (as a parameter - res_dir). It does NOT read the inode of the\n * entry - you'll have to do that yourself if you want to.\n *\n * This also takes care of the few special cases due to '..'-traversal\n * over a pseudo-root and a mount point.\n */\n", "func_signal": "static struct buffer_head * find_entry(struct m_inode ** dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint entries;\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\tstruct super_block * sb;\n\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tentries = (*dir)->i_size / (sizeof (struct dir_entry));\n\t*res_dir = NULL;\n\tif (!namelen)\n\t\treturn NULL;\n/* check for '..', as we might have to do some \"magic\" for it */\n\tif (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {\n/* '..' in a pseudo-root results in a faked '.' (just change namelen) */\n\t\tif ((*dir) == current->root)\n\t\t\tnamelen=1;\n\t\telse if ((*dir)->i_num == ROOT_INO) {\n/* '..' over a mount-point results in 'dir' being exchanged for the mounted\n   directory-inode. NOTE! We set mounted, so that we can iput the new dir */\n\t\t\tsb=get_super((*dir)->i_dev);\n\t\t\tif (sb->s_imount) {\n\t\t\t\tiput(*dir);\n\t\t\t\t(*dir)=sb->s_imount;\n\t\t\t\t(*dir)->i_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (!(block = (*dir)->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread((*dir)->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (i < entries) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||\n\t\t\t    !(bh = bread((*dir)->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (match(namelen,name,de)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * create_tables() parses the env- and arg-strings in new user\n * memory and creates the pointer tables from them, and puts their\n * addresses on the \"stack\", returning the new stack pointer value.\n */\n", "func_signal": "static unsigned long * create_tables(char * p,int argc,int envc)", "code": "{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\n\tsp = (unsigned long *) (0xfffffffc & (unsigned long) p);\n\tsp -= envc+1;\n\tenvp = sp;\n\tsp -= argc+1;\n\targv = sp;\n\tput_fs_long((unsigned long)envp,--sp);\n\tput_fs_long((unsigned long)argv,--sp);\n\tput_fs_long((unsigned long)argc,--sp);\n\twhile (argc-->0) {\n\t\tput_fs_long((unsigned long) p,argv++);\n\t\twhile (get_fs_byte(p++)) /* nothing */ ;\n\t}\n\tput_fs_long(0,argv);\n\twhile (envc-->0) {\n\t\tput_fs_long((unsigned long) p,envp++);\n\t\twhile (get_fs_byte(p++)) /* nothing */ ;\n\t}\n\tput_fs_long(0,envp);\n\treturn sp;\n}", "path": "fs\\exec.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * This routine is called when everything should be correctly set up\n * for the transfer (ie floppy motor is on and the correct floppy is\n * selected).\n */\n", "func_signal": "static void transfer(void)", "code": "{\n\tif (cur_spec1 != floppy->spec1) {\n\t\tcur_spec1 = floppy->spec1;\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(cur_spec1);\t\t/* hut etc */\n\t\toutput_byte(6);\t\t\t/* Head load time =6ms, DMA */\n\t}\n\tif (cur_rate != floppy->rate)\n\t\toutb_p(cur_rate = floppy->rate,FD_DCR);\n\tif (reset) {\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tif (!seek) {\n\t\tsetup_rw_floppy();\n\t\treturn;\n\t}\n\tdo_floppy = seek_interrupt;\n\tif (seek_track) {\n\t\toutput_byte(FD_SEEK);\n\t\toutput_byte(head<<2 | current_drive);\n\t\toutput_byte(seek_track);\n\t} else {\n\t\toutput_byte(FD_RECALIBRATE);\n\t\toutput_byte(head<<2 | current_drive);\n\t}\n\tif (reset)\n\t\tdo_fd_request();\n}", "path": "kernel\\blk_drv\\floppy.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *  void con_init(void);\n *\n * This routine initalizes console interrupts, and does nothing\n * else. If you want the screen to clear, call tty_write with\n * the appropriate escape-sequece.\n *\n * Reads the information preserved by setup.s to determine the current display\n * type and sets everything accordingly.\n */\n", "func_signal": "void con_init(void)", "code": "{\n\tregister unsigned char a;\n\tchar *display_desc = \"????\";\n\tchar *display_ptr;\n\n\tvideo_num_columns = ORIG_VIDEO_COLS;\n\tvideo_size_row = video_num_columns * 2;\n\tvideo_num_lines = ORIG_VIDEO_LINES;\n\tvideo_page = ORIG_VIDEO_PAGE;\n\tvideo_erase_char = 0x0720;\n\t\n\tif (ORIG_VIDEO_MODE == 7)\t\t\t/* Is this a monochrome display? */\n\t{\n\t\tvideo_mem_start = 0xb0000;\n\t\tvideo_port_reg = 0x3b4;\n\t\tvideo_port_val = 0x3b5;\n\t\tif ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_EGAM;\n\t\t\tvideo_mem_end = 0xb8000;\n\t\t\tdisplay_desc = \"EGAm\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_MDA;\n\t\t\tvideo_mem_end\t= 0xb2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t}\n\t}\n\telse\t\t\t\t\t\t\t\t/* If not, it is color. */\n\t{\n\t\tvideo_mem_start = 0xb8000;\n\t\tvideo_port_reg\t= 0x3d4;\n\t\tvideo_port_val\t= 0x3d5;\n\t\tif ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_EGAC;\n\t\t\tvideo_mem_end = 0xbc000;\n\t\t\tdisplay_desc = \"EGAc\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_CGA;\n\t\t\tvideo_mem_end = 0xba000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t}\n\t}\n\n\t/* Let the user known what kind of display driver we are using */\n\t\n\tdisplay_ptr = ((char *)video_mem_start) + video_size_row - 8;\n\twhile (*display_desc)\n\t{\n\t\t*display_ptr++ = *display_desc++;\n\t\tdisplay_ptr++;\n\t}\n\t\n\t/* Initialize the variables used for scrolling (mostly EGA/VGA)\t*/\n\t\n\torigin\t= video_mem_start;\n\tscr_end\t= video_mem_start + video_num_lines * video_size_row;\n\ttop\t= 0;\n\tbottom\t= video_num_lines;\n\n\tgotoxy(ORIG_X,ORIG_Y);\n\tset_trap_gate(0x21,&keyboard_interrupt);\n\toutb_p(inb_p(0x21)&0xfd,0x21);\n\ta=inb_p(0x61);\n\toutb_p(a|0x80,0x61);\n\toutb(a,0x61);\n}", "path": "kernel\\chr_drv\\console.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n *\tget_dir()\n *\n * Getdir traverses the pathname until it hits the topmost directory.\n * It returns NULL on failure.\n */\n", "func_signal": "static struct m_inode * get_dir(const char * pathname)", "code": "{\n\tchar c;\n\tconst char * thisname;\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint namelen,inr,idev;\n\tstruct dir_entry * de;\n\n\tif (!current->root || !current->root->i_count)\n\t\tpanic(\"No root inode\");\n\tif (!current->pwd || !current->pwd->i_count)\n\t\tpanic(\"No cwd inode\");\n\tif ((c=get_fs_byte(pathname))=='/') {\n\t\tinode = current->root;\n\t\tpathname++;\n\t} else if (c)\n\t\tinode = current->pwd;\n\telse\n\t\treturn NULL;\t/* empty name is bad */\n\tinode->i_count++;\n\twhile (1) {\n\t\tthisname = pathname;\n\t\tif (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)\n\t\t\t/* nothing */ ;\n\t\tif (!c)\n\t\t\treturn inode;\n\t\tif (!(bh = find_entry(&inode,thisname,namelen,&de))) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tinr = de->inode;\n\t\tidev = inode->i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tif (!(inode = iget(idev,inr)))\n\t\t\treturn NULL;\n\t}\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * ok, we cannot use strncmp, as the name is not in our data space.\n * Thus we'll have to use match. No big problem. Match also makes\n * some sanity tests.\n *\n * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.\n */\n", "func_signal": "static int match(int len,const char * name,struct dir_entry * de)", "code": "{\n\tregister int same ;\n\n\tif (!de || !de->inode || len > NAME_LEN)\n\t\treturn 0;\n\tif (len < NAME_LEN && de->name[len])\n\t\treturn 0;\n\t__asm__(\"cld\\n\\t\"\n\t\t\"fs ; repe ; cmpsb\\n\\t\"\n\t\t\"setz %%al\"\n\t\t:\"=a\" (same)\n\t\t:\"0\" (0),\"S\" ((long) name),\"D\" ((long) de->name),\"c\" (len)\n\t\t);\n\treturn same;\n}", "path": "fs\\namei.c", "repo_name": "bboymimi/linux-kernel-0.12-study-version", "stars": 11, "license": "None", "language": "c", "size": 241}
{"docstring": "/*\n * makeindex: make index file\n *\n *\ti)\tfile\tfile name\n *\ti)\ttitle\ttitle of index file\n *\ti)\tindex\tcommon part\n */\n", "func_signal": "static void\nmakeindex(const char *file, const char *title, const char *index)", "code": "{\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot make file '%s'.\", file);\n\tif (Fflag) {\n\t\tfputs_nl(gen_page_frameset_begin(title), op);\n\t\tfputs_nl(gen_frameset_begin(\"cols='200,*'\"), op);\n\t\tif (fflag) {\n\t\t\tfputs_nl(gen_frameset_begin(\"rows='33%,33%,*'\"), op);\n\t\t\tfputs_nl(gen_frame(\"search\", makepath(NULL, \"search\", normal_suffix)), op);\n\t\t} else {\n\t\t\tfputs_nl(gen_frameset_begin(\"rows='50%,*'\"), op);\n\t\t}\n\t\t/*\n\t\t * id='xxx' for XHTML\n\t\t * name='xxx' for HTML\n\t\t */\n\t\tfputs_nl(gen_frame(\"defines\", makepath(NULL, \"defines\", normal_suffix)), op);\n\t\tfputs_nl(gen_frame(\"files\", makepath(NULL, \"files\", normal_suffix)), op);\n\t\tfputs_nl(gen_frameset_end(), op);\n\t\tfputs_nl(gen_frame(\"mains\", makepath(NULL, \"mains\", normal_suffix)), op);\n\t\tfputs_nl(noframes_begin, op);\n\t\tfputs_nl(body_begin, op);\n\t\tfputs(index, op);\n\t\tfputs_nl(body_end, op);\n\t\tfputs_nl(noframes_end, op);\n\t\tfputs_nl(gen_frameset_end(), op);\n\t\tfputs_nl(gen_page_end(), op);\n\t} else {\n\t\tfputs_nl(gen_page_index_begin(title, jscode), op);\n\t\tfputs_nl(body_begin, op);\n\t\tif (insert_header)\n\t\t\tfputs(gen_insert_header(TOPDIR), op);\n\t\tfputs(index, op);\n\t\tif (insert_footer)\n\t\t\tfputs(gen_insert_footer(TOPDIR), op);\n\t\tfputs_nl(body_end, op);\n\t\tfputs_nl(gen_page_end(), op);\n\t}\n\tfclose(op);\n\thtml_count++;\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * generate_file: generate file with replacing macro.\n *\n *\ti)\tdist\tdirectory where the file should be created\n *\ti)\tfile\tfile name\n *\ti)\tplace\tTOPDIR, SUBDIR, CGIDIR\n */\n", "func_signal": "static void\ngenerate_file(const char *dist, const char *file, int place)", "code": "{\n\tFILE *op;\n\tSTRBUF *result = strbuf_open(0);\n\n\top = fopen(makepath(dist, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot create file '%s'.\", file);\n\tload_with_replace(file, result, place);\n\tfputs(strbuf_value(result), op);\n\tfclose(op);\n\thtml_count++;\n\tstrbuf_close(result);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * basic check.\n */\n", "func_signal": "static void\nbasic_check(void)", "code": "{\n\tconst char *p;\n\n\t/*\n\t * COMMAND EXISTENCE CHECK\n\t */\n\tif (!(p = usable(\"gtags\")))\n\t\tdie(\"gtags command required but not found.\");\n\tstrlimcpy(gtags_path, p, sizeof(gtags_path));\n\tif (!(p = usable(\"global\")))\n\t\tdie(\"global command required but not found.\");\n\tstrlimcpy(global_path, p, sizeof(global_path));\n\t/*\n\t * Temporary directory.\n\t */\n\tif ((p = getenv(\"TMPDIR\")) == NULL)\n\t\tp = getenv(\"TMP\");\n\tif (p != NULL && test(\"d\", p))\n\t\ttmpdir = p;\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * make directory in the dist directory.\n */\n", "func_signal": "static void\nmake_directory_in_distpath(const char *name)", "code": "{\n\tchar path[MAXPATHLEN];\n\tFILE *op;\n\n\tstrlimcpy(path, makepath(distpath, name, NULL), sizeof(path));\n\tif (!test(\"d\", path))\n\t\tif (mkdir(path, 0775))\n\t\t\tdie(\"cannot make directory '%s'.\", path);\n\t/*\n\t * Not to publish the directory list.\n\t */\n\top = fopen(makepath(path, \"index.html\", NULL), \"w\");\n\tif (op == NULL)\n\t\tdie(\"cannot make file '%s'.\", makepath(path, \"index.html\", NULL));\n\tfputs(html_begin, op);\n\tfputs(html_end, op);\n\tfputc('\\n', op);\n\tfclose(op);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * load configuration variables.\n */\n", "func_signal": "static void\nconfiguration(int argc, char *const *argv)", "code": "{\n\tSTRBUF *sb = strbuf_open(0);\n\tint i, n;\n\tchar *p, *q;\n\n\t/*\n\t * Setup the GTAGSCONF and the GTAGSLABEL environment variable\n\t * according to the --gtagsconf and --gtagslabel option.\n\t */\n\t{\n\t\tchar *confpath = NULL;\n\t\tchar *label = NULL;\n\t\tchar *opt_gtagsconf = \"--gtagsconf\";\n\t\tchar *opt_gtagslabel = \"--gtagslabel\";\n\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tif ((p = locatestring(argv[i], opt_gtagsconf, MATCH_AT_FIRST))) {\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tif (++i >= argc)\n\t\t\t\t\t\tdie(\"%s needs an argument.\", opt_gtagsconf);\n\t\t\t\t\tconfpath = argv[i];\n\t\t\t\t} else {\n\t\t\t\t\tif (*p++ == '=' && *p)\n\t\t\t\t\t\tconfpath = p;\n\t\t\t\t}\n\t\t\t} else if ((p = locatestring(argv[i], opt_gtagslabel, MATCH_AT_FIRST))) {\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tif (++i >= argc)\n\t\t\t\t\t\tdie(\"%s needs an argument.\", opt_gtagslabel);\n\t\t\t\t\tlabel = argv[i];\n\t\t\t\t} else {\n\t\t\t\t\tif (*p++ == '=' && *p)\n\t\t\t\t\t\tlabel = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (confpath) {\n\t\t\tchar real[MAXPATHLEN];\n\n\t\t\tif (!test(\"f\", confpath))\n\t\t\t\tdie(\"%s file not found.\", opt_gtagsconf);\n\t\t\tif (!realpath(confpath, real))\n\t\t\t\tdie(\"cannot get absolute path of %s file.\", opt_gtagsconf);\n\t\t\tset_env(\"GTAGSCONF\", real);\n\t\t}\n\t\tif (label)\n\t\t\tset_env(\"GTAGSLABEL\", label);\n\t}\n\t/*\n\t * Config variables.\n\t */\n\tstrbuf_reset(sb);\n\tif (!getconfs(\"datadir\", sb))\n\t\tdie(\"cannot get datadir directory name.\");\n\tstrlimcpy(datadir, strbuf_value(sb), sizeof(datadir));\n\tstrbuf_reset(sb);\n\tif (!getconfs(\"localstatedir\", sb))\n\t\tdie(\"cannot get localstatedir directory name.\");\n\tstrlimcpy(localstatedir, strbuf_value(sb), sizeof(localstatedir));\n\tif (getconfn(\"ncol\", &n)) {\n\t\tif (n < 1 || n > 10)\n\t\t\twarning(\"parameter 'ncol' ignored because the value (=%d) is too large or too small.\", n);\n\t\telse\n\t\t\tncol = n;\n\t}\n\tif (getconfn(\"tabs\", &n)) {\n\t\tif (n < 1 || n > 32)\n\t\t\twarning(\"parameter 'tabs' ignored because the value (=%d) is too large or too small.\", n);\n\t\telse\n\t\t\ttabs = n;\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"gzipped_suffix\", sb))\n\t\tgzipped_suffix = check_strdup(strbuf_value(sb));\n\tstrbuf_reset(sb);\n\tif (getconfs(\"normal_suffix\", sb))\n\t\tnormal_suffix = check_strdup(strbuf_value(sb));\n\tif (getconfb(\"no_order_list\"))\n\t\tno_order_list = 1;\n\tstrbuf_reset(sb);\n\tif (getconfs(\"prolog_script\", sb))\n\t\tprolog_script = check_strdup(strbuf_value(sb));\n\tstrbuf_reset(sb);\n\tif (getconfs(\"epilog_script\", sb))\n\t\tepilog_script = check_strdup(strbuf_value(sb));\n\tif (getconfb(\"colorize_warned_line\"))\n\t\tcolorize_warned_line = 1;\n\tstrbuf_reset(sb);\n\tif (getconfs(\"script_alias\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\t/* remove the last '/' */\n\t\tq = p + strlen(p) - 1;\n\t\tif (*q == '/')\n\t\t\t*q = '\\0';\n\t\tscript_alias = p;\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"body_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"body_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\tbody_begin = p;\n\t\t\tbody_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"table_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"table_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\ttable_begin = p;\n\t\t\ttable_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"title_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"title_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\ttitle_begin = p;\n\t\t\ttitle_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"comment_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"comment_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\tcomment_begin = p;\n\t\t\tcomment_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"sharp_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"sharp_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\tsharp_begin = p;\n\t\t\tsharp_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"brace_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"brace_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\tbrace_begin = p;\n\t\t\tbrace_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"reserved_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"reserved_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\treserved_begin = p;\n\t\t\treserved_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"position_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"position_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\tposition_begin = p;\n\t\t\tposition_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"warned_line_begin\", sb)) {\n\t\tp = check_strdup(strbuf_value(sb));\n\t\tstrbuf_reset(sb);\n\t\tif (getconfs(\"warned_line_end\", sb)) {\n\t\t\tq = check_strdup(strbuf_value(sb));\n\t\t\twarned_line_begin = p;\n\t\t\twarned_line_end = q;\n\t\t} else {\n\t\t\tfree(p);\n\t\t}\n\t}\n\tstrbuf_reset(sb);\n\tif (getconfs(\"include_file_suffixes\", sb))\n\t\tinclude_file_suffixes = check_strdup(strbuf_value(sb));\n\tstrbuf_reset(sb);\n\tif (getconfs(\"langmap\", sb))\n\t\tlangmap = check_strdup(strbuf_value(sb));\n\tstrbuf_reset(sb);\n\tif (getconfs(\"xhtml_version\", sb))\n\t\txhtml_version = check_strdup(strbuf_value(sb));\n\t/* insert htags_options into the head of ARGSV array. */\n\tstrbuf_reset(sb);\n\tif (getconfs(\"htags_options\", sb))\n\t\thtags_options = check_strdup(strbuf_value(sb));\n\tstrbuf_close(sb);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * Setup signal hander.\n */\n", "func_signal": "static void\nsignal_setup(void)", "code": "{\n        signal(SIGINT, suddenly);\n        signal(SIGTERM, suddenly);\n#ifdef SIGHUP\n        signal(SIGHUP, suddenly);\n#endif\n#ifdef SIGQUIT\n        signal(SIGQUIT, suddenly);\n#endif\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makehelp: make help file\n */\n", "func_signal": "static void\nmakehelp(const char *file)", "code": "{\n\tconst char **label = Iflag ? anchor_comment : anchor_label;\n\tconst char **icons = anchor_icons;\n\tconst char **msg   = anchor_msg;\n\tint n, last = 7;\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot make help file.\");\n\tfputs_nl(gen_page_begin(\"HELP\", TOPDIR), op);\n\tfputs_nl(body_begin, op);\n\tfputs(header_begin, op);\n\tfputs(\"Usage of Links\", op);\n\tfputs_nl(header_end, op);\n\tif (!Iflag)\n\t\tfputs(verbatim_begin, op);\n\tfputs(\"/* \", op);\n\tfor (n = 0; n <= last; n++) {\n\t\tif (Iflag) {\n\t\t\tfputs(gen_image(CURRENT, icons[n], label[n]), op);\n\t\t\tif (n < last)\n\t\t\t\tfputc(' ', op);\n\t\t} else {\n\t\t\tfprintf(op, \"[%s]\", label[n]);\n\t\t}\n\t}\n\tif (show_position)\n\t\tfprintf(op, \"[+line file]\");\n\tfputs(\" */\", op);\n\tif (!Iflag)\n\t\tfputs_nl(verbatim_end, op);\n\telse\n\t\tfputc('\\n', op);\n\tfputs_nl(define_list_begin, op);\n\tfor (n = 0; n <= last; n++) {\n\t\tfputs(define_term_begin, op);\n\t\tif (Iflag) {\n\t\t\tfputs(gen_image(CURRENT, icons[n], label[n]), op);\n\t\t} else {\n\t\t\tfprintf(op, \"[%s]\", label[n]);\n\t\t}\n\t\tfputs(define_term_end, op);\n\t\tfputs(define_desc_begin, op);\n\t\tfputs(msg[n], op);\n\t\tfputs_nl(define_desc_end, op);\n\t}\n\tif (show_position) {\n\t\tfputs(define_term_begin, op);\n\t\tfputs(\"[+line file]\", op);\n\t\tfputs(define_term_end, op);\n\t\tfputs(define_desc_begin, op);\n\t\tfputs(\"Current position (line number and file name).\", op);\n\t\tfputs_nl(define_desc_end, op);\n\t}\n\tfputs_nl(define_list_end, op);\n\tfputs_nl(body_end, op);\n\tfputs_nl(gen_page_end(), op);\n\tfclose(op);\n\thtml_count++;\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makehtml: make html files\n *\n *\ti)\ttotal\tnumber of files.\n */\n", "func_signal": "static void\nmakehtml(int total)", "code": "{\n\tGFIND *gp;\n\tFILE *anchor_stream;\n\tconst char *path;\n\tint count = 0;\n\n\t/*\n\t * Create anchor stream for anchor_load().\n\t */\n\tanchor_stream = tmpfile();\n\tgp = gfind_open(dbpath, NULL, other_files ? GPATH_BOTH : GPATH_SOURCE);\n\twhile ((path = gfind_read(gp)) != NULL) {\n\t\tif (gp->type == GPATH_OTHER)\n\t\t\tfputc(' ', anchor_stream);\n\t\tfputs(path, anchor_stream);\n\t\tfputc('\\n', anchor_stream);\n\t}\n\tgfind_close(gp);\n\t/*\n\t * Prepare anchor stream for anchor_load().\n\t */\n\tanchor_prepare(anchor_stream);\n\t/*\n\t * For each path in GPATH, convert the path into HTML file.\n\t */\n\tgp = gfind_open(dbpath, NULL, other_files ? GPATH_BOTH : GPATH_SOURCE);\n\twhile ((path = gfind_read(gp)) != NULL) {\n\t\tchar html[MAXPATHLEN];\n\n\t\tif (gp->type == GPATH_OTHER && !other_files)\n\t\t\tcontinue;\n\t\t/*\n\t\t * load tags belonging to the path.\n\t\t * The path must be start \"./\".\n\t\t */\n\t\tanchor_load(path);\n\t\t/*\n\t\t * inform the current path name to lex() function.\n\t\t */\n\t\tsave_current_path(path);\n\t\tcount++;\n\t\tpath += 2;\t\t/* remove './' at the head */\n\t\tmessage(\" [%d/%d] converting %s\", count, total, path);\n\t\tsnprintf(html, sizeof(html), \"%s/%s/%s.%s\", distpath, SRCS, path2fid(path), HTML);\n\t\tsrc2html(path, html, gp->type == GPATH_OTHER);\n\t}\n\tgfind_close(gp);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makecommonpart: make a common part for mains.html and index.html\n *\n *\ti)\ttitle\n *\ti)\tdefines\n *\ti)\tfiles\n *\tr)\tindex\tcommon part\n */\n", "func_signal": "static char *\nmakecommonpart(const char *title, const char *defines, const char *files)", "code": "{\n\tFILE *ip;\n\tSTRBUF *sb = strbuf_open(0);\n\tSTRBUF *ib = strbuf_open(0);\n\tchar buf[MAXFILLEN];\n\tconst char *tips = \"Go to the GLOBAL project page.\";\n\tconst char *_, *item;\n\n\tstrbuf_puts(sb, title_begin);\n\tstrbuf_puts(sb, title);\n\tstrbuf_puts_nl(sb, title_end);\n\tstrbuf_puts_nl(sb, gen_div_begin(\"right\"));\n\tstrbuf_sprintf(sb, \"Last updated %s%s\\n\", now(), br);\n\tif (Iflag) {\n\t\tsnprintf(buf, sizeof(buf), \"Powered by GLOBAL-%s.\", get_version());\n\t\tstrbuf_puts(sb, gen_href_begin_with_title_target(NULL, www, NULL, NULL, tips,\"_top\"));\n\t\tstrbuf_puts(sb, gen_image(CURRENT, \"pglobe\", buf));\n\t\tstrbuf_puts(sb, gen_href_end());\n\t\tstrbuf_puts(sb, br);\n\t} else {\n\t\tstrbuf_sprintf(sb, \"Powered by %sGLOBAL-%s%s.%s\\n\",\n\t\t\tgen_href_begin_with_title_target(NULL, www, NULL, NULL, tips, \"_top\"),\n\t\t\tget_version(),\n\t\t\tgen_href_end(),\n\t\t\tbr);\n\t}\n\tstrbuf_puts_nl(sb, gen_div_end());\n\tstrbuf_puts_nl(sb, hr);\n\t/*\n\t * Print items according to the value of variable 'item_order'.\n\t */\n\tfor (item = item_order; *item; item++) {\n\t\tswitch (*item) {\n\t\tcase 'c':\n\t\t\tif (caution) {\n\t\t\t\tstrbuf_puts_nl(sb, caution_begin);\n\t\t\t\tstrbuf_sprintf(sb, \"<font size='+2' color='red'>CAUTION</font>%s\\n\", br);\n\t\t\t\tstrbuf_sprintf(sb, \"This hypertext consist of %d files.\\n\", html_count);\n\t\t\t\tstrbuf_puts_nl(sb, \"Please don't download whole hypertext using hypertext copy tools.\");\n\t\t\t\tstrbuf_puts_nl(sb, \"Our network cannot afford such traffic.\");\n\t\t\t\tstrbuf_puts_nl(sb, \"Instead, you can generate same thing in your computer using\");\n\t\t\t\tstrbuf_puts(sb, gen_href_begin_with_title_target(NULL, www, NULL, NULL, NULL, \"_top\"));\n\t\t\t\tstrbuf_puts(sb, \"GLOBAL source code tag system\");\n\t\t\t\tstrbuf_puts_nl(sb, gen_href_end());\n\t\t\t\tstrbuf_puts_nl(sb, \"Thank you.\");\n\t\t\t\tstrbuf_puts_nl(sb, caution_end);\n\t\t\t\tstrbuf_sprintf(sb, \"\\n%s\\n\", hr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (fflag) {\n\t\t\t\tstrbuf_puts(sb, makesearchpart(NULL));\n\t\t\t\tstrbuf_puts_nl(sb, hr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (cflow_file) {\n\t\t\t\tstrbuf_puts(sb, header_begin);\n\t\t\t\tstrbuf_puts(sb, gen_href_begin(NULL, \"cflow\", normal_suffix, NULL));\n\t\t\t\tstrbuf_puts(sb, title_call_tree);\n\t\t\t\tstrbuf_puts(sb, gen_href_end());\n\t\t\t\tstrbuf_puts_nl(sb, header_end);\n\t\t\t\tstrbuf_puts_nl(sb, hr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tstrbuf_sprintf(sb, \"%sMAINS%s\\n\", header_begin, header_end);\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%s --result=ctags-xid --encode-path=\\\" \\t\\\" --nofilter=path %s\", global_path, main_func);\n\t\t\tip = popen(buf, \"r\");\n\t\t\tif (!ip)\n\t\t\t\tdie(\"cannot execute command '%s'.\", buf);\n\t\t\tstrbuf_puts_nl(sb, gen_list_begin());\n\t\t\twhile ((_ = strbuf_fgets(ib, ip, STRBUF_NOCRLF)) != NULL) {\n\t\t\t\tchar fid[MAXFIDLEN];\n\t\t\t\tconst char *ctags_x = parse_xid(_, fid, NULL);\n\n\t\t\t\tstrbuf_puts_nl(sb, gen_list_body(SRCS, ctags_x, fid));\n\t\t\t}\n\t\t\tstrbuf_puts_nl(sb, gen_list_end());\n\t\t\tif (pclose(ip) != 0)\n\t\t\tdie(\"cannot execute command '%s'.\", buf);\n\t\t\tstrbuf_puts_nl(sb, hr);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (aflag && !Fflag) {\n\t\t\t\tstrbuf_puts(sb, header_begin);\n\t\t\t\tstrbuf_puts(sb, title_define_index);\n\t\t\t\tstrbuf_puts_nl(sb, header_end);\n\t\t\t\tstrbuf_puts(sb, defines);\n\t\t\t} else {\n\t\t\t\tstrbuf_puts(sb, header_begin);\n\t\t\t\tstrbuf_puts(sb, gen_href_begin(NULL, \"defines\", normal_suffix, NULL));\n\t\t\t\tstrbuf_puts(sb, title_define_index);\n\t\t\t\tstrbuf_puts(sb, gen_href_end());\n\t\t\t\tstrbuf_puts_nl(sb, header_end);\n\t\t\t}\n\t\t\tstrbuf_puts_nl(sb, hr);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (Fflag) {\n\t\t\t\tstrbuf_puts(sb, header_begin);\n\t\t\t\tstrbuf_puts(sb, gen_href_begin(NULL, \"files\", normal_suffix, NULL));\n\t\t\t\tstrbuf_puts(sb, title_file_index);\n\t\t\t\tstrbuf_puts(sb, gen_href_end());\n\t\t\t\tstrbuf_puts_nl(sb, header_end);\n\t\t\t} else {\n\t\t\t\tstrbuf_puts(sb, header_begin);\n\t\t\t\tstrbuf_puts(sb, title_file_index);\n\t\t\t\tstrbuf_puts_nl(sb, header_end);\n\t\t\t\tif (tree_view) {\n\t\t\t\t\tstrbuf_puts_nl(sb, tree_control);\n\t\t\t\t\tstrbuf_puts_nl(sb, tree_begin);\n\t\t\t\t} else if (table_flist)\n\t\t\t\t\tstrbuf_puts_nl(sb, flist_begin);\n\t\t\t\telse if (!no_order_list)\n\t\t\t\t\tstrbuf_puts_nl(sb, list_begin);\n\t\t\t\tstrbuf_puts(sb, files);\n\t\t\t\tif (tree_view)\n\t\t\t\t\tstrbuf_puts_nl(sb, tree_end);\n\t\t\t\telse if (table_flist)\n\t\t\t\t\tstrbuf_puts_nl(sb, flist_end);\n\t\t\t\telse if (!no_order_list)\n\t\t\t\t\tstrbuf_puts_nl(sb, list_end);\n\t\t\t\telse\n\t\t\t\t\tstrbuf_puts_nl(sb, br);\n\t\t\t}\n\t\t\tstrbuf_puts_nl(sb, hr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarning(\"unknown item '%c'. (Ignored)\", *item);\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrbuf_close(ib);\n\n\treturn strbuf_value(sb);\n\t/* doesn't close string buffer */\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * Signal handler.\n *\n * This handler is set up in signal_setup().\n */\n", "func_signal": "static void\nsuddenly(int signo)", "code": "{\n        signo = 0;      /* to satisfy compiler */\n\n\tclean();\n\texit(1);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makesearchindex: make search html\n *\n *\ti)\tfile\tfile name\n */\n", "func_signal": "static void\nmakesearchindex(const char *file)", "code": "{\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot create file '%s'.\", file);\n\tfputs_nl(gen_page_index_begin(\"SEARCH\", jscode), op);\n\tfputs_nl(body_begin, op);\n\tfputs(makesearchpart(\"mains\"), op);\n\tfputs_nl(body_end, op);\n\tfputs_nl(gen_page_end(), op);\n\tfclose(op);\n\thtml_count++;\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * copy file.\n */\n", "func_signal": "static void\ncopyfile(const char *from, const char *to)", "code": "{\n\tint ip, op, size;\n\tchar buf[8192];\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\tip = open(from, O_RDONLY|O_BINARY);\n\tif (ip < 0)\n\t\tdie(\"cannot open input file '%s'.\", from);\n\top = open(to, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0775);\n\tif (op < 0)\n\t\tdie(\"cannot create output file '%s'.\", to);\n\twhile ((size = read(ip, buf, sizeof(buf))) != 0) {\n\t\tif (size < 0)\n\t\t\tdie(\"file read error.\");\n\t\tif (write(op, buf, size) != size)\n\t\t\tdie(\"file write error.\");\n\t}\n\tclose(op);\n\tclose(ip);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * Load file.\n */\n", "func_signal": "void\nloadfile_asis(const char *file, STRBUF *result)", "code": "{\n\tSTRBUF *sb = strbuf_open(0);\n\tFILE *ip = fopen(file, \"r\");\n\tif (!ip)\n\t\tdie(\"file '%s' not found.\", file);\n\twhile (strbuf_fgets(sb, ip, STRBUF_NOCRLF) != NULL)\n\t\tstrbuf_puts_nl(result, strbuf_value(sb));\n\tfclose(ip);\n\tstrbuf_close(sb);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makehtaccess: make .htaccess skeleton file.\n */\n", "func_signal": "static void\nmakehtaccess(const char *cgidir, const char *file)", "code": "{\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot make .htaccess skeleton file.\");\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# Skeleton file for .htaccess -- This file was generated by htags(1).\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# To make this file effective, undermentioned description is necessary\", op);\n\tfputs_nl(\"# in your system's configuration file.\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# [/usr/local/apache/conf/http.conf]\", op);\n\tfputs_nl(\"# +-------------------------------------\", op);\n\tfputs_nl(\"# |...\", op);\n\tfputs_nl(\"# |AllowOverride Options FileInfo\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# Htags was invoked with the -f, -c or -D option.\", op);\n\tfprintf(op, \"# You should start http server so that %s/*.cgi is executed\\n\", cgidir);\n\tfputs_nl(\"# as a CGI script.\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"Options +ExecCGI\", op);\n\tfputs_nl(\"AddHandler cgi-script .cgi\", op);\n\tif (cflag) {\n\t\tfputs_nl(\"#\", op);\n\t\tfputs_nl(\"# Htags have made gzipped html files because you specified the -c option.\", op);\n\t\tfputs_nl(\"# If your browser doesn't decompress gzipped files, you should start\", op);\n\t\tfputs_nl(\"# http server so that they are decompressed.\", op);\n\t\tfputs_nl(\"#\", op);\n\t\tfputs_nl(\"# Please rewrite appropriately the string '/cgi-bin/ghtml.cgi' below, or\", op);\n\t\tfputs_nl(\"# copy the file 'cgi-bin/ghtml.cgi' itself to the system's CGI directory.\", op);\n\t\tfputs_nl(\"#\", op);\n\t\tfprintf(op, \"AddHandler htags-gzipped-html %s\\n\", gzipped_suffix);\n\t\tfputs_nl(\"Action htags-gzipped-html /cgi-bin/ghtml.cgi\", op);\n\t\tfputs_nl(\"#                         ==================\", op);\n\t}\n\tfclose(op);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makesearchpart: make search part\n *\n *\ti)\t$target\ttarget\n *\tr)\t\thtml\n */\n", "func_signal": "static char *\nmakesearchpart(const char *target)", "code": "{\n\tSTATIC_STRBUF(sb);\n\n\tstrbuf_clear(sb);\n\tstrbuf_puts(sb, header_begin);\n\tif (Fflag)\n\t\tstrbuf_puts(sb, gen_href_begin(NULL, \"search\", normal_suffix, NULL));\n\tstrbuf_puts(sb, \"SEARCH\");\n\tif (Fflag)\n\t\tstrbuf_puts(sb, gen_href_end());\n\tstrbuf_puts_nl(sb, header_end);\n\tif (!target) {\n\t\tstrbuf_puts(sb, \"Please input object name and select [Search]. POSIX's regular expression is allowed.\");\n\t\tstrbuf_puts_nl(sb, br);\n\t}\n\tstrbuf_puts_nl(sb, gen_form_begin(target));\n\tstrbuf_puts_nl(sb, gen_input(\"pattern\", NULL, NULL));\n\tstrbuf_puts_nl(sb, gen_input(\"id\", sitekey, \"hidden\"));\n\tstrbuf_puts_nl(sb, gen_input(NULL, \"Search\", \"submit\"));\n\tstrbuf_puts(sb, gen_input(NULL, \"Reset\", \"reset\"));\n\tstrbuf_puts_nl(sb, br);\n\tstrbuf_puts(sb, gen_input_radio(\"type\", \"definition\", 1, \"Retrieve the definition place of the specified symbol.\"));\n\tstrbuf_puts_nl(sb, target ? \"Def\" : \"Definition\");\n\tstrbuf_puts(sb, gen_input_radio(\"type\", \"reference\", 0, \"Retrieve the reference place of the specified symbol.\"));\n\tstrbuf_puts_nl(sb, target ? \"Ref\" : \"Reference\");\n\tstrbuf_puts(sb, gen_input_radio(\"type\", \"symbol\", 0, \"Retrieve the place of the specified symbol is used.\"));\n\tstrbuf_puts_nl(sb, target ? \"Sym\" : \"Other symbol\");\n\tstrbuf_puts(sb, gen_input_radio(\"type\", \"path\", 0, \"Look for path name which matches to the specified pattern.\"));\n\tstrbuf_puts_nl(sb, target ? \"Path\" : \"Path name\");\n\tif (enable_grep) {\n\t\tstrbuf_puts(sb, gen_input_radio(\"type\", \"grep\", 0, \"Retrieve lines which matches to the specified pattern.\"));\n\t\tstrbuf_puts_nl(sb, target ? \"Grep\" : \"Grep pattern\");\n\t}\n\tif (enable_idutils && test(\"f\", makepath(dbpath, \"ID\", NULL))) {\n\t\tstrbuf_puts(sb, gen_input_radio(\"type\", \"idutils\", 0, \"Retrieve lines which matches to the specified pattern using idutils(1).\"));\n\t\tstrbuf_puts_nl(sb, target ? \"Id\" : \"Id pattern\");\n\t}\n\tstrbuf_puts_nl(sb, br);\n\tstrbuf_puts(sb, gen_input_checkbox(\"icase\", NULL, \"Ignore case distinctions in the pattern.\"));\n\tstrbuf_puts_nl(sb, target ? \"Icase\" : \"Ignore case\");\n\tif (other_files) {\n\t\tstrbuf_puts(sb, gen_input_checkbox(\"other\", NULL, \"Files other than the source code are also retrieved.\"));\n\t\tstrbuf_puts_nl(sb, target ? \"Other\" : \"Other files\");\n\t}\n\tif (other_files && !target) {\n\t\tstrbuf_puts_nl(sb, br);\n\t\tstrbuf_puts(sb, \"('Other files' is effective only to 'Path name'\");\n\t\tif (enable_grep)\n\t\t\tstrbuf_puts(sb, \" and 'Grep pattern'\");\n\t\tstrbuf_puts_nl(sb, \".)\");\n\t}\n\tstrbuf_puts_nl(sb, gen_form_end());\n\treturn strbuf_value(sb);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makemainindex: make main index\n *\n *\ti)\tfile\tfile name\n *\ti)\tindex\tcommon part\n */\n", "func_signal": "static void\nmakemainindex(const char *file, const char *index)", "code": "{\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot make file '%s'.\", file);\n\tfputs_nl(gen_page_index_begin(title, jscode), op);\n\tfputs_nl(body_begin, op);\n\tif (insert_header)\n\t\tfputs(gen_insert_header(TOPDIR), op);\n\tfputs(index, op);\n\tif (insert_footer)\n\t\tfputs(gen_insert_footer(TOPDIR), op);\n\tfputs_nl(body_end, op);\n\tfputs_nl(gen_page_end(), op);\n\tfclose(op);\n\thtml_count++;\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * make file in the dist directory.\n */\n", "func_signal": "static void\nmake_file_in_distpath(const char *name, const char *data)", "code": "{\n\tFILE *op;\n\tconst char *path = makepath(distpath, name, NULL);\n\n\top = fopen(path, \"w\");\n\tif (op) {\n\t\tif (data && *data) {\n\t\t\tfputs(data, op);\n\t\t\tfputc('\\n', op);\n\t\t}\n\t\tfclose(op);\n\t} else {\n\t\tdie(\"cannot make file '%s'.\", path); \n\t}\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * Htags catch signal even if the parent ignore it.\n */\n", "func_signal": "void\nclean(void)", "code": "{\n\tunload_gpath();\n\tcache_close();\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * makerebuild: make rebuild script\n */\n", "func_signal": "static void\nmakerebuild(const char *file)", "code": "{\n\tFILE *op;\n\n\top = fopen(makepath(distpath, file, NULL), \"w\");\n\tif (!op)\n\t\tdie(\"cannot make rebuild script.\");\n\tfputs_nl(\"#!/bin/sh\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# rebuild.sh: rebuild hypertext with the previous context.\", op);\n\tfputs_nl(\"#\", op);\n\tfputs_nl(\"# Usage:\", op);\n\tfputs_nl(\"#\\t% sh rebuild.sh\", op);\n\tfputs_nl(\"#\", op);\n\tfprintf(op, \"cd %s && GTAGSCONF='%s' htags%s\\n\", cwdpath, save_config, save_argv);\n        fclose(op);\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*\n * save_environment: save configuration data and arguments.\n */\n", "func_signal": "static void\nsave_environment(int argc, char *const *argv)", "code": "{\n\tchar command[MAXFILLEN];\n\tSTRBUF *sb = strbuf_open(0);\n\tSTRBUF *save_c = strbuf_open(0);\n\tSTRBUF *save_a = strbuf_open(0);\n\tint i;\n\tconst char *p;\n\tFILE *ip;\n\n\t/*\n\t * save config values.\n\t */\n\tsnprintf(command, sizeof(command), \"%s --config\", gtags_path);\n\tif ((ip = popen(command, \"r\")) == NULL)\n\t\tdie(\"cannot execute '%s'.\", command);\n\twhile (strbuf_fgets(sb, ip, STRBUF_NOCRLF) != NULL) {\n\t\tfor (p = strbuf_value(sb); *p; p++) {\n\t\t\tif (*p == '\\'') {\n\t\t\t\tstrbuf_putc(save_c, '\\'');\n\t\t\t\tstrbuf_putc(save_c, '\"');\n\t\t\t\tstrbuf_putc(save_c, '\\'');\n\t\t\t\tstrbuf_putc(save_c, '\"');\n\t\t\t\tstrbuf_putc(save_c, '\\'');\n\t\t\t} else\n\t\t\t\tstrbuf_putc(save_c, *p);\n\t\t}\n\t}\n\tif (pclose(ip) != 0)\n\t\tdie(\"cannot execute '%s'.\", command);\n\tstrbuf_close(sb);\n\tsave_config = strbuf_value(save_c);\n\t/* doesn't close string buffer for save config. */\n\t/* strbuf_close(save_c); */\n\n\t/*\n\t * save arguments.\n\t */\n\t{\n\t\tchar *opt_gtagsconf = \"--gtagsconf\";\n\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tchar *blank;\n\n\t\t\t/*\n\t\t\t * skip --gtagsconf because it is already read\n\t\t\t * as config value.\n\t\t\t */\n\t\t\tif ((p = locatestring(argv[i], opt_gtagsconf, MATCH_AT_FIRST))) {\n\t\t\t\tif (*p == '\\0')\n\t\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tblank = locatestring(argv[i], \" \", MATCH_FIRST);\n\t\t\tstrbuf_putc(save_a, ' ');\n\t\t\tif (blank)\n\t\t\t\tstrbuf_putc(save_a, '\\'');\n\t\t\tstrbuf_puts(save_a, argv[i]);\n\t\t\tif (blank)\n\t\t\t\tstrbuf_putc(save_a, '\\'');\n\t\t}\n\t}\n\tsave_argv = strbuf_value(save_a);\n\t/* doesn't close string buffer for save arguments. */\n\t/* strbuf_close(save_a); */\n}", "path": "htags\\htags.c", "repo_name": "kosaki/gtags", "stars": 12, "license": "other", "language": "c", "size": 753}
{"docstring": "/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n", "func_signal": "static void field (LexState *ls, expdesc *v)", "code": "{\n  /* field -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyreg(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}", "path": "open-ldb\\lparser.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* }====================================================== */\n", "func_signal": "static int g_write (lua_State *L, FILE *f, int arg)", "code": "{\n  int nargs = lua_gettop(L) - 1;\n  int status = 1;\n  for (; nargs--; arg++) {\n    if (lua_type(L, arg) == LUA_TNUMBER) {\n      /* optimization: could be done exactly as for strings */\n      status = status &&\n          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;\n    }\n    else {\n      size_t l;\n      const char *s = luaL_checklstring(L, arg, &l);\n      status = status && (fwrite(s, sizeof(char), l, f) == l);\n    }\n  }\n  return pushresult(L, status, NULL);\n}", "path": "open-ldb\\liolib.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* this function handles only `%d', `%c', %f, %p, and `%s' formats */\n", "func_signal": "const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp)", "code": "{\n  int n = 1;\n  pushstr(L, \"\");\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));\n    incr_top(L);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s);\n        break;\n      }\n      case 'c': {\n        char buff[2];\n        buff[0] = cast(char, va_arg(argp, int));\n        buff[1] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n      case 'd': {\n        setnvalue(L->top, cast_num(va_arg(argp, int)));\n        incr_top(L);\n        break;\n      }\n      case 'f': {\n        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));\n        incr_top(L);\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */\n        sprintf(buff, \"%p\", va_arg(argp, void *));\n        pushstr(L, buff);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\");\n        break;\n      }\n      default: {\n        char buff[3];\n        buff[0] = '%';\n        buff[1] = *(e+1);\n        buff[2] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  pushstr(L, fmt);\n  luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);\n  L->top -= n;\n  return svalue(L->top - 1);\n}", "path": "open-ldb\\lobject.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** miscellaneous functions\n*/\n", "func_signal": "LUA_API int lua_error (lua_State *L)", "code": "{\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  lua_unlock(L);\n  return 0;  /* to avoid warnings */\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** set functions (stack -> Lua)\n*/\n", "func_signal": "LUA_API void lua_settable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** Garbage-collection function\n*/\n", "func_signal": "LUA_API int lua_gc (lua_State *L, int what, int data)", "code": "{\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->GCthreshold = MAX_LUMEM;\n      break;\n    }\n    case LUA_GCRESTART: {\n      g->GCthreshold = g->totalbytes;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(g->totalbytes >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(g->totalbytes & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      lu_mem a = (cast(lu_mem, data) << 10);\n      if (a <= g->totalbytes)\n        g->GCthreshold = g->totalbytes - a;\n      else\n        g->GCthreshold = 0;\n      while (g->GCthreshold <= g->totalbytes)\n        luaC_step(L);\n      if (g->gcstate == GCSpause)  /* end of cycle? */\n        res = 1;  /* signal it */\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      g->gcstepmul = data;\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  lua_unlock(L);\n  return res;\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** check whether, in an assignment to a local variable, the local variable\n** is needed in a previous assignment (to a table). If so, save original\n** local value in a safe place and use this safe copy in the previous\n** assignment.\n*/\n", "func_signal": "static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {\n    if (lh->v.k == VINDEXED) {\n      if (lh->v.u.s.info == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.info = extra;  /* previous assignment will use safe copy */\n      }\n      if (lh->v.u.s.aux == v->u.s.info) {  /* conflict? */\n        conflict = 1;\n        lh->v.u.s.aux = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */\n    luaK_reserveregs(fs, 1);\n  }\n}", "path": "open-ldb\\lparser.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)", "code": "{\n LoadState S;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n return LoadFunction(&S,luaS_newliteral(L,\"=?\"));\n}", "path": "open-ldb\\lundump.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* converts back */\n", "func_signal": "int luaO_fb2int (int x)", "code": "{\n  int e = (x >> 3) & 31;\n  if (e == 0) return x;\n  else return ((x & 7)+8) << (e - 1);\n}", "path": "open-ldb\\lobject.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* }====================================================================== */\n", "func_signal": "static void parlist (LexState *ls)", "code": "{\n  /* parlist -> [ param { `,' param } ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  f->is_vararg = 0;\n  if (ls->t.token != ')') {  /* is `parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {  /* param -> NAME */\n          new_localvar(ls, str_checkname(ls), nparams++);\n          break;\n        }\n        case TK_DOTS: {  /* param -> `...' */\n          luaX_next(ls);\n#if defined(LUA_COMPAT_VARARG)\n          /* use `arg' as default name */\n          new_localvarliteral(ls, \"arg\", nparams++);\n          f->is_vararg = VARARG_HASARG | VARARG_NEEDSARG;\n#endif\n          f->is_vararg |= VARARG_ISVARARG;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or \" LUA_QL(\"...\") \" expected\");\n      }\n    } while (!f->is_vararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */\n}", "path": "open-ldb\\lparser.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n* make header\n*/\n", "func_signal": "void luaU_header (char* h)", "code": "{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);\n h+=sizeof(LUA_SIGNATURE)-1;\n *h++=(char)LUAC_VERSION;\n *h++=(char)LUAC_FORMAT;\n *h++=(char)*(char*)&x;\t\t\t\t/* endianness */\n *h++=(char)sizeof(int);\n *h++=(char)sizeof(size_t);\n *h++=(char)sizeof(Instruction);\n *h++=(char)sizeof(lua_Number);\n *h++=(char)(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n}", "path": "open-ldb\\lundump.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** When creating file handles, always creates a `closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** file is not left opened.\n*/\n", "func_signal": "static FILE **newfile (lua_State *L)", "code": "{\n  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));\n  *pf = NULL;  /* file handle is currently `closed' */\n  luaL_getmetatable(L, LUA_FILEHANDLE);\n  lua_setmetatable(L, -2);\n  return pf;\n}", "path": "open-ldb\\liolib.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** get functions (Lua -> stack)\n*/\n", "func_signal": "LUA_API void lua_gettable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "open-ldb\\lcode.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "open-ldb\\lcode.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** push functions (C -> stack)\n*/\n", "func_signal": "LUA_API void lua_pushnil (lua_State *L)", "code": "{\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** this function has a separated environment, which defines the\n** correct __close for 'popen' files\n*/\n", "func_signal": "static int io_pclose (lua_State *L)", "code": "{\n  FILE **p = topfile(L);\n  int ok = lua_pclose(L, *p);\n  *p = NULL;\n  return pushresult(L, ok, NULL);\n}", "path": "open-ldb\\liolib.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize)", "code": "{\n  (void)ud;\n  (void)osize;\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}", "path": "open-ldb\\lauxlib.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/*\n** access functions (stack -> C)\n*/\n", "func_signal": "LUA_API int lua_type (lua_State *L, int idx)", "code": "{\n  StkId o = index2adr(L, idx);\n  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);\n}", "path": "open-ldb\\lapi.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_ref (lua_State *L, int t)", "code": "{\n  int ref;\n  t = abs_index(L, t);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* `nil' has a unique fixed reference */\n  }\n  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */\n  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */\n  lua_pop(L, 1);  /* remove it from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */\n  }\n  else {  /* no free elements */\n    ref = (int)lua_objlen(L, t);\n    ref++;  /* create new reference */\n  }\n  lua_rawseti(L, t, ref);\n  return ref;\n}", "path": "open-ldb\\lauxlib.c", "repo_name": "luaforge/lua-eclipse-ide", "stars": 11, "license": "None", "language": "c", "size": 30025}
{"docstring": "// Print a pending request\n", "func_signal": "void printRequest(request* req)", "code": "{\n\tprintf(\"number: %d\\n\", req->number);\n\tprintf(\"clientID: %s\\n\", req->clientID);\n\tprintf(\"priority: %d\\n\", req->priority);\n\tprintf(\"funcRequest: %s\\n\", req->funcRequest);\n\tprintf(\"movieName: %s\\n\", req->movieName);\n\tprintf(\"argument: %d\\n\", req->argument);\n\tprintf(\"request string: %s\\n\", req->requestString);\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Delete worker threads until we are back at the initial number of worker threads\n// This is the loopback function for the reaper thread.  The reaper thread uses\n// pthread_cond_timedwait to sleep for REAPER_TIMEOUT time.  When it awakes,\n// it checks to see if there are idle threads to kill. \n", "func_signal": "void deleteWorkers()", "code": "{\n\tint i, numToDelete;\n\n\twhile (1) {\n\t\treaperTime.tv_sec = time(NULL) + REAPER_TIMEOUT;\n\t\treaperTime.tv_nsec = 0;\n#ifdef DEBUG\n\t\tprintf(\"Reaper going to sleep\\n\");\n#endif\n\t\t// Sleep for a period of time\n\t\tpthread_cond_timedwait(&reaperCondVar, &reaperMutex, &reaperTime);\n\n#ifdef DEBUG\n\t\tprintf(\"Reaper about to kill something\\n\");\n#endif\n\n\t\t// Reaper is awake, see if there are idle threads to kill (if number of\n\t\t// threads is greater than the initial worker threads\n\t\tnumToDelete = numWorkerThreads - MIN_WORKER_THREADS;\n\t\ti = 0;\n\t\twhile (numToDelete > 0 && i <= highestThreadID) {\n\t\t\tif (workerAction[i] == IDLE) {\n\t\t\t\tworkerAction[i] = KILL;\n\t\t\t\tnumWorkerThreads--;\n\t\t\t\tnumToDelete--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t// Wake all worker threads so they can check if they should kill themselves\n\t\tpthread_cond_broadcast(&pendingRequest);\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Remove a clientID from the stopList.  If the requested clientID does\n// not exist in the stopList, nothing is done.\n", "func_signal": "void deleteStopID(char* stopID)", "code": "{\n\tstopList* current;\n\n\t// Start at the head\n\tcurrent = stopHead;\n\n\tif (!current) return;\n\n\n\t// Head is the delete guy\n\tif (strcmp(current->clientID, stopID) == 0) {\n\t\tstopHead = stopHead->next;\n\t\tfree(current);\n\t\treturn;\n\t}\n\n\t// Search for the clientID to remove\n\twhile (current->next) {\n\t\tif (strcmp(current->next->clientID, stopID) == 0) {\n\t\t\tstopList* deleteGuy = current->next;\n\t\t\tcurrent->next = current->next->next;\n\t\t\tfree(deleteGuy);\n\t\t\treturn;\n\t\t}\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Generates the messages based on the function requested by the client\n// Function name is either: start_movie, stop_movie, seek_movie\n", "func_signal": "void generateMessages(int workerThreadID, request* req)", "code": "{\n\tint frame, messageID, endFrame, startFrame;\n\tint repeat;\n\tchar* clientID = req->clientID;\n\n\t// Handle a stop_movie request\n\t// Add the clientID into the stopList\n\tif(strcmp(req->funcRequest, \"stop_movie\") == 0) {\\\n\t\tinsertStopID(clientID);\n#ifdef DEBUG\n\t\tprintStopList();\n#endif\n\t\treturn;\n\t}\n\n\t// Handle a start_movie request\n\tif (strcmp(req->funcRequest, \"start_movie\") == 0) {\n\t\tstartFrame = 1;  \n\t\trepeat = req->argument; \n\t}\n\t// Handle a seek_movie request\n\telse if(strcmp(req->funcRequest, \"seek_movie\") == 0) {\n\t\t// Start frame is the seek frame\n\t\tstartFrame = req->argument;\n\t\trepeat = 0;\n\t\t// Do some minor error checking\n\t\tif (startFrame <= 0) {\n\t\t\tstartFrame = 1;\n\t\t}\n\t}\n\n\tmessageID = 1;\n\tendFrame = 100; //magic cookie bad\n\n\t// Create a message for each frame from the startframe to the endframe\n\t// For start_movie, it is the entire movie\n\t// For seek_movie, it is seekFrame-->endFrame\n\tfor (frame = startFrame; frame <= endFrame; frame++) {\n\t\tpixel** pixArray;\n\t\tFILE *fp;\n\t\tint cols, rows;\n\t\tpixval maxval;\n\t\tchar s[80];\n\n\t\t// Attempt to open the frame for processing\n\t\tsprintf (s, \"./images/%s%d.ppm\", req->filePrefix, frame);\n\t\tif ((fp = fopen (s,\"r\")) == NULL) {\n\t\t\tfprintf (stderr, \"%s: Can't open input file:\\n %s.\\n\", s);\n\t\t\texit (1);\n\t\t}\n\n\t\t// Read the ppm image into a multidimensional array\n\t\tpixArray = ppm_readppm (fp, &cols, &rows, &maxval);\n\t\tfclose (fp);\n\n\t\t// Since all slots have a copy of the original client request\n\t\t// create a pointer to the request object so we don't waste memory\n\t\trequest* copyReq = req;\n\n\t\t// IMPORTANT regarding stopping playback\t\n\t\t// We check every 20 frames to reduce redundancy\n\t\t// We don't want to generate messages for a movie that the client\n\t\t// has already requested be stopped, so check every 20 messages to make sure\n\t\tif (frame != 100 && ((frame % 20) == 0)) {\n\t\t\t// If the message is part of a movie which the client has already\n\t\t\t// requested be stopped, then stop sending them frames and\n\t\t\t// jump to the last frame\n\t\t\tif (searchStopList(clientID) == TRUE) {\n\t\t\t\tframe = 99;\t\n\t\t\t\tppm_freearray (pixArray, rows);\n\t\t\t}\n\t\t\t// Otherwise this is still part of a valid movie request\n\t\t\telse {\n\t\t\t\t// Insert this message into the buffer\tand increment the message id\n\t\t\t\tinsertToBuffer(workerThreadID, copyReq, messageID, pixArray, rows, cols, frame, repeat);\n\t\t\t\tmessageID++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Insert this message into the buffer\tand increment the message id\n\t\t\tinsertToBuffer(workerThreadID, copyReq, messageID, pixArray, rows, cols, frame, repeat);\n\t\t\tmessageID++;\n\t\t}\n\t}                                                                           \n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Eventhandler for a worker thread\n", "func_signal": "void handleRequest(request* req, int threadID)", "code": "{\n\tif (req != NULL) {\n\t\t// This function is in buffer.c\n\t\tgenerateMessages(threadID, req);\n#ifdef DEBUG\n\t\tprintf(\"thread: %d handled request %d\\n\", threadID, req->number);\n#endif\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Insert a new worker thread into thread pool \n", "func_signal": "void insertWorker()", "code": "{\n\tint i, ret;\n\tpthread_t newWorker;\n\tworkerIDs[nextThreadID] = nextThreadID;\n\n\t// Create a new pthread\n\tret = pthread_create(&newWorker, NULL, (void *) handleLoop, (void*)&workerIDs[nextThreadID]);\n\tworkerAction[nextThreadID] = IDLE;\n\n\t// Find the next threadID to use for the next new worker thread\n\tfor (i = 0; i <= highestThreadID + 1; i++) {\n\t\tif (workerAction[i] == DEAD) {\n\t\t\tnextThreadID = i;\n\t\t\tif (nextThreadID > highestThreadID) {\n\t\t\t\thighestThreadID = nextThreadID;\n\t\t\t}\n\t\t\tnumWorkerThreads++;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Initialize the circular buffer\n", "func_signal": "void initBuffer()", "code": "{\n\tint i;\n\tfor (i = 0; i < MAXSLOTS; i++) {\n\t\tinitSlot(i);\n\t}\n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Sends the pixarray for a given slot in the circular buffer\n// The size of the frame we send is (rows * cols * 3) + 1.\n// The *3 is for the three channels per pixel (RGB) and the +1\n// is an extra byte which lets the client know whether or not\n// more data is coming (we denote this byte as the TERM flag).\n// If the term flag == 1, then there is more data coming, so the\n// client should keep the connection open.\n// If the term flag == 0, then there is no more data coming, and\n// the client should close the connection.\n", "func_signal": "void sendFrame(int bufferIndex)", "code": "{ \n\tint i = bufferIndex;\n\tint sizeToSend = buffer[i].rows * buffer[i].cols * 3 + 1;\n\tint x, y;\n\tint rows = buffer[i].rows;\n\tint cols = buffer[i].cols;\n\tunsigned char *buf = NULL;\n\n\t// +1 slot used to determine if there is more data coming: 0 or 1\n\tbuf = (unsigned char *)malloc ((cols*rows*3) + 1);\n\tif (!buf) {\n\t\tperror(\"Could not malloc memory for buf\\n\");\t\n\t\texit(1);\n\t}\n\n\t// Place the frame data into a char array\n\tfor (y = 0; y < rows; y++) {\n\t\tfor (x = 0; x < cols; x++) {\n\t\t\tbuf[(y*cols+x)*3+0] = PPM_GETR(buffer[i].pixArray[rows-y-1][x]);\n\t\t\tbuf[(y*cols+x)*3+1] = PPM_GETG(buffer[i].pixArray[rows-y-1][x]);\n\t\t\tbuf[(y*cols+x)*3+2] = PPM_GETB(buffer[i].pixArray[rows-y-1][x]);\n\t\t}\n\t}\n\tchar* clientID = buffer[i].clientRequest->clientID;\n\n\t// Determine if this is part of a movie which was already stopped by client\n\tint inStopList = searchStopList(clientID);\n\n\t// clientRequest objects are shared for all frames belonging to a single\n\t// client request.  Therefore, no need to make redundant copies, just pointers.\n\t// Only free this client request obj when the last frame is serviced!\n\tint deleteFlag = FALSE;\n\n\t// Check to see if the movie has repeat = 1, if so, there is more data to send even\n\t// though the movie is done playing.\n\tif (buffer[i].frame == 100) {\n\t\t// If its a repeat, and the client hasnt requested a stop movie, then copy this request again\n\t\tif (buffer[i].repeat == TRUE && inStopList == FALSE) {\n\t\t\t// Add a start_movie request to the request list, with repeat flag = 1\n\t\t\t// Set the 100th frame with more data flag = 1\n\t\t\tdeleteFlag = FALSE;\n\t\t\tinsertRequest(buffer[i].clientRequest);\n\t\t\tbuf[cols*rows*3] = NOTCLOSE;\n\t\t}\n\t\telse {\n\t\t\t// Call deleteStopID(clientID)\n\t\t\t// Set the 100th frame with more data flag = 0\n\t\t\tdeleteStopID(clientID);\n\t\t\tbuf[cols*rows*3] = CLOSE;\n\t\t\tdeleteFlag = TRUE;\n\t\t}\n\t}\n\t// If its not the last frame\n\telse {\n\t\t// If it is part of a movie which was stopped, then this is the last frame\n\t\t// and the client should just close the connection\n\t\tif (inStopList == TRUE) {\n\t\t\tbuf[cols*rows*3] = CLOSE;\n\t\t}\n\t\t// Otherwise this is a frame for a movie which has regular playback\n\t\t// so don't close the connection, just receive the movie frames\n\t\telse {\n\t\t\tbuf[cols*rows*3] = NOTCLOSE;\n\t\t}\n\t}\n\n\t// The movie hasn't been stopped, so send the frame data\n\tif (inStopList == FALSE) {\n\t\t// Send the entire frame (reduces write syscalls)\n#ifdef DEBUG\n\t\tprintf(\"Send frame: %d    request string: %s\\n\", \n\t\t\t\tbuffer[i].frame, buffer[i].clientRequest->requestString);\n#endif\n\t\twrite(buffer[i].clientRequest->clientSD, buf, sizeToSend);\n\t\tif (errno == EPIPE) {\n#ifdef DEBUG\n\t\t\tprintf(\"Got EPIPE error   errno: %d\\n\", errno);\n#endif\n\t\t\tinsertStopID(buffer[i].clientRequest->clientID);\n\t\t\tclose(buffer[i].clientRequest->clientSD);\n\t\t\terrno = 0;\n\t\t}\n\t}\n\n\t// Release the memory \n\tppm_freearray (buffer[i].pixArray, buffer[i].rows);\n\tfree(buf);\n\n\t// If this clientRequest obj is not going to be used anymore, free\n\tif (deleteFlag == TRUE) {\n\t\tfree(buffer[i].clientRequest);\n\t}\n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Initializes the thread pool by creating 'initialThreads' workerthreads\n// And creating a dispatcher thread who sleeps initially\n// And creating a reaper thread who kills idle threads\n", "func_signal": "void initThreadPool(int initialThreads)", "code": "{\n\tint i;\n\n\tMIN_WORKER_THREADS = initialThreads;\n\n\t// Initialize worker thread data structures\n\tfor (i = 0; i < MAX_WORKER_THREADS; i++) {\n\t\tworkerAction[i] = DEAD;\n\t\tworkerIDs[i] = 0;\n\t}\n\n\t// Create initial worker threads\n\tfor (i = 0; i < initialThreads; i++) {\n\t\tinsertWorker();\n\t}\n\n\t// Initialize dispatcher thread; it will process the m messages.\n\tpthread_t dispatcher;\n\tpthread_create(&dispatcher, NULL,(void*) process, NULL);\n#ifdef DEBUG\n\tprintf(\"Dispatcher thread created.\\n\");\n#endif\t\n\t// Create a reaper thread here\n\tpthread_t reaper;\n\tpthread_create(&reaper, NULL, (void *) deleteWorkers, NULL);\n#ifdef DEBUG\n\tprintf(\"Reaper thread created.\\n\");\n#endif\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Inserts a worker thread's text message into the next\n// available slot in the circular buffer.\n", "func_signal": "void insertToBuffer(int in_workerthread_id, request* clientRequest, int messageID, \n\t\tpixel** in_pixArray, int in_rows, int in_cols, int in_frame, int in_repeat)", "code": "{\n\twhile (1) {\n\t\t// Check for empty slots; if no empty slots, wait.\n\t\tif (isBufferFull() == TRUE) {\n\t\t\tpthread_cond_wait(&bufferWait, &bufferMutex);\n\t\t}\n\t\telse {\n\t\t\t// Grab buffer mutex to ensure exclusive access to buffer.\n\t\t\tpthread_mutex_lock(&bufferMutex);\n\t\t}\n\n\t\t// Go through all buffer slots and find an empty one;\n\t\tint i;\n\t\tfor (i = 0; i < MAXSLOTS; i++) {\n\t\t\tif (buffer[i].isFilled == FALSE) {\n\t\t\t\tbuffer[i].isFilled = TRUE;\n\t\t\t\tbuffer[i].workerthread_id = in_workerthread_id;\n\t\t\t\tbuffer[i].clientRequest = clientRequest;\n\t\t\t\tbuffer[i].priority = clientRequest->priority;\n\t\t\t\tbuffer[i].messageID = messageID;\n\t\t\t\tbuffer[i].pixArray = in_pixArray;\n\t\t\t\tbuffer[i].rows = in_rows;\n\t\t\t\tbuffer[i].cols = in_cols;\n\t\t\t\tbuffer[i].frame = in_frame;\n\t\t\t\tbuffer[i].repeat = in_repeat;\n\t\t\t\topenSlots--;\n\n\t\t\t\t// Check to see if m slots are full, then signal dispatcher\n\t\t\t\tif (openSlots == (MAXSLOTS - DISPATCHER_BATCH_AMOUNT)) {\n\t\t\t\t\tpthread_cond_signal(&dispatcherWait);\n\n\t\t\t\t\t// Have the worker thread wait until the dispatcher wakes it\n\t\t\t\t\tpthread_cond_wait(&bufferWait, &bufferMutex);\n\t\t\t\t}\n\n\t\t\t\t// Release buffer mutex.\n\t\t\t\tpthread_mutex_unlock(&bufferMutex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Release buffer mutex.\n\t\tpthread_mutex_unlock(&bufferMutex);\n\t}\n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Print the list of all pending requests\n", "func_signal": "void printAllRequests()", "code": "{\n\trequest* iter = requests;\n\twhile (iter) {\n\t\tprintRequest(iter);\n\t\titer = iter->next;\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Loopback function for a worker thread\n// If there are pending requests, and the worker is IDLE, then it attempts\n// to grab the mutex and service the next request.  IF there are no pending\n// requests then it sleeps by waiting on a condition variable.\n// If the thread has been selected for termination (by the reaper thread), then\n// it calls pthread_exit() to terminate itself.\n", "func_signal": "void* handleLoop(void* data)", "code": "{\n\tint ret;\n\trequest* req = NULL;\n\tint threadID = *((int*)data);\n\n#ifdef DEBUG\n\tprintf(\"thread: %d starting thread\\n\", threadID);\n#endif\n\n\t// Lock the mutex \n\tret = pthread_mutex_lock(&requestMutex);\n\n\t// Perform this loop forever\n\twhile (1) {\n\t\t// The thread has been selected for termination by the reaper\n\t\tif (workerAction[threadID] == KILL) {\n\t\t\tret = pthread_mutex_unlock(&requestMutex);\n#ifdef DEBUG\n\t\t\tprintf(\"thread: %d about to kill himself\\n\", threadID);\n#endif\n\t\t\tworkerAction[threadID] = DEAD;\n\t\t\tpthread_exit(0);\n\t\t}\n\t\t// There are pending requests and the thread is idle\n\t\telse if (workerAction[threadID] == IDLE && numRequests > 0) {\n#ifdef DEBUG\n\t\t\tprintf(\"thread: %d about to do some work   numRequests: %d\\n\", threadID, numRequests);\n#endif\n\n\t\t\t// At this point we should have a mutex lock from wait() or the initial lock\n\t\t\t// So get the next request and service it\n\t\t\treq = getNextRequest();\n\t\t\tif (req != NULL) {\n\t\t\t\t// Update my status so the reaper won't select me for termination\n\t\t\t\tworkerAction[threadID] = BUSY;\n\n\t\t\t\t// Unlock mutex so another thread can get another request \n\t\t\t\tret = pthread_mutex_unlock(&requestMutex);\n\n\t\t\t\thandleRequest(req, threadID);\n\t\t\t\tworkerAction[threadID] = IDLE;\n\t\t\t\tret = pthread_mutex_lock(&requestMutex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Wait to be signaled \n#ifdef DEBUG\n\t\t\tprintf(\"thread: %d waiting for signal\\n\", threadID);\n#endif\n\t\t\tret = pthread_cond_wait(&pendingRequest, &requestMutex);\n#ifdef DEBUG\n\t\t\tprintf(\"thread: %d got signaled\\n\", threadID);\n#endif\n\t\t}\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Given a client request string populate a new request object\n// NOTE! We assume the client is sending valid requests that follow our protocol\n", "func_signal": "void populateRequest(char* requestString, request* newRequest)", "code": "{\n\tchar* temp = NULL;\n\tchar* delimeter = \":\";\n\tchar* copy = NULL;\n\n\t// make a copy of the string first\n\tcopy = (char*) malloc(sizeof(char) * (strlen(requestString) + 1));\n\tstrcpy(copy, requestString);\n\n\t// Lets be nice and check for stupidity\n\tif (!newRequest) {\n\t\tperror(\"populateRequest: cannot pass in null newRequest object.\\n\");\n\t\texit(1);\n\t}\n\n\t// Get the clientID\n\ttemp = strtok(copy, delimeter);\n\tnewRequest->clientID = (char*)malloc(sizeof(char) * (strlen(temp) + 1));\n\tstrcpy(newRequest->clientID, temp);\n\n\t// Get the priority\n\ttemp = strtok(NULL, delimeter);\n\tint priority = atoi(temp);\n\tnewRequest->priority = priority;\n\n\t// Get the function request\n\ttemp = strtok(NULL, delimeter);\n\tnewRequest->funcRequest = (char*)malloc(sizeof(char) * (strlen(temp) + 1));\n\tstrcpy(newRequest->funcRequest, temp);\n\n\t// Get the movie name\n\ttemp = strtok(NULL, delimeter);\n\tnewRequest->movieName = (char*)malloc(sizeof(char) * (strlen(temp) + 1));\n\tstrcpy(newRequest->movieName, temp);\n\n\t// Get the argument (if available)\n\ttemp = strtok(NULL, delimeter);\n\tif (temp) {\n\t\tint argument = atoi(temp);\n\t\tnewRequest->argument = argument;\n#ifdef DEBUG\n\t\tprintf(\"argument: %d    newRequest->argument: %d\\n\", argument, newRequest->argument);\n#endif\n\t}\n\n\t// Store a copy of the original request string\n\tnewRequest->requestString = (char*)malloc(sizeof(char) * (strlen(requestString) + 1));\n\tstrcpy(newRequest->requestString, requestString);\n\n\tnewRequest->next = NULL;\n\tfree(copy);\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Dispatcher thread's function call that processes m messages.\n", "func_signal": "void process()", "code": "{\n\t// Do this forever\n\twhile (1) {\n#ifdef DEBUG\n\t\tprintf(\"dispatcher: going to sleep again\\n\");\n#endif\n\n\t\t// Wait until its time to wake up\n\t\tpthread_cond_wait(&dispatcherWait, &bufferMutex);\n\n#ifdef DEBUG\n\t\tprintf(\"dispatcher: i'm awake\\n\");\n#endif\n\n\t\t// Ok at this point our dispatcher is awake and ready\n\n\t\t// Dispatcher thread calls sorting algorithm here to sort buffer in order.\n\t\tqsort(buffer, MAXSLOTS, sizeof(struct slot), compare);\n#ifdef DEBUG\n\t\tprintf(\"dispatcher: buffer sorted\\n\");\n#endif\n\n\t\t// Retrieve m messages\n\t\tint i = 0;\n\t\tint served = 0;\n\t\twhile (served < DISPATCHER_BATCH_AMOUNT && i < MAXSLOTS) {\n\t\t\tif (buffer[i].isFilled == TRUE) {\n\t\t\t\t// PART 1 Test\n\t\t\t\t//\twrite(buffer[i].clientRequest->clientSD, buffer[i].clientRequest->requestString, 1000);\n\n\t\t\t\t// Send this frame\n\t\t\t\tsendFrame(i);\n\n\t\t\t\topenSlots++;\n\t\t\t\tinitSlot(i);\n\t\t\t\tserved++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"dispatcher: done\\n\");\n#endif\n\n\t\t// Release buffer mutex.\n\t\tpthread_mutex_unlock(&bufferMutex);\n\n\t\t// Let workers know I'm done so they can continue\n\t\t// Prevents a deadlock I was getting\n\t\tpthread_cond_signal(&bufferWait);\n\t}\n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Print all clientIDs in the stop list\n", "func_signal": "void printStopList()", "code": "{\n\tstopList* iter = stopHead;\n\twhile (iter) {\n\t\tprintf(\"clientID: %s\\n\", iter->clientID);\n\t\titer = iter->next;\n\t}\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Initialize a request object\n", "func_signal": "void initRequest(request* req)", "code": "{\n\treq->number = 0;\n\treq->clientSD = 0;\n\treq->clientID = 0;\n\treq->priority = 0;\n\treq->funcRequest = NULL;\n\treq->movieName = NULL;\n\treq->argument = 0;\n\treq->requestString = NULL;\n\treq->filePrefix = NULL;\n\treq->next = NULL;\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Insert a clientID into the stop list. \n", "func_signal": "void insertStopID(char* stopID)", "code": "{\n\tstopList* newStop = (stopList*) malloc(sizeof(stopList));\n\n\t// Nice error checking\n\tif (!newStop) {\n\t\tperror(\"Couldn't allocate memory for insertStopID\\n\");\n\t\texit(1);\n\t}\n\n\t// Populate our new stopList node\n\t//newStop->clientID = stopID;\n\tnewStop->clientID = (char*)malloc(sizeof(char) * (strlen(stopID) + 1));\n\tstrcpy(newStop->clientID, stopID);\n\n\t// Insert into head\n\tnewStop->next = stopHead;\n\n\t// Update head\n\tstopHead = newStop;\t\t\t\t\t\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Get next request to be serviced (head)\n", "func_signal": "request* getNextRequest()", "code": "{\n\trequest* returnRequest;\n\n\tif (numRequests > 0) {\n\t\treturnRequest = requests;\n\t\trequests = returnRequest->next;\n\t\t// If this was the last request on the list\n\t\tif (requests == NULL) { \n\t\t\ttailRequest = NULL;\n\t\t}\n\t\t// decrease the total number of pending requests \n\t\tnumRequests--;\n\t}\n\telse { \n\t\treturnRequest = NULL;\n\t}\n\n\treturn returnRequest;\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Initialize one slot in the circular buffer\n", "func_signal": "void initSlot(int slotNumber)", "code": "{\n\tbuffer[slotNumber].isFilled = FALSE;\n\tbuffer[slotNumber].workerthread_id = -1;\n\tbuffer[slotNumber].priority = -1;\n\tbuffer[slotNumber].messageID = -1;\n\tbuffer[slotNumber].clientRequest = NULL;\n\tbuffer[slotNumber].pixArray = NULL;\n\tbuffer[slotNumber].rows = -1;\n\tbuffer[slotNumber].cols = -1;\n\tbuffer[slotNumber].repeat = -1;\n\tbuffer[slotNumber].frame = -1;\n}", "path": "src\\buffer.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "// Insert a request object into the linked list of pending requests\n// Worker threads are signaled when a new request is added and compete\n// for a mutex.  Requests are serviced FIFO.\n", "func_signal": "void insertRequest(request* newRequest)", "code": "{\n\t// Lock the mutex, to assure exclusive access to the list \n\tint ret = pthread_mutex_lock(&requestMutex);\n\n\t// Add new request to the end of the list, updating list \n\tif (numRequests == 0) {\n\t\trequests = newRequest;\n\t\ttailRequest = newRequest;\n\t}\n\telse {\n\t\ttailRequest->next = newRequest;\n\t\ttailRequest = newRequest;\n\t}\n\n\t// Increase total number of pending requests \n\tnumRequests++;\n\n\t// Check to see if we need more worker threads\n\tif (numRequests > MIN_WORKER_THREADS) {\n\t\tinsertWorker();\n\t}\n\n#ifdef DEBUG\n\tprintf(\"added new request id: %d\\n\", newRequest->number);\n#endif\n\n\t// Unlock mutex \n\tret = pthread_mutex_unlock(&requestMutex);\n\n\t// Signal the condition variable - there's a new request to handle \n\tret = pthread_cond_signal(&pendingRequest);\n}", "path": "src\\threadpool.c", "repo_name": "hanchang/VideoServerClient", "stars": 8, "license": "None", "language": "c", "size": 6192}
{"docstring": "/**\n * blend destination pixel and glyf pixel with correct color and alpha\n *\n * @param backColor color read from bitmap pixel\n * @param glyfColor color of glyf\n * @param glyfAlpha antialias value from alpha mask\n * @param globAlpha global alpha of text\n * return           blended pixel value to be written\n */\n", "func_signal": "inline static unsigned int blend( unsigned int backColor,\n                                  unsigned int glyfColor,\n                                  unsigned int glyfAlpha,\n                                  unsigned int globAlpha )", "code": "{\n   unsigned int c = 0;\n\n   glyfAlpha = ( glyfAlpha * globAlpha ) / 255;\n\n   c += ( ( ( ( glyfColor & 0x000000FF ) * glyfAlpha ) +\n              ( backColor & 0x000000FF ) * ( 0xFF - glyfAlpha ) ) >> 8 ) & 0x000000FF;\n   c += ( ( ( ( glyfColor & 0x0000FF00 ) * glyfAlpha ) +\n              ( backColor & 0x0000FF00 ) * ( 0xFF - glyfAlpha ) ) >> 8 ) & 0x0000FF00;\n   c += ( ( ( ( glyfColor & 0x00FF0000 ) * glyfAlpha ) +\n              ( backColor & 0x00FF0000 ) * ( 0xFF - glyfAlpha ) ) >> 8 ) & 0x00FF0000;\n\n   return c;\n}", "path": "PAL\\Linux\\src\\PALFont.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// decode one 64-entry block--\n", "func_signal": "static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)", "code": "{\n   int diff,dc,k;\n   int t = decode(j, hdc);\n   if (t < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) dc;\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      int r,s;\n      int rs = decode(j, hac);\n      if (rs < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n      s = rs & 15;\n      r = rs >> 4;\n      if (s == 0) {\n         if (rs != 0xf0) break; // end block\n         k += 16;\n      } else {\n         k += r;\n         // decode into unzigzag'd location\n         data[dezigzag[k++]] = (short) extend_receive(j,s);\n      }\n   } while (k < 64);\n   return 1;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// create the png data from post-deflated data\n", "func_signal": "static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)", "code": "{\n   stbi *s = &a->s;\n   uint32 i,j,stride = x*out_n;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n   assert(out_n == s->img_n || out_n == s->img_n+1);\n   if (stbi_png_partial) y = 1;\n   a->out = (uint8 *) malloc(x * y * out_n);\n   if (!a->out) return e(\"outofmem\", \"Out of memory\");\n   if (!stbi_png_partial) {\n      if (s->img_x == x && s->img_y == y)\n         if (raw_len != (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n      else // interlaced:\n         if (raw_len < (img_n * x + 1) * y) return e(\"not enough pixels\",\"Corrupt PNG\");\n   }\n   for (j=0; j < y; ++j) {\n      uint8 *cur = a->out + stride*j;\n      uint8 *prior = cur - stride;\n      int filter = *raw++;\n      if (filter > 4) return e(\"invalid filter\",\"Corrupt PNG\");\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n      // handle first pixel explicitly\n      for (k=0; k < img_n; ++k) {\n         switch(filter) {\n            case F_none       : cur[k] = raw[k]; break;\n            case F_sub        : cur[k] = raw[k]; break;\n            case F_up         : cur[k] = raw[k] + prior[k]; break;\n            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;\n            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;\n            case F_avg_first  : cur[k] = raw[k]; break;\n            case F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n      if (img_n != out_n) cur[img_n] = 255;\n      raw += img_n;\n      cur += out_n;\n      prior += out_n;\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (img_n == out_n) {\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch(filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;\n         }\n         #undef CASE\n      } else {\n         assert(img_n+1 == out_n);\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch(filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;\n         }\n         #undef CASE\n      }\n   }\n   return 1;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// take a -128..127 value and clamp it and convert to 0..255\n", "func_signal": "__forceinline static uint8 clamp(int x)", "code": "{\n   x += 128;\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (uint8) x;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/**\n * reverse the direction of the outline so it can be subtracted\n *\n * @param  aOutlineIn  outline to be reversed\n * @param  aOutlineOut reversed ouline\n * @return             none\n */\n", "func_signal": "static void ft_OutlineReverse( FT_Outline *aOutlineIn,\n                               FT_Outline *aOutlineOut )", "code": "{\n   int i;\n\n   /* Reverse the points */\n   for ( i = 0 ; i < aOutlineIn->n_points; i++ ) {\n      aOutlineOut->points[ i ] = aOutlineIn->points[ aOutlineIn->n_points - i - 1 ];\n   }\n\n   /* Reverse the tags */\n   for ( i = 0 ; i < aOutlineIn->n_points; i++ ) {\n      aOutlineOut->tags[ i ] = aOutlineIn->tags[ aOutlineIn->n_points - i - 1 ];\n   }\n\n   /* Reverse the contours */\n   for ( i = 0; i < aOutlineIn->n_contours - 1; i++ ) {\n      aOutlineOut->contours[ i ] = aOutlineIn->n_points - aOutlineIn->contours[ aOutlineIn->n_contours - i - 2 ] - 2;\n   }\n}", "path": "PAL\\Linux\\src\\outline.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// Targa Truevision - TGA\n// by Jonathan Dummer\n", "func_signal": "static int tga_test(stbi *s)", "code": "{\n\tint sz;\n\tget8u(s);\t\t//\tdiscard Offset\n\tsz = get8u(s);\t//\tcolor type\n\tif( sz > 1 ) return 0;\t//\tonly RGB or indexed allowed\n\tsz = get8u(s);\t//\timage type\n\tif( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;\t//\tonly RGB or grey allowed, +/- RLE\n\tget16(s);\t\t//\tdiscard palette start\n\tget16(s);\t\t//\tdiscard palette length\n\tget8(s);\t\t\t//\tdiscard bits per palette color entry\n\tget16(s);\t\t//\tdiscard x origin\n\tget16(s);\t\t//\tdiscard y origin\n\tif( get16(s) < 1 ) return 0;\t\t//\ttest width\n\tif( get16(s) < 1 ) return 0;\t\t//\ttest height\n\tsz = get8(s);\t//\tbits per pixel\n\tif( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;\t//\tonly RGB or RGBA or grey allowed\n\treturn 1;\t\t//\tseems to have passed everything\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\n", "func_signal": "static uint8 get_marker(jpeg *j)", "code": "{\n   uint8 x;\n   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }\n   x = get8u(&j->s);\n   if (x != 0xff) return MARKER_none;\n   while (x == 0xff)\n      x = get8u(&j->s);\n   return x;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/**\n * get unicode from a ut8 string and advance character pointer\n *\n * @param text pointer to pointer to utf8\n * @return     unicode\n */\n", "func_signal": "inline static unsigned int getNextUnicodeFromUTF8( unsigned char **text )", "code": "{\n  unsigned int result = 0;\n\n  // NULL pointer\n  if ( text == NULL ) {\n    return result;\n  }\n\n  else if ( *text[ 0 ] < 0x80 ) {\n    // U+0000\u2192U+007F    0xxxxxxx\n    result = *(*text)++;\n  }\n  else if ( *text[ 0 ] < 0xE0 ) {\n    // U+0080\u2192U+07FF    110xxxxx 10xxxxxx\n    result  = ( ( *( *text )++ & 0x1f ) << 6 );\n    result |= ( ( *( *text )++ & 0x3f ) );\n  }\n  else if ( *text[ 0 ] < 0xF0 ) {\n    // U+0080\u2192U+07FF    110xxxxx 10xxxxxx\n    result  = ( ( *( *text )++ & 0x0f ) << 12 );\n    result |= ( ( *( *text )++ & 0x3f ) << 6 );\n    result |=     *( *text )++ & 0x3f;\n  }\n  else {\n  // U+10000\u2192U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n    result  = ( ( *( *text )++ & 0x0f ) << 18 );\n    result |= ( ( *( *text )++ & 0x3f ) << 12 );\n    result |= ( ( *( *text )++ & 0x3f ) << 6 );\n    result |=     *( *text )++ & 0x3f;\n  }\n\n  return result;\n}", "path": "PAL\\Linux\\src\\PALFont.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicholas Schulz, tweaked by STB\n", "func_signal": "static int psd_test(stbi *s)", "code": "{\n\tif (get32(s) != 0x38425053) return 0;\t// \"8BPS\"\n\telse return 1;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/**\n * merge the two source outlines into one destination outline\n * destination must be preallocated the right size\n *\n * @param  aOutlineIn  outline to be reversed\n * @param  aOutlineOut reversed ouline\n * @return             none\n */\n", "func_signal": "static void ft_OutlineMerge( FT_Outline *Src1,\n                             FT_Outline *Src2,\n                             FT_Outline *Dest )", "code": "{\n   int i;\n\n   /* Copy Src1 points */\n   for ( i = 0; i < Src1->n_points; i++ ) {\n      Dest->points[ i ] = Src1->points[ i ];\n   }\n\n   /* Copy Src2 points */\n   for ( i = 0; i < Src2->n_points; i++ ) {\n      Dest->points[ Src1->n_points + i ] = Src2->points[ i ];\n   }\n\n   /* Copy Src1 tags */\n   for ( i = 0; i < Src1->n_points; i++ ) {\n      Dest->tags[ i ] = Src1->tags[ i ];\n   }\n\n   /* Copy Src2 tags */\n   for ( i = 0; i < Src2->n_points; i++ ) {\n      Dest->tags[ Src1->n_points + i ] = Src2->tags[ i ];\n   }\n\n   /* Copy Src1 contours */\n   for ( i = 0; i < Src1->n_contours; i++ ) {\n      Dest->contours[ i ] = Src1->contours[ i ];\n   }\n\n   /* Copy Src2 contours */\n   for ( i = 0; i < Src2->n_contours; i++ ) {\n      Dest->contours[ Src1->n_contours + i ] = Src1->n_points + Src2->contours[ i ];\n   }\n\n   Dest->n_contours = Src1->n_contours + Src2->n_contours;\n   Dest->n_points   = Src1->n_points   + Src2->n_points;\n}", "path": "PAL\\Linux\\src\\outline.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/* Exported Functions */\n", "func_signal": "int PalFont_Initialise( void **aContext )", "code": "{\n   ft_Context_t *ftContext;\n   int           err = 0;\n\n   assert( aContext != NULL );\n\n   ftContext = ( ft_Context_t * )malloc( sizeof( ft_Context_t ) );\n   if ( ftContext == NULL ) {\n      return -1;\n   }\n\n   memset( ftContext, 0, sizeof( ft_Context_t ) );\n\n   ftContext->m_tag = ( unsigned int )\"FREE\";\n   ftContext->m_library      = NULL;\n   ftContext->m_face         = NULL;\n   ftContext->m_fontColor    = DEFAULT_INTERIOR_COLOR;\n   ftContext->m_fontColorTwo = DEFAULT_EXTERIOR_COLOR;\n   ftContext->m_fontSize     = DEFAULT_SIZE;\n   ftContext->m_Synth        = SynthNone;\n\n   /* identity matrix */\n   ftContext->m_Matrix.xx    = ONE_POINT_ZERO;\n   ftContext->m_Matrix.yy    = ONE_POINT_ZERO;\n   ftContext->m_Matrix.xy    = 0;\n   ftContext->m_Matrix.yx    = 0;\n\n   ftContext->m_Alpha1       = DEFAULT_EXTERIOR_ALPHA;\n   ftContext->m_Alpha2       = DEFAULT_INTERIOR_ALPHA;\n\n   err = FT_Init_FreeType( &ftContext->m_library );\n   if ( err != 0 ) {\n      return err;\n   }\n\n   /* err = PalFont_Face_Set( ftContext, DEFAULT_FACE ); */\n   /* if ( err != 0 ) { */\n   /*    return err; */\n   /* } */\n\n   /* err = PalFont_Size_Set( ftContext, DEFAULT_SIZE ); */\n   /* if ( err != 0 ) { */\n   /*    return err; */\n   /* } */\n\n   *aContext = ftContext;\n\n   return 0;\n}", "path": "PAL\\Linux\\src\\PALFont.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is\n// defined, for API simplicity; if STBI_NO_HDR is defined, it always\n// reports false!\n", "func_signal": "int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)", "code": "{\n   #ifndef STBI_NO_HDR\n   return stbi_hdr_test_memory(buffer, len);\n   #else\n   return 0;\n   #endif\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// Microsoft/Windows BMP image\n", "func_signal": "static int bmp_test(stbi *s)", "code": "{\n   int sz;\n   if (get8(s) != 'B') return 0;\n   if (get8(s) != 'M') return 0;\n   get32le(s); // discard filesize\n   get16le(s); // discard reserved\n   get16le(s); // discard reserved\n   get32le(s); // discard data offset\n   sz = get32le(s);\n   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;\n   return 0;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// clean up the temporary component buffers\n", "func_signal": "static void cleanup_jpeg(jpeg *j)", "code": "{\n   int i;\n   for (i=0; i < j->s.img_n; ++i) {\n      if (j->img_comp[i].data) {\n         free(j->img_comp[i].raw_data);\n         j->img_comp[i].data = NULL;\n      }\n      if (j->img_comp[i].linebuf) {\n         free(j->img_comp[i].linebuf);\n         j->img_comp[i].linebuf = NULL;\n      }\n   }\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// after a restart interval, reset the entropy decoder and\n// the dc prediction\n", "func_signal": "static void reset(jpeg *j)", "code": "{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;\n   j->marker = MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/**\n * type check and return freetype context\n *\n * @param aContext void context\n * @return         freetype context\n */\n", "func_signal": "inline static ft_Context_t *FT_CONTEXT( void *aContext )", "code": "{\n   ft_Context_t *ftContext = ( ft_Context_t * )aContext;\n   assert( ftContext != NULL );\n   assert( ftContext->m_tag == ( unsigned int )\"FREE\" );\n   return ftContext;\n}", "path": "PAL\\Linux\\src\\PALFont.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/**\n * takes a utf16 string and runs Harfbuzz to create a list of glyphs\n *\n * @param aContext     void context\n * @param aUtf16String the utf16 string\n * @param aHarfBuzz    structure containing Harfbuzz stuff\n * @return             error\n */\n", "func_signal": "static int Utf16_To_Harfbuzz( void       *aContext,\n                              uint16_t   *aUtf16String,\n                              int         nChars,\n                              HarfBuzz_t *aHarfBuzz )", "code": "{\n   ft_Context_t *ftContext = FT_CONTEXT( aContext );\n   HB_FontRec    hbFont;\n   HB_Face       hbFace = NULL;\n   HB_ShaperItem hbShaperItem;\n\n   memset( aHarfBuzz->str,             0, sizeof( aHarfBuzz->str ) );\n   memset( aHarfBuzz->out_glyphs,      0, sizeof( aHarfBuzz->out_glyphs ) );\n   memset( aHarfBuzz->out_attrs,       0, sizeof( aHarfBuzz->out_attrs ) );\n   memset( aHarfBuzz->out_advs,        0, sizeof( aHarfBuzz->out_advs ) );\n   memset( aHarfBuzz->out_offsets,     0, sizeof( aHarfBuzz->out_offsets ) );\n   memset( aHarfBuzz->out_logClusters, 0, sizeof( aHarfBuzz->out_logClusters ) );\n\n   memset( &hbFont,                    0, sizeof( HB_FontRec ) );\n   memset( &hbFace,                    0, sizeof( HB_Face ) );\n\n   hbFace = HB_NewFace( ftContext->m_face, hb_freetype_table_sfnt_get );\n\n   memcpy( aHarfBuzz->str, aUtf16String, nChars * sizeof( uint16_t ) );\n\n   aHarfBuzz->n_Chars = nChars;\n\n   assert( ftContext->m_face != NULL );\n\n   hbFont.klass    = &hb_freetype_class;\n   hbFont.userData = ftContext->m_face;\n   hbFont.x_ppem   = ftContext->m_face->size->metrics.x_ppem;\n   hbFont.y_ppem   = ftContext->m_face->size->metrics.y_ppem;\n   hbFont.x_scale  = ftContext->m_face->size->metrics.x_scale;\n   hbFont.y_scale  = ftContext->m_face->size->metrics.y_scale;\n\n   memset( &hbShaperItem, 0, sizeof( HB_ShaperItem ) );\n\n   hbShaperItem.kerning_applied     = FALSE;\n   hbShaperItem.string              = ( HB_UChar16 * )aHarfBuzz->str;\n   hbShaperItem.stringLength        = nChars;\n   hbShaperItem.item.bidiLevel      = 0;\n   hbShaperItem.item.script         = HB_Script_Arabic;\n   hbShaperItem.item.pos            = 0;\n   hbShaperItem.item.length         = hbShaperItem.stringLength;\n   hbShaperItem.shaperFlags         = 0;\n   hbShaperItem.font                = &hbFont;\n   hbShaperItem.face                = hbFace;\n   hbShaperItem.glyphIndicesPresent = FALSE;\n   hbShaperItem.initialGlyphCount   = 0;\n   hbShaperItem.glyphs              = aHarfBuzz->out_glyphs;\n   hbShaperItem.attributes          = aHarfBuzz->out_attrs;\n   hbShaperItem.advances            = aHarfBuzz->out_advs;\n   hbShaperItem.offsets             = aHarfBuzz->out_offsets;\n   hbShaperItem.log_clusters        = aHarfBuzz->out_logClusters;\n   hbShaperItem.num_glyphs          = MAX_CHARS;\n\n   HB_ShapeItem( &hbShaperItem );\n   HB_FreeFace( hbFace );\n\n   return 0;\n}", "path": "PAL\\Linux\\src\\PALFont.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// returns 0..31 for the highest set bit\n", "func_signal": "static int high_bit(unsigned int z)", "code": "{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) n += 16, z >>= 16;\n   if (z >= 0x00100) n +=  8, z >>=  8;\n   if (z >= 0x00010) n +=  4, z >>=  4;\n   if (z >= 0x00004) n +=  2, z >>=  2;\n   if (z >= 0x00002) n +=  1, z >>=  1;\n   return n;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead\n", "func_signal": "static int parse_zlib(zbuf *a, int parse_header)", "code": "{\n   int final, type;\n   if (parse_header)\n      if (!parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   do {\n      final = zreceive(a,1);\n      type = zreceive(a,2);\n      if (type == 0) {\n         if (!parse_uncompressed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!default_distance[31]) init_defaults();\n            if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;\n            if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;\n         } else {\n            if (!compute_huffman_codes(a)) return 0;\n         }\n         if (!parse_huffman_block(a)) return 0;\n      }\n      if (stbi_png_partial && a->zout - a->zout_start > 65536)\n         break;\n   } while (!final);\n   return 1;\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "// .344 seconds on 3*anemones.jpg\n", "func_signal": "static void idct_block(uint8 *out, int out_stride, short data[64], uint8 *dequantize)", "code": "{\n   int i,val[64],*v=val;\n   uint8 *o,*dq = dequantize;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d,++dq, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0] * dq[0] << 2;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],\n                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      x0 += 65536; x1 += 65536; x2 += 65536; x3 += 65536;\n      o[0] = clamp((x0+t3) >> 17);\n      o[7] = clamp((x0-t3) >> 17);\n      o[1] = clamp((x1+t2) >> 17);\n      o[6] = clamp((x1-t2) >> 17);\n      o[2] = clamp((x2+t1) >> 17);\n      o[5] = clamp((x2-t1) >> 17);\n      o[3] = clamp((x3+t0) >> 17);\n      o[4] = clamp((x3-t0) >> 17);\n   }\n}", "path": "PAL\\src\\stb_image.c", "repo_name": "wayfinder/Wayfinder-CppCore-v3", "stars": 10, "license": "bsd-3-clause", "language": "c", "size": 1302}
{"docstring": "/*!\n * Free a node and all of its resources.\n *\n * \\param node Lib3dsNode object to be freed.\n *\n * \\ingroup node\n */\n", "func_signal": "void\nlib3ds_node_free(Lib3dsNode *node)", "code": "{\n  ASSERT(node);\n  free_node_and_childs(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * \\ingroup node\n */\n", "func_signal": "Lib3dsBool\nlib3ds_node_write(Lib3dsNode *node, Lib3dsFile *file, Lib3dsIo *io)", "code": "{\n  Lib3dsChunk c;\n\n  switch (node->type) {\n    case LIB3DS_AMBIENT_NODE:\n      c.chunk=LIB3DS_AMBIENT_NODE_TAG;\n      break;\n    case LIB3DS_OBJECT_NODE:\n      c.chunk=LIB3DS_OBJECT_NODE_TAG;\n      break;\n    case LIB3DS_CAMERA_NODE:\n      c.chunk=LIB3DS_CAMERA_NODE_TAG;\n      break;\n    case LIB3DS_TARGET_NODE:\n      c.chunk=LIB3DS_TARGET_NODE_TAG;\n      break;\n    case LIB3DS_LIGHT_NODE:\n      if (lib3ds_file_node_by_name(file, node->name, LIB3DS_SPOT_NODE)) {\n        c.chunk=LIB3DS_SPOTLIGHT_NODE_TAG;\n      }\n      else {\n        c.chunk=LIB3DS_LIGHT_NODE_TAG;\n      }\n      break;\n    case LIB3DS_SPOT_NODE:\n      c.chunk=LIB3DS_L_TARGET_NODE_TAG;\n      break;\n    default:\n      return(LIB3DS_FALSE);\n  }\n  if (!lib3ds_chunk_write_start(&c,io)) {\n    return(LIB3DS_FALSE);\n  }\n\n  { /*---- LIB3DS_NODE_ID ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_NODE_ID;\n    c.size=8;\n    lib3ds_chunk_write(&c,io);\n    lib3ds_io_write_intw(io, node->node_id);\n  }\n\n  { /*---- LIB3DS_NODE_HDR ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_NODE_HDR;\n    c.size=6+ 1+(Lib3dsDword)strlen(node->name) +2+2+2;\n    lib3ds_chunk_write(&c,io);\n    lib3ds_io_write_string(io, node->name);\n    lib3ds_io_write_word(io, node->flags1);\n    lib3ds_io_write_word(io, node->flags2);\n    lib3ds_io_write_word(io, node->parent_id);\n  }\n\n  switch (c.chunk) {\n    case LIB3DS_AMBIENT_NODE_TAG:\n      { /*---- LIB3DS_COL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_COL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.ambient.col_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_OBJECT_NODE_TAG:\n      { /*---- LIB3DS_PIVOT ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_PIVOT;\n        c.size=18;\n        lib3ds_chunk_write(&c,io);\n        lib3ds_io_write_vector(io, node->data.object.pivot);\n      }\n      { /*---- LIB3DS_INSTANCE_NAME ----*/\n        Lib3dsChunk c;\n        const char *name;\n        if (strlen(node->data.object.instance)) {\n          name=node->data.object.instance;\n\n          c.chunk=LIB3DS_INSTANCE_NAME;\n          c.size=6+1+(Lib3dsDword)strlen(name);\n          lib3ds_chunk_write(&c,io);\n          lib3ds_io_write_string(io, name);\n        }\n      }\n      {\n        int i;\n        for (i=0; i<3; ++i) {\n          if ((fabs(node->data.object.bbox_min[i])>LIB3DS_EPSILON) ||\n            (fabs(node->data.object.bbox_max[i])>LIB3DS_EPSILON)) {\n            break;\n          }\n        }\n        \n        if (i<3) { /*---- LIB3DS_BOUNDBOX ----*/\n          Lib3dsChunk c;\n          c.chunk=LIB3DS_BOUNDBOX;\n          c.size=30;\n          lib3ds_chunk_write(&c,io);\n          lib3ds_io_write_vector(io, node->data.object.bbox_min);\n          lib3ds_io_write_vector(io, node->data.object.bbox_max);\n        }\n      }\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.object.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_ROT_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_ROT_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_quat_track_write(&node->data.object.rot_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_SCL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_SCL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.object.scl_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      if (node->data.object.hide_track.keyL) { /*---- LIB3DS_HIDE_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_HIDE_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_bool_track_write(&node->data.object.hide_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      if (fabs(node->data.object.morph_smooth)>LIB3DS_EPSILON){ /*---- LIB3DS_MORPH_SMOOTH ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_MORPH_SMOOTH;\n        c.size=10;\n        lib3ds_chunk_write(&c,io);\n        lib3ds_io_write_float(io, node->data.object.morph_smooth);\n      }\n      break;\n    case LIB3DS_CAMERA_NODE_TAG:\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.camera.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_FOV_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_FOV_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin1_track_write(&node->data.camera.fov_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_ROLL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_ROLL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin1_track_write(&node->data.camera.roll_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_TARGET_NODE_TAG:\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.target.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_LIGHT_NODE_TAG:\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.light.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_COL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_COL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.light.col_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_SPOTLIGHT_NODE_TAG:\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.light.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_COL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_COL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.light.col_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_HOT_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_HOT_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin1_track_write(&node->data.light.hotspot_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_FALL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_FALL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin1_track_write(&node->data.light.falloff_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      { /*---- LIB3DS_ROLL_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_ROLL_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin1_track_write(&node->data.light.roll_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_L_TARGET_NODE_TAG:\n      { /*---- LIB3DS_POS_TRACK_TAG ----*/\n        Lib3dsChunk c;\n        c.chunk=LIB3DS_POS_TRACK_TAG;\n        if (!lib3ds_chunk_write_start(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_lin3_track_write(&node->data.spot.pos_track,io)) {\n          return(LIB3DS_FALSE);\n        }\n        if (!lib3ds_chunk_write_end(&c,io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    default:\n      return(LIB3DS_FALSE);\n  }\n\n  if (!lib3ds_chunk_write_end(&c,io)) {\n    return(LIB3DS_FALSE);\n  }\n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Return a node object by id.\n *\n * This function performs a recursive search for the specified node.\n *\n * \\param node The parent node for the search\n * \\param node_id The target node id.\n *\n * \\return A pointer to the first matching node, or NULL if not found.\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_by_id(Lib3dsNode *node, Lib3dsWord node_id)", "code": "{\n  Lib3dsNode *p,*q;\n\n  for (p=node->childs; p!=0; p=p->next) {\n    if (p->node_id==node_id) {\n      return(p);\n    }\n    q=lib3ds_node_by_id(p, node_id);\n    if (q) {\n      return(q);\n    }\n  }\n  return(0);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Read a camera definition from a file.\n *\n * This function is called by lib3ds_file_read(), and you probably\n * don't want to call it directly.\n *\n * \\param camera A Lib3dsCamera to be filled in.\n * \\param io A Lib3dsIo object previously set up by the caller.\n *\n * \\return LIB3DS_TRUE on success, LIB3DS_FALSE on failure.\n *\n * \\see lib3ds_file_read\n *\n * \\ingroup camera\n */\n", "func_signal": "Lib3dsBool\nlib3ds_camera_read(Lib3dsCamera *camera, Lib3dsIo *io)", "code": "{\n  Lib3dsChunk c;\n  Lib3dsWord chunk;\n\n  if (!lib3ds_chunk_read_start(&c, LIB3DS_N_CAMERA, io)) {\n    return(LIB3DS_FALSE);\n  }\n  {\n    int i;\n    for (i=0; i<3; ++i) {\n      camera->position[i]=lib3ds_io_read_float(io);\n    }\n    for (i=0; i<3; ++i) {\n      camera->target[i]=lib3ds_io_read_float(io);\n    }\n  }\n  camera->roll=lib3ds_io_read_float(io);\n  {\n    float s;\n    s=lib3ds_io_read_float(io);\n    if (fabs(s)<LIB3DS_EPSILON) {\n      camera->fov=45.0;\n    }\n    else {\n      camera->fov=2400.0f/s;\n    }\n  }\n  lib3ds_chunk_read_tell(&c, io);\n  \n  while ((chunk=lib3ds_chunk_read_next(&c, io))!=0) {\n    switch (chunk) {\n      case LIB3DS_CAM_SEE_CONE:\n        {\n          camera->see_cone=LIB3DS_TRUE;\n        }\n        break;\n      case LIB3DS_CAM_RANGES:\n        {\n          camera->near_range=lib3ds_io_read_float(io);\n          camera->far_range=lib3ds_io_read_float(io);\n        }\n        break;\n      default:\n        lib3ds_chunk_unknown(chunk);\n    }\n  }\n  \n  lib3ds_chunk_read_end(&c, io);\n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\camera.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * \\ingroup node\n */\n", "func_signal": "Lib3dsBool\nlib3ds_node_read(Lib3dsNode *node, Lib3dsFile *file, Lib3dsIo *io)", "code": "{\n  Lib3dsChunk c;\n  Lib3dsWord chunk;\n\n  ASSERT(node);\n  if (!lib3ds_chunk_read_start(&c, 0, io)) {\n    return(LIB3DS_FALSE);\n  }\n  switch (c.chunk) {\n    case LIB3DS_AMBIENT_NODE_TAG:\n    case LIB3DS_OBJECT_NODE_TAG:\n    case LIB3DS_CAMERA_NODE_TAG:\n    case LIB3DS_TARGET_NODE_TAG:\n    case LIB3DS_LIGHT_NODE_TAG:\n    case LIB3DS_SPOTLIGHT_NODE_TAG:\n    case LIB3DS_L_TARGET_NODE_TAG:\n      break;\n    default:\n      return(LIB3DS_FALSE);\n  }\n\n  while ((chunk=lib3ds_chunk_read_next(&c, io))!=0) {\n    switch (chunk) {\n      case LIB3DS_NODE_ID:\n        {\n          node->node_id=lib3ds_io_read_word(io);\n          lib3ds_chunk_dump_info(\"  ID = %d\", (short)node->node_id);\n        }\n        break;\n      case LIB3DS_NODE_HDR:\n        {\n          if (!lib3ds_io_read_string(io, node->name, 64)) {\n            return(LIB3DS_FALSE);\n          }\n          node->flags1=lib3ds_io_read_word(io);\n          node->flags2=lib3ds_io_read_word(io);\n          node->parent_id=lib3ds_io_read_word(io);\n          lib3ds_chunk_dump_info(\"  NAME =%s\", node->name);\n          lib3ds_chunk_dump_info(\"  PARENT=%d\", (short)node->parent_id);\n        }\n        break;\n      case LIB3DS_PIVOT:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            int i;\n            for (i=0; i<3; ++i) {\n              node->data.object.pivot[i]=lib3ds_io_read_float(io);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_INSTANCE_NAME:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            if (!lib3ds_io_read_string(io, node->data.object.instance, 64)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_BOUNDBOX:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            int i;\n            for (i=0; i<3; ++i) {\n              node->data.object.bbox_min[i]=lib3ds_io_read_float(io);\n            }\n            for (i=0; i<3; ++i) {\n              node->data.object.bbox_max[i]=lib3ds_io_read_float(io);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_COL_TRACK_TAG:\n        {\n          Lib3dsBool result=LIB3DS_TRUE;\n          \n          switch (node->type) {\n            case LIB3DS_AMBIENT_NODE:\n              result=lib3ds_lin3_track_read(&node->data.ambient.col_track, io);\n              break;\n            case LIB3DS_LIGHT_NODE:\n              result=lib3ds_lin3_track_read(&node->data.light.col_track, io);\n              break;\n            default:\n              lib3ds_chunk_unknown(chunk);\n          }\n          if (!result) {\n            return(LIB3DS_FALSE);\n          }\n        }\n        break;\n      case LIB3DS_POS_TRACK_TAG:\n        {\n          Lib3dsBool result=LIB3DS_TRUE;\n\n          switch (node->type) {\n            case LIB3DS_OBJECT_NODE:\n              result=lib3ds_lin3_track_read(&node->data.object.pos_track, io);\n              break;\n            case LIB3DS_CAMERA_NODE:\n              result=lib3ds_lin3_track_read(&node->data.camera.pos_track, io);\n              break;\n            case LIB3DS_TARGET_NODE:\n              result=lib3ds_lin3_track_read(&node->data.target.pos_track, io);\n              break;\n            case LIB3DS_LIGHT_NODE:\n              result=lib3ds_lin3_track_read(&node->data.light.pos_track, io);\n              break;\n            case LIB3DS_SPOT_NODE:\n              result=lib3ds_lin3_track_read(&node->data.spot.pos_track, io);\n              break;\n            default:\n              lib3ds_chunk_unknown(chunk);\n          }\n          if (!result) {\n            return(LIB3DS_FALSE);\n          }\n        }\n        break;\n      case LIB3DS_ROT_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            if (!lib3ds_quat_track_read(&node->data.object.rot_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_SCL_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            if (!lib3ds_lin3_track_read(&node->data.object.scl_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_FOV_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_CAMERA_NODE) {\n            if (!lib3ds_lin1_track_read(&node->data.camera.fov_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_HOT_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_LIGHT_NODE) {\n            if (!lib3ds_lin1_track_read(&node->data.light.hotspot_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_FALL_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_LIGHT_NODE) {\n            if (!lib3ds_lin1_track_read(&node->data.light.falloff_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_ROLL_TRACK_TAG:\n        {\n          Lib3dsBool result=LIB3DS_TRUE;\n\n          switch (node->type) {\n            case LIB3DS_CAMERA_NODE:\n              result=lib3ds_lin1_track_read(&node->data.camera.roll_track, io);\n              break;\n            case LIB3DS_LIGHT_NODE:\n              result=lib3ds_lin1_track_read(&node->data.light.roll_track, io);\n              break;\n            default:\n              lib3ds_chunk_unknown(chunk);\n          }\n          if (!result) {\n            return(LIB3DS_FALSE);\n          }\n        }\n        break;\n      case LIB3DS_HIDE_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            if (!lib3ds_bool_track_read(&node->data.object.hide_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_MORPH_SMOOTH:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            node->data.object.morph_smooth=lib3ds_io_read_float(io);\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      case LIB3DS_MORPH_TRACK_TAG:\n        {\n          if (node->type==LIB3DS_OBJECT_NODE) {\n            if (!lib3ds_morph_track_read(&node->data.object.morph_track, io)) {\n              return(LIB3DS_FALSE);\n            }\n          }\n          else {\n            lib3ds_chunk_unknown(chunk);\n          }\n        }\n        break;\n      default:\n        lib3ds_chunk_unknown(chunk);\n    }\n  }\n\n  lib3ds_chunk_read_end(&c, io);\n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Return a new Lib3dsCamera object.\n *\n * Object is initialized with the given name and fov=45.  All other\n * values are 0.\n *\n * \\param name Name of this camera.  Must not be NULL.  Must be < 64 characters.\n *\n * \\return Lib3dsCamera object or NULL on failure.\n *\n * \\ingroup camera\n */\n", "func_signal": "Lib3dsCamera*\nlib3ds_camera_new(const char *name)", "code": "{\n  Lib3dsCamera *camera;\n\n  ASSERT(name);\n  ASSERT(strlen(name)<64);\n  \n  camera=(Lib3dsCamera*)calloc(sizeof(Lib3dsCamera), 1);\n  if (!camera) {\n    return(0);\n  }\n  strcpy(camera->name, name);\n  camera->fov=45.0f;\n  return(camera);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\camera.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new light node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_light()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_LIGHT_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new ambient node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_ambient()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_AMBIENT_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Free a Lib3dsCamera object and all of its resources.\n *\n * \\param camera Lib3dsCamera object to be freed.\n *\n * \\ingroup camera \n */\n", "func_signal": "void\nlib3ds_camera_free(Lib3dsCamera *camera)", "code": "{\n  memset(camera, 0, sizeof(Lib3dsCamera));\n  free(camera);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\camera.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * \\ingroup background\n */\n", "func_signal": "Lib3dsBool\nlib3ds_background_write(Lib3dsBackground *background, Lib3dsIo *io)", "code": "{\n  if (strlen(background->bitmap.name)) { /*---- LIB3DS_BIT_MAP ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_BIT_MAP;\n    c.size=6+1+(Lib3dsDword)strlen(background->bitmap.name);\n    lib3ds_chunk_write(&c,io);\n    lib3ds_io_write_string(io, background->bitmap.name);\n  }\n\n  if (colorf_defined(background->solid.col)) { /*---- LIB3DS_SOLID_BGND ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_SOLID_BGND;\n    c.size=42;\n    lib3ds_chunk_write(&c,io);\n    colorf_write(background->solid.col, io);\n  }\n\n  if (colorf_defined(background->gradient.top) ||\n    colorf_defined(background->gradient.middle) ||\n    colorf_defined(background->gradient.bottom)) { /*---- LIB3DS_V_GRADIENT ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_V_GRADIENT;\n    c.size=118;\n    lib3ds_chunk_write(&c,io);\n    lib3ds_io_write_float(io, background->gradient.percent);\n    colorf_write(background->gradient.top,io);\n    colorf_write(background->gradient.middle,io);\n    colorf_write(background->gradient.bottom,io);\n  }\n\n  if (background->bitmap.use) { /*---- LIB3DS_USE_BIT_MAP ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_USE_BIT_MAP;\n    c.size=6;\n    lib3ds_chunk_write(&c,io);\n  }\n\n  if (background->solid.use) { /*---- LIB3DS_USE_SOLID_BGND ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_USE_SOLID_BGND;\n    c.size=6;\n    lib3ds_chunk_write(&c,io);\n  }\n\n  if (background->gradient.use) { /*---- LIB3DS_USE_V_GRADIENT ----*/\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_USE_V_GRADIENT;\n    c.size=6;\n    lib3ds_chunk_write(&c,io);\n  }\n  \n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\background.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new spot node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_spot()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_SPOT_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Dump node and all descendants recursively.\n *\n * \\param node The top-level node to be dumped.\n * \\param level current recursion depth\n *\n * \\ingroup node\n */\n", "func_signal": "void\nlib3ds_node_dump(Lib3dsNode *node, Lib3dsIntd level)", "code": "{\n  Lib3dsNode *p;\n  char l[128];\n\n  ASSERT(node);\n  memset(l, ' ', 2*level);\n  l[2*level]=0;\n\n  if (node->type==LIB3DS_OBJECT_NODE) {\n    printf(\"%s%s [%s] (%s)\\n\",\n      l,\n      node->name,\n      node->data.object.instance,\n      node_names_table[node->type]\n    );\n  }\n  else {\n    printf(\"%s%s (%s)\\n\",\n      l,\n      node->name,\n      node_names_table[node->type]\n    );\n  }\n  \n  for (p=node->childs; p!=0; p=p->next) {\n    lib3ds_node_dump(p, level+1);\n  }\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Evaluate an animation node.\n *\n * Recursively sets node and its children to their appropriate values\n * for this point in the animation.\n *\n * \\param node Node to be evaluated.\n * \\param t time value, between 0. and file->frames\n *\n * \\ingroup node\n */\n", "func_signal": "void\nlib3ds_node_eval(Lib3dsNode *node, Lib3dsFloat t)", "code": "{\n  ASSERT(node);\n  switch (node->type) {\n    case LIB3DS_UNKNOWN_NODE:\n      {\n        ASSERT(LIB3DS_FALSE);\n      }\n      break;\n    case LIB3DS_AMBIENT_NODE:\n      {\n        Lib3dsAmbientData *n=&node->data.ambient;\n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n        }\n        else {\n          lib3ds_matrix_identity(node->matrix);\n        }\n        lib3ds_lin3_track_eval(&n->col_track, n->col, t);\n      }\n      break;\n    case LIB3DS_OBJECT_NODE:\n      {\n        Lib3dsMatrix M;\n        Lib3dsObjectData *n=&node->data.object;\n\n        lib3ds_lin3_track_eval(&n->pos_track, n->pos, t);\n        lib3ds_quat_track_eval(&n->rot_track, n->rot, t);\n        if (n->scl_track.keyL) {\n          lib3ds_lin3_track_eval(&n->scl_track, n->scl, t);\n        }\n        else {\n          n->scl[0] = n->scl[1] = n->scl[2] = 1.0f;\n        }\n        lib3ds_bool_track_eval(&n->hide_track, &n->hide, t);\n        lib3ds_morph_track_eval(&n->morph_track, n->morph, t);\n\n        lib3ds_matrix_identity(M);\n        lib3ds_matrix_translate(M, n->pos);\n        lib3ds_matrix_rotate(M, n->rot);\n        lib3ds_matrix_scale(M, n->scl);\n        \n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n          lib3ds_matrix_mult(node->matrix, M);\n        }\n        else {\n          lib3ds_matrix_copy(node->matrix, M);\n        }\n      }\n      break;\n    case LIB3DS_CAMERA_NODE:\n      {\n        Lib3dsCameraData *n=&node->data.camera;\n        lib3ds_lin3_track_eval(&n->pos_track, n->pos, t);\n        lib3ds_lin1_track_eval(&n->fov_track, &n->fov, t);\n        lib3ds_lin1_track_eval(&n->roll_track, &n->roll, t);\n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n        }\n        else {\n          lib3ds_matrix_identity(node->matrix);\n        }\n        lib3ds_matrix_translate(node->matrix, n->pos);\n      }\n      break;\n    case LIB3DS_TARGET_NODE:\n      {\n        Lib3dsTargetData *n=&node->data.target;\n        lib3ds_lin3_track_eval(&n->pos_track, n->pos, t);\n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n        }\n        else {\n          lib3ds_matrix_identity(node->matrix);\n        }\n        lib3ds_matrix_translate(node->matrix, n->pos);\n      }\n      break;\n    case LIB3DS_LIGHT_NODE:\n      {\n        Lib3dsLightData *n=&node->data.light;\n        lib3ds_lin3_track_eval(&n->pos_track, n->pos, t);\n        lib3ds_lin3_track_eval(&n->col_track, n->col, t);\n        lib3ds_lin1_track_eval(&n->hotspot_track, &n->hotspot, t);\n        lib3ds_lin1_track_eval(&n->falloff_track, &n->falloff, t);\n        lib3ds_lin1_track_eval(&n->roll_track, &n->roll, t);\n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n        }\n        else {\n          lib3ds_matrix_identity(node->matrix);\n        }\n        lib3ds_matrix_translate(node->matrix, n->pos);\n      }\n      break;\n    case LIB3DS_SPOT_NODE:\n      {\n        Lib3dsSpotData *n=&node->data.spot;\n        lib3ds_lin3_track_eval(&n->pos_track, n->pos, t);\n        if (node->parent) {\n          lib3ds_matrix_copy(node->matrix, node->parent->matrix);\n        }\n        else {\n          lib3ds_matrix_identity(node->matrix);\n        }\n        lib3ds_matrix_translate(node->matrix, n->pos);\n      }\n      break;\n  }\n  {\n    Lib3dsNode *p;\n\n    for (p=node->childs; p!=0; p=p->next) {\n      lib3ds_node_eval(p, t);\n    }\n  }\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new camera node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_camera()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_CAMERA_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Return a node object by name and type.\n *\n * This function performs a recursive search for the specified node.\n * Both name and type must match.\n *\n * \\param node The parent node for the search\n * \\param name The target node name.\n * \\param type The target node type\n *\n * \\return A pointer to the first matching node, or NULL if not found.\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_by_name(Lib3dsNode *node, const char* name, Lib3dsNodeTypes type)", "code": "{\n  Lib3dsNode *p,*q;\n\n  for (p=node->childs; p!=0; p=p->next) {\n    if ((p->type==type) && (strcmp(p->name, name)==0)) {\n      return(p);\n    }\n    q=lib3ds_node_by_name(p, name, type);\n    if (q) {\n      return(q);\n    }\n  }\n  return(0);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Dump information about a Lib3dsCamera object to stdout.\n *\n * \\param camera Object to be dumped.\n *\n * \\see lib3ds_file_dump_cameras\n *\n * \\ingroup camera\n */\n", "func_signal": "void\nlib3ds_camera_dump(Lib3dsCamera *camera)", "code": "{\n  ASSERT(camera);\n  printf(\"  name:       %s\\n\", camera->name);\n  printf(\"  position:   (%f, %f, %f)\\n\", \n    camera->position[0], camera->position[1], camera->position[2]);\n  printf(\"  target      (%f, %f, %f)\\n\", \n    camera->target[0], camera->target[1], camera->target[2]);\n  printf(\"  roll:       %f\\n\", camera->roll);\n  printf(\"  fov:        %f\\n\", camera->fov);\n  printf(\"  see_cone:   %s\\n\", camera->see_cone ? \"yes\" : \"no\");\n  printf(\"  near_range: %f\\n\", camera->near_range);\n  printf(\"  far_range:  %f\\n\", camera->far_range);\n  printf(\"\\n\");\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\camera.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Write a camera definition to a file.\n *\n * This function is called by lib3ds_file_write(), and you probably\n * don't want to call it directly.\n *\n * \\param camera A Lib3dsCamera to be written.\n * \\param io A Lib3dsIo object previously set up by the caller.\n *\n * \\return LIB3DS_TRUE on success, LIB3DS_FALSE on failure.\n *\n * \\see lib3ds_file_write\n *\n * \\ingroup camera\n */\n", "func_signal": "Lib3dsBool\nlib3ds_camera_write(Lib3dsCamera *camera, Lib3dsIo *io)", "code": "{\n  Lib3dsChunk c;\n\n  c.chunk=LIB3DS_N_CAMERA;\n  if (!lib3ds_chunk_write_start(&c,io)) {\n    return(LIB3DS_FALSE);\n  }\n\n  lib3ds_io_write_vector(io, camera->position);\n  lib3ds_io_write_vector(io, camera->target);\n  lib3ds_io_write_float(io, camera->roll);\n  if (fabs(camera->fov)<LIB3DS_EPSILON) {\n    lib3ds_io_write_float(io, 2400.0f/45.0f);\n  }\n  else {\n    lib3ds_io_write_float(io, 2400.0f/camera->fov);\n  }\n\n  if (camera->see_cone) {\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_CAM_SEE_CONE;\n    c.size=6;\n    lib3ds_chunk_write(&c, io);\n  }\n  {\n    Lib3dsChunk c;\n    c.chunk=LIB3DS_CAM_RANGES;\n    c.size=14;\n    lib3ds_chunk_write(&c, io);\n    lib3ds_io_write_float(io, camera->near_range);\n    lib3ds_io_write_float(io, camera->far_range);\n  }\n\n  if (!lib3ds_chunk_write_end(&c,io)) {\n    return(LIB3DS_FALSE);\n  }\n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\camera.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * \\ingroup background\n */\n", "func_signal": "Lib3dsBool\nlib3ds_background_read(Lib3dsBackground *background, Lib3dsIo *io)", "code": "{\n  Lib3dsChunk c;\n\n  if (!lib3ds_chunk_read(&c, io)) {\n    return(LIB3DS_FALSE);\n  }\n  \n  switch (c.chunk) {\n    case LIB3DS_BIT_MAP:\n      {\n        if (!lib3ds_io_read_string(io, background->bitmap.name, 64)) {\n            return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_SOLID_BGND:\n      {\n        lib3ds_chunk_read_reset(&c, io);\n        if (!solid_bgnd_read(background, io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_V_GRADIENT:\n      {\n        lib3ds_chunk_read_reset(&c, io);\n        if (!v_gradient_read(background, io)) {\n          return(LIB3DS_FALSE);\n        }\n      }\n      break;\n    case LIB3DS_USE_BIT_MAP:\n      {\n        background->bitmap.use=LIB3DS_TRUE;\n      }\n      break;\n    case LIB3DS_USE_SOLID_BGND:\n      {\n        background->solid.use=LIB3DS_TRUE;\n      }\n      break;\n    case LIB3DS_USE_V_GRADIENT:\n      {\n        background->gradient.use=LIB3DS_TRUE;\n      }\n      break;\n  }\n  \n  return(LIB3DS_TRUE);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\background.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new target node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_target()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_TARGET_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/*!\n * Create and return a new object node.\n *\n * The node is returned with an identity matrix.  All other fields\n * are zero.\n *\n * \\return Lib3dsNode\n *\n * \\ingroup node\n */\n", "func_signal": "Lib3dsNode*\nlib3ds_node_new_object()", "code": "{\n  Lib3dsNode *node=(Lib3dsNode*)calloc(sizeof(Lib3dsNode), 1);\n  node->type=LIB3DS_OBJECT_NODE;\n  lib3ds_matrix_identity(node->matrix);\n  return(node);\n}", "path": "Other\\lib3ds\\lib3ds-1.3.0\\lib3ds\\node.c", "repo_name": "jjoonathan/objc3d", "stars": 8, "license": "None", "language": "c", "size": 19236}
{"docstring": "/* Byteswap each halfword.  */\n", "func_signal": "static void gen_rev16(TCGv var)", "code": "{\n    TCGv tmp = new_tmp();\n    tcg_gen_shri_i32(tmp, var, 8);\n    tcg_gen_andi_i32(tmp, tmp, 0x00ff00ff);\n    tcg_gen_shli_i32(var, var, 8);\n    tcg_gen_andi_i32(var, var, 0xff00ff00);\n    tcg_gen_or_i32(var, var, tmp);\n    dead_tmp(tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Round the top 32 bits of a 64-bit value.  */\n", "func_signal": "static void gen_roundqd(TCGv a, TCGv b)", "code": "{\n    tcg_gen_shri_i32(a, a, 31);\n    tcg_gen_add_i32(a, a, b);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* FIXME: Most targets have native widening multiplication.\n   It would be good to use that instead of a full wide multiply.  */\n/* 32x32->64 multiply.  Marks inputs as dead.  */\n", "func_signal": "static TCGv_i64 gen_mulu_i64_i32(TCGv a, TCGv b)", "code": "{\n    TCGv_i64 tmp1 = tcg_temp_new_i64();\n    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n    tcg_gen_extu_i32_i64(tmp1, a);\n    dead_tmp(a);\n    tcg_gen_extu_i32_i64(tmp2, b);\n    dead_tmp(b);\n    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n    return tmp1;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* dest = T0 - T1 + CF - 1.  */\n", "func_signal": "static void gen_sub_carry(TCGv dest, TCGv t0, TCGv t1)", "code": "{\n    tcg_gen_sub_i32(dest, t0, t1);\n    tcg_gen_add_i32(dest, dest, cpu_CF);\n    tcg_gen_subi_i32(dest, dest, 1);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Dual 16-bit add.  Result placed in t0 and t1 is marked as dead.\n    tmp = (t0 ^ t1) & 0x8000;\n    t0 &= ~0x8000;\n    t1 &= ~0x8000;\n    t0 = (t0 + t1) ^ tmp;\n */\n", "func_signal": "static void gen_add16(TCGv t0, TCGv t1)", "code": "{\n    TCGv tmp = new_tmp();\n    tcg_gen_xor_i32(tmp, t0, t1);\n    tcg_gen_andi_i32(tmp, tmp, 0x8000);\n    tcg_gen_andi_i32(t0, t0, ~0x8000);\n    tcg_gen_andi_i32(t1, t1, ~0x8000);\n    tcg_gen_add_i32(t0, t0, t1);\n    tcg_gen_xor_i32(t0, t0, tmp);\n    dead_tmp(tmp);\n    dead_tmp(t1);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Release a temporary variable.  */\n", "func_signal": "static void dead_tmp(TCGv tmp)", "code": "{\n    tcg_temp_free(tmp);\n    num_temps--;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Generate code for a Thumb-2 data processing operation.  If CONDS is nonzero\n   then set condition code flags based on the result of the operation.\n   If SHIFTER_OUT is nonzero then set the carry flag for logical operations\n   to the high bit of T1.\n   Returns zero if the opcode is valid.  */\n", "func_signal": "static int\ngen_thumb2_data_op(DisasContext *s, int op, int conds, uint32_t shifter_out, TCGv t0, TCGv t1)", "code": "{\n    int logic_cc;\n\n    logic_cc = 0;\n    switch (op) {\n    case 0: /* and */\n        tcg_gen_and_i32(t0, t0, t1);\n        logic_cc = conds;\n        break;\n    case 1: /* bic */\n        tcg_gen_bic_i32(t0, t0, t1);\n        logic_cc = conds;\n        break;\n    case 2: /* orr */\n        tcg_gen_or_i32(t0, t0, t1);\n        logic_cc = conds;\n        break;\n    case 3: /* orn */\n        tcg_gen_not_i32(t1, t1);\n        tcg_gen_or_i32(t0, t0, t1);\n        logic_cc = conds;\n        break;\n    case 4: /* eor */\n        tcg_gen_xor_i32(t0, t0, t1);\n        logic_cc = conds;\n        break;\n    case 8: /* add */\n        if (conds)\n            gen_helper_add_cc(t0, t0, t1);\n        else\n            tcg_gen_add_i32(t0, t0, t1);\n        break;\n    case 10: /* adc */\n        if (conds)\n            gen_helper_adc_cc(t0, t0, t1);\n        else\n            gen_add_carry(t0, t0, t1);\n        break;\n    case 11: /* sbc */\n        if (conds)\n            gen_helper_sbc_cc(t0, t0, t1);\n        else\n            gen_sub_carry(t0, t0, t1);\n        break;\n    case 13: /* sub */\n        if (conds)\n            gen_helper_sub_cc(t0, t0, t1);\n        else\n            tcg_gen_sub_i32(t0, t0, t1);\n        break;\n    case 14: /* rsb */\n        if (conds)\n            gen_helper_sub_cc(t0, t1, t0);\n        else\n            tcg_gen_sub_i32(t0, t1, t0);\n        break;\n    default: /* 5, 6, 7, 9, 12, 15. */\n        return 1;\n    }\n    if (logic_cc) {\n        gen_logic_CC(t0);\n        if (shifter_out)\n            gen_set_CF_bit31(t1);\n    }\n    return 0;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Bitwise select.  dest = c ? t : f.  Clobbers T and F.  */\n", "func_signal": "static void gen_neon_bsl(TCGv dest, TCGv t, TCGv f, TCGv c)", "code": "{\n    tcg_gen_and_i32(t, t, c);\n    tcg_gen_bic_i32(f, f, c);\n    tcg_gen_or_i32(dest, t, f);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Disassemble system coprocessor (cp15) instruction.  Return nonzero if\n   instruction is not defined.  */\n", "func_signal": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)", "code": "{\n    uint32_t rd;\n    TCGv tmp;\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n    if (arm_feature(env, ARM_FEATURE_M) ||\n        !arm_feature(env, ARM_FEATURE_CP15)) {\n\t    return 1;\n    }\n\n    if ((insn & (1 << 25)) == 0) {\n        if (insn & (1 << 20)) {\n            /* mrrc */\n            return 1;\n        }\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n        return 0;\n    }\n    if ((insn & (1 << 4)) == 0) {\n        /* cdp */\n        return 1;\n    }\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n        return 1;\n    }\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n        /* Wait for interrupt.  */\n        gen_set_pc_im(s->pc);\n        s->is_jmp = DISAS_WFI;\n        return 0;\n    }\n    rd = (insn >> 12) & 0xf;\n    if (insn & ARM_CP_RW_BIT) {\n        tmp = new_tmp();\n        gen_helper_get_cp15(tmp, cpu_env, tcg_const_i32(insn));\n        /* If the destination register is r15 then sets condition codes.  */\n        if (rd != 15)\n            store_reg(s, rd, tmp);\n        else\n            dead_tmp(tmp);\n    } else {\n        tmp = load_reg(s, rd);\n        gen_helper_set_cp15(cpu_env, tcg_const_i32(insn), tmp);\n        dead_tmp(tmp);\n        /* Normally we would always end the TB here, but Linux\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n                (insn & 0x0fff0fff) != 0x0e010f10)\n            gen_lookup_tb(s);\n    }\n    return 0;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Unsigned bitfield extract.  */\n", "func_signal": "static void gen_ubfx(TCGv var, int shift, uint32_t mask)", "code": "{\n    if (shift)\n        tcg_gen_shri_i32(var, var, shift);\n    tcg_gen_andi_i32(var, var, mask);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Returns nonzero if access to the PSR is not permitted.  */\n", "func_signal": "static int gen_set_psr_im(DisasContext *s, uint32_t mask, int spsr, uint32_t val)", "code": "{\n\tTCGv tmp;\n\ttmp = new_tmp();\n\ttcg_gen_movi_i32(tmp, val);\n\treturn gen_set_psr(s, mask, spsr, tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Byteswap low halfword and sign extend.  */\n", "func_signal": "static void gen_revsh(TCGv var)", "code": "{\n    TCGv tmp = new_tmp();\n    tcg_gen_shri_i32(tmp, var, 8);\n    tcg_gen_andi_i32(tmp, tmp, 0x00ff);\n    tcg_gen_shli_i32(var, var, 8);\n    tcg_gen_ext8s_i32(var, var);\n    tcg_gen_or_i32(var, var, tmp);\n    dead_tmp(tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Get the byte address of the real memory for a bitband acess.  */\n", "func_signal": "static inline uint32_t bitband_addr(void * opaque, uint32_t addr)", "code": "{\n    uint32_t res;\n\n    res = *(uint32_t *)opaque;\n    res |= (addr & 0x1ffffff) >> 5;\n    return res;\n\n}", "path": "hw\\armv7m.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* T0 &= ~T1.  Clobbers T1.  */\n/* FIXME: Implement bic natively.  */\n", "func_signal": "static inline void tcg_gen_bic_i32(TCGv dest, TCGv t0, TCGv t1)", "code": "{\n    TCGv tmp = new_tmp();\n    tcg_gen_not_i32(tmp, t1);\n    tcg_gen_and_i32(dest, t0, tmp);\n    dead_tmp(tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Store a 64-bit value to a register pair.  Clobbers val.  */\n", "func_signal": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)", "code": "{\n    TCGv tmp;\n    tmp = new_tmp();\n    tcg_gen_trunc_i64_i32(tmp, val);\n    store_reg(s, rlow, tmp);\n    tmp = new_tmp();\n    tcg_gen_shri_i64(val, val, 32);\n    tcg_gen_trunc_i64_i32(tmp, val);\n    store_reg(s, rhigh, tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Translate a NEON data processing instruction.  Return nonzero if the\n   instruction is invalid.\n   We process data in a mixture of 32-bit and 64-bit chunks.\n   Mostly we use 32-bit chunks so we can use normal scalar instructions.  */\n", "func_signal": "static int disas_neon_data_insn(CPUState * env, DisasContext *s, uint32_t insn)", "code": "{\n    int op;\n    int q;\n    int rd, rn, rm;\n    int size;\n    int shift;\n    int pass;\n    int count;\n    int pairwise;\n    int u;\n    int n;\n    uint32_t imm;\n    TCGv tmp;\n    TCGv tmp2;\n    TCGv tmp3;\n    TCGv_i64 tmp64;\n\n    if (!vfp_enabled(env))\n      return 1;\n    q = (insn & (1 << 6)) != 0;\n    u = (insn >> 24) & 1;\n    VFP_DREG_D(rd, insn);\n    VFP_DREG_N(rn, insn);\n    VFP_DREG_M(rm, insn);\n    size = (insn >> 20) & 3;\n    if ((insn & (1 << 23)) == 0) {\n        /* Three register same length.  */\n        op = ((insn >> 7) & 0x1e) | ((insn >> 4) & 1);\n        if (size == 3 && (op == 1 || op == 5 || op == 8 || op == 9\n                          || op == 10 || op  == 11 || op == 16)) {\n            /* 64-bit element instructions.  */\n            for (pass = 0; pass < (q ? 2 : 1); pass++) {\n                neon_load_reg64(cpu_V0, rn + pass);\n                neon_load_reg64(cpu_V1, rm + pass);\n                switch (op) {\n                case 1: /* VQADD */\n                    if (u) {\n                        gen_helper_neon_add_saturate_u64(CPU_V001);\n                    } else {\n                        gen_helper_neon_add_saturate_s64(CPU_V001);\n                    }\n                    break;\n                case 5: /* VQSUB */\n                    if (u) {\n                        gen_helper_neon_sub_saturate_u64(CPU_V001);\n                    } else {\n                        gen_helper_neon_sub_saturate_s64(CPU_V001);\n                    }\n                    break;\n                case 8: /* VSHL */\n                    if (u) {\n                        gen_helper_neon_shl_u64(cpu_V0, cpu_V1, cpu_V0);\n                    } else {\n                        gen_helper_neon_shl_s64(cpu_V0, cpu_V1, cpu_V0);\n                    }\n                    break;\n                case 9: /* VQSHL */\n                    if (u) {\n                        gen_helper_neon_qshl_u64(cpu_V0, cpu_env,\n                                                 cpu_V0, cpu_V0);\n                    } else {\n                        gen_helper_neon_qshl_s64(cpu_V1, cpu_env,\n                                                 cpu_V1, cpu_V0);\n                    }\n                    break;\n                case 10: /* VRSHL */\n                    if (u) {\n                        gen_helper_neon_rshl_u64(cpu_V0, cpu_V1, cpu_V0);\n                    } else {\n                        gen_helper_neon_rshl_s64(cpu_V0, cpu_V1, cpu_V0);\n                    }\n                    break;\n                case 11: /* VQRSHL */\n                    if (u) {\n                        gen_helper_neon_qrshl_u64(cpu_V0, cpu_env,\n                                                  cpu_V1, cpu_V0);\n                    } else {\n                        gen_helper_neon_qrshl_s64(cpu_V0, cpu_env,\n                                                  cpu_V1, cpu_V0);\n                    }\n                    break;\n                case 16:\n                    if (u) {\n                        tcg_gen_sub_i64(CPU_V001);\n                    } else {\n                        tcg_gen_add_i64(CPU_V001);\n                    }\n                    break;\n                default:\n                    abort();\n                }\n                neon_store_reg64(cpu_V0, rd + pass);\n            }\n            return 0;\n        }\n        switch (op) {\n        case 8: /* VSHL */\n        case 9: /* VQSHL */\n        case 10: /* VRSHL */\n        case 11: /* VQRSHL */\n            {\n                int rtmp;\n                /* Shift instruction operands are reversed.  */\n                rtmp = rn;\n                rn = rm;\n                rm = rtmp;\n                pairwise = 0;\n            }\n            break;\n        case 20: /* VPMAX */\n        case 21: /* VPMIN */\n        case 23: /* VPADD */\n            pairwise = 1;\n            break;\n        case 26: /* VPADD (float) */\n            pairwise = (u && size < 2);\n            break;\n        case 30: /* VPMIN/VPMAX (float) */\n            pairwise = u;\n            break;\n        default:\n            pairwise = 0;\n            break;\n        }\n        \n        for (pass = 0; pass < (q ? 4 : 2); pass++) {\n\n        if (pairwise) {\n            /* Pairwise.  */\n            if (q)\n                n = (pass & 1) * 2;\n            else\n                n = 0;\n            if (pass < q + 1) {\n                tmp = neon_load_reg(rn, n);\n                tmp2 = neon_load_reg(rn, n + 1);\n            } else {\n                tmp = neon_load_reg(rm, n);\n                tmp2 = neon_load_reg(rm, n + 1);\n            }\n        } else {\n            /* Elementwise.  */\n            tmp = neon_load_reg(rn, pass);\n            tmp2 = neon_load_reg(rm, pass);\n        }\n        switch (op) {\n        case 0: /* VHADD */\n            GEN_NEON_INTEGER_OP(hadd);\n            break;\n        case 1: /* VQADD */\n            GEN_NEON_INTEGER_OP_ENV(qadd);\n            break;\n        case 2: /* VRHADD */\n            GEN_NEON_INTEGER_OP(rhadd);\n            break;\n        case 3: /* Logic ops.  */\n            switch ((u << 2) | size) {\n            case 0: /* VAND */\n            \ttcg_gen_and_i32(tmp, tmp, tmp2);\n                break;\n            case 1: /* BIC */\n                tcg_gen_bic_i32(tmp, tmp, tmp2);\n                break;\n            case 2: /* VORR */\n            \ttcg_gen_or_i32(tmp, tmp, tmp2);\n                break;\n            case 3: /* VORN */\n                tcg_gen_not_i32(tmp2, tmp2);\n            \ttcg_gen_or_i32(tmp, tmp, tmp2);\n                break;\n            case 4: /* VEOR */\n            \ttcg_gen_xor_i32(tmp, tmp, tmp2);\n                break;\n            case 5: /* VBSL */\n                tmp3 = neon_load_reg(rd, pass);\n                gen_neon_bsl(tmp, tmp, tmp2, tmp3);\n                dead_tmp(tmp3);\n                break;\n            case 6: /* VBIT */\n                tmp3 = neon_load_reg(rd, pass);\n                gen_neon_bsl(tmp, tmp, tmp3, tmp2);\n                dead_tmp(tmp3);\n                break;\n            case 7: /* VBIF */\n                tmp3 = neon_load_reg(rd, pass);\n                gen_neon_bsl(tmp, tmp3, tmp, tmp2);\n                dead_tmp(tmp3);\n                break;\n            }\n            break;\n        case 4: /* VHSUB */\n            GEN_NEON_INTEGER_OP(hsub);\n            break;\n        case 5: /* VQSUB */\n            GEN_NEON_INTEGER_OP_ENV(qsub);\n            break;\n        case 6: /* VCGT */\n            GEN_NEON_INTEGER_OP(cgt);\n            break;\n        case 7: /* VCGE */\n            GEN_NEON_INTEGER_OP(cge);\n            break;\n        case 8: /* VSHL */\n            GEN_NEON_INTEGER_OP(shl);\n            break;\n        case 9: /* VQSHL */\n            GEN_NEON_INTEGER_OP_ENV(qshl);\n            break;\n        case 10: /* VRSHL */\n            GEN_NEON_INTEGER_OP(rshl);\n            break;\n        case 11: /* VQRSHL */\n            GEN_NEON_INTEGER_OP_ENV(qrshl);\n            break;\n        case 12: /* VMAX */\n            GEN_NEON_INTEGER_OP(max);\n            break;\n        case 13: /* VMIN */\n            GEN_NEON_INTEGER_OP(min);\n            break;\n        case 14: /* VABD */\n            GEN_NEON_INTEGER_OP(abd);\n            break;\n        case 15: /* VABA */\n            GEN_NEON_INTEGER_OP(abd);\n            dead_tmp(tmp2);\n            tmp2 = neon_load_reg(rd, pass);\n            gen_neon_add(size, tmp, tmp2);\n            break;\n        case 16:\n            if (!u) { /* VADD */\n                if (gen_neon_add(size, tmp, tmp2))\n                    return 1;\n            } else { /* VSUB */\n                switch (size) {\n                case 0: gen_helper_neon_sub_u8(tmp, tmp, tmp2); break;\n                case 1: gen_helper_neon_sub_u16(tmp, tmp, tmp2); break;\n                case 2: tcg_gen_sub_i32(tmp, tmp, tmp2); break;\n                default: return 1;\n                }\n            }\n            break;\n        case 17:\n            if (!u) { /* VTST */\n                switch (size) {\n                case 0: gen_helper_neon_tst_u8(tmp, tmp, tmp2); break;\n                case 1: gen_helper_neon_tst_u16(tmp, tmp, tmp2); break;\n                case 2: gen_helper_neon_tst_u32(tmp, tmp, tmp2); break;\n                default: return 1;\n                }\n            } else { /* VCEQ */\n                switch (size) {\n                case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n                case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n                case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n                default: return 1;\n                }\n            }\n            break;\n        case 18: /* Multiply.  */\n            switch (size) {\n            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n            default: return 1;\n            }\n            dead_tmp(tmp2);\n            tmp2 = neon_load_reg(rd, pass);\n            if (u) { /* VMLS */\n                gen_neon_rsb(size, tmp, tmp2);\n            } else { /* VMLA */\n                gen_neon_add(size, tmp, tmp2);\n            }\n            break;\n        case 19: /* VMUL */\n            if (u) { /* polynomial */\n                gen_helper_neon_mul_p8(tmp, tmp, tmp2);\n            } else { /* Integer */\n                switch (size) {\n                case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n                case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n                case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n                default: return 1;\n                }\n            }\n            break;\n        case 20: /* VPMAX */\n            GEN_NEON_INTEGER_OP(pmax);\n            break;\n        case 21: /* VPMIN */\n            GEN_NEON_INTEGER_OP(pmin);\n            break;\n        case 22: /* Hultiply high.  */\n            if (!u) { /* VQDMULH */\n                switch (size) {\n                case 1: gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2); break;\n                case 2: gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2); break;\n                default: return 1;\n                }\n            } else { /* VQRDHMUL */\n                switch (size) {\n                case 1: gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2); break;\n                case 2: gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2); break;\n                default: return 1;\n                }\n            }\n            break;\n        case 23: /* VPADD */\n            if (u)\n                return 1;\n            switch (size) {\n            case 0: gen_helper_neon_padd_u8(tmp, tmp, tmp2); break;\n            case 1: gen_helper_neon_padd_u16(tmp, tmp, tmp2); break;\n            case 2: tcg_gen_add_i32(tmp, tmp, tmp2); break;\n            default: return 1;\n            }\n            break;\n        case 26: /* Floating point arithnetic.  */\n            switch ((u << 2) | size) {\n            case 0: /* VADD */\n                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n                break;\n            case 2: /* VSUB */\n                gen_helper_neon_sub_f32(tmp, tmp, tmp2);\n                break;\n            case 4: /* VPADD */\n                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n                break;\n            case 6: /* VABD */\n                gen_helper_neon_abd_f32(tmp, tmp, tmp2);\n                break;\n            default:\n                return 1;\n            }\n            break;\n        case 27: /* Float multiply.  */\n            gen_helper_neon_mul_f32(tmp, tmp, tmp2);\n            if (!u) {\n                dead_tmp(tmp2);\n                tmp2 = neon_load_reg(rd, pass);\n                if (size == 0) {\n                    gen_helper_neon_add_f32(tmp, tmp, tmp2);\n                } else {\n                    gen_helper_neon_sub_f32(tmp, tmp2, tmp);\n                }\n            }\n            break;\n        case 28: /* Float compare.  */\n            if (!u) {\n                gen_helper_neon_ceq_f32(tmp, tmp, tmp2);\n            } else {\n                if (size == 0)\n                    gen_helper_neon_cge_f32(tmp, tmp, tmp2);\n                else\n                    gen_helper_neon_cgt_f32(tmp, tmp, tmp2);\n            }\n            break;\n        case 29: /* Float compare absolute.  */\n            if (!u)\n                return 1;\n            if (size == 0)\n                gen_helper_neon_acge_f32(tmp, tmp, tmp2);\n            else\n                gen_helper_neon_acgt_f32(tmp, tmp, tmp2);\n            break;\n        case 30: /* Float min/max.  */\n            if (size == 0)\n                gen_helper_neon_max_f32(tmp, tmp, tmp2);\n            else\n                gen_helper_neon_min_f32(tmp, tmp, tmp2);\n            break;\n        case 31:\n            if (size == 0)\n                gen_helper_recps_f32(tmp, tmp, tmp2, cpu_env);\n            else\n                gen_helper_rsqrts_f32(tmp, tmp, tmp2, cpu_env);\n            break;\n        default:\n            abort();\n        }\n        dead_tmp(tmp2);\n\n        /* Save the result.  For elementwise operations we can put it\n           straight into the destination register.  For pairwise operations\n           we have to be careful to avoid clobbering the source operands.  */\n        if (pairwise && rd == rm) {\n            neon_store_scratch(pass, tmp);\n        } else {\n            neon_store_reg(rd, pass, tmp);\n        }\n\n        } /* for pass */\n        if (pairwise && rd == rm) {\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n                tmp = neon_load_scratch(pass);\n                neon_store_reg(rd, pass, tmp);\n            }\n        }\n        /* End of 3 register same size operations.  */\n    } else if (insn & (1 << 4)) {\n        if ((insn & 0x00380080) != 0) {\n            /* Two registers and shift.  */\n            op = (insn >> 8) & 0xf;\n            if (insn & (1 << 7)) {\n                /* 64-bit shift.   */\n                size = 3;\n            } else {\n                size = 2;\n                while ((insn & (1 << (size + 19))) == 0)\n                    size--;\n            }\n            shift = (insn >> 16) & ((1 << (3 + size)) - 1);\n            /* To avoid excessive dumplication of ops we implement shift\n               by immediate using the variable shift operations.  */\n            if (op < 8) {\n                /* Shift by immediate:\n                   VSHR, VSRA, VRSHR, VRSRA, VSRI, VSHL, VQSHL, VQSHLU.  */\n                /* Right shifts are encoded as N - shift, where N is the\n                   element size in bits.  */\n                if (op <= 4)\n                    shift = shift - (1 << (size + 3));\n                if (size == 3) {\n                    count = q + 1;\n                } else {\n                    count = q ? 4: 2;\n                }\n                switch (size) {\n                case 0:\n                    imm = (uint8_t) shift;\n                    imm |= imm << 8;\n                    imm |= imm << 16;\n                    break;\n                case 1:\n                    imm = (uint16_t) shift;\n                    imm |= imm << 16;\n                    break;\n                case 2:\n                case 3:\n                    imm = shift;\n                    break;\n                default:\n                    abort();\n                }\n\n                for (pass = 0; pass < count; pass++) {\n                    if (size == 3) {\n                        neon_load_reg64(cpu_V0, rm + pass);\n                        tcg_gen_movi_i64(cpu_V1, imm);\n                        switch (op) {\n                        case 0:  /* VSHR */\n                        case 1:  /* VSRA */\n                            if (u)\n                                gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n                            else\n                                gen_helper_neon_shl_s64(cpu_V0, cpu_V0, cpu_V1);\n                            break;\n                        case 2: /* VRSHR */\n                        case 3: /* VRSRA */\n                            if (u)\n                                gen_helper_neon_rshl_u64(cpu_V0, cpu_V0, cpu_V1);\n                            else\n                                gen_helper_neon_rshl_s64(cpu_V0, cpu_V0, cpu_V1);\n                            break;\n                        case 4: /* VSRI */\n                            if (!u)\n                                return 1;\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n                            break;\n                        case 5: /* VSHL, VSLI */\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, cpu_V1);\n                            break;\n                        case 6: /* VQSHL */\n                            if (u)\n                                gen_helper_neon_qshl_u64(cpu_V0, cpu_env, cpu_V0, cpu_V1);\n                            else\n                                gen_helper_neon_qshl_s64(cpu_V0, cpu_env, cpu_V0, cpu_V1);\n                            break;\n                        case 7: /* VQSHLU */\n                            gen_helper_neon_qshl_u64(cpu_V0, cpu_env, cpu_V0, cpu_V1);\n                            break;\n                        }\n                        if (op == 1 || op == 3) {\n                            /* Accumulate.  */\n                            neon_load_reg64(cpu_V0, rd + pass);\n                            tcg_gen_add_i64(cpu_V0, cpu_V0, cpu_V1);\n                        } else if (op == 4 || (op == 5 && u)) {\n                            /* Insert */\n                            cpu_abort(env, \"VS[LR]I.64 not implemented\");\n                        }\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    } else { /* size < 3 */\n                        /* Operands in T0 and T1.  */\n                        tmp = neon_load_reg(rm, pass);\n                        tmp2 = new_tmp();\n                        tcg_gen_movi_i32(tmp2, imm);\n                        switch (op) {\n                        case 0:  /* VSHR */\n                        case 1:  /* VSRA */\n                            GEN_NEON_INTEGER_OP(shl);\n                            break;\n                        case 2: /* VRSHR */\n                        case 3: /* VRSRA */\n                            GEN_NEON_INTEGER_OP(rshl);\n                            break;\n                        case 4: /* VSRI */\n                            if (!u)\n                                return 1;\n                            GEN_NEON_INTEGER_OP(shl);\n                            break;\n                        case 5: /* VSHL, VSLI */\n                            switch (size) {\n                            case 0: gen_helper_neon_shl_u8(tmp, tmp, tmp2); break;\n                            case 1: gen_helper_neon_shl_u16(tmp, tmp, tmp2); break;\n                            case 2: gen_helper_neon_shl_u32(tmp, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 6: /* VQSHL */\n                            GEN_NEON_INTEGER_OP_ENV(qshl);\n                            break;\n                        case 7: /* VQSHLU */\n                            switch (size) {\n                            case 0: gen_helper_neon_qshl_u8(tmp, cpu_env, tmp, tmp2); break;\n                            case 1: gen_helper_neon_qshl_u16(tmp, cpu_env, tmp, tmp2); break;\n                            case 2: gen_helper_neon_qshl_u32(tmp, cpu_env, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                            break;\n                        }\n                        dead_tmp(tmp2);\n\n                        if (op == 1 || op == 3) {\n                            /* Accumulate.  */\n                            tmp2 = neon_load_reg(rd, pass);\n                            gen_neon_add(size, tmp2, tmp);\n                            dead_tmp(tmp2);\n                        } else if (op == 4 || (op == 5 && u)) {\n                            /* Insert */\n                            switch (size) {\n                            case 0:\n                                if (op == 4)\n                                    imm = 0xff >> -shift;\n                                else\n                                    imm = (uint8_t)(0xff << shift);\n                                imm |= imm << 8;\n                                imm |= imm << 16;\n                                break;\n                            case 1:\n                                if (op == 4)\n                                    imm = 0xffff >> -shift;\n                                else\n                                    imm = (uint16_t)(0xffff << shift);\n                                imm |= imm << 16;\n                                break;\n                            case 2:\n                                if (op == 4)\n                                    imm = 0xffffffffu >> -shift;\n                                else\n                                    imm = 0xffffffffu << shift;\n                                break;\n                            default:\n                                abort();\n                            }\n                            tmp2 = neon_load_reg(rd, pass);\n                            tcg_gen_andi_i32(tmp, tmp, imm);\n                            tcg_gen_andi_i32(tmp2, tmp2, ~imm);\n                            tcg_gen_or_i32(tmp, tmp, tmp2);\n                            dead_tmp(tmp2);\n                        }\n                        neon_store_reg(rd, pass, tmp);\n                    }\n                } /* for pass */\n            } else if (op < 10) {\n                /* Shift by immediate and narrow:\n                   VSHRN, VRSHRN, VQSHRN, VQRSHRN.  */\n                shift = shift - (1 << (size + 3));\n                size++;\n                switch (size) {\n                case 1:\n                    imm = (uint16_t)shift;\n                    imm |= imm << 16;\n                    tmp2 = tcg_const_i32(imm);\n                    TCGV_UNUSED_I64(tmp64);\n                    break;\n                case 2:\n                    imm = (uint32_t)shift;\n                    tmp2 = tcg_const_i32(imm);\n                    TCGV_UNUSED_I64(tmp64);\n                    break;\n                case 3:\n                    tmp64 = tcg_const_i64(shift);\n                    TCGV_UNUSED(tmp2);\n                    break;\n                default:\n                    abort();\n                }\n\n                for (pass = 0; pass < 2; pass++) {\n                    if (size == 3) {\n                        neon_load_reg64(cpu_V0, rm + pass);\n                        if (q) {\n                          if (u)\n                            gen_helper_neon_rshl_u64(cpu_V0, cpu_V0, tmp64);\n                          else\n                            gen_helper_neon_rshl_s64(cpu_V0, cpu_V0, tmp64);\n                        } else {\n                          if (u)\n                            gen_helper_neon_shl_u64(cpu_V0, cpu_V0, tmp64);\n                          else\n                            gen_helper_neon_shl_s64(cpu_V0, cpu_V0, tmp64);\n                        }\n                    } else {\n                        tmp = neon_load_reg(rm + pass, 0);\n                        gen_neon_shift_narrow(size, tmp, tmp2, q, u);\n                        tmp3 = neon_load_reg(rm + pass, 1);\n                        gen_neon_shift_narrow(size, tmp3, tmp2, q, u);\n                        tcg_gen_concat_i32_i64(cpu_V0, tmp, tmp3);\n                        dead_tmp(tmp);\n                        dead_tmp(tmp3);\n                    }\n                    tmp = new_tmp();\n                    if (op == 8 && !u) {\n                        gen_neon_narrow(size - 1, tmp, cpu_V0);\n                    } else {\n                        if (op == 8)\n                            gen_neon_narrow_sats(size - 1, tmp, cpu_V0);\n                        else\n                            gen_neon_narrow_satu(size - 1, tmp, cpu_V0);\n                    }\n                    if (pass == 0) {\n                        tmp2 = tmp;\n                    } else {\n                        neon_store_reg(rd, 0, tmp2);\n                        neon_store_reg(rd, 1, tmp);\n                    }\n                } /* for pass */\n            } else if (op == 10) {\n                /* VSHLL */\n                if (q || size == 3)\n                    return 1;\n                tmp = neon_load_reg(rm, 0);\n                tmp2 = neon_load_reg(rm, 1);\n                for (pass = 0; pass < 2; pass++) {\n                    if (pass == 1)\n                        tmp = tmp2;\n\n                    gen_neon_widen(cpu_V0, tmp, size, u);\n\n                    if (shift != 0) {\n                        /* The shift is less than the width of the source\n                           type, so we can just shift the whole register.  */\n                        tcg_gen_shli_i64(cpu_V0, cpu_V0, shift);\n                        if (size < 2 || !u) {\n                            uint64_t imm64;\n                            if (size == 0) {\n                                imm = (0xffu >> (8 - shift));\n                                imm |= imm << 16;\n                            } else {\n                                imm = 0xffff >> (16 - shift);\n                            }\n                            imm64 = imm | (((uint64_t)imm) << 32);\n                            tcg_gen_andi_i64(cpu_V0, cpu_V0, imm64);\n                        }\n                    }\n                    neon_store_reg64(cpu_V0, rd + pass);\n                }\n            } else if (op == 15 || op == 16) {\n                /* VCVT fixed-point.  */\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n                    tcg_gen_ld_f32(cpu_F0s, cpu_env, neon_reg_offset(rm, pass));\n                    if (op & 1) {\n                        if (u)\n                            gen_vfp_ulto(0, shift);\n                        else\n                            gen_vfp_slto(0, shift);\n                    } else {\n                        if (u)\n                            gen_vfp_toul(0, shift);\n                        else\n                            gen_vfp_tosl(0, shift);\n                    }\n                    tcg_gen_st_f32(cpu_F0s, cpu_env, neon_reg_offset(rd, pass));\n                }\n            } else {\n                return 1;\n            }\n        } else { /* (insn & 0x00380080) == 0 */\n            int invert;\n\n            op = (insn >> 8) & 0xf;\n            /* One register and immediate.  */\n            imm = (u << 7) | ((insn >> 12) & 0x70) | (insn & 0xf);\n            invert = (insn & (1 << 5)) != 0;\n            switch (op) {\n            case 0: case 1:\n                /* no-op */\n                break;\n            case 2: case 3:\n                imm <<= 8;\n                break;\n            case 4: case 5:\n                imm <<= 16;\n                break;\n            case 6: case 7:\n                imm <<= 24;\n                break;\n            case 8: case 9:\n                imm |= imm << 16;\n                break;\n            case 10: case 11:\n                imm = (imm << 8) | (imm << 24);\n                break;\n            case 12:\n                imm = (imm < 8) | 0xff;\n                break;\n            case 13:\n                imm = (imm << 16) | 0xffff;\n                break;\n            case 14:\n                imm |= (imm << 8) | (imm << 16) | (imm << 24);\n                if (invert)\n                    imm = ~imm;\n                break;\n            case 15:\n                imm = ((imm & 0x80) << 24) | ((imm & 0x3f) << 19)\n                      | ((imm & 0x40) ? (0x1f << 25) : (1 << 30));\n                break;\n            }\n            if (invert)\n                imm = ~imm;\n\n            for (pass = 0; pass < (q ? 4 : 2); pass++) {\n                if (op & 1 && op < 12) {\n                    tmp = neon_load_reg(rd, pass);\n                    if (invert) {\n                        /* The immediate value has already been inverted, so\n                           BIC becomes AND.  */\n                        tcg_gen_andi_i32(tmp, tmp, imm);\n                    } else {\n                        tcg_gen_ori_i32(tmp, tmp, imm);\n                    }\n                } else {\n                    /* VMOV, VMVN.  */\n                    tmp = new_tmp();\n                    if (op == 14 && invert) {\n                        uint32_t val;\n                        val = 0;\n                        for (n = 0; n < 4; n++) {\n                            if (imm & (1 << (n + (pass & 1) * 4)))\n                                val |= 0xff << (n * 8);\n                        }\n                        tcg_gen_movi_i32(tmp, val);\n                    } else {\n                        tcg_gen_movi_i32(tmp, imm);\n                    }\n                }\n                neon_store_reg(rd, pass, tmp);\n            }\n        }\n    } else { /* (insn & 0x00800010 == 0x00800000) */\n        if (size != 3) {\n            op = (insn >> 8) & 0xf;\n            if ((insn & (1 << 6)) == 0) {\n                /* Three registers of different lengths.  */\n                int src1_wide;\n                int src2_wide;\n                int prewiden;\n                /* prewiden, src1_wide, src2_wide */\n                static const int neon_3reg_wide[16][3] = {\n                    {1, 0, 0}, /* VADDL */\n                    {1, 1, 0}, /* VADDW */\n                    {1, 0, 0}, /* VSUBL */\n                    {1, 1, 0}, /* VSUBW */\n                    {0, 1, 1}, /* VADDHN */\n                    {0, 0, 0}, /* VABAL */\n                    {0, 1, 1}, /* VSUBHN */\n                    {0, 0, 0}, /* VABDL */\n                    {0, 0, 0}, /* VMLAL */\n                    {0, 0, 0}, /* VQDMLAL */\n                    {0, 0, 0}, /* VMLSL */\n                    {0, 0, 0}, /* VQDMLSL */\n                    {0, 0, 0}, /* Integer VMULL */\n                    {0, 0, 0}, /* VQDMULL */\n                    {0, 0, 0}  /* Polynomial VMULL */\n                };\n\n                prewiden = neon_3reg_wide[op][0];\n                src1_wide = neon_3reg_wide[op][1];\n                src2_wide = neon_3reg_wide[op][2];\n\n                if (size == 0 && (op == 9 || op == 11 || op == 13))\n                    return 1;\n\n                /* Avoid overlapping operands.  Wide source operands are\n                   always aligned so will never overlap with wide\n                   destinations in problematic ways.  */\n                if (rd == rm && !src2_wide) {\n                    tmp = neon_load_reg(rm, 1);\n                    neon_store_scratch(2, tmp);\n                } else if (rd == rn && !src1_wide) {\n                    tmp = neon_load_reg(rn, 1);\n                    neon_store_scratch(2, tmp);\n                }\n                TCGV_UNUSED(tmp3);\n                for (pass = 0; pass < 2; pass++) {\n                    if (src1_wide) {\n                        neon_load_reg64(cpu_V0, rn + pass);\n                        TCGV_UNUSED(tmp);\n                    } else {\n                        if (pass == 1 && rd == rn) {\n                            tmp = neon_load_scratch(2);\n                        } else {\n                            tmp = neon_load_reg(rn, pass);\n                        }\n                        if (prewiden) {\n                            gen_neon_widen(cpu_V0, tmp, size, u);\n                        }\n                    }\n                    if (src2_wide) {\n                        neon_load_reg64(cpu_V1, rm + pass);\n                        TCGV_UNUSED(tmp2);\n                    } else {\n                        if (pass == 1 && rd == rm) {\n                            tmp2 = neon_load_scratch(2);\n                        } else {\n                            tmp2 = neon_load_reg(rm, pass);\n                        }\n                        if (prewiden) {\n                            gen_neon_widen(cpu_V1, tmp2, size, u);\n                        }\n                    }\n                    switch (op) {\n                    case 0: case 1: case 4: /* VADDL, VADDW, VADDHN, VRADDHN */\n                        gen_neon_addl(size);\n                        break;\n                    case 2: case 3: case 6: /* VSUBL, VSUBW, VSUBHL, VRSUBHL */\n                        gen_neon_subl(size);\n                        break;\n                    case 5: case 7: /* VABAL, VABDL */\n                        switch ((size << 1) | u) {\n                        case 0:\n                            gen_helper_neon_abdl_s16(cpu_V0, tmp, tmp2);\n                            break;\n                        case 1:\n                            gen_helper_neon_abdl_u16(cpu_V0, tmp, tmp2);\n                            break;\n                        case 2:\n                            gen_helper_neon_abdl_s32(cpu_V0, tmp, tmp2);\n                            break;\n                        case 3:\n                            gen_helper_neon_abdl_u32(cpu_V0, tmp, tmp2);\n                            break;\n                        case 4:\n                            gen_helper_neon_abdl_s64(cpu_V0, tmp, tmp2);\n                            break;\n                        case 5:\n                            gen_helper_neon_abdl_u64(cpu_V0, tmp, tmp2);\n                            break;\n                        default: abort();\n                        }\n                        dead_tmp(tmp2);\n                        dead_tmp(tmp);\n                        break;\n                    case 8: case 9: case 10: case 11: case 12: case 13:\n                        /* VMLAL, VQDMLAL, VMLSL, VQDMLSL, VMULL, VQDMULL */\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n                        dead_tmp(tmp2);\n                        dead_tmp(tmp);\n                        break;\n                    case 14: /* Polynomial VMULL */\n                        cpu_abort(env, \"Polynomial VMULL not implemented\");\n\n                    default: /* 15 is RESERVED.  */\n                        return 1;\n                    }\n                    if (op == 5 || op == 13 || (op >= 8 && op <= 11)) {\n                        /* Accumulate.  */\n                        if (op == 10 || op == 11) {\n                            gen_neon_negl(cpu_V0, size);\n                        }\n\n                        if (op != 13) {\n                            neon_load_reg64(cpu_V1, rd + pass);\n                        }\n\n                        switch (op) {\n                        case 5: case 8: case 10: /* VABAL, VMLAL, VMLSL */\n                            gen_neon_addl(size);\n                            break;\n                        case 9: case 11: /* VQDMLAL, VQDMLSL */\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n                            break;\n                            /* Fall through.  */\n                        case 13: /* VQDMULL */\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n                            break;\n                        default:\n                            abort();\n                        }\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    } else if (op == 4 || op == 6) {\n                        /* Narrowing operation.  */\n                        tmp = new_tmp();\n                        if (u) {\n                            switch (size) {\n                            case 0:\n                                gen_helper_neon_narrow_high_u8(tmp, cpu_V0);\n                                break;\n                            case 1:\n                                gen_helper_neon_narrow_high_u16(tmp, cpu_V0);\n                                break;\n                            case 2:\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n                                break;\n                            default: abort();\n                            }\n                        } else {\n                            switch (size) {\n                            case 0:\n                                gen_helper_neon_narrow_round_high_u8(tmp, cpu_V0);\n                                break;\n                            case 1:\n                                gen_helper_neon_narrow_round_high_u16(tmp, cpu_V0);\n                                break;\n                            case 2:\n                                tcg_gen_addi_i64(cpu_V0, cpu_V0, 1u << 31);\n                                tcg_gen_shri_i64(cpu_V0, cpu_V0, 32);\n                                tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n                                break;\n                            default: abort();\n                            }\n                        }\n                        if (pass == 0) {\n                            tmp3 = tmp;\n                        } else {\n                            neon_store_reg(rd, 0, tmp3);\n                            neon_store_reg(rd, 1, tmp);\n                        }\n                    } else {\n                        /* Write back the result.  */\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    }\n                }\n            } else {\n                /* Two registers and a scalar.  */\n                switch (op) {\n                case 0: /* Integer VMLA scalar */\n                case 1: /* Float VMLA scalar */\n                case 4: /* Integer VMLS scalar */\n                case 5: /* Floating point VMLS scalar */\n                case 8: /* Integer VMUL scalar */\n                case 9: /* Floating point VMUL scalar */\n                case 12: /* VQDMULH scalar */\n                case 13: /* VQRDMULH scalar */\n                    tmp = neon_get_scalar(size, rm);\n                    neon_store_scratch(0, tmp);\n                    for (pass = 0; pass < (u ? 4 : 2); pass++) {\n                        tmp = neon_load_scratch(0);\n                        tmp2 = neon_load_reg(rn, pass);\n                        if (op == 12) {\n                            if (size == 1) {\n                                gen_helper_neon_qdmulh_s16(tmp, cpu_env, tmp, tmp2);\n                            } else {\n                                gen_helper_neon_qdmulh_s32(tmp, cpu_env, tmp, tmp2);\n                            }\n                        } else if (op == 13) {\n                            if (size == 1) {\n                                gen_helper_neon_qrdmulh_s16(tmp, cpu_env, tmp, tmp2);\n                            } else {\n                                gen_helper_neon_qrdmulh_s32(tmp, cpu_env, tmp, tmp2);\n                            }\n                        } else if (op & 1) {\n                            gen_helper_neon_mul_f32(tmp, tmp, tmp2);\n                        } else {\n                            switch (size) {\n                            case 0: gen_helper_neon_mul_u8(tmp, tmp, tmp2); break;\n                            case 1: gen_helper_neon_mul_u16(tmp, tmp, tmp2); break;\n                            case 2: tcg_gen_mul_i32(tmp, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                        }\n                        dead_tmp(tmp2);\n                        if (op < 8) {\n                            /* Accumulate.  */\n                            tmp2 = neon_load_reg(rd, pass);\n                            switch (op) {\n                            case 0:\n                                gen_neon_add(size, tmp, tmp2);\n                                break;\n                            case 1:\n                                gen_helper_neon_add_f32(tmp, tmp, tmp2);\n                                break;\n                            case 4:\n                                gen_neon_rsb(size, tmp, tmp2);\n                                break;\n                            case 5:\n                                gen_helper_neon_sub_f32(tmp, tmp2, tmp);\n                                break;\n                            default:\n                                abort();\n                            }\n                            dead_tmp(tmp2);\n                        }\n                        neon_store_reg(rd, pass, tmp);\n                    }\n                    break;\n                case 2: /* VMLAL sclar */\n                case 3: /* VQDMLAL scalar */\n                case 6: /* VMLSL scalar */\n                case 7: /* VQDMLSL scalar */\n                case 10: /* VMULL scalar */\n                case 11: /* VQDMULL scalar */\n                    if (size == 0 && (op == 3 || op == 7 || op == 11))\n                        return 1;\n\n                    tmp2 = neon_get_scalar(size, rm);\n                    tmp3 = neon_load_reg(rn, 1);\n\n                    for (pass = 0; pass < 2; pass++) {\n                        if (pass == 0) {\n                            tmp = neon_load_reg(rn, 0);\n                        } else {\n                            tmp = tmp3;\n                        }\n                        gen_neon_mull(cpu_V0, tmp, tmp2, size, u);\n                        dead_tmp(tmp);\n                        if (op == 6 || op == 7) {\n                            gen_neon_negl(cpu_V0, size);\n                        }\n                        if (op != 11) {\n                            neon_load_reg64(cpu_V1, rd + pass);\n                        }\n                        switch (op) {\n                        case 2: case 6:\n                            gen_neon_addl(size);\n                            break;\n                        case 3: case 7:\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n                            gen_neon_addl_saturate(cpu_V0, cpu_V1, size);\n                            break;\n                        case 10:\n                            /* no-op */\n                            break;\n                        case 11:\n                            gen_neon_addl_saturate(cpu_V0, cpu_V0, size);\n                            break;\n                        default:\n                            abort();\n                        }\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    }\n                    \n                    dead_tmp(tmp2);\n                    \n                    break;\n                default: /* 14 and 15 are RESERVED */\n                    return 1;\n                }\n            }\n        } else { /* size == 3 */\n            if (!u) {\n                /* Extract.  */\n                imm = (insn >> 8) & 0xf;\n                count = q + 1;\n\n                if (imm > 7 && !q)\n                    return 1;\n\n                if (imm == 0) {\n                    neon_load_reg64(cpu_V0, rn);\n                    if (q) {\n                        neon_load_reg64(cpu_V1, rn + 1);\n                    }\n                } else if (imm == 8) {\n                    neon_load_reg64(cpu_V0, rn + 1);\n                    if (q) {\n                        neon_load_reg64(cpu_V1, rm);\n                    }\n                } else if (q) {\n                    tmp64 = tcg_temp_new_i64();\n                    if (imm < 8) {\n                        neon_load_reg64(cpu_V0, rn);\n                        neon_load_reg64(tmp64, rn + 1);\n                    } else {\n                        neon_load_reg64(cpu_V0, rn + 1);\n                        neon_load_reg64(tmp64, rm);\n                    }\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, (imm & 7) * 8);\n                    tcg_gen_shli_i64(cpu_V1, tmp64, 64 - ((imm & 7) * 8));\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n                    if (imm < 8) {\n                        neon_load_reg64(cpu_V1, rm);\n                    } else {\n                        neon_load_reg64(cpu_V1, rm + 1);\n                        imm -= 8;\n                    }\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n                    tcg_gen_shri_i64(tmp64, tmp64, imm * 8);\n                    tcg_gen_or_i64(cpu_V1, cpu_V1, tmp64);\n                } else {\n                    /* BUGFIX */\n                    neon_load_reg64(cpu_V0, rn);\n                    tcg_gen_shri_i64(cpu_V0, cpu_V0, imm * 8);\n                    neon_load_reg64(cpu_V1, rm);\n                    tcg_gen_shli_i64(cpu_V1, cpu_V1, 64 - (imm * 8));\n                    tcg_gen_or_i64(cpu_V0, cpu_V0, cpu_V1);\n                }\n                neon_store_reg64(cpu_V0, rd);\n                if (q) {\n                    neon_store_reg64(cpu_V1, rd + 1);\n                }\n            } else if ((insn & (1 << 11)) == 0) {\n                /* Two register misc.  */\n                op = ((insn >> 12) & 0x30) | ((insn >> 7) & 0xf);\n                size = (insn >> 18) & 3;\n                switch (op) {\n                case 0: /* VREV64 */\n                    if (size == 3)\n                        return 1;\n                    for (pass = 0; pass < (q ? 2 : 1); pass++) {\n                        tmp = neon_load_reg(rm, pass * 2);\n                        tmp2 = neon_load_reg(rm, pass * 2 + 1);\n                        switch (size) {\n                        case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n                        case 1: gen_swap_half(tmp); break;\n                        case 2: /* no-op */ break;\n                        default: abort();\n                        }\n                        neon_store_reg(rd, pass * 2 + 1, tmp);\n                        if (size == 2) {\n                            neon_store_reg(rd, pass * 2, tmp2);\n                        } else {\n                            switch (size) {\n                            case 0: tcg_gen_bswap32_i32(tmp2, tmp2); break;\n                            case 1: gen_swap_half(tmp2); break;\n                            default: abort();\n                            }\n                            neon_store_reg(rd, pass * 2, tmp2);\n                        }\n                    }\n                    break;\n                case 4: case 5: /* VPADDL */\n                case 12: case 13: /* VPADAL */\n                    if (size == 3)\n                        return 1;\n                    for (pass = 0; pass < q + 1; pass++) {\n                        tmp = neon_load_reg(rm, pass * 2);\n                        gen_neon_widen(cpu_V0, tmp, size, op & 1);\n                        tmp = neon_load_reg(rm, pass * 2 + 1);\n                        gen_neon_widen(cpu_V1, tmp, size, op & 1);\n                        switch (size) {\n                        case 0: gen_helper_neon_paddl_u16(CPU_V001); break;\n                        case 1: gen_helper_neon_paddl_u32(CPU_V001); break;\n                        case 2: tcg_gen_add_i64(CPU_V001); break;\n                        default: abort();\n                        }\n                        if (op >= 12) {\n                            /* Accumulate.  */\n                            neon_load_reg64(cpu_V1, rd + pass);\n                            gen_neon_addl(size);\n                        }\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    }\n                    break;\n                case 33: /* VTRN */\n                    if (size == 2) {\n                        for (n = 0; n < (q ? 4 : 2); n += 2) {\n                            tmp = neon_load_reg(rm, n);\n                            tmp2 = neon_load_reg(rd, n + 1);\n                            neon_store_reg(rm, n, tmp2);\n                            neon_store_reg(rd, n + 1, tmp);\n                        }\n                    } else {\n                        goto elementwise;\n                    }\n                    break;\n                case 34: /* VUZP */\n                    /* Reg  Before       After\n                       Rd   A3 A2 A1 A0  B2 B0 A2 A0\n                       Rm   B3 B2 B1 B0  B3 B1 A3 A1\n                     */\n                    if (size == 3)\n                        return 1;\n                    gen_neon_unzip(rd, q, 0, size);\n                    gen_neon_unzip(rm, q, 4, size);\n                    if (q) {\n                        static int unzip_order_q[8] =\n                            {0, 2, 4, 6, 1, 3, 5, 7};\n                        for (n = 0; n < 8; n++) {\n                            int reg = (n < 4) ? rd : rm;\n                            tmp = neon_load_scratch(unzip_order_q[n]);\n                            neon_store_reg(reg, n % 4, tmp);\n                        }\n                    } else {\n                        static int unzip_order[4] =\n                            {0, 4, 1, 5};\n                        for (n = 0; n < 4; n++) {\n                            int reg = (n < 2) ? rd : rm;\n                            tmp = neon_load_scratch(unzip_order[n]);\n                            neon_store_reg(reg, n % 2, tmp);\n                        }\n                    }\n                    break;\n                case 35: /* VZIP */\n                    /* Reg  Before       After\n                       Rd   A3 A2 A1 A0  B1 A1 B0 A0\n                       Rm   B3 B2 B1 B0  B3 A3 B2 A2\n                     */\n                    if (size == 3)\n                        return 1;\n                    count = (q ? 4 : 2);\n                    for (n = 0; n < count; n++) {\n                        tmp = neon_load_reg(rd, n);\n                        tmp2 = neon_load_reg(rd, n);\n                        switch (size) {\n                        case 0: gen_neon_zip_u8(tmp, tmp2); break;\n                        case 1: gen_neon_zip_u16(tmp, tmp2); break;\n                        case 2: /* no-op */; break;\n                        default: abort();\n                        }\n                        neon_store_scratch(n * 2, tmp);\n                        neon_store_scratch(n * 2 + 1, tmp2);\n                    }\n                    for (n = 0; n < count * 2; n++) {\n                        int reg = (n < count) ? rd : rm;\n                        tmp = neon_load_scratch(n);\n                        neon_store_reg(reg, n % count, tmp);\n                    }\n                    break;\n                case 36: case 37: /* VMOVN, VQMOVUN, VQMOVN */\n                    if (size == 3)\n                        return 1;\n                    TCGV_UNUSED(tmp2);\n                    for (pass = 0; pass < 2; pass++) {\n                        neon_load_reg64(cpu_V0, rm + pass);\n                        tmp = new_tmp();\n                        if (op == 36 && q == 0) {\n                            gen_neon_narrow(size, tmp, cpu_V0);\n                        } else if (q) {\n                            gen_neon_narrow_satu(size, tmp, cpu_V0);\n                        } else {\n                            gen_neon_narrow_sats(size, tmp, cpu_V0);\n                        }\n                        if (pass == 0) {\n                            tmp2 = tmp;\n                        } else {\n                            neon_store_reg(rd, 0, tmp2);\n                            neon_store_reg(rd, 1, tmp);\n                        }\n                    }\n                    break;\n                case 38: /* VSHLL */\n                    if (q || size == 3)\n                        return 1;\n                    tmp = neon_load_reg(rm, 0);\n                    tmp2 = neon_load_reg(rm, 1);\n                    for (pass = 0; pass < 2; pass++) {\n                        if (pass == 1)\n                            tmp = tmp2;\n                        gen_neon_widen(cpu_V0, tmp, size, 1);\n                        neon_store_reg64(cpu_V0, rd + pass);\n                    }\n                    break;\n                default:\n                elementwise:\n                    for (pass = 0; pass < (q ? 4 : 2); pass++) {\n                        if (op == 30 || op == 31 || op >= 58) {\n                            tcg_gen_ld_f32(cpu_F0s, cpu_env,\n                                           neon_reg_offset(rm, pass));\n                            TCGV_UNUSED(tmp);\n                        } else {\n                            tmp = neon_load_reg(rm, pass);\n                        }\n                        switch (op) {\n                        case 1: /* VREV32 */\n                            switch (size) {\n                            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n                            case 1: gen_swap_half(tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 2: /* VREV16 */\n                            if (size != 0)\n                                return 1;\n                            gen_rev16(tmp);\n                            break;\n                        case 8: /* CLS */\n                            switch (size) {\n                            case 0: gen_helper_neon_cls_s8(tmp, tmp); break;\n                            case 1: gen_helper_neon_cls_s16(tmp, tmp); break;\n                            case 2: gen_helper_neon_cls_s32(tmp, tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 9: /* CLZ */\n                            switch (size) {\n                            case 0: gen_helper_neon_clz_u8(tmp, tmp); break;\n                            case 1: gen_helper_neon_clz_u16(tmp, tmp); break;\n                            case 2: gen_helper_clz(tmp, tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 10: /* CNT */\n                            if (size != 0)\n                                return 1;\n                            gen_helper_neon_cnt_u8(tmp, tmp);\n                            break;\n                        case 11: /* VNOT */\n                            if (size != 0)\n                                return 1;\n                            tcg_gen_not_i32(tmp, tmp);\n                            break;\n                        case 14: /* VQABS */\n                            switch (size) {\n                            case 0: gen_helper_neon_qabs_s8(tmp, cpu_env, tmp); break;\n                            case 1: gen_helper_neon_qabs_s16(tmp, cpu_env, tmp); break;\n                            case 2: gen_helper_neon_qabs_s32(tmp, cpu_env, tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 15: /* VQNEG */\n                            switch (size) {\n                            case 0: gen_helper_neon_qneg_s8(tmp, cpu_env, tmp); break;\n                            case 1: gen_helper_neon_qneg_s16(tmp, cpu_env, tmp); break;\n                            case 2: gen_helper_neon_qneg_s32(tmp, cpu_env, tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 16: case 19: /* VCGT #0, VCLE #0 */\n                            tmp2 = tcg_const_i32(0);\n                            switch(size) {\n                            case 0: gen_helper_neon_cgt_s8(tmp, tmp, tmp2); break;\n                            case 1: gen_helper_neon_cgt_s16(tmp, tmp, tmp2); break;\n                            case 2: gen_helper_neon_cgt_s32(tmp, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                            tcg_temp_free(tmp2);\n                            if (op == 19)\n                                tcg_gen_not_i32(tmp, tmp);\n                            break;\n                        case 17: case 20: /* VCGE #0, VCLT #0 */\n                            tmp2 = tcg_const_i32(0);\n                            switch(size) {\n                            case 0: gen_helper_neon_cge_s8(tmp, tmp, tmp2); break;\n                            case 1: gen_helper_neon_cge_s16(tmp, tmp, tmp2); break;\n                            case 2: gen_helper_neon_cge_s32(tmp, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                            tcg_temp_free(tmp2);\n                            if (op == 20)\n                                tcg_gen_not_i32(tmp, tmp);\n                            break;\n                        case 18: /* VCEQ #0 */\n                            tmp2 = tcg_const_i32(0);\n                            switch(size) {\n                            case 0: gen_helper_neon_ceq_u8(tmp, tmp, tmp2); break;\n                            case 1: gen_helper_neon_ceq_u16(tmp, tmp, tmp2); break;\n                            case 2: gen_helper_neon_ceq_u32(tmp, tmp, tmp2); break;\n                            default: return 1;\n                            }\n                            tcg_temp_free(tmp2);\n                            break;\n                        case 22: /* VABS */\n                            switch(size) {\n                            case 0: gen_helper_neon_abs_s8(tmp, tmp); break;\n                            case 1: gen_helper_neon_abs_s16(tmp, tmp); break;\n                            case 2: tcg_gen_abs_i32(tmp, tmp); break;\n                            default: return 1;\n                            }\n                            break;\n                        case 23: /* VNEG */\n                            if (size == 3)\n                                return 1;\n                            tmp2 = tcg_const_i32(0);\n                            gen_neon_rsb(size, tmp, tmp2);\n                            tcg_temp_free(tmp2);\n                            break;\n                        case 24: case 27: /* Float VCGT #0, Float VCLE #0 */\n                            tmp2 = tcg_const_i32(0);\n                            gen_helper_neon_cgt_f32(tmp, tmp, tmp2);\n                            tcg_temp_free(tmp2);\n                            if (op == 27)\n                                tcg_gen_not_i32(tmp, tmp);\n                            break;\n                        case 25: case 28: /* Float VCGE #0, Float VCLT #0 */\n                            tmp2 = tcg_const_i32(0);\n                            gen_helper_neon_cge_f32(tmp, tmp, tmp2);\n                            tcg_temp_free(tmp2);\n                            if (op == 28)\n                                tcg_gen_not_i32(tmp, tmp);\n                            break;\n                        case 26: /* Float VCEQ #0 */\n                            tmp2 = tcg_const_i32(0);\n                            gen_helper_neon_ceq_f32(tmp, tmp, tmp2);\n                            tcg_temp_free(tmp2);\n                            break;\n                        case 30: /* Float VABS */\n                            gen_vfp_abs(0);\n                            break;\n                        case 31: /* Float VNEG */\n                            gen_vfp_neg(0);\n                            break;\n                        case 32: /* VSWP */\n                            tmp2 = neon_load_reg(rd, pass);\n                            neon_store_reg(rm, pass, tmp2);\n                            break;\n                        case 33: /* VTRN */\n                            tmp2 = neon_load_reg(rd, pass);\n                            switch (size) {\n                            case 0: gen_neon_trn_u8(tmp, tmp2); break;\n                            case 1: gen_neon_trn_u16(tmp, tmp2); break;\n                            case 2: abort();\n                            default: return 1;\n                            }\n                            neon_store_reg(rm, pass, tmp2);\n                            break;\n                        case 56: /* Integer VRECPE */\n                            gen_helper_recpe_u32(tmp, tmp, cpu_env);\n                            break;\n                        case 57: /* Integer VRSQRTE */\n                            gen_helper_rsqrte_u32(tmp, tmp, cpu_env);\n                            break;\n                        case 58: /* Float VRECPE */\n                            gen_helper_recpe_f32(cpu_F0s, cpu_F0s, cpu_env);\n                            break;\n                        case 59: /* Float VRSQRTE */\n                            gen_helper_rsqrte_f32(cpu_F0s, cpu_F0s, cpu_env);\n                            break;\n                        case 60: /* VCVT.F32.S32 */\n                            gen_vfp_tosiz(0);\n                            break;\n                        case 61: /* VCVT.F32.U32 */\n                            gen_vfp_touiz(0);\n                            break;\n                        case 62: /* VCVT.S32.F32 */\n                            gen_vfp_sito(0);\n                            break;\n                        case 63: /* VCVT.U32.F32 */\n                            gen_vfp_uito(0);\n                            break;\n                        default:\n                            /* Reserved: 21, 29, 39-56 */\n                            return 1;\n                        }\n                        if (op == 30 || op == 31 || op >= 58) {\n                            tcg_gen_st_f32(cpu_F0s, cpu_env,\n                                           neon_reg_offset(rd, pass));\n                        } else {\n                            neon_store_reg(rd, pass, tmp);\n                        }\n                    }\n                    break;\n                }\n            } else if ((insn & (1 << 10)) == 0) {\n                /* VTBL, VTBX.  */\n                n = ((insn >> 5) & 0x18) + 8;\n                if (insn & (1 << 6)) {\n                    tmp = neon_load_reg(rd, 0);\n                } else {\n                    tmp = new_tmp();\n                    tcg_gen_movi_i32(tmp, 0);\n                }\n                tmp2 = neon_load_reg(rm, 0);\n                gen_helper_neon_tbl(tmp2, tmp2, tmp, tcg_const_i32(rn),\n                                    tcg_const_i32(n));\n                dead_tmp(tmp);\n                if (insn & (1 << 6)) {\n                    tmp = neon_load_reg(rd, 1);\n                } else {\n                    tmp = new_tmp();\n                    tcg_gen_movi_i32(tmp, 0);\n                }\n                tmp3 = neon_load_reg(rm, 1);\n                gen_helper_neon_tbl(tmp3, tmp3, tmp, tcg_const_i32(rn),\n                                    tcg_const_i32(n));\n                neon_store_reg(rd, 0, tmp2);\n                neon_store_reg(rd, 1, tmp3);\n                dead_tmp(tmp);\n            } else if ((insn & 0x380) == 0) {\n                /* VDUP */\n                if (insn & (1 << 19)) {\n                    tmp = neon_load_reg(rm, 1);\n                } else {\n                    tmp = neon_load_reg(rm, 0);\n                }\n                if (insn & (1 << 16)) {\n                    gen_neon_dup_u8(tmp, ((insn >> 17) & 3) * 8);\n                } else if (insn & (1 << 17)) {\n                    if ((insn >> 18) & 1)\n                        gen_neon_dup_high16(tmp);\n                    else\n                        gen_neon_dup_low16(tmp);\n                }\n                for (pass = 0; pass < (q ? 4 : 2); pass++) {\n                    tmp2 = new_tmp();\n                    tcg_gen_mov_i32(tmp2, tmp);\n                    neon_store_reg(rd, pass, tmp2);\n                }\n                dead_tmp(tmp);\n            } else {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Variant of store_reg which uses branch&exchange logic when storing\n   to r15 in ARM architecture v7 and above. The source must be a temporary\n   and will be marked as dead. */\n", "func_signal": "static inline void store_reg_bx(CPUState *env, DisasContext *s,\n                                int reg, TCGv var)", "code": "{\n    if (reg == 15 && ENABLE_ARCH_7) {\n        gen_bx(s, var);\n    } else {\n        store_reg(s, reg, var);\n    }\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Disassemble a VFP instruction.  Returns nonzero if an error occured\n   (ie. an undefined instruction).  */\n", "func_signal": "static int disas_vfp_insn(CPUState * env, DisasContext *s, uint32_t insn)", "code": "{\n    uint32_t rd, rn, rm, op, i, n, offset, delta_d, delta_m, bank_mask;\n    int dp, veclen;\n    TCGv addr;\n    TCGv tmp;\n    TCGv tmp2;\n\n    if (!arm_feature(env, ARM_FEATURE_VFP))\n        return 1;\n\n    if (!vfp_enabled(env)) {\n        /* VFP disabled.  Only allow fmxr/fmrx to/from some control regs.  */\n        if ((insn & 0x0fe00fff) != 0x0ee00a10)\n            return 1;\n        rn = (insn >> 16) & 0xf;\n        if (rn != ARM_VFP_FPSID && rn != ARM_VFP_FPEXC\n            && rn != ARM_VFP_MVFR1 && rn != ARM_VFP_MVFR0)\n            return 1;\n    }\n    dp = ((insn & 0xf00) == 0xb00);\n    switch ((insn >> 24) & 0xf) {\n    case 0xe:\n        if (insn & (1 << 4)) {\n            /* single register transfer */\n            rd = (insn >> 12) & 0xf;\n            if (dp) {\n                int size;\n                int pass;\n\n                VFP_DREG_N(rn, insn);\n                if (insn & 0xf)\n                    return 1;\n                if (insn & 0x00c00060\n                    && !arm_feature(env, ARM_FEATURE_NEON))\n                    return 1;\n\n                pass = (insn >> 21) & 1;\n                if (insn & (1 << 22)) {\n                    size = 0;\n                    offset = ((insn >> 5) & 3) * 8;\n                } else if (insn & (1 << 5)) {\n                    size = 1;\n                    offset = (insn & (1 << 6)) ? 16 : 0;\n                } else {\n                    size = 2;\n                    offset = 0;\n                }\n                if (insn & ARM_CP_RW_BIT) {\n                    /* vfp->arm */\n                    tmp = neon_load_reg(rn, pass);\n                    switch (size) {\n                    case 0:\n                        if (offset)\n                            tcg_gen_shri_i32(tmp, tmp, offset);\n                        if (insn & (1 << 23))\n                            gen_uxtb(tmp);\n                        else\n                            gen_sxtb(tmp);\n                        break;\n                    case 1:\n                        if (insn & (1 << 23)) {\n                            if (offset) {\n                                tcg_gen_shri_i32(tmp, tmp, 16);\n                            } else {\n                                gen_uxth(tmp);\n                            }\n                        } else {\n                            if (offset) {\n                                tcg_gen_sari_i32(tmp, tmp, 16);\n                            } else {\n                                gen_sxth(tmp);\n                            }\n                        }\n                        break;\n                    case 2:\n                        break;\n                    }\n                    store_reg(s, rd, tmp);\n                } else {\n                    /* arm->vfp */\n                    tmp = load_reg(s, rd);\n                    if (insn & (1 << 23)) {\n                        /* VDUP */\n                        if (size == 0) {\n                            gen_neon_dup_u8(tmp, 0);\n                        } else if (size == 1) {\n                            gen_neon_dup_low16(tmp);\n                        }\n                        for (n = 0; n <= pass * 2; n++) {\n                            tmp2 = new_tmp();\n                            tcg_gen_mov_i32(tmp2, tmp);\n                            neon_store_reg(rn, n, tmp2);\n                        }\n                        neon_store_reg(rn, n, tmp);\n                    } else {\n                        /* VMOV */\n                        switch (size) {\n                        case 0:\n                            tmp2 = neon_load_reg(rn, pass);\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xff);\n                            dead_tmp(tmp2);\n                            break;\n                        case 1:\n                            tmp2 = neon_load_reg(rn, pass);\n                            gen_bfi(tmp, tmp2, tmp, offset, 0xffff);\n                            dead_tmp(tmp2);\n                            break;\n                        case 2:\n                            break;\n                        }\n                        neon_store_reg(rn, pass, tmp);\n                    }\n                }\n            } else { /* !dp */\n                if ((insn & 0x6f) != 0x00)\n                    return 1;\n                rn = VFP_SREG_N(insn);\n                if (insn & ARM_CP_RW_BIT) {\n                    /* vfp->arm */\n                    if (insn & (1 << 21)) {\n                        /* system register */\n                        rn >>= 1;\n\n                        switch (rn) {\n                        case ARM_VFP_FPSID:\n                            /* VFP2 allows access to FSID from userspace.\n                               VFP3 restricts all id registers to privileged\n                               accesses.  */\n                            if (IS_USER(s)\n                                && arm_feature(env, ARM_FEATURE_VFP3))\n                                return 1;\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n                            break;\n                        case ARM_VFP_FPEXC:\n                            if (IS_USER(s))\n                                return 1;\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n                            break;\n                        case ARM_VFP_FPINST:\n                        case ARM_VFP_FPINST2:\n                            /* Not present in VFP3.  */\n                            if (IS_USER(s)\n                                || arm_feature(env, ARM_FEATURE_VFP3))\n                                return 1;\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n                            break;\n                        case ARM_VFP_FPSCR:\n                            if (rd == 15) {\n                                tmp = load_cpu_field(vfp.xregs[ARM_VFP_FPSCR]);\n                                tcg_gen_andi_i32(tmp, tmp, 0xf0000000);\n                            } else {\n                                tmp = new_tmp();\n                                gen_helper_vfp_get_fpscr(tmp, cpu_env);\n                            }\n                            break;\n                        case ARM_VFP_MVFR0:\n                        case ARM_VFP_MVFR1:\n                            if (IS_USER(s)\n                                || !arm_feature(env, ARM_FEATURE_VFP3))\n                                return 1;\n                            tmp = load_cpu_field(vfp.xregs[rn]);\n                            break;\n                        default:\n                            return 1;\n                        }\n                    } else {\n                        gen_mov_F0_vreg(0, rn);\n                        tmp = gen_vfp_mrs();\n                    }\n                    if (rd == 15) {\n                        /* Set the 4 flag bits in the CPSR.  */\n                        gen_set_nzcv(tmp);\n                        dead_tmp(tmp);\n                    } else {\n                        store_reg(s, rd, tmp);\n                    }\n                } else {\n                    /* arm->vfp */\n                    tmp = load_reg(s, rd);\n                    if (insn & (1 << 21)) {\n                        rn >>= 1;\n                        /* system register */\n                        switch (rn) {\n                        case ARM_VFP_FPSID:\n                        case ARM_VFP_MVFR0:\n                        case ARM_VFP_MVFR1:\n                            /* Writes are ignored.  */\n                            break;\n                        case ARM_VFP_FPSCR:\n                            gen_helper_vfp_set_fpscr(cpu_env, tmp);\n                            dead_tmp(tmp);\n                            gen_lookup_tb(s);\n                            break;\n                        case ARM_VFP_FPEXC:\n                            if (IS_USER(s))\n                                return 1;\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n                            gen_lookup_tb(s);\n                            break;\n                        case ARM_VFP_FPINST:\n                        case ARM_VFP_FPINST2:\n                            store_cpu_field(tmp, vfp.xregs[rn]);\n                            break;\n                        default:\n                            return 1;\n                        }\n                    } else {\n                        gen_vfp_msr(tmp);\n                        gen_mov_vreg_F0(0, rn);\n                    }\n                }\n            }\n        } else {\n            /* data processing */\n            /* The opcode is in bits 23, 21, 20 and 6.  */\n            op = ((insn >> 20) & 8) | ((insn >> 19) & 6) | ((insn >> 6) & 1);\n            if (dp) {\n                if (op == 15) {\n                    /* rn is opcode */\n                    rn = ((insn >> 15) & 0x1e) | ((insn >> 7) & 1);\n                } else {\n                    /* rn is register number */\n                    VFP_DREG_N(rn, insn);\n                }\n\n                if (op == 15 && (rn == 15 || rn > 17)) {\n                    /* Integer or single precision destination.  */\n                    rd = VFP_SREG_D(insn);\n                } else {\n                    VFP_DREG_D(rd, insn);\n                }\n\n                if (op == 15 && (rn == 16 || rn == 17)) {\n                    /* Integer source.  */\n                    rm = ((insn << 1) & 0x1e) | ((insn >> 5) & 1);\n                } else {\n                    VFP_DREG_M(rm, insn);\n                }\n            } else {\n                rn = VFP_SREG_N(insn);\n                if (op == 15 && rn == 15) {\n                    /* Double precision destination.  */\n                    VFP_DREG_D(rd, insn);\n                } else {\n                    rd = VFP_SREG_D(insn);\n                }\n                rm = VFP_SREG_M(insn);\n            }\n\n            veclen = env->vfp.vec_len;\n            if (op == 15 && rn > 3)\n                veclen = 0;\n\n            /* Shut up compiler warnings.  */\n            delta_m = 0;\n            delta_d = 0;\n            bank_mask = 0;\n\n            if (veclen > 0) {\n                if (dp)\n                    bank_mask = 0xc;\n                else\n                    bank_mask = 0x18;\n\n                /* Figure out what type of vector operation this is.  */\n                if ((rd & bank_mask) == 0) {\n                    /* scalar */\n                    veclen = 0;\n                } else {\n                    if (dp)\n                        delta_d = (env->vfp.vec_stride >> 1) + 1;\n                    else\n                        delta_d = env->vfp.vec_stride + 1;\n\n                    if ((rm & bank_mask) == 0) {\n                        /* mixed scalar/vector */\n                        delta_m = 0;\n                    } else {\n                        /* vector */\n                        delta_m = delta_d;\n                    }\n                }\n            }\n\n            /* Load the initial operands.  */\n            if (op == 15) {\n                switch (rn) {\n                case 16:\n                case 17:\n                    /* Integer source */\n                    gen_mov_F0_vreg(0, rm);\n                    break;\n                case 8:\n                case 9:\n                    /* Compare */\n                    gen_mov_F0_vreg(dp, rd);\n                    gen_mov_F1_vreg(dp, rm);\n                    break;\n                case 10:\n                case 11:\n                    /* Compare with zero */\n                    gen_mov_F0_vreg(dp, rd);\n                    gen_vfp_F1_ld0(dp);\n                    break;\n                case 20:\n                case 21:\n                case 22:\n                case 23:\n                case 28:\n                case 29:\n                case 30:\n                case 31:\n                    /* Source and destination the same.  */\n                    gen_mov_F0_vreg(dp, rd);\n                    break;\n                default:\n                    /* One source operand.  */\n                    gen_mov_F0_vreg(dp, rm);\n                    break;\n                }\n            } else {\n                /* Two source operands.  */\n                gen_mov_F0_vreg(dp, rn);\n                gen_mov_F1_vreg(dp, rm);\n            }\n\n            for (;;) {\n                /* Perform the calculation.  */\n                switch (op) {\n                case 0: /* mac: fd + (fn * fm) */\n                    gen_vfp_mul(dp);\n                    gen_mov_F1_vreg(dp, rd);\n                    gen_vfp_add(dp);\n                    break;\n                case 1: /* nmac: fd - (fn * fm) */\n                    gen_vfp_mul(dp);\n                    gen_vfp_neg(dp);\n                    gen_mov_F1_vreg(dp, rd);\n                    gen_vfp_add(dp);\n                    break;\n                case 2: /* msc: -fd + (fn * fm) */\n                    gen_vfp_mul(dp);\n                    gen_mov_F1_vreg(dp, rd);\n                    gen_vfp_sub(dp);\n                    break;\n                case 3: /* nmsc: -fd - (fn * fm)  */\n                    gen_vfp_mul(dp);\n                    gen_vfp_neg(dp);\n                    gen_mov_F1_vreg(dp, rd);\n                    gen_vfp_sub(dp);\n                    break;\n                case 4: /* mul: fn * fm */\n                    gen_vfp_mul(dp);\n                    break;\n                case 5: /* nmul: -(fn * fm) */\n                    gen_vfp_mul(dp);\n                    gen_vfp_neg(dp);\n                    break;\n                case 6: /* add: fn + fm */\n                    gen_vfp_add(dp);\n                    break;\n                case 7: /* sub: fn - fm */\n                    gen_vfp_sub(dp);\n                    break;\n                case 8: /* div: fn / fm */\n                    gen_vfp_div(dp);\n                    break;\n                case 14: /* fconst */\n                    if (!arm_feature(env, ARM_FEATURE_VFP3))\n                      return 1;\n\n                    n = (insn << 12) & 0x80000000;\n                    i = ((insn >> 12) & 0x70) | (insn & 0xf);\n                    if (dp) {\n                        if (i & 0x40)\n                            i |= 0x3f80;\n                        else\n                            i |= 0x4000;\n                        n |= i << 16;\n                        tcg_gen_movi_i64(cpu_F0d, ((uint64_t)n) << 32);\n                    } else {\n                        if (i & 0x40)\n                            i |= 0x780;\n                        else\n                            i |= 0x800;\n                        n |= i << 19;\n                        tcg_gen_movi_i32(cpu_F0s, n);\n                    }\n                    break;\n                case 15: /* extension space */\n                    switch (rn) {\n                    case 0: /* cpy */\n                        /* no-op */\n                        break;\n                    case 1: /* abs */\n                        gen_vfp_abs(dp);\n                        break;\n                    case 2: /* neg */\n                        gen_vfp_neg(dp);\n                        break;\n                    case 3: /* sqrt */\n                        gen_vfp_sqrt(dp);\n                        break;\n                    case 8: /* cmp */\n                        gen_vfp_cmp(dp);\n                        break;\n                    case 9: /* cmpe */\n                        gen_vfp_cmpe(dp);\n                        break;\n                    case 10: /* cmpz */\n                        gen_vfp_cmp(dp);\n                        break;\n                    case 11: /* cmpez */\n                        gen_vfp_F1_ld0(dp);\n                        gen_vfp_cmpe(dp);\n                        break;\n                    case 15: /* single<->double conversion */\n                        if (dp)\n                            gen_helper_vfp_fcvtsd(cpu_F0s, cpu_F0d, cpu_env);\n                        else\n                            gen_helper_vfp_fcvtds(cpu_F0d, cpu_F0s, cpu_env);\n                        break;\n                    case 16: /* fuito */\n                        gen_vfp_uito(dp);\n                        break;\n                    case 17: /* fsito */\n                        gen_vfp_sito(dp);\n                        break;\n                    case 20: /* fshto */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_shto(dp, 16 - rm);\n                        break;\n                    case 21: /* fslto */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_slto(dp, 32 - rm);\n                        break;\n                    case 22: /* fuhto */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_uhto(dp, 16 - rm);\n                        break;\n                    case 23: /* fulto */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_ulto(dp, 32 - rm);\n                        break;\n                    case 24: /* ftoui */\n                        gen_vfp_toui(dp);\n                        break;\n                    case 25: /* ftouiz */\n                        gen_vfp_touiz(dp);\n                        break;\n                    case 26: /* ftosi */\n                        gen_vfp_tosi(dp);\n                        break;\n                    case 27: /* ftosiz */\n                        gen_vfp_tosiz(dp);\n                        break;\n                    case 28: /* ftosh */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_tosh(dp, 16 - rm);\n                        break;\n                    case 29: /* ftosl */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_tosl(dp, 32 - rm);\n                        break;\n                    case 30: /* ftouh */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_touh(dp, 16 - rm);\n                        break;\n                    case 31: /* ftoul */\n                        if (!arm_feature(env, ARM_FEATURE_VFP3))\n                          return 1;\n                        gen_vfp_toul(dp, 32 - rm);\n                        break;\n                    default: /* undefined */\n                        printf (\"rn:%d\\n\", rn);\n                        return 1;\n                    }\n                    break;\n                default: /* undefined */\n                    printf (\"op:%d\\n\", op);\n                    return 1;\n                }\n\n                /* Write back the result.  */\n                if (op == 15 && (rn >= 8 && rn <= 11))\n                    ; /* Comparison, do nothing.  */\n                else if (op == 15 && rn > 17)\n                    /* Integer result.  */\n                    gen_mov_vreg_F0(0, rd);\n                else if (op == 15 && rn == 15)\n                    /* conversion */\n                    gen_mov_vreg_F0(!dp, rd);\n                else\n                    gen_mov_vreg_F0(dp, rd);\n\n                /* break out of the loop if we have finished  */\n                if (veclen == 0)\n                    break;\n\n                if (op == 15 && delta_m == 0) {\n                    /* single source one-many */\n                    while (veclen--) {\n                        rd = ((rd + delta_d) & (bank_mask - 1))\n                             | (rd & bank_mask);\n                        gen_mov_vreg_F0(dp, rd);\n                    }\n                    break;\n                }\n                /* Setup the next operands.  */\n                veclen--;\n                rd = ((rd + delta_d) & (bank_mask - 1))\n                     | (rd & bank_mask);\n\n                if (op == 15) {\n                    /* One source operand.  */\n                    rm = ((rm + delta_m) & (bank_mask - 1))\n                         | (rm & bank_mask);\n                    gen_mov_F0_vreg(dp, rm);\n                } else {\n                    /* Two source operands.  */\n                    rn = ((rn + delta_d) & (bank_mask - 1))\n                         | (rn & bank_mask);\n                    gen_mov_F0_vreg(dp, rn);\n                    if (delta_m) {\n                        rm = ((rm + delta_m) & (bank_mask - 1))\n                             | (rm & bank_mask);\n                        gen_mov_F1_vreg(dp, rm);\n                    }\n                }\n            }\n        }\n        break;\n    case 0xc:\n    case 0xd:\n        if (dp && (insn & 0x03e00000) == 0x00400000) {\n            /* two-register transfer */\n            rn = (insn >> 16) & 0xf;\n            rd = (insn >> 12) & 0xf;\n            if (dp) {\n                VFP_DREG_M(rm, insn);\n            } else {\n                rm = VFP_SREG_M(insn);\n            }\n\n            if (insn & ARM_CP_RW_BIT) {\n                /* vfp->arm */\n                if (dp) {\n                    gen_mov_F0_vreg(0, rm * 2);\n                    tmp = gen_vfp_mrs();\n                    store_reg(s, rd, tmp);\n                    gen_mov_F0_vreg(0, rm * 2 + 1);\n                    tmp = gen_vfp_mrs();\n                    store_reg(s, rn, tmp);\n                } else {\n                    gen_mov_F0_vreg(0, rm);\n                    tmp = gen_vfp_mrs();\n                    store_reg(s, rn, tmp);\n                    gen_mov_F0_vreg(0, rm + 1);\n                    tmp = gen_vfp_mrs();\n                    store_reg(s, rd, tmp);\n                }\n            } else {\n                /* arm->vfp */\n                if (dp) {\n                    tmp = load_reg(s, rd);\n                    gen_vfp_msr(tmp);\n                    gen_mov_vreg_F0(0, rm * 2);\n                    tmp = load_reg(s, rn);\n                    gen_vfp_msr(tmp);\n                    gen_mov_vreg_F0(0, rm * 2 + 1);\n                } else {\n                    tmp = load_reg(s, rn);\n                    gen_vfp_msr(tmp);\n                    gen_mov_vreg_F0(0, rm);\n                    tmp = load_reg(s, rd);\n                    gen_vfp_msr(tmp);\n                    gen_mov_vreg_F0(0, rm + 1);\n                }\n            }\n        } else {\n            /* Load/store */\n            rn = (insn >> 16) & 0xf;\n            if (dp)\n                VFP_DREG_D(rd, insn);\n            else\n                rd = VFP_SREG_D(insn);\n            if (s->thumb && rn == 15) {\n                addr = new_tmp();\n                tcg_gen_movi_i32(addr, s->pc & ~2);\n            } else {\n                addr = load_reg(s, rn);\n            }\n            if ((insn & 0x01200000) == 0x01000000) {\n                /* Single load/store */\n                offset = (insn & 0xff) << 2;\n                if ((insn & (1 << 23)) == 0)\n                    offset = -offset;\n                tcg_gen_addi_i32(addr, addr, offset);\n                if (insn & (1 << 20)) {\n                    gen_vfp_ld(s, dp, addr);\n                    gen_mov_vreg_F0(dp, rd);\n                } else {\n                    gen_mov_F0_vreg(dp, rd);\n                    gen_vfp_st(s, dp, addr);\n                }\n                dead_tmp(addr);\n            } else {\n                /* load/store multiple */\n                if (dp)\n                    n = (insn >> 1) & 0x7f;\n                else\n                    n = insn & 0xff;\n\n                if (insn & (1 << 24)) /* pre-decrement */\n                    tcg_gen_addi_i32(addr, addr, -((insn & 0xff) << 2));\n\n                if (dp)\n                    offset = 8;\n                else\n                    offset = 4;\n                for (i = 0; i < n; i++) {\n                    if (insn & ARM_CP_RW_BIT) {\n                        /* load */\n                        gen_vfp_ld(s, dp, addr);\n                        gen_mov_vreg_F0(dp, rd + i);\n                    } else {\n                        /* store */\n                        gen_mov_F0_vreg(dp, rd + i);\n                        gen_vfp_st(s, dp, addr);\n                    }\n                    tcg_gen_addi_i32(addr, addr, offset);\n                }\n                if (insn & (1 << 21)) {\n                    /* writeback */\n                    if (insn & (1 << 24))\n                        offset = -offset * n;\n                    else if (dp && (insn & 1))\n                        offset = 4;\n                    else\n                        offset = 0;\n\n                    if (offset != 0)\n                        tcg_gen_addi_i32(addr, addr, offset);\n                    store_reg(s, rn, addr);\n                } else {\n                    dead_tmp(addr);\n                }\n            }\n        }\n        break;\n    default:\n        /* Should never happen.  */\n        return 1;\n    }\n    return 0;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* load a 32-bit value from a register and perform a 64-bit accumulate.  */\n", "func_signal": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)", "code": "{\n    TCGv_i64 tmp;\n    TCGv tmp2;\n\n    /* Load value and extend to 64 bits.  */\n    tmp = tcg_temp_new_i64();\n    tmp2 = load_reg(s, rlow);\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n    dead_tmp(tmp2);\n    tcg_gen_add_i64(val, val, tmp);\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* Create a new temporary and set it to the value of a CPU register.  */\n", "func_signal": "static inline TCGv load_reg(DisasContext *s, int reg)", "code": "{\n    TCGv tmp = new_tmp();\n    load_reg_var(s, tmp, reg);\n    return tmp;\n}", "path": "target-arm\\translate.c", "repo_name": "Dushistov/qemu_at91sam9263", "stars": 10, "license": "other", "language": "c", "size": 17960}
{"docstring": "/* local addr = jit.util.ircalladdr(idx) */\n", "func_signal": "LJLIB_CF(jit_util_ircalladdr)", "code": "{\n  uint32_t idx = (uint32_t)lj_lib_checkint(L, 1);\n  if (idx < IRCALL__MAX) {\n    setnumV(L->top-1, cast_num((uintptr_t)(void *)lj_ir_callinfo[idx].func));\n    return 1;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local mcode, addr, loop = jit.util.tracemc(tr) */\n", "func_signal": "LJLIB_CF(jit_util_tracemc)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  if (T && T->mcode != NULL) {\n    setstrV(L, L->top-1, lj_str_new(L, (const char *)T->mcode, T->szmcode));\n    setnumV(L->top++, cast_num((intptr_t)T->mcode));\n    setintV(L->top++, T->mcloop);\n    return 3;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local k = jit.util.funck(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funck)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  ptrdiff_t idx = (ptrdiff_t)lj_lib_checkint(L, 2);\n  if (idx >= 0) {\n    if (idx < (ptrdiff_t)pt->sizekn) {\n      setnumV(L->top-1, proto_knum(pt, idx));\n      return 1;\n    }\n  } else {\n    if (~idx < (ptrdiff_t)pt->sizekgc) {\n      GCobj *gc = proto_kgc(pt, idx);\n      setgcV(L, L->top-1, gc, ~gc->gch.gct);\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Parse optimization flag. */\n", "func_signal": "static int jitopt_flag(jit_State *J, const char *str)", "code": "{\n  const char *lst = JIT_F_OPTSTRING;\n  uint32_t opt;\n  int set = 1;\n  if (str[0] == '+') {\n    str++;\n  } else if (str[0] == '-') {\n    str++;\n    set = 0;\n  } else if (str[0] == 'n' && str[1] == 'o') {\n    str += str[2] == '-' ? 3 : 2;\n    set = 0;\n  }\n  for (opt = JIT_F_OPT_FIRST; ; opt <<= 1) {\n    size_t len = *(const uint8_t *)lst;\n    if (len == 0)\n      break;\n    if (strncmp(str, lst+1, len) == 0 && str[len] == '\\0') {\n      if (set) J->flags |= opt; else J->flags &= ~opt;\n      return 1;  /* Ok. */\n    }\n    lst += 1+len;\n  }\n  return 0;  /* No match. */\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* jit.opt.start(flags...) */\n", "func_signal": "LJLIB_CF(jit_opt_start)", "code": "{\n#if LJ_HASJIT\n  jit_State *J = L2J(L);\n  int nargs = (int)(L->top - L->base);\n  if (nargs == 0) {\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | JIT_F_OPT_DEFAULT;\n  } else {\n    int i;\n    for (i = 1; i <= nargs; i++) {\n      const char *str = strdata(lj_lib_checkstr(L, i));\n      if (!jitopt_level(J, str) &&\n\t  !jitopt_flag(J, str) &&\n\t  !jitopt_param(J, str))\n\tlj_err_callerv(L, LJ_ERR_JITOPT, str);\n    }\n  }\n#else\n  lj_err_caller(L, LJ_ERR_NOJIT);\n#endif\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local name = jit.util.funcuvname(func, idx) */\n", "func_signal": "LJLIB_CF(jit_util_funcuvname)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  uint32_t idx = (uint32_t)lj_lib_checkint(L, 2);\n  if (idx < pt->sizeuv) {\n    setstrV(L, L->top-1, proto_uvname(pt, idx));\n    return 1;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Return prototype of first argument (Lua function or prototype object) */\n", "func_signal": "static GCproto *check_Lproto(lua_State *L, int nolua)", "code": "{\n  TValue *o = L->base;\n  if (L->top > o) {\n    if (tvisproto(o)) {\n      return protoV(o);\n    } else if (tvisfunc(o)) {\n      if (isluafunc(funcV(o)))\n\treturn funcproto(funcV(o));\n      else if (nolua)\n\treturn NULL;\n    }\n  }\n  lj_err_argt(L, 1, LUA_TFUNCTION);\n  return NULL;  /* unreachable */\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local m, ot, op1, op2, prev = jit.util.traceir(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_traceir)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= REF_BIAS && ref < T->nins) {\n    IRIns *ir = &T->ir[ref];\n    int32_t m = lj_ir_mode[ir->o];\n    setintV(L->top-2, m);\n    setintV(L->top-1, ir->ot);\n    setintV(L->top++, (int32_t)ir->op1 - (irm_op1(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, (int32_t)ir->op2 - (irm_op2(m)==IRMref ? REF_BIAS : 0));\n    setintV(L->top++, ir->prev);\n    return 5;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Parse optimization level. */\n", "func_signal": "static int jitopt_level(jit_State *J, const char *str)", "code": "{\n  if (str[0] >= '0' && str[0] <= '9' && str[1] == '\\0') {\n    uint32_t flags;\n    if (str[0] == '0') flags = JIT_F_OPT_0;\n    else if (str[0] == '1') flags = JIT_F_OPT_1;\n    else if (str[0] == '2') flags = JIT_F_OPT_2;\n    else flags = JIT_F_OPT_3;\n    J->flags = (J->flags & ~JIT_F_OPT_MASK) | flags;\n    return 1;  /* Ok. */\n  }\n  return 0;  /* No match. */\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local addr = jit.util.traceexitstub(idx) */\n", "func_signal": "LJLIB_CF(jit_util_traceexitstub)", "code": "{\n  ExitNo exitno = (ExitNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (exitno < EXITSTUBS_PER_GROUP*LJ_MAX_EXITSTUBGR) {\n    setnumV(L->top-1, cast_num((uintptr_t)exitstub_addr(J, exitno)));\n    return 1;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Push a string for every flag bit that is set. */\n", "func_signal": "static void flagbits_to_strings(lua_State *L, uint32_t flags, uint32_t base,\n\t\t\t\tconst char *str)", "code": "{\n  for (; *str; base <<= 1, str += 1+*str)\n    if (flags & base)\n      setstrV(L, L->top++, lj_str_new(L, str+1, *(uint8_t *)str));\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Parse optimization parameter. */\n", "func_signal": "static int jitopt_param(jit_State *J, const char *str)", "code": "{\n  const char *lst = JIT_P_STRING;\n  int i;\n  for (i = 0; i < JIT_P__MAX; i++) {\n    size_t len = *(const uint8_t *)lst;\n    TValue tv;\n    lua_assert(len != 0);\n    if (strncmp(str, lst+1, len) == 0 && str[len] == '=' &&\n\tlj_str_numconv(&str[len+1], &tv)) {\n      J->param[i] = lj_num2int(tv.n);\n      if (i == JIT_P_hotloop)\n\tlj_dispatch_init_hotcount(J2G(J));\n      return 1;  /* Ok. */\n    }\n    lst += 1+len;\n  }\n  return 0;  /* No match. */\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local info = jit.util.funcinfo(func [,pc]) */\n", "func_signal": "LJLIB_CF(jit_util_funcinfo)", "code": "{\n  GCproto *pt = check_Lproto(L, 1);\n  if (pt) {\n    BCPos pc = (BCPos)lj_lib_optint(L, 2, 0);\n    GCtab *t;\n    lua_createtable(L, 0, 16);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"linedefined\", proto_line(pt, 0));\n    setintfield(L, t, \"lastlinedefined\", pt->lastlinedefined);\n    setintfield(L, t, \"stackslots\", pt->framesize);\n    setintfield(L, t, \"params\", pt->numparams);\n    setintfield(L, t, \"bytecodes\", (int32_t)pt->sizebc);\n    setintfield(L, t, \"gcconsts\", (int32_t)pt->sizekgc);\n    setintfield(L, t, \"nconsts\", (int32_t)pt->sizekn);\n    setintfield(L, t, \"upvalues\", (int32_t)pt->sizeuv);\n    if (pc < pt->sizebc)\n      setintfield(L, t, \"currentline\",\n\t\t  proto_lineinfo(pt) ? proto_line(pt, pc) : 0);\n    lua_pushboolean(L, (pt->flags & PROTO_IS_VARARG));\n    lua_setfield(L, -2, \"isvararg\");\n    setstrV(L, L->top++, proto_chunkname(pt));\n    lua_setfield(L, -2, \"source\");\n    lj_err_pushloc(L, pt, pc);\n    lua_setfield(L, -2, \"loc\");\n  } else {\n    GCfunc *fn = funcV(L->base);\n    GCtab *t;\n    lua_createtable(L, 0, 4);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    if (!iscfunc(fn))\n      setintfield(L, t, \"ffid\", fn->c.ffid);\n    setnumV(lj_tab_setstr(L, t, lj_str_newlit(L, \"addr\")),\n\t    cast_num((intptr_t)fn->c.f));\n    setintfield(L, t, \"upvalues\", fn->c.nupvalues);\n  }\n  return 1;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Check trace argument. Must not throw for non-existent trace numbers. */\n", "func_signal": "static GCtrace *jit_checktrace(lua_State *L)", "code": "{\n  TraceNo tr = (TraceNo)lj_lib_checkint(L, 1);\n  jit_State *J = L2J(L);\n  if (tr > 0 && tr < J->sizetrace)\n    return traceref(J, tr);\n  return NULL;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Initialize JIT compiler. */\n", "func_signal": "static void jit_init(lua_State *L)", "code": "{\n  uint32_t flags = jit_cpudetect(L);\n#if LJ_HASJIT\n  jit_State *J = L2J(L);\n#if LJ_TARGET_X86\n  /* Silently turn off the JIT compiler on CPUs without SSE2. */\n  if ((flags & JIT_F_SSE2))\n#endif\n    J->flags = flags | JIT_F_ON | JIT_F_OPT_DEFAULT;\n  memcpy(J->param, jit_param_default, sizeof(J->param));\n  lj_dispatch_update(G(L));\n#else\n  UNUSED(flags);\n#endif\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local snap = jit.util.tracesnap(tr, sn) */\n", "func_signal": "LJLIB_CF(jit_util_tracesnap)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  SnapNo sn = (SnapNo)lj_lib_checkint(L, 2);\n  if (T && sn < T->nsnap) {\n    SnapShot *snap = &T->snap[sn];\n    SnapEntry *map = &T->snapmap[snap->mapofs];\n    MSize n, nent = snap->nent;\n    GCtab *t;\n    lua_createtable(L, nent+2, 0);\n    t = tabV(L->top-1);\n    setintV(lj_tab_setint(L, t, 0), (int32_t)snap->ref - REF_BIAS);\n    setintV(lj_tab_setint(L, t, 1), (int32_t)snap->nslots);\n    for (n = 0; n < nent; n++)\n      setintV(lj_tab_setint(L, t, (int32_t)(n+2)), (int32_t)map[n]);\n    setintV(lj_tab_setint(L, t, (int32_t)(nent+2)), (int32_t)SNAP(255, 0, 0));\n    return 1;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* Arch-dependent CPU detection. */\n", "func_signal": "static uint32_t jit_cpudetect(lua_State *L)", "code": "{\n  uint32_t flags = 0;\n#if LJ_TARGET_X86ORX64\n  uint32_t vendor[4];\n  uint32_t features[4];\n  if (lj_vm_cpuid(0, vendor) && lj_vm_cpuid(1, features)) {\n#if !LJ_HASJIT\n#define JIT_F_CMOV\t1\n#define JIT_F_SSE2\t2\n#endif\n    flags |= ((features[3] >> 15)&1) * JIT_F_CMOV;\n    flags |= ((features[3] >> 26)&1) * JIT_F_SSE2;\n#if LJ_HASJIT\n    flags |= ((features[2] >> 19)&1) * JIT_F_SSE4_1;\n    if (vendor[2] == 0x6c65746e) {  /* Intel. */\n      if ((features[0] & 0x0ff00f00) == 0x00000f00)  /* P4. */\n\tflags |= JIT_F_P4;  /* Currently unused. */\n      else if ((features[0] & 0x0fff0ff0) == 0x000106c0)  /* Atom. */\n\tflags |= JIT_F_LEA_AGU;\n    } else if (vendor[2] == 0x444d4163) {  /* AMD. */\n      uint32_t fam = (features[0] & 0x0ff00f00);\n      if (fam == 0x00000f00)  /* K8. */\n\tflags |= JIT_F_SPLIT_XMM;\n      if (fam >= 0x00000f00)  /* K8, K10. */\n\tflags |= JIT_F_PREFER_IMUL;\n    }\n#endif\n  }\n  /* Check for required instruction set support on x86 (unnecessary on x64). */\n#if LJ_TARGET_X86\n#if !defined(LUAJIT_CPU_NOCMOV)\n  if (!(flags & JIT_F_CMOV))\n    luaL_error(L, \"Ancient CPU lacks CMOV support (recompile with -DLUAJIT_CPU_NOCMOV)\");\n#endif\n#if defined(LUAJIT_CPU_SSE2)\n  if (!(flags & JIT_F_SSE2))\n    luaL_error(L, \"CPU does not support SSE2 (recompile without -DLUAJIT_CPU_SSE2)\");\n#endif\n#endif\n#elif LJ_TARGET_PPC\n  /* Nothing to do. */\n#else\n#error \"Missing CPU detection for this architecture\"\n#endif\n  UNUSED(L);\n  return flags;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local ins, m = jit.util.funcbc(func, pc) */\n", "func_signal": "LJLIB_CF(jit_util_funcbc)", "code": "{\n  GCproto *pt = check_Lproto(L, 0);\n  BCPos pc = (BCPos)lj_lib_checkint(L, 2);\n  if (pc < pt->sizebc) {\n    BCIns ins = proto_bc(pt)[pc];\n    BCOp op = bc_op(ins);\n    lua_assert(op < BC__MAX);\n    setintV(L->top, ins);\n    setintV(L->top+1, lj_bc_mode[op]);\n    L->top += 2;\n    return 2;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local info = jit.util.traceinfo(tr) */\n", "func_signal": "LJLIB_CF(jit_util_traceinfo)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  if (T) {\n    GCtab *t;\n    lua_createtable(L, 0, 4);  /* Increment hash size if fields are added. */\n    t = tabV(L->top-1);\n    setintfield(L, t, \"nins\", (int32_t)T->nins - REF_BIAS - 1);\n    setintfield(L, t, \"nk\", REF_BIAS - (int32_t)T->nk);\n    setintfield(L, t, \"link\", T->link);\n    setintfield(L, t, \"nexit\", T->nsnap);\n    /* There are many more fields. Add them only when needed. */\n    return 1;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/* local k, t [, slot] = jit.util.tracek(tr, idx) */\n", "func_signal": "LJLIB_CF(jit_util_tracek)", "code": "{\n  GCtrace *T = jit_checktrace(L);\n  IRRef ref = (IRRef)lj_lib_checkint(L, 2) + REF_BIAS;\n  if (T && ref >= T->nk && ref < REF_BIAS) {\n    IRIns *ir = &T->ir[ref];\n    int32_t slot = -1;\n    if (ir->o == IR_KSLOT) {\n      slot = ir->op2;\n      ir = &T->ir[ir->op1];\n    }\n    lj_ir_kvalue(L, L->top-2, ir);\n    setintV(L->top-1, (int32_t)irt_type(ir->t));\n    if (slot == -1)\n      return 2;\n    setintV(L->top++, slot);\n    return 3;\n  }\n  return 0;\n}", "path": "src\\lib_jit.c", "repo_name": "fanf2/luajit-2", "stars": 8, "license": "other", "language": "c", "size": 2432}
{"docstring": "/**\n * Experimental Filter 1\n * will not damage linear gradients\n * Flat blocks should look like they were passed through the (1,1,2,2,4,2,2,1,1) 9-Tap filter\n * can only smooth blocks at the expected locations (it cannot smooth them if they did move)\n * MMX2 version does correct clipping C version does not\n */\n", "func_signal": "static inline void RENAME(vertX1Filter)(uint8_t *src, int stride, PPContext *co)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= stride*3;\n\n    asm volatile(\n        \"pxor %%mm7, %%mm7                      \\n\\t\" // 0\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_c\"      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1\n        \"movq (%%\"REG_a\", %1, 2), %%mm0         \\n\\t\" // line 3\n        \"movq (%0, %1, 4), %%mm1                \\n\\t\" // line 4\n        \"movq %%mm1, %%mm2                      \\n\\t\" // line 4\n        \"psubusb %%mm0, %%mm1                   \\n\\t\"\n        \"psubusb %%mm2, %%mm0                   \\n\\t\"\n        \"por %%mm1, %%mm0                       \\n\\t\" // |l2 - l3|\n        \"movq (%%\"REG_c\"), %%mm3                \\n\\t\" // line 5\n        \"movq (%%\"REG_c\", %1), %%mm4            \\n\\t\" // line 6\n        \"movq %%mm3, %%mm5                      \\n\\t\" // line 5\n        \"psubusb %%mm4, %%mm3                   \\n\\t\"\n        \"psubusb %%mm5, %%mm4                   \\n\\t\"\n        \"por %%mm4, %%mm3                       \\n\\t\" // |l5 - l6|\n        PAVGB(%%mm3, %%mm0)                           // (|l2 - l3| + |l5 - l6|)/2\n        \"movq %%mm2, %%mm1                      \\n\\t\" // line 4\n        \"psubusb %%mm5, %%mm2                   \\n\\t\"\n        \"movq %%mm2, %%mm4                      \\n\\t\"\n        \"pcmpeqb %%mm7, %%mm2                   \\n\\t\" // (l4 - l5) <= 0 ? -1 : 0\n        \"psubusb %%mm1, %%mm5                   \\n\\t\"\n        \"por %%mm5, %%mm4                       \\n\\t\" // |l4 - l5|\n        \"psubusb %%mm0, %%mm4                   \\n\\t\" //d = MAX(0, |l4-l5| - (|l2-l3| + |l5-l6|)/2)\n        \"movq %%mm4, %%mm3                      \\n\\t\" // d\n        \"movq %2, %%mm0                         \\n\\t\"\n        \"paddusb %%mm0, %%mm0                   \\n\\t\"\n        \"psubusb %%mm0, %%mm4                   \\n\\t\"\n        \"pcmpeqb %%mm7, %%mm4                   \\n\\t\" // d <= QP ? -1 : 0\n        \"psubusb \"MANGLE(b01)\", %%mm3           \\n\\t\"\n        \"pand %%mm4, %%mm3                      \\n\\t\" // d <= QP ? d : 0\n\n        PAVGB(%%mm7, %%mm3)                           // d/2\n        \"movq %%mm3, %%mm1                      \\n\\t\" // d/2\n        PAVGB(%%mm7, %%mm3)                           // d/4\n        PAVGB(%%mm1, %%mm3)                           // 3*d/8\n\n        \"movq (%0, %1, 4), %%mm0                \\n\\t\" // line 4\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l4-1 : l4\n        \"psubusb %%mm3, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%0, %1, 4)                \\n\\t\" // line 4\n\n        \"movq (%%\"REG_c\"), %%mm0                \\n\\t\" // line 5\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l5-1 : l5\n        \"paddusb %%mm3, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%%\"REG_c\")                \\n\\t\" // line 5\n\n        PAVGB(%%mm7, %%mm1)                           // d/4\n\n        \"movq (%%\"REG_a\", %1, 2), %%mm0         \\n\\t\" // line 3\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l4-1 : l4\n        \"psubusb %%mm1, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%%\"REG_a\", %1, 2)         \\n\\t\" // line 3\n\n        \"movq (%%\"REG_c\", %1), %%mm0            \\n\\t\" // line 6\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l5-1 : l5\n        \"paddusb %%mm1, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%%\"REG_c\", %1)            \\n\\t\" // line 6\n\n        PAVGB(%%mm7, %%mm1)                           // d/8\n\n        \"movq (%%\"REG_a\", %1), %%mm0            \\n\\t\" // line 2\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l2-1 : l2\n        \"psubusb %%mm1, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%%\"REG_a\", %1)            \\n\\t\" // line 2\n\n        \"movq (%%\"REG_c\", %1, 2), %%mm0         \\n\\t\" // line 7\n        \"pxor %%mm2, %%mm0                      \\n\\t\" //(l4 - l5) <= 0 ? -l7-1 : l7\n        \"paddusb %%mm1, %%mm0                   \\n\\t\"\n        \"pxor %%mm2, %%mm0                      \\n\\t\"\n        \"movq %%mm0, (%%\"REG_c\", %1, 2)         \\n\\t\" // line 7\n\n        :\n        : \"r\" (src), \"r\" ((long)stride), \"m\" (co->pQPb)\n        : \"%\"REG_a, \"%\"REG_c\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n    const int l1= stride;\n    const int l2= stride + l1;\n    const int l3= stride + l2;\n    const int l4= stride + l3;\n    const int l5= stride + l4;\n    const int l6= stride + l5;\n    const int l7= stride + l6;\n//    const int l8= stride + l7;\n//    const int l9= stride + l8;\n    int x;\n\n    src+= stride*3;\n    for(x=0; x<BLOCK_SIZE; x++){\n        int a= src[l3] - src[l4];\n        int b= src[l4] - src[l5];\n        int c= src[l5] - src[l6];\n\n        int d= FFABS(b) - ((FFABS(a) + FFABS(c))>>1);\n        d= FFMAX(d, 0);\n\n        if(d < co->QP*2){\n            int v = d * FFSIGN(-b);\n\n            src[l2] +=v>>3;\n            src[l3] +=v>>2;\n            src[l4] +=(3*v)>>3;\n            src[l5] -=(3*v)>>3;\n            src[l6] -=v>>2;\n            src[l7] -=v>>3;\n        }\n        src++;\n    }\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/* These functions were the base for the optimized assembler routines,\n   and remain here for documentation purposes.  */\n", "func_signal": "static void put_pixels_clamped_mvi(const DCTELEM *block, uint8_t *pixels,\n                                   int line_size)", "code": "{\n    int i = 8;\n    uint64_t clampmask = zap(-1, 0xaa); /* 0x00ff00ff00ff00ff */\n\n    do {\n        uint64_t shorts0, shorts1;\n\n        shorts0 = ldq(block);\n        shorts0 = maxsw4(shorts0, 0);\n        shorts0 = minsw4(shorts0, clampmask);\n        stl(pkwb(shorts0), pixels);\n\n        shorts1 = ldq(block + 4);\n        shorts1 = maxsw4(shorts1, 0);\n        shorts1 = minsw4(shorts1, clampmask);\n        stl(pkwb(shorts1), pixels + 4);\n\n        pixels += line_size;\n        block += 8;\n    } while (--i);\n}", "path": "ffmpeg-orig\\libavcodec\\alpha\\dsputil_alpha.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by applying a median filter to every second line.\n * will be called for every 8x8 block and can read & write from line 4-15,\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n */\n", "func_signal": "static inline void RENAME(deInterlaceMedian)(uint8_t src[], int stride)", "code": "{\n#ifdef HAVE_MMX\n    src+= 4*stride;\n#ifdef HAVE_MMX2\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1\n\n        \"movq (%0), %%mm0                       \\n\\t\" //\n        \"movq (%%\"REG_a\", %1), %%mm2            \\n\\t\" //\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\" //\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"pmaxub %%mm1, %%mm0                    \\n\\t\" //\n        \"pminub %%mm3, %%mm1                    \\n\\t\" //\n        \"pmaxub %%mm2, %%mm1                    \\n\\t\" //\n        \"pminub %%mm1, %%mm0                    \\n\\t\"\n        \"movq %%mm0, (%%\"REG_a\")                \\n\\t\"\n\n        \"movq (%0, %1, 4), %%mm0                \\n\\t\" //\n        \"movq (%%\"REG_a\", %1, 2), %%mm1         \\n\\t\" //\n        \"movq %%mm2, %%mm3                      \\n\\t\"\n        \"pmaxub %%mm1, %%mm2                    \\n\\t\" //\n        \"pminub %%mm3, %%mm1                    \\n\\t\" //\n        \"pmaxub %%mm0, %%mm1                    \\n\\t\" //\n        \"pminub %%mm1, %%mm2                    \\n\\t\"\n        \"movq %%mm2, (%%\"REG_a\", %1, 2)         \\n\\t\"\n\n        \"movq (%%\"REG_d\"), %%mm2                \\n\\t\" //\n        \"movq (%%\"REG_d\", %1), %%mm1            \\n\\t\" //\n        \"movq %%mm2, %%mm3                      \\n\\t\"\n        \"pmaxub %%mm0, %%mm2                    \\n\\t\" //\n        \"pminub %%mm3, %%mm0                    \\n\\t\" //\n        \"pmaxub %%mm1, %%mm0                    \\n\\t\" //\n        \"pminub %%mm0, %%mm2                    \\n\\t\"\n        \"movq %%mm2, (%%\"REG_d\")                \\n\\t\"\n\n        \"movq (%%\"REG_d\", %1, 2), %%mm2         \\n\\t\" //\n        \"movq (%0, %1, 8), %%mm0                \\n\\t\" //\n        \"movq %%mm2, %%mm3                      \\n\\t\"\n        \"pmaxub %%mm0, %%mm2                    \\n\\t\" //\n        \"pminub %%mm3, %%mm0                    \\n\\t\" //\n        \"pmaxub %%mm1, %%mm0                    \\n\\t\" //\n        \"pminub %%mm0, %%mm2                    \\n\\t\"\n        \"movq %%mm2, (%%\"REG_d\", %1, 2)         \\n\\t\"\n\n\n        : : \"r\" (src), \"r\" ((long)stride)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n\n#else // MMX without MMX2\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1\n        \"pxor %%mm7, %%mm7                      \\n\\t\"\n\n#define REAL_MEDIAN(a,b,c)\\\n        \"movq \" #a \", %%mm0                     \\n\\t\"\\\n        \"movq \" #b \", %%mm2                     \\n\\t\"\\\n        \"movq \" #c \", %%mm1                     \\n\\t\"\\\n        \"movq %%mm0, %%mm3                      \\n\\t\"\\\n        \"movq %%mm1, %%mm4                      \\n\\t\"\\\n        \"movq %%mm2, %%mm5                      \\n\\t\"\\\n        \"psubusb %%mm1, %%mm3                   \\n\\t\"\\\n        \"psubusb %%mm2, %%mm4                   \\n\\t\"\\\n        \"psubusb %%mm0, %%mm5                   \\n\\t\"\\\n        \"pcmpeqb %%mm7, %%mm3                   \\n\\t\"\\\n        \"pcmpeqb %%mm7, %%mm4                   \\n\\t\"\\\n        \"pcmpeqb %%mm7, %%mm5                   \\n\\t\"\\\n        \"movq %%mm3, %%mm6                      \\n\\t\"\\\n        \"pxor %%mm4, %%mm3                      \\n\\t\"\\\n        \"pxor %%mm5, %%mm4                      \\n\\t\"\\\n        \"pxor %%mm6, %%mm5                      \\n\\t\"\\\n        \"por %%mm3, %%mm1                       \\n\\t\"\\\n        \"por %%mm4, %%mm2                       \\n\\t\"\\\n        \"por %%mm5, %%mm0                       \\n\\t\"\\\n        \"pand %%mm2, %%mm0                      \\n\\t\"\\\n        \"pand %%mm1, %%mm0                      \\n\\t\"\\\n        \"movq %%mm0, \" #b \"                     \\n\\t\"\n#define MEDIAN(a,b,c)  REAL_MEDIAN(a,b,c)\n\nMEDIAN((%0)        , (%%REGa)       , (%%REGa, %1))\nMEDIAN((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4))\nMEDIAN((%0, %1, 4) , (%%REGd)       , (%%REGd, %1))\nMEDIAN((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8))\n\n        : : \"r\" (src), \"r\" ((long)stride)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n#endif //HAVE_MMX2\n#else //HAVE_MMX\n    int x, y;\n    src+= 4*stride;\n    // FIXME - there should be a way to do a few columns in parallel like w/mmx\n    for(x=0; x<8; x++){\n        uint8_t *colsrc = src;\n        for (y=0; y<4; y++){\n            int a, b, c, d, e, f;\n            a = colsrc[0       ];\n            b = colsrc[stride  ];\n            c = colsrc[stride*2];\n            d = (a-b)>>31;\n            e = (b-c)>>31;\n            f = (c-a)>>31;\n            colsrc[stride  ] = (a|(d^f)) & (b|(d^e)) & (c|(e^f));\n            colsrc += stride*2;\n        }\n        src++;\n    }\n#endif //HAVE_MMX\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Check if the middle 8x8 Block in the given 8x16 block is flat\n */\n", "func_signal": "static inline int RENAME(vertClassify)(uint8_t src[], int stride, PPContext *c)", "code": "{\n    int numEq= 0, dcOk;\n    src+= stride*4; // src points to begin of the 8x8 Block\n    asm volatile(\n        \"movq %0, %%mm7                         \\n\\t\"\n        \"movq %1, %%mm6                         \\n\\t\"\n        : : \"m\" (c->mmxDcOffset[c->nonBQP]),  \"m\" (c->mmxDcThreshold[c->nonBQP])\n        );\n\n    asm volatile(\n        \"lea (%2, %3), %%\"REG_a\"                \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %1      eax     eax+%2  eax+2%2 %1+4%2  ecx     ecx+%2  ecx+2%2 %1+8%2  ecx+4%2\n\n        \"movq (%2), %%mm0                       \\n\\t\"\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\"\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"movq %%mm0, %%mm4                      \\n\\t\"\n        PMAXUB(%%mm1, %%mm4)\n        PMINUB(%%mm1, %%mm3, %%mm5)\n        \"psubb %%mm1, %%mm0                     \\n\\t\" // mm0 = differnece\n        \"paddb %%mm7, %%mm0                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm0                   \\n\\t\"\n\n        \"movq (%%\"REG_a\",%3), %%mm2             \\n\\t\"\n        PMAXUB(%%mm2, %%mm4)\n        PMINUB(%%mm2, %%mm3, %%mm5)\n        \"psubb %%mm2, %%mm1                     \\n\\t\"\n        \"paddb %%mm7, %%mm1                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm1                   \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n\n        \"movq (%%\"REG_a\", %3, 2), %%mm1         \\n\\t\"\n        PMAXUB(%%mm1, %%mm4)\n        PMINUB(%%mm1, %%mm3, %%mm5)\n        \"psubb %%mm1, %%mm2                     \\n\\t\"\n        \"paddb %%mm7, %%mm2                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm2                   \\n\\t\"\n        \"paddb %%mm2, %%mm0                     \\n\\t\"\n\n        \"lea (%%\"REG_a\", %3, 4), %%\"REG_a\"      \\n\\t\"\n\n        \"movq (%2, %3, 4), %%mm2                \\n\\t\"\n        PMAXUB(%%mm2, %%mm4)\n        PMINUB(%%mm2, %%mm3, %%mm5)\n        \"psubb %%mm2, %%mm1                     \\n\\t\"\n        \"paddb %%mm7, %%mm1                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm1                   \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\"\n        PMAXUB(%%mm1, %%mm4)\n        PMINUB(%%mm1, %%mm3, %%mm5)\n        \"psubb %%mm1, %%mm2                     \\n\\t\"\n        \"paddb %%mm7, %%mm2                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm2                   \\n\\t\"\n        \"paddb %%mm2, %%mm0                     \\n\\t\"\n\n        \"movq (%%\"REG_a\", %3), %%mm2            \\n\\t\"\n        PMAXUB(%%mm2, %%mm4)\n        PMINUB(%%mm2, %%mm3, %%mm5)\n        \"psubb %%mm2, %%mm1                     \\n\\t\"\n        \"paddb %%mm7, %%mm1                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm1                   \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n\n        \"movq (%%\"REG_a\", %3, 2), %%mm1         \\n\\t\"\n        PMAXUB(%%mm1, %%mm4)\n        PMINUB(%%mm1, %%mm3, %%mm5)\n        \"psubb %%mm1, %%mm2                     \\n\\t\"\n        \"paddb %%mm7, %%mm2                     \\n\\t\"\n        \"pcmpgtb %%mm6, %%mm2                   \\n\\t\"\n        \"paddb %%mm2, %%mm0                     \\n\\t\"\n        \"psubusb %%mm3, %%mm4                   \\n\\t\"\n\n        \"                                       \\n\\t\"\n#ifdef HAVE_MMX2\n        \"pxor %%mm7, %%mm7                      \\n\\t\"\n        \"psadbw %%mm7, %%mm0                    \\n\\t\"\n#else\n        \"movq %%mm0, %%mm1                      \\n\\t\"\n        \"psrlw $8, %%mm0                        \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n        \"movq %%mm0, %%mm1                      \\n\\t\"\n        \"psrlq $16, %%mm0                       \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n        \"movq %%mm0, %%mm1                      \\n\\t\"\n        \"psrlq $32, %%mm0                       \\n\\t\"\n        \"paddb %%mm1, %%mm0                     \\n\\t\"\n#endif\n        \"movq %4, %%mm7                         \\n\\t\" // QP,..., QP\n        \"paddusb %%mm7, %%mm7                   \\n\\t\" // 2QP ... 2QP\n        \"psubusb %%mm7, %%mm4                   \\n\\t\" // Diff <= 2QP -> 0\n        \"packssdw %%mm4, %%mm4                  \\n\\t\"\n        \"movd %%mm0, %0                         \\n\\t\"\n        \"movd %%mm4, %1                         \\n\\t\"\n\n        : \"=r\" (numEq), \"=r\" (dcOk)\n        : \"r\" (src), \"r\" ((long)stride), \"m\" (c->pQPb)\n        : \"%\"REG_a\n        );\n\n    numEq= (-numEq) &0xFF;\n    if(numEq > c->ppMode.flatnessThreshold){\n        if(dcOk) return 0;\n        else     return 1;\n    }else{\n        return 2;\n    }\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/** initialize 8svx decoder */\n", "func_signal": "static av_cold int eightsvx_decode_init(AVCodecContext *avctx)", "code": "{\n    EightSvxContext *esc = avctx->priv_data;\n\n    switch(avctx->codec->id) {\n        case CODEC_ID_8SVX_FIB:\n          esc->table = fibonacci;\n          break;\n        case CODEC_ID_8SVX_EXP:\n          esc->table = exponential;\n          break;\n        default:\n          return -1;\n    }\n    return 0;\n}", "path": "ffmpeg\\libavcodec\\8svx.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * transposes and shift the given 8x8 Block into dst1 and dst2\n */\n", "func_signal": "static inline void RENAME(transpose1)(uint8_t *dst1, uint8_t *dst2, uint8_t *src, int srcStride)", "code": "{\n    asm(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1\n        \"movq (%0), %%mm0                       \\n\\t\" // 12345678\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\" // abcdefgh\n        \"movq %%mm0, %%mm2                      \\n\\t\" // 12345678\n        \"punpcklbw %%mm1, %%mm0                 \\n\\t\" // 1a2b3c4d\n        \"punpckhbw %%mm1, %%mm2                 \\n\\t\" // 5e6f7g8h\n\n        \"movq (%%\"REG_a\", %1), %%mm1            \\n\\t\"\n        \"movq (%%\"REG_a\", %1, 2), %%mm3         \\n\\t\"\n        \"movq %%mm1, %%mm4                      \\n\\t\"\n        \"punpcklbw %%mm3, %%mm1                 \\n\\t\"\n        \"punpckhbw %%mm3, %%mm4                 \\n\\t\"\n\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"punpcklwd %%mm1, %%mm0                 \\n\\t\"\n        \"punpckhwd %%mm1, %%mm3                 \\n\\t\"\n        \"movq %%mm2, %%mm1                      \\n\\t\"\n        \"punpcklwd %%mm4, %%mm2                 \\n\\t\"\n        \"punpckhwd %%mm4, %%mm1                 \\n\\t\"\n\n        \"movd %%mm0, 128(%2)                    \\n\\t\"\n        \"psrlq $32, %%mm0                       \\n\\t\"\n        \"movd %%mm0, 144(%2)                    \\n\\t\"\n        \"movd %%mm3, 160(%2)                    \\n\\t\"\n        \"psrlq $32, %%mm3                       \\n\\t\"\n        \"movd %%mm3, 176(%2)                    \\n\\t\"\n        \"movd %%mm3, 48(%3)                     \\n\\t\"\n        \"movd %%mm2, 192(%2)                    \\n\\t\"\n        \"movd %%mm2, 64(%3)                     \\n\\t\"\n        \"psrlq $32, %%mm2                       \\n\\t\"\n        \"movd %%mm2, 80(%3)                     \\n\\t\"\n        \"movd %%mm1, 96(%3)                     \\n\\t\"\n        \"psrlq $32, %%mm1                       \\n\\t\"\n        \"movd %%mm1, 112(%3)                    \\n\\t\"\n\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_a\"      \\n\\t\"\n\n        \"movq (%0, %1, 4), %%mm0                \\n\\t\" // 12345678\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\" // abcdefgh\n        \"movq %%mm0, %%mm2                      \\n\\t\" // 12345678\n        \"punpcklbw %%mm1, %%mm0                 \\n\\t\" // 1a2b3c4d\n        \"punpckhbw %%mm1, %%mm2                 \\n\\t\" // 5e6f7g8h\n\n        \"movq (%%\"REG_a\", %1), %%mm1            \\n\\t\"\n        \"movq (%%\"REG_a\", %1, 2), %%mm3         \\n\\t\"\n        \"movq %%mm1, %%mm4                      \\n\\t\"\n        \"punpcklbw %%mm3, %%mm1                 \\n\\t\"\n        \"punpckhbw %%mm3, %%mm4                 \\n\\t\"\n\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"punpcklwd %%mm1, %%mm0                 \\n\\t\"\n        \"punpckhwd %%mm1, %%mm3                 \\n\\t\"\n        \"movq %%mm2, %%mm1                      \\n\\t\"\n        \"punpcklwd %%mm4, %%mm2                 \\n\\t\"\n        \"punpckhwd %%mm4, %%mm1                 \\n\\t\"\n\n        \"movd %%mm0, 132(%2)                    \\n\\t\"\n        \"psrlq $32, %%mm0                       \\n\\t\"\n        \"movd %%mm0, 148(%2)                    \\n\\t\"\n        \"movd %%mm3, 164(%2)                    \\n\\t\"\n        \"psrlq $32, %%mm3                       \\n\\t\"\n        \"movd %%mm3, 180(%2)                    \\n\\t\"\n        \"movd %%mm3, 52(%3)                     \\n\\t\"\n        \"movd %%mm2, 196(%2)                    \\n\\t\"\n        \"movd %%mm2, 68(%3)                     \\n\\t\"\n        \"psrlq $32, %%mm2                       \\n\\t\"\n        \"movd %%mm2, 84(%3)                     \\n\\t\"\n        \"movd %%mm1, 100(%3)                    \\n\\t\"\n        \"psrlq $32, %%mm1                       \\n\\t\"\n        \"movd %%mm1, 116(%3)                    \\n\\t\"\n\n\n        :: \"r\" (src), \"r\" ((long)srcStride), \"r\" (dst1), \"r\" (dst2)\n        : \"%\"REG_a\n    );\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * transposes the given 8x8 block\n */\n", "func_signal": "static inline void RENAME(transpose2)(uint8_t *dst, int dstStride, uint8_t *src)", "code": "{\n    asm(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\",%1,4), %%\"REG_d\"        \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1\n        \"movq (%2), %%mm0                       \\n\\t\" // 12345678\n        \"movq 16(%2), %%mm1                     \\n\\t\" // abcdefgh\n        \"movq %%mm0, %%mm2                      \\n\\t\" // 12345678\n        \"punpcklbw %%mm1, %%mm0                 \\n\\t\" // 1a2b3c4d\n        \"punpckhbw %%mm1, %%mm2                 \\n\\t\" // 5e6f7g8h\n\n        \"movq 32(%2), %%mm1                     \\n\\t\"\n        \"movq 48(%2), %%mm3                     \\n\\t\"\n        \"movq %%mm1, %%mm4                      \\n\\t\"\n        \"punpcklbw %%mm3, %%mm1                 \\n\\t\"\n        \"punpckhbw %%mm3, %%mm4                 \\n\\t\"\n\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"punpcklwd %%mm1, %%mm0                 \\n\\t\"\n        \"punpckhwd %%mm1, %%mm3                 \\n\\t\"\n        \"movq %%mm2, %%mm1                      \\n\\t\"\n        \"punpcklwd %%mm4, %%mm2                 \\n\\t\"\n        \"punpckhwd %%mm4, %%mm1                 \\n\\t\"\n\n        \"movd %%mm0, (%0)                       \\n\\t\"\n        \"psrlq $32, %%mm0                       \\n\\t\"\n        \"movd %%mm0, (%%\"REG_a\")                \\n\\t\"\n        \"movd %%mm3, (%%\"REG_a\", %1)            \\n\\t\"\n        \"psrlq $32, %%mm3                       \\n\\t\"\n        \"movd %%mm3, (%%\"REG_a\", %1, 2)         \\n\\t\"\n        \"movd %%mm2, (%0, %1, 4)                \\n\\t\"\n        \"psrlq $32, %%mm2                       \\n\\t\"\n        \"movd %%mm2, (%%\"REG_d\")                \\n\\t\"\n        \"movd %%mm1, (%%\"REG_d\", %1)            \\n\\t\"\n        \"psrlq $32, %%mm1                       \\n\\t\"\n        \"movd %%mm1, (%%\"REG_d\", %1, 2)         \\n\\t\"\n\n\n        \"movq 64(%2), %%mm0                     \\n\\t\" // 12345678\n        \"movq 80(%2), %%mm1                     \\n\\t\" // abcdefgh\n        \"movq %%mm0, %%mm2                      \\n\\t\" // 12345678\n        \"punpcklbw %%mm1, %%mm0                 \\n\\t\" // 1a2b3c4d\n        \"punpckhbw %%mm1, %%mm2                 \\n\\t\" // 5e6f7g8h\n\n        \"movq 96(%2), %%mm1                     \\n\\t\"\n        \"movq 112(%2), %%mm3                    \\n\\t\"\n        \"movq %%mm1, %%mm4                      \\n\\t\"\n        \"punpcklbw %%mm3, %%mm1                 \\n\\t\"\n        \"punpckhbw %%mm3, %%mm4                 \\n\\t\"\n\n        \"movq %%mm0, %%mm3                      \\n\\t\"\n        \"punpcklwd %%mm1, %%mm0                 \\n\\t\"\n        \"punpckhwd %%mm1, %%mm3                 \\n\\t\"\n        \"movq %%mm2, %%mm1                      \\n\\t\"\n        \"punpcklwd %%mm4, %%mm2                 \\n\\t\"\n        \"punpckhwd %%mm4, %%mm1                 \\n\\t\"\n\n        \"movd %%mm0, 4(%0)                      \\n\\t\"\n        \"psrlq $32, %%mm0                       \\n\\t\"\n        \"movd %%mm0, 4(%%\"REG_a\")               \\n\\t\"\n        \"movd %%mm3, 4(%%\"REG_a\", %1)           \\n\\t\"\n        \"psrlq $32, %%mm3                       \\n\\t\"\n        \"movd %%mm3, 4(%%\"REG_a\", %1, 2)        \\n\\t\"\n        \"movd %%mm2, 4(%0, %1, 4)               \\n\\t\"\n        \"psrlq $32, %%mm2                       \\n\\t\"\n        \"movd %%mm2, 4(%%\"REG_d\")               \\n\\t\"\n        \"movd %%mm1, 4(%%\"REG_d\", %1)           \\n\\t\"\n        \"psrlq $32, %%mm1                       \\n\\t\"\n        \"movd %%mm1, 4(%%\"REG_d\", %1, 2)        \\n\\t\"\n\n        :: \"r\" (dst), \"r\" ((long)dstStride), \"r\" (src)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/** discard data from the fifo */\n", "func_signal": "void av_fifo_drain(AVFifoBuffer *f, int size)", "code": "{\n    f->rptr += size;\n    if (f->rptr >= f->end)\n        f->rptr -= f->end - f->buffer;\n}", "path": "ffmpeg\\libavutil\\fifo.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by cubic interpolating every second line.\n * will be called for every 8x8 block and can read & write from line 4-15\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n * this filter will read lines 3-15 and write 7-13\n */\n", "func_signal": "static inline void RENAME(deInterlaceInterpolateCubic)(uint8_t src[], int stride)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= stride*3;\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n        \"lea (%%\"REG_d\", %1, 4), %%\"REG_c\"      \\n\\t\"\n        \"add %1, %%\"REG_c\"                      \\n\\t\"\n        \"pxor %%mm7, %%mm7                      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9       10\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx\n\n#define REAL_DEINT_CUBIC(a,b,c,d,e)\\\n        \"movq \" #a \", %%mm0                     \\n\\t\"\\\n        \"movq \" #b \", %%mm1                     \\n\\t\"\\\n        \"movq \" #d \", %%mm2                     \\n\\t\"\\\n        \"movq \" #e \", %%mm3                     \\n\\t\"\\\n        PAVGB(%%mm2, %%mm1)                             /* (b+d) /2 */\\\n        PAVGB(%%mm3, %%mm0)                             /* a(a+e) /2 */\\\n        \"movq %%mm0, %%mm2                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm0                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm2                 \\n\\t\"\\\n        \"movq %%mm1, %%mm3                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm1                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm3                 \\n\\t\"\\\n        \"psubw %%mm1, %%mm0                     \\n\\t\"   /* L(a+e - (b+d))/2 */\\\n        \"psubw %%mm3, %%mm2                     \\n\\t\"   /* H(a+e - (b+d))/2 */\\\n        \"psraw $3, %%mm0                        \\n\\t\"   /* L(a+e - (b+d))/16 */\\\n        \"psraw $3, %%mm2                        \\n\\t\"   /* H(a+e - (b+d))/16 */\\\n        \"psubw %%mm0, %%mm1                     \\n\\t\"   /* L(9b + 9d - a - e)/16 */\\\n        \"psubw %%mm2, %%mm3                     \\n\\t\"   /* H(9b + 9d - a - e)/16 */\\\n        \"packuswb %%mm3, %%mm1                  \\n\\t\"\\\n        \"movq %%mm1, \" #c \"                     \\n\\t\"\n#define DEINT_CUBIC(a,b,c,d,e)  REAL_DEINT_CUBIC(a,b,c,d,e)\n\nDEINT_CUBIC((%0)        , (%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd, %1))\nDEINT_CUBIC((%%REGa, %1), (%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%0, %1, 8))\nDEINT_CUBIC((%0, %1, 4) , (%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGc))\nDEINT_CUBIC((%%REGd, %1), (%0, %1, 8) , (%%REGd, %1, 4), (%%REGc)    , (%%REGc, %1, 2))\n\n        : : \"r\" (src), \"r\" ((long)stride)\n        : \"%\"REG_a, \"%\"REG_d, \"%\"REG_c\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    int x;\n    src+= stride*3;\n    for(x=0; x<8; x++){\n        src[stride*3] = CLIP((-src[0]        + 9*src[stride*2] + 9*src[stride*4] - src[stride*6])>>4);\n        src[stride*5] = CLIP((-src[stride*2] + 9*src[stride*4] + 9*src[stride*6] - src[stride*8])>>4);\n        src[stride*7] = CLIP((-src[stride*4] + 9*src[stride*6] + 9*src[stride*8] - src[stride*10])>>4);\n        src[stride*9] = CLIP((-src[stride*6] + 9*src[stride*8] + 9*src[stride*10] - src[stride*12])>>4);\n        src++;\n    }\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Filters array of bytes (Y or U or V values)\n */\n", "func_signal": "static void RENAME(postProcess)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,\n                                const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2)", "code": "{\n    DECLARE_ALIGNED(8, PPContext, c)= *c2; //copy to stack for faster access\n    int x,y;\n#ifdef COMPILE_TIME_MODE\n    const int mode= COMPILE_TIME_MODE;\n#else\n    const int mode= isColor ? c.ppMode.chromMode : c.ppMode.lumMode;\n#endif\n    int black=0, white=255; // blackest black and whitest white in the picture\n    int QPCorrecture= 256*256;\n\n    int copyAhead;\n#ifdef HAVE_MMX\n    int i;\n#endif\n\n    const int qpHShift= isColor ? 4-c.hChromaSubSample : 4;\n    const int qpVShift= isColor ? 4-c.vChromaSubSample : 4;\n\n    //FIXME remove\n    uint64_t * const yHistogram= c.yHistogram;\n    uint8_t * const tempSrc= srcStride > 0 ? c.tempSrc : c.tempSrc - 23*srcStride;\n    uint8_t * const tempDst= dstStride > 0 ? c.tempDst : c.tempDst - 23*dstStride;\n    //const int mbWidth= isColor ? (width+7)>>3 : (width+15)>>4;\n\n#ifdef HAVE_MMX\n    for(i=0; i<57; i++){\n        int offset= ((i*c.ppMode.baseDcDiff)>>8) + 1;\n        int threshold= offset*2 + 1;\n        c.mmxDcOffset[i]= 0x7F - offset;\n        c.mmxDcThreshold[i]= 0x7F - threshold;\n        c.mmxDcOffset[i]*= 0x0101010101010101LL;\n        c.mmxDcThreshold[i]*= 0x0101010101010101LL;\n    }\n#endif\n\n    if(mode & CUBIC_IPOL_DEINT_FILTER) copyAhead=16;\n    else if(   (mode & LINEAR_BLEND_DEINT_FILTER)\n            || (mode & FFMPEG_DEINT_FILTER)\n            || (mode & LOWPASS5_DEINT_FILTER)) copyAhead=14;\n    else if(   (mode & V_DEBLOCK)\n            || (mode & LINEAR_IPOL_DEINT_FILTER)\n            || (mode & MEDIAN_DEINT_FILTER)\n            || (mode & V_A_DEBLOCK)) copyAhead=13;\n    else if(mode & V_X1_FILTER) copyAhead=11;\n//    else if(mode & V_RK1_FILTER) copyAhead=10;\n    else if(mode & DERING) copyAhead=9;\n    else copyAhead=8;\n\n    copyAhead-= 8;\n\n    if(!isColor){\n        uint64_t sum= 0;\n        int i;\n        uint64_t maxClipped;\n        uint64_t clipped;\n        double scale;\n\n        c.frameNum++;\n        // first frame is fscked so we ignore it\n        if(c.frameNum == 1) yHistogram[0]= width*height/64*15/256;\n\n        for(i=0; i<256; i++){\n            sum+= yHistogram[i];\n        }\n\n        /* We always get a completely black picture first. */\n        maxClipped= (uint64_t)(sum * c.ppMode.maxClippedThreshold);\n\n        clipped= sum;\n        for(black=255; black>0; black--){\n            if(clipped < maxClipped) break;\n            clipped-= yHistogram[black];\n        }\n\n        clipped= sum;\n        for(white=0; white<256; white++){\n            if(clipped < maxClipped) break;\n            clipped-= yHistogram[white];\n        }\n\n        scale= (double)(c.ppMode.maxAllowedY - c.ppMode.minAllowedY) / (double)(white-black);\n\n#ifdef HAVE_MMX2\n        c.packedYScale= (uint16_t)(scale*256.0 + 0.5);\n        c.packedYOffset= (((black*c.packedYScale)>>8) - c.ppMode.minAllowedY) & 0xFFFF;\n#else\n        c.packedYScale= (uint16_t)(scale*1024.0 + 0.5);\n        c.packedYOffset= (black - c.ppMode.minAllowedY) & 0xFFFF;\n#endif\n\n        c.packedYOffset|= c.packedYOffset<<32;\n        c.packedYOffset|= c.packedYOffset<<16;\n\n        c.packedYScale|= c.packedYScale<<32;\n        c.packedYScale|= c.packedYScale<<16;\n\n        if(mode & LEVEL_FIX)        QPCorrecture= (int)(scale*256*256 + 0.5);\n        else                        QPCorrecture= 256*256;\n    }else{\n        c.packedYScale= 0x0100010001000100LL;\n        c.packedYOffset= 0;\n        QPCorrecture= 256*256;\n    }\n\n    /* copy & deinterlace first row of blocks */\n    y=-BLOCK_SIZE;\n    {\n        const uint8_t *srcBlock= &(src[y*srcStride]);\n        uint8_t *dstBlock= tempDst + dstStride;\n\n        // From this point on it is guaranteed that we can read and write 16 lines downward\n        // finish 1 block before the next otherwise we might have a problem\n        // with the L1 Cache of the P4 ... or only a few blocks at a time or soemthing\n        for(x=0; x<width; x+=BLOCK_SIZE){\n\n#ifdef HAVE_MMX2\n/*\n            prefetchnta(srcBlock + (((x>>2)&6) + 5)*srcStride + 32);\n            prefetchnta(srcBlock + (((x>>2)&6) + 6)*srcStride + 32);\n            prefetcht0(dstBlock + (((x>>2)&6) + 5)*dstStride + 32);\n            prefetcht0(dstBlock + (((x>>2)&6) + 6)*dstStride + 32);\n*/\n\n            asm(\n                \"mov %4, %%\"REG_a\"              \\n\\t\"\n                \"shr $2, %%\"REG_a\"              \\n\\t\"\n                \"and $6, %%\"REG_a\"              \\n\\t\"\n                \"add %5, %%\"REG_a\"              \\n\\t\"\n                \"mov %%\"REG_a\", %%\"REG_d\"       \\n\\t\"\n                \"imul %1, %%\"REG_a\"             \\n\\t\"\n                \"imul %3, %%\"REG_d\"             \\n\\t\"\n                \"prefetchnta 32(%%\"REG_a\", %0)  \\n\\t\"\n                \"prefetcht0 32(%%\"REG_d\", %2)   \\n\\t\"\n                \"add %1, %%\"REG_a\"              \\n\\t\"\n                \"add %3, %%\"REG_d\"              \\n\\t\"\n                \"prefetchnta 32(%%\"REG_a\", %0)  \\n\\t\"\n                \"prefetcht0 32(%%\"REG_d\", %2)   \\n\\t\"\n                :: \"r\" (srcBlock), \"r\" ((long)srcStride), \"r\" (dstBlock), \"r\" ((long)dstStride),\n                \"g\" ((long)x), \"g\" ((long)copyAhead)\n                : \"%\"REG_a, \"%\"REG_d\n            );\n\n#elif defined(HAVE_3DNOW)\n//FIXME check if this is faster on an 3dnow chip or if it is faster without the prefetch or ...\n/*          prefetch(srcBlock + (((x>>3)&3) + 5)*srcStride + 32);\n            prefetch(srcBlock + (((x>>3)&3) + 9)*srcStride + 32);\n            prefetchw(dstBlock + (((x>>3)&3) + 5)*dstStride + 32);\n            prefetchw(dstBlock + (((x>>3)&3) + 9)*dstStride + 32);\n*/\n#endif\n\n            RENAME(blockCopy)(dstBlock + dstStride*8, dstStride,\n                              srcBlock + srcStride*8, srcStride, mode & LEVEL_FIX, &c.packedYOffset);\n\n            RENAME(duplicate)(dstBlock + dstStride*8, dstStride);\n\n            if(mode & LINEAR_IPOL_DEINT_FILTER)\n                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);\n            else if(mode & LINEAR_BLEND_DEINT_FILTER)\n                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);\n            else if(mode & MEDIAN_DEINT_FILTER)\n                RENAME(deInterlaceMedian)(dstBlock, dstStride);\n            else if(mode & CUBIC_IPOL_DEINT_FILTER)\n                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);\n            else if(mode & FFMPEG_DEINT_FILTER)\n                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);\n            else if(mode & LOWPASS5_DEINT_FILTER)\n                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);\n/*          else if(mode & CUBIC_BLEND_DEINT_FILTER)\n                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);\n*/\n            dstBlock+=8;\n            srcBlock+=8;\n        }\n        if(width==FFABS(dstStride))\n            linecpy(dst, tempDst + 9*dstStride, copyAhead, dstStride);\n        else{\n            int i;\n            for(i=0; i<copyAhead; i++){\n                memcpy(dst + i*dstStride, tempDst + (9+i)*dstStride, width);\n            }\n        }\n    }\n\n    for(y=0; y<height; y+=BLOCK_SIZE){\n        //1% speedup if these are here instead of the inner loop\n        const uint8_t *srcBlock= &(src[y*srcStride]);\n        uint8_t *dstBlock= &(dst[y*dstStride]);\n#ifdef HAVE_MMX\n        uint8_t *tempBlock1= c.tempBlocks;\n        uint8_t *tempBlock2= c.tempBlocks + 8;\n#endif\n        const int8_t *QPptr= &QPs[(y>>qpVShift)*QPStride];\n        int8_t *nonBQPptr= &c.nonBQPTable[(y>>qpVShift)*FFABS(QPStride)];\n        int QP=0;\n        /* can we mess with a 8x16 block from srcBlock/dstBlock downwards and 1 line upwards\n           if not than use a temporary buffer */\n        if(y+15 >= height){\n            int i;\n            /* copy from line (copyAhead) to (copyAhead+7) of src, these will be copied with\n               blockcopy to dst later */\n            linecpy(tempSrc + srcStride*copyAhead, srcBlock + srcStride*copyAhead,\n                    FFMAX(height-y-copyAhead, 0), srcStride);\n\n            /* duplicate last line of src to fill the void upto line (copyAhead+7) */\n            for(i=FFMAX(height-y, 8); i<copyAhead+8; i++)\n                    memcpy(tempSrc + srcStride*i, src + srcStride*(height-1), FFABS(srcStride));\n\n            /* copy up to (copyAhead+1) lines of dst (line -1 to (copyAhead-1))*/\n            linecpy(tempDst, dstBlock - dstStride, FFMIN(height-y+1, copyAhead+1), dstStride);\n\n            /* duplicate last line of dst to fill the void upto line (copyAhead) */\n            for(i=height-y+1; i<=copyAhead; i++)\n                    memcpy(tempDst + dstStride*i, dst + dstStride*(height-1), FFABS(dstStride));\n\n            dstBlock= tempDst + dstStride;\n            srcBlock= tempSrc;\n        }\n\n        // From this point on it is guaranteed that we can read and write 16 lines downward\n        // finish 1 block before the next otherwise we might have a problem\n        // with the L1 Cache of the P4 ... or only a few blocks at a time or soemthing\n        for(x=0; x<width; x+=BLOCK_SIZE){\n            const int stride= dstStride;\n#ifdef HAVE_MMX\n            uint8_t *tmpXchg;\n#endif\n            if(isColor){\n                QP= QPptr[x>>qpHShift];\n                c.nonBQP= nonBQPptr[x>>qpHShift];\n            }else{\n                QP= QPptr[x>>4];\n                QP= (QP* QPCorrecture + 256*128)>>16;\n                c.nonBQP= nonBQPptr[x>>4];\n                c.nonBQP= (c.nonBQP* QPCorrecture + 256*128)>>16;\n                yHistogram[ srcBlock[srcStride*12 + 4] ]++;\n            }\n            c.QP= QP;\n#ifdef HAVE_MMX\n            asm volatile(\n                \"movd %1, %%mm7         \\n\\t\"\n                \"packuswb %%mm7, %%mm7  \\n\\t\" // 0, 0, 0, QP, 0, 0, 0, QP\n                \"packuswb %%mm7, %%mm7  \\n\\t\" // 0,QP, 0, QP, 0,QP, 0, QP\n                \"packuswb %%mm7, %%mm7  \\n\\t\" // QP,..., QP\n                \"movq %%mm7, %0         \\n\\t\"\n                : \"=m\" (c.pQPb)\n                : \"r\" (QP)\n            );\n#endif\n\n\n#ifdef HAVE_MMX2\n/*\n            prefetchnta(srcBlock + (((x>>2)&6) + 5)*srcStride + 32);\n            prefetchnta(srcBlock + (((x>>2)&6) + 6)*srcStride + 32);\n            prefetcht0(dstBlock + (((x>>2)&6) + 5)*dstStride + 32);\n            prefetcht0(dstBlock + (((x>>2)&6) + 6)*dstStride + 32);\n*/\n\n            asm(\n                \"mov %4, %%\"REG_a\"              \\n\\t\"\n                \"shr $2, %%\"REG_a\"              \\n\\t\"\n                \"and $6, %%\"REG_a\"              \\n\\t\"\n                \"add %5, %%\"REG_a\"              \\n\\t\"\n                \"mov %%\"REG_a\", %%\"REG_d\"       \\n\\t\"\n                \"imul %1, %%\"REG_a\"             \\n\\t\"\n                \"imul %3, %%\"REG_d\"             \\n\\t\"\n                \"prefetchnta 32(%%\"REG_a\", %0)  \\n\\t\"\n                \"prefetcht0 32(%%\"REG_d\", %2)   \\n\\t\"\n                \"add %1, %%\"REG_a\"              \\n\\t\"\n                \"add %3, %%\"REG_d\"              \\n\\t\"\n                \"prefetchnta 32(%%\"REG_a\", %0)  \\n\\t\"\n                \"prefetcht0 32(%%\"REG_d\", %2)   \\n\\t\"\n                :: \"r\" (srcBlock), \"r\" ((long)srcStride), \"r\" (dstBlock), \"r\" ((long)dstStride),\n                \"g\" ((long)x), \"g\" ((long)copyAhead)\n                : \"%\"REG_a, \"%\"REG_d\n            );\n\n#elif defined(HAVE_3DNOW)\n//FIXME check if this is faster on an 3dnow chip or if it is faster without the prefetch or ...\n/*          prefetch(srcBlock + (((x>>3)&3) + 5)*srcStride + 32);\n            prefetch(srcBlock + (((x>>3)&3) + 9)*srcStride + 32);\n            prefetchw(dstBlock + (((x>>3)&3) + 5)*dstStride + 32);\n            prefetchw(dstBlock + (((x>>3)&3) + 9)*dstStride + 32);\n*/\n#endif\n\n            RENAME(blockCopy)(dstBlock + dstStride*copyAhead, dstStride,\n                              srcBlock + srcStride*copyAhead, srcStride, mode & LEVEL_FIX, &c.packedYOffset);\n\n            if(mode & LINEAR_IPOL_DEINT_FILTER)\n                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);\n            else if(mode & LINEAR_BLEND_DEINT_FILTER)\n                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);\n            else if(mode & MEDIAN_DEINT_FILTER)\n                RENAME(deInterlaceMedian)(dstBlock, dstStride);\n            else if(mode & CUBIC_IPOL_DEINT_FILTER)\n                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);\n            else if(mode & FFMPEG_DEINT_FILTER)\n                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);\n            else if(mode & LOWPASS5_DEINT_FILTER)\n                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);\n/*          else if(mode & CUBIC_BLEND_DEINT_FILTER)\n                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);\n*/\n\n            /* only deblock if we have 2 blocks */\n            if(y + 8 < height){\n                if(mode & V_X1_FILTER)\n                    RENAME(vertX1Filter)(dstBlock, stride, &c);\n                else if(mode & V_DEBLOCK){\n                    const int t= RENAME(vertClassify)(dstBlock, stride, &c);\n\n                    if(t==1)\n                        RENAME(doVertLowPass)(dstBlock, stride, &c);\n                    else if(t==2)\n                        RENAME(doVertDefFilter)(dstBlock, stride, &c);\n                }else if(mode & V_A_DEBLOCK){\n                    RENAME(do_a_deblock)(dstBlock, stride, 1, &c);\n                }\n            }\n\n#ifdef HAVE_MMX\n            RENAME(transpose1)(tempBlock1, tempBlock2, dstBlock, dstStride);\n#endif\n            /* check if we have a previous block to deblock it with dstBlock */\n            if(x - 8 >= 0){\n#ifdef HAVE_MMX\n                if(mode & H_X1_FILTER)\n                        RENAME(vertX1Filter)(tempBlock1, 16, &c);\n                else if(mode & H_DEBLOCK){\n//START_TIMER\n                    const int t= RENAME(vertClassify)(tempBlock1, 16, &c);\n//STOP_TIMER(\"dc & minmax\")\n                    if(t==1)\n                        RENAME(doVertLowPass)(tempBlock1, 16, &c);\n                    else if(t==2)\n                        RENAME(doVertDefFilter)(tempBlock1, 16, &c);\n                }else if(mode & H_A_DEBLOCK){\n                        RENAME(do_a_deblock)(tempBlock1, 16, 1, &c);\n                }\n\n                RENAME(transpose2)(dstBlock-4, dstStride, tempBlock1 + 4*16);\n\n#else\n                if(mode & H_X1_FILTER)\n                    horizX1Filter(dstBlock-4, stride, QP);\n                else if(mode & H_DEBLOCK){\n#ifdef HAVE_ALTIVEC\n                    DECLARE_ALIGNED(16, unsigned char, tempBlock[272]);\n                    transpose_16x8_char_toPackedAlign_altivec(tempBlock, dstBlock - (4 + 1), stride);\n\n                    const int t=vertClassify_altivec(tempBlock-48, 16, &c);\n                    if(t==1) {\n                        doVertLowPass_altivec(tempBlock-48, 16, &c);\n                        transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);\n                    }\n                    else if(t==2) {\n                        doVertDefFilter_altivec(tempBlock-48, 16, &c);\n                        transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);\n                    }\n#else\n                    const int t= RENAME(horizClassify)(dstBlock-4, stride, &c);\n\n                    if(t==1)\n                        RENAME(doHorizLowPass)(dstBlock-4, stride, &c);\n                    else if(t==2)\n                        RENAME(doHorizDefFilter)(dstBlock-4, stride, &c);\n#endif\n                }else if(mode & H_A_DEBLOCK){\n                    RENAME(do_a_deblock)(dstBlock-8, 1, stride, &c);\n                }\n#endif //HAVE_MMX\n                if(mode & DERING){\n                //FIXME filter first line\n                    if(y>0) RENAME(dering)(dstBlock - stride - 8, stride, &c);\n                }\n\n                if(mode & TEMP_NOISE_FILTER)\n                {\n                    RENAME(tempNoiseReducer)(dstBlock-8, stride,\n                            c.tempBlurred[isColor] + y*dstStride + x,\n                            c.tempBlurredPast[isColor] + (y>>3)*256 + (x>>3),\n                            c.ppMode.maxTmpNoise);\n                }\n            }\n\n            dstBlock+=8;\n            srcBlock+=8;\n\n#ifdef HAVE_MMX\n            tmpXchg= tempBlock1;\n            tempBlock1= tempBlock2;\n            tempBlock2 = tmpXchg;\n#endif\n        }\n\n        if(mode & DERING){\n            if(y > 0) RENAME(dering)(dstBlock - dstStride - 8, dstStride, &c);\n        }\n\n        if((mode & TEMP_NOISE_FILTER)){\n            RENAME(tempNoiseReducer)(dstBlock-8, dstStride,\n                    c.tempBlurred[isColor] + y*dstStride + x,\n                    c.tempBlurredPast[isColor] + (y>>3)*256 + (x>>3),\n                    c.ppMode.maxTmpNoise);\n        }\n\n        /* did we use a tmp buffer for the last lines*/\n        if(y+15 >= height){\n            uint8_t *dstBlock= &(dst[y*dstStride]);\n            if(width==FFABS(dstStride))\n                linecpy(dstBlock, tempDst + dstStride, height-y, dstStride);\n            else{\n                int i;\n                for(i=0; i<height-y; i++){\n                    memcpy(dstBlock + i*dstStride, tempDst + (i+1)*dstStride, width);\n                }\n            }\n        }\n/*\n        for(x=0; x<width; x+=32){\n            volatile int i;\n            i+= + dstBlock[x + 7*dstStride] + dstBlock[x + 8*dstStride]\n                + dstBlock[x + 9*dstStride] + dstBlock[x +10*dstStride]\n                + dstBlock[x +11*dstStride] + dstBlock[x +12*dstStride];\n                + dstBlock[x +13*dstStride]\n                + dstBlock[x +14*dstStride] + dstBlock[x +15*dstStride];\n        }*/\n    }\n#ifdef HAVE_3DNOW\n    asm volatile(\"femms\");\n#elif defined (HAVE_MMX)\n    asm volatile(\"emms\");\n#endif\n\n#ifdef DEBUG_BRIGHTNESS\n    if(!isColor){\n        int max=1;\n        int i;\n        for(i=0; i<256; i++)\n            if(yHistogram[i] > max) max=yHistogram[i];\n\n        for(i=1; i<256; i++){\n            int x;\n            int start=yHistogram[i-1]/(max/256+1);\n            int end=yHistogram[i]/(max/256+1);\n            int inc= end > start ? 1 : -1;\n            for(x=start; x!=end+inc; x+=inc)\n                dst[ i*dstStride + x]+=128;\n        }\n\n        for(i=0; i<100; i+=2){\n            dst[ (white)*dstStride + i]+=128;\n            dst[ (black)*dstStride + i]+=128;\n        }\n    }\n#endif\n\n    *c2= c; //copy local context back\n\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by filtering all lines with a (1 2 1) filter.\n * will be called for every 8x8 block and can read & write from line 4-15\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n * this filter will read lines 4-13 and write 4-11\n */\n", "func_signal": "static inline void RENAME(deInterlaceBlendLinear)(uint8_t src[], int stride, uint8_t *tmp)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= 4*stride;\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1\n\n        \"movq (%2), %%mm0                       \\n\\t\" // L0\n        \"movq (%%\"REG_a\"), %%mm1                \\n\\t\" // L2\n        PAVGB(%%mm1, %%mm0)                           // L0+L2\n        \"movq (%0), %%mm2                       \\n\\t\" // L1\n        PAVGB(%%mm2, %%mm0)\n        \"movq %%mm0, (%0)                       \\n\\t\"\n        \"movq (%%\"REG_a\", %1), %%mm0            \\n\\t\" // L3\n        PAVGB(%%mm0, %%mm2)                           // L1+L3\n        PAVGB(%%mm1, %%mm2)                           // 2L2 + L1 + L3\n        \"movq %%mm2, (%%\"REG_a\")                \\n\\t\"\n        \"movq (%%\"REG_a\", %1, 2), %%mm2         \\n\\t\" // L4\n        PAVGB(%%mm2, %%mm1)                           // L2+L4\n        PAVGB(%%mm0, %%mm1)                           // 2L3 + L2 + L4\n        \"movq %%mm1, (%%\"REG_a\", %1)            \\n\\t\"\n        \"movq (%0, %1, 4), %%mm1                \\n\\t\" // L5\n        PAVGB(%%mm1, %%mm0)                           // L3+L5\n        PAVGB(%%mm2, %%mm0)                           // 2L4 + L3 + L5\n        \"movq %%mm0, (%%\"REG_a\", %1, 2)         \\n\\t\"\n        \"movq (%%\"REG_d\"), %%mm0                \\n\\t\" // L6\n        PAVGB(%%mm0, %%mm2)                           // L4+L6\n        PAVGB(%%mm1, %%mm2)                           // 2L5 + L4 + L6\n        \"movq %%mm2, (%0, %1, 4)                \\n\\t\"\n        \"movq (%%\"REG_d\", %1), %%mm2            \\n\\t\" // L7\n        PAVGB(%%mm2, %%mm1)                           // L5+L7\n        PAVGB(%%mm0, %%mm1)                           // 2L6 + L5 + L7\n        \"movq %%mm1, (%%\"REG_d\")                \\n\\t\"\n        \"movq (%%\"REG_d\", %1, 2), %%mm1         \\n\\t\" // L8\n        PAVGB(%%mm1, %%mm0)                           // L6+L8\n        PAVGB(%%mm2, %%mm0)                           // 2L7 + L6 + L8\n        \"movq %%mm0, (%%\"REG_d\", %1)            \\n\\t\"\n        \"movq (%0, %1, 8), %%mm0                \\n\\t\" // L9\n        PAVGB(%%mm0, %%mm2)                           // L7+L9\n        PAVGB(%%mm1, %%mm2)                           // 2L8 + L7 + L9\n        \"movq %%mm2, (%%\"REG_d\", %1, 2)         \\n\\t\"\n        \"movq %%mm1, (%2)                       \\n\\t\"\n\n        : : \"r\" (src), \"r\" ((long)stride), \"r\" (tmp)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    int a, b, c, x;\n    src+= 4*stride;\n\n    for(x=0; x<2; x++){\n        a= *(uint32_t*)&tmp[stride*0];\n        b= *(uint32_t*)&src[stride*0];\n        c= *(uint32_t*)&src[stride*1];\n        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*0]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n\n        a= *(uint32_t*)&src[stride*2];\n        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*1]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);\n\n        b= *(uint32_t*)&src[stride*3];\n        c= (b&c) + (((b^c)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*2]= (c|a) - (((c^a)&0xFEFEFEFEUL)>>1);\n\n        c= *(uint32_t*)&src[stride*4];\n        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*3]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n\n        a= *(uint32_t*)&src[stride*5];\n        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*4]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);\n\n        b= *(uint32_t*)&src[stride*6];\n        c= (b&c) + (((b^c)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*5]= (c|a) - (((c^a)&0xFEFEFEFEUL)>>1);\n\n        c= *(uint32_t*)&src[stride*7];\n        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*6]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n\n        a= *(uint32_t*)&src[stride*8];\n        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);\n        *(uint32_t*)&src[stride*7]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);\n\n        *(uint32_t*)&tmp[stride*0]= c;\n        src += 4;\n        tmp += 4;\n    }\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Resizes a FIFO.\n */\n", "func_signal": "void av_fifo_realloc(AVFifoBuffer *f, unsigned int new_size)", "code": "{\n    unsigned int old_size= f->end - f->buffer;\n\n    if(old_size <= new_size){\n        int len= av_fifo_size(f);\n        AVFifoBuffer f2;\n\n        av_fifo_init(&f2, new_size);\n        av_fifo_read(f, f2.buffer, len);\n        f2.wptr += len;\n        av_free(f->buffer);\n        *f= f2;\n    }\n}", "path": "ffmpeg\\libavutil\\fifo.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by filtering every line with a (-1 2 6 2 -1) filter.\n * will be called for every 8x8 block and can read & write from line 4-15\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n * this filter will read lines 4-13 and write 4-11\n */\n", "func_signal": "static inline void RENAME(deInterlaceL5)(uint8_t src[], int stride, uint8_t *tmp, uint8_t *tmp2)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= stride*4;\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n        \"pxor %%mm7, %%mm7                      \\n\\t\"\n        \"movq (%2), %%mm0                       \\n\\t\"\n        \"movq (%3), %%mm1                       \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9       10\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx\n\n#define REAL_DEINT_L5(t1,t2,a,b,c)\\\n        \"movq \" #a \", %%mm2                     \\n\\t\"\\\n        \"movq \" #b \", %%mm3                     \\n\\t\"\\\n        \"movq \" #c \", %%mm4                     \\n\\t\"\\\n        PAVGB(t2, %%mm3)                             \\\n        PAVGB(t1, %%mm4)                             \\\n        \"movq %%mm2, %%mm5                      \\n\\t\"\\\n        \"movq %%mm2, \" #t1 \"                    \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm2                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm5                 \\n\\t\"\\\n        \"movq %%mm2, %%mm6                      \\n\\t\"\\\n        \"paddw %%mm2, %%mm2                     \\n\\t\"\\\n        \"paddw %%mm6, %%mm2                     \\n\\t\"\\\n        \"movq %%mm5, %%mm6                      \\n\\t\"\\\n        \"paddw %%mm5, %%mm5                     \\n\\t\"\\\n        \"paddw %%mm6, %%mm5                     \\n\\t\"\\\n        \"movq %%mm3, %%mm6                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm3                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm6                 \\n\\t\"\\\n        \"paddw %%mm3, %%mm3                     \\n\\t\"\\\n        \"paddw %%mm6, %%mm6                     \\n\\t\"\\\n        \"paddw %%mm3, %%mm2                     \\n\\t\"\\\n        \"paddw %%mm6, %%mm5                     \\n\\t\"\\\n        \"movq %%mm4, %%mm6                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm4                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm6                 \\n\\t\"\\\n        \"psubw %%mm4, %%mm2                     \\n\\t\"\\\n        \"psubw %%mm6, %%mm5                     \\n\\t\"\\\n        \"psraw $2, %%mm2                        \\n\\t\"\\\n        \"psraw $2, %%mm5                        \\n\\t\"\\\n        \"packuswb %%mm5, %%mm2                  \\n\\t\"\\\n        \"movq %%mm2, \" #a \"                     \\n\\t\"\\\n\n#define DEINT_L5(t1,t2,a,b,c)  REAL_DEINT_L5(t1,t2,a,b,c)\n\nDEINT_L5(%%mm0, %%mm1, (%0)           , (%%REGa)       , (%%REGa, %1)   )\nDEINT_L5(%%mm1, %%mm0, (%%REGa)       , (%%REGa, %1)   , (%%REGa, %1, 2))\nDEINT_L5(%%mm0, %%mm1, (%%REGa, %1)   , (%%REGa, %1, 2), (%0, %1, 4)   )\nDEINT_L5(%%mm1, %%mm0, (%%REGa, %1, 2), (%0, %1, 4)    , (%%REGd)       )\nDEINT_L5(%%mm0, %%mm1, (%0, %1, 4)    , (%%REGd)       , (%%REGd, %1)   )\nDEINT_L5(%%mm1, %%mm0, (%%REGd)       , (%%REGd, %1)   , (%%REGd, %1, 2))\nDEINT_L5(%%mm0, %%mm1, (%%REGd, %1)   , (%%REGd, %1, 2), (%0, %1, 8)   )\nDEINT_L5(%%mm1, %%mm0, (%%REGd, %1, 2), (%0, %1, 8)    , (%%REGd, %1, 4))\n\n        \"movq %%mm0, (%2)                       \\n\\t\"\n        \"movq %%mm1, (%3)                       \\n\\t\"\n        : : \"r\" (src), \"r\" ((long)stride), \"r\"(tmp), \"r\"(tmp2)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    int x;\n    src+= stride*4;\n    for(x=0; x<8; x++){\n        int t1= tmp[x];\n        int t2= tmp2[x];\n        int t3= src[0];\n\n        src[stride*0]= CLIP((-(t1 + src[stride*2]) + 2*(t2 + src[stride*1]) + 6*t3 + 4)>>3);\n        t1= src[stride*1];\n        src[stride*1]= CLIP((-(t2 + src[stride*3]) + 2*(t3 + src[stride*2]) + 6*t1 + 4)>>3);\n        t2= src[stride*2];\n        src[stride*2]= CLIP((-(t3 + src[stride*4]) + 2*(t1 + src[stride*3]) + 6*t2 + 4)>>3);\n        t3= src[stride*3];\n        src[stride*3]= CLIP((-(t1 + src[stride*5]) + 2*(t2 + src[stride*4]) + 6*t3 + 4)>>3);\n        t1= src[stride*4];\n        src[stride*4]= CLIP((-(t2 + src[stride*6]) + 2*(t3 + src[stride*5]) + 6*t1 + 4)>>3);\n        t2= src[stride*5];\n        src[stride*5]= CLIP((-(t3 + src[stride*7]) + 2*(t1 + src[stride*6]) + 6*t2 + 4)>>3);\n        t3= src[stride*6];\n        src[stride*6]= CLIP((-(t1 + src[stride*8]) + 2*(t2 + src[stride*7]) + 6*t3 + 4)>>3);\n        t1= src[stride*7];\n        src[stride*7]= CLIP((-(t2 + src[stride*9]) + 2*(t3 + src[stride*8]) + 6*t1 + 4)>>3);\n\n        tmp[x]= t3;\n        tmp2[x]= t1;\n\n        src++;\n    }\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by linearly interpolating every second line.\n * will be called for every 8x8 block and can read & write from line 4-15\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n */\n", "func_signal": "static inline void RENAME(deInterlaceInterpolateLinear)(uint8_t src[], int stride)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= 4*stride;\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_c\"      \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1\n\n        \"movq (%0), %%mm0                       \\n\\t\"\n        \"movq (%%\"REG_a\", %1), %%mm1            \\n\\t\"\n        PAVGB(%%mm1, %%mm0)\n        \"movq %%mm0, (%%\"REG_a\")                \\n\\t\"\n        \"movq (%0, %1, 4), %%mm0                \\n\\t\"\n        PAVGB(%%mm0, %%mm1)\n        \"movq %%mm1, (%%\"REG_a\", %1, 2)         \\n\\t\"\n        \"movq (%%\"REG_c\", %1), %%mm1            \\n\\t\"\n        PAVGB(%%mm1, %%mm0)\n        \"movq %%mm0, (%%\"REG_c\")                \\n\\t\"\n        \"movq (%0, %1, 8), %%mm0                \\n\\t\"\n        PAVGB(%%mm0, %%mm1)\n        \"movq %%mm1, (%%\"REG_c\", %1, 2)         \\n\\t\"\n\n        : : \"r\" (src), \"r\" ((long)stride)\n        : \"%\"REG_a, \"%\"REG_c\n    );\n#else\n    int a, b, x;\n    src+= 4*stride;\n\n    for(x=0; x<2; x++){\n        a= *(uint32_t*)&src[stride*0];\n        b= *(uint32_t*)&src[stride*2];\n        *(uint32_t*)&src[stride*1]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n        a= *(uint32_t*)&src[stride*4];\n        *(uint32_t*)&src[stride*3]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n        b= *(uint32_t*)&src[stride*6];\n        *(uint32_t*)&src[stride*5]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n        a= *(uint32_t*)&src[stride*8];\n        *(uint32_t*)&src[stride*7]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);\n        src += 4;\n    }\n#endif\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Experimental implementation of the filter (Algorithm 1) described in a paper from Ramkishor & Karandikar\n * values are correctly clipped (MMX2)\n * values are wraparound (C)\n * Conclusion: It is fast, but introduces ugly horizontal patterns\n * if there is a continuous gradient.\n        0 8 16 24\n        x = 8\n        x/2 = 4\n        x/8 = 1\n        1 12 12 23\n */\n", "func_signal": "static inline void RENAME(vertRK1Filter)(uint8_t *src, int stride, int QP)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= stride*3;\n// FIXME rounding\n    asm volatile(\n        \"pxor %%mm7, %%mm7                      \\n\\t\" // 0\n        \"movq \"MANGLE(b80)\", %%mm6              \\n\\t\" // MIN_SIGNED_BYTE\n        \"leal (%0, %1), %%\"REG_a\"               \\n\\t\"\n        \"leal (%%\"REG_a\", %1, 4), %%\"REG_c\"     \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1\n        \"movq \"MANGLE(pQPb)\", %%mm0             \\n\\t\" // QP,..., QP\n        \"movq %%mm0, %%mm1                      \\n\\t\" // QP,..., QP\n        \"paddusb \"MANGLE(b02)\", %%mm0           \\n\\t\"\n        \"psrlw $2, %%mm0                        \\n\\t\"\n        \"pand \"MANGLE(b3F)\", %%mm0              \\n\\t\" // QP/4,..., QP/4\n        \"paddusb %%mm1, %%mm0                   \\n\\t\" // QP*1.25 ...\n        \"movq (%0, %1, 4), %%mm2                \\n\\t\" // line 4\n        \"movq (%%\"REG_c\"), %%mm3                \\n\\t\" // line 5\n        \"movq %%mm2, %%mm4                      \\n\\t\" // line 4\n        \"pcmpeqb %%mm5, %%mm5                   \\n\\t\" // -1\n        \"pxor %%mm2, %%mm5                      \\n\\t\" // -line 4 - 1\n        PAVGB(%%mm3, %%mm5)\n        \"paddb %%mm6, %%mm5                     \\n\\t\" // (l5-l4)/2\n        \"psubusb %%mm3, %%mm4                   \\n\\t\"\n        \"psubusb %%mm2, %%mm3                   \\n\\t\"\n        \"por %%mm3, %%mm4                       \\n\\t\" // |l4 - l5|\n        \"psubusb %%mm0, %%mm4                   \\n\\t\"\n        \"pcmpeqb %%mm7, %%mm4                   \\n\\t\"\n        \"pand %%mm4, %%mm5                      \\n\\t\" // d/2\n\n//        \"paddb %%mm6, %%mm2                     \\n\\t\" // line 4 + 0x80\n        \"paddb %%mm5, %%mm2                     \\n\\t\"\n//        \"psubb %%mm6, %%mm2                     \\n\\t\"\n        \"movq %%mm2, (%0,%1, 4)                 \\n\\t\"\n\n        \"movq (%%\"REG_c\"), %%mm2                \\n\\t\"\n//        \"paddb %%mm6, %%mm2                     \\n\\t\" // line 5 + 0x80\n        \"psubb %%mm5, %%mm2                     \\n\\t\"\n//        \"psubb %%mm6, %%mm2                     \\n\\t\"\n        \"movq %%mm2, (%%\"REG_c\")                \\n\\t\"\n\n        \"paddb %%mm6, %%mm5                     \\n\\t\"\n        \"psrlw $2, %%mm5                        \\n\\t\"\n        \"pand \"MANGLE(b3F)\", %%mm5              \\n\\t\"\n        \"psubb \"MANGLE(b20)\", %%mm5             \\n\\t\" // (l5-l4)/8\n\n        \"movq (%%\"REG_a\", %1, 2), %%mm2         \\n\\t\"\n        \"paddb %%mm6, %%mm2                     \\n\\t\" // line 3 + 0x80\n        \"paddsb %%mm5, %%mm2                    \\n\\t\"\n        \"psubb %%mm6, %%mm2                     \\n\\t\"\n        \"movq %%mm2, (%%\"REG_a\", %1, 2)         \\n\\t\"\n\n        \"movq (%%\"REG_c\", %1), %%mm2            \\n\\t\"\n        \"paddb %%mm6, %%mm2                     \\n\\t\" // line 6 + 0x80\n        \"psubsb %%mm5, %%mm2                    \\n\\t\"\n        \"psubb %%mm6, %%mm2                     \\n\\t\"\n        \"movq %%mm2, (%%\"REG_c\", %1)            \\n\\t\"\n\n        :\n        : \"r\" (src), \"r\" ((long)stride)\n        : \"%\"REG_a, \"%\"REG_c\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    const int l1= stride;\n    const int l2= stride + l1;\n    const int l3= stride + l2;\n    const int l4= stride + l3;\n    const int l5= stride + l4;\n    const int l6= stride + l5;\n//    const int l7= stride + l6;\n//    const int l8= stride + l7;\n//    const int l9= stride + l8;\n    int x;\n    const int QP15= QP + (QP>>2);\n    src+= stride*3;\n    for(x=0; x<BLOCK_SIZE; x++){\n        const int v = (src[x+l5] - src[x+l4]);\n        if(FFABS(v) < QP15){\n            src[x+l3] +=v>>3;\n            src[x+l4] +=v>>1;\n            src[x+l5] -=v>>1;\n            src[x+l6] -=v>>3;\n        }\n    }\n\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/* The XY2 routines basically utilize this scheme, but reuse parts in\n   each iteration.  */\n", "func_signal": "static inline uint64_t avg4(uint64_t l1, uint64_t l2, uint64_t l3, uint64_t l4)", "code": "{\n    uint64_t r1 = ((l1 & ~BYTE_VEC(0x03)) >> 2)\n                + ((l2 & ~BYTE_VEC(0x03)) >> 2)\n                + ((l3 & ~BYTE_VEC(0x03)) >> 2)\n                + ((l4 & ~BYTE_VEC(0x03)) >> 2);\n    uint64_t r2 = ((  (l1 & BYTE_VEC(0x03))\n                    + (l2 & BYTE_VEC(0x03))\n                    + (l3 & BYTE_VEC(0x03))\n                    + (l4 & BYTE_VEC(0x03))\n                    + BYTE_VEC(0x02)) >> 2) & BYTE_VEC(0x03);\n    return r1 + r2;\n}", "path": "ffmpeg-orig\\libavcodec\\alpha\\dsputil_alpha.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Duplicates the given 8 src pixels ? times upward\n */\n", "func_signal": "static inline void RENAME(duplicate)(uint8_t src[], int stride)", "code": "{\n#ifdef HAVE_MMX\n    asm volatile(\n        \"movq (%0), %%mm0               \\n\\t\"\n        \"add %1, %0                     \\n\\t\"\n        \"movq %%mm0, (%0)               \\n\\t\"\n        \"movq %%mm0, (%0, %1)           \\n\\t\"\n        \"movq %%mm0, (%0, %1, 2)        \\n\\t\"\n        : \"+r\" (src)\n        : \"r\" ((long)-stride)\n    );\n#else\n    int i;\n    uint8_t *p=src;\n    for(i=0; i<3; i++){\n        p-= stride;\n        memcpy(p, src, 8);\n    }\n#endif\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/**\n * Deinterlaces the given block by filtering every second line with a (-1 4 2 4 -1) filter.\n * will be called for every 8x8 block and can read & write from line 4-15\n * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.\n * lines 4-12 will be read into the deblocking filter and should be deinterlaced\n * this filter will read lines 4-13 and write 5-11\n */\n", "func_signal": "static inline void RENAME(deInterlaceFF)(uint8_t src[], int stride, uint8_t *tmp)", "code": "{\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    src+= stride*4;\n    asm volatile(\n        \"lea (%0, %1), %%\"REG_a\"                \\n\\t\"\n        \"lea (%%\"REG_a\", %1, 4), %%\"REG_d\"      \\n\\t\"\n        \"pxor %%mm7, %%mm7                      \\n\\t\"\n        \"movq (%2), %%mm0                       \\n\\t\"\n//      0       1       2       3       4       5       6       7       8       9       10\n//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx\n\n#define REAL_DEINT_FF(a,b,c,d)\\\n        \"movq \" #a \", %%mm1                     \\n\\t\"\\\n        \"movq \" #b \", %%mm2                     \\n\\t\"\\\n        \"movq \" #c \", %%mm3                     \\n\\t\"\\\n        \"movq \" #d \", %%mm4                     \\n\\t\"\\\n        PAVGB(%%mm3, %%mm1)                          \\\n        PAVGB(%%mm4, %%mm0)                          \\\n        \"movq %%mm0, %%mm3                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm0                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm3                 \\n\\t\"\\\n        \"movq %%mm1, %%mm4                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm1                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm4                 \\n\\t\"\\\n        \"psllw $2, %%mm1                        \\n\\t\"\\\n        \"psllw $2, %%mm4                        \\n\\t\"\\\n        \"psubw %%mm0, %%mm1                     \\n\\t\"\\\n        \"psubw %%mm3, %%mm4                     \\n\\t\"\\\n        \"movq %%mm2, %%mm5                      \\n\\t\"\\\n        \"movq %%mm2, %%mm0                      \\n\\t\"\\\n        \"punpcklbw %%mm7, %%mm2                 \\n\\t\"\\\n        \"punpckhbw %%mm7, %%mm5                 \\n\\t\"\\\n        \"paddw %%mm2, %%mm1                     \\n\\t\"\\\n        \"paddw %%mm5, %%mm4                     \\n\\t\"\\\n        \"psraw $2, %%mm1                        \\n\\t\"\\\n        \"psraw $2, %%mm4                        \\n\\t\"\\\n        \"packuswb %%mm4, %%mm1                  \\n\\t\"\\\n        \"movq %%mm1, \" #b \"                     \\n\\t\"\\\n\n#define DEINT_FF(a,b,c,d)  REAL_DEINT_FF(a,b,c,d)\n\nDEINT_FF((%0)        , (%%REGa)       , (%%REGa, %1), (%%REGa, %1, 2))\nDEINT_FF((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd)       )\nDEINT_FF((%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%%REGd, %1, 2))\nDEINT_FF((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGd, %1, 4))\n\n        \"movq %%mm0, (%2)                       \\n\\t\"\n        : : \"r\" (src), \"r\" ((long)stride), \"r\"(tmp)\n        : \"%\"REG_a, \"%\"REG_d\n    );\n#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n    int x;\n    src+= stride*4;\n    for(x=0; x<8; x++){\n        int t1= tmp[x];\n        int t2= src[stride*1];\n\n        src[stride*1]= CLIP((-t1 + 4*src[stride*0] + 2*t2 + 4*src[stride*2] - src[stride*3] + 4)>>3);\n        t1= src[stride*4];\n        src[stride*3]= CLIP((-t2 + 4*src[stride*2] + 2*t1 + 4*src[stride*4] - src[stride*5] + 4)>>3);\n        t2= src[stride*6];\n        src[stride*5]= CLIP((-t1 + 4*src[stride*4] + 2*t2 + 4*src[stride*6] - src[stride*7] + 4)>>3);\n        t1= src[stride*8];\n        src[stride*7]= CLIP((-t2 + 4*src[stride*6] + 2*t1 + 4*src[stride*8] - src[stride*9] + 4)>>3);\n        tmp[x]= t1;\n\n        src++;\n    }\n#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n}", "path": "ffmpeg\\libpostproc\\postprocess_template.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/** initializes mt[AV_RANDOM_N] with a seed */\n", "func_signal": "void av_init_random(unsigned int seed, AVRandomState *state)", "code": "{\n    int index;\n\n    /*\n     This differs from the wikipedia article.  Source is from the Makoto\n     Makoto Matsumoto and Takuji Nishimura code, with the following comment:\n     */\n     /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n     /* In the previous versions, MSBs of the seed affect   */\n     /* only MSBs of the array mt[].                        */\n    state->mt[0] = seed & 0xffffffff;\n    for (index = 1; index < AV_RANDOM_N; index++) {\n        unsigned int prev= state->mt[index - 1];\n        state->mt[index] = (1812433253UL * (prev ^ (prev>>30)) + index) & 0xffffffff;\n    }\n    state->index= index; // will cause it to generate untempered numbers the first iteration\n}", "path": "ffmpeg-orig\\libavutil\\random.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/** generate AV_RANDOM_N words at one time (which will then be tempered later) (av_random calls this; you shouldn't) */\n", "func_signal": "void av_random_generate_untempered_numbers(AVRandomState *state)", "code": "{\n    int kk;\n    unsigned int y;\n\n    for (kk = 0; kk < AV_RANDOM_N - M; kk++) {\n        y = (state->mt[kk] & UPPER_MASK) | (state->mt[kk + 1] & LOWER_MASK);\n        state->mt[kk] = state->mt[kk + M] ^ (y >> 1) ^ ((y&1)*A);\n    }\n    for (; kk < AV_RANDOM_N - 1; kk++) {\n        y = (state->mt[kk] & UPPER_MASK) | (state->mt[kk + 1] & LOWER_MASK);\n        state->mt[kk] = state->mt[kk + (M - AV_RANDOM_N)] ^ (y >> 1) ^ ((y&1)*A);\n    }\n    y = (state->mt[AV_RANDOM_N - 1] & UPPER_MASK) | (state->mt[0] & LOWER_MASK);\n    state->mt[AV_RANDOM_N - 1] = state->mt[M - 1] ^ (y >> 1) ^ ((y&1)*A);\n    state->index = 0;\n}", "path": "ffmpeg-orig\\libavutil\\random.c", "repo_name": "slash-dev-null/gsoc", "stars": 8, "license": "None", "language": "c", "size": 77532}
{"docstring": "/* Get the number of blocks in the source data.\n   `bhash' specifies the block hash object.\n   The return value is the number of blocks in the source data.\n */\n", "func_signal": "static int getnumblocks(BLKHASH *bhash)", "code": "{\n  assert(bhash);\n  return (bhash->ptrsiz / bhash->blksiz);\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * private functions\n */\n", "func_signal": "static void ssbfclear(SSBF *bf)", "code": "{\n  assert(bf);\n  bf->fd = -1;\n  bf->map = NULL;\n  bf->mapsiz = 0;\n  bf->omode = 0;\n  bf->nfuncs = 0;\n  bf->funcs = NULL;\n  bf->ecode = SSESUCCESS;\n}", "path": "src\\ssbf.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "char *vcdiffencode(const char *ptr, size_t ptrsiz)", "code": "{\n  if (ptr == NULL || ptrsiz == 0) return NULL;\n  char *compressedptr = NULL;\n  VCDIFFENC *enc = NULL;\n  BLKHASH *bhash = NULL;\n  ROLLINGHASH *rhash = NULL;\n  enc = encodernew();\n  if (enc == NULL) goto error;\n  bhash = blkhashnew(ptr, ptrsiz);\n  if (bhash == NULL) goto error;\n  if (ptrsiz < bhash->blksiz) {\n    /* too small to compress */\n    adddata(enc, ptr, ptrsiz);\n    goto end;\n  }\n  size_t blksiz = bhash->blksiz;\n  const char *unencodedptr = ptr;\n  const char *ptrbegin = ptr;\n  const char *ptrend = ptr + ptrsiz;\n  const char *ptrlastblk = ptrend - blksiz;\n  rhash = rollinghashnew(blksiz);\n  if (rhash == NULL) goto error;\n  /* iterate througth the data */\n  uint32_t hash = rollinghashdohash(rhash, ptr);\n  while (1) {\n    assert(unencodedptr <= ptrend);\n    int encoded = findbestmatch(enc, hash, ptr, unencodedptr, ptrend - unencodedptr, bhash);\n    if (encoded > 0) {\n      /* matching block is found */\n      unencodedptr += encoded;\n      if (ptr > ptrlastblk) break;\n      while (ptr < unencodedptr) {\n        blkhashaddhash(bhash, ptr - ptrbegin, hash);\n        hash = rollinghashupdate(rhash, hash, ptr[0], ptr[blksiz]);\n        ptr++;\n      }\n      assert(ptr == unencodedptr);\n    } else {\n      /* no matching block was found */\n      if (ptr + 1 > ptrlastblk) break;\n      blkhashaddhash(bhash, ptr - ptrbegin, hash);\n      hash = rollinghashupdate(rhash, hash, ptr[0], ptr[blksiz]);\n      ptr++;\n    }\n  }\n  /* add remaining unencoded data */\n  if (unencodedptr < ptrend)\n    adddata(enc, unencodedptr, ptrend - unencodedptr);\nend:\n  compressedptr = encoderout(enc);\n  blkhashdel(bhash);\n  rollinghashdel(rhash);\n  encoderdel(enc);\n  return compressedptr;\nerror:\n  if (bhash) blkhashdel(bhash);\n  if (rhash) rollinghashdel(rhash);\n  if (enc) encoderdel(enc);\n  return NULL;\n}", "path": "src\\compress\\vcdiff.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* rtbl has 256 entry table, which is used to fast rolling update.\n * it stores the following value:\n *   rtbl[byte] == - (byte * pow(RHASHMULT, wsiz - 1)) % RHASHBASE\n */\n", "func_signal": "uint32_t *initremovetbl(size_t wsiz)", "code": "{\n  unsigned int i;\n  uint32_t *rtbl;\n  SSMALLOC(rtbl, sizeof(uint32_t) * 256);\n  /* multiplier = pow(RHASHMULT, wsiz - 1) */\n  uint32_t multiplier = 1;\n  for (i = 0; i < wsiz - 1; i++)\n    multiplier = MODBASE(multiplier * RHASHMULT);\n  /* byte_multiplier = (byte * multiplier) % RHASHBASE */\n  uint32_t byte_multiplier = 0;\n  for (i = 0; i < 256; i++) {\n    rtbl[i] = MODBASEINV(byte_multiplier);\n    byte_multiplier = MODBASE(byte_multiplier + multiplier);\n  }\n  return rtbl;\n}", "path": "src\\compress\\rollinghash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "SSFTBL *ssftblnew(void)", "code": "{\n  SSFTBL *tbl = NULL;\n  SSMALLOC(tbl, sizeof(SSFTBL));\n  ssftblclear(tbl);\n  return tbl;\n}", "path": "src\\ssftbl.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "BLKHASH *blkhashnew(const char *sourceptr, size_t sourceptrsiz)", "code": "{\n  uint32_t i;\n  uint32_t tblsiz = calctblsize(sourceptrsiz);\n  if (tblsiz <= 0) return NULL;\n  BLKHASH *bhash;\n  SSMALLOC(bhash, sizeof(BLKHASH));\n  bhash->ptr = sourceptr;\n  bhash->ptrsiz = sourceptrsiz;\n  bhash->blksiz = BLKHASHBLKSIZ;\n  bhash->lastaddedblknum = -1;\n  bhash->ecode = SSESUCCESS;\n  SSMALLOC(bhash->hashtbl, tblsiz * sizeof(uint32_t));\n  bhash->hashtblmask = ((uint32_t)tblsiz) - 1;\n  SSMALLOC(bhash->nextblktbl, getnumblocks(bhash) * sizeof(int));\n  SSMALLOC(bhash->lastblktbl, getnumblocks(bhash) * sizeof(int));\n  for (i = 0; i < tblsiz; i++)\n    bhash->hashtbl[i] = -1;\n  for (i = 0; i < (uint32_t)getnumblocks(bhash); i++) {\n    bhash->nextblktbl[i] = -1;\n    bhash->lastblktbl[i] = -1;\n  }\n  return bhash;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Replace the BLKHASHMATCH if longer one is found.\n   `m' specifies the pointer to the match result structure.\n   `matchsize' specifies the newly found matching size.\n   `targetoff' specifies the target offset of the newly found matching region.\n   `sourceoff' specifies the source offset of the newly found matching region.\n   The return value is 1 if replaced, otherwise 0.\n */\n", "func_signal": "static int replaceifbettermatch(BLKHASHMATCH *m, int matchsize,\n                                int targetoff, int sourceoff)", "code": "{\n  assert(m != NULL);\n  if (m->size < (unsigned int)matchsize) {\n    m->size = matchsize;\n    m->targetoff = targetoff;\n    m->sourceoff = sourceoff;\n    return 1;\n  }\n  return 0;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "SSMTBL *ssmtblnew(void)", "code": "{\n  SSMTBL *tbl;\n  SSMALLOC(tbl, sizeof(SSMTBL));\n  ssmtblclear(tbl);\n  tbl->mdb = tcmdbnew();\n  if (pthread_rwlock_init(&tbl->mtx, NULL) != 0)\n    goto err;\n  return tbl;\nerr:\n  if (tbl) ssmtbldel(tbl);\n  return NULL;\n}", "path": "src\\ssmtbl.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Count the matching bytes to the right between two pointers.\n   `ptr1' specifies the data pointer.\n   `ptr2' specifies the another data pointer.\n   `maxsiz' specifies the max size of the matching region.\n   The return value is the number of matching bytes.\n */\n", "func_signal": "static int matchright(const char *ptr1, const char *ptr2, int maxsiz)", "code": "{\n  int matchsiz = 0;\n  while (matchsiz < maxsiz) {\n    if (*ptr1 != *ptr2) break;\n    ++ptr1;\n    ++ptr2;\n    ++matchsiz;\n  }\n  return matchsiz;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Count the matching bytes to the left between two pointers.\n   `ptr1' specifies the data pointer.\n   `ptr2' specifies the another data pointer.\n   `maxsiz' specifies the max size of the matching region.\n   The return value is the number of matching bytes.\n */\n", "func_signal": "static int matchleft(const char *ptr1, const char *ptr2, int maxsiz)", "code": "{\n  int matchsiz = 0;\n  while (matchsiz < maxsiz) {\n    --ptr1;\n    --ptr2;\n    if (*ptr1 != *ptr2) break;\n    matchsiz++;\n  }\n  return matchsiz;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "SSBF *ssbfnew(uint64_t bsiz)", "code": "{\n  SSBF *bf = NULL;\n  SSMALLOC(bf, sizeof(SSBF));\n  ssbfclear(bf);\n  bf->mapsiz = bsiz;\n  if (pthread_rwlock_init(&bf->mtx, NULL) != 0)\n    goto err;\n  return bf;\nerr:\n  if (bf) ssbfdel(bf);\n  return NULL;\n}", "path": "src\\ssbf.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * private functions\n */\n", "func_signal": "static VCDIFFENC *encodernew(void)", "code": "{\n  VCDIFFENC *e;\n  SSMALLOC(e, sizeof(VCDIFFENC));\n  e->ops = NULL;\n  e->addopnum = 0;\n  e->adddata = NULL;\n  e->adddatasizs = NULL;\n  e->copyopnum = 0;\n  e->copyoffsets = NULL;\n  e->copysizs = NULL;\n  return e;\n}", "path": "src\\compress\\vcdiff.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * none\n */\n", "func_signal": "char *sscodec_nonecompress(const char *ptr, int size, int *sp)", "code": "{\n  if (ptr == NULL || size == 0 || sp == NULL) return NULL;\n  char *ret = NULL;\n  SSMALLOC(ret, size);\n  memcpy(ret, ptr, size);\n  *sp = size;\n  return ret;\n}", "path": "src\\compress.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * private functions\n */\n", "func_signal": "static void ssftblclear(SSFTBL *tbl)", "code": "{\n  assert(tbl);\n  tbl->path = NULL;\n  tbl->dfd = -1;\n  tbl->blksiz = DEFBLKSIZ;\n  tbl->rnum = 0;\n  tbl->cmethod = SSCMZLIB;\n  tbl->omode = 0;\n  tbl->ecode = SSESUCCESS;\n  tbl->blkbuf = NULL;\n  tbl->blkbufsiz = 0;\n  tbl->curblkrnum = 0;\n  tbl->curblksiz = 0;\n  tbl->lastappended.kbuf = NULL;\n  tbl->lastappended.ksiz = 0;\n  tbl->lastappended.doff = 0;\n  tbl->lastappended.blksiz = 0;\n  tbl->idx = NULL;\n  tbl->idxnum = 0;\n  tbl->idxoff = 0;\n  tbl->blkc = NULL;\n  tbl->blkcnum = DEFBLKCNUM;\n}", "path": "src\\ssftbl.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Add the block to the block hash object.\n   `bhash' specifies the block hash object.\n   `hash' specifies the hash value of the adding block.\n   The return value is 0 if success, otherwise -1.\n */\n", "func_signal": "static int addblk(BLKHASH *bhash, uint32_t hash)", "code": "{\n  int blknum = bhash->lastaddedblknum + 1;\n  int totalblknum = (bhash->ptrsiz / bhash->blksiz) + 1;\n  if (blknum >= totalblknum) {\n    setecode(bhash, SSEINVALID);\n    return -1;\n  }\n  if (bhash->nextblktbl[blknum] != -1) {\n    setecode(bhash, SSEINVALID);\n    return -1;\n  }\n  uint32_t hashtblindex = gethashtblindex(bhash, hash);\n  int firstmatchingblk = bhash->hashtbl[hashtblindex];\n  if (firstmatchingblk < 0) {\n    /* first entry with this hash value */\n    bhash->hashtbl[hashtblindex] = blknum;\n    bhash->lastblktbl[blknum] = blknum;\n  } else {\n    /* the blocks which has this hash value already appeared several times */\n    int lastmatchingblk = bhash->lastblktbl[firstmatchingblk];\n    if (bhash->nextblktbl[lastmatchingblk] != -1) {\n      setecode(bhash, SSEINVALID);\n      return -1;\n    }\n    bhash->nextblktbl[lastmatchingblk] = blknum;\n    bhash->lastblktbl[firstmatchingblk] = blknum;\n  }\n  bhash->lastaddedblknum = blknum;\n  return 0;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Get the index of the hashtbl.\n   `bhash' specifies the block hash object.\n   The return value is the index of bhash->hashtbl.\n */\n", "func_signal": "static uint32_t gethashtblindex(BLKHASH *bhash, uint32_t hash)", "code": "{\n  assert(bhash);\n  return hash & bhash->hashtblmask;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Calc the number of entries of hashtbl.\n   `ptrsiz' specifies the size of the source data.\n   The return value is the number of entries of bhash->hashtbl.\n   Increasing this value is a tradeoff between the performance and the memory\n   consumption.\n */\n", "func_signal": "static int calctblsize(size_t ptrsiz)", "code": "{\n  int minsiz = (ptrsiz / sizeof(int)) + 1;\n  int tblsiz = 1;\n  while (tblsiz < minsiz) {\n    tblsiz <<= 1;\n    assert(tblsiz > 0);\n  }\n  assert((tblsiz & (tblsiz - 1)) == 0);\n  assert(0 < tblsiz && tblsiz < minsiz * 2);\n  return tblsiz;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/* Scan the blocks to find the matching block.\n   `bhash' specifies the block hash object.\n   `blknum' specifies the block number.\n   `targetptr' specifies the pointer to the data to be matched.\n   The return value is the matched block number.\n */\n", "func_signal": "static int scanblks(BLKHASH *bhash, int blknum, const char* targetptr)", "code": "{\n  int n = 0;\n  while (blknum >= 0\n         && memcmp(targetptr,\n                   bhash->ptr + (bhash->blksiz * blknum),\n                   bhash->blksiz) != 0) {\n    if (++n > BLKHASHMAXPROBES)\n      return -1; /* avoid too much scanning */\n    assert(0 <= blknum && blknum < getnumblocks(bhash));\n    blknum = bhash->nextblktbl[blknum];\n  }\n  return blknum;\n}", "path": "src\\compress\\blkhash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * APIs\n */\n", "func_signal": "ROLLINGHASH *rollinghashnew(size_t wsiz)", "code": "{\n  if (wsiz <= 2) return NULL;\n  ROLLINGHASH *rhash;\n  SSMALLOC(rhash, sizeof(ROLLINGHASH));\n  rhash->wsiz = wsiz;\n  rhash->rtbl = initremovetbl(wsiz);\n  return rhash;\n}", "path": "src\\compress\\rollinghash.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/*-----------------------------------------------------------------------------\n * private functions\n */\n", "func_signal": "static void ssmtblclear(SSMTBL *tbl)", "code": "{\n  assert(tbl);\n  tbl->mdb = NULL;\n  tbl->msiz = 0;\n  tbl->rnum = 0;\n  tbl->ecode = SSESUCCESS;\n}", "path": "src\\ssmtbl.c", "repo_name": "kzk/libsstbl", "stars": 14, "license": "None", "language": "c", "size": 125}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tLEDs_SetAllLEDs(LEDMASK_USB_READY);\n\n\tif (!(HID_Device_ConfigureEndpoints(&Mouse_HID_Interface)))\n\t  LEDs_SetAllLEDs(LEDMASK_USB_ERROR);\n\n\tUSB_Device_EnableSOFEvents();\n}", "path": "gadget\\LUFA\\Demos\\Device\\ClassDriver\\Mouse\\Mouse.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Interface descriptor of the correct Keyboard HID Class and Protocol values.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextKeyboardInterface(void* CurrentDescriptor)", "code": "{\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Check the HID descriptor class and protocol, break out if correct class/protocol interface found */\n\t\tif ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == KEYBOARD_CLASS) &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Protocol == KEYBOARD_PROTOCOL))\n\t\t{\n\t\t\treturn DESCRIPTOR_SEARCH_Found;\n\t\t}\n\t}\n\t\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "gadget\\LUFA\\Demos\\Host\\LowLevel\\KeyboardHostWithParser\\ConfigDescriptor.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Interface descriptor of the correct Mouse HID Class and Protocol values.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextMouseInterface(void* CurrentDescriptor)", "code": "{\n\t/* Determine if the current descriptor is an interface descriptor */\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Check the HID descriptor class and protocol, break out if correct class/protocol interface found */\n\t\tif ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == MOUSE_CLASS) &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Protocol == MOUSE_PROTOCOL))\n\t\t{\n\t\t\t/* Indicate that the descriptor being searched for has been found */\n\t\t\treturn DESCRIPTOR_SEARCH_Found;\n\t\t}\n\t}\n\t\n\t/* Current descriptor does not match what this comparator is looking for */\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "gadget\\LUFA\\Demos\\Host\\LowLevel\\MouseHost\\ConfigDescriptor.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_LOAD_ADDRESS command, loading the given device address into a\n *  global storage variable for later use, and issuing LOAD EXTENDED ADDRESS commands\n *  to the attached device as required.\n */\n", "func_signal": "static void V2Protocol_Command_LoadAddress(void)", "code": "{\n\tEndpoint_Read_Stream_BE(&CurrentAddress, sizeof(CurrentAddress));\n\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\t\n\tif (CurrentAddress & (1UL << 31))\n\t  V2Protocol_LoadExtendedAddress();\n\n\tEndpoint_Write_Byte(CMD_LOAD_ADDRESS);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tvoid*    Address = NULL;\n\tuint16_t Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device: \n\t\t\tAddress = (void*)&DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration: \n\t\t\tAddress = (void*)&ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String: \n\t\t\tswitch (DescriptorNumber)\n\t\t\t{\n\t\t\t\tcase 0x00: \n\t\t\t\t\tAddress = (void*)&LanguageString;\n\t\t\t\t\tSize    = pgm_read_byte(&LanguageString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01: \n\t\t\t\t\tAddress = (void*)&ManufacturerString;\n\t\t\t\t\tSize    = pgm_read_byte(&ManufacturerString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02: \n\t\t\t\t\tAddress = (void*)&ProductString;\n\t\t\t\t\tSize    = pgm_read_byte(&ProductString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\tcase DTYPE_HID: \n\t\t\tif (!(wIndex))\n\t\t\t{\n\t\t\t\tAddress = (void*)&ConfigurationDescriptor.KeyboardHID;\n\t\t\t\tSize    = sizeof(USB_HID_Descriptor_t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAddress = (void*)&ConfigurationDescriptor.MouseHID;\n\t\t\t\tSize    = sizeof(USB_HID_Descriptor_t);\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTYPE_Report: \n\t\t\tif (!(wIndex))\n\t\t\t{\n\t\t\t\tAddress = (void*)&KeyboardReport;\n\t\t\t\tSize    = sizeof(KeyboardReport);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\t\t\n\t\t\t\tAddress = (void*)&MouseReport;\n\t\t\t\tSize    = sizeof(MouseReport);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "gadget\\LUFA\\Demos\\Device\\ClassDriver\\KeyboardMouse\\Descriptors.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_WRITE_FUSE_ISP and CMD_WRITE_LOCK_ISP commands, writing the requested configuration\n *  byte to the device.\n *\n *  \\param[in] V2Command  Issued V2 Protocol command byte from the host\n */\n", "func_signal": "static void V2Protocol_Command_WriteFuseLock(uint8_t V2Command)", "code": "{\n\tstruct\n\t{\n\t\tuint8_t WriteCommandBytes[4];\n\t} Write_FuseLockSig_Params;\n\t\n\tEndpoint_Read_Stream_LE(&Write_FuseLockSig_Params, sizeof(Write_FuseLockSig_Params));\n\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tfor (uint8_t SByte = 0; SByte < sizeof(Write_FuseLockSig_Params.WriteCommandBytes); SByte++)\n\t  SPI_SendByte(Write_FuseLockSig_Params.WriteCommandBytes[SByte]);\n\t\t\n\tEndpoint_Write_Byte(V2Command);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_PROGRAM_FLASH_ISP and CMD_PROGRAM_EEPROM_ISP commands, writing out bytes,\n *  words or pages of data to the attached device.\n *\n *  \\param[in] V2Command  Issued V2 Protocol command byte from the host\n */\n", "func_signal": "static void V2Protocol_Command_ProgramMemory(uint8_t V2Command)", "code": "{\n\tstruct\n\t{\n\t\tuint16_t BytesToWrite;\n\t\tuint8_t  ProgrammingMode;\n\t\tuint8_t  DelayMS;\n\t\tuint8_t  ProgrammingCommands[3];\n\t\tuint8_t  PollValue1;\n\t\tuint8_t  PollValue2;\n\t\tuint8_t  ProgData[256]; // Note, the Jungo driver has a very short ACK timeout period, need to buffer the\n\t} Write_Memory_Params;      // whole page and ACK the packet as fast as possible to prevent it from aborting\n\t\n\tEndpoint_Read_Stream_LE(&Write_Memory_Params, sizeof(Write_Memory_Params) - sizeof(Write_Memory_Params.ProgData));\n\tWrite_Memory_Params.BytesToWrite = SwapEndian_16(Write_Memory_Params.BytesToWrite);\n\t\n\tif (Write_Memory_Params.BytesToWrite > sizeof(Write_Memory_Params.ProgData))\n\t{\n\t\tEndpoint_ClearOUT();\n\t\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\t\tEndpoint_Write_Byte(V2Command);\n\t\tEndpoint_Write_Byte(STATUS_CMD_FAILED);\n\t\tEndpoint_ClearIN();\n\t\treturn;\n\t}\n\t\n\tEndpoint_Read_Stream_LE(&Write_Memory_Params.ProgData, Write_Memory_Params.BytesToWrite);\n\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tuint8_t  ProgrammingStatus = STATUS_CMD_OK;\t\n\tuint16_t PollAddress       = 0;\n\tuint8_t  PollValue         = (V2Command == CMD_PROGRAM_FLASH_ISP) ? Write_Memory_Params.PollValue1 :\n\t                                                                    Write_Memory_Params.PollValue2;\n\tuint8_t* NextWriteByte = Write_Memory_Params.ProgData;\n\n\tif (Write_Memory_Params.ProgrammingMode & PROG_MODE_PAGED_WRITES_MASK)\n\t{\n\t\tuint16_t StartAddress = (CurrentAddress & 0xFFFF);\n\t\n\t\t/* Paged mode memory programming */\n\t\tfor (uint16_t CurrentByte = 0; CurrentByte < Write_Memory_Params.BytesToWrite; CurrentByte++)\n\t\t{\n\t\t\tbool    IsOddByte   = (CurrentByte & 0x01);\n\t\t\tuint8_t ByteToWrite = *(NextWriteByte++);\n\t\t\n\t\t\tif (IsOddByte && (V2Command == CMD_PROGRAM_FLASH_ISP))\n\t\t\t  Write_Memory_Params.ProgrammingCommands[0] |=  READ_WRITE_HIGH_BYTE_MASK;\n\t\t\telse\n\t\t\t  Write_Memory_Params.ProgrammingCommands[0] &= ~READ_WRITE_HIGH_BYTE_MASK;\n\t\t\t  \n\t\t\tSPI_SendByte(Write_Memory_Params.ProgrammingCommands[0]);\n\t\t\tSPI_SendByte(CurrentAddress >> 8);\n\t\t\tSPI_SendByte(CurrentAddress & 0xFF);\n\t\t\tSPI_SendByte(ByteToWrite);\n\t\t\t\n\t\t\tif (!(PollAddress) && (ByteToWrite != PollValue))\n\t\t\t{\n\t\t\t\tif (IsOddByte && (V2Command == CMD_PROGRAM_FLASH_ISP))\n\t\t\t\t  Write_Memory_Params.ProgrammingCommands[2] |= READ_WRITE_HIGH_BYTE_MASK;\n\t\t\t\t  \n\t\t\t\tPollAddress = (CurrentAddress & 0xFFFF);\t\t\t\t\n\t\t\t}\t\t\n\n\t\t\tif (IsOddByte || (V2Command == CMD_PROGRAM_EEPROM_ISP))\n\t\t\t  CurrentAddress++;\n\t\t}\n\t\t\n\t\t/* If the current page must be committed, send the PROGRAM PAGE command to the target */\n\t\tif (Write_Memory_Params.ProgrammingMode & PROG_MODE_COMMIT_PAGE_MASK)\n\t\t{\n\t\t\tSPI_SendByte(Write_Memory_Params.ProgrammingCommands[1]);\n\t\t\tSPI_SendByte(StartAddress >> 8);\n\t\t\tSPI_SendByte(StartAddress & 0xFF);\n\t\t\tSPI_SendByte(0x00);\n\t\t\t\n\t\t\t/* Check if polling is possible, if not switch to timed delay mode */\n\t\t\tif (!(PollAddress))\n\t\t\t{\n\t\t\t\tWrite_Memory_Params.ProgrammingMode &= ~PROG_MODE_PAGED_VALUE_MASK;\n\t\t\t\tWrite_Memory_Params.ProgrammingMode |=  PROG_MODE_PAGED_TIMEDELAY_MASK;\t\t\t\t\n\t\t\t}\n\n\t\t\tProgrammingStatus = V2Protocol_WaitForProgComplete(Write_Memory_Params.ProgrammingMode, PollAddress, PollValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   Write_Memory_Params.DelayMS, Write_Memory_Params.ProgrammingCommands[2]);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Word/byte mode memory programming */\n\t\tfor (uint16_t CurrentByte = 0; CurrentByte < Write_Memory_Params.BytesToWrite; CurrentByte++)\n\t\t{\n\t\t\tbool    IsOddByte   = (CurrentByte & 0x01);\n\t\t\tuint8_t ByteToWrite = *(NextWriteByte++);\n\t\t\n\t\t\tif (IsOddByte && (V2Command == CMD_READ_FLASH_ISP))\n\t\t\t  Write_Memory_Params.ProgrammingCommands[0] |=  READ_WRITE_HIGH_BYTE_MASK;\n\t\t\telse\n\t\t\t  Write_Memory_Params.ProgrammingCommands[0] &= ~READ_WRITE_HIGH_BYTE_MASK;\t\t\t\n\t\t\t  \n\t\t\tSPI_SendByte(Write_Memory_Params.ProgrammingCommands[0]);\n\t\t\tSPI_SendByte(CurrentAddress >> 8);\n\t\t\tSPI_SendByte(CurrentAddress & 0xFF);\n\t\t\tSPI_SendByte(ByteToWrite);\n\t\t\t\n\t\t\tif (ByteToWrite != PollValue)\n\t\t\t{\n\t\t\t\tif (IsOddByte && (V2Command == CMD_PROGRAM_FLASH_ISP))\n\t\t\t\t  Write_Memory_Params.ProgrammingCommands[2] |= READ_WRITE_HIGH_BYTE_MASK;\n\t\t\t\t  \n\t\t\t\tPollAddress = (CurrentAddress & 0xFFFF);\n\t\t\t}\n\n\t\t\tif (IsOddByte || (V2Command == CMD_PROGRAM_EEPROM_ISP))\n\t\t\t  CurrentAddress++;\n\t\t\t\n\t\t\tProgrammingStatus = V2Protocol_WaitForProgComplete(Write_Memory_Params.ProgrammingMode, PollAddress, PollValue,\n\t\t\t                                                   Write_Memory_Params.DelayMS, Write_Memory_Params.ProgrammingCommands[2]);\n\t\t\t  \n\t\t\tif (ProgrammingStatus != STATUS_CMD_OK)\n\t\t\t  break;\n\t\t}\n\t}\n\n\tEndpoint_Write_Byte(V2Command);\n\tEndpoint_Write_Byte(ProgrammingStatus);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const DescriptorAddress)", "code": "{\n\tconst uint8_t  DescriptorType   = (wValue >> 8);\n\tconst uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n\tvoid*    Address = NULL;\n\tuint16_t Size    = NO_DESCRIPTOR;\n\n\tswitch (DescriptorType)\n\t{\n\t\tcase DTYPE_Device: \n\t\t\tAddress = (void*)&DeviceDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Device_t);\n\t\t\tbreak;\n\t\tcase DTYPE_Configuration: \n\t\t\tAddress = (void*)&ConfigurationDescriptor;\n\t\t\tSize    = sizeof(USB_Descriptor_Configuration_t);\n\t\t\tbreak;\n\t\tcase DTYPE_String: \n\t\t\tswitch (DescriptorNumber)\n\t\t\t{\n\t\t\t\tcase 0x00: \n\t\t\t\t\tAddress = (void*)&LanguageString;\n\t\t\t\t\tSize    = pgm_read_byte(&LanguageString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01: \n\t\t\t\t\tAddress = (void*)&ManufacturerString;\n\t\t\t\t\tSize    = pgm_read_byte(&ManufacturerString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x02: \n\t\t\t\t\tAddress = (void*)&ProductString;\n\t\t\t\t\tSize    = pgm_read_byte(&ProductString.Header.Size);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\t*DescriptorAddress = Address;\n\treturn Size;\n}", "path": "gadget\\LUFA\\Demos\\Device\\LowLevel\\MassStorage\\Descriptors.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tJoystick_Init();\n\tLEDs_Init();\n\tButtons_Init();\n\tUSB_Init();\n}", "path": "gadget\\LUFA\\Demos\\Device\\ClassDriver\\Mouse\\Mouse.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_ENTER_PROGMODE_ISP command, which attempts to enter programming mode on\n *  the attached device, returning success or failure back to the host.\n */\n", "func_signal": "static void V2Protocol_Command_EnterISPMode(void)", "code": "{\n\tstruct\n\t{\n\t\tuint8_t TimeoutMS;\n\t\tuint8_t PinStabDelayMS;\n\t\tuint8_t ExecutionDelayMS;\n\t\tuint8_t SynchLoops;\n\t\tuint8_t ByteDelay;\n\t\tuint8_t PollValue;\n\t\tuint8_t PollIndex;\n\t\tuint8_t EnterProgBytes[4];\n\t} Enter_ISP_Params;\n\t\n\tEndpoint_Read_Stream_LE(&Enter_ISP_Params, sizeof(Enter_ISP_Params));\n\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tuint8_t ResponseStatus = STATUS_CMD_FAILED;\n\t\n\tCurrentAddress = 0;\n\n\tV2Protocol_DelayMS(Enter_ISP_Params.ExecutionDelayMS);\t  \n\tSPI_Init(V2Protocol_GetSPIPrescalerMask() | SPI_SCK_LEAD_RISING | SPI_SAMPLE_LEADING | SPI_MODE_MASTER);\n\t\t\n\twhile (Enter_ISP_Params.SynchLoops-- && (ResponseStatus == STATUS_CMD_FAILED))\n\t{\n\t\tuint8_t ResponseBytes[4];\n\n\t\tV2Protocol_ChangeTargetResetLine(true);\n\t\tV2Protocol_DelayMS(Enter_ISP_Params.PinStabDelayMS);\n\n\t\tfor (uint8_t RByte = 0; RByte < sizeof(ResponseBytes); RByte++)\n\t\t{\n\t\t\tV2Protocol_DelayMS(Enter_ISP_Params.ByteDelay);\n\t\t\tResponseBytes[RByte] = SPI_TransferByte(Enter_ISP_Params.EnterProgBytes[RByte]);\n\t\t}\n\t\t\n\t\t/* Check if polling disabled, or if the polled value matches the expected value */\n\t\tif (!(Enter_ISP_Params.PollIndex) || (ResponseBytes[Enter_ISP_Params.PollIndex - 1] == Enter_ISP_Params.PollValue))\n\t\t{\n\t\t\tResponseStatus = STATUS_CMD_OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV2Protocol_ChangeTargetResetLine(false);\n\t\t\tV2Protocol_DelayMS(Enter_ISP_Params.PinStabDelayMS);\n\t\t}\n\t}\n\n\tEndpoint_Write_Byte(CMD_ENTER_PROGMODE_ISP);\n\tEndpoint_Write_Byte(ResponseStatus);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_RESET_PROTECTION command, currently implemented as a dummy ACK function\n *  as no ISP short-circuit protection is currently implemented.\n */\n", "func_signal": "static void V2Protocol_Command_ResetProtection(void)", "code": "{\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\t\n\tEndpoint_Write_Byte(CMD_RESET_PROTECTION);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_ClearIN();\t\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_SPI_MULTI command, writing and reading arbitrary SPI data to and from the attached device. */\n", "func_signal": "static void V2Protocol_Command_SPIMulti(void)", "code": "{\n\tstruct\n\t{\n\t\tuint8_t TxBytes;\n\t\tuint8_t RxBytes;\n\t\tuint8_t RxStartAddr;\n\t\tuint8_t TxData[255];\n\t} SPI_Multi_Params;\n\t\n\tEndpoint_Read_Stream_LE(&SPI_Multi_Params, sizeof(SPI_Multi_Params) - sizeof(SPI_Multi_Params.TxData));\n\tEndpoint_Read_Stream_LE(&SPI_Multi_Params.TxData, SPI_Multi_Params.TxBytes);\n\t\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\t\n\tEndpoint_Write_Byte(CMD_SPI_MULTI);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\n\tuint8_t CurrTxPos = 0;\n\tuint8_t CurrRxPos = 0;\n\n\t/* Write out bytes to transmit until the start of the bytes to receive is met */\n\twhile (CurrTxPos < SPI_Multi_Params.RxStartAddr)\n\t{\n\t\tif (CurrTxPos < SPI_Multi_Params.TxBytes)\n\t\t  SPI_SendByte(SPI_Multi_Params.TxData[CurrTxPos]);\n\t\telse\n\t\t  SPI_SendByte(0);\n\t\t\n\t\tCurrTxPos++;\n\t}\n\n\t/* Transmit remaining bytes with padding as needed, read in response bytes */\n\twhile (CurrRxPos < SPI_Multi_Params.RxBytes)\n\t{\n\t\tif (CurrTxPos < SPI_Multi_Params.TxBytes)\n\t\t  Endpoint_Write_Byte(SPI_TransferByte(SPI_Multi_Params.TxData[CurrTxPos++]));\n\t\telse\n\t\t  Endpoint_Write_Byte(SPI_ReceiveByte());\n\t\t\n\t\tCurrRxPos++;\n\t}\t\n\t\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** HID class driver callback function for the creation of HID reports to the host.\n *\n *  \\param[in] HIDInterfaceInfo  Pointer to the HID class interface configuration structure being referenced\n *  \\param[in,out] ReportID  Report ID requested by the host if non-zero, otherwise callback should set to the generated report ID\n *  \\param[out] ReportData  Pointer to a buffer where the created report should be stored\n *  \\param[out] ReportSize  Number of bytes written in the report (or zero if no report is to be sent\n *\n *  \\return Boolean true to force the sending of the report, false to let the library determine if it needs to be sent\n */\n", "func_signal": "bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo, uint8_t* const ReportID,\n                                         void* ReportData, uint16_t* ReportSize)", "code": "{\n\tUSB_MouseReport_Data_t* MouseReport = (USB_MouseReport_Data_t*)ReportData;\n\t\t\n\tuint8_t JoyStatus_LCL    = Joystick_GetStatus();\n\tuint8_t ButtonStatus_LCL = Buttons_GetStatus();\n\n\tif (JoyStatus_LCL & JOY_UP)\n\t  MouseReport->Y = -1;\n\telse if (JoyStatus_LCL & JOY_DOWN)\n\t  MouseReport->Y =  1;\n\n\tif (JoyStatus_LCL & JOY_LEFT)\n\t  MouseReport->X = -1;\n\telse if (JoyStatus_LCL & JOY_RIGHT)\n\t  MouseReport->X =  1;\n\n\tif (JoyStatus_LCL & JOY_PRESS)\n\t  MouseReport->Button  = (1 << 0);\n\t  \n\tif (ButtonStatus_LCL & BUTTONS_BUTTON1)\n\t  MouseReport->Button |= (1 << 1);\n\t\n\t*ReportSize = sizeof(USB_MouseReport_Data_t);\n\treturn true;\n}", "path": "gadget\\LUFA\\Demos\\Device\\ClassDriver\\Mouse\\Mouse.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Reads and processes an attached device's descriptors, to determine compatibility and pipe configurations. This\n *  routine will read in the entire configuration descriptor, and configure the hosts pipes to correctly communicate\n *  with compatible devices.\n *\n *  This routine searches for a HID interface descriptor containing at least one Interrupt type IN endpoint.\n *\n *  \\return An error code from the \\ref MouseHost_GetConfigDescriptorDataCodes_t enum.\n */\n", "func_signal": "uint8_t ProcessConfigurationDescriptor(void)", "code": "{\n\tuint8_t  ConfigDescriptorData[512];\n\tvoid*    CurrConfigLocation = ConfigDescriptorData;\n\tuint16_t CurrConfigBytesRem;\n\n\t/* Retrieve the entire configuration descriptor into the allocated buffer */\n\tswitch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(ConfigDescriptorData)))\n\t{\n\t\tcase HOST_GETCONFIG_Successful:\n\t\t\tbreak;\n\t\tcase HOST_GETCONFIG_InvalidData:\n\t\t\treturn InvalidConfigDataReturned;\n\t\tcase HOST_GETCONFIG_BuffOverflow:\n\t\t\treturn DescriptorTooLarge;\n\t\tdefault:\n\t\t\treturn ControlError;\n\t}\n\t\n\t/* Get the mouse interface from the configuration descriptor */\n\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t                              DComp_NextMouseInterface) != DESCRIPTOR_SEARCH_COMP_Found)\n\t{\n\t\t/* Descriptor not found, error out */\n\t\treturn NoHIDInterfaceFound;\n\t}\n\n\t/* Get the mouse interface's data endpoint descriptor */\n\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t                              DComp_NextMouseInterfaceDataEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)\n\t{\n\t\t/* Descriptor not found, error out */\n\t\treturn NoEndpointFound;\n\t}\n\t\n\t/* Retrieve the endpoint address from the endpoint descriptor */\n\tUSB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Endpoint_t);\n\n\t/* Configure the mouse data pipe */\n\tPipe_ConfigurePipe(MOUSE_DATAPIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,\n\t                   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);\n\n\t/* Valid data found, return success */\n\treturn SuccessfulConfigRead;\n}", "path": "gadget\\LUFA\\Demos\\Host\\LowLevel\\MouseHost\\ConfigDescriptor.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_SIGN_ON command, returning the programmer ID string to the host. */\n", "func_signal": "static void V2Protocol_Command_SignOn(void)", "code": "{\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tEndpoint_Write_Byte(CMD_SIGN_ON);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_Write_Byte(sizeof(PROGRAMMER_ID) - 1);\n\tEndpoint_Write_Stream_LE(PROGRAMMER_ID, (sizeof(PROGRAMMER_ID) - 1));\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_CHI_ERASE_ISP command, clearing the target's FLASH memory. */\n", "func_signal": "static void V2Protocol_Command_ChipErase(void)", "code": "{\n\tstruct\n\t{\n\t\tuint8_t EraseDelayMS;\n\t\tuint8_t PollMethod;\n\t\tuint8_t EraseCommandBytes[4];\n\t} Erase_Chip_Params;\n\t\n\tEndpoint_Read_Stream_LE(&Erase_Chip_Params, sizeof(Erase_Chip_Params));\n\t\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\t\n\tuint8_t ResponseStatus = STATUS_CMD_OK;\n\t\n\tfor (uint8_t SByte = 0; SByte < sizeof(Erase_Chip_Params.EraseCommandBytes); SByte++)\n\t  SPI_SendByte(Erase_Chip_Params.EraseCommandBytes[SByte]);\n\n\tif (!(Erase_Chip_Params.PollMethod))\n\t  V2Protocol_DelayMS(Erase_Chip_Params.EraseDelayMS);\n\telse\n\t  ResponseStatus = V2Protocol_WaitWhileTargetBusy();\n\t  \n\tEndpoint_Write_Byte(CMD_CHIP_ERASE_ISP);\n\tEndpoint_Write_Byte(ResponseStatus);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next IN Endpoint descriptor inside the current interface descriptor,\n *  aborting the search if another interface descriptor is found before the required endpoint.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextKeyboardInterfaceDataEndpoint(void* CurrentDescriptor)", "code": "{\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Endpoint)\n\t{\n\t\tif (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Endpoint_t).EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)\n\t\t  return DESCRIPTOR_SEARCH_Found;\n\t}\n\telse if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\treturn DESCRIPTOR_SEARCH_Fail;\n\t}\n\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "gadget\\LUFA\\Demos\\Host\\LowLevel\\KeyboardHostWithParser\\ConfigDescriptor.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_LEAVE_ISP command, which releases the target from programming mode. */\n", "func_signal": "static void V2Protocol_Command_LeaveISPMode(void)", "code": "{\n\tstruct\n\t{\n\t\tuint8_t PreDelayMS;\n\t\tuint8_t PostDelayMS;\n\t} Leave_ISP_Params;\n\n\tEndpoint_Read_Stream_LE(&Leave_ISP_Params, sizeof(Leave_ISP_Params));\n\t\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tV2Protocol_DelayMS(Leave_ISP_Params.PreDelayMS);\n\tV2Protocol_ChangeTargetResetLine(false);\n\tSPI_ShutDown();\n\tV2Protocol_DelayMS(Leave_ISP_Params.PostDelayMS);\n\n\tEndpoint_Write_Byte(CMD_LEAVE_PROGMODE_ISP);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for the CMD_READ_FLASH_ISP and CMD_READ_EEPROM_ISP commands, reading in bytes,\n *  words or pages of data from the attached device.\n *\n *  \\param[in] V2Command  Issued V2 Protocol command byte from the host\n */\n", "func_signal": "static void V2Protocol_Command_ReadMemory(uint8_t V2Command)", "code": "{\n\tstruct\n\t{\n\t\tuint16_t BytesToRead;\n\t\tuint8_t  ReadMemoryCommand;\n\t} Read_Memory_Params;\n\t\n\tEndpoint_Read_Stream_LE(&Read_Memory_Params, sizeof(Read_Memory_Params));\n\tRead_Memory_Params.BytesToRead = SwapEndian_16(Read_Memory_Params.BytesToRead);\n\t\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\t\n\tEndpoint_Write_Byte(V2Command);\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\t\n\tfor (uint16_t CurrentByte = 0; CurrentByte < Read_Memory_Params.BytesToRead; CurrentByte++)\n\t{\n\t\tbool IsOddByte = (CurrentByte & 0x01);\n\n\t\tif (IsOddByte && (V2Command == CMD_READ_FLASH_ISP))\n\t\t  Read_Memory_Params.ReadMemoryCommand |=  READ_WRITE_HIGH_BYTE_MASK;\n\t\telse\n\t\t  Read_Memory_Params.ReadMemoryCommand &= ~READ_WRITE_HIGH_BYTE_MASK;\n\n\t\tSPI_SendByte(Read_Memory_Params.ReadMemoryCommand);\n\t\tSPI_SendByte(CurrentAddress >> 8);\n\t\tSPI_SendByte(CurrentAddress & 0xFF);\n\t\tEndpoint_Write_Byte(SPI_ReceiveByte());\n\t\t\n\t\t/* Check if the endpoint bank is currently full */\n\t\tif (!(Endpoint_IsReadWriteAllowed()))\n\t\t{\n\t\t\tEndpoint_ClearIN();\n\t\t\tEndpoint_WaitUntilReady();\n\t\t}\n\t\t\n\t\tif ((IsOddByte && (V2Command == CMD_READ_FLASH_ISP)) || (V2Command == CMD_READ_EEPROM_ISP))\n\t\t  CurrentAddress++;\n\t}\n\n\tEndpoint_Write_Byte(STATUS_CMD_OK);\n\n\tbool IsEndpointFull = !(Endpoint_IsReadWriteAllowed());\n\tEndpoint_ClearIN();\n\t\n\t/* Ensure last packet is a short packet to terminate the transfer */\n\tif (IsEndpointFull)\n\t{\n\t\tEndpoint_WaitUntilReady();\t\n\t\tEndpoint_ClearIN();\n\t\tEndpoint_WaitUntilReady();\t\n\t}\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/** Handler for unknown V2 protocol commands. This discards all sent data and returns a\n *  STATUS_CMD_UNKNOWN status back to the host.\n *\n *  \\param[in] V2Command  Issued V2 Protocol command byte from the host\n */\n", "func_signal": "static void V2Protocol_Command_Unknown(uint8_t V2Command)", "code": "{\n\t/* Discard all incoming data */\n\twhile (Endpoint_BytesInEndpoint() == AVRISP_DATA_EPSIZE)\n\t{\n\t\tEndpoint_ClearOUT();\n\t\tEndpoint_WaitUntilReady();\n\t}\n\n\tEndpoint_ClearOUT();\n\tEndpoint_SetEndpointDirection(ENDPOINT_DIR_IN);\n\n\tEndpoint_Write_Byte(V2Command);\n\tEndpoint_Write_Byte(STATUS_CMD_UNKNOWN);\n\tEndpoint_ClearIN();\n}", "path": "gadget\\LUFA\\Projects\\AVRISP\\Lib\\V2Protocol.c", "repo_name": "TomMD/teensy", "stars": 8, "license": "None", "language": "c", "size": 2638}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Copy the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    target  target address to copy to\n  @param    def     Default value if key not found, which can be the same pointer as target\n  @param    maxLen  Maximum length of target\n  \n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\".\n  The dictionary content for the key will be copied into target for maxLen.\n  If the key cannot be found, the content in 'def' will be copied instead.\n  def can be the same pointer as target. \n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_copystring(dictionary * d, char * key, char *target, char * def, int maxLen)", "code": "{\n    char * lc_key ;\n    char * sval ;\n\n    if (d==NULL || key==NULL)\n        return;\n\n\t// Check whether the dictionary is case-sensitive\n\tif (d->caseSensitive) {\n\t\tlc_key = inistrdup(key);\n\t} else {\n        lc_key = inistrdup(inistrlwc(key));\n\t}\n    sval = dictionary_get(d, lc_key, def);\n    free(lc_key);\n\n\tif (target != sval) {\n\t\tstrncpy(target, sval, maxLen);\n\t\ttarget[maxLen] = '\\0';\n\t}\n\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/** returns TRUE if there is single triplet in the sequence considered */\n", "func_signal": "static unsigned char wo1 (int len, unsigned char* seq, int iwo, DCURLOC* cloc)", "code": "{\n   unsigned int sum;\n\tint loop;\n\n\tshort* countsptr;\n\tshort counts[4*4*4];\n\tunsigned char triplet_count = 0;\n\n\tmemset (counts, 0, sizeof (counts));\n/* zero everything */\n\tsum = 0;\n\n/* dust loop -- specific for triplets\t*/\n\tfor (loop = 0; loop < len; loop++)\n\t{\n\t\tcountsptr = &counts[*seq++];\n\t\tif (*countsptr)\n\t\t{\n\t\t\tsum += (unsigned int)(*countsptr);\n\n\t\t    if (sum >= SUM_THRESHOLD[loop])\n\t\t    {\n\t\t\tif ((unsigned int)cloc->cursum*loop < sum*cloc->curlength)\n\t\t\t{\n\t\t\t\tcloc->cursum = sum;\n\t\t\t\tcloc->curlength = (short)loop;\n\t\t\t\tcloc->curstart = iwo;\n\t\t\t\tcloc->curend = loop + 2; /* triplets */\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t\ttriplet_count++;\n\t\t(*countsptr)++;\n\t}\n\n\tif (triplet_count > 1)\n\t\treturn(FALSE);\n\treturn(TRUE);\n}", "path": "blast_dust.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of argument in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of argument found in dictionary\n\n  This function returns the number of argument found in a dictionary.\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int paraparser_getnargument(dictionary * d)", "code": "{\n    int i ;\n    int nsec ;\n\n    if (d==NULL) return -1 ;\n    nsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n\t\tif (strncmp(d->key[i], \"argument:\", 9)==0) {\n            nsec ++ ;\n        }\n    }\n    return nsec ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Return the dictionary entry for an argument\n  @param    dictionary, argument number\n  @return   dictionary entry\n\n  Return the dictionary entry for an argument.\n  Used for looping on variable argument list.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "char* paraparser_argument(dictionary *d, int argumentNumber)", "code": "{\n    int i ;\n    int foundsec ;\n\n    if (d==NULL || argumentNumber<0) return NULL ;\n    foundsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n\t\tif (strncmp(d->key[i], \"argument:\", 9)==0) {\n            foundsec++ ;\n            if (foundsec>argumentNumber)\n                break ;\n        }\n    }\n    if (foundsec<=argumentNumber) {\n        return NULL ;\n    }\n    return d->key[i] ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "// Input SA index is in evenIterationSaIndexList and must be sorted in increasing SA index order\n// Input SA index must not be zero\n// If maxnumOfIteration is set, undecoded SA index is in evenIterationSaIndexList if maxnumOfIteration is even or \n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toddIterationSaIndexList if maxnumOfIteration is odd\n// The number of undecoded SA is returned\n", "func_signal": "unsigned int BWTDecodeTextPosition(const BWT *bwt, SaIndexList* __restrict evenIterationSaIndexList, SaIndexList* __restrict oddIterationSaIndexList,\n\t\t\t\t\t\t  const unsigned int numOfSaIndex, const unsigned int numOfIterationProcessed, const unsigned int maxnumOfIteration, \n\t\t\t\t\t\t  HitList* __restrict hitList, BWTSaRetrievalStatistics* __restrict bwtSaRetrievalStatistics)", "code": "{\n\n\t#define\tCHAR_GAP_THRESHOLD\t16\n\t#define\tWORD_GAP_THRESHOLD\t128\n\n\tunsigned int iteration;\n\tunsigned int numOfSaToDecode;\n\tunsigned int numOfUndecodedSa, numOfSaProcessed;\n\tunsigned int occValue[ALPHABET_SIZE];\n\tunsigned int undecodedSaBwtCharCount[ALPHABET_SIZE + 1];\n\n\tunsigned int firstSaIndex, lastSaIndexInPrevGroup;\n\tunsigned int saIndexAdjustment;\n\tunsigned int numOfSaToProcess, maxnumOfSaToProcess, saIndexLimit;\n\tunsigned int lastBwtWordOffset, lastBwtBitOffset;\n\tunsigned int bwtWordOffset, bwtBitOffset;\n\n\tunsigned int i, c, sum, bwtChar;\n\tunsigned int firstBwtChar;\n\tunsigned int saIndex;\n\n\n\tfirstBwtChar = bwt->bwtCode[0] >> (BITS_IN_WORD - BIT_PER_CHAR);\n\n\t// First decode SA index with saIndex % saInterval == 0\n\tif (numOfIterationProcessed == 0) {\n\t\tnumOfSaProcessed = 0;\n\t\tnumOfUndecodedSa = 0;\n\t\twhile (numOfSaProcessed < numOfSaIndex) {\n\t\t\tif (evenIterationSaIndexList[numOfSaProcessed].saIndex % bwt->saInterval != 0) {\n\t\t\t\t// Pack undecoded SA to the front\n\t\t\t\tif (numOfSaProcessed > numOfUndecodedSa) {\n\t\t\t\t\tevenIterationSaIndexList[numOfUndecodedSa].saIndex = evenIterationSaIndexList[numOfSaProcessed].saIndex;\n\t\t\t\t\tevenIterationSaIndexList[numOfUndecodedSa].textPositionIndex = evenIterationSaIndexList[numOfSaProcessed].textPositionIndex;\n\t\t\t\t}\n\t\t\t\tnumOfUndecodedSa++;\n\t\t\t} else {\n\t\t\t\t// decode the text position\n\t\t\t\thitList[evenIterationSaIndexList[numOfSaProcessed].textPositionIndex].posText = numOfIterationProcessed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           + bwt->saValue[evenIterationSaIndexList[numOfSaProcessed].saIndex / bwt->saInterval];\n\t\t\t\tbwtSaRetrievalStatistics->bwtSaRetrieved++;\n\t\t\t}\n\t\t\tnumOfSaProcessed++;\n\t\t}\n\t} else {\n\t\tnumOfUndecodedSa = numOfSaIndex;\n\t}\n\n\n\t// This while loop processes 2 iterations at a time\n\t// The codes for both odd and even iterations are the same except for the source and target SA index list (to avoid aliasing)\n\n\titeration = 0;\n\n\twhile (numOfUndecodedSa > 0 && iteration < maxnumOfIteration) {\n\n\t\t// Odd iteration; input in evenIterationSaIndexList; output to oddIterationSaIndexList\n\n\t\tnumOfSaProcessed = 0;\n\t\tlastSaIndexInPrevGroup = 0;\n\t\toccValue[0] = 0;\n\t\toccValue[1] = 0;\n\t\toccValue[2] = 0;\n\t\toccValue[3] = 0;\n\t\toccValue[firstBwtChar] = 1;\n\t\tundecodedSaBwtCharCount[0] = 0;\n\t\tundecodedSaBwtCharCount[1] = 0;\n\t\tundecodedSaBwtCharCount[2] = 0;\n\t\tundecodedSaBwtCharCount[3] = 0;\n\t\tundecodedSaBwtCharCount[4] = 0;\n\t\tlastBwtWordOffset = 0;\n\t\tlastBwtBitOffset = BIT_PER_CHAR;\n\n\t\twhile (numOfSaProcessed < numOfUndecodedSa) {\n\n\t\t\tfirstSaIndex = evenIterationSaIndexList[numOfSaProcessed].saIndex;\n\n\t\t\t// keep SA index in a group either < or > inverseSa0\n\t\t\tif (firstSaIndex < bwt->inverseSa0) {\n\t\t\t\tsaIndexLimit = bwt->inverseSa0;\n\t\t\t\tsaIndexAdjustment = 0;\n\t\t\t} else {\n\t\t\t\tif (firstSaIndex > bwt->inverseSa0) {\n\t\t\t\t\tsaIndexLimit = ALL_ONE_MASK;\n\t\t\t\t\tsaIndexAdjustment = (unsigned int)-1;\t// $ in BWT is not encoded\n\t\t\t\t} else {\n\t\t\t\t\t// Decode the SA when SA index = inverseSa0\n\t\t\t\t\thitList[evenIterationSaIndexList[numOfSaProcessed].textPositionIndex].posText = numOfIterationProcessed + iteration;\n\t\t\t\t\tevenIterationSaIndexList[numOfSaProcessed].saIndex = 0;\t// mark as decoded\n\t\t\t\t\tlastSaIndexInPrevGroup = bwt->inverseSa0;\n\t\t\t\t\tnumOfSaProcessed++;\n\t\t\t\t\tbwtSaRetrievalStatistics->bwtSaRetrieved++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find a group of near consecutive SA index\n\n\t\t\tnumOfSaToProcess = 1;\n\t\t\tmaxnumOfSaToProcess = numOfUndecodedSa - numOfSaProcessed;\n\n\t\t\twhile (numOfSaToProcess < maxnumOfSaToProcess &&\n\t\t\t\t   evenIterationSaIndexList[numOfSaProcessed + numOfSaToProcess].saIndex\n\t\t\t\t    - evenIterationSaIndexList[numOfSaProcessed + numOfSaToProcess - 1].saIndex < CHAR_GAP_THRESHOLD &&\n\t\t\t\t   evenIterationSaIndexList[numOfSaProcessed + numOfSaToProcess].saIndex < saIndexLimit) {\n\t\t\t\tnumOfSaToProcess++;\n\t\t\t}\n\n\t\t\t// Find the occurrence count of the first SA index (up to the character before firstSaIndex)\n\t\t\tbwtWordOffset = (firstSaIndex + saIndexAdjustment) / CHAR_PER_WORD;\n\t\t\tbwtBitOffset = ((firstSaIndex + saIndexAdjustment) % CHAR_PER_WORD) * BIT_PER_CHAR;\n\n\t\t\tif (firstSaIndex - lastSaIndexInPrevGroup >= WORD_GAP_THRESHOLD ||\n\t\t\t\t(lastSaIndexInPrevGroup <= bwt->inverseSa0 && firstSaIndex > bwt->inverseSa0)) {\n\n\t\t\t\t// retrieve occurrence count without making use of last occurrence value information\n\t\t\t\tBWTAllOccValue(bwt, firstSaIndex, occValue);\t// SA index is adjusted in BWTALLOccValue()\n\n\t\t\t} else {\n\n\t\t\t\t// Advance by retrieving BWT only\n\t\t\t\t// The BWT character pointed by wordOffset+bitOffset is not counted\n\n\t\t\t\t#ifdef DEBUG\n\t\t\t\tif (bwtWordOffset < lastBwtWordOffset) {\n\t\t\t\t\tfprintf(stderr, \"BWTDecodeTextPosition(): bwtIndex < lastBwtIndex!\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\t// first advance to the next word boundary\n\t\t\t\tsum = 0;\n\t\t\t\t// The whole word = lastBwtWordOffset is counted\n\t\t\t\tif (lastBwtBitOffset > 0) {\n\t\t\t\t\tc = bwt->bwtCode[lastBwtWordOffset] & (ALL_ONE_MASK >> lastBwtBitOffset);\n\t\t\t\t\tsum += (bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF]) - lastBwtBitOffset / BIT_PER_CHAR;\n\t\t\t\t\tlastBwtBitOffset = 0;\n\t\t\t\t\tlastBwtWordOffset++;\n\t\t\t\t}\n\t\t\t\twhile (lastBwtWordOffset <= bwtWordOffset) {\n\t\t\t\t\tc = bwt->bwtCode[lastBwtWordOffset];\n\t\t\t\t\tsum += bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF];\n\t\t\t\t\tlastBwtWordOffset++;\n\t\t\t\t}\n\t\t\t\t// Subtract the remaining in bwtWordOffset\n\t\t\t\tc = bwt->bwtCode[bwtWordOffset] & (ALL_ONE_MASK >> bwtBitOffset);\n\t\t\t\tsum -= (bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF]) - bwtBitOffset / BIT_PER_CHAR;\n\n\t\t\t\toccValue[0] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[1] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[2] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[3] += sum;\n\n\t\t\t}\n\n\t\t\t// Decode the SA range for the group\n\t\t\tlastSaIndexInPrevGroup = evenIterationSaIndexList[numOfSaProcessed + numOfSaToProcess - 1].saIndex;\n\t\t\tnumOfSaToDecode = lastSaIndexInPrevGroup - firstSaIndex + 1;\n\n\t\t\tsaIndex = firstSaIndex;\n\t\t\tc = bwt->bwtCode[bwtWordOffset] << bwtBitOffset;\n\n\t\t\tfor (i=0; i<numOfSaToDecode; i++) {\n\n\t\t\t\tbwtChar = c >> (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\toccValue[bwtChar]++;\n\n\t\t\t\tif (saIndex == evenIterationSaIndexList[numOfSaProcessed].saIndex) {\n\t\t\t\t\tif ((occValue[bwtChar] + bwt->cumulativeFreq[bwtChar]) % bwt->saInterval != 0) {\n\t\t\t\t\t\tevenIterationSaIndexList[numOfSaProcessed].textPositionIndex |= bwtChar << (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\t\t\tevenIterationSaIndexList[numOfSaProcessed].saIndex = occValue[bwtChar] + bwt->cumulativeFreq[bwtChar];\n\t\t\t\t\t\tundecodedSaBwtCharCount[bwtChar + 1]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// decode the text position\n\t\t\t\t\t\thitList[evenIterationSaIndexList[numOfSaProcessed].textPositionIndex].posText = numOfIterationProcessed + iteration + 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           + bwt->saValue[(occValue[bwtChar] + bwt->cumulativeFreq[bwtChar]) / bwt->saInterval];\n\t\t\t\t\t\tevenIterationSaIndexList[numOfSaProcessed].saIndex = 0;\t// mark as decoded\n\t\t\t\t\t\tbwtSaRetrievalStatistics->bwtSaRetrieved++;\n\t\t\t\t\t}\n\t\t\t\t\tnumOfSaProcessed++;\n\t\t\t\t}\n\n\t\t\t\tsaIndex++;\n\t\t\t\tc <<= BIT_PER_CHAR;\n\t\t\t\tbwtBitOffset += BIT_PER_CHAR;\n\t\t\t\tif (bwtBitOffset >= BITS_IN_WORD) {\n\t\t\t\t\tbwtBitOffset = 0;\n\t\t\t\t\tbwtWordOffset++;\n\t\t\t\t\tc = bwt->bwtCode[bwtWordOffset];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlastBwtWordOffset = bwtWordOffset;\n\t\t\tlastBwtBitOffset = bwtBitOffset;\n\n\t\t}\n\n\t\tundecodedSaBwtCharCount[2] += undecodedSaBwtCharCount[1];\n\t\tundecodedSaBwtCharCount[3] += undecodedSaBwtCharCount[2];\n\t\tundecodedSaBwtCharCount[4] += undecodedSaBwtCharCount[3];\n\n\t\t// Stable bucket sort the decoded SA into olddIterationSaIndexList\n\t\tfor (i=0; i<numOfSaProcessed; i++) {\n\t\t\tif (evenIterationSaIndexList[i].saIndex != 0) {\n\t\t\t\tbwtChar = evenIterationSaIndexList[i].textPositionIndex >> (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\toddIterationSaIndexList[undecodedSaBwtCharCount[bwtChar]].saIndex = evenIterationSaIndexList[i].saIndex;\n\t\t\t\toddIterationSaIndexList[undecodedSaBwtCharCount[bwtChar]].textPositionIndex = evenIterationSaIndexList[i].textPositionIndex & (ALL_ONE_MASK >> BIT_PER_CHAR);\n\t\t\t\tundecodedSaBwtCharCount[bwtChar]++;\n\t\t\t}\n\t\t}\n\n\t\titeration++;\n\t\tnumOfUndecodedSa = undecodedSaBwtCharCount[4];\n\n\t\tif (numOfUndecodedSa == 0 || iteration >= maxnumOfIteration) {\n\t\t\tbreak;\n\t\t}\n\n\n\t\t// Even iteration; input in oddIterationSaIndexList; output to evenIterationSaIndexList\n\n\t\tnumOfSaProcessed = 0;\n\t\tlastSaIndexInPrevGroup = 0;\n\t\toccValue[0] = 0;\n\t\toccValue[1] = 0;\n\t\toccValue[2] = 0;\n\t\toccValue[3] = 0;\n\t\toccValue[firstBwtChar] = 1;\n\t\tundecodedSaBwtCharCount[0] = 0;\n\t\tundecodedSaBwtCharCount[1] = 0;\n\t\tundecodedSaBwtCharCount[2] = 0;\n\t\tundecodedSaBwtCharCount[3] = 0;\n\t\tundecodedSaBwtCharCount[4] = 0;\n\t\tlastBwtWordOffset = 0;\n\t\tlastBwtBitOffset = BIT_PER_CHAR;\n\n\t\twhile (numOfSaProcessed < numOfUndecodedSa) {\n\n\t\t\tfirstSaIndex = oddIterationSaIndexList[numOfSaProcessed].saIndex;\n\n\t\t\t// keep SA index in a group either < or > inverseSa0\n\t\t\tif (firstSaIndex < bwt->inverseSa0) {\n\t\t\t\tsaIndexLimit = bwt->inverseSa0;\n\t\t\t\tsaIndexAdjustment = 0;\n\t\t\t} else {\n\t\t\t\tif (firstSaIndex > bwt->inverseSa0) {\n\t\t\t\t\tsaIndexLimit = ALL_ONE_MASK;\n\t\t\t\t\tsaIndexAdjustment = (unsigned int)-1;\t// $ in BWT is not encoded\n\t\t\t\t} else {\n\t\t\t\t\t// Decode the SA when SA index = inverseSa0\n\t\t\t\t\thitList[oddIterationSaIndexList[numOfSaProcessed].textPositionIndex].posText = numOfIterationProcessed + iteration;\n\t\t\t\t\toddIterationSaIndexList[numOfSaProcessed].saIndex = 0;\t// mark as decoded\n\t\t\t\t\tlastSaIndexInPrevGroup = bwt->inverseSa0;\n\t\t\t\t\tnumOfSaProcessed++;\n\t\t\t\t\tbwtSaRetrievalStatistics->bwtSaRetrieved++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find a group of near consecutive SA index\n\n\t\t\tnumOfSaToProcess = 1;\n\t\t\tmaxnumOfSaToProcess = numOfUndecodedSa - numOfSaProcessed;\n\n\t\t\twhile (numOfSaToProcess < maxnumOfSaToProcess &&\n\t\t\t\t   oddIterationSaIndexList[numOfSaProcessed + numOfSaToProcess].saIndex\n\t\t\t\t    - oddIterationSaIndexList[numOfSaProcessed + numOfSaToProcess - 1].saIndex < CHAR_GAP_THRESHOLD &&\n\t\t\t\t   oddIterationSaIndexList[numOfSaProcessed + numOfSaToProcess].saIndex < saIndexLimit) {\n\t\t\t\tnumOfSaToProcess++;\n\t\t\t}\n\n\t\t\t// Find the occurrence count of the first SA index (up to the character before firstSaIndex)\n\t\t\tbwtWordOffset = (firstSaIndex + saIndexAdjustment) / CHAR_PER_WORD;\n\t\t\tbwtBitOffset = ((firstSaIndex + saIndexAdjustment) % CHAR_PER_WORD) * BIT_PER_CHAR;\n\n\t\t\tif (firstSaIndex - lastSaIndexInPrevGroup >= WORD_GAP_THRESHOLD ||\n\t\t\t\t(lastSaIndexInPrevGroup <= bwt->inverseSa0 && firstSaIndex > bwt->inverseSa0)) {\n\n\t\t\t\t// retrieve occurrence count without making use of last occurrence value information\n\t\t\t\tBWTAllOccValue(bwt, firstSaIndex, occValue);\t// SA index is adjusted in BWTALLOccValue()\n\n\t\t\t} else {\n\n\t\t\t\t// Advance by retrieving BWT only\n\t\t\t\t// The BWT character pointed by wordOffset+bitOffset is not counted\n\n\t\t\t\t#ifdef DEBUG\n\t\t\t\tif (bwtWordOffset < lastBwtWordOffset) {\n\t\t\t\t\tfprintf(stderr, \"BWTDecodeTextPosition(): bwtIndex < lastBwtIndex!\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\t// first advance to the next word boundary\n\t\t\t\tsum = 0;\n\t\t\t\t// The whole word = lastBwtWordOffset is counted\n\t\t\t\tif (lastBwtBitOffset > 0) {\n\t\t\t\t\tc = bwt->bwtCode[lastBwtWordOffset] & (ALL_ONE_MASK >> lastBwtBitOffset);\n\t\t\t\t\tsum += (bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF]) - lastBwtBitOffset / BIT_PER_CHAR;\n\t\t\t\t\tlastBwtBitOffset = 0;\n\t\t\t\t\tlastBwtWordOffset++;\n\t\t\t\t}\n\t\t\t\twhile (lastBwtWordOffset <= bwtWordOffset) {\n\t\t\t\t\tc = bwt->bwtCode[lastBwtWordOffset];\n\t\t\t\t\tsum += bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF];\n\t\t\t\t\tlastBwtWordOffset++;\n\t\t\t\t}\n\t\t\t\t// Subtract the remaining in bwtWordOffset\n\t\t\t\tc = bwt->bwtCode[bwtWordOffset] & (ALL_ONE_MASK >> bwtBitOffset);\n\t\t\t\tsum -= (bwt->decodeTable[c >> 16] + bwt->decodeTable[c & 0xFFFF]) - bwtBitOffset / BIT_PER_CHAR;\n\n\t\t\t\toccValue[0] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[1] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[2] += sum & 0x000000FF;\tsum >>= 8;\n\t\t\t\toccValue[3] += sum;\n\n\t\t\t}\n\n\t\t\t// Decode the SA range for the group to bufferDecodedSaIndex\n\t\t\tlastSaIndexInPrevGroup = oddIterationSaIndexList[numOfSaProcessed + numOfSaToProcess - 1].saIndex;\n\t\t\tnumOfSaToDecode = lastSaIndexInPrevGroup - firstSaIndex + 1;\n\n\t\t\tsaIndex = firstSaIndex;\n\t\t\tc = bwt->bwtCode[bwtWordOffset] << bwtBitOffset;\n\n\t\t\tfor (i=0; i<numOfSaToDecode; i++) {\n\n\t\t\t\tbwtChar = c >> (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\toccValue[bwtChar]++;\n\n\t\t\t\tif (saIndex == oddIterationSaIndexList[numOfSaProcessed].saIndex) {\n\t\t\t\t\tif ((occValue[bwtChar] + bwt->cumulativeFreq[bwtChar]) % bwt->saInterval != 0) {\n\t\t\t\t\t\toddIterationSaIndexList[numOfSaProcessed].textPositionIndex |= bwtChar << (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\t\t\toddIterationSaIndexList[numOfSaProcessed].saIndex = occValue[bwtChar] + bwt->cumulativeFreq[bwtChar];\n\t\t\t\t\t\tundecodedSaBwtCharCount[bwtChar + 1]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// decode the text position\n\t\t\t\t\t\thitList[oddIterationSaIndexList[numOfSaProcessed].textPositionIndex].posText = numOfIterationProcessed + iteration + 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   + bwt->saValue[(occValue[bwtChar] + bwt->cumulativeFreq[bwtChar]) / bwt->saInterval];\n\t\t\t\t\t\toddIterationSaIndexList[numOfSaProcessed].saIndex = 0;\t// mark as decoded\n\t\t\t\t\t\tbwtSaRetrievalStatistics->bwtSaRetrieved++;\n\t\t\t\t\t}\n\t\t\t\t\tnumOfSaProcessed++;\n\t\t\t\t}\n\n\t\t\t\tsaIndex++;\n\t\t\t\tc <<= BIT_PER_CHAR;\n\t\t\t\tbwtBitOffset += BIT_PER_CHAR;\n\t\t\t\tif (bwtBitOffset >= BITS_IN_WORD) {\n\t\t\t\t\tbwtBitOffset = 0;\n\t\t\t\t\tbwtWordOffset++;\n\t\t\t\t\tc = bwt->bwtCode[bwtWordOffset];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlastBwtWordOffset = bwtWordOffset;\n\t\t\tlastBwtBitOffset = bwtBitOffset;\n\n\t\t}\n\n\t\tundecodedSaBwtCharCount[2] += undecodedSaBwtCharCount[1];\n\t\tundecodedSaBwtCharCount[3] += undecodedSaBwtCharCount[2];\n\t\tundecodedSaBwtCharCount[4] += undecodedSaBwtCharCount[3];\n\n\t\t// Stable bucket sort the decoded SA into olddIterationSaIndexList\n\t\tfor (i=0; i<numOfSaProcessed; i++) {\n\t\t\tif (oddIterationSaIndexList[i].saIndex != 0) {\n\t\t\t\tbwtChar = oddIterationSaIndexList[i].textPositionIndex >> (BITS_IN_WORD - BIT_PER_CHAR);\n\t\t\t\tevenIterationSaIndexList[undecodedSaBwtCharCount[bwtChar]].saIndex = oddIterationSaIndexList[i].saIndex;\n\t\t\t\tevenIterationSaIndexList[undecodedSaBwtCharCount[bwtChar]].textPositionIndex = oddIterationSaIndexList[i].textPositionIndex & (ALL_ONE_MASK >> BIT_PER_CHAR);\n\t\t\t\tundecodedSaBwtCharCount[bwtChar]++;\n\t\t\t}\n\t\t}\n\n\t\titeration++;\n\t\tnumOfUndecodedSa = undecodedSaBwtCharCount[4];\n\n\t}\n\n\treturn numOfUndecodedSa;\n\n}", "path": "BWT.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int 0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, -1 is returned.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_setstr(dictionary * ini, char * entry, char * val)", "code": "{\n\t// Check whether the dictionary is case-sensitive\n\tif (ini->caseSensitive) {\n\t\tdictionary_set(ini, entry, val);\n\t} else {\n        dictionary_set(ini, inistrlwc(entry), val);\n\t}\n    \n    return 0 ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "// This is a version making use of saIndexRange and is with bug\n", "func_signal": "unsigned int BWTEditDistMatch(const unsigned char *convertedKey, const unsigned int keyLength, const BWT *bwt, const unsigned int maxError,\n\t\t\t\t\t const SaIndexRange *saIndexRange, const unsigned int saIndexRangeNumOfChar,\n\t\t\t\t\t SaIndexGroupWithLengthError* __restrict saIndexGroup, const unsigned int maxSaIndexGroup)", "code": "{\n\n\t// stack\n\tunsigned int startSaIndex[MAX_ARPROX_MATCH_LENGTH + 1];\n\tunsigned int endSaIndex[MAX_ARPROX_MATCH_LENGTH+1];\n\tunsigned char generatedPattern[MAX_ARPROX_MATCH_LENGTH+1];\n\tunsigned int errorPos[MAX_APPROX_MATCH_ERROR + 1];\n\tunsigned int errorPosLength[MAX_APPROX_MATCH_ERROR + 1];\n\n\t// for insertion\n\tunsigned int startSaIndexBefore[MAX_APPROX_MATCH_ERROR + 1];\n\tunsigned int endSaIndexBefore[MAX_APPROX_MATCH_ERROR+1];\n\tunsigned char charBefore[MAX_APPROX_MATCH_ERROR + 1];\n\tunsigned int saRangeIndexBefore[MAX_APPROX_MATCH_ERROR + 1];\n\n\tunsigned int numOfSaGroup;\n\tunsigned int numOfError;\n\n\tunsigned int c, e;\n\tunsigned int errorAdded;\n\tunsigned char maxPatternValue;\n\tunsigned int tempSaIndexLeft, tempSaIndexRight;\n\n\tunsigned int length;\n\n\tunsigned int exceedMaxSaIndexGroupPrinted = FALSE;\n\n\tunsigned int saRangeIndex;\n\tunsigned int saIndexRangeLength;\n\n\t#ifdef DEBUG\n\tif (maxError > keyLength) {\n\t\tfprintf(stderr, \"BWTEditDistMatch() : maxError > keyLength!\\n\");\n\t\texit(1);\n\t}\n\tif (keyLength > MAX_ARPROX_MATCH_LENGTH) {\n\t\tfprintf(stderr, \"BWTEditDistMatch() : keyLength > MAX_ARPROX_MATCH_LENGTH!\\n\");\n\t\texit(1);\n\t}\n\tif (maxError > MAX_APPROX_MATCH_ERROR) {\n\t\tfprintf(stderr, \"BWTEditDistMatch() : maxError > MAX_APPROX_MATCH_ERROR!\\n\");\n\t\texit(1);\n\t}\n\t#endif\n\n\t// Setup for looking up SA index range\n\tif (saIndexRangeNumOfChar <= keyLength - maxError) {\n\t\tsaIndexRangeLength = saIndexRangeNumOfChar;\n\t} else {\n\t\tsaIndexRangeLength = 0;\n\t}\n\n\t// Set this boundary case so that the last character of generated pattern can be located by backward search\n\tstartSaIndex[keyLength] = 0;\n\tendSaIndex[keyLength] = bwt->textLength;\n\tmaxPatternValue = (unsigned char)(ALPHABET_SIZE * 2);\t// 0 to alphabetSize - 1 = edit; alphabetSize = delete; alphabetSize + 1 to alphabetsize * 2 = insert\n\n\t// Exact match\n\tnumOfSaGroup = BWTBackwardSearch(convertedKey, keyLength, bwt, &tempSaIndexLeft, &tempSaIndexRight);\n\tif (numOfSaGroup > 0) {\n\t\tsaIndexGroup[0].startSaIndex = tempSaIndexLeft;\n\t\tsaIndexGroup[0].numOfMatch = tempSaIndexRight - tempSaIndexLeft + 1;\n\t\tsaIndexGroup[0].length = keyLength;\n\t\tsaIndexGroup[0].error = 0;\n\t}\n\n\t// With errors\n\tfor (numOfError = 1; numOfError <= maxError; numOfError++) {\n\n\t\tmemcpy(generatedPattern, convertedKey, keyLength);\n\n\t\t// Set initial state\n\t\te = errorPos[1] = keyLength - 1;\n\t\terrorPosLength[1] = 1;\n\t\tgeneratedPattern[e] = (unsigned char)-1;\n\t\terrorAdded = 1;\n\t\tsaRangeIndex = 0;\n\n\t\t// store before change data\n\t\tc = charBefore[1] = convertedKey[e];\n\t\tstartSaIndexBefore[1] = bwt->cumulativeFreq[c] + 1;\n\t\tendSaIndexBefore[1] = bwt->cumulativeFreq[c+1];\n\t\t//startSaIndexBefore[1] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, startSaIndex[e+1], c) + 1;\n\t\t//endSaIndexBefore[1] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, endSaIndex[e+1] + 1, c);\n\t\tsaRangeIndexBefore[1] = c;\n\n\t\twhile (errorAdded > 0) {\n\t\t\t\n\t\t\t// Increment the last error\n\t\t\te = errorPos[errorAdded];\n\t\t\tlength = errorPosLength[errorAdded];\n\t\t\tif (length < saIndexRangeNumOfChar + 1) {\n\t\t\t\tsaRangeIndex >>= (saIndexRangeNumOfChar - length + 1) * BIT_PER_CHAR;\n\t\t\t}\n\t\t\tgeneratedPattern[e]++;\n\t\t\tif (generatedPattern[e] == convertedKey[e]) {\n\t\t\t\tgeneratedPattern[e]++;\n\t\t\t}\n\t\t\tif (generatedPattern[e] > maxPatternValue) {\n\n\t\t\t\t// Cannot increment the last error; try moving the error to the left\n\t\t\t\tif (e > 1 || (e == 1 && numOfError - errorAdded == 0)) {\t// only the last error can move to the leftmost position as insertion is not done on pattern boundary\n\n\t\t\t\t\t// restore before change data\n\t\t\t\t\tc = generatedPattern[e] = charBefore[errorAdded];\n\t\t\t\t\tif (startSaIndexBefore[errorAdded] <= endSaIndexBefore[errorAdded] || length <= saIndexRangeLength) {\n\t\t\t\t\t\tstartSaIndex[e] = startSaIndexBefore[errorAdded];\n\t\t\t\t\t\tendSaIndex[e] = endSaIndexBefore[errorAdded];\n\t\t\t\t\t\tsaRangeIndex = saRangeIndexBefore[errorAdded];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Pattern suffix not found\n\t\t\t\t\t\terrorAdded--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// move error\n\t\t\t\t\terrorPos[errorAdded]--;\n\t\t\t\t\te = errorPos[errorAdded];\n\t\t\t\t\tgeneratedPattern[e] = (convertedKey[e] == 0);\t// 1 if convertedKey = 0, 0 otherwise\n\n\t\t\t\t\t// store before change data\n\t\t\t\t\tc = charBefore[errorAdded] = convertedKey[e];\n\n\t\t\t\t\tlength++;\n\t\t\t\t\terrorPosLength[errorAdded] = length;\n\t\t\t\t\tif (length <= saIndexRangeLength) {\n\t\t\t\t\t\tsaRangeIndexBefore[errorAdded] = (saRangeIndex << BIT_PER_CHAR) | c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (length > saIndexRangeLength + 1) {\n\t\t\t\t\t\t\tstartSaIndexBefore[errorAdded] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, startSaIndex[e+1], c) + 1;\n\t\t\t\t\t\t\tendSaIndexBefore[errorAdded] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, endSaIndex[e+1] + 1, c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstartSaIndexBefore[errorAdded] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].startSaIndex, c) + 1;\n\t\t\t\t\t\t\tendSaIndexBefore[errorAdded] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].endSaIndex + 1, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// Cannot move error to the left\n\t\t\t\t\t// restore before change data\n\t\t\t\t\tgeneratedPattern[e] = charBefore[errorAdded];\n\t\t\t\t\t//c = generatedPattern[e] = charBefore[errorAdded];\n\t\t\t\t\t//startSaIndex[e] = startSaIndexBefore[errorAdded];\n\t\t\t\t\t//endSaIndex[e] = endSaIndexBefore[errorAdded];\n\n\t\t\t\t\terrorAdded--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (generatedPattern[e] < ALPHABET_SIZE) {\n\n\t\t\t\t// edit\n\t\t\t\tc = generatedPattern[e];\n\n\t\t\t\tif (length <= saIndexRangeLength) {\n\t\t\t\t\tsaRangeIndex = (saRangeIndex << BIT_PER_CHAR) | c;\n\t\t\t\t} else {\n\t\t\t\t\tif (length > saIndexRangeLength + 1) {\n\t \t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, startSaIndex[e+1], c) + 1;\n\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, endSaIndex[e+1] + 1, c);\n\t\t\t\t\t} else {\n\t \t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].startSaIndex, c) + 1;\n\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].endSaIndex + 1, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (generatedPattern[e] > ALPHABET_SIZE) {\n\t\t\t\t\tif (e > 0 && (startSaIndexBefore[errorAdded] <= endSaIndexBefore[errorAdded]\n\t\t\t\t\t\t\t      || length <= saIndexRangeLength)) {\n\t\t\t\t\t\t// insert\n\t\t\t\t\t\tc = generatedPattern[e] - ALPHABET_SIZE - 1;\t// get back the character to be inserted\n\t\t\t\t\t\tlength++;\n\t\t\t\t\t\tif (length <= saIndexRangeLength) {\n\t\t\t\t\t\t\tsaRangeIndex = (saRangeIndexBefore[errorAdded] << BIT_PER_CHAR) | c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (length > saIndexRangeLength + 1) {\n\t \t\t\t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, startSaIndexBefore[errorAdded], c) + 1;\n\t\t\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, endSaIndexBefore[errorAdded] + 1, c);\n\t\t\t\t\t\t\t} else {\n\t \t\t\t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndexBefore[errorAdded]].startSaIndex, c) + 1;\n\t\t\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndexBefore[errorAdded]].endSaIndex + 1, c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// do not insert on pattern boundary\n\t\t\t\t\t\tgeneratedPattern[e] = maxPatternValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// delete\n\t\t\t\t\tstartSaIndex[e] = startSaIndex[e+1];\n\t\t\t\t\tendSaIndex[e] = endSaIndex[e+1];\n\t\t\t\t\t//saRangeIndex >>= BIT_PER_CHAR;\n\t\t\t\t\tlength--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (errorAdded < numOfError && startSaIndex[e] <= endSaIndex[e]) {\n\n\t\t\t\t// Add insertions\n\t\t\t\terrorAdded++;\n\t\t\t\terrorPos[errorAdded] = errorPos[errorAdded-1];\n\t\t\t\terrorPosLength[errorAdded] = length;\n\n\t\t\t\t// store before change data\n\t\t\t\tcharBefore[errorAdded] = generatedPattern[e];\n\t\t\t\tstartSaIndexBefore[errorAdded] = startSaIndex[e];\n\t\t\t\tendSaIndexBefore[errorAdded] = endSaIndex[e];\n\t\t\t\tsaRangeIndexBefore[errorAdded] = saRangeIndex;\n\n\t\t\t\t// Assign code for inserting the char = 0\n\t\t\t\tgeneratedPattern[e] = (unsigned char)(ALPHABET_SIZE + 1);\n\t\t\t\tlength++;\n\t\t\t\tif (length <= saIndexRangeLength) {\n\t\t\t\t\tsaRangeIndex <<= BIT_PER_CHAR;\n\t\t\t\t} else {\n\t\t\t\t\tif (length > saIndexRangeLength + 1) {\n\t \t\t\t\t\tstartSaIndex[e] = BWTOccValue(bwt, startSaIndex[e], 0) + 1;\n\t\t\t\t\t\tendSaIndex[e] = BWTOccValue(bwt, endSaIndex[e] + 1, 0);\n\t\t\t\t\t} else {\n\t \t\t\t\t\tstartSaIndex[e] = BWTOccValue(bwt, saIndexRange[saRangeIndex].startSaIndex, 0) + 1;\n\t\t\t\t\t\tendSaIndex[e] = BWTOccValue(bwt, saIndexRange[saRangeIndex].endSaIndex + 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search for pattern\n\t\t\twhile (e>0 && (length <= saIndexRangeLength || startSaIndex[e] <= endSaIndex[e])) {\n\t\t\t\te--;\n\t\t\t\tlength++;\n\t\t\t\tc = generatedPattern[e];\n\t\t\t\tif (length <= saIndexRangeLength) {\n\t\t\t\t\tsaRangeIndex = (saRangeIndex << BIT_PER_CHAR) | c;\n\t\t\t\t} else {\n\t\t\t\t\tif (length > saIndexRangeLength + 1) {\n\t\t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, startSaIndex[e+1], c) + 1;\n\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, endSaIndex[e+1] + 1, c);\n\t\t\t\t\t} else {\n\t \t\t\t\t\tstartSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].startSaIndex, c) + 1;\n\t\t\t\t\t\tendSaIndex[e] = bwt->cumulativeFreq[c] + BWTOccValue(bwt, saIndexRange[saRangeIndex].endSaIndex + 1, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (startSaIndex[e] <= endSaIndex[e]) {\n\t\t\t\tif (numOfSaGroup < maxSaIndexGroup) {\n\t\t\t\t\tsaIndexGroup[numOfSaGroup].startSaIndex = startSaIndex[0];\n\t\t\t\t\tsaIndexGroup[numOfSaGroup].numOfMatch = endSaIndex[0] - startSaIndex[0] + 1;\n\t\t\t\t\tsaIndexGroup[numOfSaGroup].length = length;\n\t\t\t\t\tsaIndexGroup[numOfSaGroup].error = numOfError;\n\t\t\t\t\tnumOfSaGroup++;\n\t\t\t\t} else {\n\t\t\t\t\tif (exceedMaxSaIndexGroupPrinted == FALSE) {\n\t\t\t\t\t\tfprintf(stderr, \"Not enough memory to store all SA index groups!\\n\");\n\t\t\t\t\t\texceedMaxSaIndexGroupPrinted = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tnumOfSaGroup = BWTEliminateDupSaIndexGroup(saIndexGroup, numOfSaGroup);\n\n\treturn numOfSaGroup;\n\n}", "path": "BWT.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/* Quadratic sorting method to use for small subarrays. */\n", "func_signal": "static void QSufSortInsertSortSplit(int* __restrict V, int* __restrict I, const int lowestPos, \n\t\t\t\t\t\t\t\t\tconst int highestPos, const int numSortedChar)", "code": "{\n\n\tint i, j;\n\tint tmpKey, tmpPos;\n\tint numItem;\n\tint key[INSERT_SORT_NUM_ITEM], pos[INSERT_SORT_NUM_ITEM];\n\tint negativeSortedLength;\n\tint groupNum;\n\n\t#ifdef DEBUG\n\tif (lowestPos > highestPos) {\n\t\tfprintf(stderr, \"QSufSortInsertSortSplit(): lowestPos > highestPos!\\n\");\n\t\texit(1);\n\t}\n\t#endif\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\t#ifdef DEBUG\n\tif (numItem > INSERT_SORT_NUM_ITEM) {\n\t\tfprintf(stderr, \"QSufSortInsertSortSplit(): number of items > INSERT_SORT_NUM_ITEM!\\n\");\n\t\texit(1);\n\t}\n\t#endif\n\n\tfor (i=0; i<numItem; i++) {\n\t\t#ifdef DEBUG\n\t\tif (I[lowestPos + i] < 0) {\n\t\t\tfprintf(stderr, \"QSufSortInsertSortSplit(): I < 0 in unsorted region!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t#endif\n\t\tpos[i] = I[lowestPos + i];\n\t\tkey[i] = V[pos[i] + numSortedChar];\n\t}\n\n\tfor (i=1; i<numItem; i++) {\n\t\ttmpKey = key[i];\n\t\ttmpPos = pos[i];\n\t\tfor (j=i; j>0 && key[j-1] > tmpKey; j--) {\n\t\t\tkey[j] = key[j-1];\n\t\t\tpos[j] = pos[j-1];\n\t\t}\n\t\tkey[j] = tmpKey;\n\t\tpos[j] = tmpPos;\n\t}\n\n\tnegativeSortedLength = -1;\n\n\ti = numItem - 1;\n\tgroupNum = highestPos;\n\twhile (i > 0) {\n\t\tI[i+lowestPos] = pos[i];\n\t\tV[I[i+lowestPos]] = groupNum;\n\t\tif (key[i-1] == key[i]) {\n\t\t\tnegativeSortedLength = 0;\n\t\t} else {\n\t\t\tif (negativeSortedLength < 0) {\n\t\t\t\tI[i+lowestPos] = negativeSortedLength;\n\t\t\t}\n\t\t\tgroupNum = i + lowestPos - 1;\n\t\t\tnegativeSortedLength--;\n\t\t}\n\t\ti--;\n\t}\n\n\tI[lowestPos] = pos[0];\n\tV[I[lowestPos]] = groupNum;\n\tif (negativeSortedLength < 0) {\n\t\tI[lowestPos] = negativeSortedLength;\n\t}\t\n\n}", "path": "QSufSort.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/** Fill an array with 2-bit encoded triplets.\n * @param seq_start Pointer to the start of the sequence in blastna \n *                  encoding [in]\n * @param icur Offset at which to start extracting triplets [in]\n * @param max Maximal length of the sequence segment to be processed [in]\n * @param s1 Array of triplets [out]\n * @return How far was the sequence processed?\n */\n", "func_signal": "static int \ndust_triplet_find (unsigned char* seq_start, int icur, int max, unsigned char* s1, const unsigned char* blastnaMap)", "code": "{\n   int n;\n   unsigned char* s2,* s3;\n   short c;\n   unsigned char* seq = &seq_start[icur];\n   unsigned char end_byte = 15;\t// 15 is not used in DNA sequence\n\n   n = 0;\n   \n   s2 = s1 + 1;\n   s3 = s1 + 2;\n   \n   /* set up 1 */\n   if ((c = blastnaMap[*seq++]) == end_byte)\n      return n;\n   c &= NCBI2NA_MASK;\n   *s1 |= c;\n   *s1 <<= 2;\n   \n   /* set up 2 */\n   if ((c = blastnaMap[*seq++]) == end_byte)\n      return n;\n   c &= NCBI2NA_MASK;\n   *s1 |= c;\n   *s2 |= c;\n   \n   /* triplet fill loop */\n   while (n < max && (c = blastnaMap[*seq++]) != end_byte) {\n      c &= NCBI2NA_MASK;\n      *s1 <<= 2;\n      *s2 <<= 2;\n      *s1 |= c;\n      *s2 |= c;\n      *s3 |= c;\n      s1++;\n      s2++;\n      s3++;\n      n++;\n   }\n   \n   return n;\n}", "path": "blast_dust.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "// mmPool can be NULL but alignmentPool must be allocated for storing alignments as they are not freed explicitly and must be freed through MMPool\n// gappedHitList should be sorted in increasin posText order\n", "func_signal": "int HSPGappedExtensionWithTraceback(const unsigned int *packedDNA, const unsigned char *convertedKey, const int queryPatternLength, \n\t\t\t\t\t   GappedHitList* __restrict gappedHitList, const int numberOfHit, \n\t\t\t\t\t   MMPool *mmPool, MMPool *alignmentPool,\n\t\t\t\t\t   const SeqOffset *seqOffset, const Ambiguity *ambiguity,\n\t\t\t\t\t   const int matchScore, const int mismatchScore,\n\t\t\t\t\t   const int gapOpenScore, const int gapExtendScore,\n\t\t\t\t\t   const double maxEvalue, const int dropoffScore)", "code": "{\n\n\tchar* __restrict textBuffer;\n\tint M, BLast;\n\tint* __restrict B;\n\tint* __restrict I;\t// insert and delete wrt query\n\tint D;\t\t\t\t// insert and delete wrt query\n\tchar* __restrict IType;\t// Gapped opening or gap extension\n\tchar DType;\t\t\t\t// Gapped opening or gap extension\n\tint scoringMatrix[16][16];\n\n\tchar* __restrict traceback;\n\tint* __restrict tracebackIndex;\n\tchar* __restrict tempForwardAlignment;\n\tchar* __restrict tempBackwardAlignment;\n\tchar* __restrict tempForwardAuxiliaryText;\n\tchar* __restrict tempBackwardAuxiliaryText;\n\tunsigned int* __restrict alignment;\n\tunsigned int* __restrict auxiliaryText;\n\n\tint hitProcessed, numberOfGappedHit;\n\n\tint i, j;\n\tunsigned int c;\n\tint queryOffset;\n\tunsigned int textOffset;\n\tunsigned int sequenceStart, sequenceEnd;\n\tint charToProcess;\n\tunsigned int textDecodePos;\n\tdouble evalue;\n\n\tint lastStartPos, startPos, nextStartPos;\n\tint endPos, nextEndPos;\n\tunsigned int textPos;\n\tint ambiguityIndex;\n\n\tint maxLengthOfGap;\n\tint currentPos;\n\tint currentTracebackIndex;\n\tint forwardMaxScore, backwardMaxScore;\n\tunsigned int forwardMaxScorePosQuery, forwardMaxScorePosText;\n\tunsigned int backwardMaxScorePosQuery, backwardMaxScorePosText;\n\tint forwardNumOfAlignment, forwardNumOfAuxiliaryText;\n\tint backwardNumOfAlignment, backwardNumOfAuxiliaryText;\n\tint numOfAlignmentWord, numOfAuxiliaryTextWord;\n\tint tracebackAllocationUnit, tracebackAllocated;\n\tchar dpType;\n\tint dpScore;\n\n\tint dpCellAllocated;\n\n\tdpCellAllocated = min(queryPatternLength + 1, MAX_ALIGNMENT_LENGTH);\n\n\tif (alignmentPool == NULL) {\n\t\tfprintf(stderr, \"HSPGappedExtensionWithTraceback(): alignmentPool is not allocated!\\n\");\n\t\texit(1);\n\t}\n\n\tmaxLengthOfGap = (dropoffScore + gapOpenScore) / (-gapExtendScore);\n\n\t// allocate working memory\n\ttextBuffer = MMPoolDispatch(mmPool, dpCellAllocated * 2);\n\tB = MMPoolDispatch(mmPool, dpCellAllocated * sizeof(int));\n\tIType = MMPoolDispatch(mmPool, dpCellAllocated);\n\tI = MMPoolDispatch(mmPool, dpCellAllocated * sizeof(int));\n\n\ttracebackIndex = MMPoolDispatch(mmPool, dpCellAllocated * 2 * 2 * sizeof(int));\n\n\ttracebackAllocated = tracebackAllocationUnit = dpCellAllocated * maxLengthOfGap * maxLengthOfGap;\n\ttraceback = MMUnitAllocate(tracebackAllocated);\n\n\ttempForwardAlignment = MMPoolDispatch(mmPool, dpCellAllocated * 2);\n\ttempBackwardAlignment = MMPoolDispatch(mmPool, dpCellAllocated * 2);\n\ttempForwardAuxiliaryText = MMPoolDispatch(mmPool, dpCellAllocated);\n\ttempBackwardAuxiliaryText = MMPoolDispatch(mmPool, dpCellAllocated);\n\n\tHSPFillScoringMatrix(scoringMatrix, matchScore, mismatchScore, 0);\n\n\thitProcessed = 0;\n\tnumberOfGappedHit = 0;\n\tambiguityIndex = 0;\n\n\twhile (hitProcessed < numberOfHit) {\n\n\t\tsequenceStart = seqOffset[gappedHitList[hitProcessed].dbSeqIndex].startPos;\n\t\tsequenceEnd = seqOffset[gappedHitList[hitProcessed].dbSeqIndex].endPos;\n\t\tif (seqOffset[gappedHitList[hitProcessed].dbSeqIndex].firstAmbiguityIndex > ambiguityIndex) {\n\t\t\tambiguityIndex = seqOffset[gappedHitList[hitProcessed].dbSeqIndex].firstAmbiguityIndex;\n\t\t}\n\n\t\ttextOffset = gappedHitList[hitProcessed].ungappedPosText;\n\t\tqueryOffset = gappedHitList[hitProcessed].ungappedPosQuery;\n\n\n\t\t// Forward extend\n\n\t\ttextDecodePos = textOffset;\n\t\tif (textDecodePos % CHAR_PER_WORD > 0) {\n\t\t\t// decode text to the next word boundary\n\t\t\tcharToProcess = CHAR_PER_WORD - (textDecodePos % CHAR_PER_WORD);\n\t\t\tc = packedDNA[textDecodePos / CHAR_PER_WORD] << (BITS_IN_WORD - charToProcess * BIT_PER_CHAR);\n\t\t\tfor (i=0; i<charToProcess; i++) {\n\t\t\t\ttextBuffer[textDecodePos + i - textOffset + 1] = (unsigned char)(c >> (BITS_IN_WORD - BIT_PER_CHAR));\n\t\t\t\tc <<= BIT_PER_CHAR;\n\t\t\t}\n\n\t\t\t// Apply ambiguity\n\t\t\twhile (ambiguity[ambiguityIndex].rightOfEndPos <= textOffset) {\n\t\t\t\tambiguityIndex++;\n\t\t\t}\n\t\t\tif (ambiguity[ambiguityIndex].startPos < textOffset + charToProcess) {\n\t\t\t\tfor (i=0; i<charToProcess; i++) {\n\t\t\t\t\twhile (ambiguity[ambiguityIndex].rightOfEndPos <= textOffset + i) {\n\t\t\t\t\t\tambiguity++;\n\t\t\t\t\t}\n\t\t\t\t\tif (ambiguity[ambiguityIndex].startPos <= textOffset + i) {\n\t\t\t\t\t\ttextBuffer[textDecodePos + i - textOffset + 1] = (char)ambiguity[ambiguityIndex].symbol;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\ttextDecodePos += charToProcess;\n\t\t}\n\n\t\t// Fill initial scores\n\t\tB[0] = 0;\n\t\ttraceback[0] = DP_MATCH_MISMATCH;\n\t\tI[0] = gapExtendScore + gapOpenScore;\n\t\tIType[0] = DP_INSERT_OPEN;\n\n\t\tB[1] = gapExtendScore + gapOpenScore;\n\t\ttraceback[1] = DP_DELETE | DP_DELETE_OPEN;\n\t\tI[1] = B[1] + gapExtendScore + gapOpenScore;\n\t\tIType[1] = DP_INSERT_OPEN;\n\n\t\tfor (i=2; i<=maxLengthOfGap; i++) {\n\t\t\tB[i] = B[i-1] + gapExtendScore;\n\t\t\ttraceback[i] = DP_DELETE;\n\t\t\tI[i] = B[i] + gapExtendScore + gapOpenScore;\n\t\t\tIType[i] = DP_INSERT_OPEN;\n\t\t}\n\t\tI[i] = DP_NEG_INFINITY;\n\n\t\tcurrentTracebackIndex = maxLengthOfGap + 1;\n\n\t\tlastStartPos = startPos = 0;\n\t\tendPos = min((maxLengthOfGap + 1), queryPatternLength - queryOffset);\n\t\ttextPos = textOffset;\n\t\t \n\t\tforwardMaxScore = 0;\n\t\tforwardMaxScorePosQuery = queryOffset;\n\t\tforwardMaxScorePosText = textOffset;\n\n\t\ttracebackIndex[0] = 0;\t// The first trackback of the row\n\t\ttracebackIndex[1] = 0;\t// The first query position of the row\n\n\t\twhile (startPos <= endPos && textPos <= sequenceEnd) {\n\n\t\t\tif (endPos >= dpCellAllocated) {\n\t\t\t\tfprintf(stderr, \"HSPGappedExtensionWithTraceback(): Not enough DP cells allocated!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (textPos < textDecodePos) {\n\t\t\t} else {\n\t\t\t\t// decode a word of text\n\t\t\t\tc = packedDNA[textDecodePos / CHAR_PER_WORD];\n\t\t\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\t\t\ttextBuffer[textDecodePos + j - textOffset + 1] = (unsigned char)(c >> (BITS_IN_WORD - BIT_PER_CHAR));\n\t\t\t\t\tc <<= BIT_PER_CHAR;\n\t\t\t\t}\n\n\t\t\t\t// Apply ambiguity\n\t\t\t\twhile (ambiguity[ambiguityIndex].rightOfEndPos <= textPos) {\n\t\t\t\t\tambiguityIndex++;\n\t\t\t\t}\n\t\t\t\tif (ambiguity[ambiguityIndex].startPos < textPos + CHAR_PER_WORD) {\n\t\t\t\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\t\t\t\twhile (ambiguity[ambiguityIndex].rightOfEndPos <= textPos + j) {\n\t\t\t\t\t\t\tambiguity++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ambiguity[ambiguityIndex].startPos <= textPos + j) {\n\t\t\t\t\t\t\ttextBuffer[textDecodePos + j - textOffset + 1] = (char)ambiguity[ambiguityIndex].symbol;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextDecodePos += CHAR_PER_WORD;\n\t\t\t}\n\n\t\t\t// traceback\n\t\t\ttracebackIndex[(textPos - textOffset + 1) * 2] = currentTracebackIndex;\t// The first trackback of the row\n\t\t\ttracebackIndex[(textPos - textOffset + 1) * 2 + 1] = startPos;\t\t\t// The first query position of the row\n\n\t\t\tnextEndPos = 0;\n\t\t\tnextStartPos = INT_MAX;\n\n\t\t\tif (currentTracebackIndex + queryPatternLength >= tracebackAllocated) {\n\t\t\t\ttraceback = MMUnitReallocate(traceback, tracebackAllocated + tracebackAllocationUnit, tracebackAllocated);\n\t\t\t\ttracebackAllocated += tracebackAllocationUnit;\n\t\t\t}\n\n\t\t\tif (startPos > lastStartPos) {\n\t\t\t\tBLast = B[startPos - 1];\n\t\t\t\tD = DP_NEG_INFINITY;\n\t\t\t\tDType = 0;\n\t\t\t\tcurrentPos = startPos;\n\t\t\t} else {\n\t\t\t\t// all scores in currentPos - 1 is DP_NEG_INFINITY\n\t\t\t\tBLast = B[startPos];\n\t\t\t\tB[startPos] = I[startPos];\n\t\t\t\ttraceback[currentTracebackIndex] = DP_INSERT | IType[startPos];\n\t\t\t\tI[startPos] = I[startPos] + gapExtendScore;\n\t\t\t\tIType[startPos] = DP_INSERT_EXTEND;\n\t\t\t\tD = B[startPos] + gapExtendScore + gapOpenScore;\n\t\t\t\tDType = DP_DELETE_OPEN;\n\t\t\t\tif (B[startPos] + dropoffScore >= forwardMaxScore) {\n\t\t\t\t\tnextStartPos = startPos;\n\t\t\t\t\tnextEndPos = startPos;\n\t\t\t\t}\n\t\t\t\tcurrentPos = startPos + 1;\n\t\t\t\tcurrentTracebackIndex++;\n\t\t\t}\n\n\t\t\twhile (currentPos <= endPos) {\n\n\t\t\t\tM = BLast + scoringMatrix[textBuffer[textPos - textOffset + 1]][convertedKey[currentPos + queryOffset - 1]];\n\t\t\t\tBLast = B[currentPos];\n\n\t\t\t\tif (M >= I[currentPos] && M >= D) {\n\t\t\t\t\t// matchScore is maximum\n\t\t\t\t\tB[currentPos] = M;\n\t\t\t\t\ttraceback[currentTracebackIndex] = DP_MATCH_MISMATCH | IType[currentPos] | DType;\n\t\t\t\t\tif (M + gapOpenScore >= I[currentPos]) {\n\t\t\t\t\t\tI[currentPos] = M + gapOpenScore + gapExtendScore;\n\t\t\t\t\t\tIType[currentPos] = DP_INSERT_OPEN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tI[currentPos] = I[currentPos] + gapExtendScore;\n\t\t\t\t\t\tIType[currentPos] = DP_INSERT_EXTEND;\n\t\t\t\t\t}\n\t\t\t\t\tif (M + gapOpenScore >= D) {\n\t\t\t\t\t\tD = M + gapOpenScore + gapExtendScore;\n\t\t\t\t\t\tDType = DP_DELETE_OPEN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t\t}\n\t\t\t\t\tif (B[currentPos] > forwardMaxScore) {\n\t\t\t\t\t\tforwardMaxScore = B[currentPos];\n\t\t\t\t\t\tforwardMaxScorePosQuery = currentPos + queryOffset;\n\t\t\t\t\t\tforwardMaxScorePosText = textPos + 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (I[currentPos] >= D) {\n\t\t\t\t\t\tB[currentPos] = I[currentPos];\n\t\t\t\t\t\ttraceback[currentTracebackIndex] = DP_INSERT | IType[currentPos] | DType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tB[currentPos] = D;\n\t\t\t\t\t\ttraceback[currentTracebackIndex] = DP_DELETE | IType[currentPos] | DType;\n\t\t\t\t\t}\n\t\t\t\t\t// insert cannot follow delete and delete cannot follow insert\n\t\t\t\t\tI[currentPos] = I[currentPos] + gapExtendScore;\n\t\t\t\t\tIType[currentPos] = DP_INSERT_EXTEND;\n\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t}\n\t\t\t\tif (B[currentPos] + dropoffScore >= forwardMaxScore) {\n\t\t\t\t\tif (nextStartPos > currentPos) {\n\t\t\t\t\t\tnextStartPos = currentPos;\n\t\t\t\t\t}\n\t\t\t\t\tnextEndPos = currentPos;\n\t\t\t\t}\n\n\t\t\t\tcurrentPos++;\n\t\t\t\tcurrentTracebackIndex++;\n\n\t\t\t}\n\n\t\t\tnextEndPos++;\n\t\t\tif (nextEndPos == currentPos) {\n\t\t\t\twhile (nextEndPos <= queryPatternLength - queryOffset && D + dropoffScore >= forwardMaxScore)  {\n\t\t\t\t\tif (nextEndPos >= dpCellAllocated) {\n\t\t\t\t\t\tfprintf(stderr, \"HSPGappedExtensionWithTraceback(): Not enough DP cells allocated!\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tB[nextEndPos] = D;\n\t\t\t\t\ttraceback[currentTracebackIndex] = DP_DELETE | DType;\n\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t\tI[nextEndPos] = DP_NEG_INFINITY;\n\t\t\t\t\tIType[nextEndPos] = 0;\n\t\t\t\t\tnextEndPos++;\n\t\t\t\t\tcurrentTracebackIndex++;\n\t\t\t\t}\n\t\t\t\tI[nextEndPos] = DP_NEG_INFINITY;\n\t\t\t\tIType[nextEndPos] = 0;\n\t\t\t}\n\n\t\t\tif (nextEndPos > queryPatternLength - queryOffset) {\n\t\t\t\tnextEndPos = queryPatternLength - queryOffset;\n\t\t\t}\n\n\t\t\tlastStartPos = startPos;\n\t\t\tstartPos = nextStartPos;\n\t\t\tendPos = nextEndPos;\n\n\t\t\ttextPos++;\n\n\t\t}\n\n\t\t// traceback\n\t\tforwardNumOfAlignment = 0;\n\t\tforwardNumOfAuxiliaryText = 0;\n\t\ttextPos = forwardMaxScorePosText - 1;\n\t\tcurrentPos = forwardMaxScorePosQuery - queryOffset;\n\t\tdpScore = 0;\t// for verifying traceback\n\n\t\tcurrentTracebackIndex = tracebackIndex[(textPos - textOffset + 1) * 2] \n\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textPos - textOffset + 1) * 2 + 1];\n\n\t\twhile (currentTracebackIndex > 0) {\n\n\t\t\tdpType = traceback[currentTracebackIndex] & DP_MASK;\n\n\t\t\tif (dpType == DP_MATCH_MISMATCH) {\n\t\t\t\tdpScore += scoringMatrix[textBuffer[textPos - textOffset + 1]][convertedKey[currentPos + queryOffset - 1]];\n\t\t\t\tif (textBuffer[textPos - textOffset + 1] == convertedKey[currentPos + queryOffset - 1] &&\n\t\t\t\t\ttextBuffer[textPos - textOffset + 1] < 4) {\t// match and not ambiguity\n\t\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_MATCH;\n\t\t\t\t} else {\n\t\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_MISMATCH_AMBIGUITY;\n\t\t\t\t\ttempForwardAuxiliaryText[forwardNumOfAuxiliaryText] = textBuffer[textPos - textOffset + 1];\n\t\t\t\t\tforwardNumOfAuxiliaryText++;\n\t\t\t\t}\n\t\t\t\ttextPos--;\n\t\t\t\tcurrentPos--;\n\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textPos - textOffset + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textPos - textOffset + 1) * 2 + 1];\n\t\t\t} else if (dpType ==  DP_INSERT) {\n\t\t\t\twhile (!(traceback[currentTracebackIndex] & DP_INSERT_OPEN)) {\n\t\t\t\t\tdpScore += gapExtendScore;\n\t\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_INSERT;\n\t\t\t\t\tforwardNumOfAlignment++;\n\t\t\t\t\ttempForwardAuxiliaryText[forwardNumOfAuxiliaryText] = textBuffer[textPos - textOffset + 1];\n\t\t\t\t\tforwardNumOfAuxiliaryText++;\n\t\t\t\t\ttextPos--;\n\t\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textPos - textOffset + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textPos - textOffset + 1) * 2 + 1];\n\t\t\t\t}\n\t\t\t\tdpScore += gapOpenScore + gapExtendScore;\n\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_INSERT;\n\t\t\t\ttempForwardAuxiliaryText[forwardNumOfAuxiliaryText] = textBuffer[textPos - textOffset + 1];\n\t\t\t\tforwardNumOfAuxiliaryText++;\n\t\t\t\ttextPos--;\n\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textPos - textOffset + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textPos - textOffset + 1) * 2 + 1];\n\t\t\t} else {\n\t\t\t\twhile (!(traceback[currentTracebackIndex] & DP_DELETE_OPEN)) {\n\t\t\t\t\tdpScore += gapExtendScore;\n\t\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_DELETE;\n\t\t\t\t\tforwardNumOfAlignment++;\n\t\t\t\t\tcurrentPos--;\n\t\t\t\t\tcurrentTracebackIndex--;\n\t\t\t\t}\n\t\t\t\tdpScore += gapOpenScore + gapExtendScore;\n\t\t\t\ttempForwardAlignment[forwardNumOfAlignment] = ALIGN_DELETE;\n\t\t\t\tcurrentPos--;\n\t\t\t\tcurrentTracebackIndex--;\n\t\t\t}\n\n\t\t\tforwardNumOfAlignment++;\n\n\t\t}\n\n\t\tif (dpScore != forwardMaxScore) {\n\t\t\tfprintf(stderr, \"Forward gapped extension traceback error!\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Backward extend\n\n\t\ttextDecodePos = textOffset;\n\t\tif (textDecodePos % CHAR_PER_WORD > 0) {\n\t\t\t// decode text to the next word boundary\n\t\t\tcharToProcess = textDecodePos % CHAR_PER_WORD;\n\t\t\tc = packedDNA[textDecodePos / CHAR_PER_WORD] >> (BITS_IN_WORD - charToProcess * BIT_PER_CHAR);\n\t\t\tfor (i=0; i<charToProcess; i++) {\n\t\t\t\ttextBuffer[textOffset - textDecodePos + i + 1] = (unsigned char)(c & 0x3);\n\t\t\t\tc >>= BIT_PER_CHAR;\n\t\t\t}\n\n\t\t\t// Apply ambiguity\n\t\t\twhile (ambiguity[ambiguityIndex].startPos >= textOffset) {\n\t\t\t\tambiguityIndex--;\n\t\t\t}\n\t\t\tif (ambiguity[ambiguityIndex].rightOfEndPos > (textOffset - charToProcess)) {\n\t\t\t\tfor (i=0; i<charToProcess; i++) {\n\t\t\t\t\twhile (ambiguity[ambiguityIndex].startPos >= (textOffset - i)) {\n\t\t\t\t\t\tambiguityIndex--;\n\t\t\t\t\t}\n\t\t\t\t\tif (ambiguity[ambiguityIndex].rightOfEndPos > (textOffset - i - 1)) {\n\t\t\t\t\t\ttextBuffer[textOffset - textDecodePos + i + 1] = (char)ambiguity[ambiguityIndex].symbol;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttextDecodePos -= charToProcess;\n\t\t}\n\n\t\t// Fill initial scores\n\t\tB[0] = 0;\n\t\ttraceback[0] = DP_MATCH_MISMATCH;\n\t\tI[0] = gapExtendScore + gapOpenScore;\n\t\tIType[0] = DP_INSERT_OPEN;\n\n\t\tB[1] = gapExtendScore + gapOpenScore;\n\t\ttraceback[1] = DP_DELETE | DP_DELETE_OPEN;\n\t\tI[1] = B[1] + gapExtendScore + gapOpenScore;\n\t\tIType[1] = DP_INSERT_OPEN;\n\n\t\tfor (i=2; i<=maxLengthOfGap; i++) {\n\t\t\tB[i] = B[i-1] + gapExtendScore;\n\t\t\ttraceback[i] = DP_DELETE;\n\t\t\tI[i] = B[i] + gapExtendScore + gapOpenScore;\n\t\t\tIType[i] = DP_INSERT_OPEN;\n\t\t}\n\t\tI[i] = DP_NEG_INFINITY;\n\n\t\tcurrentTracebackIndex = maxLengthOfGap + 1;\n\n\t\tlastStartPos = startPos = 0;\n\t\tendPos = min((maxLengthOfGap + 1), queryOffset);\n\t\ttextPos = textOffset;\n\t\t \n\t\tbackwardMaxScore = 0;\n\t\tbackwardMaxScorePosQuery = queryOffset;\n\t\tbackwardMaxScorePosText = textOffset;\n\n\t\ttracebackIndex[0] = 0;\n\t\ttracebackIndex[1] = 0;\n\n\t\twhile (startPos <= endPos && textPos + 1 > sequenceStart) {\n\n\t\t\tif (endPos >= dpCellAllocated) {\n\t\t\t\tfprintf(stderr, \"HSPGappedExtensionWithTraceback(): Not enough DP cells allocated!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (textPos > textDecodePos) {\n\t\t\t} else {\n\t\t\t\t// decode a word of text\n\t\t\t\tc = packedDNA[textDecodePos / CHAR_PER_WORD - 1];\n\t\t\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\t\t\ttextBuffer[textOffset - textDecodePos + j + 1] = (unsigned char)(c & 0x3);\n\t\t\t\t\tc >>= BIT_PER_CHAR;\n\t\t\t\t}\n\n\t\t\t\t// Apply ambiguity\n\t\t\t\twhile (ambiguity[ambiguityIndex].startPos >= textPos) {\n\t\t\t\t\tambiguityIndex--;\n\t\t\t\t}\n\t\t\t\tif (ambiguity[ambiguityIndex].rightOfEndPos > (textPos - CHAR_PER_WORD)) {\n\t\t\t\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\t\t\t\twhile (ambiguity[ambiguityIndex].startPos >= (textPos - j)) {\n\t\t\t\t\t\t\tambiguityIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ambiguity[ambiguityIndex].rightOfEndPos > (textPos - j - 1)) {\n\t\t\t\t\t\t\ttextBuffer[textOffset - textDecodePos + j + 1] = (char)ambiguity[ambiguityIndex].symbol;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextDecodePos -= CHAR_PER_WORD;\n\t\t\t}\n\n\t\t\t// traceback\n\t\t\ttracebackIndex[(textOffset - textPos + 1) * 2] = currentTracebackIndex;\n\t\t\ttracebackIndex[(textOffset - textPos + 1) * 2 + 1] = startPos;\n\n\t\t\tnextEndPos = 0;\n\t\t\tnextStartPos = INT_MAX;\n\n\t\t\tif (currentTracebackIndex + queryPatternLength >= tracebackAllocated) {\n\t\t\t\ttraceback = MMUnitReallocate(traceback, tracebackAllocated + tracebackAllocationUnit, tracebackAllocated);\n\t\t\t\ttracebackAllocated += tracebackAllocationUnit;\n\t\t\t}\n\n\t\t\tif (startPos > lastStartPos) {\n\t\t\t\tBLast = B[startPos - 1];\n\t\t\t\tD = DP_NEG_INFINITY;\n\t\t\t\tDType = 0;\n\t\t\t\tcurrentPos = startPos;\n\t\t\t} else {\n\t\t\t\t// all scores in currentPos - 1 is DP_NEG_INFINITY\n\t\t\t\tBLast = B[startPos];\n\t\t\t\tB[startPos] = I[startPos];\n\t\t\t\ttraceback[currentTracebackIndex] = DP_INSERT | IType[startPos];\n\t\t\t\tI[startPos] = I[startPos] + gapExtendScore;\n\t\t\t\tIType[startPos] = DP_INSERT_EXTEND;\n\t\t\t\tD = B[startPos] + gapExtendScore + gapOpenScore;\n\t\t\t\tDType = DP_DELETE_OPEN;\n\t\t\t\tif (B[startPos] + dropoffScore >= forwardMaxScore) {\n\t\t\t\t\tnextStartPos = startPos;\n\t\t\t\t\tnextEndPos = startPos;\n\t\t\t\t}\n\t\t\t\tcurrentPos = startPos + 1;\n\t\t\t\tcurrentTracebackIndex++;\n\t\t\t}\n\n\n\t\t\twhile (currentPos <= endPos) {\n\n\t\t\t\tM = BLast + scoringMatrix[textBuffer[textOffset - textPos + 1]][convertedKey[queryOffset - currentPos]];\n\t\t\t\tBLast = B[currentPos];\n\n\t\t\t\tif (M >= I[currentPos] && M >= D) {\n\t\t\t\t\t// matchScore is maximum\n\t\t\t\t\tB[currentPos] = M;\n\t\t\t\t\ttraceback[currentTracebackIndex] = DP_MATCH_MISMATCH | IType[currentPos] | DType;\n\t\t\t\t\tif (M + gapOpenScore >= I[currentPos]) {\n\t\t\t\t\t\tI[currentPos] = M + gapOpenScore + gapExtendScore;\n\t\t\t\t\t\tIType[currentPos] = DP_INSERT_OPEN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tI[currentPos] = I[currentPos] + gapExtendScore;\n\t\t\t\t\t\tIType[currentPos] = DP_INSERT_EXTEND;\n\t\t\t\t\t}\n\t\t\t\t\tif (M + gapOpenScore >= D) {\n\t\t\t\t\t\tD = M + gapOpenScore + gapExtendScore;\n\t\t\t\t\t\tDType = DP_DELETE_OPEN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t\t}\n\t\t\t\t\tif (B[currentPos] > backwardMaxScore) {\n\t\t\t\t\t\tbackwardMaxScore = B[currentPos];\n\t\t\t\t\t\tbackwardMaxScorePosQuery =  queryOffset - currentPos;\n\t\t\t\t\t\tbackwardMaxScorePosText = textPos - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (I[currentPos] >= D) {\n\t\t\t\t\t\tB[currentPos] = I[currentPos];\n\t\t\t\t\t\ttraceback[currentTracebackIndex] = DP_INSERT | IType[currentPos] | DType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tB[currentPos] = D;\n\t\t\t\t\t\ttraceback[currentTracebackIndex] = DP_DELETE | IType[currentPos] | DType;\n\t\t\t\t\t}\n\t\t\t\t\t// insert cannot follow delete and delete cannot follow insert\n\t\t\t\t\tI[currentPos] = I[currentPos] + gapExtendScore;\n\t\t\t\t\tIType[currentPos] = DP_INSERT_EXTEND;\n\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t}\n\n\t\t\t\tif (B[currentPos] + dropoffScore >= backwardMaxScore) {\n\t\t\t\t\tif (nextStartPos > currentPos) {\n\t\t\t\t\t\tnextStartPos = currentPos;\n\t\t\t\t\t}\n\t\t\t\t\tnextEndPos = currentPos;\n\t\t\t\t}\n\n\t\t\t\tcurrentPos++;\n\t\t\t\tcurrentTracebackIndex++;\n\n\t\t\t}\n\n\t\t\tnextEndPos++;\n\t\t\tif (nextEndPos == currentPos) {\n\t\t\t\twhile (nextEndPos <= queryOffset && D + dropoffScore >= backwardMaxScore)  {\n\t\t\t\t\tif (nextEndPos >= dpCellAllocated) {\n\t\t\t\t\t\tfprintf(stderr, \"HSPGappedExtensionWithTraceback(): Not enough DP cells allocated!\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tB[nextEndPos] = D;\n\t\t\t\t\ttraceback[currentTracebackIndex] = DP_DELETE | DType;\n\t\t\t\t\tD = D + gapExtendScore;\n\t\t\t\t\tDType = DP_DELETE_EXTEND;\n\t\t\t\t\tI[nextEndPos] = DP_NEG_INFINITY;\n\t\t\t\t\tIType[nextEndPos] = 0;\n\t\t\t\t\tnextEndPos++;\n\t\t\t\t\tcurrentTracebackIndex++;\n\t\t\t\t}\n\t\t\t\tI[nextEndPos] = DP_NEG_INFINITY;\n\t\t\t\tIType[nextEndPos] = 0;\n\t\t\t}\n\n\t\t\tif (nextEndPos > queryOffset) {\n\t\t\t\tnextEndPos = queryOffset;\n\t\t\t}\n\n\t\t\tlastStartPos = startPos;\n\t\t\tstartPos = nextStartPos;\n\t\t\tendPos = nextEndPos;\n\n\t\t\ttextPos--;\n\n\t\t}\n\n\t\t// traceback\n\t\tbackwardNumOfAlignment = 0;\n\t\tbackwardNumOfAuxiliaryText = 0;\n\t\ttextPos = backwardMaxScorePosText + 1;\n\t\tcurrentPos = queryOffset - backwardMaxScorePosQuery;\n\t\tdpScore = 0;\t// for verifying traceback\n\n\t\tcurrentTracebackIndex = tracebackIndex[(textOffset - textPos + 1) * 2] \n\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textOffset - textPos + 1) * 2 + 1];\n\n\t\twhile (currentTracebackIndex > 0) {\n\n\t\t\tdpType = traceback[currentTracebackIndex] & DP_MASK;\n\n\t\t\tif (dpType == DP_MATCH_MISMATCH) {\n\t\t\t\tdpScore += scoringMatrix[textBuffer[textOffset - textPos + 1]][convertedKey[queryOffset - currentPos]];\n\t\t\t\tif (textBuffer[textOffset - textPos + 1] == convertedKey[queryOffset - currentPos] &&\n\t\t\t\t\ttextBuffer[textOffset - textPos + 1] < 4) {\t// match and not ambiguity\n\t\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_MATCH;\n\t\t\t\t} else {\n\t\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_MISMATCH_AMBIGUITY;\n\t\t\t\t\ttempBackwardAuxiliaryText[backwardNumOfAuxiliaryText] = textBuffer[textOffset - textPos + 1];\n\t\t\t\t\tbackwardNumOfAuxiliaryText++;\n\t\t\t\t}\n\t\t\t\ttextPos++;\n\t\t\t\tcurrentPos--;\n\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textOffset - textPos + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textOffset - textPos + 1) * 2 + 1];\n\t\t\t} else if (dpType == DP_INSERT) {\n\t\t\t\twhile (!(traceback[currentTracebackIndex] & DP_INSERT_OPEN)) {\n\t\t\t\t\tdpScore += gapExtendScore;\n\t\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_INSERT;\n\t\t\t\t\tbackwardNumOfAlignment++;\n\t\t\t\t\ttempBackwardAuxiliaryText[backwardNumOfAuxiliaryText] = textBuffer[textOffset - textPos + 1];\n\t\t\t\t\tbackwardNumOfAuxiliaryText++;\n\t\t\t\t\ttextPos++;\n\t\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textOffset - textPos + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textOffset - textPos + 1) * 2 + 1];\n\t\t\t\t}\n\t\t\t\tdpScore += gapOpenScore + gapExtendScore;\n\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_INSERT;\n\t\t\t\ttempBackwardAuxiliaryText[backwardNumOfAuxiliaryText] = textBuffer[textOffset - textPos + 1];\n\t\t\t\tbackwardNumOfAuxiliaryText++;\n\t\t\t\ttextPos++;\n\t\t\t\tcurrentTracebackIndex = tracebackIndex[(textOffset - textPos + 1) * 2] \n\t\t\t\t\t\t\t\t\t\t+ currentPos - tracebackIndex[(textOffset - textPos + 1) * 2 + 1];\n\t\t\t} else {\n\t\t\t\twhile (!(traceback[currentTracebackIndex] & DP_DELETE_OPEN)) {\n\t\t\t\t\tdpScore += gapExtendScore;\n\t\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_DELETE;\n\t\t\t\t\tbackwardNumOfAlignment++;\n\t\t\t\t\tcurrentPos--;\n\t\t\t\t\tcurrentTracebackIndex--;\n\t\t\t\t}\n\t\t\t\tdpScore += gapOpenScore + gapExtendScore;\n\t\t\t\ttempBackwardAlignment[backwardNumOfAlignment] = ALIGN_DELETE;\n\t\t\t\tcurrentPos--;\n\t\t\t\tcurrentTracebackIndex--;\n\t\t\t}\n\n\t\t\tbackwardNumOfAlignment++;\n\n\t\t}\n\n\t\tif (dpScore != backwardMaxScore) {\n\t\t\tfprintf(stderr, \"Backward gapped extension traceback error!\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// check cutoff score\n\t\tevalue = stat_gapCalcEvalue(stat_gapNominal2normalized(forwardMaxScore + backwardMaxScore));\n\t\tif (evalue < maxEvalue) {\n\t\t\tgappedHitList[numberOfGappedHit].posText = backwardMaxScorePosText;\n\t\t\tgappedHitList[numberOfGappedHit].posQuery = backwardMaxScorePosQuery;\n\t\t\tgappedHitList[numberOfGappedHit].lengthQuery = forwardMaxScorePosQuery - backwardMaxScorePosQuery;\n\t\t\tgappedHitList[numberOfGappedHit].score = forwardMaxScore + backwardMaxScore;\n\t\t\tgappedHitList[numberOfGappedHit].lengthText = forwardMaxScorePosText - backwardMaxScorePosText;\n\t\t\tgappedHitList[numberOfGappedHit].dbSeqIndex = gappedHitList[hitProcessed].dbSeqIndex;\n\n\t\t\t// Store alignment and auxiliary text\n\t\t\tnumOfAlignmentWord = (forwardNumOfAlignment + backwardNumOfAlignment + ALIGN_PER_WORD - 1) / ALIGN_PER_WORD;\n\t\t\talignment = MMPoolDispatch(alignmentPool, numOfAlignmentWord * sizeof(unsigned int));\n\t\t\tfor (i=0; i<numOfAlignmentWord; i++) {\n\t\t\t\talignment[i] = 0;\n\t\t\t}\n\t\t\tif (forwardNumOfAuxiliaryText + backwardNumOfAuxiliaryText > 0) {\n\t\t\t\tnumOfAuxiliaryTextWord = (forwardNumOfAuxiliaryText + backwardNumOfAuxiliaryText + AUX_TEXT_PER_WORD - 1) / AUX_TEXT_PER_WORD;\n\t\t\t\tauxiliaryText = MMPoolDispatch(alignmentPool, numOfAuxiliaryTextWord * sizeof(unsigned int));\n\t\t\t\tfor (i=0; i<numOfAuxiliaryTextWord; i++) {\n\t\t\t\t\tauxiliaryText[i] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tauxiliaryText = NULL;\n\t\t\t}\n\n\t\t\t// backward alignment\n\t\t\tfor (i=0; i<backwardNumOfAlignment; i++) {\n\t\t\t\talignment[i/ALIGN_PER_WORD] |= (tempBackwardAlignment[i] << (BITS_IN_WORD - (i % ALIGN_PER_WORD + 1) * ALIGN_BIT));\n\t\t\t}\n\t\t\tfor (i=0; i<backwardNumOfAuxiliaryText; i++) {\n\t\t\t\tauxiliaryText[i/AUX_TEXT_PER_WORD] |= (tempBackwardAuxiliaryText[i] << (BITS_IN_WORD - (i % AUX_TEXT_PER_WORD + 1) * AUX_TEXT_BIT));\n\t\t\t}\n\n\t\t\t// forward alignment\n\t\t\tfor (i=0; i<forwardNumOfAlignment; i++) {\n\t\t\t\talignment[(i+backwardNumOfAlignment)/ALIGN_PER_WORD] |= (tempForwardAlignment[forwardNumOfAlignment - i - 1] \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<< (BITS_IN_WORD - ((i+backwardNumOfAlignment) % ALIGN_PER_WORD + 1) * ALIGN_BIT));\n\t\t\t}\n\t\t\tfor (i=0; i<forwardNumOfAuxiliaryText; i++) {\n\t\t\t\tauxiliaryText[(i+backwardNumOfAuxiliaryText)/AUX_TEXT_PER_WORD] |= (tempForwardAuxiliaryText[forwardNumOfAuxiliaryText - i - 1] \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   << (BITS_IN_WORD - ((i+backwardNumOfAuxiliaryText) % AUX_TEXT_PER_WORD + 1) * AUX_TEXT_BIT));\n\t\t\t}\n\t\t\t\n\t\t\t((GappedHitListWithAlignment*)(gappedHitList + numberOfGappedHit))->alignment = alignment;\n\t\t\t((GappedHitListWithAlignment*)(gappedHitList + numberOfGappedHit))->auxiliaryText = auxiliaryText;\n\n\t\t\tnumberOfGappedHit++;\n\n\t\t}\n\n\t\thitProcessed++;\n\n\t}\n\n\t// free working memory\n\tMMPoolReturn(mmPool, textBuffer, dpCellAllocated * 2);\n\tMMPoolReturn(mmPool, B, dpCellAllocated * sizeof(int));\n\tMMPoolReturn(mmPool, IType, dpCellAllocated);\n\tMMPoolReturn(mmPool, I, dpCellAllocated * sizeof(int));\n\n\tMMPoolReturn(mmPool, tracebackIndex, dpCellAllocated * 2 * 2 * sizeof(int));\n\n\tMMUnitFree(traceback, tracebackAllocated);\n\n\tMMPoolReturn(mmPool, tempForwardAlignment, dpCellAllocated * 2);\n\tMMPoolReturn(mmPool, tempBackwardAlignment, dpCellAllocated * 2);\n\tMMPoolReturn(mmPool, tempForwardAuxiliaryText, dpCellAllocated);\n\tMMPoolReturn(mmPool, tempBackwardAuxiliaryText, dpCellAllocated);\n\n\treturn numberOfGappedHit;\n\n}", "path": "HSP.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "void iniparser_dump_ini(dictionary * d, FILE * f)", "code": "{\n    int     i, j ;\n    char    keym[ASCIILINESZ+1];\n    int     nsec ;\n    char *  secname ;\n    int     seclen ;\n\n    if (d==NULL || f==NULL) return ;\n\n    nsec = iniparser_getnsec(d);\n    if (nsec<1) {\n        /* No section in file: dump all keys as they are */\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            fprintf(f, \"%s = %s\\n\", d->key[i], d->val[i]);\n        }\n        return ;\n    }\n    for (i=0 ; i<nsec ; i++) {\n        secname = iniparser_getsecname(d, i) ;\n        seclen  = (int)strlen(secname);\n        fprintf(f, \"\\n[%s]\\n\", secname);\n        sprintf(keym, \"%s:\", secname);\n        for (j=0 ; j<d->size ; j++) {\n            if (d->key[j]==NULL)\n                continue ;\n            if (!strncmp(d->key[j], keym, seclen+1)) {\n                fprintf(f,\n                        \"%-30s = %s\\n\",\n                        d->key[j]+seclen+1,\n                        d->val[j] ? d->val[j] : \"\");\n            }\n        }\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "int iniparser_getnsec(dictionary * d)", "code": "{\n    int i ;\n    int nsec ;\n\n    if (d==NULL) return -1 ;\n    nsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            nsec ++ ;\n        }\n    }\n    return nsec ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/* vim: set ts=4 et sw=4 tw=75 */\n", "func_signal": "dictionary * paraparser_load(int argc, char *argv[], int booleanc, char *booleanv[])", "code": "{\n    dictionary *d;\n\tint i, j;\n\tint booleanParameter;\n\tchar trueValue[2];\n\tchar argumentNumber[3];\n\n\t/*\n     * Initialize a new dictionary entry\n     */\n    d = dictionary_new(0, 1);\t// Case sensitive\n\n\targumentNumber[0] = '0';\n\targumentNumber[1] = '\\0';\n\targumentNumber[2] = '\\0';\n\n\ttrueValue[0] = 'Y';\n\ttrueValue[1] = '\\0';\n\n\tfor(i=0;i<argc;i++) {\n\t\tif (*argv[i] == '-') {\n\t\t\tif (*(argv[i]+1) != '\\0') {\n\t\t\t\t// check if it is a boolean parameters\n\t\t\t\tbooleanParameter = 0;\n\t\t\t\tfor (j=0; j<booleanc; j++) {\n\t\t\t\t\tif (strcmp(argv[i], booleanv[j]) == 0) {\n\t\t\t\t\t\tbooleanParameter = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (booleanParameter == 1) {\n\t\t\t\t\tiniparser_add_entry(d, \"parameter\", argv[i], trueValue);\n\t\t\t\t} else {\n\t\t\t\t\tif (i+1 >= argc) {\n\t\t\t\t\t\t// invalid input! Do nothing!\n\t\t\t\t\t} else {\n\t\t\t\t\t\tiniparser_add_entry(d, \"parameter\", argv[i], argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tiniparser_add_entry(d, \"argument\", argumentNumber, argv[i]);\n\t\t\tif (argumentNumber[1] != '\\0') {\n\t\t\t\tif (argumentNumber[1] == '9') {\n\t\t\t\t\tif (argumentNumber[0] == '9') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\targumentNumber[0]++;\n\t\t\t\t\t\targumentNumber[1] = '0';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\targumentNumber[1]++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (argumentNumber[0] == '9') {\n\t\t\t\t\targumentNumber[0] = '1';\n\t\t\t\t\targumentNumber[1] = '0';\n\t\t\t\t} else {\n\t\t\t\t\targumentNumber[0]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    return d ;\n\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "char * iniparser_getstring(dictionary * d, char * key, char * def)", "code": "{\n    char * lc_key ;\n    char * sval ;\n\n    if (d==NULL || key==NULL)\n        return def ;\n\n\t// Check whether the dictionary is case-sensitive\n\tif (d->caseSensitive) {\n\t\tlc_key = inistrdup(key);\n\t} else {\n        lc_key = inistrdup(inistrlwc(key));\n\t}\n    sval = dictionary_get(d, lc_key, def);\n    free(lc_key);\n    return sval ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "dictionary * iniparser_load(char * ininame, int caseSensitive)", "code": "{\n    dictionary  *   d ;\n    char        lin[ASCIILINESZ+1];\n    char        sec[ASCIILINESZ+1];\n    char        key[ASCIILINESZ+1];\n    char        val[ASCIILINESZ+1];\n    char    *   where ;\n    FILE    *   ini ;\n    int         lineno ;\n\n    if ((ini=fopen(ininame, \"r\"))==NULL) {\n        return NULL ;\n    }\n\n    sec[0]=0;\n\n    /*\n     * Initialize a new dictionary entry\n     */\n    d = dictionary_new(0, caseSensitive);\t// Added case sensitive setting;\n  //d = dictionary_new(0);\n    lineno = 0 ;\n    while (fgets(lin, ASCIILINESZ, ini)!=NULL) {\n        lineno++ ;\n        where = inistrskp(lin); /* Skip leading spaces */\n        if (*where==';' || *where=='#' || *where==0)\n            continue ; /* Comment lines */\n        else {\n            if (sscanf(where, \"[%[^]]\", sec)==1) {\n                /* Valid section name */\n\t\t\t\tif (caseSensitive) {\n\t\t\t\t\tstrcpy(sec, sec);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(sec, inistrlwc(sec));\n\t\t\t\t}\n                iniparser_add_entry(d, sec, NULL, NULL);\n            } else if (sscanf (where, \"%[^=] = \\\"%[^\\\"]\\\"\", key, val) == 2\n                   ||  sscanf (where, \"%[^=] = '%[^\\']'\",   key, val) == 2\n                   ||  sscanf (where, \"%[^=] = %[^;#]\",     key, val) == 2) {\n\t\t\t\tif (caseSensitive) {\n\t\t\t\t\tstrcpy(key, inistrcrop(key));\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(key, inistrlwc(inistrcrop(key)));\n\t\t\t\t}\n                /*\n                 * sscanf cannot handle \"\" or '' as empty value,\n                 * this is done here\n                 */\n                if (!strcmp(val, \"\\\"\\\"\") || !strcmp(val, \"''\")) {\n                    val[0] = (char)0;\n                } else {\n                    strcpy(val, inistrcrop(val));\n                }\n                iniparser_add_entry(d, sec, key, val);\n            }\n        }\n    }\n    fclose(ini);\n    return d ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/* Sorting routine called for each unsorted group. Sorts the array of integers\n   (suffix numbers) of length n starting at p. The algorithm is a ternary-split\n   quicksort taken from Bentley & McIlroy, \"Engineering a Sort Function\",\n   Software -- Practice and Experience 23(11), 1249-1265 (November 1993). This\n   function is based on Program 7.*/\n", "func_signal": "static void QSufSortSortSplit(int* __restrict V, int* __restrict I, const int lowestPos, \n\t\t\t\t\t\t\t  const int highestPos, const int numSortedChar)", "code": "{\n\n\tint a, b, c, d;\n\tint l, m;\n\tint f, v, s, t;\n\tint tmp;\n\tint numItem;\n\n\t#ifdef DEBUG\n\tif (lowestPos > highestPos) {\n\t\tfprintf(stderr, \"QSufSortSortSplit(): lowestPos > highestPos!\\n\");\n\t\texit(1);\n\t}\n\t#endif\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tif (numItem <= INSERT_SORT_NUM_ITEM) {\n\t\tQSufSortInsertSortSplit(V, I, lowestPos, highestPos, numSortedChar);\n\t\treturn;\n\t}\n\n\tv = QSufSortChoosePivot(V, I, lowestPos, highestPos, numSortedChar);\n\n\ta = b = lowestPos;\n\tc = d = highestPos;\n\n\twhile (TRUE) {\n\t\twhile (c >= b && (f = KEY(V, I, b, numSortedChar)) <= v) {\n\t\t\tif (f == v) {\n\t\t\t\tswap(I[a], I[b], tmp);\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\twhile (c >= b && (f = KEY(V, I, c, numSortedChar)) >= v) {\n\t\t\tif (f == v) {\n\t\t\t\tswap(I[c], I[d], tmp);\n\t\t\t\td--;\n\t\t\t}\n\t\t\tc--;\n\t\t}\n\t\tif (b > c) {\n\t\t\tbreak;\n\t\t}\n\t\tswap(I[b], I[c], tmp);\n\t\tb++;\n\t\tc--;\n\t}\n\n\ts = a - lowestPos;\n\tt = b - a;\n\ts = min(s, t);\n\tfor (l = lowestPos, m = b - s; m < b; l++, m++) {\n\t\tswap(I[l], I[m], tmp);\n\t}\n\n\ts = d - c;\n\tt = highestPos - d;\n\ts = min(s, t);\n\tfor (l = b, m = highestPos - s + 1; m <= highestPos; l++, m++) {\n\t\tswap(I[l], I[m], tmp);\n\t}\n\n\ts = b - a;\n\tt = d - c;\n\tif (s > 0) {\n\t\tQSufSortSortSplit(V, I, lowestPos, lowestPos + s - 1, numSortedChar);\n\t}\n\n\t// Update group number for equal portion\n\ta = lowestPos + s;\n\tb = highestPos - t;\n\tif (a == b) {\n\t\t// Sorted group\n\t\tV[I[a]] = a;\n\t\tI[a] = -1;\n\t} else {\n\t\t// Unsorted group\n\t\tfor (c=a; c<=b; c++) {\n\t\t\tV[I[c]] = b;\n\t\t}\n\t}\n\n\tif (t > 0) {\n\t\tQSufSortSortSplit(V, I, highestPos - t + 1, highestPos, numSortedChar);\n\t}\n\n}", "path": "QSufSort.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/* Private: add an entry to the dictionary */\n", "func_signal": "static void iniparser_add_entry(\n    dictionary * d,\n    char * sec,\n    char * key,\n    char * val)", "code": "{\n    char longkey[2*ASCIILINESZ+1];\n\n    /* Make a key as section:keyword */\n    if (key!=NULL) {\n        sprintf(longkey, \"%s:%s\", sec, key);\n    } else {\n        strcpy(longkey, sec);\n    }\n\n    /* Add (key,val) to dictionary */\n    dictionary_set(d, longkey, val);\n    return ;\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*\nvoid BWTOccValueTwoIndex(const BWT *bwt, unsigned int index1, unsigned int index2, const unsigned int character, unsigned int* __restrict occValue) {\n\n}\n*/\n", "func_signal": "void BWTAllOccValue(const BWT *bwt, unsigned int index, unsigned int* __restrict occValue)", "code": "{\n\n\tunsigned int occExplicitIndex, occIndex;\n\tunsigned int tempOccValue[ALPHABET_SIZE];\n\n\t// $ is supposed to be positioned at inverseSa0 but it is not encoded\n\t// therefore index is subtracted by 1 for adjustment\n\tif (index > bwt->inverseSa0) {\n\t\tindex--;\n\t}\n#ifdef DEBUG\n\tif (index > bwt->textLength) {\n\t\tfprintf(stderr, \"BWTOccValue() : index > textLength!\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\toccExplicitIndex = (index + OCC_INTERVAL / 2 - 1) / OCC_INTERVAL;\t// Bidirectional encoding\n\toccIndex = occExplicitIndex * OCC_INTERVAL;\n\n\tBWTAllOccValueExplicit(bwt, occExplicitIndex, occValue);\n\n\tif (occIndex == index) {\n\t\treturn;\n\t}\n\n\tif (occIndex < index) {\n\t\tForwardDNAAllOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, index - occIndex, tempOccValue, bwt->decodeTable);\n\t\toccValue[0] += tempOccValue[0];\n\t\toccValue[1] += tempOccValue[1];\n\t\toccValue[2] += tempOccValue[2];\n\t\toccValue[3] += tempOccValue[3];\n\t} else {\n\t\tBackwardDNAAllOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, occIndex - index, tempOccValue, bwt->decodeTable);\n\t\toccValue[0] -= tempOccValue[0];\n\t\toccValue[1] -= tempOccValue[1];\n\t\toccValue[2] -= tempOccValue[2];\n\t\toccValue[3] -= tempOccValue[3];\n\t}\n\n}", "path": "BWT.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "double iniparser_getdouble(dictionary * d, char * key, double notfound)", "code": "{\n    char    *   str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return atof(str);\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to an unsigned int\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   unsigned integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\n", "func_signal": "unsigned int iniparser_getuint(dictionary * d, char * key, int notfound)", "code": "{\n    char    *   str ;\n\tchar    *   stopstr;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return strtoul(str, &stopstr, 10);\n\n}", "path": "iniparser.c", "repo_name": "mruffalo/bwt-sw", "stars": 11, "license": "gpl-2.0", "language": "c", "size": 298}
{"docstring": "/* see if the quote-prefixed linky segment is actually a title.\n */\n", "func_signal": "static int\nlinkytitle(MMIOT *f, char quote, Footnote *ref)", "code": "{\n    int whence = mmiottell(f);\n    char *title = cursor(f);\n    char *e;\n    register int c;\n\n    while ( (c = pull(f)) != EOF ) {\n\te = cursor(f);\n\tif ( c == quote ) {\n\t    if ( (c = eatspace(f)) == ')' ) {\n\t\tT(ref->title) = 1+title;\n\t\tS(ref->title) = (e-title)-2;\n\t\treturn 1;\n\t    }\n\t}\n    }\n    mmiotseek(f, whence);\n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* The size-length token at cursor(f) is either a mailto:, an\n * implicit mailto:, one of the approved url protocols, or just\n * plain old text.   If it's a mailto: or an approved protocol,\n * linkify it, otherwise say \"no\"\n */\n", "func_signal": "static int\nprocess_possible_link(MMIOT *f, int size)", "code": "{\n    int address= 0;\n    int mailto = 0;\n    char *text = cursor(f);\n    \n    if ( f->flags & DENY_A ) return 0;\n\n    if ( (size > 7) && strncasecmp(text, \"mailto:\", 7) == 0 ) {\n\t/* if it says it's a mailto, it's a mailto -- who am\n\t * I to second-guess the user?\n\t */\n\taddress = 1;\n\tmailto = 7; \t/* 7 is the length of \"mailto:\"; we need this */\n    }\n    else \n\taddress = maybe_address(text, size);\n\n    if ( address ) { \n\tQstring(\"<a href=\\\"\", f);\n\tif ( !mailto ) {\n\t    /* supply a mailto: protocol if one wasn't attached */\n\t    mangle(\"mailto:\", 7, f);\n\t}\n\tmangle(text, size, f);\n\tQstring(\"\\\">\", f);\n\tmangle(text+mailto, size-mailto, f);\n\tQstring(\"</a>\", f);\n\treturn 1;\n    }\n    else if ( isautoprefix(text, size) ) {\n\tprintlinkyref(f, &linkt, text, size);\n\tQchar('>', f);\n\tputurl(text,size,f, 1);\n\tQstring(\"</a>\", f);\n\treturn 1;\n    }\n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Check a string to see if it looks like a mail address\n * \"looks like a mail address\" means alphanumeric + some\n * specials, then a `@`, then alphanumeric + some specials,\n * but with a `.`\n */\n", "func_signal": "static int\nmaybe_address(char *p, int size)", "code": "{\n    int ok = 0;\n    \n    for ( ;size && (isalnum(*p) || strchr(\"._-+*\", *p)); ++p, --size)\n\t;\n\n    if ( ! (size && *p == '@') )\n\treturn 0;\n    \n    --size, ++p;\n\n    if ( size && *p == '.' ) return 0;\n    \n    for ( ;size && (isalnum(*p) || strchr(\"._-+\", *p)); ++p, --size )\n\tif ( *p == '.' && size > 1 ) ok = 1;\n\n    return size ? 0 : ok;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/*\n * write out a url, escaping problematic characters\n */\n", "func_signal": "static void\nputurl(char *s, int size, MMIOT *f, int display)", "code": "{\n    unsigned char c;\n\n    while ( size-- > 0 ) {\n\tc = *s++;\n\n\tif ( c == '\\\\' && size-- > 0 ) {\n\t    c = *s++;\n\n\t    if ( !( ispunct(c) || isspace(c) ) )\n\t\tQchar('\\\\', f);\n\t}\n\t\n\tif ( c == '&' )\n\t    Qstring(\"&amp;\", f);\n\telse if ( c == '<' )\n\t    Qstring(\"&lt;\", f);\n\telse if ( c == '\"' )\n\t    Qstring(\"%22\", f);\n\telse if ( isalnum(c) || ispunct(c) || (display && isspace(c)) )\n\t    Qchar(c, f);\n\telse if ( c == 003 )\t/* untokenize ^C */\n\t    Qstring(\"  \", f);\n\telse\n\t    Qprintf(f, \"%%%02X\", c);\n    }\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* a < may be just a regular character, the start of an embedded html\n * tag, or the start of an <automatic link>.    If it's an automatic\n * link, we also need to know if it's an email address because if it\n * is we need to mangle it in our futile attempt to cut down on the\n * spaminess of the rendered page.\n */\n", "func_signal": "static int\nmaybe_tag_or_link(MMIOT *f)", "code": "{\n    int c, size;\n    int maybetag = 1;\n\n    if ( f->flags & INSIDE_TAG )\n\treturn 0;\n\n    for ( size=0; (c = peek(f, size+1)) != '>'; size++) {\n\tif ( c == EOF )\n\t    return 0;\n\telse if ( c == '\\\\' ) {\n\t    maybetag=0;\n\t    if ( peek(f, size+2) != EOF )\n\t\tsize++;\n\t}\n\telse if ( isspace(c) )\n\t    break;\n\telse if ( ! (c == '/' || isalnum(c) ) )\n\t    maybetag=0;\n    }\n\n    if ( size ) {\n\tif ( maybetag || (size >= 3 && strncmp(cursor(f), \"!--\", 3) == 0) ) {\n\n\t    /* It is not a html tag unless we find the closing '>' in\n\t     * the same block.\n\t     */\n\t    while ( (c = peek(f, size+1)) != '>' )\n\t\tif ( c == EOF )\n\t\t    return 0;\n\t\telse\n\t\t    size++;\n\t    \n\t    if ( forbidden_tag(f) )\n\t\treturn 0;\n\n\t    Qchar('<', f);\n\t    while ( ((c = peek(f, 1)) != EOF) && (c != '>') )\n\t\tQchar(pull(f), f);\n\t    return 1;\n\t}\n\telse if ( !isspace(c) && process_possible_link(f, size) ) {\n\t    shift(f, size+1);\n\t    return 1;\n\t}\n    }\n    \n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* matchticks() -- match a certain # of ticks, and if that fails\n *                 match the largest subset of those ticks.\n *\n *                 if a subset was matched, modify the passed in\n *                 # of ticks so that the caller (text()) can\n *                 appropriately process the horrible thing.\n */\n", "func_signal": "static int\nmatchticks(MMIOT *f, int *ticks)", "code": "{\n    int size, tick, c;\n    int subsize=0, subtick=0;\n    \n    for (size = *ticks; (c=peek(f,size)) != EOF; ) {\n\tif ( c == '`' )\n\t    if ( (tick=nrticks(size,f)) == *ticks )\n\t\treturn size;\n\t    else {\n\t\tif ( tick > subtick ) {\n\t\t    subsize = size;\n\t\t    subtick = tick;\n\t\t}\n\t\tsize += tick;\n\t    }\n\telse\n\t    size++;\n    }\n    if ( subsize ) {\n\t*ticks = subtick;\n\treturn subsize;\n    }\n    return 0;\n    \n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Qprintf()\n */\n", "func_signal": "static void\nQprintf(MMIOT *f, char *fmt, ...)", "code": "{\n    char bfr[80];\n    va_list ptr;\n\n    va_start(ptr,fmt);\n    vsnprintf(bfr, sizeof bfr, fmt, ptr);\n    va_end(ptr);\n    Qstring(bfr, f);\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* print out a linky (or fail if it's Not Allowed)\n */\n", "func_signal": "static int\nlinkyformat(MMIOT *f, Cstring text, int image, Footnote *ref)", "code": "{\n    linkytype *tag;\n\n    if ( image )\n\ttag = &imaget;\n    else if ( tag = pseudo(ref->link) ) {\n\tif ( f->flags & (NO_PSEUDO_PROTO|SAFELINK) )\n\t    return 0;\n    }\n    else if ( (f->flags & SAFELINK) && T(ref->link)\n\t\t\t\t    && (T(ref->link)[0] != '/')\n\t\t\t\t    && !isautoprefix(T(ref->link), S(ref->link)) )\n\t/* if SAFELINK, only accept links that are local or\n\t * a well-known protocol\n\t */\n\treturn 0;\n    else\n\ttag = &linkt;\n\n    if ( f->flags & tag->flags )\n\treturn 0;\n\n    if ( tag->link_pfx ) {\n\tprintlinkyref(f, tag, T(ref->link), S(ref->link));\n\n\tif ( tag->WxH ) {\n\t    if ( ref->height ) Qprintf(f,\" height=\\\"%d\\\"\", ref->height);\n\t    if ( ref->width ) Qprintf(f, \" width=\\\"%d\\\"\", ref->width);\n\t}\n\n\tif ( S(ref->title) ) {\n\t    Qstring(\" title=\\\"\", f);\n\t    ___mkd_reparse(T(ref->title), S(ref->title), INSIDE_TAG, f);\n\t    Qchar('\"', f);\n\t}\n\n\tQstring(tag->text_pfx, f);\n\t___mkd_reparse(T(text), S(text), tag->flags, f);\n\tQstring(tag->text_sfx, f);\n    }\n    else\n\tQwrite(T(ref->link) + tag->szpat, S(ref->link) - tag->szpat, f);\n\n    return 1;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Qstring()\n */\n", "func_signal": "static void\nQstring(char *s, MMIOT *f)", "code": "{\n    while (*s)\n\tQchar(*s++, f);\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/*\n * process embedded links and images\n */\n", "func_signal": "static int\nlinkylinky(int image, MMIOT *f)", "code": "{\n    int start = mmiottell(f);\n    Cstring name;\n    Footnote key, *ref;\n\t\t\n    int status = 0;\n\n    CREATE(name);\n    memset(&key, 0, sizeof key);\n\n    if ( linkylabel(f, &name) ) {\n\tif ( peek(f,1) == '(' ) {\n\t    pull(f);\n\t    if ( linkyurl(f, image, &key) )\n\t\tstatus = linkyformat(f, name, image, &key);\n\t}\n\telse {\n\t    int goodlink, implicit_mark = mmiottell(f);\n\n\t    if ( eatspace(f) == '[' ) {\n\t\tpull(f);\t/* consume leading '[' */\n\t\tgoodlink = linkylabel(f, &key.tag);\n\t    }\n\t    else {\n\t\t/* new markdown implicit name syntax doesn't\n\t\t * require a second []\n\t\t */\n\t\tmmiotseek(f, implicit_mark);\n\t\tgoodlink = !(f->flags & MKD_1_COMPAT);\n\t    }\n\t    \n\t    if ( goodlink ) {\n\t\tif ( !S(key.tag) ) {\n\t\t    DELETE(key.tag);\n\t\t    T(key.tag) = T(name);\n\t\t    S(key.tag) = S(name);\n\t\t}\n\n\t\tif ( ref = bsearch(&key, T(*f->footnotes), S(*f->footnotes),\n\t\t\t\t\t  sizeof key, (stfu)__mkd_footsort) )\n\t\t    status = linkyformat(f, name, image, ref);\n\t    }\n\t}\n    }\n\n    DELETE(name);\n    ___mkd_freefootnote(&key);\n\n    if ( status == 0 )\n\tmmiotseek(f, start);\n\n    return status;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* move n characters forward ( or -n characters backward) in the input buffer.\n */\n", "func_signal": "static void\nshift(MMIOT *f, int i)", "code": "{\n    if (f->isp + i >= 0 )\n\tf->isp += i;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Smarty-pants-style chrome for quotes, -, ellipses, and (r)(c)(tm)\n */\n", "func_signal": "static int\nsmartypants(int c, int *flags, MMIOT *f)", "code": "{\n    int i;\n\n    if ( f->flags & (DENY_SMARTY|INSIDE_TAG) )\n\treturn 0;\n\n    for ( i=0; i < NRSMART; i++)\n\tif ( (c == smarties[i].c0) && islike(f, smarties[i].pat) ) {\n\t    if ( smarties[i].entity )\n\t\tQprintf(f, \"&%s;\", smarties[i].entity);\n\t    shift(f, smarties[i].shift);\n\t    return 1;\n\t}\n\n    switch (c) {\n    case '<' :  return 0;\n    case '\\'':  if ( smartyquote(flags, 's', f) ) return 1;\n\t\tbreak;\n\n    case '\"':\tif ( smartyquote(flags, 'd', f) ) return 1;\n\t\tbreak;\n\n    case '`':   if ( peek(f, 1) == '`' ) {\n\t\t    int j = 2;\n\n\t\t    while ( (c=peek(f,j)) != EOF ) {\n\t\t\tif ( c == '\\\\' )\n\t\t\t    j += 2;\n\t\t\telse if ( c == '`' )\n\t\t\t    break;\n\t\t\telse if ( c == '\\'' && peek(f, j+1) == '\\'' ) {\n\t\t\t    Qstring(\"&ldquo;\", f);\n\t\t\t    ___mkd_reparse(cursor(f)+1, j-2, 0, f);\n\t\t\t    Qstring(\"&rdquo;\", f);\n\t\t\t    shift(f,j+1);\n\t\t\t    return 1;\n\t\t\t}\n\t\t\telse ++j;\n\t\t    }\n\n\t\t}\n\t\tbreak;\n    }\n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* look <i> characters ahead of the cursor.\n */\n", "func_signal": "static int\npeek(MMIOT *f, int i)", "code": "{\n\n    i += (f->isp-1);\n\n    return (i >= 0) && (i < S(f->in)) ? T(f->in)[i] : EOF;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* smartyquote code that's common for single and double quotes\n */\n", "func_signal": "static int\nsmartyquote(int *flags, char typeofquote, MMIOT *f)", "code": "{\n    int bit = (typeofquote == 's') ? 0x01 : 0x02;\n\n    if ( bit & (*flags) ) {\n\tif ( isthisnonword(f,1) ) {\n\t    Qprintf(f, \"&r%cquo;\", typeofquote);\n\t    (*flags) &= ~bit;\n\t    return 1;\n\t}\n    }\n    else if ( isthisnonword(f,-1) && peek(f,1) != EOF ) {\n\tQprintf(f, \"&l%cquo;\", typeofquote);\n\t(*flags) |= bit;\n\treturn 1;\n    }\n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* extract a =HHHxWWW size from the input stream\n */\n", "func_signal": "static int\nlinkysize(MMIOT *f, Footnote *ref)", "code": "{\n    int height=0, width=0;\n    int whence = mmiottell(f);\n    int c;\n\n    if ( isspace(peek(f,0)) ) {\n\tpull(f);\t/* eat '=' */\n\n\tfor ( c = pull(f); isdigit(c); c = pull(f))\n\t    width = (width * 10) + (c - '0');\n\n\tif ( c == 'x' ) {\n\t    for ( c = pull(f); isdigit(c); c = pull(f))\n\t\theight = (height*10) + (c - '0');\n\n\t    if ( isspace(c) )\n\t\tc = eatspace(f);\n\n\t    if ( (c == ')') || ((c == '\\'' || c == '\"') && linkytitle(f, c, ref)) ) {\n\t\tref->height = height;\n\t\tref->width  = width;\n\t\treturn 1;\n\t    }\n\t}\n    }\n    mmiotseek(f, whence);\n    return 0;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Qchar()\n */\n", "func_signal": "static void\nQchar(int c, MMIOT *f)", "code": "{\n    block *cur;\n    \n    if ( S(f->Q) == 0 ) {\n\tcur = &EXPAND(f->Q);\n\tmemset(cur, 0, sizeof *cur);\n\tcur->b_type = bTEXT;\n    }\n    else\n\tcur = &T(f->Q)[S(f->Q)-1];\n\n    EXPAND(cur->b_text) = c;\n    \n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* generate html from a markup fragment\n */\n", "func_signal": "void\n___mkd_reparse(char *bfr, int size, int flags, MMIOT *f)", "code": "{\n    MMIOT sub;\n\n    ___mkd_initmmiot(&sub, f->footnotes);\n    \n    sub.flags = f->flags | flags;\n    sub.cb = f->cb;\n\n    push(bfr, size, &sub);\n    EXPAND(sub.in) = 0;\n    S(sub.in)--;\n    \n    text(&sub);\n    ___mkd_emblock(&sub);\n    \n    Qwrite(T(sub.out), S(sub.out), f);\n\n    ___mkd_freemmiot(&sub, f->footnotes);\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* Qcopy()\n */\n", "func_signal": "static void\nQcopy(int count, MMIOT *f)", "code": "{\n    while ( count-- > 0 )\n\tQchar(pull(f), f);\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/*\n * push text into the generator input buffer\n */\n", "func_signal": "static void\npush(char *bfr, int size, MMIOT *f)", "code": "{\n    while ( size-- > 0 )\n\tEXPAND(f->in) = *bfr++;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "/* advance forward until the next character is not whitespace\n */\n", "func_signal": "static int\neatspace(MMIOT *f)", "code": "{\n    int c;\n\n    for ( ; ((c=peek(f, 1)) != EOF) && isspace(c); pull(f) )\n\t;\n    return c;\n}", "path": "libmarkdown\\generate.c", "repo_name": "Arclite/Jotdown", "stars": 9, "license": "bsd-3-clause", "language": "c", "size": 200}
{"docstring": "// =============================================================================\n// output functions\n// =============================================================================\n", "func_signal": "static int hash_entry_compare(const void* arg1, const void* arg2)", "code": "{\n    HashEntry* e1 = *(HashEntry**)arg1;\n    HashEntry* e2 = *(HashEntry**)arg2;\n\n    size_t nbAlloc1 = e1->allocations;\n    size_t nbAlloc2 = e2->allocations;\n    size_t size1 = e1->size & ~SIZE_FLAG_MASK;\n    size_t size2 = e2->size & ~SIZE_FLAG_MASK;\n    size_t alloc1 = nbAlloc1 * size1;\n    size_t alloc2 = nbAlloc2 * size2;\n\n    // sort in descending order by:\n    // 1) total size\n    // 2) number of allocations\n    //\n    // This is used for sorting, not determination of equality, so we don't\n    // need to compare the bit flags.\n    int result;\n    if (alloc1 > alloc2) {\n        result = -1;\n    } else if (alloc1 < alloc2) {\n        result = 1;\n    } else {\n        if (nbAlloc1 > nbAlloc2) {\n            result = -1;\n        } else if (nbAlloc1 < nbAlloc2) {\n            result = 1;\n        } else {\n            result = 0;\n        }\n    }\n    return result;\n}", "path": "libc\\bionic\\malloc_leak.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * numeric hostname with scope\n */\n", "func_signal": "static int\nexplore_numeric_scope(const struct addrinfo *pai, const char *hostname,\n    const char *servname, struct addrinfo **res)", "code": "{\n#if !defined(SCOPE_DELIMITER) || !defined(INET6)\n\treturn explore_numeric(pai, hostname, servname, res, hostname);\n#else\n\tconst struct afd *afd;\n\tstruct addrinfo *cur;\n\tint error;\n\tchar *cp, *hostname2 = NULL, *scope, *addr;\n\tstruct sockaddr_in6 *sin6;\n\n\tassert(pai != NULL);\n\t/* hostname may be NULL */\n\t/* servname may be NULL */\n\tassert(res != NULL);\n\n\t/*\n\t * if the servname does not match socktype/protocol, ignore it.\n\t */\n\tif (get_portmatch(pai, servname) != 0)\n\t\treturn 0;\n\n\tafd = find_afd(pai->ai_family);\n\tif (afd == NULL)\n\t\treturn 0;\n\n\tif (!afd->a_scoped)\n\t\treturn explore_numeric(pai, hostname, servname, res, hostname);\n\n\tcp = strchr(hostname, SCOPE_DELIMITER);\n\tif (cp == NULL)\n\t\treturn explore_numeric(pai, hostname, servname, res, hostname);\n\n\t/*\n\t * Handle special case of <scoped_address><delimiter><scope id>\n\t */\n\thostname2 = strdup(hostname);\n\tif (hostname2 == NULL)\n\t\treturn EAI_MEMORY;\n\t/* terminate at the delimiter */\n\thostname2[cp - hostname] = '\\0';\n\taddr = hostname2;\n\tscope = cp + 1;\n\n\terror = explore_numeric(pai, addr, servname, res, hostname);\n\tif (error == 0) {\n\t\tu_int32_t scopeid;\n\n\t\tfor (cur = *res; cur; cur = cur->ai_next) {\n\t\t\tif (cur->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsin6 = (struct sockaddr_in6 *)(void *)cur->ai_addr;\n\t\t\tif (ip6_str2scopeid(scope, sin6, &scopeid) == -1) {\n\t\t\t\tfree(hostname2);\n\t\t\t\treturn(EAI_NODATA); /* XXX: is return OK? */\n\t\t\t}\n\t\t\tsin6->sin6_scope_id = scopeid;\n\t\t}\n\t}\n\n\tfree(hostname2);\n\n\treturn error;\n#endif\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * syslog, vsyslog --\n *\tprint message on log file; output is intended for syslogd(8).\n */\n", "func_signal": "void\nsyslog(int pri, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsyslog(pri, fmt, ap);\n\tva_end(ap);\n}", "path": "libc\\unistd\\syslog.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * Concatenate src on the end of dst.  At most strlen(dst)+n+1 bytes\n * are written at dst (at most n+1 bytes being appended).  Return dst.\n */\n", "func_signal": "char *\nstrncat(char *dst, const char *src, size_t n)", "code": "{\n\tif (n != 0) {\n\t\tchar *d = dst;\n\t\tconst char *s = src;\n\n\t\twhile (*d != 0)\n\t\t\td++;\n\t\tdo {\n\t\t\tif ((*d = *s++) == 0)\n\t\t\t\tbreak;\n\t\t\td++;\n\t\t} while (--n != 0);\n\t\t*d = 0;\n  }\n\treturn (dst);\n}", "path": "libc\\string\\strncat.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* lldiv_t */\n", "func_signal": "lldiv_t\nlldiv(long long num, long long denom)", "code": "{\n\tlldiv_t r;\n\n\t/* see div.c for comments */\n\n\tr.quot = num / denom;\n\tr.rem = num % denom;\n\tif (num >= 0 && r.rem < 0) {\n\t\tr.quot++;\n\t\tr.rem -= denom;\n\t}\n\treturn (r);\n}", "path": "libc\\stdlib\\lldiv.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * Transform string s2 to string s1 using the current locale so that\n * strcmp of transformed strings yields the same result as strcoll. \n * Since Bionic really does not support locales, we assume we always use\n * the C locale.\n *\n * This function is provided to make libstdc++-v3 usable.\n */\n", "func_signal": "size_t\nstrxfrm(char *s1, const char *s2, size_t n)", "code": "{\n\tsize_t len = strlen(s2) + 1;\n\n\tif (len < n)\n\t\tn = len;\n\tmemcpy(s1, s2, n);\n\treturn len;\n}", "path": "libc\\string\\strxfrm.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* 0x4c000000 */\n", "func_signal": "float\nlogbf(float x)", "code": "{\n\tint32_t ix;\n\tGET_FLOAT_WORD(ix,x);\n\tix &= 0x7fffffff;\t\t\t/* high |x| */\n\tif(ix==0) return (float)-1.0/fabsf(x);\n\tif(ix>=0x7f800000) return x*x;\n\tif(ix<0x00800000) {\n\t\tx *= two25;\t\t /* convert subnormal x to normal */\n\t\tGET_FLOAT_WORD(ix,x);\n\t\tix &= 0x7fffffff;\n\t\treturn (float) ((ix>>23)-127-25);\n\t} else\n\t\treturn (float) ((ix>>23)-127);\n}", "path": "libm\\src\\s_logbf.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* setlogmask -- set the log mask level */\n", "func_signal": "int\nsetlogmask_r(int pmask, struct syslog_data *data)", "code": "{\n\tint omask;\n\n\tomask = data->log_mask;\n\tif (pmask != 0)\n\t\tdata->log_mask = pmask;\n\treturn (omask);\n}", "path": "libc\\unistd\\syslog.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static int\n_files_getaddrinfo(void *rv, void *cb_data, va_list ap)", "code": "{\n\tconst char *name;\n\tconst struct addrinfo *pai;\n\tstruct addrinfo sentinel, *cur;\n\tstruct addrinfo *p;\n\tFILE *hostf = NULL;\n\n\tname = va_arg(ap, char *);\n\tpai = va_arg(ap, struct addrinfo *);\n\n//\tfprintf(stderr, \"_files_getaddrinfo() name = '%s'\\n\", name);\n\tmemset(&sentinel, 0, sizeof(sentinel));\n\tcur = &sentinel;\n\n\t_sethtent(&hostf);\n\twhile ((p = _gethtent(&hostf, name, pai)) != NULL) {\n\t\tcur->ai_next = p;\n\t\twhile (cur && cur->ai_next)\n\t\t\tcur = cur->ai_next;\n\t}\n\t_endhtent(&hostf);\n\n\t*((struct addrinfo **)rv) = sentinel.ai_next;\n\tif (sentinel.ai_next == NULL)\n\t\treturn NS_NOTFOUND;\n\treturn NS_SUCCESS;\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * setenv --\n *\tSet the value of the environmental variable \"name\" to be\n *\t\"value\".  If rewrite is set, replace any current value.\n */\n", "func_signal": "int\nsetenv(const char *name, const char *value, int rewrite)", "code": "{\n\tstatic char **lastenv;\t\t\t/* last value of environ */\n\tchar *C;\n\tint l_value, offset;\n\n\tif (*value == '=')\t\t\t/* no `=' in value */\n\t\t++value;\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, &offset))) {\t/* find if already exists */\n\t\tif (!rewrite)\n\t\t\treturn (0);\n\t\tif ((int)strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\t\tchar **P;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n        P = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tfor (C = (char *)name; *C && *C != '='; ++C)\n\t\t;\t\t\t\t/* no `=' in name */\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(C - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}", "path": "libc\\stdlib\\setenv.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static int\n_dns_getaddrinfo(void *rv, void\t*cb_data, va_list ap)", "code": "{\n\tstruct addrinfo *ai;\n\tquerybuf *buf, *buf2;\n\tconst char *name;\n\tconst struct addrinfo *pai;\n\tstruct addrinfo sentinel, *cur;\n\tstruct res_target q, q2;\n\tres_state res;\n\n\tname = va_arg(ap, char *);\n\tpai = va_arg(ap, const struct addrinfo *);\n\t//fprintf(stderr, \"_dns_getaddrinfo() name = '%s'\\n\", name);\n\n\tmemset(&q, 0, sizeof(q));\n\tmemset(&q2, 0, sizeof(q2));\n\tmemset(&sentinel, 0, sizeof(sentinel));\n\tcur = &sentinel;\n\n\tbuf = malloc(sizeof(*buf));\n\tif (buf == NULL) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn NS_NOTFOUND;\n\t}\n\tbuf2 = malloc(sizeof(*buf2));\n\tif (buf2 == NULL) {\n\t\tfree(buf);\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn NS_NOTFOUND;\n\t}\n\n\tswitch (pai->ai_family) {\n\tcase AF_UNSPEC:\n\t\t/* prefer IPv6 */\n\t\tq.name = name;\n\t\tq.qclass = C_IN;\n\t\tq.answer = buf->buf;\n\t\tq.anslen = sizeof(buf->buf);\n\t\t/* If AI_ADDRCONFIG, lookup IPv6 only if we have connectivity */\n\t\tif (!(pai->ai_flags & AI_ADDRCONFIG) || _have_ipv6()) {\n\t\t\tq.qtype = T_AAAA;\n\t\t\tq.next = &q2;\n\t\t\tq2.name = name;\n\t\t\tq2.qclass = C_IN;\n\t\t\tq2.qtype = T_A;\n\t\t\tq2.answer = buf2->buf;\n\t\t\tq2.anslen = sizeof(buf2->buf);\n\t\t} else {\n\t\t\tq.qtype = T_A;\n\t\t}\n\t\tbreak;\n\tcase AF_INET:\n\t\tq.name = name;\n\t\tq.qclass = C_IN;\n\t\tq.qtype = T_A;\n\t\tq.answer = buf->buf;\n\t\tq.anslen = sizeof(buf->buf);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tq.name = name;\n\t\tq.qclass = C_IN;\n\t\tq.qtype = T_AAAA;\n\t\tq.answer = buf->buf;\n\t\tq.anslen = sizeof(buf->buf);\n\t\tbreak;\n\tdefault:\n\t\tfree(buf);\n\t\tfree(buf2);\n\t\treturn NS_UNAVAIL;\n\t}\n\n\tres = __res_get_state();\n\tif (res == NULL) {\n\t\tfree(buf);\n\t\tfree(buf2);\n\t\treturn NS_NOTFOUND;\n\t}\n\n\tif (res_searchN(name, &q, res) < 0) {\n\t\t__res_put_state(res);\n\t\tfree(buf);\n\t\tfree(buf2);\n\t\treturn NS_NOTFOUND;\n\t}\n\tai = getanswer(buf, q.n, q.name, q.qtype, pai);\n\tif (ai) {\n\t\tcur->ai_next = ai;\n\t\twhile (cur && cur->ai_next)\n\t\t\tcur = cur->ai_next;\n\t}\n\tif (q.next) {\n\t\tai = getanswer(buf2, q2.n, q2.name, q2.qtype, pai);\n\t\tif (ai)\n\t\t\tcur->ai_next = ai;\n\t}\n\tfree(buf);\n\tfree(buf2);\n\tif (sentinel.ai_next == NULL) {\n\t\t__res_put_state(res);\n\t\tswitch (h_errno) {\n\t\tcase HOST_NOT_FOUND:\n\t\t\treturn NS_NOTFOUND;\n\t\tcase TRY_AGAIN:\n\t\t\treturn NS_TRYAGAIN;\n\t\tdefault:\n\t\t\treturn NS_UNAVAIL;\n\t\t}\n\t}\n\n\tif (res->nsort)\n\t\taisort(&sentinel, res);\n\n\t__res_put_state(res);\n\n\t*((struct addrinfo **)rv) = sentinel.ai_next;\n\treturn NS_SUCCESS;\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* ok, this is really subtle: <asm/signal.h> defines sigset_t differently\n * when you're in the kernel or in the C library.\n *\n * in the kernel, this is an array of 2 32-bit unsigned longs\n * in the C library, this is a single 32-bit unsigned long\n *\n * moreover, the kernel implementation of rt_sigtimedwait doesn't\n * accept anything except kernel-sized signal sets (probably a bug !)\n *\n * we thus need to create a fake kernel sigset !!\n */\n", "func_signal": "int sigwait(const sigset_t *set, int *sig)", "code": "{\n    int  ret;\n    /* use a union to get rid of aliasing warnings */\n    union {\n      unsigned long  kernel_sigset[2];\n      sigset_t       dummy_sigset;\n    } u;\n\n/*\n * easyweb2:\n *  09-08-15\n *   o Update sigset_t type for compatibility with kernel >= 2.6.30\n */\n#ifndef EASYWEB2\n    u.kernel_sigset[0] = *set;\n    u.kernel_sigset[1] = 0;  /* no real-time signals supported ? */\n#else\n    u.kernel_sigset[0] = set->sig[0];\n    u.kernel_sigset[1] = 0;  /* no real-time signals supported */\n#endif\n    for (;;)\n    {\n     /* __rt_sigtimedwait can return EAGAIN or EINTR, we need to loop\n      * around them since sigwait is only allowed to return EINVAL\n      */\n      ret = __rt_sigtimedwait ( &u.dummy_sigset, NULL, NULL, sizeof(u.kernel_sigset));\n      if (ret >= 0)\n        break;\n\n      if (errno != EAGAIN && errno != EINTR)\n        return errno;\n    }\n\n    *sig = ret;\n    return 0;\n}", "path": "libc\\unistd\\sigwait.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* \n * Re-direct an existing, open (probably) file to some other file. \n * ANSI is written such that the original file gets closed if at\n * all possible, no matter what.\n */\n", "func_signal": "FILE *\nfreopen(const char *file, const char *mode, FILE *fp)", "code": "{\n\tint f;\n\tint flags, isopen, oflags, sverrno, wantfd;\n\n\tif ((flags = __sflags(mode, &oflags)) == 0) {\n\t\t(void) fclose(fp);\n\t\treturn (NULL);\n\t}\n\n\tif (!__sdidinit)\n\t\t__sinit();\n\n\t/*\n\t * There are actually programs that depend on being able to \"freopen\"\n\t * descriptors that weren't originally open.  Keep this from breaking.\n\t * Remember whether the stream was open to begin with, and which file\n\t * descriptor (if any) was associated with it.  If it was attached to\n\t * a descriptor, defer closing it; freopen(\"/dev/stdin\", \"r\", stdin)\n\t * should work.  This is unnecessary if it was not a Unix file.\n\t */\n\tif (fp->_flags == 0) {\n\t\tfp->_flags = __SEOF;\t/* hold on to it */\n\t\tisopen = 0;\n\t\twantfd = -1;\n\t} else {\n\t\t/* flush the stream; ANSI doesn't require this. */\n\t\tif (fp->_flags & __SWR)\n\t\t\t(void) __sflush(fp);\n\t\t/* if close is NULL, closing is a no-op, hence pointless */\n\t\tisopen = fp->_close != NULL;\n\t\tif ((wantfd = fp->_file) < 0 && isopen) {\n\t\t\t(void) (*fp->_close)(fp->_cookie);\n\t\t\tisopen = 0;\n\t\t}\n\t}\n\n\t/* Get a new descriptor to refer to the new file. */\n\tf = open(file, oflags, DEFFILEMODE);\n\tif (f < 0 && isopen) {\n\t\t/* If out of fd's close the old one and try again. */\n\t\tif (errno == ENFILE || errno == EMFILE) {\n\t\t\t(void) (*fp->_close)(fp->_cookie);\n\t\t\tisopen = 0;\n\t\t\tf = open(file, oflags, DEFFILEMODE);\n\t\t}\n\t}\n\tsverrno = errno;\n\n\t/*\n\t * Finish closing fp.  Even if the open succeeded above, we cannot\n\t * keep fp->_base: it may be the wrong size.  This loses the effect\n\t * of any setbuffer calls, but stdio has always done this before.\n\t */\n\tif (isopen && f != wantfd)\n\t\t(void) (*fp->_close)(fp->_cookie);\n\tif (fp->_flags & __SMBF)\n\t\tfree((char *)fp->_bf._base);\n\tfp->_w = 0;\n\tfp->_r = 0;\n\tfp->_p = NULL;\n\tfp->_bf._base = NULL;\n\tfp->_bf._size = 0;\n\tfp->_lbfsize = 0;\n\tif (HASUB(fp))\n\t\tFREEUB(fp);\n\t_UB(fp)._size = 0;\n\tWCIO_FREE(fp);\n\tif (HASLB(fp))\n\t\tFREELB(fp);\n\tfp->_lb._size = 0;\n\n\tif (f < 0) {\t\t\t/* did not get it after all */\n\t\tfp->_flags = 0;\t\t/* set it free */\n\t\terrno = sverrno;\t/* restore in case _close clobbered */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * If reopening something that was open before on a real file, try\n\t * to maintain the descriptor.  Various C library routines (perror)\n\t * assume stderr is always fd STDERR_FILENO, even if being freopen'd.\n\t */\n\tif (wantfd >= 0 && f != wantfd) {\n\t\tif (dup2(f, wantfd) >= 0) {\n\t\t\t(void) close(f);\n\t\t\tf = wantfd;\n\t\t}\n\t}\n\n\tfp->_flags = flags;\n\tfp->_file = f;\n\tfp->_cookie = fp;\n\tfp->_read = __sread;\n\tfp->_write = __swrite;\n\tfp->_seek = __sseek;\n\tfp->_close = __sclose;\n\n\t/*\n\t * When opening in append mode, even though we use O_APPEND,\n\t * we need to seek to the end so that ftell() gets the right\n\t * answer.  If the user then alters the seek pointer, or\n\t * the file extends, this will fail, but there is not much\n\t * we can do about this.  (We could set __SAPP and check in\n\t * fseek and ftell.)\n\t */\n\tif (oflags & O_APPEND)\n\t\t(void) __sseek((void *)fp, (fpos_t)0, SEEK_END);\n\treturn (fp);\n}", "path": "libc\\stdio\\freopen.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* convert a string to a scope identifier. XXX: IPv6 specific */\n", "func_signal": "static int\nip6_str2scopeid(char *scope, struct sockaddr_in6 *sin6, u_int32_t *scopeid)", "code": "{\n\tu_long lscopeid;\n\tstruct in6_addr *a6;\n\tchar *ep;\n\n\tassert(scope != NULL);\n\tassert(sin6 != NULL);\n\tassert(scopeid != NULL);\n\n\ta6 = &sin6->sin6_addr;\n\n\t/* empty scopeid portion is invalid */\n\tif (*scope == '\\0')\n\t\treturn -1;\n\n\tif (IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6)) {\n\t\t/*\n\t\t * We currently assume a one-to-one mapping between links\n\t\t * and interfaces, so we simply use interface indices for\n\t\t * like-local scopes.\n\t\t */\n\t\t*scopeid = if_nametoindex(scope);\n\t\tif (*scopeid == 0)\n\t\t\tgoto trynumeric;\n\t\treturn 0;\n\t}\n\n\t/* still unclear about literal, allow numeric only - placeholder */\n\tif (IN6_IS_ADDR_SITELOCAL(a6) || IN6_IS_ADDR_MC_SITELOCAL(a6))\n\t\tgoto trynumeric;\n\tif (IN6_IS_ADDR_MC_ORGLOCAL(a6))\n\t\tgoto trynumeric;\n\telse\n\t\tgoto trynumeric;\t/* global */\n\n\t/* try to convert to a numeric id as a last resort */\n  trynumeric:\n\terrno = 0;\n\tlscopeid = strtoul(scope, &ep, 10);\n\t*scopeid = (u_int32_t)(lscopeid & 0xffffffffUL);\n\tif (errno == 0 && ep && *ep == '\\0' && *scopeid == lscopeid)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* Reentrant version of syslog, i.e. syslog_r() */\n", "func_signal": "void\nsyslog_r(int pri, struct syslog_data *data, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsyslog_r(pri, data, fmt, ap);\n\tva_end(ap);\n}", "path": "libc\\unistd\\syslog.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */\n", "func_signal": "double\ncbrt(double x)", "code": "{\n\tint32_t\thx;\n\tdouble r,s,t=0.0,w;\n\tu_int32_t sign;\n\tu_int32_t high,low;\n\n\tGET_HIGH_WORD(hx,x);\n\tsign=hx&0x80000000; \t\t/* sign= sign(x) */\n\thx  ^=sign;\n\tif(hx>=0x7ff00000) return(x+x); /* cbrt(NaN,INF) is itself */\n\tGET_LOW_WORD(low,x);\n\tif((hx|low)==0)\n\t    return(x);\t\t/* cbrt(0) is itself */\n\n    /*\n     * Rough cbrt to 5 bits:\n     *    cbrt(2**e*(1+m) ~= 2**(e/3)*(1+(e%3+m)/3)\n     * where e is integral and >= 0, m is real and in [0, 1), and \"/\" and\n     * \"%\" are integer division and modulus with rounding towards minus\n     * infinity.  The RHS is always >= the LHS and has a maximum relative\n     * error of about 1 in 16.  Adding a bias of -0.03306235651 to the\n     * (e%3+m)/3 term reduces the error to about 1 in 32. With the IEEE\n     * floating point representation, for finite positive normal values,\n     * ordinary integer divison of the value in bits magically gives\n     * almost exactly the RHS of the above provided we first subtract the\n     * exponent bias (1023 for doubles) and later add it back.  We do the\n     * subtraction virtually to keep e >= 0 so that ordinary integer\n     * division rounds towards minus infinity; this is also efficient.\n     */\n\tif(hx<0x00100000) { \t\t/* subnormal number */\n\t    SET_HIGH_WORD(t,0x43500000); /* set t= 2**54 */\n\t    t*=x;\n\t    GET_HIGH_WORD(high,t);\n\t    SET_HIGH_WORD(t,sign|((high&0x7fffffff)/3+B2));\n\t} else\n\t    SET_HIGH_WORD(t,sign|(hx/3+B1));\n\n    /* new cbrt to 23 bits; may be implemented in single precision */\n\tr=t*t/x;\n\ts=C+r*t;\n\tt*=G+F/(s+E+D/s);\n\n    /* chop t to 20 bits and make it larger in magnitude than cbrt(x) */\n\tGET_HIGH_WORD(high,t);\n\tINSERT_WORDS(t,high+0x00000001,0);\n\n    /* one step Newton iteration to 53 bits with error less than 0.667 ulps */\n\ts=t*t;\t\t/* t*t is exact */\n\tr=x/s;\n\tw=t+t;\n\tr=(r-t)/(w+r);\t/* r-t is exact */\n\tt=t+t*r;\n\n\treturn(t);\n}", "path": "libm\\src\\s_cbrt.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * hostname == NULL.\n * passive socket -> anyaddr (0.0.0.0 or ::)\n * non-passive socket -> localhost (127.0.0.1 or ::1)\n */\n", "func_signal": "static int\nexplore_null(const struct addrinfo *pai, const char *servname,\n    struct addrinfo **res)", "code": "{\n\tint s;\n\tconst struct afd *afd;\n\tstruct addrinfo *cur;\n\tstruct addrinfo sentinel;\n\tint error;\n\n\tassert(pai != NULL);\n\t/* servname may be NULL */\n\tassert(res != NULL);\n\n\t*res = NULL;\n\tsentinel.ai_next = NULL;\n\tcur = &sentinel;\n\n\t/*\n\t * filter out AFs that are not supported by the kernel\n\t * XXX errno?\n\t */\n\ts = socket(pai->ai_family, SOCK_DGRAM, 0);\n\tif (s < 0) {\n\t\tif (errno != EMFILE)\n\t\t\treturn 0;\n\t} else\n\t\tclose(s);\n\n\t/*\n\t * if the servname does not match socktype/protocol, ignore it.\n\t */\n\tif (get_portmatch(pai, servname) != 0)\n\t\treturn 0;\n\n\tafd = find_afd(pai->ai_family);\n\tif (afd == NULL)\n\t\treturn 0;\n\n\tif (pai->ai_flags & AI_PASSIVE) {\n\t\tGET_AI(cur->ai_next, afd, afd->a_addrany);\n\t\t/* xxx meaningless?\n\t\t * GET_CANONNAME(cur->ai_next, \"anyaddr\");\n\t\t */\n\t\tGET_PORT(cur->ai_next, servname);\n\t} else {\n\t\tGET_AI(cur->ai_next, afd, afd->a_loopback);\n\t\t/* xxx meaningless?\n\t\t * GET_CANONNAME(cur->ai_next, \"localhost\");\n\t\t */\n\t\tGET_PORT(cur->ai_next, servname);\n\t}\n\tcur = cur->ai_next;\n\n\t*res = sentinel.ai_next;\n\treturn 0;\n\nfree:\n\tif (sentinel.ai_next)\n\t\tfreeaddrinfo(sentinel.ai_next);\n\treturn error;\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/* Determine whether IPv6 connectivity is available. */\n", "func_signal": "static int\n_have_ipv6()", "code": "{\n\t/*\n\t * Connect a UDP socket to an global unicast IPv6 address. This will\n\t * cause no network traffic, but will fail fast if the system has no or\n\t * limited IPv6 connectivity (e.g., only a link-local address).\n\t */\n\tstatic const struct sockaddr_in6 sin6_test = {\n\t\t/* family, port, flow label */\n\t\tAF_INET6, 0, 0,\n\t\t/* 2000:: */\n\t\t{{{ 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}},\n\t\t/* scope ID */\n\t\t0};\n\tstatic const struct sockaddr *sa_test = (struct sockaddr *) &sin6_test;\n\tint s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\tif (s < 0)\n\t\treturn 0;\n\tint ret;\n\tdo {\n\t\tret = connect(s, sa_test, sizeof(sin6_test));\n\t} while (ret < 0 && errno == EINTR);\n\tint have_ipv6 = (ret == 0);\n\tdo {\n\t\tret = close(s);\n\t} while (ret < 0 && errno == EINTR);\n\treturn have_ipv6;\n}", "path": "libc\\netbsd\\net\\getaddrinfo.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "// =============================================================================\n// malloc fill functions\n// =============================================================================\n", "func_signal": "void* fill_malloc(size_t bytes)", "code": "{\n    void* buffer = dlmalloc(bytes);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes);\n    }\n    return buffer;\n}", "path": "libc\\bionic\\malloc_leak.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n * unsetenv(name) --\n *\tDelete environmental variable \"name\".\n */\n", "func_signal": "int\nunsetenv(const char *name)", "code": "{\n\tchar **P;\n\tint offset;\n\n\twhile (__findenv(name, &offset))\t/* if set multiple times */\n\t\tfor (P = &environ[offset];; ++P)\n\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\tbreak;\n\n        return 0;\n}", "path": "libc\\stdlib\\setenv.c", "repo_name": "koush/android_bionic", "stars": 14, "license": "None", "language": "c", "size": 2128}
{"docstring": "/*\n ***********************************************************************\n *\n * sftp_perform()\n *\n * This is the actual DO function for SFTP. Get a file/directory according to\n * the options previously setup.\n */\n", "func_signal": "static\nCURLcode sftp_perform(struct connectdata *conn,\n                      bool *connected,\n                      bool *dophase_done)", "code": "{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(conn->data, \"DO phase starts\\n\"));\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(conn, SSH_SFTP_QUOTE_INIT);\n\n  /* run the state-machine */\n  if(conn->data->state.used_interface == Curl_if_multi) {\n    result = ssh_multi_statemach(conn, dophase_done);\n  }\n  else {\n    result = ssh_easy_statemach(conn, FALSE);\n    *dophase_done = TRUE; /* with the easy interface we are done here */\n  }\n  *connected = conn->bits.tcpconnect;\n\n  if(*dophase_done) {\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n  }\n\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* return number of sent bytes */\n", "func_signal": "static ssize_t sftp_send(struct connectdata *conn, int sockindex,\n                         const void *mem, size_t len, CURLcode *err)", "code": "{\n  ssize_t nwrite;   /* libssh2_sftp_write() used to return size_t in 0.14\n                       but is changed to ssize_t in 0.15. These days we don't\n                       support libssh2 0.15*/\n  (void)sockindex;\n\n  nwrite = libssh2_sftp_write(conn->proto.sshc.sftp_handle, mem, len);\n\n  ssh_block2waitfor(conn, (nwrite == LIBSSH2_ERROR_EAGAIN)?TRUE:FALSE);\n\n  if(nwrite == LIBSSH2_ERROR_EAGAIN) {\n    *err = CURLE_AGAIN;\n    nwrite = 0;\n  }\n\n  return nwrite;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * Curl_resolv_fdset() is called when someone from the outside world (using\n * curl_multi_fdset()) wants to get our fd_set setup and we're talking with\n * ares. The caller must make sure that this function is only called when we\n * have a working ares channel.\n *\n * Returns: CURLE_OK always!\n */\n", "func_signal": "int Curl_resolv_getsock(struct connectdata *conn,\n                        curl_socket_t *socks,\n                        int numsocks)", "code": "{\n  struct timeval maxtime;\n  struct timeval timebuf;\n  struct timeval *timeout;\n  int max = ares_getsock(conn->data->state.areschannel,\n                         (ares_socket_t *)socks, numsocks);\n\n\n  maxtime.tv_sec = CURL_TIMEOUT_RESOLVE;\n  maxtime.tv_usec = 0;\n\n  timeout = ares_timeout(conn->data->state.areschannel, &maxtime, &timebuf);\n\n  Curl_expire(conn->data,\n              (timeout->tv_sec * 1000) + (timeout->tv_usec/1000));\n\n  return max;\n}", "path": "lib\\hostares.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * SSH setup and connection\n */\n", "func_signal": "static CURLcode ssh_init(struct connectdata *conn)", "code": "{\n  struct SessionHandle *data = conn->data;\n  struct SSHPROTO *ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  sshc->actualcode = CURLE_OK; /* reset error code */\n  sshc->secondCreateDirs =0;   /* reset the create dir attempt state\n                                  variable */\n\n  if(data->state.proto.ssh)\n    return CURLE_OK;\n\n  ssh = calloc(1, sizeof(struct SSHPROTO));\n  if(!ssh)\n    return CURLE_OUT_OF_MEMORY;\n\n  data->state.proto.ssh = ssh;\n\n  return CURLE_OK;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* called repeatedly until done from multi.c */\n", "func_signal": "static CURLcode ssh_multi_statemach(struct connectdata *conn, bool *done)", "code": "{\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  CURLcode result = CURLE_OK;\n  bool block; /* we store the status and use that to provide a ssh_getsock()\n                 implementation */\n\n  result = ssh_statemach_act(conn, &block);\n  *done = (bool)(sshc->state == SSH_STOP);\n  ssh_block2waitfor(conn, block);\n\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * Curl_is_resolved() is called repeatedly to check if a previous name resolve\n * request has completed. It should also make sure to time-out if the\n * operation seems to take too long.\n *\n * Returns normal CURLcode errors.\n */\n", "func_signal": "CURLcode Curl_is_resolved(struct connectdata *conn,\n                          struct Curl_dns_entry **dns)", "code": "{\n  struct SessionHandle *data = conn->data;\n\n  *dns = NULL;\n\n  waitperform(conn, 0);\n\n  if(conn->async.done) {\n    /* we're done, kill the ares handle */\n    if(!conn->async.dns) {\n      failf(data, \"Could not resolve host: %s (%s)\", conn->host.dispname,\n            ares_strerror(conn->async.status));\n      return CURLE_COULDNT_RESOLVE_HOST;\n    }\n    *dns = conn->async.dns;\n  }\n\n  return CURLE_OK;\n}", "path": "lib\\hostares.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * ssh_statemach_act() runs the SSH state machine as far as it can without\n * blocking and without reaching the end.  The data the pointer 'block' points\n * to will be set to TRUE if the libssh2 function returns LIBSSH2_ERROR_EAGAIN\n * meaning it wants to be called again when the socket is ready\n */\n", "func_signal": "static CURLcode ssh_statemach_act(struct connectdata *conn, bool *block)", "code": "{\n  CURLcode result = CURLE_OK;\n  struct SessionHandle *data = conn->data;\n  struct SSHPROTO *sftp_scp = data->state.proto.ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n#ifdef CURL_LIBSSH2_DEBUG\n  const char *fingerprint;\n#endif /* CURL_LIBSSH2_DEBUG */\n  const char *host_public_key_md5;\n  int rc = LIBSSH2_ERROR_NONE, i;\n  int err;\n  int seekerr = CURL_SEEKFUNC_OK;\n  *block = 0; /* we're not blocking by default */\n\n  do {\n\n    switch(sshc->state) {\n    case SSH_S_STARTUP:\n      sshc->secondCreateDirs = 0;\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_OK;\n\n      rc = libssh2_session_startup(sshc->ssh_session, sock);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc) {\n        failf(data, \"Failure establishing ssh session\");\n        state(conn, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_FAILED_INIT;\n        break;\n      }\n\n      /* Set libssh2 to non-blocking, since everything internally is\n         non-blocking */\n      libssh2_session_set_blocking(sshc->ssh_session, 0);\n\n      state(conn, SSH_HOSTKEY);\n\n      /* fall-through */\n    case SSH_HOSTKEY:\n\n#ifdef CURL_LIBSSH2_DEBUG\n      /*\n       * Before we authenticate we should check the hostkey's fingerprint\n       * against our known hosts. How that is handled (reading from file,\n       * whatever) is up to us. As for know not much is implemented, besides\n       * showing how to get the fingerprint.\n       */\n      fingerprint = libssh2_hostkey_hash(sshc->ssh_session,\n                                         LIBSSH2_HOSTKEY_HASH_MD5);\n\n      /* The fingerprint points to static storage (!), don't free() it. */\n      infof(data, \"Fingerprint: \");\n      for (rc = 0; rc < 16; rc++) {\n        infof(data, \"%02X \", (unsigned char) fingerprint[rc]);\n      }\n      infof(data, \"\\n\");\n#endif /* CURL_LIBSSH2_DEBUG */\n\n      /* Before we authenticate we check the hostkey's MD5 fingerprint\n       * against a known fingerprint, if available.  This implementation pulls\n       * it from the curl option.\n       */\n      if(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5] &&\n         strlen(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]) == 32) {\n        char buf[33];\n        host_public_key_md5 = libssh2_hostkey_hash(sshc->ssh_session,\n                                                   LIBSSH2_HOSTKEY_HASH_MD5);\n        for (i = 0; i < 16; i++)\n          snprintf(&buf[i*2], 3, \"%02x\",\n                   (unsigned char) host_public_key_md5[i]);\n        if(!strequal(buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5])) {\n          failf(data,\n                \"Denied establishing ssh session: mismatch md5 fingerprint. \"\n                \"Remote %s is not equal to %s\",\n                buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]);\n          state(conn, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n          break;\n        }\n      }\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n      if(data->set.str[STRING_SSH_KNOWNHOSTS]) {\n        /* we're asked to verify the host against a file */\n        int keytype;\n        size_t keylen;\n        const char *remotekey = libssh2_session_hostkey(sshc->ssh_session,\n                                                        &keylen, &keytype);\n        int keycheck;\n        int keybit;\n\n        if(remotekey) {\n          /*\n           * A subject to figure out is what host name we need to pass in here.\n           * What host name does OpenSSH store in its file if an IDN name is\n           * used?\n           */\n          struct libssh2_knownhost *host;\n          enum curl_khmatch keymatch;\n          curl_sshkeycallback func =\n            data->set.ssh_keyfunc?data->set.ssh_keyfunc:sshkeycallback;\n          struct curl_khkey knownkey;\n          struct curl_khkey *knownkeyp = NULL;\n          struct curl_khkey foundkey;\n\n          keybit = (keytype == LIBSSH2_HOSTKEY_TYPE_RSA)?\n            LIBSSH2_KNOWNHOST_KEY_SSHRSA:LIBSSH2_KNOWNHOST_KEY_SSHDSS;\n\n          keycheck = libssh2_knownhost_check(sshc->kh,\n                                             conn->host.name,\n                                             remotekey, keylen,\n                                             LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n                                             LIBSSH2_KNOWNHOST_KEYENC_RAW|\n                                             keybit,\n                                             &host);\n\n          infof(data, \"SSH host check: %d, key: %s\\n\", keycheck,\n                (keycheck <= LIBSSH2_KNOWNHOST_CHECK_MISMATCH)?\n                host->key:\"<none>\");\n\n          /* setup 'knownkey' */\n          if(keycheck <= LIBSSH2_KNOWNHOST_CHECK_MISMATCH) {\n            knownkey.key = host->key;\n            knownkey.len = 0;\n            knownkey.keytype = (keytype == LIBSSH2_HOSTKEY_TYPE_RSA)?\n              CURLKHTYPE_RSA : CURLKHTYPE_DSS;\n            knownkeyp = &knownkey;\n          }\n\n          /* setup 'foundkey' */\n          foundkey.key = remotekey;\n          foundkey.len = keylen;\n          foundkey.keytype = (keytype == LIBSSH2_HOSTKEY_TYPE_RSA)?\n            CURLKHTYPE_RSA : CURLKHTYPE_DSS;\n\n          /*\n           * if any of the LIBSSH2_KNOWNHOST_CHECK_* defines and the\n           * curl_khmatch enum are ever modified, we need to introduce a\n           * translation table here!\n           */\n          keymatch = (enum curl_khmatch)keycheck;\n\n          /* Ask the callback how to behave */\n          rc = func(data, knownkeyp, /* from the knownhosts file */\n                    &foundkey, /* from the remote host */\n                    keymatch, data->set.ssh_keyfunc_userp);\n        }\n        else\n          /* no remotekey means failure! */\n          rc = CURLKHSTAT_REJECT;\n\n        switch(rc) {\n        default: /* unknown return codes will equal reject */\n        case CURLKHSTAT_REJECT:\n          state(conn, SSH_SESSION_FREE);\n        case CURLKHSTAT_DEFER:\n          /* DEFER means bail out but keep the SSH_HOSTKEY state */\n          result = sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n          break;\n        case CURLKHSTAT_FINE:\n        case CURLKHSTAT_FINE_ADD_TO_FILE:\n          /* proceed */\n          if(keycheck != LIBSSH2_KNOWNHOST_CHECK_MATCH) {\n            /* the found host+key didn't match but has been told to be fine\n               anyway so we add it in memory */\n            int addrc = libssh2_knownhost_add(sshc->kh,\n                                              conn->host.name, NULL,\n                                              remotekey, keylen,\n                                              LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n                                              LIBSSH2_KNOWNHOST_KEYENC_RAW|\n                                              keybit, NULL);\n            if(addrc)\n              infof(data, \"Warning adding the known host %s failed!\\n\",\n                    conn->host.name);\n            else if(rc == CURLKHSTAT_FINE_ADD_TO_FILE) {\n              /* now we write the entire in-memory list of known hosts to the\n                 known_hosts file */\n              int wrc =\n                libssh2_knownhost_writefile(sshc->kh,\n                                            data->set.str[STRING_SSH_KNOWNHOSTS],\n                                            LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n              if(wrc) {\n                infof(data, \"Warning, writing %s failed!\\n\",\n                      data->set.str[STRING_SSH_KNOWNHOSTS]);\n              }\n            }\n          }\n          break;\n        }\n      }\n#endif /* HAVE_LIBSSH2_KNOWNHOST_API */\n\n      state(conn, SSH_AUTHLIST);\n      break;\n\n    case SSH_AUTHLIST:\n      /*\n       * Figure out authentication methods\n       * NB: As soon as we have provided a username to an openssh server we\n       * must never change it later. Thus, always specify the correct username\n       * here, even though the libssh2 docs kind of indicate that it should be\n       * possible to get a 'generic' list (not user-specific) of authentication\n       * methods, presumably with a blank username. That won't work in my\n       * experience.\n       * So always specify it here.\n       */\n      sshc->authlist = libssh2_userauth_list(sshc->ssh_session,\n                                             conn->user,\n                                             (unsigned int)strlen(conn->user));\n\n      if(!sshc->authlist) {\n        if((err = libssh2_session_last_errno(sshc->ssh_session)) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          state(conn, SSH_SESSION_FREE);\n          sshc->actualcode = libssh2_session_error_to_CURLE(err);\n          break;\n        }\n      }\n      infof(data, \"SSH authentication methods available: %s\\n\",\n            sshc->authlist);\n\n      state(conn, SSH_AUTH_PKEY_INIT);\n      break;\n\n    case SSH_AUTH_PKEY_INIT:\n      /*\n       * Check the supported auth types in the order I feel is most secure\n       * with the requested type of authentication\n       */\n      sshc->authed = FALSE;\n\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_PUBLICKEY) &&\n         (strstr(sshc->authlist, \"publickey\") != NULL)) {\n        char *home;\n\n        sshc->rsa_pub = sshc->rsa = NULL;\n\n        /* To ponder about: should really the lib be messing about with the\n           HOME environment variable etc? */\n        home = curl_getenv(\"HOME\");\n\n        if(data->set.str[STRING_SSH_PUBLIC_KEY])\n          sshc->rsa_pub = aprintf(\"%s\", data->set.str[STRING_SSH_PUBLIC_KEY]);\n        else if(home)\n          sshc->rsa_pub = aprintf(\"%s/.ssh/id_dsa.pub\", home);\n        else\n          /* as a final resort, try current dir! */\n          sshc->rsa_pub = strdup(\"id_dsa.pub\");\n\n        if(sshc->rsa_pub == NULL) {\n          Curl_safefree(home);\n          home = NULL;\n          state(conn, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n\n        if(data->set.str[STRING_SSH_PRIVATE_KEY])\n          sshc->rsa = aprintf(\"%s\", data->set.str[STRING_SSH_PRIVATE_KEY]);\n        else if(home)\n          sshc->rsa = aprintf(\"%s/.ssh/id_dsa\", home);\n        else\n          /* as a final resort, try current dir! */\n          sshc->rsa = strdup(\"id_dsa\");\n\n        if(sshc->rsa == NULL) {\n          Curl_safefree(home);\n          home = NULL;\n          Curl_safefree(sshc->rsa_pub);\n          sshc->rsa_pub = NULL;\n          state(conn, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n\n        sshc->passphrase = data->set.str[STRING_KEY_PASSWD];\n        if(!sshc->passphrase)\n          sshc->passphrase = \"\";\n\n        Curl_safefree(home);\n        home = NULL;\n\n        infof(data, \"Using ssh public key file %s\\n\", sshc->rsa_pub);\n        infof(data, \"Using ssh private key file %s\\n\", sshc->rsa);\n\n        state(conn, SSH_AUTH_PKEY);\n      }\n      else {\n        state(conn, SSH_AUTH_PASS_INIT);\n      }\n      break;\n\n    case SSH_AUTH_PKEY:\n      /* The function below checks if the files exists, no need to stat() here.\n       */\n      rc = libssh2_userauth_publickey_fromfile_ex(sshc->ssh_session,\n                                                  conn->user,\n                                                  (unsigned int)\n                                                  strlen(conn->user),\n                                                  sshc->rsa_pub,\n                                                  sshc->rsa, sshc->passphrase);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n\n      Curl_safefree(sshc->rsa_pub);\n      sshc->rsa_pub = NULL;\n      Curl_safefree(sshc->rsa);\n      sshc->rsa = NULL;\n\n      if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized SSH public key authentication\\n\");\n        state(conn, SSH_AUTH_DONE);\n      }\n      else {\n        char *err_msg;\n        (void)libssh2_session_last_error(sshc->ssh_session,\n                                         &err_msg, NULL, 0);\n        infof(data, \"SSH public key authentication failed: %s\\n\", err_msg);\n        state(conn, SSH_AUTH_PASS_INIT);\n      }\n      break;\n\n    case SSH_AUTH_PASS_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_PASSWORD) &&\n         (strstr(sshc->authlist, \"password\") != NULL)) {\n        state(conn, SSH_AUTH_PASS);\n      }\n      else {\n        state(conn, SSH_AUTH_HOST_INIT);\n      }\n      break;\n\n    case SSH_AUTH_PASS:\n      rc = libssh2_userauth_password_ex(sshc->ssh_session, conn->user,\n                                        (unsigned int)strlen(conn->user),\n                                        conn->passwd,\n                                        (unsigned int)strlen(conn->passwd),\n                                        NULL);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized password authentication\\n\");\n        state(conn, SSH_AUTH_DONE);\n      }\n      else {\n        state(conn, SSH_AUTH_HOST_INIT);\n      }\n      break;\n\n    case SSH_AUTH_HOST_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_HOST) &&\n         (strstr(sshc->authlist, \"hostbased\") != NULL)) {\n        state(conn, SSH_AUTH_HOST);\n      }\n      else {\n        state(conn, SSH_AUTH_KEY_INIT);\n      }\n      break;\n\n    case SSH_AUTH_HOST:\n      state(conn, SSH_AUTH_KEY_INIT);\n      break;\n\n    case SSH_AUTH_KEY_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_KEYBOARD)\n         && (strstr(sshc->authlist, \"keyboard-interactive\") != NULL)) {\n        state(conn, SSH_AUTH_KEY);\n      }\n      else {\n        state(conn, SSH_AUTH_DONE);\n      }\n      break;\n\n    case SSH_AUTH_KEY:\n      /* Authentication failed. Continue with keyboard-interactive now. */\n      rc = libssh2_userauth_keyboard_interactive_ex(sshc->ssh_session,\n                                                    conn->user,\n                                                    (unsigned int)\n                                                    strlen(conn->user),\n                                                    &kbd_callback);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized keyboard interactive authentication\\n\");\n      }\n      state(conn, SSH_AUTH_DONE);\n      break;\n\n    case SSH_AUTH_DONE:\n      if(!sshc->authed) {\n        failf(data, \"Authentication failure\");\n        state(conn, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_LOGIN_DENIED;\n        break;\n      }\n\n      /*\n       * At this point we have an authenticated ssh session.\n       */\n      infof(data, \"Authentication complete\\n\");\n\n      Curl_pgrsTime(conn->data, TIMER_APPCONNECT); /* SSH is connected */\n\n      conn->sockfd = sock;\n      conn->writesockfd = CURL_SOCKET_BAD;\n\n      if(conn->handler->protocol == CURLPROTO_SFTP) {\n        state(conn, SSH_SFTP_INIT);\n        break;\n      }\n      infof(data, \"SSH CONNECT phase done\\n\");\n      state(conn, SSH_STOP);\n      break;\n\n    case SSH_SFTP_INIT:\n      /*\n       * Start the libssh2 sftp session\n       */\n      sshc->sftp_session = libssh2_sftp_init(sshc->ssh_session);\n      if(!sshc->sftp_session) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          char *err_msg;\n\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          failf(data, \"Failure initializing sftp session: %s\", err_msg);\n          state(conn, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_FAILED_INIT;\n          break;\n        }\n      }\n      state(conn, SSH_SFTP_REALPATH);\n      break;\n\n    case SSH_SFTP_REALPATH:\n    {\n      char tempHome[PATH_MAX];\n\n      /*\n       * Get the \"home\" directory\n       */\n      rc = libssh2_sftp_realpath(sshc->sftp_session, \".\",\n                                 tempHome, PATH_MAX-1);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc > 0) {\n        /* It seems that this string is not always NULL terminated */\n        tempHome[rc] = '\\0';\n        sshc->homedir = strdup(tempHome);\n        if(!sshc->homedir) {\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->actualcode = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n        conn->data->state.most_recent_ftp_entrypath = sshc->homedir;\n      }\n      else {\n        /* Return the error type */\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        result = sftp_libssh2_error_to_CURLE(err);\n        sshc->actualcode = result?result:CURLE_SSH;\n        DEBUGF(infof(data, \"error = %d makes libcurl = %d\\n\",\n                     err, (int)result));\n        state(conn, SSH_STOP);\n        break;\n      }\n    }\n    /* This is the last step in the SFTP connect phase. Do note that while\n       we get the homedir here, we get the \"workingpath\" in the DO action\n       since the homedir will remain the same between request but the\n       working path will not. */\n    DEBUGF(infof(data, \"SSH CONNECT phase done\\n\"));\n    state(conn, SSH_STOP);\n    break;\n\n    case SSH_SFTP_QUOTE_INIT:\n\n      result = ssh_getworkingpath(conn, sshc->homedir, &sftp_scp->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(conn, SSH_STOP);\n        break;\n      }\n\n      if(data->set.quote) {\n        infof(data, \"Sending quote commands\\n\");\n        sshc->quote_item = data->set.quote;\n        state(conn, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(conn, SSH_SFTP_TRANS_INIT);\n      }\n      break;\n\n    case SSH_SFTP_POSTQUOTE_INIT:\n      if(data->set.postquote) {\n        infof(data, \"Sending quote commands\\n\");\n        sshc->quote_item = data->set.postquote;\n        state(conn, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(conn, SSH_STOP);\n      }\n      break;\n\n    case SSH_SFTP_QUOTE:\n      /* Send any quote commands */\n    {\n      const char *cp;\n\n      /*\n       * Support some of the \"FTP\" commands\n       */\n      if(curl_strequal(\"pwd\", sshc->quote_item->data)) {\n        /* output debug output if that is requested */\n        char *tmp = aprintf(\"257 \\\"%s\\\" is current directory.\\n\",\n                            sftp_scp->path);\n        if(!tmp) {\n          result = CURLE_OUT_OF_MEMORY;\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          break;\n        }\n        if(data->set.verbose) {\n          Curl_debug(data, CURLINFO_HEADER_OUT, (char *)\"PWD\\n\", 4, conn);\n          Curl_debug(data, CURLINFO_HEADER_IN, tmp, strlen(tmp), conn);\n        }\n        /* this sends an FTP-like \"header\" to the header callback so that the\n           current directory can be read very similar to how it is read when\n           using ordinary FTP. */\n        result = Curl_client_write(conn, CLIENTWRITE_HEADER, tmp, strlen(tmp));\n        free(tmp);\n        state(conn, SSH_SFTP_NEXT_QUOTE);\n        break;\n      }\n      else if(sshc->quote_item->data) {\n        /*\n         * the arguments following the command must be separated from the\n         * command with a space so we can check for it unconditionally\n         */\n        cp = strchr(sshc->quote_item->data, ' ');\n        if(cp == NULL) {\n          failf(data, \"Syntax error in SFTP command. Supply parameter(s)!\");\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n\n        /*\n         * also, every command takes at least one argument so we get that\n         * first argument right now\n         */\n        result = get_pathname(&cp, &sshc->quote_path1);\n        if(result) {\n          if(result == CURLE_OUT_OF_MEMORY)\n            failf(data, \"Out of memory\");\n          else\n            failf(data, \"Syntax error: Bad first parameter\");\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n          break;\n        }\n\n        /*\n         * SFTP is a binary protocol, so we don't send text commands to\n         * the server. Instead, we scan for commands for commands used by\n         * OpenSSH's sftp program and call the appropriate libssh2\n         * functions.\n         */\n        if(curl_strnequal(sshc->quote_item->data, \"chgrp \", 6) ||\n           curl_strnequal(sshc->quote_item->data, \"chmod \", 6) ||\n           curl_strnequal(sshc->quote_item->data, \"chown \", 6) ) {\n          /* attribute change */\n\n          /* sshc->quote_path1 contains the mode to set */\n          /* get the destination */\n          result = get_pathname(&cp, &sshc->quote_path2);\n          if(result) {\n            if(result == CURLE_OUT_OF_MEMORY)\n              failf(data, \"Out of memory\");\n            else\n              failf(data, \"Syntax error in chgrp/chmod/chown: \"\n                    \"Bad second parameter\");\n            Curl_safefree(sshc->quote_path1);\n            sshc->quote_path1 = NULL;\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->nextstate = SSH_NO_STATE;\n            sshc->actualcode = result;\n            break;\n          }\n          memset(&sshc->quote_attrs, 0, sizeof(LIBSSH2_SFTP_ATTRIBUTES));\n          state(conn, SSH_SFTP_QUOTE_STAT);\n          break;\n        }\n        else if(curl_strnequal(sshc->quote_item->data, \"ln \", 3) ||\n                curl_strnequal(sshc->quote_item->data, \"symlink \", 8)) {\n          /* symbolic linking */\n          /* sshc->quote_path1 is the source */\n          /* get the destination */\n          result = get_pathname(&cp, &sshc->quote_path2);\n          if(result) {\n            if(result == CURLE_OUT_OF_MEMORY)\n              failf(data, \"Out of memory\");\n            else\n              failf(data,\n                    \"Syntax error in ln/symlink: Bad second parameter\");\n            Curl_safefree(sshc->quote_path1);\n            sshc->quote_path1 = NULL;\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->nextstate = SSH_NO_STATE;\n            sshc->actualcode = result;\n            break;\n          }\n          state(conn, SSH_SFTP_QUOTE_SYMLINK);\n          break;\n        }\n        else if(curl_strnequal(sshc->quote_item->data, \"mkdir \", 6)) {\n          /* create dir */\n          state(conn, SSH_SFTP_QUOTE_MKDIR);\n          break;\n        }\n        else if(curl_strnequal(sshc->quote_item->data, \"rename \", 7)) {\n          /* rename file */\n          /* first param is the source path */\n          /* second param is the dest. path */\n          result = get_pathname(&cp, &sshc->quote_path2);\n          if(result) {\n            if(result == CURLE_OUT_OF_MEMORY)\n              failf(data, \"Out of memory\");\n            else\n              failf(data, \"Syntax error in rename: Bad second parameter\");\n            Curl_safefree(sshc->quote_path1);\n            sshc->quote_path1 = NULL;\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->nextstate = SSH_NO_STATE;\n            sshc->actualcode = result;\n            break;\n          }\n          state(conn, SSH_SFTP_QUOTE_RENAME);\n          break;\n        }\n        else if(curl_strnequal(sshc->quote_item->data, \"rmdir \", 6)) {\n          /* delete dir */\n          state(conn, SSH_SFTP_QUOTE_RMDIR);\n          break;\n        }\n        else if(curl_strnequal(sshc->quote_item->data, \"rm \", 3)) {\n          state(conn, SSH_SFTP_QUOTE_UNLINK);\n          break;\n        }\n\n        failf(data, \"Unknown SFTP command\");\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        Curl_safefree(sshc->quote_path2);\n        sshc->quote_path2 = NULL;\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n    }\n    if(!sshc->quote_item) {\n      state(conn, SSH_SFTP_TRANS_INIT);\n    }\n    break;\n\n    case SSH_SFTP_NEXT_QUOTE:\n      if(sshc->quote_path1) {\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n      }\n      if(sshc->quote_path2) {\n        Curl_safefree(sshc->quote_path2);\n        sshc->quote_path2 = NULL;\n      }\n\n      sshc->quote_item = sshc->quote_item->next;\n\n      if(sshc->quote_item) {\n        state(conn, SSH_SFTP_QUOTE);\n      }\n      else {\n        if(sshc->nextstate != SSH_NO_STATE) {\n          state(conn, sshc->nextstate);\n          sshc->nextstate = SSH_NO_STATE;\n        }\n        else {\n          state(conn, SSH_SFTP_TRANS_INIT);\n        }\n      }\n      break;\n\n    case SSH_SFTP_QUOTE_STAT:\n      if(!curl_strnequal(sshc->quote_item->data, \"chmod\", 5)) {\n        /* Since chown and chgrp only set owner OR group but libssh2 wants to\n         * set them both at once, we need to obtain the current ownership\n         * first.  This takes an extra protocol round trip.\n         */\n        rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshc->quote_path2,\n                                  (unsigned int)strlen(sshc->quote_path2),\n                                  LIBSSH2_SFTP_STAT,\n                                  &sshc->quote_attrs);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc != 0) { /* get those attributes */\n          err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n          Curl_safefree(sshc->quote_path1);\n          sshc->quote_path1 = NULL;\n          Curl_safefree(sshc->quote_path2);\n          sshc->quote_path2 = NULL;\n          failf(data, \"Attempt to get SFTP stats failed: %s\",\n                sftp_libssh2_strerror(err));\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n\n      /* Now set the new attributes... */\n      if(curl_strnequal(sshc->quote_item->data, \"chgrp\", 5)) {\n        sshc->quote_attrs.gid = strtoul(sshc->quote_path1, NULL, 10);\n        sshc->quote_attrs.flags = LIBSSH2_SFTP_ATTR_UIDGID;\n        if(sshc->quote_attrs.gid == 0 && !ISDIGIT(sshc->quote_path1[0])) {\n          Curl_safefree(sshc->quote_path1);\n          sshc->quote_path1 = NULL;\n          Curl_safefree(sshc->quote_path2);\n          sshc->quote_path2 = NULL;\n          failf(data, \"Syntax error: chgrp gid not a number\");\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n      else if(curl_strnequal(sshc->quote_item->data, \"chmod\", 5)) {\n        sshc->quote_attrs.permissions = strtoul(sshc->quote_path1, NULL, 8);\n        sshc->quote_attrs.flags = LIBSSH2_SFTP_ATTR_PERMISSIONS;\n        /* permissions are octal */\n        if(sshc->quote_attrs.permissions == 0 &&\n           !ISDIGIT(sshc->quote_path1[0])) {\n          Curl_safefree(sshc->quote_path1);\n          sshc->quote_path1 = NULL;\n          Curl_safefree(sshc->quote_path2);\n          sshc->quote_path2 = NULL;\n          failf(data, \"Syntax error: chmod permissions not a number\");\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n      else if(curl_strnequal(sshc->quote_item->data, \"chown\", 5)) {\n        sshc->quote_attrs.uid = strtoul(sshc->quote_path1, NULL, 10);\n        sshc->quote_attrs.flags = LIBSSH2_SFTP_ATTR_UIDGID;\n        if(sshc->quote_attrs.uid == 0 && !ISDIGIT(sshc->quote_path1[0])) {\n          Curl_safefree(sshc->quote_path1);\n          sshc->quote_path1 = NULL;\n          Curl_safefree(sshc->quote_path2);\n          sshc->quote_path2 = NULL;\n          failf(data, \"Syntax error: chown uid not a number\");\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n\n      /* Now send the completed structure... */\n      state(conn, SSH_SFTP_QUOTE_SETSTAT);\n      break;\n\n    case SSH_SFTP_QUOTE_SETSTAT:\n      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshc->quote_path2,\n                                (unsigned int)strlen(sshc->quote_path2),\n                                LIBSSH2_SFTP_SETSTAT,\n                                &sshc->quote_attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        Curl_safefree(sshc->quote_path2);\n        sshc->quote_path2 = NULL;\n        failf(data, \"Attempt to set SFTP stats failed: %s\",\n              sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_SYMLINK:\n      rc = libssh2_sftp_symlink_ex(sshc->sftp_session, sshc->quote_path1,\n                                   (unsigned int)strlen(sshc->quote_path1),\n                                   sshc->quote_path2,\n                                   (unsigned int)strlen(sshc->quote_path2),\n                                   LIBSSH2_SFTP_SYMLINK);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        Curl_safefree(sshc->quote_path2);\n        sshc->quote_path2 = NULL;\n        failf(data, \"symlink command failed: %s\",\n              sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_MKDIR:\n      rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshc->quote_path1,\n                                 (unsigned int)strlen(sshc->quote_path1),\n                                 0755);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        failf(data, \"mkdir command failed: %s\", sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RENAME:\n      rc = libssh2_sftp_rename_ex(sshc->sftp_session, sshc->quote_path1,\n                                  (unsigned int)strlen(sshc->quote_path1),\n                                  sshc->quote_path2,\n                                  (unsigned int)strlen(sshc->quote_path2),\n                                  LIBSSH2_SFTP_RENAME_OVERWRITE |\n                                  LIBSSH2_SFTP_RENAME_ATOMIC |\n                                  LIBSSH2_SFTP_RENAME_NATIVE);\n\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        Curl_safefree(sshc->quote_path2);\n        sshc->quote_path2 = NULL;\n        failf(data, \"rename command failed: %s\", sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RMDIR:\n      rc = libssh2_sftp_rmdir_ex(sshc->sftp_session, sshc->quote_path1,\n                                 (unsigned int)strlen(sshc->quote_path1));\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        failf(data, \"rmdir command failed: %s\", sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_UNLINK:\n      rc = libssh2_sftp_unlink_ex(sshc->sftp_session, sshc->quote_path1,\n                                  (unsigned int)strlen(sshc->quote_path1));\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc != 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        Curl_safefree(sshc->quote_path1);\n        sshc->quote_path1 = NULL;\n        failf(data, \"rm command failed: %s\", sftp_libssh2_strerror(err));\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(conn, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_TRANS_INIT:\n      if(data->set.upload)\n        state(conn, SSH_SFTP_UPLOAD_INIT);\n      else {\n        if(data->set.opt_no_body)\n          state(conn, SSH_STOP);\n        else if(sftp_scp->path[strlen(sftp_scp->path)-1] == '/')\n          state(conn, SSH_SFTP_READDIR_INIT);\n        else\n          state(conn, SSH_SFTP_DOWNLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_UPLOAD_INIT:\n    {\n      unsigned long flags;\n      /*\n       * NOTE!!!  libssh2 requires that the destination path is a full path\n       *          that includes the destination file and name OR ends in a \"/\"\n       *          If this is not done the destination file will be named the\n       *          same name as the last directory in the path.\n       */\n\n      if(data->state.resume_from != 0) {\n        LIBSSH2_SFTP_ATTRIBUTES attrs;\n        if(data->state.resume_from < 0) {\n          rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,\n                                    (unsigned int)strlen(sftp_scp->path),\n                                    LIBSSH2_SFTP_STAT, &attrs);\n          if(rc == LIBSSH2_ERROR_EAGAIN) {\n            break;\n          }\n          else if(rc) {\n            data->state.resume_from = 0;\n          }\n          else {\n            curl_off_t size = attrs.filesize;\n            if(size < 0) {\n              failf(data, \"Bad file size (%\" FORMAT_OFF_T \")\", size);\n              return CURLE_BAD_DOWNLOAD_RESUME;\n            }\n            data->state.resume_from = attrs.filesize;\n          }\n        }\n      }\n\n      if(data->set.ftp_append)\n        /* Try to open for append, but create if nonexisting */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_APPEND;\n      else if (data->state.resume_from > 0)\n        /* If we have restart position then open for append */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_APPEND;\n      else\n        /* Clear file before writing (normal behaviour) */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_TRUNC;\n\n      sshc->sftp_handle =\n        libssh2_sftp_open_ex(sshc->sftp_session, sftp_scp->path,\n                             (unsigned int)strlen(sftp_scp->path),\n                             flags, data->set.new_file_perms,\n                             LIBSSH2_SFTP_OPENFILE);\n\n      if(!sshc->sftp_handle) {\n        rc = libssh2_session_last_errno(sshc->ssh_session);\n\n        if(LIBSSH2_ERROR_EAGAIN == rc)\n          break;\n        else {\n          if(LIBSSH2_ERROR_SFTP_PROTOCOL == rc)\n            /* only when there was an SFTP protocol error can we extract\n               the sftp error! */\n            err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n          else\n            err = -1; /* not an sftp error at all */\n\n          if(sshc->secondCreateDirs) {\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->actualcode = err>= LIBSSH2_FX_OK?\n              sftp_libssh2_error_to_CURLE(err):CURLE_SSH;\n            failf(data, \"Creating the dir/file failed: %s\",\n                  sftp_libssh2_strerror(err));\n            break;\n          }\n          else if(((err == LIBSSH2_FX_NO_SUCH_FILE) ||\n                   (err == LIBSSH2_FX_FAILURE) ||\n                   (err == LIBSSH2_FX_NO_SUCH_PATH)) &&\n                  (data->set.ftp_create_missing_dirs &&\n                   (strlen(sftp_scp->path) > 1))) {\n            /* try to create the path remotely */\n            sshc->secondCreateDirs = 1;\n            state(conn, SSH_SFTP_CREATE_DIRS_INIT);\n            break;\n          }\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->actualcode = err>= LIBSSH2_FX_OK?\n            sftp_libssh2_error_to_CURLE(err):CURLE_SSH;\n          if(!sshc->actualcode) {\n            /* Sometimes, for some reason libssh2_sftp_last_error() returns\n               zero even though libssh2_sftp_open() failed previously! We need\n               to work around that! */\n            sshc->actualcode = CURLE_SSH;\n            err=-1;\n          }\n          failf(data, \"Upload failed: %s (%d/%d)\",\n                err>= LIBSSH2_FX_OK?sftp_libssh2_strerror(err):\"ssh error\",\n                err, rc);\n          break;\n        }\n      }\n\n      /* If we have restart point then we need to seek to the correct\n         position. */\n      if(data->state.resume_from > 0) {\n        /* Let's read off the proper amount of bytes from the input. */\n        if(conn->seek_func) {\n          seekerr = conn->seek_func(conn->seek_client, data->state.resume_from,\n                                    SEEK_SET);\n        }\n\n        if(seekerr != CURL_SEEKFUNC_OK){\n\n          if(seekerr != CURL_SEEKFUNC_CANTSEEK) {\n            failf(data, \"Could not seek stream\");\n            return CURLE_FTP_COULDNT_USE_REST;\n          }\n          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */\n          else {\n            curl_off_t passed=0;\n            do {\n              size_t readthisamountnow =\n                (data->state.resume_from - passed > CURL_OFF_T_C(BUFSIZE)) ?\n                BUFSIZE : curlx_sotouz(data->state.resume_from - passed);\n\n              size_t actuallyread =\n                conn->fread_func(data->state.buffer, 1, readthisamountnow,\n                                 conn->fread_in);\n\n              passed += actuallyread;\n              if((actuallyread == 0) || (actuallyread > readthisamountnow)) {\n                /* this checks for greater-than only to make sure that the\n                   CURL_READFUNC_ABORT return code still aborts */\n                failf(data, \"Failed to read data\");\n                return CURLE_FTP_COULDNT_USE_REST;\n              }\n            } while(passed < data->state.resume_from);\n          }\n        }\n\n        /* now, decrease the size of the read */\n        if(data->set.infilesize > 0) {\n          data->set.infilesize -= data->state.resume_from;\n          data->req.size = data->set.infilesize;\n          Curl_pgrsSetUploadSize(data, data->set.infilesize);\n        }\n\n        SFTP_SEEK(sshc->sftp_handle, data->state.resume_from);\n      }\n      if(data->set.infilesize > 0) {\n        data->req.size = data->set.infilesize;\n        Curl_pgrsSetUploadSize(data, data->set.infilesize);\n      }\n      /* upload data */\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, FIRSTSOCKET, NULL);\n\n      /* not set by Curl_setup_transfer to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      if(result) {\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->actualcode = result;\n      }\n      else {\n        /* store this original bitmask setup to use later on if we can't\n           figure out a \"real\" bitmask */\n        sshc->orig_waitfor = data->req.keepon;\n\n        /* we want to use the _sending_ function even when the socket turns\n           out readable as the underlying libssh2 sftp send function will deal\n           with both accordingly */\n        conn->cselect_bits = CURL_CSELECT_OUT;\n\n        /* since we don't really wait for anything at this point, we want the\n           state machine to move on as soon as possible so we set a very short\n           timeout here */\n        Curl_expire(data, 1);\n\n        state(conn, SSH_STOP);\n      }\n      break;\n    }\n\n    case SSH_SFTP_CREATE_DIRS_INIT:\n      if(strlen(sftp_scp->path) > 1) {\n        sshc->slash_pos = sftp_scp->path + 1; /* ignore the leading '/' */\n        state(conn, SSH_SFTP_CREATE_DIRS);\n      }\n      else {\n        state(conn, SSH_SFTP_UPLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_CREATE_DIRS:\n      if((sshc->slash_pos = strchr(sshc->slash_pos, '/')) != NULL) {\n        *sshc->slash_pos = 0;\n\n        infof(data, \"Creating directory '%s'\\n\", sftp_scp->path);\n        state(conn, SSH_SFTP_CREATE_DIRS_MKDIR);\n        break;\n      }\n      else {\n        state(conn, SSH_SFTP_UPLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_CREATE_DIRS_MKDIR:\n      /* 'mode' - parameter is preliminary - default to 0644 */\n      rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sftp_scp->path,\n                                 (unsigned int)strlen(sftp_scp->path),\n                                 data->set.new_directory_perms);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      *sshc->slash_pos = '/';\n      ++sshc->slash_pos;\n      if(rc == -1) {\n        unsigned int sftp_err = 0;\n        /*\n         * Abort if failure wasn't that the dir already exists or the\n         * permission was denied (creation might succeed further down the\n         * path) - retry on unspecific FAILURE also\n         */\n        sftp_err = (unsigned int)(libssh2_sftp_last_error(sshc->sftp_session));\n        if((sftp_err != LIBSSH2_FX_FILE_ALREADY_EXISTS) &&\n           (sftp_err != LIBSSH2_FX_FAILURE) &&\n           (sftp_err != LIBSSH2_FX_PERMISSION_DENIED)) {\n          result = sftp_libssh2_error_to_CURLE(sftp_err);\n          state(conn, SSH_SFTP_CLOSE);\n          sshc->actualcode = result?result:CURLE_SSH;\n          break;\n        }\n      }\n      state(conn, SSH_SFTP_CREATE_DIRS);\n      break;\n\n    case SSH_SFTP_READDIR_INIT:\n      /*\n       * This is a directory that we are trying to get, so produce a directory\n       * listing\n       */\n      sshc->sftp_handle = libssh2_sftp_open_ex(sshc->sftp_session,\n                                               sftp_scp->path,\n                                               (unsigned int)\n                                               strlen(sftp_scp->path),\n                                               0, 0, LIBSSH2_SFTP_OPENDIR);\n      if(!sshc->sftp_handle) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n          failf(data, \"Could not open directory for reading: %s\",\n                sftp_libssh2_strerror(err));\n          state(conn, SSH_SFTP_CLOSE);\n          result = sftp_libssh2_error_to_CURLE(err);\n          sshc->actualcode = result?result:CURLE_SSH;\n          break;\n        }\n      }\n      if((sshc->readdir_filename = malloc(PATH_MAX+1)) == NULL) {\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n      if((sshc->readdir_longentry = malloc(PATH_MAX+1)) == NULL) {\n        Curl_safefree(sshc->readdir_filename);\n        sshc->readdir_filename = NULL;\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n      state(conn, SSH_SFTP_READDIR);\n      break;\n\n    case SSH_SFTP_READDIR:\n      sshc->readdir_len = libssh2_sftp_readdir_ex(sshc->sftp_handle,\n                                                  sshc->readdir_filename,\n                                                  PATH_MAX,\n                                                  sshc->readdir_longentry,\n                                                  PATH_MAX,\n                                                  &sshc->readdir_attrs);\n      if(sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {\n        rc = LIBSSH2_ERROR_EAGAIN;\n        break;\n      }\n      if(sshc->readdir_len > 0) {\n        sshc->readdir_filename[sshc->readdir_len] = '\\0';\n\n        if(data->set.ftp_list_only) {\n          char *tmpLine;\n\n          tmpLine = aprintf(\"%s\\n\", sshc->readdir_filename);\n          if(tmpLine == NULL) {\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->actualcode = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n          result = Curl_client_write(conn, CLIENTWRITE_BODY,\n                                     tmpLine, sshc->readdir_len+1);\n          Curl_safefree(tmpLine);\n\n          if(result) {\n            state(conn, SSH_STOP);\n            break;\n          }\n          /* since this counts what we send to the client, we include the\n             newline in this counter */\n          data->req.bytecount += sshc->readdir_len+1;\n\n          /* output debug output if that is requested */\n          if(data->set.verbose) {\n            Curl_debug(data, CURLINFO_DATA_OUT, sshc->readdir_filename,\n                       sshc->readdir_len, conn);\n          }\n        }\n        else {\n          sshc->readdir_currLen = (int)strlen(sshc->readdir_longentry);\n          sshc->readdir_totalLen = 80 + sshc->readdir_currLen;\n          sshc->readdir_line = calloc(sshc->readdir_totalLen, 1);\n          if(!sshc->readdir_line) {\n            Curl_safefree(sshc->readdir_filename);\n            sshc->readdir_filename = NULL;\n            Curl_safefree(sshc->readdir_longentry);\n            sshc->readdir_longentry = NULL;\n            state(conn, SSH_SFTP_CLOSE);\n            sshc->actualcode = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n\n          memcpy(sshc->readdir_line, sshc->readdir_longentry,\n                 sshc->readdir_currLen);\n          if((sshc->readdir_attrs.flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) &&\n             ((sshc->readdir_attrs.permissions & LIBSSH2_SFTP_S_IFMT) ==\n              LIBSSH2_SFTP_S_IFLNK)) {\n            sshc->readdir_linkPath = malloc(PATH_MAX + 1);\n            if(sshc->readdir_linkPath == NULL) {\n              Curl_safefree(sshc->readdir_filename);\n              sshc->readdir_filename = NULL;\n              Curl_safefree(sshc->readdir_longentry);\n              sshc->readdir_longentry = NULL;\n              state(conn, SSH_SFTP_CLOSE);\n              sshc->actualcode = CURLE_OUT_OF_MEMORY;\n              break;\n            }\n\n            snprintf(sshc->readdir_linkPath, PATH_MAX, \"%s%s\", sftp_scp->path,\n                     sshc->readdir_filename);\n            state(conn, SSH_SFTP_READDIR_LINK);\n            break;\n          }\n          state(conn, SSH_SFTP_READDIR_BOTTOM);\n          break;\n        }\n      }\n      else if(sshc->readdir_len == 0) {\n        Curl_safefree(sshc->readdir_filename);\n        sshc->readdir_filename = NULL;\n        Curl_safefree(sshc->readdir_longentry);\n        sshc->readdir_longentry = NULL;\n        state(conn, SSH_SFTP_READDIR_DONE);\n        break;\n      }\n      else if(sshc->readdir_len <= 0) {\n        err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n        result = sftp_libssh2_error_to_CURLE(err);\n        sshc->actualcode = result?result:CURLE_SSH;\n        failf(data, \"Could not open remote file for reading: %s :: %d\",\n              sftp_libssh2_strerror(err),\n              libssh2_session_last_errno(sshc->ssh_session));\n        Curl_safefree(sshc->readdir_filename);\n        sshc->readdir_filename = NULL;\n        Curl_safefree(sshc->readdir_longentry);\n        sshc->readdir_longentry = NULL;\n        state(conn, SSH_SFTP_CLOSE);\n        break;\n      }\n      break;\n\n    case SSH_SFTP_READDIR_LINK:\n      sshc->readdir_len =\n        libssh2_sftp_symlink_ex(sshc->sftp_session,\n                                sshc->readdir_linkPath,\n                                (unsigned int) strlen(sshc->readdir_linkPath),\n                                sshc->readdir_filename,\n                                PATH_MAX, LIBSSH2_SFTP_READLINK);\n      if(sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {\n        rc = LIBSSH2_ERROR_EAGAIN;\n        break;\n      }\n      Curl_safefree(sshc->readdir_linkPath);\n      sshc->readdir_linkPath = NULL;\n      sshc->readdir_line = realloc(sshc->readdir_line,\n                                   sshc->readdir_totalLen + 4 +\n                                   sshc->readdir_len);\n      if(!sshc->readdir_line) {\n        Curl_safefree(sshc->readdir_filename);\n        sshc->readdir_filename = NULL;\n        Curl_safefree(sshc->readdir_longentry);\n        sshc->readdir_longentry = NULL;\n        state(conn, SSH_SFTP_CLOSE);\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n\n      sshc->readdir_currLen += snprintf(sshc->readdir_line +\n                                        sshc->readdir_currLen,\n                                        sshc->readdir_totalLen -\n                                        sshc->readdir_currLen,\n                                        \" -> %s\",\n                                        sshc->readdir_filename);\n\n      state(conn, SSH_SFTP_READDIR_BOTTOM);\n      break;\n\n    case SSH_SFTP_READDIR_BOTTOM:\n      sshc->readdir_currLen += snprintf(sshc->readdir_line +\n                                        sshc->readdir_currLen,\n                                        sshc->readdir_totalLen -\n                                        sshc->readdir_currLen, \"\\n\");\n      result = Curl_client_write(conn, CLIENTWRITE_BODY,\n                                 sshc->readdir_line,\n                                 sshc->readdir_currLen);\n\n      if(result == CURLE_OK) {\n\n        /* output debug output if that is requested */\n        if(data->set.verbose) {\n          Curl_debug(data, CURLINFO_DATA_OUT, sshc->readdir_line,\n                     sshc->readdir_currLen, conn);\n        }\n        data->req.bytecount += sshc->readdir_currLen;\n      }\n      Curl_safefree(sshc->readdir_line);\n      sshc->readdir_line = NULL;\n      if(result) {\n        state(conn, SSH_STOP);\n      }\n      else\n        state(conn, SSH_SFTP_READDIR);\n      break;\n\n    case SSH_SFTP_READDIR_DONE:\n      if(libssh2_sftp_closedir(sshc->sftp_handle) ==\n         LIBSSH2_ERROR_EAGAIN) {\n        rc = LIBSSH2_ERROR_EAGAIN;\n        break;\n      }\n      sshc->sftp_handle = NULL;\n      Curl_safefree(sshc->readdir_filename);\n      sshc->readdir_filename = NULL;\n      Curl_safefree(sshc->readdir_longentry);\n      sshc->readdir_longentry = NULL;\n\n      /* no data to transfer */\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n      state(conn, SSH_STOP);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_INIT:\n      /*\n       * Work on getting the specified file\n       */\n      sshc->sftp_handle =\n        libssh2_sftp_open_ex(sshc->sftp_session, sftp_scp->path,\n                             (unsigned int)strlen(sftp_scp->path),\n                             LIBSSH2_FXF_READ, data->set.new_file_perms,\n                             LIBSSH2_SFTP_OPENFILE);\n      if(!sshc->sftp_handle) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          err = (int)(libssh2_sftp_last_error(sshc->sftp_session));\n          failf(data, \"Could not open remote file for reading: %s\",\n                sftp_libssh2_strerror(err));\n          state(conn, SSH_SFTP_CLOSE);\n          result = sftp_libssh2_error_to_CURLE(err);\n          sshc->actualcode = result?result:CURLE_SSH;\n          break;\n        }\n      }\n      state(conn, SSH_SFTP_DOWNLOAD_STAT);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_STAT:\n    {\n      LIBSSH2_SFTP_ATTRIBUTES attrs;\n\n      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sftp_scp->path,\n                                (unsigned int)strlen(sftp_scp->path),\n                                LIBSSH2_SFTP_STAT, &attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      else if(rc) {\n        /*\n         * libssh2_sftp_open() didn't return an error, so maybe the server\n         * just doesn't support stat()\n         */\n        data->req.size = -1;\n        data->req.maxdownload = -1;\n      }\n      else {\n        curl_off_t size = attrs.filesize;\n\n        if(size < 0) {\n          failf(data, \"Bad file size (%\" FORMAT_OFF_T \")\", size);\n          return CURLE_BAD_DOWNLOAD_RESUME;\n        }\n        if(conn->data->state.use_range) {\n          curl_off_t from, to;\n          char *ptr;\n          char *ptr2;\n\n          from=curlx_strtoofft(conn->data->state.range, &ptr, 0);\n          while(*ptr && (ISSPACE(*ptr) || (*ptr=='-')))\n            ptr++;\n          to=curlx_strtoofft(ptr, &ptr2, 0);\n          if((ptr == ptr2) /* no \"to\" value given */\n             || (to >= size)) {\n            to = size - 1;\n          }\n          if(from < 0) {\n            /* from is relative to end of file */\n            from += size;\n          }\n          if(from >= size) {\n            failf(data, \"Offset (%\"\n                  FORMAT_OFF_T \") was beyond file size (%\" FORMAT_OFF_T \")\",\n                  from, attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          if(from > to) {\n            from = to;\n            size = 0;\n          }\n          else {\n            size = to - from + 1;\n          }\n\n          SFTP_SEEK(conn->proto.sshc.sftp_handle, from);\n        }\n        data->req.size = size;\n        data->req.maxdownload = size;\n        Curl_pgrsSetDownloadSize(data, size);\n      }\n\n      /* We can resume if we can seek to the resume position */\n      if(data->state.resume_from) {\n        if(data->state.resume_from < 0) {\n          /* We're supposed to download the last abs(from) bytes */\n          if((curl_off_t)attrs.filesize < -data->state.resume_from) {\n            failf(data, \"Offset (%\"\n                  FORMAT_OFF_T \") was beyond file size (%\" FORMAT_OFF_T \")\",\n                  data->state.resume_from, attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          /* download from where? */\n          data->state.resume_from += attrs.filesize;\n        }\n        else {\n          if((curl_off_t)attrs.filesize < data->state.resume_from) {\n            failf(data, \"Offset (%\" FORMAT_OFF_T\n                  \") was beyond file size (%\" FORMAT_OFF_T \")\",\n                  data->state.resume_from, attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n        }\n        /* Does a completed file need to be seeked and started or closed ? */\n        /* Now store the number of bytes we are expected to download */\n        data->req.size = attrs.filesize - data->state.resume_from;\n        data->req.maxdownload = attrs.filesize - data->state.resume_from;\n        Curl_pgrsSetDownloadSize(data,\n                                 attrs.filesize - data->state.resume_from);\n        SFTP_SEEK(sshc->sftp_handle, data->state.resume_from);\n      }\n    }\n    /* Setup the actual download */\n    if(data->req.size == 0) {\n      /* no data to transfer */\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n      infof(data, \"File already completely downloaded\\n\");\n      state(conn, SSH_STOP);\n      break;\n    }\n    else {\n      Curl_setup_transfer(conn, FIRSTSOCKET, data->req.size,\n                          FALSE, NULL, -1, NULL);\n\n      /* not set by Curl_setup_transfer to preserve keepon bits */\n      conn->writesockfd = conn->sockfd;\n\n      /* we want to use the _receiving_ function even when the socket turns\n         out writableable as the underlying libssh2 recv function will deal\n         with both accordingly */\n      conn->cselect_bits = CURL_CSELECT_IN;\n    }\n    if(result) {\n      state(conn, SSH_SFTP_CLOSE);\n      sshc->actualcode = result;\n    }\n    else {\n      state(conn, SSH_STOP);\n    }\n    break;\n\n    case SSH_SFTP_CLOSE:\n      if(sshc->sftp_handle) {\n        rc = libssh2_sftp_close(sshc->sftp_handle);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to close libssh2 file\\n\");\n        }\n        sshc->sftp_handle = NULL;\n      }\n      if(sftp_scp) {\n        Curl_safefree(sftp_scp->path);\n        sftp_scp->path = NULL;\n      }\n\n      DEBUGF(infof(data, \"SFTP DONE done\\n\"));\n\n      /* Check if nextstate is set and move .nextstate could be POSTQUOTE_INIT\n         After nextstate is executed,the control should come back to\n         SSH_SFTP_CLOSE to pass the correct result back  */\n      if(sshc->nextstate != SSH_NO_STATE) {\n        state(conn, sshc->nextstate);\n        sshc->nextstate = SSH_SFTP_CLOSE;\n      }\n      else {\n        state(conn, SSH_STOP);\n        result = sshc->actualcode;\n      }\n      break;\n\n    case SSH_SFTP_SHUTDOWN:\n      /* during times we get here due to a broken transfer and then the\n         sftp_handle might not have been taken down so make sure that is done\n         before we proceed */\n\n      if(sshc->sftp_handle) {\n        rc = libssh2_sftp_close(sshc->sftp_handle);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to close libssh2 file\\n\");\n        }\n        sshc->sftp_handle = NULL;\n      }\n      if(sshc->sftp_session) {\n        rc = libssh2_sftp_shutdown(sshc->sftp_session);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to stop libssh2 sftp subsystem\\n\");\n        }\n        sshc->sftp_session = NULL;\n      }\n\n      Curl_safefree(sshc->homedir);\n      sshc->homedir = NULL;\n      conn->data->state.most_recent_ftp_entrypath = NULL;\n\n      state(conn, SSH_SESSION_DISCONNECT);\n      break;\n\n    case SSH_SCP_TRANS_INIT:\n      result = ssh_getworkingpath(conn, sshc->homedir, &sftp_scp->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(conn, SSH_STOP);\n        break;\n      }\n\n      if(data->set.upload) {\n        if(data->set.infilesize < 0) {\n          failf(data, \"SCP requires a known file size for upload\");\n          sshc->actualcode = CURLE_UPLOAD_FAILED;\n          state(conn, SSH_SCP_CHANNEL_FREE);\n          break;\n        }\n        state(conn, SSH_SCP_UPLOAD_INIT);\n      }\n      else {\n        state(conn, SSH_SCP_DOWNLOAD_INIT);\n      }\n      break;\n\n    case SSH_SCP_UPLOAD_INIT:\n      /*\n       * libssh2 requires that the destination path is a full path that\n       * includes the destination file and name OR ends in a \"/\" .  If this is\n       * not done the destination file will be named the same name as the last\n       * directory in the path.\n       */\n      sshc->ssh_channel =\n        SCP_SEND(sshc->ssh_session, sftp_scp->path, data->set.new_file_perms,\n                 data->set.infilesize);\n      if(!sshc->ssh_channel) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          int ssh_err;\n          char *err_msg;\n\n          ssh_err = (int)(libssh2_session_last_error(sshc->ssh_session,\n                                                     &err_msg, NULL, 0));\n          failf(conn->data, \"%s\", err_msg);\n          state(conn, SSH_SCP_CHANNEL_FREE);\n          sshc->actualcode = libssh2_session_error_to_CURLE(ssh_err);\n          break;\n        }\n      }\n\n      /* upload data */\n      Curl_setup_transfer(conn, -1, data->req.size, FALSE, NULL,\n                          FIRSTSOCKET, NULL);\n\n      /* not set by Curl_setup_transfer to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      if(result) {\n        state(conn, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = result;\n      }\n      else {\n        /* we want to use the _sending_ function even when the socket turns\n           out readable as the underlying libssh2 scp send function will deal\n           with both accordingly */\n        conn->cselect_bits = CURL_CSELECT_OUT;\n\n        state(conn, SSH_STOP);\n      }\n      break;\n\n    case SSH_SCP_DOWNLOAD_INIT:\n    {\n      /*\n       * We must check the remote file; if it is a directory no values will\n       * be set in sb\n       */\n      struct stat sb;\n      curl_off_t bytecount;\n\n      /* clear the struct scp recv will fill in */\n      memset(&sb, 0, sizeof(struct stat));\n\n      /* get a fresh new channel from the ssh layer */\n      sshc->ssh_channel = libssh2_scp_recv(sshc->ssh_session,\n                                           sftp_scp->path, &sb);\n      if(!sshc->ssh_channel) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        else {\n          int ssh_err;\n          char *err_msg;\n\n          ssh_err = (int)(libssh2_session_last_error(sshc->ssh_session,\n                                                     &err_msg, NULL, 0));\n          failf(conn->data, \"%s\", err_msg);\n          state(conn, SSH_SCP_CHANNEL_FREE);\n          sshc->actualcode = libssh2_session_error_to_CURLE(ssh_err);\n          break;\n        }\n      }\n\n      /* download data */\n      bytecount = (curl_off_t)sb.st_size;\n      data->req.maxdownload =  (curl_off_t)sb.st_size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, bytecount, FALSE, NULL, -1, NULL);\n\n      /* not set by Curl_setup_transfer to preserve keepon bits */\n      conn->writesockfd = conn->sockfd;\n\n      /* we want to use the _receiving_ function even when the socket turns\n         out writableable as the underlying libssh2 recv function will deal\n         with both accordingly */\n      conn->cselect_bits = CURL_CSELECT_IN;\n\n      if(result) {\n        state(conn, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = result;\n      }\n      else\n        state(conn, SSH_STOP);\n    }\n    break;\n\n    case SSH_SCP_DONE:\n      if(data->set.upload)\n        state(conn, SSH_SCP_SEND_EOF);\n      else\n        state(conn, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_SEND_EOF:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_send_eof(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc) {\n          infof(data, \"Failed to send libssh2 channel EOF\\n\");\n        }\n      }\n      state(conn, SSH_SCP_WAIT_EOF);\n      break;\n\n    case SSH_SCP_WAIT_EOF:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_wait_eof(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc) {\n          infof(data, \"Failed to get channel EOF: %d\\n\", rc);\n        }\n      }\n      state(conn, SSH_SCP_WAIT_CLOSE);\n      break;\n\n    case SSH_SCP_WAIT_CLOSE:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_wait_closed(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc) {\n          infof(data, \"Channel failed to close: %d\\n\", rc);\n        }\n      }\n      state(conn, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_CHANNEL_FREE:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_free(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to free libssh2 scp subsystem\\n\");\n        }\n        sshc->ssh_channel = NULL;\n      }\n      DEBUGF(infof(data, \"SCP DONE phase complete\\n\"));\n#if 0 /* PREV */\n      state(conn, SSH_SESSION_DISCONNECT);\n#endif\n      state(conn, SSH_STOP);\n      result = sshc->actualcode;\n      break;\n\n    case SSH_SESSION_DISCONNECT:\n      /* during weird times when we've been prematurely aborted, the channel\n         is still alive when we reach this state and we MUST kill the channel\n         properly first */\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_free(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to free libssh2 scp subsystem\\n\");\n        }\n        sshc->ssh_channel = NULL;\n      }\n\n      if(sshc->ssh_session) {\n        rc = libssh2_session_disconnect(sshc->ssh_session, \"Shutdown\");\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to disconnect libssh2 session\\n\");\n        }\n      }\n\n      Curl_safefree(sshc->homedir);\n      sshc->homedir = NULL;\n      conn->data->state.most_recent_ftp_entrypath = NULL;\n\n      state(conn, SSH_SESSION_FREE);\n      break;\n\n    case SSH_SESSION_FREE:\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n      if(sshc->kh) {\n        libssh2_knownhost_free(sshc->kh);\n        sshc->kh = NULL;\n      }\n#endif\n\n      if(sshc->ssh_session) {\n        rc = libssh2_session_free(sshc->ssh_session);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        else if(rc < 0) {\n          infof(data, \"Failed to free libssh2 session\\n\");\n        }\n        sshc->ssh_session = NULL;\n      }\n      conn->bits.close = TRUE;\n      sshc->nextstate = SSH_NO_STATE;\n      state(conn, SSH_STOP);\n      result = sshc->actualcode;\n      break;\n\n    case SSH_QUIT:\n      /* fallthrough, just stop! */\n    default:\n      /* internal error */\n      sshc->nextstate = SSH_NO_STATE;\n      state(conn, SSH_STOP);\n      break;\n    }\n\n  } while(!rc && (sshc->state != SSH_STOP));\n\n  if(rc == LIBSSH2_ERROR_EAGAIN) {\n    /* we would block, we need to wait for the socket to be ready (in the\n       right direction too)! */\n    *block = TRUE;\n  }\n\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* Create a new easy handle, and add it to the global curl_multi */\n", "func_signal": "static void new_conn(char *url, GlobalInfo *g )", "code": "{\n  ConnInfo *conn;\n  CURLMcode rc;\n\n  conn = g_malloc0(sizeof(ConnInfo));\n\n  conn->error[0]='\\0';\n\n  conn->easy = curl_easy_init();\n  if (!conn->easy) {\n    MSG_OUT(\"curl_easy_init() failed, exiting!\\n\");\n    exit(2);\n  }\n  conn->global = g;\n  conn->url = g_strdup(url);\n  curl_easy_setopt(conn->easy, CURLOPT_URL, conn->url);\n  curl_easy_setopt(conn->easy, CURLOPT_WRITEFUNCTION, write_cb);\n  curl_easy_setopt(conn->easy, CURLOPT_WRITEDATA, &conn);\n  curl_easy_setopt(conn->easy, CURLOPT_VERBOSE, (long)SHOW_VERBOSE);\n  curl_easy_setopt(conn->easy, CURLOPT_ERRORBUFFER, conn->error);\n  curl_easy_setopt(conn->easy, CURLOPT_PRIVATE, conn);\n  curl_easy_setopt(conn->easy, CURLOPT_NOPROGRESS, SHOW_PROGRESS?0L:1L);\n  curl_easy_setopt(conn->easy, CURLOPT_PROGRESSFUNCTION, prog_cb);\n  curl_easy_setopt(conn->easy, CURLOPT_PROGRESSDATA, conn);\n  curl_easy_setopt(conn->easy, CURLOPT_FOLLOWLOCATION, 1L);\n  curl_easy_setopt(conn->easy, CURLOPT_CONNECTTIMEOUT, 30L);\n  curl_easy_setopt(conn->easy, CURLOPT_LOW_SPEED_LIMIT, 1L);\n  curl_easy_setopt(conn->easy, CURLOPT_LOW_SPEED_TIME, 30L);\n\n  MSG_OUT(\"Adding easy %p to multi %p (%s)\\n\", conn->easy, g->multi, url);\n  rc =curl_multi_add_handle(g->multi, conn->easy);\n  mcode_or_die(\"new_conn: curl_multi_add_handle\", rc);\n\n  /* note that the add_handle() will set a time-out to trigger very soon so\n     that the necessary socket_action() call will be called by this app */\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* called from multi.c while DOing */\n", "func_signal": "static CURLcode sftp_doing(struct connectdata *conn,\n                           bool *dophase_done)", "code": "{\n  CURLcode result;\n  result = ssh_multi_statemach(conn, dophase_done);\n\n  if(*dophase_done) {\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n  }\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * From \"KNOWN_BUGS\" April 2009:\n\n 59. If the CURLOPT_PORT option is used on an FTP URL like\n \"ftp://example.com/file;type=A\" the \";type=A\" is stripped off.\n\n */\n", "func_signal": "int test(char *URL)", "code": "{\n  CURL *curl;\n  CURLcode res = CURLE_OK;\n\n  if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    fprintf(stderr, \"curl_global_init() failed\\n\");\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n  /* get a curl handle */\n  if ((curl = curl_easy_init()) == NULL) {\n    fprintf(stderr, \"curl_easy_init() failed\\n\");\n    curl_global_cleanup();\n    return TEST_ERR_MAJOR_BAD;\n  }\n\n  /* enable verbose */\n  test_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n  /* set port number */\n  test_setopt(curl, CURLOPT_PORT, strtol(libtest_arg2, NULL, 10));\n\n  /* specify target */\n  test_setopt(curl,CURLOPT_URL, URL);\n\n  /* Now run off and do what you've been told! */\n  res = curl_easy_perform(curl);\n\ntest_cleanup:\n\n  curl_easy_cleanup(curl);\n  curl_global_cleanup();\n\n  return res;\n}", "path": "tests\\libtest\\lib562.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n ***********************************************************************\n *\n * scp_perform()\n *\n * This is the actual DO function for SCP. Get a file according to\n * the options previously setup.\n */\n", "func_signal": "static\nCURLcode scp_perform(struct connectdata *conn,\n                      bool *connected,\n                      bool *dophase_done)", "code": "{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(conn->data, \"DO phase starts\\n\"));\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(conn, SSH_SCP_TRANS_INIT);\n\n  /* run the state-machine */\n  if(conn->data->state.used_interface == Curl_if_multi) {\n    result = ssh_multi_statemach(conn, dophase_done);\n  }\n  else {\n    result = ssh_easy_statemach(conn, FALSE);\n    *dophase_done = TRUE; /* with the easy interface we are done here */\n  }\n  *connected = conn->bits.tcpconnect;\n\n  if(*dophase_done) {\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n  }\n\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * Curl_ssh_connect() gets called from Curl_protocol_connect() to allow us to\n * do protocol-specific actions at connect-time.\n */\n", "func_signal": "static CURLcode ssh_connect(struct connectdata *conn, bool *done)", "code": "{\n#ifdef CURL_LIBSSH2_DEBUG\n  curl_socket_t sock;\n#endif\n  struct ssh_conn *ssh;\n  CURLcode result;\n  struct SessionHandle *data = conn->data;\n\n  /* We default to persistent connections. We set this already in this connect\n     function to make the re-use checks properly be able to check this bit. */\n  conn->bits.close = FALSE;\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = ssh_init(conn);\n  if(result)\n    return result;\n\n  if(conn->handler->protocol & CURLPROTO_SCP) {\n    conn->recv[FIRSTSOCKET] = scp_recv;\n    conn->send[FIRSTSOCKET] = scp_send;\n  } else {\n    conn->recv[FIRSTSOCKET] = sftp_recv;\n    conn->send[FIRSTSOCKET] = sftp_send;\n  }\n  ssh = &conn->proto.sshc;\n\n#ifdef CURL_LIBSSH2_DEBUG\n  if(conn->user) {\n    infof(data, \"User: %s\\n\", conn->user);\n  }\n  if(conn->passwd) {\n    infof(data, \"Password: %s\\n\", conn->passwd);\n  }\n  sock = conn->sock[FIRSTSOCKET];\n#endif /* CURL_LIBSSH2_DEBUG */\n\n  ssh->ssh_session = libssh2_session_init_ex(my_libssh2_malloc,\n                                             my_libssh2_free,\n                                             my_libssh2_realloc, conn);\n  if(ssh->ssh_session == NULL) {\n    failf(data, \"Failure initialising ssh session\");\n    return CURLE_FAILED_INIT;\n  }\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n  if(data->set.str[STRING_SSH_KNOWNHOSTS]) {\n    int rc;\n    ssh->kh = libssh2_knownhost_init(ssh->ssh_session);\n    if(!ssh->kh) {\n      /* eeek. TODO: free the ssh_session! */\n      return CURLE_FAILED_INIT;\n    }\n\n    /* read all known hosts from there */\n    rc = libssh2_knownhost_readfile(ssh->kh,\n                                    data->set.str[STRING_SSH_KNOWNHOSTS],\n                                    LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n    if(rc < 0)\n      infof(data, \"Failed to read known hosts from %s\\n\",\n            data->set.str[STRING_SSH_KNOWNHOSTS]);\n  }\n#endif /* HAVE_LIBSSH2_KNOWNHOST_API */\n\n#ifdef CURL_LIBSSH2_DEBUG\n  libssh2_trace(ssh->ssh_session, ~0);\n  infof(data, \"SSH socket: %d\\n\", (int)sock);\n#endif /* CURL_LIBSSH2_DEBUG */\n\n  state(conn, SSH_S_STARTUP);\n\n  if(data->state.used_interface == Curl_if_multi)\n    result = ssh_multi_statemach(conn, done);\n  else {\n    result = ssh_easy_statemach(conn, TRUE);\n    if(!result)\n      *done = TRUE;\n  }\n\n  return result;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* CURLMOPT_SOCKETFUNCTION */\n", "func_signal": "static int sock_cb(CURL *e, curl_socket_t s, int what, void *cbp, void *sockp)", "code": "{\n  GlobalInfo *g = (GlobalInfo*) cbp;\n  SockInfo *fdp = (SockInfo*) sockp;\n  static const char *whatstr[]={ \"none\", \"IN\", \"OUT\", \"INOUT\", \"REMOVE\" };\n\n  MSG_OUT(\"socket callback: s=%d e=%p what=%s \", s, e, whatstr[what]);\n  if (what == CURL_POLL_REMOVE) {\n    MSG_OUT(\"\\n\");\n    remsock(fdp);\n  } else {\n    if (!fdp) {\n      MSG_OUT(\"Adding data: %s%s\\n\",\n             what&CURL_POLL_IN?\"READ\":\"\",\n             what&CURL_POLL_OUT?\"WRITE\":\"\" );\n      addsock(s, e, what, g);\n    }\n    else {\n      MSG_OUT(\n        \"Changing action from %d to %d\\n\", fdp->action, what);\n      setsock(fdp, s, e, what, g);\n    }\n  }\n  return 0;\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* Assign information to a SockInfo structure */\n", "func_signal": "static void setsock(SockInfo*f, curl_socket_t s, CURL*e, int act, GlobalInfo*g)", "code": "{\n  GIOCondition kind =\n     (act&CURL_POLL_IN?G_IO_IN:0)|(act&CURL_POLL_OUT?G_IO_OUT:0);\n\n  f->sockfd = s;\n  f->action = act;\n  f->easy = e;\n  if (f->ev) { g_source_remove(f->ev); }\n  f->ev=g_io_add_watch(f->ch, kind, event_cb,g);\n\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* BLOCKING, but the function is using the state machine so the only reason\n   this is still blocking is that the multi interface code has no support for\n   disconnecting operations that takes a while */\n", "func_signal": "static CURLcode sftp_disconnect(struct connectdata *conn, bool dead_connection)", "code": "{\n  CURLcode result = CURLE_OK;\n  (void) dead_connection;\n\n  DEBUGF(infof(conn->data, \"SSH DISCONNECT starts now\\n\"));\n\n  Curl_safefree(conn->data->state.proto.ssh);\n  conn->data->state.proto.ssh = NULL;\n\n  if(conn->proto.sshc.ssh_session) {\n    /* only if there's a session still around to use! */\n    state(conn, SSH_SFTP_SHUTDOWN);\n    result = ssh_easy_statemach(conn, FALSE);\n  }\n\n  DEBUGF(infof(conn->data, \"SSH DISCONNECT is done\\n\"));\n\n  return result;\n\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/*\n * SSH State machine related code\n */\n/* This is the ONLY way to change SSH state! */\n", "func_signal": "static void state(struct connectdata *conn, sshstate nowstate)", "code": "{\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\n  static const char * const names[] = {\n    \"SSH_STOP\",\n    \"SSH_S_STARTUP\",\n    \"SSH_HOSTKEY\",\n    \"SSH_AUTHLIST\",\n    \"SSH_AUTH_PKEY_INIT\",\n    \"SSH_AUTH_PKEY\",\n    \"SSH_AUTH_PASS_INIT\",\n    \"SSH_AUTH_PASS\",\n    \"SSH_AUTH_HOST_INIT\",\n    \"SSH_AUTH_HOST\",\n    \"SSH_AUTH_KEY_INIT\",\n    \"SSH_AUTH_KEY\",\n    \"SSH_AUTH_DONE\",\n    \"SSH_SFTP_INIT\",\n    \"SSH_SFTP_REALPATH\",\n    \"SSH_SFTP_QUOTE_INIT\",\n    \"SSH_SFTP_POSTQUOTE_INIT\",\n    \"SSH_SFTP_QUOTE\",\n    \"SSH_SFTP_NEXT_QUOTE\",\n    \"SSH_SFTP_QUOTE_STAT\",\n    \"SSH_SFTP_QUOTE_SETSTAT\",\n    \"SSH_SFTP_QUOTE_SYMLINK\",\n    \"SSH_SFTP_QUOTE_MKDIR\",\n    \"SSH_SFTP_QUOTE_RENAME\",\n    \"SSH_SFTP_QUOTE_RMDIR\",\n    \"SSH_SFTP_QUOTE_UNLINK\",\n    \"SSH_SFTP_TRANS_INIT\",\n    \"SSH_SFTP_UPLOAD_INIT\",\n    \"SSH_SFTP_CREATE_DIRS_INIT\",\n    \"SSH_SFTP_CREATE_DIRS\",\n    \"SSH_SFTP_CREATE_DIRS_MKDIR\",\n    \"SSH_SFTP_READDIR_INIT\",\n    \"SSH_SFTP_READDIR\",\n    \"SSH_SFTP_READDIR_LINK\",\n    \"SSH_SFTP_READDIR_BOTTOM\",\n    \"SSH_SFTP_READDIR_DONE\",\n    \"SSH_SFTP_DOWNLOAD_INIT\",\n    \"SSH_SFTP_DOWNLOAD_STAT\",\n    \"SSH_SFTP_CLOSE\",\n    \"SSH_SFTP_SHUTDOWN\",\n    \"SSH_SCP_TRANS_INIT\",\n    \"SSH_SCP_UPLOAD_INIT\",\n    \"SSH_SCP_DOWNLOAD_INIT\",\n    \"SSH_SCP_DONE\",\n    \"SSH_SCP_SEND_EOF\",\n    \"SSH_SCP_WAIT_EOF\",\n    \"SSH_SCP_WAIT_CLOSE\",\n    \"SSH_SCP_CHANNEL_FREE\",\n    \"SSH_SESSION_DISCONNECT\",\n    \"SSH_SESSION_FREE\",\n    \"QUIT\"\n  };\n#endif\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  if(sshc->state != nowstate) {\n    infof(conn->data, \"SFTP %p state change from %s to %s\\n\",\n          sshc, names[sshc->state], names[nowstate]);\n  }\n#endif\n\n  sshc->state = nowstate;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* Die if we get a bad CURLMcode somewhere */\n", "func_signal": "static void mcode_or_die(const char *where, CURLMcode code)", "code": "{\n  if ( CURLM_OK != code ) {\n    const char *s;\n    switch (code) {\n      case     CURLM_CALL_MULTI_PERFORM: s=\"CURLM_CALL_MULTI_PERFORM\"; break;\n      case     CURLM_BAD_HANDLE:         s=\"CURLM_BAD_HANDLE\";         break;\n      case     CURLM_BAD_EASY_HANDLE:    s=\"CURLM_BAD_EASY_HANDLE\";    break;\n      case     CURLM_OUT_OF_MEMORY:      s=\"CURLM_OUT_OF_MEMORY\";      break;\n      case     CURLM_INTERNAL_ERROR:     s=\"CURLM_INTERNAL_ERROR\";     break;\n      case     CURLM_BAD_SOCKET:         s=\"CURLM_BAD_SOCKET\";         break;\n      case     CURLM_UNKNOWN_OPTION:     s=\"CURLM_UNKNOWN_OPTION\";     break;\n      case     CURLM_LAST:               s=\"CURLM_LAST\";               break;\n      default: s=\"CURLM_unknown\";\n    }\n    MSG_OUT(\"ERROR: %s returns %s\\n\", where, s);\n    exit(code);\n  }\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* kbd_callback */\n", "func_signal": "static CURLcode sftp_libssh2_error_to_CURLE(int err)", "code": "{\n  switch (err) {\n    case LIBSSH2_FX_OK:\n      return CURLE_OK;\n\n    case LIBSSH2_FX_NO_SUCH_FILE:\n    case LIBSSH2_FX_NO_SUCH_PATH:\n      return CURLE_REMOTE_FILE_NOT_FOUND;\n\n    case LIBSSH2_FX_PERMISSION_DENIED:\n    case LIBSSH2_FX_WRITE_PROTECT:\n    case LIBSSH2_FX_LOCK_CONFlICT:\n      return CURLE_REMOTE_ACCESS_DENIED;\n\n    case LIBSSH2_FX_NO_SPACE_ON_FILESYSTEM:\n    case LIBSSH2_FX_QUOTA_EXCEEDED:\n      return CURLE_REMOTE_DISK_FULL;\n\n    case LIBSSH2_FX_FILE_ALREADY_EXISTS:\n      return CURLE_REMOTE_FILE_EXISTS;\n\n    case LIBSSH2_FX_DIR_NOT_EMPTY:\n      return CURLE_QUOTE_ERROR;\n\n    default:\n      break;\n  }\n\n  return CURLE_SSH;\n}", "path": "lib\\ssh.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* Called by glib when we get action on a multi socket */\n", "func_signal": "static gboolean event_cb(GIOChannel *ch, GIOCondition condition, gpointer data)", "code": "{\n  GlobalInfo *g = (GlobalInfo*) data;\n  CURLMcode rc;\n  int fd=g_io_channel_unix_get_fd(ch);\n\n  int action =\n    (condition & G_IO_IN ? CURL_CSELECT_IN : 0) |\n    (condition & G_IO_OUT ? CURL_CSELECT_OUT : 0);\n\n  rc = curl_multi_socket_action(g->multi, fd, action, &g->still_running);\n  mcode_or_die(\"event_cb: curl_multi_socket_action\", rc);\n\n  check_multi_info(g);\n  if(g->still_running) {\n    return TRUE;\n  } else {\n    MSG_OUT(\"last transfer done, kill timeout\\n\");\n    if (g->timer_event) { g_source_remove(g->timer_event); }\n    return FALSE;\n  }\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/* CURLOPT_PROGRESSFUNCTION */\n", "func_signal": "static int prog_cb (void *p, double dltotal, double dlnow, double ult, double uln)", "code": "{\n  ConnInfo *conn = (ConnInfo *)p;\n  MSG_OUT(\"Progress: %s (%g/%g)\\n\", conn->url, dlnow, dltotal);\n  return 0;\n}", "path": "docs\\examples\\ghiper.c", "repo_name": "kakaroto/libcurl-ps3", "stars": 13, "license": "other", "language": "c", "size": 3413}
{"docstring": "/************************************************************************\n    mm_read_mtx_crd()  fills M, N, nz, array of values, and return\n                        type code, e.g. 'MCRS'\n\n                        if matrix is complex, values[] is of size 2*nz,\n                            (nz pairs of real/imaginary values)\n************************************************************************/\n", "func_signal": "int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J, \n        double **val, MM_typecode matcode)", "code": "{\n    int ret_code;\n    FILE *f;\n\n    if (strcmp(fname, \"stdin\") == 0) f=stdin;\n    else\n    if ((f = fopen(fname, \"r\")) == NULL)\n        return MM_COULD_NOT_READ_FILE;\n\n\n    if ((ret_code = mm_read_banner(f, matcode)) != 0)\n        return ret_code;\n\n    if (!(mm_is_valid(matcode) && mm_is_sparse(matcode) && \n            mm_is_matrix(matcode)))\n        return MM_UNSUPPORTED_TYPE;\n\n    if ((ret_code = mm_read_mtx_crd_size(f, M, N, nz)) != 0)\n        return ret_code;\n\n\n    *I = (int *)  malloc(*nz * sizeof(int));\n    *J = (int *)  malloc(*nz * sizeof(int));\n    *val = NULL;\n\n    if (mm_is_complex(matcode))\n    {\n        *val = (double *) malloc(*nz * 2 * sizeof(double));\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                matcode);\n        if (ret_code != 0) return ret_code;\n    }\n    else if (mm_is_real(matcode))\n    {\n        *val = (double *) malloc(*nz * sizeof(double));\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                matcode);\n        if (ret_code != 0) return ret_code;\n    }\n\n    else if (mm_is_pattern(matcode))\n    {\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                matcode);\n        if (ret_code != 0) return ret_code;\n    }\n\n    if (f != stdin) fclose(f);\n    return 0;\n}", "path": "pysparse\\sparse\\src\\mmio_patched.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************/\n/* use when I[], J[], and val[]J, and val[] are already allocated */\n/******************************************************************/\n", "func_signal": "int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],\n        double val[], MM_typecode matcode)", "code": "{\n    int i;\n    if (mm_is_complex(matcode))\n    {\n        for (i=0; i<nz; i++)\n            if (fscanf(f, \"%d %d %lg %lg\", &I[i], &J[i], &val[2*i], &val[2*i+1])\n                != 4) return MM_PREMATURE_EOF;\n    }\n    else if (mm_is_real(matcode))\n    {\n        for (i=0; i<nz; i++)\n        {\n            if (fscanf(f, \"%d %d %lg\\n\", &I[i], &J[i], &val[i])\n                != 3) return MM_PREMATURE_EOF;\n\n        }\n    }\n\n    else if (mm_is_pattern(matcode))\n    {\n        for (i=0; i<nz; i++)\n            if (fscanf(f, \"%d %d\", &I[i], &J[i])\n                != 2) return MM_PREMATURE_EOF;\n    }\n    else\n        return MM_UNSUPPORTED_TYPE;\n\n    return 0;\n        \n}", "path": "pysparse\\sparse\\src\\mmio_patched.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/* MATVEC - matrix vector multiplications\n */\n", "func_signal": "void matvec(double *x, double *y)", "code": "{\n  double s, v, xi;\n  int i, j, k;\n \n  for (i = 0; i < n_s; i ++) {\n    xi = x[i];\n    s = 0.0;\n    for (k = ia_s[i]; k < ia_s[i+1]; k ++) {\n      j = ja_s[k];\n      v = va_s[k];\n      s += v * x[j];\n      y[j] += v * xi;\n    }\n    y[i] = s + da_s[i]*xi;\n  }\n}", "path": "examples\\poisson_test\\poisson_test.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/* CONVERT_COO_SSS - convert sparse matrix from COO to SSS format\n */\n", "func_signal": "void convert_COO_SSS(int n, int nz,\n                     int *i_coo, int *j_coo, double *v_coo,\n                     int **ia, int **ja, double **va, double **da)", "code": "{\n  int i, k, l, t, nnz;\n  int *root;\n\n  root = (int *)malloc(n * sizeof(int));\n  assert(root);\n\n  /* allocate SSS matrix structure (1st part) */\n  (*da) = (double *)malloc(n * sizeof(double));\n\n  for (i = 0; i < n; i ++) {\n    root[i] = 0;\n    (*da)[i] = 0.0;\n  }\n\n  /* build n linked lists */\n  nnz = 0;\n  for (k = 0; k < nz; k ++) {\n    if (i_coo[k] == j_coo[k])\n      /* diagonal element */\n      (*da)[i_coo[k]] = v_coo[k];\n    else {\n      /* off diagonal element */\n      if (i_coo[k] < j_coo[k]) {   /* move to lower triangle */\n        t = i_coo[k];\n        i_coo[k] = j_coo[k];\n        j_coo[k] = t;\n      }\n      i = i_coo[k];                /* link */\n      i_coo[k] = root[i];\n      root[i] = k;\n      nnz ++;\n    }\n  }\n\n  /* allocate SSS matrix structure (2nd part) */\n  (*ia) = (int *)malloc((n+1) * sizeof(int));\n  (*va) = (double *)malloc((nnz * sizeof(double)));\n  (*ja) = (int *)malloc(nnz * sizeof(int));\n\n  /* fill SSS matrix structure */\n  k = 0;\n  for (i = 0; i < n; i ++) {\n    (*ia)[i] = k;\n    l = root[i];\n    while (l != 0) {\n      (*ja)[k] = j_coo[l];\n      (*va)[k] = v_coo[l];\n      k ++;\n      l = i_coo[l];\n    }\n  }\n  (*ia)[n] = k;\n  assert(k == nnz);\n  free(root);\n}", "path": "examples\\poisson_test\\poisson_test.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************************\n *                                                                            *\n * SpMatrix_GetShape -- get object shape                                      *\n *                                                                            *\n *   Query the shape attribute of an object.                                  *\n *                                                                            *\n *   Used to get the number of row and columns of a sparse matrix or a        *\n *   preconditioner.                                                          *\n *                                                                            *\n ******************************************************************************/\n", "func_signal": "static int\nSpMatrix_GetShape(PyObject *op, int dim[])", "code": "{\n  PyObject *sh, *elem;\n  \n  if ((sh = PyObject_GetAttrString(op, \"shape\")) == NULL)\n    return -1;\n  if (PySequence_Size(sh) != 2) {\n    PyErr_SetString(PyExc_ValueError, \"invalid matrix shape\");\n    return -1;\n  }\n  elem = PySequence_GetItem(sh, 0); dim[0] = PyInt_AsLong(elem); Py_DECREF(elem);\n  elem = PySequence_GetItem(sh, 1); dim[1] = PyInt_AsLong(elem); Py_DECREF(elem);\n  Py_DECREF(sh);\n  if (PyErr_Occurred() != NULL) {\n    PyErr_SetString(PyExc_ValueError, \"invalid matrix shape\");\n    return -1;\n  }\n  return 0;\n}", "path": "pysparse\\sparse\\src\\spmatrixmodule.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************/\n/* use when I[], J[], and val[]J, and val[] are already allocated */\n/******************************************************************/\n", "func_signal": "int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],\n        double val[], MM_typecode matcode)", "code": "{\n    int i;\n    if (mm_is_complex(matcode))\n    {\n        for (i=0; i<nz; i++)\n            if (fscanf(f, \"%d %d %lg %lg\", &I[i], &J[i], &val[2*i], &val[2*i+1])\n                != 4) return MM_PREMATURE_EOF;\n    }\n    else if (mm_is_real(matcode))\n    {\n        for (i=0; i<nz; i++)\n        {\n            if (fscanf(f, \"%d %d %lg\\n\", &I[i], &J[i], &val[i])\n                != 3) return MM_PREMATURE_EOF;\n\n        }\n    }\n\n    else if (mm_is_pattern(matcode))\n    {\n        for (i=0; i<nz; i++)\n            if (fscanf(f, \"%d %d\", &I[i], &J[i])\n                != 2) return MM_PREMATURE_EOF;\n    }\n    else\n        return MM_UNSUPPORTED_TYPE;\n\n    return 0;\n        \n}", "path": "examples\\poisson_test\\mmio.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************************\n *                                                                            *\n * LLMatType_alloc                                                            *\n *                                                                            *\n *   construct an ll_mat object that represents an empty sparse matrix.       *\n *                                                                            *\n ******************************************************************************/\n", "func_signal": "static PyObject *\nLLMat_zeros(PyObject *self, PyObject *args)", "code": "{\n  int dim[2], sizeHint;\n  \n  sizeHint = 1000;\n  if (!PyArg_ParseTuple(args, \"ii|i\", dim, dim + 1, &sizeHint))\n    return NULL;\n\n  return SpMatrix_NewLLMatObject(dim, 0, sizeHint);\n}", "path": "pysparse\\sparse\\src\\spmatrixmodule.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************************\n *                                                                            *\n * SpMatrix_GetItem -- access matrix entry (i,j)                              *\n *                                                                            *\n *      returns matrix entry op[i,j] as a double                              *\n *                                                                            *\n ******************************************************************************/\n", "func_signal": "static double \nSpMatrix_GetItem(PyObject *op, int i, int j)", "code": "{\n  PyObject *index;\n  PyObject *fo;\n  double d;\n\n  index = Py_BuildValue(\"(ii)\", i, j);\n  assert(index);\n  fo = PyObject_GetItem(op, index);\n  Py_DECREF(index);\n  if (fo == NULL)\n    return 0.0;\n  d = PyFloat_AsDouble(fo);\n  Py_DECREF(fo);\n  return d;\n}", "path": "pysparse\\sparse\\src\\spmatrixmodule.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/*********************************************************************** \n * CSRMatType methods\n */\n", "func_signal": "static void\nCSRMatType_dealloc(CSRMatObject *a)", "code": "{\n  PyMem_DEL(a->ind);\n  PyMem_DEL(a->val);\n  PyMem_DEL(a->col);\n  PyObject_Del(a);\n}", "path": "pysparse\\sparse\\src\\csr_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/************************************************************************\n    mm_read_mtx_crd()  fills M, N, nz, array of values, and return\n                        type code, e.g. 'MCRS'\n\n                        if matrix is complex, values[] is of size 2*nz,\n                            (nz pairs of real/imaginary values)\n************************************************************************/\n", "func_signal": "int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J, \n        double **val, MM_typecode *matcode)", "code": "{\n    int ret_code;\n    FILE *f;\n\n    if (strcmp(fname, \"stdin\") == 0) f=stdin;\n    else\n    if ((f = fopen(fname, \"r\")) == NULL)\n        return MM_COULD_NOT_READ_FILE;\n\n\n    if ((ret_code = mm_read_banner(f, matcode)) != 0)\n        return ret_code;\n\n    if (!(mm_is_valid(*matcode) && mm_is_sparse(*matcode) && \n            mm_is_matrix(*matcode)))\n        return MM_UNSUPPORTED_TYPE;\n\n    if ((ret_code = mm_read_mtx_crd_size(f, M, N, nz)) != 0)\n        return ret_code;\n\n\n    *I = (int *)  malloc(*nz * sizeof(int));\n    *J = (int *)  malloc(*nz * sizeof(int));\n    *val = NULL;\n\n    if (mm_is_complex(*matcode))\n    {\n        *val = (double *) malloc(*nz * 2 * sizeof(double));\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                *matcode);\n        if (ret_code != 0) return ret_code;\n    }\n    else if (mm_is_real(*matcode))\n    {\n        *val = (double *) malloc(*nz * sizeof(double));\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                *matcode);\n        if (ret_code != 0) return ret_code;\n    }\n\n    else if (mm_is_pattern(*matcode))\n    {\n        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, \n                *matcode);\n        if (ret_code != 0) return ret_code;\n    }\n\n    if (f != stdin) fclose(f);\n    return 0;\n}", "path": "examples\\poisson_test\\mmio.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/* READ_MTX - read symmetric sparse matrix in MatrixMarket format\n */\n", "func_signal": "void read_MTX_SSS(char *fname, int *n,\n                  double **va, double **da, int **ja, int **ia)", "code": "{\n  int m, nz, ret_code, i;\n  double *v_coo;\n  int *i_coo, *j_coo;\n  MM_typecode matcode;\n  FILE *f;\n\n  f = fopen(fname, \"r\");\n  assert(f != NULL);\n  ret_code = mm_read_banner(f, &matcode);\n  assert(ret_code == 0);\n  assert(mm_is_real(matcode) && mm_is_matrix(matcode) &&\n         mm_is_sparse(matcode) && mm_is_symmetric(matcode));\n  ret_code = mm_read_mtx_crd_size(f, &m, n, &nz);\n  assert(ret_code == 0);\n  assert(m == *n);\n  /* read COO format */\n  i_coo = (int *)malloc(nz * sizeof(int));\n  j_coo = (int *)malloc(nz * sizeof(int));\n  v_coo = (double *)malloc(nz * sizeof(double));\n  assert(i_coo && j_coo && v_coo);\n  for (i = 0; i < nz; i ++) {\n    fscanf(f, \"%d %d %lg\\n\", &i_coo[i], &j_coo[i], &v_coo[i]);\n    i_coo[i]--;  /* adjust from 1-based to 0-based */\n    j_coo[i]--;\n  }\n  fclose(f);\n  /* convert to SSS format */\n  convert_COO_SSS(*n, nz, i_coo, j_coo, v_coo, ia, ja, va, da);\n  free(i_coo); free(j_coo); free(v_coo);\n}", "path": "examples\\poisson_test\\poisson_test.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/*********************************************************************** \n * SSSMatType methods\n */\n", "func_signal": "static void\nSSSMatType_dealloc(SSSMatObject *self)", "code": "{\n  PyMem_DEL(self->ind);\n  PyMem_DEL(self->val);\n  PyMem_DEL(self->col);\n  PyMem_DEL(self->diag);  \n  PyObject_Del(self);\n}", "path": "pysparse\\sparse\\src\\sss_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/** SSSMat_subscript\n *    Called when treating array object like a mapping. This is used\n *    implement two-dimensional idices, e.g. A[i,j] or A[i1:i2,j1:j2]\n */\n", "func_signal": "static PyObject *\nSSSMat_subscript(SSSMatObject *self, PyObject *idx)", "code": "{\n  int type, start0, stop0, step0, len0, start1, stop1, step1, len1;\n  int dim[2];\n\n  dim[0] = dim[1] = self->n;\n  if ((type = LLMat_parse_index(idx, dim,\n                                &start0, &stop0, &step0, &len0,\n                                &start1, &stop1, &step1, &len1)) == -1)\n    return NULL;\n  if (type == 1)\n    return getitem(self, start0, start1);\n  else {\n    PyErr_SetString(PyExc_IndexError, \"slices not supported\");\n    return NULL;\n  }\n}", "path": "pysparse\\sparse\\src\\sss_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/* PCG - Conjugate Gradients Algorithm\n */\n", "func_signal": "void pcg(int n, \n\t double *x, \n\t double *b,\n\t double tol, \n\t int maxit,\n\t int clvl,\n\t int *iter, \n\t double *relres, \n\t int *flag,\n\t double *work,\n\t void (*matvec)(double *, double *),\n\t void (*precon)(double *, double *))", "code": "{\n  double ALPHA;\t\t\t/* used for passing parameters */\n  int ONE = 1;\t\t\t/* to BLAS routines */\n\n  double n2b;\t\t\t/* norm of rhs vector */\n  double tolb;\t\t\t/* requested tolerance for residual */\n  double normr;\t\t\t/* residual norm */\n  double alpha, beta;\n  double rho, rho1;\n  double pq;\n  double dmax, ddum;\t\t/* used to detect stagnation */\n  int stag;\t\t\t/* flag to indicate stagnation */\n  int it;\t\t\t/* current iteration number */\n  int i;\t\t\t/* index variable */\n  double *r, *z, *p, *q;\t/* pointers to vectors in PCG algorithm */\n  \n  /* setup pointers into work */\n  r = work;\n  z = work + n;\n  p = work + 2*n;\n  q = work + 3*n;\n\n  /* Check for all zero right hand side vector => all zero solution */\n  n2b = F77(dnrm2)(&n, b, &ONE);/* Norm of rhs vector, b */\n  if (n2b == 0.0) {\t\t/* if rhs vector is all zeros */\n    for (i = 0; i < n; i ++)\t/* then  solution is all zeros */\n      x[i] = 0.0;\n    *flag = 0;\t\t\t/* a valid solution has been obtained */\n    *relres = 0.0;\t\t/* the relative residual is actually 0/0 */\n    *iter = 0;\t\t\t/* no iterations need be performed */\n    if (clvl)\n      itermsg(tol,maxit,*flag,*iter,*relres);\n    return;\n  }\n  \n  /* Set up for the method */\n  *flag = 1;\n  tolb = tol * n2b;\t\t/* Relative tolerance */\n  matvec(x, r);\t\t\t/* Zero-th residual: r = b - A * x*/\n  for (i = 0; i < n; i ++)\t/* then  solution is all zeros */\n    r[i] = b[i] - r[i];\n  normr = F77(dnrm2)(&n, r, &ONE); /* Norm of residual */\n  \n  if (normr <= tolb) {\t\t/* Initial guess is a good enough solution */\n    *flag = 0;\n    *relres = normr / n2b;\n    *iter = 0;\n    if (clvl)\n      itermsg(tol,maxit,*flag,*iter,*relres);\n    return;\n  }\n\n  rho = 1.0;\n  stag = 0;\t\t\t/* stagnation of the method */\n\n  /* loop over maxit iterations (unless convergence or failure) */\n  \n  for (it = 1; it <= maxit; it ++) {\n    \n    if (precon) {\n      precon(r, z);\n      /*\n\tif isinf(norm(y,inf))\n\tflag = 2;\n\tbreak\n\tend\n      */\n    } else {\n      F77(dcopy)(&n, r, &ONE, z, &ONE);\n    }\n   \n    rho1 = rho;\n    rho = F77(ddot)(&n, r, &ONE, z, &ONE);\n    if (rho == 0.0) {\t\t/* or isinf(rho) */\n      *flag = 4;\n      break;\n    }\n    if (it == 1) {\n      F77(dcopy)(&n, z, &ONE, p, &ONE);\n    } else {\n      beta = rho / rho1;\n      if (beta == 0.0) {\t/* | isinf(beta) */\n\t*flag = 4;\n\tbreak;\n      }\n      for (i = 0; i < n; i ++)\t/* p = z + beta * p; */\n\tp[i] = z[i] + beta * p[i];\n    }\n    matvec(p, q);\t\t/* q = A * p */\n    pq = F77(ddot)(&n, p, &ONE, q, &ONE); /* pq = p' * q */\n    if (pq == 0.0) {\t\t/* | isinf(pq) */\n      *flag = 4;\n      break;\n    } else {\n      alpha = rho / pq;\n    }\n    /* \n       if isinf(alpha)\n       flag = 4;\n       break\n       end\n    */\n    if (alpha == 0.0)\t\t/* stagnation of the method */\n      stag = 1;\n   \n    /* Check for stagnation of the method */\n    if (stag == 0) {\n      dmax = 0.0;\n      for (i = 0; i < n; i ++)\n\tif (x[i] != 0.0) {\n\t  ddum = fabs(alpha * p[i]/x[i]);\n\t  if (ddum > dmax)\n\t    dmax = ddum;\n\t} else\n\t  if (p[i] != 0.0)\n\t    dmax = 1.0;\n      stag = (1.0 + dmax == 1.0);\n    }\n    \n    F77(daxpy)(&n, &alpha, p, &ONE, x, &ONE); /* form new iterate */\n    ALPHA = -alpha;\n    F77(daxpy)(&n, &ALPHA, q, &ONE, r, &ONE); /* r = r - alpha * q */\n    \n    /* check for convergence */\n#ifdef EXPENSIVE_CRIT\n    matvec(x, z);\t\t/* normr = norm(b - A * x) */\n    for (i = 0; i < n; i ++)\n      z[i] = b[i] - z[i];\n    normr = F77(dnrm2)(&n, z, &ONE);\n#else\n    normr = F77(dnrm2)(&n, r, &ONE); /* normr = norm(r) */\n#endif\n    if (normr <= tolb) {\n      *flag = 0;\n      break;\n    }\n    \n    if (stag == 1) {\n      *flag = 3;\n      break;\n    }\n  } /* for it = 1 : maxit */\n  \n  *iter = it;\n  *relres = normr / n2b;\n\n  if (clvl)\n    itermsg(tol,maxit,*flag,*iter,*relres);\n}", "path": "examples\\poisson_test\\pcg.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/* ITERMSG - Displays the final message for PCG method\n */\n", "func_signal": "static void itermsg(double tol,\n\t\t    int maxit,\n\t\t    int flag,\n\t\t    int iter,\n\t\t    double relres)", "code": "{\n  if (flag != 0) {\n    printf(\"PCG stopped at iteration %d without converging to the desired tolerance %0.2g\", iter, tol);\n  }\n  \n  switch(flag) {\n  case 0:\n    if (iter == 0)\n      printf(\"The initial guess has relative residual %0.2g which is within\\nthe desired tolerance %0.2g so PCG returned it without iterating.\",\n\t     relres, tol);\n    else\n      printf(\"PCG converged at iteration %d to a solution with relative residual %0.2g\", iter, relres);\n    break;\n  case 1:\n    printf(\"\\nbecause the maximum number of iterations was reached.\");\n    break;\n  case 2:\n    printf(\"\\nbecause the system involving the preconditioner was ill conditioned.\");\n    break;\n  case 3:\n    printf(\"\\nbecause the method stagnated.\");\n    break;\n  case 4:\n    printf(\"\\nbecause a scalar quantity became too small or too large to continue computing.\");\n    break;\n  }\n  \n  if (flag != 0)\n    printf(\"\\nThe iterate returned (number %d) has relative residual %0.2g\",iter,relres);\n\n  printf(\"\\n\");\n}", "path": "examples\\poisson_test\\pcg.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/** newCSRMatObject -- allocate a new CSRMatObject instance\n *\n *    a newly allocated, uninitialized CSRMatObject is returned\n */\n", "func_signal": "static PyObject *\nnewCSRMatObject(int dim[], int nnz)", "code": "{\n  CSRMatObject *op;\n\n  /* create new SparseArrayt object */\n  op = PyObject_New(CSRMatObject, &CSRMatType);\n  if (op == NULL)\n    PyErr_NoMemory();\n\n  op->val = NULL;\n  op->ind = NULL;\n  op->col = NULL;\n\n  /* allocate arrays */\n  op->ind = PyMem_New(int, dim[0] + 1);\n  if (op->ind == NULL)\n    goto fail;\n  op->val = PyMem_New(double, nnz);\n  if (op->val == NULL)\n    goto fail;\n  op->col = PyMem_New(int, nnz);\n  if (op->col == NULL)\n    goto fail;\n\n  /* initialize rest of fields */\n  op->dim[0] = dim[0];\n  op->dim[1] = dim[1];\n  op->nnz = nnz;\n\n  return (PyObject *) op;\n\n fail:\n    PyMem_Del(op->ind);    \n    PyMem_Del(op->val);    \n    PyMem_Del(op->col);    \n    PyObject_Del(op);\n    return PyErr_NoMemory();\n}", "path": "pysparse\\sparse\\src\\csr_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/*********************************************************************** \n * CSRMatObject methods\n */\n", "func_signal": "static void\ncsr_matvec_kernel(int m, double *x, double *y,\n\t\t  double *va, int *ja, int *ia)", "code": "{\n  double s;\n  int i, k;\n  \n#if UNROLL_LOOPS\n  int k1, *ja_ptr;\n\n  ja_ptr = ja;\n  k = ia[0];\n  for (i = 0; i < m; i ++) {\n    s = 0.0;\n    k1 = ia[i+1];\n    for (; k+10 < k1; k += 10) {\n      s += va[k+9]*x[ja_ptr[9]] +\n        va[k+8]*x[ja_ptr[8]] +\n        va[k+7]*x[ja_ptr[7]] +\n        va[k+6]*x[ja_ptr[6]] +\n        va[k+5]*x[ja_ptr[5]] +\n        va[k+4]*x[ja_ptr[4]] +\n        va[k+3]*x[ja_ptr[3]] +\n        va[k+2]*x[ja_ptr[2]] +\n        va[k+1]*x[ja_ptr[1]] +\n        va[k]*x[*ja_ptr];\n      ja_ptr += 10;\n    }\n    for (; k < ia[i+1]; k ++)\n      s += va[k]*x[*ja_ptr++];\n    y[i] = s;\n  }\n#else\n  for (i = 0; i < m; i ++) {\n    s = 0.0;\n    for (k = ia[i]; k < ia[i+1]; k ++)\n      s += va[k] * x[ja[k]];\n    y[i] = s;\n  }\n#endif\n}", "path": "pysparse\\sparse\\src\\csr_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************************\n *                                                                            *\n * SpMatrix_Matvec -- invoke matrix-vector multiplication                     *\n *                                                                            *\n *   Invokes matrix-vector multiplication, by calling the 'matvec'-method of  *\n *   'matrix',  y = matrix*x. The vectors 'x' and 'y' are given as arrays of  *\n *   double.                                                                  *\n *                                                                            *\n *   Returns 0 if the operation was successful, or -1 if an error occured.    *\n *                                                                            *\n ******************************************************************************/\n", "func_signal": "static int\nSpMatrix_Matvec(PyObject *matrix, int nx, double *x, int ny, double *y)", "code": "{\n  PyObject *x_arr = NULL;\n  PyObject *y_arr = NULL;\n  PyObject *res;\n  npy_intp dims[1];\n\n  /* create array objects from x and y */\n  dims[0] = nx;\n  x_arr = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void *)x);\n  if (x_arr == NULL)\n    goto fail;\n  dims[0] = ny;\n  y_arr = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, (void *)y);\n  if (y_arr == NULL)\n    goto fail;\n\n  /* Call matvec method of matrix object */\n  res = PyObject_CallMethod(matrix, \"matvec\", \"OO\", x_arr, y_arr);\n  if (res == NULL)\n    goto fail;\n  Py_DECREF(res);\n  \n  /* free array objects */\n  Py_DECREF(x_arr);\n  Py_DECREF(y_arr);\n  return 0;\n\n fail:\n  Py_XDECREF(x_arr);\n  Py_XDECREF(y_arr);\n  return -1;\n}", "path": "pysparse\\sparse\\src\\spmatrixmodule.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/** getitem\n *\n */\n", "func_signal": "static PyObject *\ngetitem(SSSMatObject *self, int i, int j)", "code": "{\n  int k, t;\n\n  if (i == j)\n    return PyFloat_FromDouble(self->diag[i]);\n  if (i < j) {\n    t = i; i = j; j = t;\n  }\n  for (k = self->ind[i]; k < self->ind[i+1]; k ++) {\n    if (self->col[k] == j)\n      return PyFloat_FromDouble(self->val[k]);\n  }\n  return PyFloat_FromDouble(0.0);\n}", "path": "pysparse\\sparse\\src\\sss_mat.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/******************************************************************************\n *                                                                            *\n * SpMatrix_Precon -- invoke preconditioner                                   *\n *                                                                            *\n *  Applies the preconditioner 'prec' on the vector 'x' and stores the result *\n *  in vector 'y'. This is done by calling the 'precon' method of 'prec'. The *\n *  vectors 'x' and 'y' are given as arrays of double.                        *\n *                                                                            *\n *  Returns 0 if the operation was successful, or -1 if an error occured.     *\n *                                                                            *\n ******************************************************************************/\n", "func_signal": "static int\nSpMatrix_Precon(PyObject *prec, int n, double *x, double *y)", "code": "{\n  PyObject *x_arr = NULL;\n  PyObject *y_arr = NULL;\n  npy_intp dimensions[1];\n  PyObject *res;\n\n  dimensions[0] = n;\n\n  /* create array objects from x and y */\n  x_arr = PyArray_SimpleNewFromData(1, dimensions, NPY_DOUBLE, (void *)x);\n  if (x_arr == NULL)\n    goto fail;\n  y_arr = PyArray_SimpleNewFromData(1, dimensions, NPY_DOUBLE, (void *)y);\n  if (y_arr == NULL)\n    goto fail;\n\n  /* Call matvec method of matrix object */\n  res = PyObject_CallMethod(prec, \"precon\", \"OO\", x_arr, y_arr);\n  if (res == NULL)\n    goto fail;\n\n  Py_DECREF(res);\n  \n  /* free array objects */\n  Py_DECREF(x_arr);\n  Py_DECREF(y_arr);\n  return 0;\n\n fail:\n  Py_XDECREF(x_arr);\n  Py_XDECREF(y_arr);\n  return -1;\n}", "path": "pysparse\\sparse\\src\\spmatrixmodule.c", "repo_name": "rspeer/csc-pysparse", "stars": 10, "license": "other", "language": "c", "size": 3936}
{"docstring": "/*\n * Inserts an object to an arbitrary position in a quotation.\n * TODO: Get memmove() to work, less naive\n */\n", "func_signal": "OBJ\nQuotation_insert_(CzState *cz, CzQuotation *self, OBJ object, int pos)", "code": "{\n\tOBJ tmp;\n\tsize_t i;\n\tQuotation_push_(cz, self, CZ_NIL);\n\tfor (i = self->size - 1; i > pos; i--) {\n\t\tself->items[i] = self->items[i - 1];\n\t}\n\t//memmove(self->items + ((pos + 1) * sizeof(OBJ)), self->items + ((pos + 0) * sizeof(OBJ)), sizeof(OBJ) * (self->size - pos - 1));\n\tself->items[pos] = object;\n\treturn (OBJ)self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Grows a table as needed.\n */\n", "func_signal": "OBJ\nTable_resize_(CzState *cz, CzTable *self)", "code": "{\n\tOBJ *new_items;\n\tsize_t i;\n\t\n\tif ((self->size / self->cap) >= 0.7) {\n\t\tself->cap = primes[++(self->prime)];\n\t}\n\tnew_items = (OBJ *)CZ_CALLOC(self->cap, sizeof(OBJ));\n\tif (new_items == NULL) {\n\t\tself->cap = primes[--(self->prime)];\n\t\treturn CZ_NIL;\n\t}\n\tmemset(new_items, 0, self->cap * sizeof(OBJ));\n\tfor (i = 0; i < self->size; i++) {\n\t\tnew_items[((size_t)(CZ_AS(Pair, self->items[i])->key_hash) % self->cap)] = self->items[i];\n\t} \n\tself->items = new_items;\n\treturn (OBJ)self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Creates a new Pair object.\n */\n", "func_signal": "OBJ\nPair_create_(CzState *cz, OBJ hash, OBJ key, OBJ value)", "code": "{\n\tCzPair *self   = CZ_MAKE_OBJECT(Pair);\n\tself->key_hash = hash;\n\tself->key      = key;\n\tself->value    = value;\n\treturn (OBJ)self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Appends an object to a quotation.\n */\n", "func_signal": "OBJ\nQuotation_push_(CzState *cz, CzQuotation *self, OBJ object)", "code": "{\n\tif ((self->size + 1) > self->cap) {\n\t\tself->items = (OBJ *)CZ_REALLOC(self->items, sizeof(OBJ) * (self->cap + 1) * 2);\n\t\tself->cap = (self->cap + 1) * 2;\n\t}\n\tself->items[self->size++] = object;\n\treturn (OBJ)self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Saves a piece of the token currently being built by the lexer.\n */\n", "func_signal": "static int\nsave(Lexer *l, int c)", "code": "{\n\tif (l->bufused + 1 > l->bufsize) {\n\t\tsize_t newsize;\n\t\tif (l->bufsize >= MAX_SIZET/2) {\n\t\t\treturn CZ_ERR;\n\t\t}\n\t\tnewsize = l->bufsize * 2;\n\t\tl->buffer = (char *)GC_REALLOC(l->buffer, sizeof(char) * newsize);\n\t\tif (l->buffer == NULL) {\n\t\t\treturn CZ_ERR;\n\t\t}\n\t\tl->bufsize = newsize;\n\t}\n\tl->buffer[l->bufused++] = (char)c;\n\treturn CZ_OK;\n}", "path": "src\\lexer.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * ( O Q -- Q )\n * Appends the element O to the quotation Q.\n */\n", "func_signal": "OBJ\nQuotation_push(CzState *cz, OBJ self)", "code": "{\n\tOBJ other;\n\tother = CZ_POP();\n\tQuotation_push_(cz, CZ_AS(Quotation, self), other);\n\tCZ_PUSH(self);\n\treturn self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Destroys a lexer.\n */\n", "func_signal": "int\nLexer_destroy(Lexer *l)", "code": "{\n\tif (l == NULL) {\n\t\treturn CZ_ERR;\n\t}\n\tGC_FREE(l->buffer);\n\tGC_FREE(l);\n\treturn CZ_OK;\n}", "path": "src\\lexer.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Creates a new lexer from a buffered I/O stream.\n */\n", "func_signal": "Lexer *\nLexer_new(cz_bufio *in)", "code": "{\n\tLexer *l = (Lexer *)GC_MALLOC(sizeof(Lexer));\n\tif (l == NULL) {\n\t\treturn NULL;\n\t}\n\tl->in = in;\n\tl->bufsize = 8096;\n\tl->bufused = -1;\n\tl->buffer = (char *)GC_MALLOC(sizeof(char)*l->bufsize);\n\tif (l->buffer == NULL) {\n\t\treturn NULL;\n\t}\n\tmemset(l->buffer, 0, l->bufsize);\n\tl->current = T_INIT;\n\treturn l;\n}", "path": "src\\lexer.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Creates a new Table object.\n */\n", "func_signal": "OBJ\nTable_create_(CzState *cz)", "code": "{\n\tCzTable *self = CZ_MAKE_OBJECT(Table);\n\tself->prime   = 0;\n\tself->size    = 0;\n\tself->cap     = primes[0];\n\tself->items   = (OBJ*)CZ_CALLOC(self->cap, sizeof(OBJ));\n\treturn (OBJ)self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Creates and returns an empty quotation.\n */\n", "func_signal": "OBJ\nQuotation_create_(CzState *cz)", "code": "{\n\tCzQuotation *q = CZ_MAKE_OBJECT(Quotation);\n\tq->size  = 0;\n\tq->cap   = 1;\n\tq->items = CZ_ALLOC_N(OBJ, 1);\n\treturn (OBJ)q;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Swaps the last two elements in a quotation.\n */\n", "func_signal": "OBJ\nQuotation_swap_(CzState *cz, CzQuotation *self)", "code": "{\n\tOBJ o1, o2;\n\tif (self->size < 2) {\n\t\treturn CZ_UNDEFINED;\n\t}\n\to1 = Quotation_pop_(cz, self);\n\to2 = Quotation_pop_(cz, self);\n\tQuotation_push_(cz, self, o1);\n\tQuotation_push_(cz, self, o2);\n\treturn (OBJ)self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Inserts a pair by pre-calculated hash into the table.\n * Reserved mostly for internal use.\n */\n", "func_signal": "OBJ\nTable_insert_pair_(CzState *cz, CzTable *self, CzPair *pair)", "code": "{\n\tsize_t i;\n\t\n\tif ((++(self->size) / self->cap) > 0.7) {\n\t\tTable_resize_(cz, self);\n\t}\n\ti = (size_t)(pair->key_hash) % self->cap;\n\tpair->next = CZ_AS(Pair, self->items[i]);\n\tself->items[i] = (OBJ)pair;\n\treturn (OBJ)self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * ( C T F -- [C? T: F] )\n * If conditional C is true, call quotation T.\n * Otherwise, call quotation F.\n */\n", "func_signal": "OBJ\nQuotation_if(CzState *cz, OBJ self)", "code": "{\n\tOBJ other, cond;\n\tother = CZ_POP();\n\tcond = CZ_POP();\n\tCZ_PUSH((cond == CZ_FALSE) ? self : other);\n\tsend2(CZ_SYMBOL(\"call\"));\n\treturn self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Inserts anything into the table.\n * This is super dangerous.\n * Also super useful.\n */\n", "func_signal": "OBJ\nTable_insert_(CzState *cz, CzTable *self, OBJ hash, OBJ key, OBJ value)", "code": "{\n\tOBJ pair;\n\tpair = Pair_create_(cz, (OBJ)hash, (OBJ)key, (OBJ)value);\n\tTable_insert_pair_(cz, self, CZ_AS(Pair, pair));\n\treturn (OBJ)self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Returns the value associated with the key from the table.\n */\n", "func_signal": "OBJ\nTable_lookup(CzState *cz, OBJ self)", "code": "{\n\tOBJ key, hash;\n\tCzPair *pair;\n\t\n\tkey = CZ_POP();\n\n\thash = send(key, CZ_SYMBOL(\"hash\"));\n\tpair = CZ_AS(Pair, CZ_AS(Table, self)->items[hash % CZ_AS(Table, self)->cap]);\n\twhile (!CZ_IS_NIL(pair)) {\n\t\tif (send(pair->key, CZ_SYMBOL(\"equals\"), key) == CZ_TRUE) {\n\t\t\tCZ_PUSH(pair->value);\n\t\t\treturn pair->value;\n\t\t}\n\t\tpair = CZ_AS(Pair, pair->next);\n\t}\n\tCZ_PUSH(CZ_NIL);\n\treturn CZ_UNDEFINED;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Removes the top object from a quotation.\n * This is unsafe.\n * Don't fuck around.\n */\n", "func_signal": "OBJ\nQuotation_drop_(CzState *cz, CzQuotation *self)", "code": "{\n\tself->size--;\n\treturn (OBJ)self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Returns the last element of a quotation.\n * Also removes that element from it.\n */\n", "func_signal": "OBJ\nQuotation_pop_(CzState *cz, CzQuotation *self)", "code": "{\n\tif (self->size <= 0) {\n\t\tprintf(\"stack underflow\\n\");\n\t\treturn CZ_UNDEFINED;\n\t}\n\treturn self->items[--(self->size)];\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Concatenates two quotations.\n * Equal to functional composition.\n * TODO: Less naive implementation, O(N) is no good.\n */\n", "func_signal": "OBJ\nQuotation_concat_(CzState *cz, CzQuotation *self, CzQuotation *other)", "code": "{\n\tint i;\n\tfor (i = 0; i < other->size; i++) {\n\t\tQuotation_push_(cz, self, other->items[i]);\n\t}\n\treturn (OBJ)self;\n}", "path": "src\\quotation.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Bootstraps the Fixnum type\n */\n", "func_signal": "void\ncz_bootstrap_fixnum(CzState *cz)", "code": "{\n\tCZ_VTABLE(Fixnum) = VTable_delegated_(cz, CZ_VTABLE(Object));\n\tcz_define_method(Fixnum, \"add\", Fixnum_add);\n\tcz_define_method(Fixnum, \"+\", Fixnum_add);\n\tcz_define_method(Fixnum, \"sub\", Fixnum_subtract);\n\tcz_define_method(Fixnum, \"-\", Fixnum_subtract);\n\tcz_define_method(Fixnum, \"mul\", Fixnum_multiply);\n\tcz_define_method(Fixnum, \"*\", Fixnum_multiply);\n\tcz_define_method(Fixnum, \"div\", Fixnum_divide);\n\tcz_define_method(Fixnum, \"/\", Fixnum_divide);\n\tcz_define_method(Fixnum, \"lt\", Fixnum_less_than);\n\tcz_define_method(Fixnum, \"<\", Fixnum_less_than);\n\tcz_define_method(Fixnum, \"gt\", Fixnum_greater_than);\n\tcz_define_method(Fixnum, \">\", Fixnum_greater_than);\n\tcz_define_method(Fixnum, \"to-string\", Fixnum_to_string);\n}", "path": "src\\number.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/*\n * Associates an object key with a value in the table.\n * ( V K T -- T )\n */\n", "func_signal": "OBJ\nTable_insert(CzState *cz, OBJ self)", "code": "{\n\tOBJ key, value, hash, pair;\n\t\n\tkey = CZ_POP();\n\tvalue = CZ_POP();\n\t\n\thash = send(key, CZ_SYMBOL(\"hash\"));\n\tpair = Pair_create_(cz, hash, hash, value);\n\tTable_insert_pair_(cz, CZ_AS(Table, self), CZ_AS(Pair, pair));\n\t\n\tCZ_PUSH(self);\n\t\n\treturn self;\n}", "path": "src\\table.c", "repo_name": "jdp/compoze", "stars": 8, "license": "isc", "language": "c", "size": 188}
{"docstring": "/****************************************************************************/\n", "func_signal": "static void\nprint_board(int width, int height)", "code": "{\n    int x, y;\n    char **board, spacing[2], dashing[2];\n\n    board = c4_board();\n\n    spacing[1] = dashing[1] = '\\0';\n    if (width > 19) {\n        spacing[0] = '\\0';\n        dashing[0] = '\\0';\n    }\n    else {\n        spacing[0] = ' ';\n        dashing[0] = '-';\n    }\n\n    printf(\"\\n\");\n    for (y=height-1; y>=0; y--) {\n\n        printf(\"|\");\n        for (x=0; x<width; x++) {\n            if (board[x][y] == C4_NONE)\n                printf(\"%s %s|\", spacing, spacing);\n            else\n                printf(\"%s%c%s|\", spacing, piece[(int)board[x][y]], spacing);\n        }\n        printf(\"\\n\");\n\n        printf(\"+\");\n        for (x=0; x<width; x++)\n            printf(\"%s-%s+\", dashing, dashing);\n        printf(\"\\n\");\n    }\n\n    printf(\" \");\n    for (x=0; x<width; x++)\n        printf(\"%s%d%s \", spacing, (x>8)?(x+1)/10:x+1, spacing);\n    if (width > 9) {\n        printf(\"\\n \");\n        for (x=0; x<width; x++)\n            printf(\"%s%c%s \", spacing, (x>8)?'0'+(x+1)-((x+1)/10)*10:' ',\n                              spacing);\n    }\n    printf(\"\\n\\n\");\n}", "path": "originalAlgorithm\\game.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function resets the state of the algorithm to the starting state **/\n/**  (i.e., no game in progress and a NULL poll function).  There should   **/\n/**  no reason to call this function unless for some reason the calling    **/\n/**  algorithm loses track of the game state.  It is illegal to call any   **/\n/**  other game function immediately after this one except for             **/\n/**  c4_new_game(), c4_poll() and c4_reset().                              **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "void\nc4_reset(void)", "code": "{\n    assert(!move_in_progress);\n    if (game_in_progress)\n        c4_end_game();\n    poll_function = NULL;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function updates the score of the specified player in the        **/\n/**  context of the current state,  given that the player has just placed  **/\n/**  a game piece in column x, row y.                                      **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static void\nupdate_score(int player, int x, int y)", "code": "{\n    register int i;\n    int win_index;\n    int this_difference = 0, other_difference = 0;\n    int **current_score_array = current_state->score_array;\n    int other_player = other(player);\n\n    for (i=0; map[x][y][i] != -1; i++) {\n        win_index = map[x][y][i];\n        this_difference += current_score_array[player][win_index];\n        other_difference += current_score_array[other_player][win_index];\n\n        current_score_array[player][win_index] <<= 1;\n        current_score_array[other_player][win_index] = 0;\n\n        if (current_score_array[player][win_index] == magic_win_number)\n            if (current_state->winner == C4_NONE)\n                current_state->winner = player;\n    }\n\n    current_state->score[player] += this_difference;\n    current_state->score[other_player] -= other_difference;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/**  corresponds to the number of \"moves\" in the game, where each player's **/\n/**  turn is considered a move.  A value of TRUE is returned if a move was **/\n/**  made, or FALSE otherwise (i.e. if the board is full).  If a move was  **/\n/**  made, the column and row where the piece ended up is returned through **/\n/**  the column and row pointers (unless a pointer is NULL, in which case  **/\n/**  it won't be used to return any information).  Note that column and    **/\n/**  row numbering start at 0.  Also note that for a standard 7x6 game of  **/\n/**  Connect-4, the computer is brain-dead at levels of three or less,     **/\n/**  while at levels of four or more the computer provides a challenge.    **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "Boolean\nc4_auto_move(int player, int level, int *column, int *row)", "code": "{\n    int i, best_column = -1, goodness = 0, best_worst = -(INT_MAX);\n    int num_of_equal = 0, real_player, current_column, result;\n\n    assert(game_in_progress);\n    assert(!move_in_progress);\n    assert(level >= 1 && level <= C4_MAX_LEVEL);\n\n    real_player = real_player(player);\n\n    /* It has been proven that the best first move for a standard 7x6 game  */\n    /* of connect-4 is the center column.  See Victor Allis' masters thesis */\n    /* (\"ftp://ftp.cs.vu.nl/pub/victor/connect4.ps\") for this proof.        */\n\n    if (current_state->num_of_pieces < 2 &&\n                        size_x == 7 && size_y == 6 && num_to_connect == 4 &&\n                        (current_state->num_of_pieces == 0 ||\n                         current_state->board[3][0] != C4_NONE)) {\n        if (column)\n            *column = 3;\n        if (row)\n            *row = current_state->num_of_pieces;\n        drop_piece(real_player, 3);\n        return TRUE;\n    }\n\n    move_in_progress = TRUE;\n\n    /* Simulate a drop in each of the columns and see what the results are. */\n\n    for (i=0; i<size_x; i++) {\n        push_state();\n        current_column = drop_order[i];\n\n        /* If this column is full, ignore it as a possibility. */\n        if (drop_piece(real_player, current_column) < 0) {\n            pop_state();\n            continue;\n        }\n\n        /* If this drop wins the game, take it! */\n        else if (current_state->winner == real_player) {\n            best_column = current_column;\n            pop_state();\n            break;\n        }\n\n        /* Otherwise, look ahead to see how good this move may turn out */\n        /* to be (assuming the opponent makes the best moves possible). */\n        else {\n            next_poll = clock() + poll_interval;\n            goodness = evaluate(real_player, level, -(INT_MAX), -best_worst);\n        }\n\n        /* If this move looks better than the ones previously considered, */\n        /* remember it.                                                   */\n        if (goodness > best_worst) {\n            best_worst = goodness;\n            best_column = current_column;\n            num_of_equal = 1;\n        }\n\n        /* If two moves are equally as good, make a random decision. */\n        else if (goodness == best_worst) {\n            num_of_equal++;\n            if (rand()%10000 < ((float)1/(float)num_of_equal) * 10000)\n                best_column = current_column;\n        }\n\n        pop_state();\n    }\n\n    move_in_progress = FALSE;\n\n    /* Drop the piece in the column decided upon. */\n\n    if (best_column >= 0) {\n        result = drop_piece(real_player, best_column);\n        if (column)\n            *column = best_column;\n        if (row)\n            *row = result;\n        return TRUE;\n    }\n    else\n        return FALSE;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n", "func_signal": "static int\nget_num(char *prompt, int lower, int upper, int default_value)", "code": "{\n    int number = -1;\n    int result;\n    static char numbuf[40];\n\n    do {\n        if (default_value != -1)\n            printf(\"%s [%d]? \", prompt, default_value);\n        else\n            printf(\"%s? \", prompt);\n\n        if (!fgets(numbuf, 40, stdin) || numbuf[0] == 'q') {\n            printf(\"\\nGoodbye!\\n\");\n            exit(0);\n        }\n        result = sscanf(numbuf, \"%d\", &number);\n    } while (result == 0 || (result != EOF && (number<lower || number>upper)));\n\n    return (result == EOF? default_value : number);\n}", "path": "originalAlgorithm\\game.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function returns TRUE if the specified player has won the game,  **/\n/**  and FALSE otherwise.                                                  **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "Boolean\nc4_is_winner(int player)", "code": "{\n    assert(game_in_progress);\n    return (current_state->winner == real_player(player));\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/**                                                                        **/\n/**  If no polling is required, the poll function can be specified as      **/\n/**  NULL.  This is the default.                                           **/\n/**                                                                        **/\n/**  This function can be called an arbitrary number of times throughout   **/\n/**  any game.                                                             **/\n/**                                                                        **/\n/**  It is illegal for the specified poll function to call the functions   **/\n/**  c4_make_move(), c4_auto_move(), c4_end_game() or c4_reset().          **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "void\nc4_poll(void (*poll_func)(void), clock_t interval)", "code": "{\n    poll_function = poll_func;\n    poll_interval = interval;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function returns the \"score\" of the specified player.  This      **/\n/**  score is a function of how many winning positions are still available **/\n/**  to the player and how close he/she is to achieving each of these      **/\n/**  positions.  The scores of both players can be compared to observe how **/\n/**  well they are doing relative to each other.                           **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "int\nc4_score_of_player(int player)", "code": "{\n    assert(game_in_progress);\n    return current_state->score[real_player(player)];\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function ends the current game.  It is assumed that a game is    **/\n/**  in progress.  It is illegal to call any other game function           **/\n/**  immediately after this one except for c4_new_game(), c4_poll() and    **/\n/**  c4_reset().                                                           **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "void\nc4_end_game(void)", "code": "{\n    int i, j;\n\n    assert(game_in_progress);\n    assert(!move_in_progress);\n\n    /* Free up the memory used by the map. */\n\n    for (i=0; i<size_x; i++) {\n        for (j=0; j<size_y; j++)\n            free(map[i][j]);\n        free(map[i]);\n    }\n    free(map);\n\n    /* Free up the memory of all the states used. */\n\n    for (i=0; i<states_allocated; i++) {\n        for (j=0; j<size_x; j++)\n            free(state_stack[i].board[j]);\n        free(state_stack[i].board);\n        free(state_stack[i].score_array[0]);\n        free(state_stack[i].score_array[1]);\n    }\n    states_allocated = 0;\n\n    /* Free up the memory used by the drop_order array. */\n\n    free(drop_order);\n\n    game_in_progress = FALSE;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function drops a piece of the specified player into the          **/\n/**  specified column.  A value of TRUE is returned if the drop is         **/\n/**  successful, or FALSE otherwise.  A drop is unsuccessful if the        **/\n/**  specified column number is invalid or full.  If the drop is           **/\n/**  successful and row is a non-NULL pointer, the row where the piece     **/\n/**  ended up is returned through the row pointer.  Note that column and   **/\n/**  row numbering start at 0.                                             **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "Boolean\nc4_make_move(int player, int column, int *row)", "code": "{\n    int result; \n\n    assert(game_in_progress);\n    assert(!move_in_progress);\n\n    if (column >= size_x || column < 0)\n        return FALSE;\n\n    result = drop_piece(real_player(player), column);\n    if (row && result >= 0)\n        *row = result;\n    return (result >= 0);\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function returns the number of possible win positions on a board **/\n/**  of dimensions x by y with n being the number of pieces required in a  **/\n/**  row in order to win.                                                  **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static int\nnum_of_win_places(int x, int y, int n)", "code": "{\n    if (x < n && y < n)\n        return 0;\n    else if (x < n)\n        return x * ((y-n)+1);\n    else if (y < n)\n        return y * ((x-n)+1);\n    else\n        return 4*x*y - 3*x*n - 3*y*n + 3*x + 3*y - 4*n + 2*n*n + 2;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function drops a piece of the specified player into the          **/\n/**  specified column.  The row where the piece ended up is returned, or   **/\n/**  -1 if the drop was unsuccessful (i.e., the specified column is full). **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static int\ndrop_piece(int player, int column)", "code": "{\n    int y = 0;\n\n    while (current_state->board[column][y] != C4_NONE && ++y < size_y)\n        ;\n\n    if (y == size_y)\n        return -1;\n\n    current_state->board[column][y] = player;\n    current_state->num_of_pieces++;\n    update_score(player, column, y);\n\n    return y;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function returns the coordinates of the winning connections of   **/\n/**  the winning player.  It is assumed that a player has indeed won the   **/\n/**  game.  The coordinates are returned in x1, y1, x2, y2, where (x1, y1) **/\n/**  specifies the lower-left piece of the winning connection, and         **/\n/**  (x2, y2) specifies the upper-right piece of the winning connection.   **/\n/**  If more than one winning connection exists, only one will be          **/\n/**  returned.                                                             **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "void\nc4_win_coords(int *x1, int *y1, int *x2, int *y2)", "code": "{\n    register int i, j, k;\n    int winner, win_pos = 0;\n    Boolean found;\n\n    assert(game_in_progress);\n\n    winner = current_state->winner;\n    assert(winner != C4_NONE);\n\n    while (current_state->score_array[winner][win_pos] != magic_win_number)\n        win_pos++;\n\n    /* Find the lower-left piece of the winning connection. */\n\n    found = FALSE;\n    for (j=0; j<size_y && !found; j++)\n        for (i=0; i<size_x; i++)\n            for (k=0; map[i][j][k] != -1; k++)\n                if (map[i][j][k] == win_pos) {\n                    *x1 = i;\n                    *y1 = j;\n                    found = TRUE;\n                    break;\n                }\n\n    /* Find the upper-right piece of the winning connection. */\n\n    found = FALSE;\n    for (j=size_y-1; j>=0 && !found; j--)\n        for (i=size_x-1; i>=0; i--)\n            for (k=0; map[i][j][k] != -1; k++)\n                if (map[i][j][k] == win_pos) {\n                    *x2 = i;\n                    *y2 = j;\n                    found = TRUE;\n                    break;\n                }\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/**                                                                        **/\n/**  Technically what it does, since the current state is considered to    **/\n/**  be the top of the stack, is push a copy of the current state onto     **/\n/**  the stack right above it.  The stack pointer (depth) is then          **/\n/**  incremented so that the new copy is considered to be the current      **/\n/**  state.  That way, all pop_state() has to do is decrement the stack    **/\n/**  pointer.                                                              **/\n/**                                                                        **/\n/**  For efficiency, memory for each stack state used is only allocated    **/\n/**  once per game, and reused for the remainder of the game.              **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static void\npush_state(void)", "code": "{\n    register int i, win_places_array_size;\n    Game_state *old_state, *new_state;\n\n    win_places_array_size = win_places * sizeof(int);\n    old_state = &state_stack[depth++];\n    new_state = &state_stack[depth];\n\n    if (depth == states_allocated) {\n\n        /* Allocate space for the board */\n\n        new_state->board = (char **) emalloc(size_x * sizeof(char *));\n        for (i=0; i<size_x; i++)\n            new_state->board[i] = (char *) emalloc(size_y);\n\n        /* Allocate space for the score array */\n\n        new_state->score_array[0] = (int *) emalloc(win_places_array_size);\n        new_state->score_array[1] = (int *) emalloc(win_places_array_size);\n\n        states_allocated++;\n    }\n\n    /* Copy the board */\n\n    for (i=0; i<size_x; i++)\n        memcpy(new_state->board[i], old_state->board[i], size_y);\n\n    /* Copy the score array */\n\n    memcpy(new_state->score_array[0], old_state->score_array[0],\n           win_places_array_size);\n    memcpy(new_state->score_array[1], old_state->score_array[1],\n           win_places_array_size);\n\n    new_state->score[0] = old_state->score[0];\n    new_state->score[1] = old_state->score[1];\n    new_state->winner = old_state->winner;\n\n    current_state = new_state;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/**  to reflect the state of the game as the game progresses.  It becomes  **/\n/**  and stays undefined when the game ends.                               **/\n/**                                                                        **/\n/**  The first dimension specifies the column number and the second        **/\n/**  dimension specifies the row number, where column and row numbering    **/\n/**  start at 0 and the bottow row is considered the 0th row.  A value of  **/\n/**  0 specifies that the position is occupied by a piece owned by player  **/\n/**  0, a value of 1 specifies that the position is occupied by a piece    **/\n/**  owned by player 1, and a value of C4_NONE specifies that the position **/\n/**  is unoccupied.                                                        **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "char **\nc4_board(void)", "code": "{\n    assert(game_in_progress);\n    return current_state->board;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/**  avoid searching unneccessary paths.                                   **/\n/**                                                                        **/\n/**  The specified poll function (if any) is called at the appropriate     **/\n/**  intervals.                                                            **/\n/**                                                                        **/\n/**  The worst goodness that the current state can produce in the number   **/\n/**  of moves (levels) searched is returned.  This is the best the         **/\n/**  specified player can hope to achieve with this state (since it is     **/\n/**  assumed that the opponent will make the best moves possible).         **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static int\nevaluate(int player, int level, int alpha, int beta)", "code": "{\n    int i, goodness, best, maxab;\n\n    if (poll_function && next_poll <= clock()) {\n        next_poll += poll_interval;\n        (*poll_function)();\n    }\n\n    if (level == depth)\n        return goodness_of(player);\n    else {\n        /* Assume it is the other player's turn. */\n        best = -(INT_MAX);\n        maxab = alpha;\n        for(i=0; i<size_x; i++) {\n            push_state();\n            if (drop_piece(other(player), drop_order[i]) < 0) {\n                pop_state();\n                continue;\n            }\n            else if (current_state->winner == other(player))\n                goodness = INT_MAX - depth;\n            else\n                goodness = evaluate(other(player), level, -beta, -maxab);\n            if (goodness > best) {\n                best = goodness;\n                if (best > maxab)\n                    maxab = best;\n            }\n            pop_state();\n            if (best > beta)\n                break;\n        }\n\n        /* What's good for the other player is bad for this one. */\n        return -best;\n    }\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n", "func_signal": "static void\nprint_dot(void)", "code": "{\n    printf(\".\");\n    fflush(stdout);\n}", "path": "originalAlgorithm\\game.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  A safer version of malloc().                                          **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "static void *\nemalloc(unsigned int n)", "code": "{\n    void *ptr;\n\n    ptr = (void *) malloc(n);\n    if (ptr == NULL) {\n        fprintf(stderr, \"c4: emalloc() - Can't allocate %d bytes.\\n\", n);\n        exit(1);\n    }\n    return ptr;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function returns TRUE if the board is completely full, and FALSE **/\n/**  otherwise.                                                            **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "Boolean\nc4_is_tie()", "code": "{\n    assert(game_in_progress);\n    return (current_state->num_of_pieces == size_x * size_y);\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/****************************************************************************/\n/**                                                                        **/\n/**  This function sets up a new game.  This must be called exactly once   **/\n/**  before each game is started.  Before it can be called a second time,  **/\n/**  end_game() must be called to destroy the previous game.               **/\n/**                                                                        **/\n/**  width and height are the desired dimensions of the game board, while  **/\n/**  num is the number of pieces required to connect in a row in order to  **/\n/**  win the game.                                                         **/\n/**                                                                        **/\n/****************************************************************************/\n", "func_signal": "void\nc4_new_game(int width, int height, int num)", "code": "{\n    register int i, j, k, x;\n    int win_index, column;\n    int *win_indices;\n\n    assert(!game_in_progress);\n    assert(width >= 1 && height >= 1 && num >= 1);\n\n    size_x = width;\n    size_y = height;\n    num_to_connect = num;\n    magic_win_number = 1 << num_to_connect;\n    win_places = num_of_win_places(size_x, size_y, num_to_connect);\n\n    /* Set up a random seed for making random decisions when there is */\n    /* equal goodness between two moves.                              */\n\n    if (!seed_chosen) {\n        srand((unsigned int) time((time_t *) 0));\n        seed_chosen = TRUE;\n    }\n\n    /* Set up the board */\n\n    depth = 0;\n    current_state = &state_stack[0];\n\n    current_state->board = (char **) emalloc(size_x * sizeof(char *));\n    for (i=0; i<size_x; i++) {\n        current_state->board[i] = (char *) emalloc(size_y);\n        for (j=0; j<size_y; j++)\n            current_state->board[i][j] = C4_NONE;\n    }\n\n    /* Set up the score array */\n\n    current_state->score_array[0] = (int *) emalloc(win_places * sizeof(int));\n    current_state->score_array[1] = (int *) emalloc(win_places * sizeof(int));\n    for (i=0; i<win_places; i++) {\n        current_state->score_array[0][i] = 1;\n        current_state->score_array[1][i] = 1;\n    }\n\n    current_state->score[0] = current_state->score[1] = win_places;\n    current_state->winner = C4_NONE;\n    current_state->num_of_pieces = 0;\n\n    states_allocated = 1;\n\n    /* Set up the map */\n\n    map = (int ***) emalloc(size_x * sizeof(int **));\n    for (i=0; i<size_x; i++) {\n        map[i] = (int **) emalloc(size_y * sizeof(int *));\n        for (j=0; j<size_y; j++) {\n            map[i][j] = (int *) emalloc((num_to_connect*4 + 1) * sizeof(int));\n            map[i][j][0] = -1;\n        }\n    }\n\n    win_index = 0;\n\n    /* Fill in the horizontal win positions */\n    for (i=0; i<size_y; i++)\n        for (j=0; j<size_x-num_to_connect+1; j++) {\n            for (k=0; k<num_to_connect; k++) {\n                win_indices = map[j+k][i];\n                for (x=0; win_indices[x] != -1; x++)\n                    ;\n                win_indices[x++] = win_index;\n                win_indices[x] = -1;\n            }\n            win_index++;\n        }\n\n    /* Fill in the vertical win positions */\n    for (i=0; i<size_x; i++)\n        for (j=0; j<size_y-num_to_connect+1; j++) {\n            for (k=0; k<num_to_connect; k++) {\n                win_indices = map[i][j+k];\n                for (x=0; win_indices[x] != -1; x++)\n                    ;\n                win_indices[x++] = win_index;\n                win_indices[x] = -1;\n            }\n            win_index++;\n        }\n\n    /* Fill in the forward diagonal win positions */\n    for (i=0; i<size_y-num_to_connect+1; i++)\n        for (j=0; j<size_x-num_to_connect+1; j++) {\n            for (k=0; k<num_to_connect; k++) {\n                win_indices = map[j+k][i+k];\n                for (x=0; win_indices[x] != -1; x++)\n                    ;\n                win_indices[x++] = win_index;\n                win_indices[x] = -1;\n            }\n            win_index++;\n        }\n\n    /* Fill in the backward diagonal win positions */\n    for (i=0; i<size_y-num_to_connect+1; i++)\n        for (j=size_x-1; j>=num_to_connect-1; j--) {\n            for (k=0; k<num_to_connect; k++) {\n                win_indices = map[j-k][i+k];\n                for (x=0; win_indices[x] != -1; x++)\n                    ;\n                win_indices[x++] = win_index;\n                win_indices[x] = -1;\n            }\n            win_index++;\n        }\n\n    /* Set up the order in which automatic moves should be tried. */\n    /* The columns nearer to the center of the board are usually  */\n    /* better tactically and are more likely to lead to a win.    */\n    /* By ordering the search such that the central columns are   */\n    /* tried first, alpha-beta cutoff is much more effective.     */\n\n    drop_order = (int *) emalloc(size_x * sizeof(int));\n    column = (size_x-1) / 2;\n    for (i=1; i<=size_x; i++) {\n        drop_order[i-1] = column;\n        column += ((i%2)? i : -i);\n    }\n\n    game_in_progress = TRUE;\n}", "path": "originalAlgorithm\\c4.c", "repo_name": "brandonaaron/connect4js", "stars": 14, "license": "other", "language": "c", "size": 114}
{"docstring": "/* 224.0.0.5 */\n", "func_signal": "void die( const char* format, ... )", "code": "{\n    va_list args;\n    va_start( args, format );\n\n    vfprintf( stderr, format, args );\n    fprintf( stderr, \"\\n\" );\n\n    va_end( args );\n    assert( 0 );\n    exit( 1 );\n}", "path": "cli\\helper.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nicmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)", "code": "{\n  struct pbuf *q;\n  struct ip_hdr *iphdr;\n  struct icmp_dur_hdr *idur;\n  \n  q = pbuf_alloc(PBUF_TRANSPORT, 8 + IP_HLEN + 8, PBUF_RAM);\n  /* ICMP header + IP header + 8 bytes of data */\n\n  iphdr = p->payload;\n  \n  idur = q->payload;\n  ICMPH_TYPE_SET(idur, ICMP_DUR);\n  ICMPH_CODE_SET(idur, t);\n\n  bcopy(p->payload, (char *)q->payload + 8, IP_HLEN + 8);\n  \n  /* calculate checksum */\n  idur->chksum = 0;\n  idur->chksum = inet_chksum(idur, q->len);\n#ifdef ICMP_STATS\n  ++stats.icmp.xmit;\n#endif /* ICMP_STATS */\n\n  ip_output(q, NULL, &(iphdr->src),\n\t    ICMP_TTL, IP_PROTO_ICMP);\n  pbuf_free(q);\n}", "path": "lwtcp\\ipv4\\icmp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nicmp_input(struct pbuf *p, struct netif *inp)", "code": "{\n  unsigned char type;\n  struct icmp_echo_hdr *iecho;\n  struct ip_hdr *iphdr;\n  struct ip_addr tmpaddr;\n  uint16_t hlen;\n  \n#ifdef ICMP_STATS\n  ++stats.icmp.recv;\n#endif /* ICMP_STATS */\n\n  \n  iphdr = p->payload;\n  hlen = IPH_HL(iphdr) * 4/sizeof(uint8_t);\n  pbuf_header(p, -hlen);\n\n  type = *((uint8_t *)p->payload);\n\n  switch(type) {\n  case ICMP_ECHO:\n    if(ip_addr_isbroadcast(&iphdr->dest, &inp->netmask) ||\n       ip_addr_ismulticast(&iphdr->dest)) {\n      DEBUGF(ICMP_DEBUG, (\"Smurf.\\n\"));\n#ifdef ICMP_STATS\n      ++stats.icmp.err;\n#endif /* ICMP_STATS */\n      pbuf_free(p);\n      return;\n    }\n    DEBUGF(ICMP_DEBUG, (\"icmp_input: ping\\n\"));\n    DEBUGF(DEMO_DEBUG, (\"Pong!\\n\"));\n    if(p->tot_len < sizeof(struct icmp_echo_hdr)) {\n      DEBUGF(ICMP_DEBUG, (\"icmp_input: bad ICMP echo received\\n\"));\n      pbuf_free(p);\n#ifdef ICMP_STATS\n      ++stats.icmp.lenerr;\n#endif /* ICMP_STATS */\n\n      return;      \n    }\n    iecho = p->payload;    \n    if(inet_chksum_pbuf(p) != 0) {\n      DEBUGF(ICMP_DEBUG, (\"icmp_input: checksum failed for received ICMP echo\\n\"));\n      pbuf_free(p);\n#ifdef ICMP_STATS\n      ++stats.icmp.chkerr;\n#endif /* ICMP_STATS */\n      return;\n    }\n    tmpaddr.addr = iphdr->src.addr;\n    iphdr->src.addr = iphdr->dest.addr;\n    iphdr->dest.addr = tmpaddr.addr;\n    ICMPH_TYPE_SET(iecho, ICMP_ER);\n    /* adjust the checksum */\n    if(iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {\n      iecho->chksum += htons(ICMP_ECHO << 8) + 1;\n    } else {\n      iecho->chksum += htons(ICMP_ECHO << 8);\n    }\n#ifdef ICMP_STATS\n    ++stats.icmp.xmit;\n#endif /* ICMP_STATS */\n\n    pbuf_header(p, hlen);\n    ip_output_if(p, &(iphdr->src), IP_HDRINCL,\n\t\t IPH_TTL(iphdr), IP_PROTO_ICMP, inp);\n    break; \n  default:\n    DEBUGF(ICMP_DEBUG, (\"icmp_input: ICMP type not supported.\\n\"));\n#ifdef ICMP_STATS\n    ++stats.icmp.proterr;\n    ++stats.icmp.drop;\n#endif /* ICMP_STATS */\n  }\n  pbuf_free(p);\n}", "path": "lwtcp\\ipv4\\icmp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_pcb_remove():\n *\n * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)", "code": "{\n  TCP_RMV(pcblist, pcb);\n\n  tcp_pcb_purge(pcb);\n  \n  /* if there is an outstanding delayed ACKs, send it */\n  if(pcb->state != TIME_WAIT &&\n     pcb->state != LISTEN &&\n     pcb->flags & TF_ACK_DELAY) {\n    pcb->flags |= TF_ACK_NOW;\n    tcp_output(pcb);\n  }  \n  pcb->state = CLOSED;\n\n  ASSERT(\"tcp_pcb_remove: tcp_pcbs_sane()\", tcp_pcbs_sane());\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_pcb_purge():\n *\n * Purges a TCP PCB. Removes any buffered data and frees the buffer memory.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_pcb_purge(struct tcp_pcb *pcb)", "code": "{\n  if(pcb->state != CLOSED &&\n     pcb->state != TIME_WAIT &&\n     pcb->state != LISTEN) {\n\n#if TCP_DEBUG\n    if(pcb->unsent != NULL) {    \n      DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: not all data sent\\n\"));\n    }\n    if(pcb->unacked != NULL) {    \n      DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: data left on ->unacked\\n\"));\n    }\n    if(pcb->ooseq != NULL) {    \n      DEBUGF(TCP_DEBUG, (\"tcp_pcb_purge: data left on ->ooseq\\n\"));\n    }\n#endif /* TCP_DEBUG */\n    tcp_segs_free(pcb->unsent);\n#if TCP_QUEUE_OOSEQ\n    tcp_segs_free(pcb->ooseq);\n#endif /* TCP_QUEUE_OOSEQ */\n    tcp_segs_free(pcb->unacked);\n    pcb->unacked = pcb->unsent =\n#if TCP_QUEUE_OOSEQ\n      pcb->ooseq =\n#endif /* TCP_QUEUE_OOSEQ */\n      NULL;\n  }\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_connect():\n *\n * Connects to another host. The function given as the \"connected\"\n * argument will be called when the connection has been established.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\ntcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, uint16_t port,\n\t    err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))", "code": "{\n  uint32_t optdata;\n  err_t ret;\n  uint32_t iss;\n\n  DEBUGF(TCP_DEBUG, (\"tcp_connect to port %d\\n\", port));\n  if(ipaddr != NULL) {\n    pcb->remote_ip = *ipaddr;\n  } else {\n    return ERR_VAL;\n  }\n  pcb->remote_port = port;\n  if(pcb->local_port == 0) {\n    pcb->local_port = tcp_new_port();\n  }\n  iss = tcp_next_iss();\n  pcb->rcv_nxt = 0;\n  pcb->snd_nxt = iss;\n  pcb->lastack = iss - 1;\n  pcb->snd_lbb = iss - 1;\n  pcb->rcv_wnd = TCP_WND;\n  pcb->snd_wnd = TCP_WND;\n  pcb->mss = TCP_MSS;\n  pcb->cwnd = 1;\n  pcb->ssthresh = pcb->mss * 10;\n  pcb->state = SYN_SENT;\n  pcb->connected = connected;\n  TCP_REG(&tcp_active_pcbs, pcb);\n  \n  /* Build an MSS option */\n  optdata = HTONL(((uint32_t)2 << 24) | \n\t\t  ((uint32_t)4 << 16) | \n\t\t  (((uint32_t)pcb->mss / 256) << 8) |\n\t\t  (pcb->mss & 255));\n\n  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (uint8_t *)&optdata, 4);\n  if(ret == ERR_OK) { \n    tcp_output(pcb);\n  }\n  return ret;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/**\n * Wrapper for writenstr.  Tries to send the specified string with the\n * file-scope fd.  If it fails, fd_alive is set to 0.  Does nothing if\n * fd_alive is already 0.\n */\n", "func_signal": "static void cli_send_str( const char* str )", "code": "{\n    if( fd_alive )\n        if( 0 != writenstr( fd, str ) )\n            fd_alive = 0;\n}", "path": "cli\\cli.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_new():\n *\n * Creates a new TCP protocol control block but doesn't place it on\n * any of the TCP PCB lists.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "struct tcp_pcb *\ntcp_new(void)", "code": "{\n  struct tcp_pcb *pcb;\n  uint32_t iss;\n  \n  pcb = (struct tcp_pcb*)memp_malloc2(MEMP_TCP_PCB);\n  if(pcb != NULL) {\n    bzero(pcb, sizeof(struct tcp_pcb));\n    pcb->snd_buf = TCP_SND_BUF;\n    pcb->snd_queuelen = 0;\n    pcb->rcv_wnd = TCP_WND;\n    pcb->mss = TCP_MSS;\n    pcb->rto = 3000 / TCP_SLOW_INTERVAL;\n    pcb->sa = 0;\n    pcb->sv = 3000 / TCP_SLOW_INTERVAL;\n    pcb->rtime = 0;\n    pcb->cwnd = 1;\n    iss = tcp_next_iss();\n    pcb->snd_wl2 = iss;\n    pcb->snd_nxt = iss;\n    pcb->snd_max = iss;\n    pcb->lastack = iss;\n    pcb->snd_lbb = iss;   \n    pcb->tmr = tcp_ticks;\n\n    pcb->polltmr = 0;\n\n    return pcb;\n  }\n  return NULL;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_close():\n *\n * Closes the connection held by the PCB.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\ntcp_close(struct tcp_pcb *pcb)", "code": "{\n  err_t err;\n\n#if TCP_DEBUG\n  DEBUGF(TCP_DEBUG, (\"tcp_close: closing in state \"));\n  tcp_debug_print_state(pcb->state);\n  DEBUGF(TCP_DEBUG, (\"\\n\"));\n#endif /* TCP_DEBUG */\n  switch(pcb->state) {\n  case LISTEN:\n    err = ERR_OK;\n    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB_LISTEN, pcb);\n    pcb = NULL;\n    break;\n  case SYN_SENT:\n    err = ERR_OK;\n    tcp_pcb_remove(&tcp_active_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB, pcb);\n    pcb = NULL;\n    break;\n  case SYN_RCVD:\n    err = tcp_send_ctrl(pcb, TCP_FIN);\n    if(err == ERR_OK) {\n      pcb->state = FIN_WAIT_1;\n    }\n    break;\n  case ESTABLISHED:\n    err = tcp_send_ctrl(pcb, TCP_FIN);\n    if(err == ERR_OK) {\n      pcb->state = FIN_WAIT_1;\n    }\n    break;\n  case CLOSE_WAIT:\n    err = tcp_send_ctrl(pcb, TCP_FIN);\n    if(err == ERR_OK) {\n      pcb->state = LAST_ACK;\n    }\n    break;\n  default:\n    /* Has already been closed, do nothing. */\n    err = ERR_OK;\n    pcb = NULL;\n    break;\n  }\n\n  if(pcb != NULL && err == ERR_OK) {\n    err = tcp_output(pcb);\n  }\n  return err;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/**\n * Initialize sr for the standalone binary which just runs the CLI.\n */\n", "func_signal": "struct sr_instance* my_get_sr()", "code": "{\n    static struct sr_instance* sr = NULL;\n    if( ! sr ) {\n        sr = malloc( sizeof(*sr) );\n        true_or_die( sr!=NULL, \"malloc falied in my_get_sr\" );\n\n        fprintf( stderr, \"not yet implemented: my_get_sr does not create a value for sr->interface_subsystem\\n\" );\n        sr->interface_subsystem = NULL;\n\n        sr->topo_id = 0;\n        strncpy( sr->vhost, \"cli\", SR_NAMELEN );\n        strncpy( sr->user, \"cli mode (no client)\", SR_NAMELEN );\n        if( gethostname(sr->lhost,  SR_NAMELEN) == -1 )\n            strncpy( sr->lhost, \"cli mode (unknown localhost)\", SR_NAMELEN );\n\n        /* NOTE: you probably want to set some dummy values for the rtable and\n           interface list of your interface_subsystem here (preferably read them\n           from a file) */\n    }\n\n    return sr;\n}", "path": "cli\\cli.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcpip_apimsg(struct api_msg *apimsg)", "code": "{\n  struct tcpip_msg *msg;\n  msg = memp_mallocp(MEMP_TCPIP_MSG);\n  if(msg == NULL) {\n    memp_free(MEMP_TCPIP_MSG, apimsg);\n    return;\n  }\n  msg->type = TCPIP_MSG_API;\n  msg->msg.apimsg = apimsg;\n  sys_mbox_post(mbox, msg);\n}", "path": "lwtcp\\tcpip.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_fasttmr():\n *\n * Is called every TCP_FINE_TIMEOUT (100 ms) and sends delayed ACKs.\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_fasttmr(void)", "code": "{\n  struct tcp_pcb *pcb;\n\n  /* send delayed ACKs */  \n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    if(pcb->flags & TF_ACK_DELAY) {\n      DEBUGF(TCP_DEBUG, (\"tcp_timer_fine: delayed ACK\\n\"));\n      tcp_ack_now(pcb);\n      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);\n    }\n  }\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_next_iss():\n *\n * Calculates a new initial sequence number for new connections.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "uint32_t\ntcp_next_iss(void)", "code": "{\n  static uint32_t iss = 6510;\n  \n  iss += tcp_ticks;       /* XXX */\n  return iss;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_segs_free():\n *\n * Deallocates a list of TCP segments (tcp_seg structures).\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "uint8_t\ntcp_segs_free(struct tcp_seg *seg)", "code": "{\n  uint8_t count = 0;\n  struct tcp_seg *next;\n again:  \n  if(seg != NULL) {\n    next = seg->next;\n    count += tcp_seg_free(seg);\n    seg = next;\n    goto again;\n  }\n  return count;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "int\ntcp_pcbs_sane(void)", "code": "{\n  struct tcp_pcb *pcb;\n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != CLOSED\", pcb->state != CLOSED);\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != LISTEN\", pcb->state != LISTEN);\n    ASSERT(\"tcp_pcbs_sane: active pcb->state != TIME-WAIT\", pcb->state != TIME_WAIT);\n  }\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    ASSERT(\"tcp_pcbs_sane: tw pcb->state == TIME-WAIT\", pcb->state == TIME_WAIT);\n  }\n  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs; pcb != NULL; pcb = pcb->next) {\n    ASSERT(\"tcp_pcbs_sane: listen pcb->state == LISTEN\", pcb->state == LISTEN);\n  }\n  return 1;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_tmr():\n *\n * Called periodically to dispatch TCP timers.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_tmr()", "code": "{\n  ++tcp_timer;\n  if(tcp_timer == 10) {\n    tcp_timer = 0;\n  }\n  \n  if(tcp_timer & 1) {\n    /* Call tcp_fasttmr() every 200 ms, i.e., every other timer\n       tcp_tmr() is called. */\n    tcp_fasttmr();\n  }\n  if(tcp_timer == 0 || tcp_timer == 5) {\n    /* Call tcp_slowtmr() every 500 ms, i.e., every fifth timer\n       tcp_tmr() is called. */\n    tcp_slowtmr();\n  }\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_bind():\n *\n * Binds the connection to a local portnumber and IP address. If the\n * IP address is not given (i.e., ipaddr == NULL), the IP address of\n * the outgoing network interface is used instead.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\ntcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, uint16_t port)", "code": "{\n  struct tcp_pcb *cpcb;\n\n  /* Check if the address already is in use. */\n  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) {\n    if(cpcb->local_port == port) {\n      if(ip_addr_isany(&(cpcb->local_ip)) ||\n\t ip_addr_isany(ipaddr) ||\n\t ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {\n\treturn ERR_USE;\n      }\n    }\n  }\n  for(cpcb = tcp_active_pcbs;\n      cpcb != NULL; cpcb = cpcb->next) {\n    if(cpcb->local_port == port) {\n      if(ip_addr_isany(&(cpcb->local_ip)) ||\n\t ip_addr_isany(ipaddr) ||\n\t ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {\n\treturn ERR_USE;\n      }\n    }\n  }\n  if(!ip_addr_isany(ipaddr)) {\n    pcb->local_ip = *ipaddr;\n  }\n  pcb->local_port = port;\n  DEBUGF(TCP_DEBUG, (\"tcp_bind: bind to port %d\\n\", port));\n  return ERR_OK;\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/*\n * tcp_abort()\n *\n * Aborts a connection by sending a RST to the remote host and deletes\n * the local protocol control block. This is done when a connection is\n * killed because of shortage of memory.\n *\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_abort(struct tcp_pcb *pcb)", "code": "{\n  uint32_t seqno, ackno;\n  uint16_t remote_port, local_port;\n  struct ip_addr remote_ip, local_ip;\n  void (* errf)(void *arg, err_t err);\n  void *errf_arg;\n\n  \n  /* Figure out on which TCP PCB list we are, and remove us. If we\n     are in an active state, call the receive function associated with\n     the PCB with a NULL argument, and send an RST to the remote end. */\n  if(pcb->state == TIME_WAIT) {\n    tcp_pcb_remove(&tcp_tw_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB, pcb);\n  } else if(pcb->state == LISTEN) {\n    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB_LISTEN, pcb);\n  } else {\n    seqno = pcb->snd_nxt;\n    ackno = pcb->rcv_nxt;\n    ip_addr_set(&local_ip, &(pcb->local_ip));\n    ip_addr_set(&remote_ip, &(pcb->remote_ip));\n    local_port = pcb->local_port;\n    remote_port = pcb->remote_port;\n    errf = pcb->errf;\n    errf_arg = pcb->callback_arg;\n    tcp_pcb_remove(&tcp_active_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB, pcb);\n    if(errf != NULL) {\n      errf(errf_arg, ERR_ABRT);\n    }\n    DEBUGF(TCP_RST_DEBUG, (\"tcp_abort: sending RST\\n\"));\n    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);\n  }\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_debug_print_pcbs(void)", "code": "{\n  struct tcp_pcb *pcb;\n  DEBUGF(TCP_DEBUG, (\"Active PCB states:\\n\"));\n  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n  DEBUGF(TCP_DEBUG, (\"Listen PCB states:\\n\"));\n  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n  DEBUGF(TCP_DEBUG, (\"TIME-WAIT PCB states:\\n\"));\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    DEBUGF(TCP_DEBUG, (\"Local port %d, foreign port %d snd_nxt %lu rcv_nxt %lu \",\n                       pcb->local_port, pcb->remote_port,\n                       pcb->snd_nxt, pcb->rcv_nxt));\n    tcp_debug_print_state(pcb->state);\n  }    \n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\ntcp_debug_print_flags(uint8_t flags)", "code": "{\n  if(flags & TCP_FIN) {\n    DEBUGF(TCP_DEBUG, (\"FIN \"));\n  }\n  if(flags & TCP_SYN) {\n    DEBUGF(TCP_DEBUG, (\"SYN \"));\n  }\n  if(flags & TCP_RST) {\n    DEBUGF(TCP_DEBUG, (\"RST \"));\n  }\n  if(flags & TCP_PSH) {\n    DEBUGF(TCP_DEBUG, (\"PSH \"));\n  }\n  if(flags & TCP_ACK) {\n    DEBUGF(TCP_DEBUG, (\"ACK \"));\n  }\n  if(flags & TCP_URG) {\n    DEBUGF(TCP_DEBUG, (\"URG \"));\n  }\n}", "path": "lwtcp\\tcp.c", "repo_name": "eastzone/cs344-sw", "stars": 10, "license": "None", "language": "c", "size": 268}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tThis routine calculates TxPER, RxPER of the past N-sec period. And\n\t\taccording to the calculation result, ChannelQuality is calculated here\n\t\tto decide if current AP is still doing the job.\n\n\t\tIf ChannelQuality is not good, a ROAMing attempt may be tried later.\n\tOutput:\n\t\tStaCfg.ChannelQuality - 0..100\n\n\tIRQL = DISPATCH_LEVEL\n\n\tNOTE: This routine decide channle quality based on RX CRC error ratio.\n\t\tCaller should make sure a function call to NICUpdateRawCounters(pAd)\n\t\tis performed right before this routine, so that this routine can decide\n\t\tchannel quality based on the most up-to-date information\n\t==========================================================================\n */\n", "func_signal": "VOID MlmeCalculateChannelQuality(\n\tIN PRTMP_ADAPTER pAd,\n\tIN ULONG Now32)", "code": "{\n\tULONG TxOkCnt, TxCnt, TxPER, TxPRR;\n\tULONG RxCnt, RxPER;\n\tUCHAR NorRssi;\n\tCHAR  MaxRssi;\n\tULONG BeaconLostTime = BEACON_LOST_TIME;\n\n\tMaxRssi = RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0, pAd->StaCfg.RssiSample.LastRssi1, pAd->StaCfg.RssiSample.LastRssi2);\n\n\t//\n\t// calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics\n\t//\n\tTxOkCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + pAd->RalinkCounters.OneSecTxRetryOkCount;\n\tTxCnt = TxOkCnt + pAd->RalinkCounters.OneSecTxFailCount;\n\tif (TxCnt < 5)\n\t{\n\t\tTxPER = 0;\n\t\tTxPRR = 0;\n\t}\n\telse\n\t{\n\t\tTxPER = (pAd->RalinkCounters.OneSecTxFailCount * 100) / TxCnt;\n\t\tTxPRR = ((TxCnt - pAd->RalinkCounters.OneSecTxNoRetryOkCount) * 100) / TxCnt;\n\t}\n\n\t//\n\t// calculate RX PER - don't take RxPER into consideration if too few sample\n\t//\n\tRxCnt = pAd->RalinkCounters.OneSecRxOkCnt + pAd->RalinkCounters.OneSecRxFcsErrCnt;\n\tif (RxCnt < 5)\n\t\tRxPER = 0;\n\telse\n\t\tRxPER = (pAd->RalinkCounters.OneSecRxFcsErrCnt * 100) / RxCnt;\n\n\t//\n\t// decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER\n\t//\n\tif (INFRA_ON(pAd) &&\n\t\t(pAd->RalinkCounters.OneSecTxNoRetryOkCount < 2) && // no heavy traffic\n\t\t(pAd->StaCfg.LastBeaconRxTime + BeaconLostTime < Now32))\n\t{\n\t\tDBGPRINT(RT_DEBUG_TRACE, (\"BEACON lost > %ld msec with TxOkCnt=%ld -> CQI=0\\n\", BeaconLostTime, TxOkCnt));\n\t\tpAd->Mlme.ChannelQuality = 0;\n\t}\n\telse\n\t{\n\t\t// Normalize Rssi\n\t\tif (MaxRssi > -40)\n\t\t\tNorRssi = 100;\n\t\telse if (MaxRssi < -90)\n\t\t\tNorRssi = 0;\n\t\telse\n\t\t\tNorRssi = (MaxRssi + 90) * 2;\n\n\t\t// ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER\t (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)\n\t\tpAd->Mlme.ChannelQuality = (RSSI_WEIGHTING * NorRssi +\n\t\t\t\t\t\t\t\t   TX_WEIGHTING * (100 - TxPRR) +\n\t\t\t\t\t\t\t\t   RX_WEIGHTING* (100 - RxPER)) / 100;\n\t\tif (pAd->Mlme.ChannelQuality >= 100)\n\t\t\tpAd->Mlme.ChannelQuality = 100;\n\t}\n\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*! \\brief init the management mac frame header\n *\t\\param p_hdr mac header\n *\t\\param subtype subtype of the frame\n *\t\\param p_ds destination address, don't care if it is a broadcast address\n *\t\\return none\n *\t\\pre the station has the following information in the pAd->StaCfg\n *\t - bssid\n *\t - station address\n *\t\\post\n *\t\\note this function initializes the following field\n\n IRQL = PASSIVE_LEVEL\n IRQL = DISPATCH_LEVEL\n\n */\n", "func_signal": "VOID MgtMacHeaderInit(\n\tIN\tPRTMP_ADAPTER\tpAd,\n\tIN OUT PHEADER_802_11 pHdr80211,\n\tIN UCHAR SubType,\n\tIN UCHAR ToDs,\n\tIN PUCHAR pDA,\n\tIN PUCHAR pBssid)", "code": "{\n\tNdisZeroMemory(pHdr80211, sizeof(HEADER_802_11));\n\n\tpHdr80211->FC.Type = BTYPE_MGMT;\n\tpHdr80211->FC.SubType = SubType;\n\tpHdr80211->FC.ToDs = ToDs;\n\tCOPY_MAC_ADDR(pHdr80211->Addr1, pDA);\n\n\tCOPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);\n\n\tCOPY_MAC_ADDR(pHdr80211->Addr3, pBssid);\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tThis routine checks if there're other APs out there capable for\n\t\troaming. Caller should call this routine only when Link up in INFRA mode\n\t\tand channel quality is below CQI_GOOD_THRESHOLD.\n\n\tIRQL = DISPATCH_LEVEL\n\n\tOutput:\n\t==========================================================================\n */\n", "func_signal": "VOID MlmeCheckForRoaming(\n\tIN PRTMP_ADAPTER pAd,\n\tIN ULONG\tNow32)", "code": "{\n\tUSHORT\t   i;\n\tBSS_TABLE  *pRoamTab = &pAd->MlmeAux.RoamTab;\n\tBSS_ENTRY  *pBss;\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"==> MlmeCheckForRoaming\\n\"));\n\t// put all roaming candidates into RoamTab, and sort in RSSI order\n\tBssTableInit(pRoamTab);\n\tfor (i = 0; i < pAd->ScanTab.BssNr; i++)\n\t{\n\t\tpBss = &pAd->ScanTab.BssEntry[i];\n\n\t\tif ((pBss->LastBeaconRxTime + BEACON_LOST_TIME) < Now32)\n\t\t\tcontinue;\t // AP disappear\n\t\tif (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)\n\t\t\tcontinue;\t // RSSI too weak. forget it.\n\t\tif (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))\n\t\t\tcontinue;\t // skip current AP\n\t\tif (pBss->Rssi < (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))\n\t\t\tcontinue;\t // only AP with stronger RSSI is eligible for roaming\n\n\t\t// AP passing all above rules is put into roaming candidate table\n\t\tNdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));\n\t\tpRoamTab->BssNr += 1;\n\t}\n\n\tif (pRoamTab->BssNr > 0)\n\t{\n\t\t// check CntlMachine.CurrState to avoid collision with NDIS SetOID request\n\t\tif (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)\n\t\t{\n\t\t\tpAd->RalinkCounters.PoorCQIRoamingCount ++;\n\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"MMCHK - Roaming attempt #%ld\\n\", pAd->RalinkCounters.PoorCQIRoamingCount));\n\t\t\tMlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);\n\t\t\tRT28XX_MLME_HANDLER(pAd);\n\t\t}\n\t}\n\tDBGPRINT(RT_DEBUG_TRACE, (\"<== MlmeCheckForRoaming(# of candidate= %d)\\n\",pRoamTab->BssNr));\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "// Antenna divesity use GPIO3 and EESK pin for control\n// Antenna and EEPROM access are both using EESK pin,\n// Therefor we should avoid accessing EESK at the same time\n// Then restore antenna after EEPROM access\n", "func_signal": "VOID AsicSetRxAnt(\n\tIN PRTMP_ADAPTER\tpAd,\n\tIN UCHAR\t\t\tAnt)", "code": "{\n\tUINT32\tValue;\n\tUINT32\tx;\n\n\tif ((pAd->EepromAccess)\t\t\t\t\t\t\t\t\t\t||\n\t\t(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS))\t||\n\t\t(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))\t||\n\t\t(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))\t\t\t||\n\t\t(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))\n\t{\n\t\treturn;\n\t}\n\n\t// the antenna selection is through firmware and MAC register(GPIO3)\n\tif (Ant == 0)\n\t{\n\t\t// Main antenna\n\t\tRTMP_IO_READ32(pAd, E2PROM_CSR, &x);\n\t\tx |= (EESK);\n\t\tRTMP_IO_WRITE32(pAd, E2PROM_CSR, x);\n\n\t\tRTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);\n\t\tValue &= ~(0x0808);\n\t\tRTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);\n\t\tDBGPRINT_RAW(RT_DEBUG_TRACE, (\"AsicSetRxAnt, switch to main antenna\\n\"));\n\t}\n\telse\n\t{\n\t\t// Aux antenna\n\t\tRTMP_IO_READ32(pAd, E2PROM_CSR, &x);\n\t\tx &= ~(EESK);\n\t\tRTMP_IO_WRITE32(pAd, E2PROM_CSR, x);\n\n\t\tRTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &Value);\n\t\tValue &= ~(0x0808);\n\t\tValue |= 0x08;\n\t\tRTMP_IO_WRITE32(pAd, GPIO_CTRL_CFG, Value);\n\t\tDBGPRINT_RAW(RT_DEBUG_TRACE, (\"AsicSetRxAnt, switch to aux antenna\\n\"));\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tDestructor of MLME (Destroy queue, state machine, spin lock and timer)\n\tParameters:\n\t\tAdapter - NIC Adapter pointer\n\tPost:\n\t\tThe MLME task will no longer work properly\n\n\tIRQL = PASSIVE_LEVEL\n\n\t==========================================================================\n */\n", "func_signal": "VOID MlmeHalt(\n\tIN PRTMP_ADAPTER pAd)", "code": "{\n\tBOOLEAN \t  Cancelled;\n#ifdef RT3070\n\tUINT32\t\tTxPinCfg = 0x00050F0F;\n#endif // RT3070 //\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"==> MlmeHalt\\n\"));\n\n\tif (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))\n\t{\n\t\t// disable BEACON generation and other BEACON related hardware timers\n\t\tAsicDisableSync(pAd);\n\t}\n\n\t{\n\t\t// Cancel pending timers\n\t\tRTMPCancelTimer(&pAd->MlmeAux.AssocTimer,\t\t&Cancelled);\n\t\tRTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,\t\t&Cancelled);\n\t\tRTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,\t&Cancelled);\n\t\tRTMPCancelTimer(&pAd->MlmeAux.AuthTimer,\t\t&Cancelled);\n\t\tRTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,\t\t&Cancelled);\n\t\tRTMPCancelTimer(&pAd->MlmeAux.ScanTimer,\t\t&Cancelled);\n#ifdef RT2860\n\t    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_ADVANCE_POWER_SAVE_PCIE_DEVICE))\n\t    {\n\t   \t    RTMPCancelTimer(&pAd->Mlme.PsPollTimer,\t\t&Cancelled);\n\t\t    RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer,\t\t&Cancelled);\n\t\t}\n#endif\n\t}\n\n\tRTMPCancelTimer(&pAd->Mlme.PeriodicTimer,\t\t&Cancelled);\n\tRTMPCancelTimer(&pAd->Mlme.RxAntEvalTimer,\t\t&Cancelled);\n\n\n\n\tif (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))\n\t{\n\t\t// Set LED\n\t\tRTMPSetLED(pAd, LED_HALT);\n        RTMPSetSignalLED(pAd, -100);\t// Force signal strength Led to be turned off, firmware is not done it.\n#ifdef RT2870\n        {\n            LED_CFG_STRUC LedCfg;\n            RTMP_IO_READ32(pAd, LED_CFG, &LedCfg.word);\n            LedCfg.field.LedPolar = 0;\n            LedCfg.field.RLedMode = 0;\n            LedCfg.field.GLedMode = 0;\n            LedCfg.field.YLedMode = 0;\n            RTMP_IO_WRITE32(pAd, LED_CFG, LedCfg.word);\n        }\n#endif // RT2870 //\n#ifdef RT3070\n\t\t//\n\t\t// Turn off LNA_PE\n\t\t//\n\t\tif (IS_RT3070(pAd) || IS_RT3071(pAd))\n\t\t{\n\t\t\tTxPinCfg &= 0xFFFFF0F0;\n\t\t\tRTUSBWriteMACRegister(pAd, TX_PIN_CFG, TxPinCfg);\n\t\t}\n#endif // RT3070 //\n\t}\n\n\tRTMPusecDelay(5000);    //  5 msec to gurantee Ant Diversity timer canceled\n\n\tMlmeQueueDestroy(&pAd->Mlme.Queue);\n\tNdisFreeSpinLock(&pAd->Mlme.TaskLock);\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\"<== MlmeHalt\\n\"));\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "// IRQL = DISPATCH_LEVEL\n", "func_signal": "VOID MlmeAutoScan(\n\tIN PRTMP_ADAPTER pAd)", "code": "{\n\t// check CntlMachine.CurrState to avoid collision with NDIS SetOID request\n\tif (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)\n\t{\n\t\tDBGPRINT(RT_DEBUG_TRACE, (\"MMCHK - Driver auto scan\\n\"));\n\t\tMlmeEnqueue(pAd,\n\t\t\t\t\tMLME_CNTL_STATE_MACHINE,\n\t\t\t\t\tOID_802_11_BSSID_LIST_SCAN,\n\t\t\t\t\t0,\n\t\t\t\t\tNULL);\n\t\tRT28XX_MLME_HANDLER(pAd);\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t========================================================================\n\n\tRoutine Description:\n\t\tSet MAC register value according operation mode.\n\t\tOperationMode AND bNonGFExist are for MM and GF Proteciton.\n\t\tIf MM or GF mask is not set, those passing argument doesn't not take effect.\n\n\t\tOperation mode meaning:\n\t\t= 0 : Pure HT, no preotection.\n\t\t= 0x01; there may be non-HT devices in both the control and extension channel, protection is optional in BSS.\n\t\t= 0x10: No Transmission in 40M is protected.\n\t\t= 0x11: Transmission in both 40M and 20M shall be protected\n\t\tif (bNonGFExist)\n\t\t\twe should choose not to use GF. But still set correct ASIC registers.\n\t========================================================================\n*/\n", "func_signal": "VOID \tAsicUpdateProtect(\n\tIN\t\tPRTMP_ADAPTER\tpAd,\n\tIN \t\tUSHORT\t\t\tOperationMode,\n\tIN \t\tUCHAR\t\t\tSetMask,\n\tIN\t\tBOOLEAN\t\t\tbDisableBGProtect,\n\tIN\t\tBOOLEAN\t\t\tbNonGFExist)", "code": "{\n\tPROT_CFG_STRUC\tProtCfg, ProtCfg4;\n\tUINT32 Protect[6];\n\tUSHORT\t\t\toffset;\n\tUCHAR\t\t\ti;\n\tUINT32 MacReg = 0;\n\n\tif (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8))\n\t{\n\t\treturn;\n\t}\n\n\tif (pAd->BATable.numAsOriginator)\n\t{\n\t\t//\n\t\t// enable the RTS/CTS to avoid channel collision\n\t\t//\n\t\tSetMask = ALLN_SETPROTECT;\n\t\tOperationMode = 8;\n\t}\n\n\t// Config ASIC RTS threshold register\n\tRTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);\n\tMacReg &= 0xFF0000FF;\n\n\t// If the user want disable RtsThreshold and enable Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096\n        if ((\n\t\t\t(pAd->CommonCfg.BACapability.field.AmsduEnable) ||\n\t\t\t(pAd->CommonCfg.bAggregationCapable == TRUE))\n            && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD)\n        {\n\t\t\tMacReg |= (0x1000 << 8);\n        }\n        else\n        {\n\t\t\tMacReg |= (pAd->CommonCfg.RtsThreshold << 8);\n        }\n\n\tRTMP_IO_WRITE32(pAd, TX_RTS_CFG, MacReg);\n\n\t// Initial common protection settings\n\tRTMPZeroMemory(Protect, sizeof(Protect));\n\tProtCfg4.word = 0;\n\tProtCfg.word = 0;\n\tProtCfg.field.TxopAllowGF40 = 1;\n\tProtCfg.field.TxopAllowGF20 = 1;\n\tProtCfg.field.TxopAllowMM40 = 1;\n\tProtCfg.field.TxopAllowMM20 = 1;\n\tProtCfg.field.TxopAllowOfdm = 1;\n\tProtCfg.field.TxopAllowCck = 1;\n\tProtCfg.field.RTSThEn = 1;\n\tProtCfg.field.ProtectNav = ASIC_SHORTNAV;\n\n\t// update PHY mode and rate\n\tif (pAd->CommonCfg.Channel > 14)\n\t\tProtCfg.field.ProtectRate = 0x4000;\n\tProtCfg.field.ProtectRate |= pAd->CommonCfg.RtsRate;\n\n\t// Handle legacy(B/G) protection\n\tif (bDisableBGProtect)\n\t{\n\t\t//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;\n\t\tProtCfg.field.ProtectCtrl = 0;\n\t\tProtect[0] = ProtCfg.word;\n\t\tProtect[1] = ProtCfg.word;\n\t}\n\telse\n\t{\n\t\t//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;\n\t\tProtCfg.field.ProtectCtrl = 0;\t\t\t// CCK do not need to be protected\n\t\tProtect[0] = ProtCfg.word;\n\t\tProtCfg.field.ProtectCtrl = ASIC_CTS;\t// OFDM needs using CCK to protect\n\t\tProtect[1] = ProtCfg.word;\n\t}\n\n\t// Decide HT frame protection.\n\tif ((SetMask & ALLN_SETPROTECT) != 0)\n\t{\n\t\tswitch(OperationMode)\n\t\t{\n\t\t\tcase 0x0:\n\t\t\t\t// NO PROTECT\n\t\t\t\t// 1.All STAs in the BSS are 20/40 MHz HT\n\t\t\t\t// 2. in ai 20/40MHz BSS\n\t\t\t\t// 3. all STAs are 20MHz in a 20MHz BSS\n\t\t\t\t// Pure HT. no protection.\n\n\t\t\t\t// MM20_PROT_CFG\n\t\t\t\t//\tReserved (31:27)\n\t\t\t\t// \tPROT_TXOP(25:20) -- 010111\n\t\t\t\t//\tPROT_NAV(19:18)  -- 01 (Short NAV protection)\n\t\t\t\t//  PROT_CTRL(17:16) -- 00 (None)\n\t\t\t\t// \tPROT_RATE(15:0)  -- 0x4004 (OFDM 24M)\n\t\t\t\tProtect[2] = 0x01744004;\n\n\t\t\t\t// MM40_PROT_CFG\n\t\t\t\t//\tReserved (31:27)\n\t\t\t\t// \tPROT_TXOP(25:20) -- 111111\n\t\t\t\t//\tPROT_NAV(19:18)  -- 01 (Short NAV protection)\n\t\t\t\t//  PROT_CTRL(17:16) -- 00 (None)\n\t\t\t\t// \tPROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)\n\t\t\t\tProtect[3] = 0x03f44084;\n\n\t\t\t\t// CF20_PROT_CFG\n\t\t\t\t//\tReserved (31:27)\n\t\t\t\t// \tPROT_TXOP(25:20) -- 010111\n\t\t\t\t//\tPROT_NAV(19:18)  -- 01 (Short NAV protection)\n\t\t\t\t//  PROT_CTRL(17:16) -- 00 (None)\n\t\t\t\t// \tPROT_RATE(15:0)  -- 0x4004 (OFDM 24M)\n\t\t\t\tProtect[4] = 0x01744004;\n\n\t\t\t\t// CF40_PROT_CFG\n\t\t\t\t//\tReserved (31:27)\n\t\t\t\t// \tPROT_TXOP(25:20) -- 111111\n\t\t\t\t//\tPROT_NAV(19:18)  -- 01 (Short NAV protection)\n\t\t\t\t//  PROT_CTRL(17:16) -- 00 (None)\n\t\t\t\t// \tPROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)\n\t\t\t\tProtect[5] = 0x03f44084;\n\n\t\t\t\tif (bNonGFExist)\n\t\t\t\t{\n\t\t\t\t\t// PROT_NAV(19:18)  -- 01 (Short NAV protectiion)\n\t\t\t\t\t// PROT_CTRL(17:16) -- 01 (RTS/CTS)\n\t\t\t\t\tProtect[4] = 0x01754004;\n\t\t\t\t\tProtect[5] = 0x03f54084;\n\t\t\t\t}\n\t\t\t\tpAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;\n\t\t\t\tbreak;\n\n \t\t\tcase 1:\n\t\t\t\t// This is \"HT non-member protection mode.\"\n\t\t\t\t// If there may be non-HT STAs my BSS\n\t\t\t\tProtCfg.word = 0x01744004;\t// PROT_CTRL(17:16) : 0 (None)\n\t\t\t\tProtCfg4.word = 0x03f44084; // duplicaet legacy 24M. BW set 1.\n\t\t\t\tif (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))\n\t\t\t\t{\n\t\t\t\t\tProtCfg.word = 0x01740003;\t//ERP use Protection bit is set, use protection rate at Clause 18..\n\t\t\t\t\tProtCfg4.word = 0x03f40003; // Don't duplicate RTS/CTS in CCK mode. 0x03f40083;\n\t\t\t\t}\n\t\t\t\t//Assign Protection method for 20&40 MHz packets\n\t\t\t\tProtCfg.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\tProtCfg.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\tProtCfg4.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\tProtCfg4.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\tProtect[2] = ProtCfg.word;\n\t\t\t\tProtect[3] = ProtCfg4.word;\n\t\t\t\tProtect[4] = ProtCfg.word;\n\t\t\t\tProtect[5] = ProtCfg4.word;\n\t\t\t\tpAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets\n\t\t\t\tProtCfg.word = 0x01744004;  // PROT_CTRL(17:16) : 0 (None)\n\t\t\t\tProtCfg4.word = 0x03f44084; // duplicaet legacy 24M. BW set 1.\n\n\t\t\t\t//Assign Protection method for 40MHz packets\n\t\t\t\tProtCfg4.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\tProtCfg4.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\tProtect[2] = ProtCfg.word;\n\t\t\t\tProtect[3] = ProtCfg4.word;\n\t\t\t\tif (bNonGFExist)\n\t\t\t\t{\n\t\t\t\t\tProtCfg.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\t\tProtCfg.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\t}\n\t\t\t\tProtect[4] = ProtCfg.word;\n\t\t\t\tProtect[5] = ProtCfg4.word;\n\n\t\t\t\tpAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t// HT mixed mode.\t PROTECT ALL!\n\t\t\t\t// Assign Rate\n\t\t\t\tProtCfg.word = 0x01744004;\t//duplicaet legacy 24M. BW set 1.\n\t\t\t\tProtCfg4.word = 0x03f44084;\n\t\t\t\t// both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the\n\t\t\t\tif (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))\n\t\t\t\t{\n\t\t\t\t\tProtCfg.word = 0x01740003;\t//ERP use Protection bit is set, use protection rate at Clause 18..\n\t\t\t\t\tProtCfg4.word = 0x03f40003; // Don't duplicate RTS/CTS in CCK mode. 0x03f40083\n\t\t\t\t}\n\t\t\t\t//Assign Protection method for 20&40 MHz packets\n\t\t\t\tProtCfg.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\tProtCfg.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\tProtCfg4.field.ProtectCtrl = ASIC_RTS;\n\t\t\t\tProtCfg4.field.ProtectNav = ASIC_SHORTNAV;\n\t\t\t\tProtect[2] = ProtCfg.word;\n\t\t\t\tProtect[3] = ProtCfg4.word;\n\t\t\t\tProtect[4] = ProtCfg.word;\n\t\t\t\tProtect[5] = ProtCfg4.word;\n\t\t\t\tpAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\t// Special on for Atheros problem n chip.\n\t\t\t\tProtect[2] = 0x01754004;\n\t\t\t\tProtect[3] = 0x03f54084;\n\t\t\t\tProtect[4] = 0x01754004;\n\t\t\t\tProtect[5] = 0x03f54084;\n\t\t\t\tpAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = CCK_PROT_CFG;\n\tfor (i = 0;i < 6;i++)\n\t{\n\t\tif ((SetMask & (1<< i)))\n\t\t{\n\t\t\tRTMP_IO_WRITE32(pAd, offset + i*4, Protect[i]);\n\t\t}\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\n\tIRQL = PASSIVE_LEVEL\n\n\t==========================================================================\n */\n", "func_signal": "VOID LfsrInit(\n\tIN PRTMP_ADAPTER pAd,\n\tIN ULONG Seed)", "code": "{\n\tif (Seed == 0)\n\t\tpAd->Mlme.ShiftReg = 1;\n\telse\n\t\tpAd->Mlme.ShiftReg = Seed;\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "// 8 sec\n", "func_signal": "VOID MlmePeriodicExec(\n\tIN PVOID SystemSpecific1,\n\tIN PVOID FunctionContext,\n\tIN PVOID SystemSpecific2,\n\tIN PVOID SystemSpecific3)", "code": "{\n\tULONG\t\t\tTxTotalCnt;\n\tPRTMP_ADAPTER\tpAd = (RTMP_ADAPTER *)FunctionContext;\n\n#ifdef RT2860\n\t//Baron 2008/07/10\n\t//printk(\"Baron_Test:\\t%s\", RTMPGetRalinkEncryModeStr(pAd->StaCfg.WepStatus));\n\t//If the STA security setting is OPEN or WEP, pAd->StaCfg.WpaSupplicantUP = 0.\n\t//If the STA security setting is WPAPSK or WPA2PSK, pAd->StaCfg.WpaSupplicantUP = 1.\n\tif(pAd->StaCfg.WepStatus<2)\n\t{\n\t\tpAd->StaCfg.WpaSupplicantUP = 0;\n\t}\n\telse\n\t{\n\t\tpAd->StaCfg.WpaSupplicantUP = 1;\n\t}\n\n\t{\n\t    // If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second.\n\t\t// Move code to here, because following code will return when radio is off\n\t\tif ((pAd->Mlme.PeriodicRound % (MLME_TASK_EXEC_MULTIPLE * 2) == 0) &&\n\t\t\t(pAd->StaCfg.bHardwareRadio == TRUE) &&\n\t\t\t(RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_START_UP)) &&\n\t\t\t(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) &&\n\t\t\t(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)))\n\t\t{\n\t\t\tUINT32\t\t\t\tdata = 0;\n\n\t\t\t// Read GPIO pin2 as Hardware controlled radio state\n\t\t\tRTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);\n\t\t\tif (data & 0x04)\n\t\t\t{\n\t\t\t\tpAd->StaCfg.bHwRadio = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpAd->StaCfg.bHwRadio = FALSE;\n\t\t\t}\n\t\t\tif (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))\n\t\t\t{\n\t\t\t\tpAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);\n\t\t\t\tif (pAd->StaCfg.bRadio == TRUE)\n\t\t\t\t{\n\t\t\t\t\tMlmeRadioOn(pAd);\n\t\t\t\t\t// Update extra information\n\t\t\t\t\tpAd->ExtraInfo = EXTRA_INFO_CLEAR;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tMlmeRadioOff(pAd);\n\t\t\t\t\t// Update extra information\n\t\t\t\t\tpAd->ExtraInfo = HW_RADIO_OFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif /* RT2860 */\n\n\t// Do nothing if the driver is starting halt state.\n\t// This might happen when timer already been fired before cancel timer with mlmehalt\n\tif ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_HALT_IN_PROGRESS |\n\t\t\t\t\t\t\t\tfRTMP_ADAPTER_RADIO_OFF |\n\t\t\t\t\t\t\t\tfRTMP_ADAPTER_RADIO_MEASUREMENT |\n\t\t\t\t\t\t\t\tfRTMP_ADAPTER_RESET_IN_PROGRESS))))\n\t\treturn;\n\n#ifdef RT2860\n\t{\n\t\tif ((pAd->RalinkCounters.LastReceivedByteCount == pAd->RalinkCounters.ReceivedByteCount) && (pAd->StaCfg.bRadio == TRUE))\n\t\t{\n\t\t\t// If ReceiveByteCount doesn't change,  increase SameRxByteCount by 1.\n\t\t\tpAd->SameRxByteCount++;\n\t\t}\n\t\telse\n\t\t\tpAd->SameRxByteCount = 0;\n\n\t\t// If after BBP, still not work...need to check to reset PBF&MAC.\n\t\tif (pAd->SameRxByteCount == 702)\n\t\t{\n\t\t\tpAd->SameRxByteCount = 0;\n\t\t\tAsicResetPBF(pAd);\n\t\t\tAsicResetMAC(pAd);\n\t\t}\n\n\t\t// If SameRxByteCount keeps happens for 2 second in infra mode, or for 60 seconds in idle mode.\n\t\tif (((INFRA_ON(pAd)) && (pAd->SameRxByteCount > 20)) || ((IDLE_ON(pAd)) && (pAd->SameRxByteCount > 600)))\n\t\t{\n\t\t\tif ((pAd->StaCfg.bRadio == TRUE) && (pAd->SameRxByteCount < 700))\n\t\t\t{\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"--->  SameRxByteCount = %lu !!!!!!!!!!!!!!! \\n\", pAd->SameRxByteCount));\n\t\t\t\tpAd->SameRxByteCount = 700;\n\t\t\t\tAsicResetBBP(pAd);\n\t\t\t}\n\t\t}\n\n\t\t// Update lastReceiveByteCount.\n\t\tpAd->RalinkCounters.LastReceivedByteCount = pAd->RalinkCounters.ReceivedByteCount;\n\n\t\tif ((pAd->CheckDmaBusyCount > 3) && (IDLE_ON(pAd)))\n\t\t{\n\t\t\tpAd->CheckDmaBusyCount = 0;\n\t\t\tAsicResetFromDMABusy(pAd);\n\t\t}\n\t}\n#endif /* RT2860 */\n\tRT28XX_MLME_PRE_SANITY_CHECK(pAd);\n\n\t{\n\t\t// Do nothing if monitor mode is on\n\t\tif (MONITOR_ON(pAd))\n\t\t\treturn;\n\n\t\tif (pAd->Mlme.PeriodicRound & 0x1)\n\t\t{\n\t\t\t// This is the fix for wifi 11n extension channel overlapping test case.  for 2860D\n\t\t\tif (((pAd->MACVersion & 0xffff) == 0x0101) &&\n\t\t\t\t(STA_TGN_WIFI_ON(pAd)) &&\n\t\t\t\t(pAd->CommonCfg.IOTestParm.bToggle == FALSE))\n\n\t\t\t\t{\n\t\t\t\t\tRTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x24Bf);\n\t\t\t\t\tpAd->CommonCfg.IOTestParm.bToggle = TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((STA_TGN_WIFI_ON(pAd)) &&\n\t\t\t\t\t\t((pAd->MACVersion & 0xffff) == 0x0101))\n\t\t\t\t{\n\t\t\t\t\tRTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x243f);\n\t\t\t\t\tpAd->CommonCfg.IOTestParm.bToggle = FALSE;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpAd->bUpdateBcnCntDone = FALSE;\n\n//\tRECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3);\n\tpAd->Mlme.PeriodicRound ++;\n\n#ifdef RT3070\n\t// execute every 100ms, update the Tx FIFO Cnt for update Tx Rate.\n\tNICUpdateFifoStaCounters(pAd);\n#endif // RT3070 //\n\t// execute every 500ms\n\tif ((pAd->Mlme.PeriodicRound % 5 == 0) && RTMPAutoRateSwitchCheck(pAd)/*(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))*/)\n\t{\n\t\t// perform dynamic tx rate switching based on past TX history\n\t\t{\n\t\t\tif ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)\n\t\t\t\t\t)\n\t\t\t\t&& (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)))\n\t\t\t\tMlmeDynamicTxRateSwitching(pAd);\n\t\t}\n\t}\n\n\t// Normal 1 second Mlme PeriodicExec.\n\tif (pAd->Mlme.PeriodicRound %MLME_TASK_EXEC_MULTIPLE == 0)\n\t{\n                pAd->Mlme.OneSecPeriodicRound ++;\n\n\t\tif (rx_Total)\n\t\t{\n\n\t\t\t// reset counters\n\t\t\trx_AMSDU = 0;\n\t\t\trx_Total = 0;\n\t\t}\n\n\t\t// Media status changed, report to NDIS\n\t\tif (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE))\n\t\t{\n\t\t\tRTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);\n\t\t\tif (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))\n\t\t\t{\n\t\t\t\tpAd->IndicateMediaState = NdisMediaStateConnected;\n\t\t\t\tRTMP_IndicateMediaState(pAd);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpAd->IndicateMediaState = NdisMediaStateDisconnected;\n\t\t\t\tRTMP_IndicateMediaState(pAd);\n\t\t\t}\n\t\t}\n\n\t\tNdisGetSystemUpTime(&pAd->Mlme.Now32);\n\n\t\t// add the most up-to-date h/w raw counters into software variable, so that\n\t\t// the dynamic tuning mechanism below are based on most up-to-date information\n\t\tNICUpdateRawCounters(pAd);\n\n#ifdef RT2870\n\t\tRT2870_WatchDog(pAd);\n#endif // RT2870 //\n\n   \t\t// Need statistics after read counter. So put after NICUpdateRawCounters\n\t\tORIBATimerTimeout(pAd);\n\n\t\t// The time period for checking antenna is according to traffic\n\t\tif (pAd->Mlme.bEnableAutoAntennaCheck)\n\t\t{\n\t\t\tTxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount +\n\t\t\t\t\t\t\t pAd->RalinkCounters.OneSecTxRetryOkCount +\n\t\t\t\t\t\t\t pAd->RalinkCounters.OneSecTxFailCount;\n\n\t\t\t// dynamic adjust antenna evaluation period according to the traffic\n\t\t\tif (TxTotalCnt > 50)\n\t\t\t{\n\t\t\t\tif (pAd->Mlme.OneSecPeriodicRound % 10 == 0)\n\t\t\t\t{\n\t\t\t\t\tAsicEvaluateRxAnt(pAd);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pAd->Mlme.OneSecPeriodicRound % 3 == 0)\n\t\t\t\t{\n\t\t\t\t\tAsicEvaluateRxAnt(pAd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSTAMlmePeriodicExec(pAd);\n\n\t\tMlmeResetRalinkCounters(pAd);\n\n\t\t{\n#ifdef RT2860\n\t\t\tif (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST) && (pAd->bPCIclkOff == FALSE))\n#endif\n\t\t\t{\n\t\t\t\t// When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock\n\t\t\t\t// and sending CTS-to-self over and over.\n\t\t\t\t// Software Patch Solution:\n\t\t\t\t// 1. Polling debug state register 0x10F4 every one second.\n\t\t\t\t// 2. If in 0x10F4 the ((bit29==1) && (bit7==1)) OR ((bit29==1) && (bit5==1)), it means the deadlock has occurred.\n\t\t\t\t// 3. If the deadlock occurred, reset MAC/BBP by setting 0x1004 to 0x0001 for a while then setting it back to 0x000C again.\n\n\t\t\t\tUINT32\tMacReg = 0;\n\n\t\t\t\tRTMP_IO_READ32(pAd, 0x10F4, &MacReg);\n\t\t\t\tif (((MacReg & 0x20000000) && (MacReg & 0x80)) || ((MacReg & 0x20000000) && (MacReg & 0x20)))\n\t\t\t\t{\n\t\t\t\t\tRTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);\n\t\t\t\t\tRTMPusecDelay(1);\n\t\t\t\t\tRTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0xC);\n\n\t\t\t\t\tDBGPRINT(RT_DEBUG_WARN,(\"Warning, MAC specific condition occurs \\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tRT28XX_MLME_HANDLER(pAd);\n\t}\n\n\tpAd->bUpdateBcnCntDone = FALSE;\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*! \\brief\ttest if the MLME Queue is empty\n *\t\\param\t*Queue\t  The MLME Queue\n *\t\\return TRUE if the Queue is empty, FALSE otherwise\n *\t\\pre\n *\t\\post\n\n IRQL = DISPATCH_LEVEL\n\n */\n", "func_signal": "BOOLEAN MlmeQueueEmpty(\n\tIN MLME_QUEUE *Queue)", "code": "{\n\tBOOLEAN Ans;\n\n\tNdisAcquireSpinLock(&(Queue->Lock));\n\tAns = (Queue->Num == 0);\n\tNdisReleaseSpinLock(&(Queue->Lock));\n\n\treturn Ans;\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tdynamic tune BBP R66 to find a balance between sensibility and\n\t\tnoise isolation\n\n\tIRQL = DISPATCH_LEVEL\n\n\t==========================================================================\n */\n", "func_signal": "VOID AsicStaBbpTuning(\n\tIN PRTMP_ADAPTER pAd)", "code": "{\n\tUCHAR\tOrigR66Value = 0, R66;//, R66UpperBound = 0x30, R66LowerBound = 0x30;\n\tCHAR\tRssi;\n\n\t// 2860C did not support Fase CCA, therefore can't tune\n\tif (pAd->MACVersion == 0x28600100)\n\t\treturn;\n\n\t//\n\t// work as a STA\n\t//\n\tif (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)  // no R66 tuning when SCANNING\n\t\treturn;\n\n\tif ((pAd->OpMode == OPMODE_STA)\n\t\t&& (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)\n\t\t\t)\n\t\t&& !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))\n#ifdef RT2860\n\t\t&& (pAd->bPCIclkOff == FALSE))\n#endif\n#ifdef RT2870\n\t\t)\n#endif\n\t{\n\t\tRTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &OrigR66Value);\n\t\tR66 = OrigR66Value;\n\n\t\tif (pAd->Antenna.field.RxPath > 1)\n\t\t\tRssi = (pAd->StaCfg.RssiSample.AvgRssi0 + pAd->StaCfg.RssiSample.AvgRssi1) >> 1;\n\t\telse\n\t\t\tRssi = pAd->StaCfg.RssiSample.AvgRssi0;\n\n\t\tif (pAd->LatchRfRegs.Channel <= 14)\n\t\t{\t//BG band\n#ifdef RT2870\n\t\t\t// RT3070 is a no LNA solution, it should have different control regarding to AGC gain control\n\t\t\t// Otherwise, it will have some throughput side effect when low RSSI\n\t\t\tif (IS_RT30xx(pAd))\n\t\t\t{\n\t\t\t\tif (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x1C + 2*GET_LNA_GAIN(pAd) + 0x20;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x1C + 2*GET_LNA_GAIN(pAd);\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif // RT2870 //\n\t\t\t{\n\t\t\t\tif (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)\n\t\t\t\t{\n\t\t\t\t\tR66 = (0x2E + GET_LNA_GAIN(pAd)) + 0x10;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x2E + GET_LNA_GAIN(pAd);\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t//A band\n\t\t\tif (pAd->CommonCfg.BBPCurrentBW == BW_20)\n\t\t\t{\n\t\t\t\tif (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x32 + (GET_LNA_GAIN(pAd)*5)/3 + 0x10;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x32 + (GET_LNA_GAIN(pAd)*5)/3;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY)\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x3A + (GET_LNA_GAIN(pAd)*5)/3 + 0x10;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tR66 = 0x3A + (GET_LNA_GAIN(pAd)*5)/3;\n\t\t\t\t\tif (OrigR66Value != R66)\n\t\t\t\t\t{\n\t\t\t\t\t\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*! \\brief Initialize the state machine.\n *\t\\param *S\t\t\tpointer to the state machine\n *\t\\param\tTrans\t\tState machine transition function\n *\t\\param\tStNr\t\tnumber of states\n *\t\\param\tMsgNr\t\tnumber of messages\n *\t\\param\tDefFunc \tdefault function, when there is invalid state/message combination\n *\t\\param\tInitState\tinitial state of the state machine\n *\t\\param\tBase\t\tStateMachine base, internal use only\n *\t\\pre p_sm should be a legal pointer\n *\t\\post\n\n IRQL = PASSIVE_LEVEL\n\n */\n", "func_signal": "VOID StateMachineInit(\n\tIN STATE_MACHINE *S,\n\tIN STATE_MACHINE_FUNC Trans[],\n\tIN ULONG StNr,\n\tIN ULONG MsgNr,\n\tIN STATE_MACHINE_FUNC DefFunc,\n\tIN ULONG InitState,\n\tIN ULONG Base)", "code": "{\n\tULONG i, j;\n\n\t// set number of states and messages\n\tS->NrState = StNr;\n\tS->NrMsg   = MsgNr;\n\tS->Base    = Base;\n\n\tS->TransFunc  = Trans;\n\n\t// init all state transition to default function\n\tfor (i = 0; i < StNr; i++)\n\t{\n\t\tfor (j = 0; j < MsgNr; j++)\n\t\t{\n\t\t\tS->TransFunc[i * MsgNr + j] = DefFunc;\n\t\t}\n\t}\n\n\t// set the starting state\n\tS->CurrState = InitState;\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "// IRQL = PASSIVE_LEVEL\n// IRQL = DISPATCH_LEVEL\n// bLinkUp is to identify the inital link speed.\n// TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps.\n", "func_signal": "VOID MlmeUpdateTxRates(\n\tIN PRTMP_ADAPTER \t\tpAd,\n\tIN \tBOOLEAN\t\t \t\tbLinkUp,\n\tIN\tUCHAR\t\t\t\tapidx)", "code": "{\n\tint i, num;\n\tUCHAR Rate = RATE_6, MaxDesire = RATE_1, MaxSupport = RATE_1;\n\tUCHAR MinSupport = RATE_54;\n\tULONG BasicRateBitmap = 0;\n\tUCHAR CurrBasicRate = RATE_1;\n\tUCHAR *pSupRate, SupRateLen, *pExtRate, ExtRateLen;\n\tPHTTRANSMIT_SETTING\t\tpHtPhy = NULL;\n\tPHTTRANSMIT_SETTING\t\tpMaxHtPhy = NULL;\n\tPHTTRANSMIT_SETTING\t\tpMinHtPhy = NULL;\n\tBOOLEAN \t\t\t\t*auto_rate_cur_p;\n\tUCHAR\t\t\t\t\tHtMcs = MCS_AUTO;\n\n\t// find max desired rate\n\tUpdateBasicRateBitmap(pAd);\n\n\tnum = 0;\n\tauto_rate_cur_p = NULL;\n\tfor (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)\n\t{\n\t\tswitch (pAd->CommonCfg.DesireRate[i] & 0x7f)\n\t\t{\n\t\t\tcase 2:  Rate = RATE_1;   num++;   break;\n\t\t\tcase 4:  Rate = RATE_2;   num++;   break;\n\t\t\tcase 11: Rate = RATE_5_5; num++;   break;\n\t\t\tcase 22: Rate = RATE_11;  num++;   break;\n\t\t\tcase 12: Rate = RATE_6;   num++;   break;\n\t\t\tcase 18: Rate = RATE_9;   num++;   break;\n\t\t\tcase 24: Rate = RATE_12;  num++;   break;\n\t\t\tcase 36: Rate = RATE_18;  num++;   break;\n\t\t\tcase 48: Rate = RATE_24;  num++;   break;\n\t\t\tcase 72: Rate = RATE_36;  num++;   break;\n\t\t\tcase 96: Rate = RATE_48;  num++;   break;\n\t\t\tcase 108: Rate = RATE_54; num++;   break;\n\t\t\t//default: Rate = RATE_1;   break;\n\t\t}\n\t\tif (MaxDesire < Rate)  MaxDesire = Rate;\n\t}\n\n//===========================================================================\n//===========================================================================\n\t{\n\t\tpHtPhy \t\t= &pAd->StaCfg.HTPhyMode;\n\t\tpMaxHtPhy\t= &pAd->StaCfg.MaxHTPhyMode;\n\t\tpMinHtPhy\t= &pAd->StaCfg.MinHTPhyMode;\n\n\t\tauto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;\n\t\tHtMcs \t\t= pAd->StaCfg.DesiredTransmitSetting.field.MCS;\n\n\t\tif ((pAd->StaCfg.BssType == BSS_ADHOC) &&\n\t\t\t(pAd->CommonCfg.PhyMode == PHY_11B) &&\n\t\t\t(MaxDesire > RATE_11))\n\t\t{\n\t\t\tMaxDesire = RATE_11;\n\t\t}\n\t}\n\n\tpAd->CommonCfg.MaxDesiredRate = MaxDesire;\n\tpMinHtPhy->word = 0;\n\tpMaxHtPhy->word = 0;\n\tpHtPhy->word = 0;\n\n\t// Auto rate switching is enabled only if more than one DESIRED RATES are\n\t// specified; otherwise disabled\n\tif (num <= 1)\n\t{\n\t\t*auto_rate_cur_p = FALSE;\n\t}\n\telse\n\t{\n\t\t*auto_rate_cur_p = TRUE;\n\t}\n\n#if 1\n\tif (HtMcs != MCS_AUTO)\n\t{\n\t\t*auto_rate_cur_p = FALSE;\n\t}\n\telse\n\t{\n\t\t*auto_rate_cur_p = TRUE;\n\t}\n#endif\n\n\tif ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))\n\t{\n\t\tpSupRate = &pAd->StaActive.SupRate[0];\n\t\tpExtRate = &pAd->StaActive.ExtRate[0];\n\t\tSupRateLen = pAd->StaActive.SupRateLen;\n\t\tExtRateLen = pAd->StaActive.ExtRateLen;\n\t}\n\telse\n\t{\n\t\tpSupRate = &pAd->CommonCfg.SupRate[0];\n\t\tpExtRate = &pAd->CommonCfg.ExtRate[0];\n\t\tSupRateLen = pAd->CommonCfg.SupRateLen;\n\t\tExtRateLen = pAd->CommonCfg.ExtRateLen;\n\t}\n\n\t// find max supported rate\n\tfor (i=0; i<SupRateLen; i++)\n\t{\n\t\tswitch (pSupRate[i] & 0x7f)\n\t\t{\n\t\t\tcase 2:   Rate = RATE_1;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0001;\t break;\n\t\t\tcase 4:   Rate = RATE_2;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0002;\t break;\n\t\t\tcase 11:  Rate = RATE_5_5;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0004;\t break;\n\t\t\tcase 22:  Rate = RATE_11;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0008;\t break;\n\t\t\tcase 12:  Rate = RATE_6;\t/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;\n\t\t\tcase 18:  Rate = RATE_9;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0020;\t break;\n\t\t\tcase 24:  Rate = RATE_12;\t/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;\n\t\t\tcase 36:  Rate = RATE_18;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0080;\t break;\n\t\t\tcase 48:  Rate = RATE_24;\t/*if (pSupRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;\n\t\t\tcase 72:  Rate = RATE_36;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0200;\t break;\n\t\t\tcase 96:  Rate = RATE_48;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0400;\t break;\n\t\t\tcase 108: Rate = RATE_54;\tif (pSupRate[i] & 0x80) BasicRateBitmap |= 0x0800;\t break;\n\t\t\tdefault:  Rate = RATE_1;\tbreak;\n\t\t}\n\t\tif (MaxSupport < Rate)\tMaxSupport = Rate;\n\n\t\tif (MinSupport > Rate) MinSupport = Rate;\n\t}\n\n\tfor (i=0; i<ExtRateLen; i++)\n\t{\n\t\tswitch (pExtRate[i] & 0x7f)\n\t\t{\n\t\t\tcase 2:   Rate = RATE_1;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0001;\t break;\n\t\t\tcase 4:   Rate = RATE_2;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0002;\t break;\n\t\t\tcase 11:  Rate = RATE_5_5;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0004;\t break;\n\t\t\tcase 22:  Rate = RATE_11;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0008;\t break;\n\t\t\tcase 12:  Rate = RATE_6;\t/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0010;  break;\n\t\t\tcase 18:  Rate = RATE_9;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0020;\t break;\n\t\t\tcase 24:  Rate = RATE_12;\t/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0040;  break;\n\t\t\tcase 36:  Rate = RATE_18;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0080;\t break;\n\t\t\tcase 48:  Rate = RATE_24;\t/*if (pExtRate[i] & 0x80)*/  BasicRateBitmap |= 0x0100;  break;\n\t\t\tcase 72:  Rate = RATE_36;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0200;\t break;\n\t\t\tcase 96:  Rate = RATE_48;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0400;\t break;\n\t\t\tcase 108: Rate = RATE_54;\tif (pExtRate[i] & 0x80) BasicRateBitmap |= 0x0800;\t break;\n\t\t\tdefault:  Rate = RATE_1;\tbreak;\n\t\t}\n\t\tif (MaxSupport < Rate)\tMaxSupport = Rate;\n\n\t\tif (MinSupport > Rate) MinSupport = Rate;\n\t}\n\n\tRTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);\n\n\t// calculate the exptected ACK rate for each TX rate. This info is used to caculate\n\t// the DURATION field of outgoing uniicast DATA/MGMT frame\n\tfor (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)\n\t{\n\t\tif (BasicRateBitmap & (0x01 << i))\n\t\t\tCurrBasicRate = (UCHAR)i;\n\t\tpAd->CommonCfg.ExpectedACKRate[i] = CurrBasicRate;\n\t}\n\n\tDBGPRINT(RT_DEBUG_TRACE,(\"MlmeUpdateTxRates[MaxSupport = %d] = MaxDesire %d Mbps\\n\", RateIdToMbps[MaxSupport], RateIdToMbps[MaxDesire]));\n\t// max tx rate = min {max desire rate, max supported rate}\n\tif (MaxSupport < MaxDesire)\n\t\tpAd->CommonCfg.MaxTxRate = MaxSupport;\n\telse\n\t\tpAd->CommonCfg.MaxTxRate = MaxDesire;\n\n\tpAd->CommonCfg.MinTxRate = MinSupport;\n\tif (*auto_rate_cur_p)\n\t{\n\t\tshort dbm = 0;\n\n\t\tdbm = pAd->StaCfg.RssiSample.AvgRssi0 - pAd->BbpRssiToDbmDelta;\n\n\t\tif (bLinkUp == TRUE)\n\t\t\tpAd->CommonCfg.TxRate = RATE_24;\n\t\telse\n\t\t\tpAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;\n\n\t\tif (dbm < -75)\n\t\t\tpAd->CommonCfg.TxRate = RATE_11;\n\t\telse if (dbm < -70)\n\t\t\tpAd->CommonCfg.TxRate = RATE_24;\n\n\t\t// should never exceed MaxTxRate (consider 11B-only mode)\n\t\tif (pAd->CommonCfg.TxRate > pAd->CommonCfg.MaxTxRate)\n\t\t\tpAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;\n\n\t\tpAd->CommonCfg.TxRateIndex = 0;\n\t}\n\telse\n\t{\n\t\tpAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;\n\t\tpHtPhy->field.MCS\t= (pAd->CommonCfg.MaxTxRate > 3) ? (pAd->CommonCfg.MaxTxRate - 4) : pAd->CommonCfg.MaxTxRate;\n\t\tpHtPhy->field.MODE\t= (pAd->CommonCfg.MaxTxRate > 3) ? MODE_OFDM : MODE_CCK;\n\n\t\tpAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC\t= pHtPhy->field.STBC;\n\t\tpAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI\t= pHtPhy->field.ShortGI;\n\t\tpAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS\t\t= pHtPhy->field.MCS;\n\t\tpAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE\t= pHtPhy->field.MODE;\n\t}\n\n\tif (pAd->CommonCfg.TxRate <= RATE_11)\n\t{\n\t\tpMaxHtPhy->field.MODE = MODE_CCK;\n\t\tpMaxHtPhy->field.MCS = pAd->CommonCfg.TxRate;\n\t\tpMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;\n\t}\n\telse\n\t{\n\t\tpMaxHtPhy->field.MODE = MODE_OFDM;\n\t\tpMaxHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.TxRate];\n\t\tif (pAd->CommonCfg.MinTxRate >= RATE_6 && (pAd->CommonCfg.MinTxRate <= RATE_54))\n\t\t\t{pMinHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MinTxRate];}\n\t\telse\n\t\t\t{pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;}\n\t}\n\n\tpHtPhy->word = (pMaxHtPhy->word);\n\tif (bLinkUp && (pAd->OpMode == OPMODE_STA))\n\t{\n\t\t\tpAd->MacTab.Content[BSSID_WCID].HTPhyMode.word = pHtPhy->word;\n\t\t\tpAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word = pMaxHtPhy->word;\n\t\t\tpAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word = pMinHtPhy->word;\n\t}\n\telse\n\t{\n\t\tswitch (pAd->CommonCfg.PhyMode)\n\t\t{\n\t\t\tcase PHY_11BG_MIXED:\n\t\t\tcase PHY_11B:\n\t\t\tcase PHY_11BGN_MIXED:\n\t\t\t\tpAd->CommonCfg.MlmeRate = RATE_1;\n\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;\n\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;\n\t\t\t\tpAd->CommonCfg.RtsRate = RATE_11;\n\t\t\t\tbreak;\n\t\t\tcase PHY_11G:\n\t\t\tcase PHY_11A:\n\t\t\tcase PHY_11AGN_MIXED:\n\t\t\tcase PHY_11GN_MIXED:\n\t\t\tcase PHY_11N_2_4G:\n\t\t\tcase PHY_11AN_MIXED:\n\t\t\tcase PHY_11N_5G:\n\t\t\t\tpAd->CommonCfg.MlmeRate = RATE_6;\n\t\t\t\tpAd->CommonCfg.RtsRate = RATE_6;\n\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;\n\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];\n\t\t\t\tbreak;\n\t\t\tcase PHY_11ABG_MIXED:\n\t\t\tcase PHY_11ABGN_MIXED:\n\t\t\t\tif (pAd->CommonCfg.Channel <= 14)\n\t\t\t\t{\n\t\t\t\t\tpAd->CommonCfg.MlmeRate = RATE_1;\n\t\t\t\t\tpAd->CommonCfg.RtsRate = RATE_1;\n\t\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;\n\t\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpAd->CommonCfg.MlmeRate = RATE_6;\n\t\t\t\t\tpAd->CommonCfg.RtsRate = RATE_6;\n\t\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;\n\t\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: // error\n\t\t\t\tpAd->CommonCfg.MlmeRate = RATE_6;\n                        \tpAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;\n\t\t\t\tpAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];\n\t\t\t\tpAd->CommonCfg.RtsRate = RATE_1;\n\t\t\t\tbreak;\n\t\t}\n\t\t//\n\t\t// Keep Basic Mlme Rate.\n\t\t//\n\t\tpAd->MacTab.Content[MCAST_WCID].HTPhyMode.word = pAd->CommonCfg.MlmeTransmit.word;\n\t\tif (pAd->CommonCfg.MlmeTransmit.field.MODE == MODE_OFDM)\n\t\t\tpAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[RATE_24];\n\t\telse\n\t\t\tpAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = RATE_1;\n\t\tpAd->CommonCfg.BasicMlmeRate = pAd->CommonCfg.MlmeRate;\n\t}\n\n\tDBGPRINT(RT_DEBUG_TRACE, (\" MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, MinRate=%d, Rate Switching =%d)\\n\",\n\t\t\t RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport], RateIdToMbps[pAd->CommonCfg.MaxTxRate], RateIdToMbps[pAd->CommonCfg.MinTxRate],\n\t\t\t /*OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)*/*auto_rate_cur_p));\n\tDBGPRINT(RT_DEBUG_TRACE, (\" MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04lx)\\n\",\n\t\t\t RateIdToMbps[pAd->CommonCfg.TxRate], RateIdToMbps[pAd->CommonCfg.RtsRate], BasicRateBitmap));\n\tDBGPRINT(RT_DEBUG_TRACE, (\"MlmeUpdateTxRates (MlmeTransmit=0x%x, MinHTPhyMode=%x, MaxHTPhyMode=0x%x, HTPhyMode=0x%x)\\n\",\n\t\t\t pAd->CommonCfg.MlmeTransmit.word, pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word ,pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word ));\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*! \\brief This function fills in the function pointer into the cell in the state machine\n *\t\\param *S\tpointer to the state machine\n *\t\\param St\tstate\n *\t\\param Msg\tincoming message\n *\t\\param f\tthe function to be executed when (state, message) combination occurs at the state machine\n *\t\\pre *S should be a legal pointer to the state machine, st, msg, should be all within the range, Base should be set in the initial state\n *\t\\post\n\n IRQL = PASSIVE_LEVEL\n\n */\n", "func_signal": "VOID StateMachineSetAction(\n\tIN STATE_MACHINE *S,\n\tIN ULONG St,\n\tIN ULONG Msg,\n\tIN STATE_MACHINE_FUNC Func)", "code": "{\n\tULONG MsgIdx;\n\n\tMsgIdx = Msg - S->Base;\n\n\tif (St < S->NrState && MsgIdx < S->NrMsg)\n\t{\n\t\t// boundary checking before setting the action\n\t\tS->TransFunc[St * S->NrMsg + MsgIdx] = Func;\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\n\tLoad RF normal operation-mode setup\n\n\t==========================================================================\n */\n", "func_signal": "VOID RT30xxLoadRFNormalModeSetup(\n\tIN PRTMP_ADAPTER \tpAd)", "code": "{\n\tUCHAR RFValue;\n\n\t// RX0_PD & TX0_PD, RF R1 register Bit 2 & Bit 3 to 0 and RF_BLOCK_en,RX1_PD & TX1_PD, Bit0, Bit 4 & Bit5 to 1\n\tRT30xxReadRFRegister(pAd, RF_R01, &RFValue);\n\tRFValue = (RFValue & (~0x0C)) | 0x31;\n\tRT30xxWriteRFRegister(pAd, RF_R01, RFValue);\n\n\t// TX_LO2_en, RF R15 register Bit 3 to 0\n\tRT30xxReadRFRegister(pAd, RF_R15, &RFValue);\n\tRFValue &= (~0x08);\n\tRT30xxWriteRFRegister(pAd, RF_R15, RFValue);\n\n\t// TX_LO1_en, RF R17 register Bit 3 to 0\n\tRT30xxReadRFRegister(pAd, RF_R17, &RFValue);\n\tRFValue &= (~0x08);\n\t// to fix rx long range issue\n\tif (((pAd->MACVersion & 0xffff) >= 0x0211) && (pAd->NicConfig2.field.ExternalLNAForG == 0))\n\t{\n\t\tRFValue |= 0x20;\n\t}\n\tRT30xxWriteRFRegister(pAd, RF_R17, RFValue);\n\n\t// RX_LO1_en, RF R20 register Bit 3 to 0\n\tRT30xxReadRFRegister(pAd, RF_R20, &RFValue);\n\tRFValue &= (~0x08);\n\tRT30xxWriteRFRegister(pAd, RF_R20, RFValue);\n\n\t// RX_LO2_en, RF R21 register Bit 3 to 0\n\tRT30xxReadRFRegister(pAd, RF_R21, &RFValue);\n\tRFValue &= (~0x08);\n\tRT30xxWriteRFRegister(pAd, RF_R21, RFValue);\n\n\t// LDORF_VC, RF R27 register Bit 2 to 0\n\tRT30xxReadRFRegister(pAd, RF_R27, &RFValue);\n\tif ((pAd->MACVersion & 0xffff) < 0x0211)\n\t\tRFValue = (RFValue & (~0x77)) | 0x3;\n\telse\n\t\tRFValue = (RFValue & (~0x77));\n\tRT30xxWriteRFRegister(pAd, RF_R27, RFValue);\n\t/* end johnli */\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*! \\brief generates a random mac address value for IBSS BSSID\n *\t\\param Addr the bssid location\n *\t\\return none\n *\t\\pre\n *\t\\post\n */\n", "func_signal": "VOID MacAddrRandomBssid(\n\tIN PRTMP_ADAPTER pAd,\n\tOUT PUCHAR pAddr)", "code": "{\n\tINT i;\n\n\tfor (i = 0; i < MAC_ADDR_LEN; i++)\n\t{\n\t\tpAddr[i] = RandomByte(pAd);\n\t}\n\n\tpAddr[0] = (pAddr[0] & 0xfe) | 0x02;  // the first 2 bits must be 01xxxxxxxx\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "// IRQL = DISPATCH_LEVEL\n", "func_signal": "VOID BssTableSortByRssi(\n\tIN OUT BSS_TABLE *OutTab)", "code": "{\n\tINT \t  i, j;\n\tBSS_ENTRY TmpBss;\n\n\tfor (i = 0; i < OutTab->BssNr - 1; i++)\n\t{\n\t\tfor (j = i+1; j < OutTab->BssNr; j++)\n\t\t{\n\t\t\tif (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi)\n\t\t\t{\n\t\t\t\tNdisMoveMemory(&TmpBss, &OutTab->BssEntry[j], sizeof(BSS_ENTRY));\n\t\t\t\tNdisMoveMemory(&OutTab->BssEntry[j], &OutTab->BssEntry[i], sizeof(BSS_ENTRY));\n\t\t\t\tNdisMoveMemory(&OutTab->BssEntry[i], &TmpBss, sizeof(BSS_ENTRY));\n\t\t\t}\n\t\t}\n\t}\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tSet My BSSID\n\n\tIRQL = DISPATCH_LEVEL\n\n\t==========================================================================\n */\n", "func_signal": "VOID AsicSetBssid(\n\tIN PRTMP_ADAPTER pAd,\n\tIN PUCHAR pBssid)", "code": "{\n\tULONG\t\t  Addr4;\n\tDBGPRINT(RT_DEBUG_TRACE, (\"==============> AsicSetBssid %x:%x:%x:%x:%x:%x\\n\",\n\t\tpBssid[0],pBssid[1],pBssid[2],pBssid[3], pBssid[4],pBssid[5]));\n\n\tAddr4 = (ULONG)(pBssid[0])\t\t |\n\t\t\t(ULONG)(pBssid[1] << 8)  |\n\t\t\t(ULONG)(pBssid[2] << 16) |\n\t\t\t(ULONG)(pBssid[3] << 24);\n\tRTMP_IO_WRITE32(pAd, MAC_BSSID_DW0, Addr4);\n\n\tAddr4 = 0;\n\t// always one BSSID in STA mode\n\tAddr4 = (ULONG)(pBssid[4]) | (ULONG)(pBssid[5] << 8);\n\n\tRTMP_IO_WRITE32(pAd, MAC_BSSID_DW1, Addr4);\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/* Translate virtual address to physical address.  */\n", "func_signal": "unsigned long\nxencomm_vtop(unsigned long vaddr)", "code": "{\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\n\tif (vaddr == 0)\n\t\treturn 0UL;\n\n\tif (REGION_NUMBER(vaddr) == 5) {\n\t\tpgd_t *pgd;\n\t\tpud_t *pud;\n\t\tpmd_t *pmd;\n\t\tpte_t *ptep;\n\n\t\t/* On ia64, TASK_SIZE refers to current.  It is not initialized\n\t\t   during boot.\n\t\t   Furthermore the kernel is relocatable and __pa() doesn't\n\t\t   work on  addresses.  */\n\t\tif (vaddr >= KERNEL_START\n\t\t    && vaddr < (KERNEL_START + KERNEL_TR_PAGE_SIZE))\n\t\t\treturn vaddr - kernel_virtual_offset;\n\n\t\t/* In kernel area -- virtually mapped.  */\n\t\tpgd = pgd_offset_k(vaddr);\n\t\tif (pgd_none(*pgd) || pgd_bad(*pgd))\n\t\t\treturn ~0UL;\n\n\t\tpud = pud_offset(pgd, vaddr);\n\t\tif (pud_none(*pud) || pud_bad(*pud))\n\t\t\treturn ~0UL;\n\n\t\tpmd = pmd_offset(pud, vaddr);\n\t\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\t\treturn ~0UL;\n\n\t\tptep = pte_offset_kernel(pmd, vaddr);\n\t\tif (!ptep)\n\t\t\treturn ~0UL;\n\n\t\treturn (pte_val(*ptep) & _PFN_MASK) | (vaddr & ~PAGE_MASK);\n\t}\n\n\tif (vaddr > TASK_SIZE) {\n\t\t/* percpu variables */\n\t\tif (REGION_NUMBER(vaddr) == 7 &&\n\t\t    REGION_OFFSET(vaddr) >= (1ULL << IA64_MAX_PHYS_BITS))\n\t\t\tia64_tpa(vaddr);\n\n\t\t/* kernel address */\n\t\treturn __pa(vaddr);\n\t}\n\n\t/* XXX double-check (lack of) locking */\n\tvma = find_extend_vma(current->mm, vaddr);\n\tif (!vma)\n\t\treturn ~0UL;\n\n\t/* We assume the page is modified.  */\n\tpage = follow_page(vma, vaddr, FOLL_WRITE | FOLL_TOUCH);\n\tif (!page)\n\t\treturn ~0UL;\n\n\treturn (page_to_pfn(page) << PAGE_SHIFT) | (vaddr & ~PAGE_MASK);\n}", "path": "arch\\ia64\\xen\\xencomm.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n\t==========================================================================\n\tDescription:\n\t\tGives CCK TX rate 2 more dB TX power.\n\t\tThis routine works only in LINK UP in INFRASTRUCTURE mode.\n\n\t\tcalculate desired Tx power in RF R3.Tx0~5,\tshould consider -\n\t\t0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)\n\t\t1. TxPowerPercentage\n\t\t2. auto calibration based on TSSI feedback\n\t\t3. extra 2 db for CCK\n\t\t4. -10 db upon very-short distance (AvgRSSI >= -40db) to AP\n\n\tNOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),\n\t\tit should be called AFTER MlmeDynamicTxRatSwitching()\n\t==========================================================================\n */\n", "func_signal": "VOID AsicAdjustTxPower(\n\tIN PRTMP_ADAPTER pAd)", "code": "{\n\tINT\t\t\ti, j;\n\tCHAR\t\tDeltaPwr = 0;\n\tBOOLEAN\t\tbAutoTxAgc = FALSE;\n\tUCHAR\t\tTssiRef, *pTssiMinusBoundary, *pTssiPlusBoundary, TxAgcStep;\n\tUCHAR\t\tBbpR1 = 0, BbpR49 = 0, idx;\n\tPCHAR\t\tpTxAgcCompensate;\n\tULONG\t\tTxPwr[5];\n\tCHAR\t\tValue;\n\n#ifdef RT2860\n\tif (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)\n\t\t|| (pAd->bPCIclkOff == TRUE)\n\t\t|| RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)\n\t\t|| RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))\n\t\treturn;\n#endif\n\n\tif (pAd->CommonCfg.BBPCurrentBW == BW_40)\n\t{\n\t\tif (pAd->CommonCfg.CentralChannel > 14)\n\t\t{\n\t\t\tTxPwr[0] = pAd->Tx40MPwrCfgABand[0];\n\t\t\tTxPwr[1] = pAd->Tx40MPwrCfgABand[1];\n\t\t\tTxPwr[2] = pAd->Tx40MPwrCfgABand[2];\n\t\t\tTxPwr[3] = pAd->Tx40MPwrCfgABand[3];\n\t\t\tTxPwr[4] = pAd->Tx40MPwrCfgABand[4];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTxPwr[0] = pAd->Tx40MPwrCfgGBand[0];\n\t\t\tTxPwr[1] = pAd->Tx40MPwrCfgGBand[1];\n\t\t\tTxPwr[2] = pAd->Tx40MPwrCfgGBand[2];\n\t\t\tTxPwr[3] = pAd->Tx40MPwrCfgGBand[3];\n\t\t\tTxPwr[4] = pAd->Tx40MPwrCfgGBand[4];\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (pAd->CommonCfg.Channel > 14)\n\t\t{\n\t\t\tTxPwr[0] = pAd->Tx20MPwrCfgABand[0];\n\t\t\tTxPwr[1] = pAd->Tx20MPwrCfgABand[1];\n\t\t\tTxPwr[2] = pAd->Tx20MPwrCfgABand[2];\n\t\t\tTxPwr[3] = pAd->Tx20MPwrCfgABand[3];\n\t\t\tTxPwr[4] = pAd->Tx20MPwrCfgABand[4];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTxPwr[0] = pAd->Tx20MPwrCfgGBand[0];\n\t\t\tTxPwr[1] = pAd->Tx20MPwrCfgGBand[1];\n\t\t\tTxPwr[2] = pAd->Tx20MPwrCfgGBand[2];\n\t\t\tTxPwr[3] = pAd->Tx20MPwrCfgGBand[3];\n\t\t\tTxPwr[4] = pAd->Tx20MPwrCfgGBand[4];\n\t\t}\n\t}\n\n\t// TX power compensation for temperature variation based on TSSI. try every 4 second\n\tif (pAd->Mlme.OneSecPeriodicRound % 4 == 0)\n\t{\n\t\tif (pAd->CommonCfg.Channel <= 14)\n\t\t{\n\t\t\t/* bg channel */\n\t\t\tbAutoTxAgc         = pAd->bAutoTxAgcG;\n\t\t\tTssiRef            = pAd->TssiRefG;\n\t\t\tpTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];\n\t\t\tpTssiPlusBoundary  = &pAd->TssiPlusBoundaryG[0];\n\t\t\tTxAgcStep          = pAd->TxAgcStepG;\n\t\t\tpTxAgcCompensate   = &pAd->TxAgcCompensateG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a channel */\n\t\t\tbAutoTxAgc         = pAd->bAutoTxAgcA;\n\t\t\tTssiRef            = pAd->TssiRefA;\n\t\t\tpTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];\n\t\t\tpTssiPlusBoundary  = &pAd->TssiPlusBoundaryA[0];\n\t\t\tTxAgcStep          = pAd->TxAgcStepA;\n\t\t\tpTxAgcCompensate   = &pAd->TxAgcCompensateA;\n\t\t}\n\n\t\tif (bAutoTxAgc)\n\t\t{\n\t\t\t/* BbpR1 is unsigned char */\n\t\t\tRTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R49, &BbpR49);\n\n\t\t\t/* (p) TssiPlusBoundaryG[0] = 0 = (m) TssiMinusBoundaryG[0] */\n\t\t\t/* compensate: +4     +3   +2   +1    0   -1   -2   -3   -4 * steps */\n\t\t\t/* step value is defined in pAd->TxAgcStepG for tx power value */\n\n\t\t\t/* [4]+1+[4]   p4     p3   p2   p1   o1   m1   m2   m3   m4 */\n\t\t\t/* ex:         0x00 0x15 0x25 0x45 0x88 0xA0 0xB5 0xD0 0xF0\n\t\t\t   above value are examined in mass factory production */\n\t\t\t/*             [4]    [3]  [2]  [1]  [0]  [1]  [2]  [3]  [4] */\n\n\t\t\t/* plus (+) is 0x00 ~ 0x45, minus (-) is 0xa0 ~ 0xf0 */\n\t\t\t/* if value is between p1 ~ o1 or o1 ~ s1, no need to adjust tx power */\n\t\t\t/* if value is 0xa5, tx power will be -= TxAgcStep*(2-1) */\n\n\t\t\tif (BbpR49 > pTssiMinusBoundary[1])\n\t\t\t{\n\t\t\t\t// Reading is larger than the reference value\n\t\t\t\t// check for how large we need to decrease the Tx power\n\t\t\t\tfor (idx = 1; idx < 5; idx++)\n\t\t\t\t{\n\t\t\t\t\tif (BbpR49 <= pTssiMinusBoundary[idx])  // Found the range\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// The index is the step we should decrease, idx = 0 means there is nothing to compensate\n\t\t\t\t*pTxAgcCompensate = -(TxAgcStep * (idx-1));\n\n\t\t\t\tDeltaPwr += (*pTxAgcCompensate);\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\\n\",\n\t\t\t\t\tBbpR49, TssiRef, TxAgcStep, idx-1));\n\t\t\t}\n\t\t\telse if (BbpR49 < pTssiPlusBoundary[1])\n\t\t\t{\n\t\t\t\t// Reading is smaller than the reference value\n\t\t\t\t// check for how large we need to increase the Tx power\n\t\t\t\tfor (idx = 1; idx < 5; idx++)\n\t\t\t\t{\n\t\t\t\t\tif (BbpR49 >= pTssiPlusBoundary[idx])   // Found the range\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// The index is the step we should increase, idx = 0 means there is nothing to compensate\n\t\t\t\t*pTxAgcCompensate = TxAgcStep * (idx-1);\n\t\t\t\tDeltaPwr += (*pTxAgcCompensate);\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"++ Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\\n\",\n\t\t\t\t\tBbpR49, TssiRef, TxAgcStep, idx-1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*pTxAgcCompensate = 0;\n\t\t\t\tDBGPRINT(RT_DEBUG_TRACE, (\"   Tx Power, BBP R49=%x, TssiRef=%x, TxAgcStep=%x, step = +%d\\n\",\n\t\t\t\t\tBbpR49, TssiRef, TxAgcStep, 0));\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (pAd->CommonCfg.Channel <= 14)\n\t\t{\n\t\t\tbAutoTxAgc         = pAd->bAutoTxAgcG;\n\t\t\tpTxAgcCompensate   = &pAd->TxAgcCompensateG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbAutoTxAgc         = pAd->bAutoTxAgcA;\n\t\t\tpTxAgcCompensate   = &pAd->TxAgcCompensateA;\n\t\t}\n\n\t\tif (bAutoTxAgc)\n\t\t\tDeltaPwr += (*pTxAgcCompensate);\n\t}\n\n\tRTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BbpR1);\n\tBbpR1 &= 0xFC;\n\n\t/* calculate delta power based on the percentage specified from UI */\n\t// E2PROM setting is calibrated for maximum TX power (i.e. 100%)\n\t// We lower TX power here according to the percentage specified from UI\n\tif (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)       // AUTO TX POWER control\n\t\t;\n\telse if (pAd->CommonCfg.TxPowerPercentage > 90)  // 91 ~ 100% & AUTO, treat as 100% in terms of mW\n\t\t;\n\telse if (pAd->CommonCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW\t\t// DeltaPwr -= 1;\n\t{\n\t\tDeltaPwr -= 1;\n\t}\n\telse if (pAd->CommonCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW\t\t// DeltaPwr -= 3;\n\t{\n\t\tDeltaPwr -= 3;\n\t}\n\telse if (pAd->CommonCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW\t\t// DeltaPwr -= 6;\n\t{\n\t\tBbpR1 |= 0x01;\n\t}\n\telse if (pAd->CommonCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW\t\t// DeltaPwr -= 9;\n\t{\n\t\tBbpR1 |= 0x01;\n\t\tDeltaPwr -= 3;\n\t}\n\telse                                           // 0 ~ 9 %, treat as MIN(~3%) in terms of mW\t\t// DeltaPwr -= 12;\n\t{\n\t\tBbpR1 |= 0x02;\n\t}\n\n\tRTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, BbpR1);\n\n\t/* reset different new tx power for different TX rate */\n\tfor(i=0; i<5; i++)\n\t{\n\t\tif (TxPwr[i] != 0xffffffff)\n\t\t{\n\t\t\tfor (j=0; j<8; j++)\n\t\t\t{\n\t\t\t\tValue = (CHAR)((TxPwr[i] >> j*4) & 0x0F); /* 0 ~ 15 */\n\n\t\t\t\tif ((Value + DeltaPwr) < 0)\n\t\t\t\t{\n\t\t\t\t\tValue = 0; /* min */\n\t\t\t\t}\n\t\t\t\telse if ((Value + DeltaPwr) > 0xF)\n\t\t\t\t{\n\t\t\t\t\tValue = 0xF; /* max */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tValue += DeltaPwr; /* temperature compensation */\n\t\t\t\t}\n\n\t\t\t\t/* fill new value to CSR offset */\n\t\t\t\tTxPwr[i] = (TxPwr[i] & ~(0x0000000F << j*4)) | (Value << j*4);\n\t\t\t}\n\n\t\t\t/* write tx power value to CSR */\n\t\t\t/* TX_PWR_CFG_0 (8 tx rate) for\tTX power for OFDM 12M/18M\n\t\t\t\t\t\t\t\t\t\t\tTX power for OFDM 6M/9M\n\t\t\t\t\t\t\t\t\t\t\tTX power for CCK5.5M/11M\n\t\t\t\t\t\t\t\t\t\t\tTX power for CCK1M/2M */\n\t\t\t/* TX_PWR_CFG_1 ~ TX_PWR_CFG_4 */\n\t\t\tRTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + i*4, TxPwr[i]);\n\t\t}\n\t}\n\n}", "path": "drivers\\staging\\rt2860\\common\\mlme.c", "repo_name": "e-yes/mini2440-kernel", "stars": 9, "license": "other", "language": "c", "size": 420176}
{"docstring": "/*\n * Low-level cursor handling routine\n */\n", "func_signal": "static void\ndo_add_cursor (tty_record *record, short x_pos)", "code": "{\n\n\trecord->x_curs = x_pos;\n\tif (record->x_curs >= record->x_size) {\n\t\tif (0L != (record->attribute [TTY_ATTRIB_FLAGS] & TA_WRAP_AROUND)) {\n\t\t\trecord->y_curs ++;\n\t\t\trecord->x_curs = 0;\n\t\t\tif (record->y_curs >= record->y_size) {\n\t\t\t\tif (0L != (record->attribute [TTY_ATTRIB_FLAGS] &\n\t\t\t\t\tTA_INHIBIT_VERT_SCROLL)) {\n\t\t\t\t\trecord->y_curs = record->y_size;\n\t\t\t\t} else {\n\t\t\t\t\tscroll_tty (record->its_window, 0, 1 + record->y_curs -\n\t\t\t\t\t\trecord->y_size);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trecord->x_curs = record->x_size;\n\t\t}\n\t}\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Use the window - unlock pixels\n */\n", "func_signal": "static void\nselect_onscreen_window (tty_record *record)", "code": "{\n\tif (record->uses_gworld) {\n\t\tuse_port (record, record->its_window_world);\n\t\tSetPortWindowPort(record->its_window);\n\t} else {\n\t\tuse_port(record, record->its_window);\n\t}\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Save the current port/world in a safe place for later retrieval\n */\n", "func_signal": "static void\nsave_port (tty_record *record, void *save)", "code": "{\nGWorldPtr gw;\nGDHandle gh;\nGrafPtr gp;\n\n\tif (record->uses_gworld) {\n\t\tGetGWorld (&gw, &gh);\n\t\t*(GWorldPtr *) save = gw;\n\t} else {\n\t\tGetPort (&gp);\n\t\t*(GrafPtr *) save = gp;\n\t}\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Highlighting a specific part of the tty window\n */\n", "func_signal": "short invert_tty_window (WindowPtr window, short from_x, short from_y ,\n\tshort to_x, short to_y)", "code": "{\nRect r;\nRECORD_EXISTS (record);\n\n\tif (from_x > to_x || from_y > to_y) {\n\t\treturn general_failure;\n\t}\n\tpos_rect (record, &r, from_x, from_y, to_x, to_y);\n\tselect_offscreen_port (record);\n\tInvertRect ( &r);\n\taccumulate_rect (record, &r);\n\tif (DRAW_DIRECT) {\n\t\tupdate_tty (window);\n\t} else\n\t\tselect_onscreen_window (record);\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Line drawing - very device dependent\n */\n", "func_signal": "short draw_tty_line (WindowPtr window, short from_x, short from_y ,\n\tshort to_x, short to_y)", "code": "{\nRect r;\nRECORD_EXISTS (record);\n\n\tselect_offscreen_port (record);\n\tMoveTo (from_x, from_y);\n\tLineTo (to_x, to_y);\n\tcanonical_rect (&r, from_x, from_y, to_x, to_y);\n\taccumulate_rect (record, &r);\n\tif (DRAW_DIRECT) {\n\t\tupdate_tty (window);\n\t} else\n\t\tselect_onscreen_window (record);\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Delete or insert operations used by many terminals can bottleneck through\n * here. Note that the order of executin for row/colum insertions is NOT\n * specified. Negative values for num_ mean delete, zero means no effect.\n */\n", "func_signal": "short mangle_tty_rows_columns (WindowPtr window, short from_row, short num_rows,\n\tshort from_column, short num_columns)", "code": "{\nRect r;\nRgnHandle rh = NewRgn ();\nRECORD_EXISTS (record);\n\n\tupdate_tty (window); /* Always make sure screen is OK */\n\tcurs_pos (record, record->x_curs, record->y_curs, 0);\n\n\tif (num_rows) {\n\t\tpos_rect (record, &r, 0, from_row, record->x_size - 1,\n\t\t\trecord->y_size - 1);\n\t\tselect_offscreen_port (record);\n\t\tScrollRect (&r, 0, num_rows * record->row_height, rh);\n\t\tEraseRgn (rh);\n\t\tSetEmptyRgn (rh);\n\t\tselect_onscreen_window (record);\n\t\tScrollRect (&r, 0, num_rows * record->row_height, rh);\n\t\tEraseRgn (rh);\n\t\tSetEmptyRgn (rh);\n\t}\n\tif (num_columns) {\n\t\tpos_rect (record, &r, from_column, 0, record->x_size - 1,\n\t\t\trecord->y_size - 1);\n\t\tselect_offscreen_port (record);\n\t\tScrollRect (&r, num_columns * record->char_width, 0, rh);\n\t\tEraseRgn (rh);\n\t\tSetEmptyRgn (rh);\n\t\tselect_onscreen_window (record);\n\t\tScrollRect (&r, num_columns * record->char_width, 0, rh);\n\t\tEraseRgn (rh);\n\t\tSetEmptyRgn (rh);\n\t}\n\tDisposeRgn (rh);\n\tif (record->x_curs >= from_column) {\n\t\trecord->x_curs += num_columns;\n\t}\n\tif (record->y_curs >= from_row) {\n\t\trecord->y_curs += num_rows;\n\t}\n\tcurs_pos (record, record->x_curs, record->y_curs, 1);\n\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Allocate memory for the bitmap holding the tty window\n */\n", "func_signal": "static short\nalloc_bits (tty_record *record)", "code": "{\nshort s_err;\n\n\tSetRect (&record->its_bits.bounds, 0, 0,\n\t\trecord->char_width * record->x_size,\n\t\trecord->row_height * record->y_size);\n\n/*\n * Clear two highest and lowest bit - not a color pixMap, and even in size\n */\n\trecord->its_bits.rowBytes = ((record->its_bits.bounds.right + 15)\n\t\t>> 3) & 0x1ffe;\n\n\tif (record->uses_gworld) {\n\t\ts_err = allocate_offscreen_world (record);\n#if !TARGET_API_MAC_CARBON\n\t} else {\n\t\ts_err = alloc_ptr ((void **) &(record->its_bits.baseAddr),\n\t\t\trecord->its_bits.rowBytes * record->its_bits.bounds.bottom);\n\t\tif (!s_err) {\n\t\t\ts_err = alloc_ptr ((void **) &(record->offscreen_port),\n\t\t\t\tsizeof (GrafPort));\n\t\t}\n\t\tif (!s_err) {\n\t\t\tOpenPort (record->offscreen_port);\n\t\t\tSetPort (record->offscreen_port);\n\t\t\tClipRect (&(record->its_bits.bounds));\n\t\t\tSetPortBits (&(record->its_bits));\n\t\t}\n#endif\n\t}\n\treturn s_err;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Map a position on the map to screen coordinates\n */\n", "func_signal": "static void\npos_rect (tty_record *record, Rect *r, short x_pos, short y_pos,\n\tshort x_end, short y_end)", "code": "{\n \n\tSetRect (r, x_pos * (record->char_width), y_pos * (record->row_height),\n\t\t(1 + x_end) * (record->char_width) , (1 + y_end) *\n\t\t(record->row_height));\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Update TTY according to new color environment for the window\n */\n", "func_signal": "static short\ntty_environment_changed (tty_record *record)", "code": "{\nPoint p = {0, 0};\nRect r_screen;\n\n\tif (record->uses_gworld) {\n\t\tr_screen = record->its_bits.bounds;\n\t\tLocalToGlobal (&p);\n\t\tOffsetRect (&r_screen, p.h, p.v);\n\t\tUpdateGWorld (&(record->offscreen_world), 0, &r_screen,\n\t\t\t(CTabHandle) 0, (GDHandle) 0, stretchPix);\n\t\tselect_offscreen_port (record);\n\t\tSetOrigin (0, 0);\n\t\tselect_onscreen_window (record);\n\t}\n\treturn 0;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Read or change attributes for the tty. Note that some attribs may\n * very well clear and reallocate the bitmap when changed, whereas\n * others (color, highlight, ...) are guaranteed not to.\n */\n", "func_signal": "short get_tty_attrib (WindowPtr window, tty_attrib attrib, long *value)", "code": "{\nRECORD_EXISTS (record);\n\n\tif (attrib < 0 || attrib >= TTY_NUMBER_ATTRIBUTES) {\n\t\treturn general_failure;\n\t}\n\t*value = record->attribute [attrib];\n\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Union twp rect together\n */\n", "func_signal": "static void\nunion_rect (Rect *r1, Rect *r2, Rect *dest)", "code": "{\n\tdest->left = min (r1->left, r2->left);\n\tdest->top = min (r1->top, r2 ->top);\n\tdest->bottom = max (r1->bottom, r2->bottom);\n\tdest->right = max (r1->right, r2->right);\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Done with GWorld, release data\n */\n", "func_signal": "static short\ndeallocate_gworld (tty_record *record)", "code": "{\n\tif (record->offscreen_world) {\n\t\tDisposeGWorld (record->offscreen_world);\n\t\trecord->offscreen_world = (GWorldPtr) 0;\n\t}\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Done with a window - destroy it. Release the memory only if\n * it wasn't allocated when we got it!\n */\n", "func_signal": "short\ndestroy_tty (WindowPtr window)", "code": "{\nshort s_err;\nRECORD_EXISTS (record);\n\n\ts_err = free_bits (record);\n\tif (!s_err) {\n#if !TARGET_API_MAC_CARBON\n\t\tif (record->was_allocated) {\n\t\t\tCloseWindow (window);\n\t\t} else {\n#endif\n\t\t\tDisposeWindow (window);\n#if !TARGET_API_MAC_CARBON\n\t\t}\n#endif\n\t\ts_err = dispose_ptr (record);\n\t}\n\t\n\treturn s_err;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Add a null-terminated string of characters\n */\n", "func_signal": "short\nadd_tty_string(WindowPtr window, const char *string)", "code": "{\n\tregister const unsigned char * start_c;\n\tregister const unsigned char * the_c;\n\tregister unsigned char ch, is_control = 0, tty_wrap;\n\tregister short max_x, pos_x;\n\tRECORD_EXISTS (record);\n\n\tif (record->curs_state != 0)\n\t\tcurs_pos (record, record->x_curs, record->y_curs, 0);\n\n\tthe_c = (const unsigned char *) string;\n\tmax_x = record->x_size;\n\ttty_wrap = (record->attribute [TTY_ATTRIB_FLAGS] & TA_WRAP_AROUND);\n\tfor (;;) {\n\t\tpos_x = record->x_curs;\n\t\tif (!tty_wrap && pos_x >= max_x) \n\t\t\tbreak;\t\t/* Optimize away drawing across border without wrap */\n\n\t\tstart_c = the_c;\n\t\tch = *the_c;\n\t\twhile (pos_x < max_x) {\n\t\t\tis_control = (ch < sizeof(long) * 8) && ((s_control & (1 << ch)) != 0L);\n\t\t\tif (is_control)\n\t\t\t\tbreak;\n\t\t\tthe_c ++; ch = *the_c;\n\t\t\tpos_x ++;\n\t\t}\n\t\tdo_add_string (record, (char *) start_c, the_c - start_c);\n\t\tdo_add_cursor (record, pos_x);\n\t\tif (!ch)\n\t\t\tbreak;\n\n\t\tif (is_control) {\n\t\t\tdo_control (record, ch);\n\t\t\tthe_c ++;\n\t\t}\n\t}\n\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/* Use alloc.c instead */\n/*\n * Allocate a pointer using the set memory-allocator\n */\n", "func_signal": "static short\nalloc_ptr (void **ptr, long size)", "code": "{\n\t*ptr = NewPtr (size);\n\treturn MemError ();\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Scroll the window. Positive is up/left. scroll_tty ( window, 0, 1 ) is a line feed.\n * Scroll flushes the accumulated update area by calling update_tty().\n */\n", "func_signal": "short scroll_tty (WindowPtr window, short delta_x, short delta_y)", "code": "{\nRgnHandle rgn;\nshort s_err;\nRECORD_EXISTS (record);\n\n\ts_err = update_tty (window);\n\n\trgn = NewRgn ();\n\n\tselect_offscreen_port (record);\n\tScrollRect (&(record->its_bits.bounds), -delta_x * record->char_width,\n\t\t-delta_y * record->row_height, rgn);\n\tEraseRgn (rgn);\n\tSetEmptyRgn (rgn);\n\n\tselect_onscreen_window (record);\n\tScrollRect (&(record->its_bits.bounds), -delta_x * record->char_width,\n\t\t-delta_y*record->row_height, rgn);\n\tEraseRgn (rgn);\n\tDisposeRgn (rgn);\n\n\trecord->y_curs -= delta_y;\n\trecord->x_curs -= delta_x;\n\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Recalculate the window based on new size, font, extent values,\n * and re-allocate the bitmap.\n */\n", "func_signal": "short\nforce_tty_coordinate_system_recalc (WindowPtr window)", "code": "{\nshort s_err;\nRECORD_EXISTS (record);\n\n\ts_err = free_bits (record);\n\tif (s_err) {\n\t\treturn s_err;\n\t}\n\tcalc_font_sizes (record);\n\n\ts_err = alloc_bits (record);\n\tif (s_err) {\n/*\n * Catastrophe! We could not allocate memory for the bitmap! Things may go very\n * much downhill from here!\n */\n \t\tdprintf (\"alloc_bits returned null in force_tty_coordinate_system_recalc!\");\n\t\treturn s_err;\n\t}\n\tselect_offscreen_port (record);\n\tdo_set_port_font (record);\n\treturn clear_tty (window);\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Set up a GWorld in the record\n */\n", "func_signal": "static short\nallocate_offscreen_world (tty_record *record)", "code": "{\nGWorldPtr gw = (GWorldPtr)0;\nGWorldFlags world_flags = 0;\nlong mem_here, mem_there, other, required_mem;\nPoint p = {0, 0};\nRect r_screen;\nGDHandle gdh;\nshort s_err;\n\n\tselect_onscreen_window (record);\n\tLocalToGlobal (&p);\n\tr_screen = record->its_bits.bounds;\n\tOffsetRect (&r_screen, p.h, p.v);\n\n\tgdh = GetMaxDevice (&r_screen);\n\trequired_mem = (long) (*((*gdh)->gdPMap))->pixelSize *\n\t\t((long) record->its_bits.bounds.right *\n\t\trecord->its_bits.bounds.bottom) >> 3;\n\n\tPurgeSpace (&other, &mem_here);\n\tif (other < mem_here + MEMORY_MARGIN) {\n\t\tmem_here = other - MEMORY_MARGIN;\n\t}\n\tdprintf (\"Heap %ld Required %ld\", mem_here, required_mem);\n\tif (required_mem > mem_here) {\n\t\tmem_there = required_mem;\n\t\tif (required_mem > TempMaxMem (&mem_there)) {\n\t\t\tdprintf (\"No memory\");\n\t\t\treturn memFullErr;\n\t\t}\n\t\tworld_flags |= useTempMem;\n\t}\n\ts_err = NewGWorld (&gw, 0, &r_screen, (CTabHandle) 0, (GDHandle) 0, world_flags);\n\tif (!s_err) {\n\t\trecord->offscreen_world = gw;\n\t\tselect_offscreen_port (record);\n\t\tSetOrigin (0, 0);\n\t\tselect_onscreen_window (record);\n\t\tdprintf (\"New GWorld @ %lx;dm\", gw);\n\t}\n\treturn s_err;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Get rid of offscreen bitmap\n */\n", "func_signal": "static short\nfree_bits (tty_record *record)", "code": "{\n\tshort s_err;\n\n\tif (record->uses_gworld) {\n\t\ts_err = deallocate_gworld (record);\n#if !TARGET_API_MAC_CARBON\n\t} else {\n\t\ts_err = dispose_ptr (record->its_bits.baseAddr);\n\t\tif (!s_err) {\n\t\t\trecord->its_bits.baseAddr = (char *)0;\n\t\t\tif (record->offscreen_port) {\n\t\t\t\tClosePort (record->offscreen_port);\n\t\t\t\ts_err = dispose_ptr (record->offscreen_port);\n\t\t\t\tif (!s_err) {\n\t\t\t\t\trecord->offscreen_port = (GrafPtr) 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn s_err;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "/*\n * Clear an area\n */\n", "func_signal": "short clear_tty_window (WindowPtr window, short from_x, short from_y,\n\tshort to_x, short to_y)", "code": "{\nRect r;\nRECORD_EXISTS (record);\n\n\tif (from_x > to_x || from_y > to_y) {\n\t\treturn general_failure;\n\t}\n\tpos_rect (record, &r, from_x, from_y, to_x, to_y);\n\tselect_offscreen_port (record);\n\terase_rect (record, &r);\n\taccumulate_rect (record, &r);\n\tif (DRAW_DIRECT) {\n\t\tupdate_tty (window);\n\t} else\n\t\tselect_onscreen_window (record);\n\treturn noErr;\n}", "path": "sys\\mac\\mactty.c", "repo_name": "harningt/nethack", "stars": 8, "license": "None", "language": "c", "size": 7174}
{"docstring": "//===========================================================================================================================\n//\tAddInterfaceToList\n//===========================================================================================================================\n", "func_signal": "mDNSlocal NetworkInterfaceInfoVxWorks *\tAddInterfaceToList( mDNS *const inMDNS, struct ifaddrs *inIFA, mDNSs32 inUTC )", "code": "{\n\tmStatus\t\t\t\t\t\t\t\terr;\n\tmDNSAddr\t\t\t\t\t\t\tip;\n\tmDNSAddr\t\t\t\t\t\t\tmask;\n\tmDNSu32\t\t\t\t\t\t\t\tscopeID;\n\tNetworkInterfaceInfoVxWorks **\t\tp;\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\t\n\ti = NULL;\n\t\n\terr = SockAddrToMDNSAddr( inIFA->ifa_addr, &ip );\n\trequire_noerr( err, exit );\n\t\n\terr = SockAddrToMDNSAddr( inIFA->ifa_netmask, &mask );\n\trequire_noerr( err, exit );\n\t\n\t// Search for an existing interface with the same info. If found, just return that one.\n\t\n\tscopeID = if_nametoindex( inIFA->ifa_name );\n\tcheck( scopeID );\n\tfor( p = &inMDNS->p->interfaceList; *p; p = &( *p )->next )\n\t{\n\t\tif( ( scopeID == ( *p )->scopeID ) && mDNSSameAddress( &ip, &( *p )->ifinfo.ip ) )\n\t\t{\n\t\t\tdmsg( kDebugLevelInfo, DEBUG_NAME \"%s: Found existing interface %u with address %#a at %#p\\n\", __ROUTINE__, \n\t\t\t\tscopeID, &ip, *p );\n\t\t\t( *p )->exists = mDNStrue;\n\t\t\ti = *p;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\t\n\t// Allocate the new interface info and fill it out.\n\t\n\ti = (NetworkInterfaceInfoVxWorks *) calloc( 1, sizeof( *i ) );\n\trequire( i, exit );\n\t\n\tdmsg( kDebugLevelInfo, DEBUG_NAME \"%s: Making   new   interface %u with address %#a at %#p\\n\", __ROUTINE__, scopeID, &ip, i );\n\tstrncpy( i->ifinfo.ifname, inIFA->ifa_name, sizeof( i->ifinfo.ifname ) );\t\n\ti->ifinfo.ifname[ sizeof( i->ifinfo.ifname ) - 1 ] = '\\0';\n\ti->ifinfo.InterfaceID\t= NULL;\n\ti->ifinfo.ip\t\t\t= ip;\n\ti->ifinfo.mask\t\t\t= mask;\n\ti->ifinfo.Advertise\t\t= inMDNS->AdvertiseLocalAddresses;\n\ti->ifinfo.McastTxRx\t\t= mDNSfalse; // For now; will be set up later at the end of UpdateInterfaceList.\n\t\n\ti->next\t\t\t\t\t= NULL;\n\ti->exists\t\t\t\t= mDNStrue;\n\ti->lastSeen\t\t\t\t= inUTC;\n\ti->scopeID\t\t\t\t= scopeID;\n\ti->family\t\t\t\t= inIFA->ifa_addr->sa_family;\n\ti->multicast\t\t\t= ( inIFA->ifa_flags & IFF_MULTICAST ) && !( inIFA->ifa_flags & IFF_POINTOPOINT );\n\t\n\ti->ss.info\t\t\t\t= i;\n\ti->ss.sockV4\t\t\t= kInvalidSocketRef;\n\ti->ss.sockV6\t\t\t= kInvalidSocketRef;\n\t*p = i;\n\t\nexit:\n\treturn( i );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tSendCommand\n//===========================================================================================================================\n", "func_signal": "mDNSlocal mStatus\tSendCommand( const mDNS * const inMDNS, MDNSPipeCommandCode inCommandCode )", "code": "{\n\tmStatus\t\terr;\n\t\n\trequire_action_quiet( inMDNS->p->commandPipe != ERROR, exit, err = mStatus_NotInitializedErr );\n\t\n\terr = write( inMDNS->p->commandPipe, &inCommandCode, sizeof( inCommandCode ) );\n\terr = translate_errno( err >= 0, errno_compat(), kWriteErr );\n\trequire_noerr( err, exit );\n\t\nexit:\n\treturn( err );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tClearInactiveInterfaces\n//\n//\tReturns count of non-link local IPv4 addresses de-registered.\n//===========================================================================================================================\n", "func_signal": "mDNSlocal int\tClearInactiveInterfaces( mDNS *const inMDNS, mDNSs32 inUTC, mDNSBool inClosing )", "code": "{\n\tint\t\t\t\t\t\t\t\t\tcount;\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\tNetworkInterfaceInfoVxWorks **\t\tp;\n\t\n\t// First pass:\n\t// If an interface is going away, then de-register it from mDNSCore.\n\t// We also have to de-register it if the primary interface that it's using for its InterfaceID is going away.\n\t// We have to do this because mDNSCore will use that InterfaceID when sending packets, and if the memory\n\t// it refers to has gone away, we'll crash. Don't actually close the sockets or free the memory yet though: \n\t// When the last representative of an interface goes away mDNSCore may want to send goodbye packets on that \n\t// interface. (Not yet implemented, but a good idea anyway.).\n\t\n\tcount = 0;\n\tfor( i = inMDNS->p->interfaceList; i; i = i->next )\n\t{\n\t\tNetworkInterfaceInfoVxWorks *\t\tprimary;\n\t\t\n\t\t// 1. If this interface is no longer active, or its InterfaceID is changing, de-register it.\n\t\t\n\t\tif( !i->ifinfo.InterfaceID ) continue;\n\t\tprimary = FindInterfaceByIndex( inMDNS, i->family, i->scopeID );\n\t\tif( ( i->exists == 0 ) || ( i->exists == 2 ) || ( i->ifinfo.InterfaceID != (mDNSInterfaceID) primary ) )\n\t\t{\n\t\t\tdmsg( kDebugLevelInfo, DEBUG_NAME \"%s: Deregistering %8s(%u) InterfaceID %#p %#a%s\\n\", __ROUTINE__, \n\t\t\t\ti->ifinfo.ifname, i->scopeID, i->ifinfo.InterfaceID, &i->ifinfo.ip, \n\t\t\t\ti->ifinfo.InterfaceActive ? \" (Primary)\" : \"\" );\n\t\t\t\n\t\t\tmDNS_DeregisterInterface( inMDNS, &i->ifinfo, mDNSfalse );\n\t\t\ti->ifinfo.InterfaceID = NULL;\n\t\t\tif( mDNSAddressIsNonLinkLocalIPv4( &i->ifinfo.ip ) ) ++count;\n\t\t}\n\t}\n\t\n\t// Second pass:\n\t// Now that everything that's going to de-register has done so, we can close sockets and free the memory.\n\t\n\tp = &inMDNS->p->interfaceList;\n\twhile( *p )\n\t{\n\t\ti = *p;\n\t\t\n\t\t// 2. Close all our sockets. We'll recreate them later as needed.\n\t\t// (We may have previously had both v4 and v6, and we may not need both any more.).\n\t\t\n\t\tForgetSocket( &i->ss.sockV4 );\n\t\tForgetSocket( &i->ss.sockV6 );\n\t\t\n\t\t// 3. If no longer active, remove the interface from the list and free its memory.\n\t\t\n\t\tif( !i->exists )\n\t\t{\n\t\t\tmDNSBool\t\tdeleteIt;\n\t\t\t\n\t\t\tif( inClosing )\n\t\t\t{\n\t\t\t\tcheck_string( NumCacheRecordsForInterfaceID( inMDNS, (mDNSInterfaceID) i ) == 0, \"closing with in-use records!\" );\n\t\t\t\tdeleteIt = mDNStrue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i->lastSeen == inUTC ) i->lastSeen = inUTC - 1;\n\t\t\t\tdeleteIt = ( NumCacheRecordsForInterfaceID( inMDNS, (mDNSInterfaceID) i ) == 0 ) && ( ( inUTC - i->lastSeen ) >= 60 );\n\t\t\t}\n\t\t\tdmsg( kDebugLevelInfo, DEBUG_NAME \"%s: %-13s %8s(%u) InterfaceID %#p %#a Age %d%s\\n\", __ROUTINE__, \n\t\t\t\tdeleteIt ? \"Deleting\" : \"Holding\", i->ifinfo.ifname, i->scopeID, i->ifinfo.InterfaceID, &i->ifinfo.ip, \n\t\t\t\tinUTC - i->lastSeen, i->ifinfo.InterfaceActive ? \" (Primary)\" : \"\" );\n\t\t\tif( deleteIt )\n\t\t\t{\n\t\t\t\t*p = i->next;\n\t\t\t\tfree( i );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tp = &i->next;\n\t}\n\treturn( count );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tTearDownCommandPipe\n//===========================================================================================================================\n", "func_signal": "mDNSlocal mStatus\tTearDownCommandPipe( mDNS * const inMDNS )", "code": "{\n\tmStatus\t\terr;\n\t\n\tif( inMDNS->p->commandPipe != ERROR )\n\t{\n\t\terr = close( inMDNS->p->commandPipe );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kUnknownErr );\n\t\tinMDNS->p->commandPipe = ERROR;\n\t\t\n\t\terr = pipeDevDelete( \"/pipe/mDNS\", FALSE );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kUnknownErr );\n\t}\n\treturn( mStatus_NoError );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tConnection-oriented (TCP) functions\n//===========================================================================================================================\n", "func_signal": "mDNSexport mStatus mDNSPlatformTCPConnect(const mDNSAddr *dst, mDNSOpaque16 dstport, mDNSInterfaceID InterfaceID,\n\t\t\t\t\t\t\t\t\t\t  TCPConnectionCallback callback, void *context, int *descriptor)", "code": "{\n\t(void)dst;\t\t\t// Unused\n\t(void)dstport;\t\t// Unused\n\t(void)InterfaceID;\t// Unused\n\t(void)callback;\t\t// Unused\n\t(void)context;\t\t// Unused\n\t(void)descriptor;\t// Unused\n\treturn(mStatus_UnsupportedErr);\n\t}\n\nmDNSexport void mDNSPlatformTCPCloseConnection(int sd)\n\t{\n\t(void)sd;\t\t\t// Unused\n\t}\n\nmDNSexport long mDNSPlatformReadTCP(int sd, void *buf, unsigned long buflen)\n\t{\n\t(void)sd;\t\t\t// Unused\n\t(void)buf;\t\t\t// Unused\n\t(void)buflen;\t\t// Unused\n\treturn(0);\n\t}\n\nmDNSexport long mDNSPlatformWriteTCP(int sd, const char *msg, unsigned long len)\n\t{\n\t(void)sd;\t\t\t// Unused\n\t(void)msg;\t\t\t// Unused\n\t(void)len;\t\t\t// Unused\n\treturn(0);\n\t}\n\n//===========================================================================================================================\n//\tmDNSPlatformLock\n//===========================================================================================================================\n\nvoid\tmDNSPlatformLock( const mDNS * const inMDNS )\n{\n\tcheck_string( inMDNS->p && ( inMDNS->p->taskID != ERROR ), \"mDNS task not started\" );\n\t\n#if( DEBUG )\n\tif( semTake( inMDNS->p->lock, 60 * sysClkRateGet() ) != OK )\n\t{\n\t\tdmsg( kDebugLevelTragic, \"\\n### DEADLOCK DETECTED ### (sem=%#p, task=%#p)\\n\\n\", inMDNS->p->lock, taskIdSelf() );\n\t\tdebug_stack_trace();\t\t\t// 1) Print Stack Trace.\n\t\tsemShow( inMDNS->p->lock, 1 );\t// 2) Print semaphore info, including which tasks are pending on it.\n\t\ttaskSuspend( 0 );\t\t\t\t// 3) Suspend task. Can be resumed from the console for debugging.\n\t}\n#else\n\tsemTake( inMDNS->p->lock, WAIT_FOREVER );\n#endif\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSRecvMsg\n//===========================================================================================================================\n", "func_signal": "mDNSlocal ssize_t\n\tmDNSRecvMsg( \n\t\tSocketRef\tinSock, \n\t\tvoid *\t\tinBuffer, \n\t\tsize_t\t\tinBufferSize, \n\t\tvoid *\t\toutFrom, \n\t\tsize_t\t\tinFromSize, \n\t\tsize_t *\toutFromSize, \n\t\tmDNSAddr *\toutDstAddr, \n\t\tuint32_t *\toutIndex )", "code": "{\n\tstruct msghdr\t\t\tmsg;\n\tstruct iovec\t\t\tiov;\n\tssize_t\t\t\t\t\tn;\n\tchar\t\t\t\t\tancillary[ 1024 ];\n\tstruct cmsghdr *\t\tcmPtr;\n\tint\t\t\t\t\t\terr;\n\t\n\t// Read a packet and any ancillary data. Note: EWOULDBLOCK errors are expected when we've read all pending packets.\n\t\n\tiov.iov_base\t\t= (char *) inBuffer;\n\tiov.iov_len\t\t\t= inBufferSize;\n\tmsg.msg_name\t\t= (caddr_t) outFrom;\n\tmsg.msg_namelen\t\t= inFromSize;\n\tmsg.msg_iov\t\t\t= &iov;\n\tmsg.msg_iovlen\t\t= 1;\n\tmsg.msg_control\t\t= (caddr_t) &ancillary;\n\tmsg.msg_controllen\t= sizeof( ancillary );\n\tmsg.msg_flags\t\t= 0;\n\tn = recvmsg( inSock, &msg, 0 );\n\tif( n < 0 )\n\t{\n\t\terr = errno_compat();\n\t\tif( err != EWOULDBLOCK ) dmsg( kDebugLevelWarning, DEBUG_NAME \"%s: recvmsg(%d) returned %d, errno %d\\n\", \n\t\t\t__ROUTINE__, inSock, n, err );\n\t\tgoto exit;\n\t}\n\tif( msg.msg_controllen < sizeof( struct cmsghdr ) )\n\t{\n\t\tdmsg( kDebugLevelWarning, DEBUG_NAME \"%s: recvmsg(%d) msg_controllen %d < sizeof( struct cmsghdr ) %u\\n\", \n\t\t\t__ROUTINE__, inSock, msg.msg_controllen, sizeof( struct cmsghdr ) );\n\t\tn = mStatus_UnknownErr;\n\t\tgoto exit;\n\t}\n\tif( msg.msg_flags & MSG_CTRUNC )\n\t{\n\t\tdmsg( kDebugLevelWarning, DEBUG_NAME \"%s: recvmsg(%d) MSG_CTRUNC (%d recv'd)\\n\", __ROUTINE__, inSock, n );\n\t\tn = mStatus_BadFlagsErr;\n\t\tgoto exit;\n\t}\n\t*outFromSize = msg.msg_namelen;\n\t\n\t// Parse each option out of the ancillary data.\n\t\n\tfor( cmPtr = CMSG_FIRSTHDR( &msg ); cmPtr; cmPtr = CMSG_NXTHDR( &msg, cmPtr ) )\n\t{\n\t\tif( ( cmPtr->cmsg_level == IPPROTO_IP ) && ( cmPtr->cmsg_type == IP_RECVDSTADDR ) )\n\t\t{\n\t\t\toutDstAddr->type\t\t\t\t= mDNSAddrType_IPv4;\n\t\t\toutDstAddr->ip.v4.NotAnInteger\t= *( (mDNSu32 *) CMSG_DATA( cmPtr ) );\n\t\t}\n\t\telse if( ( cmPtr->cmsg_level == IPPROTO_IP ) && ( cmPtr->cmsg_type == IP_RECVIF ) )\n\t\t{\n\t\t\tstruct sockaddr_dl *\t\tsdl;\n\t\t\t\n\t\t\tsdl = (struct sockaddr_dl *) CMSG_DATA( cmPtr );\n\t\t\t*outIndex = sdl->sdl_index;\n\t\t}\n\t\telse if( ( cmPtr->cmsg_level == IPPROTO_IPV6 ) && ( cmPtr->cmsg_type == IPV6_PKTINFO ) )\n\t\t{\n\t\t\tstruct in6_pktinfo *\t\tpi6;\n\t\t\t\n\t\t\tpi6 = (struct in6_pktinfo *) CMSG_DATA( cmPtr );\n\t\t\toutDstAddr->type\t= mDNSAddrType_IPv6;\n\t\t\toutDstAddr->ip.v6\t= *( (mDNSv6Addr *) &pi6->ipi6_addr );\n\t\t\t*outIndex\t\t\t= pi6->ipi6_ifindex;\n\t\t}\n\t}\n\t\nexit:\n\treturn( n );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformInterfaceIndexfromInterfaceID\n//===========================================================================================================================\n", "func_signal": "mDNSexport mDNSu32\tmDNSPlatformInterfaceIndexfromInterfaceID( mDNS *const inMDNS, mDNSInterfaceID inID )", "code": "{\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\n\tif( inID == mDNSInterface_LocalOnly ) return( (mDNSu32) -1 );\n\tif( inID )\n\t{\n\t\t// Don't use i->ifinfo.InterfaceID here, because we DO want to find inactive interfaces.\n\t\t\n\t\tfor( i = inMDNS->p->interfaceList; i && ( (mDNSInterfaceID) i != inID ); i = i->next ) {}\n\t\tif( i ) return( i->scopeID );\n\t}\n\treturn( 0 );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformInterfaceIDToInfo\n//===========================================================================================================================\n", "func_signal": "mStatus\tmDNSPlatformInterfaceIDToInfo( mDNS * const inMDNS, mDNSInterfaceID inID, mDNSPlatformInterfaceInfo *outInfo )", "code": "{\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\n\t// Don't use i->ifinfo.InterfaceID here, because we DO want to find inactive interfaces.\n\t\n\tfor( i = inMDNS->p->interfaceList; i && ( (mDNSInterfaceID) i != inID ); i = i->next ) {}\n\tif( !i ) return( mStatus_NoSuchNameErr );\n\t\n\toutInfo->name \t= i->ifinfo.ifname;\n\toutInfo->ip \t= i->ifinfo.ip;\n\treturn( mStatus_NoError );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tFindInterfaceByIndex\n//===========================================================================================================================\n", "func_signal": "mDNSlocal NetworkInterfaceInfoVxWorks *\tFindInterfaceByIndex( mDNS *const inMDNS, int inFamily, mDNSu32 inIndex )", "code": "{\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\n\tcheck( inIndex != 0 );\n\t\n\tfor( i = inMDNS->p->interfaceList; i; i = i->next )\n\t{\n\t\tif( i->exists && ( i->scopeID == inIndex ) &&\n\t\t\t( MDNS_AAAA_OVER_IPV4\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t||\n\t\t\t  ( ( inFamily == AF_INET  ) && ( i->ifinfo.ip.type == mDNSAddrType_IPv4 ) )\t||\n\t\t\t  ( ( inFamily == AF_INET6 ) && ( i->ifinfo.ip.type == mDNSAddrType_IPv6 ) ) ) )\n\t\t{\n\t\t\treturn( i );\n\t\t}\n\t}\n\treturn( NULL );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tTask\n//===========================================================================================================================\n", "func_signal": "mDNSlocal void\tTask( mDNS *inMDNS )", "code": "{\n\tmStatus\t\t\t\t\t\t\t\terr;\n\tmDNSs32\t\t\t\t\t\t\t\tnextEvent;\n\tfd_set\t\t\t\t\t\t\t\treadSet;\n\tint\t\t\t\t\t\t\t\t\tmaxFd;\n\tstruct timeval\t\t\t\t\t\ttimeout;\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\tint\t\t\t\t\t\t\t\t\tfd;\n\tint\t\t\t\t\t\t\t\t\tn;\n\t\n\tcheck( inMDNS );\n\t\n\terr = TaskInit( inMDNS );\n\trequire_noerr( err, exit );\n\t\n\twhile( !inMDNS->p->quit )\n\t{\n\t\t// Let mDNSCore do its work then wait for an event. On idle timeouts (n == 0), just loop back to mDNS_Exceute.\n\t\t\n\t\tnextEvent = mDNS_Execute( inMDNS );\n\t\tTaskSetupSelect( inMDNS, &readSet, &maxFd, nextEvent, &timeout );\t\t\t\n\t\tn = select( maxFd + 1, &readSet, NULL, NULL, &timeout );\n\t\tcheck_translated_errno( n >= 0, errno_compat(), kUnknownErr );\n\t\tif( n == 0 ) continue;\n\t\t\n\t\t// Process interface-specific sockets with pending data.\n\t\t\n\t\tn = 0;\n\t\tfor( i = inMDNS->p->interfaceList; i; i = i->next )\n\t\t{\n\t\t\tfd = i->ss.sockV4;\n\t\t\tif( IsValidSocket( fd ) && FD_ISSET( fd, &readSet ) )\n\t\t\t{\n\t\t\t\tTaskProcessPackets( inMDNS, &i->ss, fd );\n\t\t\t\t++n;\n\t\t\t}\n\t\t\tfd = i->ss.sockV6;\n\t\t\tif( IsValidSocket( fd ) && FD_ISSET( fd, &readSet ) )\n\t\t\t{\n\t\t\t\tTaskProcessPackets( inMDNS, &i->ss, fd );\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Process unicast sockets with pending data.\n\t\t\n\t\tfd = inMDNS->p->unicastSS.sockV4;\n\t\tif( IsValidSocket( fd ) && FD_ISSET( fd, &readSet ) )\n\t\t{\n\t\t\tTaskProcessPackets( inMDNS, &inMDNS->p->unicastSS, fd );\n\t\t\t++n;\n\t\t}\n\t\tfd = inMDNS->p->unicastSS.sockV6;\n\t\tif( IsValidSocket( fd ) && FD_ISSET( fd, &readSet ) )\n\t\t{\n\t\t\tTaskProcessPackets( inMDNS, &inMDNS->p->unicastSS, fd );\n\t\t\t++n;\n\t\t}\n\t\t\n\t\t// Processing pending commands.\n\t\t\n\t\tfd = inMDNS->p->commandPipe;\n\t\tcheck( fd >= 0 );\n\t\tif( FD_ISSET( fd, &readSet ) )\n\t\t{\n\t\t\tProcessCommand( inMDNS );\n\t\t\t++n;\n\t\t}\n\t\tcheck_string( n > 0, \"select said something was readable, but nothing was\" );\n\t}\n\nexit:\n\tTaskTerm( inMDNS );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tFindRoutableIPv4\n//===========================================================================================================================\n", "func_signal": "mDNSlocal NetworkInterfaceInfoVxWorks *\tFindRoutableIPv4( mDNS *const inMDNS, mDNSu32 inScopeID )", "code": "{\n#if( MDNS_EXCLUDE_IPV4_ROUTABLE_IPV6 )\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\n\tfor( i = inMDNS->p->interfaceList; i; i = i->next )\n\t{\n\t\tif( i->exists && ( i->scopeID == inScopeID ) && mDNSAddressIsNonLinkLocalIPv4( &i->ifinfo.ip ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn( i );\n#else\n\tDEBUG_UNUSED( inMDNS );\n\tDEBUG_UNUSED( inScopeID );\n\t\n\treturn( NULL );\n#endif\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tDebugMsg\n//===========================================================================================================================\n", "func_signal": "mDNSlocal void\tDebugMsg( DebugLevel inLevel, const char *inFormat, ... )", "code": "{\n\tchar\t\tbuffer[ 512 ];\n\tva_list\t\targs;\n\t\n\tva_start( args, inFormat );\n\tmDNS_vsnprintf( buffer, sizeof( buffer ), inFormat, args );\n\tva_end( args );\n\t\n\tif( inLevel >= gMDNSDebugOverrideLevel ) inLevel = kDebugLevelMax;\n\tdlog( inLevel, \"%s\", buffer );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformMemAllocate\n//===========================================================================================================================\n", "func_signal": "mDNSexport void *\tmDNSPlatformMemAllocate( mDNSu32 inSize )", "code": "{\n\tvoid *\t\tmem;\n\t\n\tcheck( inSize > 0 );\n\t\n\tmem = malloc( inSize );\n\tcheck( mem );\n\t\n\treturn( mem );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformMemCopy\n//===========================================================================================================================\n", "func_signal": "void\tmDNSPlatformMemCopy( void *inDst, const void *inSrc, mDNSu32 inSize )", "code": "{\n\tcheck( inSrc );\n\tcheck( inDst );\n\t\n\tmemcpy( inDst, inSrc, inSize );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformClose\n//===========================================================================================================================\n", "func_signal": "void\tmDNSPlatformClose( mDNS * const inMDNS )", "code": "{\n\tmStatus\t\terr;\n\t\n\tcheck( inMDNS );\n\t\n\tgMDNSPtr = NULL;\n\t\n\t// Signal the task to quit and wait for it to signal back that it exited. Timeout in 10 seconds to handle a hung thread.\n\t\n\tif( inMDNS->p->taskID != ERROR )\n\t{\n\t\tSendCommand( inMDNS, kMDNSPipeCommandCodeQuit );\n\t\tif( inMDNS->p->quitEvent )\n\t\t{\n\t\t\terr = semTake( inMDNS->p->quitEvent, sysClkRateGet() * 10 );\n\t\t\tcheck_noerr( err );\n\t\t}\n\t\tinMDNS->p->taskID = ERROR;\n\t}\n\t\n\t// Clean up resources set up in mDNSPlatformInit. All other resources should have been cleaned up already by TaskTerm.\n\t\n\tForgetSem( &inMDNS->p->quitEvent );\n\tForgetSem( &inMDNS->p->initEvent );\n\tForgetSem( &inMDNS->p->lock );\n\t\n\tdmsg( kDebugLevelNotice, DEBUG_NAME \"CLOSED\\n\" );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformMemFree\n//===========================================================================================================================\n", "func_signal": "mDNSexport void\tmDNSPlatformMemFree( void *inMem )", "code": "{\n\tcheck( inMem );\n\tif( inMem ) free( inMem );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformMemZero\n//===========================================================================================================================\n", "func_signal": "void\tmDNSPlatformMemZero( void *inDst, mDNSu32 inSize )", "code": "{\n\tcheck( inDst );\n\t\n\tmemset( inDst, 0, inSize );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tSetupSocket\n//===========================================================================================================================\n", "func_signal": "mDNSlocal mStatus\tSetupSocket( mDNS *const inMDNS, const mDNSAddr *inAddr, mDNSBool inMcast, int inFamily, SocketSet *inSS )", "code": "{\n\tmStatus\t\t\terr;\n\tSocketRef *\t\tsockPtr;\n\tmDNSIPPort\t\tport;\n\tSocketRef\t\tsock;\n\tconst int\t\ton = 1;\n\t\t\n\tcheck( inAddr );\n\tcheck( inSS );\n\t\n\tsockPtr\t= ( inFamily == AF_INET ) ? &inSS->sockV4 : &inSS->sockV6;\n\tport\t= ( inMcast || inMDNS->CanReceiveUnicastOn5353 ) ? MulticastDNSPort : zeroIPPort;\n\t\n\tsock = socket( inFamily, SOCK_DGRAM, IPPROTO_UDP );\n\terr = translate_errno( IsValidSocket( sock ), errno_compat(), mStatus_UnknownErr );\n\trequire_noerr( err, exit );\n\t\n\t// Allow multiple listeners if this is a multicast port.\n\t\n\tif( port.NotAnInteger )\n\t{\t\n\t\terr = setsockopt( sock, SOL_SOCKET, SO_REUSEPORT, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t}\n\t\n\t// Set up the socket based on the family (IPv4 or IPv6).\n\t\n\tif( inFamily == AF_INET )\n\t{\n\t\tconst int\t\t\t\tttlV4\t\t= 255;\n\t\tconst u_char\t\t\tttlV4Mcast\t= 255;\n\t\tstruct sockaddr_in\t\tsa4;\n\t\t\n\t\t// Receive destination addresses so we know which address the packet was sent to.\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IP, IP_RECVDSTADDR, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Receive interface indexes so we know which interface received the packet.\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IP, IP_RECVIF, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Join the multicast group on this interface and specify the outgoing interface, if it's for multicast receiving.\n\t\t\n\t\tif( inMcast )\n\t\t{\n\t\t\tstruct in_addr\t\taddrV4;\n\t\t\tstruct ip_mreq\t\tmreqV4;\n\t\t\t\n\t\t\taddrV4.s_addr\t\t\t\t= inAddr->ip.v4.NotAnInteger;\n\t\t\tmreqV4.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;\n\t\t\tmreqV4.imr_interface\t\t= addrV4;\n\t\t\terr = setsockopt( sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *) &mreqV4, sizeof( mreqV4 ) );\n\t\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\t\n\t\t\terr = setsockopt( sock, IPPROTO_IP, IP_MULTICAST_IF, (char *) &addrV4, sizeof( addrV4 ) );\n\t\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t}\n\t\t\n\t\t// Send unicast packets with TTL 255 (helps against spoofing).\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IP, IP_TTL, (char *) &ttlV4, sizeof( ttlV4 ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Send multicast packets with TTL 255 (helps against spoofing).\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IP, IP_MULTICAST_TTL, (char *) &ttlV4Mcast, sizeof( ttlV4Mcast ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Start listening for packets.\n\t\t\n\t\tmDNSPlatformMemZero( &sa4, sizeof( sa4 ) );\n\t\tsa4.sin_len\t\t\t= sizeof( sa4 );\n\t\tsa4.sin_family\t\t= AF_INET;\n\t\tsa4.sin_port\t\t= port.NotAnInteger;\n\t\tsa4.sin_addr.s_addr\t= htonl( INADDR_ANY ); // We want to receive multicasts AND unicasts on this socket.\n\t\terr = bind( sock, (struct sockaddr *) &sa4, sizeof( sa4 ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t}\n\telse if( inFamily == AF_INET6 )\n\t{\n\t\tstruct sockaddr_in6\t\tsa6;\n\t\tconst int\t\t\t\tttlV6 = 255;\n\t\t\n\t\t// Receive destination addresses and interface index so we know where the packet was received and intended.\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_PKTINFO, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Receive only IPv6 packets because otherwise, we may get IPv4 addresses as IPv4-mapped IPv6 addresses.\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Join the multicast group on this interface and specify the outgoing interface, if it's for multicast receiving.\n\t\t\n\t\tif( inMcast )\n\t\t{\n\t\t\tu_int\t\t\t\t\tifindex;\n\t\t\tstruct ipv6_mreq\t\tmreqV6;\n\t\t\t\n\t\t\tifindex\t\t\t\t\t= inSS->info->scopeID;\n\t\t\tmreqV6.ipv6mr_interface\t= ifindex;\n\t\t\tmreqV6.ipv6mr_multiaddr\t= *( (struct in6_addr * ) &AllDNSLinkGroup_v6.ip.v6 );\n\t\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, (char *) &mreqV6, sizeof( mreqV6 ) );\n\t\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\t\n\t\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_MULTICAST_IF, (char *) &ifindex, sizeof( ifindex ) );\n\t\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t}\n\t\t\n\t\t// Send unicast packets with TTL 255 (helps against spoofing).\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_UNICAST_HOPS, (char *) &ttlV6, sizeof( ttlV6 ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Send multicast packets with TTL 255 (helps against spoofing).\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *) &ttlV6, sizeof( ttlV6 ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Receive our own packets for same-machine operation.\n\t\t\n\t\terr = setsockopt( sock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, (char *) &on, sizeof( on ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\t\n\t\t// Start listening for packets.\n\t\t\n\t\tmDNSPlatformMemZero( &sa6, sizeof( sa6 ) );\n\t\tsa6.sin6_len\t\t= sizeof( sa6 );\n\t\tsa6.sin6_family\t\t= AF_INET6;\n\t\tsa6.sin6_port\t\t= port.NotAnInteger;\n\t\tsa6.sin6_flowinfo\t= 0;\n\t\tsa6.sin6_addr\t\t= in6addr_any; // We want to receive multicasts AND unicasts on this socket.\n\t\tsa6.sin6_scope_id\t= 0;\n\t\terr = bind( sock, (struct sockaddr *) &sa6, sizeof( sa6 ) );\n\t\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t}\n\telse\n\t{\n\t\tdmsg( kDebugLevelError, DEBUG_NAME \"%s: unsupport socket family (%d)\\n\", __ROUTINE__, inFamily );\n\t\terr = kUnsupportedErr;\n\t\tgoto exit;\n\t}\n\t\n\t// Make the socket non-blocking so we can potentially get multiple packets per select call.\n\t\n\terr = ioctl( sock, FIONBIO, (int) &on );\n\tcheck_translated_errno( err == 0, errno_compat(), kOptionErr );\n\t\n\t*sockPtr = sock;\n\tsock = kInvalidSocketRef;\n\terr = mStatus_NoError;\n\t\nexit:\n\tif( IsValidSocket( sock ) ) close_compat( sock );\n\treturn( err );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tTaskTerm\n//===========================================================================================================================\n", "func_signal": "mDNSlocal void\tTaskTerm( mDNS *inMDNS )", "code": "{\n\tmStatus\t\terr;\n\tmDNSs32\t\tutc;\n\t\n\t// Tear down all interfaces.\n\t\n\tutc = mDNSPlatformUTC();\n\tMarkAllInterfacesInactive( inMDNS, utc );\n\tClearInactiveInterfaces( inMDNS, utc, mDNStrue );\n\tcheck_string( !inMDNS->p->interfaceList, \"LEAK: closing without deleting all interfaces\" );\n\t\n\t// Close unicast sockets.\n\t\n\tForgetSocket( &inMDNS->p->unicastSS.sockV4);\n\tForgetSocket( &inMDNS->p->unicastSS.sockV6 );\n\t\n\t// Tear down everything else that was set up in TaskInit then signal back that we're done.\n\t\n\terr = TearDownCommandPipe( inMDNS );\n\tcheck_noerr( err );\n\t\n\terr = semGive( inMDNS->p->quitEvent );\n\tcheck_translated_errno( err == 0, errno_compat(), kUnknownErr );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "//===========================================================================================================================\n//\tmDNSPlatformInterfaceNameToID\n//===========================================================================================================================\n", "func_signal": "mStatus\tmDNSPlatformInterfaceNameToID( mDNS * const inMDNS, const char *inName, mDNSInterfaceID *outID )", "code": "{\n\tNetworkInterfaceInfoVxWorks *\t\ti;\n\t\n\tfor( i = inMDNS->p->interfaceList; i; i = i->next )\n\t{\n\t\t// Don't get tricked by inactive interfaces with no InterfaceID set.\n\t\t\n\t\tif( i->ifinfo.InterfaceID && ( strcmp( i->ifinfo.ifname, inName ) == 0 ) )\n\t\t{\n\t\t\t*outID = (mDNSInterfaceID) i;\n\t\t\treturn( mStatus_NoError );\n\t\t}\n\t}\n\treturn( mStatus_NoSuchNameErr );\n}", "path": "mDNSVxWorks\\mDNSVxWorks.c", "repo_name": "Sha0/mDNSResponder", "stars": 9, "license": "other", "language": "c", "size": 9873}
{"docstring": "/* Detect which power sources are present. */\n", "func_signal": "unsigned int power_input_status(void)", "code": "{\n    unsigned int status = power_status;\n\n    if (GPIO3_DR & (1 << 20))\n        status |= POWER_INPUT_BATTERY;\n\n    if (usb_charging_maxcurrent() < 500)\n    {\n        /* ACK that USB is connected but NOT chargeable */\n        status &= ~(POWER_INPUT_USB_CHARGER & POWER_INPUT_CHARGER);\n    }\n\n    return status;\n}", "path": "firmware\\target\\arm\\imx31\\gigabeat-s\\power-gigabeat-s.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* fixed point exp() */\n", "func_signal": "static int exp_s16p16(int x)", "code": "{\n    int t;\n    int y = 0x00010000;\n\n    if (x < 0) x += 0xb1721,            y >>= 16;\n    t = x - 0x58b91; if (t >= 0) x = t, y <<= 8;\n    t = x - 0x2c5c8; if (t >= 0) x = t, y <<= 4;\n    t = x - 0x162e4; if (t >= 0) x = t, y <<= 2;\n    t = x - 0x0b172; if (t >= 0) x = t, y <<= 1;\n    t = x - 0x067cd; if (t >= 0) x = t, y += y >> 1;\n    t = x - 0x03920; if (t >= 0) x = t, y += y >> 2;\n    t = x - 0x01e27; if (t >= 0) x = t, y += y >> 3;\n    t = x - 0x00f85; if (t >= 0) x = t, y += y >> 4;\n    t = x - 0x007e1; if (t >= 0) x = t, y += y >> 5;\n    t = x - 0x003f8; if (t >= 0) x = t, y += y >> 6;\n    t = x - 0x001fe; if (t >= 0) x = t, y += y >> 7;\n    y += ((y >> 8) * x) >> 8;\n\n    return y;\n}", "path": "apps\\plugins\\lib\\grey_core.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Return a pointer to the memory handle of given ID.\n   NULL if the handle wasn't found */\n", "func_signal": "static struct memory_handle *find_handle(int handle_id)", "code": "{\n    if (handle_id < 0)\n        return NULL;\n\n    /* simple caching because most of the time the requested handle\n    will either be the same as the last, or the one after the last */\n    if (cached_handle) {\n        if (cached_handle->id == handle_id) {\n            return cached_handle;\n        } else if (cached_handle->next &&\n                   (cached_handle->next->id == handle_id)) {\n            cached_handle = cached_handle->next;\n            return cached_handle;\n        }\n    }\n\n    struct memory_handle *m = first_handle;\n    while (m && m->id != handle_id) {\n        m = m->next;\n    }\n    /* This condition can only be reached with !m or m->id == handle_id */\n    if (m)\n        cached_handle = m;\n\n    return m;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Detect changes in USB bus power. Called from usb connect event handler. */\n", "func_signal": "void charger_usb_detect_event(int status)", "code": "{\n    /* USB plugged does not imply charging is possible or even\n     * powering the device to maintain the battery. */\n    if (status == USB_INSERTED)\n        power_status |= POWER_INPUT_USB_CHARGER;\n    else\n        power_status &= ~POWER_INPUT_USB_CHARGER;\n}", "path": "firmware\\target\\arm\\imx31\\gigabeat-s\\power-gigabeat-s.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Update LCD areas not covered by the greyscale overlay */\n", "func_signal": "static inline void _deferred_update(void)", "code": "{\n    int x1 = MAX(_grey_info.x, 0);\n    int x2 = MIN(_grey_info.x + _grey_info.width, LCD_WIDTH);\n    int y1 = MAX(_grey_info.y, 0);\n    int y2 = MIN(_grey_info.y + _grey_info.height, LCD_HEIGHT);\n\n    if (y1 > 0)  /* refresh part above overlay, full width */\n        rb->lcd_update_rect(0, 0, LCD_WIDTH, y1);\n\n    if (y2 < LCD_HEIGHT) /* refresh part below overlay, full width */\n        rb->lcd_update_rect(0, y2, LCD_WIDTH, LCD_HEIGHT - y2);\n\n    if (x1 > 0) /* refresh part to the left of overlay */\n        rb->lcd_update_rect(0, y1, x1, y2 - y1);\n\n    if (x2 < LCD_WIDTH) /* refresh part to the right of overlay */\n        rb->lcd_update_rect(x2, y1, LCD_WIDTH - x2, y2 - y1);\n}", "path": "apps\\plugins\\lib\\grey_core.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Open a new handle from data that needs to be copied from memory.\n   src is the source buffer from which to copy data. It can be NULL to simply\n   reserve buffer space.\n   size is the requested size. The call will only be successful if the\n   requested amount of data can entirely fit in the buffer without wrapping.\n   Return value is the handle id for success or <0 for failure.\n*/\n", "func_signal": "int bufalloc(const void *src, size_t size, enum data_type type)", "code": "{\n    int handle_id;\n\n    if (type == TYPE_UNKNOWN)\n        return ERR_UNSUPPORTED_TYPE;\n\n    handle_id = ERR_BUFFER_FULL;\n\n    mutex_lock(&llist_mutex);\n\n    struct memory_handle *h = add_handle(size, false, true);\n\n    if (h) {\n        handle_id = h->id;\n\n        if (src) {\n            if (type == TYPE_ID3 && size == sizeof(struct mp3entry)) {\n                /* specially take care of struct mp3entry */\n                copy_mp3entry((struct mp3entry *)&buffer[buf_widx],\n                              (const struct mp3entry *)src);\n            } else {\n                memcpy(&buffer[buf_widx], src, size);\n            }\n        }\n        \n        h->fd = -1;\n        *h->path = 0;\n        h->filesize = size;\n        h->offset = 0;\n        h->ridx = buf_widx;\n        h->data = buf_widx;\n        buf_widx = ringbuf_add(buf_widx, size);\n        h->widx = buf_widx;\n        h->available = size;\n        h->type = type;\n    }\n\n    mutex_unlock(&llist_mutex);\n\n    logf(\"bufalloc: new hdl %d\", handle_id);\n    return handle_id;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Buffer pointer (p) plus value (v), wrapped if necessary */\n", "func_signal": "static inline uintptr_t ringbuf_add(uintptr_t p, size_t v)", "code": "{\n    uintptr_t res = p + v;\n    if (res >= buffer_len)\n        res -= buffer_len; /* wrap if necssary */\n    return res;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Update the whole greyscale overlay */\n", "func_signal": "void grey_update(void)", "code": "{\n    grey_ub_gray_bitmap_part(_grey_info.buffer, 0, 0, _grey_info.width,\n                             0, 0, _grey_info.width, _grey_info.height);\n}", "path": "apps\\plugins\\lib\\grey_core.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Backend to bufseek and bufadvance */\n", "func_signal": "static int seek_handle(struct memory_handle *h, size_t newpos)", "code": "{\n    if (newpos > h->filesize) {\n        /* access beyond the end of the file */\n        return ERR_INVALID_VALUE;\n    }\n    else if ((newpos < h->offset || h->offset + h->available <= newpos) &&\n             (newpos < h->filesize || h->filerem > 0)) {\n        /* access before or after buffered data and not to end of file or file\n           is not buffered to the end-- a rebuffer is needed. */\n        struct buf_message_data parm = { h->id, newpos };\n        return queue_send(&buffering_queue, Q_REBUFFER_HANDLE,\n                          (intptr_t)&parm);\n    }\n    else {\n        h->ridx = ringbuf_add(h->data, newpos - h->offset);\n    }\n\n    return 0;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Copy data from the given handle to the dest buffer.\n   Return the number of bytes copied or < 0 for failure (handle not found).\n   The caller is blocked until the requested amount of data is available.\n*/\n", "func_signal": "ssize_t bufread(int handle_id, size_t size, void *dest)", "code": "{\n    const struct memory_handle *h;\n    size_t adjusted_size = size;\n\n    h = prep_bufdata(handle_id, &adjusted_size, false);\n    if (!h)\n        return ERR_HANDLE_NOT_FOUND;\n\n    if (h->ridx + adjusted_size > buffer_len) {\n        /* the data wraps around the end of the buffer */\n        size_t read = buffer_len - h->ridx;\n        memcpy(dest, &buffer[h->ridx], read);\n        memcpy(dest+read, buffer, adjusted_size - read);\n    } else {\n        memcpy(dest, &buffer[h->ridx], adjusted_size);\n    }\n\n    return adjusted_size;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Read an unaligned 32-bit little endian long from buffer. */\n", "func_signal": "static unsigned long get_long_le(void* buf)", "code": "{\n    unsigned char* p = (unsigned char*) buf;\n\n    return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n}", "path": "apps\\codecs\\libasf\\asf.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Add a new handle to the linked list and return it. It will have become the\n   new current handle.\n   data_size must contain the size of what will be in the handle.\n   can_wrap tells us whether this type of data may wrap on buffer\n   alloc_all tells us if we must immediately be able to allocate data_size\n   returns a valid memory handle if all conditions for allocation are met.\n           NULL if there memory_handle itself cannot be allocated or if the\n           data_size cannot be allocated and alloc_all is set. */\n", "func_signal": "static struct memory_handle *add_handle(size_t data_size, bool can_wrap,\n                                        bool alloc_all)", "code": "{\n    /* gives each handle a unique id */\n    static int cur_handle_id = 0;\n    size_t shift;\n    size_t widx, new_widx;\n    size_t len;\n    ssize_t overlap;\n\n    if (num_handles >= BUF_MAX_HANDLES)\n        return NULL;\n\n    widx = buf_widx;\n\n    if (cur_handle && cur_handle->filerem > 0) {\n        /* the current handle hasn't finished buffering. We can only add\n           a new one if there is already enough free space to finish\n           the buffering. */\n        size_t req = cur_handle->filerem;\n        if (ringbuf_add_cross(cur_handle->widx, req, buf_ridx) >= 0) {\n            /* Not enough space to finish allocation */\n            return NULL;\n        } else {\n            /* Allocate the remainder of the space for the current handle */\n            widx = ringbuf_add(cur_handle->widx, cur_handle->filerem);\n        }\n    }\n\n    /* align to 4 bytes up always leaving a gap */\n    new_widx = ringbuf_add(widx, 4) & ~3;\n\n    len = data_size + sizeof(struct memory_handle);\n\n    /* First, will the handle wrap? */\n    /* If the handle would wrap, move to the beginning of the buffer,\n     * or if the data must not but would wrap, move it to the beginning */\n    if (new_widx + sizeof(struct memory_handle) > buffer_len ||\n                   (!can_wrap && new_widx + len > buffer_len)) {\n        new_widx = 0;\n    }\n\n    /* How far we shifted the new_widx to align things, must be < buffer_len */\n    shift = ringbuf_sub(new_widx, widx);\n\n    /* How much space are we short in the actual ring buffer? */\n    overlap = ringbuf_add_cross(widx, shift + len, buf_ridx);\n    if (overlap >= 0 && (alloc_all || (size_t)overlap >= data_size)) {\n        /* Not enough space for required allocations */\n        return NULL;\n    }\n\n    /* There is enough space for the required data, advance the buf_widx and\n     * initialize the struct */\n    buf_widx = new_widx;\n\n    struct memory_handle *new_handle =\n        (struct memory_handle *)(&buffer[buf_widx]);\n\n    /* Prevent buffering thread from looking at it */\n    new_handle->filerem = 0;\n\n    /* Handle can be moved by default */\n    new_handle->pinned = 0;\n\n    /* Handle data can be waited for by default */\n    new_handle->signaled = 0;\n\n    /* only advance the buffer write index of the size of the struct */\n    buf_widx = ringbuf_add(buf_widx, sizeof(struct memory_handle));\n\n    new_handle->id = cur_handle_id;\n    /* Wrap signed int is safe and 0 doesn't happen */\n    cur_handle_id = (cur_handle_id + 1) & BUF_HANDLE_MASK;\n    new_handle->next = NULL;\n    num_handles++;\n\n    if (!first_handle)\n        /* the new handle is the first one */\n        first_handle = new_handle;\n\n    if (cur_handle)\n        cur_handle->next = new_handle;\n\n    cur_handle = new_handle;\n\n    return new_handle;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* This is a demonstration of the encryption and decryption process.\n *  It patches a FW image to include the SVG exploit.\n */\n", "func_signal": "int main (int argc, char *argv[])", "code": "{\n    uint32_t checksum;\n    uint32_t stored_crc;\n    \n    enum operations {\n        decrypt,\n        encrypt,\n        patch\n    } operation;\n    \n    char *encrypt_file;\n    char *decrypt_file;\n\n    struct olympus_header header;\n\n    if (argc < 2) {\n        usage();\n        return -1;\n    }\n    \n    if(!strcmp(argv[1], \"-decrypt\")) {\n        if(argc < 3) {\n            usage();\n            return -1;\n        }\n        encrypt_file=argv[2];\n        decrypt_file=argv[3];\n        operation = decrypt;\n    } else if(!strcmp(argv[1], \"-encrypt\")) {\n        if(argc < 3) {\n            usage();\n            return -1;\n        }\n        decrypt_file = argv[2];\n        encrypt_file = argv[3];\n        operation = encrypt;\n    } else if(!strcmp(argv[1], \"-patch\")) {\n        decrypt_file = argv[2];\n        encrypt_file = argv[3];\n        operation = patch;\n    } else {\n        return -1;\n    }\n    \n    /* Initialize encryption/decryption routine */\n    mr500_init();\n    \n    if(operation == decrypt) {\n        /* Read in the header of the encrypted file */\n        if(mr500_read_header(encrypt_file, &header) < 0 ) {\n            printf(\"ERROR: Unable to read header: %s\\n\", strerror(errno));\n            return -1;\n        }\n    \n        /* Read CRC of encrypted file */\n        if(mr500_read_crc(encrypt_file, \n                header.header_length+header.image_length, &stored_crc) < 0 ) {\n            printf(\"ERROR: Unable to read CRC: %s\\n\", strerror(errno));\n            return -1;\n        }\n\n        /* Display the header information */\n        printf(\"File format:\\n\");\n        \n        printf(\"*****Header*****\\n\");\n        display_header(&header);\n        printf(\"****************\\n\\n\");\n    \n        printf(\"*****Image******\\n\\n\");\n    \n        printf(\"*****Footer*****\\n\");\n        printf(\"Checksum: \\t0x%08X\\n\",      stored_crc);\n        printf(\"****************\\n\\n\");\n    \n        printf(\"Writing Decrypted file...\\n\");\n    \n        /*********************************************************************\n        *  Save a decrypted file\n        **********************************************************************/\n     \n        /* Check to make sure this is a encrypted file (bogus flag not set) */\n        if(header.flags & HEADER_DECRYPTED) {\n            printf(\"ERROR: This appears to be a decrypted file! Quitting\\n\");\n            return -1;\n        }\n        \n        /* Check to make sure MAGIC string matches expected*/\n        if(strncmp((char *)header.magic_name, \"OIMCFWUP\", 8)) {\n            printf(\"ERROR: Magic string does not match expected! Quitting\\n\");\n            return -1;\n        }\n     \n        /* Set a bogus flag to let the tool know that this is a decrypted file*/\n        header.flags |= HEADER_DECRYPTED;\n     \n        /* Start by writing out the header */\n        if(mr500_save_header(decrypt_file, &header) < 0 ) {\n            printf(\"ERROR: Unable to save header: %s\\n\", strerror(errno));\n            return -1;\n        }\n    \n        /* Read encrypted data and save decrypted data */\n        if(mr500_save_data( encrypt_file, decrypt_file, header.header_length,\n                    header.image_length, decrypt_array) < 0 ) {\n            printf(\"ERROR: Unable to save decrypted data: %s\\n\", strerror(errno));\n            return -1;\n        }\n    \n        printf(\"Calculating Checksum...\\n\");\n        /* Calculate CRC of decrypted data */\n        if(mr500_calculate_crc( decrypt_file, header.header_length, \n                    header.image_length, &checksum) < 0 ) {\n            printf(\"ERROR: Unable to calculate CRC: %s\\n\", strerror(errno));\n            return -1;\n        }\n    \n        printf(\"Calculated Checksum: \\n\\t\\t0x%08X\\n\", checksum);\n    \n        /* Double check to make sure that the two CRCs match */\n        if(checksum!=stored_crc) {\n            printf(\"\\tERROR: \\tCalculated checksum: \\t0x%08X and\\n\", checksum);\n            printf(\"\\t\\tStored checksum: \\t0x%08X do not match\\n\", stored_crc);\n            return -1;\n        } else {\n            printf(\"\\tOK: Calculated checksum and stored checksum match.\\n\");\n        }\n    \n        printf(\"Saving Checksum...\\n\");\n        /* Save the calculated CRC to the file */\n        if(mr500_save_crc(decrypt_file, header.header_length+header.image_length,\n                    &checksum) < 0 ) {\n            printf(\"ERROR: Unable to save CRC: %s\\n\", strerror(errno));\n            return -1;\n        } \n    \n    } else if(operation == patch) {\n    \n        /**********************************************************************\n         *  Patch decryped file with SVG exploit\n         **********************************************************************/\n        printf(\"Patching decrypted file.\\n\");\n        \n        /* Read in the header of the encrypted file */\n        if(mr500_read_header(decrypt_file, &header) < 0 ) {\n            printf(\"ERROR: Unable to read header: %s\\n\", strerror(errno));\n            return -1;\n        }\n        \n        /* Check to make sure this is a decrypted file (bogus flag not set) */\n        if(!(header.flags & HEADER_DECRYPTED)) {\n            printf(\"ERROR: This appears to be a encrypted file! Quitting\\n\");\n            return -1;\n        }\n        \n        /* Check to make sure MAGIC string matches expected*/\n        if(strncmp((char *)header.magic_name, \"OIMCFWUP\", 8)) {\n            printf(\"ERROR: Magic string does not match expected! Quitting\\n\");\n            return -1;\n        }\n        \n        printf(\"File Header:\\n\");\n        display_header(&header);\n        \n        if(mr500_patch_file (decrypt_file, hack, 2) < 0 ) {\n            printf(\"ERROR: Unable to patch file: %s\\n\", strerror(errno));\n            return -1;\n        }\n        \n        printf(\"\\nCalculating new CRC\\n\");\n        \n        /* Calculate the 'CRC' of the patched file */\n        if(mr500_calculate_crc( decrypt_file, header.header_length, \n                            header.image_length, &checksum) < 0 ) {\n            printf(\"ERROR: Unable to calculate CRC: %s\\n\", strerror(errno));\n            return -1;\n        }\n                            \n        printf(\"Calculated CRC: \\n\\t\\t0x%08X\\n\", checksum);\n        /* Store the calculated 'CRC' (not encrypted) */\n        if(mr500_save_crc(decrypt_file, header.header_length+header.image_length,\n                    &checksum) < 0 ) {\n            printf(\"ERROR: Unable to save CRC: %s\\n\", strerror(errno));\n            return -1;\n        } \n        \n    } else if(operation == encrypt) {\n    \n        /**********************************************************************\n         *  Save an encrypted file\n         **********************************************************************/\n        printf(\"Saving Encrypted file\\n\");\n        \n        /* Read in the header of the encrypted file */\n        if(mr500_read_header(decrypt_file, &header) < 0 ) {\n            printf(\"ERROR: Unable to read header: %s\\n\", strerror(errno));\n            return -1;\n        }\n        \n        /* Check to make sure this is a decrypted file (bogus flag not set) */\n        if(!(header.flags & HEADER_DECRYPTED)) {\n            printf(\"ERROR: This appears to be a encrypted file! Quitting\\n\");\n            return -1;\n        }\n        \n        /* Check to make sure MAGIC string matches expected*/\n        if(strncmp((char *)header.magic_name, \"OIMCFWUP\", 7)) {\n            printf(\"ERROR: Magic string does not match expected! Quitting\\n\");\n            return -1;\n        }\n        \n        /* Remove the bogus flag */\n        header.flags &= ~HEADER_DECRYPTED;\n        \n        printf(\"File Header:\\n\");\n        display_header(&header);\n    \n        /* Header is not encrypted, save it */\n        if(mr500_save_header(encrypt_file, &header) < 0 ) {\n            printf(\"ERROR: Unable to save header: %s\\n\", strerror(errno));\n            return -1;\n        }\n        \n        /* Read CRC of decrypted file */\n        if(mr500_read_crc(decrypt_file, \n                header.header_length+header.image_length, &stored_crc) < 0 ) {\n            printf(\"ERROR: Unable to read CRC: %s\\n\", strerror(errno));\n            return -1;\n        }\n    \n        /* Calculate the 'CRC' of the decrypted data */\n        if(mr500_calculate_crc( decrypt_file, header.header_length, \n                            header.image_length, &checksum) < 0 ) {\n            printf(\"ERROR: Unable to calculate CRC: %s\\n\", strerror(errno));\n            return -1;\n        }\n        \n        if(stored_crc != checksum) {\n            printf(\"\\nERROR: Stored and calculated checksums do not match!\\n\"\n                    \"\\tFile has been improperly modified. Quitting\\n\");\n            return -1;\n        }\n        \n        printf(\"Encrypting data...\\n\");\n        \n        /* Write the encrypted data to a file */\n        if(mr500_save_data( decrypt_file, encrypt_file, header.header_length,\n                    header.image_length, encrypt_array) < 0 ) {\n            printf(\"ERROR: Unable to save encrypted data: %s\\n\", strerror(errno));\n            return -1;\n        }\n\n        printf(\"Saving CRC\\n\");\n    \n        /* Store the calculated 'CRC' (not encrypted) */\n        if(mr500_save_crc(encrypt_file, header.header_length+header.image_length,\n                    &checksum) < 0 ) {\n            printf(\"ERROR: Unable to save CRC: %s\\n\", strerror(errno));\n            return -1;\n        } \n                    \n        printf(\"File sucesfully encrypted!\\n\");\n    }\n    \n    printf(\"Done\\n\");\n    return 0;\n}", "path": "tools\\mk500boot.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Free buffer space by moving the handle struct right before the useful\n   part of its data buffer or by moving all the data. */\n", "func_signal": "static void shrink_handle(struct memory_handle *h)", "code": "{\n    if (!h)\n        return;\n\n    if (h->type == TYPE_PACKET_AUDIO) {\n        /* only move the handle struct */\n        /* data is pinned by default - if we start moving packet audio,\n           the semantics will determine whether or not data is movable\n           but the handle will remain movable in either case */\n        size_t delta = ringbuf_sub(h->ridx, h->data);\n\n        /* The value of delta might change for alignment reasons */\n        if (!move_handle(&h, &delta, 0, true))\n            return;\n\n        h->data = ringbuf_add(h->data, delta);\n        h->available -= delta;\n        h->offset += delta;\n    } else {\n        /* metadata handle: we can move all of it */\n        if (h->pinned || !h->next || h->filerem != 0)\n            return; /* Pinned, last handle or not finished loading */\n\n        uintptr_t handle_distance =\n            ringbuf_sub(ringbuf_offset(h->next), h->data);\n        size_t delta = handle_distance - h->available;\n\n        /* The value of delta might change for alignment reasons */\n        if (!move_handle(&h, &delta, h->available, h->type==TYPE_CODEC))\n            return;\n\n        size_t olddata = h->data;\n        h->data = ringbuf_add(h->data, delta);\n        h->ridx = ringbuf_add(h->ridx, delta);\n        h->widx = ringbuf_add(h->widx, delta);\n\n        if (h->type == TYPE_ID3 && h->filesize == sizeof(struct mp3entry)) {\n            /* when moving an mp3entry we need to readjust its pointers. */\n            adjust_mp3entry((struct mp3entry *)&buffer[h->data],\n                            (void *)&buffer[h->data],\n                            (const void *)&buffer[olddata]);\n        } else if (h->type == TYPE_BITMAP) {\n            /* adjust the bitmap's pointer */\n            struct bitmap *bmp = (struct bitmap *)&buffer[h->data];\n            bmp->data = &buffer[h->data + sizeof(struct bitmap)];\n        }\n    }\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/*\nSECONDARY EXPORTED FUNCTIONS\n============================\n\nbuf_handle_offset\nbuf_set_base_handle\nbuf_handle_data_type\nbuf_is_handle\nbuf_pin_handle\nbuf_signal_handle\nbuf_length\nbuf_used\nbuf_set_watermark\nbuf_get_watermark\n\nThese functions are exported, to allow interaction with the buffer.\nThey take care of the content of the structs, and rely on the linked list\nmanagement functions for all the actual handle management work.\n*/\n", "func_signal": "ssize_t buf_handle_offset(int handle_id)", "code": "{\n    const struct memory_handle *h = find_handle(handle_id);\n    if (!h)\n        return ERR_HANDLE_NOT_FOUND;\n    return h->offset;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Given a file descriptor to a bitmap file, write the bitmap data to the\n   buffer, with a struct bitmap and the actual data immediately following.\n   Return value is the total size (struct + data). */\n", "func_signal": "static int load_image(int fd, const char *path,\n                      struct bufopen_bitmap_data *data)", "code": "{\n    int rc;\n    struct bitmap *bmp = (struct bitmap *)&buffer[buf_widx];\n    struct dim *dim = data->dim;\n    struct mp3_albumart *aa = data->embedded_albumart;\n\n    /* get the desired image size */\n    bmp->width = dim->width, bmp->height = dim->height;\n    /* FIXME: alignment may be needed for the data buffer. */\n    bmp->data = &buffer[buf_widx + sizeof(struct bitmap)];\n#ifndef HAVE_JPEG\n    (void) path;\n#endif\n#if (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1)\n    bmp->maskdata = NULL;\n#endif\n\n    int free = (int)MIN(buffer_len - BUF_USED, buffer_len - buf_widx)\n                               - sizeof(struct bitmap);\n\n#ifdef HAVE_JPEG\n    if (aa != NULL) {\n        lseek(fd, aa->pos, SEEK_SET);\n        rc = clip_jpeg_fd(fd, aa->size, bmp, free, FORMAT_NATIVE|FORMAT_DITHER|\n                         FORMAT_RESIZE|FORMAT_KEEP_ASPECT, NULL);\n    }\n    else if (strcmp(path + strlen(path) - 4, \".bmp\"))\n        rc = read_jpeg_fd(fd, bmp, free, FORMAT_NATIVE|FORMAT_DITHER|\n                         FORMAT_RESIZE|FORMAT_KEEP_ASPECT, NULL);\n    else\n#endif\n        rc = read_bmp_fd(fd, bmp, free, FORMAT_NATIVE|FORMAT_DITHER|\n                         FORMAT_RESIZE|FORMAT_KEEP_ASPECT, NULL);\n    return rc + (rc > 0 ? sizeof(struct bitmap) : 0);\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Buffer pointer (p) minus value (v), wrapped if necessary */\n", "func_signal": "static inline uintptr_t ringbuf_sub(uintptr_t p, size_t v)", "code": "{\n    uintptr_t res = p;\n    if (p < v)\n        res += buffer_len; /* wrap */\n        \n    return res - v;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Switch the greyscale overlay on or off\n   DO NOT call lcd_update() or any other api function that directly accesses\n   the lcd while the greyscale overlay is running! If you need to do\n   lcd_update() to update something outside the greyscale overlay area, use\n   grey_deferred_update() instead.\n\n Other functions to avoid are:\n   lcd_blit_mono(), lcd_update_rect(), lcd_set_contrast(),\n   lcd_set_invert_display(), lcd_set_flip() */\n", "func_signal": "void grey_show(bool enable)", "code": "{\n    if (enable && !(_grey_info.flags & _GREY_RUNNING))\n    {\n        _grey_info.flags |= _GREY_RUNNING;\n#ifdef SIMULATOR\n        rb->sim_lcd_ex_init(_grey_get_pixel);\n        rb->sim_lcd_ex_update_rect(_grey_info.x, _grey_info.y,\n                                   _grey_info.width, _grey_info.height);\n#else /* !SIMULATOR */\n#ifdef NEED_BOOST\n        rb->cpu_boost(true);\n#endif\n#if NUM_CORES > 1\n        rb->timer_register(1, NULL, TIMER_FREQ / LCD_SCANRATE,\n                                      _timer_isr,\n                                      (_grey_info.flags & GREY_ON_COP) ? COP : CPU);\n#else\n        rb->timer_register(1, NULL, TIMER_FREQ / LCD_SCANRATE, _timer_isr);\n#endif\n#endif /* !SIMULATOR */\n        rb->screen_dump_set_hook(grey_screendump_hook);\n    }\n    else if (!enable && (_grey_info.flags & _GREY_RUNNING))\n    {\n#ifdef SIMULATOR\n        rb->sim_lcd_ex_init(NULL);\n#else /* !SIMULATOR */\n        rb->timer_unregister();\n#if NUM_CORES > 1  /* Make sure the ISR has finished before calling lcd_update() */\n        rb->sleep(HZ/100);\n#endif\n#ifdef NEED_BOOST\n        rb->cpu_boost(false);\n#endif\n#endif /* !SIMULATOR */\n        _grey_info.flags &= ~_GREY_RUNNING;\n        rb->screen_dump_set_hook(NULL);\n        rb->lcd_update(); /* restore whatever there was before */\n    }\n}", "path": "apps\\plugins\\lib\\grey_core.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Reserve space in the buffer for a file.\n   filename: name of the file to open\n   offset: offset at which to start buffering the file, useful when the first\n           offset bytes of the file aren't needed.\n   type: one of the data types supported (audio, image, cuesheet, others\n   user_data: user data passed possibly passed in subcalls specific to a\n              data_type (only used for image (albumart) buffering so far )\n   return value: <0 if the file cannot be opened, or one file already\n   queued to be opened, otherwise the handle for the file in the buffer\n*/\n", "func_signal": "int bufopen(const char *file, size_t offset, enum data_type type,\n            void *user_data)", "code": "{\n#ifndef HAVE_ALBUMART\n    /* currently only used for aa loading */\n    (void)user_data;\n#endif\n    int handle_id = ERR_BUFFER_FULL;\n\n    /* No buffer refs until after the mutex_lock call! */\n\n    if (type == TYPE_ID3) {\n        /* ID3 case: allocate space, init the handle and return. */\n        mutex_lock(&llist_mutex);\n\n        struct memory_handle *h =\n            add_handle(sizeof(struct mp3entry), false, true);\n\n        if (h) {\n            handle_id = h->id;\n            h->fd = -1;\n            h->filesize = sizeof(struct mp3entry);\n            h->offset = 0;\n            h->data = buf_widx;\n            h->ridx = buf_widx;\n            h->widx = buf_widx;\n            h->available = 0;\n            h->type = type;\n            strlcpy(h->path, file, MAX_PATH);\n\n            buf_widx = ringbuf_add(buf_widx, sizeof(struct mp3entry));\n\n            h->filerem = sizeof(struct mp3entry);\n\n            /* Inform the buffering thread that we added a handle */\n            LOGFQUEUE(\"buffering > Q_HANDLE_ADDED %d\", handle_id);\n            queue_post(&buffering_queue, Q_HANDLE_ADDED, handle_id);\n        }\n\n        mutex_unlock(&llist_mutex);\n        return handle_id;\n    }\n    else if (type == TYPE_UNKNOWN)\n        return ERR_UNSUPPORTED_TYPE;\n#ifdef APPLICATION\n    /* loading code from memory is not supported in application builds */\n    else if (type == TYPE_CODEC)\n        return ERR_UNSUPPORTED_TYPE;\n#endif\n    /* Other cases: there is a little more work. */\n    int fd = open(file, O_RDONLY);\n    if (fd < 0)\n        return ERR_FILE_ERROR;\n\n    size_t size = 0;\n#ifdef HAVE_ALBUMART\n    if (type == TYPE_BITMAP) {\n        /* if albumart is embedded, the complete file is not buffered,\n         * but only the jpeg part; filesize() would be wrong */\n        struct bufopen_bitmap_data *aa = (struct bufopen_bitmap_data*)user_data;\n        if (aa->embedded_albumart)\n            size = aa->embedded_albumart->size;\n    }\n#endif\n    if (size == 0)\n        size = filesize(fd);\n    bool can_wrap = type==TYPE_PACKET_AUDIO || type==TYPE_CODEC;\n\n    size_t adjusted_offset = offset;\n    if (adjusted_offset > size)\n        adjusted_offset = 0;\n\n    /* Reserve extra space because alignment can move data forward */\n    size_t padded_size = STORAGE_PAD(size-adjusted_offset);\n\n    mutex_lock(&llist_mutex);\n\n    struct memory_handle *h = add_handle(padded_size, can_wrap, false);\n    if (!h) {\n        DEBUGF(\"%s(): failed to add handle\\n\", __func__);\n        mutex_unlock(&llist_mutex);\n        close(fd);\n        return ERR_BUFFER_FULL;\n    }\n\n    handle_id = h->id;\n    strlcpy(h->path, file, MAX_PATH);\n    h->offset = adjusted_offset;\n\n#ifdef STORAGE_WANTS_ALIGN\n    /* Don't bother to storage align bitmaps because they are not\n     * loaded directly into the buffer.\n     */\n    if (type != TYPE_BITMAP) {\n        /* Align to desired storage alignment */\n        size_t alignment_pad = STORAGE_OVERLAP(adjusted_offset -\n                                               (size_t)(&buffer[buf_widx]));\n        buf_widx = ringbuf_add(buf_widx, alignment_pad);\n    }\n#endif /* STORAGE_WANTS_ALIGN */\n\n    h->fd   = -1;\n    h->data = buf_widx;\n    h->ridx = buf_widx;\n    h->widx = buf_widx;\n    h->available = 0;\n    h->type = type;\n\n#ifdef HAVE_ALBUMART\n    if (type == TYPE_BITMAP) {\n        /* Bitmap file: we load the data instead of the file */\n        int rc;\n        rc = load_image(fd, file, (struct bufopen_bitmap_data*)user_data);\n        if (rc <= 0) {\n            rm_handle(h);\n            handle_id = ERR_FILE_ERROR;\n        } else {\n            h->filesize = rc;\n            h->available = rc;\n            buf_widx = ringbuf_add(buf_widx, rc);\n            h->widx = buf_widx;\n        }\n    }\n    else\n#endif\n    {\n        if (type == TYPE_CUESHEET)\n            h->fd = fd;\n\n        h->filesize = size;\n        h->available = 0;\n        h->widx = buf_widx;\n        h->filerem = size - adjusted_offset;\n    }\n\n    mutex_unlock(&llist_mutex);\n\n    if (type == TYPE_CUESHEET) {\n        /* Immediately start buffering those */\n        LOGFQUEUE(\"buffering >| Q_BUFFER_HANDLE %d\", handle_id);\n        queue_send(&buffering_queue, Q_BUFFER_HANDLE, handle_id);\n    } else {\n        /* Other types will get buffered in the course of normal operations */\n        close(fd);\n\n        if (handle_id >= 0) {\n            /* Inform the buffering thread that we added a handle */\n            LOGFQUEUE(\"buffering > Q_HANDLE_ADDED %d\", handle_id);\n            queue_post(&buffering_queue, Q_HANDLE_ADDED, handle_id);\n        }\n    }\n\n    logf(\"bufopen: new hdl %d\", handle_id);\n    return handle_id;\n}", "path": "apps\\buffering.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "/* Do an lcd_update() to show changes done by rb->lcd_xxx() functions\n   (in areas of the screen not covered by the greyscale overlay). */\n", "func_signal": "void grey_deferred_lcd_update(void)", "code": "{\n    if (_grey_info.flags & _GREY_RUNNING)\n    {\n#ifdef SIMULATOR\n        _deferred_update();\n#else\n        _grey_info.flags |= _GREY_DEFERRED_UPDATE;\n#endif\n    }\n    else\n        rb->lcd_update();\n}", "path": "apps\\plugins\\lib\\grey_core.c", "repo_name": "mguentner/rockbox", "stars": 14, "license": "None", "language": "c", "size": 123449}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "DISPATCH_NOINLINE\nvoid\n_dispatch_queue_invoke(dispatch_queue_t dq)", "code": "{\n\tdispatch_queue_t tq = dq->do_targetq;\n\n\tif (!slowpath(DISPATCH_OBJECT_SUSPENDED(dq)) && fastpath(_dispatch_queue_trylock(dq))) {\n\t\t_dispatch_queue_drain(dq);\n\t\tif (tq == dq->do_targetq) {\n\t\t\ttq = dx_invoke(dq);\n\t\t} else {\n\t\t\ttq = dq->do_targetq;\n\t\t}\n\t\t// We do not need to check the result.\n\t\t// When the suspend-count lock is dropped, then the check will happen.\n\t\tdispatch_atomic_dec(&dq->dq_running);\n\t\tif (tq) {\n\t\t\treturn _dispatch_queue_push(tq, dq);\n\t\t}\n\t}\n\n\tdq->do_next = DISPATCH_OBJECT_LISTLESS;\n\tif (dispatch_atomic_sub(&dq->do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK) == 0) {\n\t\tif (dq->dq_running == 0) {\n\t\t\t_dispatch_wakeup(dq);\t// verify that the queue is idle\n\t\t}\n\t}\n\t_dispatch_release(dq);\t// added when the queue is put on the list\n}", "path": "src\\queue.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// We are waiting to for an HTTP request (we eitther havn't gotten\n// the first request, or pipelneing is on, and we finished a request),\n// and there is data to read on the network socket.\n", "func_signal": "void read_req(struct request *req, size_t avail)", "code": "{\n    if (req->timeo.ds) {\n\tdelete_source(req, &req->timeo);\n    }\n\n    // -1 to account for the trailing NUL\n    int s = (sizeof(req->cmd_buf) - (req->cb - req->cmd_buf)) -1;\n    if (s == 0) {\n\tqprintf(\"read_req fd#%d command overflow\\n\", req->sd);\n\tclose_connection(req);\n\treturn;\n    }\n    int rd = read(req->sd, req->cb, s);\n    if (rd > 0) {\n\treq->cb += rd;\n\tif (req->cb > req->cmd_buf + 4) {\n\t    int i;\n\t    for(i = -4; i != 0; i++) {\n\t\tchar ch = *(req->cb + i);\n\t\tif (ch != '\\n' && ch != '\\r') {\n\t\t    break;\n\t\t}\n\t    }\n\t    if (i == 0) {\n\t\t*(req->cb) = '\\0';\n\n\t\tassert(buf_outof_sz(&req->file_b) == 0);\n\t\tassert(buf_outof_sz(&req->deflate_b) == 0);\n\t\tregmatch_t pmatch[re_request_nmatch];\n\t\tregex_t *rex = req->files_served ? &re_first_request : &re_nth_request;\n\t\tint rc = regexec(rex, req->cmd_buf, re_request_nmatch, pmatch, 0);\n\t\tif (rc) {\n\t\t    char ebuf[1024];\n\t\t    regerror(rc, rex, ebuf, sizeof(ebuf));\n\t\t    qprintf(\"\\n$$$ regexec error: %s, ditching request: '%s'\\n\", ebuf, req->cmd_buf);\n\t\t    close_connection(req);\n\t\t    return;\n\t\t} else {\n\t\t    if (!strncmp(\"GET\", req->cmd_buf + pmatch[1].rm_so, pmatch[1].rm_eo - pmatch[1].rm_so)) {\n\t\t\trc = regexec(&re_accept_deflate, req->cmd_buf, 0, NULL, 0);\n\t\t\tassert(rc == 0 || rc == REG_NOMATCH);\n\t\t\t// to disable deflate code:\n\t\t\t// rc = REG_NOMATCH;\n\t\t\tif (req->deflate) {\n\t\t\t    deflateEnd(req->deflate);\n\t\t\t    free(req->deflate);\n\t\t\t}\n\t\t\treq->deflate = (0 == rc) ? calloc(1, sizeof(z_stream)) : NULL;\n\t\t\tchar path_buf[4096];\n\t\t\tstrlcpy(path_buf, DOC_BASE, sizeof(path_buf));\n\t\t\t// WARNING: this doesn't avoid use of .. in the path\n\t\t\t// do get outside of DOC_ROOT, a real web server would\n\t\t\t// really have to avoid that.\n\t\t\tchar ch = *(req->cmd_buf + pmatch[2].rm_eo);\n\t\t\t*(req->cmd_buf + pmatch[2].rm_eo) = '\\0';\n\t\t\tstrlcat(path_buf, req->cmd_buf + pmatch[2].rm_so, sizeof(path_buf));\n\t\t\t*(req->cmd_buf + pmatch[2].rm_eo) = ch;\n\t\t\treq->fd = open(path_buf, O_RDONLY|O_NONBLOCK);\n\t\t\tqprintf(\"GET req for %s, path: %s, deflate: %p; fd#%d\\n\", dispatch_queue_get_label(req->q), path_buf, req->deflate, req->fd);\n\t\t\tsize_t n;\n\t\t\tif (req->fd < 0) {\n\t\t\t    const char *msg = \"<HTML><HEAD><TITLE>404 Page not here</TITLE></HEAD><BODY><P>You step in the stream,<BR>but the water has moved on.<BR>This <B>page is not here</B>.<BR></BODY></HTML>\";\n\t\t\t    req->status_number = 404;\n\t\t\t    n = buf_sprintf(&req->file_b, \"HTTP/1.1 404 Not Found\\r\\nContent-Length: %zu\\r\\nExpires: now\\r\\nServer: %s\\r\\n\\r\\n%s\", strlen(msg), argv0, msg);\n\t\t\t    req->sb.st_size = 0;\n\t\t\t} else {\n\t\t\t    rc = fstat(req->fd, &req->sb);\n\t\t\t    assert(rc >= 0);\n\t\t\t    if (req->sb.st_mode & S_IFDIR) {\n\t\t\t\treq->status_number = 301;\n\t\t\t\tregmatch_t hmatch[re_request_nmatch];\n\t\t\t\trc = regexec(&re_host, req->cmd_buf, re_request_nmatch, hmatch, 0);\n\t\t\t\tassert(rc == 0 || rc == REG_NOMATCH);\n\t\t\t\tif (rc == REG_NOMATCH) {\n\t\t\t\t    hmatch[1].rm_so = hmatch[1].rm_eo = 0;\n\t\t\t\t}\n\t\t\t\tn = buf_sprintf(&req->file_b, \"HTTP/1.1 301 Redirect\\r\\nContent-Length: 0\\r\\nExpires: now\\r\\nServer: %s\\r\\nLocation: http://%*.0s/%*.0s/index.html\\r\\n\\r\\n\", argv0, (int)(hmatch[1].rm_eo - hmatch[1].rm_so), req->cmd_buf + hmatch[1].rm_so, (int)(pmatch[2].rm_eo - pmatch[2].rm_so), req->cmd_buf + pmatch[2].rm_so);\n\t\t\t\treq->sb.st_size = 0;\n\t\t\t\tclose(req->fd);\n\t\t\t\treq->fd = -1;\n\t\t\t    } else {\n\t\t\t\treq->status_number = 200;\n\t\t\t\tif (req->deflate) {\n\t\t\t\t    n = buf_sprintf(&req->deflate_b, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\nContent-Encoding: deflate\\r\\nExpires: now\\r\\nServer: %s\\r\\n\", argv0);\n\t\t\t\t    req->chunk_bytes_remaining = buf_outof_sz(&req->deflate_b);\n\t\t\t\t} else {\n\t\t\t\t    n = buf_sprintf(req->deflate ? &req->deflate_b : &req->file_b, \"HTTP/1.1 200 OK\\r\\nContent-Length: %lld\\r\\nExpires: now\\r\\nServer: %s\\r\\n\\r\\n\", req->sb.st_size, argv0);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (req->status_number != 200) {\n\t\t\t    free(req->deflate);\n\t\t\t    req->deflate = NULL;\n\t\t\t}\n\n\t\t\tif (req->deflate) {\n\t\t\t    rc = deflateInit(req->deflate, Z_BEST_COMPRESSION);\n\t\t\t    assert(rc == Z_OK);\n\t\t\t}\n\n\t\t\t// Cheat: we don't count the header bytes as part of total_written\n\t\t\treq->total_written = -buf_outof_sz(&req->file_b);\n\t\t\tif (req->fd >= 0) {\n\t\t\t    req->fd_rd.ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, req->fd, 0, req->q);\n\t\t\t    // Cancelation is async, so we capture the fd and read sources we will want to operate on as the req struct may have moved on to a new set of values\n\t\t\t    int fd = req->fd;\n\t\t\t    dispatch_source_t fd_rd = req->fd_rd.ds;\n\t\t\t    dispatch_source_set_cancel_handler(req->fd_rd.ds, ^{\n\t\t\t\t    close(fd);\n\t\t\t\t    if (req->fd == fd) {\n\t\t\t\t\t    req->fd = -1;\n\t\t\t\t    }\n\t\t\t\t    if (req->fd_rd.ds == fd_rd) {\n\t\t\t\t\t    req->fd_rd.ds = NULL;\n\t\t\t\t    }\n\t\t\t    });\n\t\t\t    dispatch_source_set_event_handler(req->fd_rd.ds, ^{\n\t\t\t\t    if (req->fd_rd.ds) {\n\t\t\t\t\t    read_filedata(req, dispatch_source_get_data(req->fd_rd.ds)); \n\t\t\t\t    }\n\t\t\t    });\n\t\t\t    dispatch_resume(req->fd_rd.ds);\n\t\t\t} else {\n\t\t\t    req->fd_rd.ds = NULL;\n\t\t\t}\n\n\t\t\tif (req->sd_wr.ds) {\n\t\t\t    enable_source(req, &req->sd_wr);\n\t\t\t} else {\n\t\t\t    req->sd_wr.ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, req->sd, 0, req->q);\n\t\t\t    dispatch_source_set_event_handler(req->sd_wr.ds, ^{ write_filedata(req, dispatch_source_get_data(req->sd_wr.ds)); });\n\t\t\t    dispatch_resume(req->sd_wr.ds);\n\t\t\t}\n\t\t\tdisable_source(req, &req->sd_rd);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else if (rd == 0) {\n\tqprintf(\"### (%s) read_req fd#%d rd=0 (%s); %d files served\\n\", dispatch_queue_get_label(req->q), req->sd, (req->cb == req->cmd_buf) ? \"no final request\" : \"incomplete request\", req->files_served);\n\tclose_connection(req);\n\treturn;\n    } else {\n\tint e = errno;\n\tqprintf(\"reqd_req fd#%d rd=%d err=%d %s\\n\", req->sd, rd, e, strerror(e));\n\tclose_connection(req);\n\treturn;\n    }\n}", "path": "examples\\DispatchWebServer\\DispatchWebServer.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "static void\n_dispatch_source_set_cancel_handler2(void *context)", "code": "{\n\tdispatch_source_t ds = (dispatch_source_t)_dispatch_queue_get_current();\n\tdispatch_assert(ds->do_vtable == &_dispatch_source_kevent_vtable);\n\t\n\tif (ds->ds_cancel_is_block && ds->ds_cancel_handler) {\n\t\tBlock_release(ds->ds_cancel_handler);\n\t}\n\tds->ds_cancel_handler = context;\n\tds->ds_cancel_is_block = true;\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "dispatch_queue_t\n_dispatch_wakeup(dispatch_object_t dou)", "code": "{\n\tdispatch_queue_t tq;\n\n\tif (slowpath(DISPATCH_OBJECT_SUSPENDED(dou._do))) {\n\t\treturn NULL;\n\t}\n\tif (!dx_probe(dou._do) && !dou._dq->dq_items_tail) {\n\t\treturn NULL;\n\t}\n\n\tif (!_dispatch_trylock(dou._do)) {\n#if DISPATCH_COCOA_COMPAT\n\t\tif (dou._dq == &_dispatch_main_q) {\n\t\t\t_dispatch_queue_wakeup_main();\n\t\t}\n#endif\n\t\treturn NULL;\n\t}\n\t_dispatch_retain(dou._do);\n\ttq = dou._do->do_targetq;\n\t_dispatch_queue_push(tq, dou._do);\n\treturn tq;\t// libdispatch doesn't need this, but the Instrument DTrace probe does\n}", "path": "src\\queue.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// Updates the ordered list of timers based on next fire date for changes to ds.\n// Should only be called from the context of _dispatch_mgr_q.\n", "func_signal": "void\n_dispatch_timer_list_update(dispatch_source_t ds)", "code": "{\n\tdispatch_source_t dsi = NULL;\n\tint idx;\n\t\n\tdispatch_assert(_dispatch_queue_get_current() == &_dispatch_mgr_q);\n\n\t// do not reschedule timers unregistered with _dispatch_kevent_release()\n\tif (!ds->ds_dkev) {\n\t\treturn;\n\t}\n\n\t// Ensure the source is on the global kevent lists before it is removed and\n\t// readded below.\n\t_dispatch_kevent_merge(ds);\n\t\n\tTAILQ_REMOVE(&ds->ds_dkev->dk_sources, ds, ds_list);\n\n\t// change the list if the clock type has changed\n\tif (ds->ds_timer.flags & DISPATCH_TIMER_WALL_CLOCK) {\n\t\tidx = DISPATCH_TIMER_INDEX_WALL;\n\t} else {\n\t\tidx = DISPATCH_TIMER_INDEX_MACH;\n\t}\n\tds->ds_dkev = &_dispatch_kevent_timer[idx];\n\n\tif (ds->ds_timer.target) {\n\t\tTAILQ_FOREACH(dsi, &ds->ds_dkev->dk_sources, ds_list) {\n\t\t\tif (dsi->ds_timer.target == 0 || ds->ds_timer.target < dsi->ds_timer.target) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (dsi) {\n\t\tTAILQ_INSERT_BEFORE(dsi, ds, ds_list);\n\t} else {\n\t\tTAILQ_INSERT_TAIL(&ds->ds_dkev->dk_sources, ds, ds_list);\n\t}\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 10M\n", "func_signal": "void pingpongloop(dispatch_group_t group, dispatch_queue_t ping, dispatch_queue_t pong, size_t counter)", "code": "{\n\t//printf(\"[%p] %s: %lu\\n\", (void*)(uintptr_t)pthread_self(), dispatch_queue_get_label(dispatch_get_current_queue()), counter);\n\tif (counter < final) {\n\t\tdispatch_group_async(group, pong, ^{ pingpongloop(group, pong, ping, counter+1); });\n\t} else {\n\t\tcount = counter;\n\t}\n}", "path": "testing\\dispatch_pingpong.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "void\n_dispatch_queue_dispose(dispatch_queue_t dq)", "code": "{\n\tif (slowpath(dq == _dispatch_queue_get_current())) {\n\t\tDISPATCH_CRASH(\"Release of a queue by itself\");\n\t}\n\tif (slowpath(dq->dq_items_tail)) {\n\t\tDISPATCH_CRASH(\"Release of a queue while items are enqueued\");\n\t}\n\n#ifndef DISPATCH_NO_LEGACY\n\tif (dq->dq_finalizer_func) {\n\t\tdq->dq_finalizer_func(dq->dq_finalizer_ctxt, dq);\n\t}\n#endif\n\n\t// trash the tail queue so that use after free will crash\n\tdq->dq_items_tail = (void *)0x200;\n\n\t_dispatch_dispose(dq);\n}", "path": "src\\queue.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "dispatch_source_t\n_dispatch_source_create2(dispatch_source_t ds,\n\tdispatch_source_attr_t attr,\n\tvoid *context,\n\tdispatch_source_handler_function_t handler)", "code": "{\n\tif (ds == NULL || handler == NULL) {\n\t\treturn NULL;\n\t}\n\n\tds->ds_is_legacy = true;\n\n\tds->ds_handler_func = handler;\n\tds->ds_handler_ctxt = context;\n\t\t\n\tif (attr && attr != DISPATCH_SOURCE_CREATE_SUSPENDED) {\n\t\tds->dq_finalizer_ctxt = attr->finalizer_ctxt;\n\t\tds->dq_finalizer_func = (typeof(ds->dq_finalizer_func))attr->finalizer_func;\n\t\tds->do_ctxt = attr->context;\n\t}\n#ifdef __BLOCKS__\n\tif (ds->dq_finalizer_func == (void*)_dispatch_call_block_and_release2) {\n\t\tds->dq_finalizer_ctxt = Block_copy(ds->dq_finalizer_ctxt);\n\t\tif (!ds->dq_finalizer_ctxt) {\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tif (handler == _dispatch_source_call_block) {\n\t\tstruct Block_layout *bl = ds->ds_handler_ctxt = Block_copy(context);\n\t\tif (!ds->ds_handler_ctxt) {\n\t\t\tif (ds->dq_finalizer_func == (void*)_dispatch_call_block_and_release2) {\n\t\t\t\tBlock_release(ds->dq_finalizer_ctxt);\n\t\t\t}\n\t\t\tgoto out_bad;\n\t\t}\n\t\tds->ds_handler_func = (void *)bl->invoke;\n\t\tds->ds_handler_is_block = true;\n\t}\n\n\t// all legacy sources get a cancellation event on the normal event handler.\n\tdispatch_source_handler_function_t func = ds->ds_handler_func;\n\tdispatch_source_handler_t block = ds->ds_handler_ctxt;\n\tvoid *ctxt = ds->ds_handler_ctxt;\n\tbool handler_is_block = ds->ds_handler_is_block;\n\t\n\tds->ds_cancel_is_block = true;\n\tif (handler_is_block) {\n\t\tds->ds_cancel_handler = _dispatch_Block_copy(^{\n\t\t\tblock(ds);\n\t\t});\n\t} else {\n\t\tds->ds_cancel_handler = _dispatch_Block_copy(^{\n\t\t\tfunc(ctxt, ds);\n\t\t});\n\t}\n#endif\n\tif (attr != DISPATCH_SOURCE_CREATE_SUSPENDED) {\n\t\tdispatch_resume(ds);\n\t}\n\n\treturn ds;\n\nout_bad:\n\tfree(ds);\n\treturn NULL;\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// LEGACY\n", "func_signal": "uint64_t\ndispatch_event_get_nanoseconds(dispatch_source_t ds)", "code": "{\n\tif (ds->ds_timer.flags & DISPATCH_TIMER_WALL_CLOCK) {\n\t\treturn ds->ds_timer.interval;\n\t} else {\n\t\treturn _dispatch_convert_mach2nano(ds->ds_timer.interval);\n\t}\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// Note to later developers: ensure that any initialization changes are\n// made for statically allocated queues (i.e. _dispatch_main_q).\n", "func_signal": "inline void\n_dispatch_queue_init(dispatch_queue_t dq)", "code": "{\n\tdq->do_vtable = &_dispatch_queue_vtable;\n\tdq->do_next = DISPATCH_OBJECT_LISTLESS;\n\tdq->do_ref_cnt = 1;\n\tdq->do_xref_cnt = 1;\n\tdq->do_targetq = _dispatch_get_root_queue(0, true);\n\tdq->dq_running = 0;\n\tdq->dq_width = 1;\n\tdq->dq_serialnum = dispatch_atomic_inc(&_dispatch_queue_serial_numbers) - 1;\n}", "path": "src\\queue.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "static void\n_dispatch_source_set_event_handler2(void *context)", "code": "{\n\tstruct Block_layout *bl = context;\n\n\tdispatch_source_t ds = (dispatch_source_t)_dispatch_queue_get_current();\n\tdispatch_assert(ds->do_vtable == &_dispatch_source_kevent_vtable);\n\t\n\tif (ds->ds_handler_is_block && ds->ds_handler_ctxt) {\n\t\tBlock_release(ds->ds_handler_ctxt);\n\t}\n\tds->ds_handler_func = bl ? (void *)bl->invoke : NULL;\n\tds->ds_handler_ctxt = bl;\n\tds->ds_handler_is_block = true;\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "/* DISPATCH_NO_LEGACY */\n", "func_signal": "static void\n_dispatch_mach_notify_source_init(void *context __attribute__((unused)))", "code": "{\n\tsize_t maxsz = sizeof(union __RequestUnion___dispatch_send_libdispatch_internal_protocol_subsystem);\n\n\tif (sizeof(union __ReplyUnion___dispatch_libdispatch_internal_protocol_subsystem) > maxsz) {\n\t\tmaxsz = sizeof(union __ReplyUnion___dispatch_libdispatch_internal_protocol_subsystem);\n\t}\n\n\t_dispatch_get_port_set();\n\n\t_dispatch_mach_notify_source = dispatch_source_mig_create(_dispatch_event_port,\n\t\t\tmaxsz, NULL, &_dispatch_mgr_q, libdispatch_internal_protocol_server);\n\n\tdispatch_assert(_dispatch_mach_notify_source);\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// Find existing kevents, and merge any new flags if necessary\n", "func_signal": "void\n_dispatch_kevent_merge(dispatch_source_t ds)", "code": "{\n\tstatic dispatch_once_t pred;\n\tdispatch_kevent_t dk;\n\ttypeof(dk->dk_kevent.fflags) new_flags;\n\tbool do_resume = false;\n\n\tif (ds->ds_is_installed) {\n\t\treturn;\n\t}\n\tds->ds_is_installed = true;\n\n\tdispatch_once_f(&pred, NULL, _dispatch_source_init_tail_queue_array);\n\n\tdk = _dispatch_kevent_find(ds->ds_dkev->dk_kevent.ident, ds->ds_dkev->dk_kevent.filter);\n\t\n\tif (dk) {\n\t\t// If an existing dispatch kevent is found, check to see if new flags\n\t\t// need to be added to the existing kevent\n\t\tnew_flags = ~dk->dk_kevent.fflags & ds->ds_dkev->dk_kevent.fflags;\n\t\tdk->dk_kevent.fflags |= ds->ds_dkev->dk_kevent.fflags;\n\t\tfree(ds->ds_dkev);\n\t\tds->ds_dkev = dk;\n\t\tdo_resume = new_flags;\n\t} else {\n\t\tdk = ds->ds_dkev;\n\t\t_dispatch_kevent_insert(dk);\n\t\tnew_flags = dk->dk_kevent.fflags;\n\t\tdo_resume = true;\n\t}\n\n\tTAILQ_INSERT_TAIL(&dk->dk_sources, ds, ds_list);\n\n\t// Re-register the kevent with the kernel if new flags were added\n\t// by the dispatch kevent\n\tif (do_resume) {\n\t\tdk->dk_kevent.flags |= EV_ADD;\n\t\t_dispatch_kevent_resume(ds->ds_dkev, new_flags, 0);\n\t\tds->ds_is_armed = true;\n\t}\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// To be called from the context of the _dispatch_mgr_q\n", "func_signal": "static void\n_dispatch_source_set_timer2(void *context)", "code": "{\n\tstruct dispatch_set_timer_params *params = context;\n\tdispatch_source_t ds = params->ds;\n\tds->ds_ident_hack = params->ident;\n\tds->ds_timer = params->values;\n\t_dispatch_timer_list_update(ds);\n\tdispatch_resume(ds);\n\tdispatch_release(ds);\n\tfree(params);\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// We have some \"content data\" (either from the file, or from\n// compressing the file), and the network socket is ready for us to\n// write it\n", "func_signal": "void write_filedata(struct request *req, size_t avail)", "code": "{\n    /* We always attempt to write as much data as we have.   This\n     is safe becuase we use non-blocking I/O.   It is a good idea\n     becuase the amount of buffer space that dispatch tells us may\n     be stale (more space could have opened up, or memory presure\n     may have caused it to go down). */\n\n    struct buffer *w_buf = req->deflate ? &req->deflate_b : &req->file_b;\n    ssize_t sz = buf_outof_sz(w_buf);\n    if (req->deflate) {\n\tstruct iovec iov[2];\n\tif (!req->chunk_bytes_remaining) {\n\t    req->chunk_bytes_remaining = sz;\n\t    req->needs_zero_chunk = sz != 0;\n\t    req->cnp = req->chunk_num;\n\t    int n = snprintf(req->chunk_num, sizeof(req->chunk_num), \"\\r\\n%lx\\r\\n%s\", sz, sz ? \"\" : \"\\r\\n\");\n\t    assert(n <= sizeof(req->chunk_num));\n\t}\n\tiov[0].iov_base = req->cnp;\n\tiov[0].iov_len = req->cnp ? strlen(req->cnp) : 0;\n\tiov[1].iov_base = w_buf->outof;\n\tiov[1].iov_len = (req->chunk_bytes_remaining < sz) ? req->chunk_bytes_remaining : sz;\n\tsz = writev(req->sd, iov, 2);\n\tif (sz > 0) {\n\t    if (req->cnp) {\n\t\tif (sz >= strlen(req->cnp)) {\n\t\t    req->cnp = NULL;\n\t\t} else {\n\t\t    req->cnp += sz;\n\t\t}\n\t    }\n\t    sz -= iov[0].iov_len;\n\t    sz = (sz < 0) ? 0 : sz;\n\t    req->chunk_bytes_remaining -= sz;\n\t}\n    } else {\n\tsz = write(req->sd, w_buf->outof, sz);\n    }\n    if (sz > 0) {\n\tbuf_used_outof(w_buf, sz);\n    } else if (sz < 0) {\n\tint e = errno;\n\tqprintf(\"write_filedata %s write error: %d %s\\n\", dispatch_queue_get_label(req->q), e, strerror(e));\n\tclose_connection(req);\n\treturn;\n    }\n\n    req->total_written += sz;\n    off_t bytes = req->total_written;\n    if (req->deflate) {\n\tbytes = req->deflate->total_in - buf_outof_sz(w_buf);\n\tif (req->deflate->total_in < buf_outof_sz(w_buf)) {\n\t    bytes = 0;\n\t}\n    }\n    if (bytes == req->sb.st_size) {\n\tif (req->needs_zero_chunk && req->deflate && (sz || req->cnp)) {\n\t    return;\n\t}\n\n\t// We have transfered the file, time to write the log entry.\n\n\t// We don't deal with \" in the request string, this is an example of how\n\t// to use dispatch, not how to do C string manipulation, eh?\n\tsize_t rlen = strcspn(req->cmd_buf, \"\\r\\n\");\n\tchar tstr[45], astr[45];\n\tstruct tm tm;\n\ttime_t clock;\n\ttime(&clock);\n\tstrftime(tstr, sizeof(tstr), \"%d/%b/%Y:%H:%M:%S +0\", gmtime_r(&clock, &tm));\n\taddr2ascii(AF_INET, &req->r_addr.sin_addr, sizeof(struct in_addr), astr);\n\tqfprintf(logfile, \"%s - - [%s] \\\"%.*s\\\" %hd %zd\\n\", astr, tstr, (int)rlen, req->cmd_buf, req->status_number, req->total_written);\n\n\tint64_t t_offset = 5 * NSEC_PER_SEC + req->files_served * NSEC_PER_SEC / 10;\n\tint64_t timeout_at = req->timeout_at = getnanotime() + t_offset;\n\n\treq->timeo.ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, req->q);\n\tdispatch_source_set_timer(req->timeo.ds, dispatch_time(DISPATCH_TIME_NOW, t_offset), NSEC_PER_SEC, NSEC_PER_SEC);\n\tdispatch_source_set_event_handler(req->timeo.ds, ^{\n\t\t\tif (req->timeout_at == timeout_at) {\n\t\t\t\tqfprintf(stderr, \"$$$ -- timeo fire (delta=%f) -- close connection: q=%s\\n\", (getnanotime() - (double)timeout_at) / NSEC_PER_SEC, dispatch_queue_get_label(req->q));\n\t\t\t\tclose_connection(req);\n\t\t\t} else {\n\t\t\t\t// This happens if the timeout value has been updated, but a pending timeout event manages to race in before the cancel\n\t\t\t}\n\t\t});\n\tdispatch_resume(req->timeo.ds);\n\n\treq->files_served++;\n\tqprintf(\"$$$ wrote whole file (%s); timeo %p, about to enable %p and close %d, total_written=%zd, this is the %d%s file served\\n\", dispatch_queue_get_label(req->q), req->timeo.ds, req->sd_rd.ds, req->fd, req->total_written, req->files_served, (1 == req->files_served) ? \"st\" : (2 == req->files_served) ? \"nd\" : \"th\");\n\tenable_source(req, &req->sd_rd);\n\tif (req->fd_rd.ds) {\n\t\tdelete_source(req, &req->fd_rd);\n\t}\n\treq->cb = req->cmd_buf;\n    } else {\n\tassert(bytes <= req->sb.st_size);\n    }\n\n    if (0 == buf_outof_sz(w_buf)) {\n\t// The write buffer is now empty, so we don't need to know when sd is ready for us to write to it.\n\tdisable_source(req, &req->sd_wr);\n    }\n}", "path": "examples\\DispatchWebServer\\DispatchWebServer.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "/*\n * Read up-to as much as is requested, and write\n * that to the other fd, taking into account exceptional\n * conditions and re-trying\n */\n", "func_signal": "void doreadwrite(int fd1, int fd2, char *buffer, size_t len)", "code": "{\n\tssize_t readBytes, writeBytes, totalWriteBytes;\n\t\n\tif (fd1 != -1) {\n\t\tsyslog(LOG_DEBUG, \"trying to read %ld bytes from fd %d\", len, fd1);\n\t\treadBytes = read(fd1, buffer, len);\n\t\tif (readBytes < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN) {\n\t\t\t\t/* can't do anything now, hope we get called again */\n\t\t\t\tsyslog(LOG_DEBUG, \"error read fd %d: %s (%d)\", fd1, strerror(errno), errno);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\terr(1, \"read fd %d\", fd1);\n\t\t\t}\n\t\t} else if (readBytes == 0) {\n\t\t\tsyslog(LOG_DEBUG, \"EOF on fd %d\", fd1);\n\t\t\treturn;\n\t\t}\n\t\tsyslog(LOG_DEBUG, \"read %ld bytes from fd %d\", readBytes, fd1);\n\t} else {\n\t\treadBytes = len;\n\t\tsyslog(LOG_DEBUG, \"read buffer has %ld bytes\", readBytes);\n\t}\n\t\n\ttotalWriteBytes = 0;\n\tdo {\n\t\twriteBytes = write(fd2, buffer+totalWriteBytes, readBytes-totalWriteBytes);\n\t\tif (writeBytes < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\terr(1, \"write fd %d\", fd2);\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_DEBUG, \"wrote %ld bytes to fd %d\", writeBytes, fd2);\n\t\ttotalWriteBytes += writeBytes;\n\t\t\n\t} while (totalWriteBytes < readBytes);\n\t\n\treturn;\n}", "path": "examples\\Dispatch Samples\\netcat.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// LEGACY\n", "func_signal": "long\ndispatch_source_timer_set_time(dispatch_source_t ds, uint64_t nanoseconds, uint64_t leeway)", "code": "{\n\tdispatch_time_t start;\n\tif (nanoseconds == 0) {\n\t\tnanoseconds = 1;\n\t}\n\tif (ds->ds_timer.flags == (DISPATCH_TIMER_ABSOLUTE|DISPATCH_TIMER_WALL_CLOCK)) {\n\t\tstatic const struct timespec t0;\n\t\tstart = dispatch_walltime(&t0, nanoseconds);\n\t} else if (ds->ds_timer.flags & DISPATCH_TIMER_WALL_CLOCK) {\n\t\tstart = dispatch_walltime(DISPATCH_TIME_NOW, nanoseconds);\n\t} else {\n\t\tstart = dispatch_time(DISPATCH_TIME_NOW, nanoseconds);\n\t}\n\tif (ds->ds_timer.flags & (DISPATCH_TIMER_ABSOLUTE|DISPATCH_TIMER_ONESHOT)) {\n\t\t// 6866347 - make sure nanoseconds won't overflow\n\t\tnanoseconds = INT64_MAX; // non-repeating (~292 years)\n\t}\n\tdispatch_source_set_timer(ds, start, nanoseconds, leeway);\n\treturn 0;\n}", "path": "src\\source.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// Our \"content file\" has some data ready for us to read.\n", "func_signal": "void read_filedata(struct request *req, size_t avail)", "code": "{\n    if (avail == 0) {\n\t    delete_source(req, &req->fd_rd);\n\t    return;\n    }\n\n    /* We make sure we can read at least as many bytes as dispatch\n      says are avilable, but if our buffer is bigger we will read as\n      much as we have space for.  We have the file opened in non-blocking\n      mode so this is safe. */\n\n    buf_need_into(&req->file_b, avail);\n    size_t rsz = buf_into_sz(&req->file_b);\n    ssize_t sz = read(req->fd, req->file_b.into, rsz);\n    if (sz >= 0) {\n\tassert(req->sd_wr.ds);\n\tsize_t sz0 = buf_outof_sz(&req->file_b);\n\tbuf_used_into(&req->file_b, sz);\n\tassert(sz == buf_outof_sz(&req->file_b) - sz0);\n    } else {\n\tint e = errno;\n\tqprintf(\"read_filedata %s read error: %d %s\\n\", dispatch_queue_get_label(req->q), e, strerror(e));\n\tclose_connection(req);\n\treturn;\n    }\n    if (req->deflate) {\n\t// Note:: deflateBound is \"worst case\", we could try with any non-zero\n\t// buffer, and alloc more if we get Z_BUF_ERROR...\n\tbuf_need_into(&req->deflate_b, deflateBound(req->deflate, buf_outof_sz(&req->file_b)));\n\treq->deflate->next_in = (req->file_b.outof);\n\tsize_t o_sz = buf_outof_sz(&req->file_b);\n\treq->deflate->avail_in = o_sz;\n\treq->deflate->next_out = req->deflate_b.into;\n\tsize_t i_sz = buf_into_sz(&req->deflate_b);\n\treq->deflate->avail_out = i_sz;\n\tassert(req->deflate->avail_in + req->deflate->total_in <= req->sb.st_size);\n\t// at EOF we want to use Z_FINISH, otherwise we pass Z_NO_FLUSH so we get maximum compression\n\tint rc = deflate(req->deflate, (req->deflate->avail_in + req->deflate->total_in >= req->sb.st_size) ? Z_FINISH : Z_NO_FLUSH);\n\tassert(rc == Z_OK || rc == Z_STREAM_END);\n\tbuf_used_outof(&req->file_b, o_sz - req->deflate->avail_in);\n\tbuf_used_into(&req->deflate_b, i_sz - req->deflate->avail_out);\n\tif (i_sz != req->deflate->avail_out) {\n\t    enable_source(req, &req->sd_wr);\n\t}\n    } else {\n\tenable_source(req, &req->sd_wr);\n    }\n}", "path": "examples\\DispatchWebServer\\DispatchWebServer.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// We have a new connection, allocate a req struct & set up a read event handler\n", "func_signal": "void accept_cb(int fd)", "code": "{\n    static int req_num = 0;\n    struct request *new_req = calloc(1, sizeof(struct request));\n    assert(new_req);\n    new_req->cb = new_req->cmd_buf;\n    socklen_t r_len = sizeof(new_req->r_addr);\n    int s = accept(fd, (struct sockaddr *)&(new_req->r_addr), &r_len);\n    if (s < 0) {\n\t    qfprintf(stderr, \"accept failure (rc=%d, errno=%d %s)\\n\", s, errno, strerror(errno));\n\t    return;\n    }\n    assert(s >= 0);\n    new_req->sd = s;\n    new_req->req_num = req_num;\n    asprintf(&(new_req->q_name), \"req#%d s#%d\", req_num++, s);\n    qprintf(\"accept_cb fd#%d; made: %s\\n\", fd, new_req->q_name);\n\n    // All further work for this request will happen \"on\" new_req->q,\n    // except the final tear down (see req_free())\n    new_req->q = dispatch_queue_create(new_req->q_name, NULL);\n    dispatch_set_context(new_req->q, new_req);\n    dispatch_set_finalizer_f(new_req->q, (dispatch_function_t)req_free);\n\n    debug_req = reallocf(debug_req, sizeof(struct request *) * ++n_req);\n    debug_req[n_req -1] = new_req;\n\n    \n    new_req->sd_rd.ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, new_req->sd, 0, new_req->q);\n    dispatch_source_set_event_handler(new_req->sd_rd.ds, ^{\n\t    read_req(new_req, dispatch_source_get_data(new_req->sd_rd.ds));\n    });\n\n    // We want our queue to go away when all of it's sources do, so we\n    // drop the reference dispatch_queue_create gave us & rely on the\n    // references each source holds on the queue to keep it alive.\n    dispatch_release(new_req->q);\n    dispatch_resume(new_req->sd_rd.ds);\n}", "path": "examples\\DispatchWebServer\\DispatchWebServer.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "// 6618342 Contact the team that owns the Instrument DTrace probe before renaming this symbol\n", "func_signal": "static void\n_dispatch_set_target_queue2(void *ctxt)", "code": "{\n\tdispatch_queue_t prev_dq, dq = _dispatch_queue_get_current();\n\t\t  \n\tprev_dq = dq->do_targetq;\n\tdq->do_targetq = ctxt;\n\t_dispatch_release(prev_dq);\n}", "path": "src\\queue.c", "repo_name": "AlanQuatermain/libdispatch-channels", "stars": 8, "license": "apache-2.0", "language": "c", "size": 320}
{"docstring": "/**************************************************************************\n  signal handlers\n**************************************************************************/\n", "func_signal": "static void sighup_handler(int xxx)", "code": "{\n  LOG_MESSAGE(\"sighup signal received\\n\");\n  cleanup();\n  /* xmemleaks(); */\n  exit(0);\n}", "path": "xnotify.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* usually called after fork if backend needs to re-arm all fds from scratch */\n", "func_signal": "static void noinline\nfd_rearm_all (EV_P)", "code": "{\n  int fd;\n\n  for (fd = 0; fd < anfdmax; ++fd)\n    if (anfds [fd].events)\n      {\n        anfds [fd].events = 0;\n        fd_change (EV_A_ fd, EV_IOFDSET | 1);\n      }\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* called on ENOMEM in select/poll to kill some fds and retry */\n", "func_signal": "static void noinline\nfd_enomem (EV_P)", "code": "{\n  int fd;\n\n  for (fd = anfdmax; fd--; )\n    if (anfds [fd].events)\n      {\n        fd_kill (EV_A_ fd);\n        return;\n      }\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void inline_speed\nfd_intern (int fd)", "code": "{\n#ifdef _WIN32\n  int arg = 1;\n  ioctlsocket (_get_osfhandle (fd), FIONBIO, &arg);\n#else\n  fcntl (fd, F_SETFD, FD_CLOEXEC);\n  fcntl (fd, F_SETFL, O_NONBLOCK);\n#endif\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* away from the root */\n", "func_signal": "void inline_speed\ndownheap (ANHE *heap, int N, int k)", "code": "{\n  ANHE he = heap [k];\n\n  for (;;)\n    {\n      int c = k << 1;\n\n      if (c > N + HEAP0 - 1)\n        break;\n\n      c += c + 1 < N + HEAP0 && ANHE_at (heap [c]) > ANHE_at (heap [c + 1])\n           ? 1 : 0;\n\n      if (ANHE_at (he) <= ANHE_at (heap [c]))\n        break;\n\n      heap [k] = heap [c];\n      ev_active (ANHE_w (heap [k])) = k;\n      \n      k = c;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void inline_size\nanfds_init (ANFD *base, int count)", "code": "{\n  while (count--)\n    {\n      base->head   = 0;\n      base->events = EV_NONE;\n      base->reify  = 0;\n\n      ++base;\n    }\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/**************************************************************************\n  libev loop and main\n**************************************************************************/\n", "func_signal": "static void init_and_start_ev_loop(int xfd)", "code": "{\n  struct ev_loop *el = ev_default_loop(0);\n  ev_io xconnection;\n\n  /* macros?! whuut?! */\n  xconnection.active = xconnection.pending = xconnection.priority = 0;\n  xconnection.cb = xconnection_cb;\n  xconnection.fd = xfd; \n  xconnection.events = EV_READ | EV_IOFDSET;\n\n  ev_io_start(el, &xconnection);\n  ev_loop(el, 0);\n}", "path": "xnotify.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* return true if we are running with elevated privileges and should ignore env variables */\n", "func_signal": "int inline_size\nenable_secure (void)", "code": "{\n#ifdef _WIN32\n  return 0;\n#else\n  return getuid () != geteuid ()\n      || getgid () != getegid ();\n#endif\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void noinline\nev_io_start (EV_P_ ev_io *w)", "code": "{\n  int fd = w->fd;\n\n  if (expect_false (ev_is_active (w)))\n    return;\n\n  assert ((\"ev_io_start called with negative fd\", fd >= 0));\n\n  EV_FREQUENT_CHECK;\n\n  ev_start (EV_A_ (W)w, 1);\n  array_needsize (ANFD, anfds, anfdmax, fd + 1, anfds_init);\n  wlist_add (&anfds[fd].head, (WL)w);\n\n  fd_change (EV_A_ fd, w->events & EV_IOFDSET | 1);\n  w->events &= ~EV_IOFDSET;\n\n  EV_FREQUENT_CHECK;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* rebuild the heap: this function is used only once and executed rarely */\n", "func_signal": "void inline_size\nreheap (ANHE *heap, int N)", "code": "{\n  int i;\n\n  /* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */\n  /* also, this is easy to implement and correct for both 2-heaps and 4-heaps */\n  for (i = 0; i < N; ++i)\n    upheap (heap, i + HEAP0);\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* prefer to allocate in chunks of this size, must be 2**n and >> 4 longs */\n", "func_signal": "int inline_size\narray_nextsize (int elem, int cur, int cnt)", "code": "{\n  int ncur = cur + 1;\n\n  do\n    ncur <<= 1;\n  while (cnt > ncur);\n\n  /* if size is large, round to MALLOC_ROUND - 4 * longs to accomodate malloc overhead */\n  if (elem * ncur > MALLOC_ROUND - sizeof (void *) * 4)\n    {\n      ncur *= elem;\n      ncur = (ncur + elem + (MALLOC_ROUND - 1) + sizeof (void *) * 4) & ~(MALLOC_ROUND - 1);\n      ncur = ncur - sizeof (void *) * 4;\n      ncur /= elem;\n    }\n\n  return ncur;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/*****************************************************************************/\n", "func_signal": "static void\nev_sighandler (int signum)", "code": "{\n#if EV_MULTIPLICITY\n  struct ev_loop *loop = &default_loop_struct;\n#endif\n\n#if _WIN32\n  signal (signum, ev_sighandler);\n#endif\n\n  signals [signum - 1].gotsig = 1;\n  evpipe_write (EV_A_ &gotsig);\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/*****************************************************************************/\n", "func_signal": "void inline_size\nwlist_add (WL *head, WL elem)", "code": "{\n  elem->next = *head;\n  *head = elem;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* away from the root */\n", "func_signal": "void inline_speed\ndownheap (ANHE *heap, int N, int k)", "code": "{\n  ANHE he = heap [k];\n  ANHE *E = heap + N + HEAP0;\n\n  for (;;)\n    {\n      ev_tstamp minat;\n      ANHE *minpos;\n      ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + 1;\n\n      /* find minimum child */\n      if (expect_true (pos + DHEAP - 1 < E))\n        {\n          /* fast path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));\n          if (               ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));\n        }\n      else if (pos < E)\n        {\n          /* slow path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));\n          if (pos + 1 < E && ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));\n          if (pos + 2 < E && ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));\n          if (pos + 3 < E && ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));\n        }\n      else\n        break;\n\n      if (ANHE_at (he) <= minat)\n        break;\n\n      heap [k] = *minpos;\n      ev_active (ANHE_w (*minpos)) = k;\n\n      k = minpos - heap;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/**************************************************************************\n  X error handlers\n**************************************************************************/\n", "func_signal": "static int X_error_handler(Display *dpy, XErrorEvent *error)", "code": "{\n  char buf[1024];\n  if (error->error_code == BadWindow)\n    return 0;\n  XGetErrorText(dpy, error->error_code, buf, sizeof(buf));\n  LOG_WARNING(\"X error: %s (resource id: %d)\\n\", buf, error->resourceid);\n  return 0;\n}", "path": "xnotify.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* towards the root */\n", "func_signal": "void inline_speed\nupheap (ANHE *heap, int k)", "code": "{\n  ANHE he = heap [k];\n\n  for (;;)\n    {\n      int p = HPARENT (k);\n\n      if (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) <= ANHE_at (he))\n        break;\n\n      heap [k] = heap [p];\n      ev_active (ANHE_w (heap [k])) = k;\n      k = p;\n    }\n\n  heap [k] = he;\n  ev_active (ANHE_w (he)) = k;\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* called on EBADF to verify fds */\n", "func_signal": "static void noinline\nfd_ebadf (EV_P)", "code": "{\n  int fd;\n\n  for (fd = 0; fd < anfdmax; ++fd)\n    if (anfds [fd].events)\n      if (!fd_valid (fd) == -1 && errno == EBADF)\n        fd_kill (EV_A_ fd);\n}", "path": "libev\\ev.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* oh, the humanity! */\n", "func_signal": "static int\nev_pipe (int filedes [2])", "code": "{\n  struct sockaddr_in addr = { 0 };\n  int addr_size = sizeof (addr);\n  SOCKET listener;\n  SOCKET sock [2] = { -1, -1 };\n\n  if ((listener = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) \n    return -1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n  addr.sin_port = 0;\n\n  if (bind (listener, (struct sockaddr *)&addr, addr_size))\n    goto fail;\n\n  if (getsockname(listener, (struct sockaddr *)&addr, &addr_size))\n    goto fail;\n\n  if (listen (listener, 1))\n    goto fail;\n\n  if ((sock [0] = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) \n    goto fail;\n\n  if (connect (sock[0], (struct sockaddr *)&addr, addr_size))\n    goto fail;\n\n  if ((sock[1] = accept (listener, 0, 0)) < 0)\n    goto fail;\n\n  closesocket (listener);\n\n#if EV_SELECT_IS_WINSOCKET\n  filedes [0] = _open_osfhandle (sock [0], 0);\n  filedes [1] = _open_osfhandle (sock [1], 0);\n#else\n  /* when select isn't winsocket, we also expect socket, connect, accept etc.\n   * to work on fds */\n  filedes [0] = sock [0];\n  filedes [1] = sock [1];\n#endif\n\n  return 0;\n\nfail:\n  closesocket (listener);\n\n  if (sock [0] != INVALID_SOCKET) closesocket (sock [0]);\n  if (sock [1] != INVALID_SOCKET) closesocket (sock [1]);\n\n  return -1;\n}", "path": "libev\\ev_win32.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/**************************************************************************\n  initialization\n**************************************************************************/\n", "func_signal": "static void initX()", "code": "{\n\t/* open connection to X server */\n\tX.display = XOpenDisplay(0);\n\tif (!X.display)\n\t\tLOG_ERROR(\"failed connect to X server\\n\");\n\tXSetErrorHandler(X_error_handler);\n\tXSetIOErrorHandler(X_io_error_handler);\n\t\n\tmemset(&X.attrs, 0, sizeof(X.attrs));\n\n\t/* useful variables */\n\tX.screen \t= DefaultScreen(X.display);\n\tX.screen_width \t= DisplayWidth(X.display, X.screen);\n\tX.screen_height\t= DisplayHeight(X.display, X.screen);\n\tX.visual \t= DefaultVisual(X.display, X.screen);\n\tX.colmap\t= CopyFromParent;\n\tX.root \t\t= RootWindow(X.display, X.screen);\n\tX.amask\t\t= 0;\n\tX.depth \t= DefaultDepth(X.display, X.screen);\n\tX.wa_x \t\t= 0;\n\tX.wa_y \t\t= 0;\n\tX.wa_w \t\t= X.screen_width;\n\tX.wa_h \t\t= X.screen_height;\n\t\n\t/* get internal atoms */\n\tXInternAtoms(X.display, atom_names, XATOM_COUNT, False, X.atoms);\n\tXSelectInput( X.display\n              , X.root\n              , PropertyChangeMask \n              | ButtonPressMask \n              | KeyPressMask \n              | ExposureMask\n              | FocusChangeMask \n              | StructureNotifyMask\n              );\n\n\t/* append_font_path_to_imlib(); */\n\n\t/* get workarea */\n\tint32_t *workarea = get_prop_data(X.root, X.atoms[XATOM_NET_WORKAREA], XA_CARDINAL, 0);\n\tif (workarea) {\n\t\tX.wa_x = workarea[0];\n\t\tX.wa_y = workarea[1];\n\t\tX.wa_w = workarea[2];\n\t\tX.wa_h = workarea[3];\n\t\tXFree(workarea);\t\n\t}\n}", "path": "xnotify.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/**************************************************************************\n  window properties\n**************************************************************************/\n", "func_signal": "static void *get_prop_data(Window win, Atom prop, Atom type, int *items)", "code": "{\n\tAtom type_ret;\n\tint format_ret;\n\tunsigned long items_ret;\n\tunsigned long after_ret;\n\tunsigned char *prop_data;\n\n\tprop_data = 0;\n\n\tXGetWindowProperty(X.display, win, prop, 0, 0x7fffffff, False,\n\t\t\ttype, &type_ret, &format_ret, &items_ret,\n\t\t\t&after_ret, &prop_data);\n\tif (items)\n\t\t*items = items_ret;\n\n\treturn prop_data;\n}", "path": "xnotify.c", "repo_name": "masutu/xnotify", "stars": 11, "license": "None", "language": "c", "size": 452}
{"docstring": "/* Function: tp_object\n * Creates a new object.\n *\n * Returns:\n * The newly created object. The object initially has no parent class, use\n * <tp_setmeta> to set a class. Also see <tp_object_new>.\n */\n", "func_signal": "tp_obj tp_object(TP)", "code": "{\n    tp_obj self = tp_dict(tp);\n    self.dict.dtype = 2;\n    return self;\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* mouse */\n", "func_signal": "tp_obj pygame_mouse_get_pos(TP)", "code": "{\n    int x,y;\n    SDL_GetMouseState(&x,&y);\n    tp_obj r = tp_list_n(tp,2,(tp_obj[]){tp_number(x),tp_number(y)});\n    return r;\n}", "path": "modules\\pygame\\init.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_iter\n * Iterate through a list or dict.\n *\n * If self is a list/string/dictionary, this will iterate over the\n * elements/characters/keys respectively, if k is an increasing index\n * starting with 0 up to the length of the object-1.\n *\n * In the case of a list of string, the returned items will correspond to the\n * item at index k. For a dictionary, no guarantees are made about the order.\n * You also cannot call the function with a specific k to get a specific\n * item -- it is only meant for iterating through all items, calling this\n * function len(self) times. Use <tp_get> to retrieve a specific item, and\n * <tp_len> to get the length.\n *\n * Parameters:\n * self - The object over which to iterate.\n * k - You must pass 0 on the first call, then increase it by 1 after each call,\n *     and don't call the function with k >= len(self).\n *\n * Returns:\n * The first (k = 0) or next (k = 1 .. len(self)-1) item in the iteration.\n */\n", "func_signal": "tp_obj tp_iter(TP,tp_obj self, tp_obj k)", "code": "{\n    int type = self.type;\n    if (type == TP_LIST || type == TP_STRING) { return tp_get(tp,self,k); }\n    if (type == TP_DICT && k.type == TP_NUMBER) {\n        return self.dict.val->items[_tp_dict_next(tp,self.dict.val)].key;\n    }\n    tp_raise(tp_None,tp_string(\"(tp_iter) TypeError: iteration over non-sequence\"));\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_iget\n * Failsafe attribute lookup.\n *\n * This is like <tp_get>, except it will return false if the attribute lookup\n * failed. Otherwise, it will return true, and the object will be returned\n * over the reference parameter r.\n */\n", "func_signal": "int tp_iget(TP,tp_obj *r, tp_obj self, tp_obj k)", "code": "{\n    if (self.type == TP_DICT) {\n        int n = _tp_dict_find(tp,self.dict.val,k);\n        if (n == -1) { return 0; }\n        *r = self.dict.val->items[n].val;\n        tp_grey(tp,*r);\n        return 1;\n    }\n    if (self.type == TP_LIST && !self.list.val->len) { return 0; }\n    *r = tp_get(tp,self,k); tp_grey(tp,*r);\n    return 1;\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_class\n * Creates a new base class.\n *\n * Parameters:\n * none\n *\n * Returns:\n * A new, empty class (derived from tinypy's builtin \"object\" class).\n */\n", "func_signal": "tp_obj tp_class(TP)", "code": "{\n    tp_obj klass = tp_dict(tp);\n    klass.dict.val->meta = tp_get(tp,tp->builtins,tp_string(\"object\")); \n    return klass;\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_system\n *\n * The system builtin. A grave security flaw. If your version of tinypy\n * enables this, you better remove it before deploying your app :P\n */\n", "func_signal": "tp_obj tp_system(TP)", "code": "{\n    char s[TP_CSTR_LEN]; tp_cstr(tp,TP_STR(),s,TP_CSTR_LEN);\n    int r = system(s);\n    return tp_number(r);\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* event module */\n", "func_signal": "tp_obj pygame_event_get(TP)", "code": "{\n    SDL_Event e;\n    tp_obj r = tp_list(tp);\n    while (SDL_PollEvent(&e)) {\n        tp_obj d = tp_dict(tp);\n        tp_set(tp,d,tp_string(\"type\"),tp_number(e.type));\n        switch (e.type) {\n            case SDL_KEYDOWN:\n            case SDL_KEYUP:\n                tp_set(tp,d,tp_string(\"key\"),tp_number(e.key.keysym.sym));\n                tp_set(tp,d,tp_string(\"mod\"),tp_number(e.key.keysym.mod));\n                break;\n            case SDL_MOUSEMOTION:\n                tp_set(tp,d,tp_string(\"pos\"),tp_list_n(tp,2,(tp_obj[]){tp_number(e.motion.x),tp_number(e.motion.y)}));\n                tp_set(tp,d,tp_string(\"rel\"),tp_list_n(tp,2,(tp_obj[]){tp_number(e.motion.xrel),tp_number(e.motion.yrel)}));\n                tp_set(tp,d,tp_string(\"state\"),tp_number(e.motion.state));\n                break;\n            case SDL_MOUSEBUTTONDOWN:\n            case SDL_MOUSEBUTTONUP:\n                tp_set(tp,d,tp_string(\"pos\"),tp_list_n(tp,2,(tp_obj[]){tp_number(e.button.x),tp_number(e.button.y)}));\n                tp_set(tp,d,tp_string(\"button\"),tp_number(e.button.button));\n                break;\n        }\n        tp_set(tp,r,tp_None,d);\n    }\n    return r;\n}", "path": "modules\\pygame\\init.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/*\n * random_mod_init()\n *\n * random module initialization function\n */\n", "func_signal": "void random_init(TP)", "code": "{\n    /*\n     * module dict for random\n     */\n    tp_obj random_mod = tp_dict(tp);\n\n    /*\n     * bind functions to random module\n     */\n    tp_set(tp, random_mod, tp_string(\"seed\"),       tp_fnc(tp, random_seed));\n    tp_set(tp, random_mod, tp_string(\"getstate\"),   tp_fnc(tp, random_getstate));\n    tp_set(tp, random_mod, tp_string(\"setstate\"),   tp_fnc(tp, random_setstate));\n    tp_set(tp, random_mod, tp_string(\"jumpahead\"),  tp_fnc(tp, random_jumpahead));\n    tp_set(tp, random_mod, tp_string(\"random\"),     tp_fnc(tp, random_random));\n\n    /*\n     * bind usual distribution random variable generator\n     */\n    tp_set(tp, random_mod, tp_string(\"uniform\"),        tp_fnc(tp, random_uniform));\n    tp_set(tp, random_mod, tp_string(\"normalvariate\"),  tp_fnc(tp, random_normalvariate));\n    tp_set(tp, random_mod, tp_string(\"lognormvariate\"), tp_fnc(tp, random_lognormvariate));\n    tp_set(tp, random_mod, tp_string(\"expovariate\"),    tp_fnc(tp, random_expovariate));\n    tp_set(tp, random_mod, tp_string(\"vonmisesvariate\"), tp_fnc(tp, random_vonmisesvariate));\n    tp_set(tp, random_mod, tp_string(\"gammavariate\"),   tp_fnc(tp, random_gammavariate));\n    tp_set(tp, random_mod, tp_string(\"betavariate\"),    tp_fnc(tp, random_betavariate));\n    tp_set(tp, random_mod, tp_string(\"paretovariate\"),  tp_fnc(tp, random_paretovariate));\n    tp_set(tp, random_mod, tp_string(\"weibullvariate\"), tp_fnc(tp, random_weibullvariate));\n    tp_set(tp, random_mod, tp_string(\"randrange\"),      tp_fnc(tp, random_randrange));\n    tp_set(tp, random_mod, tp_string(\"randint\"),        tp_fnc(tp, random_randint));\n    tp_set(tp, random_mod, tp_string(\"choice\"),         tp_fnc(tp, random_choice));\n    tp_set(tp, random_mod, tp_string(\"shuffle\"),        tp_fnc(tp, random_shuffle));\n\n    /*\n     * bind special attributes to random module\n     */\n    tp_set(tp, random_mod, tp_string(\"__doc__\"),  tp_string(\"Random variable generators.\"));\n    tp_set(tp, random_mod, tp_string(\"__name__\"), tp_string(\"random\"));\n    tp_set(tp, random_mod, tp_string(\"__file__\"), tp_string(__FILE__));\n\n    /*\n     * bind random module to tinypy modules[]\n     */\n    tp_set(tp, tp->modules, tp_string(\"random\"), random_mod);\n}", "path": "modules\\random\\init.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_str\n * String representation of an object.\n *\n * Returns a string object representating self.\n */\n", "func_signal": "tp_obj tp_str(TP,tp_obj self)", "code": "{\n    int type = self.type;\n    if (type == TP_STRING) { return self; }\n    if (type == TP_NUMBER) {\n        tp_num v = self.number.val;\n        if ((fabs(v)-fabs((long)v)) < 0.000001) { return tp_printf(tp,\"%ld\",(long)v); }\n        return tp_printf(tp,\"%f\",v);\n    } else if(type == TP_DICT) {\n        return tp_printf(tp,\"<dict 0x%x>\",self.dict.val);\n    } else if(type == TP_LIST) {\n        return tp_printf(tp,\"<list 0x%x>\",self.list.val);\n    } else if (type == TP_NONE) {\n        return tp_string(\"None\");\n    } else if (type == TP_DATA) {\n        return tp_printf(tp,\"<data 0x%x>\",self.data.val);\n    } else if (type == TP_FNC) {\n        return tp_printf(tp,\"<fnc 0x%x>\",self.fnc.info);\n    }\n    return tp_string(\"<?>\");\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_has\n * Checks if an object contains a key.\n *\n * Returns tp_True if self[k] exists, tp_False otherwise.\n */\n", "func_signal": "tp_obj tp_has(TP,tp_obj self, tp_obj k)", "code": "{\n    int type = self.type;\n    if (type == TP_DICT) {\n        if (_tp_dict_find(tp,self.dict.val,k) != -1) { return tp_True; }\n        return tp_False;\n    } else if (type == TP_STRING && k.type == TP_STRING) {\n        return tp_number(_tp_str_index(self,k)!=-1);\n    } else if (type == TP_LIST) {\n        return tp_number(_tp_list_find(tp,self.list.val,k)!=-1);\n    }\n    tp_raise(tp_None,tp_string(\"(tp_has) TypeError: iterable argument required\"));\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* utility functions */\n", "func_signal": "Uint32 pygame_list_to_color(TP,tp_obj clr,SDL_Surface *s)", "code": "{\n    int r,g,b;\n    r = tp_get(tp,clr,tp_number(0)).number.val;\n    g = tp_get(tp,clr,tp_number(1)).number.val;\n    b = tp_get(tp,clr,tp_number(2)).number.val;\n    return SDL_MapRGB(s->format,r,g,b);\n}", "path": "modules\\pygame\\init.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_get\n * Attribute lookup.\n * \n * This returns the result of using self[k] in actual code. It works for\n * dictionaries (including classes and instantiated objects), lists and strings.\n *\n * As a special case, if self is a list, self[None] will return the first\n * element in the list and subsequently remove it from the list.\n */\n", "func_signal": "tp_obj tp_get(TP,tp_obj self, tp_obj k)", "code": "{\n    int type = self.type;\n    tp_obj r;\n    if (type == TP_DICT) {\n        TP_META_BEGIN(self,\"__get__\");\n            return tp_call(tp,meta,tp_params_v(tp,1,k));\n        TP_META_END;\n        if (self.dict.dtype && _tp_lookup(tp,self,k,&r)) { return r; }\n        return _tp_dict_get(tp,self.dict.val,k,\"tp_get\");\n    } else if (type == TP_LIST) {\n        if (k.type == TP_NUMBER) {\n            int l = tp_len(tp,self).number.val;\n            int n = k.number.val;\n            n = (n<0?l+n:n);\n            return _tp_list_get(tp,self.list.val,n,\"tp_get\");\n        } else if (k.type == TP_STRING) {\n            if (tp_cmp(tp,tp_string(\"append\"),k) == 0) {\n                return tp_method(tp,self,tp_append);\n            } else if (tp_cmp(tp,tp_string(\"pop\"),k) == 0) {\n                return tp_method(tp,self,tp_pop);\n            } else if (tp_cmp(tp,tp_string(\"index\"),k) == 0) {\n                return tp_method(tp,self,tp_index);\n            } else if (tp_cmp(tp,tp_string(\"sort\"),k) == 0) {\n                return tp_method(tp,self,tp_sort);\n            } else if (tp_cmp(tp,tp_string(\"extend\"),k) == 0) {\n                return tp_method(tp,self,tp_extend);\n            } else if (tp_cmp(tp,tp_string(\"*\"),k) == 0) {\n                tp_params_v(tp,1,self);\n                r = tp_copy(tp);\n                self.list.val->len=0;\n                return r;\n            }\n        } else if (k.type == TP_NONE) {\n            return _tp_list_pop(tp,self.list.val,0,\"tp_get\");\n        }\n    } else if (type == TP_STRING) {\n        if (k.type == TP_NUMBER) {\n            int l = self.string.len;\n            int n = k.number.val;\n            n = (n<0?l+n:n);\n            if (n >= 0 && n < l) {\n                char tmp = (unsigned char)self.string.val[n];\n                /* return tp_string_n(tp->chars[(unsigned char)self.string.val[n]],1); */\n                return tp_string_copy(tp, &tmp, 1);\n            }\n        } else if (k.type == TP_STRING) {\n            if (tp_cmp(tp,tp_string(\"join\"),k) == 0) {\n                return tp_method(tp,self,tp_join);\n            } else if (tp_cmp(tp,tp_string(\"split\"),k) == 0) {\n                return tp_method(tp,self,tp_split);\n            } else if (tp_cmp(tp,tp_string(\"index\"),k) == 0) {\n                return tp_method(tp,self,tp_str_index);\n            } else if (tp_cmp(tp,tp_string(\"strip\"),k) == 0) {\n                return tp_method(tp,self,tp_strip);\n            } else if (tp_cmp(tp,tp_string(\"replace\"),k) == 0) {\n                return tp_method(tp,self,tp_replace);\n            }\n        }\n    }\n\n    if (k.type == TP_LIST) {\n        int a,b,l;\n        tp_obj tmp;\n        l = tp_len(tp,self).number.val;\n        tmp = tp_get(tp,k,tp_number(0));\n        if (tmp.type == TP_NUMBER) { a = tmp.number.val; }\n        else if(tmp.type == TP_NONE) { a = 0; }\n        else { tp_raise(tp_None,tp_string(\"(tp_get) TypeError: indices must be numbers\")); }\n        tmp = tp_get(tp,k,tp_number(1));\n        if (tmp.type == TP_NUMBER) { b = tmp.number.val; }\n        else if(tmp.type == TP_NONE) { b = l; }\n        else { tp_raise(tp_None,tp_string(\"(tp_get) TypeError: indices must be numbers\")); }\n        a = _tp_max(0,(a<0?l+a:a)); b = _tp_min(l,(b<0?l+b:b));\n        if (type == TP_LIST) {\n            return tp_list_n(tp,b-a,&self.list.val->items[a]);\n        } else if (type == TP_STRING) {\n            return tp_string_sub(tp,self,a,b);\n        }\n    }\n\n    tp_raise(tp_None,tp_string(\"(tp_get) TypeError: ?\"));\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* INCLUDE */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n    tp_vm *tp = tp_init(argc,argv);\n    /* INIT */\n    tp_ez_call(tp,\"py2bc\",\"tinypy\",tp_None);\n    tp_deinit(tp);\n    return(0);\n}", "path": "tinypy\\tpmain.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_builtins_bool\n * Coerces any value to a boolean.\n */\n", "func_signal": "tp_obj tp_builtins_bool(TP)", "code": "{\n    tp_obj v = TP_OBJ();\n    return (tp_number(tp_bool(tp, v)));\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_del\n * Remove a dictionary entry.\n *\n * Removes the key k from self. Also works on classes and objects.\n *\n * Note that unlike with Python, you cannot use this to remove list items.\n */\n", "func_signal": "void tp_del(TP,tp_obj self, tp_obj k)", "code": "{\n    int type = self.type;\n    if (type == TP_DICT) {\n        _tp_dict_del(tp,self.dict.val,k,\"tp_del\");\n        return;\n    }\n    tp_raise(,tp_string(\"(tp_del) TypeError: object does not support item deletion\"));\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* display module */\n", "func_signal": "tp_obj pygame_display_set_mode(TP)", "code": "{\n    tp_obj sz = TP_TYPE(TP_LIST);\n    int w = tp_get(tp,sz,tp_number(0)).number.val;\n    int h = tp_get(tp,sz,tp_number(1)).number.val;\n    SDL_Surface *s = SDL_SetVideoMode(w, h, 0, 0);\n    return pygame_surf_to_obj(tp,s);\n}", "path": "modules\\pygame\\init.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_bool\n * Check the truth value of an object\n *\n * Returns false if v is a numeric object with a value of exactly 0, v is of\n * type None or v is a string list or dictionary with a length of 0. Else true\n * is returned.\n */\n", "func_signal": "int tp_bool(TP,tp_obj v)", "code": "{\n    switch(v.type) {\n        case TP_NUMBER: return v.number.val != 0;\n        case TP_NONE: return 0;\n        case TP_STRING: return v.string.len != 0;\n        case TP_LIST: return v.list.val->len != 0;\n        case TP_DICT: return v.dict.val->len != 0;\n    }\n    return 1;\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_getraw\n * Retrieve the raw dict of a dict.\n *\n * This builtin retrieves one dict parameter from tinypy, and returns its raw\n * dict. This is very useful when implementing your own __get__ and __set__\n * functions, as it allows you to directly access the attributes stored in the\n * dict.\n */\n", "func_signal": "tp_obj tp_getraw(TP)", "code": "{\n    tp_obj self = TP_TYPE(TP_DICT);\n    self.dict.dtype = 0;\n    return self;\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_setmeta\n * Set a \"dict's meta\".\n *\n * This is a builtin function, so you need to use <tp_params> to provide the\n * parameters.\n *\n * In tinypy, each dictionary can have a so-called \"meta\" dictionary attached\n * to it. When dictionary attributes are accessed, but not present in the\n * dictionary, they instead are looked up in the meta dictionary. To get the\n * raw dictionary, you can use <tp_getraw>.\n *\n * This function is particulary useful for objects and classes, which are just\n * special dictionaries created with <tp_object> and <tp_class>. There you can\n * use tp_setmeta to change the class of the object or parent class of a class.\n *\n * Parameters:\n * self - The dictionary for which to set a meta.\n * meta - The meta dictionary.\n *\n * Returns:\n * None\n */\n", "func_signal": "tp_obj tp_setmeta(TP)", "code": "{\n    tp_obj self = TP_TYPE(TP_DICT);\n    tp_obj meta = TP_TYPE(TP_DICT);\n    self.dict.val->meta = meta;\n    return tp_None;\n}", "path": "tinypy\\builtins.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "/* Function: tp_set\n * Attribute modification.\n * \n * This is the counterpart of tp_get, it does the same as self[k] = v would do\n * in actual tinypy code.\n */\n", "func_signal": "void tp_set(TP,tp_obj self, tp_obj k, tp_obj v)", "code": "{\n    int type = self.type;\n\n    if (type == TP_DICT) {\n        TP_META_BEGIN(self,\"__set__\");\n            tp_call(tp,meta,tp_params_v(tp,2,k,v));\n            return;\n        TP_META_END;\n        _tp_dict_set(tp,self.dict.val,k,v);\n        return;\n    } else if (type == TP_LIST) {\n        if (k.type == TP_NUMBER) {\n            _tp_list_set(tp,self.list.val,k.number.val,v,\"tp_set\");\n            return;\n        } else if (k.type == TP_NONE) {\n            _tp_list_append(tp,self.list.val,v);\n            return;\n        } else if (k.type == TP_STRING) {\n            if (tp_cmp(tp,tp_string(\"*\"),k) == 0) {\n                tp_params_v(tp,2,self,v); tp_extend(tp);\n                return;\n            }\n        }\n    }\n    tp_raise(,tp_string(\"(tp_set) TypeError: object does not support item assignment\"));\n}", "path": "tinypy\\ops.c", "repo_name": "dkasak/tinypy-panda", "stars": 15, "license": "other", "language": "c", "size": 997}
{"docstring": "// write a cpu register\n", "func_signal": "int dbg_cpu1_write(uint32_t adr, uint32_t data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n  if ((err = adbg_select_module(DC_CPU0)))\n    {\n      cable_flush();\n      pthread_mutex_unlock(&dbg_access_mutex);\n      return err;\n    }\n  err = adbg_wb_burst_write((void *)&data, 4, 1, adr);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      data = ntohl(data);\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU1)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x2, adr, 4)))\n\t  err = legacy_dbg_go((unsigned char*)&data, 4, 0);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* read a register from cpu0.  This is assumed to be an OR32 CPU, with 32-bit regs. */\n", "func_signal": "int dbg_cpu0_read(uint32_t adr, uint32_t *data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU0)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_read(4, 1, adr, (void *) data); // All CPU register reads / writes are bursts\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU0)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x6, adr, 4)))\n\t  if (APP_ERR_NONE == (err = legacy_dbg_go((unsigned char*)data, 4, 1)))\n\t    *data = ntohl(*data);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  debug(\"dbg_cpu_read(), addr 0x%X, data[0] = 0x%X\\n\", adr, data[0]);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* read a register from cpu module of the debug unit. \n * Currently, there is only 1 register, so we do not need to select it, adr is ignored\n */\n", "func_signal": "int dbg_cpu0_read_ctrl(uint32_t adr, uint8_t *data)", "code": "{\n  int err = APP_ERR_NONE;\n  uint32_t dataword;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  // reset is bit 1, stall is bit 0 in *data\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU0))) {\n\tprintf(\"Failed to set chain to 0x%X\\n\", DC_CPU0);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n      if ((err = adbg_ctrl_read(DBG_CPU0_REG_STATUS, &dataword, 2))) {\n\tprintf(\"Failed to read chain 0x%X control reg 0x%X\\n\", DC_CPU0, DBG_CPU0_REG_STATUS);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n      *data = dataword;\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int r, s;\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU0)))\n\terr = legacy_dbg_ctrl_read(&r, &s);\n      *data = (r << 1) | s;\n      debug(\"api cpu0 read ctrl: r = %i, s = %i, data = %i\\n\", r, s, *data);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// In-place string capitalizer\n", "func_signal": "char * strtoupper(char *str)", "code": "{\n  int i = 0;\n\n  while(str[i] != '\\0') { \n    str[i] = toupper(str[i]);\n    i++;\n  }\n\n  return str;\n}", "path": "Software\\adv_jtag_bridge\\bsdl_parse.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* write a cpu register to cpu0.  This is assumed to be an OR32 CPU, with 32-bit regs. */\n", "func_signal": "int dbg_cpu0_write(uint32_t adr, uint32_t data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU0))) \n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)&data, 4, 1, adr);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      data = ntohl(data);\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU0)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x2, adr, 4)))\n\t  err = legacy_dbg_go((unsigned char*)&data, 4, 0);  \n    }\n  debug(\"cpu0_write, adr 0x%X, data 0x%X, ret %i\\n\", adr, data, err);\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// read a debug unit cpu module register\n", "func_signal": "int dbg_cpu1_read_ctrl(uint32_t adr, uint8_t *data)", "code": "{\n  int err;\n  uint32_t dataword;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  // reset is bit 1, stall is bit 0 in *data\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU1))) {\n\tprintf(\"Failed to set chain to 0x%X\\n\", DC_CPU1);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n      if ((err = adbg_ctrl_read(DBG_CPU1_REG_STATUS, &dataword, 2))) {\n\tprintf(\"Failed to read chain 0x%X control reg 0x%X\\n\", DC_CPU0, DBG_CPU1_REG_STATUS);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n     *data = dataword;\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int r, s;\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU1)))\n\terr = legacy_dbg_ctrl_read(&r, &s);\n      *data = (r << 1) | s; \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a block to wishbone\n", "func_signal": "int dbg_wb_write_block8(uint32_t adr, uint8_t *data, int len)", "code": "{\n  int err;\n\n  if(!len)\n    return APP_ERR_NONE;  // GDB may issue a 0-length transaction to test if a feature is supported\n\n  pthread_mutex_lock(&dbg_access_mutex);\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)data, 1, len, adr);  // 'len' is in words...\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x0, adr, len)))\n\t  err = legacy_dbg_go((unsigned char*)data, len, 0); \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// Never actually called from the GDB interface\n", "func_signal": "int dbg_wb_read_block16(uint32_t adr, uint16_t *data, int len)", "code": "{\n  int err;\n\n  if(!len)\n    return APP_ERR_NONE;  // GDB may issue a 0-length transaction to test if a feature is supported\n\n  pthread_mutex_lock(&dbg_access_mutex);\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_read(2, len, adr, (void *)data);  // 'len' is 16-bit halfwords\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int i;\n      int bytelen = len<<1;\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x5, adr, bytelen)))\n\t  if (APP_ERR_NONE == (err = legacy_dbg_go((unsigned char*)data, bytelen, 1)))  // 'len' is halfwords, call wants bytes\n\t    for (i = 0; i < len; i ++) data[i] = ntohs(data[i]); \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a debug unit cpu module register\n", "func_signal": "int dbg_cpu1_write_ctrl(uint32_t adr, uint8_t data)", "code": "{\n   int err;\n  uint32_t dataword = data;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU1))) {\n\tprintf(\"Failed to set chain to 0x%X\\n\", DC_CPU1);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n      if((err = adbg_ctrl_write(DBG_CPU1_REG_STATUS, &dataword, 2))) {\n\tprintf(\"Failed to write chain to 0x%X control reg 0x%X\\n\", DC_CPU1,DBG_CPU0_REG_STATUS );  // Only 2 bits: Reset, Stall\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU1)))\n\terr = legacy_dbg_ctrl(data & 2, data & 1);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* write a word to wishbone */\n", "func_signal": "int dbg_wb_write32(uint32_t adr, uint32_t data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)&data, 4, 1, adr);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      data = ntohl(data);\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x2, adr, 4)))\n\t  err = legacy_dbg_go((unsigned char*)&data, 4, 0);  \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// Searches a string 'str' for the first occurance of any \n// character in the string 'chars'.  Returns a pointer to\n// the char in 'str' if one is found, returns NULL if\n// none of the chars in 'chars' are present in 'str'.\n", "func_signal": "char * strchr_s(char *str, char *chars)", "code": "{\n  int slen = strlen(chars);\n  char *ptr = str;\n  int i;\n\n  while(*ptr != '\\0') {\n    for(i = 0; i < slen; i++) {\n      if(*ptr == chars[i]) \n\treturn ptr;\n    }\n    ptr++;\n  }\n\n  return NULL;\n}", "path": "Software\\adv_jtag_bridge\\bsdl_parse.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// Never actually called from the GDB interface\n", "func_signal": "int dbg_wb_read_block8(uint32_t adr, uint8_t *data, int len)", "code": "{\n  int err;\n\n  if(!len)\n    return APP_ERR_NONE;  // GDB may issue a 0-length transaction to test if a feature is supported\n\n  pthread_mutex_lock(&dbg_access_mutex);\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_read(1, len, adr, (void *)data);  // *** is 'len' bits or words?? Call wants words...\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x4, adr, len)))\n\t  err = legacy_dbg_go((unsigned char*)data, len, 1);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a block to wishbone \n", "func_signal": "int dbg_wb_write_block32(uint32_t adr, uint32_t *data, int len)", "code": "{\n  int err;\n\n  if(!len)\n    return APP_ERR_NONE;  // GDB may issue a 0-length transaction to test if a feature is supported\n\n  pthread_mutex_lock(&dbg_access_mutex);\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)data, 4, len, adr);  // 'len' is words.\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int i;\n      int bytelen = len << 2;\n      for (i = 0; i < len; i ++) data[i] = ntohl(data[i]);\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x2, adr, bytelen)))\n\t  err = legacy_dbg_go((unsigned char*)data, bytelen, 0);  // 'len' is words, call wants bytes \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* write multiple cpu registers to cpu0.  This is assumed to be an OR32 CPU, with 32-bit regs. */\n", "func_signal": "int dbg_cpu0_write_block(uint32_t adr, uint32_t *data, int count)", "code": "{\n  int err;\n  \n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      pthread_mutex_lock(&dbg_access_mutex);\n      if ((err = adbg_select_module(DC_CPU0)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)data, 4, count, adr);\n      cable_flush();\n      pthread_mutex_unlock(&dbg_access_mutex);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int i;\n      unsigned long writeaddr = adr;\n      err = APP_ERR_NONE;\n      for(i = 0; i < count; i++) {\n\terr |= dbg_cpu0_write(writeaddr++, data[i]);\n      }\n    }\n  debug(\"cpu0_write_block, adr 0x%X, data[0] 0x%X, count %i, ret %i\\n\", adr, data[0], count, err);\n \n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* write a debug unit cpu module register \n * Since OR32 debug module has only 1 register,\n * adr is ignored (for now) */\n", "func_signal": "int dbg_cpu0_write_ctrl(uint32_t adr, uint8_t data)", "code": "{\n  int err = APP_ERR_NONE;\n  uint32_t dataword = data;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_CPU0))) {\n\tprintf(\"Failed to set chain to 0x%X\\n\", DC_CPU0);\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n      if((err = adbg_ctrl_write(DBG_CPU0_REG_STATUS, &dataword, 2))) {\n\tprintf(\"Failed to write chain to 0x%X control reg 0x%X\\n\", DC_CPU0,DBG_CPU0_REG_STATUS );  // Only 2 bits: Reset, Stall\n\tcable_flush();\n\tpthread_mutex_unlock(&dbg_access_mutex);\n\treturn err;\n      }\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_CPU0)))\n\terr = legacy_dbg_ctrl(data & 2, data &1);\n    }\n  debug(\"cpu0_write_ctrl(): set reg to 0x%X\\n\", data);\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a word to wishbone\n// Never actually called from the GDB interface\n", "func_signal": "int dbg_wb_write8(uint32_t adr, uint8_t data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)&data, 1, 1, adr);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n        if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\t  if (APP_ERR_NONE == (err = legacy_dbg_command(0x0, adr, 1)))\n\t    err = legacy_dbg_go((unsigned char*)&data, 1, 0);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// API call: extract desired info from 1 BSDL fise\n", "func_signal": "bsdlinfo *parse_extract_values(char *bsdlfilename)", "code": "{\n  FILE *fd;\n  int filesize;\n  bsdlinfo *ret;\n  char *filedata;\n  char *linedata;\n  char *token;\n  char *last;\n  char *cmdbuf;\n  int filepos = 0;\n  int i,j;\n  char done,valid,opens;\n\n  int IR_size = -1;\n  uint8_t found_IR_size = 0;\n  uint32_t debug_cmd = TAP_CMD_INVALID;\n  uint32_t user1_cmd = TAP_CMD_INVALID;\n  uint32_t idcode_cmd = TAP_CMD_INVALID;\n  uint8_t found_cmds = 0;\n  uint32_t idcode = 0;\n  uint32_t idcode_mask = 0xFFFFFFFF;  // 'X' is a valid char in an IDCODE, set 0's here for X's.\n  uint8_t found_idcode = 0;\n  char *entityname = NULL;\n  \n  // Open the file\n  fd = fopen(bsdlfilename, \"r\");\n  if(fd == NULL) {\n    printf(\"ERROR:  failed to open BSDL file %s\\n\", bsdlfilename);\n    return NULL;\n  }\n\n  fseek(fd, 0, SEEK_END);\n  filesize = ftell(fd);\n  fseek(fd, 0, SEEK_SET);\n\n  filedata = (char *) malloc(filesize);\n  if(filedata == NULL) {\n    printf(\"ERROR: failed to allocate memory for BSDL file %s\\n\", bsdlfilename);\n    return NULL;\n  }\n\n  if(fread(filedata, 1, filesize, fd) < filesize) {  // 1 long read will be faster than many short ones\n    printf(\"Warning: failed to read entire BSDL file %s\\n\", bsdlfilename);\n  }\n\n  fclose(fd);\n\n\n  // while there's more data and not all values have been found\n  while((filepos < filesize) && (!found_IR_size || !found_cmds || !found_idcode))\n    {\n      // Get a line.  Replace any \"--\" with a \\0 char\n      filepos = get_line(filedata, filepos, &linedata, filesize);\n\n      // look for each value\n      token = strtok_r(linedata, \" \\t\", &last);\n      if(token == NULL) {\n\tprintf(\"ERROR: End of file reached before END statement is BSDL file \\'%s\\'\\n\", bsdlfilename);\n\tbreak;\n      }\n\n      if(!strcmp(strtoupper(token), \"ENTITY\")) {\n\t// Parse an entity line\n\ttoken = strtok_r(NULL, \" \\t\", &last);\n\tif(token != NULL) {\n\t  entityname = strdup(token);\n\t  if(entityname != NULL) \n\t    {\n\t      debug(\"Found entity \\'%s\\'\\n\", entityname);\n\t    }\n\t} else {\n\t  printf(\"Parse error near ENTITY token in file %s\\n\", bsdlfilename);\n\t}\n      }\n      else if(!strcmp(strtoupper(token), \"CONSTANT\")) {\n\t// Parse a constant declaration...we ignore them, just get lines until we find a ';' char\n\t// assume nothing else useful comes on the line after the ';'\n\t// Slightly awkward, since we have to search the rest of the line after the strtok, then possible\n\t// new lines as well.\n\ttoken = strtok_r(NULL, \" \\t\", &last);  // debug...don't worry about error, token only used in printf\n\tdebug(\"Ignoring constant \\'%s\\'\\n\", token);  // debug\n\twhile(strchr(last, ';') == NULL) { \n\t  filepos = get_line(filedata, filepos, &last, filesize); \n\t}\n      }\n      else if(!strcmp(strtoupper(token), \"GENERIC\")) {\n\t// Parse a generic declaration...we ignore them, just get lines until we find a ';' char\n\t// assume nothing else useful comes on the line after the ';'\n\t// Slightly awkward, since we have to search the rest of the line after the strtok, then possible\n\t// new lines as well.\n\ttoken = strtok_r(NULL, \" \\t\", &last);  // debug...don't worry about error, token only used in printf\n\tdebug(\"Ignoring generic \\'%s\\'\\n\", token);  // debug\n\twhile(strchr(last, ';') == NULL) { \n\t  filepos = get_line(filedata, filepos, &last, filesize); \n\t}\n      }\n      else if(!strcmp(strtoupper(token), \"USE\")) {\n\t// Parse a 'use' declaration...we ignore them, just get lines until we find a ';' char\n\t// assume nothing else useful comes on the line after the ';'\n\t// Note that there may be no space after the token, so add ';' to the tokenizing list in the debug bits.\n\t// Slightly awkward, since we have to search the rest of the line after the strtok, then possible\n\t// new lines as well.\n\ttoken = strtok_r(NULL, \" \\t;\", &last);  // debug ...don't worry about error, token only used in printf\n\tdebug(\"Ignoring use \\'%s\\'\\n\", token);  // debug\n\twhile(strchr(last, ';') == NULL) { \n\t  filepos = get_line(filedata, filepos, &last, filesize); \n\t}\n      }\n      else if(!strcmp(strtoupper(token), \"END\")) {\n\t// We're done, whether we've found what we want or not.  Eject eject eject...\n\tdebug(\"Found END token, stopping parser\\n\");\n\tbreak;\n      }\n      else if(!strcmp(strtoupper(token), \"PORT\")) {\n\t// Parse a port list.  Find a '(', find a ')', find a ';'.\n\t// Note that \"()\" pairs may occur in between.\n\t// 'last' must be set in the first two strchr() calls so that the next strchr() call will\n\t// begin parsing after the previous char position.  Otherwise, e.g. a ';' before the ')' but on the same\n\t// line would (incorrectly) satisfy the search.\n\twhile((last = strchr(last, '(')) == NULL) { \n\t  filepos = get_line(filedata, filepos, &last, filesize); \n\t}\n\topens = 1;\n\tlast++;  // don't leave 'last' pointing at the '(' char, since we're looking for another\n\n\tdo {\n\t  while((last = strchr_s(last, \"()\")) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** abort if new line is empty\n\t  }\n\t  if(*last == '(') opens++;\n\t  else if(*last == ')') opens--;\n\t  last++;  // don't leave last pointing at the same \"()\" char, since we're looking for another\n\t} while(opens);\n\n\n\twhile(strchr(last, ';') == NULL) { \n\t  filepos = get_line(filedata, filepos, &last, filesize); \n\t}\n\tdebug(\"Ignored port statement\\n\");\n      }\n      else if(!strcmp(strtoupper(token), \"ATTRIBUTE\")) {\n\t// Parse an attribute\n\ttoken = strtok_r(NULL, \" \\t\", &last);  // *** check for error\n\tif(!strcmp(strtoupper(token), \"INSTRUCTION_LENGTH\")) {\n\t  // Find ':', then \"entity\", then \"is\", then take anything before the ';' as the value\n\t  while((last = strchr(last, ':')) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"entity\")) == NULL) { // don't do strtoupper() here, that would do the entire line\n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"is\")) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\n\t  // scan until the end of the line looking for data\n\t  j = 0;\n\t  done = 0;\n\t  while(*last != '\\0') {\n\t    if(isdigit(*last)) tmpbuf[j++] = *last;\n\t    else if(*last == ';') { done = 1; break;}\n\t    last++;\n\t  }\n\t  // May need to go to additional lines\n\t  while(!done) {\n\t    filepos = get_line(filedata, filepos, &linedata, filesize);  // *** break if linedata has no data\n\t    while(*linedata != '\\0') {\n\t      if(isdigit(*linedata)) tmpbuf[j++] = *linedata;\n\t      else if(*linedata == ';') { done = 1; break;}\n\t      linedata++;\n\t    }\n\t  }\n\n\t  tmpbuf[j] = '\\0';\n\t  IR_size = strtoul(tmpbuf, NULL, 0);\n\t  found_IR_size = 1;\n\t  debug(\"Found IR size %i (%s)\\n\", IR_size, tmpbuf);\n\t}  // end if INSTRUCTION_LENGTH\n\n\telse if(!strcmp(strtoupper(token), \"INSTRUCTION_OPCODE\")) {\n\t  // Find \": entity is\"\n\t  while((last = strchr(last, ':')) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"entity\")) == NULL) { // don't do strtoupper() here, that would do the entire line\n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"is\")) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\n\t  // We're going to copy the entire attribute (all commands) into a temp. buffer.  We need a big enough buffer,\n\t  // and we can't just scan for ';' to find out because there's a '\\0' at the end of this line.\n\t  // But, it can't be bigger than the entire rest of the file, so...\n\t  cmdbuf = (char *) malloc(filesize-filepos);\n\t  debug(\"Malloc'd %i bytes for INSTRUCTION_OPCODE\\n\", filesize-filepos);\n\n\t  // Parse until ';', and grab everything between each pair of \"\" found\n\t  // Note that 'last' still points at \"is\"\n\t  j = 0;\n\t  done = 0;\n\t  valid = 0;\n\t  while(*last != '\\0') {\n\t    if(*last == ';') { done = 1; break;}  // Put this first in case of badly formed BSDL files\n\t    else if(valid && (*last != '\\\"')) cmdbuf[j++] = *last;\n\t    else if(*last == '\\\"') valid = !valid;\n\t    last++;\n\t  }\n\t  // May need to go to additional lines\n\t  while(!done) {\n\t    filepos = get_line(filedata, filepos, &linedata, filesize); // *** break if linedata has no data\n\t    while(*linedata != '\\0') {\n\t      if(valid && (*linedata != '\\\"')) cmdbuf[j++] = *linedata;\n\t      else if(*linedata == '\\\"') valid = !valid;\n\t      else if(*linedata == ';') { done = 1; break;}\n\t      linedata++;\n\t    }\n\t  }\n\t  cmdbuf[j] = '\\0';\n\t  debug(\"Finished copying INSTRUCTION_OPCODE, copied %i bytes\", j+1);\n\n\t  // Parse the opcodes attribute.  This is an exercise unto itself, so do it in another function.\n\t  parse_opcodes(cmdbuf, &debug_cmd, &user1_cmd, &idcode_cmd);\n\t  found_cmds = 1;\n\t  free(cmdbuf);\n\n\t}   // end if INSTRUCTION_OPCODE\n\n\telse if(!strcmp(strtoupper(token), \"IDCODE_REGISTER\")) {\n\t  // Find : entity is\n\t  while((last = strchr(last, ':')) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"entity\")) == NULL) { // don't do strtoupper() here, that would do the entire line\n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\t  while((last = strstr(last, \"is\")) == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); // *** check last actually has data?\n\t  }\n\n\t  // Parse until ';', and grab everything between each pair of \"\" found\n\t  // Note that 'last' still points at \"is\"\n\t  j = 0;\n\t  done = 0;\n\t  valid = 0;\n\t  while(*last != '\\0') {\n\t    if(*last == ';') { done = 1; break;}  // Put this first in case of badly formed BSDL files\n\t    else if(valid && (*last != '\\\"')) tmpbuf[j++] = *last;\n\t    else if(*last == '\\\"') valid = !valid;\n\t    last++;\n\t  }\n\t  // May need to go to additional lines\n\t  while(!done) {\n\t    filepos = get_line(filedata, filepos, &linedata, filesize); // *** break if linedata has no data\n\t    while(*linedata != '\\0') {\n\t      if(valid && (*linedata != '\\\"')) tmpbuf[j++] = *linedata;\n\t      else if(*linedata == '\\\"') valid = !valid;\n\t      else if(*linedata == ';') { done = 1; break;}\n\t      linedata++;\n\t    }\n\t  }\n\t  tmpbuf[j] = '\\0';\n\n\t  // Parse the tmpbuf\n\t  if(j != 32) printf(\"Warning:  found %i chars (expected 32) while getting IDCODE in BSDL file %s.\\n\", j, bsdlfilename);  // Sanity check\n\t  debug(\"Got IDCODE string \\'%s\\'\\n\", tmpbuf);\n\t  for(i = 0; i < j; i++) {\n\t    if(tmpbuf[i] == '1') idcode |= 0x1<<(31-i);\n\t    else if(toupper(tmpbuf[i]) == 'X') idcode_mask &= ~(0x1<<(31-i)); \n\t  }\n\t  debug(\"Found IDCODE 0x%08X (%s), mask is 0x%08X\\n\", idcode, tmpbuf, idcode_mask);\n\t  found_idcode = 1;\n\n\t}  // end if IDCODE_REGISTER\n\n\telse {\n\t  debug(\"Ignoring attribute \\'%s\\'\\n\", token);\n\t  // Consume chars until ';' found\n\t  while(strchr(last, ';') == NULL) { \n\t    filepos = get_line(filedata, filepos, &last, filesize); \n\t  }\n\t}\n      }\n      else {\n\tdebug(\"Unknown token \\'%s\\' found in BSDL file %s\\n\", token, bsdlfilename);\n      }\n    }\n\n  free(filedata);\n\n  // Put the data in a struct for return and storage\n  ret = (bsdlinfo *) malloc(sizeof(bsdlinfo));\n  if(ret == NULL) {\n       printf(\"Error: out of memory, unable to store BSDL info for file %s\\n\", bsdlfilename);\n       return NULL;\n  }\n\n  ret->name = entityname;  // this was malloc'd, so it's persistant, this is safe\n  ret->idcode = idcode;\n  ret->idcode_mask = idcode_mask;\n  ret->IR_size = IR_size;\n  ret->cmd_debug = debug_cmd;\n  ret->cmd_user1 = user1_cmd;\n  ret->cmd_idcode = idcode_cmd;\n  ret->next = NULL;\n\n  return ret;\n}", "path": "Software\\adv_jtag_bridge\\bsdl_parse.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a word to wishbone\n// Never actually called from the GDB interface\n", "func_signal": "int dbg_wb_write16(uint32_t adr, uint16_t data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}  \n      err = adbg_wb_burst_write((void *)&data, 2, 1, adr);\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n        data = ntohs(data);\n\tif (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\t  if (APP_ERR_NONE == (err = legacy_dbg_command(0x1, adr, 2)))\n\t    err = legacy_dbg_go((unsigned char*)&data, 2, 0);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* read a word from wishbone */\n", "func_signal": "int dbg_wb_read32(uint32_t adr, uint32_t *data)", "code": "{\n  int err;\n  pthread_mutex_lock(&dbg_access_mutex);\n\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_read(4, 1, adr, (void *)data); // All WB reads / writes are bursts\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x6, adr, 4)))\n\t  err = legacy_dbg_go((unsigned char*)data, 4, 1);\n      *data = ntohl(*data);\n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "// write a block to wishbone\n// Never actually called from the GDB interface\n", "func_signal": "int dbg_wb_write_block16(uint32_t adr, uint16_t *data, int len)", "code": "{\n  int err;\n\n  if(!len)\n    return APP_ERR_NONE;  // GDB may issue a 0-length transaction to test if a feature is supported\n\n  pthread_mutex_lock(&dbg_access_mutex);\n  if(DEBUG_HARDWARE == DBG_HW_ADVANCED)\n    {\n      if ((err = adbg_select_module(DC_WISHBONE)))\n\t{\n\t  cable_flush();\n\t  pthread_mutex_unlock(&dbg_access_mutex);\n\t  return err;\n\t}\n      err = adbg_wb_burst_write((void *)data, 2, len, adr);  // 'len' is (half)words\n    }\n  else if(DEBUG_HARDWARE == DBG_HW_LEGACY)\n    {\n      int i;\n      int bytelen = len<<1;\n      for (i = 0; i < len; i ++) data[i] = ntohs(data[i]);\n      if (APP_ERR_NONE == (err = legacy_dbg_set_chain(DC_WISHBONE)))\n\tif (APP_ERR_NONE == (err = legacy_dbg_command(0x1, adr, bytelen)))\n\t  err = legacy_dbg_go((unsigned char*)data, bytelen, 0);  // 'len' is 16-bit halfwords, call wants bytes  \n    }\n  cable_flush();\n  pthread_mutex_unlock(&dbg_access_mutex);\n  return err;\n}", "path": "Software\\adv_jtag_bridge\\dbg_api.c", "repo_name": "lgeek/adv_debug_sys", "stars": 10, "license": "None", "language": "c", "size": 4281}
{"docstring": "/* SYNTAX: LASTLOG [-] [-file <filename>] [-window <ref#|name>] [-new | -away]\n\t\t   [-<level> -<level...>] [-clear] [-count] [-case]\n\t\t   [-regexp | -word] [-before [<#>]] [-after [<#>]]\n\t\t   [-<# before+after>] [<pattern>] [<count> [<start>]] */\n", "func_signal": "static void cmd_lastlog(const char *data)", "code": "{\n\tGHashTable *optlist;\n\tchar *text, *countstr, *start, *fname;\n\tvoid *free_arg;\n        int count, fd;\n\tFILE *fhandle;\n\n\tg_return_if_fail(data != NULL);\n\n\tif (!cmd_get_params(data, &free_arg, 3 | PARAM_FLAG_OPTIONS |\n\t\t\t    PARAM_FLAG_UNKNOWN_OPTIONS, \"lastlog\", &optlist,\n\t\t\t    &text, &countstr, &start))\n\t\treturn;\n\n\tif (*start == '\\0' && is_numeric(text, 0) && *text != '0' &&\n\t    (*countstr == '\\0' || is_numeric(countstr, 0))) {\n\t\tstart = countstr;\n\t\tcountstr = text;\n\t\ttext = \"\";\n\t}\n\tcount = atoi(countstr);\n\tif (count == 0) count = -1;\n\n\t/* target where to print it */\n        fhandle = NULL;\n\tfname = g_hash_table_lookup(optlist, \"file\");\n\tif (fname != NULL) {\n                fname = convert_home(fname);\n\t\tfd = open(fname, O_WRONLY | O_APPEND | O_CREAT,\n\t\t\t  octal2dec(settings_get_int(\"log_create_mode\")));\n\t\tif (fd != -1) {\n\t\t\tfhandle = fdopen(fd, \"a\");\n\t\t\tif (fhandle == NULL)\n\t\t\t\tclose(fd);\n\t\t}\n                g_free(fname);\n\t}\n\n\tif (fname != NULL && fhandle == NULL) {\n\t\tprinttext(NULL, NULL, MSGLEVEL_CLIENTERROR,\n\t\t\t  \"Could not open lastlog: %s\", g_strerror(errno));\n\t} else {\n\t\tshow_lastlog(text, optlist, atoi(start), count, fhandle);\n\t\tif (fhandle != NULL) {\n\t\t\tif (ferror(fhandle))\n\t\t\t\tprinttext(NULL, NULL, MSGLEVEL_CLIENTERROR,\n\t\t\t\t  \t  \"Could not write lastlog: %s\", g_strerror(errno));\n\t\t\tfclose(fhandle);\n\t\t}\n\t}\n\n\tcmd_params_free(free_arg);\n}", "path": "src\\fe-text\\lastlog.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* parse ANSI color string */\n", "func_signal": "static const char *get_ansi_color(THEME_REC *theme, const char *str,\n\t\t\t\t  int *fg_ret, int *bg_ret, int *flags_ret)", "code": "{\n\tstatic char ansitab[8] = { 0, 4, 2, 6, 1, 5, 3, 7 };\n\tconst char *start;\n\tint fg, bg, flags, num;\n\n\tif (*str != '[')\n\t\treturn str;\n\tstart = str++;\n\n\tfg = fg_ret == NULL || *fg_ret < 0 ? theme->default_color : *fg_ret;\n\tbg = bg_ret == NULL || *bg_ret < 0 ? -1 : *bg_ret;\n\tflags = flags_ret == NULL ? 0 : *flags_ret;\n\n\tnum = 0;\n\tfor (;; str++) {\n\t\tif (*str == '\\0') return start;\n\n\t\tif (i_isdigit(*str)) {\n\t\t\tnum = num*10 + (*str-'0');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*str != ';' && *str != 'm')\n\t\t\treturn start;\n\n\t\tswitch (num) {\n\t\tcase 0:\n\t\t\t/* reset colors back to default */\n\t\t\tfg = theme->default_color;\n\t\t\tbg = -1;\n\t\t\tflags &= ~GUI_PRINT_FLAG_INDENT;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* hilight */\n\t\t\tflags |= GUI_PRINT_FLAG_BOLD;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t/* blink */\n\t\t\tflags |= GUI_PRINT_FLAG_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t/* reverse */\n\t\t\tflags |= GUI_PRINT_FLAG_REVERSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (num >= 30 && num <= 37) {\n\t\t\t\tif (fg == -1) fg = 0;\n\t\t\t\tfg = (fg & 0xf8) | ansitab[num-30];\n\t\t\t}\n\t\t\tif (num >= 40 && num <= 47) {\n\t\t\t\tif (bg == -1) bg = 0;\n\t\t\t\tbg = (bg & 0xf8) | ansitab[num-40];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnum = 0;\n\n\t\tif (*str == 'm') {\n\t\t\tif (fg_ret != NULL) *fg_ret = fg;\n\t\t\tif (bg_ret != NULL) *bg_ret = bg;\n\t\t\tif (flags_ret != NULL) *flags_ret = flags;\n\n\t\t\tstr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn str;\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Returns 1 if ok, 0 if error in module and\n   -1 if module wasn't found */\n", "func_signal": "static int module_load_name(const char *path, const char *rootmodule,\n\t\t\t    const char *submodule, int silent)", "code": "{\n\tvoid (*module_init) (void);\n\tvoid (*module_deinit) (void);\n\tGModule *gmodule;\n        MODULE_REC *module;\n\tMODULE_FILE_REC *rec;\n\tgpointer value1, value2;\n\tchar *initfunc, *deinitfunc;\n        int found;\n\n\tgmodule = module_open(path, &found);\n\tif (gmodule == NULL) {\n\t\tif (!silent || found) {\n\t\t\tmodule_error(MODULE_ERROR_LOAD, g_module_error(),\n\t\t\t\t     rootmodule, submodule);\n\t\t}\n\t\treturn found ? 0 : -1;\n\t}\n\n\t/* get the module's init() and deinit() functions */\n\tinitfunc = module_get_func(rootmodule, submodule, \"init\");\n\tdeinitfunc = module_get_func(rootmodule, submodule, \"deinit\");\n\tfound = g_module_symbol(gmodule, initfunc, &value1) &&\n\t\tg_module_symbol(gmodule, deinitfunc, &value2);\n\tg_free(initfunc);\n\tg_free(deinitfunc);\n\n\tmodule_init = value1;\n\tmodule_deinit = value2;\n\n\tif (!found) {\n\t\tmodule_error(MODULE_ERROR_INVALID, NULL,\n\t\t\t     rootmodule, submodule);\n\t\tg_module_close(gmodule);\n\t\treturn 0;\n\t}\n\n\t/* Call the module's init() function - it should register itself\n\t   with module_register() function, abort if it doesn't. */\n\tmodule_init();\n\n\tmodule = module_find(rootmodule);\n\trec = module == NULL ? NULL :\n                strcmp(rootmodule, submodule) == 0 ?\n\t\tmodule_file_find(module, \"core\") :\n\t\tmodule_file_find(module, submodule);\n\tif (rec == NULL) {\n\t\trec = module_register_full(rootmodule, submodule, NULL);\n\t\trec->gmodule = gmodule;\n\t\tmodule_file_unload(rec);\n\n\t\tmodule_error(MODULE_ERROR_INVALID, NULL,\n\t\t\t     rootmodule, submodule);\n                return 0;\n\t}\n\n        rec->module_deinit = module_deinit;\n\trec->gmodule = gmodule;\n        rec->initialized = TRUE;\n\n\tsettings_check_module(rec->defined_module_name);\n\n\tsignal_emit(\"module loaded\", 2, rec->root, rec);\n\treturn 1;\n}", "path": "src\\core\\modules-load.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* check if `text' contains ignored nick at the start of the line. */\n", "func_signal": "static int ignore_check_replies_rec(IGNORE_REC *rec, CHANNEL_REC *channel,\n\t\t\t\t    const char *text)", "code": "{\n\tGSList *nicks, *tmp;\n\n\tnicks = nicklist_find_multiple(channel, rec->mask);\n\tif (nicks == NULL) return FALSE;\n\n\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next) {\n\t\tNICK_REC *nick = tmp->data;\n\n\t\tif (nick_match_msg(channel, text, nick->nick))\n\t\t\treturn TRUE;\n\t}\n\tg_slist_free(nicks);\n\n\treturn FALSE;\n}", "path": "src\\core\\ignore.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Returns the root module name for given submodule (eg. perl_core -> perl) */\n", "func_signal": "static char *module_get_root(const char *name, char **prefixes)", "code": "{\n\tint len;\n\n\t/* skip any of the prefixes.. */\n\tif (prefixes != NULL) {\n\t\twhile (*prefixes != NULL) {\n\t\t\tlen = strlen(*prefixes);\n\t\t\tif (strncmp(name, *prefixes, len) == 0 &&\n\t\t\t    name[len] == '_') {\n\t\t\t\tname += len+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprefixes++;\n\t\t}\n\t}\n\n\t/* skip the _core part */\n        len = strlen(name);\n\tif (len > 5 && strcmp(name+len-5, \"_core\") == 0)\n\t\treturn g_strndup(name, len-5);\n\n        return g_strdup(name);\n}", "path": "src\\core\\modules-load.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Read a line */\n", "func_signal": "gint read_line(GIOChannel *handle, GString *output, GString *buffer)", "code": "{\n    gchar tmpbuf[512];\n    gint recvlen, pos;\n\n    g_return_val_if_fail(handle != NULL, -1);\n    g_return_val_if_fail(output != NULL, -1);\n    g_return_val_if_fail(buffer != NULL, -1);\n\n    g_string_truncate(output, 0);\n\n    recvlen = net_receive(handle, tmpbuf, sizeof(tmpbuf)-1);\n\n    if (recvlen <= 0)\n    {\n        if (buffer->len > 0)\n        {\n            /* no new data got but still something in buffer.. */\n            for (pos = 0; pos < buffer->len; pos++)\n            {\n                if (buffer->str[pos] == 13 || buffer->str[pos] == 10)\n                {\n                    recvlen = 0;\n                    break;\n                }\n            }\n            if (recvlen < 0 && buffer->len > 0)\n            {\n                /* connection closed and last line is missing \\n ..\n                   just add it so we can see if it had anything useful.. */\n                recvlen = 0;\n                g_string_append_c(buffer, '\\n');\n            }\n        }\n\n        if (recvlen < 0) return -1;\n    }\n    else\n    {\n        /* append received data to buffer */\n        tmpbuf[recvlen] = '\\0';\n        g_string_append(buffer, tmpbuf);\n    }\n\n    for (pos = 0; pos < buffer->len; pos++)\n    {\n        if (buffer->str[pos] == 13 || buffer->str[pos] == 10)\n        {\n            /* end of line */\n            buffer->str[pos] = '\\0';\n            g_string_assign(output, buffer->str);\n\n            if (buffer->str[pos] == 13 && buffer->str[pos+1] == 10)\n            {\n                /* skip \\n too */\n                pos++;\n            }\n\n            g_string_erase(buffer, 0, pos+1);\n            return 1;\n        }\n    }\n\n    /* EOL wasn't found, wait for more data.. */\n    return 0;\n}", "path": "servertest\\server.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* send a fully parsed text string for GUI to print */\n", "func_signal": "void format_send_to_gui(TEXT_DEST_REC *dest, const char *text)", "code": "{\n\tTHEME_REC *theme;\n\tchar *dup, *str, *ptr, type;\n\tint fgcolor, bgcolor;\n\tint flags;\n\n\ttheme = window_get_theme(dest->window);\n\n\tdup = str = g_strdup(text);\n\n\tflags = 0; fgcolor = theme->default_color; bgcolor = -1;\n\twhile (*str != '\\0') {\n\t\ttype = '\\0';\n\t\tfor (ptr = str; *ptr != '\\0'; ptr++) {\n\t\t\tif (IS_COLOR_CODE(*ptr) || *ptr == '\\n') {\n\t\t\t\ttype = *ptr;\n\t\t\t\t*ptr++ = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (type == 7) {\n\t\t\t/* bell */\n\t\t\tif (settings_get_bool(\"bell_beeps\"))\n\t\t\t\tsignal_emit(\"beep\", 0);\n\t\t} else if (type == 4 && *ptr == FORMAT_STYLE_CLRTOEOL) {\n\t\t\t/* clear to end of line */\n\t\t\tflags |= GUI_PRINT_FLAG_CLRTOEOL;\n\t\t}\n\n\t\tif (*str != '\\0' || (flags & GUI_PRINT_FLAG_CLRTOEOL)) {\n\t\t\t/* send the text to gui handler */\n\t\t\tsignal_emit_id(signal_gui_print_text, 6, dest->window,\n\t\t\t\t       GINT_TO_POINTER(fgcolor),\n\t\t\t\t       GINT_TO_POINTER(bgcolor),\n\t\t\t\t       GINT_TO_POINTER(flags), str,\n\t\t\t\t       dest);\n\t\t\tflags &= ~(GUI_PRINT_FLAG_INDENT|GUI_PRINT_FLAG_CLRTOEOL);\n\t\t}\n\n\t\tif (type == '\\n') {\n\t\t\tformat_newline(dest->window);\n\t\t\tfgcolor = theme->default_color;\n\t\t\tbgcolor = -1;\n\t\t\tflags &= GUI_PRINT_FLAG_INDENT|GUI_PRINT_FLAG_MONOSPACE;\n\t\t}\n\n\t\tif (*ptr == '\\0')\n\t\t\tbreak;\n\n\t\tswitch (type)\n\t\t{\n\t\tcase 2:\n\t\t\t/* bold */\n\t\t\tif (!hide_text_style)\n\t\t\t\tflags ^= GUI_PRINT_FLAG_BOLD;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t/* MIRC color */\n\t\t\tget_mirc_color((const char **) &ptr,\n\t\t\t\t\thide_colors ? NULL : &fgcolor,\n\t\t\t\t\thide_colors ? NULL : &bgcolor);\n\t\t\tif (!hide_colors)\n\t\t\t\tflags |= GUI_PRINT_FLAG_MIRC_COLOR;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t/* user specific colors */\n\t\t\tflags &= ~GUI_PRINT_FLAG_MIRC_COLOR;\n\t\t\tswitch (*ptr) {\n\t\t\tcase FORMAT_STYLE_BLINK:\n\t\t\t\tflags ^= GUI_PRINT_FLAG_BLINK;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_UNDERLINE:\n\t\t\t\tflags ^= GUI_PRINT_FLAG_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_BOLD:\n\t\t\t\tflags ^= GUI_PRINT_FLAG_BOLD;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_REVERSE:\n\t\t\t\tflags ^= GUI_PRINT_FLAG_REVERSE;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_MONOSPACE:\n\t\t\t\tflags ^= GUI_PRINT_FLAG_MONOSPACE;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_INDENT:\n\t\t\t\tflags |= GUI_PRINT_FLAG_INDENT;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_DEFAULTS:\n\t\t\t\tfgcolor = theme->default_color;\n\t\t\t\tbgcolor = -1;\n\t\t\t\tflags &= GUI_PRINT_FLAG_INDENT|GUI_PRINT_FLAG_MONOSPACE;\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_STYLE_CLRTOEOL:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (*ptr != FORMAT_COLOR_NOCHANGE) {\n\t\t\t\t\tfgcolor = (unsigned char) *ptr-'0';\n\t\t\t\t}\n\t\t\t\tif (ptr[1] == '\\0')\n\t\t\t\t\tbreak;\n\n\t\t\t\tptr++;\n\t\t\t\tif (*ptr != FORMAT_COLOR_NOCHANGE) {\n\t\t\t\t\tbgcolor = *ptr-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr++;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t/* blink */\n\t\t\tif (!hide_text_style)\n\t\t\t\tflags ^= GUI_PRINT_FLAG_BLINK;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\t/* remove all styling */\n\t\t\tfgcolor = theme->default_color;\n\t\t\tbgcolor = -1;\n\t\t\tflags &= GUI_PRINT_FLAG_INDENT|GUI_PRINT_FLAG_MONOSPACE;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\t/* reverse */\n\t\t\tif (!hide_text_style)\n\t\t\t\tflags ^= GUI_PRINT_FLAG_REVERSE;\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\t/* underline */\n\t\t\tif (!hide_text_style)\n\t\t\t\tflags ^= GUI_PRINT_FLAG_UNDERLINE;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\t/* ansi color code */\n\t\t\tptr = (char *)\n\t\t\t\tget_ansi_color(theme, ptr,\n\t\t\t\t\t       hide_colors ? NULL : &fgcolor,\n\t\t\t\t\t       hide_colors ? NULL : &bgcolor,\n\t\t\t\t\t       hide_colors ? NULL : &flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = ptr;\n\t}\n\n\tg_free(dup);\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* add `linestart' to start of each line in `text'. `text' may contain\n   multiple lines separated with \\n. */\n", "func_signal": "char *format_add_linestart(const char *text, const char *linestart)", "code": "{\n\tGString *str;\n\tchar *ret;\n\n\tif (linestart == NULL)\n\t\treturn g_strdup(text);\n\n\tif (strchr(text, '\\n') == NULL)\n\t\treturn g_strconcat(linestart, text, NULL);\n\n\tstr = g_string_new(linestart);\n\twhile (*text != '\\0') {\n\t\tg_string_append_c(str, *text);\n\t\tif (*text == '\\n')\n\t\t\tg_string_append(str, linestart);\n\t\ttext++;\n\t}\n\n\tret = str->str;\n\tg_string_free(str, FALSE);\n\treturn ret;\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Fill information to connection from server setup record */\n", "func_signal": "static void sig_server_setup_fill_reconn(IRC_SERVER_CONNECT_REC *conn,\n\t\t\t\t\t IRC_SERVER_SETUP_REC *sserver)", "code": "{\n        if (!IS_IRC_SERVER_CONNECT(conn) ||\n\t    !IS_IRC_SERVER_SETUP(sserver))\n\t\treturn;\n\n\tif (sserver->cmd_queue_speed > 0)\n\t\tconn->cmd_queue_speed = sserver->cmd_queue_speed;\n\tif (sserver->max_cmds_at_once > 0)\n\t\tconn->max_cmds_at_once = sserver->max_cmds_at_once;\n\tif (sserver->max_query_chans > 0)\n\t\tconn->max_query_chans = sserver->max_query_chans;\n}", "path": "src\\irc\\core\\irc-servers-setup.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Return how many characters in `str' must be skipped before `len'\n   characters of text is skipped. */\n", "func_signal": "int strip_real_length(const char *str, int len,\n\t\t      int *last_color_pos, int *last_color_len)", "code": "{\n\tconst char *start = str;\n\n\tif (last_color_pos != NULL)\n\t\t*last_color_pos = -1;\n\tif (last_color_len != NULL)\n\t\t*last_color_len = -1;\n\n\twhile (*str != '\\0') {\n\t\tif (*str == 3) {\n\t\t\tconst char *mircstart = str;\n\n\t\t\tif (last_color_pos != NULL)\n\t\t\t\t*last_color_pos = (int) (str-start);\n\t\t\tstr++;\n\t\t\tget_mirc_color(&str, NULL, NULL);\n\t\t\tif (last_color_len != NULL)\n\t\t\t\t*last_color_len = (int) (str-mircstart);\n\n\t\t} else if (*str == 4 && str[1] != '\\0') {\n\t\t\tif (str[1] < FORMAT_STYLE_SPECIAL && str[2] != '\\0') {\n\t\t\t\tif (last_color_pos != NULL)\n\t\t\t\t\t*last_color_pos = (int) (str-start);\n\t\t\t\tif (last_color_len != NULL)\n\t\t\t\t\t*last_color_len = 3;\n\t\t\t\tstr++;\n\t\t\t} else if (str[1] == FORMAT_STYLE_DEFAULTS) {\n\t\t\t\tif (last_color_pos != NULL)\n\t\t\t\t\t*last_color_pos = (int) (str-start);\n\t\t\t\tif (last_color_len != NULL)\n\t\t\t\t\t*last_color_len = 2;\n\t\t\t}\n\t\t\tstr += 2;\n\t\t} else {\n\t\t\tif (!IS_COLOR_CODE(*str)) {\n\t\t\t\tif (len-- == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr++;\n\t\t}\n\t}\n\n\treturn (int) (str-start);\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Returns the lag in milliseconds. If we haven't been able to ask the lag\n   for a while, unknown is set to TRUE. */\n", "func_signal": "static int get_lag(SERVER_REC *server, int *unknown)", "code": "{\n\tlong lag;\n\n        *unknown = FALSE;\n\n\tif (server == NULL || server->lag_last_check == 0) {\n                /* lag has not been asked even once yet */\n\t\treturn 0;\n\t}\n\n\tif (server->lag_sent.tv_sec == 0) {\n\t\t/* no lag queries going on currently */\n                return server->lag;\n\t}\n\n        /* we're not sure about our current lag.. */\n\t*unknown = TRUE;\n\n        lag = (long) (time(NULL)-server->lag_sent.tv_sec);\n\tif (server->lag/1000 > lag) {\n\t\t/* we've been waiting the lag reply less time than\n\t\t   what last known lag was -> use the last known lag */\n\t\treturn server->lag;\n\t}\n\n        /* return how long we have been waiting for lag reply */\n        return lag*1000;\n}", "path": "src\\fe-text\\statusbar-items.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Return how many characters in `str' must be skipped before `len'\n   characters of text is skipped. Like strip_real_length(), except this\n   handles %codes. */\n", "func_signal": "int format_real_length(const char *str, int len)", "code": "{\n\tGString *tmp;\n\tconst char *start;\n\tconst char *oldstr;\n\tgboolean utf8;\n\n\tg_return_val_if_fail(str != NULL, 0);\n\tg_return_val_if_fail(len >= 0, 0);\n\n\tutf8 = is_utf8() && g_utf8_validate(str, -1, NULL);\n\n\tstart = str;\n\ttmp = g_string_new(NULL);\n\twhile (*str != '\\0' && len > 0) {\n\t\tif (*str == '%' && str[1] != '\\0') {\n\t\t\tstr++;\n\t\t\tif (*str != '%' &&\n\t\t\t    format_expand_styles(tmp, &str, NULL)) {\n\t\t\t\tstr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* %% or unknown %code, written as-is */\n\t\t\tif (*str != '%') {\n\t\t\t\tif (--len == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\toldstr = str;\n\t\tlen -= advance(&str, utf8);\n\t\tif (len < 0)\n\t\t\tstr = oldstr;\n\t}\n\n\tg_string_free(tmp, TRUE);\n\treturn (int) (str-start);\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Load a sub module. */\n", "func_signal": "int module_load_sub(const char *path, const char *submodule, char **prefixes)", "code": "{\n        GString *full_path;\n\tchar *exppath, *name, *rootmodule;\n        int start, end, ret;\n\n\tg_return_val_if_fail(path != NULL, FALSE);\n\tg_return_val_if_fail(submodule != NULL, FALSE);\n\n        exppath = convert_home(path);\n\n\tname = module_get_name(exppath, &start, &end);\n\trootmodule = module_get_root(name, prefixes);\n\tg_free(name);\n\n        full_path = g_string_new(exppath);\n\tif (strcmp(submodule, \"core\") == 0)\n\t\tg_string_insert(full_path, end, \"_core\");\n\telse {\n\t\tg_string_insert_c(full_path, start, '_');\n\t\tg_string_insert(full_path, start, submodule);\n\t}\n\n\tret = module_load_full(full_path->str, rootmodule, submodule,\n\t\t\t       start, end, NULL);\n\n\tg_string_free(full_path, TRUE);\n\tg_free(rootmodule);\n\tg_free(exppath);\n        return ret;\n}", "path": "src\\core\\modules-load.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Massjoin support - really useful when trying to do things (like op/deop)\n   to people after netjoins. It sends\n   \"massjoin #channel nick!user@host nick2!user@host ...\" signals */\n", "func_signal": "static void event_join(IRC_SERVER_REC *server, const char *data,\n\t\t       const char *nick, const char *address)", "code": "{\n\tchar *params, *channel, *ptr;\n\tIRC_CHANNEL_REC *chanrec;\n\tNICK_REC *nickrec;\n\tGSList *nicks, *tmp;\n\n\tg_return_if_fail(data != NULL);\n\n\tif (g_strcasecmp(nick, server->nick) == 0) {\n\t\t/* You joined, no need to do anything here */\n\t\treturn;\n\t}\n\n\tparams = event_get_params(data, 1, &channel);\n\tptr = strchr(channel, 7); /* ^G does something weird.. */\n\tif (ptr != NULL) *ptr = '\\0';\n\n\t/* find channel */\n\tchanrec = irc_channel_find(server, channel);\n\tg_free(params);\n\tif (chanrec == NULL) return;\n\n\t/* check that the nick isn't already in nicklist. seems to happen\n\t   sometimes (server desyncs or something?) */\n\tnickrec = nicklist_find(CHANNEL(chanrec), nick);\n\tif (nickrec != NULL) {\n\t\t/* destroy the old record */\n\t\tnicklist_remove(CHANNEL(chanrec), nickrec);\n\t}\n\n\t/* add user to nicklist */\n\tnickrec = irc_nicklist_insert(chanrec, nick, FALSE, FALSE, FALSE, TRUE, NULL);\n        nicklist_set_host(CHANNEL(chanrec), nickrec, address);\n\n\tif (chanrec->massjoins == 0) {\n\t\t/* no nicks waiting in massjoin queue */\n\t\tchanrec->massjoin_start = time(NULL);\n\t\tchanrec->last_massjoins = 0;\n\t}\n\n\tif (nickrec->realname == NULL) {\n\t\t/* Check if user is already in some other channel,\n\t\t   get the realname and other stuff from there */\n\t\tnicks = nicklist_get_same(SERVER(server), nick);\n\t\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next->next) {\n\t\t\tNICK_REC *rec = tmp->next->data;\n\n\t\t\tif (rec->realname != NULL) {\n\t\t\t\tnickrec->last_check = rec->last_check;\n\t\t\t\tnickrec->realname = g_strdup(rec->realname);\n\t\t\t\tnickrec->gone = rec->gone;\n\t\t\t\tnickrec->serverop = rec->serverop;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg_slist_free(nicks);\n\t}\n\n\tchanrec->massjoins++;\n}", "path": "src\\irc\\core\\massjoin.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Only unknown keys in `optlist' should be levels.\n   Returns -1 if unknown option was given. */\n", "func_signal": "int cmd_options_get_level(const char *cmd, GHashTable *optlist)", "code": "{\n\tGSList *list, *tmp, *next;\n        int level, retlevel;\n\n\t/* get all the options, then remove the known ones. there should\n\t   be only one left - the server tag. */\n\tlist = hashtable_get_keys(optlist);\n\tif (cmd != NULL) {\n\t\tfor (tmp = list; tmp != NULL; tmp = next) {\n\t\t\tchar *option = tmp->data;\n\t\t\tnext = tmp->next;\n\n\t\t\tif (command_have_option(cmd, option))\n\t\t\t\tlist = g_slist_remove(list, option);\n\t\t}\n\t}\n\n        retlevel = 0;\n\twhile (list != NULL) {\n\t\tlevel = level_get(list->data);\n\t\tif (level == 0) {\n\t\t\t/* unknown option */\n\t\t\tsignal_emit(\"error command\", 2,\n\t\t\t\t    GINT_TO_POINTER(CMDERR_OPTION_UNKNOWN),\n\t\t\t\t    list->data);\n\t\t\tretlevel = -1;\n                        break;\n\t\t}\n\n\t\tretlevel |= level;\n                list = g_slist_remove(list, list->data);\n\t}\n\n\treturn retlevel;\n}", "path": "src\\fe-text\\lastlog.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Send channel's massjoin list signal */\n", "func_signal": "static void massjoin_send(IRC_CHANNEL_REC *channel)", "code": "{\n\tGSList *list;\n\n\tlist = NULL;\n\tg_hash_table_foreach(channel->nicks, (GHFunc) massjoin_send_hash, &list);\n\n\tchannel->massjoins = 0;\n\tsignal_emit(\"massjoin\", 2, channel, list);\n\tg_slist_free(list);\n}", "path": "src\\irc\\core\\massjoin.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Return length of text part in string (ie. without % codes) */\n", "func_signal": "int format_get_length(const char *str)", "code": "{\n\tGString *tmp;\n\tint len;\n\tgboolean utf8;\n\n\tg_return_val_if_fail(str != NULL, 0);\n\n\tutf8 = is_utf8() && g_utf8_validate(str, -1, NULL);\n\n\ttmp = g_string_new(NULL);\n\tlen = 0;\n\twhile (*str != '\\0') {\n\t\tif (*str == '%' && str[1] != '\\0') {\n\t\t\tstr++;\n\t\t\tif (*str != '%' &&\n\t\t\t    format_expand_styles(tmp, &str, NULL)) {\n\t\t\t\tstr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* %% or unknown %code, written as-is */\n\t\t\tif (*str != '%')\n\t\t\t\tlen++;\n\t\t}\n\n\t\tlen += advance(&str, utf8);\n\t}\n\n\tg_string_free(tmp, TRUE);\n\treturn len;\n}", "path": "src\\fe-common\\core\\formats.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Returns the sub module name for given submodule (eg. perl_core -> core) */\n", "func_signal": "static char *module_get_sub(const char *name, const char *root)", "code": "{\n\tint rootlen, namelen;\n\n        namelen = strlen(name);\n\trootlen = strlen(root);\n        g_return_val_if_fail(namelen >= rootlen, g_strdup(name));\n\n\tif (strncmp(name, root, rootlen) == 0 &&\n\t    strcmp(name+rootlen, \"_core\") == 0)\n                return g_strdup(\"core\");\n\n\tif (namelen > rootlen && name[namelen-rootlen-1] == '_' &&\n\t    strcmp(name+namelen-rootlen, root) == 0)\n                return g_strndup(name, namelen-rootlen-1);\n\n        return g_strdup(name);\n}", "path": "src\\core\\modules-load.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* Returns the module name without path, \"lib\" prefix or \".so\" suffix */\n", "func_signal": "static char *module_get_name(const char *path, int *start, int *end)", "code": "{\n\tconst char *name;\n\tchar *module_name, *ptr;\n\n        name = NULL;\n\tif (*path == '~' || g_path_is_absolute(path)) {\n\t\tname = strrchr(path, G_DIR_SEPARATOR);\n                if (name != NULL) name++;\n\t}\n\n\tif (name == NULL)\n\t\tname = path;\n\n\tif (strncmp(name, \"lib\", 3) == 0)\n\t\tname += 3;\n\n\tmodule_name = g_strdup(name);\n\tptr = strchr(module_name, '.');\n\tif (ptr != NULL) *ptr = '\\0';\n\n\t*start = (int) (name-path);\n\t*end = *start + (ptr == NULL ? strlen(name) :\n\t\t\t (int) (ptr-module_name));\n\n\treturn module_name;\n}", "path": "src\\core\\modules-load.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "/* redraw activity, FIXME: if we didn't get enough size, this gets buggy.\n   At least \"Det:\" isn't printed properly. also we should rearrange the\n   act list so that the highest priority items comes first. */\n", "func_signal": "static void item_act(SBAR_ITEM_REC *item, int get_size_only)", "code": "{\n\tchar *actlist;\n\n\tactlist = get_activity_list(item->bar->parent_window, TRUE, TRUE);\n\tif (actlist == NULL) {\n\t\tif (get_size_only)\n\t\t\titem->min_size = item->max_size = 0;\n\t\treturn;\n\t}\n\n\tstatusbar_item_default_handler(item, get_size_only,\n\t\t\t\t       NULL, actlist, FALSE);\n\n\tg_free_not_null(actlist);\n}", "path": "src\\fe-text\\statusbar-items.c", "repo_name": "jahrome/irssi-android", "stars": 11, "license": "other", "language": "c", "size": 4802}
{"docstring": "//===== LDA R,mem\n", "func_signal": "void dstLDAL()", "code": "{\n\tregL(R) = (_u32)mem;\n\tcycles = 4;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LD (mem),#\n", "func_signal": "void dstLDBi()", "code": "{\n\tstoreB(mem, FETCH8);\n\tcycles = 5;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== SET #3,(mem)\n", "func_signal": "void dstSET()", "code": "{\n\tstoreB(mem, loadB(mem) | (1 << R));\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== JP cc,mem\n", "func_signal": "void dstJP()", "code": "{\n\tif (conditionCode(second & 0xF))\n\t{\n\t\tpc = mem;\n\t\tcycles = 9;\n\t}\n\telse\n\t{\n\t\tcycles = 6;\n\t}\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== XORCF A,(mem)\n", "func_signal": "void dstXORCFA()", "code": "{\n\t_u8 bit = REGA & 0xF;\n\t_u8 mbit = (loadB(mem) >> bit) & 1;\n\tif (bit < 8) SETFLAG_C(mbit ^ FLAG_C);\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== RET cc\n", "func_signal": "void dstRET()", "code": "{\n\tif (conditionCode(second & 0xF))\n\t{\n\t\tpc = pop32();\n\t\tcycles = 12;\n\t}\n\telse\n\t{\n\t\tcycles = 6;\n\t}\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== POP (mem)\n", "func_signal": "void dstPOPW()", "code": "{\n\tstoreW(mem, pop16());\n\tcycles = 6;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== RES #3,(mem)\n", "func_signal": "void dstRES()", "code": "{\n\tstoreB(mem, loadB(mem) & (~(1 << R)));\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== ORCF #3,(mem)\n", "func_signal": "void dstORCF()", "code": "{\n\t_u8 bit = R;\n\t_u8 mbit = (loadB(mem) >> bit) & 1;\n\tSETFLAG_C(mbit | FLAG_C);\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== CHG #3,(mem)\n", "func_signal": "void dstCHG()", "code": "{\n\tstoreB(mem, loadB(mem) ^ (1 << R));\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LDA R,mem\n", "func_signal": "void dstLDAW()", "code": "{\n\tregW(R) = (_u16)mem;\n\tcycles = 4;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LD (mem),(nn)\n", "func_signal": "void dstLDWm16()", "code": "{\n\tstoreW(mem, loadW(fetch16()));\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LD (mem),R\n", "func_signal": "void dstLDWR()", "code": "{\n\tstoreW(mem, regW(R));\n\tcycles = 4;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== STCF A,(mem)\n", "func_signal": "void dstSTCFA()", "code": "{\n\t_u8 bit = REGA & 0xF;\n\t_u8 cmask = ~(1 << bit);\n\t_u8 set = FLAG_C << bit;\n\tif (bit < 8) storeB(mem, (loadB(mem) & cmask) | set); \n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LDCF A,(mem)\n", "func_signal": "void dstLDCFA()", "code": "{\n\t_u8 bit = REGA & 0xF;\n\t_u8 mask = (1 << bit);\n\tif (bit < 8) SETFLAG_C(loadB(mem) & mask);\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== LD (mem),R\n", "func_signal": "void dstLDLR()", "code": "{\n\tstoreL(mem, regL(R));\n\tcycles = 6;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== POP (mem)\n", "func_signal": "void dstPOPB()", "code": "{\n\tstoreB(mem, pop8());\n\tcycles = 6;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== STCF #3,(mem)\n", "func_signal": "void dstSTCF()", "code": "{\n\t_u8 bit = R;\n\t_u8 cmask = ~(1 << bit);\n\t_u8 set = FLAG_C << bit;\n\tstoreB(mem, (loadB(mem) & cmask) | set); \n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== ANDCF A,(mem)\n", "func_signal": "void dstANDCFA()", "code": "{\n\t_u8 bit = REGA & 0xF;\n\t_u8 mbit = (loadB(mem) >> bit) & 1;\n\tif (bit < 8) SETFLAG_C(mbit & FLAG_C);\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "//===== XORCF #3,(mem)\n", "func_signal": "void dstXORCF()", "code": "{\n\t_u8 bit = R;\n\t_u8 mbit = (loadB(mem) >> bit) & 1;\n\tSETFLAG_C(mbit ^ FLAG_C);\n\tcycles = 8;\n}", "path": "neopop_q2\\TLCS-900h\\TLCS900h_interpret_dst.c", "repo_name": "LemonBoy/Q2-Tools", "stars": 13, "license": "None", "language": "c", "size": 1460}
{"docstring": "/* name is unused if prctl is unavailable */\n", "func_signal": "void avahi_set_proc_title(const char *name AVAHI_GCC_UNUSED, const char *fmt,...)", "code": "{\n#ifdef HAVE_SETPROCTITLE\n    char t[256];\n\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(t, sizeof(t), fmt, ap);\n    va_end(ap);\n\n    setproctitle(\"-%s\", t);\n#elif __linux__\n    size_t l;\n    va_list ap;\n    \n    if (!argv_buffer)\n        return;\n    \n    va_start(ap, fmt);\n    vsnprintf(argv_buffer[0], argv_size, fmt, ap);\n    va_end(ap);\n\n    l = strlen(argv_buffer[0]);\n    \n    memset(argv_buffer[0] + l, 0, argv_size - l);\n    argv_buffer[1] = NULL;\n#endif\n\n#if defined(HAVE_SYS_PRCTL_H) && defined(PR_SET_NAME)\n\n    if (name)\n        prctl(PR_SET_NAME, (unsigned long) name, 0, 0, 0);\n    \n#endif\n}", "path": "avahi-common\\setproctitle.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* Default implementation for avahi_calloc() */\n", "func_signal": "static void *xcalloc(size_t nmemb, size_t size)", "code": "{\n    void *p;\n    \n    if (size == 0 || nmemb == 0)\n        return NULL;\n\n    if (!(p = calloc(nmemb, size)))\n        oom();\n\n    return p;\n}", "path": "avahi-common\\malloc.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* NATPMD_STANDALONE */\n", "func_signal": "AvahiIniFile* avahi_ini_file_load(const char *fname)", "code": "{\n    AvahiIniFile *f;\n    FILE *fo;\n    AvahiIniFileGroup *group = NULL;\n    unsigned line;\n    \n    assert(fname);\n\n    if (!(fo = fopen(fname, \"r\"))) {\n        avahi_log_error(\"Failed to open file '%s': %s\", fname, strerror(errno));\n        return NULL;\n    }\n    \n    f = avahi_new(AvahiIniFile, 1);\n    AVAHI_LLIST_HEAD_INIT(AvahiIniFileGroup, f->groups);\n    f->n_groups = 0;\n\n    line = 0;\n    while (!feof(fo)) {\n        char ln[256], *s, *e;\n        AvahiIniFilePair *pair;\n        \n        if (!(fgets(ln, sizeof(ln), fo)))\n            break;\n\n        line++;\n        \n        s = ln + strspn(ln, \" \\t\");\n        s[strcspn(s, \"\\r\\n\")] = 0;\n\n        /* Skip comments and empty lines */\n        if (*s == '#' || *s == '%' || *s == 0)\n            continue;\n\n        if (*s == '[') {\n            /* new group */\n            \n            if (!(e = strchr(s, ']'))) {\n                avahi_log_error(\"Unclosed group header in %s:%u: <%s>\", fname, line, s);\n                goto fail;\n            }\n\n            *e = 0;\n            \n            group = avahi_new(AvahiIniFileGroup, 1);\n            group->name = avahi_strdup(s+1);\n            group->n_pairs = 0;\n            AVAHI_LLIST_HEAD_INIT(AvahiIniFilePair, group->pairs);\n            \n            AVAHI_LLIST_PREPEND(AvahiIniFileGroup, groups, f->groups, group);\n            f->n_groups++;\n        } else {\n\n            /* Normal assignment */\n            if (!(e = strchr(s, '='))) {\n                avahi_log_error(\"Missing assignment in %s:%u: <%s>\", fname, line, s);\n                goto fail;\n            }\n            \n            if (!group) {\n                avahi_log_error(\"Assignment outside group in %s:%u <%s>\", fname, line, s);\n                goto fail;\n            }\n            \n            /* Split the key and the value */\n            *(e++) = 0;\n            \n            pair = avahi_new(AvahiIniFilePair, 1);\n            pair->key = avahi_strdup(s);\n            pair->value = avahi_strdup(e);\n            \n            AVAHI_LLIST_PREPEND(AvahiIniFilePair, pairs, group->pairs, pair);\n            group->n_pairs++;\n        }\n    }\n    \n    fclose(fo);\n        \n    return f;\n\nfail:\n\n    if (fo)\n        fclose(fo);\n\n    if (f)\n        avahi_ini_file_free(f);\n\n    return NULL;\n}", "path": "avahi-common\\ini-file-parser.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* FIXME: This should also ensure trailing slashes are honoured, a la\n * AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK */\n", "func_signal": "int rpl_lstat(const char *path, struct stat *buf)", "code": "{\n    if (*path == '\\0') {\n        errno = ENOENT;\n        return -1;\n    }\n\n    return lstat(path, buf);\n}", "path": "lib\\lstat.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Set the provided head pointer to a linked list of private interfaces with\n * multicast sockets.\n * Returns 0 on success, -1 on error.\n * On *head will only be set on success.\n *\n * This function is too long.\n */\n", "func_signal": "int avahi_natpm_get_private_interfaces(AvahiNatpmPrivateInterface **head)", "code": "{\n    int ret = -1;\n    int snetdev = -1; /* netdevice(7) ioctl socket */\n    AVAHI_LLIST_HEAD(AvahiNatpmPrivateInterface, new_head);\n    int iface_alloc;\n    struct ifconf ifconf;\n    size_t i;\n\n    AVAHI_LLIST_HEAD_INIT(AvahiNatpmPrivateInterface, new_head);\n\n    snetdev = socket(PF_INET, SOCK_DGRAM, 0);\n    if (snetdev == -1) {\n        daemon_log(LOG_DEBUG, \"%s: ipv4 control socket unavailable: %s\",\n                __FUNCTION__, strerror(errno));\n\n        snetdev = socket(PF_INET6, SOCK_DGRAM, 0);\n\n        if (snetdev == -1) {\n            daemon_log(LOG_ERR, \"%s: Unable to create netdev control socket: %s\",\n                    __FUNCTION__, strerror(errno));\n\n            goto cleanup;\n        }\n    }\n\n    iface_alloc = INIT_IFACE_ALLOC / 2;\n    ifconf.ifc_req = NULL;\n\n    assert(iface_alloc > 0);\n\n    do {\n        avahi_free(ifconf.ifc_req);\n\n        iface_alloc *= 2;\n\n        daemon_log(LOG_DEBUG, \"%s: Allocating for %d structures\",\n                __FUNCTION__, iface_alloc);\n\n        ifconf.ifc_len = iface_alloc * sizeof(struct ifreq);\n        ifconf.ifc_req = avahi_new(struct ifreq, iface_alloc);\n\n        if (ifconf.ifc_req == NULL) {\n            daemon_log(LOG_ERR, \"%s: Out of memory\", __FUNCTION__);\n            goto cleanup;\n        }\n\n        if (-1 == ioctl(snetdev, SIOCGIFCONF, &ifconf)) {\n            daemon_log(LOG_ERR, \"%s: ioctl(SIOCGIFCONF) failed to get interfaces: %s\",\n                    __FUNCTION__, strerror(errno));\n            \n            goto cleanup;\n        }\n    } while (((size_t)ifconf.ifc_len) == iface_alloc * sizeof(struct ifreq));\n\n    for (i = 0; i * sizeof(struct ifreq) < (size_t)ifconf.ifc_len; ++i) {\n        const struct sockaddr_in *sin;\n        struct ifreq *ifreq = &ifconf.ifc_req[i];\n\n        if (ifreq->ifr_addr.sa_family != AF_INET)\n            continue;\n\n        sin = (struct sockaddr_in*)(&ifreq->ifr_addr);\n        if (   avahi_natpm_address_visibility(sin->sin_addr.s_addr) == AVAHI_NATPM_ADDRESS_VISIBILITY_PRIVATE\n            || avahi_natpm_address_visibility(sin->sin_addr.s_addr) == AVAHI_NATPM_ADDRESS_VISIBILITY_LOOPBACK) {\n\n            struct ifreq ifreq_flags;\n            AvahiNatpmPrivateInterface *newif;\n\n            strncpy(ifreq_flags.ifr_name, ifreq->ifr_name, IFNAMSIZ);\n            ifreq_flags.ifr_name[IFNAMSIZ - 1] = '\\0';\n\n            if (-1 == ioctl(snetdev, SIOCGIFFLAGS, &ifreq_flags)) {\n                daemon_log(LOG_ERR, \"%s: SIOCGIFFLAGS ioctl failed on %s\",\n                        __FUNCTION__, ifreq->ifr_name);\n                continue;\n            }\n\n            if ((ifreq_flags.ifr_flags & IFF_MULTICAST) == 0) {\n                daemon_log(LOG_INFO, \"%s: Skipping %s (not multicast-enabled)\",\n                        __FUNCTION__, ifreq->ifr_name);\n                continue;\n            }\n\n            /* Fill in interface structure and add it to the llist. */\n            \n            newif = avahi_new0(AvahiNatpmPrivateInterface, 1);\n\n            if (!newif) {\n                daemon_log(LOG_ERR, \"%s: Out of memory\", __FUNCTION__);\n                goto cleanup;\n            }\n\n            AVAHI_LLIST_INIT(AvahiNatpmPrivateInterface, ifa, newif);\n\n            /* XXX: I wrote this at SFO after a long day. There are probably\n             * bugs. */\n\n            /* newif.iface.index = ; */\n            {\n                struct ifreq iftmp;\n                strncpy(iftmp.ifr_name, ifreq->ifr_name, sizeof(iftmp.ifr_name));\n                iftmp.ifr_name[sizeof(iftmp.ifr_name)-1] = '\\0'; /* Ensure NUL-termination */\n                if (-1 == ioctl(snetdev, SIOCGIFINDEX, &iftmp)) {\n                    daemon_log(LOG_ERR, \"%s: ioctl(SIOCGIFINDEX) failed: %s\",\n                            __FUNCTION__, strerror(errno));\n                    avahi_free(newif);\n                    goto cleanup;\n                }\n                newif->iface.index = iftmp.ifr_ifindex;\n            }\n\n            /* newif.iface.name = ; */\n            newif->iface.name = avahi_strdup(ifreq->ifr_name);\n            if (!newif->iface.name) {\n                daemon_log(LOG_ERR, \"%s: Out of memory\", __FUNCTION__);\n                avahi_free(newif);\n                goto cleanup;\n            }\n\n            /* newif.sock = ; */\n            newif->sock = get_multicast_socket((struct sockaddr_in*)&ifreq->ifr_addr);\n            if (newif->sock == -1) {\n                avahi_free(newif);\n                goto cleanup;\n            }\n\n            /* OK, everything worked */\n            AVAHI_LLIST_PREPEND(AvahiNatpmPrivateInterface, ifa, new_head, newif);\n        }\n    }\n\n    ret = 0;\n    *head = new_head;\n\ncleanup:\n    if (snetdev >= 0)\n        close(snetdev);\n\n    avahi_free(ifconf.ifc_req);\n\n    if (ret != 0) {\n        /* Remove any items that were added */\n        while(new_head)\n            AVAHI_LLIST_REMOVE(AvahiNatpmPrivateInterface, ifa, new_head, new_head);\n    }\n\n    return ret;\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Parse the given line looking for a gateway definition.\n * If the gateway flag is set, the address is stored in *addr\n * and the function returns 1. If no gateway is found, it returns\n * 0 and the content of *addr is undefined.\n *\n * The input line will be modified during the search process.\n */\n", "func_signal": "static int find_gateway(char *line, struct in_addr *addr)", "code": "{\n    unsigned long int flags = 0;\n    char *endptr;\n    const char *addrstr = NULL, *flagstr = NULL;\n    unsigned int field = 1;\n    union {\n        struct in_addr sin_addr;\n        unsigned long numeric;\n    } address;\n\n    if (!line || !addr)\n        return 0;\n\n    while ((line = strtok(field == 1 ? line : NULL, \"\\t \"))) {\n        if (field == 3)\n            addrstr = line;\n        else if (field == 4) {\n            flagstr = line;\n            break;\n        }\n        ++field;\n    }\n\n    if (!addrstr || !flagstr) {\n        daemon_log(LOG_WARNING, \"%s: Did not find %s field\\n\",\n                __FUNCTION__, (addrstr == NULL) ? \"gateway\" : \"flags\");\n        return 0;\n    }\n\n    flags = strtoul(flagstr, &endptr, 16);\n    if (endptr == flagstr || *endptr != '\\0') {\n        daemon_log(LOG_WARNING, \"%s: Could not parse flag string \\\"%s\\\"\",\n                __FUNCTION__, flagstr);\n        return 0;\n    }\n\n    if ((flags & RTF_GATEWAY) && (flags & RTF_UP)) { /* Valid gateway */\n        address.numeric = strtoul(addrstr, &endptr, 16);\n        if (endptr == addrstr || *endptr != '\\0') {\n            daemon_log(LOG_ERR, \"%s: Could not parse address string \\\"%s\\\"\",\n                    __FUNCTION__, addrstr);\n            return 0;\n        }\n\n        *addr = address.sin_addr;\n\n        return 1;\n    }\n\n    return 0;\n}", "path": "testclient\\gateway.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* Returns the given address converted to a string.\n * The returned buffer is statically allocated and will be overridden by\n * subsequent calls.\n */\n", "func_signal": "const char *ip4_addr_str(struct in_addr addr)", "code": "{\n    static char str[16];\n    if (inet_ntop(AF_INET, &addr.s_addr, str, sizeof(str)))\n        return str;\n    else\n        return \"?\";\n}", "path": "common.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Gets the default route (gateway) that NAT-PMP packets should be sent\n * to.\n * Returns -1 on error, 0 on success.\n */\n", "func_signal": "int avahi_natpm_get_gateway(struct in_addr *addr)", "code": "{\n    FILE *froute = NULL;\n    char line[LINE_BUF_LEN];\n    int result = -1;\n\n    froute = fopen(PROC_NET_ROUTE, \"r\");\n    if (!froute) {\n        daemon_log(LOG_ERR, \"%s: Failed to open %s: %s\",\n                __FUNCTION__, PROC_NET_ROUTE, strerror(errno));\n        goto finish;\n    }\n\n    /* Throw away the first line -- it's a header line. */\n    if (!get_line(line, sizeof(line), froute)) {\n        daemon_log(LOG_ERR, \"%s: Unexpected error reading %s: %s\",\n                __FUNCTION__, PROC_NET_ROUTE, strerror(errno));\n        goto finish;\n    }\n\n    /* Look for the gateway line */\n    while (get_line(line, sizeof(line), froute)) {\n        if (find_gateway(line, addr)) {\n            result = 0;\n            break;\n        }\n    }\n\nfinish:\n    if (froute)\n        fclose(froute);\n\n    return result;\n}", "path": "testclient\\gateway.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/** Reads a line of text up to buflen bytes long into buf from stream,\n * dropping any text that exceeds the buffer length and always reading a\n * full line.\n *\n * Returns buf if reading succeeded, or NULL on error or end of file\n * when no characters were read (like fgets).\n */\n", "func_signal": "static char *get_line(char buf[], size_t buflen, FILE *stream)", "code": "{\n    if (!fgets(buf, buflen, stream))\n        return NULL;\n\n    if (!strchr(buf, '\\n')) { /* Not at end of line yet */\n        int c;\n        do c = getc(stream);\n        while (c != '\\n' && c != EOF);\n    }\n\n    return buf;\n}", "path": "testclient\\gateway.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Frees an interface. It is safe to pass NULL.\n */\n", "func_signal": "void avahi_natpm_free_interface(AvahiNatpmInterface *iface)", "code": "{\n    if (iface) {\n        avahi_free(iface->name);\n        avahi_free(iface);\n    }\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Iterate through interfaces to find a public interface.\n * The intended interface name may be passed in, in which case that interface\n * will be returned (if found).\n *\n * @param ifacename Name of the interface to be used as the public interface.\n *                  May be NULL, in which case the first interface with a\n *                  public IP address will be used.\n *\n * Returns NULL if there is no appropriate interface.\n * Free the result with avahi_natpm_free_interface().\n */\n", "func_signal": "AvahiNatpmInterface *avahi_natpm_get_public_interface(const char *ifacename)", "code": "{\n    AvahiNatpmInterface *iface = NULL;\n    struct ifaddrs *ifaddrs_top, *ifaddr;\n\n    /* Consider an empty interface as if it's not set at all. */\n    if (ifacename && ifacename[0] == '\\0')\n        ifacename = NULL;\n\n    if (-1 == getifaddrs(&ifaddrs_top))\n        return NULL;\n\n    for (ifaddr = ifaddrs_top; ifaddr; ifaddr = ifaddr->ifa_next) {\n        if (!ifaddr->ifa_addr)\n            continue;\n\n        if (ifaddr->ifa_addr->sa_family == AF_INET) {\n            const struct sockaddr_in *sin = (struct sockaddr_in*)ifaddr->ifa_addr;\n\n            if (is_public_iface(ifaddr, ifacename))\n            {\n                iface = avahi_new0(AvahiNatpmInterface, 1);\n                if (!iface)\n                    goto end;\n\n                iface->index = if_nametoindex(ifaddr->ifa_name);\n                iface->name = avahi_strdup(ifaddr->ifa_name);\n\n                iface->address = sin->sin_addr.s_addr;\n                break;\n            }\n        }\n    }\n\n    if (ifacename && !iface)\n        daemon_log(LOG_ERR, \"Interface \\\"%s\\\" not found.\", ifacename);\n\nend:\n    freeifaddrs(ifaddrs_top);\n\n    return iface;\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* Default implementation for avahi_malloc() */\n", "func_signal": "static void* xmalloc(size_t size)", "code": "{\n    void *p;\n\n    if (size == 0)\n        return NULL;\n\n    if (!(p = malloc(size)))\n        oom();\n\n    return p;\n}", "path": "avahi-common\\malloc.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Determine whether an IPv4 address is on a private network or a public network.\n * All non-private networks are considered public.\n * Based on RFCs 1918 & 3330.\n */\n", "func_signal": "AvahiNatpmAddressVisibility avahi_natpm_address_visibility(in_addr_t addr)", "code": "{\n\n    /* Save my brain from exploding */\n    addr = ntohl(addr);\n\n    if (   (addr & 0xff000000UL) == 0x7f000000UL) /* 127.0.0.0   /8  */\n        return AVAHI_NATPM_ADDRESS_VISIBILITY_LOOPBACK;\n\n    if (   (addr & 0xffff0000UL) == 0xc0a80000UL  /* 192.168.0.0 /16 */\n        || (addr & 0xffff0000UL) == 0xa9fe0000UL  /* 169.254.0.0 /16 */\n        || (addr & 0xff000000UL) == 0x0a000000UL  /* 10.0.0.0    /8  */\n        || (addr & 0xfff00000UL) == 0xac100000UL) /* 172.16.0.0  /12 */\n        return AVAHI_NATPM_ADDRESS_VISIBILITY_PRIVATE;\n    return AVAHI_NATPM_ADDRESS_VISIBILITY_PUBLIC;\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Return nonzero if the given interface either\n * a) matches the given interface name; or\n * b) is a public interface.\n * Note that if an interface name is provided, *only* that interface will match,\n * other interfaces with public addresses will be ignored.\n */\n", "func_signal": "static int is_public_iface(const struct ifaddrs *ifaddr, const char *pubifname)", "code": "{\n    const struct sockaddr_in *sin = (struct sockaddr_in*)ifaddr->ifa_addr;\n\n    if (pubifname)\n        return (strcmp(ifaddr->ifa_name, pubifname) == 0) ? 1 : 0;\n    return (avahi_natpm_address_visibility(sin->sin_addr.s_addr)\n            == AVAHI_NATPM_ADDRESS_VISIBILITY_PUBLIC);\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Destroy a map.\n * Closes its sockets (if they are >= 0) and frees the memory.\n * Must not be passed NULL.\n */\n", "func_signal": "void avahi_natpm_map_destroy(AvahiNatpmMap *map)", "code": "{\n    assert(map != NULL);\n\n    if (map->tcp.sock >= 0)\n        close(map->tcp.sock);\n\n    if (map->udp.sock >= 0)\n        close(map->udp.sock);\n\n    free(map);\n}", "path": "natmap.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Does _not_ close the interface's socket.\n */\n", "func_signal": "void avahi_natpm_free_private_interface(AvahiNatpmPrivateInterface *iface)", "code": "{\n    if (iface) {\n        avahi_free(iface->iface.name);\n        avahi_free(iface);\n    }\n}", "path": "interface.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * The next expiry of either a TCP or UDP map.\n */\n", "func_signal": "time_t avahi_natpm_map_next_expiry(const AvahiNatpmMap *map)", "code": "{\n\n    if (map->tcp.state != PORT_MAPPED) {\n        assert(map->udp.state == PORT_MAPPED);\n        return map->udp.expiry;\n    }\n\n    if (map->udp.state != PORT_MAPPED) {\n        assert(map->tcp.state == PORT_MAPPED);\n        return map->tcp.expiry;\n    }\n\n    /* Both mapped, return the smaller. */\n    return (map->tcp.expiry < map->udp.expiry) ? map->tcp.expiry : map->udp.expiry;\n}", "path": "natmap.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/**\n * Also handles an expiry in the past, if you are silly enough to request one.\n * In that case it will trigger immediately.\n *\n * An expiry of (time_t)-1 is ignored.\n */\n", "func_signal": "void timer_notify_expiry(time_t expiry)", "code": "{\n    long int delta;\n\n    if (expiry == -1) {\n        daemon_log(LOG_DEBUG, \"%s: Ignoring expiry of -1\", __FUNCTION__);\n        return;\n    }\n    \n    delta = expiry - time(NULL);\n\n    if (delta < 1) {\n        daemon_log(LOG_DEBUG, \"%s: Firing a SIGALRM right now\", __FUNCTION__);\n        kill(getpid(), SIGALRM);\n    } else {\n#if 0 /* noisy */\n        daemon_log(LOG_DEBUG, \"%s: Set alarm for %ld seconds from now\",\n                __FUNCTION__, delta);\n#endif\n\n        alarm(delta);\n    }\n}", "path": "timer.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* !DAEMON_LOGV_AVAILABLE */\n", "func_signal": "static void avahi_log_error(const char *msg, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap, msg);\n\tdaemon_logv(LOG_ERR, msg, ap);\n\tva_end(ap);\n}", "path": "avahi-common\\ini-file-parser.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* unused */\n", "func_signal": "unsigned avahi_natpm_map_hash(const void *m)", "code": "{\n    const AvahiNatpmMap *map = m;\n    unsigned hash;\n    const int shift = (sizeof(hash) < 8) ? 0 : 32;\n\n    hash  = map->private_addr.address;\n    hash ^= map->private_port << (shift);\n    hash ^= map->public_port << (shift + 16);\n    return hash;\n}", "path": "common.c", "repo_name": "tedjp/stallone", "stars": 11, "license": "lgpl-2.1", "language": "c", "size": 279}
{"docstring": "/* perpd_svdef_clear()\n**   prepare a clean perpd_svdef object\n*/\n", "func_signal": "void\nperpd_svdef_clear(struct svdef *svdef)", "code": "{\n  buf_zero(svdef, sizeof (struct svdef));\n  return;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* ioq_putfill()\n**   fill internal buffer first, then flush\n**   repeat as necessary\n**   note: internal ioq buffer may be non-empty on return\n*/\n", "func_signal": "int\nioq_putfill(ioq_t *ioq, const uchar_t *data, size_t len)", "code": "{\n  size_t  n;\n\n  while(len > (n = ioq->n - ioq->p)){\n      /* fill up available space in buffer: */\n      buf_copy(ioq->buf + ioq->p, data, n);\n      ioq->p += n;\n      data += n;\n      len -= n;\n      /* flush: */\n      if(ioq_flush(ioq) == -1) return -1;\n  }\n  /* now len <= available space in ioq */\n  /* ie, len <= (ioq->n - ioq->p) */\n  buf_copy(ioq->buf + ioq->p, data, len);\n  ioq->p += len;\n\n  return 0;\n}", "path": "lasagna\\ioq\\ioq_put.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* do_runlimits()\n**   scan through runlimits[]\n**   call setrlimit() for any entries that have been setup\n**   abort on failure\n*/\n", "func_signal": "static\nvoid\ndo_runlimits(void)", "code": "{\n  struct  rlimit  rlim;\n  int             i;\n\n  for(i = 0; runlimits[i].name != NULL; ++i){\n      if(runlimits[i].is_set){\n          rlim.rlim_cur = runlimits[i].rl_soft;\n          rlim.rlim_max = runlimits[i].rl_hard;\n          if(setrlimit(runlimits[i].id, &rlim) == -1){\n              fatal_syserr(\"failure setrlimit() for resource \", runlimits[i].name);\n          }\n      }\n      /* else skip... */\n  }\n\n  return;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* djbm\n** djb hash, modified:\n**   mix/combine operations reordered\n**   post-processesing as in fnvm()\n*/\n", "func_signal": "uint32_t\nhfunc_djbm(const uchar_t *key, size_t klen)", "code": "{\n  uint32_t   h = 5381;\n\n  while(klen){\n      h ^= *key;\n      h = ((h << 5) + h);\n      ++key; --klen;\n  }\n\n  /* post-processing: */\n  h += h << 13;\n  h ^= h >> 7;\n  h += h << 3;\n  h ^= h >> 17;\n  h += h << 5;\n\n  return h;\n}", "path": "lasagna\\hfunc\\hfunc_djbm.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perpd_svdef_close()\n**   close descriptors in a perpd_svdef object\n*/\n", "func_signal": "void\nperpd_svdef_close(struct svdef *svdef)", "code": "{\n  close(svdef->fd_dir);\n  return;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* runlimit_setup_ndx()\n**   setup runlimits[ndx] with runlimit specified in arg obtained from source\n**   ndx previously obtained from runlimit_ndx()\n**   skips any setup on any previous setting found\n**   abort on failure\n*/\n", "func_signal": "static\nvoid\nrunlimit_setup_ndx(int ndx, const char *arg, const char *source)", "code": "{\n  const char     *name = runlimits[ndx].name;\n  int             id;\n  struct rlimit   rlim;\n  uint32_t        u;\n  const char     *z;\n  char            nbuf[NFMT_SIZE];\n\n  if(runlimits[ndx].is_set){\n     /* skipping on previous setup: */\n     return;\n  }\n \n  if((arg == NULL) || (arg[0] == '\\0')){\n      fatal_usage(\"NULL or empty argument for resource \", name,\n                  \" found in \", source);\n  }\n\n  id = rlimit_lookup(name);\n  if(id == -1){\n      warn(\"resource \", name, \" from \", source, \"not supported on this system\");\n      return;\n  }\n\n  if(getrlimit(id, &rlim) == -1){\n      fatal_syserr(\"failure getrlimit() for resource \", name, \" from \", source);\n  }\n\n  runlimits[ndx].rl_hard = rlim.rlim_max;\n  if((arg[0] == '_') || (arg[0] == '^') || (arg[0] == '=')){\n      runlimits[ndx].rl_soft = rlim.rlim_max;\n  } else {\n      z = nuscan_uint32(&u, arg);\n      if(*z != '\\0'){\n          fatal_usage(\"non-numeric argument for resource \", name,\n                      \" from \", source, \": \", arg);\n      }\n      if(u < rlim.rlim_max){\n          runlimits[ndx].rl_soft = (rlim_t)u;\n      } else {\n          warn(\"truncating runlimit request for \", name, \" from \", source,\n               \" to hard limit: \", nfmt_uint32(nbuf, (uint32_t)rlim.rlim_max));\n          runlimits[ndx].rl_soft = rlim.rlim_max;\n      }\n  }\n  ++runlimits[ndx].is_set;\n  runlimits[ndx].id = id;\n\n  return;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perpd_svdef_wantcull()\n**   initiate deactivation of service definition\n**     - called by perpd_scan() on deactivation of single service\n**     - called by perpd_mainloop() on shutdown of all services\n**\n**   return:\n**     0: cull initiated on svdef (but not complete)\n**     1: svdef already in cull state\n*/\n", "func_signal": "int\nperpd_svdef_wantcull(struct svdef *svdef)", "code": "{\n  struct subsv  *subsv;\n\n  svdef->bitflags |= SVDEF_FLAG_CULL;\n\n  /* initiate termination: */\n  svdef->svpair[SUBSV_MAIN].bitflags |= SUBSV_FLAG_WANTDOWN;\n  if(svdef->bitflags & SVDEF_FLAG_HASLOG){\n      svdef->svpair[SUBSV_LOG].bitflags |= SUBSV_FLAG_WANTDOWN;\n  }\n\n  /* subsv main: */\n  subsv = &svdef->svpair[SUBSV_MAIN];\n\n  /* sigterm main (if not running reset) and make sure not paused: */\n  if(subsv->pid > 0){\n      if(!(subsv->bitflags & SUBSV_FLAG_ISRESET)){\n          kill(subsv->pid, SIGTERM);\n      }\n      subsv->bitflags &= ~SUBSV_FLAG_ISPAUSED;\n      kill(subsv->pid, SIGCONT);\n      return 0;\n  }\n\n  /* subsv log?: */\n  subsv = (svdef->bitflags & SVDEF_FLAG_HASLOG) ? &svdef->svpair[SUBSV_LOG] : NULL;\n\n  /* shutdown log (if not already running reset) and make sure not paused: */\n  if((subsv != NULL) && (subsv->pid > 0)){\n      if(!(subsv->bitflags & SUBSV_FLAG_ISRESET)){\n          close(svdef->logpipe[1]);\n          close(svdef->logpipe[0]);\n          kill(subsv->pid, SIGTERM);\n      }\n      subsv->bitflags &= ~SUBSV_FLAG_ISPAUSED;\n      kill(subsv->pid, SIGCONT);\n      return 0;\n  }\n\n  /* if here, nothing was running to kill()\n  **   - for example: no log, and main service was already down\n  **   - but upto now the service was still considered active\n  **\n  ** in any case, no kill() means:\n  **   - no triggering of sigchld\n  **   - and perpd_waitup() will not harvest the cull\n  **\n  ** indicate already in cull ready state:\n  */\n\n  return 1;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perpd_svdef_run()\n**   exec() a service:\n**     \"which\" is SUBSV_MAIN or SUBSV_LOG\n**     \"target\" is SVRUN_START or SVRUN_RESET\n**\n**   side effects:\n**     global flag_failing set on fail of fork()\n**     child uses (but does not alter) global poll_sigset\n*/\n", "func_signal": "int\nperpd_svdef_run(struct svdef *svdef, int which, int target)", "code": "{\n  struct subsv  *subsv = &svdef->svpair[which];\n  char          *prog[7];\n  tain_t         now, when_ok;\n  tain_t         towait = tain_INIT(0,0);\n  pid_t          pid;\n  int            i;\n\n  /* insanity checks: */\n  if((which == SUBSV_LOG) && !(svdef->bitflags & SVDEF_FLAG_HASLOG)){\n      log_debug(\"logging service requested but not enabled\");\n      return 0;\n  }\n\n  if(subsv->pid > 0){\n      log_debug(\"perpd_svrun() requested for service still running\");\n      return 0;\n  }\n\n  /* initialize (attempted) target, etc: */\n  switch(target){\n  case SVRUN_RESET: subsv->bitflags |= SUBSV_FLAG_ISRESET; break;\n  default: subsv->bitflags &= ~SUBSV_FLAG_ISRESET; break;\n  }\n  subsv->pid = 0;\n  subsv->wstat = 0;\n  subsv->bitflags &= ~SUBSV_FLAG_FAILING;\n\n  /* setup argv: */\n  prog[0] = (which == SUBSV_LOG) ? \"./rc.log\" : \"./rc.main\";\n  prog[1] = (target == SVRUN_START) ? \"start\" : \"reset\";\n  prog[2] = svdef->name;\n  prog[3] = NULL;\n\n  /* additional args if running \"reset\": */\n  if(target == SVRUN_RESET){\n      int  wstat = subsv->wstat;\n\n      if(WIFEXITED(wstat)){\n          char  nstr[NFMT_SIZE];\n          prog[3] = \"exit\";\n          prog[4] = nfmt_uint32(nstr, (uint32_t)WEXITSTATUS(wstat));\n          prog[5] = NULL;\n      } else {\n          int    n = (WIFSIGNALED(wstat) ? WTERMSIG(wstat) : WSTOPSIG(wstat));\n          char   nstr[NFMT_SIZE];\n          char  *s = (char *)sysstr_signal(n);\n          prog[3] = (WIFSIGNALED(wstat) ? \"signal\" : \"stopped\");\n          prog[4] = nfmt_uint32(nstr, (uint32_t)n);\n          prog[5] = ((s != NULL) ? s : \"SIGUNKNOWN\");\n          prog[6] = NULL;\n      }\n  }\n\n  /* timestamps and respawn governor: */\n  tain_now(&now);\n  tain_assign(&when_ok, &subsv->when_ok);\n  if((target == SVRUN_START) && tain_less(&now, &when_ok)){\n          log_warning(\"setting respawn governor on 'start' target of service \", svdef->name,\n                      \" for \", prog[0]);\n          tain_minus(&towait, &when_ok, &now);\n  }\n\n  /* fork/exec: */\n  if((pid = fork()) == -1){\n      subsv->pid = 0;\n      subsv->bitflags |= SUBSV_FLAG_FAILING;\n      perpd_trigger_fail();\n      warn_syserr(\"failure fork() for service \", svdef->name);\n      return -1;\n  }\n\n  /* XXX, TODO:\n  **   if child error before exec(), die() with a distinctive error code\n  */\n\n  /* child: */\n  if(pid == 0){\n      /* run child in new process group: */\n      setsid();\n      /* cwd for runscripts is svdir: */\n      if(fchdir(svdef->fd_dir) == -1){\n          fatal_syserr(\"(in child for service \", svdef->name,\n                       \"): failure fchdir() to service directory\");\n      }\n      /* setup logpipe: */\n      if(svdef->bitflags & SVDEF_FLAG_HASLOG){\n          if(which == SUBSV_MAIN){\n              /* set stdout to logpipe: */\n              close(1);\n              if(dup2(svdef->logpipe[1], 1) != 1){\n                  fatal_syserr(\"(in child for service \", svdef->name,\n                               \"): failure dup2() on logpipe[1] to logging service\");\n              }\n          }\n          if((which == SUBSV_LOG) && (target == SVRUN_START)){\n              /* set stdin to logpipe:\n              **   (but not if this is a resetting log service)\n              */\n              close(0);\n              if(dup2(svdef->logpipe[0], 0) != 0){\n                  fatal_syserr(\"(in child for service \", svdef->name,\n                               \"): failure dup2() on logpipe[0] for logging service\");\n              }\n          }\n          close(svdef->logpipe[0]);\n          close(svdef->logpipe[1]);\n      }\n      /* close extraneous descriptors (shouldn't be any!): */\n      for(i = 3; i < 1024; ++i) close(i);\n      /* set PERP_BASE in the environment: */\n      if(newenv_set(\"PERP_BASE\", basedir) == -1){\n          fatal_syserr(\"(in child for service \", svdef->name,\n                       \"): failure setting PERP_BASE environment for \",\n                       prog[0], \" \", prog[1]);\n      }\n      /* respawn governor: */\n      if((target == SVRUN_START) && !(tain_iszero(&towait))){\n          tain_pause(&towait, NULL);\n      }\n      /* clear signal handlers from child process: */\n      sig_uncatch(SIGCHLD);\n      sig_uncatch(SIGHUP);\n      sig_uncatch(SIGINT);\n      sig_uncatch(SIGTERM);\n      sig_uncatch(SIGPIPE);\n      sigset_unblock(&poll_sigset);\n      /* go forth my child: */\n      newenv_run(prog, environ);\n      /* nuts, exec failed: */\n      fatal_syserr(\"(in child for service \", svdef->name,\n                   \"):  failure execve()\");\n  }\n\n  /* parent: */\n  subsv->pid = pid;\n  /* set timestamps and respawn governor: */\n  tain_assign(&subsv->when, &now);\n  if(target == SVRUN_START){\n      /* when_ok = now + 1sec + wait: */ \n      tain_LOAD(&when_ok, 1, 0);\n      tain_plus(&when_ok, &now, &when_ok);\n      tain_plus(&when_ok, &when_ok, &towait);\n      tain_assign(&subsv->when_ok, &when_ok);\n  }\n\n  return 0;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* do_rlimfile()\n**   read RLIMIT_* values from rlimfile\n**   abort on failure\n*/\n", "func_signal": "static\nvoid\ndo_file(const char *rlimfile)", "code": "{\n  int         fd;\n  const char *source = rlimfile;\n  int         eof = 0;\n  ioq_t       q;\n  uchar_t     qbuf[IOQ_BUFSIZE];\n  dynstr_t    L = dynstr_INIT();\n  char       *line = NULL;\n  char       *key, *val;\n  size_t      split;\n  size_t      lineno = 0;\n  char        nbuf[NFMT_SIZE];\n  int         ndx;\n  int         r;\n\n  if(cstr_cmp(rlimfile, \"-\") == 0){\n      fd = 0;\n      source = \"<stdin>\";\n  } else {\n      fd = open(rlimfile, O_RDONLY | O_NONBLOCK);\n      if(fd == -1){\n          fatal_syserr(\"unable to open \", rlimfile);\n      }\n  }\n\n  ioq_init(&q, fd, qbuf, sizeof qbuf, &read); \n\n  while(!eof){ \n      /* recycle any allocated dynstr: */\n      dynstr_CLEAR(&L);\n\n      /* fetch next line: */\n      r = ioq_getln(&q, &L);\n      if(r == -1){\n          fatal_syserr(\"error reading \", source);\n      }\n      ++lineno;\n      if(r == 0){\n          /* set terminal condition: */\n          ++eof;\n          if((dynstr_STR(&L) == NULL) || (dynstr_LEN(&L) == 0)){\n              /* all done: */\n              break;\n          }\n          /* else:\n          ** eof was encountered after partial line read\n          ** (last line not terminated with '\\n')\n          ** proceed through the end of this loop \n          */\n      }\n\n      /* work directly on string buffer: */\n      line = dynstr_STR(&L);\n      cstr_trim(line);\n\n      /* skip empty lines and comments: */\n      if((line[0] == '\\0') || (line[0] == '#')){\n          continue;\n      }\n\n      /* parse line into key, value: */\n      key = line;\n      split = cstr_pos(key, '=');\n      if(key[split] == '='){\n          val = &line[split + 1];\n          key[split] = '\\0';\n          /* trim whitespace around '=': */\n          cstr_rtrim(key);\n          cstr_ltrim(val);\n      } else {\n          errno = EPROTO;\n          fatal_syserr(\"empty value or format error found in \", source,\n                       \", line \", nfmt_uint32(nbuf, (uint32_t)lineno));\n      }\n\n      /* skip empty key: */\n      if(key[0] == '\\0'){\n          continue;\n      }\n\n      /* setup resource: */\n      if((ndx = runlimit_ndx(key)) == -1){\n          errno = EPROTO;\n          /* fail on bogus resource name: */\n          fatal_syserr(\"unknown resource found in \", source,\n                       \", line \", nfmt_uint32(nbuf, (uint32_t)lineno),\n                       \": \", key);\n      }\n      /* else: */\n      runlimit_setup_ndx(ndx, val, source);\n  }\n \n  /* success: */\n  if(fd) close(fd);\n  return;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* ioq_putflush()\n**   flush internal buffer first, then write() data directly\n**   note: internal buffer will be empty on success\n*/\n", "func_signal": "int\nioq_putflush(ioq_t *ioq, const uchar_t *data, size_t len)", "code": "{\n  /* flush first: */\n  if(ioq_flush(ioq) == -1) return -1;\n\n  /* write() the rest */\n  return write_all(ioq->fd, (void *)data, len, ioq->op);\n}", "path": "lasagna\\ioq\\ioq_put.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* runlimit_ndx()\n**   lookup name in runlimits[]\n**   return:\n**    >= 0: index to match in runlimits[]\n**      -1: not found\n*/\n", "func_signal": "static\nint\nrunlimit_ndx(const char *name)", "code": "{\n  int  i;\n\n  for(i = 0; runlimits[i].name != NULL; ++i){\n      if(cstr_cmp(name, runlimits[i].name) == 0){\n          return i;\n      }\n  }\n\n  /* not found: */\n  return -1;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* do_environment()\n**   scan runlimits[] for matching keys in environment\n**   on found keys, set runlimit with runlimit_setup_ndx()\n*/\n", "func_signal": "static\nvoid\ndo_environment(void)", "code": "{\n  char  *val;\n  int    i;\n \n  for(i = 0; runlimits[i].name != NULL; ++i){\n      val = getenv(runlimits[i].name);\n      if(val != NULL){\n          runlimit_setup_ndx(i, val, \"environment\");\n      }\n  } \n\n  return;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* runlimit_setup_opt()\n**   set runlimit for name with arg, as given with option character opt\n**   abort on fail\n*/\n", "func_signal": "static\nvoid\nrunlimit_setup_opt(const char *name, const char *arg, char opt)", "code": "{\n  char           option[2] = {opt, '\\0'};\n  int            ndx, id;\n  struct rlimit  rlim;\n  char           nbuf[NFMT_SIZE];\n  uint32_t       u;\n  const char    *z;\n\n  ndx = runlimit_ndx(name);\n  if(ndx == -1){\n      /* shouldn't happen from command line! */\n      barf(name, \" is blaargh!\");\n  }\n\n  id = rlimit_lookup(name);\n  if(id == -1){\n      warn(\"option -\", option, \": resource \", name, \" not supported on this system\");\n      return;\n  }\n\n  if(getrlimit(id, &rlim) == -1){\n      fatal_syserr(\"option -\", option, \": failure getrlimit() for resource \", name);\n  }\n\n  runlimits[ndx].rl_hard = rlim.rlim_max;\n  if((arg[0] == '_') || (arg[0] == '^') || (arg[0] == '=')){\n      runlimits[ndx].rl_soft = rlim.rlim_max;\n  } else {\n      z = nuscan_uint32(&u, arg);\n      if(*z != '\\0'){\n          fatal_usage(\"option -\", option,\n                      \": non-numeric argument for resource \", name,\n                      \": \", arg);\n      }\n      if(u < rlim.rlim_max){\n          runlimits[ndx].rl_soft = (rlim_t)u;\n      } else {\n          warn(\"option -\", option,\n               \": truncating runlimit request for \", name,\n               \" to hard limit: \", nfmt_uint32(nbuf, (uint32_t)rlim.rlim_max));\n          runlimits[ndx].rl_soft = rlim.rlim_max;\n      }\n  }\n  runlimits[ndx].id = id;\n  ++runlimits[ndx].is_set;\n\n  return;\n}", "path": "runtools\\runlimit.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/*\n** ioq_put()\n**   append data of size len to internal buffer\n**   call ioq_flush() as necessary to handle all len bytes of data\n**   return\n**     0 : success, no error\n**    -1 : write() error, errno set\n*/\n", "func_signal": "int\nioq_put(ioq_t *ioq, const uchar_t *data, size_t len)", "code": "{\n  size_t  n = ioq->n;\n\n  if(len > (n - ioq->p)){\n      /* length of data exceeds space available in internal buffer */\n      /* flush current contents of buffer: */\n      if(ioq_flush(ioq) != 0){\n          return -1;\n      }\n      /* after ioq_flush(), ioq->p == 0 */\n      /* set up an efficient length for block write: */\n      if(n < IOQ_BUFSIZE) n = IOQ_BUFSIZE;\n\n      /* flush data directly until remainder will fit within internal ioq */\n      while(len > ioq->n){\n          /* don't write more than len! */\n          if(len < n) n = len;\n          if(write_all(ioq->fd, (void *)data, n, ioq->op) == -1){\n              /* write() error: */\n              return -1;\n          }\n          data += n;\n          len -= n;\n      }\n  }\n\n  /* now len < available space in ioq */\n  /* ie, len < (ioq->n - ioq->p) */\n  buf_copy(ioq->buf + ioq->p, data, len);\n  ioq->p += len;\n\n  return 0;\n}", "path": "lasagna\\ioq\\ioq_put.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perd_svdef_checkfail()\n**   in perpd_mainloop():\n**     if global flag_failing is set, called for each active svdef\n*/\n", "func_signal": "void\nperpd_svdef_checkfail(struct svdef *svdef)", "code": "{\n  struct subsv  *subsv;\n  int            target, r = 0;\n\n  /* insanity? */\n  if(!(svdef->bitflags & SVDEF_FLAG_ACTIVE))\n      return;\n\n  /* logic:\n  **   perpd_svdef_run() sets last attempted target for fork(), eg FLAG_ISRESET\n  **   if failing, retry that target\n  */\n\n  /* check log first: */\n  subsv = (svdef->bitflags & SVDEF_FLAG_HASLOG) ? &svdef->svpair[SUBSV_LOG] : NULL;\n  if((subsv != NULL) && (subsv->bitflags & SUBSV_FLAG_FAILING)){\n      target = (subsv->bitflags & SUBSV_FLAG_ISRESET) ? SVRUN_RESET : SVRUN_START;\n      r = perpd_svdef_run(svdef, SUBSV_LOG, target);\n  }\n\n  /* XXX, bail here if log is failing? */\n\n  /* main: */\n  subsv = &svdef->svpair[SUBSV_MAIN];  \n  if(subsv->bitflags & SUBSV_FLAG_FAILING){\n      target = (subsv->bitflags & SUBSV_FLAG_ISRESET) ? SVRUN_RESET : SVRUN_START;\n      perpd_svdef_run(svdef, SUBSV_MAIN, target);\n  }\n\n  return;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* hash function: */\n", "func_signal": "uint32_t\nhfunc_sax1(const uchar_t *key, size_t klen)", "code": "{\n  uint32_t   h = 0;\n\n  while(klen){\n      h ^= (h << 5) + (h >> 2)  + *key;\n      ++key; --klen;\n  }\n\n  return h;\n}", "path": "lasagna\\hfunc\\hfunc_sax1.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perpd_svdef_activate()\n**   activate service definition\n**   called by perpd_scan()\n**\n**   return:\n**     0: success\n**    -1: failure\n**\n**   notes:\n**     failures include:\n**       - service definition directory name too long\n**         (must me less than, say, 240 characters)\n**       - open() on service definition directory\n**       - pipe() for logpipe\n**     service is activated only on success\n*/\n", "func_signal": "int\nperpd_svdef_activate(struct svdef *svdef, const char *svdir, const struct stat *st_dir)", "code": "{\n  struct stat  st;\n  char         path_buf[256];\n  int          fd;\n\n  perpd_svdef_clear(svdef);\n\n  if(cstr_len(svdir) > 240){\n      errno = ENAMETOOLONG;\n      warn_syserr(\"service definition directory name error: \", svdir);\n      return -1;\n  }\n\n  svdef->dev = st_dir->st_dev;\n  svdef->ino = st_dir->st_ino;\n  cstr_lcpy(svdef->name, svdir, sizeof svdef->name);\n  tain_now(&svdef->when);\n  svdef->bitflags |= SVDEF_FLAG_ACTIVE;\n\n  /* open an fd to use for fchdir() in perpd_svrun(): */\n  cstr_vcopy(path_buf, \"./\", svdir);\n  if((fd = open(path_buf, O_RDONLY)) == -1){\n      warn_syserr(\"failure open() on service definition directory \", svdir);\n      return -1;\n  }\n  fd_cloexec(fd);\n  svdef->fd_dir = fd;\n\n  /* inspect service definition directory: */\n  cstr_vcopy(path_buf, \"./\", svdir, \"/flag.down\");\n  if(stat(path_buf, &st) != -1){\n      svdef->bitflags |= SVDEF_FLAG_DOWN;\n  }\n  cstr_vcopy(path_buf, \"./\", svdir, \"/flag.once\");\n  if(stat(path_buf, &st) != -1){\n      svdef->bitflags |= SVDEF_FLAG_ONCE;\n  }\n\n  /* logging? */\n  cstr_vcopy(path_buf, \"./\", svdir, \"/rc.log\");\n  if(stat(path_buf, &st) != -1){\n      if(st.st_mode & S_IXUSR){\n          svdef->bitflags |= SVDEF_FLAG_HASLOG;\n          log_debug(\"rc.log exists and is executable for \", svdir);\n      }else{\n          log_warning(\"rc.log exists but is not set executable for \", svdir);\n      }\n  }\n\n  /* setup logpipe: */\n  if(svdef->bitflags & SVDEF_FLAG_HASLOG){\n      if(pipe(svdef->logpipe) == -1){\n          warn_syserr(\"failure pipe() on logpipe for \", svdir);\n          close(fd);\n          return -1;\n      }\n      fd_cloexec(svdef->logpipe[0]);\n      fd_cloexec(svdef->logpipe[1]);\n  } \n\n  /*\n  ** from here on, the service is considered activated\n  */\n\n  /* first time startup: */\n  /* log: if FLAG_HASLOG, start irrespective of any other svdef->bitflags: */\n  if(svdef->bitflags & SVDEF_FLAG_HASLOG){\n      svdef->svpair[SUBSV_LOG].bitflags |= SUBSV_FLAG_ISLOG;\n      perpd_svdef_run(svdef, SUBSV_LOG, SVRUN_START);\n  }\n\n  /* XXX, bail here if log startup fails on fork() ?  */\n\n  /* main: */\n  if(!(svdef->bitflags & SVDEF_FLAG_DOWN)){\n      /* setup for running once? */\n      if(svdef->bitflags & SVDEF_FLAG_ONCE){\n          svdef->svpair[SUBSV_MAIN].bitflags |= SUBSV_FLAG_ISONCE;\n      }\n      perpd_svdef_run(svdef, SUBSV_MAIN, SVRUN_START);\n  } else {\n      svdef->svpair[SUBSV_MAIN].bitflags |= SUBSV_FLAG_WANTDOWN;\n  }\n \n  return 0;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* hash function: */\n", "func_signal": "uint32_t\nhfunc_rsuh(const uchar_t *key, size_t klen)", "code": "{\n  uint32_t   h = 0;\n  uint32_t   a = 31415U, b = 27183U;\n\n  while(klen){\n      h = (h * a) + *key;\n      a *= b;\n      ++key; --klen;\n  }\n\n  return h;\n}", "path": "lasagna\\hfunc\\hfunc_rsuh.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* perpd_svdef_keep()\n**   set this svdef as active\n**   called by perpd_scan()\n*/\n", "func_signal": "void\nperpd_svdef_keep(struct svdef *svdef, const char *svdir)", "code": "{\n  /* flag active: */\n  svdef->bitflags |= SVDEF_FLAG_ACTIVE;\n\n  /* possible name update: */\n  cstr_lcpy(svdef->name, svdir, sizeof svdef->name);\n\n  return;\n}", "path": "perp\\perpd_svdef.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* ioq_flush()\n**   dump internal buffer with write_all() to fd\n**   return:\n**     0 : success, no error\n**    -1 : write() error, errno set\n**\n**   note: on error, some bytes may have been written\n*/\n", "func_signal": "int\nioq_flush(ioq_t *ioq)", "code": "{\n  int to_write = ioq->p;\n\n  if(to_write == 0) return 0;\n  ioq->p = 0;\n\n  return write_all(ioq->fd, ioq->buf, to_write, ioq->op);\n}", "path": "lasagna\\ioq\\ioq_put.c", "repo_name": "wereHamster/perp", "stars": 10, "license": "other", "language": "c", "size": 568}
{"docstring": "/* For caching of stat() calls */\n", "func_signal": "extern fileStatus *eStat (const char *const fileName)", "code": "{\n\tstruct stat status;\n\tstatic fileStatus file;\n\tif (file.name == NULL  ||  strcmp (fileName, file.name) != 0)\n\t{\n\t\teStatFree (&file);\n\t\tfile.name = eStrdup (fileName);\n\t\tif (lstat (file.name, &status) != 0)\n\t\t\tfile.exists = FALSE;\n\t\telse\n\t\t{\n\t\t\tfile.isSymbolicLink = (boolean) S_ISLNK (status.st_mode);\n\t\t\tif (file.isSymbolicLink  &&  stat (file.name, &status) != 0)\n\t\t\t\tfile.exists = FALSE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfile.exists = TRUE;\n#ifdef AMIGA\n\t\t\t\tfile.isDirectory = isAmigaDirectory (file.name);\n#else\n\t\t\t\tfile.isDirectory = (boolean) S_ISDIR (status.st_mode);\n#endif\n\t\t\t\tfile.isNormalFile = (boolean) (S_ISREG (status.st_mode));\n\t\t\t\tfile.isExecutable = (boolean) ((status.st_mode &\n\t\t\t\t\t(S_IXUSR | S_IXGRP | S_IXOTH)) != 0);\n\t\t\t\tfile.isSetuid = (boolean) ((status.st_mode & S_ISUID) != 0);\n\t\t\t\tfile.size = status.st_size;\n\t\t\t}\n\t\t}\n\t}\n\treturn &file;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n*   Pseudo tag support\n*/\n", "func_signal": "static void rememberMaxLengths (const size_t nameLength, const size_t lineLength)", "code": "{\n\tif (nameLength > TagFile.max.tag)\n\t\tTagFile.max.tag = nameLength;\n\n\tif (lineLength > TagFile.max.line)\n\t\tTagFile.max.line = lineLength;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/* Return a newly-allocated string whose contents concatenate those of\n * s1, s2, s3.\n * Routine adapted from Gnu etags.\n */\n", "func_signal": "static char* concat (const char *s1, const char *s2, const char *s3)", "code": "{\n  int len1 = strlen (s1), len2 = strlen (s2), len3 = strlen (s3);\n  char *result = xMalloc (len1 + len2 + len3 + 1, char);\n\n  strcpy (result, s1);\n  strcpy (result + len1, s2);\n  strcpy (result + len1 + len2, s3);\n  result [len1 + len2 + len3] = '\\0';\n\n  return result;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Newly allocated string containing lower case conversion of a string.\n */\n", "func_signal": "extern char* newLowerString (const char* str)", "code": "{\n\tchar* const result = xMalloc (strlen (str) + 1, char);\n\tint i = 0;\n\tdo\n\t\tresult [i] = tolower ((int) str [i]);\n\twhile (str [i++] != '\\0');\n\treturn result;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "extern void freeRoutineResources (void)", "code": "{\n\tif (CurrentDirectory != NULL)\n\t\teFree (CurrentDirectory);\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Writes \"line\", stripping leading and duplicate white space.\n */\n", "func_signal": "static size_t writeCompactSourceLine (FILE *const fp, const char *const line)", "code": "{\n\tboolean lineStarted = FALSE;\n\tsize_t  length = 0;\n\tconst char *p;\n\tint c;\n#ifdef KANJI\n    int klen;\n    int ki;\n#endif\n\n\t/*  Write everything up to, but not including, the newline.\n\t */\n\tfor (p = line, c = *p  ;  c != NEWLINE  &&  c != '\\0'  ;  c = *++p)\n\t{\n\t\tif (lineStarted  || ! isspace (c))  /* ignore leading spaces */\n\t\t{\n\t\t\tlineStarted = TRUE;\n#ifdef KANJI\n\t\t\tif (klen = ISkanji(c))\n\t\t\t{\n\t\t\t\tfor (ki = 0; ki < klen; ki++)\t\n\t\t\t\t\tputc(*p++, fp);\n\t\t\t\t--p;\n\t\t\t\tlength += klen;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (isspace (c))\n\t\t\t{\n\t\t\t\tint next;\n\n\t\t\t\t/*  Consume repeating white space.\n\t\t\t\t */\n\t\t\t\twhile (next = *(p+1) , isspace (next)  &&  next != NEWLINE)\n\t\t\t\t\t++p;\n\t\t\t\tc = ' ';  /* force space character for any white space */\n\t\t\t}\n\t\t\tif (c != CRETURN  ||  *(p + 1) != NEWLINE)\n\t\t\t{\n\t\t\t\tputc (c, fp);\n\t\t\t\t++length;\n\t\t\t}\n\t\t}\n\t}\n\treturn length;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/* Return a newly allocated string containing the absolute file name of dir\n * where `file' resides given `CurrentDirectory'.\n * Routine adapted from Gnu etags.\n */\n", "func_signal": "extern char* absoluteDirname (char *file)", "code": "{\n\tchar *slashp, *res;\n\tchar save;\n\tslashp = strrchr (file, PATH_SEPARATOR);\n\tif (slashp == NULL)\n\t\tres = eStrdup (CurrentDirectory);\n\telse\n\t{\n\t\tsave = slashp [1];\n\t\tslashp [1] = '\\0';\n\t\tres = absoluteFilename (file);\n\t\tslashp [1] = save;\n\t}\n\treturn res;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/* When run with --c-kinds=+lp option demonstrates spurious tags for statement\n * following a label\n */\n", "func_signal": "static void label_forced_tags(void)", "code": "{\nlabel1:\n\tproto1(arg);\nlabel2:\n\tif (arg)\n\t\tproto2(arg);\nlabel3:\n\tvariable = 3;\n\twhile (condition) {\n\tlabel4:\n\t\tproto3(arg);\n\t}\n}", "path": "Test\\spurious_label_tags.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n *  Tag file management\n */\n", "func_signal": "static boolean isValidTagAddress (const char *const excmd)", "code": "{\n\tboolean isValid = FALSE;\n\n\tif (strchr (\"/?\", excmd [0]) != NULL)\n\t\tisValid = TRUE;\n\telse\n\t{\n\t\tchar *address = xMalloc (strlen (excmd) + 1, char);\n\t\tif (sscanf (excmd, \"%[^;\\n]\", address) == 1  &&\n\t\t\tstrspn (address,\"0123456789\") == strlen (address))\n\t\t\t\tisValid = TRUE;\n\t\teFree (address);\n\t}\n\treturn isValid;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Replacement for missing library function.\n */\n", "func_signal": "static int replacementTruncate (const char *const name, const long size)", "code": "{\n\tchar *tempName = NULL;\n\tFILE *fp = tempFile (\"w\", &tempName);\n\tfclose (fp);\n\tcopyFile (name, tempName, size);\n\tcopyFile (tempName, name, WHOLE_FILE);\n\tremove (tempName);\n\teFree (tempName);\n\n\treturn 0;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "static void installCobolRegex (const langType language)", "code": "{\n   addTagRegex (language, \"^[ \\t]*[0-9]+[ \\t]+([A-Z0-9][A-Z0-9-]*)[ \\t]+(BLANK|OCCURS|IS|JUST|PIC|REDEFINES|RENAMES|SIGN|SYNC|USAGE|VALUE)\",\n\t\t\"\\\\1\", \"d,data,data items\", \"i\");\n\taddTagRegex (language, \"^[ \\t]*[FSR]D[ \\t]+([A-Z0-9][A-Z0-9-]*)\\\\.\",\n\t\t\"\\\\1\", \"f,file,file descriptions (FD, SD, RD)\", \"i\");\n\taddTagRegex (language, \"^[ \\t]*[0-9]+[ \\t]+([A-Z0-9][A-Z0-9-]*)\\\\.\",\n\t\t\"\\\\1\", \"g,group,group items\", \"i\");\n\taddTagRegex (language, \"^[ \\t]*([A-Z0-9][A-Z0-9-]*)\\\\.\",\n\t\t\"\\\\1\", \"p,paragraph,paragraphs\", \"i\");\n\taddTagRegex (language, \"^[ \\t]*PROGRAM-ID\\\\.[ \\t]+([A-Z0-9][A-Z0-9-]*)\\\\.\",\n\t\t\"\\\\1\", \"P,program,program ids\", \"i\");\n\taddTagRegex (language, \"^[ \\t]*([A-Z0-9][A-Z0-9-]*)[ \\t]+SECTION\\\\.\",\n\t\t\"\\\\1\", \"s,section,sections\", \"i\");\n}", "path": "cobol.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Look through all line beginning with \"!_TAG_FILE\", and update those which\n *  require it.\n */\n", "func_signal": "static long unsigned int updatePseudoTags (FILE *const fp)", "code": "{\n\tenum { maxEntryLength = 20 };\n\tchar entry [maxEntryLength + 1];\n\tunsigned long linesRead = 0;\n\tfpos_t startOfLine;\n\tsize_t entryLength;\n\tconst char *line;\n\n\tsprintf (entry, \"%sTAG_FILE\", PSEUDO_TAG_PREFIX);\n\tentryLength = strlen (entry);\n\tAssert (entryLength < maxEntryLength);\n\n\tfgetpos (fp, &startOfLine);\n\tline = readLine (TagFile.vLine, fp);\n\twhile (line != NULL  &&  line [0] == entry [0])\n\t{\n\t\t++linesRead;\n\t\tif (strncmp (line, entry, entryLength) == 0)\n\t\t{\n\t\t\tchar tab, classType [16];\n\n\t\t\tif (sscanf (line + entryLength, \"%15s%c\", classType, &tab) == 2  &&\n\t\t\t\ttab == '\\t')\n\t\t\t{\n\t\t\t\tif (strcmp (classType, \"_SORTED\") == 0)\n\t\t\t\t\tupdateSortedFlag (line, fp, startOfLine);\n\t\t\t}\n\t\t\tfgetpos (fp, &startOfLine);\n\t\t}\n\t\tline = readLine (TagFile.vLine, fp);\n\t}\n\twhile (line != NULL)  /* skip to end of file */\n\t{\n\t\t++linesRead;\n\t\tline = readLine (TagFile.vLine, fp);\n\t}\n\treturn linesRead;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Truncates the text line containing the tag at the character following the\n *  tag, providing a character which designates the end of the tag.\n */\n", "func_signal": "static void truncateTagLine (\n\t\tchar *const line, const char *const token, const boolean discardNewline)", "code": "{\n\tchar *p = strstr (line, token);\n\n\tif (p != NULL)\n\t{\n\t\tp += strlen (token);\n\t\tif (*p != '\\0'  &&  ! (*p == '\\n'  &&  discardNewline))\n\t\t\t++p;    /* skip past character terminating character */\n\t\t*p = '\\0';\n\t}\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  This function copies the current line out to a specified file. It has no\n *  effect on the fileGetc () function.  During copying, any '\\' characters\n *  are doubled and a leading '^' or trailing '$' is also quoted. End of line\n *  characters (line feed or carriage return) are dropped.\n */\n", "func_signal": "static size_t writeSourceLine (FILE *const fp, const char *const line)", "code": "{\n\tsize_t length = 0;\n\tconst char *p;\n#ifdef KANJI\n    int klen;\n    int ki;\n#endif\n\n\t/*  Write everything up to, but not including, a line end character.\n\t */\n\tfor (p = line  ;  *p != '\\0'  ;  ++p)\n\t{\n\t\tconst int next = *(p + 1);\n\t\tconst int c = *p;\n\n\t\tif (c == CRETURN  ||  c == NEWLINE)\n\t\t\tbreak;\n\n#ifdef KANJI\n\t\tif (klen = ISkanji(c))\n\t\t{\n\t\t\tfor (ki = 0; ki < klen; ki++)\t\n\t\t\t\tputc(*p++, fp);\n\t\t\t--p;\n\t\t\tlength += klen;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/*  If character is '\\', or a terminal '$', then quote it.\n\t\t */\n\t\tif (c == BACKSLASH  ||  c == (Option.backward ? '?' : '/')  ||\n\t\t\t(c == '$'  &&  (next == NEWLINE  ||  next == CRETURN)))\n\t\t{\n\t\t\tputc (BACKSLASH, fp);\n\t\t\t++length;\n\t\t}\n\t\tputc (c, fp);\n\t\t++length;\n\t}\n\treturn length;\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n * Compare two strings, ignoring case.\n * Return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n * This makes a difference when one of the chars lies between upper and lower\n * ie. one of the chars [ \\ ] ^ _ ` for ascii. (The '_' in particular !)\n */\n", "func_signal": "extern int struppercmp (const char *s1, const char *s2)", "code": "{\n\tint result;\n\tdo\n\t{\n\t\tresult = toupper ((int) *s1) - toupper ((int) *s2);\n\t} while (result == 0  &&  *s1++ != '\\0'  &&  *s2++ != '\\0');\n\treturn result;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "static void findAspTags (void)", "code": "{\n\tvString *name = vStringNew ();\n\tconst unsigned char *line;\n\n\twhile ((line = fileReadLine ()) != NULL)\n\t{\n\t\tconst unsigned char *cp = line;\n\n\t\twhile (*cp != '\\0')\n\t\t{\n\t\t\t/* jump over whitespace */\n\t\t\twhile (isspace ((int)*cp))\n\t\t\t\tcp++;\n\n\t\t\t/* jump over strings */\n\t\t\tif (*cp == '\"')\n\t\t\t{\n\t\t\t\tcp++;\n\t\t\t\twhile (*cp!='\"' && *cp!='\\0')\n\t\t\t\t\tcp++;\n\t\t\t}\n\n\t\t\t/* jump over comments */ \n\t\t\telse if (*cp == '\\'')\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t/* jump over end function/sub lines */\n\t\t\telse if (strncasecmp ((const char*) cp, \"end\", (size_t) 3)== 0)\n\t\t\t{\n\t\t\t\tcp += 3;\n\t\t\t\tif (isspace ((int)*cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int)*cp))\n\t\t\t\t\t\t++cp;\n\n\t\t\t\t\tif (strncasecmp ((const char*) cp, \"function\", (size_t) 8) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcp+=8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (strncasecmp ((const char*) cp, \"sub\", (size_t) 3) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcp+=3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* jump over exit function/sub lines */\n\t\t\telse if (strncasecmp ((const char*) cp, \"exit\", (size_t) 4)==0)\n\t\t\t{\n\t\t\t\tcp += 4;\n\t\t\t\tif (isspace ((int) *cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t\t\t++cp;\n\n\t\t\t\t\tif (strncasecmp ((const char*) cp, \"function\", (size_t) 8) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcp+=8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (strncasecmp ((const char*) cp, \"sub\", (size_t) 3) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcp+=3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* function? */\n\t\t\telse if (strncasecmp ((const char*) cp, \"function\", (size_t) 8) == 0)\n\t\t\t{\n\t\t\t\tcp += 8;\n\n\t\t\t\tif (isspace ((int) *cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t\t\t++cp;\n\t\t\t\t\twhile (isalnum ((int) *cp)  ||  *cp == '_')\n\t\t\t\t\t{\n\t\t\t\t\t\tvStringPut (name, (int) *cp);\n\t\t\t\t\t\t++cp;\n\t\t\t\t\t}\n\t\t\t\t\tvStringTerminate (name);\n\t\t\t\t\tmakeSimpleTag (name, AspKinds, K_FUNCTION);\n\t\t\t\t\tvStringClear (name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* sub? */\n\t\t\telse if (strncasecmp ((const char*) cp, \"sub\", (size_t) 3) == 0)\n\t\t\t{\n\t\t\t\tcp += 3;\n\t\t\t\tif (isspace ((int) *cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t\t\t++cp;\n\t\t\t\t\twhile (isalnum ((int) *cp)  ||  *cp == '_')\n\t\t\t\t\t{\n\t\t\t\t\t\tvStringPut (name, (int) *cp);\n\t\t\t\t\t\t++cp;\n\t\t\t\t\t}\n\t\t\t\t\tvStringTerminate (name);\n\t\t\t\t\tmakeSimpleTag (name, AspKinds, K_SUB);\n\t\t\t\t\tvStringClear (name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* dim variable? */\n\t\t\telse if (strncasecmp ((const char*) cp, \"dim\", (size_t) 3) == 0)\n\t\t\t{\n\t\t\t\tcp += 3;\n\t\t\t\tif (isspace ((int) *cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t\t\t++cp;\n\t\t\t\t\twhile (isalnum ((int) *cp)  ||  *cp == '_')\n\t\t\t\t\t{\n\t\t\t\t\t\tvStringPut (name, (int) *cp);\n\t\t\t\t\t\t++cp;\n\t\t\t\t\t}\n\t\t\t\t\tvStringTerminate (name);\n\t\t\t\t\tmakeSimpleTag (name, AspKinds, K_DIM);\n\t\t\t\t\tvStringClear (name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* const declaration? */\n\t\t\telse if (strncasecmp ((const char*) cp, \"const\", (size_t) 5) == 0)\n\t\t\t{\n\t\t\t\tcp += 5;\n\t\t\t\tif (isspace ((int) *cp))\n\t\t\t\t{\n\t\t\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t\t\t++cp;\n\t\t\t\t\twhile (isalnum ((int) *cp)  ||  *cp == '_')\n\t\t\t\t\t{\n\t\t\t\t\t\tvStringPut (name, (int) *cp);\n\t\t\t\t\t\t++cp;\n\t\t\t\t\t}\n\t\t\t\t\tvStringTerminate (name);\n\t\t\t\t\tmakeSimpleTag (name, AspKinds, K_CONST);\n\t\t\t\t\tvStringClear (name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* nothing relevant */\n\t\t\telse if (*cp != '\\0')\n\t\t\t\tcp++;\n\t\t}\n\t}\n\tvStringDelete (name);\n}", "path": "asp.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "extern void freeTagFileResources (void)", "code": "{\n\tif (TagFile.directory != NULL)\n\t\teFree (TagFile.directory);\n\tvStringDelete (TagFile.vLine);\n}", "path": "entry.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*\n * File system functions\n */\n", "func_signal": "extern void setCurrentDirectory (void)", "code": "{\n#ifndef AMIGA\n\tchar* buf;\n#endif\n\tif (CurrentDirectory == NULL)\n\t\tCurrentDirectory = xMalloc ((size_t) (PATH_MAX + 1), char);\n#ifdef AMIGA\n\tstrcpy (CurrentDirectory, \".\");\n#else\n\tbuf = getcwd (CurrentDirectory, PATH_MAX);\n\tif (buf == NULL)\n\t\tperror (\"\");\n#endif\n\tif (CurrentDirectory [strlen (CurrentDirectory) - (size_t) 1] !=\n\t\t\tPATH_SEPARATOR)\n\t{\n\t\tsprintf (CurrentDirectory + strlen (CurrentDirectory), \"%c\",\n\t\t\t\tOUTPUT_PATH_SEPARATOR);\n\t}\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/*  Newly allocated string containing upper case conversion of a string.\n */\n", "func_signal": "extern char* newUpperString (const char* str)", "code": "{\n\tchar* const result = xMalloc (strlen (str) + 1, char);\n\tint i = 0;\n\tdo\n\t\tresult [i] = toupper ((int) str [i]);\n\twhile (str [i++] != '\\0');\n\treturn result;\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/* Return a newly allocated string containing the absolute file name of FILE\n * given CWD (which should end with a slash).\n * Routine adapted from Gnu etags.\n */\n", "func_signal": "extern char* absoluteFilename (const char *file)", "code": "{\n\tchar *slashp, *cp;\n\tchar *res = NULL;\n\tif (isAbsolutePath (file))\n\t{\n#ifdef MSDOS_STYLE_PATH\n\t\tif (file [1] == ':')\n\t\t\tres = eStrdup (file);\n\t\telse\n\t\t{\n\t\t\tchar drive [3];\n\t\t\tsprintf (drive, \"%c:\", currentdrive ());\n\t\t\tres = concat (drive, file, \"\");\n\t\t}\n#else\n\t\tres = eStrdup (file);\n#endif\n\t}\n\telse\n\t\tres = concat (CurrentDirectory, file, \"\");\n\n\t/* Delete the \"/dirname/..\" and \"/.\" substrings. */\n\tslashp = strchr (res, PATH_SEPARATOR);\n\twhile (slashp != NULL  &&  slashp [0] != '\\0')\n\t{\n\t\tif (slashp[1] == '.')\n\t\t{\n\t\t\tif (slashp [2] == '.' &&\n\t\t\t\t(slashp [3] == PATH_SEPARATOR || slashp [3] == '\\0'))\n\t\t\t{\n\t\t\t\tcp = slashp;\n\t\t\t\tdo\n\t\t\t\t\tcp--;\n\t\t\t\twhile (cp >= res  &&  ! isAbsolutePath (cp));\n\t\t\t\tif (cp < res)\n\t\t\t\t\tcp = slashp;/* the absolute name begins with \"/..\" */\n#ifdef MSDOS_STYLE_PATH\n\t\t\t\t/* Under MSDOS and NT we get `d:/NAME' as absolute file name,\n\t\t\t\t * so the luser could say `d:/../NAME'. We silently treat this\n\t\t\t\t * as `d:/NAME'.\n\t\t\t\t */\n\t\t\t\telse if (cp [0] != PATH_SEPARATOR)\n\t\t\t\t\tcp = slashp;\n#endif\n\t\t\t\tstrcpy (cp, slashp + 3);\n\t\t\t\tslashp = cp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (slashp [2] == PATH_SEPARATOR  ||  slashp [2] == '\\0')\n\t\t\t{\n\t\t\t\tstrcpy (slashp, slashp + 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tslashp = strchr (slashp + 1, PATH_SEPARATOR);\n\t}\n\n\tif (res [0] == '\\0')\n\t\treturn eStrdup (\"/\");\n\telse\n\t{\n#ifdef MSDOS_STYLE_PATH\n\t\t/* Canonicalize drive letter case. */\n\t\tif (res [1] == ':'  &&  islower (res [0]))\n\t\t\tres [0] = toupper (res [0]);\n#endif\n\n\t\treturn res;\n\t}\n}", "path": "routines.c", "repo_name": "splhack/ctags-objc-ja", "stars": 14, "license": "gpl-2.0", "language": "c", "size": 1718}
{"docstring": "/* read from the buffer that is filled with the get function */\n", "func_signal": "ssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos)", "code": "{\n\tstruct simple_attr *attr;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\n\tif (!attr->get)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*ppos) {\t\t/* continued read */\n\t\tsize = strlen(attr->get_buf);\n\t} else {\t\t/* first read */\n\t\tu64 val;\n\t\tret = attr->get(attr->data, &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\n\t\t\t\t attr->fmt, (unsigned long long)val);\n\t}\n\n\tret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static void capidtmf_goertzel_loop (long *buffer, long *coeffs, short *sample, long count)", "code": "{\n  int i, j;\n  long c, d, q0, q1, q2;\n\n  for (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT - 1; i++)\n  {\n    q1 = buffer[i];\n    q2 = buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\n    d = coeffs[i] >> 1;\n    c = d << 1;\n    if (c >= 0)\n    {\n      for (j = 0; j < count; j++)\n      {\n        q0 = sample[j] - q2 + (c * (q1 >> 16)) + (((dword)(((dword) d) * ((dword)(q1 & 0xffff)))) >> 15);\n        q2 = q1;\n        q1 = q0;\n      }\n    }\n    else\n    {\n      c = -c;\n      d = -d;\n      for (j = 0; j < count; j++)\n      {\n        q0 = sample[j] - q2 - ((c * (q1 >> 16)) + (((dword)(((dword) d) * ((dword)(q1 & 0xffff)))) >> 15));\n        q2 = q1;\n        q1 = q0;\n      }\n    }\n    buffer[i] = q1;\n    buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT] = q2;\n  }\n  q1 = buffer[i];\n  q2 = buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\n  c = (coeffs[i] >> 1) << 1;\n  if (c >= 0)\n  {\n    for (j = 0; j < count; j++)\n    {\n      q0 = sample[j] - q2 + (c * (q1 >> 16)) + (((dword)(((dword)(c >> 1)) * ((dword)(q1 & 0xffff)))) >> 15);\n      q2 = q1;\n      q1 = q0;\n      c -= CAPIDTMF_RECV_FUNDAMENTAL_DECREMENT;\n    }\n  }\n  else\n  {\n    c = -c;\n    for (j = 0; j < count; j++)\n    {\n      q0 = sample[j] - q2 - ((c * (q1 >> 16)) + (((dword)(((dword)(c >> 1)) * ((dword)(q1 & 0xffff)))) >> 15));\n      q2 = q1;\n      q1 = q0;\n      c += CAPIDTMF_RECV_FUNDAMENTAL_DECREMENT;\n    }\n  }\n  coeffs[i] = c;\n  buffer[i] = q1;\n  buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT] = q2;\n}", "path": "drivers\\isdn\\hardware\\eicon\\capidtmf.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * No need to abort pipes, as when this is called, all the children\n * has been disconnected and that has done it [through\n * usb_disable_interface() -> usb_disable_endpoint() ->\n * hwahc_op_ep_disable() - >rpipe_ep_disable()].\n */\n", "func_signal": "static void hwahc_op_stop(struct usb_hcd *usb_hcd)", "code": "{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\n\tmutex_lock(&wusbhc->mutex);\n\twusb_cluster_id_put(wusbhc->cluster_id);\n\tmutex_unlock(&wusbhc->mutex);\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/**\n * simple_read_from_buffer - copy data from the buffer to user space\n * @to: the user space buffer to read to\n * @count: the maximum number of bytes to read\n * @ppos: the current position in the buffer\n * @from: the buffer to read from\n * @available: the size of the buffer\n *\n * The simple_read_from_buffer() function reads up to @count bytes from the\n * buffer @from at offset @ppos into the user space address starting at @to.\n *\n * On success, the number of bytes read is returned and the offset @ppos is\n * advanced by this number, or negative value is returned on error.\n **/\n", "func_signal": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)", "code": "{\n\tloff_t pos = *ppos;\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tif (copy_to_user(to, from + pos, count))\n\t\treturn -EFAULT;\n\t*ppos = pos + count;\n\treturn count;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * FIXME should be wusbhc\n *\n * NOTE: we need to cache the Cluster ID because later...there is no\n *       way to get it :)\n */\n", "func_signal": "static int __hwahc_set_cluster_id(struct hwahc *hwahc, u8 cluster_id)", "code": "{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct device *dev = &wa->usb_iface->dev;\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_CLUSTER_ID,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tcluster_id,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, 1000 /* FIXME: arbitrary */);\n\tif (result < 0)\n\t\tdev_err(dev, \"Cannot set WUSB Cluster ID to 0x%02x: %d\\n\",\n\t\t\tcluster_id, result);\n\telse\n\t\twusbhc->cluster_id = cluster_id;\n\tdev_info(dev, \"Wireless USB Cluster ID set to 0x%02x\\n\", cluster_id);\n\treturn result;\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Get the Wire Adapter class-specific descriptor\n *\n * NOTE: this descriptor comes with the big bundled configuration\n *       descriptor that includes the interfaces' and endpoints', so\n *       we just look for it in the cached copy kept by the USB stack.\n *\n * NOTE2: We convert LE fields to CPU order.\n */\n", "func_signal": "static int wa_fill_descr(struct wahc *wa)", "code": "{\n\tint result;\n\tstruct device *dev = &wa->usb_iface->dev;\n\tchar *itr;\n\tstruct usb_device *usb_dev = wa->usb_dev;\n\tstruct usb_descriptor_header *hdr;\n\tstruct usb_wa_descriptor *wa_descr;\n\tsize_t itr_size, actconfig_idx;\n\n\tactconfig_idx = (usb_dev->actconfig - usb_dev->config) /\n\t\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[actconfig_idx];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\twhile (itr_size >= sizeof(*hdr)) {\n\t\thdr = (struct usb_descriptor_header *) itr;\n\t\tdev_dbg(dev, \"Extra device descriptor: \"\n\t\t\t\"type %02x/%u bytes @ %zu (%zu left)\\n\",\n\t\t\thdr->bDescriptorType, hdr->bLength,\n\t\t\t(itr - usb_dev->rawdescriptors[actconfig_idx]),\n\t\t\titr_size);\n\t\tif (hdr->bDescriptorType == USB_DT_WIRE_ADAPTER)\n\t\t\tgoto found;\n\t\titr += hdr->bLength;\n\t\titr_size -= hdr->bLength;\n\t}\n\tdev_err(dev, \"cannot find Wire Adapter Class descriptor\\n\");\n\treturn -ENODEV;\n\nfound:\n\tresult = -EINVAL;\n\tif (hdr->bLength > itr_size) {\t/* is it available? */\n\t\tdev_err(dev, \"incomplete Wire Adapter Class descriptor \"\n\t\t\t\"(%zu bytes left, %u needed)\\n\",\n\t\t\titr_size, hdr->bLength);\n\t\tgoto error;\n\t}\n\tif (hdr->bLength < sizeof(*wa->wa_descr)) {\n\t\tdev_err(dev, \"short Wire Adapter Class descriptor\\n\");\n\t\tgoto error;\n\t}\n\twa->wa_descr = wa_descr = (struct usb_wa_descriptor *) hdr;\n\t/* Make LE fields CPU order */\n\twa_descr->bcdWAVersion = le16_to_cpu(wa_descr->bcdWAVersion);\n\twa_descr->wNumRPipes = le16_to_cpu(wa_descr->wNumRPipes);\n\twa_descr->wRPipeMaxBlock = le16_to_cpu(wa_descr->wRPipeMaxBlock);\n\tif (wa_descr->bcdWAVersion > 0x0100)\n\t\tdev_warn(dev, \"Wire Adapter v%d.%d newer than groked v1.0\\n\",\n\t\t\t wa_descr->bcdWAVersion & 0xff00 >> 8,\n\t\t\t wa_descr->bcdWAVersion & 0x00ff);\n\tresult = 0;\nerror:\n\treturn result;\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Set host's GTK key\n */\n", "func_signal": "static int __hwahc_op_set_gtk(struct wusbhc *wusbhc, u32 tkid,\n\t\t\t      const void *key, size_t key_size)", "code": "{\n\tu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_GTK,\n\t\t\t\t    WUSB_KEY_INDEX_ORIGINATOR_HOST);\n\n\treturn __hwahc_dev_set_key(wusbhc, 0, tkid, key, key_size, key_idx);\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/**\n * generic_fh_to_dentry - generic helper for the fh_to_parent export operation\n * @sb:\t\tfilesystem to do the file handle conversion on\n * @fid:\tfile handle to convert\n * @fh_len:\tlength of the file handle in bytes\n * @fh_type:\ttype of file handle\n * @get_inode:\tfilesystem callback to retrieve inode\n *\n * This function decodes @fid as long as it has one of the well-known\n * Linux filehandle types and calls @get_inode on it to retrieve the\n * inode for the _parent_ object specified in the file handle if it\n * is specified in the file handle, or NULL otherwise.\n */\n", "func_signal": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))", "code": "{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Directory is locked and all positive dentries in it are safe, since\n * for ramfs-type trees they can't go away without unlink() or rmdir(),\n * both impossible due to the lock on directory.\n */\n", "func_signal": "int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)", "code": "{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct dentry *cursor = filp->private_data;\n\tstruct list_head *p, *q = &cursor->d_u.d_child;\n\tino_t ino;\n\tint i = filp->f_pos;\n\n\tswitch (i) {\n\t\tcase 0:\n\t\t\tino = dentry->d_inode->i_ino;\n\t\t\tif (filldir(dirent, \".\", 1, i, ino, DT_DIR) < 0)\n\t\t\t\tbreak;\n\t\t\tfilp->f_pos++;\n\t\t\ti++;\n\t\t\t/* fallthrough */\n\t\tcase 1:\n\t\t\tino = parent_ino(dentry);\n\t\t\tif (filldir(dirent, \"..\", 2, i, ino, DT_DIR) < 0)\n\t\t\t\tbreak;\n\t\t\tfilp->f_pos++;\n\t\t\ti++;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tspin_lock(&dcache_lock);\n\t\t\tif (filp->f_pos == 2)\n\t\t\t\tlist_move(q, &dentry->d_subdirs);\n\n\t\t\tfor (p=q->next; p != &dentry->d_subdirs; p=p->next) {\n\t\t\t\tstruct dentry *next;\n\t\t\t\tnext = list_entry(p, struct dentry, d_u.d_child);\n\t\t\t\tif (d_unhashed(next) || !next->d_inode)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tspin_unlock(&dcache_lock);\n\t\t\t\tif (filldir(dirent, next->d_name.name, \n\t\t\t\t\t    next->d_name.len, filp->f_pos, \n\t\t\t\t\t    next->d_inode->i_ino, \n\t\t\t\t\t    dt_type(next->d_inode)) < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tspin_lock(&dcache_lock);\n\t\t\t\t/* next is still alive */\n\t\t\t\tlist_move(q, p);\n\t\t\t\tp = q;\n\t\t\t\tfilp->f_pos++;\n\t\t\t}\n\t\t\tspin_unlock(&dcache_lock);\n\t}\n\treturn 0;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * FIXME: break this function up\n */\n", "func_signal": "static int hwahc_op_start(struct usb_hcd *usb_hcd)", "code": "{\n\tu8 addr;\n\tint result;\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\tresult = -ENOSPC;\n\tmutex_lock(&wusbhc->mutex);\n\taddr = wusb_cluster_id_get();\n\tif (addr == 0)\n\t\tgoto error_cluster_id_get;\n\tresult = __hwahc_set_cluster_id(hwahc, addr);\n\tif (result < 0)\n\t\tgoto error_set_cluster_id;\n\n\tusb_hcd->uses_new_polling = 1;\n\tusb_hcd->poll_rh = 1;\n\tusb_hcd->state = HC_STATE_RUNNING;\n\tresult = 0;\nout:\n\tmutex_unlock(&wusbhc->mutex);\n\treturn result;\n\nerror_set_cluster_id:\n\twusb_cluster_id_put(wusbhc->cluster_id);\nerror_cluster_id_get:\n\tgoto out;\n\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Set host's idea of which encryption (and key) method to use when\n * talking to ad evice on a given port.\n *\n * If key is NULL, it means disable encryption for that \"virtual port\"\n * (used when we disconnect).\n */\n", "func_signal": "static int __hwahc_dev_set_key(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\n\t\t\t       const void *key, size_t key_size,\n\t\t\t       u8 key_idx)", "code": "{\n\tint result = -ENOMEM;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tstruct usb_key_descriptor *keyd;\n\tsize_t keyd_len;\n\n\tkeyd_len = sizeof(*keyd) + key_size;\n\tkeyd = kzalloc(keyd_len, GFP_KERNEL);\n\tif (keyd == NULL)\n\t\treturn -ENOMEM;\n\n\tkeyd->bLength = keyd_len;\n\tkeyd->bDescriptorType = USB_DT_KEY;\n\tkeyd->tTKID[0] = (tkid >>  0) & 0xff;\n\tkeyd->tTKID[1] = (tkid >>  8) & 0xff;\n\tkeyd->tTKID[2] = (tkid >> 16) & 0xff;\n\tmemcpy(keyd->bKeyData, key, key_size);\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tUSB_REQ_SET_DESCRIPTOR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tUSB_DT_KEY << 8 | key_idx,\n\t\t\tport_idx << 8 | iface_no,\n\t\t\tkeyd, keyd_len, 1000 /* FIXME: arbitrary */);\n\n\tmemset(keyd, 0, sizeof(*keyd));\t/* clear keys etc. */\n\tkfree(keyd);\n\treturn result;\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Remove an IE to the host's MMC\n *\n * @handle:      See WUSB1.0[8.5.3.1]\n */\n", "func_signal": "static int __hwahc_op_mmcie_rm(struct wusbhc *wusbhc, u8 handle)", "code": "{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_REMOVE_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, handle << 8 | iface_no,\n\t\t\tNULL, 0, 1000 /* FIXME: arbitrary */);\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/**\n * memory_read_from_buffer - copy data from the buffer\n * @to: the kernel space buffer to read to\n * @count: the maximum number of bytes to read\n * @ppos: the current position in the buffer\n * @from: the buffer to read from\n * @available: the size of the buffer\n *\n * The memory_read_from_buffer() function reads up to @count bytes from the\n * buffer @from at offset @ppos into the kernel space address starting at @to.\n *\n * On success, the number of bytes read is returned and the offset @ppos is\n * advanced by this number, or negative value is returned on error.\n **/\n", "func_signal": "ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)", "code": "{\n\tloff_t pos = *ppos;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tmemcpy(to, from + pos, count);\n\t*ppos = pos + count;\n\n\treturn count;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/**\n * generic_fh_to_dentry - generic helper for the fh_to_dentry export operation\n * @sb:\t\tfilesystem to do the file handle conversion on\n * @fid:\tfile handle to convert\n * @fh_len:\tlength of the file handle in bytes\n * @fh_type:\ttype of file handle\n * @get_inode:\tfilesystem callback to retrieve inode\n *\n * This function decodes @fid as long as it has one of the well-known\n * Linux filehandle types and calls @get_inode on it to retrieve the\n * inode for the object specified in the file handle.\n */\n", "func_signal": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))", "code": "{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Add an IE to the host's MMC\n *\n * @interval:    See WUSB1.0[8.5.3.1]\n * @repeat_cnt:  See WUSB1.0[8.5.3.1]\n * @handle:      See WUSB1.0[8.5.3.1]\n * @wuie:        Pointer to the header of the WUSB IE data to add.\n *               MUST BE allocated in a kmalloc buffer (no stack or\n *               vmalloc).\n *\n * NOTE: the format of the WUSB IEs for MMCs are different to the\n *       normal MBOA MAC IEs (IE Id + Length in MBOA MAC vs. Length +\n *       Id in WUSB IEs). Standards...you gotta love'em.\n */\n", "func_signal": "static int __hwahc_op_mmcie_add(struct wusbhc *wusbhc, u8 interval,\n\t\t\t\tu8 repeat_cnt, u8 handle,\n\t\t\t\tstruct wuie_hdr *wuie)", "code": "{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_ADD_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tinterval << 8 | repeat_cnt,\n\t\t\thandle << 8 | iface_no,\n\t\t\twuie, wuie->bLength, 1000 /* FIXME: arbitrary */);\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Transaction based IO.\n * The file expects a single write which triggers the transaction, and then\n * possibly a read which collects the result - which is stored in a\n * file-local buffer.\n */\n", "func_signal": "char *simple_transaction_get(struct file *file, const char __user *buf, size_t size)", "code": "{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t/* only one write allowed per open */\n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Release resources allocated for an endpoint\n *\n * If there is an associated rpipe to this endpoint, go ahead and put it.\n */\n", "func_signal": "static void hwahc_op_endpoint_disable(struct usb_hcd *usb_hcd,\n\t\t\t\t      struct usb_host_endpoint *ep)", "code": "{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\trpipe_ep_disable(&hwahc->wa, ep);\n}", "path": "drivers\\usb\\host\\hwa-hc.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * Common helper for pseudo-filesystems (sockfs, pipefs, bdev - stuff that\n * will never be mountable)\n */\n", "func_signal": "int get_sb_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops, unsigned long magic,\n\tstruct vfsmount *mnt)", "code": "{\n\tstruct super_block *s = sget(fs_type, NULL, set_anon_super, NULL);\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = {.name = name, .len = strlen(name)};\n\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\ts->s_flags = MS_NOUSER;\n\ts->s_maxbytes = ~0ULL;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = d_alloc(NULL, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\tdentry->d_sb = s;\n\tdentry->d_parent = dentry;\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_flags |= MS_ACTIVE;\n\treturn simple_set_mnt(mnt, s);\n\nEnomem:\n\tup_write(&s->s_umount);\n\tdeactivate_super(s);\n\treturn -ENOMEM;\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * /dev/watchdog handling\n */\n", "func_signal": "static ssize_t fop_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)", "code": "{\n\t/* See if we got the magic character 'V' and reload the timer */\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t ofs;\n\n\t\t\t/* note: just in case someone wrote the magic character\n\t\t\t * five months ago... */\n\t\t\twdt_expect_close = 0;\n\n\t\t\t/* now scan */\n\t\t\tfor (ofs = 0; ofs != count; ofs++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + ofs))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\twdt_expect_close = 42;\n\t\t\t}\n\t\t}\n\t\t/* someone wrote to us, we should restart timer */\n\t\twdt_keepalive();\n\t}\n\treturn count;\n}", "path": "drivers\\watchdog\\alim7101_wdt.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/* simple_attr_open is called by an actual attribute open file operation\n * to set the attribute specific access operations. */\n", "func_signal": "int simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt)", "code": "{\n\tstruct simple_attr *attr;\n\n\tattr = kmalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tattr->get = get;\n\tattr->set = set;\n\tattr->data = inode->i_private;\n\tattr->fmt = fmt;\n\tmutex_init(&attr->mutex);\n\n\tfile->private_data = attr;\n\n\treturn nonseekable_open(inode, file);\n}", "path": "fs\\libfs.c", "repo_name": "drakaz/gaosp_kernel", "stars": 15, "license": "other", "language": "c", "size": 91808}
{"docstring": "/*\n * We calculate the wall-time slice from the period by taking a part\n * proportional to the weight.\n *\n * s = p*P[w/rw]\n */\n", "func_signal": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)", "code": "{\n\tu64 slice = __sched_period(cfs_rq->nr_running + !se->on_rq);\n\n\tfor_each_sched_entity(se) {\n\t\tstruct load_weight *load;\n\t\tstruct load_weight lw;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tload = &cfs_rq->load;\n\n\t\tif (unlikely(!se->on_rq)) {\n\t\t\tlw = cfs_rq->load;\n\n\t\t\tupdate_load_add(&lw, se->load.weight);\n\t\t\tload = &lw;\n\t\t}\n\t\tslice = calc_delta_mine(slice, se->load.weight, load);\n\t}\n\treturn slice;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*__LINSCHED__*/\n/*\n * delta /= w\n */\n", "func_signal": "static inline unsigned long\ncalc_delta_fair(unsigned long delta, struct sched_entity *se)", "code": "{\n\tif (unlikely(se->load.weight != NICE_0_LOAD))\n\t\tdelta = calc_delta_mine(delta, NICE_0_LOAD, &se->load);\n\n\treturn delta;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Enqueue an entity into the rb-tree:\n */\n", "func_signal": "static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)", "code": "{\n\tstruct rb_node **link = &cfs_rq->tasks_timeline.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_entity *entry;\n\ts64 key = entity_key(cfs_rq, se);\n\tint leftmost = 1;\n\n\t/*\n\t * Find the right place in the rbtree:\n\t */\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_entity, run_node);\n\t\t/*\n\t\t * We dont care about collisions. Nodes with\n\t\t * the same key stay together.\n\t\t */\n\t\tif (key < entity_key(cfs_rq, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Maintain a cache of leftmost tree entries (it is frequently\n\t * used):\n\t */\n\tif (leftmost)\n\t\tcfs_rq->rb_leftmost = &se->run_node;\n\n\trb_link_node(&se->run_node, parent, link);\n\trb_insert_color(&se->run_node, &cfs_rq->tasks_timeline);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Preempt the current task with a newly woken task if needed:\n */\n", "func_signal": "static void\ncheck_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)", "code": "{\n\tunsigned long ideal_runtime, delta_exec;\n\n\tideal_runtime = sched_slice(cfs_rq, curr);\n\tdelta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;\n\tif (delta_exec > ideal_runtime) {\n\t\tresched_task(rq_of(cfs_rq)->curr);\n\t\t/*\n\t\t * The current task ran long enough, ensure it doesn't get\n\t\t * re-elected due to buddy favours.\n\t\t */\n\t\tclear_buddies(cfs_rq, curr);\n\t}\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * sched_yield() support is very simple - we dequeue and enqueue.\n *\n * If compat_yield is turned on then we requeue to the end of the tree.\n */\n", "func_signal": "static void yield_task_fair(struct rq *rq)", "code": "{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *rightmost, *se = &curr->se;\n\n\t/*\n\t * Are we the only task in the tree?\n\t */\n\tif (unlikely(cfs_rq->nr_running == 1))\n\t\treturn;\n\n\tclear_buddies(cfs_rq, se);\n\n\tif (likely(!sysctl_sched_compat_yield) && curr->policy != SCHED_BATCH) {\n\t\tupdate_rq_clock(rq);\n\t\t/*\n\t\t * Update run-time statistics of the 'current'.\n\t\t */\n\t\tupdate_curr(cfs_rq);\n\n\t\treturn;\n\t}\n\t/*\n\t * Find the rightmost entry in the rbtree:\n\t */\n\trightmost = __pick_last_entity(cfs_rq);\n\t/*\n\t * Already in the rightmost position?\n\t */\n\tif (unlikely(!rightmost || entity_before(rightmost, se)))\n\t\treturn;\n\n\t/*\n\t * Minimally necessary key value to be last in the tree:\n\t * Upon rescheduling, sched_class::put_prev_task() will place\n\t * 'current' within the tree based on its new key value.\n\t */\n\tse->vruntime = rightmost->vruntime + 1;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/* Do the two (enqueued) entities belong to the same group ? */\n", "func_signal": "static inline int\nis_same_group(struct sched_entity *se, struct sched_entity *pse)", "code": "{\n\tif (se->cfs_rq == pse->cfs_rq)\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * find_idlest_group finds and returns the least busy CPU group within the\n * domain.\n */\n", "func_signal": "static struct sched_group *\nfind_idlest_group(struct sched_domain *sd, struct task_struct *p,\n\t\t  int this_cpu, int load_idx)", "code": "{\n\tstruct sched_group *idlest = NULL, *this = NULL, *group = sd->groups;\n\tunsigned long min_load = ULONG_MAX, this_load = 0;\n\tint imbalance = 100 + (sd->imbalance_pct-100)/2;\n\n\tdo {\n\t\tunsigned long load, avg_load;\n\t\tint local_group;\n\t\tint i;\n\n\t\t/* Skip over this group if it has no CPUs allowed */\n\t\tif (!cpumask_intersects(sched_group_cpus(group),\n\t\t\t\t\t&p->cpus_allowed))\n\t\t\tcontinue;\n\n\t\tlocal_group = cpumask_test_cpu(this_cpu,\n\t\t\t\t\t       sched_group_cpus(group));\n\n\t\t/* Tally up the load of all CPUs in the group */\n\t\tavg_load = 0;\n\n\t\tfor_each_cpu(i, sched_group_cpus(group)) {\n\t\t\t/* Bias balancing toward cpus of our domain */\n\t\t\tif (local_group)\n\t\t\t\tload = source_load(i, load_idx);\n\t\t\telse\n\t\t\t\tload = target_load(i, load_idx);\n\n\t\t\tavg_load += load;\n\t\t}\n\n\t\t/* Adjust by relative CPU power of the group */\n\t\tavg_load = (avg_load * SCHED_LOAD_SCALE) / group->cpu_power;\n\n\t\tif (local_group) {\n\t\t\tthis_load = avg_load;\n\t\t\tthis = group;\n\t\t} else if (avg_load < min_load) {\n\t\t\tmin_load = avg_load;\n\t\t\tidlest = group;\n\t\t}\n\t} while (group = group->next, group != sd->groups);\n\n\tif (!idlest || 100*this_load < imbalance*min_load)\n\t\treturn NULL;\n\treturn idlest;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Task is being enqueued - update stats:\n */\n", "func_signal": "static void update_stats_enqueue(struct cfs_rq *cfs_rq, struct sched_entity *se)", "code": "{\n\t/*\n\t * Are we enqueueing a waiting task? (for current tasks\n\t * a dequeue/enqueue event is a NOP)\n\t */\n\tif (se != cfs_rq->curr)\n\t\tupdate_stats_wait_start(cfs_rq, se);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Share the fairness runtime between parent and child, thus the\n * total amount of pressure for CPU stays equal - new tasks\n * get a chance to run but frequent forkers are not allowed to\n * monopolize the CPU. Note: the parent runqueue is locked,\n * the child is not running yet.\n */\n", "func_signal": "static void task_new_fair(struct rq *rq, struct task_struct *p)", "code": "{\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(p);\n\tstruct sched_entity *se = &p->se, *curr = cfs_rq->curr;\n\tint this_cpu = smp_processor_id();\n\n\tsched_info_queued(p);\n\n\tupdate_curr(cfs_rq);\n\tif (curr)\n\t\tse->vruntime = curr->vruntime;\n\tplace_entity(cfs_rq, se, 1);\n\n\t/* 'curr' will be NULL if the child belongs to a different group */\n\tif (sysctl_sched_child_runs_first && this_cpu == task_cpu(p) &&\n\t\t\tcurr && entity_before(curr, se)) {\n\t\t/*\n\t\t * Upon rescheduling, sched_class::put_prev_task() will place\n\t\t * 'current' within the tree based on its new key value.\n\t\t */\n\t\tswap(curr->vruntime, se->vruntime);\n\t\tresched_task(rq->curr);\n\t}\n\n\tenqueue_task_fair(rq, p, 0);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * The enqueue_task method is called before nr_running is\n * increased. Here we update the fair scheduling stats and\n * then put the task into the rbtree:\n */\n", "func_signal": "static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int wakeup)", "code": "{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se;\n\n\tfor_each_sched_entity(se) {\n\t\tif (se->on_rq)\n\t\t\tbreak;\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tenqueue_entity(cfs_rq, se, wakeup);\n\t\twakeup = 1;\n\t}\n\n\thrtick_update(rq);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * sched_balance_self: balance the current task (running on cpu) in domains\n * that have the 'flag' flag set. In practice, this is SD_BALANCE_FORK and\n * SD_BALANCE_EXEC.\n *\n * Balance, ie. select the least loaded group.\n *\n * Returns the target CPU number, or the same CPU if no balancing is needed.\n *\n * preempt must be disabled.\n */\n", "func_signal": "static int select_task_rq_fair(struct task_struct *p, int sd_flag, int wake_flags)", "code": "{\n\tstruct sched_domain *tmp, *affine_sd = NULL, *sd = NULL;\n\tint cpu = smp_processor_id();\n\tint prev_cpu = task_cpu(p);\n\tint new_cpu = cpu;\n\tint want_affine = 0;\n\tint want_sd = 1;\n\tint sync = wake_flags & WF_SYNC;\n\n\tif (sd_flag & SD_BALANCE_WAKE) {\n\t\tif (sched_feat(AFFINE_WAKEUPS) &&\n\t\t    cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\t\twant_affine = 1;\n\t\tnew_cpu = prev_cpu;\n\t}\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, tmp) {\n\t\t/*\n\t\t * If power savings logic is enabled for a domain, see if we\n\t\t * are not overloaded, if so, don't balance wider.\n\t\t */\n\t\tif (tmp->flags & (SD_POWERSAVINGS_BALANCE|SD_PREFER_LOCAL)) {\n\t\t\tunsigned long power = 0;\n\t\t\tunsigned long nr_running = 0;\n\t\t\tunsigned long capacity;\n\t\t\tint i;\n\n\t\t\tfor_each_cpu(i, sched_domain_span(tmp)) {\n\t\t\t\tpower += power_of(i);\n\t\t\t\tnr_running += cpu_rq(i)->cfs.nr_running;\n\t\t\t}\n\n\t\t\tcapacity = DIV_ROUND_CLOSEST(power, SCHED_LOAD_SCALE);\n\n\t\t\tif (tmp->flags & SD_POWERSAVINGS_BALANCE)\n\t\t\t\tnr_running /= 2;\n\n\t\t\tif (nr_running < capacity)\n\t\t\t\twant_sd = 0;\n\t\t}\n\n\t\tif (want_affine && (tmp->flags & SD_WAKE_AFFINE) &&\n\t\t    cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))) {\n\n\t\t\taffine_sd = tmp;\n\t\t\twant_affine = 0;\n\t\t}\n\n\t\tif (!want_sd && !want_affine)\n\t\t\tbreak;\n\n\t\tif (!(tmp->flags & sd_flag))\n\t\t\tcontinue;\n\n\t\tif (want_sd)\n\t\t\tsd = tmp;\n\t}\n\n\tif (sched_feat(LB_SHARES_UPDATE)) {\n\t\t/*\n\t\t * Pick the largest domain to update shares over\n\t\t */\n\t\ttmp = sd;\n\t\tif (affine_sd && (!tmp ||\n\t\t\t\t  cpumask_weight(sched_domain_span(affine_sd)) >\n\t\t\t\t  cpumask_weight(sched_domain_span(sd))))\n\t\t\ttmp = affine_sd;\n\n\t\tif (tmp)\n\t\t\tupdate_shares(tmp);\n\t}\n\n\tif (affine_sd && wake_affine(affine_sd, p, sync)) {\n\t\tnew_cpu = cpu;\n\t\tgoto out;\n\t}\n\n\twhile (sd) {\n\t\tint load_idx = sd->forkexec_idx;\n\t\tstruct sched_group *group;\n\t\tint weight;\n\n\t\tif (!(sd->flags & sd_flag)) {\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sd_flag & SD_BALANCE_WAKE)\n\t\t\tload_idx = sd->wake_idx;\n\n\t\tgroup = find_idlest_group(sd, p, cpu, load_idx);\n\t\tif (!group) {\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_cpu = find_idlest_cpu(group, p, cpu);\n\t\tif (new_cpu == -1 || new_cpu == cpu) {\n\t\t\t/* Now try balancing at a lower domain level of cpu */\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Now try balancing at a lower domain level of new_cpu */\n\t\tcpu = new_cpu;\n\t\tweight = cpumask_weight(sched_domain_span(sd));\n\t\tsd = NULL;\n\t\tfor_each_domain(cpu, tmp) {\n\t\t\tif (weight <= cpumask_weight(sched_domain_span(tmp)))\n\t\t\t\tbreak;\n\t\t\tif (tmp->flags & sd_flag)\n\t\t\t\tsd = tmp;\n\t\t}\n\t\t/* while loop will break here if sd == NULL */\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn new_cpu;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Account for a descheduled task:\n */\n", "func_signal": "static void put_prev_task_fair(struct rq *rq, struct task_struct *prev)", "code": "{\n\tstruct sched_entity *se = &prev->se;\n\tstruct cfs_rq *cfs_rq;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tput_prev_entity(cfs_rq, se);\n\t}\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * find_idlest_cpu - find the idlest cpu among the cpus in group.\n */\n", "func_signal": "static int\nfind_idlest_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)", "code": "{\n\tunsigned long load, min_load = ULONG_MAX;\n\tint idlest = -1;\n\tint i;\n\n\t/* Traverse only the allowed CPUs */\n\tfor_each_cpu_and(i, sched_group_cpus(group), &p->cpus_allowed) {\n\t\tload = weighted_cpuload(i);\n\n\t\tif (load < min_load || (load == min_load && i == this_cpu)) {\n\t\t\tmin_load = load;\n\t\t\tidlest = i;\n\t\t}\n\t}\n\n\treturn idlest;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/**************************************************************\n * Scheduling class tree data structure manipulation methods:\n */\n", "func_signal": "static inline u64 max_vruntime(u64 min_vruntime, u64 vruntime)", "code": "{\n\ts64 delta = (s64)(vruntime - min_vruntime);\n\tif (delta > 0)\n\t\tmin_vruntime = vruntime;\n\n\treturn min_vruntime;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * We switched to the sched_fair class.\n */\n", "func_signal": "static void switched_to_fair(struct rq *rq, struct task_struct *p,\n\t\t\t     int running)", "code": "{\n\t/*\n\t * We were most likely switched from sched_rt, so\n\t * kick off the schedule if running, otherwise just see\n\t * if we can still preempt the current task.\n\t */\n\tif (running)\n\t\tresched_task(rq->curr);\n\telse\n\t\tcheck_preempt_curr(rq, p, 0);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * Load-balancing iterator. Note: while the runqueue stays locked\n * during the whole iteration, the current task might be\n * dequeued so the iterator has to be dequeue-safe. Here we\n * achieve that by always pre-iterating before returning\n * the current task:\n */\n", "func_signal": "static struct task_struct *\n__load_balance_iterator(struct cfs_rq *cfs_rq, struct list_head *next)", "code": "{\n\tstruct task_struct *p = NULL;\n\tstruct sched_entity *se;\n\n\tif (next == &cfs_rq->tasks)\n\t\treturn NULL;\n\n\tse = list_entry(next, struct sched_entity, group_node);\n\tp = task_of(se);\n\tcfs_rq->balance_iterator = next->next;\n\n\treturn p;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * scheduler tick hitting a task of our scheduling class:\n */\n", "func_signal": "static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)", "code": "{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &curr->se;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tentity_tick(cfs_rq, se, queued);\n\t}\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * The dequeue_task method is called before nr_running is\n * decreased. We remove the task from the rbtree and\n * update the fair scheduling stats:\n */\n", "func_signal": "static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int sleep)", "code": "{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tdequeue_entity(cfs_rq, se, sleep);\n\t\t/* Don't dequeue parent if it has other entities besides us */\n\t\tif (cfs_rq->load.weight)\n\t\t\tbreak;\n\t\tsleep = 1;\n\t}\n\n\thrtick_update(rq);\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/* return depth at which a sched entity is present in the hierarchy */\n", "func_signal": "static inline int depth_se(struct sched_entity *se)", "code": "{\n\tint depth = 0;\n\n\tfor_each_sched_entity(se)\n\t\tdepth++;\n\n\treturn depth;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "/*\n * effective_load() calculates the load change as seen from the root_task_group\n *\n * Adding load to a group doesn't make a group heavier, but can cause movement\n * of group shares between cpus. Assuming the shares were perfectly aligned one\n * can calculate the shift in shares.\n *\n * The problem is that perfectly aligning the shares is rather expensive, hence\n * we try to avoid doing that too often - see update_shares(), which ratelimits\n * this change.\n *\n * We compensate this by not only taking the current delta into account, but\n * also considering the delta between when the shares were last adjusted and\n * now.\n *\n * We still saw a performance dip, some tracing learned us that between\n * cgroup:/ and cgroup:/foo balancing the number of affine wakeups increased\n * significantly. Therefore try to bias the error in direction of failing\n * the affine wakeup.\n *\n */\n", "func_signal": "static long effective_load(struct task_group *tg, int cpu,\n\t\tlong wl, long wg)", "code": "{\n\tstruct sched_entity *se = tg->se[cpu];\n\n\tif (!tg->parent)\n\t\treturn wl;\n\n\t/*\n\t * By not taking the decrease of shares on the other cpu into\n\t * account our error leans towards reducing the affine wakeups.\n\t */\n\tif (!wl && sched_feat(ASYM_EFF_LOAD))\n\t\treturn wl;\n\n\tfor_each_sched_entity(se) {\n\t\tlong S, rw, s, a, b;\n\t\tlong more_w;\n\n\t\t/*\n\t\t * Instead of using this increment, also add the difference\n\t\t * between when the shares were last updated and now.\n\t\t */\n\t\tmore_w = se->my_q->load.weight - se->my_q->rq_weight;\n\t\twl += more_w;\n\t\twg += more_w;\n\n\t\tS = se->my_q->tg->shares;\n\t\ts = se->my_q->shares;\n\t\trw = se->my_q->rq_weight;\n\n\t\ta = S*(rw + wl);\n\t\tb = S*rw + s*wg;\n\n\t\twl = s*(a-b);\n\n\t\tif (likely(b))\n\t\t\twl /= b;\n\n\t\t/*\n\t\t * Assume the group is already running and will\n\t\t * thus already be accounted for in the weight.\n\t\t *\n\t\t * That is, moving shares between CPUs, does not\n\t\t * alter the group weight.\n\t\t */\n\t\twg = 0;\n\t}\n\n\treturn wl;\n}", "path": "linux-2.6.32-rc3\\kernel\\sched_fair.c", "repo_name": "jontore/LinSched", "stars": 12, "license": "None", "language": "c", "size": 3068}
{"docstring": "// Rotate A left dropping MSB in favor fo F carry\n", "func_signal": "static void OP_RAL(Intel8080 *cpu)", "code": "{\n    uint8_t carry_in   = (*cpu->F) &   1 ? 1 : 0; // check carry flag\n    uint8_t carry_out  = (*cpu->A) & 128 ? 1 : 0; // check msb of A\n\n    *cpu->A = ((*cpu->A) << 1) + carry_in;\n    *cpu->F = ((*cpu->F) & ~1) | carry_out; // set new carry\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Destructor -----------------------------------------------------------------\n// ----------------------------------------------------------------------------\n", "func_signal": "static void cpu_destroy(Intel8080 **cpu)", "code": "{\n    free(*cpu);\n    *cpu = NULL;\n}", "path": "Intel8080\\Cpu.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Halt\n", "func_signal": "static void OP_HLT(Intel8080 *cpu)", "code": "{ \n    cpu->halt = 1;\n    (*cpu->PC)--;\n}", "path": "Intel8080\\base.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add contents of (HL) to A\n", "func_signal": "static void OP_ADD_M(Intel8080 *cpu)", "code": "{ \\\n    uint16_t i = *cpu->A + cpu->read_mem(*cpu->HL);\n    *cpu->A = i & 0xff; // mask to 255\n    cpu_flag_szap(cpu, cpu->A); // check flags\n    *cpu->F |= i > 0xff; // set carry flag\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// OR A with contents of (HL)\n", "func_signal": "static void OP_ORA_M(Intel8080 *cpu)", "code": "{\n    *cpu->A |= cpu->read_mem(*cpu->HL); \\\n    cpu_flag_szp(cpu, cpu->A); \\\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Exchange Top of Stack with HL\n// Swap H with (SP +1) / L with (SP)\n", "func_signal": "static void OP_XTHL(Intel8080 *cpu)", "code": "{\n    uint8_t h = *cpu->H;\n    uint8_t l = *cpu->L;\n\n    *cpu->H = cpu->read_mem((*cpu->SP) + 1);\n    *cpu->L = cpu->read_mem((*cpu->SP));\n    \n    cpu->write_mem(*cpu->SP + 1, h);\n    cpu->write_mem(*cpu->SP, l);\n}", "path": "Intel8080\\stack.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Compare A with next BYTE\n", "func_signal": "static void OP_CPI(Intel8080 *cpu)", "code": "{\n    int16_t i = *cpu->A - cpu->read_mem(*cpu->PC);\n    *cpu->A = i & 0xff;\n    cpu_flag_szp(cpu, cpu->A);\n    *cpu->F |= i < 0;\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add (contents of (HL) + carry) to A\n", "func_signal": "static void OP_ADC_M(Intel8080 *cpu)", "code": "{\n    uint16_t i = (*cpu->A + cpu->read_mem(*cpu->HL)) + (*cpu->F & 1);\n    *cpu->A = i & 0xff; // mask to 255\n    cpu_flag_szap(cpu, cpu->A); // check flags\n    *cpu->F |= i > 0xff; // set carry flag\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// XOR A with next BYTE\n", "func_signal": "static void OP_XRI(Intel8080 *cpu)", "code": "{\n    *cpu->A ^= cpu->read_mem(*cpu->PC); \\\n    cpu_flag_szp(cpu, cpu->A); \\\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Rotate A right ignoring F carry\n", "func_signal": "static void OP_RRC(Intel8080 *cpu)", "code": "{\n    uint8_t carry_in   = (*cpu->A) & 1 ? 128 : 0; // check for msb of A\n    uint8_t carry_out  = (*cpu->A) & 1 ?   1 : 0; // check for lsb of A\n\n    *cpu->A = ((*cpu->A) >> 1) + carry_in;\n    *cpu->F = ((*cpu->F) & ~1) | carry_out; // set new carry\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// OR A with next BYTE\n", "func_signal": "static void OP_ORI(Intel8080 *cpu)", "code": "{\n    *cpu->A |= cpu->read_mem(*cpu->PC); \\\n    cpu_flag_szp(cpu, cpu->A); \\\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Exectute a given number of cycles ------------------------------------------\n// ----------------------------------------------------------------------------\n", "func_signal": "static unsigned long cpu_exec(Intel8080 *cpu, unsigned long cycles)", "code": "{\n\n    unsigned long old_cycle_count = cpu->cycle_count;\n    uint8_t inst = 0;\n    while(cpu->cycle_count - old_cycle_count < cycles) {\n\n        // Fetch instruction and increase PC\n        inst = cpu->read_mem((*cpu->PC)++);\n\n        // Call op code function\n        op_code_table(cpu, inst);\n        \n    }\n    \n    cpu->instruction = inst;\n    return cpu->cycle_count - old_cycle_count;\n\n}", "path": "Intel8080\\Cpu.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add BC to HL\n", "func_signal": "static void OP_DAD_B(Intel8080 *cpu)", "code": "{\n    uint32_t i = *cpu->HL + *cpu->BC;\n    *cpu->F = i > 0xffff; // Carry is bit 1, so this clears and sets correctly\n    *cpu->HL = (i & 0xffff);\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add next (BYTE + carry) to A\n", "func_signal": "static void OP_ACI(Intel8080 *cpu)", "code": "{\n    uint16_t i = *cpu->A + cpu->read_mem(*cpu->PC) + (*cpu->F & 1);\n    *cpu->A = i & 0xff;\n    cpu_flag_szap(cpu, cpu->A);\n    *cpu->F |= i > 0xff;\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Increment contents of (HL)\n", "func_signal": "static void OP_INR_M(Intel8080 *cpu)", "code": "{\n    uint8_t i = cpu->read_mem(*cpu->HL) + 1;\n    cpu->write_mem(*cpu->HL, i);\n    cpu_flag_szap(cpu, &i);\n}", "path": "Intel8080\\reg.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add DE to HL\n", "func_signal": "static void OP_DAD_D(Intel8080 *cpu)", "code": "{\n    uint32_t i = *cpu->HL + *cpu->DE;\n    *cpu->F = i > 0xffff;\n    *cpu->HL = (i & 0xffff);\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Compare A with (HL)\n", "func_signal": "static void OP_CMP_M(Intel8080 *cpu)", "code": "{ \\\n    int16_t i = *cpu->A - cpu->read_mem(*cpu->HL);\n    *cpu->A = i & 0xff;\n    cpu_flag_szp(cpu, cpu->A);\n    *cpu->F |= i < 0;\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Reset the CPU --------------------------------------------------------------\n// ----------------------------------------------------------------------------\n", "func_signal": "static void cpu_reset(Intel8080 *cpu)", "code": "{\n\n    // Registers\n    *cpu->PSW = 0;\n    *cpu->BC = 0;\n    *cpu->DE = 0;\n    *cpu->HL = 0;\n\n    *cpu->SP = *cpu->stack_top;\n    *cpu->PC = 0;\n\n    // State info\n    cpu->instruction = 0;\n    cpu->cycle_count = 0;\n    cpu->ime = 0;\n\n    // Pins\n    cpu->halt = 0;\n    \n}", "path": "Intel8080\\Cpu.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// XOR A with contents of (HL)\n", "func_signal": "static void OP_XRA_M(Intel8080 *cpu)", "code": "{\n    *cpu->A ^= cpu->read_mem(*cpu->HL); \\\n    cpu_flag_szp(cpu, cpu->A); \\\n}", "path": "Intel8080\\bit.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "// Add next BYTE to A\n", "func_signal": "static void OP_ADI(Intel8080 *cpu)", "code": "{\n    uint16_t i = *cpu->A + cpu->read_mem(*cpu->PC);\n    *cpu->A = i & 0xff;\n    cpu_flag_szap(cpu, cpu->A);\n    *cpu->F |= i > 0xff;\n}", "path": "Intel8080\\math.c", "repo_name": "BonsaiDen/I8080", "stars": 9, "license": "None", "language": "c", "size": 301}
{"docstring": "/*\n * Translates old vtx IOCTLs to new ones\n *\n * This keeps new kernel versions compatible with old userspace programs.\n */\n", "func_signal": "static inline unsigned int vtx_fix_command(unsigned int cmd)", "code": "{\n\tswitch (cmd) {\n\tcase VTXIOCGETINFO_OLD:\n\t\tcmd = VTXIOCGETINFO;\n\t\tbreak;\n\tcase VTXIOCCLRPAGE_OLD:\n\t\tcmd = VTXIOCCLRPAGE;\n\t\tbreak;\n\tcase VTXIOCCLRFOUND_OLD:\n\t\tcmd = VTXIOCCLRFOUND;\n\t\tbreak;\n\tcase VTXIOCPAGEREQ_OLD:\n\t\tcmd = VTXIOCPAGEREQ;\n\t\tbreak;\n\tcase VTXIOCGETSTAT_OLD:\n\t\tcmd = VTXIOCGETSTAT;\n\t\tbreak;\n\tcase VTXIOCGETPAGE_OLD:\n\t\tcmd = VTXIOCGETPAGE;\n\t\tbreak;\n\tcase VTXIOCSTOPDAU_OLD:\n\t\tcmd = VTXIOCSTOPDAU;\n\t\tbreak;\n\tcase VTXIOCPUTPAGE_OLD:\n\t\tcmd = VTXIOCPUTPAGE;\n\t\tbreak;\n\tcase VTXIOCSETDISP_OLD:\n\t\tcmd = VTXIOCSETDISP;\n\t\tbreak;\n\tcase VTXIOCPUTSTAT_OLD:\n\t\tcmd = VTXIOCPUTSTAT;\n\t\tbreak;\n\tcase VTXIOCCLRCACHE_OLD:\n\t\tcmd = VTXIOCCLRCACHE;\n\t\tbreak;\n\tcase VTXIOCSETVIRT_OLD:\n\t\tcmd = VTXIOCSETVIRT;\n\t\tbreak;\n\t}\n\treturn cmd;\n}", "path": "drivers\\media\\video\\saa5249.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*\n *\tStandard character-device-driver functions\n */\n", "func_signal": "static int do_saa5249_ioctl(struct inode *inode, struct file *file,\n\t\t\t    unsigned int cmd, void *arg)", "code": "{\n\tstatic int virtual_mode = FALSE;\n\tstruct video_device *vd = video_devdata(file);\n\tstruct saa5249_device *t=vd->priv;\n\n\tswitch(cmd) \n\t{\n\t\tcase VTXIOCGETINFO: \n\t\t{\n\t\t\tvtx_info_t *info = arg;\n\t\t\tinfo->version_major = VTX_VER_MAJ;\n\t\t\tinfo->version_minor = VTX_VER_MIN;\n\t\t\tinfo->numpages = NUM_DAUS;\n\t\t\t/*info->cct_type = CCT_TYPE;*/\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCCLRPAGE: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n      \n\t\t\tif (req->pgbuf < 0 || req->pgbuf >= NUM_DAUS)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemset(t->vdau[req->pgbuf].pgbuf, ' ', sizeof(t->vdau[0].pgbuf));\n\t\t\tt->vdau[req->pgbuf].clrfound = TRUE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCCLRFOUND: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n      \n\t\t\tif (req->pgbuf < 0 || req->pgbuf >= NUM_DAUS)\n\t\t\t\treturn -EINVAL;\n\t\t\tt->vdau[req->pgbuf].clrfound = TRUE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCPAGEREQ: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n\t\t\tif (!(req->pagemask & PGMASK_PAGE))\n\t\t\t\treq->page = 0;\n\t\t\tif (!(req->pagemask & PGMASK_HOUR))\n\t\t\t\treq->hour = 0;\n\t\t\tif (!(req->pagemask & PGMASK_MINUTE))\n\t\t\t\treq->minute = 0;\n\t\t\tif (req->page < 0 || req->page > 0x8ff) /* 7FF ?? */\n\t\t\t\treturn -EINVAL;\n\t\t\treq->page &= 0x7ff;\n\t\t\tif (req->hour < 0 || req->hour > 0x3f || req->minute < 0 || req->minute > 0x7f ||\n\t\t\t\treq->pagemask < 0 || req->pagemask >= PGMASK_MAX || req->pgbuf < 0 || req->pgbuf >= NUM_DAUS)\n\t\t\t\treturn -EINVAL;\n\t\t\tt->vdau[req->pgbuf].sregs[0] = (req->pagemask & PG_HUND ? 0x10 : 0) | (req->page / 0x100);\n\t\t\tt->vdau[req->pgbuf].sregs[1] = (req->pagemask & PG_TEN ? 0x10 : 0) | ((req->page / 0x10) & 0xf);\n\t\t\tt->vdau[req->pgbuf].sregs[2] = (req->pagemask & PG_UNIT ? 0x10 : 0) | (req->page & 0xf);\n\t\t\tt->vdau[req->pgbuf].sregs[3] = (req->pagemask & HR_TEN ? 0x10 : 0) | (req->hour / 0x10);\n\t\t\tt->vdau[req->pgbuf].sregs[4] = (req->pagemask & HR_UNIT ? 0x10 : 0) | (req->hour & 0xf);\n\t\t\tt->vdau[req->pgbuf].sregs[5] = (req->pagemask & MIN_TEN ? 0x10 : 0) | (req->minute / 0x10);\n\t\t\tt->vdau[req->pgbuf].sregs[6] = (req->pagemask & MIN_UNIT ? 0x10 : 0) | (req->minute & 0xf);\n\t\t\tt->vdau[req->pgbuf].stopped = FALSE;\n\t\t\tt->vdau[req->pgbuf].clrfound = TRUE;\n\t\t\tt->is_searching[req->pgbuf] = TRUE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCGETSTAT: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n\t\t\tu8 infobits[10];\n\t\t\tvtx_pageinfo_t info;\n\t\t\tint a;\n\n\t\t\tif (req->pgbuf < 0 || req->pgbuf >= NUM_DAUS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!t->vdau[req->pgbuf].stopped) \n\t\t\t{\n\t\t\t\tif (i2c_senddata(t, 2, 0, -1) ||\n\t\t\t\t\ti2c_sendbuf(t, 3, sizeof(t->vdau[0].sregs), t->vdau[req->pgbuf].sregs) ||\n\t\t\t\t\ti2c_senddata(t, 8, 0, 25, 0, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', -1) ||\n\t\t\t\t\ti2c_senddata(t, 2, 0, t->vdau[req->pgbuf].sregs[0] | 8, -1) ||\n\t\t\t\t\ti2c_senddata(t, 8, 0, 25, 0, -1))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tjdelay(PAGE_WAIT);\n\t\t\t\tif (i2c_getdata(t, 10, infobits))\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (!(infobits[8] & 0x10) && !(infobits[7] & 0xf0) &&\t/* check FOUND-bit */\n\t\t\t\t\t(memcmp(infobits, t->vdau[req->pgbuf].laststat, sizeof(infobits)) || \n\t\t\t\t\ttime_after_eq(jiffies, t->vdau[req->pgbuf].expire)))\n\t\t\t\t{\t\t/* check if new page arrived */\n\t\t\t\t\tif (i2c_senddata(t, 8, 0, 0, 0, -1) ||\n\t\t\t\t\t\ti2c_getdata(t, VTX_PAGESIZE, t->vdau[req->pgbuf].pgbuf))\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\tt->vdau[req->pgbuf].expire = jiffies + PGBUF_EXPIRE;\n\t\t\t\t\tmemset(t->vdau[req->pgbuf].pgbuf + VTX_PAGESIZE, ' ', VTX_VIRTUALSIZE - VTX_PAGESIZE);\n\t\t\t\t\tif (t->virtual_mode) \n\t\t\t\t\t{\n\t\t\t\t\t\t/* Packet X/24 */\n\t\t\t\t\t\tif (i2c_senddata(t, 8, 0, 0x20, 0, -1) ||\n\t\t\t\t\t\t\ti2c_getdata(t, 40, t->vdau[req->pgbuf].pgbuf + VTX_PAGESIZE + 20 * 40))\n\t\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t\t/* Packet X/27/0 */\n\t\t\t\t\t\tif (i2c_senddata(t, 8, 0, 0x21, 0, -1) ||\n\t\t\t\t\t\t\ti2c_getdata(t, 40, t->vdau[req->pgbuf].pgbuf + VTX_PAGESIZE + 16 * 40))\n\t\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t\t/* Packet 8/30/0...8/30/15\n\t\t\t\t\t\t * FIXME: AFAIK, the 5249 does hamming-decoding for some bytes in packet 8/30,\n\t\t\t\t\t\t *        so we should undo this here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i2c_senddata(t, 8, 0, 0x22, 0, -1) ||\n\t\t\t\t\t\t\ti2c_getdata(t, 40, t->vdau[req->pgbuf].pgbuf + VTX_PAGESIZE + 23 * 40))\n\t\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tt->vdau[req->pgbuf].clrfound = FALSE;\n\t\t\t\t\tmemcpy(t->vdau[req->pgbuf].laststat, infobits, sizeof(infobits));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmemcpy(infobits, t->vdau[req->pgbuf].laststat, sizeof(infobits));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(infobits, t->vdau[req->pgbuf].laststat, sizeof(infobits));\n\t\t\t}\n\n\t\t\tinfo.pagenum = ((infobits[8] << 8) & 0x700) | ((infobits[1] << 4) & 0xf0) | (infobits[0] & 0x0f);\n\t\t\tif (info.pagenum < 0x100)\n\t\t\t\tinfo.pagenum += 0x800;\n\t\t\tinfo.hour = ((infobits[5] << 4) & 0x30) | (infobits[4] & 0x0f);\n\t\t\tinfo.minute = ((infobits[3] << 4) & 0x70) | (infobits[2] & 0x0f);\n\t\t\tinfo.charset = ((infobits[7] >> 1) & 7);\n\t\t\tinfo.delete = !!(infobits[3] & 8);\n\t\t\tinfo.headline = !!(infobits[5] & 4);\n\t\t\tinfo.subtitle = !!(infobits[5] & 8);\n\t\t\tinfo.supp_header = !!(infobits[6] & 1);\n\t\t\tinfo.update = !!(infobits[6] & 2);\n\t\t\tinfo.inter_seq = !!(infobits[6] & 4);\n\t\t\tinfo.dis_disp = !!(infobits[6] & 8);\n\t\t\tinfo.serial = !!(infobits[7] & 1);\n\t\t\tinfo.notfound = !!(infobits[8] & 0x10);\n\t\t\tinfo.pblf = !!(infobits[9] & 0x20);\n\t\t\tinfo.hamming = 0;\n\t\t\tfor (a = 0; a <= 7; a++) \n\t\t\t{\n\t\t\t\tif (infobits[a] & 0xf0) \n\t\t\t\t{\n\t\t\t\t\tinfo.hamming = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t->vdau[req->pgbuf].clrfound)\n\t\t\t\tinfo.notfound = 1;\n\t\t\tif(copy_to_user(req->buffer, &info, sizeof(vtx_pageinfo_t)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (!info.hamming && !info.notfound) \n\t\t\t{\n\t\t\t\tt->is_searching[req->pgbuf] = FALSE;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCGETPAGE: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n\t\t\tint start, end;\n\n\t\t\tif (req->pgbuf < 0 || req->pgbuf >= NUM_DAUS || req->start < 0 ||\n\t\t\t\treq->start > req->end || req->end >= (virtual_mode ? VTX_VIRTUALSIZE : VTX_PAGESIZE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif(copy_to_user(req->buffer, &t->vdau[req->pgbuf].pgbuf[req->start], req->end - req->start + 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t\t\n\t\t\t /* \n\t\t\t  *\tAlways read the time directly from SAA5249\n\t\t\t  */\n\t\t\t  \n\t\t\tif (req->start <= 39 && req->end >= 32) \n\t\t\t{\n\t\t\t\tint len;\n\t\t\t\tchar buf[16];  \n\t\t\t\tstart = max(req->start, 32);\n\t\t\t\tend = min(req->end, 39);\n\t\t\t\tlen=end-start+1;\n\t\t\t\tif (i2c_senddata(t, 8, 0, 0, start, -1) ||\n\t\t\t\t\ti2c_getdata(t, len, buf))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tif(copy_to_user(req->buffer+start-req->start, buf, len))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\t/* Insert the current header if DAU is still searching for a page */\n\t\t\tif (req->start <= 31 && req->end >= 7 && t->is_searching[req->pgbuf]) \n\t\t\t{\n\t\t\t\tchar buf[32];\n\t\t\t\tint len;\n\t\t\t\tstart = max(req->start, 7);\n\t\t\t\tend = min(req->end, 31);\n\t\t\t\tlen=end-start+1;\n\t\t\t\tif (i2c_senddata(t, 8, 0, 0, start, -1) ||\n\t\t\t\t\ti2c_getdata(t, len, buf))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tif(copy_to_user(req->buffer+start-req->start, buf, len))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCSTOPDAU: \n\t\t{\n\t\t\tvtx_pagereq_t *req = arg;\n\n\t\t\tif (req->pgbuf < 0 || req->pgbuf >= NUM_DAUS)\n\t\t\t\treturn -EINVAL;\n\t\t\tt->vdau[req->pgbuf].stopped = TRUE;\n\t\t\tt->is_searching[req->pgbuf] = FALSE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCPUTPAGE: \n\t\tcase VTXIOCSETDISP: \n\t\tcase VTXIOCPUTSTAT: \n\t\t\treturn 0;\n\t\t\t\n\t\tcase VTXIOCCLRCACHE: \n\t\t{\n\t\t\tif (i2c_senddata(t, 0, NUM_DAUS, 0, 8, -1) || i2c_senddata(t, 11,\n\t\t\t\t' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',\n\t\t\t\t' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ', -1))\n\t\t\t\treturn -EIO;\n\t\t\tif (i2c_senddata(t, 3, 0x20, -1))\n\t\t\t\treturn -EIO;\n\t\t\tjdelay(10 * CLEAR_DELAY);\t\t\t/* I have no idea how long we have to wait here */\n\t\t\treturn 0;\n\t\t}\n\n\t\tcase VTXIOCSETVIRT: \n\t\t{\n\t\t\t/* The SAA5249 has virtual-row reception turned on always */\n\t\t\tt->virtual_mode = (int)(long)arg;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}", "path": "drivers\\media\\video\\saa5249.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * initialise the /proc/net/rxrpc/ directory\n */\n", "func_signal": "int rxrpc_proc_init(void)", "code": "{\n\tstruct proc_dir_entry *p;\n\n\tproc_rxrpc = proc_mkdir(\"rxrpc\", proc_net);\n\tif (!proc_rxrpc)\n\t\tgoto error;\n\tproc_rxrpc->owner = THIS_MODULE;\n\n\tp = create_proc_entry(\"calls\", 0, proc_rxrpc);\n\tif (!p)\n\t\tgoto error_proc;\n\tp->proc_fops = &rxrpc_proc_calls_fops;\n\tp->owner = THIS_MODULE;\n\n\tp = create_proc_entry(\"connections\", 0, proc_rxrpc);\n\tif (!p)\n\t\tgoto error_calls;\n\tp->proc_fops = &rxrpc_proc_conns_fops;\n\tp->owner = THIS_MODULE;\n\n\tp = create_proc_entry(\"peers\", 0, proc_rxrpc);\n\tif (!p)\n\t\tgoto error_calls;\n\tp->proc_fops = &rxrpc_proc_peers_fops;\n\tp->owner = THIS_MODULE;\n\n\tp = create_proc_entry(\"transports\", 0, proc_rxrpc);\n\tif (!p)\n\t\tgoto error_conns;\n\tp->proc_fops = &rxrpc_proc_transports_fops;\n\tp->owner = THIS_MODULE;\n\n\treturn 0;\n\n error_conns:\n\tremove_proc_entry(\"connections\", proc_rxrpc);\n error_calls:\n\tremove_proc_entry(\"calls\", proc_rxrpc);\n error_proc:\n\tremove_proc_entry(\"rxrpc\", proc_net);\n error:\n\treturn -ENOMEM;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * move to next conn in conns list\n */\n", "func_signal": "static void *rxrpc_proc_conns_next(struct seq_file *p, void *v, loff_t *pos)", "code": "{\n\tstruct list_head *_p;\n\n\t(*pos)++;\n\n\t_p = v;\n\t_p = (v == SEQ_START_TOKEN) ? rxrpc_conns.next : _p->next;\n\n\treturn _p != &rxrpc_conns ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * clean up the /proc/net/rxrpc/ directory\n */\n", "func_signal": "void rxrpc_proc_cleanup(void)", "code": "{\n\tremove_proc_entry(\"transports\", proc_rxrpc);\n\tremove_proc_entry(\"peers\", proc_rxrpc);\n\tremove_proc_entry(\"connections\", proc_rxrpc);\n\tremove_proc_entry(\"calls\", proc_rxrpc);\n\n\tremove_proc_entry(\"rxrpc\", proc_net);\n\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*\n *\tWait the given number of jiffies (10ms). This calls the scheduler, so the actual\n *\tdelay may be longer.\n */\n", "func_signal": "static void jdelay(unsigned long delay)", "code": "{\n\tsigset_t oldblocked = current->blocked;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigfillset(&current->blocked);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tmsleep_interruptible(jiffies_to_msecs(delay));\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = oldblocked;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}", "path": "drivers\\media\\video\\saa5249.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * set up the iterator to start reading from the conns list and return the\n * first item\n */\n", "func_signal": "static void *rxrpc_proc_conns_start(struct seq_file *m, loff_t *_pos)", "code": "{\n\tstruct list_head *_p;\n\tloff_t pos = *_pos;\n\n\t/* lock the list against modification */\n\tdown_read(&rxrpc_conns_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\tpos--;\n\n\t/* find the n'th element in the list */\n\tlist_for_each(_p, &rxrpc_conns)\n\t\tif (!pos--)\n\t\t\tbreak;\n\n\treturn _p != &rxrpc_conns ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * open \"/proc/net/rxrpc/connections\" which provides a summary of extant\n * connections\n */\n", "func_signal": "static int rxrpc_proc_conns_open(struct inode *inode, struct file *file)", "code": "{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &rxrpc_proc_conns_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = PDE(inode)->data;\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * open \"/proc/net/rxrpc/peers\" which provides a summary of extant peers\n */\n", "func_signal": "static int rxrpc_proc_peers_open(struct inode *inode, struct file *file)", "code": "{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &rxrpc_proc_peers_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = PDE(inode)->data;\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*\n *\tWe do most of the hard work when we become a device on the i2c.\n */\n", "func_signal": "static int saa5249_probe(struct i2c_adapter *adap)", "code": "{\n\tif (adap->class & I2C_CLASS_TV_ANALOG)\n\t\treturn i2c_probe(adap, &addr_data, saa5249_attach);\n\treturn 0;\n}", "path": "drivers\\media\\video\\saa5249.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * open \"/proc/net/rxrpc/calls\" which provides a summary of extant calls\n */\n", "func_signal": "static int rxrpc_proc_calls_open(struct inode *inode, struct file *file)", "code": "{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &rxrpc_proc_calls_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = PDE(inode)->data;\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * move to next call in transports list\n */\n", "func_signal": "static void *rxrpc_proc_transports_next(struct seq_file *p, void *v, loff_t *pos)", "code": "{\n\tstruct list_head *_p;\n\n\t(*pos)++;\n\n\t_p = v;\n\t_p = (v == SEQ_START_TOKEN) ? rxrpc_proc_transports.next : _p->next;\n\n\treturn _p != &rxrpc_proc_transports ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * set up the iterator to start reading from the transports list and return the first item\n */\n", "func_signal": "static void *rxrpc_proc_transports_start(struct seq_file *m, loff_t *_pos)", "code": "{\n\tstruct list_head *_p;\n\tloff_t pos = *_pos;\n\n\t/* lock the list against modification */\n\tdown_read(&rxrpc_proc_transports_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\tpos--;\n\n\t/* find the n'th element in the list */\n\tlist_for_each(_p, &rxrpc_proc_transports)\n\t\tif (!pos--)\n\t\t\tbreak;\n\n\treturn _p != &rxrpc_proc_transports ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*\n *\tI2C interfaces\n */\n", "func_signal": "static int i2c_sendbuf(struct saa5249_device *t, int reg, int count, u8 *data)", "code": "{\n\tchar buf[64];\n\t\n\tbuf[0] = reg;\n\tmemcpy(buf+1, data, count);\n\t\n\tif(i2c_master_send(t->client, buf, count+1)==count+1)\n\t\treturn 0;\n\treturn -1;\n}", "path": "drivers\\media\\video\\saa5249.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * move to next conn in peers list\n */\n", "func_signal": "static void *rxrpc_proc_peers_next(struct seq_file *p, void *v, loff_t *pos)", "code": "{\n\tstruct list_head *_p;\n\n\t(*pos)++;\n\n\t_p = v;\n\t_p = (v == SEQ_START_TOKEN) ? rxrpc_peers.next : _p->next;\n\n\treturn _p != &rxrpc_peers ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * set up the iterator to start reading from the peers list and return the\n * first item\n */\n", "func_signal": "static void *rxrpc_proc_peers_start(struct seq_file *m, loff_t *_pos)", "code": "{\n\tstruct list_head *_p;\n\tloff_t pos = *_pos;\n\n\t/* lock the list against modification */\n\tdown_read(&rxrpc_peers_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\tpos--;\n\n\t/* find the n'th element in the list */\n\tlist_for_each(_p, &rxrpc_peers)\n\t\tif (!pos--)\n\t\t\tbreak;\n\n\treturn _p != &rxrpc_peers ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * display a header line followed by a load of call lines\n */\n", "func_signal": "static int rxrpc_proc_calls_show(struct seq_file *m, void *v)", "code": "{\n\tstruct rxrpc_call *call = list_entry(v, struct rxrpc_call, call_link);\n\n\t/* display header on line 1 */\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m,\n\t\t\t \"LOCAL REMOT SRVC CONN     CALL     DIR USE \"\n\t\t\t \" L STATE   OPCODE ABORT    ERRNO\\n\"\n\t\t\t );\n\t\treturn 0;\n\t}\n\n\t/* display one call per line on subsequent lines */\n\tseq_printf(m,\n\t\t   \"%5hu %5hu %04hx %08x %08x %s %3u%c\"\n\t\t   \" %c %-7.7s %6d %08x %5d\\n\",\n\t\t   call->conn->trans->port,\n\t\t   ntohs(call->conn->addr.sin_port),\n\t\t   ntohs(call->conn->service_id),\n\t\t   ntohl(call->conn->conn_id),\n\t\t   ntohl(call->call_id),\n\t\t   call->conn->service ? \"SVC\" : \"CLT\",\n\t\t   atomic_read(&call->usage),\n\t\t   waitqueue_active(&call->waitq) ? 'w' : ' ',\n\t\t   call->app_last_rcv ? 'Y' : '-',\n\t\t   (call->app_call_state!=RXRPC_CSTATE_ERROR ?\n\t\t    rxrpc_call_states7[call->app_call_state] :\n\t\t    rxrpc_call_error_states7[call->app_err_state]),\n\t\t   call->app_opcode,\n\t\t   call->app_abort_code,\n\t\t   call->app_errno\n\t\t   );\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * display a header line followed by a load of conn lines\n */\n", "func_signal": "static int rxrpc_proc_peers_show(struct seq_file *m, void *v)", "code": "{\n\tstruct rxrpc_peer *peer = list_entry(v, struct rxrpc_peer, proc_link);\n\tsigned long timeout;\n\n\t/* display header on line 1 */\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"LOCAL REMOTE   USAGE CONNS  TIMEOUT\"\n\t\t\t \"   MTU RTT(uS)\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one peer per line on subsequent lines */\n\ttimeout = 0;\n\tif (!list_empty(&peer->timeout.link))\n\t\ttimeout = (signed long) peer->timeout.timo_jif -\n\t\t\t(signed long) jiffies;\n\n\tseq_printf(m, \"%5hu %08x %5d %5d %8ld %5Zu %7lu\\n\",\n\t\t   peer->trans->port,\n\t\t   ntohl(peer->addr.s_addr),\n\t\t   atomic_read(&peer->usage),\n\t\t   atomic_read(&peer->conn_count),\n\t\t   timeout,\n\t\t   peer->if_mtu,\n\t\t   (long) peer->rtt\n\t\t   );\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * display a header line followed by a load of call lines\n */\n", "func_signal": "static int rxrpc_proc_transports_show(struct seq_file *m, void *v)", "code": "{\n\tstruct rxrpc_transport *trans =\n\t\tlist_entry(v, struct rxrpc_transport, proc_link);\n\n\t/* display header on line 1 */\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"LOCAL USE\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one transport per line on subsequent lines */\n\tseq_printf(m, \"%5hu %3d\\n\",\n\t\t   trans->port,\n\t\t   atomic_read(&trans->usage)\n\t\t   );\n\n\treturn 0;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/*****************************************************************************/\n/*\n * set up the iterator to start reading from the calls list and return the\n * first item\n */\n", "func_signal": "static void *rxrpc_proc_calls_start(struct seq_file *m, loff_t *_pos)", "code": "{\n\tstruct list_head *_p;\n\tloff_t pos = *_pos;\n\n\t/* lock the list against modification */\n\tdown_read(&rxrpc_calls_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\tpos--;\n\n\t/* find the n'th element in the list */\n\tlist_for_each(_p, &rxrpc_calls)\n\t\tif (!pos--)\n\t\t\tbreak;\n\n\treturn _p != &rxrpc_calls ? _p : NULL;\n}", "path": "net\\rxrpc\\proc.c", "repo_name": "xtreamerdev/linux-xtr", "stars": 8, "license": "other", "language": "c", "size": 165992}
{"docstring": "/***\n****\n***/\n", "func_signal": "gboolean\npref_flag_get( const char * key )", "code": "{\n    int64_t i;\n\n    tr_bencDictFindInt( getPrefs( ), key, &i );\n    return i != 0;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n****  Preferences\n****\n***/\n", "func_signal": "static char*\ngetPrefsFilename( void )", "code": "{\n    assert( gl_confdir != NULL );\n    return g_build_filename( gl_confdir, \"settings.json\", NULL );\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* Closing the file descriptor is the responsibility of the caller */\n", "func_signal": "void\ntr_iobuf_free( struct tr_iobuf * b )", "code": "{\n    assert( isBuf( b ) );\n\n    b->magicNumber = 0xDEAD;\n    event_del( &b->ev_read );\n    event_del( &b->ev_write );\n    evbuffer_free( b->input );\n    evbuffer_free( b->output );\n    tr_free( b );\n}", "path": "libtransmission\\iobuf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n***/\n", "func_signal": "static const char*\ngetNatStateStr( int state )", "code": "{\n    switch( state )\n    {\n        /* we're in the process of trying to set up port forwarding */\n        case TR_PORT_MAPPING:\n            return _( \"Starting\" );\n\n        /* we've successfully forwarded the port */\n        case TR_PORT_MAPPED:\n            return _( \"Forwarded\" );\n\n        /* we're cancelling the port forwarding */\n        case TR_PORT_UNMAPPING:\n            return _( \"Stopping\" );\n\n        /* the port isn't forwarded */\n        case TR_PORT_UNMAPPED:\n            return _( \"Not forwarded\" );\n\n        case TR_PORT_ERROR:\n            return \"???\";\n    }\n\n    return \"notfound\";\n}", "path": "libtransmission\\port-forwarding.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* errstr may be NULL, this might be called before GTK is initialized */\n", "func_signal": "static gboolean\nlockfile( const char *         filename,\n          tr_lockfile_state_t *tr_state,\n          char **              errstr )", "code": "{\n    const tr_lockfile_state_t state = tr_lockfile( filename );\n    const gboolean            success = state == TR_LOCKFILE_SUCCESS;\n\n    if( errstr ) switch( state )\n        {\n            case TR_LOCKFILE_EOPEN:\n                *errstr =\n                    g_strdup_printf( _( \"Couldn't open \\\"%1$s\\\": %2$s\" ),\n                                    filename, g_strerror( errno ) );\n                break;\n\n            case TR_LOCKFILE_ELOCK:\n                *errstr = g_strdup_printf( _( \"%s is already running.\" ),\n                                          g_get_application_name( ) );\n                break;\n\n            case TR_LOCKFILE_SUCCESS:\n                *errstr = NULL;\n                break;\n        }\n\n    if( tr_state != NULL )\n        *tr_state = state;\n\n    return success;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* Unmarshal a fixed length tag */\n", "func_signal": "int\nevtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag, void *data,\n    size_t len)", "code": "{\n\tev_uint32_t tag;\n\n\t/* Initialize this event buffer so that we can read into it */\n\tevbuffer_drain(_buf, EVBUFFER_LENGTH(_buf));\n\n\t/* Now unmarshal a tag and check that it matches the tag we want */\n\tif (evtag_unmarshal(src, &tag, _buf) == -1 || tag != need_tag)\n\t\treturn (-1);\n\n\tif (EVBUFFER_LENGTH(_buf) != len)\n\t\treturn (-1);\n\n\tmemcpy(data, EVBUFFER_DATA(_buf), len);\n\treturn (0);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* Reads the data type from an event buffer */\n", "func_signal": "int\nevtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)", "code": "{\n\tev_uint32_t len;\n\tev_uint32_t integer;\n\n\tif (decode_tag_internal(ptag, src, 1 /* dodrain */) == -1)\n\t\treturn (-1);\n\tif (evtag_decode_int(&integer, src) == -1)\n\t\treturn (-1);\n\tlen = integer;\n\n\tif (EVBUFFER_LENGTH(src) < len)\n\t\treturn (-1);\n\n\tif (evbuffer_add(dst, EVBUFFER_DATA(src), len) == -1)\n\t\treturn (-1);\n\n\tevbuffer_drain(src, len);\n\n\treturn (len);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* errstr may be NULL, this might be called before GTK is initialized */\n", "func_signal": "gboolean\ncf_lock( tr_lockfile_state_t *tr_state,\n         char **              errstr )", "code": "{\n    char *         path = getLockFilename( );\n    const gboolean didLock = lockfile( path, tr_state, errstr );\n\n    if( didLock )\n        gl_lockpath = g_strdup( path );\n    g_atexit( cf_removelocks );\n    g_free( path );\n    return didLock;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* Marshaling for integers */\n", "func_signal": "void\nevtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)", "code": "{\n\tevbuffer_drain(_buf, EVBUFFER_LENGTH(_buf));\n\tencode_int(_buf, integer);\n\n\tevtag_encode_tag(evbuf, tag);\n\tencode_int(evbuf, EVBUFFER_LENGTH(_buf));\n\tevbuffer_add_buffer(evbuf, _buf);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/*\n * Support variable length encoding of tags; we use the high bit in each\n * octet as a continuation signal.\n */\n", "func_signal": "int\nevtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag)", "code": "{\n\tint bytes = 0;\n\tev_uint8_t data[5];\n\n\tmemset(data, 0, sizeof(data));\n\tdo {\n\t\tev_uint8_t lower = tag & 0x7f;\n\t\ttag >>= 7;\n\n\t\tif (tag)\n\t\t\tlower |= 0x80;\n\n\t\tdata[bytes++] = lower;\n\t} while (tag);\n\n\tif (evbuf != NULL)\n\t\tevbuffer_add(evbuf, data, bytes);\n\n\treturn (bytes);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n***/\n", "func_signal": "int64_t\npref_int_get( const char * key )", "code": "{\n    int64_t i = 0;\n\n    tr_bencDictFindInt( getPrefs( ), key, &i );\n    return i;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* errstr may be NULL, this might be called before GTK is initialized */\n", "func_signal": "gboolean\ncf_init( const char *dir,\n         char **     errstr )", "code": "{\n    if( errstr != NULL )\n        *errstr = NULL;\n\n    gl_confdir = g_strdup( dir );\n\n    if( mkdir_p( gl_confdir, 0755 ) )\n        return TRUE;\n\n    if( errstr != NULL )\n        *errstr = g_strdup_printf( _( \"Couldn't create \\\"%1$s\\\": %2$s\" ),\n                                  gl_confdir, g_strerror( errno ) );\n\n    return FALSE;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* not thread safe */\n", "func_signal": "void\nevtag_init(void)", "code": "{\n\tif (_buf != NULL)\n\t\treturn;\n\n\tif ((_buf = evbuffer_new()) == NULL)\n\t\tevent_err(1, \"%s: malloc\", __func__);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/*\n * Marshal a data type, the general format is as follows:\n *\n * tag number: one byte; length: var bytes; payload: var bytes\n */\n", "func_signal": "void\nevtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag,\n    const void *data, ev_uint32_t len)", "code": "{\n\tevtag_encode_tag(evbuf, tag);\n\tencode_int(evbuf, len);\n\tevbuffer_add(evbuf, (void *)data, len);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n***/\n", "func_signal": "tr_shared *\ntr_sharedInit( tr_session  * session,\n               int           isEnabled,\n               int           publicPort )", "code": "{\n    tr_shared * s = tr_new0( tr_shared, 1 );\n\n    s->session      = session;\n    s->publicPort   = publicPort;\n    s->bindPort     = -1;\n    s->bindSocket   = -1;\n    s->natpmp       = tr_natpmpInit( );\n    s->upnp         = tr_upnpInit( );\n    s->pulseTimer   = tr_timerNew( session, sharedPulse, s, 1000 );\n    s->isEnabled    = isEnabled ? 1 : 0;\n    s->upnpStatus   = TR_PORT_UNMAPPED;\n    s->natpmpStatus = TR_PORT_UNMAPPED;\n\n    return s;\n}", "path": "libtransmission\\port-forwarding.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n***/\n", "func_signal": "void\npref_save( void )", "code": "{\n    char * filename = getPrefsFilename( );\n    char * path = g_path_get_dirname( filename );\n\n    mkdir_p( path, 0755 );\n    tr_bencSaveJSONFile( filename, getPrefs( ) );\n\n    g_free( path );\n    g_free( filename );\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/*\n * Create a new buffered event object.\n *\n * The read callback is invoked whenever we read new data.\n * The write callback is invoked whenever the output buffer is drained.\n * The error callback is invoked on a write/read error or on EOF.\n *\n * Both read and write callbacks maybe NULL.  The error callback is not\n * allowed to be NULL and have to be provided always.\n */\n", "func_signal": "struct tr_iobuf *\ntr_iobuf_new( struct tr_handle    * session,\n              tr_bandwidth        * bandwidth,\n              int                   fd,\n              short                 event,\n              tr_iobuf_cb           readcb,\n              tr_iobuf_cb           writecb,\n              tr_iobuf_error_cb     errorcb,\n              void                * cbarg )", "code": "{\n    struct tr_iobuf * b;\n\n    b = tr_new0( struct tr_iobuf, 1 );\n    b->magicNumber = MAGIC_NUMBER;\n    b->session = session;\n    b->bandwidth = bandwidth;\n    b->input = evbuffer_new( );\n    b->output = evbuffer_new( );\n\n    event_set( &b->ev_read, fd, EV_READ, tr_iobuf_readcb, b );\n    event_set( &b->ev_write, fd, EV_WRITE, tr_iobuf_writecb, b );\n\n    tr_iobuf_setcb( b, readcb, writecb, errorcb, cbarg );\n    tr_iobuf_enable( b, event );\n\n    return b;\n}", "path": "libtransmission\\iobuf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/* \n * We encode integer's by nibbles; the first nibble contains the number\n * of significant nibbles - 1;  this allows us to encode up to 64-bit\n * integers.  This function is byte-order independent.\n */\n", "func_signal": "void\nencode_int(struct evbuffer *evbuf, ev_uint32_t number)", "code": "{\n\tint off = 1, nibbles = 0;\n\tev_uint8_t data[5];\n\n\tmemset(data, 0, sizeof(ev_uint32_t)+1);\n\twhile (number) {\n\t\tif (off & 0x1)\n\t\t\tdata[off/2] = (data[off/2] & 0xf0) | (number & 0x0f);\n\t\telse\n\t\t\tdata[off/2] = (data[off/2] & 0x0f) |\n\t\t\t    ((number & 0x0f) << 4);\n\t\tnumber >>= 4;\n\t\toff++;\n\t}\n\n\tif (off > 2)\n\t\tnibbles = off - 2;\n\n\t/* Off - 1 is the number of encoded nibbles */\n\tdata[0] = (data[0] & 0x0f) | ((nibbles & 0x0f) << 4);\n\n\tevbuffer_add(evbuf, data, (off + 1) / 2);\n}", "path": "third-party\\libevent\\event_tagging.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***\n****\n***/\n", "func_signal": "const char*\npref_string_get( const char * key )", "code": "{\n    const char * str = NULL;\n\n    tr_bencDictFindStr( getPrefs( ), key, &str );\n    return str;\n}", "path": "gtk\\conf.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/***********************************************************************\n * TCP sockets\n **********************************************************************/\n", "func_signal": "int\ntr_netSetTOS( int s,\n              int tos )", "code": "{\n#ifdef IP_TOS\n    return setsockopt( s, IPPROTO_IP, IP_TOS, (char*)&tos, sizeof( tos ) );\n#else\n    return 0;\n#endif\n}", "path": "libtransmission\\net.c", "repo_name": "pieter/transmission", "stars": 11, "license": "other", "language": "c", "size": 41460}
{"docstring": "/**\n * sifaddr - Config the interface IP addresses and netmask.\n * @param pd Interface unit ???\n * @param o Our IP address ???\n * @param h His IP address ???\n * @param m IP subnet mask ???\n * @param ns1 Primary DNS\n * @param ns2 Secondary DNS\n */\n", "func_signal": "int\nsifaddr( int pd, u32_t o, u32_t h, u32_t m, u32_t ns1, u32_t ns2)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n  \n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifup[%d]: bad parms\\n\", pd));\n  } else {\n    SMEMCPY(&pc->addrs.our_ipaddr, &o, sizeof(o));\n    SMEMCPY(&pc->addrs.his_ipaddr, &h, sizeof(h));\n    SMEMCPY(&pc->addrs.netmask, &m, sizeof(m));\n    SMEMCPY(&pc->addrs.dns1, &ns1, sizeof(ns1));\n    SMEMCPY(&pc->addrs.dns2, &ns2, sizeof(ns2));\n  }\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* Get and set parameters for the given connection.\n * Return 0 on success, an error code on failure. */\n", "func_signal": "int\npppIOCtl(int pd, int cmd, void *arg)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 0;\n\n  if (pd < 0 || pd >= NUM_PPP) {\n    st = PPPERR_PARAM;\n  } else {\n    switch(cmd) {\n    case PPPCTLG_UPSTATUS:      /* Get the PPP up status. */\n      if (arg) {\n        *(int *)arg = (int)(pc->if_up);\n      } else {\n        st = PPPERR_PARAM;\n      }\n      break;\n    case PPPCTLS_ERRCODE:       /* Set the PPP error code. */\n      if (arg) {\n        pc->errCode = *(int *)arg;\n      } else {\n        st = PPPERR_PARAM;\n      }\n      break;\n    case PPPCTLG_ERRCODE:       /* Get the PPP error code. */\n      if (arg) {\n        *(int *)arg = (int)(pc->errCode);\n      } else {\n        st = PPPERR_PARAM;\n      }\n      break;\n#if PPPOS_SUPPORT\n    case PPPCTLG_FD:\n      if (arg) {\n        *(sio_fd_t *)arg = pc->fd;\n      } else {\n        st = PPPERR_PARAM;\n      }\n      break;\n#endif /* PPPOS_SUPPORT */\n    default:\n      st = PPPERR_PARAM;\n      break;\n    }\n  }\n\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * sifup - Config the interface up and enable IP packets to pass.\n */\n", "func_signal": "int\nsifup(int pd)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n  \n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifup[%d]: bad parms\\n\", pd));\n  } else {\n    netif_remove(&pc->netif);\n    if (netif_add(&pc->netif, &pc->addrs.our_ipaddr, &pc->addrs.netmask, &pc->addrs.his_ipaddr, (void *)pd, pppifNetifInit, ip_input)) {\n      netif_set_up(&pc->netif);\n#if LWIP_DHCP\n      /* ugly workaround for storing a reference to the ppp related info*/\n      pc->netif.dhcp = (struct dhcp *) &pc->addrs;\n#endif /* LWIP_DHCP */\n      pc->if_up = 1;\n      pc->errCode = PPPERR_NONE;\n\n      PPPDEBUG((LOG_DEBUG, \"sifup: unit %d: linkStatusCB=%lx errCode=%d\\n\", pd, pc->linkStatusCB, pc->errCode));\n      if(pc->linkStatusCB) {\n        pc->linkStatusCB(pc->linkStatusCtx, pc->errCode, &pc->addrs);\n      }\n    } else {\n      st = 0;\n      PPPDEBUG((LOG_ERR, \"sifup[%d]: netif_add failed\\n\", pd));\n    }\n  }\n\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * cifdefaultroute - delete a default route through the address given.\n */\n", "func_signal": "int\ncifdefaultroute(int pd, u32_t l, u32_t g)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n\n  LWIP_UNUSED_ARG(l);\n  LWIP_UNUSED_ARG(g);\n\n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifup[%d]: bad parms\\n\", pd));\n  } else {\n    netif_set_default(NULL);\n  }\n\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * pppifNetifInit - netif init callback\n */\n", "func_signal": "static err_t\npppifNetifInit(struct netif *netif)", "code": "{\n  netif->name[0] = 'p';\n  netif->name[1] = 'p';\n  netif->output = pppifOutput;\n  netif->mtu = pppMTU((int)netif->state);\n  return ERR_OK;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* Open a new PPP connection using the given I/O device.\n * This initializes the PPP control block but does not\n * attempt to negotiate the LCP session.  If this port\n * connects to a modem, the modem connection must be\n * established before calling this.\n * Return a new PPP connection descriptor on success or\n * an error code (negative) on failure. */\n", "func_signal": "int\npppOverSerialOpen(sio_fd_t fd, void (*linkStatusCB)(void *ctx, int errCode, void *arg), void *linkStatusCtx)", "code": "{\n  PPPControl *pc;\n  int pd;\n\n  /* Find a free PPP session descriptor. Critical region? */\n  for (pd = 0; pd < NUM_PPP && pppControl[pd].openFlag != 0; pd++);\n\n  if (pd >= NUM_PPP) {\n    pd = PPPERR_OPEN;\n  } else {\n    pppControl[pd].openFlag = !0;\n  }\n\n  /* Launch a deamon thread. */\n  if (pd >= 0) {\n    pppControl[pd].openFlag = 1;\n\n    lcp_init(pd);\n    pc = &pppControl[pd];\n    pc->fd = fd;\n#if PPPOE_SUPPORT\n    pc->ethif= NULL;\n#endif /* PPPOE_SUPPORT */\n    pc->kill_link = 0;\n    pc->sig_hup = 0;\n    pc->if_up = 0;\n    pc->errCode = 0;\n    pc->inState = PDIDLE;\n    pc->inHead = NULL;\n    pc->inTail = NULL;\n    pc->inEscaped = 0;\n    pc->lastXMit = 0;\n\n#if VJ_SUPPORT\n    pc->vjEnabled = 0;\n    vj_compress_init(&pc->vjComp);\n#endif /* VJ_SUPPORT */\n\n    /* \n     * Default the in and out accm so that escape and flag characters\n     * are always escaped. \n     */\n    memset(pc->inACCM, 0, sizeof(ext_accm));\n    pc->inACCM[15] = 0x60;\n    memset(pc->outACCM, 0, sizeof(ext_accm));\n    pc->outACCM[15] = 0x60;\n\n    pc->linkStatusCB = linkStatusCB;\n    pc->linkStatusCtx = linkStatusCtx;\n\n    sys_thread_new(PPP_THREAD_NAME, pppMain, (void*)pd, PPP_THREAD_STACKSIZE, PPP_THREAD_PRIO);\n    if(!linkStatusCB) {\n      while(pd >= 0 && !pc->if_up) {\n        sys_msleep(500);\n        if (lcp_phase[pd] == PHASE_DEAD) {\n          pppClose(pd);\n          if (pc->errCode) {\n            pd = pc->errCode;\n          } else {\n            pd = PPPERR_CONNECT;\n          }\n        }\n      }\n    }\n  }\n\n  return pd;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * get_idle_time - return how long the link has been idle.\n */\n", "func_signal": "int\nget_idle_time(int u, struct ppp_idle *ip)", "code": "{\n  /* XXX */\n  LWIP_UNUSED_ARG(u);\n  LWIP_UNUSED_ARG(ip);\n\n  return 0;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * Return user specified netmask, modified by any mask we might determine\n * for address `addr' (in network byte order).\n * Here we scan through the system's list of interfaces, looking for\n * any non-point-to-point interfaces which might appear to be on the same\n * network as `addr'.  If we find any, we OR in their netmask to the\n * user-specified netmask.\n */\n", "func_signal": "u32_t\nGetMask(u32_t addr)", "code": "{\n  u32_t mask, nmask;\n\n  htonl(addr);\n  if (IN_CLASSA(addr)) { /* determine network mask for address class */\n    nmask = IN_CLASSA_NET;\n  } else if (IN_CLASSB(addr)) {\n    nmask = IN_CLASSB_NET;\n  } else { \n    nmask = IN_CLASSC_NET;\n  }\n\n  /* class D nets are disallowed by bad_ip_adrs */\n  mask = subnetMask | htonl(nmask);\n  \n  /* XXX\n   * Scan through the system's network interfaces.\n   * Get each netmask and OR them into our mask.\n   */\n\n  return mask;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * sifdefaultroute - assign a default route through the address given.\n */\n", "func_signal": "int\nsifdefaultroute(int pd, u32_t l, u32_t g)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n\n  LWIP_UNUSED_ARG(l);\n  LWIP_UNUSED_ARG(g);\n\n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifup[%d]: bad parms\\n\", pd));\n  } else {\n    netif_set_default(&pc->netif);\n  }\n\n  /* TODO: check how PPP handled the netMask, previously not set by ipSetDefault */\n\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * sifdown - Config the interface down and disable IP.\n */\n", "func_signal": "int\nsifdown(int pd)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n  \n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifdown[%d]: bad parms\\n\", pd));\n  } else {\n    pc->if_up = 0;\n    netif_remove(&pc->netif);\n    PPPDEBUG((LOG_DEBUG, \"sifdown: unit %d: linkStatusCB=%lx errCode=%d\\n\", pd, pc->linkStatusCB, pc->errCode));\n    if(pc->linkStatusCB) {\n      pc->linkStatusCB(pc->linkStatusCtx, PPPERR_CONNECT, NULL);\n    }\n  }\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* PPPOS_SUPPORT */\n", "func_signal": "void\npppLinkTerminated(int pd)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n\n  PPPDEBUG((LOG_DEBUG, \"pppLinkTerminated: unit %d\\n\", pd));\n\n#if PPPOE_SUPPORT\n  if(pc->ethif) {\n    pppoe_disconnect(pc->pppoe_sc);\n  } else\n#endif /* PPPOE_SUPPORT */\n  {\n#if PPPOS_SUPPORT\n    pppMainWakeup(pd);\n#endif /* PPPOS_SUPPORT */\n  }\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * Write n characters to a ppp link.\n *  RETURN: >= 0 Number of characters written\n *           -1 Failed to write to device\n */\n", "func_signal": "int\npppWrite(int pd, const u_char *s, int n)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n#if PPPOS_SUPPORT\n  u_char c;\n  u_int fcsOut;\n  struct pbuf *headMB, *tailMB;\n#endif /* PPPOS_SUPPORT */\n\n#if PPPOE_SUPPORT\n  if(pc->ethif) {\n    return pppWriteOverEthernet(pd, s, n);\n  }\n#endif /* PPPOE_SUPPORT */\n\n#if PPPOS_SUPPORT\n  headMB = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);\n  if (headMB == NULL) {\n    LINK_STATS_INC(link.memerr);\n    LINK_STATS_INC(link.proterr);\n    return PPPERR_ALLOC;\n  }\n\n  tailMB = headMB;\n\n  /* If the link has been idle, we'll send a fresh flag character to\n   * flush any noise. */\n  if ((sys_jiffies() - pc->lastXMit) >= PPP_MAXIDLEFLAG) {\n    tailMB = pppAppend(PPP_FLAG, tailMB, NULL);\n  }\n  pc->lastXMit = sys_jiffies();\n\n  fcsOut = PPP_INITFCS;\n  /* Load output buffer. */\n  while (n-- > 0) {\n    c = *s++;\n\n    /* Update FCS before checking for special characters. */\n    fcsOut = PPP_FCS(fcsOut, c);\n\n    /* Copy to output buffer escaping special characters. */\n    tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  }\n    \n  /* Add FCS and trailing flag. */\n  c = ~fcsOut & 0xFF;\n  tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  c = (~fcsOut >> 8) & 0xFF;\n  tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  tailMB = pppAppend(PPP_FLAG, tailMB, NULL);\n\n  /* If we failed to complete the packet, throw it away.\n   * Otherwise send it. */\n  if (!tailMB) {\n    PPPDEBUG((LOG_WARNING,\n             \"pppWrite[%d]: Alloc err - dropping pbuf len=%d\\n\", pd, headMB->len));\n           /*\"pppWrite[%d]: Alloc err - dropping %d:%.*H\", pd, headMB->len, LWIP_MIN(headMB->len * 2, 40), headMB->payload)); */\n    pbuf_free(headMB);\n    LINK_STATS_INC(link.memerr);\n    LINK_STATS_INC(link.proterr);\n    return PPPERR_ALLOC;\n  }\n\n  PPPDEBUG((LOG_INFO, \"pppWrite[%d]: len=%d\\n\", pd, headMB->len));\n                   /* \"pppWrite[%d]: %d:%.*H\", pd, headMB->len, LWIP_MIN(headMB->len * 2, 40), headMB->payload)); */\n  nPut(pc, headMB);\n#endif /* PPPOS_SUPPORT */\n\n  return PPPERR_NONE;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* The main PPP process function.  This implements the state machine according\n * to section 4 of RFC 1661: The Point-To-Point Protocol. */\n", "func_signal": "static void\npppMain(void *arg)", "code": "{\n  int pd = (int)arg;\n  struct pbuf *p;\n  PPPControl* pc;\n  int c;\n\n  pc = &pppControl[pd];\n\n  p = pbuf_alloc(PBUF_RAW, PPP_MRU+PPP_HDRLEN, PBUF_RAM);\n  if (!p) {\n    LWIP_ASSERT(\"p != NULL\", p);\n    pc->errCode = PPPERR_ALLOC;\n    goto out;\n  }\n\n  /*\n   * Start the connection and handle incoming events (packet or timeout).\n   */\n  PPPDEBUG((LOG_INFO, \"pppMain: unit %d: Connecting\\n\", pd));\n  tcpip_callback(pppStartCB, arg);\n  while (lcp_phase[pd] != PHASE_DEAD) {\n    if (pc->kill_link) {\n      PPPDEBUG((LOG_DEBUG, \"pppMain: unit %d kill_link -> pppStopCB\\n\", pd));\n      pc->errCode = PPPERR_USER;\n      /* This will leave us at PHASE_DEAD. */\n      tcpip_callback(pppStopCB, arg);\n      pc->kill_link = 0;\n    } else if (pc->sig_hup) {\n      PPPDEBUG((LOG_DEBUG, \"pppMain: unit %d sig_hup -> pppHupCB\\n\", pd));\n      pc->sig_hup = 0;\n      tcpip_callback(pppHupCB, arg);\n    } else {\n      c = sio_read(pc->fd, p->payload, p->len);\n      if(c > 0) {\n        pppInProc(pd, p->payload, c);\n      } else {\n        PPPDEBUG((LOG_DEBUG, \"pppMain: unit %d sio_read len=%d returned %d\\n\", pd, p->len, c));\n        sys_msleep(1); /* give other tasks a chance to run */\n      }\n    }\n  }\n  PPPDEBUG((LOG_INFO, \"pppMain: unit %d: PHASE_DEAD\\n\", pd));\n  pppDrop(pc); /* bug fix #17726 */\n  pbuf_free(p);\n\nout:\n  PPPDEBUG((LOG_DEBUG, \"pppMain: unit %d: linkStatusCB=%lx errCode=%d\\n\", pd, pc->linkStatusCB, pc->errCode));\n  if(pc->linkStatusCB) {\n    pc->linkStatusCB(pc->linkStatusCtx, pc->errCode ? pc->errCode : PPPERR_PROTOCOL, NULL);\n  }\n\n  pc->openFlag = 0;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * sifvjcomp - config tcp header compression\n */\n", "func_signal": "int\nsifvjcomp( int pd, int vjcomp, int cidcomp, int maxcid)", "code": "{\n#if PPPOS_SUPPORT && VJ_SUPPORT\n  PPPControl *pc = &pppControl[pd];\n  \n  pc->vjEnabled = vjcomp;\n  pc->vjComp.compressSlot = cidcomp;\n  pc->vjComp.maxSlotIndex = maxcid;\n  PPPDEBUG((LOG_INFO, \"sifvjcomp: VJ compress enable=%d slot=%d max slot=%d\\n\",\n            vjcomp, cidcomp, maxcid));\n#endif /* PPPOS_SUPPORT && VJ_SUPPORT */\n\n  return 0;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* Send a packet on the given connection. */\n", "func_signal": "static err_t\npppifOutput(struct netif *netif, struct pbuf *pb, struct ip_addr *ipaddr)", "code": "{\n  int pd = (int)netif->state;\n  u_short protocol = PPP_IP;\n  PPPControl *pc = &pppControl[pd];\n#if PPPOS_SUPPORT\n  u_int fcsOut = PPP_INITFCS;\n  struct pbuf *headMB = NULL, *tailMB = NULL, *p;\n  u_char c;\n#endif /* PPPOS_SUPPORT */\n\n  LWIP_UNUSED_ARG(ipaddr);\n\n  /* Validate parameters. */\n  /* We let any protocol value go through - it can't hurt us\n   * and the peer will just drop it if it's not accepting it. */\n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag || !pb) {\n    PPPDEBUG((LOG_WARNING, \"pppifOutput[%d]: bad parms prot=%d pb=%p\\n\",\n              pd, protocol, pb));\n    LINK_STATS_INC(link.opterr);\n    LINK_STATS_INC(link.drop);\n    return ERR_ARG;\n  }\n\n  /* Check that the link is up. */\n  if (lcp_phase[pd] == PHASE_DEAD) {\n    PPPDEBUG((LOG_ERR, \"pppifOutput[%d]: link not up\\n\", pd));\n    LINK_STATS_INC(link.rterr);\n    LINK_STATS_INC(link.drop);\n    return ERR_RTE;\n  }\n\n#if PPPOE_SUPPORT\n  if(pc->ethif) {\n    return pppifOutputOverEthernet(pd, pb);\n  }\n#endif /* PPPOE_SUPPORT */\n\n#if PPPOS_SUPPORT\n  /* Grab an output buffer. */\n  headMB = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);\n  if (headMB == NULL) {\n    PPPDEBUG((LOG_WARNING, \"pppifOutput[%d]: first alloc fail\\n\", pd));\n    LINK_STATS_INC(link.memerr);\n    LINK_STATS_INC(link.drop);\n    return ERR_MEM;\n  }\n\n#if VJ_SUPPORT\n  /* \n   * Attempt Van Jacobson header compression if VJ is configured and\n   * this is an IP packet. \n   */\n  if (protocol == PPP_IP && pc->vjEnabled) {\n    switch (vj_compress_tcp(&pc->vjComp, pb)) {\n      case TYPE_IP:\n        /* No change...\n           protocol = PPP_IP_PROTOCOL; */\n        break;\n      case TYPE_COMPRESSED_TCP:\n        protocol = PPP_VJC_COMP;\n        break;\n      case TYPE_UNCOMPRESSED_TCP:\n        protocol = PPP_VJC_UNCOMP;\n        break;\n      default:\n        PPPDEBUG((LOG_WARNING, \"pppifOutput[%d]: bad IP packet\\n\", pd));\n        LINK_STATS_INC(link.proterr);\n        LINK_STATS_INC(link.drop);\n        pbuf_free(headMB);\n        return ERR_VAL;\n    }\n  }\n#endif /* VJ_SUPPORT */\n\n  tailMB = headMB;\n\n  /* Build the PPP header. */\n  if ((sys_jiffies() - pc->lastXMit) >= PPP_MAXIDLEFLAG) {\n    tailMB = pppAppend(PPP_FLAG, tailMB, NULL);\n  }\n\n  pc->lastXMit = sys_jiffies();\n  if (!pc->accomp) {\n    fcsOut = PPP_FCS(fcsOut, PPP_ALLSTATIONS);\n    tailMB = pppAppend(PPP_ALLSTATIONS, tailMB, &pc->outACCM);\n    fcsOut = PPP_FCS(fcsOut, PPP_UI);\n    tailMB = pppAppend(PPP_UI, tailMB, &pc->outACCM);\n  }\n  if (!pc->pcomp || protocol > 0xFF) {\n    c = (protocol >> 8) & 0xFF;\n    fcsOut = PPP_FCS(fcsOut, c);\n    tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  }\n  c = protocol & 0xFF;\n  fcsOut = PPP_FCS(fcsOut, c);\n  tailMB = pppAppend(c, tailMB, &pc->outACCM);\n\n  /* Load packet. */\n  for(p = pb; p; p = p->next) {\n    int n;\n    u_char *sPtr;\n\n    sPtr = (u_char*)p->payload;\n    n = p->len;\n    while (n-- > 0) {\n      c = *sPtr++;\n\n      /* Update FCS before checking for special characters. */\n      fcsOut = PPP_FCS(fcsOut, c);\n      \n      /* Copy to output buffer escaping special characters. */\n      tailMB = pppAppend(c, tailMB, &pc->outACCM);\n    }\n  }\n\n  /* Add FCS and trailing flag. */\n  c = ~fcsOut & 0xFF;\n  tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  c = (~fcsOut >> 8) & 0xFF;\n  tailMB = pppAppend(c, tailMB, &pc->outACCM);\n  tailMB = pppAppend(PPP_FLAG, tailMB, NULL);\n\n  /* If we failed to complete the packet, throw it away. */\n  if (!tailMB) {\n    PPPDEBUG((LOG_WARNING,\n             \"pppifOutput[%d]: Alloc err - dropping proto=%d\\n\", \n              pd, protocol));\n    pbuf_free(headMB);\n    LINK_STATS_INC(link.memerr);\n    LINK_STATS_INC(link.drop);\n    return ERR_MEM;\n  }\n\n  /* Send it. */\n  PPPDEBUG((LOG_INFO, \"pppifOutput[%d]: proto=0x%04X\\n\", pd, protocol));\n\n  nPut(pc, headMB);\n#endif /* PPPOS_SUPPORT */\n\n  return ERR_OK;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * Drop the input packet.\n */\n", "func_signal": "static void\npppDrop(PPPControl *pc)", "code": "{\n  if (pc->inHead != NULL) {\n#if 0\n    PPPDEBUG((LOG_INFO, \"pppDrop: %d:%.*H\\n\", pc->inHead->len, min(60, pc->inHead->len * 2), pc->inHead->payload));\n#endif\n    PPPDEBUG((LOG_INFO, \"pppDrop: pbuf len=%d\\n\", pc->inHead->len));\n    if (pc->inTail && (pc->inTail != pc->inHead)) {\n      pbuf_free(pc->inTail);\n    }\n    pbuf_free(pc->inHead);\n    pc->inHead = NULL;\n    pc->inTail = NULL;\n  }\n#if VJ_SUPPORT\n  vj_uncompress_err(&pc->vjComp);\n#endif /* VJ_SUPPORT */\n\n  LINK_STATS_INC(link.drop);\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * ppp_send_config - configure the transmit characteristics of\n * the ppp interface.\n */\n", "func_signal": "void\nppp_send_config( int unit, int mtu, u32_t asyncmap, int pcomp, int accomp)", "code": "{\n  PPPControl *pc = &pppControl[unit];\n  int i;\n  \n  pc->mtu = mtu;\n  pc->pcomp = pcomp;\n  pc->accomp = accomp;\n  \n  /* Load the ACCM bits for the 32 control codes. */\n  for (i = 0; i < 32/8; i++) {\n    pc->outACCM[i] = (u_char)((asyncmap >> (8 * i)) & 0xFF);\n  }\n  PPPDEBUG((LOG_INFO, \"ppp_send_config[%d]: outACCM=%X %X %X %X\\n\",\n            unit,\n            pc->outACCM[0], pc->outACCM[1], pc->outACCM[2], pc->outACCM[3]));\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/**\n * cifaddr - Clear the interface IP addresses, and delete routes\n * through the interface if possible.\n * @param pd Interface unit ???\n * @param o Our IP address ???\n * @param h IP broadcast address ???\n */\n", "func_signal": "int\ncifaddr( int pd, u32_t o, u32_t h)", "code": "{\n  PPPControl *pc = &pppControl[pd];\n  int st = 1;\n  \n  LWIP_UNUSED_ARG(o);\n  LWIP_UNUSED_ARG(h);\n  if (pd < 0 || pd >= NUM_PPP || !pc->openFlag) {\n    st = 0;\n    PPPDEBUG((LOG_WARNING, \"sifup[%d]: bad parms\\n\", pd));\n  } else {\n    IP4_ADDR(&pc->addrs.our_ipaddr, 0,0,0,0);\n    IP4_ADDR(&pc->addrs.his_ipaddr, 0,0,0,0);\n    IP4_ADDR(&pc->addrs.netmask, 255,255,255,0);\n    IP4_ADDR(&pc->addrs.dns1, 0,0,0,0);\n    IP4_ADDR(&pc->addrs.dns2, 0,0,0,0);\n  }\n  return st;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/*\n * sifnpmode - Set the mode for handling packets for a given NP.\n */\n", "func_signal": "int\nsifnpmode(int u, int proto, enum NPmode mode)", "code": "{\n  LWIP_UNUSED_ARG(u);\n  LWIP_UNUSED_ARG(proto);\n  LWIP_UNUSED_ARG(mode);\n  return 0;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/* \n * pppAppend - append given character to end of given pbuf.  If outACCM\n * is not NULL and the character needs to be escaped, do so.\n * If pbuf is full, append another.\n * Return the current pbuf.\n */\n", "func_signal": "static struct pbuf *\npppAppend(u_char c, struct pbuf *nb, ext_accm *outACCM)", "code": "{\n  struct pbuf *tb = nb;\n  \n  /* Make sure there is room for the character and an escape code.\n   * Sure we don't quite fill the buffer if the character doesn't\n   * get escaped but is one character worth complicating this? */\n  /* Note: We assume no packet header. */\n  if (nb && (PBUF_POOL_BUFSIZE - nb->len) < 2) {\n    tb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);\n    if (tb) {\n      nb->next = tb;\n    } else {\n      LINK_STATS_INC(link.memerr);\n    }\n    nb = tb;\n  }\n\n  if (nb) {\n    if (outACCM && ESCAPE_P(*outACCM, c)) {\n      *((u_char*)nb->payload + nb->len++) = PPP_ESCAPE;\n      *((u_char*)nb->payload + nb->len++) = c ^ PPP_TRANS;\n    } else {\n      *((u_char*)nb->payload + nb->len++) = c;\n    }\n  }\n\n  return tb;\n}", "path": "net\\lwip\\netif\\ppp\\ppp.c", "repo_name": "l2y3n2/my-jos", "stars": 8, "license": "None", "language": "c", "size": 738}
{"docstring": "/**\n * Get the first connected MTP device node in the linked list of devices.\n * Currently this only provides access to USB devices\n * @param device_list A list of devices ready to be used by the caller. You\n *        need to know how many there are.\n * @return Any error information gathered from device connections\n * @see LIBMTP_Number_Devices_In_List()\n */\n", "func_signal": "LIBMTP_error_number_t LIBMTP_Get_Connected_Devices(LIBMTP_mtpdevice_t **device_list)", "code": "{\n  LIBMTP_raw_device_t *devices;\n  int numdevs;\n  LIBMTP_error_number_t ret;\n  \n  ret = LIBMTP_Detect_Raw_Devices(&devices, &numdevs);\n  if (ret != LIBMTP_ERROR_NONE) {\n    *device_list = NULL;\n    return ret;\n  }\n\n  /* Assign linked list of devices */\n  if (devices == NULL || numdevs == 0) {\n    *device_list = NULL;\n    return LIBMTP_ERROR_NO_DEVICE_ATTACHED;\n  }\n\n  *device_list = create_usb_mtp_devices(devices, numdevs);\n  free(devices);\n\n  /* TODO: Add wifi device access here */\n  \n  /* We have found some devices but create failed */\n  if (*device_list == NULL)\n    return LIBMTP_ERROR_CONNECTING;\n\n  return LIBMTP_ERROR_NONE;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Helper function. This indicates if a track exists on the device\n * @param device a pointer to the device to get the track from.\n * @param id the track ID of the track to retrieve.\n * @return TRUE (!=0) if the track exists, FALSE (0) if not\n */\n", "func_signal": "int LIBMTP_Track_Exists(LIBMTP_mtpdevice_t *device,\n           uint32_t const id)", "code": "{\n  PTPParams *params = (PTPParams *) device->params;\n  uint16_t ret;\n  PTPObject *ob;\n\n  ret = ptp_object_want (params, id, 0, &ob);\n  if (ret == PTP_RC_OK)\n      return -1;\n  return 0;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This is a manual conversion from MTPDataGetFunc to PTPDataGetFunc\n * to isolate the internal type.\n */\n", "func_signal": "static uint16_t get_func_wrapper(PTPParams* params, void* priv, unsigned long wantlen, unsigned char *data, unsigned long *gotlen)", "code": "{\n  MTPDataHandler *handler = (MTPDataHandler *)priv;\n  uint16_t ret;\n  uint32_t local_gotlen = 0;\n  ret = handler->getfunc(params, handler->priv, wantlen, data, &local_gotlen);\n  *gotlen = local_gotlen;\n  switch (ret)\n  {\n    case LIBMTP_HANDLER_RETURN_OK:\n      return PTP_RC_OK;\n    case LIBMTP_HANDLER_RETURN_ERROR:\n      return PTP_ERROR_IO;\n    case LIBMTP_HANDLER_RETURN_CANCEL:\n      return PTP_ERROR_CANCEL;\n    default:\n      return PTP_ERROR_IO;\n  }\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Create a new property mapping entry\n * @return a newly allocated propertymapping entry.\n */\n", "func_signal": "static propertymap_t *new_propertymap_entry()", "code": "{\n  propertymap_t *propertymap;\n\n  propertymap = (propertymap_t *)malloc(sizeof(propertymap_t));\n\n  if( propertymap != NULL ) {\n    propertymap->description = NULL;\n    propertymap->id = LIBMTP_PROPERTY_UNKNOWN;\n    propertymap->ptp_id = 0;\n    propertymap->next = NULL;\n  }\n\n  return propertymap;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This function retrieves an individual album from the device.\n * @param device a pointer to the device to get the album from.\n * @param albid the unique ID of the album to retrieve.\n * @return a valid album metadata or NULL on failure.\n * @see LIBMTP_Get_Album_List()\n */\n", "func_signal": "LIBMTP_album_t *LIBMTP_Get_Album(LIBMTP_mtpdevice_t *device, uint32_t const albid)", "code": "{\n  PTPParams *params = (PTPParams *) device->params;\n  uint16_t ret;\n  PTPObject *ob;\n  LIBMTP_album_t *alb;\n\n  // Get all the handles if we haven't already done that\n  if (params->nrofobjects == 0)\n    flush_handles(device);\n\n  ret = ptp_object_want(params, albid, PTPOBJECT_OBJECTINFO_LOADED, &ob);\n  if (ret != PTP_RC_OK)\n    return NULL;\n\n  // Ignore stuff that isn't an album\n  if (ob->oi.ObjectFormat != PTP_OFC_MTP_AbstractAudioAlbum)\n    return NULL;\n\n  // Allocate a new album type\n  alb = LIBMTP_new_album_t();\n  alb->album_id = ob->oid;\n  alb->parent_id = ob->oi.ParentObject;\n  alb->storage_id = ob->oi.StorageID;\n\n  // Fetch supported metadata\n  get_album_metadata(device, alb);\n\n  // Then get the track listing for this album\n  ret = ptp_mtp_getobjectreferences(params, alb->album_id, &alb->tracks, &alb->no_tracks);\n  if (ret != PTP_RC_OK) {\n    add_ptp_error_to_errorstack(device, ret, \"LIBMTP_Get_Album: Could not get object references.\");\n    alb->tracks = NULL;\n    alb->no_tracks = 0;\n  }\n\n  return alb;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This helper function returns a textual description for a libmtp\n * property to be used in dialog boxes etc.\n * @param inproperty the libmtp internal property to get a description for.\n * @return a string representing the filetype, this must <b>NOT</b>\n *         be free():ed by the caller!\n */\n", "func_signal": "char const * LIBMTP_Get_Property_Description(LIBMTP_property_t inproperty)", "code": "{\n  propertymap_t *current;\n\n  current = propertymap;\n\n  while (current != NULL) {\n    if(current->id == inproperty) {\n      return current->description;\n    }\n    current = current->next;\n  }\n\n  return \"Unknown property\";\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This destroys a file sample metadata type.\n * @param sample the file sample metadata to be destroyed.\n */\n", "func_signal": "void LIBMTP_destroy_filesampledata_t(LIBMTP_filesampledata_t * sample)", "code": "{\n  if (sample == NULL) {\n    return;\n  }\n  if (sample->data != NULL) {\n    free(sample->data);\n  }\n  free(sample);\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This function maps and copies a property onto the album metadata if applicable.\n */\n", "func_signal": "static void pick_property_to_album_metadata(LIBMTP_mtpdevice_t *device,\n\t\t\t\t\t    MTPProperties *prop, LIBMTP_album_t *alb)", "code": "{\n  switch (prop->property) {\n  case PTP_OPC_Name:\n    if (prop->propval.str != NULL)\n      alb->name = strdup(prop->propval.str);\n    else\n      alb->name = NULL;\n    break;\n  case PTP_OPC_AlbumArtist:\n    if (prop->propval.str != NULL) {\n      // This should take precedence over plain \"Artist\"\n      if (alb->artist != NULL)\n\tfree(alb->artist);\n      alb->artist = strdup(prop->propval.str);\n    } else\n      alb->artist = NULL;\n    break;\n  case PTP_OPC_Artist:\n    if (prop->propval.str != NULL) {\n      // Only use of AlbumArtist is not set\n      if (alb->artist == NULL)\n\talb->artist = strdup(prop->propval.str);\n    } else\n      alb->artist = NULL;\n    break;\n  case PTP_OPC_Composer:\n    if (prop->propval.str != NULL)\n      alb->composer = strdup(prop->propval.str);\n    else\n      alb->composer = NULL;\n    break;\n  case PTP_OPC_Genre:\n    if (prop->propval.str != NULL)\n      alb->genre = strdup(prop->propval.str);\n    else\n      alb->genre = NULL;\n    break;\n  }\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Sets an object attribute from an unsigned 16-bit integer\n *\n * @param device a pointer to an MTP device.\n * @param object_id Object reference\n * @param attribute_id PTP attribute ID\n * @param value 16-bit unsigned integer to set\n * @return 0 on success, any other value means failure\n */\n", "func_signal": "static int set_object_u16(LIBMTP_mtpdevice_t *device, uint32_t const object_id,\n\t\t\t  uint16_t const attribute_id, uint16_t const value)", "code": "{\n  PTPPropertyValue propval;\n  PTPParams *params = (PTPParams *) device->params;\n  uint16_t ret;\n\n  if (device == NULL) {\n    return 1;\n  }\n\n  if (!ptp_operation_issupported(params,PTP_OC_MTP_SetObjectPropValue)) {\n    add_error_to_errorstack(device, LIBMTP_ERROR_GENERAL, \"set_object_u16(): could not set unsigned 16bit integer property: \"\n\t\t\t\t\"PTP_OC_MTP_SetObjectPropValue not supported.\");\n    return -1;\n  }\n  propval.u16 = value;\n  ret = ptp_mtp_setobjectpropvalue(params, object_id, attribute_id, &propval, PTP_DTC_UINT16);\n  if (ret != PTP_RC_OK) {\n    add_ptp_error_to_errorstack(device, ret, \"set_object_u16(): could not set unsigned 16bit integer property.\");\n    return 1;\n  }\n\n  return 0;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This returns a list of all folders available\n * on the current MTP device.\n *\n * @param device a pointer to the device to get the folder listing for.\n * @return a list of folders\n */\n", "func_signal": "LIBMTP_folder_t *LIBMTP_Get_Folder_List(LIBMTP_mtpdevice_t *device)", "code": "{\n  PTPParams *params = (PTPParams *) device->params;\n  LIBMTP_folder_t head, *rv;\n  int i;\n\n  // Get all the handles if we haven't already done that\n  if (params->nrofobjects == 0) {\n    flush_handles(device);\n  }\n\n  /*\n   * This creates a temporary list of the folders, this is in a\n   * reverse order and uses the Folder pointers that are already\n   * in the Folder structure. From this we can then build up the\n   * folder hierarchy with only looking at this temporary list,\n   * and removing the folders from this temporary list as we go.\n   * This significantly reduces the number of operations that we\n   * have to do in building the folder hierarchy. Also since the\n   * temp list is in reverse order, when we prepend to the sibling\n   * list things are in the same order as they were originally\n   * in the handle list.\n   */\n  head.sibling = &head;\n  head.child = &head;\n  for (i = 0; i < params->nrofobjects; i++) {\n    LIBMTP_folder_t *folder;\n    PTPObject *ob;\n\n    ob = &params->objects[i];\n    if (ob->oi.ObjectFormat != PTP_OFC_Association) {\n      continue;\n    }\n    /*\n     * Do we know how to handle these? They are part\n     * of the MTP 1.0 specification paragraph 3.6.4.\n     * For AssociationDesc 0x00000001U ptp_mtp_getobjectreferences()\n     * should be called on these to get the contained objects, but\n     * we basically don't care. Hopefully parent_id is maintained for all\n     * children, because we rely on that instead.\n     */\n    if (ob->oi.AssociationDesc != 0x00000000U) {\n      printf(\"MTP extended association type 0x%08x encountered\\n\", ob->oi.AssociationDesc);\n    }\n\n    // Create a folder struct...\n    folder = LIBMTP_new_folder_t();\n    if (folder == NULL) {\n      // malloc failure or so.\n      return NULL;\n    }\n    folder->folder_id = ob->oid;\n    folder->parent_id = ob->oi.ParentObject;\n    folder->storage_id = ob->oi.StorageID;\n    folder->name = (ob->oi.Filename) ? (char *)strdup(ob->oi.Filename) : NULL;\n\n    // pretend sibling says next, and child says prev.\n    folder->sibling = head.sibling;\n    folder->child = &head;\n    head.sibling->child = folder;\n    head.sibling = folder;\n  }\n\n  // We begin at the root folder and get them all recursively\n  rv = get_subfolders_for_folder(&head, 0x00000000);\n\n  // The temp list should be empty. Clean up any orphans just in case.\n  while(head.sibling != &head) {\n    LIBMTP_folder_t *curr = head.sibling;\n\n    printf(\"Orphan folder with ID: 0x%08x name: \\\"%s\\\" encountered.\\n\",\n\t   curr->folder_id,\n\t   curr->name);\n    curr->sibling->child = curr->child;\n    curr->child->sibling = curr->sibling;\n    curr->child = NULL;\n    curr->sibling = NULL;\n    LIBMTP_destroy_folder_t(curr);\n  }\n\n  return rv;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This creates a new file metadata structure and allocates memory\n * for it. Notice that if you add strings to this structure they\n * will be freed by the corresponding <code>LIBMTP_destroy_file_t</code>\n * operation later, so be careful of using strdup() when assigning\n * strings, e.g.:\n *\n * <pre>\n * LIBMTP_file_t *file = LIBMTP_new_file_t();\n * file->filename = strdup(namestr);\n * ....\n * LIBMTP_destroy_file_t(file);\n * </pre>\n *\n * @return a pointer to the newly allocated metadata structure.\n * @see LIBMTP_destroy_file_t()\n */\n", "func_signal": "LIBMTP_file_t *LIBMTP_new_file_t(void)", "code": "{\n  LIBMTP_file_t *new = (LIBMTP_file_t *) malloc(sizeof(LIBMTP_file_t));\n  if (new == NULL) {\n    return NULL;\n  }\n  new->filename = NULL;\n  new->item_id = 0;\n  new->parent_id = 0;\n  new->storage_id = 0;\n  new->filesize = 0;\n  new->modificationdate = 0;\n  new->filetype = LIBMTP_FILETYPE_UNKNOWN;\n  new->next = NULL;\n  return new;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Retrieves an unsigned 8-bit integer from an object attribute\n *\n * @param device a pointer to an MTP device.\n * @param object_id Object reference\n * @param attribute_id PTP attribute ID\n * @param value_default Default value to return on failure\n * @return a value\n */\n", "func_signal": "static uint8_t get_u8_from_object(LIBMTP_mtpdevice_t *device, uint32_t const object_id,\n\t\t\t\t  uint16_t const attribute_id, uint8_t const value_default)", "code": "{\n  PTPPropertyValue propval;\n  uint8_t retval = value_default;\n  PTPParams *params = (PTPParams *) device->params;\n  uint16_t ret;\n  MTPProperties *prop;\n\n  if ( device == NULL ) {\n    return value_default;\n  }\n\n  // This O(n) search should not be used so often, since code\n  // using the cached properties don't usually call this function.\n  prop = ptp_find_object_prop_in_cache(params, object_id, attribute_id);\n  if (prop)\n    return prop->propval.u8;\n\n  ret = ptp_mtp_getobjectpropvalue(params, object_id,\n                                   attribute_id,\n                                   &propval,\n                                   PTP_DTC_UINT8);\n  if (ret == PTP_RC_OK) {\n    retval = propval.u8;\n  } else {\n    add_ptp_error_to_errorstack(device, ret, \"get_u8_from_object(): could not get unsigned 8bit integer from object.\");\n  }\n\n  return retval;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This creates a new album metadata structure and allocates memory\n * for it. Notice that if you add strings to this structure they\n * will be freed by the corresponding <code>LIBMTP_destroy_album_t</code>\n * operation later, so be careful of using strdup() when assigning\n * strings.\n *\n * @return a pointer to the newly allocated metadata structure.\n * @see LIBMTP_destroy_album_t()\n */\n", "func_signal": "LIBMTP_album_t *LIBMTP_new_album_t(void)", "code": "{\n  LIBMTP_album_t *new = (LIBMTP_album_t *) malloc(sizeof(LIBMTP_album_t));\n  if (new == NULL) {\n    return NULL;\n  }\n  new->album_id = 0;\n  new->parent_id = 0;\n  new->storage_id = 0;\n  new->name = NULL;\n  new->artist = NULL;\n  new->composer = NULL;\n  new->genre = NULL;\n  new->tracks = NULL;\n  new->no_tracks = 0;\n  new->next = NULL;\n  return new;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Sets the synchronization partner of an MTP device. Note that\n * we have no idea what the effect of setting this to \"foobar\"\n * may be. But the general idea seems to be to tell which program\n * shall synchronize with this device and tell others to leave\n * it alone.\n * @param device a pointer to the device to set the sync partner for.\n * @param syncpartner the new synchronization partner for the device.\n * @return 0 on success, any other value means failure.\n * @see LIBMTP_Get_Syncpartner()\n */\n", "func_signal": "int LIBMTP_Set_Syncpartner(LIBMTP_mtpdevice_t *device,\n\t\t\t char const * const syncpartner)", "code": "{\n  PTPPropertyValue propval;\n  PTPParams *params = (PTPParams *) device->params;\n  uint16_t ret;\n\n  if (!ptp_property_issupported(params, PTP_DPC_MTP_SynchronizationPartner)) {\n    return -1;\n  }\n  propval.str = (char *) syncpartner;\n  ret = ptp_setdevicepropvalue(params,\n\t\t\t       PTP_DPC_MTP_SynchronizationPartner,\n\t\t\t       &propval,\n\t\t\t       PTP_DTC_STR);\n  if (ret != PTP_RC_OK) {\n    add_ptp_error_to_errorstack(device, ret, \"Error setting syncpartner.\");\n    return -1;\n  }\n  return 0;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This destroys a track metadata structure and deallocates the memory\n * used by it, including any strings. Never use a track metadata\n * structure again after calling this function on it.\n * @param track the track metadata to destroy.\n * @see LIBMTP_new_track_t()\n */\n", "func_signal": "void LIBMTP_destroy_track_t(LIBMTP_track_t *track)", "code": "{\n  if (track == NULL) {\n    return;\n  }\n  if (track->title != NULL)\n    free(track->title);\n  if (track->artist != NULL)\n    free(track->artist);\n  if (track->composer != NULL)\n    free(track->composer);\n  if (track->album != NULL)\n    free(track->album);\n  if (track->genre != NULL)\n    free(track->genre);\n  if (track->date != NULL)\n    free(track->date);\n  if (track->filename != NULL)\n    free(track->filename);\n  free(track);\n  return;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Register an MTP or PTP property for data retrieval\n *\n * @param description Text description of property\n * @param id libmtp internal property id\n * @param ptp_id PTP property id\n * @return 0 for success any other value means error.\n*/\n", "func_signal": "static int register_property(char const * const description, LIBMTP_property_t const id,\n\t\t\t     uint16_t const ptp_id)", "code": "{\n  propertymap_t *new = NULL, *current;\n\n  // Has this LIBMTP propety been registered before ?\n  current = propertymap;\n  while (current != NULL) {\n    if(current->id == id) {\n      break;\n    }\n    current = current->next;\n  }\n\n  // Create the entry\n  if(current == NULL) {\n    new = new_propertymap_entry();\n    if(new == NULL) {\n      return 1;\n    }\n\n    new->id = id;\n    if(description != NULL) {\n      new->description = strdup(description);\n    }\n    new->ptp_id = ptp_id;\n\n    // Add the entry to the list\n    if(propertymap == NULL) {\n      propertymap = new;\n    } else {\n      current = propertymap;\n      while (current->next != NULL ) current=current->next;\n      current->next = new;\n    }\n    // Update the existing entry\n  } else {\n    if (current->description != NULL) {\n      free(current->description);\n    }\n    current->description = NULL;\n    if(description != NULL) {\n      current->description = strdup(description);\n    }\n    current->ptp_id = ptp_id;\n  }\n\n  return 0;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This retrieves the model name (often equal to product name)\n * of an MTP device.\n * @param device a pointer to the device to get the model name for.\n * @return a newly allocated UTF-8 string representing the model name.\n *         The string must be freed by the caller after use. If the call\n *         was unsuccessful this will contain NULL.\n */\n", "func_signal": "char *LIBMTP_Get_Modelname(LIBMTP_mtpdevice_t *device)", "code": "{\n  char *retmodel = NULL;\n  PTPParams *params = (PTPParams *) device->params;\n\n  if (params->deviceinfo.Model != NULL) {\n    retmodel = strdup(params->deviceinfo.Model);\n  }\n  return retmodel;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This creates a new playlist metadata structure and allocates memory\n * for it. Notice that if you add strings to this structure they\n * will be freed by the corresponding <code>LIBMTP_destroy_playlist_t</code>\n * operation later, so be careful of using strdup() when assigning\n * strings, e.g.:\n *\n * <pre>\n * LIBMTP_playlist_t *pl = LIBMTP_new_playlist_t();\n * pl->name = strdup(str);\n * ....\n * LIBMTP_destroy_playlist_t(pl);\n * </pre>\n *\n * @return a pointer to the newly allocated metadata structure.\n * @see LIBMTP_destroy_playlist_t()\n */\n", "func_signal": "LIBMTP_playlist_t *LIBMTP_new_playlist_t(void)", "code": "{\n  LIBMTP_playlist_t *new = (LIBMTP_playlist_t *) malloc(sizeof(LIBMTP_playlist_t));\n  if (new == NULL) {\n    return NULL;\n  }\n  new->playlist_id = 0;\n  new->parent_id = 0;\n  new->storage_id = 0;\n  new->name = NULL;\n  new->tracks = NULL;\n  new->no_tracks = 0;\n  new->next = NULL;\n  return new;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * Gets the allowed values (range or enum) for a property\n * @param device a pointer to an MTP device\n * @param property the property to query\n * @param filetype the filetype of the object you want to set values for\n * @param allowed_vals pointer to a LIBMTP_allowed_values_t struct to\n *        receive the allowed values.  Call LIBMTP_destroy_allowed_values_t\n *        on this on successful completion.\n * @return 0 on success, any other value means failure\n */\n", "func_signal": "int LIBMTP_Get_Allowed_Property_Values(LIBMTP_mtpdevice_t *device, LIBMTP_property_t const property,\n            LIBMTP_filetype_t const filetype, LIBMTP_allowed_values_t *allowed_vals)", "code": "{\n  PTPObjectPropDesc opd;\n  uint16_t ret = 0;\n  \n  ret = ptp_mtp_getobjectpropdesc(device->params, map_libmtp_property_to_ptp_property(property), map_libmtp_type_to_ptp_type(filetype), &opd);\n  if (ret != PTP_RC_OK) {\n    add_ptp_error_to_errorstack(device, ret, \"LIBMTP_Get_Allowed_Property_Values(): could not get property description.\");\n    return -1;\n  }\n\n  if (opd.FormFlag == PTP_OPFF_Enumeration) {\n    int i = 0;\n    \n    allowed_vals->is_range = 0;\n    allowed_vals->num_entries = opd.FORM.Enum.NumberOfValues;\n\n    switch (opd.DataType)\n    {\n      case PTP_DTC_INT8:\n        allowed_vals->i8vals = malloc(sizeof(int8_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT8;\n        break;\n      case PTP_DTC_UINT8:\n        allowed_vals->u8vals = malloc(sizeof(uint8_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT8;\n        break;\n      case PTP_DTC_INT16:\n        allowed_vals->i16vals = malloc(sizeof(int16_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT16;\n        break;\n      case PTP_DTC_UINT16:\n        allowed_vals->u16vals = malloc(sizeof(uint16_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT16;\n        break;\n      case PTP_DTC_INT32:\n        allowed_vals->i32vals = malloc(sizeof(int32_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT32;\n        break;\n      case PTP_DTC_UINT32:\n        allowed_vals->u32vals = malloc(sizeof(uint32_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT32;\n        break;\n      case PTP_DTC_INT64:\n        allowed_vals->i64vals = malloc(sizeof(int64_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT64;\n        break;\n      case PTP_DTC_UINT64:\n        allowed_vals->u64vals = malloc(sizeof(uint64_t) * opd.FORM.Enum.NumberOfValues);\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT64;\n        break;\n    }\n    \n    for (i = 0; i < opd.FORM.Enum.NumberOfValues; i++) {\n      switch (opd.DataType)\n      {\n        case PTP_DTC_INT8:\n          allowed_vals->i8vals[i] = opd.FORM.Enum.SupportedValue[i].i8;\n          break;\n        case PTP_DTC_UINT8:\n          allowed_vals->u8vals[i] = opd.FORM.Enum.SupportedValue[i].u8;\n          break;\n        case PTP_DTC_INT16:\n          allowed_vals->i16vals[i] = opd.FORM.Enum.SupportedValue[i].i16;\n          break;\n        case PTP_DTC_UINT16:\n          allowed_vals->u16vals[i] = opd.FORM.Enum.SupportedValue[i].u16;\n          break;\n        case PTP_DTC_INT32:\n          allowed_vals->i32vals[i] = opd.FORM.Enum.SupportedValue[i].i32;\n          break;\n        case PTP_DTC_UINT32:\n          allowed_vals->u32vals[i] = opd.FORM.Enum.SupportedValue[i].u32;\n          break;\n        case PTP_DTC_INT64:\n          allowed_vals->i64vals[i] = opd.FORM.Enum.SupportedValue[i].i64;\n          break;\n        case PTP_DTC_UINT64:\n          allowed_vals->u64vals[i] = opd.FORM.Enum.SupportedValue[i].u64;\n          break;\n      }\n    }\n    ptp_free_objectpropdesc(&opd);\n    return 0;\n  } else if (opd.FormFlag == PTP_OPFF_Range) {\n    allowed_vals->is_range = 1;\n    \n    switch (opd.DataType)\n    {\n      case PTP_DTC_INT8:\n        allowed_vals->i8min = opd.FORM.Range.MinimumValue.i8;\n        allowed_vals->i8max = opd.FORM.Range.MaximumValue.i8;\n        allowed_vals->i8step = opd.FORM.Range.StepSize.i8;\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT8;\n        break;\n      case PTP_DTC_UINT8:\n        allowed_vals->u8min = opd.FORM.Range.MinimumValue.u8;\n        allowed_vals->u8max = opd.FORM.Range.MaximumValue.u8;\n        allowed_vals->u8step = opd.FORM.Range.StepSize.u8;\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT8;\n        break;\n      case PTP_DTC_INT16:\n        allowed_vals->i16min = opd.FORM.Range.MinimumValue.i16;\n        allowed_vals->i16max = opd.FORM.Range.MaximumValue.i16;\n        allowed_vals->i16step = opd.FORM.Range.StepSize.i16;\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT16;\n        break;\n      case PTP_DTC_UINT16:\n        allowed_vals->u16min = opd.FORM.Range.MinimumValue.u16;\n        allowed_vals->u16max = opd.FORM.Range.MaximumValue.u16;\n        allowed_vals->u16step = opd.FORM.Range.StepSize.u16;\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT16;\n        break;\n      case PTP_DTC_INT32:\n        allowed_vals->i32min = opd.FORM.Range.MinimumValue.i32;\n        allowed_vals->i32max = opd.FORM.Range.MaximumValue.i32;\n        allowed_vals->i32step = opd.FORM.Range.StepSize.i32;\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT32;\n        break;\n      case PTP_DTC_UINT32:\n        allowed_vals->u32min = opd.FORM.Range.MinimumValue.u32;\n        allowed_vals->u32max = opd.FORM.Range.MaximumValue.u32;\n        allowed_vals->u32step = opd.FORM.Range.StepSize.u32;\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT32;\n        break;\n      case PTP_DTC_INT64:\n        allowed_vals->i64min = opd.FORM.Range.MinimumValue.i64;\n        allowed_vals->i64max = opd.FORM.Range.MaximumValue.i64;\n        allowed_vals->i64step = opd.FORM.Range.StepSize.i64;\n        allowed_vals->datatype = LIBMTP_DATATYPE_INT64;\n        break;\n      case PTP_DTC_UINT64:\n        allowed_vals->u64min = opd.FORM.Range.MinimumValue.u64;\n        allowed_vals->u64max = opd.FORM.Range.MaximumValue.u64;\n        allowed_vals->u64step = opd.FORM.Range.StepSize.u64;\n        allowed_vals->datatype = LIBMTP_DATATYPE_UINT64;\n        break;\n    }\n    return 0; \n  } else\n    return -1;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/**\n * This creates a new sample data metadata structure and allocates memory\n * for it. Notice that if you add strings to this structure they\n * will be freed by the corresponding <code>LIBMTP_destroy_sampledata_t</code>\n * operation later, so be careful of using strdup() when assigning\n * strings.\n *\n * @return a pointer to the newly allocated metadata structure.\n * @see LIBMTP_destroy_sampledata_t()\n */\n", "func_signal": "LIBMTP_filesampledata_t *LIBMTP_new_filesampledata_t(void)", "code": "{\n  LIBMTP_filesampledata_t *new = (LIBMTP_filesampledata_t *) malloc(sizeof(LIBMTP_filesampledata_t));\n  if (new == NULL) {\n    return NULL;\n  }\n  new->height=0;\n  new->width = 0;\n  new->data = NULL;\n  new->duration = 0;\n  new->size = 0;\n  return new;\n}", "path": "jmtp\\libs\\libmtp\\src\\libmtp.c", "repo_name": "sixones/zenses", "stars": 9, "license": "None", "language": "c", "size": 21548}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void acked(void)", "code": "{\n\tu16_t len;\n\n\tif(s.getrequestleft > 0) {\n\t\tlen = s.getrequestleft > uip_mss()?uip_mss():s.getrequestleft;\n\t\ts.getrequestleft -= len;\n\t\ts.getrequestptr += len;\n\t}\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static unsigned char* copy_string(unsigned char *dest, const unsigned char *src, unsigned char len)", "code": "{\n\tstrncpy(dest, src, len);\n\treturn dest + len;\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "char\nmemb_free(struct memb_blocks *m, void *ptr)", "code": "{\n  int i;\n  char *ptr2;\n\n  /* Walk through the list of blocks and try to find the block to\n     which the pointer \"ptr\" points to. */\n  ptr2 = (char *)m->mem;\n  for(i = 0; i < m->num; ++i) {\n    \n    if(ptr2 == (char *)ptr) {\n      /* We've found to block to which \"ptr\" points so we decrease the\n\t reference count and return the new value of it. */\n      if(m->count[i] > 0) {\n\t/* Make sure that we don't deallocate free memory. */\n\t--(m->count[i]);\n      }\n      return m->count[i];\n    }\n    ptr2 += m->size;\n  }\n  return -1;\n}", "path": "Libraries\\WiShield\\memb.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void init_connection(void)", "code": "{\n\ts.state = WEBCLIENT_STATE_STATUSLINE;\n\n\t// set the length of the client string to be transmitted\n\ts.getrequestleft = strlen_P(twitter);\n\n\ts.getrequestptr = 0;\n\n\ts.httpheaderlineptr = 0;\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n   /* Disable watchdog if enabled by bootloader/fuses */\n   MCUSR &= ~(1 << WDRF);\n   wdt_disable();\n\n   /* Disable clock division */\n   clock_prescale_set(clock_div_1);\n\n   /* Hardware Initialization */\n   USB_Init();\n}", "path": "bootloader\\midi\\examples\\lufa_midi\\midi_usb.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_neighbor_periodic(void)", "code": "{\n  int i;\n\n  for(i = 0; i < ENTRIES; ++i) {\n    if(entries[i].time < MAX_TIME) {\n      entries[i].time++;\n    }\n  }\n}", "path": "Libraries\\WiShield\\uip-neighbor.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/** Event handler for the library USB Configuration Changed event. */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tbool ConfigSuccess = true;\n\n\tConfigSuccess &= MIDI_Device_ConfigureEndpoints(&USB_MIDI_Interface);\n   //set some LED?\n}", "path": "bootloader\\midi\\examples\\lufa_midi\\midi_usb.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static struct neighbor_entry *\nfind_entry(uip_ipaddr_t ipaddr)", "code": "{\n  int i;\n  \n  for(i = 0; i < ENTRIES; ++i) {\n    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {\n      return &entries[i];\n    }\n  }\n  return NULL;\n}", "path": "Libraries\\WiShield\\uip-neighbor.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void senddata(void)", "code": "{\n\tu16_t len;\n\tchar *getrequest;\n\tchar *cptr;\n\n\tif(s.getrequestleft > 0) {\n\t\tcptr = getrequest = (char *)uip_appdata;\n\n#if 0\n\t\tcptr = copy_string(cptr, http_get, sizeof(http_get) - 1);\n\t\tcptr = copy_string(cptr, s.file, strlen(s.file));\n\t\t*cptr++ = ISO_space;\n\t\tcptr = copy_string(cptr, http_10, sizeof(http_10) - 1);\n\n\t\tcptr = copy_string(cptr, http_crnl, sizeof(http_crnl) - 1);\n\n\t\tcptr = copy_string(cptr, http_host, sizeof(http_host) - 1);\n\t\tcptr = copy_string(cptr, s.host, strlen(s.host));\n\t\tcptr = copy_string(cptr, http_crnl, sizeof(http_crnl) - 1);\n\n\t\tcptr = copy_string(cptr, http_user_agent_fields,\n\t\t\t\tstrlen(http_user_agent_fields));\n#endif\n\n\t\t// copy the client transmit string into the TX buffer\n\t\tmemcpy_P(cptr, twitter, strlen_P(twitter));\n\n\t\tlen = s.getrequestleft > uip_mss()?uip_mss():s.getrequestleft;\n\t\tuip_send(&(getrequest[s.getrequestptr]), len);\n\t}\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n/*\n * In socketapp.h we have defined the UIP_APPCALL macro to\n * socket_app_appcall so that this function is uIP's application\n * function. This function is called whenever an uIP event occurs\n * (e.g. when a new connection is established, new data arrives, sent\n * data is acknowledged, data needs to be retransmitted, etc.).\n */\n", "func_signal": "void socket_app_appcall(void)", "code": "{\n  /*\n   * The uip_conn structure has a field called \"appstate\" that holds\n   * the application state of the connection. We make a pointer to\n   * this to access it easier.\n   */\n  struct socket_app_state *s = &(uip_conn->appstate);\n\n  /*\n   * If a new connection was just established, we should initialize\n   * the protosocket in our applications' state structure.\n   */\n  if(uip_connected()) {\n    PSOCK_INIT(&s->p, s->inputbuffer, sizeof(s->inputbuffer));\n  }\n\n  /*\n   * Finally, we run the protosocket function that actually handles\n   * the communication. We pass it a pointer to the application state\n   * of the current connection.\n   */\n  handle_connection(s);\n}", "path": "Libraries\\WiShield\\examples\\SocketApp\\socketapp.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "//Overflow interrupt\n", "func_signal": "ISR(TIMER0_OVF_vect)", "code": "{\n\tclock_datetime += 1;\n\tTIFR0 |= (1<<TOV0);\n}", "path": "Libraries\\WiShield\\clock-arch.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static u16_t parse_headers(u16_t len)", "code": "{\n\tchar *cptr;\n\tstatic unsigned char i;\n\tchar* temp;\n\n\twhile(len > 0 && s.httpheaderlineptr < sizeof(s.httpheaderline)) {\n\t\ts.httpheaderline[s.httpheaderlineptr] = *(char *)uip_appdata;\n\t\t//++((char *)uip_appdata);\n\t\ttemp = (char *)uip_appdata;\n\t\ttemp++;\n\t\tuip_appdata = temp;\n\t\t--len;\n\t\tif(s.httpheaderline[s.httpheaderlineptr] == ISO_nl) {\n\t\t\t/* We have an entire HTTP header line in s.httpheaderline, so\n\t\t\t * we parse it. */\n\t\t\tif(s.httpheaderline[0] == ISO_cr) {\n\t\t\t\t/* This was the last header line (i.e., and empty \"\\r\\n\"), so\n\t\t\t\t * we are done with the headers and proceed with the actual\n\t\t\t\t * data. */\n\t\t\t\ts.state = WEBCLIENT_STATE_DATA;\n\t\t\t\treturn len;\n\t\t\t}\n\n\t\t\t/* We're done parsing, so we reset the pointer and start the\n\t\t\t * next line. */\n\t\t\ts.httpheaderlineptr = 0;\n\t\t}\n\t\telse {\n\t\t\t++s.httpheaderlineptr;\n\t\t}\n\t}\n\n\treturn len;\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void webclient_appcall(void)", "code": "{\n\tif(uip_connected()) {\n\t\ts.timer = 0;\n\t\ts.state = WEBCLIENT_STATE_STATUSLINE;\n\t\tsenddata();\n\t\twebclient_connected();\n\t\treturn;\n\t}\n\n\tif(s.state == WEBCLIENT_STATE_CLOSE) {\n\t\twebclient_closed();\n\t\tuip_abort();\n\t\treturn;\n\t}\n\n\tif(uip_aborted()) {\n\t\twebclient_aborted();\n\t}\n\n\tif(uip_timedout()) {\n\t\twebclient_timedout();\n\t}\n\n\tif(uip_acked()) {\n\t\ts.timer = 0;\n\t\tacked();\n\t}\n\n\tif(uip_newdata()) {\n\t\ts.timer = 0;\n\t\tnewdata();\n\t}\n\n\tif(uip_rexmit() || uip_newdata() || uip_acked()) {\n\t\tsenddata();\n\t}\n\telse if(uip_poll()) {\n\t\t++s.timer;\n\t\tif(s.timer == WEBCLIENT_TIMEOUT) {\n\t\t\twebclient_timedout();\n\t\t\tuip_abort();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(uip_closed()) {\n\t\tif(s.httpflag != HTTPFLAG_MOVED) {\n\t\t\t/* Send NULL data to signal EOF. */\n\t\t\twebclient_datahandler(NULL, 0);\n\t\t}\n\t\telse {\n\t\t\t//webclient_get(s.host, s.port, s.file);\n\t\t}\n\t}\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_neighbor_init(void)", "code": "{\n  int i;\n\n  for(i = 0; i < ENTRIES; ++i) {\n    entries[i].time = MAX_TIME;\n  }\n}", "path": "Libraries\\WiShield\\uip-neighbor.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "unsigned char webclient_get(char *host, u16_t port, char *file)", "code": "{\n\tstruct uip_conn *conn;\n\tuip_ipaddr_t ipaddr;\n\n\tuip_ipaddr(&ipaddr, host[0],host[1],host[2],host[3]);\n\n\tconn = uip_connect(&ipaddr, htons(port));\n\n\tif(conn == NULL) {\n\t\treturn 0;\n\t}\n\n\ts.port = port;\n\tstrncpy(s.file, file, sizeof(s.file));\n\tstrncpy(s.host, host, sizeof(s.host));\n\n\tinit_connection();\n\treturn 1;\n}", "path": "Libraries\\WiShield\\examples\\WebClient\\webclient.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */\n", "func_signal": "void delayMicroseconds(unsigned int us)", "code": "{\n\t// calling avrlib's delay_us() function with low values (e.g. 1 or\n\t// 2 microseconds) gives delays longer than desired.\n\t//delay_us(us);\n\n#if F_CPU >= 16000000L\n\t// for the 16 MHz clock on most Arduino boards\n\n\t// for a one-microsecond delay, simply return.  the overhead\n\t// of the function call yields a delay of approximately 1 1/8 us.\n\tif (--us == 0)\n\t\treturn;\n\n\t// the following loop takes a quarter of a microsecond (4 cycles)\n\t// per iteration, so execute it four times for each microsecond of\n\t// delay requested.\n\tus <<= 2;\n\n\t// account for the time taken in the preceeding commands.\n\tus -= 2;\n#else\n\t// for the 8 MHz internal clock on the ATmega168\n\n\t// for a one- or two-microsecond delay, simply return.  the overhead of\n\t// the function calls takes more than two microseconds.  can't just\n\t// subtract two, since us is unsigned; we'd overflow.\n\tif (--us == 0)\n\t\treturn;\n\tif (--us == 0)\n\t\treturn;\n\n\t// the following loop takes half of a microsecond (4 cycles)\n\t// per iteration, so execute it twice for each microsecond of\n\t// delay requested.\n\tus <<= 1;\n\n\t// partially compensate for the time taken by the preceeding commands.\n\t// we can't subtract any more than this or we'd overflow w/ small delays.\n\tus--;\n#endif\n\n\t// busy wait\n\t__asm__ __volatile__ (\n\t\t\"1: sbiw %0,1\" \"\\n\\t\" // 2 cycles\n\t\t\"brne 1b\" : \"=w\" (us) : \"0\" (us) // 2 cycles\n\t);\n}", "path": "Libraries\\arduino\\wiring.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n/*\n * This is the protosocket function that handles the communication. A\n * protosocket function must always return an int, but must never\n * explicitly return - all return statements are hidden in the PSOCK\n * macros.\n */\n", "func_signal": "static int handle_connection(struct socket_app_state *s)", "code": "{\n  PSOCK_BEGIN(&s->p);\n\n  PSOCK_SEND_STR(&s->p, \"Hello. What is you name?\\n\");\n  PSOCK_READTO(&s->p, '\\n');\n  PSOCK_SEND_STR(&s->p, \"Hello \");\n  PSOCK_SEND_STR(&s->p, s->inputbuffer);\n  memset(s->inputbuffer, 0x00, sizeof(s->inputbuffer));\n  PSOCK_CLOSE(&s->p);\n\n  PSOCK_END(&s->p);\n}", "path": "Libraries\\WiShield\\examples\\SocketApp\\socketapp.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "unsigned char\nuiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)", "code": "{\n  unsigned char tmp;\n  char c;\n  unsigned char i, j;\n\n  tmp = 0;\n  \n  for(i = 0; i < 4; ++i) {\n    j = 0;\n    do {\n      c = *addrstr;\n      ++j;\n      if(j > 4) {\n\treturn 0;\n      }\n      if(c == '.' || c == 0) {\n\t*ipaddr = tmp;\n\t++ipaddr;\n\ttmp = 0;\n      } else if(c >= '0' && c <= '9') {\n\ttmp = (tmp * 10) + (c - '0');\n      } else {\n\treturn 0;\n      }\n      ++addrstr;\n    } while(c != '.' && c != 0);\n  }\n  return 1;\n}", "path": "Libraries\\WiShield\\uiplib.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void *\nmemb_alloc(struct memb_blocks *m)", "code": "{\n  int i;\n\n  for(i = 0; i < m->num; ++i) {\n    if(m->count[i] == 0) {\n      /* If this block was unused, we increase the reference count to\n\t indicate that it now is used and return a pointer to the\n\t memory block. */\n      ++(m->count[i]);\n      return (void *)((char *)m->mem + (i * m->size));\n    }\n  }\n\n  /* No free block was found, so we return NULL to indicate failure to\n     allocate block. */\n  return NULL;\n}", "path": "Libraries\\WiShield\\memb.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "struct uip_neighbor_addr *\nuip_neighbor_lookup(uip_ipaddr_t ipaddr)", "code": "{\n  struct neighbor_entry *e;\n\n  e = find_entry(ipaddr);\n  if(e != NULL) {\n    /*    printf(\"Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t   e->addr.addr.addr[0], e->addr.addr.addr[1], e->addr.addr.addr[2], e->addr.addr.addr[3],\n\t   e->addr.addr.addr[4], e->addr.addr.addr[5]);*/\n\n    return &e->addr;\n  }\n  return NULL;\n}", "path": "Libraries\\WiShield\\uip-neighbor.c", "repo_name": "bzztbomb/MissingLinkFirmware", "stars": 8, "license": "gpl-3.0", "language": "c", "size": 338}
{"docstring": "/**\n ** Increments the 'absolute' value(that is, regardless of the +/- sign) of:\n ** \\param s - a number passed as a string (WILL BE FREED AFTERWARDS)\n ** \\returns a wide char equivalent of s\n ** note: will not enlarge the string, overflow is theoretically possible\n **/\n", "func_signal": "static wchar_t* spp2ws(char *s)", "code": "{\n    char *sp;\n    int ws_size = mbstowcs(NULL, s, 0)+1;\n    wchar_t *ws = malloc(sizeof(wchar_t) * ws_size);\n    int carry;\n    \n    for (sp=s; *(sp+1)!='\\0'; ++sp);\n    carry=1;\n    while (carry  &&  *sp>='0' && *sp<='9'  &&  sp>=s) {\n        *sp += carry;\n        if (*sp>'9') {\n            *sp -= '9';\n            carry=1;\n        }\n        else\n            carry=0;\n        --sp;\n    }\n    \n    mbstowcs(ws, s, ws_size);\n    free(s);\n    return ws;\n}", "path": "tests\\numeric.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** A bridge function for sigaction(), jumps via longjmp() back to a setjmp()\n **/\n", "func_signal": "void bridge_sig_jmp(int sig)", "code": "{\n    longjmp(env, sig);\n    return;\n}", "path": "tests\\string.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** A strcmp replacement function (man strncmp)\n **/\n", "func_signal": "size_t own_strncmp(char *s1, char *s2, size_t n)", "code": "{\n    size_t i;\n    if (n<1)\n        return 0;\n    for (i=0; i<n-1 && s2[i]==s1[i]; ++i);\n    return (size_t)(s1[i]-s2[i]);\n}", "path": "tests\\string.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** \\returns 1 if 'key' was found in the sequence, otherwise 0\n ** \\param key - an integer to search for\n ** \\param sequence - a 'sequence' to be searched in\n **/\n", "func_signal": "int seq_has(int key, int *sequence)", "code": "{\n    if (bsearch(&key, &sequence[1], sequence[0], sizeof(int), seq_cmp) != NULL)\n        return 1;\n    return 0;\n}", "path": "tests\\common\\sequence.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** \\returns smaller of the two parameters passed\n ** \\param a first value for the comparison\n ** \\param b second value for the comparison\n **/\n", "func_signal": "size_t min(size_t a, size_t b)", "code": "{\n    if (a < b)\n        return a;\n    return b;\n}", "path": "tests\\string.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n **  Generates a sequence given bounds, and a sequence of integers to exclude\n **  \\param from the lower bound\n **  \\param to the upper bound\n **  \\param exclude another sequence of integers to exclude from the new one\n **  \\returns a pointer to the newly created sequence.\n **/\n", "func_signal": "int* seq_x(int from, int to, int *exclude)", "code": "{\n    int i, j=1, k=0,\n        *sequence = malloc(sizeof(int)*(to-from+2));\n    \n    for (i=from; i<=to; ++i) {\n        if (j <= exclude[0] && i == exclude[j])\n            ++j;\n        else\n            sequence[++k] = i;\n    }\n    sequence[0] = k;\n\n    return sequence;\n}", "path": "tests\\common\\sequence.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** Preforms the actual tests, and prints the results. Takes:\n ** \\param function_nr a 'number' of a function to be called (see function_nrs)\n ** \\param base - the function preforms the test for a single base\n ** \\params wnprtr,result,error - from struct [strwcsto|sscanf]_tests\n ** \\param x - a void pointer to either endptr_offset or sscanf_return\n ** \\param result a pointer to the result(to be cast according to function_nr)\n ** \\returns a non-zero on failure\n **/\n", "func_signal": "static int test_function(const int function_nr, const int base,\n                         const wchar_t *wnptr, const void *x,\n                         const struct function_result result, const int error)", "code": "{\n    ///function names/formats for the output (function_nr used as the index):\n    static const char\n        *f_names[] = {\n            \"strtoumax\",\n            \"strtoimax\",\n            \"strtol\",\n            \"strtoll\",\n            \"strtoul\",\n            \"strtoull\",\n            \"strtof\",\n            \"strtod\",\n            \"strtold\",\n            \n            \"wcstoumax\",\n            \"wcstoimax\",\n            \"wcstol\",\n            \"wcstoll\",\n            \"wcstoul\",\n            \"wcstoull\",\n            \"wcstof\",\n            \"wcstod\",\n            \"wcstold\",\n            \n            \"%ju\",\n            \"%jd\",\n            \"%ld\",\n            \"%lld\",\n            \"%lu\",\n            \"%llu\",\n            \"%f\",\n            \"%lf\",\n            \"%Lf\",\n            \"%o\",\n            \"%x\"\n        };\n    ///remembering return values\n    struct function_result rval;\n    //other stuff\n    int err, wrong;\n    int\n        *f_sscanf    =  seq(fnr_sscanfumax, fnr_sscanfx),\n        f_decimal[]  =  {9, fnr_strtof,  fnr_strtod,  fnr_strtold,\n                            fnr_wcstof,  fnr_wcstod,  fnr_wcstold,\n                            fnr_sscanff, fnr_sscanfd, fnr_sscanfld},\n        *f_wide      =  seq(fnr_wcstoumax, fnr_wcstold);\n    size_t wnptr_size = wcstombs(NULL, wnptr, 0)+1;\n    char *endptr, *resulted, *expected, *s,\n         *nptr = malloc(sizeof(char) + wnptr_size);\n    wcstombs(nptr, wnptr, wnptr_size);\n    wchar_t *wendptr;\n    size_t off, endptr_offset;\n    int ret=0, sscanf_return;\n    \n    errno = err = wrong = 0;\n    switch (function_nr)\n    {\n        case fnr_strtoumax:\n        case fnr_wcstoumax:\n        case fnr_sscanfumax:\n            if (function_nr == fnr_strtoumax)\n                rval.ut = strtoumax(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstoumax)\n                rval.ut = wcstoumax(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%ju\", &rval.ut);\n            err = errno;\n            \n            if (rval.ut != result.ut || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%ju\", rval.ut);\n                expected = sreturnf(\"%ju\", result.ut);\n                wrong = 1;\n            }\n        break;\n        case fnr_strtoimax:\n        case fnr_wcstoimax:\n        case fnr_sscanfimax:\n            if (function_nr == fnr_strtoimax)\n                rval.it = strtoimax(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstoimax)\n                rval.it = wcstoimax(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%jd\", &rval.it);\n            err = errno;\n            \n            if (rval.it != result.it || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%jd\", rval.it);\n                expected = sreturnf(\"%jd\", result.it);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtol:\n        case fnr_wcstol:\n        case fnr_sscanfl:\n            if (function_nr == fnr_strtol)\n                rval.l = strtol(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstol)\n                rval.l = wcstol(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%ld\", &rval.l);\n            err = errno;\n            \n            if (rval.l != result.l || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%ld\", rval.l);\n                expected = sreturnf(\"%ld\", result.l);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtoll:\n        case fnr_wcstoll:\n        case fnr_sscanfll:\n            if (function_nr == fnr_strtoll)\n                rval.ll = strtoll(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstoll)\n                rval.ll = wcstoll(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%lld\", &rval.ll);\n            err = errno;\n            \n            if (rval.ll != result.ll || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%lld\", rval.ll);\n                expected = sreturnf(\"%lld\", result.ll);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtoul:\n        case fnr_wcstoul:\n        case fnr_sscanful:\n            if (function_nr == fnr_strtoul)\n                rval.ul = strtoul(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstoul)\n                rval.ul = wcstoul(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%lu\", &rval.ul);\n            err = errno;\n            \n            if(rval.ul != result.ul || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%lu\", rval.ul);\n                expected = sreturnf(\"%lu\", result.ul);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtoull:\n        case fnr_wcstoull:\n        case fnr_sscanfull:\n            if (function_nr == fnr_strtoull)\n                rval.ull = strtoull(nptr, &endptr, base);\n            else if (function_nr == fnr_wcstoull)\n                rval.ull = wcstoull(wnptr, &wendptr, base);\n            else\n                ret = sscanf(nptr, \"%llu\", &rval.ull);\n            err = errno;\n            \n            if (rval.ull != result.ull || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%llu\", rval.ull);\n                expected = sreturnf(\"%llu\", result.ull);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtof:\n        #ifndef MUSL\n        case fnr_wcstof:\n        #endif\n        case fnr_sscanff:\n            if (function_nr == fnr_strtof)\n                rval.f = strtof(nptr, &endptr);\n            #ifndef MUSL\n            else if (function_nr == fnr_wcstof)\n                rval.f = wcstof(wnptr, &wendptr);\n            #endif\n            else\n                ret = sscanf(nptr, \"%f\", &rval.f);\n            err = errno;\n            \n            if (rval.f != result.f || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%f(%a)\", rval.f, (double)rval.f);\n                expected = sreturnf(\"%f(%a)\", result.f, (double)result.f);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtod:\n        #ifndef MUSL\n        case fnr_wcstod:\n        #endif\n        case fnr_sscanfd:\n            if (function_nr == fnr_strtod)\n                rval.d = strtod(nptr, &endptr);\n            #ifndef MUSL\n            else if (function_nr == fnr_wcstod)\n                rval.d = wcstod(wnptr, &wendptr);\n            #endif\n            else\n                ret = sscanf(nptr, \"%lf\", &rval.d);\n            err = errno;\n            \n            if (rval.d != result.d || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%lf(%a)\", rval.d, rval.d);\n                expected = sreturnf(\"%lf(%a)\", result.d, result.d);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_strtold:\n        #ifndef MUSL\n        case fnr_wcstold:\n        #endif\n        case fnr_sscanfld:\n            if (function_nr == fnr_strtold)\n                rval.ld = strtold(nptr, &endptr);\n            #ifndef MUSL\n            else if (function_nr == fnr_wcstold)\n                rval.ld = wcstold(wnptr, &wendptr);\n            #endif\n            else\n                ret = sscanf(nptr, \"%Lf\", &rval.ld);\n            err = errno;\n            \n            if (rval.ld != result.ld || (error!=-1 && err!=error)){\n                s = strhex((unsigned char*)&rval.ld, sizeof(rval.ld));\n                resulted = sreturnf(\"%Lf(%s)\", rval.ld, s);\n                free(s);\n                s = strhex((unsigned char*)&result.ld, sizeof(result.ld));\n                expected = sreturnf(\"%Lf(%s)\", result.ld, s);\n                free(s);\n                wrong = 1;\n\t\t\t}\n        break;\n        case fnr_sscanfo:\n        case fnr_sscanfx:\n            if (function_nr == fnr_sscanfo)\n                ret = sscanf(nptr, \"%o\", &rval.ui);\n            else if (function_nr == fnr_sscanfx)\n                ret = sscanf(nptr, \"%x\", &rval.ui);\n            err = errno;\n            \n            if (rval.ui != result.ui || (error!=-1 && err!=error)){\n                resulted = sreturnf(\"%u(%o)\", rval.ui, rval.ui);\n                expected = sreturnf(\"%u(%a)\", result.ui, rval.ui);\n                wrong = 1;\n\t\t\t}\n        break;\n        default:\n            wrong = -1;\n        break;\n    }\n    \n    if (wrong == -1)\n        ;//missing function\n    else if (wrong) {\n        s = e_name(error);\n        if (!seq_has(function_nr, f_sscanf)) {\n            fprintf(stderr, \"%s(\\\"%ls\\\", &endptr\", f_names[function_nr],wnptr);\n            if (!seq_has(function_nr, f_decimal))\n                fprintf(stderr, \", %d\", base);\n            fprintf(stderr, \") should return %s, errno=%s\\n\", expected, s);\n            fprintf(stderr,\"\\tinstead, it returns\");\n        } else {\n            fprintf(\n                stderr,\n                \"sscanf(\\\"%ls\\\", \\\"%s\\\", ...) should produce %s, errno=%s\\n\",\n                wnptr, f_names[function_nr], expected, s\n            );\n            fprintf(stderr,\"\\tinstead, it produces\");\n        }\n        free(s);\n        fprintf(stderr, \" %s, errno=%s\\n\", resulted, e_name(err));\n        free(resulted);\n        free(expected);\n    } else if (seq_has(function_nr, f_sscanf)) {\n        sscanf_return = *((int *)x);\n        if (ret != sscanf_return)\n        {\n            fprintf (\n                stderr,\n                \"sscanf(\\\"%ls\\\", \\\"%s\\\", ...) returns %d instead of %d\\n\",\n                wnptr, f_names[function_nr], ret, sscanf_return\n            );\n        }\n    } else {\n        endptr_offset = *((size_t *)x);\n        if(seq_has(function_nr, f_wide))\n          off = (size_t)wendptr/sizeof(wchar_t) -(size_t)wnptr/sizeof(wchar_t);\n        else\n          off = (size_t)endptr/sizeof(char) -(size_t)nptr/sizeof(char);\n        \n        if (off != endptr_offset)\n        {\n            wrong = 1;\n            fprintf(stderr,\"%s(\\\"%ls\\\", &endptr, \",f_names[function_nr],wnptr);\n            if(!seq_has(function_nr, f_decimal))\n                fprintf(stderr, \"%i\", base);\n            fprintf (\n                stderr,\n                \") offsets endptr by %zu instead of by %zu\\n\",\n                off, endptr_offset\n            );\n        }\n    }\n    free(nptr);\n    \n    return wrong;\n}", "path": "tests\\numeric.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///A handy auxiliary function, passes seq_x an empty exclude sequence\n", "func_signal": "int* seq(int from, int to)", "code": "{\n    static int none[] = {0, 0};\n    return seq_x(from, to, none);\n}", "path": "tests\\common\\sequence.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** Tests string.h functions for invalid memory access\n ** and for correctnes when handling various byte values.\n **\n ** functions tested: memcpy\n **/\n", "func_signal": "int main()", "code": "{\n    char *m1, *m2, *m3, *s1, *s2,  tmpc, *tmps;\n    unsigned int i, j, k,\n        reported[100]; ///< prevents recurring error messages !0 = \"reported\"\n    const int fd = open(\"/dev/zero\", O_RDWR);\n    const size_t pg_size = sysconf(_SC_PAGESIZE);\n    size_t t, real_size, buf_size[] =\n    {\n        1,                  //also tests 0 lenth\n        sizeof(size_t)+1,   //brute force tests (keep it small)\n        \n        2,\n        pg_size+1,\n        4*pg_size,\n        4*1024*1024\n    };\n    struct sigaction oldact, act;\n\n    //call bridge_sig_jmp on segmentation fault:\n    act.sa_handler = bridge_sig_jmp;\n    act.sa_flags   = SA_NODEFER;\n    sigaction(SIGSEGV, &act, &oldact);\n    for (i=0; i<sizeof(buf_size)/sizeof(buf_size[0]); ++i) {\n        //stretch to a page size:\n        real_size = (buf_size[i]/pg_size) * pg_size;\n        if (buf_size[i]%pg_size != 0)\n            real_size += pg_size;\n        //allocate three memory segments, restrict the access to the last one:\n        m1 = mmap(NULL, real_size*3, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n        m3 = m1+(real_size*2);\n        mprotect(m3, real_size, PROT_NONE);\n        m2 = m3-buf_size[i]; //just before the restricted segment\n        \n        if (buf_size[i] == 1) {\n            /* -- 0 length tests -- */\n            //memcpy\n            if (!setjmp(env)) {\n                if (memcpy(m3, m1, 0) != m3)\n                    fprintf(stderr, \"memcpy returned a wrong value when asked to copy 0B TO restricted memory\\n\");\n            } else\n                fprintf(stderr, \"memcpy tried to access restricted memory when asked to copy 0B TO it\\n\");\n            if (!setjmp(env)) {\n                if (memcpy(m1, m3, 0) != m1)\n                    fprintf(stderr, \"memcpy returned a wrong value when asked to copy 0B FROM restricted memory\\n\");\n            } else\n                fprintf(stderr, \"memcpy tried to access restricted memory when asked to copy 0B FROM it\\n\");\n            \n            //memchr\n            *m2 = 'a';\n            if (!setjmp(env)) {\n                if (memchr(m2, '\\0', 0) != NULL || memchr(m2, 'a', 0) != NULL || memchr(m3, '\\0', 0) != NULL)\n                    fprintf(stdout, \"memchr failed to return a NULL pointer when given 0B to search through\\n\");\n            } else\n                fprintf(stderr, \"memchr tried to access restricted memory when given 0B to search through\\n\");\n                \n            \n            \n            /* -- single byte tests with all possible byte values -- */\n            for (j=0; j<3; ++j)\n                reported[j] = 0;\n            \n            for (j=0; j<=255; ++j) {\n                //memcpy\n                for (k=0; k<=255; ++k) {\n                    if (!reported[0]) {\n                        *m1 = (char)j;\n                        *m2 = (char)k;\n                        tmpc = *m2;\n                        if (!setjmp(env)) {\n                            if (memcpy(m1, m2, 1) != m1)\n                               reported[0] = fprintf(stderr, \"memcpy returned a wrong value after copying a single byte(%d)\\n\", k);\n                            if (*m1 != tmpc)\n                               reported[0] = fprintf(stderr, \"memcpy incorrectly copied a single byte(%d)\\n\", k);\n                        } else\n                            reported[0] = fprintf(stderr, \"memcpy failed to stop after reading a single byte(%d)\\n\", k);\n                    }\n                    \n                    if (!reported[1]) {\n                        *m1 = (char)j;\n                        *m2 = (char)k;\n                        tmpc = *m1;\n                        if (!setjmp(env)) {\n                            if (memcpy(m2, m1, 1) != m2)\n                                reported[1] = fprintf(stderr, \"memcpy returned a wrong value after copying a single byte(%d)\\n\", j);\n                            if (*m2 != tmpc)\n                               reported[1] = fprintf(stderr, \"memcpy incorrectly copied a single byte(%d)\\n\", j);\n                        } else\n                            reported[1] = fprintf(stderr, \"memcpy failed to stop after writing a single byte(%d)\\n\", j);\n                    }\n                }\n                 \n                //memchr\n                if (!reported[2]) {\n                    tmpc = *m2 = (char)j;\n                    if (!setjmp(env)) {\n                        if (memchr(m2, tmpc, 1) != m2)\n                            reported[2] = fprintf(stderr, \"memchr returned a wrong value searching for THE one byte(%d)\\n\", j);\n                    } else\n                       reported[2] = fprintf(stderr, \"memchr failed to stop searching for THE one byte(%d)\\n\", j);\n                }\n            }\n        }\n        /* -- brute force alignment/bitfield tests -- */\n        else if (buf_size[i] == sizeof(size_t)+1) {   \n            for (j=0; j<2; ++j)\n               reported[j] = 0;\n            for (s2=m2; s2<m3; ++s2) {\n                //memcpy\n                for (s1=m1; s1<m2;  ++s1) {\n                    for (t=0; !reported[0] && t<=min(m2-s1, m3-s2); ++t) {\n                        for (k=0; k<buf_size[i]; ++k)\n                            m2[k] = 256-(m1[k] = k%256); //various Bs\n                        if (!setjmp(env)) {\n                            if (memcpy(s1, s2, t) != s1 || memcpy(s2, s1, t) != s2)\n                                reported[0] = fprintf(stderr, \"memcpy(%zu,%zu,%zu) returned a wrong value\\n\", (size_t)s1, (size_t)s2, t);\n                            if (own_strncmp(s1, s2, t))\n                                reported[0] = fprintf(stderr, \"memcpy(%zu,%zu,%zu) incorrectly copied memory\\n\", (size_t)s1, (size_t)s2, t);\n                        } else\n                            reported[0] = fprintf(stderr, \"memcpy(%zu,%zu,%zu) tried to access restricted memory\\n\", (size_t)s1, (size_t)s2, t);\n                    }\n                }\n                \n                //memchr\n                for (j=0; j<=255; ++j) {\n                    for (k=0; k<buf_size[i]; ++k) {\n                        m2[k] = k%256;\n                        if ((unsigned char)m2[k] == j)\n                            ++m2[k];\n                    }\n                    for (k=0; k<m3-s2; ++k) {\n                        for (t=0; !reported[1] && t<(size_t)(m3-s2); ++t) {\n                            tmpc = s2[k];\n                            s2[k] = (char)j;\n                            if (!setjmp(env)) {\n                                if ((t>k && (tmps=memchr(s2, (char)j, t)) != s2+k) || (t<=k && (tmps=memchr(s2, (char)j, t)) != NULL))\n                                    reported[1] = fprintf(stderr, \"memchr(%zu,%d,%zu) returned a wrong value(%zu)\\n\", (size_t)s2, j, t, (size_t)tmps);\n                            } else\n                                reported[1] = fprintf(stderr, \"memchr(%zu,%d,%zu) tried to access restricted memory\\n\", (size_t)s2, j, t);\n                            s2[k] = tmpc;\n                        }\n                    }\n                }\n            }\n             \n        }\n        /* -- tests for other lengths -- */\n        else {\n            for (j=0; j<2; ++j) {\n                //memcpy\n                for (k=0; k<buf_size[i]; ++k)\n                    m2[k] = 255-(m1[k] = k%255);\n                if (!setjmp(env)) {\n                    if (!j && memcpy(m1, m2, buf_size[i]) != m1)\n                        fprintf(stderr, \"memcpy returned a wrong value after reading %zuB\\n\", buf_size[i]);\n                    else if (j && memcpy(m2, m1, buf_size[i]) != m2)\n                        fprintf(stderr, \"memcpy returned a wrong value after writing %zuB\\n\", buf_size[i]);\n                    if (own_strncmp(m1, m2, buf_size[i]))\n                        fprintf(stderr, \"memcpy incorrectly copied %zuB\\n\", buf_size[i]);\n                } else {\n                    if (!j)\n                        fprintf(stderr, \"memcpy failed to stop after copying %zuB\\n\", buf_size[i]);\n                    else if (j)\n                        fprintf(stderr, \"memcpy failed to stop after writing %zuB\\n\", buf_size[i]);\n                }\n            }\n            \n            //memchr\n            for (k=0; k<buf_size[i]; ++k) {\n                m2[k] = k%256;\n                if (m2[k] == 1)\n                    ++m2[k];\n            }\n            m2[k-1] = 1;\n            if (!setjmp(env)) {\n                if ((tmps = memchr(m2, 1, buf_size[i])) != &m2[k-1])\n                    fprintf(stderr, \"memchr returned a wrong value searching %zuB for a 1\\n\", buf_size[i]);\n            } else\n               fprintf(stderr, \"memchr failed to stop searching %zuB for a 1\\n\", buf_size[i]);\n        }\n\n        \n        munmap(m1, real_size*3);\n    }\n    sigaction(SIGSEGV, &oldact, NULL);\n    \n    return 0;\n}", "path": "tests\\string.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///waits for blocked to be unset by a signal[!] via the signal handler, returns\n", "func_signal": "static void block(void)", "code": "{\n    while(blocked)\n        sched_yield(); //can't use pause() - handle() doesn't return on SIGTERM\n    sleep(3);printf(\"exit block()\\n\");//---\n}", "path": "tests\\pthread_eintr.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///< Wrappers start here: They take the same~ arguments as the functions that\n///< they call, but catch SIGSEGVs, and return error codes on failure\n", "func_signal": "static int wrap_confstr(int name, char *buf, size_t len)", "code": "{\n        int err = 0;\n        sigaction(SIGSEGV, &act, &oldact[0]);\n        if(!setjmp(env)) {\n            if (confstr(name, buf, len)  ==  0)\n                err = errno;\n        }else\n            err = -1;\n        sigaction(SIGSEGV, &oldact[0], NULL);\n        return err;\n}", "path": "tests\\buf.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** Signal handler. Upon receiving the first SIGTERM it unsets blocked, longjmps\n ** Otherwise - on another signal or if blocked is unset - it simply returns\n **/\n", "func_signal": "static void handle(int sig)", "code": "{\n    if (sig == SIGTERM) {\n        if(blocked) {\n            blocked = 0;\n            longjmp(env, 1);\n        }\n        //else {printf(\"BUG: Misplaced SIGTERM!\\n\");} //-----\n    }\n}", "path": "tests\\pthread_eintr.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "//\\file depends: strerror, [sreturnf]\n/**\n ** \\returns a string with a human-readable error name\n ** \\param error - errno to be \"stringized\"\n **/\n", "func_signal": "char* e_name(int error)", "code": "{\n    char *s;\n    \n    switch (error) {\n        case -1:\n            s = sreturnf(\"<any>\");\n        break;\n        case EINVAL:\n            s = sreturnf(\"EINVAL\");\n        break;\n        case ERANGE:\n            s = sreturnf(\"ERANGE\");\n        break;\n        case ENOMEM:\n            s = sreturnf(\"ENOMEM\");\n        break;\n        case E2BIG:\n            s = sreturnf(\"E2BIG\");\n        break;\n        case ENAMETOOLONG:\n            s = sreturnf(\"ENAMETOOLONG\");\n        break;\n        case EINTR:\n            s = sreturnf(\"EINTR\");\n        break;\n        default:\n            s = sreturnf(\"%i(%s)\", error, strerror(error));\n        break;\n    }\n    return s;\n}", "path": "tests\\common\\e_name.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** Establishes the function passed to it as a thread cancellation handler and\n ** calls it. Thus, if the executing thread is canceled, the said function will\n ** still have to be executed before the thread is terminated.\n ** \\param fun a void* cast of (void (*)()) or NULL (only return)\n **/\n", "func_signal": "static void* thread(void *fun)", "code": "{\n    if (fun != NULL) {\n        pthread_cleanup_push(fun, NULL);\n        ((void (*)())fun)();\n        pthread_cleanup_pop(0);\n    }\n    return NULL;\n}", "path": "tests\\pthread_eintr.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///Compares two integers given pointers to them (needed for bsearch in seq_has)\n", "func_signal": "int seq_cmp(const void *a, const void *b)", "code": "{\n    if (*(int*)a < *(int*)b)\n        return -1;\n    else if (*(int*)a == *(int*)b)\n        return 0;\n    return 1;\n}", "path": "tests\\common\\sequence.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///A SIGABRT/SIGSEGV - resistant free()\n", "func_signal": "static int safe_free(void* vp)", "code": "{\n    int sig;\n    struct sigaction\n        act = {.sa_handler=bridge_sig_jmp},\n        oldact[2];\n    sigaction(SIGABRT, &act, &oldact[0]);\n    sigaction(SIGSEGV, &act, &oldact[0]);\n    if (!(sig = setjmp(env)))\n        free(vp);\n    sigaction(SIGSEGV, &oldact[0], NULL);\n    sigaction(SIGABRT, &oldact[0], NULL);\n    return sig;\n}", "path": "tests\\buf.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///A bridge function for sigaction(), jumps via longjmp() back to a setjmp()\n", "func_signal": "void bridge_sig_jmp(int sig)", "code": "{\n    longjmp(env, sig);\n    return;\n}", "path": "tests\\buf.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n ** Represents bytes as a string of 'hexadecimal numerals'\n ** \\param object - pointer to the memory to be represented\n ** \\param length - the number of bytes to be processed\n ** \\returns a string with the hexadecimal representation\n **/\n", "func_signal": "static char* strhex(unsigned char *object, size_t length)", "code": "{\n    unsigned int i;\n    char *s = malloc(sizeof(char) * length*2+1);\n    \n    for (i=0; i<length; ++i)\n            sprintf(&s[i*2], \"%.2x\", object[i]);\n    s[i*2]='\\0';\n    \n    return s;\n}", "path": "tests\\numeric.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "/**\n **  Tests [wcs|str]to* functions' and sscanf's return values when given\n **  corner-case arguments, as well as whether they set correct errno values\n **/\n", "func_signal": "int main()", "code": "{\n    setlocale(LC_NUMERIC, \"POSIX\");\n    int i, j, k, err, failed, decimal;\n    //note that given a sufficiently large base, x=34 and z=36:\n    int\n        b_zero[]           =  {1, 0},\n        b_sixteen[]        =  {1, 16},\n        b_hexadecimal[]    =  {2, 0,16},\n        b_x[]              =  {1, 34},\n        *b_nothexadecimal  =  seq_x(0,33, b_hexadecimal),\n        *b_lessthanx       =  seq(0,33),\n        *b_xandabove       =  seq(34,36),\n        *b_all             =  seq(0,36);\n    int\n        *f_strwcsto           =  seq(fnr_strtoumax, fnr_wcstold),\n        *f_sscanf             =  seq(fnr_sscanfumax, fnr_sscanfx),\n        f_sscanf_decimal[]    =  {3, fnr_sscanff, fnr_sscanfd, fnr_sscanfld},\n        f_strwcsto_decimal[]  =  {6, fnr_strtof, fnr_strtod, fnr_strtold,\n                                     fnr_wcstof, fnr_wcstod, fnr_wcstold},\n        f_sscanfx[]           =  {1, fnr_sscanfx},\n        *f_sscanf_nonx        =  seq(fnr_sscanfumax, fnr_sscanfo);\n    struct function_result\n        r_zero      =  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n        r_one       =  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n        r_thirty    =  {30,30,30,30,30,30,30,30,30,30},\n        r_x         =  {33,33,33,33,33,33,33,33,33,33},\n        r_x0        =  {1122,1122,1122,1122,1122,1122,1122,1122,1122,1122},\n        r_0_0625    =  {.f=0.0625, .d=0.0625, .ld=0.0625L},\n        r_0_1       =  {.f=0.1,    .d=0.1,    .ld=0.1L};\n    wchar_t *max[] = {\n        spp2ws(sreturnf(\"%jd\\0\",  INTMAX_MAX)),\n        spp2ws(sreturnf(\"%jd\\0\",  INTMAX_MIN)),\n        spp2ws(sreturnf(\"%ju\\0\",  UINTMAX_MAX)),\n        spp2ws(sreturnf(\"%ld\\0\",  LONG_MAX)),\n        spp2ws(sreturnf(\"%ld\\0\",  LONG_MIN)),\n        spp2ws(sreturnf(\"%lld\\0\", LLONG_MAX)),\n        spp2ws(sreturnf(\"%lld\\0\", LLONG_MIN)),\n        spp2ws(sreturnf(\"%lu\\0\",  ULONG_MAX)),\n        spp2ws(sreturnf(\"%llu\\0\", ULLONG_MAX)),\n        spp2ws(sreturnf(\"%f\\0\",   FLT_MAX)),\n        spp2ws(sreturnf(\"%f\\0\",   FLT_MIN)),\n        spp2ws(sreturnf(\"%lf\\0\",  DBL_MAX)),\n        spp2ws(sreturnf(\"%lf\\0\",  DBL_MIN)),\n        spp2ws(sreturnf(\"%Lf\\0\",  LDBL_MAX)),\n        spp2ws(sreturnf(\"%Lf\\0\",  LDBL_MIN))\n    };\n    \n    struct strwcsto_tests {\n        int                    *function_nrs;\n        wchar_t                *wnptr;\n        size_t                 endptr_offset;\n        int                    *bases;\n        struct function_result result;\n        int                    error;\n    } t[] = {\n        //Universal strto* tests:\n        //functions   wnptr    end  bases             result   error\n        {f_strwcsto,  L\"0 1\",  1,   b_all,            r_zero,  0},\n        {f_strwcsto,  L\"01\",   2,   b_all,            r_one,   0},\n        {f_strwcsto,  L\"0+1\",  1,   b_all,            r_zero,  0},\n        {f_strwcsto,  L\"0-1\",  1,   b_all,            r_zero,  0},      \n        //standard says to match the first char making the rest invalid:\n        {f_strwcsto,  L\"- 1\",  0,   b_all,            r_zero,  -1},\n        {f_strwcsto,  L\"--1\",  0,   b_all,            r_zero,  -1},\n        {f_strwcsto,  L\"-+1\",  0,   b_all,            r_zero,  -1},\n        {f_strwcsto,  L\"+-1\",  0,   b_all,            r_zero,  -1},\n        \n        //Non-base-X strto* tests, and explicitly base >=X tests:\n        //functions   wnptr    end  bases             result   error\n        //the 'longest initial subsequence OF THE EXPECTED FORM' is \"?0\"\n        {f_strwcsto,  L\"0x\",   1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0xX\",  1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0Xx\",  1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0x 1\", 1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0x+1\", 1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0x-1\", 1,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"00x1\", 2,   b_lessthanx,      r_zero,  0},\n        {f_strwcsto,  L\"0X0x\", 1,   b_nothexadecimal, r_zero,  0},\n        //Not a hex value (x is 33):\n        {f_strwcsto,  L\"0x\",   2,   b_xandabove,      r_x,     0},\n        {f_strwcsto,  L\"0X\",   2,   b_xandabove,      r_x,     0},\n        {f_strwcsto,  L\"0x0\",  3,   b_x,              r_x0,    0},\n        {f_strwcsto,  L\"0X0\",  3,   b_x,              r_x0,    0},\n    \n        //Decimal strto* tests(NOTE: base 16 is faux, behavior is more like 0):\n        //functions          wnptr     end (bases)     result        error\n        {f_strwcsto_decimal, L\"0x.1\",  4,  b_sixteen,  r_0_0625,     0},\n        {f_strwcsto_decimal, L\".10x1\", 3,  b_sixteen,  r_0_1,        0},\n        //E is a hexadecimal numeral, not an exponent:\n        {f_strwcsto_decimal, L\"0x1e\",  4,  b_sixteen,  r_thirty,     0},\n        {f_strwcsto_decimal, L\"0x1E\",  4,  b_sixteen,  r_thirty,     0},\n        //a 'non-empty sequence' missing before E/P: this is not hexadecimal,\n        //hexadecimal for 'decimal' functions invariably has a \"0x\" prefix:\n        {f_strwcsto_decimal, L\"e1\",    0,  b_sixteen,  r_zero,       -1},\n        {f_strwcsto_decimal, L\"E1\",    0,  b_sixteen,  r_zero,       -1},\n        {f_strwcsto_decimal, L\"p1\",    0,  b_sixteen,  r_zero,       -1},\n        {f_strwcsto_decimal, L\"P1\",    0,  b_sixteen,  r_zero,       -1},\n        //missing exponent (+/- after exponent is optional, the rest isn't):\n        {f_strwcsto_decimal, L\"1e\",    1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1E\",    1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1p\",  3,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1P\",  3,  b_sixteen,  r_one,        0},\n        \n        {f_strwcsto_decimal, L\"1e+\",   1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1E+\",   1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1e-\",   1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1E-\",   1,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1p-\", 3,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1P-\", 3,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1p+\", 3,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"0x1P+\", 3,  b_sixteen,  r_one,        0},\n        //'optional' [+|-] does not make invalid:\n        {f_strwcsto_decimal, L\"-0x0\",  4,  b_sixteen,  r_zero,       0},\n        {f_strwcsto_decimal, L\"+0x1\",  4,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1e+0\",  4,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1E+0\",  4,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1e-0\",  4,  b_sixteen,  r_one,        0},\n        {f_strwcsto_decimal, L\"1E-0\",  4,  b_sixteen,  r_one,        0},\n    \n        //Min/max value tests of individual functions(code's wide here,i know):\n        //functions                               wnptr     end              bases      result               error\n        {(int[]){2,fnr_strtoimax,fnr_wcstoimax},  max[0],   wcslen(max[0]),  b_zero,    {.it = INTMAX_MAX},  ERANGE},\n        {(int[]){2,fnr_strtoimax,fnr_wcstoimax},  max[1],   wcslen(max[1]),  b_zero,    {.it = INTMAX_MIN},  ERANGE},\n        {(int[]){2,fnr_strtoumax,fnr_wcstoumax},  max[2],   wcslen(max[2]),  b_zero,    {.ut = UINTMAX_MAX}, ERANGE},\n        {(int[]){2,fnr_strtol,   fnr_wcstol},     max[3],   wcslen(max[3]),  b_zero,    {.l  = LONG_MAX},    ERANGE},\n        {(int[]){2,fnr_strtol,   fnr_wcstol},     max[4],   wcslen(max[4]),  b_zero,    {.l  = LONG_MIN},    ERANGE},\n        {(int[]){2,fnr_strtoll,  fnr_wcstoll},    max[5],   wcslen(max[5]),  b_zero,    {.ll = LLONG_MAX},   ERANGE},\n        {(int[]){2,fnr_strtoll,  fnr_wcstoll},    max[6],   wcslen(max[6]),  b_zero,    {.ll = LLONG_MIN},   ERANGE},\n        {(int[]){2,fnr_strtoul,  fnr_wcstoul},    max[7],   wcslen(max[7]),  b_zero,    {.ul = ULONG_MAX},   ERANGE},\n        {(int[]){2,fnr_strtoull, fnr_wcstoull},   max[8],   wcslen(max[8]),  b_zero,    {.ull= ULLONG_MAX},  ERANGE},\n        \n        {(int[]){2,fnr_strtof,   fnr_wcstof},     max[9],   wcslen(max[9]),  b_sixteen, {.f  = HUGE_VALF},   ERANGE},\n        {(int[]){2,fnr_strtof,   fnr_wcstof},     max[10],  wcslen(max[10]), b_sixteen, {.f  = -HUGE_VALF},  ERANGE},\n        {(int[]){2,fnr_strtod,   fnr_wcstod},     max[11],  wcslen(max[11]), b_sixteen, {.d  = HUGE_VAL},    ERANGE},\n        {(int[]){2,fnr_strtod,   fnr_wcstod},     max[12],  wcslen(max[12]), b_sixteen, {.d  = -HUGE_VAL},   ERANGE},\n        {(int[]){2,fnr_strtold,  fnr_wcstold},    max[13],  wcslen(max[13]), b_sixteen, {.ld = HUGE_VALL},   ERANGE},\n        {(int[]){2,fnr_strtold,  fnr_wcstold},    max[14],  wcslen(max[14]), b_sixteen, {.ld = -HUGE_VALL},  ERANGE},\n    };\n    \n    struct sscanf_tests {\n        int                    *function_nrs;\n        wchar_t                *wnptr;\n        int                    sscanf_return;\n        struct function_result result;\n        int                    error;\n    } t2[] = {\n        //functions         wnptr    s_r  result   error\n        {f_sscanf,          L\"0 1\",  1,   r_zero,  0},\n        {f_sscanf,          L\"01\",   1,   r_one,   0},\n        {f_sscanf,          L\"0+1\",  1,   r_zero,  0},\n        {f_sscanf,          L\"0-1\",  1,   r_zero,  0},\n        {f_sscanf,          L\"00x1\", 1,   r_zero,  0},\n        {f_sscanf,          L\"0X0x\", 1,   r_zero,  0},\n        //standard says to match the first char making the rest invalid:\n        {f_sscanf,          L\"- 1\",  0,   r_zero,  -1},\n        {f_sscanf,          L\"--1\",  0,   r_zero,  -1},\n        {f_sscanf,          L\"-+1\",  0,   r_zero,  -1},\n        {f_sscanf,          L\"+-1\",  0,   r_zero,  -1},\n        //the 'longest initial subsequence OF THE EXPECTED FORM' is \"0\"\n        {f_sscanfx,         L\"0x\",   1,   r_zero,  0},\n        {f_sscanfx,         L\"0x 1\", 1,   r_zero,  0},\n        {f_sscanfx,         L\"0x+1\", 1,   r_zero,  0},\n        {f_sscanfx,         L\"0x-1\", 1,   r_zero,  0},\n        {f_sscanfx,         L\"0Xx\",  1,   r_zero,  0},\n        {f_sscanfx,         L\"0xX\",  1,   r_zero,  0},\n        //should be a valid zero interpreted as a non-16 base number:\n        {f_sscanf_nonx,     L\"0xX\",  1,   r_zero,  0},\n        {f_sscanf_nonx,     L\"0Xx\",  1,   r_zero,  0},\n        {f_sscanf_nonx,     L\"0x+1\", 1,   r_zero,  0},\n        {f_sscanf_nonx,     L\"0x-1\", 1,   r_zero,  0},\n    \n        //Decimal sscanf tests:\n        //functions         wnptr     s_r  result    error\n        {f_sscanf_decimal,  L\"0x.1\",  1,   r_0_0625, 0},\n        {f_sscanf_decimal,  L\".10x1\", 1,   r_0_1,    0},\n        //a 'non-empty sequence' missing before E/P:\n        {f_sscanf_decimal,  L\"e1\",    0,   r_zero,   -1},\n        {f_sscanf_decimal,  L\"E1\",    0,   r_zero,   -1},\n        {f_sscanf_decimal,  L\"p1\",    0,   r_zero,   -1},\n        {f_sscanf_decimal,  L\"P1\",    0,   r_zero,   -1},\n        //missing exponent (+/- optional, the rest isn't):\n        {f_sscanf_decimal,  L\"1e\",    1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1E\",    1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1p\",  1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1P\",  1,   r_one,    0},\n        \n        {f_sscanf_decimal,  L\"1e+\",   1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1E+\",   1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1p+\", 1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1P+\", 1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1e-\",   1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1E-\",   1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1p-\", 1,   r_one,    0},\n        {f_sscanf_decimal,  L\"0x1P-\", 1,   r_one,    0},\n        //'optional' does not make invalid:\n        {f_sscanf_decimal,  L\"1e+0\",  1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1E+0\",  1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1e-0\",  1,   r_one,    0},\n        {f_sscanf_decimal,  L\"1E-0\",  1,   r_one,    0},\n    };\n    \n    failed=0;\n    //Execute strwcsto tests (decimal functions only if testing base 16 too):\n    for (i=0; i<(int)(sizeof(t)/sizeof(t[0])); ++i) {\n        err = 0;\n        for (j=1; !err && j<=t[i].function_nrs[0]; ++j) {\n            decimal = seq_has(t[i].function_nrs[j], f_strwcsto_decimal);\n            for (k=1; !err && k <= t[i].bases[0]; ++k)\n                if (t[i].bases[k] != 1 && (!decimal || t[i].bases[k]==16))\n                    err = test_function(\n                                        t[i].function_nrs[j],\n                                        t[i].bases[k],\n                                        t[i].wnptr,\n                                        &t[i].endptr_offset,\n                                        t[i].result,\n                                        t[i].error\n                    );\n        }\n        if (err)\n            ++failed;\n    }\n    \n    //Execute sscanf tests:\n    for (i=0; i<(int)(sizeof(t2)/sizeof(t2[0])); ++i) {\n        err = 0;\n        for (j=1; !err && j<=t2[i].function_nrs[0]; ++j)\n            err = test_function(\n                                t2[i].function_nrs[j],\n                                0,\n                                t2[i].wnptr,\n                                &t2[i].sscanf_return,\n                                t2[i].result,\n                                t2[i].error\n            );\n        if (err)\n            ++failed;\n    }\n    \n    return failed;\n}", "path": "tests\\numeric.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
{"docstring": "///<Wrappers start here: They take the same arguments as the functions they\n///<call but install the SIGTERM handler and optionally loop until it's received\n", "func_signal": "static int wrap_pthread_create(pthread_t *restrict thread,\n                               const pthread_attr_t *restrict attr,\n                               void *(*start_routine)(void*),\n                               void *restrict arg)", "code": "{\n    WRAP_START\n        while (!err)\n            err = pthread_create(thread, attr, start_routine, arg);\n    WRAP_END\n}", "path": "tests\\pthread_eintr.c", "repo_name": "lmarcetic/cluts", "stars": 8, "license": "None", "language": "c", "size": 404}
