{"docstring": "/**\n * Generates command string required by authentication process.\n * Does what Linux NateOn's void NateonDPConnection::putLSIN() does.\n */\n", "func_signal": "char *makeLSIN( const char *username, const char *password, gchar *ticket )", "code": "{\n\tchar *id, *pcname, *pcid, *lockey, *info, *cmd;\n\t// Linux NateOn sends user id (YOUR PC LOGON!) and the HOSTNAME!\n\t// I don't want that to happen. I'm sending the id from my mail address,\n\t// which SK already knows.\n\t// Also, instead of telling them my real hostname, I'm sending ubuntu,\n\t// which is the default value for Ubuntu distro.\n\tid = g_strdup(username);\n\tstrtok(id, \"@\");\n\tpcname = g_strdup_printf( \"%s@ubuntu\", id );\n\n\t/* NateOn saves PCID  on your PC. pidgin-nateon doesn't */\n\tpcid = makePCID();\n\tlockey = getLocKey();\n\n\tinfo = g_strdup_printf( \"SSL 1.1.0.301 UTF8 ko.linuxm %%00 %s %c %s %s\",\n\t\t\t\t makePCID(),\n\t\t\t\t 'N', /* silent login? */\n\t\t\t\t pcname, lockey );\n\n\tcmd = g_strdup_printf(\"%s %s %s\", username, ticket, info );\n\n\tg_free( info );\n\tg_free( pcname );\n\tg_free( pcid );\n\t//g_free( ticket );\n\tfree( lockey ); /* getLocKey uses malloc */\n\n\treturn cmd;\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Log out\n **************************************************************************/\n", "func_signal": "static void\nkill_cmd(NateonCmdProc *cmdproc, NateonCommand *cmd)", "code": "{\n//\tif (!g_ascii_strcasecmp(cmd->params[0], \"OTH\"))\n\t\tnateon_session_set_error(cmdproc->session, NATEON_ERROR_SIGN_OTHER,\n\t\t\t\t\t\t\t  NULL);\n//\telse if (!g_ascii_strcasecmp(cmd->params[0], \"SSD\"))\n//\t\tnateon_session_set_error(cmdproc->session, NATEON_ERROR_SERV_DOWN, NULL);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * get \uce5c\uad6c\uc774\ub984\n * Retrieves data->from_friendly, guessed from data->from.\n */\n", "func_signal": "static const char *\nimsg_get_friendly_name( const char *mail, NateonCmdProc *cmdproc)", "code": "{\n\tNateonUser *user = nateon_userlist_find_user_with_name(cmdproc->session->userlist, mail);\n\treturn nateon_user_get_friendly_name(user);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * Many commands carry payload...\n */\n", "func_signal": "void payload_cmd( NateonCmdProc *cmdproc, NateonCommand *cmd, int payload_index )", "code": "{\n\tint len;\n\tpurple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\n\tif( cmd->param_count == 0 )\n\t\treturn;\n\t\n\tif( cmd->param_count <= payload_index )\n\t{\n\t\t// probably some ack signal like CMSG 8 0\n\t\treturn;\n\t}\n\n\t// set expected payload length\n\tlen = atoi(cmd->params[payload_index]);\n\tcmdproc->servconn->payload_len = len;\n\n\tif( len == 0 )\n\t{\n\t\t// do nothing, since payload == 0.\n\t\tcmdproc->last_cmd->payload_cb  = NULL;\n\t}\n\telse if( !strcmp( cmd->params[payload_index-1], \"U\" ) )\n\t{\n\t\t// binary data expected!\n\t\tcmdproc->last_cmd->payload_cb  = ctoc_cmd_bin_post;\n\t}\n\telse\n\t{\n\t\tcmdproc->last_cmd->payload_cb  = ctoc_cmd_post;\n\t}\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Init\n **************************************************************************/\n", "func_signal": "void\nnateon_notification_init(void)", "code": "{\n\t/* TODO: check prp, blp */\n\n\tcbs_table = nateon_table_new();\n\n\t/* Synchronous */\n\n\t// PRS server\n\tnateon_table_add_cmd(cbs_table, \"RCON\", \"RCON\", rcon_cmd);\n\n\t// Login/Dispatch server\n\tnateon_table_add_cmd(cbs_table, \"PVER\", \"PVER\", pver_cmd);\n\tnateon_table_add_cmd(cbs_table, \"AUTH\", \"AUTH\", auth_cmd);\n\tnateon_table_add_cmd(cbs_table, \"REQS\", \"REQS\", reqs_cmd);\n\n\t// Notification server\n\tnateon_table_add_cmd(cbs_table, \"LSIN\", \"LSIN\", lsin_cmd);\n\tnateon_table_add_cmd(cbs_table, \"ONST\", \"ONST\", NULL);\n\tnateon_table_add_cmd(cbs_table, \"CNIK\", \"CNIK\", cnik_cmd);\n\n\t// Buddy & Group\n\tnateon_table_add_cmd(cbs_table, \"ADSB\", \"ADSB\", adsb_cmd);\n\tnateon_table_add_cmd(cbs_table, \"RMVB\", \"RMVB\", rmvb_cmd);\n\tnateon_table_add_cmd(cbs_table, \"ADDG\", \"ADDG\", addg_cmd);\n\tnateon_table_add_cmd(cbs_table, \"RMVG\", \"RMVG\", rmvg_cmd);\n\tnateon_table_add_cmd(cbs_table, \"RENG\", \"RENG\", reng_cmd);\n\tnateon_table_add_cmd(cbs_table, \"MVBG\", \"MVBG\", mvbg_cmd);\n\tnateon_table_add_cmd(cbs_table, \"ADDB\", \"ADDB\", addb_cmd);\n\t\n//\tnateon_table_add_cmd(cbs_table, \"CHG\", \"CHG\", NULL);\n//\tnateon_table_add_cmd(cbs_table, \"CHG\", \"ILN\", iln_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"ADD\", \"ADD\", add_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"ADD\", \"ILN\", iln_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"REM\", \"REM\", rem_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"USR\", \"USR\", usr_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"USR\", \"XFR\", xfr_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"SYN\", \"SYN\", syn_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"CVR\", \"CVR\", cvr_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"REA\", \"REA\", rea_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"PRP\", \"PRP\", prp_cmd);\n//\t/* nateon_table_add_cmd(cbs_table, \"BLP\", \"BLP\", blp_cmd); */\n//\tnateon_table_add_cmd(cbs_table, \"BLP\", \"BLP\", NULL);\n//\tnateon_table_add_cmd(cbs_table, \"REG\", \"REG\", reg_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"ADG\", \"ADG\", adg_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"RMG\", \"RMG\", rmg_cmd);\n//\tnateon_table_add_cmd(cbs_table, \"XFR\", \"XFR\", xfr_cmd);\n\n\t/* Asynchronous */\n\tnateon_table_add_cmd(cbs_table, NULL, \"INFY\", infy_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"NTFY\", ntfy_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"PING\", ping_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"PONG\", pong_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"CTOC\", ctoc_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"SMSG\", cmsg_cmd); // \uc11c\ubc84\ucabd\uc9c0\n\tnateon_table_add_cmd(cbs_table, NULL, \"CMSG\", cmsg_cmd); // \uc0ac\uc6a9\uc790\ucabd\uc9c0\n\tnateon_table_add_cmd(cbs_table, NULL, \"PMSG\", cmsg_cmd); // \uc6f9\ucabd\uc9c0\n\n\t// IMSG (separated from SMSG or others)\n\tnateon_table_add_cmd(cbs_table, NULL, \"IMSG\", imsg_cmd);\n\t// TICK\n\tnateon_table_add_cmd(cbs_table, NULL, \"TICK\", tick_cmd);\n\n\t// Buddy\n//\tnateon_table_add_cmd(cbs_table, NULL, \"ADDB\", addb_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"RMVB\", rmvb_cmd);\n\n//\tnateon_table_add_cmd(cbs_table, NULL, \"IPG\", ipg_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"MSG\", msg_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"NOT\", not_cmd);\n//\n//\tnateon_table_add_cmd(cbs_table, NULL, \"CHL\", chl_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"REM\", rem_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"ADD\", add_cmd);\n//\n//\tnateon_table_add_cmd(cbs_table, NULL, \"QRY\", NULL);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"QNG\", NULL);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"FLN\", fln_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"NLN\", nln_cmd);\n//\tnateon_table_add_cmd(cbs_table, NULL, \"ILN\", iln_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"NPRF\", nprf_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"NNIK\", nnik_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"KILL\", kill_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"INVT\", invt_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"REQC\", reqc_cmd);\n\tnateon_table_add_cmd(cbs_table, NULL, \"REFR\", refr_cmd);\n\n//\n//\tnateon_table_add_cmd(cbs_table, NULL, \"URL\", url_cmd);\n//\n//\tnateon_table_add_cmd(cbs_table, \"fallback\", \"XFR\", xfr_cmd);\n//\n\tnateon_table_add_error(cbs_table, \"RENG\", reng_error);\n//\tnateon_table_add_error(cbs_table, \"ADD\", add_error);\n//\tnateon_table_add_error(cbs_table, \"REG\", reg_error);\n//\tnateon_table_add_error(cbs_table, \"RMG\", rmg_error);\n//\t/* nateon_table_add_error(cbs_table, \"REA\", rea_error); */\n\tnateon_table_add_error(cbs_table, \"LSIN\", lsin_error);\n\n//\tnateon_table_add_msg_type(cbs_table,\n//\t\t\t\t\t\t   \"text/x-msmsgsprofile\",\n//\t\t\t\t\t\t   profile_msg);\n//\tnateon_table_add_msg_type(cbs_table,\n//\t\t\t\t\t\t   \"text/x-msmsgsinitialemailnotification\",\n//\t\t\t\t\t\t   initial_email_msg);\n//\tnateon_table_add_msg_type(cbs_table,\n//\t\t\t\t\t\t   \"text/x-msmsgsemailnotification\",\n//\t\t\t\t\t\t   email_msg);\n//\tnateon_table_add_msg_type(cbs_table,\n//\t\t\t\t\t\t   \"application/x-msmsgssystemmessage\",\n//\t\t\t\t\t\t   system_msg);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * CTOC: Clent to Clent \n **************************************************************************/\n", "func_signal": "static void\nctoc_cmd_post(NateonCmdProc *cmdproc, NateonCommand *cmd, char *payload,\n\t\t\t size_t len)", "code": "{\n\tchar *cmd_string, *sub_payload;\n\tNateonCommand *new_cmd;\n\n\t// strlen(paylaod) could be larger than len!\n\t// We only take what we need.\n\tsub_payload = g_strndup( payload, len );\n\n\tpurple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\tpurple_debug_info(\"nateon\", \"[%s]\\n%s\\n\", __FUNCTION__, sub_payload);\n\n\tcmd_string = purple_strreplace(sub_payload, \"\\r\\n\", \" \");\n\tnew_cmd = nateon_command_from_string(cmd_string);\n\n\t//nateon_cmdproc_process_cmd_text(cmdproc, command);\n\tnateon_cmdproc_process_cmd(cmdproc, new_cmd);\n\n\tg_free(cmd_string);\n\tg_free(sub_payload);\n\tnateon_command_unref(new_cmd);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * jdj\n * The auth transfer step, where we are sending LSIN with ticket.\n */\n", "func_signal": "static void\nnateon_auth_step_transfer( NateonServConn *servconn, gchar *ticket )", "code": "{\n\tNateonCmdProc *cmdproc;\n\tNateonSession *session;\n\tPurpleAccount *account;\n\tconst char *username, *password;\n\tchar *cmd;\n\n\tg_return_if_fail(servconn != NULL);\n\n\tcmdproc = servconn->cmdproc;\n\tsession = servconn->session;\n\taccount = session->account;\n\n\tusername = purple_account_get_username(account);\n\tpassword = purple_account_get_password(account);\n\n\tcmd = makeLSIN( username, password, ticket );\n\t// printf( \"%s\\n\", cmd );\n\n\tnateon_session_set_login_step(session, NATEON_LOGIN_STEP_AUTH_START);\n\tnateon_cmdproc_send(cmdproc, \"LSIN\", \"%s\", cmd);\n\n\tg_free(cmd);\n\tg_free( ticket ); // it goes free here.\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Util\n **************************************************************************/\n", "func_signal": "static void\ngroup_error_helper(NateonSession *session, const char *msg, int group_id, int error)", "code": "{\n\tPurpleAccount *account;\n\tPurpleConnection *gc;\n\tchar *reason = NULL;\n\tchar *title = NULL;\n\n\tpurple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\n\taccount = session->account;\n\tgc = purple_account_get_connection(account);\n\n\tif (error == 304)\n\t{\n\n\t\tif (group_id == 0)\n\t\t{\n\t\t\tpurple_debug_info(\"nateon\", \"[%s] \uae30\ubcf8\uadf8\ub8f9\uc758 \uba85\uce6d\uc744 \ubcc0\uacbd\ud558\ub824\uace0 \ud568.\\n\", __FUNCTION__);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *group_name;\n\t\t\tgroup_name = nateon_userlist_find_group_name(session->userlist, group_id);\n\t\t\treason = g_strdup_printf(_(\"%s is not a valid group.\"), group_name);\n\t\t}\n\t}\n\telse\n\t{\n\t\treason = g_strdup(_(\"Unknown error.\"));\n\t}\n\n\ttitle = g_strdup_printf(_(\"%s on %s (%s)\"), msg,\n\t\t\t\t\t\t  purple_account_get_username(account),\n\t\t\t\t\t\t  purple_account_get_protocol_name(account));\n\tpurple_notify_error(gc, NULL, title, reason);\n\tg_free(title);\n\tg_free(reason);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * Retrieves data->from_friendly, guessed from data->from.\n * get \ub300\ud654\uba85\n */\n", "func_signal": "static const char *\nimsg_get_store_name( const char *mail, NateonCmdProc *cmdproc)", "code": "{\n\tNateonUser *user = nateon_userlist_find_user_with_name(cmdproc->session->userlist, mail);\n\treturn nateon_user_get_store_name(user);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * jdj: receive ticket from CGI (KNateon::connectDPWithAccount)\n */\n", "func_signal": "char* makeTicketURL( const char *username, const char *password )", "code": "{\n\t// generate URL\n\tconst char * pass = purple_url_encode( password );\n\tchar * url = g_strdup_printf( \"https://nsl.nate.com/client/login.do?id=%s&pwd=%s\",\n\t\tusername, pass );\n\n\t// purple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\t// purple_debug_info(\"nateon\", \"Ticket URL: %s\\n\", url );\n\n\treturn url;\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "//void\n//nateon_parse_format(const char *mime, char **pre_ret, char **post_ret)\n", "func_signal": "char *\nnateon_parse_format(const char *payload)", "code": "{\n//\tchar *cur;\n\tchar **split;\n\tGString *pre  = g_string_new(NULL);\n\tGString *post = g_string_new(NULL);\n\tunsigned int colors[3];\n\tchar *fontface;\n\tchar *fontcolor;\n\tchar *fonteffect;\n\tchar *body;\n\tchar *tmp;\n\n//\tif (pre_ret  != NULL) *pre_ret  = NULL;\n//\tif (post_ret != NULL) *post_ret = NULL;\n\n\tpurple_debug_info(\"nateon\", \"[%s], %s\\n\", __FUNCTION__, payload);\n\n\tsplit = g_strsplit(payload, \"%09\", 0);\n\n\tif (strstr(payload, \"%09\") == NULL)\n\t{\n\t\tfontface = g_strdup(\"\uad74\ub9bc\");\n\t\tfontcolor = g_strdup(\"0\");\n\t\tfonteffect = g_strdup(\"\");\n\t\tbody = split[0];\n\t}\n\telse\n\t{\n\t\tfontface = split[0];\n\t\tfontcolor = g_strdup_printf(\"%06X\", atoi(split[1]));\n\t\tfonteffect = split[2];\n\t\tbody = split[3];\n\t}\n\n\tbody = purple_strreplace(body, \"%20\", \" \");\n\ttmp = body;\n\n\tbody = purple_strreplace(tmp, \"%0A\", \"<br>\");\n\tg_free(tmp);\n\ttmp = body;\n\n\tbody = purple_strreplace(tmp, \"%25\", \"%\");\n\tg_free(tmp);\n\ttmp = body;\n\n\tbody = purple_strreplace(tmp, \"%0D\", \"\");\n\tg_free(tmp);\n\n\tpurple_debug_info(\"nateon\", \"[%s], %s\\n\", __FUNCTION__, fontface);\n\tpurple_debug_info(\"nateon\", \"[%s], %s\\n\", __FUNCTION__, fontcolor);\n\tpurple_debug_info(\"nateon\", \"[%s], %s\\n\", __FUNCTION__, fonteffect);\n\tpurple_debug_info(\"nateon\", \"[%s], %s\\n\", __FUNCTION__, body);\n//\tcur = strstr(mime, \"FN=\");\n//\n//\tif (cur && (*(cur = cur + 3) != ';'))\n\tif (strcmp(fontface, \"\"))\n\t{\n\t\tpre = g_string_append(pre, \"<FONT FACE=\\\"\");\n\t\tpre = g_string_append(pre, fontface);\n\t\tpre = g_string_append(pre, \"\\\">\");\n\t\tpost = g_string_prepend(post, \"</FONT>\");\n\t}\n\n//\tcur = strstr(mime, \"EF=\");\n\n//\tif (cur && (*(cur = cur + 3) != ';'))\n\tif (strcmp(fonteffect, \"\"))\n\t{\n\t\tchar *effect = fonteffect;\n\n\t\twhile (*effect)\n\t\t{\n\t\t\tpre = g_string_append_c(pre, '<');\n\t\t\tpre = g_string_append_c(pre, *effect);\n\t\t\tpre = g_string_append_c(pre, '>');\n\t\t\tpost = g_string_prepend_c(post, '>');\n\t\t\tpost = g_string_prepend_c(post, *effect);\n\t\t\tpost = g_string_prepend_c(post, '/');\n\t\t\tpost = g_string_prepend_c(post, '<');\n\n\t\t\teffect++;\n\t\t}\n\t}\n\n//\tcur = strstr(mime, \"CO=\");\n//\n//\tif (cur && (*(cur = cur + 3) != ';'))\n\tif (strcmp(fontcolor, \"\"))\n\t{\n\t\tint i;\n\n\t\ti = sscanf(fontcolor, \"%02x%02x%02x;\", &colors[0], &colors[1], &colors[2]);\n\n\t\tif (i > 0)\n\t\t{\n\t\t\tchar tag[64];\n\n\t\t\tif (i == 1)\n\t\t\t{\n\t\t\t\tcolors[1] = 0;\n\t\t\t\tcolors[2] = 0;\n\t\t\t}\n\t\t\telse if (i == 2)\n\t\t\t{\n\t\t\t\tunsigned int temp = colors[0];\n\n\t\t\t\tcolors[0] = colors[1];\n\t\t\t\tcolors[1] = temp;\n\t\t\t\tcolors[2] = 0;\n\t\t\t}\n\t\t\telse if (i == 3)\n\t\t\t{\n\t\t\t\tunsigned int temp = colors[2];\n\n\t\t\t\tcolors[2] = colors[0];\n\t\t\t\tcolors[0] = temp;\n\t\t\t}\n\n\t\t\tg_snprintf(tag, sizeof(tag),\n\t\t\t\t\t   \"<FONT COLOR=\\\"#%02hhx%02hhx%02hhx\\\">\",\n\t\t\t\t\t   colors[0], colors[1], colors[2]);\n\n\t\t\tpre = g_string_append(pre, tag);\n\t\t\tpost = g_string_prepend(post, \"</FONT>\");\n\t\t}\n\t}\n//\n//\tcur = strstr(mime, \"RL=\");\n//\n//\tif (cur && (*(cur = cur + 3) != ';'))\n//\t{\n//\t\tif (*cur == '1')\n//\t\t{\n//\t\t\t/* RTL text was received */\n//\t\t\tpre = g_string_append(pre, \"<SPAN style=\\\"direction:rtl;text-align:right;\\\">\");\n//\t\t\tpost = g_string_prepend(post, \"</SPAN>\");\n//\t\t}\n//\t}\n//\n//\tcur = g_strdup(purple_url_decode(pre->str));\n//\tg_string_free(pre, TRUE);\n//\n//\tif (pre_ret != NULL)\n//\t\t*pre_ret = cur;\n//\telse\n//\t\tg_free(cur);\n//\n//\tcur = g_strdup(purple_url_decode(post->str));\n//\tg_string_free(post, TRUE);\n//\n//\tif (post_ret != NULL)\n//\t\t*post_ret = cur;\n//\telse\n//\t\tg_free(cur);\n\n\tpurple_debug_info(\"nateon\", \"[%s] %s\\n\", __FUNCTION__, pre->str);\n\tpurple_debug_info(\"nateon\", \"[%s] %s\\n\", __FUNCTION__, post->str);\n\n\treturn g_strdup_printf(\"%s%s%s\", g_string_free(pre, FALSE), body, g_string_free(post, FALSE));\n}", "path": "src\\nateon-utils.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * Incoming memo handler. shows popup.\n */\n", "func_signal": "static void\nimsg_cmd(NateonCmdProc *cmdproc, NateonCommand *cmd)", "code": "{\n\tPurpleConnection *gc;\n\t//PurpleRequestFields *fields;\n\t//PurpleRequestFieldGroup *g;\n\t//PurpleRequestField *f;\n\tPurpleAccount *account;\n\n\t//NateonMemoImsg data; you CAN'T use plain structs and pass &data as callback param!\n\tNateonMemoImsg *data = g_new0(NateonMemoImsg, 1);\n\tint i;\n\n\tgc = purple_account_get_connection(cmdproc->session->account);\n\taccount = purple_connection_get_account( gc );\n\n\tpurple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\tpurple_debug_info(\"nateon\", \"[%s] param_count(%d)\\n\", __FUNCTION__, cmd->param_count);\n\n\tdata->gc = gc;\n\tdata->to = g_strdup( account->username );\n\n\t// parse contents\n\tfor (i = 0; i < (cmd->param_count - 1); i++)\n\t{\n\t\tgchar **params;\n\t\tpurple_debug_info(\"nateon\", \"%d: [%s]\\n\", i, cmd->params[i]);\n\n\t\tparams = g_strsplit(cmd->params[i], \":\", 0);\n\t\tif( params[0] == NULL )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(params[0], \"uuid\") )\n\t\t{\n\t\t\tchar* hold;\n\t\t\tparams = &cmd->params[i+1];\n\t\t\thold = g_strjoinv(\" \", params);\n\t\t\tdata->contents = purple_unescape_html( hold );\n\t\t\tg_strstrip(data->contents);\n\t\t\tg_free( hold );\n\t\t\tbreak;\n\t\t}\n\t\telse if (!strcmp(params[0], \"from\"))\n\t\t{\n\t\t\tdata->from = g_strdup( params[1] );\n\t\t}\n\t\telse if (!strcmp(params[0], \"date\"))\n\t\t{\n\t\t\tint year, mon, day, hour, min, sec;\n\t\t\tsscanf(params[1], \"%04d%02d%02d%02d%02d%02d\", &year, &mon, &day, &hour, &min, &sec);\n\t\t\tdata->date = g_strdup_printf(\"%04d-%02d-%2d %02d:%02d:%02d\", year, mon, day, hour, min, sec);\n\t\t}\n\t\tg_strfreev(params);\n\t}\n\n\tpurple_debug_info(\"nateon\", \"[%s] contents(%s)\\n\", __FUNCTION__, data->contents);\n\n\t{ // UI part of \"reply\" or \"close\" dialog.\n\t\t// notifi_formatted SUCKS. it is \"read only\"\n\t\t// purple_notify_formatted(gc, _(\"Incoming Memo\"), buddy_name, date, contents, NULL, gc);\n\t\t// pruple_request_input is quite fine too, but I couldn't make it \"read only\".\n\n\t\tconst char *store = imsg_get_store_name(data->from, cmdproc);\n\t\tconst char *real_name = imsg_get_friendly_name(data->from, cmdproc);\n\t\tdata->win_title = g_strdup_printf( _(\"Incoming Memo from %s\"), data->from );\n\t\tdata->title = g_strdup_printf( \"%s(%s)\", real_name, store );\n\t\t// these functions are NONBLOCKING.\n\t\t// you must NOT use local variables in\n\t\t// \"data\", bassed for callback functions.\n\t\t// freeing is upto the callback functions, too.\n\t\tpurple_request_action(\n\t\t\tgc,                   /* Connection */\n\t\t\tdata->win_title,      /* Window title */\n\t\t\tdata->title,          /* Bold \"title\" for message body */\n\t\t\tdata->contents,       /* Contents */\n\t\t\t0,                    /* Default action == close */\n\t\t\taccount,              /* Current account */\n\t\t\tdata->from,           /* Your friend's id(mail) */\n\t\t\tNULL,                 /* Conversation. NULL for this case */\n\t\t\tdata,                 /* Data sent to your callback functions */\n\t\t\t2,                    /* number of actions(buttons) */\n\t\t\t_(\"_Close\"), G_CALLBACK(imsg_noreply), /* action 0: silently close  */\n\t\t\t_(\"_Reply\"), G_CALLBACK(imsg_reply)    /* imsg_reply */\n\t\t);\n\t}\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/* Remove the buddy referenced by the MsnAddRemData before the serverside list is changed.\n * If the buddy will be added, he'll be added back; if he will be removed, he won't be. */\n", "func_signal": "static void\nnateon_complete_sync_issue(NateonAddRemData *data)", "code": "{\n        PurpleBuddy *buddy;\n        PurpleGroup *group = NULL;\n\n        if (data->group != NULL)\n                group = purple_find_group(data->group);\n\n        if (group != NULL)\n                buddy = purple_find_buddy_in_group(purple_connection_get_account(data->gc), data->who, group);\n        else\n                buddy = purple_find_buddy(purple_connection_get_account(data->gc), data->who);\n\n        if (buddy != NULL)\n                purple_blist_remove_buddy(buddy);\n}", "path": "src\\dialog.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Connect\n **************************************************************************/\n", "func_signal": "char *makePCID(void)", "code": "{\n\tint ms = g_random_int_range(0,999); // micro-second. who cares?\n\tconst char * date = purple_utf8_strftime(\"%Y%m%d%H%M%S\",NULL);\n\tchar * pcid = g_strdup_printf(\"0%s%03d\", date, ms);\n\t//printf( \"PCID:%s\\n\", pcid );\n\treturn pcid;\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Main\n **************************************************************************/\n", "func_signal": "static void\ndestroy_cb(NateonServConn *servconn)", "code": "{\n\tNateonNotification *notification;\n\n\tnotification = servconn->cmdproc->data;\n\tg_return_if_fail(notification != NULL);\n\n\tnateon_notification_destroy(notification);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * jdj\n * received http data from ticket url.\n */\n", "func_signal": "static void got_ticket(\n\tPurpleUtilFetchUrlData *url_data, gpointer user_data, const gchar *ret_data,\n\tsize_t len, const gchar *error_message )", "code": "{\n\tNateonServConn *servconn = user_data;\n\tNateonSession *session = servconn->session;\n\tPurpleConnection *gc = purple_account_get_connection(session->account);\n\tgchar **split_data;\n\tgchar *ticket;\n\n\tpurple_debug_info(\"nateon\", \"[%s]\\n\", __FUNCTION__);\n\tpurple_debug_info(\"nateon\", \"receiving ticket\\n\");\n\n\tif( error_message != NULL ) {\n\t\tpurple_debug_error(\"nateon\", \"failed to get ticket\\n\");\n\t\tpurple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, error_message);\n\t\treturn;\n\t}\n\n\t/*\n\tret_data should look something like this:\n\n\t100 OK\n\t0001MIHnBgkrBgEEAYI3WAOggdkwgdYGCisGAQQBgjdYAwGggccwgcQCAwIAA...\n\n\tWe ALWAYS get 100 OK in the first line, even if the password in request URL\n\tis wrong; it's only a ticket.\n\t*/\n\tsplit_data = g_strsplit( ret_data, \"\\r\\n\", -1 );\n\t//printf( \"0: %s\\n\", split_data[0] ); holds 100 OK\n\t//printf( \"1: %s\\n\", split_data[1] ); holds 0011MIHn...\n\tticket = g_strdup( split_data[1] );\n\tg_strfreev(split_data);\n\n\tnateon_auth_step_transfer( servconn, ticket ); // proceed to next step of auth\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**************************************************************************\n * Switchboards\n **************************************************************************/\n", "func_signal": "static void\ninvt_cmd(NateonCmdProc *cmdproc, NateonCommand *cmd)", "code": "{\n\t//       0    1      2      3\n\t// INVT [id] [host] [port] [key]\n\tNateonSession *session;\n\tNateonSwitchBoard *swboard;\n\tchar *host;\n\tint port;\n\n\tsession = cmdproc->session;\n\n\thost = g_strdup(cmd->params[1]);\n\tport = atoi(cmd->params[2]);\n\n//\tif (session->http_method)\n//\t\tport = 80;\n\n\n\tswboard = nateon_switchboard_new(session);\n\n\tnateon_switchboard_set_invited(swboard, TRUE);\n//\tnateon_switchboard_set_session_id(swboard, cmd->params[0]);\n\tnateon_switchboard_set_auth_key(swboard, cmd->params[3]);\n\tswboard->im_user = g_strdup(cmd->params[0]);\n\t/* nateon_switchboard_add_user(swboard, cmd->params[4]); */\n\n\tif (!nateon_switchboard_connect(swboard, host, port))\n\t\tnateon_switchboard_destroy(swboard);\n\n\tg_free(host);\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/*\n * Taken from the zephyr plugin.\n * This parses HTML formatting (put out by one of the gtkimhtml widgets\n * and converts it to nateon formatting. It doesn't deal with the tag closing,\n * but gtkimhtml widgets give valid html.\n * It currently deals properly with <b>, <u>, <i>, <font face=...>,\n * <font color=...>, <span dir=...>, <span style=\"direction: ...\">.\n * It ignores <font back=...> and <font size=...>\n */\n//void\n//nateon_import_html(const char *html, char **attributes, char **message)\n", "func_signal": "char *\nnateon_import_html(const char *html)", "code": "{\n\tconst char *c;\n\tGString *msg = g_string_new(NULL);\n\tchar *fontface = NULL;\n\tchar fonteffect[4];\n//\tchar fontcolor[7];\n\tint fontcolor = 0;\n//\tchar direction = '0';\n\tchar *attributes;\n\n\tgboolean has_bold = FALSE;\n\tgboolean has_italic = FALSE;\n\tgboolean has_underline = FALSE;\n\tgboolean has_strikethrough = FALSE;\n\n//\tg_return_if_fail(html != NULL);\n\n//\tmemset(fontcolor, 0, sizeof(fontcolor));\n//\tstrcat(fontcolor, \"0\");\n\tmemset(fonteffect, 0, sizeof(fonteffect));\n\n\tfor (c = html; *c != '\\0';)\n\t{\n\t\tif (*c == '%')\n\t\t{\n\t\t\tg_string_append(msg, \"%25\");\n\t\t\tc ++;\n\t\t}\n\t\telse if (*c == ' ' || *c == '\\t')\n\t\t{\n\t\t\tg_string_append(msg, \"%20\");\n\t\t\tc ++;\n\t\t}\n\t\telse if (*c == '\\n')\n\t\t{\n\t\t\tg_string_append(msg, \"%0D%0A\");\n\t\t\tc ++;\n\t\t}\n\t\telse if (*c == '<')\n\t\t{\n\t\t\tif (!g_ascii_strncasecmp(c + 1, \"br>\", 3))\n\t\t\t{\n\t\t\t\tg_string_append(msg, \"%0A\");\n\t\t\t\tc += 4;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"b>\", 2))\n\t\t\t{\n\t\t\t\tif (!has_bold)\n\t\t\t\t{\n\t\t\t\t\tstrcat(fonteffect, \"B\");\n\t\t\t\t\thas_bold = TRUE;\n\t\t\t\t}\n\t\t\t\tc += 3;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"i>\", 2))\n\t\t\t{\n\t\t\t\tif (!has_italic)\n\t\t\t\t{\n\t\t\t\t\tstrcat(fonteffect, \"I\");\n\t\t\t\t\thas_italic = TRUE;\n\t\t\t\t}\n\t\t\t\tc += 3;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"s>\", 2))\n\t\t\t{\n\t\t\t\tif (!has_strikethrough)\n\t\t\t\t{\n\t\t\t\t\tstrcat(fonteffect, \"S\");\n\t\t\t\t\thas_strikethrough = TRUE;\n\t\t\t\t}\n\t\t\t\tc += 3;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"u>\", 2))\n\t\t\t{\n\t\t\t\tif (!has_underline)\n\t\t\t\t{\n\t\t\t\t\tstrcat(fonteffect, \"U\");\n\t\t\t\t\thas_underline = TRUE;\n\t\t\t\t}\n\t\t\t\tc += 3;\n\t\t\t}\n//\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"a href=\\\"\", 8))\n//\t\t\t{\n//\t\t\t\tc += 9;\n//\n//\t\t\t\tif (!g_ascii_strncasecmp(c, \"mailto:\", 7))\n//\t\t\t\t\tc += 7;\n//\n//\t\t\t\twhile ((*c != '\\0') && g_ascii_strncasecmp(c, \"\\\">\", 2))\n//\t\t\t\t\tmsg[retcount++] = *c++;\n//\n//\t\t\t\tif (*c != '\\0')\n//\t\t\t\t\tc += 2;\n//\n//\t\t\t\t/* ignore descriptive string */\n//\t\t\t\twhile ((*c != '\\0') && g_ascii_strncasecmp(c, \"</a>\", 4))\n//\t\t\t\t\tc++;\n//\n//\t\t\t\tif (*c != '\\0')\n//\t\t\t\t\tc += 4;\n//\t\t\t}\n//\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"span\", 4))\n//\t\t\t{\n//\t\t\t\t/* Bi-directional text support using CSS properties in span tags */\n//\t\t\t\tc += 5;\n//\n//\t\t\t\twhile (*c != '\\0' && *c != '>')\n//\t\t\t\t{\n//\t\t\t\t\twhile (*c == ' ')\n//\t\t\t\t\t\tc++;\n//\t\t\t\t\tif (!g_ascii_strncasecmp(c, \"dir=\\\"rtl\\\"\", 9))\n//\t\t\t\t\t{\n//\t\t\t\t\t\tc += 9;\n//\t\t\t\t\t\tdirection = '1';\n//\t\t\t\t\t}\n//\t\t\t\t\telse if (!g_ascii_strncasecmp(c, \"style=\\\"\", 7))\n//\t\t\t\t\t{\n//\t\t\t\t\t\t/* Parse inline CSS attributes */\n//\t\t\t\t\t\tchar *attributes;\n//\t\t\t\t\t\tint attr_len = 0;\n//\t\t\t\t\t\tc += 7;\n//\t\t\t\t\t\twhile (*(c + attr_len) != '\\0' && *(c + attr_len) != '\"')\n//\t\t\t\t\t\t\tattr_len++;\n//\t\t\t\t\t\tif (*(c + attr_len) == '\"')\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tchar *attr_dir;\n//\t\t\t\t\t\t\tattributes = g_strndup(c, attr_len);\n//\t\t\t\t\t\t\tattr_dir = purple_markup_get_css_property(attributes, \"direction\");\n//\t\t\t\t\t\t\tif (attr_dir && (!g_ascii_strncasecmp(attr_dir, \"RTL\", 3)))\n//\t\t\t\t\t\t\t\tdirection = '1';\n//\t\t\t\t\t\t\tg_free(attr_dir);\n//\t\t\t\t\t\t\tg_free(attributes);\n//\t\t\t\t\t\t}\n//\n//\t\t\t\t\t}\n//\t\t\t\t\telse\n//\t\t\t\t\t{\n//\t\t\t\t\t\tc++;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tif (*c == '>')\n//\t\t\t\t\tc++;\n//\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c + 1, \"font\", 4))\n\t\t\t{\n\t\t\t\tc += 5;\n\n\t\t\t\twhile ((*c != '\\0') && !g_ascii_strncasecmp(c, \" \", 1))\n\t\t\t\t\tc++;\n\n\t\t\t\tif (!g_ascii_strncasecmp(c, \"color=\\\"#\", 7))\n\t\t\t\t{\n\t\t\t\t\tchar color[7] = {0};\n\n\t\t\t\t\tc += 8;\n\n\t\t\t\t\tcolor[0] = *(c + 4);\n\t\t\t\t\tcolor[1] = *(c + 5);\n\t\t\t\t\tcolor[2] = *(c + 2);\n\t\t\t\t\tcolor[3] = *(c + 3);\n\t\t\t\t\tcolor[4] = *c;\n\t\t\t\t\tcolor[5] = *(c + 1);\n\n\t\t\t\t\tsscanf(color, \"%06X\", &fontcolor);\n\n\t\t\t\t\tc += 8;\n\t\t\t\t}\n\t\t\t\telse if (!g_ascii_strncasecmp(c, \"face=\\\"\", 6))\n\t\t\t\t{\n\t\t\t\t\tconst char *end = NULL;\n\t\t\t\t\tconst char *comma = NULL;\n\t\t\t\t\tunsigned int namelen = 0;\n\n\t\t\t\t\tc += 6;\n\t\t\t\t\tend = strchr(c, '\\\"');\n\t\t\t\t\tcomma = strchr(c, ',');\n\n\t\t\t\t\tif (comma == NULL || comma > end)\n\t\t\t\t\t\tnamelen = (unsigned int)(end - c);\n\t\t\t\t\telse\n\t\t\t\t\t\tnamelen = (unsigned int)(comma - c);\n\n\t\t\t\t\tfontface = g_strndup(c, namelen);\n\t\t\t\t\tc = end + 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Drop all unrecognized/misparsed font tags */\n\t\t\t\t\twhile ((*c != '\\0') && g_ascii_strncasecmp(c, \"\\\">\", 2))\n\t\t\t\t\t\tc++;\n\n\t\t\t\t\tif (*c != '\\0')\n\t\t\t\t\t\tc += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile ((*c != '\\0') && (*c != '>'))\n\t\t\t\t\tc++;\n\t\t\t\tif (*c != '\\0')\n\t\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\telse if (*c == '&')\n\t\t{\n\t\t\tif (!g_ascii_strncasecmp(c, \"&lt;\", 4))\n\t\t\t{\n\t\t\t\tg_string_append_c(msg, '<');\n\t\t\t\tc += 4;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c, \"&gt;\", 4))\n\t\t\t{\n\t\t\t\tg_string_append_c(msg, '>');\n\t\t\t\tc += 4;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c, \"&nbsp;\", 6))\n\t\t\t{\n\t\t\t\tg_string_append(msg, \"%20\");\n\t\t\t\tc += 6;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c, \"&quot;\", 6))\n\t\t\t{\n\t\t\t\tg_string_append_c(msg, '\"');\n\t\t\t\tc += 6;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c, \"&amp;\", 5))\n\t\t\t{\n\t\t\t\tg_string_append_c(msg, '&');\n\t\t\t\tc += 5;\n\t\t\t}\n\t\t\telse if (!g_ascii_strncasecmp(c, \"&apos;\", 6))\n\t\t\t{\n\t\t\t\tg_string_append_c(msg, '\\'');\n\t\t\t\tc += 6;\n\t\t\t}\n\t\t\telse\n\t\t\t\tg_string_append_c(msg, *c++);\n\t\t}\n\t\telse\n\t\t\tg_string_append_c(msg, *c++);\n\t}\n\n\tif (fontface == NULL)\n\t\tfontface = g_strdup(\"\uad74\ub9bc\");\n\n\tpurple_debug_info(\"nateon\", \"FN=%s; EF=%s; CO=%d\\n\",\n\t\t\tfontface, fonteffect, fontcolor);\n\n\tattributes = g_strdup_printf(\"%s%%09%d%%09%s%%09\",\n\t\t       \tencode_spaces(fontface), fontcolor, fonteffect);\n\tg_string_prepend(msg, attributes);\n\n\tg_free(fontface);\n\tg_free(attributes);\n\n\treturn g_string_free(msg, FALSE);\n}", "path": "src\\nateon-utils.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/**\n * jdj: copied from NateOn's code.\n * only modifed random part.\n * I'm not sure what this is at higher level.\n */\n", "func_signal": "char *getLocKey(void)", "code": "{\n  char chfl[]=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYGabcdefghijklmnopqrstuvwxyz\";\n  int chfl_len=strlen(chfl);\n  char *result =(char*)malloc(5);\n  int i=0;\n  int sr[4];\n\n  memset(result, 0x00, 5);\n\n  for(i=0; i<4; i++) {\n    sr[i]=g_random_int_range(0,chfl_len);\n    memcpy(result+i, &chfl[sr[i]], 1);\n    // printf(\"%d\\n\", sr[i]);\n  }\n  // printf(\"%s\", result);\n  return result;\n}", "path": "src\\notification.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/*\n * We need this because we're only supposed to encode spaces in the font\n * names. purple_url_encode() isn't acceptable.\n */\n", "func_signal": "const char *\nencode_spaces(const char *str)", "code": "{\n\tstatic char buf[BUF_LEN];\n\tconst char *c;\n\tchar *d;\n\n\tg_return_val_if_fail(str != NULL, NULL);\n\n\tfor (c = str, d = buf; *c != '\\0'; c++)\n\t{\n\t\tif (*c == ' ')\n\t\t{\n\t\t\t*d++ = '%';\n\t\t\t*d++ = '2';\n\t\t\t*d++ = '0';\n\t\t}\n\t\telse\n\t\t\t*d++ = *c;\n\t}\n\n\treturn buf;\n}", "path": "src\\nateon-utils.c", "repo_name": "difro/pidgin-nateon", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 2687}
{"docstring": "/*proto*/\n", "func_signal": "static Py_ssize_t __pyx_pw_8chartrie_14FrozenCharTrie_5__len__(PyObject *__pyx_v_self)", "code": "{\n  Py_ssize_t __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__len__ (wrapper)\", 0);\n  __pyx_r = __pyx_pf_8chartrie_14FrozenCharTrie_4__len__(((struct __pyx_obj_8chartrie_FrozenCharTrie *)__pyx_v_self));\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static void __pyx_pw_8chartrie_8CharTrie_3__dealloc__(PyObject *__pyx_v_self)", "code": "{\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__dealloc__ (wrapper)\", 0);\n  __pyx_pf_8chartrie_8CharTrie_2__dealloc__(((struct __pyx_obj_8chartrie_CharTrie *)__pyx_v_self));\n  __Pyx_RefNannyFinishContext();\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pw_8chartrie_8CharTrie_7__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key)", "code": "{\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__getitem__ (wrapper)\", 0);\n  __pyx_r = __pyx_pf_8chartrie_8CharTrie_6__getitem__(((struct __pyx_obj_8chartrie_CharTrie *)__pyx_v_self), ((PyObject *)__pyx_v_key));\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":37\n * cdef class CharTrie:\n *     cdef Trie *trie\n *     def __cinit__(self):             # <<<<<<<<<<<<<<\n *         self.trie = trie_create()\n * \n */\n", "func_signal": "static int __pyx_pf_8chartrie_8CharTrie___cinit__(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self)", "code": "{\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__cinit__\", 0);\n\n  /* \"chartrie.pyx\":38\n *     cdef Trie *trie\n *     def __cinit__(self):\n *         self.trie = trie_create()             # <<<<<<<<<<<<<<\n * \n *     def __dealloc__(self):\n */\n  __pyx_v_self->trie = trie_create();\n\n  __pyx_r = 0;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":79\n *     cdef FrozenTrie *trie\n * \n *     def __cinit__(self):             # <<<<<<<<<<<<<<\n *         self.trie = NULL\n * \n */\n", "func_signal": "static int __pyx_pf_8chartrie_14FrozenCharTrie___cinit__(struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_self)", "code": "{\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__cinit__\", 0);\n\n  /* \"chartrie.pyx\":80\n * \n *     def __cinit__(self):\n *         self.trie = NULL             # <<<<<<<<<<<<<<\n * \n *     def __dealloc__(self):\n */\n  __pyx_v_self->trie = NULL;\n\n  __pyx_r = 0;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":82\n *         self.trie = NULL\n * \n *     def __dealloc__(self):             # <<<<<<<<<<<<<<\n *         if self.trie is not NULL:\n *             free(self.trie.root)\n */\n", "func_signal": "static void __pyx_pf_8chartrie_14FrozenCharTrie_2__dealloc__(struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_self)", "code": "{\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__dealloc__\", 0);\n\n  /* \"chartrie.pyx\":83\n * \n *     def __dealloc__(self):\n *         if self.trie is not NULL:             # <<<<<<<<<<<<<<\n *             free(self.trie.root)\n *             free(self.trie.chars)\n */\n  __pyx_t_1 = (__pyx_v_self->trie != NULL);\n  if (__pyx_t_1) {\n\n    /* \"chartrie.pyx\":84\n *     def __dealloc__(self):\n *         if self.trie is not NULL:\n *             free(self.trie.root)             # <<<<<<<<<<<<<<\n *             free(self.trie.chars)\n *             free(self.trie)\n */\n    free(__pyx_v_self->trie->root);\n\n    /* \"chartrie.pyx\":85\n *         if self.trie is not NULL:\n *             free(self.trie.root)\n *             free(self.trie.chars)             # <<<<<<<<<<<<<<\n *             free(self.trie)\n *             self.trie = NULL\n */\n    free(__pyx_v_self->trie->chars);\n\n    /* \"chartrie.pyx\":86\n *             free(self.trie.root)\n *             free(self.trie.chars)\n *             free(self.trie)             # <<<<<<<<<<<<<<\n *             self.trie = NULL\n * \n */\n    free(__pyx_v_self->trie);\n\n    /* \"chartrie.pyx\":87\n *             free(self.trie.chars)\n *             free(self.trie)\n *             self.trie = NULL             # <<<<<<<<<<<<<<\n * \n *     def __len__(self):\n */\n    __pyx_v_self->trie = NULL;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  __Pyx_RefNannyFinishContext();\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pw_8chartrie_14FrozenCharTrie_17find_splits(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_suffixes = 0;\n  PyObject *__pyx_v_key = 0;\n  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__suffixes,&__pyx_n_s__key,0};\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"find_splits (wrapper)\", 0);\n  {\n    PyObject* values[2] = {0,0};\n    if (unlikely(__pyx_kwds)) {\n      Py_ssize_t kw_args;\n      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);\n      switch (pos_args) {\n        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n        case  0: break;\n        default: goto __pyx_L5_argtuple_error;\n      }\n      kw_args = PyDict_Size(__pyx_kwds);\n      switch (pos_args) {\n        case  0:\n        values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__suffixes);\n        if (likely(values[0])) kw_args--;\n        else goto __pyx_L5_argtuple_error;\n        case  1:\n        values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__key);\n        if (likely(values[1])) kw_args--;\n        else {\n          __Pyx_RaiseArgtupleInvalid(\"find_splits\", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n        }\n      }\n      if (unlikely(kw_args > 0)) {\n        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, \"find_splits\") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n      }\n    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {\n      goto __pyx_L5_argtuple_error;\n    } else {\n      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);\n    }\n    __pyx_v_suffixes = ((struct __pyx_obj_8chartrie_FrozenCharTrie *)values[0]);\n    __pyx_v_key = values[1];\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"find_splits\", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"chartrie.FrozenCharTrie.find_splits\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __Pyx_RefNannyFinishContext();\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_suffixes), __pyx_ptype_8chartrie_FrozenCharTrie, 1, \"suffixes\", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_r = __pyx_pf_8chartrie_14FrozenCharTrie_16find_splits(((struct __pyx_obj_8chartrie_FrozenCharTrie *)__pyx_v_self), __pyx_v_suffixes, __pyx_v_key);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":104\n *         trie_print(self.trie.root)\n * \n *     def find(self, key):             # <<<<<<<<<<<<<<\n *         node = trie_find_word(self.trie.root, key)\n *         return node\n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_14FrozenCharTrie_12find(struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_self, PyObject *__pyx_v_key)", "code": "{\n  int __pyx_v_node;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  char *__pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"find\", 0);\n\n  /* \"chartrie.pyx\":105\n * \n *     def find(self, key):\n *         node = trie_find_word(self.trie.root, key)             # <<<<<<<<<<<<<<\n *         return node\n * \n */\n  __pyx_t_1 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_node = trie_find_word(__pyx_v_self->trie->root, __pyx_t_1);\n\n  /* \"chartrie.pyx\":106\n *     def find(self, key):\n *         node = trie_find_word(self.trie.root, key)\n *         return node             # <<<<<<<<<<<<<<\n * \n *     def find_prefixes(trie, key):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_2 = PyInt_FromLong(__pyx_v_node); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_r = __pyx_t_2;\n  __pyx_t_2 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_AddTraceback(\"chartrie.FrozenCharTrie.find\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":46\n *             self.trie = NULL\n * \n *     def __len__(self):             # <<<<<<<<<<<<<<\n *         return trie_size(self.trie.root)\n * \n */\n", "func_signal": "static Py_ssize_t __pyx_pf_8chartrie_8CharTrie_4__len__(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self)", "code": "{\n  Py_ssize_t __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__len__\", 0);\n\n  /* \"chartrie.pyx\":47\n * \n *     def __len__(self):\n *         return trie_size(self.trie.root)             # <<<<<<<<<<<<<<\n * \n *     def __getitem__(self, key):\n */\n  __pyx_r = trie_size(__pyx_v_self->trie->root);\n  goto __pyx_L0;\n\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":60\n *         node.value = value\n * \n *     def dumps(self):             # <<<<<<<<<<<<<<\n *         cdef SerialTrie* buf = trie_save(self.trie.root)\n *         try:\n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_8CharTrie_10dumps(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self)", "code": "{\n  struct SerialTrie *__pyx_v_buf;\n  PyObject *__pyx_v_result = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"dumps\", 0);\n\n  /* \"chartrie.pyx\":61\n * \n *     def dumps(self):\n *         cdef SerialTrie* buf = trie_save(self.trie.root)             # <<<<<<<<<<<<<<\n *         try:\n *             result = buf.stream[:buf.size]\n */\n  __pyx_v_buf = trie_save(__pyx_v_self->trie->root);\n\n  /* \"chartrie.pyx\":62\n *     def dumps(self):\n *         cdef SerialTrie* buf = trie_save(self.trie.root)\n *         try:             # <<<<<<<<<<<<<<\n *             result = buf.stream[:buf.size]\n *         finally:\n */\n  /*try:*/ {\n\n    /* \"chartrie.pyx\":63\n *         cdef SerialTrie* buf = trie_save(self.trie.root)\n *         try:\n *             result = buf.stream[:buf.size]             # <<<<<<<<<<<<<<\n *         finally:\n *             free(buf.stream)\n */\n    __pyx_t_1 = PyBytes_FromStringAndSize(__pyx_v_buf->stream + 0, __pyx_v_buf->size - 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L4;}\n    __Pyx_GOTREF(((PyObject *)__pyx_t_1));\n    __pyx_v_result = __pyx_t_1;\n    __pyx_t_1 = 0;\n  }\n\n  /* \"chartrie.pyx\":65\n *             result = buf.stream[:buf.size]\n *         finally:\n *             free(buf.stream)             # <<<<<<<<<<<<<<\n *             free(buf)\n *         return result\n */\n  /*finally:*/ {\n    int __pyx_why;\n    PyObject *__pyx_exc_type, *__pyx_exc_value, *__pyx_exc_tb;\n    int __pyx_exc_lineno;\n    __pyx_exc_type = 0; __pyx_exc_value = 0; __pyx_exc_tb = 0; __pyx_exc_lineno = 0;\n    __pyx_why = 0; goto __pyx_L5;\n    __pyx_L4: {\n      __pyx_why = 4;\n      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n      __Pyx_ErrFetch(&__pyx_exc_type, &__pyx_exc_value, &__pyx_exc_tb);\n      __pyx_exc_lineno = __pyx_lineno;\n      goto __pyx_L5;\n    }\n    __pyx_L5:;\n    free(__pyx_v_buf->stream);\n\n    /* \"chartrie.pyx\":66\n *         finally:\n *             free(buf.stream)\n *             free(buf)             # <<<<<<<<<<<<<<\n *         return result\n * \n */\n    free(__pyx_v_buf);\n    switch (__pyx_why) {\n      case 4: {\n        __Pyx_ErrRestore(__pyx_exc_type, __pyx_exc_value, __pyx_exc_tb);\n        __pyx_lineno = __pyx_exc_lineno;\n        __pyx_exc_type = 0;\n        __pyx_exc_value = 0;\n        __pyx_exc_tb = 0;\n        goto __pyx_L1_error;\n      }\n    }\n  }\n\n  /* \"chartrie.pyx\":67\n *             free(buf.stream)\n *             free(buf)\n *         return result             # <<<<<<<<<<<<<<\n * \n *     def debug_print(self):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(((PyObject *)__pyx_v_result));\n  __pyx_r = ((PyObject *)__pyx_v_result);\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"chartrie.CharTrie.dumps\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_result);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pw_8chartrie_8CharTrie_13debug_print(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused)", "code": "{\n  PyObject *__pyx_r = 0;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"debug_print (wrapper)\", 0);\n  __pyx_r = __pyx_pf_8chartrie_8CharTrie_12debug_print(((struct __pyx_obj_8chartrie_CharTrie *)__pyx_v_self));\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* CYTHON_REFNANNY */\n", "func_signal": "static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name)", "code": "{\n    PyObject *result;\n    result = PyObject_GetAttr(dict, name);\n    if (!result) {\n        if (dict != __pyx_b) {\n            PyErr_Clear();\n            result = PyObject_GetAttr(__pyx_b, name);\n        }\n        if (!result) {\n            PyErr_SetObject(PyExc_NameError, name);\n        }\n    }\n    return result;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":69\n *         return result\n * \n *     def debug_print(self):             # <<<<<<<<<<<<<<\n *         trie_print(self.trie.root)\n * \n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_8CharTrie_12debug_print(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"debug_print\", 0);\n\n  /* \"chartrie.pyx\":70\n * \n *     def debug_print(self):\n *         trie_print(self.trie.root)             # <<<<<<<<<<<<<<\n * \n *     def find(self, key):\n */\n  trie_print(__pyx_v_self->trie->root);\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":55\n *         return node\n * \n *     def __setitem__(self, key, value):             # <<<<<<<<<<<<<<\n *         assert value>=0, \"Value should be >= 0\"\n *         node = trie_add_word(self.trie.root, key)\n */\n", "func_signal": "static int __pyx_pf_8chartrie_8CharTrie_8__setitem__(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_value)", "code": "{\n  struct Node *__pyx_v_node;\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  char *__pyx_t_3;\n  int __pyx_t_4;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__setitem__\", 0);\n\n  /* \"chartrie.pyx\":56\n * \n *     def __setitem__(self, key, value):\n *         assert value>=0, \"Value should be >= 0\"             # <<<<<<<<<<<<<<\n *         node = trie_add_word(self.trie.root, key)\n *         node.value = value\n */\n  #ifndef CYTHON_WITHOUT_ASSERTIONS\n  __pyx_t_1 = PyObject_RichCompare(__pyx_v_value, __pyx_int_0, Py_GE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  if (unlikely(!__pyx_t_2)) {\n    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  }\n  #endif\n\n  /* \"chartrie.pyx\":57\n *     def __setitem__(self, key, value):\n *         assert value>=0, \"Value should be >= 0\"\n *         node = trie_add_word(self.trie.root, key)             # <<<<<<<<<<<<<<\n *         node.value = value\n * \n */\n  __pyx_t_3 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_node = trie_add_word(__pyx_v_self->trie->root, __pyx_t_3);\n\n  /* \"chartrie.pyx\":58\n *         assert value>=0, \"Value should be >= 0\"\n *         node = trie_add_word(self.trie.root, key)\n *         node.value = value             # <<<<<<<<<<<<<<\n * \n *     def dumps(self):\n */\n  __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_v_value); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_node->value = __pyx_t_4;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"chartrie.CharTrie.__setitem__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":92\n *         return self.trie.node_count - 1\n * \n *     def __getitem__(self, key):             # <<<<<<<<<<<<<<\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:\n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_14FrozenCharTrie_6__getitem__(struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_self, PyObject *__pyx_v_key)", "code": "{\n  int __pyx_v_node;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  char *__pyx_t_1;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__getitem__\", 0);\n\n  /* \"chartrie.pyx\":93\n * \n *     def __getitem__(self, key):\n *         node = trie_find_word(self.trie.root, key)             # <<<<<<<<<<<<<<\n *         if node < 0:\n *             return None\n */\n  __pyx_t_1 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_node = trie_find_word(__pyx_v_self->trie->root, __pyx_t_1);\n\n  /* \"chartrie.pyx\":94\n *     def __getitem__(self, key):\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:             # <<<<<<<<<<<<<<\n *             return None\n *         return node\n */\n  __pyx_t_2 = (__pyx_v_node < 0);\n  if (__pyx_t_2) {\n\n    /* \"chartrie.pyx\":95\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:\n *             return None             # <<<<<<<<<<<<<<\n *         return node\n * \n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(Py_None);\n    __pyx_r = Py_None;\n    goto __pyx_L0;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"chartrie.pyx\":96\n *         if node < 0:\n *             return None\n *         return node             # <<<<<<<<<<<<<<\n * \n *     def loads(self, stream):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_3 = PyInt_FromLong(__pyx_v_node); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_r = __pyx_t_3;\n  __pyx_t_3 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"chartrie.FrozenCharTrie.__getitem__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":98\n *         return node\n * \n *     def loads(self, stream):             # <<<<<<<<<<<<<<\n *         self.trie = trie_load(stream)\n * \n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_14FrozenCharTrie_8loads(struct __pyx_obj_8chartrie_FrozenCharTrie *__pyx_v_self, PyObject *__pyx_v_stream)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  char *__pyx_t_1;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"loads\", 0);\n\n  /* \"chartrie.pyx\":99\n * \n *     def loads(self, stream):\n *         self.trie = trie_load(stream)             # <<<<<<<<<<<<<<\n * \n *     def debug_print(self):\n */\n  __pyx_t_1 = PyBytes_AsString(__pyx_v_stream); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_self->trie = trie_load(__pyx_t_1);\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"chartrie.FrozenCharTrie.loads\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static Py_ssize_t __pyx_pw_8chartrie_8CharTrie_5__len__(PyObject *__pyx_v_self)", "code": "{\n  Py_ssize_t __pyx_r;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__len__ (wrapper)\", 0);\n  __pyx_r = __pyx_pf_8chartrie_8CharTrie_4__len__(((struct __pyx_obj_8chartrie_CharTrie *)__pyx_v_self));\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*proto*/\n", "func_signal": "static void __pyx_pw_8chartrie_14FrozenCharTrie_3__dealloc__(PyObject *__pyx_v_self)", "code": "{\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"__dealloc__ (wrapper)\", 0);\n  __pyx_pf_8chartrie_14FrozenCharTrie_2__dealloc__(((struct __pyx_obj_8chartrie_FrozenCharTrie *)__pyx_v_self));\n  __Pyx_RefNannyFinishContext();\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":49\n *         return trie_size(self.trie.root)\n * \n *     def __getitem__(self, key):             # <<<<<<<<<<<<<<\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:\n */\n", "func_signal": "static PyObject *__pyx_pf_8chartrie_8CharTrie_6__getitem__(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self, PyObject *__pyx_v_key)", "code": "{\n  int __pyx_v_node;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  char *__pyx_t_1;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__getitem__\", 0);\n\n  /* \"chartrie.pyx\":50\n * \n *     def __getitem__(self, key):\n *         node = trie_find_word(self.trie.root, key)             # <<<<<<<<<<<<<<\n *         if node < 0:\n *             return None\n */\n  __pyx_t_1 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_node = trie_find_word(__pyx_v_self->trie->root, __pyx_t_1);\n\n  /* \"chartrie.pyx\":51\n *     def __getitem__(self, key):\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:             # <<<<<<<<<<<<<<\n *             return None\n *         return node\n */\n  __pyx_t_2 = (__pyx_v_node < 0);\n  if (__pyx_t_2) {\n\n    /* \"chartrie.pyx\":52\n *         node = trie_find_word(self.trie.root, key)\n *         if node < 0:\n *             return None             # <<<<<<<<<<<<<<\n *         return node\n * \n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(Py_None);\n    __pyx_r = Py_None;\n    goto __pyx_L0;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"chartrie.pyx\":53\n *         if node < 0:\n *             return None\n *         return node             # <<<<<<<<<<<<<<\n * \n *     def __setitem__(self, key, value):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_3 = PyInt_FromLong(__pyx_v_node); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_r = __pyx_t_3;\n  __pyx_t_3 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"chartrie.CharTrie.__getitem__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/* \"chartrie.pyx\":40\n *         self.trie = trie_create()\n * \n *     def __dealloc__(self):             # <<<<<<<<<<<<<<\n *         if self.trie is not NULL:\n *             trie_destroy(self.trie)\n */\n", "func_signal": "static void __pyx_pf_8chartrie_8CharTrie_2__dealloc__(struct __pyx_obj_8chartrie_CharTrie *__pyx_v_self)", "code": "{\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__dealloc__\", 0);\n\n  /* \"chartrie.pyx\":41\n * \n *     def __dealloc__(self):\n *         if self.trie is not NULL:             # <<<<<<<<<<<<<<\n *             trie_destroy(self.trie)\n *             free(self.trie)\n */\n  __pyx_t_1 = (__pyx_v_self->trie != NULL);\n  if (__pyx_t_1) {\n\n    /* \"chartrie.pyx\":42\n *     def __dealloc__(self):\n *         if self.trie is not NULL:\n *             trie_destroy(self.trie)             # <<<<<<<<<<<<<<\n *             free(self.trie)\n *             self.trie = NULL\n */\n    trie_destroy(__pyx_v_self->trie);\n\n    /* \"chartrie.pyx\":43\n *         if self.trie is not NULL:\n *             trie_destroy(self.trie)\n *             free(self.trie)             # <<<<<<<<<<<<<<\n *             self.trie = NULL\n * \n */\n    free(__pyx_v_self->trie);\n\n    /* \"chartrie.pyx\":44\n *             trie_destroy(self.trie)\n *             free(self.trie)\n *             self.trie = NULL             # <<<<<<<<<<<<<<\n * \n *     def __len__(self):\n */\n    __pyx_v_self->trie = NULL;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  __Pyx_RefNannyFinishContext();\n}", "path": "chartrie.c", "repo_name": "buriy/python-chartrie", "stars": 19, "license": "None", "language": "c", "size": 145}
{"docstring": "/*\n * Send userauth request message specifying keyboard-interactive method.\n */\n", "func_signal": "int\nuserauth_kbdint(Authctxt *authctxt)", "code": "{\n\tstatic int attempt = 0;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\t/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */\n\tif (attempt > 1 && !authctxt->info_req_seen) {\n\t\tdebug3(\"userauth_kbdint: disable: no info_req_seen\");\n\t\tdispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);\n\t\treturn 0;\n\t}\n\n\tdebug2(\"userauth_kbdint\");\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_cstring(authctxt->server_user);\n\tpacket_put_cstring(authctxt->service);\n\tpacket_put_cstring(authctxt->method->name);\n\tpacket_put_cstring(\"\");\t\t\t\t\t/* lang */\n\tpacket_put_cstring(options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\");\n\tpacket_send();\n\n\tdispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);\n\treturn 1;\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_banner(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tchar *msg, *raw, *lang;\n\tu_int len;\n\n\tdebug3(\"input_userauth_banner\");\n\traw = packet_get_string(&len);\n\tlang = packet_get_string(NULL);\n\tif (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO) {\n\t\tif (len > 65536)\n\t\t\tlen = 65536;\n\t\tmsg = xmalloc(len * 4 + 1); /* max expansion from strnvis() */\n\t\tstrnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL|VIS_NOSLASH);\n\t\tfprintf(stderr, \"%s\", msg);\n\t\txfree(msg);\n\t}\n\txfree(raw);\n\txfree(lang);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_step1(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\tu_char *x3_proof, *x4_proof, *x2_s_proof;\n\tu_int x3_proof_len, x4_proof_len, x2_s_proof_len;\n\tchar *crypt_scheme, *salt;\n        BIGNUM *secret_bn;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1, NULL);\n\n\tif ((pctx->g_x3 = BN_new()) == NULL ||\n\t    (pctx->g_x4 = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new\", __func__);\n\n\t/* Fetch step 1 values */\n\tcrypt_scheme = packet_get_string(NULL);\n\tsalt = packet_get_string(NULL);\n\tpctx->server_id = packet_get_string(&pctx->server_id_len);\n\tpacket_get_bignum2(pctx->g_x3);\n\tpacket_get_bignum2(pctx->g_x4);\n\tx3_proof = packet_get_string(&x3_proof_len);\n\tx4_proof = packet_get_string(&x4_proof_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 1 received in %s\", __func__));\n\n\t/* Obtain password and derive secret */\n        secret_bn = BN_new();  // no need to set a specific value.\n\tpctx->s = secret_bn;\n\tbzero(crypt_scheme, strlen(crypt_scheme));\n\tbzero(salt, strlen(salt));\n\txfree(crypt_scheme);\n\txfree(salt);\n\tJPAKE_DEBUG_BN((pctx->s, \"%s: s = \", __func__));\n\n\t/* Calculate step 2 values */\n\tjpake_step2_mod(pctx->grp, pctx->s, pctx->g_x1,\n\t    pctx->g_x3, pctx->g_x4, pctx->x2,\n\t    pctx->server_id, pctx->server_id_len,\n\t    pctx->client_id, pctx->client_id_len,\n\t    x3_proof, x3_proof_len,\n\t    x4_proof, x4_proof_len,\n\t    &pctx->a,\n\t    &x2_s_proof, &x2_s_proof_len);\n\n\tbzero(x3_proof, x3_proof_len);\n\tbzero(x4_proof, x4_proof_len);\n\txfree(x3_proof);\n\txfree(x4_proof);\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 2 sending in %s\", __func__));\n\n\t/* Send values for step 2 */\n\tpacket_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2);\n\tpacket_put_bignum2(pctx->a);\n\tpacket_put_string(x2_s_proof, x2_s_proof_len);\n\tpacket_send();\n\n\tbzero(x2_s_proof, x2_s_proof_len);\n\txfree(x2_s_proof);\n\n\t/* Expect step 2 packet from peer */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2,\n\t    input_userauth_jpake_server_step2);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_response(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tGssctxt *gssctxt;\n\tint oidlen;\n\tchar *oidv;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\t/* Setup our OID */\n\toidv = packet_get_string(&oidlen);\n\n\tif (oidlen <= 2 ||\n\t    oidv[0] != SSH_GSS_OIDTYPE ||\n\t    oidv[1] != oidlen - 2) {\n\t\txfree(oidv);\n\t\tdebug(\"Badly encoded mechanism OID received\");\n\t\tuserauth(authctxt, NULL);\n\t\treturn;\n\t}\n\n\tif (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))\n\t\tfatal(\"Server returned different OID than expected\");\n\n\tpacket_check_eom();\n\n\txfree(oidv);\n\n\tif (GSS_ERROR(process_gssapi_token(ctxt, GSS_C_NO_BUFFER))) {\n\t\t/* Start again with next method on list */\n\t\tdebug(\"Trying to start again\");\n\t\tuserauth(authctxt, NULL);\n\t\treturn;\n\t}\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_token(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 status;\n\tu_int slen;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\n\trecv_tok.value = packet_get_string(&slen);\n\trecv_tok.length = slen;\t/* safe typecast */\n\n\tpacket_check_eom();\n\n\tstatus = process_gssapi_token(ctxt, &recv_tok);\n\n\txfree(recv_tok.value);\n\n\tif (GSS_ERROR(status)) {\n\t\t/* Start again with the next method in the list */\n\t\tuserauth(authctxt, NULL);\n\t\treturn;\n\t}\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_step2(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\tu_char *x4_s_proof;\n\tu_int x4_s_proof_len;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2, NULL);\n\n\tif ((pctx->b = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new\", __func__);\n\n\t/* Fetch step 2 values */\n\tpacket_get_bignum2(pctx->b);\n\tx4_s_proof = packet_get_string(&x4_s_proof_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"step 2 received in %s\", __func__));\n\n\t/* Derive shared key and calculate confirmation hash */\n\tjpake_key_confirm(pctx->grp, pctx->s, pctx->b,\n\t    pctx->x2, pctx->g_x1, pctx->g_x2, pctx->g_x3, pctx->g_x4,\n\t    pctx->client_id, pctx->client_id_len,\n\t    pctx->server_id, pctx->server_id_len,\n\t    session_id2, session_id2_len,\n\t    x4_s_proof, x4_s_proof_len,\n\t    &pctx->k,\n\t    &pctx->h_k_cid_sessid, &pctx->h_k_cid_sessid_len);\n\n\tbzero(x4_s_proof, x4_s_proof_len);\n\txfree(x4_s_proof);\n\n\tJPAKE_DEBUG_CTX((pctx, \"confirm sending in %s\", __func__));\n\n\t/* Send key confirmation proof */\n\tpacket_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM);\n\tpacket_put_string(pctx->h_k_cid_sessid, pctx->h_k_cid_sessid_len);\n\tpacket_send();\n\n\t/* Expect confirmation from peer */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM,\n\t    input_userauth_jpake_server_confirm);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_error(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tfatal(\"input_userauth_error: bad message during authentication: \"\n\t    \"type %d\", type);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * parse PASSWD_CHANGEREQ, prompt user and send SSH2_MSG_USERAUTH_REQUEST\n */\n/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_passwd_changereq(int type, u_int32_t seqnr, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tchar *info, *lang, *password = NULL, *retype = NULL;\n\tchar prompt[150];\n\tconst char *host = options.host_key_alias ? options.host_key_alias :\n\t    authctxt->host;\n\n\tdebug2(\"input_userauth_passwd_changereq\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\");\n\n\tinfo = packet_get_string(NULL);\n\tlang = packet_get_string(NULL);\n\tif (strlen(info) > 0)\n\t\tlogit(\"%s\", info);\n\txfree(info);\n\txfree(lang);\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_cstring(authctxt->server_user);\n\tpacket_put_cstring(authctxt->service);\n\tpacket_put_cstring(authctxt->method->name);\n\tpacket_put_char(1);\t\t\t/* additional info */\n\tsnprintf(prompt, sizeof(prompt),\n\t    \"Enter %.30s@%.128s's old password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tpacket_put_cstring(password);\n\tmemset(password, 0, strlen(password));\n\txfree(password);\n\tpassword = NULL;\n\twhile (password == NULL) {\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Enter %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tpassword = read_passphrase(prompt, RP_ALLOW_EOF);\n\t\tif (password == NULL) {\n\t\t\t/* bail out */\n\t\t\treturn;\n\t\t}\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Retype %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tretype = read_passphrase(prompt, 0);\n\t\tif (strcmp(password, retype) != 0) {\n\t\t\tmemset(password, 0, strlen(password));\n\t\t\txfree(password);\n\t\t\tlogit(\"Mismatch; try again, EOF to quit.\");\n\t\t\tpassword = NULL;\n\t\t}\n\t\tmemset(retype, 0, strlen(retype));\n\t\txfree(retype);\n\t}\n\tpacket_put_cstring(password);\n\tmemset(password, 0, strlen(password));\n\txfree(password);\n\tpacket_add_padding(64);\n\tpacket_send();\n\n\tdispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_errtok(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 status, ms;\n\tu_int len;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\trecv_tok.value = packet_get_string(&len);\n\trecv_tok.length = len;\n\n\tpacket_check_eom();\n\n\t/* Stick it into GSSAPI and see what it says */\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    &recv_tok, &send_tok, NULL);\n\n\txfree(recv_tok.value);\n\tgss_release_buffer(&ms, &send_tok);\n\n\t/* Server will be returning a failed packet after this one */\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* GSSAPI */\n", "func_signal": "int\nuserauth_none(Authctxt *authctxt)", "code": "{\n\t/* initial userauth request */\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_cstring(authctxt->server_user);\n\tpacket_put_cstring(authctxt->service);\n\tpacket_put_cstring(authctxt->method->name);\n\tpacket_send();\n\treturn 1;\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_jpake_server_confirm(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tstruct jpake_ctx *pctx = authctxt->methoddata;\n\n\t/* Disable this message */\n\tdispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM, NULL);\n\n\tpctx->h_k_sid_sessid = packet_get_string(&pctx->h_k_sid_sessid_len);\n\tpacket_check_eom();\n\n\tJPAKE_DEBUG_CTX((pctx, \"confirm received in %s\", __func__));\n\n\t/* Verify expected confirmation hash */\n\tif (jpake_check_confirm(pctx->k,\n\t    pctx->server_id, pctx->server_id_len,\n\t    session_id2, session_id2_len,\n\t    pctx->h_k_sid_sessid, pctx->h_k_sid_sessid_len) == 1)\n\t\tdebug(\"%s: %s success\", __func__, authctxt->method->name);\n\telse {\n\t\tdebug(\"%s: confirmation mismatch\", __func__);\n\t\t/* XXX stash this so if auth succeeds then we can warn/kill */\n\t}\n\n\tuserauth_jpake_cleanup(authctxt);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_success(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_success: no authentication context\");\n\tif (authctxt->authlist) {\n\t\txfree(authctxt->authlist);\n\t\tauthctxt->authlist = NULL;\n\t}\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\tif (authctxt->methoddata) {\n\t\txfree(authctxt->methoddata);\n\t\tauthctxt->methoddata = NULL;\n\t}\n\tauthctxt->success = 1;\t\t\t/* break out */\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_pk_ok(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tKey *key = NULL;\n\tIdentity *id = NULL;\n\tBuffer b;\n\tint pktype, sent = 0;\n\tu_int alen, blen;\n\tchar *pkalg, *fp;\n\tu_char *pkblob;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_pk_ok: no authentication context\");\n\tif (datafellows & SSH_BUG_PKOK) {\n\t\t/* this is similar to SSH_BUG_PKAUTH */\n\t\tdebug2(\"input_userauth_pk_ok: SSH_BUG_PKOK\");\n\t\tpkblob = packet_get_string(&blen);\n\t\tbuffer_init(&b);\n\t\tbuffer_append(&b, pkblob, blen);\n\t\tpkalg = buffer_get_string(&b, &alen);\n\t\tbuffer_free(&b);\n\t} else {\n\t\tpkalg = packet_get_string(&alen);\n\t\tpkblob = packet_get_string(&blen);\n\t}\n\tpacket_check_eom();\n\n\tdebug(\"Server accepts key: pkalg %s blen %u\", pkalg, blen);\n\n\tif ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {\n\t\tdebug(\"unknown pkalg %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif ((key = key_from_blob(pkblob, blen)) == NULL) {\n\t\tdebug(\"no key from blob. pkalg %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"input_userauth_pk_ok: type mismatch \"\n\t\t    \"for decoded key (received %d, expected %d)\",\n\t\t    key->type, pktype);\n\t\tgoto done;\n\t}\n\tfp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);\n\tdebug2(\"input_userauth_pk_ok: fp %s\", fp);\n\txfree(fp);\n\n\t/*\n\t * search keys in the reverse order, because last candidate has been\n\t * moved to the end of the queue.  this also avoids confusion by\n\t * duplicate keys\n\t */\n\tTAILQ_FOREACH_REVERSE(id, &authctxt->keys, idlist, next) {\n\t\tif (key_equal(key, id->key)) {\n\t\t\tsent = sign_and_send_pubkey(authctxt, id);\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tif (key != NULL)\n\t\tkey_free(key);\n\txfree(pkalg);\n\txfree(pkblob);\n\n\t/* try another method if we did not send a packet */\n\tif (sent == 0)\n\t\tuserauth(authctxt, NULL);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * try keys in the following order:\n *\t1. agent keys that are found in the config file\n *\t2. other agent keys\n *\t3. keys that are only listed in the config file\n */\n", "func_signal": "static void\npubkey_prepare(Authctxt *authctxt)", "code": "{\n\tIdentity *id;\n\tIdlist agent, files, *preferred;\n\tKey *key;\n\tAuthenticationConnection *ac;\n\tchar *comment;\n\tint i, found;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->type == KEY_RSA1)\n\t\t\tcontinue;\n\t\tif (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((ac = ssh_get_authentication_connection())) {\n\t\tfor (key = ssh_get_first_identity(ac, &comment, 2);\n\t\t    key != NULL;\n\t\t    key = ssh_get_next_identity(ac, &comment, 2)) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/* agent keys from the config file are preferred */\n\t\t\t\tif (key_equal(key, id->key)) {\n\t\t\t\t\tkey_free(key);\n\t\t\t\t\txfree(comment);\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->ac = ac;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\tid->key = key;\n\t\t\t\tid->filename = comment;\n\t\t\t\tid->ac = ac;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent = ac;\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\tTAILQ_FOREACH(id, preferred, next) {\n\t\tdebug2(\"key: %s (%p)\", id->filename, id->key);\n\t}\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * given auth method name, if configurable options permit this method fill\n * in auth_ident field and return true, otherwise return false.\n */\n", "func_signal": "static int\nauthmethod_is_enabled(Authmethod *method)", "code": "{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_gssapi_error(int type, u_int32_t plen, void *ctxt)", "code": "{\n\tOM_uint32 maj, min;\n\tchar *msg;\n\tchar *lang;\n\n\tmaj=packet_get_int();\n\tmin=packet_get_int();\n\tmsg=packet_get_string(NULL);\n\tlang=packet_get_string(NULL);\n\n\tpacket_check_eom();\n\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n\txfree(msg);\n\txfree(lang);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* ARGSUSED */\n", "func_signal": "void\ninput_userauth_failure(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tchar *authlist = NULL;\n\tint partial;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_failure: no authentication context\");\n\n\tauthlist = packet_get_string(NULL);\n\tpartial = packet_get_char();\n\tpacket_check_eom();\n\n\tif (partial != 0)\n\t\tlogit(\"Authenticated with partial success.\");\n\tdebug(\"Authentications that can continue: %s\", authlist);\n\n\tuserauth(authctxt, authlist);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * parse INFO_REQUEST, prompt user and send INFO_RESPONSE\n */\n", "func_signal": "void\ninput_userauth_info_req(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tAuthctxt *authctxt = ctxt;\n\tchar *name, *inst, *lang, *prompt, *response;\n\tu_int num_prompts, i;\n\tint echo = 0;\n\n\tdebug2(\"input_userauth_info_req\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_req: no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tname = packet_get_string(NULL);\n\tinst = packet_get_string(NULL);\n\tlang = packet_get_string(NULL);\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\txfree(name);\n\txfree(inst);\n\txfree(lang);\n\n\tnum_prompts = packet_get_int();\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tpacket_start(SSH2_MSG_USERAUTH_INFO_RESPONSE);\n\tpacket_put_int(num_prompts);\n\n\tdebug2(\"input_userauth_info_req: num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tprompt = packet_get_string(NULL);\n\t\techo = packet_get_char();\n\n\t\tresponse = read_passphrase(prompt, echo ? RP_ECHO : 0);\n\n\t\tpacket_put_cstring(response);\n\t\tmemset(response, 0, strlen(response));\n\t\txfree(response);\n\t\txfree(prompt);\n\t}\n\tpacket_check_eom(); /* done with parsing incoming message. */\n\n\tpacket_add_padding(64);\n\tpacket_send();\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/* JPAKE */\n", "func_signal": "static int\nidentity_sign(Identity *id, u_char **sigp, u_int *lenp,\n    u_char *data, u_int datalen)", "code": "{\n\tKey *prv;\n\tint ret;\n\n\t/* the agent supports this key */\n\tif (id->ac)\n\t\treturn (ssh_agent_sign(id->ac, id->key, sigp, lenp,\n\t\t    data, datalen));\n\t/*\n\t * we have already loaded the private key or\n\t * the private key is stored in external hardware\n\t */\n\tif (id->isprivate || (id->key->flags & KEY_FLAG_EXT))\n\t\treturn (key_sign(id->key, sigp, lenp, data, datalen));\n\t/* load the private key from the file */\n\tif ((prv = load_identity_file(id->filename)) == NULL)\n\t\treturn (-1);\n\tret = key_sign(prv, sigp, lenp, data, datalen);\n\tkey_free(prv);\n\treturn (ret);\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * Given the authentication method list sent by the server, return the\n * next method we should try.  If the server initially sends a nil list,\n * use a built-in default list.\n */\n", "func_signal": "static Authmethod *\nauthmethod_get(char *authlist)", "code": "{\n\tchar *name = NULL;\n\tu_int next;\n\n\t/* Use a suitable default if we're passed a nil list.  */\n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tif (supported != NULL)\n\t\t\txfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\treturn current;\n\t\t}\n\t}\n}", "path": "openssh-jpake\\sshconnect2.c", "repo_name": "seb-m/jpake", "stars": 23, "license": "None", "language": "c", "size": 189}
{"docstring": "/*\n * R5RS 6.6.3\n */\n", "func_signal": "static int write(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1 && nargs != 2) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  if(nargs == 1) {\n    sly_push_current_output_port(S);\n  }\n\n  sly_write(S, 0, 1);\n\n  return 0;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.2.6\n */\n", "func_signal": "static int number_to_string(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  } else {\n    sly_number_to_string(S, 0);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * creates an input port that is the\n * system's standard input\n */\n", "func_signal": "static int open_stdin_port(sly_state_t* S)", "code": "{\n  STKGC(S->sp) = sly_io_create_stdin(S);\n  STK(S->sp++).type = SLY_TYPE_INPUT_PORT;\n\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.3.6\n */\n", "func_signal": "static int vectorp(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  if(sly_vectorp(S, 0)) {\n    sly_push_boolean(S, 1);\n  } else {\n    sly_push_boolean(S, 0);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * search for a dynamic binding with the given tag\n * on the stack, sets the associated value\n * of the binding with the given argument, and\n * returns true if successful, false otherwise\n * the tag and the value must have been pushed\n * on the stack\n */\n", "func_signal": "static int dynamic_store(sly_state_t* S)", "code": "{\n  int idx;\n\n  for(idx = S->sp - 3; idx >= 0; idx--) {\n    if(STK(idx).type == SLY_TYPE_DYN_BIND &&\n       SLY_OBJ_EQ(SLY_DYN_BIND(STKGC(idx))->tag, STK(S->sp-2))) {\n      SLY_DYN_BIND(STKGC(idx))->value = STK(S->sp-1);\n      break;\n    }\n  }\n\n  STK(S->sp).type = SLY_TYPE_BOOL;\n  if(idx < 0) {\n    STK(S->sp++).value.bool = 0;\n  } else {\n    STK(S->sp++).value.bool = 1;\n  }\n\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * parses input into tokens to be used\n * by the 'read' procedure'\n */\n", "func_signal": "static int read_token(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  assert(STK(S->sp-1).type == SLY_TYPE_INPUT_PORT);\n\n  STK(S->sp++).type = SLY_TYPE_NIL;\n  sly_io_read_token(S, &STK(S->sp-2), &STK(S->sp-1));\n\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.3.2\n */\n", "func_signal": "static int cons(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 2) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  sly_cons(S, 0, 1);\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * loading\n */\n", "func_signal": "static void sly_destroy_module(sly_module_t *M)", "code": "{\n  uint32_t i;\n\n  free(M->code);\n\n  for(i = 0; i < M->nr_globals; i++) {\n    free(M->globals[i]);\n  }\n  free(M->globals);\n}", "path": "src\\vm.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.3.3\n */\n", "func_signal": "static int string_to_symbol(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  sly_string_to_symbol(S, 0);\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/* creates syntactic closures */\n", "func_signal": "static int make_syn_clo(sly_state_t* S)", "code": "{\n  sly_object_t synclo;\n  int nargs = sly_get_top(S);\n\n  if(nargs != 3) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  synclo.type = SLY_TYPE_SYNCLO;\n  synclo.value.gc = sly_create_syn_closure(S);\n\n  SLY_SYNCLO(synclo.value.gc)->env  = STK(S->sp-3);\n  SLY_SYNCLO(synclo.value.gc)->free = STK(S->sp-2);\n  SLY_SYNCLO(synclo.value.gc)->exp  = STK(S->sp-1);\n\n  STK(S->sp++) = synclo;\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.4\n */\n", "func_signal": "static int procedurep(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  if(sly_procedurep(S, 0)) {\n    sly_push_boolean(S, 1);\n  } else {\n    sly_push_boolean(S, 0);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * debugging\n */\n", "func_signal": "static void dump_instr(sly_state_t *S, uint32_t instr, sly_object_t *port)", "code": "{\n  uint8_t op;\n  sly_opcode_t* dbg;\n  char buf[64];\n\n  op = EXTRACT_OP(instr);\n  for(dbg = global_opcodes; dbg->name != NULL; dbg++) {\n    if(dbg->op == op) {\n      snprintf(buf, 64, \"%u\\t%s\", (uint32_t)op, dbg->name);\n      sly_io_write_c_string(S, buf, port);\n      if(IS_TYPE_B(op)) {\n\tsnprintf(buf, 64, \" %u\", EXTRACT_ARG(instr));\n        sly_io_write_c_string(S, buf, port);\n      }\n      break;\n    }\n  }\n}", "path": "src\\vm.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\nstatic void disassemble(sly_state_t* S)\n{\n  uint32_t i;\n\n  printf(\"Code listing:\\n\");\n  for(i = 0; i < S->code_size; i++) {\n    printf(\"\\t%u\\t\", i);\n    dump_instr(S->code[i]);\n    printf(\"\\n\");\n  }\n}\n*/\n", "func_signal": "void sly_vm_dump(sly_state_t* S)", "code": "{\n  uint32_t i;\n  char buf[64];\n  sly_object_t port;\n\n  port.type = SLY_TYPE_OUTPUT_PORT;\n  port.value.gc = sly_io_create_stderr(S);\n\n  sly_io_write_c_string(S, \"Instruction: \", &port);\n  dump_instr(S, S->code[S->pc], &port);\n  sly_io_newline(S, &port);\n\n  sly_io_write_c_string(S, \"Registers:\", &port);\n  sly_io_newline(S, &port);\n  sly_io_write_c_string(S, \"\\taccum: \", &port);\n  sly_io_write(S, &S->accum, &port);\n  sly_io_newline(S, &port);\n  sly_io_write_c_string(S, \"\\tclosure: \", &port);\n  sly_io_write(S, &S->proc, &port);\n  sly_io_newline(S, &port);\n  snprintf(buf, 64, \"\\tPC: %d\", S->pc);\n  sly_io_write_c_string(S, buf, &port);\n  sly_io_newline(S, &port);\n  snprintf(buf, 64, \"\\tFP: %d\", S->fp);\n  sly_io_write_c_string(S, buf, &port);\n  sly_io_newline(S, &port);\n\n  sly_io_write_c_string(S, \"Stack:\", &port);\n  for(i = 0; i < S->sp; i++) {\n    sly_io_write_c_string(S, \" \", &port);\n    sly_io_write(S, S->stack + i, &port);\n  }\n\n  sly_io_newline(S, &port);\n  sly_io_newline(S, &port);\n\n#if 0\n  printf(\"Globals:\\n\");\n  for(i = 0; i < S->global_env.size; i++) {\n    sly_env_var_t var = S->global_env.vars[i];\n    printf(\" [ %d , \", i);\n    fflush(NULL);\n    if(var.symbol) {\n      sly_io_write_symbol(S, var.symbol, &port);\n    }\n    printf(\" , \");\n    fflush(NULL);\n    sly_io_write(S, &var.value, &port);\n    printf(\"]\\n\");\n    fflush(NULL);\n  }\n  printf(\"\\n\\n\");\n  fflush(NULL);\n\n  printf(\"Constants:\");\n  for(i = 0; i < S->nr_consts; i++) {\n    printf(\" \");\n    sly_io_write(S->consts + i);\n  }\n  printf(\"\\n\\n\");\n#endif\n}", "path": "src\\vm.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.2.5\n */\n", "func_signal": "static int compare(sly_state_t* S, int c)", "code": "{\n  int i, ret, nargs = sly_get_top(S);\n\n  if(nargs == 0) {\n    sly_push_string(S, \"cannot compare zero numbers\");\n    sly_error(S, 1);\n  } else if(nargs == 1) {\n    if(!sly_numberp(S, 0)) {\n      sly_push_string(S, \"cannot compare single non-number\");\n      sly_error(S, 1);\n    } else {\n      sly_push_boolean(S, 1);\n    }\n  } else {\n    for(i = 0; i < nargs - 1; i++) {\n      switch(c) {\n      case 0:\n        ret = sly_less_than(S, i, i+1);\n        break;\n      case 1:\n        ret = sly_greater_than(S, i, i+1);\n        break;\n      default:\n\tabort();\n      }\n      if(!ret) {\n\tsly_push_boolean(S, 0);\n\treturn 1;\n      }\n    }\n    sly_push_boolean(S, 1);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * creates an input port that is the\n * system's standard output\n */\n", "func_signal": "static int open_stdout_port(sly_state_t* S)", "code": "{\n  STKGC(S->sp) = sly_io_create_stdout(S);\n  STK(S->sp++).type = SLY_TYPE_OUTPUT_PORT;\n\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * search for a dynamic binding with the given tag\n * on the stack, and pushes the associanted value or\n * a default one if the binding was not found\n * the tag and a default value must have been pushed\n * on the stack\n */\n", "func_signal": "static int dynamic_lookup(sly_state_t* S)", "code": "{\n  int idx;\n\n  for(idx = S->sp - 3; idx >= 0; idx--) {\n    if(STK(idx).type == SLY_TYPE_DYN_BIND &&\n       SLY_OBJ_EQ(SLY_DYN_BIND(STKGC(idx))->tag, STK(S->sp-2))) {\n      STK(S->sp++) = SLY_DYN_BIND(STKGC(idx))->value;\n      break;\n    }\n  }\n\n  return 1;\n}", "path": "src\\lib.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.3.5\n */\n", "func_signal": "static int stringp(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  if(sly_stringp(S, 0)) {\n    sly_push_boolean(S, 1);\n  } else {\n    sly_push_boolean(S, 0);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.5\n */\n", "func_signal": "static int eval(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  sly_eval(S, 0);\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * R5RS 6.6.1\n */\n", "func_signal": "static int input_portp(sly_state_t* S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  if(sly_input_portp(S, 0)) {\n    sly_push_boolean(S, 1);\n  } else {\n    sly_push_boolean(S, 0);\n  }\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/*\n * boxes\n */\n", "func_signal": "static int box(sly_state_t *S)", "code": "{\n  int nargs = sly_get_top(S);\n\n  if(nargs != 1) {\n    sly_push_string(S, \"wrong number of arguments\");\n    sly_error(S, 1);\n  }\n\n  sly_box(S);\n\n  return 1;\n}", "path": "src\\std.c", "repo_name": "asandroq/sly", "stars": 25, "license": "mit", "language": "c", "size": 1383}
{"docstring": "/* Called with .video_lock held */\n", "func_signal": "static void isi_camera_remove_device(struct soc_camera_device *icd)", "code": "{\n\tstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\n\tstruct atmel_isi *isi = ici->priv;\n\n\tBUG_ON(icd != isi->icd);\n\n\tclk_disable(isi->pclk);\n\tisi->icd = NULL;\n\n\tdev_dbg(icd->parent, \"Atmel ISI Camera driver detached from camera %d\\n\",\n\t\t icd->devnum);\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* -----------------------------------------------------------------------*/\n", "func_signal": "static int __devexit atmel_isi_remove(struct platform_device *pdev)", "code": "{\n\tstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\n\tstruct atmel_isi *isi = container_of(soc_host,\n\t\t\t\t\tstruct atmel_isi, soc_host);\n\n\tfree_irq(isi->irq, isi);\n\tsoc_camera_host_unregister(soc_host);\n\tvb2_dma_contig_cleanup_ctx(isi->alloc_ctx);\n\tdma_free_coherent(&pdev->dev,\n\t\t\tsizeof(struct fbd) * MAX_BUFFER_NUM,\n\t\t\tisi->p_fb_descriptors,\n\t\t\tisi->fb_descriptors_phys);\n\n\tiounmap(isi->regs);\n\tclk_put(isi->pclk);\n\tkfree(isi);\n\n\treturn 0;\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_convert_to_buffer\n *\n * PARAMETERS:  obj_desc        - Object to be converted. Must be an\n *                                Integer, Buffer, or String\n *              result_desc     - Where the new buffer object is returned\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert an ACPI Object to a Buffer\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ex_convert_to_buffer(union acpi_operand_object *obj_desc,\n\t\t\t  union acpi_operand_object **result_desc)", "code": "{\n\tunion acpi_operand_object *return_desc;\n\tu8 *new_buf;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_convert_to_buffer, obj_desc);\n\n\tswitch (obj_desc->common.type) {\n\tcase ACPI_TYPE_BUFFER:\n\n\t\t/* No conversion necessary */\n\n\t\t*result_desc = obj_desc;\n\t\treturn_ACPI_STATUS(AE_OK);\n\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t/*\n\t\t * Create a new Buffer object.\n\t\t * Need enough space for one integer\n\t\t */\n\t\treturn_desc =\n\t\t    acpi_ut_create_buffer_object(acpi_gbl_integer_byte_width);\n\t\tif (!return_desc) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\t/* Copy the integer to the buffer, LSB first */\n\n\t\tnew_buf = return_desc->buffer.pointer;\n\t\tACPI_MEMCPY(new_buf,\n\t\t\t    &obj_desc->integer.value,\n\t\t\t    acpi_gbl_integer_byte_width);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\t/*\n\t\t * Create a new Buffer object\n\t\t * Size will be the string length\n\t\t *\n\t\t * NOTE: Add one to the string length to include the null terminator.\n\t\t * The ACPI spec is unclear on this subject, but there is existing\n\t\t * ASL/AML code that depends on the null being transferred to the new\n\t\t * buffer.\n\t\t */\n\t\treturn_desc = acpi_ut_create_buffer_object((acpi_size)\n\t\t\t\t\t\t\t   obj_desc->string.\n\t\t\t\t\t\t\t   length + 1);\n\t\tif (!return_desc) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\t/* Copy the string to the buffer */\n\n\t\tnew_buf = return_desc->buffer.pointer;\n\t\tACPI_STRNCPY((char *)new_buf, (char *)obj_desc->string.pointer,\n\t\t\t     obj_desc->string.length);\n\t\tbreak;\n\n\tdefault:\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t/* Mark buffer initialized */\n\n\treturn_desc->common.flags |= AOPOBJ_DATA_VALID;\n\t*result_desc = return_desc;\n\treturn_ACPI_STATUS(AE_OK);\n}", "path": "drivers\\acpi\\acpica\\exconvrt.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*\n * Update the DC servo calibration on gain changes\n */\n", "func_signal": "static int wm8993_put_dc_servo(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)", "code": "{\n\tstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\n\tint ret;\n\n\tret = snd_soc_put_volsw_2r(kcontrol, ucontrol);\n\n\t/* Updating the analogue gains invalidates the DC servo cache */\n\thubs->class_w_dcs = 0;\n\n\t/* If we're applying an offset correction then updating the\n\t * callibration would be likely to introduce further offsets. */\n\tif (hubs->dcs_codes)\n\t\treturn ret;\n\n\t/* Only need to do this if the outputs are active */\n\tif (snd_soc_read(codec, WM8993_POWER_MANAGEMENT_1)\n\t    & (WM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA))\n\t\tsnd_soc_update_bits(codec,\n\t\t\t\t    WM8993_DC_SERVO_0,\n\t\t\t\t    WM8993_DCS_TRIG_SINGLE_0 |\n\t\t\t\t    WM8993_DCS_TRIG_SINGLE_1,\n\t\t\t\t    WM8993_DCS_TRIG_SINGLE_0 |\n\t\t\t\t    WM8993_DCS_TRIG_SINGLE_1);\n\n\treturn ret;\n}", "path": "sound\\soc\\codecs\\wm_hubs.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*****************************************************************************/\n/*\n * see if there's a fixup handler available to deal with a kernel fault\n */\n", "func_signal": "unsigned long search_exception_table(unsigned long pc)", "code": "{\n\tconst struct exception_table_entry *extab;\n\n\t/* determine if the fault lay during a memcpy_user or a memset_user */\n\tif (__frame->lr == (unsigned long) &__memset_user_error_lr &&\n\t    (unsigned long) &memset <= pc && pc < (unsigned long) &__memset_end\n\t    ) {\n\t\t/* the fault occurred in a protected memset\n\t\t * - we search for the return address (in LR) instead of the program counter\n\t\t * - it was probably during a clear_user()\n\t\t */\n\t\treturn (unsigned long) &__memset_user_error_handler;\n\t}\n\n\tif (__frame->lr == (unsigned long) &__memcpy_user_error_lr &&\n\t    (unsigned long) &memcpy <= pc && pc < (unsigned long) &__memcpy_end\n\t    ) {\n\t\t/* the fault occurred in a protected memset\n\t\t * - we search for the return address (in LR) instead of the program counter\n\t\t * - it was probably during a copy_to/from_user()\n\t\t */\n\t\treturn (unsigned long) &__memcpy_user_error_handler;\n\t}\n\n\textab = search_exception_tables(pc);\n\tif (extab)\n\t\treturn extab->fixup;\n\n\treturn 0;\n\n}", "path": "arch\\frv\\mm\\extable.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* ------------------------------------------------------------------\n\tVideobuf operations\n   ------------------------------------------------------------------*/\n", "func_signal": "static int queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\tunsigned int *nplanes, unsigned long sizes[],\n\t\t\t\tvoid *alloc_ctxs[])", "code": "{\n\tstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\n\tstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\n\tstruct atmel_isi *isi = ici->priv;\n\tunsigned long size;\n\tint ret, bytes_per_line;\n\n\t/* Reset ISI */\n\tret = atmel_isi_wait_status(isi, WAIT_ISI_RESET);\n\tif (ret < 0) {\n\t\tdev_err(icd->parent, \"Reset ISI timed out\\n\");\n\t\treturn ret;\n\t}\n\t/* Disable all interrupts */\n\tisi_writel(isi, ISI_INTDIS, ~0UL);\n\n\tbytes_per_line = soc_mbus_bytes_per_line(icd->user_width,\n\t\t\t\t\t\ticd->current_fmt->host_fmt);\n\n\tif (bytes_per_line < 0)\n\t\treturn bytes_per_line;\n\n\tsize = bytes_per_line * icd->user_height;\n\n\tif (!*nbuffers || *nbuffers > MAX_BUFFER_NUM)\n\t\t*nbuffers = MAX_BUFFER_NUM;\n\n\tif (size * *nbuffers > VID_LIMIT_BYTES)\n\t\t*nbuffers = VID_LIMIT_BYTES / size;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\talloc_ctxs[0] = isi->alloc_ctx;\n\n\tisi->sequence = 0;\n\tisi->active = NULL;\n\n\tdev_dbg(icd->parent, \"%s, count=%d, size=%ld\\n\", __func__,\n\t\t*nbuffers, size);\n\n\treturn 0;\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_convert_to_ascii\n *\n * PARAMETERS:  Integer         - Value to be converted\n *              Base            - ACPI_STRING_DECIMAL or ACPI_STRING_HEX\n *              String          - Where the string is returned\n *              data_width      - Size of data item to be converted, in bytes\n *\n * RETURN:      Actual string length\n *\n * DESCRIPTION: Convert an ACPI Integer to a hex or decimal string\n *\n ******************************************************************************/\n", "func_signal": "static u32\nacpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 data_width)", "code": "{\n\tu64 digit;\n\tu32 i;\n\tu32 j;\n\tu32 k = 0;\n\tu32 hex_length;\n\tu32 decimal_length;\n\tu32 remainder;\n\tu8 supress_zeros;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tswitch (base) {\n\tcase 10:\n\n\t\t/* Setup max length for the decimal number */\n\n\t\tswitch (data_width) {\n\t\tcase 1:\n\t\t\tdecimal_length = ACPI_MAX8_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdecimal_length = ACPI_MAX32_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\tdefault:\n\t\t\tdecimal_length = ACPI_MAX64_DECIMAL_DIGITS;\n\t\t\tbreak;\n\t\t}\n\n\t\tsupress_zeros = TRUE;\t/* No leading zeros */\n\t\tremainder = 0;\n\n\t\tfor (i = decimal_length; i > 0; i--) {\n\n\t\t\t/* Divide by nth factor of 10 */\n\n\t\t\tdigit = integer;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t(void)acpi_ut_short_divide(digit, 10, &digit,\n\t\t\t\t\t\t\t   &remainder);\n\t\t\t}\n\n\t\t\t/* Handle leading zeros */\n\n\t\t\tif (remainder != 0) {\n\t\t\t\tsupress_zeros = FALSE;\n\t\t\t}\n\n\t\t\tif (!supress_zeros) {\n\t\t\t\tstring[k] = (u8) (ACPI_ASCII_ZERO + remainder);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 16:\n\n\t\t/* hex_length: 2 ascii hex chars per data byte */\n\n\t\thex_length = ACPI_MUL_2(data_width);\n\t\tfor (i = 0, j = (hex_length - 1); i < hex_length; i++, j--) {\n\n\t\t\t/* Get one hex digit, most significant digits first */\n\n\t\t\tstring[k] =\n\t\t\t    (u8) acpi_ut_hex_to_ascii_char(integer,\n\t\t\t\t\t\t\t   ACPI_MUL_4(j));\n\t\t\tk++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Since leading zeros are suppressed, we must check for the case where\n\t * the integer equals 0\n\t *\n\t * Finally, null terminate the string and return the length\n\t */\n\tif (!k) {\n\t\tstring[0] = ACPI_ASCII_ZERO;\n\t\tk = 1;\n\t}\n\n\tstring[k] = 0;\n\treturn ((u32) k);\n}", "path": "drivers\\acpi\\acpica\\exconvrt.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*****************************************************************************/\n/*\n *\n */\n", "func_signal": "static inline unsigned long search_one_table(const struct exception_table_entry *first,\n\t\t\t\t\t     const struct exception_table_entry *last,\n\t\t\t\t\t     unsigned long value)", "code": "{\n        while (first <= last) {\n\t\tconst struct exception_table_entry __attribute__((aligned(8))) *mid;\n\t\tlong diff;\n\n\t\tmid = (last - first) / 2 + first;\n\t\tdiff = mid->insn - value;\n                if (diff == 0)\n                        return mid->fixup;\n                else if (diff < 0)\n                        first = mid + 1;\n                else\n                        last = mid - 1;\n        }\n        return 0;\n}", "path": "arch\\frv\\mm\\extable.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* For backward compatibility */\n", "func_signal": "int sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,\n\t\tstruct scsi_ioctl_command __user *sic)", "code": "{\n\tstruct request *rq;\n\tint err;\n\tunsigned int in_len, out_len, bytes, opcode, cmdlen;\n\tchar *buffer = NULL, sense[SCSI_SENSE_BUFFERSIZE];\n\n\tif (!sic)\n\t\treturn -EINVAL;\n\n\t/*\n\t * get in an out lengths, verify they don't exceed a page worth of data\n\t */\n\tif (get_user(in_len, &sic->inlen))\n\t\treturn -EFAULT;\n\tif (get_user(out_len, &sic->outlen))\n\t\treturn -EFAULT;\n\tif (in_len > PAGE_SIZE || out_len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\tif (get_user(opcode, sic->data))\n\t\treturn -EFAULT;\n\n\tbytes = max(in_len, out_len);\n\tif (bytes) {\n\t\tbuffer = kzalloc(bytes, q->bounce_gfp | GFP_USER| __GFP_NOWARN);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t}\n\n\trq = blk_get_request(q, in_len ? WRITE : READ, __GFP_WAIT);\n\n\tcmdlen = COMMAND_SIZE(opcode);\n\n\t/*\n\t * get command and data to send to device, if any\n\t */\n\terr = -EFAULT;\n\trq->cmd_len = cmdlen;\n\tif (copy_from_user(rq->cmd, sic->data, cmdlen))\n\t\tgoto error;\n\n\tif (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))\n\t\tgoto error;\n\n\terr = blk_verify_command(rq->cmd, mode & FMODE_WRITE);\n\tif (err)\n\t\tgoto error;\n\n\t/* default.  possible overriden later */\n\trq->retries = 5;\n\n\tswitch (opcode) {\n\tcase SEND_DIAGNOSTIC:\n\tcase FORMAT_UNIT:\n\t\trq->timeout = FORMAT_UNIT_TIMEOUT;\n\t\trq->retries = 1;\n\t\tbreak;\n\tcase START_STOP:\n\t\trq->timeout = START_STOP_TIMEOUT;\n\t\tbreak;\n\tcase MOVE_MEDIUM:\n\t\trq->timeout = MOVE_MEDIUM_TIMEOUT;\n\t\tbreak;\n\tcase READ_ELEMENT_STATUS:\n\t\trq->timeout = READ_ELEMENT_STATUS_TIMEOUT;\n\t\tbreak;\n\tcase READ_DEFECT_DATA:\n\t\trq->timeout = READ_DEFECT_DATA_TIMEOUT;\n\t\trq->retries = 1;\n\t\tbreak;\n\tdefault:\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\t\tbreak;\n\t}\n\n\tif (bytes && blk_rq_map_kern(q, rq, buffer, bytes, __GFP_WAIT)) {\n\t\terr = DRIVER_ERROR << 24;\n\t\tgoto out;\n\t}\n\n\tmemset(sense, 0, sizeof(sense));\n\trq->sense = sense;\n\trq->sense_len = 0;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\tblk_execute_rq(q, disk, rq, 0);\n\nout:\n\terr = rq->errors & 0xff;\t/* only 8 bit SCSI status */\n\tif (err) {\n\t\tif (rq->sense_len && rq->sense) {\n\t\t\tbytes = (OMAX_SB_LEN > rq->sense_len) ?\n\t\t\t\trq->sense_len : OMAX_SB_LEN;\n\t\t\tif (copy_to_user(sic->data, rq->sense, bytes))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t} else {\n\t\tif (copy_to_user(sic->data, buffer, out_len))\n\t\t\terr = -EFAULT;\n\t}\n\t\nerror:\n\tkfree(buffer);\n\tblk_put_request(rq);\n\treturn err;\n}", "path": "block\\scsi_ioctl.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_convert_to_string\n *\n * PARAMETERS:  obj_desc        - Object to be converted. Must be an\n *                                Integer, Buffer, or String\n *              result_desc     - Where the string object is returned\n *              Type            - String flags (base and conversion type)\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert an ACPI Object to a string\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ex_convert_to_string(union acpi_operand_object * obj_desc,\n\t\t\t  union acpi_operand_object ** result_desc, u32 type)", "code": "{\n\tunion acpi_operand_object *return_desc;\n\tu8 *new_buf;\n\tu32 i;\n\tu32 string_length = 0;\n\tu16 base = 16;\n\tu8 separator = ',';\n\n\tACPI_FUNCTION_TRACE_PTR(ex_convert_to_string, obj_desc);\n\n\tswitch (obj_desc->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\t/* No conversion necessary */\n\n\t\t*result_desc = obj_desc;\n\t\treturn_ACPI_STATUS(AE_OK);\n\n\tcase ACPI_TYPE_INTEGER:\n\n\t\tswitch (type) {\n\t\tcase ACPI_EXPLICIT_CONVERT_DECIMAL:\n\n\t\t\t/* Make room for maximum decimal number */\n\n\t\t\tstring_length = ACPI_MAX_DECIMAL_DIGITS;\n\t\t\tbase = 10;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\t/* Two hex string characters for each integer byte */\n\n\t\t\tstring_length = ACPI_MUL_2(acpi_gbl_integer_byte_width);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Create a new String\n\t\t * Need enough space for one ASCII integer (plus null terminator)\n\t\t */\n\t\treturn_desc =\n\t\t    acpi_ut_create_string_object((acpi_size) string_length);\n\t\tif (!return_desc) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\tnew_buf = return_desc->buffer.pointer;\n\n\t\t/* Convert integer to string */\n\n\t\tstring_length =\n\t\t    acpi_ex_convert_to_ascii(obj_desc->integer.value, base,\n\t\t\t\t\t     new_buf,\n\t\t\t\t\t     acpi_gbl_integer_byte_width);\n\n\t\t/* Null terminate at the correct place */\n\n\t\treturn_desc->string.length = string_length;\n\t\tnew_buf[string_length] = 0;\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\t/* Setup string length, base, and separator */\n\n\t\tswitch (type) {\n\t\tcase ACPI_EXPLICIT_CONVERT_DECIMAL:\t/* Used by to_decimal_string */\n\t\t\t/*\n\t\t\t * From ACPI: \"If Data is a buffer, it is converted to a string of\n\t\t\t * decimal values separated by commas.\"\n\t\t\t */\n\t\t\tbase = 10;\n\n\t\t\t/*\n\t\t\t * Calculate the final string length. Individual string values\n\t\t\t * are variable length (include separator for each)\n\t\t\t */\n\t\t\tfor (i = 0; i < obj_desc->buffer.length; i++) {\n\t\t\t\tif (obj_desc->buffer.pointer[i] >= 100) {\n\t\t\t\t\tstring_length += 4;\n\t\t\t\t} else if (obj_desc->buffer.pointer[i] >= 10) {\n\t\t\t\t\tstring_length += 3;\n\t\t\t\t} else {\n\t\t\t\t\tstring_length += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACPI_IMPLICIT_CONVERT_HEX:\n\t\t\t/*\n\t\t\t * From the ACPI spec:\n\t\t\t *\"The entire contents of the buffer are converted to a string of\n\t\t\t * two-character hexadecimal numbers, each separated by a space.\"\n\t\t\t */\n\t\t\tseparator = ' ';\n\t\t\tstring_length = (obj_desc->buffer.length * 3);\n\t\t\tbreak;\n\n\t\tcase ACPI_EXPLICIT_CONVERT_HEX:\t/* Used by to_hex_string */\n\t\t\t/*\n\t\t\t * From ACPI: \"If Data is a buffer, it is converted to a string of\n\t\t\t * hexadecimal values separated by commas.\"\n\t\t\t */\n\t\t\tstring_length = (obj_desc->buffer.length * 3);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t\t}\n\n\t\t/*\n\t\t * Create a new string object and string buffer\n\t\t * (-1 because of extra separator included in string_length from above)\n\t\t * Allow creation of zero-length strings from zero-length buffers.\n\t\t */\n\t\tif (string_length) {\n\t\t\tstring_length--;\n\t\t}\n\n\t\treturn_desc = acpi_ut_create_string_object((acpi_size)\n\t\t\t\t\t\t\t   string_length);\n\t\tif (!return_desc) {\n\t\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t\t}\n\n\t\tnew_buf = return_desc->buffer.pointer;\n\n\t\t/*\n\t\t * Convert buffer bytes to hex or decimal values\n\t\t * (separated by commas or spaces)\n\t\t */\n\t\tfor (i = 0; i < obj_desc->buffer.length; i++) {\n\t\t\tnew_buf += acpi_ex_convert_to_ascii((u64) obj_desc->\n\t\t\t\t\t\t\t    buffer.pointer[i],\n\t\t\t\t\t\t\t    base, new_buf, 1);\n\t\t\t*new_buf++ = separator;\t/* each separated by a comma or space */\n\t\t}\n\n\t\t/*\n\t\t * Null terminate the string\n\t\t * (overwrites final comma/space from above)\n\t\t */\n\t\tif (obj_desc->buffer.length) {\n\t\t\tnew_buf--;\n\t\t}\n\t\t*new_buf = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t*result_desc = return_desc;\n\treturn_ACPI_STATUS(AE_OK);\n}", "path": "drivers\\acpi\\acpica\\exconvrt.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* ------------------------------------------------------------------\n\tSOC camera operations for the device\n   ------------------------------------------------------------------*/\n", "func_signal": "static int isi_camera_init_videobuf(struct vb2_queue *q,\n\t\t\t\t     struct soc_camera_device *icd)", "code": "{\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP;\n\tq->drv_priv = icd;\n\tq->buf_struct_size = sizeof(struct frame_buffer);\n\tq->ops = &isi_video_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\n\treturn vb2_queue_init(q);\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* Called with .video_lock held */\n", "func_signal": "static int isi_camera_add_device(struct soc_camera_device *icd)", "code": "{\n\tstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\n\tstruct atmel_isi *isi = ici->priv;\n\tint ret;\n\n\tif (isi->icd)\n\t\treturn -EBUSY;\n\n\tret = clk_enable(isi->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tisi->icd = icd;\n\tdev_dbg(icd->parent, \"Atmel ISI Camera driver attached to camera %d\\n\",\n\t\t icd->devnum);\n\treturn 0;\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* ISI interrupt service routine */\n", "func_signal": "static irqreturn_t isi_interrupt(int irq, void *dev_id)", "code": "{\n\tstruct atmel_isi *isi = dev_id;\n\tu32 status, mask, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&isi->lock);\n\n\tstatus = isi_readl(isi, ISI_STATUS);\n\tmask = isi_readl(isi, ISI_INTMASK);\n\tpending = status & mask;\n\n\tif (pending & ISI_CTRL_SRST) {\n\t\tcomplete(&isi->complete);\n\t\tisi_writel(isi, ISI_INTDIS, ISI_CTRL_SRST);\n\t\tret = IRQ_HANDLED;\n\t} else if (pending & ISI_CTRL_DIS) {\n\t\tcomplete(&isi->complete);\n\t\tisi_writel(isi, ISI_INTDIS, ISI_CTRL_DIS);\n\t\tret = IRQ_HANDLED;\n\t} else {\n\t\tif ((pending & ISI_SR_VSYNC) &&\n\t\t\t\t(isi->state == ISI_STATE_IDLE)) {\n\t\t\tisi->state = ISI_STATE_READY;\n\t\t\twake_up_interruptible(&isi->vsync_wq);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t\tif (likely(pending & ISI_SR_CXFR_DONE))\n\t\t\tret = atmel_isi_handle_streaming(isi);\n\t}\n\n\tspin_unlock(&isi->lock);\n\treturn ret;\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* Send basic block requests */\n", "func_signal": "static int __blk_send_generic(struct request_queue *q, struct gendisk *bd_disk,\n\t\t\t      int cmd, int data)", "code": "{\n\tstruct request *rq;\n\tint err;\n\n\trq = blk_get_request(q, WRITE, __GFP_WAIT);\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\trq->cmd[0] = cmd;\n\trq->cmd[4] = data;\n\trq->cmd_len = 6;\n\terr = blk_execute_rq(q, bd_disk, rq, 0);\n\tblk_put_request(rq);\n\n\treturn err;\n}", "path": "block\\scsi_ioctl.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* This will be corrected as we get more formats */\n", "func_signal": "static bool isi_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)", "code": "{\n\treturn\tfmt->packing == SOC_MBUS_PACKING_NONE ||\n\t\t(fmt->bits_per_sample == 8 &&\n\t\t fmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\n\t\t(fmt->bits_per_sample > 8 &&\n\t\t fmt->packing == SOC_MBUS_PACKING_EXTEND16);\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* abort streaming and wait for last buffer */\n", "func_signal": "static int stop_streaming(struct vb2_queue *vq)", "code": "{\n\tstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\n\tstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\n\tstruct atmel_isi *isi = ici->priv;\n\tstruct frame_buffer *buf, *node;\n\tint ret = 0;\n\tunsigned long timeout;\n\n\tspin_lock_irq(&isi->lock);\n\tisi->active = NULL;\n\t/* Release all active buffers */\n\tlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irq(&isi->lock);\n\n\ttimeout = jiffies + FRAME_INTERVAL_MILLI_SEC * HZ;\n\t/* Wait until the end of the current frame. */\n\twhile ((isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) &&\n\t\t\ttime_before(jiffies, timeout))\n\t\tmsleep(1);\n\n\tif (time_after(jiffies, timeout)) {\n\t\tdev_err(icd->parent,\n\t\t\t\"Timeout waiting for finishing codec request\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* Disable interrupts */\n\tisi_writel(isi, ISI_INTDIS,\n\t\t\tISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\n\n\t/* Disable ISI and wait for it is done */\n\tret = atmel_isi_wait_status(isi, WAIT_ISI_DISABLE);\n\tif (ret < 0)\n\t\tdev_err(icd->parent, \"Disable ISI timed out\\n\");\n\n\treturn ret;\n}", "path": "drivers\\media\\video\\atmel-isi.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_convert_to_integer\n *\n * PARAMETERS:  obj_desc        - Object to be converted. Must be an\n *                                Integer, Buffer, or String\n *              result_desc     - Where the new Integer object is returned\n *              Flags           - Used for string conversion\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert an ACPI Object to an integer.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ex_convert_to_integer(union acpi_operand_object *obj_desc,\n\t\t\t   union acpi_operand_object **result_desc, u32 flags)", "code": "{\n\tunion acpi_operand_object *return_desc;\n\tu8 *pointer;\n\tu64 result;\n\tu32 i;\n\tu32 count;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_convert_to_integer, obj_desc);\n\n\tswitch (obj_desc->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t/* No conversion necessary */\n\n\t\t*result_desc = obj_desc;\n\t\treturn_ACPI_STATUS(AE_OK);\n\n\tcase ACPI_TYPE_BUFFER:\n\tcase ACPI_TYPE_STRING:\n\n\t\t/* Note: Takes advantage of common buffer/string fields */\n\n\t\tpointer = obj_desc->buffer.pointer;\n\t\tcount = obj_desc->buffer.length;\n\t\tbreak;\n\n\tdefault:\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t/*\n\t * Convert the buffer/string to an integer. Note that both buffers and\n\t * strings are treated as raw data - we don't convert ascii to hex for\n\t * strings.\n\t *\n\t * There are two terminating conditions for the loop:\n\t * 1) The size of an integer has been reached, or\n\t * 2) The end of the buffer or string has been reached\n\t */\n\tresult = 0;\n\n\t/* String conversion is different than Buffer conversion */\n\n\tswitch (obj_desc->common.type) {\n\tcase ACPI_TYPE_STRING:\n\n\t\t/*\n\t\t * Convert string to an integer - for most cases, the string must be\n\t\t * hexadecimal as per the ACPI specification. The only exception (as\n\t\t * of ACPI 3.0) is that the to_integer() operator allows both decimal\n\t\t * and hexadecimal strings (hex prefixed with \"0x\").\n\t\t */\n\t\tstatus = acpi_ut_strtoul64((char *)pointer, flags, &result);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\t/* Check for zero-length buffer */\n\n\t\tif (!count) {\n\t\t\treturn_ACPI_STATUS(AE_AML_BUFFER_LIMIT);\n\t\t}\n\n\t\t/* Transfer no more than an integer's worth of data */\n\n\t\tif (count > acpi_gbl_integer_byte_width) {\n\t\t\tcount = acpi_gbl_integer_byte_width;\n\t\t}\n\n\t\t/*\n\t\t * Convert buffer to an integer - we simply grab enough raw data\n\t\t * from the buffer to fill an integer\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t/*\n\t\t\t * Get next byte and shift it into the Result.\n\t\t\t * Little endian is used, meaning that the first byte of the buffer\n\t\t\t * is the LSB of the integer\n\t\t\t */\n\t\t\tresult |= (((u64) pointer[i]) << (i * 8));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\t/* No other types can get here */\n\t\tbreak;\n\t}\n\n\t/* Create a new integer */\n\n\treturn_desc = acpi_ut_create_integer_object(result);\n\tif (!return_desc) {\n\t\treturn_ACPI_STATUS(AE_NO_MEMORY);\n\t}\n\n\tACPI_DEBUG_PRINT((ACPI_DB_EXEC, \"Converted value: %8.8X%8.8X\\n\",\n\t\t\t  ACPI_FORMAT_UINT64(result)));\n\n\t/* Save the Result */\n\n\tacpi_ex_truncate_for32bit_table(return_desc);\n\t*result_desc = return_desc;\n\treturn_ACPI_STATUS(AE_OK);\n}", "path": "drivers\\acpi\\acpica\\exconvrt.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*\n * UHC(usb host controller) enable function.\n * affect to both of OHCI and EHCI core module.\n */\n", "func_signal": "static void enable_scc_uhc(struct pci_dev *dev)", "code": "{\n\tvoid __iomem *uhc_base;\n\tu32 __iomem *uhc_clkctrl;\n\tu32 __iomem *uhc_ecmode;\n\tu32 val = 0;\n\tint i;\n\n\tif (!machine_is(celleb_beat) &&\n\t    !machine_is(celleb_native))\n\t\treturn;\n\n\tuhc_base = ioremap(pci_resource_start(dev, 0),\n\t\t\t   pci_resource_len(dev, 0));\n\tif (!uhc_base) {\n\t\tprintk(KERN_ERR \"failed to map UHC register base.\\n\");\n\t\treturn;\n\t}\n\tuhc_clkctrl = uhc_base + SCC_UHC_CKRCTRL;\n\tuhc_ecmode  = uhc_base + SCC_UHC_ECMODE;\n\n\t/* setup for normal mode */\n\tval |= SCC_UHC_F48MCKLEN;\n\tout_be32(uhc_clkctrl, val);\n\tval |= SCC_UHC_PHY_SUSPEND_SEL;\n\tout_be32(uhc_clkctrl, val);\n\tudelay(10);\n\tval |= SCC_UHC_PHYEN;\n\tout_be32(uhc_clkctrl, val);\n\tudelay(50);\n\n\t/* disable reset */\n\tval |= SCC_UHC_HCLKEN;\n\tout_be32(uhc_clkctrl, val);\n\tval |= (SCC_UHC_USBCEN | SCC_UHC_USBEN);\n\tout_be32(uhc_clkctrl, val);\n\ti = 0;\n\twhile (!uhc_clkctrl_ready(in_be32(uhc_clkctrl))) {\n\t\tudelay(10);\n\t\tif (i++ > UHC_RESET_WAIT_MAX) {\n\t\t\tprintk(KERN_ERR \"Failed to disable UHC reset %x\\n\",\n\t\t\t       in_be32(uhc_clkctrl));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Endian Conversion Mode for Master ALL area */\n\tout_be32(uhc_ecmode, SCC_UHC_ECMODE_BY_BYTE);\n\n\tiounmap(uhc_base);\n}", "path": "arch\\powerpc\\platforms\\cell\\celleb_scc_uhc.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*\n * Startup calibration of the DC servo\n */\n", "func_signal": "static void calibrate_dc_servo(struct snd_soc_codec *codec)", "code": "{\n\tstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\n\ts8 offset;\n\tu16 reg, reg_l, reg_r, dcs_cfg;\n\n\t/* If we're using a digital only path and have a previously\n\t * callibrated DC servo offset stored then use that. */\n\tif (hubs->class_w && hubs->class_w_dcs) {\n\t\tdev_dbg(codec->dev, \"Using cached DC servo offset %x\\n\",\n\t\t\thubs->class_w_dcs);\n\t\tsnd_soc_write(codec, WM8993_DC_SERVO_3, hubs->class_w_dcs);\n\t\twait_for_dc_servo(codec,\n\t\t\t\t  WM8993_DCS_TRIG_DAC_WR_0 |\n\t\t\t\t  WM8993_DCS_TRIG_DAC_WR_1);\n\t\treturn;\n\t}\n\n\t/* Devices not using a DCS code correction have startup mode */\n\tif (hubs->dcs_codes) {\n\t\t/* Set for 32 series updates */\n\t\tsnd_soc_update_bits(codec, WM8993_DC_SERVO_1,\n\t\t\t\t    WM8993_DCS_SERIES_NO_01_MASK,\n\t\t\t\t    32 << WM8993_DCS_SERIES_NO_01_SHIFT);\n\t\twait_for_dc_servo(codec,\n\t\t\t\t  WM8993_DCS_TRIG_SERIES_0 |\n\t\t\t\t  WM8993_DCS_TRIG_SERIES_1);\n\t} else {\n\t\twait_for_dc_servo(codec,\n\t\t\t\t  WM8993_DCS_TRIG_STARTUP_0 |\n\t\t\t\t  WM8993_DCS_TRIG_STARTUP_1);\n\t}\n\n\t/* Different chips in the family support different readback\n\t * methods.\n\t */\n\tswitch (hubs->dcs_readback_mode) {\n\tcase 0:\n\t\treg_l = snd_soc_read(codec, WM8993_DC_SERVO_READBACK_1)\n\t\t\t& WM8993_DCS_INTEG_CHAN_0_MASK;\n\t\treg_r = snd_soc_read(codec, WM8993_DC_SERVO_READBACK_2)\n\t\t\t& WM8993_DCS_INTEG_CHAN_1_MASK;\n\t\tbreak;\n\tcase 1:\n\t\treg = snd_soc_read(codec, WM8993_DC_SERVO_3);\n\t\treg_l = (reg & WM8993_DCS_DAC_WR_VAL_1_MASK)\n\t\t\t>> WM8993_DCS_DAC_WR_VAL_1_SHIFT;\n\t\treg_r = reg & WM8993_DCS_DAC_WR_VAL_0_MASK;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unknown DCS readback method\\n\");\n\t\tbreak;\n\t}\n\n\tdev_dbg(codec->dev, \"DCS input: %x %x\\n\", reg_l, reg_r);\n\n\t/* Apply correction to DC servo result */\n\tif (hubs->dcs_codes) {\n\t\tdev_dbg(codec->dev, \"Applying %d code DC servo correction\\n\",\n\t\t\thubs->dcs_codes);\n\n\t\t/* HPOUT1L */\n\t\toffset = reg_l;\n\t\toffset += hubs->dcs_codes;\n\t\tdcs_cfg = (u8)offset << WM8993_DCS_DAC_WR_VAL_1_SHIFT;\n\n\t\t/* HPOUT1R */\n\t\toffset = reg_r;\n\t\toffset += hubs->dcs_codes;\n\t\tdcs_cfg |= (u8)offset;\n\n\t\tdev_dbg(codec->dev, \"DCS result: %x\\n\", dcs_cfg);\n\n\t\t/* Do it */\n\t\tsnd_soc_write(codec, WM8993_DC_SERVO_3, dcs_cfg);\n\t\twait_for_dc_servo(codec,\n\t\t\t\t  WM8993_DCS_TRIG_DAC_WR_0 |\n\t\t\t\t  WM8993_DCS_TRIG_DAC_WR_1);\n\t} else {\n\t\tdcs_cfg = reg_l << WM8993_DCS_DAC_WR_VAL_1_SHIFT;\n\t\tdcs_cfg |= reg_r;\n\t}\n\n\t/* Save the callibrated offset if we're in class W mode and\n\t * therefore don't have any analogue signal mixed in. */\n\tif (hubs->class_w)\n\t\thubs->class_w_dcs = dcs_cfg;\n}", "path": "sound\\soc\\codecs\\wm_hubs.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_convert_to_target_type\n *\n * PARAMETERS:  destination_type    - Current type of the destination\n *              source_desc         - Source object to be converted.\n *              result_desc         - Where the converted object is returned\n *              walk_state          - Current method state\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Implements \"implicit conversion\" rules for storing an object.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ex_convert_to_target_type(acpi_object_type destination_type,\n\t\t\t       union acpi_operand_object *source_desc,\n\t\t\t       union acpi_operand_object **result_desc,\n\t\t\t       struct acpi_walk_state *walk_state)", "code": "{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ex_convert_to_target_type);\n\n\t/* Default behavior */\n\n\t*result_desc = source_desc;\n\n\t/*\n\t * If required by the target,\n\t * perform implicit conversion on the source before we store it.\n\t */\n\tswitch (GET_CURRENT_ARG_TYPE(walk_state->op_info->runtime_args)) {\n\tcase ARGI_SIMPLE_TARGET:\n\tcase ARGI_FIXED_TARGET:\n\tcase ARGI_INTEGER_REF:\t/* Handles Increment, Decrement cases */\n\n\t\tswitch (destination_type) {\n\t\tcase ACPI_TYPE_LOCAL_REGION_FIELD:\n\t\t\t/*\n\t\t\t * Named field can always handle conversions\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* No conversion allowed for these types */\n\n\t\t\tif (destination_type != source_desc->common.type) {\n\t\t\t\tACPI_DEBUG_PRINT((ACPI_DB_INFO,\n\t\t\t\t\t\t  \"Explicit operator, will store (%s) over existing type (%s)\\n\",\n\t\t\t\t\t\t  acpi_ut_get_object_type_name\n\t\t\t\t\t\t  (source_desc),\n\t\t\t\t\t\t  acpi_ut_get_type_name\n\t\t\t\t\t\t  (destination_type)));\n\t\t\t\tstatus = AE_TYPE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ARGI_TARGETREF:\n\n\t\tswitch (destination_type) {\n\t\tcase ACPI_TYPE_INTEGER:\n\t\tcase ACPI_TYPE_BUFFER_FIELD:\n\t\tcase ACPI_TYPE_LOCAL_BANK_FIELD:\n\t\tcase ACPI_TYPE_LOCAL_INDEX_FIELD:\n\t\t\t/*\n\t\t\t * These types require an Integer operand. We can convert\n\t\t\t * a Buffer or a String to an Integer if necessary.\n\t\t\t */\n\t\t\tstatus =\n\t\t\t    acpi_ex_convert_to_integer(source_desc, result_desc,\n\t\t\t\t\t\t       16);\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_STRING:\n\t\t\t/*\n\t\t\t * The operand must be a String. We can convert an\n\t\t\t * Integer or Buffer if necessary\n\t\t\t */\n\t\t\tstatus =\n\t\t\t    acpi_ex_convert_to_string(source_desc, result_desc,\n\t\t\t\t\t\t      ACPI_IMPLICIT_CONVERT_HEX);\n\t\t\tbreak;\n\n\t\tcase ACPI_TYPE_BUFFER:\n\t\t\t/*\n\t\t\t * The operand must be a Buffer. We can convert an\n\t\t\t * Integer or String if necessary\n\t\t\t */\n\t\t\tstatus =\n\t\t\t    acpi_ex_convert_to_buffer(source_desc, result_desc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tACPI_ERROR((AE_INFO,\n\t\t\t\t    \"Bad destination type during conversion: 0x%X\",\n\t\t\t\t    destination_type));\n\t\t\tstatus = AE_AML_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ARGI_REFERENCE:\n\t\t/*\n\t\t * create_xxxx_field cases - we are storing the field object into the name\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tACPI_ERROR((AE_INFO,\n\t\t\t    \"Unknown Target type ID 0x%X AmlOpcode 0x%X DestType %s\",\n\t\t\t    GET_CURRENT_ARG_TYPE(walk_state->op_info->\n\t\t\t\t\t\t runtime_args),\n\t\t\t    walk_state->opcode,\n\t\t\t    acpi_ut_get_type_name(destination_type)));\n\t\tstatus = AE_AML_INTERNAL;\n\t}\n\n\t/*\n\t * Source-to-Target conversion semantics:\n\t *\n\t * If conversion to the target type cannot be performed, then simply\n\t * overwrite the target with the new object and type.\n\t */\n\tif (status == AE_TYPE) {\n\t\tstatus = AE_OK;\n\t}\n\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\exconvrt.c", "repo_name": "GlitchKernel/Glitch", "stars": 31, "license": "other", "language": "c", "size": 610317}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_crc_error(png_structp png_ptr)", "code": "{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n\n   if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name))\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n\n   else /* critical */\n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n#endif\n\n   /* The chunk CRC must be serialized in a single I/O call. */\n   png_read_data(png_ptr, crc_bytes, 4);\n\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n\n   else\n      return (0);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_finish_row(png_structp png_ptr)", "code": "{\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\n\n   png_debug(1, \"in png_read_finish_row\");\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced)\n   {\n      png_ptr->row_number = 0;\n\n      /* TO DO: don't do this if prev_row isn't needed (requires\n       * read-ahead of the next row's filter byte.\n       */\n      png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n      do\n      {\n         png_ptr->pass++;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if (!(png_ptr->transformations & PNG_INTERLACE))\n         {\n            png_ptr->num_rows = (png_ptr->height +\n                png_pass_yinc[png_ptr->pass] - 1 -\n                png_pass_ystart[png_ptr->pass]) /\n                png_pass_yinc[png_ptr->pass];\n         }\n\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\n            break; /* libpng deinterlacing sees every row */\n\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\n\n      if (png_ptr->pass < 7)\n         return;\n   }\n#endif /* PNG_READ_INTERLACING_SUPPORTED */\n\n   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))\n   {\n      char extra;\n      int ret;\n\n      png_ptr->zstream.next_out = (Byte *)&extra;\n      png_ptr->zstream.avail_out = (uInt)1;\n\n      for (;;)\n      {\n         if (!(png_ptr->zstream.avail_in))\n         {\n            while (!png_ptr->idat_size)\n            {\n               png_crc_finish(png_ptr, 0);\n               png_ptr->idat_size = png_read_chunk_header(png_ptr);\n               if (png_ptr->chunk_name != png_IDAT)\n                  png_error(png_ptr, \"Not enough image data\");\n            }\n\n            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;\n            png_ptr->zstream.next_in = png_ptr->zbuf;\n\n            if (png_ptr->zbuf_size > png_ptr->idat_size)\n               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;\n\n            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);\n            png_ptr->idat_size -= png_ptr->zstream.avail_in;\n         }\n\n         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);\n\n         if (ret == Z_STREAM_END)\n         {\n            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||\n                png_ptr->idat_size)\n               png_warning(png_ptr, \"Extra compressed data\");\n\n            png_ptr->mode |= PNG_AFTER_IDAT;\n            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;\n            break;\n         }\n\n         if (ret != Z_OK)\n            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :\n                \"Decompression Error\");\n\n         if (!(png_ptr->zstream.avail_out))\n         {\n            png_warning(png_ptr, \"Extra compressed data\");\n            png_ptr->mode |= PNG_AFTER_IDAT;\n            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;\n            break;\n         }\n\n      }\n      png_ptr->zstream.avail_out = 0;\n   }\n\n   if (png_ptr->idat_size || png_ptr->zstream.avail_in)\n      png_warning(png_ptr, \"Extra compression data\");\n\n   inflateReset(&png_ptr->zstream);\n\n   png_ptr->mode |= PNG_AFTER_IDAT;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte buf[13];\n   png_uint_32 width, height;\n   int bit_depth, color_type, compression_type, filter_type;\n   int interlace_type;\n\n   png_debug(1, \"in png_handle_IHDR\");\n\n   if (png_ptr->mode & PNG_HAVE_IHDR)\n      png_error(png_ptr, \"Out of place IHDR\");\n\n   /* Check the length */\n   if (length != 13)\n      png_error(png_ptr, \"Invalid IHDR chunk\");\n\n   png_ptr->mode |= PNG_HAVE_IHDR;\n\n   png_crc_read(png_ptr, buf, 13);\n   png_crc_finish(png_ptr, 0);\n\n   width = png_get_uint_31(png_ptr, buf);\n   height = png_get_uint_31(png_ptr, buf + 4);\n   bit_depth = buf[8];\n   color_type = buf[9];\n   compression_type = buf[10];\n   filter_type = buf[11];\n   interlace_type = buf[12];\n\n   /* Set internal variables */\n   png_ptr->width = width;\n   png_ptr->height = height;\n   png_ptr->bit_depth = (png_byte)bit_depth;\n   png_ptr->interlaced = (png_byte)interlace_type;\n   png_ptr->color_type = (png_byte)color_type;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   png_ptr->filter_type = (png_byte)filter_type;\n#endif\n   png_ptr->compression_type = (png_byte)compression_type;\n\n   /* Find number of channels */\n   switch (png_ptr->color_type)\n   {\n      default: /* invalid, png_set_IHDR calls png_error */\n      case PNG_COLOR_TYPE_GRAY:\n      case PNG_COLOR_TYPE_PALETTE:\n         png_ptr->channels = 1;\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n         png_ptr->channels = 3;\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         png_ptr->channels = 2;\n         break;\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         png_ptr->channels = 4;\n         break;\n   }\n\n   /* Set up other useful info */\n   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *\n   png_ptr->channels);\n   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);\n   png_debug1(3, \"bit_depth = %d\", png_ptr->bit_depth);\n   png_debug1(3, \"channels = %d\", png_ptr->channels);\n   png_debug1(3, \"rowbytes = %lu\", (unsigned long)png_ptr->rowbytes);\n   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,\n       color_type, interlace_type, compression_type, filter_type);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* Grab a signed 32-bit integer from a buffer in big-endian format.  The\n * data is stored in the PNG file in two's complement format and there\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\n * the following code does a two's complement to native conversion.\n */\n", "func_signal": "png_int_32 (PNGAPI\npng_get_int_32)(png_const_bytep buf)", "code": "{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   return -(png_int_32)uval;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\n", "func_signal": "png_uint_16 (PNGAPI\npng_get_uint_16)(png_const_bytep buf)", "code": "{\n   /* ANSI-C requires an int value to accomodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32 bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_debug(1, \"in png_handle_IEND\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))\n   {\n      png_error(png_ptr, \"No image in file\");\n   }\n\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\n\n   if (length != 0)\n   {\n      png_warning(png_ptr, \"Incorrect IEND chunk length\");\n   }\n\n   png_crc_finish(png_ptr, length);\n\n   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before hIST\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid hIST after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (!(png_ptr->mode & PNG_HAVE_PLTE))\n   {\n      png_warning(png_ptr, \"Missing PLTE before hIST\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))\n   {\n      png_warning(png_ptr, \"Duplicate hIST chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length > 2*PNG_MAX_PALETTE_LENGTH ||\n       length != (unsigned int) (2*png_ptr->num_palette))\n   {\n      png_warning(png_ptr, \"Incorrect hIST chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   num = length / 2 ;\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_textp text_ptr;\n   png_charp text;\n   int comp_type;\n   int ret;\n   png_size_t slength, prefix_len, data_len;\n\n   png_debug(1, \"in png_handle_zTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_warning(png_ptr, \"No space in chunk cache for zTXt\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n   }\n#endif\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before zTXt\");\n\n   if (png_ptr->mode & PNG_HAVE_IDAT)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n#ifdef PNG_MAX_MALLOC_64K\n   /* We will no doubt have problems with chunks even half this size, but\n    * there is no hard and fast rule to tell us where to stop.\n    */\n   if (length > (png_uint_32)65535L)\n   {\n      png_warning(png_ptr, \"zTXt chunk too large to fit in memory\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n#endif\n\n   png_free(png_ptr, png_ptr->chunkdata);\n   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);\n\n   if (png_ptr->chunkdata == NULL)\n   {\n      png_warning(png_ptr, \"Out of memory processing zTXt chunk\");\n      return;\n   }\n\n   slength = length;\n   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   png_ptr->chunkdata[slength] = 0x00;\n\n   for (text = png_ptr->chunkdata; *text; text++)\n      /* Empty loop */ ;\n\n   /* zTXt must have some text after the chunkdataword */\n   if (text >= png_ptr->chunkdata + slength - 2)\n   {\n      png_warning(png_ptr, \"Truncated zTXt chunk\");\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   else\n   {\n       comp_type = *(++text);\n\n       if (comp_type != PNG_TEXT_COMPRESSION_zTXt)\n       {\n          png_warning(png_ptr, \"Unknown compression type in zTXt chunk\");\n          comp_type = PNG_TEXT_COMPRESSION_zTXt;\n       }\n\n       text++;        /* Skip the compression_method byte */\n   }\n\n   prefix_len = text - png_ptr->chunkdata;\n\n   png_decompress_chunk(png_ptr, comp_type,\n       (png_size_t)length, prefix_len, &data_len);\n\n   text_ptr = (png_textp)png_malloc_warn(png_ptr,\n       png_sizeof(png_text));\n\n   if (text_ptr == NULL)\n   {\n      png_warning(png_ptr, \"Not enough memory to process zTXt chunk\");\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   text_ptr->compression = comp_type;\n   text_ptr->key = png_ptr->chunkdata;\n   text_ptr->lang = NULL;\n   text_ptr->lang_key = NULL;\n   text_ptr->itxt_length = 0;\n   text_ptr->text = png_ptr->chunkdata + prefix_len;\n   text_ptr->text_length = data_len;\n\n   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);\n\n   png_free(png_ptr, text_ptr);\n   png_free(png_ptr, png_ptr->chunkdata);\n   png_ptr->chunkdata = NULL;\n\n   if (ret)\n      png_error(png_ptr, \"Insufficient memory to store zTXt chunk\");\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_fixed_point igamma;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_gAMA\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before gAMA\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid gAMA after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      /* Should be an error, but we can cope with it */\n      png_warning(png_ptr, \"Out of place gAMA chunk\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)\n#ifdef PNG_READ_sRGB_SUPPORTED\n       && !(info_ptr->valid & PNG_INFO_sRGB)\n#endif\n       )\n   {\n      png_warning(png_ptr, \"Duplicate gAMA chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 4)\n   {\n      png_warning(png_ptr, \"Incorrect gAMA chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 4);\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   igamma = png_get_fixed_point(NULL, buf);\n\n   /* Check for zero gamma or an error. */\n   if (igamma <= 0)\n   {\n      png_warning(png_ptr,\n          \"Ignoring gAMA chunk with out of range gamma\");\n\n      return;\n   }\n\n#  ifdef PNG_READ_sRGB_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))\n   {\n      if (PNG_OUT_OF_RANGE(igamma, 45500, 500))\n      {\n         PNG_WARNING_PARAMETERS(p)\n         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, igamma);\n         png_formatted_warning(png_ptr, p,\n             \"Ignoring incorrect gAMA value @1 when sRGB is also present\");\n         return;\n      }\n   }\n#  endif /* PNG_READ_sRGB_SUPPORTED */\n\n#  ifdef PNG_READ_GAMMA_SUPPORTED\n   /* Gamma correction on read is supported. */\n   png_ptr->gamma = igamma;\n#  endif\n   /* And set the 'info' structure members. */\n   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_size_t truelen;\n   png_byte buf[6];\n   png_color_16 background;\n\n   png_debug(1, \"in png_handle_bKGD\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before bKGD\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid bKGD after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n       !(png_ptr->mode & PNG_HAVE_PLTE))\n   {\n      png_warning(png_ptr, \"Missing PLTE before bKGD\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))\n   {\n      png_warning(png_ptr, \"Duplicate bKGD chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      truelen = 1;\n\n   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)\n      truelen = 6;\n\n   else\n      truelen = 2;\n\n   if (length != truelen)\n   {\n      png_warning(png_ptr, \"Incorrect bKGD chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   /* We convert the index value into RGB components so that we can allow\n    * arbitrary RGB values for background when we have transparency, and\n    * so it is easy to determine the RGB values of the background color\n    * from the info_ptr struct.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      background.index = buf[0];\n\n      if (info_ptr && info_ptr->num_palette)\n      {\n         if (buf[0] >= info_ptr->num_palette)\n         {\n            png_warning(png_ptr, \"Incorrect bKGD chunk index value\");\n            return;\n         }\n\n         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;\n         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;\n         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;\n      }\n\n      else\n         background.red = background.green = background.blue = 0;\n\n      background.gray = 0;\n   }\n\n   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */\n   {\n      background.index = 0;\n      background.red =\n      background.green =\n      background.blue =\n      background.gray = png_get_uint_16(buf);\n   }\n\n   else\n   {\n      background.index = 0;\n      background.red = png_get_uint_16(buf);\n      background.green = png_get_uint_16(buf + 2);\n      background.blue = png_get_uint_16(buf + 4);\n      background.gray = 0;\n   }\n\n   png_set_bKGD(png_ptr, info_ptr, &background);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* report a zlib or i/o error */\n", "func_signal": "void zerr(int ret)", "code": "{\n    fputs(\"zpipe: \", stderr);\n    switch (ret) {\n    case Z_ERRNO:\n        if (ferror(stdin))\n            fputs(\"error reading stdin\\n\", stderr);\n        if (ferror(stdout))\n            fputs(\"error writing stdout\\n\", stderr);\n        break;\n    case Z_STREAM_ERROR:\n        fputs(\"invalid compression level\\n\", stderr);\n        break;\n    case Z_DATA_ERROR:\n        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n        break;\n    case Z_MEM_ERROR:\n        fputs(\"out of memory\\n\", stderr);\n        break;\n    case Z_VERSION_ERROR:\n        fputs(\"zlib version mismatch!\\n\", stderr);\n    }\n}", "path": "extradnf\\zlib-1.2.5\\examples\\zpipe.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte buf[32];\n   png_fixed_point x_white, y_white, x_red, y_red, x_green, y_green, x_blue,\n      y_blue;\n\n   png_debug(1, \"in png_handle_cHRM\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before cHRM\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid cHRM after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      /* Should be an error, but we can cope with it */\n      png_warning(png_ptr, \"Out of place cHRM chunk\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)\n#  ifdef PNG_READ_sRGB_SUPPORTED\n       && !(info_ptr->valid & PNG_INFO_sRGB)\n#  endif\n      )\n   {\n      png_warning(png_ptr, \"Duplicate cHRM chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 32)\n   {\n      png_warning(png_ptr, \"Incorrect cHRM chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 32);\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   x_white = png_get_fixed_point(NULL, buf);\n   y_white = png_get_fixed_point(NULL, buf + 4);\n   x_red   = png_get_fixed_point(NULL, buf + 8);\n   y_red   = png_get_fixed_point(NULL, buf + 12);\n   x_green = png_get_fixed_point(NULL, buf + 16);\n   y_green = png_get_fixed_point(NULL, buf + 20);\n   x_blue  = png_get_fixed_point(NULL, buf + 24);\n   y_blue  = png_get_fixed_point(NULL, buf + 28);\n\n   if (x_white == PNG_FIXED_ERROR ||\n       y_white == PNG_FIXED_ERROR ||\n       x_red   == PNG_FIXED_ERROR ||\n       y_red   == PNG_FIXED_ERROR ||\n       x_green == PNG_FIXED_ERROR ||\n       y_green == PNG_FIXED_ERROR ||\n       x_blue  == PNG_FIXED_ERROR ||\n       y_blue  == PNG_FIXED_ERROR)\n   {\n      png_warning(png_ptr, \"Ignoring cHRM chunk with negative chromaticities\");\n      return;\n   }\n\n#ifdef PNG_READ_sRGB_SUPPORTED\n   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))\n   {\n      if (PNG_OUT_OF_RANGE(x_white, 31270,  1000) ||\n          PNG_OUT_OF_RANGE(y_white, 32900,  1000) ||\n          PNG_OUT_OF_RANGE(x_red,   64000,  1000) ||\n          PNG_OUT_OF_RANGE(y_red,   33000,  1000) ||\n          PNG_OUT_OF_RANGE(x_green, 30000,  1000) ||\n          PNG_OUT_OF_RANGE(y_green, 60000,  1000) ||\n          PNG_OUT_OF_RANGE(x_blue,  15000,  1000) ||\n          PNG_OUT_OF_RANGE(y_blue,   6000,  1000))\n      {\n         PNG_WARNING_PARAMETERS(p)\n\n         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, x_white);\n         png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_fixed, y_white);\n         png_warning_parameter_signed(p, 3, PNG_NUMBER_FORMAT_fixed, x_red);\n         png_warning_parameter_signed(p, 4, PNG_NUMBER_FORMAT_fixed, y_red);\n         png_warning_parameter_signed(p, 5, PNG_NUMBER_FORMAT_fixed, x_green);\n         png_warning_parameter_signed(p, 6, PNG_NUMBER_FORMAT_fixed, y_green);\n         png_warning_parameter_signed(p, 7, PNG_NUMBER_FORMAT_fixed, x_blue);\n         png_warning_parameter_signed(p, 8, PNG_NUMBER_FORMAT_fixed, y_blue);\n\n         png_formatted_warning(png_ptr, p,\n             \"Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) \"\n             \"when sRGB is also present\");\n      }\n      return;\n   }\n#endif /* PNG_READ_sRGB_SUPPORTED */\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   /* Store the _white values as default coefficients for the rgb to gray\n    * operation if it is supported.  Check if the transform is already set to\n    * avoid destroying the transform values.\n    */\n   if (!png_ptr->rgb_to_gray_coefficients_set)\n   {\n      /* png_set_background has not been called and we haven't seen an sRGB\n       * chunk yet.  Find the XYZ of the three end points.\n       */\n      png_XYZ XYZ;\n      png_xy xy;\n\n      xy.redx = x_red;\n      xy.redy = y_red;\n      xy.greenx = x_green;\n      xy.greeny = y_green;\n      xy.bluex = x_blue;\n      xy.bluey = y_blue;\n      xy.whitex = x_white;\n      xy.whitey = y_white;\n\n      if (png_XYZ_from_xy_checked(png_ptr, &XYZ, xy))\n      {\n         /* The success case, because XYZ_from_xy normalises to a reference\n          * white Y of 1.0 we just need to scale the numbers.  This should\n          * always work just fine. It is an internal error if this overflows.\n          */\n         {\n            png_fixed_point r, g, b;\n            if (png_muldiv(&r, XYZ.redY, 32768, PNG_FP_1) &&\n               r >= 0 && r <= 32768 &&\n               png_muldiv(&g, XYZ.greenY, 32768, PNG_FP_1) &&\n               g >= 0 && g <= 32768 &&\n               png_muldiv(&b, XYZ.blueY, 32768, PNG_FP_1) &&\n               b >= 0 && b <= 32768 &&\n               r+g+b <= 32769)\n            {\n               /* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n                * all of the coefficients were rounded up.  Handle this by\n                * reducing the *largest* coefficient by 1; this matches the\n                * approach used for the default coefficients in pngrtran.c\n                */\n               int add = 0;\n\n               if (r+g+b > 32768)\n                  add = -1;\n               else if (r+g+b < 32768)\n                  add = 1;\n\n               if (add != 0)\n               {\n                  if (g >= r && g >= b)\n                     g += add;\n                  else if (r >= g && r >= b)\n                     r += add;\n                  else\n                     b += add;\n               }\n\n               /* Check for an internal error. */\n               if (r+g+b != 32768)\n                  png_error(png_ptr,\n                     \"internal error handling cHRM coefficients\");\n\n               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n            }\n\n            /* This is a png_error at present even though it could be ignored -\n             * it should never happen, but it is important that if it does, the\n             * bug is fixed.\n             */\n            else\n               png_error(png_ptr, \"internal error handling cHRM->XYZ\");\n         }\n      }\n   }\n#endif\n\n   png_set_cHRM_fixed(png_ptr, info_ptr, x_white, y_white, x_red, y_red,\n      x_green, y_green, x_blue, y_blue);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_sig(png_structp png_ptr, png_infop info_ptr)", "code": "{\n   png_size_t num_checked, num_to_check;\n\n   /* Exit if the user application does not expect a signature. */\n   if (png_ptr->sig_bytes >= 8)\n      return;\n\n   num_checked = png_ptr->sig_bytes;\n   num_to_check = 8 - num_checked;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;\n#endif\n\n   /* The signature must be serialized in a single I/O call. */\n   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\n   png_ptr->sig_bytes = 8;\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   if (num_checked < 3)\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_size_t slength, i;\n   int state;\n\n   png_debug(1, \"in png_handle_sCAL\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sCAL\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sCAL after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))\n   {\n      png_warning(png_ptr, \"Duplicate sCAL chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   /* Need unit type, width, \\0, height: minimum 4 bytes */\n   else if (length < 4)\n   {\n      png_warning(png_ptr, \"sCAL chunk too short\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",\n      length + 1);\n\n   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);\n\n   if (png_ptr->chunkdata == NULL)\n   {\n      png_warning(png_ptr, \"Out of memory while processing sCAL chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   slength = length;\n   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);\n   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   /* Validate the unit. */\n   if (png_ptr->chunkdata[0] != 1 && png_ptr->chunkdata[0] != 2)\n   {\n      png_warning(png_ptr, \"Invalid sCAL ignored: invalid unit\");\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   /* Validate the ASCII numbers, need two ASCII numbers separated by\n    * a '\\0' and they need to fit exactly in the chunk data.\n    */\n   i = 1;\n   state = 0;\n\n   if (!png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||\n       i >= slength || png_ptr->chunkdata[i++] != 0)\n      png_warning(png_ptr, \"Invalid sCAL chunk ignored: bad width format\");\n\n   else if (!PNG_FP_IS_POSITIVE(state))\n      png_warning(png_ptr, \"Invalid sCAL chunk ignored: non-positive width\");\n\n   else\n   {\n      png_size_t heighti = i;\n\n      state = 0;\n      if (!png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||\n          i != slength)\n         png_warning(png_ptr, \"Invalid sCAL chunk ignored: bad height format\");\n\n      else if (!PNG_FP_IS_POSITIVE(state))\n         png_warning(png_ptr,\n            \"Invalid sCAL chunk ignored: non-positive height\");\n\n      else\n         /* This is the (only) success case. */\n         png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0],\n            png_ptr->chunkdata+1, png_ptr->chunkdata+heighti);\n   }\n\n   /* Clean up - just free the temporarily allocated buffer. */\n   png_free(png_ptr, png_ptr->chunkdata);\n   png_ptr->chunkdata = NULL;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\n", "func_signal": "png_uint_32 (PNGAPI\npng_get_uint_32)(png_const_bytep buf)", "code": "{\n   png_uint_32 uval =\n       ((png_uint_32)(*(buf    )) << 24) +\n       ((png_uint_32)(*(buf + 1)) << 16) +\n       ((png_uint_32)(*(buf + 2)) <<  8) +\n       ((png_uint_32)(*(buf + 3))      ) ;\n\n   return uval;\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_read_filter_row(png_structp pp, png_row_infop row_info, png_bytep row,\n   png_const_bytep prev_row, int filter)", "code": "{\n   if (pp->read_filter[0] == NULL)\n      png_init_filter_functions(pp);\n   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)\n      pp->read_filter[filter-1](row_info, row, prev_row);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* Compress from file source to file dest until EOF on source.\n   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n   allocated for processing, Z_STREAM_ERROR if an invalid compression\n   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the\n   version of the library linked do not match, or Z_ERRNO if there is\n   an error reading or writing the files. */\n", "func_signal": "int def(FILE *source, FILE *dest, int level)", "code": "{\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate deflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, level);\n    if (ret != Z_OK)\n        return ret;\n\n    /* compress until end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        /* run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);    /* no bad return value */\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when last data in file processed */\n    } while (flush != Z_FINISH);\n    assert(ret == Z_STREAM_END);        /* stream will be complete */\n\n    /* clean up and return */\n    (void)deflateEnd(&strm);\n    return Z_OK;\n}", "path": "extradnf\\zlib-1.2.5\\examples\\zpipe.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   int intent;\n   png_byte buf[1];\n\n   png_debug(1, \"in png_handle_sRGB\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before sRGB\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid sRGB after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (png_ptr->mode & PNG_HAVE_PLTE)\n      /* Should be an error, but we can cope with it */\n      png_warning(png_ptr, \"Out of place sRGB chunk\");\n\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))\n   {\n      png_warning(png_ptr, \"Duplicate sRGB chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (length != 1)\n   {\n      png_warning(png_ptr, \"Incorrect sRGB chunk length\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_crc_read(png_ptr, buf, 1);\n\n   if (png_crc_finish(png_ptr, 0))\n      return;\n\n   intent = buf[0];\n\n   /* Check for bad intent */\n   if (intent >= PNG_sRGB_INTENT_LAST)\n   {\n      png_warning(png_ptr, \"Unknown sRGB intent\");\n      return;\n   }\n\n#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))\n   {\n      if (PNG_OUT_OF_RANGE(info_ptr->gamma, 45500, 500))\n      {\n         PNG_WARNING_PARAMETERS(p)\n\n         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed,\n            info_ptr->gamma);\n\n         png_formatted_warning(png_ptr, p,\n             \"Ignoring incorrect gAMA value @1 when sRGB is also present\");\n      }\n   }\n#endif /* PNG_READ_gAMA_SUPPORTED */\n\n#ifdef PNG_READ_cHRM_SUPPORTED\n   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))\n      if (PNG_OUT_OF_RANGE(info_ptr->x_white, 31270,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->y_white, 32900,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->x_red,   64000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->y_red,   33000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->x_green, 30000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->y_green, 60000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->x_blue,  15000,  1000) ||\n          PNG_OUT_OF_RANGE(info_ptr->y_blue,   6000,  1000))\n      {\n         png_warning(png_ptr,\n             \"Ignoring incorrect cHRM value when sRGB is also present\");\n      }\n#endif /* PNG_READ_cHRM_SUPPORTED */\n\n   /* This is recorded for use when handling the cHRM chunk above.  An sRGB\n    * chunk unconditionally overwrites the coefficients for grayscale conversion\n    * too.\n    */\n   png_ptr->is_sRGB = 1;\n\n#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n      /* Don't overwrite user supplied values: */\n      if (!png_ptr->rgb_to_gray_coefficients_set)\n      {\n         /* These numbers come from the sRGB specification (or, since one has to\n          * pay much money to get a copy, the wikipedia sRGB page) the\n          * chromaticity values quoted have been inverted to get the reverse\n          * transformation from RGB to XYZ and the 'Y' coefficients scaled by\n          * 32768 (then rounded).\n          *\n          * sRGB and ITU Rec-709 both truncate the values for the D65 white\n          * point to four digits and, even though it actually stores five\n          * digits, the PNG spec gives the truncated value.\n          *\n          * This means that when the chromaticities are converted back to XYZ\n          * end points we end up with (6968,23435,2366), which, as described in\n          * pngrtran.c, would overflow.  If the five digit precision and up is\n          * used we get, instead:\n          *\n          *    6968*R + 23435*G + 2365*B\n          *\n          * (Notice that this rounds the blue coefficient down, rather than the\n          * choice used in pngrtran.c which is to round the green one down.)\n          */\n         png_ptr->rgb_to_gray_red_coeff   =  6968; /* 0.212639005871510 */\n         png_ptr->rgb_to_gray_green_coeff = 23434; /* 0.715168678767756 */\n         /* png_ptr->rgb_to_gray_blue_coeff  =  2366; 0.072192315360734\t*/\n\n         /* The following keeps the cHRM chunk from destroying the\n          * coefficients again in the event that it follows the sRGB chunk.\n          */\n         png_ptr->rgb_to_gray_coefficients_set = 1;\n      }\n#  endif\n\n   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before tRNS\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid tRNS after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))\n   {\n      png_warning(png_ptr, \"Duplicate tRNS chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.gray = png_get_uint_16(buf);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, buf, (png_size_t)length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.red = png_get_uint_16(buf);\n      png_ptr->trans_color.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (!(png_ptr->mode & PNG_HAVE_PLTE))\n      {\n         /* Should be an error, but we can cope with it. */\n         png_warning(png_ptr, \"Missing PLTE before tRNS\");\n      }\n\n      if (length > (png_uint_32)png_ptr->num_palette ||\n          length > PNG_MAX_PALETTE_LENGTH)\n      {\n         png_warning(png_ptr, \"Incorrect tRNS chunk length\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      if (length == 0)\n      {\n         png_warning(png_ptr, \"Zero length tRNS chunk\");\n         png_crc_finish(png_ptr, length);\n         return;\n      }\n\n      png_crc_read(png_ptr, readbuf, (png_size_t)length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n\n   else\n   {\n      png_warning(png_ptr, \"tRNS chunk not allowed with alpha channel\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_ptr->num_trans = 0;\n      return;\n   }\n\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n       &(png_ptr->trans_color));\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)", "code": "{\n   png_int_32 X0, X1;\n   png_byte type, nparams;\n   png_charp buf, units, endptr;\n   png_charpp params;\n   png_size_t slength;\n   int i;\n\n   png_debug(1, \"in png_handle_pCAL\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR))\n      png_error(png_ptr, \"Missing IHDR before pCAL\");\n\n   else if (png_ptr->mode & PNG_HAVE_IDAT)\n   {\n      png_warning(png_ptr, \"Invalid pCAL after IDAT\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))\n   {\n      png_warning(png_ptr, \"Duplicate pCAL chunk\");\n      png_crc_finish(png_ptr, length);\n      return;\n   }\n\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%u bytes)\",\n       length + 1);\n   png_free(png_ptr, png_ptr->chunkdata);\n   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);\n\n   if (png_ptr->chunkdata == NULL)\n   {\n      png_warning(png_ptr, \"No memory for pCAL purpose\");\n      return;\n   }\n\n   slength = length;\n   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);\n\n   if (png_crc_finish(png_ptr, 0))\n   {\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */\n\n   png_debug(3, \"Finding end of pCAL purpose string\");\n   for (buf = png_ptr->chunkdata; *buf; buf++)\n      /* Empty loop */ ;\n\n   endptr = png_ptr->chunkdata + slength;\n\n   /* We need to have at least 12 bytes after the purpose string\n    * in order to get the parameter information.\n    */\n   if (endptr <= buf + 12)\n   {\n      png_warning(png_ptr, \"Invalid pCAL data\");\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\");\n   X0 = png_get_int_32((png_bytep)buf+1);\n   X1 = png_get_int_32((png_bytep)buf+5);\n   type = buf[9];\n   nparams = buf[10];\n   units = buf + 11;\n\n   png_debug(3, \"Checking pCAL equation type and number of parameters\");\n   /* Check that we have the right number of parameters for known\n    * equation types.\n    */\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\n   {\n      png_warning(png_ptr, \"Invalid pCAL parameters for equation type\");\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      return;\n   }\n\n   else if (type >= PNG_EQUATION_LAST)\n   {\n      png_warning(png_ptr, \"Unrecognized equation type for pCAL chunk\");\n   }\n\n   for (buf = units; *buf; buf++)\n      /* Empty loop to move past the units string. */ ;\n\n   png_debug(3, \"Allocating pCAL parameters array\");\n\n   params = (png_charpp)png_malloc_warn(png_ptr,\n       (png_size_t)(nparams * png_sizeof(png_charp)));\n\n   if (params == NULL)\n   {\n      png_free(png_ptr, png_ptr->chunkdata);\n      png_ptr->chunkdata = NULL;\n      png_warning(png_ptr, \"No memory for pCAL params\");\n      return;\n   }\n\n   /* Get pointers to the start of each parameter string. */\n   for (i = 0; i < (int)nparams; i++)\n   {\n      buf++; /* Skip the null string terminator from previous parameter. */\n\n      png_debug1(3, \"Reading pCAL parameter %d\", i);\n\n      for (params[i] = buf; buf <= endptr && *buf != 0x00; buf++)\n         /* Empty loop to move past each parameter string */ ;\n\n      /* Make sure we haven't run out of data yet */\n      if (buf > endptr)\n      {\n         png_warning(png_ptr, \"Invalid pCAL data\");\n         png_free(png_ptr, png_ptr->chunkdata);\n         png_ptr->chunkdata = NULL;\n         png_free(png_ptr, params);\n         return;\n      }\n   }\n\n   png_set_pCAL(png_ptr, info_ptr, png_ptr->chunkdata, X0, X1, type, nparams,\n      units, params);\n\n   png_free(png_ptr, png_ptr->chunkdata);\n   png_ptr->chunkdata = NULL;\n   png_free(png_ptr, params);\n}", "path": "extradnf\\extradnf\\libpng\\pngrutil.c", "repo_name": "langresser/dnfextrator", "stars": 22, "license": "None", "language": "c", "size": 3044}
{"docstring": "/* decode a frame of frame_len samples */\n", "func_signal": "static int wma_decode_frame(WMADecodeContext *s)", "code": "{\n    int ret;\n\n    /* read each block */\n    s->block_num = 0;\n    s->block_pos = 0;\n\n\n    for(;;)\n    {\n        ret = wma_decode_block(s);\n        if (ret < 0)\n        {\n\n            DEBUGF(\"wma_decode_block failed with code %d\\n\", ret);\n            return -1;\n        }\n        if (ret)\n        {\n            break;\n        }\n    }\n    \n    return 0;\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* turn the display upside down (call lcd_update() afterwards) */\n", "func_signal": "void lcd_set_flip(bool yesno)", "code": "{\n    /* TODO: flip mode isn't working.  The commands in the else part of\n       this function are how the original firmware inits the LCD */\n\n    if (yesno)\n    {\n        xoffset = 132 - LCD_WIDTH; /* 132 colums minus the 128 we have */\n    }\n    else \n    {\n        xoffset = 0;\n    }\n}", "path": "firmware\\target\\arm\\s5l8700\\ipodnano2g\\lcd-nano2g.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* Set the pin pad configuration (keeper, drive strength, etc.) */\n", "func_signal": "void iomuxc_set_pad_config(enum IMX31_IOMUXC_PINS pin,\n                           unsigned long config)", "code": "{\n    unsigned long padoffs = pin + 2;\n    unsigned long index = padoffs / 3;\n    unsigned int shift = 10*(padoffs % 3);\n\n    bitmod32((unsigned long *)(IOMUXC_BASE_ADDR + 0x154) + index,\n             config << shift, IOMUXC_PAD_MASK << shift);\n}", "path": "firmware\\target\\arm\\imx31\\iomuxc-imx31.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* add a creation method, which is a function that returns a Pd object\n    suitable for putting in an object box.  We presume you've got a class it\n    can belong to, but this won't be used until the newmethod is actually\n    called back (and the new method explicitly takes care of this.) */\n", "func_signal": "void class_addcreator(t_newmethod newmethod, t_symbol *s, \n    t_atomtype type1, ...)", "code": "{\n    va_list ap;\n    t_atomtype vec[MAXPDARG+1], *vp = vec;\n    int count = 0;\n    *vp = type1;\n\n    va_start(ap, type1);\n    while (*vp)\n    {\n\tif (count == MAXPDARG)\n\t{\n    \t    error(\"class %s: sorry: only %d creation args allowed\",\n    \t\ts->s_name, MAXPDARG);\n    \t    break;\n\t}\n\tvp++;\n\tcount++;\n\t*vp = va_arg(ap, t_atomtype);\n    } \n    va_end(ap);\n    class_addmethod(pd_objectmaker, (t_method)newmethod, s,\n    \tvec[0], vec[1], vec[2], vec[3], vec[4], vec[5]);\n}", "path": "apps\\plugins\\pdbox\\PDa\\src\\m_class.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* this routine is called when a new \"object\" is requested whose class Pd\n    doesn't know.  Pd tries to load it as an extern, then as an abstraction. */\n", "func_signal": "void new_anything(void *dummy, t_symbol *s, int argc, t_atom *argv)", "code": "{\n    t_pd *current;\n    t_symbol *dir = canvas_getcurrentdir();\n    int fd;\n    char dirbuf[MAXPDSTRING], *nameptr;\n    if (tryingalready) return;\n    newest = 0;\n    class_loadsym = s;\n    if (sys_load_lib(dir->s_name, s->s_name))\n    {\n    \ttryingalready = 1;\n    \ttypedmess(dummy, s, argc, argv);\n    \ttryingalready = 0;\n    \treturn;\n    }\n    class_loadsym = 0;\n    current = s__X.s_thing;\n    if ((fd = open_via_path(dir->s_name, s->s_name, \".pd\",\n    \tdirbuf, &nameptr, MAXPDSTRING, 0)) >= 0 ||\n\t    (fd = open_via_path(dir->s_name, s->s_name, \".pat\",\n    \t    \tdirbuf, &nameptr, MAXPDSTRING, 0)) >= 0)\n    {\n    \tclose (fd);\n\tif (!pd_setloadingabstraction(s))\n\t{\n    \t    canvas_setargs(argc, argv); /* bug fix by Krzysztof Czaja */\n    \t    binbuf_evalfile(gensym(nameptr), gensym(dirbuf));\n    \t    if (s__X.s_thing != current)\n    \t    \tcanvas_popabstraction((t_canvas *)(s__X.s_thing));\n    \t    canvas_setargs(0, 0);\n\t}\n\telse error(\"%s: can't load abstraction within itself\\n\", s->s_name);\n    }\n    else newest = 0;\n}", "path": "apps\\plugins\\pdbox\\PDa\\src\\m_class.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* compute x^-0.25 with an exponent and mantissa table. We use linear\n   interpolation to reduce the mantissa table size at a small speed\n   expense (linear interpolation approximately doubles the number of\n   bits of precision). */\n", "func_signal": "static inline fixed32 pow_m1_4(WMADecodeContext *s, fixed32 x)", "code": "{\n    union {\n        float f;\n        unsigned int v;\n    } u, t;\n    unsigned int e, m;\n    fixed32 a, b;\n\n    u.f = fixtof64(x);\n    e = u.v >> 23;\n    m = (u.v >> (23 - LSP_POW_BITS)) & ((1 << LSP_POW_BITS) - 1);\n    /* build interpolation scale: 1 <= t < 2. */\n    t.v = ((u.v << LSP_POW_BITS) & ((1 << 23) - 1)) | (127 << 23);\n    a = ((fixed32*)s->lsp_pow_m_table1)[m];\n    b = ((fixed32*)s->lsp_pow_m_table2)[m];\n\n    /* lsp_pow_e_table contains 32.32 format */\n    /* TODO:  Since we're unlikely have value that cover the whole\n     * IEEE754 range, we probably don't need to have all possible exponents */\n\n    return (lsp_pow_e_table[e] * (a + fixmul32(b, ftofix32(t.f))) >>32);\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* handle \"list\" messages to Pds without explicit list methods defined. */\n", "func_signal": "static void pd_defaultlist(t_pd *x, t_symbol *s, int argc, t_atom *argv)", "code": "{\n    \t    /* a list with one element which is a number can be handled by a\n\t    \"float\" method if any is defined; same for \"symbol\", \"pointer\". */\n    if (argc == 1)\n    {\n    \tif (argv->a_type == A_FLOAT &&\n    \t*(*x)->c_floatmethod != pd_defaultfloat)\n    \t{\n    \t    (*(*x)->c_floatmethod)(x, argv->a_w.w_float);\n\t    return;\n\t}\n\telse if (argv->a_type == A_SYMBOL &&\n    \t    *(*x)->c_symbolmethod != pd_defaultsymbol)\n\t{\n    \t    (*(*x)->c_symbolmethod)(x, argv->a_w.w_symbol);\n\t    return;\n\t}\n\telse if (argv->a_type == A_POINTER &&\n    \t    *(*x)->c_pointermethod != pd_defaultpointer)\n\t{\n    \t    (*(*x)->c_pointermethod)(x, argv->a_w.w_gpointer);\n\t    return;\n\t}\n    }\n    \t/* Next try for an \"anything\" method */\n    if ((*x)->c_anymethod != pd_defaultanything)\n    \t(*(*x)->c_anymethod)(x, &s_list, argc, argv);\n\n    \t/* if the object is patchable (i.e., can have proper inlets)\n\t    send it on to obj_list which will unpack the list into the inlets */\n    else if ((*x)->c_patchable)\n    \tobj_list((t_object *)x, s, argc, argv);\n\t    /* otherwise gove up and complain. */\n    else pd_defaultanything(x, &s_list, argc, argv);\n}", "path": "apps\\plugins\\pdbox\\PDa\\src\\m_class.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* ROCKBOX */\n", "func_signal": "static void netreceive_doit(void *z, t_binbuf *b)", "code": "{\n#ifndef ROCKBOX\n    t_atom messbuf[1024];\n#endif\n    t_netreceive *x = (t_netreceive *)z;\n    int msg, natom = binbuf_getnatom(b);\n    t_atom *at = binbuf_getvec(b);\n    for (msg = 0; msg < natom;)\n    {\n    \tint emsg;\n\tfor (emsg = msg; emsg < natom && at[emsg].a_type != A_COMMA\n\t    && at[emsg].a_type != A_SEMI; emsg++)\n\t    \t;\n\tif (emsg > msg)\n\t{\n\t    int i;\n\t    for (i = msg; i < emsg; i++)\n\t    \tif (at[i].a_type == A_DOLLAR || at[i].a_type == A_DOLLSYM)\n\t    {\n\t    \tpd_error(x, \"netreceive: got dollar sign in message\");\n\t\tgoto nodice;\n\t    }\n\t    if (at[msg].a_type == A_FLOAT)\n\t    {\n\t    \tif (emsg > msg + 1)\n\t\t    outlet_list(x->x_msgout, 0, emsg-msg, at + msg);\n\t\telse outlet_float(x->x_msgout, at[msg].a_w.w_float);\n\t    }\n\t    else if (at[msg].a_type == A_SYMBOL)\n\t    \toutlet_anything(x->x_msgout, at[msg].a_w.w_symbol,\n\t\t    emsg-msg-1, at + msg + 1);\n\t}\n    nodice:\n    \tmsg = emsg + 1;\n    }\n}", "path": "apps\\plugins\\pdbox\\PDa\\src\\x_net.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* Set the pin multiplexing configuration (functional, GPIO, etc.) */\n", "func_signal": "void iomuxc_set_pin_mux(enum IMX31_IOMUXC_PINS pin,\n                        unsigned long mux)", "code": "{\n    unsigned long index = pin / 4;\n    unsigned int shift = 8*(pin % 4);\n\n    bitmod32((unsigned long *)(IOMUXC_BASE_ADDR + 0xc) + index,\n              mux << shift, IOMUXC_MUX_MASK << shift);\n}", "path": "firmware\\target\\arm\\imx31\\iomuxc-imx31.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* LCD init */\n", "func_signal": "void lcd_init_device(void)", "code": "{\n    /* Detect lcd type */\n\n    PCON13 &= ~0xf;    /* Set pin 0 to input */\n    PCON14 &= ~0xf0;   /* Set pin 1 to input */\n\n    if (((PDAT13 & 1) == 0) && ((PDAT14 & 2) == 2)) {\n        lcd_type   = 0;     /* Similar to ILI9320 - aka \"type 2\" */\n        LCD_CON   |= 0x180; /* use 16 bit bus width, big endian */\n    } else {\n        lcd_type   = 1;     /* Similar to LDS176  - aka \"type 7\" */\n        LCD_CON   |= 0x100; /* use 16 bit bus width, little endian */\n    }\n    \n    LCD_PHTIME = 0x00; /* Set Phase Time (faster LCD IF than Apple OF) */\n\n    lcd_ispowered = true;\n}", "path": "firmware\\target\\arm\\s5l8700\\ipodnano2g\\lcd-nano2g.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/**\n  * Apply MDCT window and add into output.\n  *\n  * We ensure that when the windows overlap their squared sum\n  * is always 1 (MDCT reconstruction rule).\n  *\n  * The Vorbis I spec has a great diagram explaining this process.\n  * See section 1.3.2.3 of http://xiph.org/vorbis/doc/Vorbis_I_spec.html\n  */\n", "func_signal": "static void wma_window(WMADecodeContext *s, fixed32 *in, fixed32 *out)", "code": "{\n     //float *in = s->output;\n     int block_len, bsize, n;\n\n     /* left part */\n     \n     /* previous block was larger, so we'll use the size of the current \n      * block to set the window size*/\n     if (s->block_len_bits <= s->prev_block_len_bits) {\n         block_len = s->block_len;\n         bsize = s->frame_len_bits - s->block_len_bits;\n\n         vector_fmul_add_add(out, in, s->windows[bsize], block_len);\n\n     } else {\n         /*previous block was smaller or the same size, so use it's size to set the window length*/\n         block_len = 1 << s->prev_block_len_bits;\n         /*find the middle of the two overlapped blocks, this will be the first overlapped sample*/\n         n = (s->block_len - block_len) / 2;\n         bsize = s->frame_len_bits - s->prev_block_len_bits;\n\n         vector_fmul_add_add(out+n, in+n, s->windows[bsize],  block_len);\n\n         memcpy(out+n+block_len, in+n+block_len, n*sizeof(fixed32));\n     }\n    /* Advance to the end of the current block and prepare to window it for the next block.\n     * Since the window function needs to be reversed, we do it backwards starting with the\n     * last sample and moving towards the first\n     */\n     out += s->block_len;\n     in += s->block_len;\n\n     /* right part */\n     if (s->block_len_bits <= s->next_block_len_bits) {\n         block_len = s->block_len;\n         bsize = s->frame_len_bits - s->block_len_bits;\n\n         vector_fmul_reverse(out, in, s->windows[bsize], block_len);\n\n     } else {\n         block_len = 1 << s->next_block_len_bits;\n         n = (s->block_len - block_len) / 2;\n         bsize = s->frame_len_bits - s->next_block_len_bits;\n\n         memcpy(out, in, n*sizeof(fixed32));\n\n         vector_fmul_reverse(out+n, in+n, s->windows[bsize], block_len);\n\n         memset(out+n+block_len, 0, n*sizeof(fixed32));\n     }\n }\n\n\n\n\n/* XXX: use same run/length optimization as mpeg decoders */\nstatic void init_coef_vlc(VLC *vlc,\n                          uint16_t **prun_table, uint16_t **plevel_table,\n                          const CoefVLCTable *vlc_table, int tab)\n{\n    int n = vlc_table->n;\n    const uint8_t *table_bits = vlc_table->huffbits;\n    const uint32_t *table_codes = vlc_table->huffcodes;\n    const uint16_t *levels_table = vlc_table->levels;\n    uint16_t *run_table, *level_table;\n    const uint16_t *p;\n    int i, l, j, level;\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, INIT_VLC_USE_NEW_STATIC);\n\n    run_table = runtabarray[tab];\n    level_table= levtabarray[tab];\n\n    p = levels_table;\n    i = 2;\n    level = 1;\n    while (i < n)\n    {\n        l = *p++;\n        for(j=0;j<l;++j)\n        {\n            run_table[i] = j;\n            level_table[i] = level;\n            ++i;\n        }\n        ++level;\n    }\n    *prun_table = run_table;\n    *plevel_table = level_table;\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* this is called for each file to process */\n", "func_signal": "enum codec_status codec_run(void)", "code": "{\n    uint32_t decodedsamples;\n    size_t n;\n    int bufcount;\n    int endofstream;\n    uint8_t *voxbuf;\n    off_t firstblockposn = 0;     /* position of the first block in file */\n    const struct pcm_codec *codec;\n    intptr_t param;\n\n    if (codec_init()) {\n        DEBUGF(\"codec_init() error\\n\");\n        return CODEC_ERROR;\n    }\n\n    codec_set_replaygain(ci->id3);\n\n    /* Need to save offset for later use (cleared indirectly by advance_buffer) */\n    bytesdone = ci->id3->offset;\n    ci->seek_buffer(0);\n\n    ci->memset(&format, 0, sizeof(struct pcm_format));\n\n    /* set format */\n    format.channels      = 1;\n    format.bitspersample = 4;\n    format.numbytes      = ci->id3->filesize;\n    format.blockalign    = 1;\n\n    /* advance to first WAVE chunk */\n    firstblockposn = 0;\n    decodedsamples = 0;\n    ci->advance_buffer(firstblockposn);\n\n    /*\n     * get codec\n     * supports dialogic oki adpcm only\n     */\n    codec = get_dialogic_oki_adpcm_codec();\n    if (!codec)\n    {\n        DEBUGF(\"CODEC_ERROR: dialogic oki adpcm codec does not load.\\n\");\n        return CODEC_ERROR;\n    }\n\n    if (!codec->set_format(&format)) {\n        return CODEC_ERROR;\n    }\n\n    if (format.numbytes == 0) {\n        DEBUGF(\"CODEC_ERROR: data size is 0\\n\");\n        return CODEC_ERROR;\n    }\n\n    /* check chunksize */\n    if (format.chunksize * 2 > PCM_SAMPLE_SIZE)\n        format.chunksize = PCM_SAMPLE_SIZE / 2;\n    if (format.chunksize == 0)\n    {\n        DEBUGF(\"CODEC_ERROR: chunksize is 0\\n\");\n        return CODEC_ERROR;\n    }\n\n    ci->configure(DSP_SWITCH_FREQUENCY, ci->id3->frequency);\n    ci->configure(DSP_SET_STEREO_MODE, STEREO_MONO);\n\n    /* make sure we're at the correct offset */\n    if (bytesdone > (uint32_t) firstblockposn) {\n        /* Round down to previous block */\n        struct pcm_pos *newpos = codec->get_seek_pos(bytesdone - firstblockposn,\n                                                     PCM_SEEK_POS, &read_buffer);\n\n        if (newpos->pos > format.numbytes) {\n            return CODEC_OK;\n        }\n        if (ci->seek_buffer(firstblockposn + newpos->pos))\n        {\n            bytesdone      = newpos->pos;\n            decodedsamples = newpos->samples;\n        }\n    } else {\n        /* already where we need to be */\n        bytesdone = 0;\n    }\n\n    ci->set_elapsed(decodedsamples*1000LL/ci->id3->frequency);\n\n    /* The main decoder loop */\n    endofstream = 0;\n\n    while (!endofstream) {\n        enum codec_command_action action = ci->get_command(&param);\n\n        if (action == CODEC_ACTION_HALT)\n            break;\n\n        if (action == CODEC_ACTION_SEEK_TIME) {\n            struct pcm_pos *newpos = codec->get_seek_pos(param, PCM_SEEK_TIME,\n                                                         &read_buffer);\n\n            if (newpos->pos > format.numbytes)\n            {\n                ci->set_elapsed(ci->id3->length);\n                ci->seek_complete();\n                break;\n            }\n\n            if (ci->seek_buffer(firstblockposn + newpos->pos))\n            {\n                bytesdone      = newpos->pos;\n                decodedsamples = newpos->samples;\n            }\n\n            ci->set_elapsed(decodedsamples*1000LL/ci->id3->frequency);\n            ci->seek_complete();\n        }\n\n        voxbuf = (uint8_t *)ci->request_buffer(&n, format.chunksize);\n        if (n == 0)\n            break; /* End of stream */\n        if (bytesdone + n > format.numbytes) {\n            n = format.numbytes - bytesdone;\n            endofstream = 1;\n        }\n\n        if (codec->decode(voxbuf, n, samples, &bufcount) == CODEC_ERROR)\n        {\n            DEBUGF(\"codec error\\n\");\n            return CODEC_ERROR;\n        }\n\n        ci->pcmbuf_insert(samples, NULL, bufcount);\n        ci->advance_buffer(n);\n        bytesdone += n;\n        decodedsamples += bufcount;\n\n        if (bytesdone >= format.numbytes)\n            endofstream = 1;\n        ci->set_elapsed(decodedsamples*1000LL/ci->id3->frequency);\n    }\n\n    return CODEC_OK;\n}", "path": "apps\\codecs\\vox.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* ROCKBOX */\n", "func_signal": "static void netreceive_setup(void)", "code": "{\n    netreceive_class = class_new(gensym(\"netreceive\"),\n    \t(t_newmethod)netreceive_new, (t_method)netreceive_free,\n    \tsizeof(t_netreceive), CLASS_NOINLET, A_DEFFLOAT, A_DEFFLOAT, \n\t    A_DEFSYM, 0);\n}", "path": "apps\\plugins\\pdbox\\PDa\\src\\x_net.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* decode exponents coded with LSP coefficients (same idea as Vorbis)\n * only used for low bitrate (< 16kbps) files\n */\n", "func_signal": "static void decode_exp_lsp(WMADecodeContext *s, int ch)", "code": "{\n    fixed32 lsp_coefs[NB_LSP_COEFS];\n    int val, i;\n\n    for (i = 0; i < NB_LSP_COEFS; ++i)\n    {\n        if (i == 0 || i >= 8)\n            val = get_bits(&s->gb, 3);\n        else\n            val = get_bits(&s->gb, 4);\n        lsp_coefs[i] = lsp_codebook[i][val];\n    }\n\n    wma_lsp_to_curve(s,\n                     s->exponents[ch],\n                     &s->max_exponent[ch],\n                     s->block_len,\n                     lsp_coefs);\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* Blit a YUV bitmap directly to the LCD */\n", "func_signal": "void lcd_blit_yuv(unsigned char * const src[3],\n                  int src_x, int src_y, int stride,\n                  int x, int y, int width, int height)", "code": "{\n    unsigned int z;\n    unsigned char const * yuv_src[3];\n    \n    width = (width + 1) & ~1;       /* ensure width is even */\n\n    lcd_setup_drawing_region(x, y, width, height);\n\n    z = stride * src_y;\n    yuv_src[0] = src[0] + z + src_x;\n    yuv_src[1] = src[1] + (z >> 2) + (src_x >> 1);\n    yuv_src[2] = src[2] + (yuv_src[1] - src[1]);\n\n    height >>= 1;\n\n    do {\n        lcd_write_yuv420_lines(yuv_src, LCD_BASE, width, stride);\n        yuv_src[0] += stride << 1;\n        yuv_src[1] += stride >> 1; /* Skip down one chroma line */\n        yuv_src[2] += stride >> 1;\n    } while (--height > 0);\n}", "path": "firmware\\target\\arm\\s5l8700\\ipodnano2g\\lcd-nano2g.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* decode exponents coded with VLC codes - used for bitrate >= 32kbps*/\n", "func_signal": "static int decode_exp_vlc(WMADecodeContext *s, int ch)", "code": "{\n    int last_exp, n, code;\n    const uint16_t *ptr, *band_ptr;\n    fixed32 v, max_scale;\n    fixed32 *q,*q_end;\n\n    /*accommodate the 60 negative indices */\n    const fixed32 *pow_10_to_yover16_ptr = &pow_10_to_yover16[61];\n\n    band_ptr = s->exponent_bands[s->frame_len_bits - s->block_len_bits];\n    ptr = band_ptr;\n    q = s->exponents[ch];\n    q_end = q + s->block_len;\n    max_scale = 0;\n\n\n    if (s->version == 1)        //wmav1 only\n    {\n        last_exp = get_bits(&s->gb, 5) + 10;\n\n        v = pow_10_to_yover16_ptr[last_exp];\n        max_scale = v;\n        n = *ptr++;\n        switch (n & 3) do {\n            case 0: *q++ = v;\n            case 3: *q++ = v;\n            case 2: *q++ = v;\n            case 1: *q++ = v;\n        } while ((n -= 4) > 0);\n    } else {\n       last_exp = 36;\n    }\n\n    while (q < q_end)\n    {\n        code = get_vlc2(&s->gb, s->exp_vlc.table, EXPVLCBITS, EXPMAX);\n        if (code < 0)\n        {\n            return -1;\n        }\n        /* NOTE: this offset is the same as MPEG4 AAC ! */\n        last_exp += code - 60;\n\n        v = pow_10_to_yover16_ptr[last_exp];\n        if (v > max_scale)\n        {\n            max_scale = v;\n        }\n        n = *ptr++;\n        switch (n & 3) do {\n            case 0: *q++ = v;\n            case 3: *q++ = v;\n            case 2: *q++ = v;\n            case 1: *q++ = v;\n        } while ((n -= 4) > 0);\n    }\n\n    s->max_exponent[ch] = max_scale;\n    return 0;\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* HAVE_LCD_SLEEP */\n", "func_signal": "static inline void s5l_lcd_write_cmd_data(int cmd, int data)", "code": "{\n    while (LCD_STATUS & 0x10);\n    LCD_WCMD = cmd;\n\n    while (LCD_STATUS & 0x10);\n    LCD_WDATA = data;\n}", "path": "firmware\\target\\arm\\s5l8700\\ipodnano2g\\lcd-nano2g.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* return 0 if OK. return 1 if last block of frame. return -1 if\n   unrecorrable error. */\n", "func_signal": "static int wma_decode_block(WMADecodeContext *s)", "code": "{\n    int n, v, a, ch, code, bsize;\n    int coef_nb_bits, total_gain;\n    int nb_coefs[MAX_CHANNELS];\n    fixed32 mdct_norm;\n\n    /*DEBUGF(\"***decode_block: %d  (%d samples of %d in frame)\\n\",  s->block_num, s->block_len, s->frame_len);*/\n\n   /* compute current block length */\n    if (s->use_variable_block_len)\n    {\n        n = av_log2(s->nb_block_sizes - 1) + 1;\n\n        if (s->reset_block_lengths)\n        {\n            s->reset_block_lengths = 0;\n            v = get_bits(&s->gb, n);\n            if (v >= s->nb_block_sizes)\n            {\n                return -2;\n            }\n            s->prev_block_len_bits = s->frame_len_bits - v;\n            v = get_bits(&s->gb, n);\n            if (v >= s->nb_block_sizes)\n            {\n                return -3;\n            }\n            s->block_len_bits = s->frame_len_bits - v;\n        }\n        else\n        {\n            /* update block lengths */\n            s->prev_block_len_bits = s->block_len_bits;\n            s->block_len_bits = s->next_block_len_bits;\n        }\n        v = get_bits(&s->gb, n);\n\n        if (v >= s->nb_block_sizes)\n        {\n         // rb->splash(HZ*4, \"v was %d\", v);        //5, 7\n            return -4;        //this is it\n        }\n        else{\n              //rb->splash(HZ, \"passed v block (%d)!\", v);\n      }\n        s->next_block_len_bits = s->frame_len_bits - v;\n    }\n    else\n    {\n        /* fixed block len */\n        s->next_block_len_bits = s->frame_len_bits;\n        s->prev_block_len_bits = s->frame_len_bits;\n        s->block_len_bits = s->frame_len_bits;\n    }\n    /* now check if the block length is coherent with the frame length */\n    s->block_len = 1 << s->block_len_bits;\n\n    if ((s->block_pos + s->block_len) > s->frame_len)\n    {\n        return -5;  //oddly 32k sample from tracker fails here\n    }\n\n    if (s->nb_channels == 2)\n    {\n        s->ms_stereo = get_bits1(&s->gb);\n    }\n    v = 0;\n    for (ch = 0; ch < s->nb_channels; ++ch)\n    {\n        a = get_bits1(&s->gb);\n        s->channel_coded[ch] = a;\n        v |= a;\n    }\n    /* if no channel coded, no need to go further */\n    /* XXX: fix potential framing problems */\n    if (!v)\n    {\n        goto next;\n    }\n\n    bsize = s->frame_len_bits - s->block_len_bits;\n\n    /* read total gain and extract corresponding number of bits for\n       coef escape coding */\n    total_gain = 1;\n    for(;;)\n    {\n        a = get_bits(&s->gb, 7);\n        total_gain += a;\n        if (a != 127)\n        {\n            break;\n        }\n    }\n\n    if (total_gain < 15)\n        coef_nb_bits = 13;\n    else if (total_gain < 32)\n        coef_nb_bits = 12;\n    else if (total_gain < 40)\n        coef_nb_bits = 11;\n    else if (total_gain < 45)\n        coef_nb_bits = 10;\n    else\n        coef_nb_bits = 9;\n\n    /* compute number of coefficients */\n    n = s->coefs_end[bsize] - s->coefs_start;\n\n    for(ch = 0; ch < s->nb_channels; ++ch)\n    {\n        nb_coefs[ch] = n;\n    }\n    /* complex coding */\n    if (s->use_noise_coding)\n    {\n\n        for(ch = 0; ch < s->nb_channels; ++ch)\n        {\n            if (s->channel_coded[ch])\n            {\n                int i, n, a;\n                n = s->exponent_high_sizes[bsize];\n                for(i=0;i<n;++i)\n                {\n                    a = get_bits1(&s->gb);\n                    s->high_band_coded[ch][i] = a;\n                    /* if noise coding, the coefficients are not transmitted */\n                    if (a)\n                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];\n                }\n            }\n        }\n        for(ch = 0; ch < s->nb_channels; ++ch)\n        {\n            if (s->channel_coded[ch])\n            {\n                int i, n, val, code;\n\n                n = s->exponent_high_sizes[bsize];\n                val = (int)0x80000000;\n                for(i=0;i<n;++i)\n                {\n                    if (s->high_band_coded[ch][i])\n                    {\n                        if (val == (int)0x80000000)\n                        {\n                            val = get_bits(&s->gb, 7) - 19;\n                        }\n                        else\n                        {\n                            //code = get_vlc(&s->gb, &s->hgain_vlc);\n                            code = get_vlc2(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);\n                            if (code < 0)\n                            {\n                                return -6;\n                            }\n                            val += code - 18;\n                        }\n                        s->high_band_values[ch][i] = val;\n                    }\n                }\n            }\n        }\n    }\n\n    /* exponents can be reused in short blocks. */\n    if ((s->block_len_bits == s->frame_len_bits) || get_bits1(&s->gb))\n    {\n        for(ch = 0; ch < s->nb_channels; ++ch)\n        {\n            if (s->channel_coded[ch])\n            {\n                if (s->use_exp_vlc)\n                {\n                    if (decode_exp_vlc(s, ch) < 0)\n                    {\n                        return -7;\n                    }\n                }\n                else\n                {\n                    decode_exp_lsp(s, ch);\n                }\n                s->exponents_bsize[ch] = bsize;\n            }\n        }\n    }\n\n    /* parse spectral coefficients : just RLE encoding */\n    for(ch = 0; ch < s->nb_channels; ++ch)\n    {\n        if (s->channel_coded[ch])\n        {\n            VLC *coef_vlc;\n            int level, run, sign, tindex;\n            int16_t *ptr, *eptr;\n            const int16_t *level_table, *run_table;\n\n            /* special VLC tables are used for ms stereo because\n               there is potentially less energy there */\n            tindex = (ch == 1 && s->ms_stereo);\n            coef_vlc = &s->coef_vlc[tindex];\n            run_table = s->run_table[tindex];\n            level_table = s->level_table[tindex];\n            /* XXX: optimize */\n            ptr = &s->coefs1[ch][0];\n            eptr = ptr + nb_coefs[ch];\n            memset(ptr, 0, s->block_len * sizeof(int16_t));\n\n            for(;;)\n            {\n                code = get_vlc2(&s->gb, coef_vlc->table, VLCBITS, VLCMAX);\n\n                if (code < 0)\n                {\n                    return -8;\n                }\n                if (code == 1)\n                {\n                    /* EOB */\n                    break;\n                }\n                else if (code == 0)\n                {\n                    /* escape */\n                    level = get_bits(&s->gb, coef_nb_bits);\n                    /* NOTE: this is rather suboptimal. reading\n                       block_len_bits would be better */\n                    run = get_bits(&s->gb, s->frame_len_bits);\n                }\n                else\n                {\n                    /* normal code */\n                    run = run_table[code];\n                    level = level_table[code];\n                }\n                sign = get_bits1(&s->gb);\n                if (!sign)\n                    level = -level;\n                ptr += run;\n                if (ptr >= eptr)\n                {\n                    break;\n                }\n                *ptr++ = level;\n\n\n                /* NOTE: EOB can be omitted */\n                if (ptr >= eptr)\n                    break;\n            }\n        }\n        if (s->version == 1 && s->nb_channels >= 2)\n        {\n            align_get_bits(&s->gb);\n        }\n    }\n\n    {\n        int n4 = s->block_len >> 1;\n\n\n        mdct_norm = 0x10000>>(s->block_len_bits-1);\n\n        if (s->version == 1)\n        {\n             mdct_norm *= fixtoi32(fixsqrt32(itofix32(n4)));\n        }\n    }\n\n\n   /* finally compute the MDCT coefficients */\n    for(ch = 0; ch < s->nb_channels; ++ch)\n    {\n        if (s->channel_coded[ch])\n        {\n            int16_t *coefs1;\n            fixed32 *exponents;\n            fixed32 *coefs, atemp;\n            fixed64 mult;\n            fixed64 mult1;\n            fixed32 noise, temp1, temp2, mult2;\n            int i, j, n, n1, last_high_band, esize;\n            fixed32 exp_power[HIGH_BAND_MAX_SIZE];\n\n            //total_gain, coefs1, mdctnorm are lossless\n\n            coefs1 = s->coefs1[ch];\n            exponents = s->exponents[ch];\n            esize = s->exponents_bsize[ch];\n            coefs = (*(s->coefs))[ch];\n            n=0;\n\n          /*\n          *  The calculation of coefs has a shift right by 2 built in.  This\n          *  prepares samples for the Tremor IMDCT which uses a slightly\n          *  different fixed format then the ffmpeg one. If the old ffmpeg\n          *  imdct is used, each shift storing into coefs should be reduced\n          *  by 1.\n          *  See SVN logs for details.\n          */\n\n\n            if (s->use_noise_coding)\n            {   \n                /*This case is only used for low bitrates (typically less then 32kbps)*/\n                \n                /*TODO:  mult should be converted to 32 bit to speed up noise coding*/\n\n                mult = fixdiv64(pow_table[total_gain+20],Fixed32To64(s->max_exponent[ch]));\n                mult = mult* mdct_norm;\n                mult1 = mult;\n\n                /* very low freqs : noise */\n                for(i = 0;i < s->coefs_start; ++i)\n                {\n                    *coefs++ = fixmul32( (fixmul32(s->noise_table[s->noise_index],\n                            exponents[i<<bsize>>esize])>>4),Fixed32From64(mult1)) >>2;\n                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n                }\n\n                n1 = s->exponent_high_sizes[bsize];\n\n                /* compute power of high bands */\n                exponents = s->exponents[ch] +(s->high_band_start[bsize]<<bsize);\n                last_high_band = 0; /* avoid warning */\n                for (j=0;j<n1;++j)\n                {\n                    n = s->exponent_high_bands[s->frame_len_bits -\n                                               s->block_len_bits][j];\n                    if (s->high_band_coded[ch][j])\n                    {\n                        fixed32 e2, v;\n                        e2 = 0;\n                        for(i = 0;i < n; ++i)\n                        {\n                            /*v is normalized later on so its fixed format is irrelevant*/\n                            v = exponents[i<<bsize>>esize]>>4;\n                            e2 += fixmul32(v, v)>>3;\n                        }\n                         exp_power[j] = e2/n; /*n is an int...*/\n                        last_high_band = j;\n                    }\n                    exponents += n<<bsize;\n                }\n\n                /* main freqs and high freqs */\n                exponents = s->exponents[ch] + (s->coefs_start<<bsize);\n                for(j=-1;j<n1;++j)\n                {\n                    if (j < 0)\n                    {\n                        n = s->high_band_start[bsize] -\n                            s->coefs_start;\n                    }\n                    else\n                    {\n                        n = s->exponent_high_bands[s->frame_len_bits -\n                                                   s->block_len_bits][j];\n                    }\n                    if (j >= 0 && s->high_band_coded[ch][j])\n                    {\n                        /* use noise with specified power */\n                        fixed32 tmp = fixdiv32(exp_power[j],exp_power[last_high_band]);\n\n                        /*mult1 is 48.16, pow_table is 48.16*/\n                        mult1 = fixmul32(fixsqrt32(tmp),\n                                pow_table[s->high_band_values[ch][j]+20]) >> 16;\n\n                        /*this step has a fairly high degree of error for some reason*/\n                        mult1 = fixdiv64(mult1,fixmul32(s->max_exponent[ch],s->noise_mult));\n                        mult1 = mult1*mdct_norm>>PRECISION;\n                        for(i = 0;i < n; ++i)\n                        {\n                            noise = s->noise_table[s->noise_index];\n                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n                            *coefs++ = fixmul32((fixmul32(exponents[i<<bsize>>esize],noise)>>4),\n                                    Fixed32From64(mult1)) >>2;\n\n                        }\n                        exponents += n<<bsize;\n                    }\n                    else\n                    {\n                        /* coded values + small noise */\n                        for(i = 0;i < n; ++i)\n                        {\n                            noise = s->noise_table[s->noise_index];\n                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n\n                           /*don't forget to renormalize the noise*/\n                           temp1 = (((int32_t)*coefs1++)<<16) + (noise>>4);\n                           temp2 = fixmul32(exponents[i<<bsize>>esize], mult>>18);\n                           *coefs++ = fixmul32(temp1, temp2);\n                        }\n                        exponents += n<<bsize;\n                    }\n                }\n\n                /* very high freqs : noise */\n                n = s->block_len - s->coefs_end[bsize];\n                mult2 = fixmul32(mult>>16,exponents[((-1<<bsize))>>esize]) ;\n                for (i = 0; i < n; ++i)\n                {\n                    /*renormalize the noise product and then reduce to 14.18 precison*/\n                    *coefs++ = fixmul32(s->noise_table[s->noise_index],mult2) >>6;\n\n                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);\n                }\n            }\n            else\n            {\n                /*Noise coding not used, simply convert from exp to fixed representation*/\n\n                fixed32 mult3 = (fixed32)(fixdiv64(pow_table[total_gain+20],\n                        Fixed32To64(s->max_exponent[ch])));\n                mult3 = fixmul32(mult3, mdct_norm);\n\n                /*zero the first 3 coefficients for WMA V1, does nothing otherwise*/\n                for(i=0; i<s->coefs_start; i++)\n                    *coefs++=0;\n\n                n = nb_coefs[ch];\n\n                /* XXX: optimize more, unrolling this loop in asm\n                                might be a good idea */\n\n                for(i = 0;i < n; ++i)\n                {\n                    /*ffmpeg imdct needs 15.17, while tremor 14.18*/\n                    atemp = (coefs1[i] * mult3)>>2;\n                    *coefs++=fixmul32(atemp,exponents[i<<bsize>>esize]);\n                }\n                n = s->block_len - s->coefs_end[bsize];\n                memset(coefs, 0, n*sizeof(fixed32));\n            }\n        }\n    }\n\n\n\n    if (s->ms_stereo && s->channel_coded[1])\n    {\n        fixed32 a, b;\n        int i;\n        fixed32 (*coefs)[MAX_CHANNELS][BLOCK_MAX_SIZE]  = (s->coefs);\n\n        /* nominal case for ms stereo: we do it before mdct */\n        /* no need to optimize this case because it should almost\n           never happen */\n        if (!s->channel_coded[0])\n        {\n            memset((*(s->coefs))[0], 0, sizeof(fixed32) * s->block_len);\n            s->channel_coded[0] = 1;\n        }\n\n        for(i = 0; i < s->block_len; ++i)\n        {\n            a = (*coefs)[0][i];\n            b = (*coefs)[1][i];\n            (*coefs)[0][i] = a + b;\n            (*coefs)[1][i] = a - b;\n        }\n    }\n\n    for(ch = 0; ch < s->nb_channels; ++ch)\n    { \n        /* BLOCK_MAX_SIZE is 2048 (samples) and MAX_CHANNELS is 2. */\n        static uint32_t scratch_buf[BLOCK_MAX_SIZE * MAX_CHANNELS] IBSS_ATTR MEM_ALIGN_ATTR;\n        if (s->channel_coded[ch])\n        {\n            int n4, index;\n\n            n4 = s->block_len >>1;\n\n            ff_imdct_calc((s->frame_len_bits - bsize + 1),\n                          scratch_buf,\n                          (*(s->coefs))[ch]);\n\n            /* add in the frame */\n            index = (s->frame_len / 2) + s->block_pos - n4;\n            wma_window(s, scratch_buf, &((*s->frame_out)[ch][index]));\n\n\n\n            /* specific fast case for ms-stereo : add to second\n               channel if it is not coded */\n            if (s->ms_stereo && !s->channel_coded[1])\n            {\n                wma_window(s, scratch_buf, &((*s->frame_out)[1][index]));\n            }\n        }\n    }\nnext:\n    /* update block number */\n    ++s->block_num;\n    s->block_pos += s->block_len;\n    if (s->block_pos >= s->frame_len)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* NOTE: We use the same code as Vorbis here */\n/* XXX: optimize it further with SSE/3Dnow */\n", "func_signal": "static void wma_lsp_to_curve(WMADecodeContext *s,\n                             fixed32 *out,\n                             fixed32 *val_max_ptr,\n                             int n,\n                             fixed32 *lsp)", "code": "{\n    int i, j;\n    fixed32 p, q, w, v, val_max, temp2;\n\n    val_max = 0;\n    for(i=0;i<n;++i)\n    {\n        /* shift by 2 now to reduce rounding error,\n         * we can renormalize right before pow_m1_4\n         */\n\n        p = 0x8000<<5;\n        q = 0x8000<<5;\n        w = s->lsp_cos_table[i];\n\n        for (j=1;j<NB_LSP_COEFS;j+=2)\n        {\n            /* w is 5.27 format, lsp is in 16.16, temp2 becomes 5.27 format */\n            temp2 = ((w - (lsp[j - 1]<<11)));\n\n            /* q is 16.16 format, temp2 is 5.27, q becomes 16.16 */\n            q = fixmul32b(q, temp2 )<<4;\n            p = fixmul32b(p, (w - (lsp[j]<<11)))<<4;\n        }\n\n        /* 2 in 5.27 format is 0x10000000 */\n        p = fixmul32(p, fixmul32b(p, (0x10000000 - w)))<<3;\n        q = fixmul32(q, fixmul32b(q, (0x10000000 + w)))<<3;\n\n        v = (p + q) >>9;  /* p/q end up as 16.16 */\n        v = pow_m1_4(s, v);\n        if (v > val_max)\n            val_max = v;\n        out[i] = v;\n    }\n\n    *val_max_ptr = val_max;\n}", "path": "apps\\codecs\\libwma\\wmadeci.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* this is the codec entry point */\n", "func_signal": "enum codec_status codec_main(enum codec_entry_call_reason reason)", "code": "{\n    if (reason == CODEC_LOAD) {\n        /* Generic codec initialisation */\n        ci->configure(DSP_SET_SAMPLE_DEPTH, PCM_OUTPUT_DEPTH-1);\n    }\n\n    return CODEC_OK;\n}", "path": "apps\\codecs\\vox.c", "repo_name": "pamaury/rockbox", "stars": 17, "license": "None", "language": "c", "size": 129427}
{"docstring": "/* extracts device info from CF dictionary records in IO registry */\n", "func_signal": "static void\nHIDGetDeviceInfo(io_object_t hidDevice, CFMutableDictionaryRef hidProperties,\n                 recDevice * pDevice)", "code": "{\n    CFMutableDictionaryRef usbProperties = 0;\n    io_registry_entry_t parent1, parent2;\n\n    /* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also\n     * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties\n     */\n    if ((KERN_SUCCESS ==\n         IORegistryEntryGetParentEntry(hidDevice, kIOServicePlane, &parent1))\n        && (KERN_SUCCESS ==\n            IORegistryEntryGetParentEntry(parent1, kIOServicePlane, &parent2))\n        && (KERN_SUCCESS ==\n            IORegistryEntryCreateCFProperties(parent2, &usbProperties,\n                                              kCFAllocatorDefault,\n                                              kNilOptions))) {\n        if (usbProperties) {\n            CFTypeRef refCF = 0;\n            /* get device info\n             * try hid dictionary first, if fail then go to usb dictionary\n             */\n\n\n            /* get product name */\n            refCF =\n                CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDProductKey));\n            if (!refCF)\n                refCF =\n                    CFDictionaryGetValue(usbProperties,\n                                         CFSTR(\"USB Product Name\"));\n            if (refCF) {\n                if (!CFStringGetCString\n                    (refCF, pDevice->product, 256,\n                     CFStringGetSystemEncoding()))\n                    SDL_SetError\n                        (\"CFStringGetCString error retrieving pDevice->product.\");\n            }\n\n            /* get usage page and usage */\n            refCF =\n                CFDictionaryGetValue(hidProperties,\n                                     CFSTR(kIOHIDPrimaryUsagePageKey));\n            if (refCF) {\n                if (!CFNumberGetValue\n                    (refCF, kCFNumberLongType, &pDevice->usagePage))\n                    SDL_SetError\n                        (\"CFNumberGetValue error retrieving pDevice->usagePage.\");\n                refCF =\n                    CFDictionaryGetValue(hidProperties,\n                                         CFSTR(kIOHIDPrimaryUsageKey));\n                if (refCF)\n                    if (!CFNumberGetValue\n                        (refCF, kCFNumberLongType, &pDevice->usage))\n                        SDL_SetError\n                            (\"CFNumberGetValue error retrieving pDevice->usage.\");\n            }\n\n            if (NULL == refCF) {        /* get top level element HID usage page or usage */\n                /* use top level element instead */\n                CFTypeRef refCFTopElement = 0;\n                refCFTopElement =\n                    CFDictionaryGetValue(hidProperties,\n                                         CFSTR(kIOHIDElementKey));\n                {\n                    /* refCFTopElement points to an array of element dictionaries */\n                    CFRange range = { 0, CFArrayGetCount(refCFTopElement) };\n                    CFArrayApplyFunction(refCFTopElement, range,\n                                         HIDTopLevelElementHandler, pDevice);\n                }\n            }\n\n            CFRelease(usbProperties);\n        } else\n            SDL_SetError\n                (\"IORegistryEntryCreateCFProperties failed to create usbProperties.\");\n\n        if (kIOReturnSuccess != IOObjectRelease(parent2))\n            SDL_SetError(\"IOObjectRelease error with parent2.\");\n        if (kIOReturnSuccess != IOObjectRelease(parent1))\n            SDL_SetError(\"IOObjectRelease error with parent1.\");\n    }\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* extracts actual specific element information from each element CF dictionary entry */\n", "func_signal": "static void\nHIDGetElementInfo(CFTypeRef refElement, recElement * pElement)", "code": "{\n    long number;\n    CFTypeRef refType;\n\n    refType = CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementCookieKey));\n    if (refType && CFNumberGetValue(refType, kCFNumberLongType, &number))\n        pElement->cookie = (IOHIDElementCookie) number;\n    refType = CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementMinKey));\n    if (refType && CFNumberGetValue(refType, kCFNumberLongType, &number))\n        pElement->minReport = pElement->min = number;\n    pElement->maxReport = pElement->min;\n    refType = CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementMaxKey));\n    if (refType && CFNumberGetValue(refType, kCFNumberLongType, &number))\n        pElement->maxReport = pElement->max = number;\n/*\n\tTODO: maybe should handle the following stuff somehow?\n\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMinKey));\n\tif (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))\n\t\tpElement->scaledMin = number;\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMaxKey));\n\tif (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))\n\t\tpElement->scaledMax = number;\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementSizeKey));\n\tif (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))\n\t\tpElement->size = number;\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsRelativeKey));\n\tif (refType)\n\t\tpElement->relative = CFBooleanGetValue (refType);\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsWrappingKey));\n\tif (refType)\n\t\tpElement->wrapping = CFBooleanGetValue (refType);\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsNonLinearKey));\n\tif (refType)\n\t\tpElement->nonLinear = CFBooleanGetValue (refType);\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasPreferedStateKey));\n\tif (refType)\n\t\tpElement->preferredState = CFBooleanGetValue (refType);\n\trefType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasNullStateKey));\n\tif (refType)\n\t\tpElement->nullState = CFBooleanGetValue (refType);\n*/\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/*****************************************************************************/\n/* SDL Video and Display initialization/handling functions                   */\n/*****************************************************************************/\n", "func_signal": "int\nPND_videoinit(_THIS)", "code": "{\n    SDL_VideoDisplay display;\n    SDL_DisplayMode current_mode;\n\n    SDL_zero(current_mode);\n#ifdef WIZ_GLES_LITE\n    current_mode.w = 320;\n    current_mode.h = 240;\n#else\n    current_mode.w = 800;\n    current_mode.h = 480;\n#endif\n    current_mode.refresh_rate = 60;\n    current_mode.format = SDL_PIXELFORMAT_RGB565;\n    current_mode.driverdata = NULL;\n\n    SDL_zero(display);\n    display.desktop_mode = current_mode;\n    display.current_mode = current_mode;\n    display.driverdata = NULL;\n\n    SDL_AddVideoDisplay(&display);\n\n    return 1;\n}", "path": "src\\video\\pandora\\SDL_pandora.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* disposes of a single device, closing and releaseing interface, freeing memory fro device and elements, setting device pointer to NULL\n * all your device no longer belong to us... (i.e., you do not 'own' the device anymore)\n */\n", "func_signal": "static recDevice *\nHIDDisposeDevice(recDevice ** ppDevice)", "code": "{\n    kern_return_t result = KERN_SUCCESS;\n    recDevice *pDeviceNext = NULL;\n    if (*ppDevice) {\n        /* save next device prior to disposing of this device */\n        pDeviceNext = (*ppDevice)->pNext;\n\n        /* free posible io_service_t */\n        if ((*ppDevice)->ffservice) {\n            IOObjectRelease((*ppDevice)->ffservice);\n            (*ppDevice)->ffservice = 0;\n        }\n\n        /* free element lists */\n        HIDDisposeElementList(&(*ppDevice)->firstAxis);\n        HIDDisposeElementList(&(*ppDevice)->firstButton);\n        HIDDisposeElementList(&(*ppDevice)->firstHat);\n\n        result = HIDCloseReleaseInterface(*ppDevice);   /* function sanity checks interface value (now application does not own device) */\n        if (kIOReturnSuccess != result)\n            HIDReportErrorNum\n                (\"HIDCloseReleaseInterface failed when trying to dipose device.\",\n                 result);\n        DisposePtr((Ptr) * ppDevice);\n        *ppDevice = NULL;\n    }\n    return pDeviceNext;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\n", "func_signal": "static void\nquit(int rc)", "code": "{\n    CommonQuit(state);\n    exit(rc);\n}", "path": "test\\testscale.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* handles extracting element information from element collection CF types\n * used from top level element decoding and hierarchy deconstruction to flatten device element list\n */\n", "func_signal": "static void\nHIDGetCollectionElements(CFMutableDictionaryRef deviceProperties,\n                         recDevice * pDevice)", "code": "{\n    CFTypeRef refElementTop =\n        CFDictionaryGetValue(deviceProperties, CFSTR(kIOHIDElementKey));\n    if (refElementTop)\n        HIDGetElements(refElementTop, pDevice);\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* use top level element usage page and usage to discern device usage page and usage setting appropriate vlaues in device record */\n", "func_signal": "static void\nHIDTopLevelElementHandler(const void *value, void *parameter)", "code": "{\n    CFTypeRef refCF = 0;\n    if (CFGetTypeID(value) != CFDictionaryGetTypeID())\n        return;\n    refCF = CFDictionaryGetValue(value, CFSTR(kIOHIDElementUsagePageKey));\n    if (!CFNumberGetValue\n        (refCF, kCFNumberLongType, &((recDevice *) parameter)->usagePage))\n        SDL_SetError(\"CFNumberGetValue error retrieving pDevice->usagePage.\");\n    refCF = CFDictionaryGetValue(value, CFSTR(kIOHIDElementUsageKey));\n    if (!CFNumberGetValue\n        (refCF, kCFNumberLongType, &((recDevice *) parameter)->usage))\n        SDL_SetError(\"CFNumberGetValue error retrieving pDevice->usage.\");\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* examines CF dictionary vlaue in device element hierarchy to determine if it is element of interest or a collection of more elements\n * if element of interest allocate storage, add to list and retrieve element specific info\n * if collection then pass on to deconstruction collection into additional individual elements\n */\n", "func_signal": "static void\nHIDAddElement(CFTypeRef refElement, recDevice * pDevice)", "code": "{\n    recElement *element = NULL;\n    recElement **headElement = NULL;\n    long elementType, usagePage, usage;\n    CFTypeRef refElementType =\n        CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementTypeKey));\n    CFTypeRef refUsagePage =\n        CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementUsagePageKey));\n    CFTypeRef refUsage =\n        CFDictionaryGetValue(refElement, CFSTR(kIOHIDElementUsageKey));\n\n\n    if ((refElementType)\n        &&\n        (CFNumberGetValue(refElementType, kCFNumberLongType, &elementType))) {\n        /* look at types of interest */\n        if ((elementType == kIOHIDElementTypeInput_Misc)\n            || (elementType == kIOHIDElementTypeInput_Button)\n            || (elementType == kIOHIDElementTypeInput_Axis)) {\n            if (refUsagePage\n                && CFNumberGetValue(refUsagePage, kCFNumberLongType,\n                                    &usagePage) && refUsage\n                && CFNumberGetValue(refUsage, kCFNumberLongType, &usage)) {\n                switch (usagePage) {    /* only interested in kHIDPage_GenericDesktop and kHIDPage_Button */\n                case kHIDPage_GenericDesktop:\n                    {\n                        switch (usage) {        /* look at usage to determine function */\n                        case kHIDUsage_GD_X:\n                        case kHIDUsage_GD_Y:\n                        case kHIDUsage_GD_Z:\n                        case kHIDUsage_GD_Rx:\n                        case kHIDUsage_GD_Ry:\n                        case kHIDUsage_GD_Rz:\n                        case kHIDUsage_GD_Slider:\n                        case kHIDUsage_GD_Dial:\n                        case kHIDUsage_GD_Wheel:\n                            element = (recElement *)\n                                NewPtrClear(sizeof(recElement));\n                            if (element) {\n                                pDevice->axes++;\n                                headElement = &(pDevice->firstAxis);\n                            }\n                            break;\n                        case kHIDUsage_GD_Hatswitch:\n                            element = (recElement *)\n                                NewPtrClear(sizeof(recElement));\n                            if (element) {\n                                pDevice->hats++;\n                                headElement = &(pDevice->firstHat);\n                            }\n                            break;\n                        }\n                    }\n                    break;\n                case kHIDPage_Button:\n                    element = (recElement *)\n                        NewPtrClear(sizeof(recElement));\n                    if (element) {\n                        pDevice->buttons++;\n                        headElement = &(pDevice->firstButton);\n                    }\n                    break;\n                default:\n                    break;\n                }\n            }\n        } else if (kIOHIDElementTypeCollection == elementType)\n            HIDGetCollectionElements((CFMutableDictionaryRef) refElement,\n                                     pDevice);\n    }\n\n    if (element && headElement) {       /* add to list */\n        recElement *elementPrevious = NULL;\n        recElement *elementCurrent = *headElement;\n        while (elementCurrent && usage >= elementCurrent->usage) {\n            elementPrevious = elementCurrent;\n            elementCurrent = elementCurrent->pNext;\n        }\n        if (elementPrevious) {\n            elementPrevious->pNext = element;\n        } else {\n            *headElement = element;\n        }\n        element->usagePage = usagePage;\n        element->usage = usage;\n        element->pNext = elementCurrent;\n        HIDGetElementInfo(refElement, element);\n        pDevice->elements++;\n    }\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* collects information from each array member in device element list (each array memeber = element) */\n", "func_signal": "static void\nHIDGetElementsCFArrayHandler(const void *value, void *parameter)", "code": "{\n    if (CFGetTypeID(value) == CFDictionaryGetTypeID())\n        HIDAddElement((CFTypeRef) value, (recDevice *) parameter);\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Function to perform any system-specific joystick related cleanup */\n", "func_signal": "void\nSDL_SYS_JoystickQuit(void)", "code": "{\n    while (NULL != gpDeviceList)\n        gpDeviceList = HIDDisposeDevice(&gpDeviceList);\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* handles retrieval of element information from arrays of elements in device IO registry information */\n", "func_signal": "static void\nHIDGetElements(CFTypeRef refElementCurrent, recDevice * pDevice)", "code": "{\n    CFTypeID type = CFGetTypeID(refElementCurrent);\n    if (type == CFArrayGetTypeID()) {   /* if element is an array */\n        CFRange range = { 0, CFArrayGetCount(refElementCurrent) };\n        /* CountElementsCFArrayHandler called for each array member */\n        CFArrayApplyFunction(refElementCurrent, range,\n                             HIDGetElementsCFArrayHandler, pDevice);\n    }\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Function to get the device-dependent name of a joystick */\n", "func_signal": "const char *\nSDL_SYS_JoystickName(int index)", "code": "{\n    recDevice *device = gpDeviceList;\n\n    for (; index > 0; index--)\n        device = device->pNext;\n\n    return device->product;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/*****************************************************************************/\n/* SDL OpenGL/OpenGL ES functions                                            */\n/*****************************************************************************/\n", "func_signal": "int\nPND_gl_loadlibrary(_THIS, const char *path)", "code": "{\n    SDL_VideoData *phdata = (SDL_VideoData *) _this->driverdata;\n\n    /* Check if OpenGL ES library is specified for GF driver */\n    if (path == NULL) {\n        path = SDL_getenv(\"SDL_OPENGL_LIBRARY\");\n        if (path == NULL) {\n            path = SDL_getenv(\"SDL_OPENGLES_LIBRARY\");\n        }\n    }\n\n    /* Check if default library loading requested */\n    if (path == NULL) {\n        /* Already linked with GF library which provides egl* subset of  */\n        /* functions, use Common profile of OpenGL ES library by default */\n#ifdef WIZ_GLES_LITE\n\tpath = \"/lib/libopengles_lite.so\";\n#else\n        path = \"/usr/lib/libGLES_CM.so\";\n#endif\n    }\n\n    /* Load dynamic library */\n    _this->gl_config.dll_handle = SDL_LoadObject(path);\n    if (!_this->gl_config.dll_handle) {\n        /* Failed to load new GL ES library */\n        SDL_SetError(\"PND: Failed to locate OpenGL ES library\");\n        return -1;\n    }\n\n    /* Store OpenGL ES library path and name */\n    SDL_strlcpy(_this->gl_config.driver_path, path,\n                SDL_arraysize(_this->gl_config.driver_path));\n\n    /* New OpenGL ES library is loaded */\n    return 0;\n}", "path": "src\\video\\pandora\\SDL_pandora.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* disposes of the element list associated with a device and the memory associated with the list\n */\n", "func_signal": "static void\nHIDDisposeElementList(recElement ** elementList)", "code": "{\n    recElement *pElement = *elementList;\n    while (pElement) {\n        recElement *pElementNext = pElement->pNext;\n        DisposePtr((Ptr) pElement);\n        pElement = pElementNext;\n    }\n    *elementList = NULL;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* returns current value for element, polling element\n * will return 0 on error conditions which should be accounted for by application\n */\n", "func_signal": "static SInt32\nHIDGetElementValue(recDevice * pDevice, recElement * pElement)", "code": "{\n    IOReturn result = kIOReturnSuccess;\n    IOHIDEventStruct hidEvent;\n    hidEvent.value = 0;\n\n    if (NULL != pDevice && NULL != pElement && NULL != pDevice->interface) {\n        result =\n            (*(pDevice->interface))->getElementValue(pDevice->interface,\n                                                     pElement->cookie,\n                                                     &hidEvent);\n        if (kIOReturnSuccess == result) {\n            /* record min and max for auto calibration */\n            if (hidEvent.value < pElement->minReport)\n                pElement->minReport = hidEvent.value;\n            if (hidEvent.value > pElement->maxReport)\n                pElement->maxReport = hidEvent.value;\n        }\n    }\n\n    /* auto user scale */\n    return hidEvent.value;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/*****************************************************************************/\n/* SDL Window Manager function                                               */\n/*****************************************************************************/\n", "func_signal": "SDL_bool\nPND_getwindowwminfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo *info)", "code": "{\n    if (info->version.major <= SDL_MAJOR_VERSION) {\n        return SDL_TRUE;\n    } else {\n        SDL_SetError(\"application not compiled with SDL %d.%d\\n\",\n                     SDL_MAJOR_VERSION, SDL_MINOR_VERSION);\n        return SDL_FALSE;\n    }\n\n    /* Failed to get window manager information */\n    return SDL_FALSE;\n}", "path": "src\\video\\pandora\\SDL_pandora.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Function to scan the system for joysticks.\n * Joystick 0 should be the system default joystick.\n * This function should return the number of available joysticks, or -1\n * on an unrecoverable fatal error.\n */\n", "func_signal": "int\nSDL_SYS_JoystickInit(void)", "code": "{\n    IOReturn result = kIOReturnSuccess;\n    mach_port_t masterPort = 0;\n    io_iterator_t hidObjectIterator = 0;\n    CFMutableDictionaryRef hidMatchDictionary = NULL;\n    recDevice *device, *lastDevice;\n    io_object_t ioHIDDeviceObject = 0;\n\n    SDL_numjoysticks = 0;\n\n    if (gpDeviceList) {\n        SDL_SetError(\"Joystick: Device list already inited.\");\n        return -1;\n    }\n\n    result = IOMasterPort(bootstrap_port, &masterPort);\n    if (kIOReturnSuccess != result) {\n        SDL_SetError(\"Joystick: IOMasterPort error with bootstrap_port.\");\n        return -1;\n    }\n\n    /* Set up a matching dictionary to search I/O Registry by class name for all HID class devices. */\n    hidMatchDictionary = IOServiceMatching(kIOHIDDeviceKey);\n    if (hidMatchDictionary) {\n        /* Add key for device type (joystick, in this case) to refine the matching dictionary. */\n\n        /* NOTE: we now perform this filtering later\n           UInt32 usagePage = kHIDPage_GenericDesktop;\n           UInt32 usage = kHIDUsage_GD_Joystick;\n           CFNumberRef refUsage = NULL, refUsagePage = NULL;\n\n           refUsage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &usage);\n           CFDictionarySetValue (hidMatchDictionary, CFSTR (kIOHIDPrimaryUsageKey), refUsage);\n           refUsagePage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &usagePage);\n           CFDictionarySetValue (hidMatchDictionary, CFSTR (kIOHIDPrimaryUsagePageKey), refUsagePage);\n         */\n    } else {\n        SDL_SetError\n            (\"Joystick: Failed to get HID CFMutableDictionaryRef via IOServiceMatching.\");\n        return -1;\n    }\n\n    /*/ Now search I/O Registry for matching devices. */\n    result =\n        IOServiceGetMatchingServices(masterPort, hidMatchDictionary,\n                                     &hidObjectIterator);\n    /* Check for errors */\n    if (kIOReturnSuccess != result) {\n        SDL_SetError(\"Joystick: Couldn't create a HID object iterator.\");\n        return -1;\n    }\n    if (!hidObjectIterator) {   /* there are no joysticks */\n        gpDeviceList = NULL;\n        SDL_numjoysticks = 0;\n        return 0;\n    }\n    /* IOServiceGetMatchingServices consumes a reference to the dictionary, so we don't need to release the dictionary ref. */\n\n    /* build flat linked list of devices from device iterator */\n\n    gpDeviceList = lastDevice = NULL;\n\n    while ((ioHIDDeviceObject = IOIteratorNext(hidObjectIterator))) {\n        /* build a device record */\n        device = HIDBuildDevice(ioHIDDeviceObject);\n        if (!device)\n            continue;\n\n        /* Filter device list to non-keyboard/mouse stuff */\n        if ((device->usagePage != kHIDPage_GenericDesktop) ||\n            ((device->usage != kHIDUsage_GD_Joystick &&\n              device->usage != kHIDUsage_GD_GamePad &&\n              device->usage != kHIDUsage_GD_MultiAxisController))) {\n\n            /* release memory for the device */\n            HIDDisposeDevice(&device);\n            DisposePtr((Ptr) device);\n            continue;\n        }\n\n        /* We have to do some storage of the io_service_t for\n         * SDL_HapticOpenFromJoystick */\n        if (FFIsForceFeedback(ioHIDDeviceObject) == FF_OK) {\n            device->ffservice = ioHIDDeviceObject;\n        } else {\n            device->ffservice = 0;\n        }\n\n        /* Add device to the end of the list */\n        if (lastDevice)\n            lastDevice->pNext = device;\n        else\n            gpDeviceList = device;\n        lastDevice = device;\n    }\n    result = IOObjectRelease(hidObjectIterator);        /* release the iterator */\n\n    /* Count the total number of devices we found */\n    device = gpDeviceList;\n    while (device) {\n        SDL_numjoysticks++;\n        device = device->pNext;\n    }\n\n    return SDL_numjoysticks;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Closes and releases interface to device, should be done prior to exting application\n * Note: will have no affect if device or interface do not exist\n * application will \"own\" the device if interface is not closed\n * (device may have to be plug and re-plugged in different location to get it working again without a restart)\n */\n", "func_signal": "static IOReturn\nHIDCloseReleaseInterface(recDevice * pDevice)", "code": "{\n    IOReturn result = kIOReturnSuccess;\n\n    if ((NULL != pDevice) && (NULL != pDevice->interface)) {\n        /* close the interface */\n        result = (*(pDevice->interface))->close(pDevice->interface);\n        if (kIOReturnNotOpen == result) {\n            /* do nothing as device was not opened, thus can't be closed */\n        } else if (kIOReturnSuccess != result)\n            HIDReportErrorNum(\"Failed to close IOHIDDeviceInterface.\",\n                              result);\n        /* release the interface */\n        result = (*(pDevice->interface))->Release(pDevice->interface);\n        if (kIOReturnSuccess != result)\n            HIDReportErrorNum(\"Failed to release IOHIDDeviceInterface.\",\n                              result);\n        pDevice->interface = NULL;\n    }\n    return result;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Function to open a joystick for use.\n * The joystick to open is specified by the index field of the joystick.\n * This should fill the nbuttons and naxes fields of the joystick structure.\n * It returns 0, or -1 if there is an error.\n */\n", "func_signal": "int\nSDL_SYS_JoystickOpen(SDL_Joystick * joystick)", "code": "{\n    recDevice *device = gpDeviceList;\n    int index;\n\n    for (index = joystick->index; index > 0; index--)\n        device = device->pNext;\n\n    joystick->hwdata = device;\n    joystick->name = device->product;\n\n    joystick->naxes = device->axes;\n    joystick->nhats = device->hats;\n    joystick->nballs = 0;\n    joystick->nbuttons = device->buttons;\n\n    return 0;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/* Function to update the state of a joystick - called as a device poll.\n * This function shouldn't update the joystick structure directly,\n * but instead should call SDL_PrivateJoystick*() to deliver events\n * and update joystick device state.\n */\n", "func_signal": "void\nSDL_SYS_JoystickUpdate(SDL_Joystick * joystick)", "code": "{\n    recDevice *device = joystick->hwdata;\n    recElement *element;\n    SInt32 value, range;\n    int i;\n\n    if (device->removed) {      /* device was unplugged; ignore it. */\n        if (device->uncentered) {\n            device->uncentered = 0;\n\n            /* Tell the app that everything is centered/unpressed... */\n            for (i = 0; i < device->axes; i++)\n                SDL_PrivateJoystickAxis(joystick, i, 0);\n\n            for (i = 0; i < device->buttons; i++)\n                SDL_PrivateJoystickButton(joystick, i, 0);\n\n            for (i = 0; i < device->hats; i++)\n                SDL_PrivateJoystickHat(joystick, i, SDL_HAT_CENTERED);\n        }\n\n        return;\n    }\n\n    element = device->firstAxis;\n    i = 0;\n    while (element) {\n        value = HIDScaledCalibratedValue(device, element, -32768, 32767);\n        if (value != joystick->axes[i])\n            SDL_PrivateJoystickAxis(joystick, i, value);\n        element = element->pNext;\n        ++i;\n    }\n\n    element = device->firstButton;\n    i = 0;\n    while (element) {\n        value = HIDGetElementValue(device, element);\n        if (value > 1)          /* handle pressure-sensitive buttons */\n            value = 1;\n        if (value != joystick->buttons[i])\n            SDL_PrivateJoystickButton(joystick, i, value);\n        element = element->pNext;\n        ++i;\n    }\n\n    element = device->firstHat;\n    i = 0;\n    while (element) {\n        Uint8 pos = 0;\n\n        range = (element->max - element->min + 1);\n        value = HIDGetElementValue(device, element) - element->min;\n        if (range == 4)         /* 4 position hatswitch - scale up value */\n            value *= 2;\n        else if (range != 8)    /* Neither a 4 nor 8 positions - fall back to default position (centered) */\n            value = -1;\n        switch (value) {\n        case 0:\n            pos = SDL_HAT_UP;\n            break;\n        case 1:\n            pos = SDL_HAT_RIGHTUP;\n            break;\n        case 2:\n            pos = SDL_HAT_RIGHT;\n            break;\n        case 3:\n            pos = SDL_HAT_RIGHTDOWN;\n            break;\n        case 4:\n            pos = SDL_HAT_DOWN;\n            break;\n        case 5:\n            pos = SDL_HAT_LEFTDOWN;\n            break;\n        case 6:\n            pos = SDL_HAT_LEFT;\n            break;\n        case 7:\n            pos = SDL_HAT_LEFTUP;\n            break;\n        default:\n            /* Every other value is mapped to center. We do that because some\n             * joysticks use 8 and some 15 for this value, and apparently\n             * there are even more variants out there - so we try to be generous.\n             */\n            pos = SDL_HAT_CENTERED;\n            break;\n        }\n        if (pos != joystick->hats[i])\n            SDL_PrivateJoystickHat(joystick, i, pos);\n        element = element->pNext;\n        ++i;\n    }\n\n    return;\n}", "path": "src\\joystick\\darwin\\SDL_sysjoystick.c", "repo_name": "dhewg/libsdl", "stars": 22, "license": "other", "language": "c", "size": 46345}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int end_button_callback (SsdWidget widget, const char *new_value)", "code": "{\n\n   set_first_time_no();\n   ssd_dialog_hide_all (dec_ok);\n\n   return 1;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//TOUCH_SCREEN\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int on_skip_workaddress(SsdWidget widget, const char *new_value, void *context)", "code": "{\n   welcome_wizard_twitter_dialog();\n   return 0;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//////////////////////////////////////////////////////////////\n", "func_signal": "static void on_dialog_closed_terms_of_use( int exit_code, void* context)", "code": "{\n#ifdef TOUCH_SCREEN\n   roadmap_bottom_bar_show();\n#endif\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//TOUCH_SCREEN\n", "func_signal": "static void on_dialog_closed( int exit_code, void* context)", "code": "{\n#ifdef TOUCH_SCREEN\n   roadmap_bottom_bar_show();\n#endif\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int on_list_item_selected_work(SsdWidget widget, const char *new_value, const void *value)", "code": "{\n   RoadMapPosition position;\n   BOOL success;\n\n   int               selected_list_item   = get_selected_list_item();\n   const address_candidate*\n                     selection            = generic_search_results( selected_list_item);\n\n   position.latitude =   (int)selection->latitude*1000000;\n   position.longitude =   (int)selection->longtitude*1000000;\n   success = Realtime_TripServer_CreatePOI(roadmap_lang_get(\"Work\"), &position, TRUE);\n   if (success){\n      roadmap_history_declare ('F', 7);\n         add_address_to_history( ADDRESS_FAVORITE_CATEGORY,\n                           selection->city,\n                           selection->street,\n                           get_house_number__str( selection->house),\n                           ADDRESS_HISTORY_STATE,\n                           roadmap_lang_get(\"Work\"),\n                           &position);\n   }\n   welcome_wizard_twitter_dialog();\n   return 0;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "void roadmap_welcome_wizard(void)", "code": "{\n\n   if (!is_wizard_enabled())\n      return;\n\n   if (!is_first_time())\n      return;\n\n   if (!Realtime_is_random_user())\n      return;\n\n   if (!is_activation_time_reached())\n      return;\n\n   gLoginCallBack = Realtime_NotifyOnLogin (welcome_dialog);\n\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n// Work address\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static void workaddress_dialog()", "code": "{\n   SsdWidget dialog;\n   SsdWidget group;\n   SsdWidget text, edit_con, edit, bitmap;\n   int txt_box_height = 40;\n#ifndef TOUCH_SCREEN\n   txt_box_height = 23;\n#endif\n\n   dialog = ssd_dialog_new (\"Work_Addresse\",\n                      roadmap_lang_get (\"Work address 3/4\"),\n                      NULL,\n                      SSD_CONTAINER_TITLE|SSD_DIALOG_NO_SCROLL);\n\n   ssd_widget_add (dialog, space(5));\n\n   group = ssd_container_new (\"work_con\", NULL,\n                        SSD_MAX_SIZE,SSD_MAX_SIZE,SSD_WIDGET_SPACE|SSD_END_ROW|SSD_ALIGN_VCENTER);\n   ssd_widget_set_color (group, NULL,NULL);\n\n   text = ssd_text_new (\"Label\", roadmap_lang_get(\"Enter your work address\"), 18,SSD_END_ROW|SSD_TEXT_LABEL);\n   ssd_widget_add (group, text);\n\n   ssd_widget_add (group, space(10));\n\n   edit_con = ssd_container_new (\"Edit_con\", NULL,\n                        SSD_MAX_SIZE,txt_box_height,SSD_WS_TABSTOP|SSD_END_ROW|SSD_CONTAINER_TXT_BOX);\n   ssd_widget_set_color (edit_con, \"#ffffff\",\"#ffffff\");\n\n   bitmap = ssd_bitmap_new(\"serach\", \"search_icon\", SSD_ALIGN_VCENTER);\n   ssd_widget_add(edit_con, bitmap);\n\n   edit = ssd_text_new     ( \"Work\",\"\", 18, SSD_ALIGN_VCENTER);\n   ssd_text_set_input_type( edit, inputtype_free_text);\n   ssd_text_set_readonly  ( edit, FALSE);\n\n   edit_con->key_pressed = workaddress_on_key_pressed_delegate_to_editbox;\n   ssd_widget_add(edit_con, edit);\n   ssd_widget_add(edit_con, ssd_bitmap_new(\"cursor\", \"cursor\",SSD_ALIGN_VCENTER));\n   ssd_widget_add (group, edit_con);\n\n   ssd_widget_add (group, space(20));\n\n#ifdef TOUCH_SCREEN\n   ssd_widget_add (group,\n   ssd_button_label (\"Search\", roadmap_lang_get (\"Search\"),\n                        SSD_WS_TABSTOP|SSD_ALIGN_CENTER|SSD_START_NEW_ROW, workaddress_button_callback));\n\n   ssd_widget_add (group,\n   ssd_button_label (\"Skip\", roadmap_lang_get (\"Skip\"),\n                        SSD_WS_TABSTOP|SSD_ALIGN_CENTER|SSD_END_ROW, workaddress_button_callback));\n   ssd_widget_add (group, space(10));\n\n   if ( roadmap_native_keyboard_enabled() )\n   {\n\t   ssd_dialog_set_ntv_keyboard_action( dialog->name, _ntv_kb_action_show );\n\t   ssd_dialog_set_ntv_keyboard_params( dialog->name, &s_gNativeKBParams );\n   }\n   else\n   {\n      ssd_create_keyboard( group,\n                     on_keyboard_pressed,\n                     NULL,\n                     NULL,\n                     edit);\n   }\n\n#else //TOUCH_SCREEN\n   ssd_widget_set_left_softkey_text       ( dialog, roadmap_lang_get(\"Skip\"));\n   ssd_widget_set_left_softkey_callback   ( dialog, on_skip_workaddress);\n#endif //TOUCH_SCREEN\n   ssd_widget_add (dialog, group);\n   dialog->context = create_results_dialog(\"Work address\");\n   ssd_dialog_activate (\"Work_Addresse\", NULL);\n   ssd_dialog_draw();\n   ssd_dialog_set_focus( edit_con );\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int personalize_buttons_callback (SsdWidget widget, const char *new_value)", "code": "{\n\n   if (!strcmp(widget->name, \"Skip\")){\n         set_first_time_no();\n         ssd_dialog_hide_current(dec_close);\n   }\n   else if (!strcmp(widget->name, \"Personalize\")){\n      roadmap_login_update_dlg_show();\n   }\n\n   return 1;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n// End\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static void end_dialog()", "code": "{\n   SsdWidget dialog;\n    SsdWidget group;\n   SsdWidget text;\n\n   dialog = ssd_dialog_new (\"Wiz_End\",\n                      roadmap_lang_get (\"End\"),\n                      NULL,\n                      SSD_CONTAINER_TITLE|SSD_DIALOG_NO_SCROLL);\n\n\n   group = ssd_container_new (\"End_con\", NULL,\n                        SSD_MIN_SIZE,SSD_MIN_SIZE,SSD_WIDGET_SPACE|SSD_END_ROW|SSD_ALIGN_VCENTER|SSD_CONTAINER_BORDER|SSD_ROUNDED_CORNERS|SSD_ROUNDED_WHITE);\n   ssd_widget_set_color (group, NULL,NULL);\n   ssd_widget_add (group, space(10));\n\n   text = ssd_text_new (\"Label\", roadmap_lang_get(\"Way to go!\"), 22,SSD_ALIGN_CENTER|SSD_END_ROW);\n   ssd_widget_set_color(text,\"#d52c6b\", \"#d52c6b\");\n   ssd_widget_add (group, text);\n   ssd_widget_add (group, space(10));\n\n   text = ssd_text_new (\"Label\", roadmap_lang_get(\"Your account has been updated\"), 18,SSD_ALIGN_CENTER|SSD_END_ROW);\n   ssd_widget_add (group, text);\n\n   ssd_widget_add (group, space(20));\n\n\n#ifdef TOUCH_SCREEN\n   ssd_widget_add (group,\n   ssd_button_label (\"Finish\", roadmap_lang_get (\"Finish\"),\n                        SSD_WS_TABSTOP|SSD_ALIGN_CENTER|SSD_START_NEW_ROW, end_button_callback));\n#else //TOUCH_SCREEN\n   ssd_widget_set_left_softkey_text       ( dialog, roadmap_lang_get(\"Finish\"));\n   ssd_widget_set_left_softkey_callback   ( dialog, on_softkey_finish);\n#endif //TOUCH_SCREEN\n\n   ssd_widget_add (dialog, group);\n   ssd_dialog_activate (\"Wiz_End\", NULL);\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//////////////////////////////////////////////////////////////\n", "func_signal": "void roadmap_term_of_use(RoadMapCallback callback)", "code": "{\n\n\n   if (is_terms_accepted()){\n      if (callback)\n         (*callback)();\n         return;\n   }else\n      gCallback = callback;\n\n#ifdef TOUCH_SCREEN\n  roadmap_bottom_bar_hide();\n#endif\n\n  term_of_use_dialog();\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int nickname_next_button_callback (SsdWidget widget, const char *new_value)", "code": "{\n\n   roadmap_config_set(&RT_CFG_PRM_NKNM_Var, ssd_dialog_get_value(\"NickName\"));\n   //homeaddress_dialog();\n   welcome_wizard_twitter_dialog();\n   return 1;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//TOUCH_SCREEN\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int on_softkey_finish(SsdWidget widget, const char *new_value, void *context)", "code": "{\n   set_first_time_no();\n   ssd_dialog_hide_all (dec_ok);\n   return 0;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int on_search_workaddress(SsdWidget widget, const char *new_value, void *context)", "code": "{\n   on_search_work(widget->children->children, NULL);\n   return 0;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/* we want a descending list so this function inverts the real comparison */\n", "func_signal": "static int angle_pair_cmp (const void *p1, const void *p2)", "code": "{\n\n   const angle_pair *pair1 = (const angle_pair *)p1;\n   const angle_pair *pair2 = (const angle_pair *)p2;\n\n   if (pair1->angle > pair2->angle) return -1;\n   else if (pair1->angle < pair2->angle) return 1;\n   else return 0;\n}", "path": "editor\\track\\editor_track_unknown.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//TOUCH_SCREEN\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int on_skip_homeaddress(SsdWidget widget, const char *new_value, void *context)", "code": "{\n   workaddress_dialog();\n   return 0;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static int twitter_button_callback (SsdWidget widget, const char *new_value)", "code": "{\n\n   if ( ( widget != NULL ) && !strcmp(widget->name, \"Skip\"))\n   {\n      end_dialog();\n   }\n   else /* if (!strcmp(widget->name, \"Next\")) */\n   {\n     const char *username = ssd_dialog_get_value(\"TwitterUserName\");\n     const char *password = ssd_dialog_get_value(\"TwitterPassword\");\n     if (!username || !*username){\n        roadmap_messagebox(\"Error\", \"Please enter a user name\");\n        return 0;\n     }\n\n     if (!password || !*password){\n        roadmap_messagebox(\"Error\", \"Please enter password\");\n        return 0;\n     }\n\n     roadmap_twitter_set_username(username);\n     roadmap_twitter_set_password(password);\n     roadmap_config_save(TRUE);\n     Realtime_TwitterConnect(ssd_dialog_get_value(\"TwitterUserName\"), ssd_dialog_get_value(\"TwitterPassword\"));\n     end_dialog();\n   }\n\n   return 1;\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "// user_input=tel aviv &server_cookie=HADFWER\n", "func_signal": "roadmap_result address_search_report_wrong_address(const char* user_input)", "code": "{\n   transaction_state tstate;\n   const char* report = NULL;\n   if( INVALID_WEBSVC_HANDLE == s_websvc)\n   {\n      roadmap_log( ROADMAP_ERROR, \"address_search_report_wrong_address() - MODULE NOT INITIALIZED\");\n      assert(0);  // 'address_search_init()' was not called\n      return err_internal_error;\n      \n   }\n   tstate = wst_get_trans_state( s_websvc);\t\n   if( trans_idle != tstate)\n   {\n      roadmap_log( ROADMAP_DEBUG, \"address_search_report_wrong_address() - Cannot start transaction: Transaction is not idle yet\");\n      wst_watchdog( s_websvc);\n      return err_as_already_in_transaction;\n   }\t\n   report = address_search_prepare_report(user_input);\n   // Perform WebService Transaction:\n   if( wst_start_trans( s_websvc,\n                        \"mozi_stat\",\n                        data_parser,\n                        sizeof(data_parser)/sizeof(wst_parser),\n                        on_completed_reporting_bad_address,\n                        NULL,\n                        report))\n   \t\treturn succeeded;\n   roadmap_log( ROADMAP_ERROR, \"address_search_resolve_address() - Transaction failed... %s\",report);\n   return err_failed;\n}", "path": "address_search\\address_search.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "//   Module initialization/termination - Called once, when the process starts/terminates\n", "func_signal": "BOOL address_search_init()", "code": "{\n   const char* address;\n\n   if( INVALID_WEBSVC_HANDLE != s_websvc)\n   {\n      assert(0);  // Called twice?\n      return TRUE;\n   }\n\n   if( !s_initialized_once)\n   {\n      //   Web-service address\n      roadmap_config_declare( ADSR_WEBSVC_CFG_FILE,\n                              &s_web_service_name,\n                              ADSR_WEBSVC_DEFAULT_ADDRESS,\n                              NULL);\n      s_initialized_once = TRUE;\n   }\n\n   address  = get_webservice_address();\n   s_websvc = wst_init( get_webservice_address(), \"application/x-www-form-urlencoded; charset=utf-8\");\n\n   if( INVALID_WEBSVC_HANDLE != s_websvc)\n   {\n      roadmap_log(ROADMAP_DEBUG,\n                  \"address_search_init() - Web-Service Address: '%s'\",\n                  address);\n      return TRUE;\n   }\n\n   roadmap_log(ROADMAP_ERROR, \"address_search_init() - 'wst_init()' failed\");\n   return FALSE;\n}", "path": "address_search\\address_search.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n", "func_signal": "static void set_first_time_no()", "code": "{\n   roadmap_config_set(&WELCOME_WIZ_FIRST_TIME_Var, WELCOME_WIZ_FIRST_TIME_No);\n   roadmap_config_save(TRUE);\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/////////////////////////////////////////////////////////////////////\n// Nickname\n/////////////////////////////////////////////////////////////////////\n", "func_signal": "static void nickname_dialog()", "code": "{\n   SsdWidget dialog;\n   SsdWidget group;\n   SsdWidget text, edit_con, edit;\n   int txt_box_height = 40;\n#ifndef TOUCH_SCREEN\n   txt_box_height = 23;\n#endif\n\n   dialog = ssd_dialog_new (\"Wiz_Nickname\",\n                      roadmap_lang_get (\"Nickname 1/2\"),\n                      NULL,\n                      SSD_CONTAINER_TITLE|SSD_DIALOG_NO_SCROLL);\n\n   ssd_widget_add (dialog, space(5));\n\n   group = ssd_container_new (\"End_con\", NULL,\n                              SSD_MAX_SIZE,SSD_MAX_SIZE,SSD_WIDGET_SPACE|SSD_END_ROW|SSD_ALIGN_VCENTER);\n   ssd_widget_set_color (group, NULL,NULL);\n\n   text = ssd_text_new (\"Label\", roadmap_lang_get(\"Choose a nickname\"), 16,SSD_END_ROW|SSD_TEXT_LABEL);\n   ssd_widget_add (group, text);\n\n   ssd_widget_add (group, space(10));\n\n   edit_con = ssd_container_new (\"Text_con\", NULL,\n                                 SSD_MAX_SIZE,txt_box_height,SSD_WS_TABSTOP|SSD_END_ROW|SSD_CONTAINER_TXT_BOX);\n   ssd_widget_set_color (edit_con, \"#ffffff\",\"#ffffff\");\n\n   edit = ssd_text_new     ( \"NickName\",roadmap_config_get( &RT_CFG_PRM_NKNM_Var), 16, SSD_ALIGN_VCENTER);\n   ssd_text_set_input_type( edit, inputtype_free_text);\n   ssd_text_set_readonly  ( edit, FALSE);\n\n   edit_con->key_pressed = nickname_on_key_pressed_delegate_to_editbox;\n   ssd_widget_add(edit_con, edit);\n\n   ssd_widget_add(edit_con, ssd_bitmap_new(\"cursor\", \"cursor\",SSD_ALIGN_VCENTER));\n   ssd_widget_add (group, edit_con);\n\n   ssd_widget_add (group, space(5));\n#ifdef TOUCH_SCREEN\n   ssd_widget_add (group,\n   ssd_button_label (\"Wizard_Next\", roadmap_lang_get (\"Next\"),\n                     SSD_WS_TABSTOP|SSD_ALIGN_CENTER|SSD_END_ROW|SSD_START_NEW_ROW, nickname_next_button_callback));\n   ssd_widget_add (group, space(10));\n\n   if ( roadmap_native_keyboard_enabled() )\n   {\n\t   ssd_dialog_set_ntv_keyboard_action( dialog->name, _ntv_kb_action_show );\n\t   ssd_dialog_set_ntv_keyboard_params( dialog->name, &s_gNativeKBParams );\n   }\n   else\n   {\n\t  ssd_create_keyboard( group,\n\t\t\t\t\t on_keyboard_pressed,\n\t\t\t\t\t NULL,\n\t\t\t\t\t NULL,\n\t\t\t\t\t edit);\n   }\n#else //TOUCH_SCREEN\n   ssd_widget_set_left_softkey_text       ( dialog, roadmap_lang_get(\"Next\"));\n   ssd_widget_set_left_softkey_callback   ( dialog, on_softkey_next_nickname);\n#endif //TOUCH_SCREEN\n\n   ssd_widget_add (dialog, group);\n\n   ssd_dialog_activate (\"Wiz_Nickname\", NULL);\n   ssd_dialog_draw();\n   ssd_dialog_set_focus( edit_con);\n}", "path": "roadmap_welcome_wizard.c", "repo_name": "maximuska/Freemap-waze", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 30447}
{"docstring": "/****************************************************************************/\n", "func_signal": "static int getgraycol(int x, int y)", "code": "{\n    uae_u8 *bufpt;\n    int xs, xl, ys, yl, c, cm;\n\n    xl = x_map[x+1] - (xs = x_map[x]);\n    yl = y_map[y+1] - (ys = y_map[y]);\n\n    bufpt = ((uae_u8 *)gfxvidinfo.bufmem) + ys*currprefs.gfx_width + xs;\n\n    cm = c = 0;\n    for(y = 0; y < yl; y++, bufpt += currprefs.gfx_width)\n\tfor(x = 0; x < xl; x++) {\n\t    c += bufpt[x];\n\t    ++cm;\n\t}\n    if (cm)\n\tc /= cm;\n    if (! currprefs.curses_reverse_video)\n\tc = maxc - c;\n    return graychar[x2graymap[c]];\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* get one bit from MFM bit stream */\n", "func_signal": "static uae_u32 getonebit (uae_u16 * mfmbuf, int mfmpos, uae_u32 word)", "code": "{\n    uae_u16 *buf;\n\n    buf = &mfmbuf[mfmpos >> 4];\n    word <<= 1;\n    word |= (buf[0] & (1 << (15 - (mfmpos & 15)))) ? 1 : 0;\n    return word;\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* Update ADF_EXT2 track header */\n", "func_signal": "static void diskfile_update (drive * drv, int len, uae_u8 type)", "code": "{\n    trackid *ti;\n    int track;\n    uae_u8 buf[2 + 2 + 4 + 4], *zerobuf;\n\n    if (drv->filetype != ADF_EXT2)\n\treturn;\n\n    track = drv->cyl * 2 + side;\n    ti = &drv->trackdata[track];\n    ti->bitlen = len;\n    zfile_fseek (drv->diskfile, 8 + 4 + (2 + 2 + 4 + 4) * track, SEEK_SET);\n    memset (buf, 0, sizeof buf);\n    ti->type = type;\n    buf[3] = ti->type;\n    do_put_mem_long ((uae_u32 *) (buf + 4), ti->len);\n    do_put_mem_long ((uae_u32 *) (buf + 8), ti->bitlen);\n    zfile_fwrite (buf, sizeof (buf), 1, drv->diskfile);\n    if (ti->len > (len + 7) / 8) {\n\tzerobuf = malloc (ti->len);\n\tmemset (zerobuf, 0, ti->len);\n\tzfile_fseek (drv->diskfile, ti->offs, SEEK_SET);\n\tzfile_fwrite (zerobuf, 1, ti->len, drv->diskfile);\n\tfree (zerobuf);\n    }\n#ifdef DISK_DEBUG\n    write_log (\"track %d, raw track length %d written (total size %d)\\n\", track, (ti->bitlen + 7) / 8, ti->len);\n#endif\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* emulate disk write dma for full horizontal line */\n", "func_signal": "static void disk_doupdate_write (drive * drv)", "code": "{\n    int hpos = disk_hpos;\n    while (hpos < (maxhpos << 8)) {\n\tdrv->mfmpos++;\n\tdrv->mfmpos %= drv->tracklen;\n\tif (!drv->mfmpos) {\n\t    disk_sync[hpos >> 8] |= DISK_INDEXSYNC;\n\t    disk_events (0);\n\t}\n\tif ((dmacon & 0x210) == 0x210 && dskdmaen == 3) {\n\t    bitoffset++;\n\t    bitoffset &= 15;\n\t    if (!bitoffset) {\n\t\tdrv->bigmfmbuf[drv->mfmpos >> 4] = get_word (dskpt);\n\t\tdskpt += 2;\n\t\tdsklength--;\n\t\tif (dsklength == 0) {\n\t\t    disk_dmafinished ();\n\t\t    drive_write_data (drv);\n\t\t}\n\t    }\n\t}\n\thpos += drv->trackspeed;\n    }\n    disk_hpos = hpos - (maxhpos << 8);\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* disk DMA fetch happens on real Amiga at the beginning of next horizontal line\n   (cycles 9, 11 and 13 according to hardware manual) We transfer all DMA'd\n   data at cycle 0. I don't think any program cares about this small difference.\n\n   We must handle dsklength = 0 because some copy protections use it to detect\n   wordsync without transferring any data.\n*/\n", "func_signal": "static void dodmafetch (void)", "code": "{\n    int i;\n\n    i = 0;\n    while (dma_tab[i] != 0xffffffff && dskdmaen == 2 && (dmacon & 0x210) == 0x210) {\n\tif (dsklength > 0) {\n\t    put_word (dskpt, dma_tab[i++]);\n\t    dskpt += 2;\n\t    dsklength--;\n\t}\n\tif (dsklength == 0) {\n\t    disk_dmafinished ();\n\t    break;\n\t}\n    }\n    dma_tab[0] = 0xffffffff;\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* Megalomania does not like zero MFM words... */\n", "func_signal": "static void mfmcode (uae_u16 * mfm, int words)", "code": "{\n    uae_u32 lastword = 0;\n\n    while (words--) {\n\tuae_u32 v = *mfm;\n\tuae_u32 lv = (lastword << 16) | v;\n\tuae_u32 nlv = 0x55555555 & ~lv;\n\tuae_u32 mfmbits = (nlv << 1) & (nlv >> 1);\n\n\t*mfm++ = v | mfmbits;\n\tlastword = v;\n    }\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/****************************************************************************/\n", "func_signal": "static void init_colors(void)", "code": "{\n    int i;\n\n    maxc = 0;\n\n    for(i = 0; i < 4096; ++i) {\n\tint r,g,b,r1,g1,b1;\n\tint m, comp;\n\tint ctype;\n\n\tr =  i >> 8;\n\tg = (i >> 4) & 15;\n\tb =  i & 15;\n\n\txcolors[i] = (77 * r + 151 * g + 28 * b)/16;\n\tif(xcolors[i] > maxc)\n\t    maxc = xcolors[i];\n\tm = r;\n\tif (g > m)\n\t    m = g;\n\tif (b > m)\n\t    m = b;\n\tif (m == 0) {\n\t    xcolors[i] |= MYCOLOR_WHITE << 8; /* to get gray instead of black in dark areas */\n\t    continue;\n\t}\n\n\tif ((currprefs.color_mode & ~1) != 0) {\n\t    r1 = r*15 / m;\n\t    g1 = g*15 / m;\n\t    b1 = b*15 / m;\n\n\t    comp = 8;\n\t    for (;;) {\n\t\tif (b1 < comp) {\n\t\t    if (r1 < comp)\n\t\t\tctype = MYCOLOR_GREEN;\n\t\t    else if (g1 < comp)\n\t\t\tctype = MYCOLOR_RED;\n\t\t    else\n\t\t\tctype = MYCOLOR_YELLOW;\n\t\t} else {\n\t\t    if (r1 < comp) {\n\t\t\tif (g1 < comp)\n\t\t\t    ctype = MYCOLOR_BLUE;\n\t\t\telse\n\t\t\t    ctype = MYCOLOR_CYAN;\n\t\t    } else if (g1 < comp)\n\t\t\t    ctype = MYCOLOR_MAGENTA;\n\t\t    else {\n\t\t\tcomp += 4;\n\t\t\tif (comp == 12 && (currprefs.color_mode & 2) != 0)\n\t\t\t    continue;\n\t\t\tctype = MYCOLOR_WHITE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (currprefs.color_mode & 8) {\n\t\tif (ctype == MYCOLOR_BLUE && xcolors[i] > /*27*/50)\n\t\t    ctype = r1 > (g1+2) ? MYCOLOR_MAGENTA : MYCOLOR_CYAN;\n\t\tif (ctype == MYCOLOR_RED && xcolors[i] > /*75*/ 90)\n\t\t    ctype = b1 > (g1+6) ? MYCOLOR_MAGENTA : MYCOLOR_YELLOW;\n\t    }\n\t    xcolors[i] |= ctype << 8;\n\t}\n    }\n    if (currprefs.color_mode & 4) {\n\tint j;\n\tfor (j = MYCOLOR_RED; j < MYCOLOR_WHITE; j++) {\n\t    int best = 0, maxv = 0;\n\t    int multi, divi;\n\n\t    for (i = 0; i < 4096; i++)\n\t\tif ((xcolors[i] & 255) > maxv && (xcolors[i] >> 8) == j) {\n\t\t    best = i;\n\t\t    maxv = (xcolors[best] & 255);\n\t\t}\n\t    /* Now maxv is the highest intensity a color of type J is supposed to have.\n\t     * In  reality, it will most likely only have intensity maxv*multi/divi.\n\t     * We try to correct this. */\n\t    maxv = maxv * 256 / maxc;\n\n\t    divi = 256;\n\t    switch (j) {\n\t     case MYCOLOR_RED:     multi = 77; break;\n\t     case MYCOLOR_GREEN:   multi = 151; break;\n\t     case MYCOLOR_BLUE:    multi = 28; break;\n\t     case MYCOLOR_YELLOW:  multi = 228; break;\n\t     case MYCOLOR_CYAN:    multi = 179; break;\n\t     case MYCOLOR_MAGENTA: multi = 105; break;\n\t     default: abort();\n\t    }\n#if 1 /* This makes the correction less extreme */\n\t    if (! (currprefs.color_mode & 8))\n\t\tmulti = (multi + maxv) / 2;\n#endif\n\t    for (i = 0; i < 4096; i++) {\n\t\tint v = xcolors[i];\n\t\tif ((v >> 8) != j)\n\t\t    continue;\n\t\tv &= 255;\n\t\t/* I don't think either of these is completely correct, but\n\t\t * the first one produces rather good results. */\n#if 1\n\t\tv = v * divi / multi;\n\t\tif (v > maxc)\n\t\t    v = maxc;\n#else\n\t\tv = v * 256 / maxv);\n\t\tif (v > maxc)\n\t\t    /*maxc = v*/abort();\n#endif\n\t\txcolors[i] = v | (j << 8);\n\t    }\n\t}\n    }\n    x2graymap = (int *)malloc(sizeof(int) * (maxc+1));\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* write raw track to disk file */\n", "func_signal": "static int drive_write_ext2 (drive * drv)", "code": "{\n    trackid *ti;\n    int len, track, i;\n\n    track = drv->cyl * 2 + side;\n    ti = &drv->trackdata[track];\n    len = (drv->tracklen + 7) / 8;\n    if (len > ti->len) {\n\twrite_log (\"disk raw write: image file's track %d is too small (%d < %d)!\\n\", track, ti->len, len);\n\treturn 0;\n    }\n    diskfile_update (drv, drv->tracklen, TRACK_RAW);\n    for (i = 0; i < drv->trackdata[track].len / 2; i++) {\n\tuae_u16 *mfm = drv->bigmfmbuf + i;\n\tuae_u8 *data = (uae_u8 *) mfm;\n\t*mfm = 256 * *data + *(data + 1);\n    }\n    zfile_fseek (drv->diskfile, ti->offs, SEEK_SET);\n    zfile_fwrite (drv->bigmfmbuf, 1, len, drv->diskfile);\n    return 1;\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* Simulate exact behaviour of an A3000T 3.5 HD disk drive.\n * The drive reports to be a 3.5 DD drive whenever there is no\n * disk or a 3.5 DD disk is inserted. Only 3.5 HD drive id is reported\n * when a real 3.5 HD disk is inserted. -Adil\n */\n", "func_signal": "static void drive_settype_id (drive *drv)", "code": "{\n    int t = drv->type;\n\n    switch (t)\n    {\n    case DRV_35_HD:\n#ifdef FLOPPY_DRIVE_HD\n\tif (!drv->diskfile || drv->ddhd <= 1)\n\t    drv->drive_id = DRIVE_ID_35DD;\n\telse\n\t    drv->drive_id = DRIVE_ID_35HD;\n#else\n\tdrv->drive_id = DRIVE_ID_35DD;\n#endif\n\tbreak;\n    case DRV_35_DD_ESCOM:\n    case DRV_35_DD:\n    default:\n\tdrv->drive_id = DRIVE_ID_35DD;\n\tbreak;\n    case DRV_525_SD:\n\tdrv->drive_id = DRIVE_ID_525SD;\n\tbreak;\n    case DRV_NONE:\n\tdrv->drive_id = DRIVE_ID_NONE;\n\tbreak;\n    }\n#ifdef DEBUG_DRIVE_ID\n    write_log (\"drive_settype_id: DF%d: set to %s\\n\", drv-floppy, drive_id_name (drv));\n#endif\n#ifdef DEBUG_DRIVE_ID\n    write_log (\"drive_settype_id: DF%d: set to %s\\n\", drv-floppy, drive_id_name (drv));\n#endif\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/*\n * old:\tfmt = \" .,:=(Io^vM^vb*X^#M^vX*boI(=:. ^b^vobX^#M\" doesn't work: \"^vXb*oI(=:. \";\n * good:\tfmt = \" .':;=(IoJpgFPEB#^vgpJoI(=;:'. ^v^b=(IoJpgFPEB\";\n *\n * \tfmt = \" .,:=(Io*b^vM^vX^#M^vXb*oI(=:. \";\n */\n", "func_signal": "static void init_graychar(void)", "code": "{\n    chtype *p = graychar;\n    chtype attrs;\n    int i,j;\n    char *fmt;\n\n    attrs = termattrs();\n    if ((currprefs.color_mode & 1) == 0 && (attrs & (A_REVERSE | A_BOLD)))\n\tfmt = \" .':;=(IoJpgFPEB#^vgpJoI(=;:'. ^v^boJpgFPEB\";\n    else if ((currprefs.color_mode & 1) == 0 && (attrs & A_REVERSE))\n\tfmt = \" .':;=(IoJpgFPEB#^vgpJoI(=;:'. \";\n    else\n\t/* One could find a better pattern.. */\n\tfmt = \" .`'^^\\\",:;i!1Il+=tfjxznuvyZYXHUOQ0MWB\";\n    attrs = A_NORMAL | COLOR_PAIR (0);\n    while(*fmt) {\n\tif(*fmt == '^') {\n\t    ++fmt;\n\t    switch(*fmt) {\n\t\tcase 's': case 'S': attrs ^= A_STANDOUT; break;\n\t\tcase 'v': case 'V': attrs ^= A_REVERSE; break;\n\t\tcase 'b': case 'B': attrs ^= A_BOLD; break;\n\t\tcase 'd': case 'D': attrs ^= A_DIM; break;\n\t\tcase 'u': case 'U': attrs ^= A_UNDERLINE; break;\n\t\tcase 'p': case 'P': attrs  = A_NORMAL; break;\n\t\tcase '#': if(ACS_CKBOARD == ':')\n\t\t\t       *p++ = (attrs | '#');\n\t\t\t  else *p++ = (attrs | ACS_CKBOARD); break;\n\t\tdefault:  *p++ = (attrs | *fmt); break;\n\t    }\n\t    ++fmt;\n\t} else *p++ = (attrs | *fmt++);\n\tif(p >= graychar + MAXGRAYCHAR) break;\n    }\n    max_graychar = (p - graychar) - 1;\n\n    for (i = 0; i <= maxc; i++)\n\tx2graymap[i] = i * max_graychar / maxc;\n#if 0\n    for(j=0;j<LINES;++j) {\n\tmove(j,0);\n\tfor(i=0;i<COLS;++i) addch(graychar[i % (max_graychar+1)]);\n    }\n    refresh();\n    sleep(3);\n#endif\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* Disk save/restore code */\n", "func_signal": "void DISK_save_custom (uae_u32 *pdskpt, uae_u16 *pdsklength, uae_u16 *pdsksync, uae_u16 *pdskdatr, uae_u16 *pdskbytr)", "code": "{\n    if (pdskpt) *pdskpt = dskpt;\n    if (pdsklength) *pdsklength = dsklength;\n    if (pdsksync) *pdsksync = dsksync;\n    if (pdskdatr) *pdskdatr = 0;\n    if (pdskbytr) *pdskbytr = dskbytr_tab[0];\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* emulate disk read dma for full horizontal line */\n", "func_signal": "static void disk_doupdate_read (drive * drv)", "code": "{\n    int hpos = disk_hpos;\n    int is_sync = 0;\n    int j = 0, k = 1, l = 0;\n    uae_u16 synccheck;\n    static int dskbytr_last = 0, wordsync_last = -1;\n\n    dskbytr_tab[0] = dskbytr_tab[dskbytr_last];\n\n    if (wordsync_last >= 0 && maxhpos - wordsync_cycle[wordsync_last] < WORDSYNC_CYCLES)\n\twordsync_cycle[l++] = (maxhpos - wordsync_cycle[wordsync_last]) - WORDSYNC_CYCLES;\n    wordsync_last = -1;\n\n    while (hpos < (maxhpos << 8)) {\n\tif (drv->dskready)\n\t    word = getonebit (drv->bigmfmbuf, drv->mfmpos, word);\n\telse\n\t    word <<= 1;\n\tdrv->mfmpos++;\n\tdrv->mfmpos %= drv->tracklen;\n\tif (!drv->mfmpos) {\n\t    disk_sync[hpos >> 8] |= DISK_INDEXSYNC;\n\t    is_sync = 1;\n\t}\n\tif (bitoffset == 31 && dma_enable) {\n\t    dma_tab[j++] = (word >> 16) & 0xffff;\n\t    if (j == MAX_DISK_WORDS_PER_LINE - 1) {\n\t\twrite_log (\"Bug: Disk DMA buffer overflow!\\n\");\n\t\tj--;\n\t    }\n\t}\n\tif (bitoffset == 15 || bitoffset == 23 || bitoffset == 31) {\n\t    dskbytr_tab[k] = (word >> 8) & 0xff;\n\t    dskbytr_tab[k] |= 0x8000;\n\t    dskbytr_last = k;\n\t    dskbytr_cycle[k++] = hpos >> 8;\n\t}\n\tsynccheck = (word >> 8) & 0xffff;\n\tif (synccheck == dsksync) {\n\t    if (adkcon & 0x400) {\n\t\tif (bitoffset != 23 || !dma_enable)\n\t\t    bitoffset = 7;\n\t\tdma_enable = 1;\n\t    }\n\t    wordsync_last = l;\n\t    wordsync_cycle[l++] = hpos >> 8;\n\t    disk_sync[hpos >> 8] |= DISK_WORDSYNC;\n\t    is_sync = 1;\n\t}\n\tbitoffset++;\n\tif (bitoffset == 32) bitoffset = 16;\n\thpos += drv->trackspeed;\n    }\n    dma_tab[j] = 0xffffffff;\n    dskbytr_cycle[k] = 255;\n    wordsync_cycle[l] = 255;\n    if (is_sync)\n\tdisk_events (0);\n\n    disk_hpos = hpos - (maxhpos << 8);\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/****************************************************************************/\n", "func_signal": "static int keycode2amiga(int ch)", "code": "{\n    switch(ch) {\n\tcase KEY_A1:    return AK_NP7;\n\tcase KEY_UP:    return AK_NP8;\n\tcase KEY_A3:    return AK_NP9;\n\tcase KEY_LEFT:  return AK_NP4;\n\tcase KEY_B2:    return AK_NP5;\n\tcase KEY_RIGHT: return AK_NP6;\n\tcase KEY_C1:    return AK_NP1;\n\tcase KEY_DOWN:  return AK_NP2;\n\tcase KEY_C3:    return AK_NP3;\n\tcase KEY_ENTER: return AK_ENT;\n\tcase 13:        return AK_RET;\n\tcase ' ':       return AK_SPC;\n\tcase 27:        return AK_ESC;\n\tdefault: return -1;\n    }\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/***************************************************************************/\n", "func_signal": "static void curses_insert_disk(void)", "code": "{\n    curses_exit();\n    gui_changesettings();\n    flush_screen(0,0);\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* this is very unoptimized. DSKBYTR is used very rarely, so it should not matter. */\n", "func_signal": "uae_u16 DSKBYTR (int hpos)", "code": "{\n    uae_u16 v;\n    int i;\n\n    i = 0;\n    while (hpos > dskbytr_cycle[i + 1])\n\ti++;\n    v = dskbytr_tab[i];\n    dskbytr_tab[i] &= ~0x8000;\n    if (wordsync_cycle[0] != 255) {\n\ti = 0;\n\twhile (hpos < wordsync_cycle[i])\n\t    i++;\n\tif (hpos - wordsync_cycle[i] <= WORDSYNC_CYCLES)\n\t    v |= 0x1000;\n    }\n    if (dskdmaen && (dmacon & 0x210) == 0x210)\n\tv |= 0x4000;\n    if (dskdmaen == 3)\n\tv |= 0x2000;\n\n    disk_data_used = 0;\n\n    return v;\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* We use this function if we have no Kickstart ROM.\n * No error checking - we trust our luck. */\n", "func_signal": "void DISK_ersatz_read (int tr, int sec, uaecptr dest)", "code": "{\n    uae_u8 *dptr = get_real_address (dest);\n    zfile_fseek (floppy[0].diskfile, floppy[0].trackdata[tr].offs + sec * 512, SEEK_SET);\n    zfile_fread (dptr, 1, 512, floppy[0].diskfile);\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/***************************************************************************/\n", "func_signal": "void handle_events(void)", "code": "{\n    int ch;\n    int kc;\n\n    /* Hack to simulate key release */\n    for(kc = 0; kc < 256; ++kc) {\n\tif(keystate[kc]) if(!--keystate[kc]) record_key((kc << 1) | 1);\n    }\n    if(buttonstate[0]) --buttonstate[0];\n    if(buttonstate[1]) --buttonstate[1];\n    if(buttonstate[2]) --buttonstate[2];\n\n    newmousecounters = 0;\n    if(!curses_on) return;\n\n    while((ch = getch())!=ERR) {\n\tif(ch == 12) {clearok(stdscr,TRUE);refresh();}\n#ifdef NCURSES_MOUSE_VERSION\n\tif(ch == KEY_MOUSE) {\n\t    MEVENT ev;\n\t    if(getmouse(&ev) == OK) {\n\t\tlastmx = (ev.x*currprefs.gfx_width)/COLS;\n\t\tlastmy = (ev.y*currprefs.gfx_height)/LINES;\n\t\tif(ev.bstate & BUTTON1_PRESSED)  buttonstate[0] = keydelay;\n\t\tif(ev.bstate & BUTTON1_RELEASED) buttonstate[0] = 0;\n\t\tif(ev.bstate & BUTTON2_PRESSED)  buttonstate[1] = keydelay;\n\t\tif(ev.bstate & BUTTON2_RELEASED) buttonstate[1] = 0;\n\t\tif(ev.bstate & BUTTON3_PRESSED)  buttonstate[2] = keydelay;\n\t\tif(ev.bstate & BUTTON3_RELEASED) buttonstate[2] = 0;\n\t    }\n\t}\n#endif\n\tif (ch == 6)  ++lastmx; /* ^F */\n\tif (ch == 2)  --lastmx; /* ^B */\n\tif (ch == 14) ++lastmy; /* ^N */\n\tif (ch == 16) --lastmy; /* ^P */\n\tif (ch == 11) {buttonstate[0] = keydelay;ch = 0;} /* ^K */\n\tif (ch == 25) {buttonstate[2] = keydelay;ch = 0;} /* ^Y */\n\tif (ch == 15) uae_reset (); /* ^O */\n\tif (ch == 17) uae_quit (); /* ^Q */\n\tif (ch == KEY_F(1)) {\n\t  curses_insert_disk();\n\t  ch = 0;\n\t}\n\n\tif(isupper(ch)) {\n\t    keystate[AK_LSH] =\n\t    keystate[AK_RSH] = keydelay;\n\t    record_key(AK_LSH << 1);\n\t    record_key(AK_RSH << 1);\n\t    kc = keycode2amiga(tolower(ch));\n\t    keystate[kc] = keydelay;\n\t    record_key(kc << 1);\n\t} else if((kc = keycode2amiga(ch)) >= 0) {\n\t    keystate[kc] = keydelay;\n\t    record_key(kc << 1);\n\t}\n    }\n    gui_handle_events();\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* internal floppy controller variables */\n", "func_signal": "const uae_u8 *restore_floppy (const uae_u8 *src)", "code": "{\n    word = restore_u16 ();\n    bitoffset = restore_u8 ();\n    dma_enable = restore_u8 ();\n    disk_hpos = restore_u8 ();\n    dskdmaen = restore_u8 ();\n    word |= restore_u16 () << 16;\n\n    return src;\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/***************************************************************************/\n", "func_signal": "void target_specific_usage(void)", "code": "{\n    printf(\"----------------------------------------------------------------------------\\n\");\n    printf(\"[n]curses specific usage:\\n\");\n    printf(\"  -x : Display reverse video.\\n\");\n    printf(\"By default uae will assume a black on white display. If yours\\n\");\n    printf(\"is light on dark, use -x. In case of graphics garbage, ^L will\\n\");\n    printf(\"redisplay the screen. ^K simulate left mouse button, ^Y RMB.\\n\");\n    printf(\"If you are using a xterm UAE can use the mouse. Else use ^F ^B\\n\");\n    printf(\"^P ^N to emulate mouse mouvements.\\n\");\n    printf(\"----------------------------------------------------------------------------\\n\");\n}", "path": "src\\ncurses.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/* code for track display */\n", "func_signal": "static void update_drive_gui (int num)", "code": "{\n    drive *drv = floppy + num;\n\n    if (drv->state == gui_data.drive_motor[num]\n\t&& drv->cyl == gui_data.drive_track[num]\n\t&& ((writing && gui_data.drive_writing[num])\n\t    || (!writing && !gui_data.drive_writing[num]))) {\n\treturn;\n    }\n    gui_data.drive_motor[num] = drv->state;\n    gui_data.drive_track[num] = drv->cyl;\n    if (!gui_data.drive_writing[num])\n\tgui_data.drive_writing[num] = writing;\n    gui_ledstate &= ~(2 << num);\n    if (drv->state)\n\tgui_ledstate |= 2 << num;\n    gui_led (num + 1, gui_data.drive_motor[num]);\n}", "path": "src\\disk.c", "repo_name": "bernds/UAE", "stars": 30, "license": "gpl-2.0", "language": "c", "size": 10738}
{"docstring": "/*\n * report back items in the playlist\n */\n", "func_signal": "int\nhgd_get_playlist(struct hgd_playlist *list)", "code": "{\n\tint\t\t\tsql_res;\n\n\tlist->n_items = 0;\n\tlist->items = NULL;\n\n\tDPRINTF(HGD_D_DEBUG, \"Playlist request\");\n\n\tsql_res = sqlite3_exec(db,\n\t    \"SELECT id, filename, tag_artist, tag_title, user, tag_album, \"\n\t    \"tag_genre, tag_duration, tag_bitrate, tag_samplerate, \"\n\t    \"tag_channels, tag_year FROM playlist\",\n\t    hgd_get_playlist_cb, list, NULL);\n\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't get playing track: %s\", DERROR);\n\t\treturn (HGD_FAIL);\n\t}\n\n\treturn (HGD_OK);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * remove user from db forever\n */\n", "func_signal": "int\nhgd_user_del_db(char *uname)", "code": "{\n\tint\t\t\t sql_res, ret = HGD_FAIL, lookup_ret;\n\tsqlite3_stmt\t\t*stmt = NULL;\n\tchar\t\t\t*sql = \"DELETE FROM users WHERE username=?\";\n\tstruct hgd_user\t\t user;\n\n\t/* look up the user so that we can report non-existency */\n\tif ((lookup_ret = hgd_get_user(uname, &user)) != HGD_OK) {\n\t\tret = lookup_ret;\n\t\tgoto clean;\n\t}\n\tfree(user.name);\n\n\tsql_res = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't prepare sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\t/* bind params */\n\tsql_res = sqlite3_bind_text(stmt, 1, uname, -1, SQLITE_TRANSIENT);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't bind sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tsql_res = sqlite3_step(stmt);\n\tif (sql_res != SQLITE_DONE) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't step sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tret = HGD_OK;\nclean:\n\tif (stmt)\n\t\tsqlite3_finalize(stmt);\n\n\treturn (ret);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * switches the content window and marks it for refresh\n */\n", "func_signal": "int\nhgd_switch_content(struct ui *u, int w)", "code": "{\n\tint\t\t\tret = HGD_FAIL;\n\n\tDPRINTF(HGD_D_INFO, \"Switch to window: %s\", window_names[w]);\n\n\tif (u->content_refresh_handler[w] == NULL) {\n\t\tDPRINTF(HGD_D_WARN, \"No content refresh handler defined\");\n\t\tgoto clean;\n\t}\n\n\tif (u->content_refresh_handler[w](u) != HGD_OK)\n\t\tgoto clean;\n\n\tu->active_content_win = w;\n\thgd_refresh_ui(u);\n\n\tret = HGD_OK;\nclean:\n\treturn (ret);\n}", "path": "nchgdc.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* mark it as playing in the database */\n", "func_signal": "int\nhgd_mark_playing(int id)", "code": "{\n\tint\t\t\t sql_res, ret = HGD_FAIL;\n\tsqlite3_stmt\t\t*stmt;\n\tchar\t\t\t*sql = \"UPDATE playlist SET playing=1 \"\n\t\t\t\t    \"WHERE id=?\";\n\n\tsql_res = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't prepare sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\t/* bind params */\n\tsql_res = sqlite3_bind_int(stmt, 1, id);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't bind sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tsql_res = sqlite3_step(stmt);\n\tif (sql_res != SQLITE_DONE) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't step sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tret = HGD_OK;\nclean:\n\tsqlite3_finalize(stmt);\n\treturn (ret);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * Please do not be tempted to move this to mplayer.c --\n * This would cause hgd-admin and hgd-netd to pull in python\n */\n", "func_signal": "int\nhgd_play_track(struct hgd_playlist_item *t, uint8_t purge_fs, uint8_t purge_db)", "code": "{\n\tint\t\t\tstatus = 0, pid, ret = HGD_FAIL;\n\tchar\t\t\t*ipc_path = 0, *pipe_arg = 0;\n\tFILE\t\t\t*ipc_file;\n\tstruct stat\t\tst;\n\n\tDPRINTF(HGD_D_INFO, \"Playing '%s' for '%s'\", t->filename, t->user);\n\tif (hgd_mark_playing(t->id) == HGD_FAIL)\n\t\tgoto clean;\n\n\t/*\n\t * We will write away the tid of the playing file\n\t * hgd-netd uses this to check the user is voting off the track\n\t * they think they are.\n\t */\n\txasprintf(&ipc_path, \"%s/%s\", state_path, HGD_PLAYING_FILE);\n\n\t/* first check the file is non-existent */\n\tif (stat(ipc_path, &st) < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tDPRINTF(HGD_D_ERROR,\n\t\t\t    \"stale tid file: %s: %s\", ipc_path, SERROR);\n\t\t\tgoto clean;\n\t\t}\n\t} else {\n\t\tDPRINTF(HGD_D_ERROR, \"stale tid file: %s\" , ipc_path);\n\t\tgoto clean;\n\t}\n\n\tif (hgd_file_open_and_lock(ipc_path, F_WRLCK, &ipc_file) != HGD_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't open+lock '%s'\", ipc_path);\n\t\tgoto clean;\n\t}\n\n\t/* try to be secure */\n\tif (chmod(ipc_path, S_IRUSR | S_IWUSR) != 0)\n\t\tDPRINTF(HGD_D_WARN, \"Can't secure ipc file: %s\", SERROR);\n\n\t/* write away tid of current track to a file for hgd-netd */\n\tif (fprintf(ipc_file, \"%d\", t->id) < 0) {\n\t\tDPRINTF(HGD_D_ERROR, \"Failed to write out tid: %s\", SERROR);\n\t\tgoto clean;\n\t}\n\n\t/* unlock */\n\tif (hgd_file_unlock_and_close(ipc_file) != HGD_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"failed to unlock\");\n\t\tgoto clean;\n\t}\n\n#ifdef HAVE_PYTHON\n\thgd_execute_py_hook(\"pre_play\");\n#endif\n\n\tif (hgd_make_mplayer_input_fifo() != HGD_OK)\n\t\tgoto clean;\n\n\txasprintf(&pipe_arg, \"file=%s\", mplayer_fifo_path);\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tDPRINTF(HGD_D_ERROR, \"Could not fork: %s\", SERROR);\n\t} else if (!pid) {\n\n\t\t/* child - your the d00d who will play this track */\n\t\texeclp(\"mplayer\", \"mplayer\", \"-really-quiet\", \"-slave\",\n\t\t    \"-input\", pipe_arg, t->filename, (char *) NULL);\n\n\t\t/* if we get here, the shit hit the fan with execlp */\n\t\tDPRINTF(HGD_D_ERROR, \"execlp() failed\");\n\t\thgd_exit_nicely(); /* child should always exit */\n\t} else {\n\t\tDPRINTF(HGD_D_INFO,\n\t\t    \"Mplayer spawned, waiting to finish: pid=%d\", pid);\n\n\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t/* it is ok for this to fail if we are restarting */\n\t\t\tif (errno != EINTR)\n\t\t\t\tDPRINTF(HGD_D_WARN, \"Could not wait(): %s\", SERROR);\n\n\t\t\tif (restarting || dying) {\n\t\t\t\tkill(pid, SIGINT);\n\t\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\t\tDPRINTF(HGD_D_WARN, \"Could not wait(): %s\", SERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* unlink ipc file */\n\t\tif (hgd_file_open_and_lock(\n\t\t    ipc_path, F_WRLCK, &ipc_file) != HGD_OK) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"Can't open+lock '%s'\", ipc_path);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (unlink(ipc_path) < 0) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"can't unlink ipc file %s: %s\",\n\t\t\t    ipc_path, SERROR);\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (hgd_file_unlock_and_close(ipc_file) != HGD_OK) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"failed to unlock+close %s: %s\",\n\t\t\t    ipc_path, SERROR);\n\t\t}\n\n\t\t/* unlink input pipe */\n\t\tif (unlink(mplayer_fifo_path) < 0)\n\t\t\tDPRINTF(HGD_D_WARN,\n\t\t\t    \"Could not unlink mplayer input fifo %s\", SERROR);\n\n\t\t/* unlink media (but not if restarting, we replay the track) */\n\t\tif ((!restarting) && (!dying)\n\t\t    && (purge_fs) && (unlink(t->filename) < 0)) {\n\t\t\tDPRINTF(HGD_D_DEBUG,\n\t\t\t    \"Deleting finished: %s\", t->filename);\n\t\t\tDPRINTF(HGD_D_WARN, \"Can't unlink '%s'\", ipc_path);\n\t\t}\n\t}\n#ifdef HAVE_PYTHON\n\thgd_execute_py_hook(\"post_play\");\n#endif\n\n\tDPRINTF(HGD_D_DEBUG, \"Finished playing (exit %d)\", status);\n\n\t/* if we are restarting, we replay the track on restart */\n\tif ((!restarting) && (!dying) &&\n\t    (hgd_mark_finished(t->id, purge_db) == HGD_FAIL))\n\t\tDPRINTF(HGD_D_WARN,\n\t\t    \"Could not purge/mark finished -- trying to continue\");\n\n\tret = HGD_OK;\n\nclean:\n\tif (pipe_arg)\n\t\tfree(pipe_arg);\n\tif (ipc_path)\n\t\tfree(ipc_path);\n\n\treturn (ret);\n}", "path": "hgd-playd.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* uh oh, someone hit enter on the files menu! */\n", "func_signal": "int\nhgd_enter_on_files_menu(struct ui *u)", "code": "{\n\tDPRINTF(HGD_D_INFO, \"Selected item on files menu\");\n\n\tchar\t\t\t*new_cwd = NULL;\n\tITEM\t\t\t*item;\n\tstruct dirent\t\t*dirent;\n\n\tif ((item = current_item(u->content_menus[HGD_WIN_FILES])) == NULL) {\n\t    DPRINTF(HGD_D_WARN, \"Could not get current item\");\n\t    return (HGD_FAIL);\n\t}\n\n\tdirent = (struct dirent *) item_userptr(item);\n\n\tswitch (dirent->d_type) {\n\tcase DT_DIR:\n\t\tDPRINTF(HGD_D_INFO, \"switch cwd: dirent->d_name\");\n\n\t\tif (strcmp(dirent->d_name, \"..\") == 0)\n\t\t\tnew_cwd = xstrdup(dirname(u->cwd));\n\t\telse\n\t\t\txasprintf(&new_cwd, \"%s/%s\", u->cwd, dirent->d_name);\n\n\t\tfree(u->cwd);\n\t\tu->cwd = new_cwd;\n\n\t\tbreak;\n\tdefault:\n\t\thgd_ui_queue_track(u, dirent->d_name);\n\t\tbreak;\n\t};\n\n\treturn (HGD_OK);\n}", "path": "nchgdc.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* make some stuff read only */\n", "func_signal": "static int\nhgd_py_meth_Hgd_read_only_raise(Hgd self, PyObject *value, void *closure)", "code": "{\n\t(void) closure;\n\t(void)value;\n\t(void)self;\n\t(void) PyErr_Format(PyExc_AttributeError, \"attribute is read-only\");\n\treturn (-1);\n}", "path": "py.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* Optionally create, and open database */\n", "func_signal": "sqlite3 *\nhgd_open_db(char *db_path, uint8_t create)", "code": "{\n\tint\t\t\t sql_res;\n\tsqlite3\t\t\t*db;\n\tint\t\t\t db_vers = -1;\n\tuint8_t\t\t\t db_schema_err = 0;\n\tstruct stat\t\t st;\n\n\tDPRINTF(HGD_D_DEBUG, \"opening database\");\n\n\tif (!create) {\n\t\tif (stat(db_path, &st) < 0) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"Can't stat %s: %s\", db_path, SERROR);\n\t\t\tDPRINTF(HGD_D_ERROR, \"Did you run 'hgd-admin db-init'?\");\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/* open the database */\n\tif (sqlite3_open(db_path, &db) != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't open %s: %s\", db_path, DERROR);\n\t\treturn (NULL);\n\t}\n\n\t/* make database secure */\n\tif (chmod(db_path, S_IRUSR | S_IWUSR) != 0) {\n\t\tDPRINTF(HGD_D_WARN, \"Could not make %s file secure: %s\",\n\t\t    db_path, SERROR);\n\t}\n\n\tDPRINTF(HGD_D_DEBUG, \"Setting database timeout\");\n\tsql_res = sqlite3_busy_timeout(db, 2000);\n\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't set busy timout: %s\", DERROR);\n\t\tsqlite3_close(db);\n\t\treturn (NULL);\n\t}\n\n\t/* if we are not creating a db, it should be the right version */\n\tif (!create) {\n\t\tsql_res = sqlite3_exec(db,\n\t\t    \"SELECT db_schema_version FROM system WHERE id=0\",\n\t\t    hgd_get_db_vers_cb, &db_vers, NULL);\n\n\t\tif (sql_res != SQLITE_OK) {\n\t\t\tDPRINTF(HGD_D_ERROR,\n\t\t\t    \"Can't get db schema version, \"\n\t\t\t    \"is your database too old?: %s\", DERROR);\n\t\t\tdb_schema_err = 1;\n\t\t} else if (db_vers != atoi(HGD_DB_SCHEMA_VERS)) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"Database schema version \"\n\t\t\t    \"mismatch: needed '%s', got '%d'\",\n\t\t\t    HGD_DB_SCHEMA_VERS, db_vers);\n\t\t\tdb_schema_err = 1;\n\t\t} else\n\t\t\tDPRINTF(HGD_D_INFO, \"Database schema version \"\n\t\t\t    \"is good: needed '%s', got '%d'\",\n\t\t\t    HGD_DB_SCHEMA_VERS, db_vers);\n\n\t\tif (db_schema_err) {\n\t\t\tDPRINTF(HGD_D_ERROR, \"If you are happy to lose your \"\n\t\t\t\t\"database,you can make a new one with: \"\n\t\t\t\t\"'hgd-admin db-init'\");\n\t\t\tsqlite3_close(db);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (db);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* get the next track (if there is one) */\n", "func_signal": "int\nhgd_get_next_track(struct hgd_playlist_item *track)", "code": "{\n\tint\t\t\t sql_res;\n\n\tsql_res = sqlite3_exec(db,\n\t    \"SELECT id, filename, user \"\n\t    \"FROM playlist WHERE finished=0 LIMIT 1\",\n\t    hgd_get_next_track_cb, track, NULL);\n\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't get next track: %s\", DERROR);\n\t\treturn (HGD_FAIL);\n\t}\n\n\treturn (HGD_OK);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * The \"standard\" statusbar that the user sees 99% of the time\n */\n", "func_signal": "int\nhgd_set_standard_statusbar_text(struct ui *u)", "code": "{\n\treturn (hgd_set_statusbar_text(u,\n\t    \"Connected >>> %s@%s:%d   Vote: %d\", user, host, port, -1));\n}", "path": "nchgdc.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * get the contents of the playlist\n *\n * needs to lock database when we make\n * the playlist re-orderable.\n *\n * args:\n * ret: list of hgd.playlist.PlaylistItem\n */\n", "func_signal": "static PyObject *\nhgd_py_meth_Hgd_get_playlist(Hgd *self)", "code": "{\n\tstruct hgd_playlist\t  list;\n\tstruct hgd_playlist_item *it;\n\tunsigned int\t\t  i, err = 0, free_playlist = 0;\n\tPyObject\t\t *rec = NULL, *ret_list = NULL;\n\tPyObject\t\t *plist_item = NULL;\n\tPyObject\t\t *ctor = NULL, *args = NULL;\n\n\t(void) self;\n\n\tif (hgd_get_playlist(&list) == HGD_FAIL) {\n\t\t(void) PyErr_Format(PyExc_RuntimeError,\n\t\t    \"Failed to get playlist from HGD\");\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\tfree_playlist = 1;\n\n\tret_list = PyList_New(list.n_items);\n\tif (!ret_list) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\t/* get ready to construct some stuff */\n\tctor = PyObject_GetAttrString(hgd_py_mods.playlist_mod, \"PlaylistItem\");\n\tif (!ctor) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\tif (!PyCallable_Check(ctor)) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\tfor (i = 0; i < list.n_items; i++) {\n\t\tit = list.items[i];\n\n\t\trec = Py_BuildValue(\"{sisssssssssssssisisisisi}\",\n\t\t    \"tid\", it->id,\n\t\t    \"filename\", it->filename,\n\t\t    \"tag_artist\", it->tags.artist,\n\t\t    \"tag_title\", it->tags.title,\n\t\t    \"user\", it->user,\n\t\t    \"album\", it->tags.album,\n\t\t    \"genre\", it->tags.genre,\n\t\t    \"duration\", it->tags.duration,\n\t\t    \"bitrate\", it->tags.bitrate,\n\t\t    \"samplerate\", it->tags.samplerate,\n\t\t    \"channels\", it->tags.channels,\n\t\t    \"year\", it->tags.year);\n\n\t\tif (rec == NULL) {\n\t\t\terr = 1;\n\t\t\tgoto clean;\n\t\t}\n\n\t\targs = Py_BuildValue(\"(O)\", rec);\n\t\tif (args == NULL) {\n\t\t\terr = 1;\n\t\t\tgoto clean;\n\t\t}\n\n\t\tplist_item = PyObject_CallObject(ctor, args);\n\t\tPy_XDECREF(args);\n\t\tPy_XDECREF(rec);\n\t\tif (plist_item == NULL) {\n\t\t\terr = 1;\n\t\t\tgoto clean;\n\t\t}\n\n\t\t/* steals ref */\n\t\tif (PyList_SetItem(ret_list, i, plist_item) != 0) {\n\t\t\terr = 1;\n\t\t\tgoto clean;\n\t\t}\n\t}\n\nclean:\n\tPy_XDECREF(ctor);\n\tif (free_playlist)\n\t\thgd_free_playlist(&list);\n\n\tif (err)\n\t\treturn (NULL);\n\treturn (ret_list);\n}", "path": "py.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * get a user account and return\n *\n * caller must free dynamic fields\n */\n", "func_signal": "int\nhgd_get_user(char *user, struct hgd_user *result)", "code": "{\n\tint\t\t\t sql_res, res = HGD_OK;\n\tsqlite3_stmt\t\t*stmt;\n\tchar\t\t\t*sql = \"SELECT username, perms FROM users WHERE username=?\";\n\n\tDPRINTF(HGD_D_DEBUG, \"Getting user info for '%s'\", user);\n\n\tsql_res = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't prepare sql: %s\", DERROR);\n\t\tres = HGD_FAIL;\n\t\tgoto clean;\n\t}\n\n\t/* bind params */\n\tsql_res = sqlite3_bind_text(stmt, 1, user, -1, SQLITE_TRANSIENT);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't bind sql: %s\", DERROR);\n\t\tres = HGD_FAIL;\n\t\tgoto clean;\n\t}\n\n\tsql_res = sqlite3_step(stmt);\n\tif (sql_res == SQLITE_DONE) {\n\t\tDPRINTF(HGD_D_WARN, \"User '%s', does not exist\", user);\n\t\tres = HGD_FAIL_USRNOEXIST;\n\t\tgoto clean;\n\t} else if (sql_res != SQLITE_ROW) { /* we expect exactly one row */\n\t\tDPRINTF(HGD_D_WARN, \"Can't step sql: %s\", DERROR);\n\t\tres = HGD_FAIL;\n\t\tgoto clean;\n\t}\n\n\tresult->name = xstrdup((const char *) sqlite3_column_text(stmt, 0));\n\tresult->perms = sqlite3_column_int(stmt, 1);\n\nclean:\n\tsqlite3_finalize(stmt);\n\treturn (res);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* embed the Python interpreter */\n", "func_signal": "int\nhgd_embed_py(uint8_t enable_user_scripts)", "code": "{\n\tDIR\t\t\t*script_dir;\n\tstruct dirent\t\t*ent;\n\tPyObject\t\t*mod;\n\tchar\t\t\t*search_path;\n\tsize_t\t\t\t s_nm_len;\n\n\tDPRINTF(HGD_D_INFO, \"Initialising Python\");\n\n\tif (hgd_py_plugin_dir == NULL) {\n\t\thgd_py_plugin_dir = xstrdup(HGD_DFL_PY_PLUGIN_DIR);\n\t}\n\n\t/* ensure we find our modules */\n\txasprintf(&search_path, \"%s:%s:%s\",\n\t    DATAROOTDIR \"/hgd/pylib\", BUILD_DIR \"/pylib\",\n\t    hgd_py_plugin_dir);\n\tDPRINTF(HGD_D_DEBUG, \"Python search path is '%s'\", search_path);\n\n\tif (setenv(\"PYTHONPATH\", search_path, 0) == -1) {\n\t\tDPRINTF(HGD_D_ERROR,\n\t\t    \"Can't set python search path: %s\", SERROR);\n\t\tfree(search_path);\n\t\thgd_exit_nicely();\n\t}\n\tfree(search_path);\n\n\tPy_InitializeEx(0); /* 0, no sighandlers thanks */\n\tmemset(&hgd_py_mods, 0, sizeof(hgd_py_mods));\n\n\t/* import inspect for hgd.dprint */\n\tmod = PyImport_ImportModule(\"inspect\");\n\tif (!mod) {\n\t\tPRINT_PY_ERROR();\n\t\thgd_exit_nicely();\n\t}\n\thgd_py_mods.inspect_mod = mod;\n\n\t/* always import the hgd support stuff from hgd.py */\n\tmod = PyImport_ImportModule(\"hgd.playlist\");\n\tif (!mod) {\n\t\tPRINT_PY_ERROR();\n\t\thgd_exit_nicely();\n\t}\n\thgd_py_mods.playlist_mod = mod;\n\n\t/* if we want to enable user scripts */\n\tif (enable_user_scripts) {\n\n\t\tscript_dir = opendir(hgd_py_plugin_dir);\n\t\tif (script_dir == NULL) {\n\t\t\tDPRINTF(HGD_D_WARN, \"Can't read script dir '%s': %s\",\n\t\t\t   hgd_py_plugin_dir, SERROR);\n\t\t}\n\n\t\t/* loop over user script dir loading modules for hooks */\n\t\twhile ((script_dir != NULL)\n\t\t    && (ent = readdir(script_dir)) != NULL) {\n\n\t\t\tif ((strcmp(ent->d_name, \".\") == 0) ||\n\t\t\t    (strcmp(ent->d_name, \"..\") == 0) ||\n\t\t\t    (strcmp(ent->d_name, \"hgd.py\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (hgd_py_mods.n_user_mods == HGD_MAX_PY_MODS) {\n\t\t\t\tDPRINTF(HGD_D_WARN,\n\t\t\t\t    \"Too many python modules loaded\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts_nm_len = strlen(ent->d_name);\n\t\t\tif (s_nm_len < 4) {\n\t\t\t\tDPRINTF(HGD_D_INFO,\n\t\t\t\t    \"skipping '%s', filename too short\",\n\t\t\t\t    ent->d_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* scripts must end '.py' */\n\t\t\tif ((ent->d_name[s_nm_len - 1] != 'y') ||\n\t\t\t    (ent->d_name[s_nm_len - 2] != 'p') ||\n\t\t\t    (ent->d_name[s_nm_len - 3] != '.')) {\n\t\t\t\tDPRINTF(HGD_D_INFO,\n\t\t\t\t    \"skipping '%s', not a '.py' suffix\",\n\t\t\t\t    ent->d_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove .py  suffix */\n\t\t\tent->d_name[s_nm_len - 3] = 0;\n\n\t\t\t/* load */\n\t\t\tDPRINTF(HGD_D_DEBUG, \"Loading '%s'\", ent->d_name);\n\t\t\tmod = PyImport_ImportModule(ent->d_name);\n\t\t\tif (!mod) {\n\t\t\t\tPRINT_PY_ERROR();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thgd_py_mods.user_mods[hgd_py_mods.n_user_mods] = mod;\n\t\t\thgd_py_mods.user_mod_names[hgd_py_mods.n_user_mods] =\n\t\t\t    xstrdup(ent->d_name);\n\t\t\thgd_py_mods.n_user_mods++;\n\t\t}\n\t\tDPRINTF(HGD_D_INFO,\n\t\t    \"Loaded %d user scripts.\", hgd_py_mods.n_user_mods);\n\n\tif (script_dir != NULL)\t(void) closedir(script_dir);\n\n\t} /* if enable_user_scripts */\n\n\t/* init hgd module and stash an instance */\n\thgd_init_hgd_mod();\n\thgd_py_mods.hgd_o = hgd_py_meth_Hgd_new(&HgdType, NULL, NULL);\n\n\thgd_execute_py_hook(\"init\");\n\n\treturn (HGD_OK);\n}", "path": "py.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * add a user to the database (pre salted and hashed)\n *\n * you probably want hgd_user_add() from admin.c\n */\n", "func_signal": "int\nhgd_user_add_db(char *user, char *salt, char *hash)", "code": "{\n\tint\t\t\t sql_res, ret = HGD_FAIL;\n\tsqlite3_stmt\t\t*stmt;\n\tchar\t\t\t*sql = \"INSERT INTO users \"\n\t\t\t\t   \"(username, salt, hash, perms) \"\n\t\t\t\t   \" VALUES (?, ?, ?, 0)\";\n\n\tsql_res = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't prepare sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\t/* bind params */\n\tsql_res = sqlite3_bind_text(stmt, 1, user, -1, SQLITE_TRANSIENT);\n\tsql_res |= sqlite3_bind_text(stmt, 2, salt, -1, SQLITE_TRANSIENT);\n\tsql_res |= sqlite3_bind_text(stmt, 3, hash, -1, SQLITE_TRANSIENT);\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't bind sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tsql_res = sqlite3_step(stmt);\n\tif (sql_res == SQLITE_CONSTRAINT) {\n\t\tDPRINTF(HGD_D_ERROR, \"User '%s' already exists\", user);\n\t\tret = HGD_FAIL_USREXIST;\n\t\tgoto clean;\n\t} else if (sql_res != SQLITE_DONE) {\n\t\tDPRINTF(HGD_D_WARN, \"Can't step sql: %s\", DERROR);\n\t\tgoto clean;\n\t}\n\n\tret = HGD_OK;\nclean:\n\tsqlite3_finalize(stmt);\n\treturn (ret);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* XXX this sucks, use memset, strncpy */\n", "func_signal": "int\nhgd_prepare_item_string(char **ret_p, char *str)", "code": "{\n\tint\t\t\tsz = 0, written = 0, i;\n\tchar\t\t\t*p = str, *c, *ret;\n\n\t/* We will be padding this up to UI width */\n\t*ret_p = xmalloc(COLS + 1);\n\tret = *ret_p;\n\n\tmemset(ret, ' ', COLS);\n\tret[COLS] = 0;\n\n\t/* count how large the string should be */\n\tp = str;\n\tc = ret;\n\twhile (written <= COLS) {\n\n\t\tif (*p == '\\0')\n\t\t\tbreak; /* done */\n\n\t\tif (*p == '\\t')\n\t\t\tsz = 4;\n\t\telse\n\t\t\tsz = 1;\n\n\t\tif (written + sz > COLS)\n\t\t\tbreak; /* that is all we would be able to cram in */\n\n\t\tif (sz == 1) { /* thus a non-tab */\n\t\t\tif ((*p == '\\n') || (*p == '\\r'))\n\t\t\t\t*p = '^';\n\t\t\t*c++ = *p;\n\t\t\twritten++;\n\t\t} else { /* thus a tab, which expands to 4 spaces */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t*c = ' ';\n\t\t\t\tc++;\n\t\t\t\twritten++;\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n\n\treturn (HGD_OK);\n}", "path": "nchgdc.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * clean up, exit. if exit_ok = 0, an error (signal/error)\n */\n", "func_signal": "void\nhgd_exit_nicely()", "code": "{\n\tif (!exit_ok)\n\t\tDPRINTF(HGD_D_ERROR, \"hgd-playd was interrupted or crashed\\n\");\n\n\tif (mplayer_fifo_path)\n\t\tfree(mplayer_fifo_path);\n\tif (db)\n\t\tsqlite3_close(db);\n\tif (state_path)\n\t\tfree(state_path);\n\tif (db_path)\n\t\tfree (db_path);\n\tif (filestore_path)\n\t\tfree(filestore_path);\n\n#ifdef HAVE_PYTHON\n\thgd_free_py();\n#endif\n\n\t/* before syslog goes down */\n\tif (restarting)\n\t\thgd_restart_myself();\n\n\tHGD_CLOSE_SYSLOG();\n\n\texit (!exit_ok);\n}", "path": "hgd-playd.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* get all users from the db, caler must free */\n", "func_signal": "struct hgd_user_list *\nhgd_get_all_users()", "code": "{\n\tint\t\t\t sql_res;\n\tstruct hgd_user_list\t*list = xcalloc(1, sizeof(struct hgd_user_list));\n\n\tsql_res = sqlite3_exec(db,\n\t    \"SELECT username, perms FROM users\",\n\t    hgd_get_all_users_cb, list, NULL);\n\n\tif (sql_res != SQLITE_OK) {\n\t\tDPRINTF(HGD_D_ERROR, \"Can't get users: %s\", DERROR);\n\t\treturn (NULL);\n\t}\n\n\treturn (list);\n}", "path": "db.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/* __init__ */\n", "func_signal": "static int\nhgd_py_meth_Hgd_init(Hgd *self, PyObject *args, PyObject *kwds)", "code": "{\n\tDPRINTF(HGD_D_INFO, \"__init__ hgd object\");\n\n\t/* quiet */\n\t(void)self;\n\t(void)args;\n\t(void)kwds;\n\n\tself->proto_version_major = 0;\n\tself->proto_version_minor = 0;\n\tself->debug_level = 0;\n\tself->component = Py_None;\n\tself->hgd_version = Py_None;\n\n\treturn (0);\n}", "path": "py.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * debug message\n *\n * args: level, message\n * ret:\n */\n", "func_signal": "static PyObject *\nhgd_py_func_dprint(PyObject *self, PyObject *args)", "code": "{\n\tPyObject\t\t*f_currentframe = NULL, *f_getframeinfo = NULL;\n\tPyObject\t\t*currentframe = NULL, *frameinfo = NULL;\n\tPyObject\t\t*a_getframeinfo = NULL, *arg1 = NULL;\n\tPyObject\t\t*file = NULL, *line = NULL, *str_arg1 = NULL;\n\tPyObject\t\t*meth = NULL;\n\tlong\t\t\t level;\n\tint\t\t\t err = 0;\n\n\t(void)self;\n\n\tif (PyArg_ParseTuple(args, \"lO\", &level, &arg1) == 0) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\t/* silent if debug level not high enough */\n\tif (level > hgd_debug)\n\t\tgoto clean;\n\n\t/* get current frame */\n\tf_currentframe = PyObject_GetAttrString(\n\t    hgd_py_mods.inspect_mod, \"currentframe\");\n\tif (!f_currentframe) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\tDPRINTF(HGD_D_INFO, \"Calling currentframe()\");\n\tcurrentframe = PyObject_CallObject(f_currentframe, NULL);\n\tif (currentframe == NULL) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\t/* get frame info */\n\tf_getframeinfo = PyObject_GetAttrString(\n\t    hgd_py_mods.inspect_mod, \"getframeinfo\");\n\tif (!f_getframeinfo) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\ta_getframeinfo = Py_BuildValue(\"(O)\", currentframe);\n\tif (a_getframeinfo == NULL) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\tDPRINTF(HGD_D_INFO, \"Calling getframeinfo()\");\n\tframeinfo = PyObject_CallObject(f_getframeinfo, a_getframeinfo);\n\tif (frameinfo == NULL) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\t/* don't decref these, borrowed from frameinfo */\n\tfile = PyTuple_GetItem(frameinfo, 0);\n\tline = PyTuple_GetItem(frameinfo, 1);\n\tmeth = PyTuple_GetItem(frameinfo, 2);\n\n\t/* Convert the message to a string */\n\targ1 = PyTuple_GetItem(args, 1);\n\tstr_arg1 = PyObject_Str(arg1);\n\tif (!str_arg1) {\n\t\terr = 1;\n\t\tgoto clean;\n\t}\n\n\tfprintf(stderr, \"[Python: %s - %08d %s:%s():%ld]\\n\\t%s\\n\",\n\t    debug_names[level],\n\t    getpid(),\n\t    PyString_AsString(file),\n\t    PyString_AsString(meth),\n\t    PyLong_AsLong(line),\n\t    PyString_AsString(str_arg1));\n\nclean:\n\tPy_XDECREF(f_currentframe);\n\tPy_XDECREF(frameinfo);\n\tPy_XDECREF(currentframe);\n\tPy_XDECREF(f_getframeinfo);\n\tPy_XDECREF(a_getframeinfo);\n\tPy_XDECREF(str_arg1);\n\n\tif (!err)\n\t\tPy_RETURN_NONE;\n\treturn (NULL);\n}", "path": "py.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*\n * clean up, exit. if exit_ok = 0, an error (signal/error)\n */\n", "func_signal": "void\nhgd_exit_nicely(void)", "code": "{\n\tif (!exit_ok)\n\t\tDPRINTF(HGD_D_ERROR, \"hgd-playd was interrupted or crashed\\n\");\n\n\thgd_free_py();\n\n\tHGD_CLOSE_SYSLOG();\n\n\texit (!exit_ok);\n}", "path": "hgd-mk-pydoc.c", "repo_name": "vext01/hgd", "stars": 21, "license": "isc", "language": "c", "size": 1745}
{"docstring": "/*****************************************************************************/\n/*\n * search the given keyring only (no recursion)\n * - keyring must be locked by caller\n * - caller must guarantee that the keyring is a keyring\n */\n", "func_signal": "key_ref_t __keyring_search_one(key_ref_t keyring_ref,\n\t\t\t       const struct key_type *ktype,\n\t\t\t       const char *description,\n\t\t\t       key_perm_t perm)", "code": "{\n\tstruct keyring_list *klist;\n\tunsigned long possessed;\n\tstruct key *keyring, *key;\n\tint loop;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tpossessed = is_key_possessed(keyring_ref);\n\n\trcu_read_lock();\n\n\tklist = rcu_dereference(keyring->payload.subscriptions);\n\tif (klist) {\n\t\tfor (loop = 0; loop < klist->nkeys; loop++) {\n\t\t\tkey = klist->keys[loop];\n\n\t\t\tif (key->type == ktype &&\n\t\t\t    (!key->type->match ||\n\t\t\t     key->type->match(key, description)) &&\n\t\t\t    key_permission(make_key_ref(key, possessed),\n\t\t\t\t\t   perm) == 0 &&\n\t\t\t    !test_bit(KEY_FLAG_REVOKED, &key->flags)\n\t\t\t    )\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOKEY);\n\nfound:\n\tatomic_inc(&key->usage);\n\trcu_read_unlock();\n\treturn make_key_ref(key, possessed);\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * find a keyring with the specified name\n * - all named keyrings are searched\n * - normally only finds keyrings with search permission for the current process\n */\n", "func_signal": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)", "code": "{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!atomic_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * search the supplied keyring tree for a key that matches the criterion\n * - perform a breadth-then-depth search up to the prescribed limit\n * - we only find keys on which we have search permission\n * - we use the supplied match function to see if the description (or other\n *   feature of interest) matches\n * - we rely on RCU to prevent the keyring lists from disappearing on us\n * - we return -EAGAIN if we didn't find any matching key\n * - we return -ENOKEY if we only found negative matching keys\n * - we propagate the possession attribute from the keyring ref to the key ref\n */\n", "func_signal": "key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     const struct cred *cred,\n\t\t\t     struct key_type *type,\n\t\t\t     const void *description,\n\t\t\t     key_match_func_t match)", "code": "{\n\tstruct {\n\t\tstruct keyring_list *keylist;\n\t\tint kix;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct keyring_list *keylist;\n\tstruct timespec now;\n\tunsigned long possessed, kflags;\n\tstruct key *keyring, *key;\n\tkey_ref_t key_ref;\n\tlong err;\n\tint sp, kix;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tpossessed = is_key_possessed(keyring_ref);\n\tkey_check(keyring);\n\n\t/* top keyring must have search permission to begin the search */\n\terr = key_task_permission(keyring_ref, cred, KEY_SEARCH);\n\tif (err < 0) {\n\t\tkey_ref = ERR_PTR(err);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error;\n\n\trcu_read_lock();\n\n\tnow = current_kernel_time();\n\terr = -EAGAIN;\n\tsp = 0;\n\n\t/* firstly we should check to see if this top-level keyring is what we\n\t * are looking for */\n\tkey_ref = ERR_PTR(-EAGAIN);\n\tkflags = keyring->flags;\n\tif (keyring->type == type && match(keyring, description)) {\n\t\tkey = keyring;\n\n\t\t/* check it isn't negative and hasn't expired or been\n\t\t * revoked */\n\t\tif (kflags & (1 << KEY_FLAG_REVOKED))\n\t\t\tgoto error_2;\n\t\tif (key->expiry && now.tv_sec >= key->expiry)\n\t\t\tgoto error_2;\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE))\n\t\t\tgoto error_2;\n\t\tgoto found;\n\t}\n\n\t/* otherwise, the top keyring must not be revoked, expired, or\n\t * negatively instantiated if we are to search it */\n\tkey_ref = ERR_PTR(-EAGAIN);\n\tif (kflags & ((1 << KEY_FLAG_REVOKED) | (1 << KEY_FLAG_NEGATIVE)) ||\n\t    (keyring->expiry && now.tv_sec >= keyring->expiry))\n\t\tgoto error_2;\n\n\t/* start processing a new keyring */\ndescend:\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto not_this_keyring;\n\n\tkeylist = rcu_dereference(keyring->payload.subscriptions);\n\tif (!keylist)\n\t\tgoto not_this_keyring;\n\n\t/* iterate through the keys in this keyring first */\n\tfor (kix = 0; kix < keylist->nkeys; kix++) {\n\t\tkey = keylist->keys[kix];\n\t\tkflags = key->flags;\n\n\t\t/* ignore keys not of this type */\n\t\tif (key->type != type)\n\t\t\tcontinue;\n\n\t\t/* skip revoked keys and expired keys */\n\t\tif (kflags & (1 << KEY_FLAG_REVOKED))\n\t\t\tcontinue;\n\n\t\tif (key->expiry && now.tv_sec >= key->expiry)\n\t\t\tcontinue;\n\n\t\t/* keys that don't match */\n\t\tif (!match(key, description))\n\t\t\tcontinue;\n\n\t\t/* key must have search permissions */\n\t\tif (key_task_permission(make_key_ref(key, possessed),\n\t\t\t\t\tcred, KEY_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\terr = -ENOKEY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgoto found;\n\t}\n\n\t/* search through the keyrings nested in this one */\n\tkix = 0;\nascend:\n\tfor (; kix < keylist->nkeys; kix++) {\n\t\tkey = keylist->keys[kix];\n\t\tif (key->type != &key_type_keyring)\n\t\t\tcontinue;\n\n\t\t/* recursively search nested keyrings\n\t\t * - only search keyrings for which we have search permission\n\t\t */\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH)\n\t\t\tcontinue;\n\n\t\tif (key_task_permission(make_key_ref(key, possessed),\n\t\t\t\t\tcred, KEY_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keylist = keylist;\n\t\tstack[sp].kix = kix;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend;\n\t}\n\n\t/* the keyring we're looking at was disqualified or didn't contain a\n\t * matching key */\nnot_this_keyring:\n\tif (sp > 0) {\n\t\t/* resume the processing of a keyring higher up in the tree */\n\t\tsp--;\n\t\tkeylist = stack[sp].keylist;\n\t\tkix = stack[sp].kix + 1;\n\t\tgoto ascend;\n\t}\n\n\tkey_ref = ERR_PTR(err);\n\tgoto error_2;\n\n\t/* we found a viable match */\nfound:\n\tatomic_inc(&key->usage);\n\tkey_check(key);\n\tkey_ref = make_key_ref(key, possessed);\nerror_2:\n\trcu_read_unlock();\nerror:\n\treturn key_ref;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * Collect garbage from the contents of a keyring\n */\n", "func_signal": "void keyring_gc(struct key *keyring, time_t limit)", "code": "{\n\tstruct keyring_list *klist, *new;\n\tstruct key *key;\n\tint loop, keep, max;\n\n\tkenter(\"{%x,%s}\", key_serial(keyring), keyring->description);\n\n\tdown_write(&keyring->sem);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\tif (!klist)\n\t\tgoto no_klist;\n\n\t/* work out how many subscriptions we're keeping */\n\tkeep = 0;\n\tfor (loop = klist->nkeys - 1; loop >= 0; loop--)\n\t\tif (!key_is_dead(klist->keys[loop], limit))\n\t\t\tkeep++;\n\n\tif (keep == klist->nkeys)\n\t\tgoto just_return;\n\n\t/* allocate a new keyring payload */\n\tmax = roundup(keep, 4);\n\tnew = kmalloc(sizeof(struct keyring_list) + max * sizeof(struct key *),\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\tgoto nomem;\n\tnew->maxkeys = max;\n\tnew->nkeys = 0;\n\tnew->delkey = 0;\n\n\t/* install the live keys\n\t * - must take care as expired keys may be updated back to life\n\t */\n\tkeep = 0;\n\tfor (loop = klist->nkeys - 1; loop >= 0; loop--) {\n\t\tkey = klist->keys[loop];\n\t\tif (!key_is_dead(key, limit)) {\n\t\t\tif (keep >= max)\n\t\t\t\tgoto discard_new;\n\t\t\tnew->keys[keep++] = key_get(key);\n\t\t}\n\t}\n\tnew->nkeys = keep;\n\n\t/* adjust the quota */\n\tkey_payload_reserve(keyring,\n\t\t\t    sizeof(struct keyring_list) +\n\t\t\t    KEYQUOTA_LINK_BYTES * keep);\n\n\tif (keep == 0) {\n\t\trcu_assign_pointer(keyring->payload.subscriptions, NULL);\n\t\tkfree(new);\n\t} else {\n\t\trcu_assign_pointer(keyring->payload.subscriptions, new);\n\t}\n\n\tup_write(&keyring->sem);\n\n\tcall_rcu(&klist->rcu, keyring_clear_rcu_disposal);\n\tkleave(\" [yes]\");\n\treturn;\n\ndiscard_new:\n\tnew->nkeys = keep;\n\tkeyring_clear_rcu_disposal(&new->rcu);\n\tup_write(&keyring->sem);\n\tkleave(\" [discard]\");\n\treturn;\n\njust_return:\n\tup_write(&keyring->sem);\n\tkleave(\" [no dead]\");\n\treturn;\n\nno_klist:\n\tup_write(&keyring->sem);\n\tkleave(\" [no_klist]\");\n\treturn;\n\nnomem:\n\tup_write(&keyring->sem);\n\tkleave(\" [oom]\");\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * match keyrings on their name\n */\n", "func_signal": "static int keyring_match(const struct key *keyring, const void *description)", "code": "{\n\treturn keyring->description &&\n\t\tstrcmp(keyring->description, description) == 0;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * see if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A)\n * - since we are adding B to A at the top level, checking for cycles should\n *   just be a matter of seeing if node A is somewhere in tree B\n */\n", "func_signal": "static int keyring_detect_cycle(struct key *A, struct key *B)", "code": "{\n\tstruct {\n\t\tstruct keyring_list *keylist;\n\t\tint kix;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct keyring_list *keylist;\n\tstruct key *subtree, *key;\n\tint sp, kix, ret;\n\n\trcu_read_lock();\n\n\tret = -EDEADLK;\n\tif (A == B)\n\t\tgoto cycle_detected;\n\n\tsubtree = B;\n\tsp = 0;\n\n\t/* start processing a new keyring */\ndescend:\n\tif (test_bit(KEY_FLAG_REVOKED, &subtree->flags))\n\t\tgoto not_this_keyring;\n\n\tkeylist = rcu_dereference(subtree->payload.subscriptions);\n\tif (!keylist)\n\t\tgoto not_this_keyring;\n\tkix = 0;\n\nascend:\n\t/* iterate through the remaining keys in this keyring */\n\tfor (; kix < keylist->nkeys; kix++) {\n\t\tkey = keylist->keys[kix];\n\n\t\tif (key == A)\n\t\t\tgoto cycle_detected;\n\n\t\t/* recursively check nested keyrings */\n\t\tif (key->type == &key_type_keyring) {\n\t\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH)\n\t\t\t\tgoto too_deep;\n\n\t\t\t/* stack the current position */\n\t\t\tstack[sp].keylist = keylist;\n\t\t\tstack[sp].kix = kix;\n\t\t\tsp++;\n\n\t\t\t/* begin again with the new keyring */\n\t\t\tsubtree = key;\n\t\t\tgoto descend;\n\t\t}\n\t}\n\n\t/* the keyring we're looking at was disqualified or didn't contain a\n\t * matching key */\nnot_this_keyring:\n\tif (sp > 0) {\n\t\t/* resume the checking of a keyring higher up in the tree */\n\t\tsp--;\n\t\tkeylist = stack[sp].keylist;\n\t\tkix = stack[sp].kix + 1;\n\t\tgoto ascend;\n\t}\n\n\tret = 0; /* no cycles detected */\n\nerror:\n\trcu_read_unlock();\n\treturn ret;\n\ntoo_deep:\n\tret = -ELOOP;\n\tgoto error;\n\ncycle_detected:\n\tret = -EDEADLK;\n\tgoto error;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * read a list of key IDs from the keyring's contents\n * - the keyring's semaphore is read-locked\n */\n", "func_signal": "static long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)", "code": "{\n\tstruct keyring_list *klist;\n\tstruct key *key;\n\tsize_t qty, tmp;\n\tint loop, ret;\n\n\tret = 0;\n\tklist = rcu_dereference_locked_keyring(keyring);\n\tif (klist) {\n\t\t/* calculate how much data we could return */\n\t\tqty = klist->nkeys * sizeof(key_serial_t);\n\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > qty)\n\t\t\t\tbuflen = qty;\n\n\t\t\t/* copy the IDs of the subscribed keys into the\n\t\t\t * buffer */\n\t\t\tret = -EFAULT;\n\n\t\t\tfor (loop = 0; loop < klist->nkeys; loop++) {\n\t\t\t\tkey = klist->keys[loop];\n\n\t\t\t\ttmp = sizeof(key_serial_t);\n\t\t\t\tif (tmp > buflen)\n\t\t\t\t\ttmp = buflen;\n\n\t\t\t\tif (copy_to_user(buffer,\n\t\t\t\t\t\t &key->serial,\n\t\t\t\t\t\t tmp) != 0)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tbuflen -= tmp;\n\t\t\t\tif (buflen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuffer += tmp;\n\t\t\t}\n\t\t}\n\n\t\tret = qty;\n\t}\n\nerror:\n\treturn ret;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * dispose of a keyring list after the RCU grace period, releasing the keys it\n * links to\n */\n", "func_signal": "static void keyring_clear_rcu_disposal(struct rcu_head *rcu)", "code": "{\n\tstruct keyring_list *klist;\n\tint loop;\n\n\tklist = container_of(rcu, struct keyring_list, rcu);\n\n\tfor (loop = klist->nkeys - 1; loop >= 0; loop--)\n\t\tkey_put(klist->keys[loop]);\n\n\tkfree(klist);\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * initialise a keyring\n * - we object if we were given any data\n */\n", "func_signal": "static int keyring_instantiate(struct key *keyring,\n\t\t\t       const void *data, size_t datalen)", "code": "{\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen == 0) {\n\t\t/* make the keyring available by name if it has one */\n\t\tkeyring_publish_name(keyring);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * check already instantiated keys aren't going to be a problem\n * - the caller must have called __key_link_begin()\n * - don't need to call this for keys that were created since __key_link_begin()\n *   was called\n */\n", "func_signal": "int __key_link_check_live_key(struct key *keyring, struct key *key)", "code": "{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * Determine whether a key is dead\n */\n", "func_signal": "static bool key_is_dead(struct key *key, time_t limit)", "code": "{\n\treturn test_bit(KEY_FLAG_DEAD, &key->flags) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * link a key into to a keyring\n * - must be called with __key_link_begin() having being called\n * - discard already extant link to matching key if there is one\n */\n", "func_signal": "void __key_link(struct key *keyring, struct key *key,\n\t\tstruct keyring_list **_prealloc)", "code": "{\n\tstruct keyring_list *klist, *nklist;\n\n\tnklist = *_prealloc;\n\t*_prealloc = NULL;\n\n\tkenter(\"%d,%d,%p\", keyring->serial, key->serial, nklist);\n\n\tklist = rcu_dereference_protected(keyring->payload.subscriptions,\n\t\t\t\t\t  rwsem_is_locked(&keyring->sem));\n\n\tatomic_inc(&key->usage);\n\n\t/* there's a matching key we can displace or an empty slot in a newly\n\t * allocated list we can fill */\n\tif (nklist) {\n\t\tkdebug(\"replace %hu/%hu/%hu\",\n\t\t       nklist->delkey, nklist->nkeys, nklist->maxkeys);\n\n\t\tnklist->keys[nklist->delkey] = key;\n\n\t\trcu_assign_pointer(keyring->payload.subscriptions, nklist);\n\n\t\t/* dispose of the old keyring list and, if there was one, the\n\t\t * displaced key */\n\t\tif (klist) {\n\t\t\tkdebug(\"dispose %hu/%hu/%hu\",\n\t\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\t\t\tcall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\n\t\t}\n\t} else {\n\t\t/* there's sufficient slack space to append directly */\n\t\tklist->keys[klist->nkeys] = key;\n\t\tsmp_wmb();\n\t\tklist->nkeys++;\n\t}\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * allocate a keyring and link into the destination keyring\n */\n", "func_signal": "struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,\n\t\t\t  const struct cred *cred, unsigned long flags,\n\t\t\t  struct key *dest)", "code": "{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred,\n\t\t\t    (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL,\n\t\t\t    flags);\n\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * unlink the first link to a key from a keyring\n */\n", "func_signal": "int key_unlink(struct key *keyring, struct key *key)", "code": "{\n\tstruct keyring_list *klist, *nklist;\n\tint loop, ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = -ENOTDIR;\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error;\n\n\tdown_write(&keyring->sem);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\tif (klist) {\n\t\t/* search the keyring for the key */\n\t\tfor (loop = 0; loop < klist->nkeys; loop++)\n\t\t\tif (klist->keys[loop] == key)\n\t\t\t\tgoto key_is_present;\n\t}\n\n\tup_write(&keyring->sem);\n\tret = -ENOENT;\n\tgoto error;\n\nkey_is_present:\n\t/* we need to copy the key list for RCU purposes */\n\tnklist = kmalloc(sizeof(*klist) +\n\t\t\t sizeof(struct key *) * klist->maxkeys,\n\t\t\t GFP_KERNEL);\n\tif (!nklist)\n\t\tgoto nomem;\n\tnklist->maxkeys = klist->maxkeys;\n\tnklist->nkeys = klist->nkeys - 1;\n\n\tif (loop > 0)\n\t\tmemcpy(&nklist->keys[0],\n\t\t       &klist->keys[0],\n\t\t       loop * sizeof(struct key *));\n\n\tif (loop < nklist->nkeys)\n\t\tmemcpy(&nklist->keys[loop],\n\t\t       &klist->keys[loop + 1],\n\t\t       (nklist->nkeys - loop) * sizeof(struct key *));\n\n\t/* adjust the user's quota */\n\tkey_payload_reserve(keyring,\n\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\n\trcu_assign_pointer(keyring->payload.subscriptions, nklist);\n\n\tup_write(&keyring->sem);\n\n\t/* schedule for later cleanup */\n\tklist->delkey = loop;\n\tcall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\n\n\tret = 0;\n\nerror:\n\treturn ret;\nnomem:\n\tret = -ENOMEM;\n\tup_write(&keyring->sem);\n\tgoto error;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * dispose of the data dangling from the corpse of a keyring\n */\n", "func_signal": "static void keyring_destroy(struct key *keyring)", "code": "{\n\tstruct keyring_list *klist;\n\tint loop;\n\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->type_data.link.next != NULL &&\n\t\t    !list_empty(&keyring->type_data.link))\n\t\t\tlist_del(&keyring->type_data.link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tklist = rcu_dereference_check(keyring->payload.subscriptions,\n\t\t\t\t      rcu_read_lock_held() ||\n\t\t\t\t      atomic_read(&keyring->usage) == 0);\n\tif (klist) {\n\t\tfor (loop = klist->nkeys - 1; loop >= 0; loop--)\n\t\t\tkey_put(klist->keys[loop]);\n\t\tkfree(klist);\n\t}\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * clear the specified process keyring\n * - implements keyctl(KEYCTL_CLEAR)\n */\n", "func_signal": "int keyring_clear(struct key *keyring)", "code": "{\n\tstruct keyring_list *klist;\n\tint ret;\n\n\tret = -ENOTDIR;\n\tif (keyring->type == &key_type_keyring) {\n\t\t/* detach the pointer block with the locks held */\n\t\tdown_write(&keyring->sem);\n\n\t\tklist = rcu_dereference_locked_keyring(keyring);\n\t\tif (klist) {\n\t\t\t/* adjust the quota */\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\t\t    sizeof(struct keyring_list));\n\n\t\t\trcu_assign_pointer(keyring->payload.subscriptions,\n\t\t\t\t\t   NULL);\n\t\t}\n\n\t\tup_write(&keyring->sem);\n\n\t\t/* free the keys after the locks have been dropped */\n\t\tif (klist)\n\t\t\tcall_rcu(&klist->rcu, keyring_clear_rcu_disposal);\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * link a key to a keyring\n */\n", "func_signal": "int key_link(struct key *keyring, struct key *key)", "code": "{\n\tstruct keyring_list *prealloc;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, key->type, key->description, &prealloc);\n\tif (ret == 0) {\n\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(keyring, key, &prealloc);\n\t\t__key_link_end(keyring, key->type, prealloc);\n\t}\n\n\treturn ret;\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * preallocate memory so that a key can be linked into to a keyring\n */\n", "func_signal": "int __key_link_begin(struct key *keyring, const struct key_type *type,\n\t\t     const char *description,\n\t\t     struct keyring_list **_prealloc)\n\t__acquires(&keyring->sem)", "code": "{\n\tstruct keyring_list *klist, *nklist;\n\tunsigned max;\n\tsize_t size;\n\tint loop, ret;\n\n\tkenter(\"%d,%s,%s,\", key_serial(keyring), type->name, description);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\n\t/* see if there's a matching key we can displace */\n\tif (klist && klist->nkeys > 0) {\n\t\tfor (loop = klist->nkeys - 1; loop >= 0; loop--) {\n\t\t\tif (klist->keys[loop]->type == type &&\n\t\t\t    strcmp(klist->keys[loop]->description,\n\t\t\t\t   description) == 0\n\t\t\t    ) {\n\t\t\t\t/* found a match - we'll replace this one with\n\t\t\t\t * the new key */\n\t\t\t\tsize = sizeof(struct key *) * klist->maxkeys;\n\t\t\t\tsize += sizeof(*klist);\n\t\t\t\tBUG_ON(size > PAGE_SIZE);\n\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tnklist = kmemdup(klist, size, GFP_KERNEL);\n\t\t\t\tif (!nklist)\n\t\t\t\t\tgoto error_sem;\n\n\t\t\t\t/* note replacement slot */\n\t\t\t\tklist->delkey = nklist->delkey = loop;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check that we aren't going to overrun the user's quota */\n\tret = key_payload_reserve(keyring,\n\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\tif (ret < 0)\n\t\tgoto error_sem;\n\n\tif (klist && klist->nkeys < klist->maxkeys) {\n\t\t/* there's sufficient slack space to append directly */\n\t\tnklist = NULL;\n\t} else {\n\t\t/* grow the key list */\n\t\tmax = 4;\n\t\tif (klist)\n\t\t\tmax += klist->maxkeys;\n\n\t\tret = -ENFILE;\n\t\tif (max > USHRT_MAX - 1)\n\t\t\tgoto error_quota;\n\t\tsize = sizeof(*klist) + sizeof(struct key *) * max;\n\t\tif (size > PAGE_SIZE)\n\t\t\tgoto error_quota;\n\n\t\tret = -ENOMEM;\n\t\tnklist = kmalloc(size, GFP_KERNEL);\n\t\tif (!nklist)\n\t\t\tgoto error_quota;\n\n\t\tnklist->maxkeys = max;\n\t\tif (klist) {\n\t\t\tmemcpy(nklist->keys, klist->keys,\n\t\t\t       sizeof(struct key *) * klist->nkeys);\n\t\t\tnklist->delkey = klist->nkeys;\n\t\t\tnklist->nkeys = klist->nkeys + 1;\n\t\t\tklist->delkey = USHRT_MAX;\n\t\t} else {\n\t\t\tnklist->nkeys = 1;\n\t\t\tnklist->delkey = 0;\n\t\t}\n\n\t\t/* add the key into the new space */\n\t\tnklist->keys[nklist->delkey] = NULL;\n\t}\n\ndone:\n\t*_prealloc = nklist;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_quota:\n\t/* undo the quota changes */\n\tkey_payload_reserve(keyring,\n\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\nerror_sem:\n\tif (type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*****************************************************************************/\n/*\n * publish the name of a keyring so that it can be found by name (if it has\n * one)\n */\n", "func_signal": "static void keyring_publish_name(struct key *keyring)", "code": "{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->type_data.link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n * dispose of a keyring list after the RCU grace period, freeing the unlinked\n * key\n */\n", "func_signal": "static void keyring_unlink_rcu_disposal(struct rcu_head *rcu)", "code": "{\n\tstruct keyring_list *klist =\n\t\tcontainer_of(rcu, struct keyring_list, rcu);\n\n\tif (klist->delkey != USHRT_MAX)\n\t\tkey_put(klist->keys[klist->delkey]);\n\tkfree(klist);\n}", "path": "security\\keys\\keyring.c", "repo_name": "BuzzBumbleBee/android_kernel_TF101", "stars": 16, "license": "other", "language": "c", "size": 108733}
{"docstring": "/*\n** Open math library\n*/\n", "func_signal": "LUALIB_API int luaopen_math (lua_State *L)", "code": "{\n  luaL_register(L, LUA_MATHLIBNAME, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n#if defined(LUA_COMPAT_MOD)\n  lua_getfield(L, -1, \"fmod\");\n  lua_setfield(L, -2, \"mod\");\n#endif\n  return 1;\n}", "path": "source\\lmathlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* LUA_NUMBER */\n", "func_signal": "static void read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  lua_assert(isdigit(ls->current));\n  do {\n    save_and_next(ls);\n  } while (isdigit(ls->current) || ls->current == '.');\n  if (check_next(ls, \"Ee\"))  /* `E'? */\n    check_next(ls, \"+-\");  /* optional exponent sign */\n  while (isalnum(ls->current) || ls->current == '_')\n    save_and_next(ls);\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}", "path": "source\\llex.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n* make header\n*/\n", "func_signal": "void luaU_header (char* h)", "code": "{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);\n h+=sizeof(LUA_SIGNATURE)-1;\n *h++=(char)LUAC_VERSION;\n *h++=(char)LUAC_FORMAT;\n *h++=(char)*(char*)&x;\t\t\t\t/* endianness */\n *h++=(char)sizeof(int);\n *h++=(char)sizeof(size_t);\n *h++=(char)sizeof(Instruction);\n *h++=(char)sizeof(lua_Number);\n *h++=(char)(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n}", "path": "source\\lundump.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)", "code": "{\n LoadState S;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n return LoadFunction(&S,luaS_newliteral(L,\"=?\"));\n}", "path": "source\\lundump.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\n", "func_signal": "const TValue *luaT_gettm (Table *events, TMS event, TString *ename)", "code": "{\n  const TValue *tm = luaH_getstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (ttisnil(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}", "path": "source\\ltm.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_ref (lua_State *L, int t)", "code": "{\n  int ref;\n  t = abs_index(L, t);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* `nil' has a unique fixed reference */\n  }\n  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */\n  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */\n  lua_pop(L, 1);  /* remove it from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */\n  }\n  else {  /* no free elements */\n    ref = (int)lua_objlen(L, t);\n    ref++;  /* create new reference */\n  }\n  lua_rawseti(L, t, ref);\n  return ref;\n}", "path": "source\\lauxlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "source\\lcode.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\n", "func_signal": "static const char *generic_reader (lua_State *L, void *ud, size_t *size)", "code": "{\n  (void)ud;  /* to avoid warnings */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    *size = 0;\n    return NULL;\n  }\n  else if (lua_isstring(L, -1)) {\n    lua_replace(L, 3);  /* save string in a reserved stack slot */\n    return lua_tolstring(L, 3, size);\n  }\n  else luaL_error(L, \"reader function must return a string\");\n  return NULL;  /* to avoid warnings */\n}", "path": "source\\lbaselib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** dump Lua function as precompiled chunk\n*/\n", "func_signal": "int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)", "code": "{\n DumpState D;\n D.L=L;\n D.writer=w;\n D.data=data;\n D.strip=strip;\n D.status=0;\n DumpHeader(&D);\n DumpFunction(f,NULL,&D);\n return D.status;\n}", "path": "source\\ldump.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n", "func_signal": "static int check_next (LexState *ls, const char *set)", "code": "{\n  if (!strchr(set, ls->current))\n    return 0;\n  save_and_next(ls);\n  return 1;\n}", "path": "source\\llex.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\n", "func_signal": "static int gctm (lua_State *L)", "code": "{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}", "path": "source\\loadlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* this function handles only `%d', `%c', %f, %p, and `%s' formats */\n", "func_signal": "const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp)", "code": "{\n  int n = 1;\n  pushstr(L, \"\");\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));\n    incr_top(L);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s);\n        break;\n      }\n      case 'c': {\n        char buff[2];\n        buff[0] = cast(char, va_arg(argp, int));\n        buff[1] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n      case 'd': {\n        setnvalue(L->top, cast_num(va_arg(argp, int)));\n        incr_top(L);\n        break;\n      }\n      case 'f': {\n        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));\n        incr_top(L);\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */\n        sprintf(buff, \"%p\", va_arg(argp, void *));\n        pushstr(L, buff);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\");\n        break;\n      }\n      default: {\n        char buff[3];\n        buff[0] = '%';\n        buff[1] = *(e+1);\n        buff[2] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  pushstr(L, fmt);\n  luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);\n  L->top -= n;\n  return svalue(L->top - 1);\n}", "path": "source\\lobject.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,\n                                                               const char *r)", "code": "{\n  const char *wild;\n  size_t l = strlen(p);\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(&b, s, wild - s);  /* push prefix */\n    luaL_addstring(&b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after `p' */\n  }\n  luaL_addstring(&b, s);  /* push last suffix */\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}", "path": "source\\lauxlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "source\\lcode.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,\n                                 const char *const lst[])", "code": "{\n  const char *name = (def) ? luaL_optstring(L, narg, def) :\n                             luaL_checkstring(L, narg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, narg,\n                       lua_pushfstring(L, \"invalid option \" LUA_QS, name));\n}", "path": "source\\lauxlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** If your system does not support `stdout', you can just remove this function.\n** If you need, you can define your own `print' function, following this\n** model but changing `fputs' to put the strings at a proper place\n** (a console window or a log file, for instance).\n*/\n", "func_signal": "static int luaB_print (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  lua_getglobal(L, \"tostring\");\n  for (i=1; i<=n; i++) {\n    const char *s;\n    lua_pushvalue(L, -1);  /* function to be called */\n    lua_pushvalue(L, i);   /* value to print */\n    lua_call(L, 1, 1);\n    s = lua_tostring(L, -1);  /* get result */\n    if (s == NULL)\n      return luaL_error(L, LUA_QL(\"tostring\") \" must return a string to \"\n                           LUA_QL(\"print\"));\n    if (i>1) fputs(\"\\t\", stdout);\n    fputs(s, stdout);\n    lua_pop(L, 1);  /* pop result */\n  }\n  fputs(\"\\n\", stdout);\n  return 0;\n}", "path": "source\\lbaselib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* converts back */\n", "func_signal": "int luaO_fb2int (int x)", "code": "{\n  int e = (x >> 3) & 31;\n  if (e == 0) return x;\n  else return ((x & 7)+8) << (e - 1);\n}", "path": "source\\lobject.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\n", "func_signal": "const char *luaF_getlocalname (const Proto *f, int local_number, int pc)", "code": "{\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}", "path": "source\\lfunc.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize)", "code": "{\n  (void)ud;\n  (void)osize;\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}", "path": "source\\lauxlib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void auxopen (lua_State *L, const char *name,\n                     lua_CFunction f, lua_CFunction u)", "code": "{\n  lua_pushcfunction(L, u);\n  lua_pushcclosure(L, f, 1);\n  lua_setfield(L, -2, name);\n}", "path": "source\\lbaselib.c", "repo_name": "namin/lua", "stars": 16, "license": "None", "language": "c", "size": 216}
{"docstring": "/* Do TAB completion */\n", "func_signal": "static void input_tab(smallint *lastWasTab)", "code": "{\n\tif (!(state->flags & TAB_COMPLETION))\n\t\treturn;\n\n\tif (!*lastWasTab) {\n\t\tchar *tmp, *tmp1;\n\t\tsize_t len_found;\n/*\t\tchar matchBuf[MAX_LINELEN]; */\n#define matchBuf (S.input_tab__matchBuf)\n\t\tint find_type;\n\t\tint recalc_pos;\n#if ENABLE_FEATURE_ASSUME_UNICODE\n\t\t/* cursor pos in command converted to multibyte form */\n\t\tint cursor_mb;\n#endif\n\n\t\t*lastWasTab = TRUE;             /* flop trigger */\n\n\t\t/* Make a local copy of the string --\n\t\t * up to the position of the cursor */\n\t\tsave_string(matchBuf, cursor + 1);\n#if ENABLE_FEATURE_ASSUME_UNICODE\n\t\tcursor_mb = strlen(matchBuf);\n#endif\n\t\ttmp = matchBuf;\n\n\t\tfind_type = find_match(matchBuf, &recalc_pos);\n\n\t\t/* Free up any memory already allocated */\n\t\tfree_tab_completion_data();\n\n#if ENABLE_FEATURE_USERNAME_COMPLETION\n\t\t/* If the word starts with `~' and there is no slash in the word,\n\t\t * then try completing this word as a username. */\n\t\tif (state->flags & USERNAME_COMPLETION)\n\t\t\tif (matchBuf[0] == '~' && strchr(matchBuf, '/') == NULL)\n\t\t\t\tusername_tab_completion(matchBuf, NULL);\n#endif\n\t\t/* Try to match any executable in our path and everything\n\t\t * in the current working directory */\n\t\tif (!matches)\n\t\t\texe_n_cwd_tab_completion(matchBuf, find_type);\n\t\t/* Sort, then remove any duplicates found */\n\t\tif (matches) {\n\t\t\tunsigned i;\n\t\t\tint n = 0;\n\t\t\tqsort_string_vector(matches, num_matches);\n\t\t\tfor (i = 0; i < num_matches - 1; ++i) {\n\t\t\t\tif (matches[i] && matches[i+1]) { /* paranoia */\n\t\t\t\t\tif (strcmp(matches[i], matches[i+1]) == 0) {\n\t\t\t\t\t\tfree(matches[i]);\n\t\t\t\t\t\tmatches[i] = NULL; /* paranoia */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatches[n++] = matches[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatches[n] = matches[i];\n\t\t\tnum_matches = n + 1;\n\t\t}\n\t\t/* Did we find exactly one match? */\n\t\tif (!matches || num_matches > 1) { /* no */\n\t\t\tbeep();\n\t\t\tif (!matches)\n\t\t\t\treturn;         /* not found */\n\t\t\t/* find minimal match */\n\t\t\ttmp1 = xstrdup(matches[0]);\n\t\t\tfor (tmp = tmp1; *tmp; tmp++) {\n\t\t\t\tfor (len_found = 1; len_found < num_matches; len_found++) {\n\t\t\t\t\tif (matches[len_found][tmp - tmp1] != *tmp) {\n\t\t\t\t\t\t*tmp = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*tmp1 == '\\0') {        /* have unique */\n\t\t\t\tfree(tmp1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttmp = add_quote_for_spec_chars(tmp1);\n\t\t\tfree(tmp1);\n\t\t} else {                        /* one match */\n\t\t\ttmp = add_quote_for_spec_chars(matches[0]);\n\t\t\t/* for next completion current found */\n\t\t\t*lastWasTab = FALSE;\n\n\t\t\tlen_found = strlen(tmp);\n\t\t\tif (tmp[len_found-1] != '/') {\n\t\t\t\ttmp[len_found] = ' ';\n\t\t\t\ttmp[len_found+1] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tlen_found = strlen(tmp);\n#if !ENABLE_FEATURE_ASSUME_UNICODE\n\t\t/* have space to place the match? */\n\t\t/* The result consists of three parts with these lengths: */\n\t\t/* (cursor - recalc_pos) + len_found + (command_len - cursor) */\n\t\t/* it simplifies into: */\n\t\tif ((int)(len_found + command_len - recalc_pos) < S.maxsize) {\n\t\t\t/* save tail */\n\t\t\tstrcpy(matchBuf, command_ps + cursor);\n\t\t\t/* add match and tail */\n\t\t\tsprintf(&command_ps[cursor - recalc_pos], \"%s%s\", tmp, matchBuf);\n\t\t\tcommand_len = strlen(command_ps);\n\t\t\t/* new pos */\n\t\t\trecalc_pos = cursor - recalc_pos + len_found;\n\t\t\t/* write out the matched command */\n\t\t\tredraw(cmdedit_y, command_len - recalc_pos);\n\t\t}\n#else\n\t\t{\n\t\t\tchar command[MAX_LINELEN];\n\t\t\tint len = save_string(command, sizeof(command));\n\t\t\t/* have space to place the match? */\n\t\t\t/* (cursor_mb - recalc_pos) + len_found + (len - cursor_mb) */\n\t\t\tif ((int)(len_found + len - recalc_pos) < MAX_LINELEN) {\n\t\t\t\t/* save tail */\n\t\t\t\tstrcpy(matchBuf, command + cursor_mb);\n\t\t\t\t/* where do we want to have cursor after all? */\n\t\t\t\tstrcpy(&command[cursor_mb - recalc_pos], tmp);\n\t\t\t\tlen = load_string(command, S.maxsize);\n\t\t\t\t/* add match and tail */\n\t\t\t\tsprintf(&command[cursor_mb - recalc_pos], \"%s%s\", tmp, matchBuf);\n\t\t\t\tcommand_len = load_string(command, S.maxsize);\n\t\t\t\t/* write out the matched command */\n\t\t\t\tredraw(cmdedit_y, command_len - len);\n\t\t\t}\n\t\t}\n#endif\n\t\tfree(tmp);\n#undef matchBuf\n\t} else {\n\t\t/* Ok -- the last char was a TAB.  Since they\n\t\t * just hit TAB again, print a list of all the\n\t\t * available choices... */\n\t\tif (matches && num_matches > 0) {\n\t\t\t/* changed by goto_new_line() */\n\t\t\tint sav_cursor = cursor;\n\n\t\t\t/* Go to the next line */\n\t\t\tgoto_new_line();\n\t\t\tshowfiles();\n\t\t\tredraw(0, command_len - sav_cursor);\n\t\t}\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* state->flags is already checked to be nonzero */\n", "func_signal": "static int get_previous_history(void)", "code": "{\n\tif ((state->flags & DO_HISTORY) && state->cur_history) {\n\t\tsave_command_ps_at_cur_history();\n\t\tstate->cur_history--;\n\t\treturn 1;\n\t}\n\tbeep();\n\treturn 0;\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* We try to ensure that concurrent additions to the history\n * do not overwrite each other.\n * Otherwise shell users get unhappy.\n *\n * History file is trimmed lazily, when it grows several times longer\n * than configured MAX_HISTORY lines.\n */\n", "func_signal": "static void free_line_input_t(line_input_t *n)", "code": "{\n\tint i = n->cnt_history;\n\twhile (i > 0)\n\t\tfree(n->history[--i]);\n\tfree(n);\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* maxsize must be >= 2.\n * Returns:\n * -1 on read errors or EOF, or on bare Ctrl-D,\n * 0  on ctrl-C (the line entered is still returned in 'command'),\n * >0 length of input string, including terminating '\\n'\n */\n", "func_signal": "int FAST_FUNC read_line_input(const char *prompt, char *command, int maxsize, line_input_t *st)", "code": "{\n\tint len;\n#if ENABLE_FEATURE_TAB_COMPLETION\n\tsmallint lastWasTab = FALSE;\n#endif\n\tsmallint break_out = 0;\n#if ENABLE_FEATURE_EDITING_VI\n\tsmallint vi_cmdmode = 0;\n#endif\n\tstruct termios initial_settings;\n\tstruct termios new_settings;\n\tchar read_key_buffer[KEYCODE_BUFFER_SIZE];\n\n\tINIT_S();\n\n\tif (tcgetattr(STDIN_FILENO, &initial_settings) < 0\n\t || !(initial_settings.c_lflag & ECHO)\n\t) {\n\t\t/* Happens when e.g. stty -echo was run before */\n\t\tparse_and_put_prompt(prompt);\n\t\t/* fflush_all(); - done by parse_and_put_prompt */\n\t\tif (fgets(command, maxsize, stdin) == NULL)\n\t\t\tlen = -1; /* EOF or error */\n\t\telse\n\t\t\tlen = strlen(command);\n\t\tDEINIT_S();\n\t\treturn len;\n\t}\n\n\tinit_unicode();\n\n// FIXME: audit & improve this\n\tif (maxsize > MAX_LINELEN)\n\t\tmaxsize = MAX_LINELEN;\n\tS.maxsize = maxsize;\n\n\t/* With null flags, no other fields are ever used */\n\tstate = st ? st : (line_input_t*) &const_int_0;\n#if MAX_HISTORY > 0\n# if ENABLE_FEATURE_EDITING_SAVEHISTORY\n\tif ((state->flags & SAVE_HISTORY) && state->hist_file)\n\t\tif (state->cnt_history == 0)\n\t\t\tload_history(state);\n# endif\n\tif (state->flags & DO_HISTORY)\n\t\tstate->cur_history = state->cnt_history;\n#endif\n\n\t/* prepare before init handlers */\n\tcmdedit_y = 0;  /* quasireal y, not true if line > xt*yt */\n\tcommand_len = 0;\n#if ENABLE_FEATURE_ASSUME_UNICODE\n\tcommand_ps = xzalloc(maxsize * sizeof(command_ps[0]));\n#else\n\tcommand_ps = command;\n\tcommand[0] = '\\0';\n#endif\n#define command command_must_not_be_used\n\n\tnew_settings = initial_settings;\n\tnew_settings.c_lflag &= ~ICANON;        /* unbuffered input */\n\t/* Turn off echoing and CTRL-C, so we can trap it */\n\tnew_settings.c_lflag &= ~(ECHO | ECHONL | ISIG);\n\t/* Hmm, in linux c_cc[] is not parsed if ICANON is off */\n\tnew_settings.c_cc[VMIN] = 1;\n\tnew_settings.c_cc[VTIME] = 0;\n\t/* Turn off CTRL-C, so we can trap it */\n#ifndef _POSIX_VDISABLE\n# define _POSIX_VDISABLE '\\0'\n#endif\n\tnew_settings.c_cc[VINTR] = _POSIX_VDISABLE;\n\ttcsetattr_stdin_TCSANOW(&new_settings);\n\n\t/* Now initialize things */\n\tprevious_SIGWINCH_handler = signal(SIGWINCH, win_changed);\n\twin_changed(0); /* do initial resizing */\n#if ENABLE_FEATURE_GETUSERNAME_AND_HOMEDIR\n\t{\n\t\tstruct passwd *entry;\n\n\t\tentry = getpwuid(geteuid());\n\t\tif (entry) {\n\t\t\tuser_buf = xstrdup(entry->pw_name);\n\t\t\thome_pwd_buf = xstrdup(entry->pw_dir);\n\t\t}\n\t}\n#endif\n\n#if 0\n\tfor (i = 0; i <= MAX_HISTORY; i++)\n\t\tbb_error_msg(\"history[%d]:'%s'\", i, state->history[i]);\n\tbb_error_msg(\"cur_history:%d cnt_history:%d\", state->cur_history, state->cnt_history);\n#endif\n\n\t/* Print out the command prompt, optionally ask where cursor is */\n\tparse_and_put_prompt(prompt);\n\task_terminal();\n\n\tread_key_buffer[0] = 0;\n\twhile (1) {\n\t\t/*\n\t\t * The emacs and vi modes share much of the code in the big\n\t\t * command loop.  Commands entered when in vi's command mode\n\t\t * (aka \"escape mode\") get an extra bit added to distinguish\n\t\t * them - this keeps them from being self-inserted. This\n\t\t * clutters the big switch a bit, but keeps all the code\n\t\t * in one place.\n\t\t */\n\t\tenum {\n\t\t\tVI_CMDMODE_BIT = 0x40000000,\n\t\t\t/* 0x80000000 bit flags KEYCODE_xxx */\n\t\t};\n\t\tint32_t ic, ic_raw;\n\n\t\tfflush_all();\n\t\tic = ic_raw = lineedit_read_key(read_key_buffer);\n\n#if ENABLE_FEATURE_EDITING_VI\n\t\tnewdelflag = 1;\n\t\tif (vi_cmdmode) {\n\t\t\t/* btw, since KEYCODE_xxx are all < 0, this doesn't\n\t\t\t * change ic if it contains one of them: */\n\t\t\tic |= VI_CMDMODE_BIT;\n\t\t}\n#endif\n\n\t\tswitch (ic) {\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tvi_case('\\n'|VI_CMDMODE_BIT:)\n\t\tvi_case('\\r'|VI_CMDMODE_BIT:)\n\t\t\t/* Enter */\n\t\t\tgoto_new_line();\n\t\t\tbreak_out = 1;\n\t\t\tbreak;\n\t\tcase CTRL('A'):\n\t\tvi_case('0'|VI_CMDMODE_BIT:)\n\t\t\t/* Control-a -- Beginning of line */\n\t\t\tinput_backward(cursor);\n\t\t\tbreak;\n\t\tcase CTRL('B'):\n\t\tvi_case('h'|VI_CMDMODE_BIT:)\n\t\tvi_case('\\b'|VI_CMDMODE_BIT:)\n\t\tvi_case('\\x7f'|VI_CMDMODE_BIT:) /* DEL */\n\t\t\t/* Control-b -- Move back one character */\n\t\t\tinput_backward(1);\n\t\t\tbreak;\n\t\tcase CTRL('E'):\n\t\tvi_case('$'|VI_CMDMODE_BIT:)\n\t\t\t/* Control-e -- End of line */\n\t\t\tinput_end();\n\t\t\tbreak;\n\t\tcase CTRL('F'):\n\t\tvi_case('l'|VI_CMDMODE_BIT:)\n\t\tvi_case(' '|VI_CMDMODE_BIT:)\n\t\t\t/* Control-f -- Move forward one character */\n\t\t\tinput_forward();\n\t\t\tbreak;\n\t\tcase '\\b':\n\t\tcase '\\x7f': /* DEL */\n\t\t\t/* Control-h and DEL */\n\t\t\tinput_backspace();\n\t\t\tbreak;\n#if ENABLE_FEATURE_TAB_COMPLETION\n\t\tcase '\\t':\n\t\t\tinput_tab(&lastWasTab);\n\t\t\tbreak;\n#endif\n\t\tcase CTRL('K'):\n\t\t\t/* Control-k -- clear to end of line */\n\t\t\tcommand_ps[cursor] = BB_NUL;\n\t\t\tcommand_len = cursor;\n\t\t\tprintf(\"\\033[J\");\n\t\t\tbreak;\n\t\tcase CTRL('L'):\n\t\tvi_case(CTRL('L')|VI_CMDMODE_BIT:)\n\t\t\t/* Control-l -- clear screen */\n\t\t\tprintf(\"\\033[H\");\n\t\t\tredraw(0, command_len - cursor);\n\t\t\tbreak;\n#if MAX_HISTORY > 0\n\t\tcase CTRL('N'):\n\t\tvi_case(CTRL('N')|VI_CMDMODE_BIT:)\n\t\tvi_case('j'|VI_CMDMODE_BIT:)\n\t\t\t/* Control-n -- Get next command in history */\n\t\t\tif (get_next_history())\n\t\t\t\tgoto rewrite_line;\n\t\t\tbreak;\n\t\tcase CTRL('P'):\n\t\tvi_case(CTRL('P')|VI_CMDMODE_BIT:)\n\t\tvi_case('k'|VI_CMDMODE_BIT:)\n\t\t\t/* Control-p -- Get previous command from history */\n\t\t\tif (get_previous_history())\n\t\t\t\tgoto rewrite_line;\n\t\t\tbreak;\n#endif\n\t\tcase CTRL('U'):\n\t\tvi_case(CTRL('U')|VI_CMDMODE_BIT:)\n\t\t\t/* Control-U -- Clear line before cursor */\n\t\t\tif (cursor) {\n\t\t\t\tcommand_len -= cursor;\n\t\t\t\tmemmove(command_ps, command_ps + cursor,\n\t\t\t\t\t(command_len + 1) * sizeof(command_ps[0]));\n\t\t\t\tredraw(cmdedit_y, command_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTRL('W'):\n\t\tvi_case(CTRL('W')|VI_CMDMODE_BIT:)\n\t\t\t/* Control-W -- Remove the last word */\n\t\t\twhile (cursor > 0 && BB_isspace(command_ps[cursor-1]))\n\t\t\t\tinput_backspace();\n\t\t\twhile (cursor > 0 && !BB_isspace(command_ps[cursor-1]))\n\t\t\t\tinput_backspace();\n\t\t\tbreak;\n\n#if ENABLE_FEATURE_EDITING_VI\n\t\tcase 'i'|VI_CMDMODE_BIT:\n\t\t\tvi_cmdmode = 0;\n\t\t\tbreak;\n\t\tcase 'I'|VI_CMDMODE_BIT:\n\t\t\tinput_backward(cursor);\n\t\t\tvi_cmdmode = 0;\n\t\t\tbreak;\n\t\tcase 'a'|VI_CMDMODE_BIT:\n\t\t\tinput_forward();\n\t\t\tvi_cmdmode = 0;\n\t\t\tbreak;\n\t\tcase 'A'|VI_CMDMODE_BIT:\n\t\t\tinput_end();\n\t\t\tvi_cmdmode = 0;\n\t\t\tbreak;\n\t\tcase 'x'|VI_CMDMODE_BIT:\n\t\t\tinput_delete(1);\n\t\t\tbreak;\n\t\tcase 'X'|VI_CMDMODE_BIT:\n\t\t\tif (cursor > 0) {\n\t\t\t\tinput_backward(1);\n\t\t\t\tinput_delete(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W'|VI_CMDMODE_BIT:\n\t\t\tvi_Word_motion(1);\n\t\t\tbreak;\n\t\tcase 'w'|VI_CMDMODE_BIT:\n\t\t\tvi_word_motion(1);\n\t\t\tbreak;\n\t\tcase 'E'|VI_CMDMODE_BIT:\n\t\t\tvi_End_motion();\n\t\t\tbreak;\n\t\tcase 'e'|VI_CMDMODE_BIT:\n\t\t\tvi_end_motion();\n\t\t\tbreak;\n\t\tcase 'B'|VI_CMDMODE_BIT:\n\t\t\tvi_Back_motion();\n\t\t\tbreak;\n\t\tcase 'b'|VI_CMDMODE_BIT:\n\t\t\tvi_back_motion();\n\t\t\tbreak;\n\t\tcase 'C'|VI_CMDMODE_BIT:\n\t\t\tvi_cmdmode = 0;\n\t\t\t/* fall through */\n\t\tcase 'D'|VI_CMDMODE_BIT:\n\t\t\tgoto clear_to_eol;\n\n\t\tcase 'c'|VI_CMDMODE_BIT:\n\t\t\tvi_cmdmode = 0;\n\t\t\t/* fall through */\n\t\tcase 'd'|VI_CMDMODE_BIT: {\n\t\t\tint nc, sc;\n\n\t\t\tic = lineedit_read_key(read_key_buffer);\n\t\t\tif (errno) /* error */\n\t\t\t\tgoto prepare_to_die;\n\t\t\tif (ic == ic_raw) { /* \"cc\", \"dd\" */\n\t\t\t\tinput_backward(cursor);\n\t\t\t\tgoto clear_to_eol;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsc = cursor;\n\t\t\tswitch (ic) {\n\t\t\tcase 'w':\n\t\t\tcase 'W':\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tswitch (ic) {\n\t\t\t\tcase 'w':   /* \"dw\", \"cw\" */\n\t\t\t\t\tvi_word_motion(vi_cmdmode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':   /* 'dW', 'cW' */\n\t\t\t\t\tvi_Word_motion(vi_cmdmode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':   /* 'de', 'ce' */\n\t\t\t\t\tvi_end_motion();\n\t\t\t\t\tinput_forward();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':   /* 'dE', 'cE' */\n\t\t\t\t\tvi_End_motion();\n\t\t\t\t\tinput_forward();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnc = cursor;\n\t\t\t\tinput_backward(cursor - sc);\n\t\t\t\twhile (nc-- > cursor)\n\t\t\t\t\tinput_delete(1);\n\t\t\t\tbreak;\n\t\t\tcase 'b':  /* \"db\", \"cb\" */\n\t\t\tcase 'B':  /* implemented as B */\n\t\t\t\tif (ic == 'b')\n\t\t\t\t\tvi_back_motion();\n\t\t\t\telse\n\t\t\t\t\tvi_Back_motion();\n\t\t\t\twhile (sc-- > cursor)\n\t\t\t\t\tinput_delete(1);\n\t\t\t\tbreak;\n\t\t\tcase ' ':  /* \"d \", \"c \" */\n\t\t\t\tinput_delete(1);\n\t\t\t\tbreak;\n\t\t\tcase '$':  /* \"d$\", \"c$\" */\n clear_to_eol:\n\t\t\t\twhile (cursor < command_len)\n\t\t\t\t\tinput_delete(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'p'|VI_CMDMODE_BIT:\n\t\t\tinput_forward();\n\t\t\t/* fallthrough */\n\t\tcase 'P'|VI_CMDMODE_BIT:\n\t\t\tput();\n\t\t\tbreak;\n\t\tcase 'r'|VI_CMDMODE_BIT:\n//FIXME: unicode case?\n\t\t\tic = lineedit_read_key(read_key_buffer);\n\t\t\tif (errno) /* error */\n\t\t\t\tgoto prepare_to_die;\n\t\t\tif (ic < ' ' || ic > 255) {\n\t\t\t\tbeep();\n\t\t\t} else {\n\t\t\t\tcommand_ps[cursor] = ic;\n\t\t\t\tbb_putchar(ic);\n\t\t\t\tbb_putchar('\\b');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\x1b': /* ESC */\n\t\t\tif (state->flags & VI_MODE) {\n\t\t\t\t/* insert mode --> command mode */\n\t\t\t\tvi_cmdmode = 1;\n\t\t\t\tinput_backward(1);\n\t\t\t}\n\t\t\tbreak;\n#endif /* FEATURE_COMMAND_EDITING_VI */\n\n#if MAX_HISTORY > 0\n\t\tcase KEYCODE_UP:\n\t\t\tif (get_previous_history())\n\t\t\t\tgoto rewrite_line;\n\t\t\tbeep();\n\t\t\tbreak;\n\t\tcase KEYCODE_DOWN:\n\t\t\tif (!get_next_history())\n\t\t\t\tbreak;\n rewrite_line:\n\t\t\t/* Rewrite the line with the selected history item */\n\t\t\t/* change command */\n\t\t\tcommand_len = load_string(state->history[state->cur_history] ?\n\t\t\t\t\tstate->history[state->cur_history] : \"\", maxsize);\n\t\t\t/* redraw and go to eol (bol, in vi) */\n\t\t\tredraw(cmdedit_y, (state->flags & VI_MODE) ? 9999 : 0);\n\t\t\tbreak;\n#endif\n\t\tcase KEYCODE_RIGHT:\n\t\t\tinput_forward();\n\t\t\tbreak;\n\t\tcase KEYCODE_LEFT:\n\t\t\tinput_backward(1);\n\t\t\tbreak;\n\t\tcase KEYCODE_CTRL_LEFT:\n\t\t\tctrl_left();\n\t\t\tbreak;\n\t\tcase KEYCODE_CTRL_RIGHT:\n\t\t\tctrl_right();\n\t\t\tbreak;\n\t\tcase KEYCODE_DELETE:\n\t\t\tinput_delete(0);\n\t\t\tbreak;\n\t\tcase KEYCODE_HOME:\n\t\t\tinput_backward(cursor);\n\t\t\tbreak;\n\t\tcase KEYCODE_END:\n\t\t\tinput_end();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (initial_settings.c_cc[VINTR] != 0\n\t\t\t && ic_raw == initial_settings.c_cc[VINTR]\n\t\t\t) {\n\t\t\t\t/* Ctrl-C (usually) - stop gathering input */\n\t\t\t\tgoto_new_line();\n\t\t\t\tcommand_len = 0;\n\t\t\t\tbreak_out = -1; /* \"do not append '\\n'\" */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (initial_settings.c_cc[VEOF] != 0\n\t\t\t && ic_raw == initial_settings.c_cc[VEOF]\n\t\t\t) {\n\t\t\t\t/* Ctrl-D (usually) - delete one character,\n\t\t\t\t * or exit if len=0 and no chars to delete */\n\t\t\t\tif (command_len == 0) {\n\t\t\t\t\terrno = 0;\n#if ENABLE_FEATURE_EDITING_VI\n prepare_to_die:\n#endif\n\t\t\t\t\tbreak_out = command_len = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinput_delete(0);\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\t/* Control-V -- force insert of next char */\n//\t\t\tif (c == CTRL('V')) {\n//\t\t\t\tif (safe_read(STDIN_FILENO, &c, 1) < 1)\n//\t\t\t\t\tgoto prepare_to_die;\n//\t\t\t\tif (c == 0) {\n//\t\t\t\t\tbeep();\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tif (ic < ' '\n\t\t\t || (!ENABLE_FEATURE_ASSUME_UNICODE && ic >= 256)\n\t\t\t || (ENABLE_FEATURE_ASSUME_UNICODE && ic >= VI_CMDMODE_BIT)\n\t\t\t) {\n\t\t\t\t/* If VI_CMDMODE_BIT is set, ic is >= 256\n\t\t\t\t * and vi mode ignores unexpected chars.\n\t\t\t\t * Otherwise, we are here if ic is a\n\t\t\t\t * control char or an unhandled ESC sequence,\n\t\t\t\t * which is also ignored.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((int)command_len >= (maxsize - 2)) {\n\t\t\t\t/* Not enough space for the char and EOL */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcommand_len++;\n\t\t\tif (cursor == (command_len - 1)) {\n\t\t\t\t/* We are at the end, append */\n\t\t\t\tcommand_ps[cursor] = ic;\n\t\t\t\tcommand_ps[cursor + 1] = BB_NUL;\n\t\t\t\tcmdedit_set_out_char(' ');\n\t\t\t} else {\n\t\t\t\t/* In the middle, insert */\n\t\t\t\tint sc = cursor;\n\n\t\t\t\tmemmove(command_ps + sc + 1, command_ps + sc,\n\t\t\t\t\t(command_len - sc) * sizeof(command_ps[0]));\n\t\t\t\tcommand_ps[sc] = ic;\n\t\t\t\tsc++;\n\t\t\t\t/* rewrite from cursor */\n\t\t\t\tinput_end();\n\t\t\t\t/* to prev x pos + 1 */\n\t\t\t\tinput_backward(cursor - sc);\n\t\t\t}\n\t\t\tbreak;\n\t\t} /* switch (ic) */\n\n\t\tif (break_out)\n\t\t\tbreak;\n\n#if ENABLE_FEATURE_TAB_COMPLETION\n\t\tif (ic_raw != '\\t')\n\t\t\tlastWasTab = FALSE;\n#endif\n\t} /* while (1) */\n\n#if ENABLE_FEATURE_EDITING_ASK_TERMINAL\n\tif (S.sent_ESC_br6n) {\n\t\t/* \"sleep 1; busybox ash\" + hold [Enter] to trigger.\n\t\t * We sent \"ESC [ 6 n\", but got '\\n' first, and\n\t\t * KEYCODE_CURSOR_POS response is now buffered from terminal.\n\t\t * It's bad already and not much can be done with it\n\t\t * (it _will_ be visible for the next process to read stdin),\n\t\t * but without this delay it even shows up on the screen\n\t\t * as garbage because we restore echo settings with tcsetattr\n\t\t * before it comes in. UGLY!\n\t\t */\n\t\tusleep(20*1000);\n\t}\n#endif\n\n/* Stop bug catching using \"command_must_not_be_used\" trick */\n#undef command\n\n#if ENABLE_FEATURE_ASSUME_UNICODE\n\tcommand[0] = '\\0';\n\tif (command_len > 0)\n\t\tcommand_len = save_string(command, maxsize - 1);\n\tfree(command_ps);\n#endif\n\n\tif (command_len > 0)\n\t\tremember_in_history(command);\n\n\tif (break_out > 0) {\n\t\tcommand[command_len++] = '\\n';\n\t\tcommand[command_len] = '\\0';\n\t}\n\n#if ENABLE_FEATURE_TAB_COMPLETION\n\tfree_tab_completion_data();\n#endif\n\n\t/* restore initial_settings */\n\ttcsetattr_stdin_TCSANOW(&initial_settings);\n\t/* restore SIGWINCH handler */\n\tsignal(SIGWINCH, previous_SIGWINCH_handler);\n\tfflush_all();\n\n\tlen = command_len;\n\tDEINIT_S();\n\n\treturn len; /* can't return command_len, DEINIT_S() destroys it */\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/*\n * vi mode implemented 2005 by Paul Fox <pgf@foxharp.boston.ma.us>\n */\n", "func_signal": "static void\nvi_Word_motion(int eat)", "code": "{\n\tCHAR_T *command = command_ps;\n\n\twhile (cursor < command_len && !BB_isspace(command[cursor]))\n\t\tinput_forward();\n\tif (eat) while (cursor < command_len && BB_isspace(command[cursor]))\n\t\tinput_forward();\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* state->flags is already checked to be nonzero */\n", "func_signal": "static void load_history(line_input_t *st_parm)", "code": "{\n\tchar *temp_h[MAX_HISTORY];\n\tchar *line;\n\tFILE *fp;\n\tunsigned idx, i, line_len;\n\n\t/* NB: do not trash old history if file can't be opened */\n\n\tfp = fopen_for_read(st_parm->hist_file);\n\tif (fp) {\n\t\t/* clean up old history */\n\t\tfor (idx = st_parm->cnt_history; idx > 0;) {\n\t\t\tidx--;\n\t\t\tfree(st_parm->history[idx]);\n\t\t\tst_parm->history[idx] = NULL;\n\t\t}\n\n\t\t/* fill temp_h[], retaining only last MAX_HISTORY lines */\n\t\tmemset(temp_h, 0, sizeof(temp_h));\n\t\tst_parm->cnt_history_in_file = idx = 0;\n\t\twhile ((line = xmalloc_fgetline(fp)) != NULL) {\n\t\t\tif (line[0] == '\\0') {\n\t\t\t\tfree(line);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(temp_h[idx]);\n\t\t\ttemp_h[idx] = line;\n\t\t\tst_parm->cnt_history_in_file++;\n\t\t\tidx++;\n\t\t\tif (idx == MAX_HISTORY)\n\t\t\t\tidx = 0;\n\t\t}\n\t\tfclose(fp);\n\n\t\t/* find first non-NULL temp_h[], if any */\n\t\tif (st_parm->cnt_history_in_file) {\n\t\t\twhile (temp_h[idx] == NULL) {\n\t\t\t\tidx++;\n\t\t\t\tif (idx == MAX_HISTORY)\n\t\t\t\t\tidx = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* copy temp_h[] to st_parm->history[] */\n\t\tfor (i = 0; i < MAX_HISTORY;) {\n\t\t\tline = temp_h[idx];\n\t\t\tif (!line)\n\t\t\t\tbreak;\n\t\t\tidx++;\n\t\t\tif (idx == MAX_HISTORY)\n\t\t\t\tidx = 0;\n\t\t\tline_len = strlen(line);\n\t\t\tif (line_len >= MAX_LINELEN)\n\t\t\t\tline[MAX_LINELEN-1] = '\\0';\n\t\t\tst_parm->history[i++] = line;\n\t\t}\n\t\tst_parm->cnt_history = i;\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Go to the next line */\n", "func_signal": "static void goto_new_line(void)", "code": "{\n\tinput_end();\n\tif (cmdedit_x)\n\t\tbb_putchar('\\n');\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Modelled after bash 4.0 behavior of Ctrl-<arrow> */\n", "func_signal": "static void ctrl_left(void)", "code": "{\n\tCHAR_T *command = command_ps;\n\n\twhile (1) {\n\t\tCHAR_T c;\n\n\t\tinput_backward(1);\n\t\tif (cursor == 0)\n\t\t\tbreak;\n\t\tc = command[cursor];\n\t\tif (c != ' ' && !BB_ispunct(c)) {\n\t\t\t/* we reached a \"word\" delimited by spaces/punct.\n\t\t\t * go to its beginning */\n\t\t\twhile (1) {\n\t\t\t\tc = command[cursor - 1];\n\t\t\t\tif (c == ' ' || BB_ispunct(c))\n\t\t\t\t\tbreak;\n\t\t\t\tinput_backward(1);\n\t\t\t\tif (cursor == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Move forward one character */\n", "func_signal": "static void input_forward(void)", "code": "{\n\tif (cursor < command_len)\n\t\tcmdedit_set_out_char(command_ps[cursor + 1]);\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* FEATURE_COMMAND_TAB_COMPLETION */\n", "func_signal": "line_input_t* FAST_FUNC new_line_input_t(int flags)", "code": "{\n\tline_input_t *n = xzalloc(sizeof(*n));\n\tn->flags = flags;\n\treturn n;\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Move to end of line (by printing all chars till the end) */\n", "func_signal": "static void input_end(void)", "code": "{\n\twhile (cursor < command_len)\n\t\tcmdedit_set_out_char(' ');\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* state->flags is already checked to be nonzero */\n", "func_signal": "static void save_history(char *str)", "code": "{\n\tint fd;\n\tint len, len2;\n\n\tfd = open(state->hist_file, O_WRONLY | O_CREAT | O_APPEND, 0666);\n\tif (fd < 0)\n\t\treturn;\n\txlseek(fd, 0, SEEK_END); /* paranoia */\n\tlen = strlen(str);\n\tstr[len] = '\\n'; /* we (try to) do atomic write */\n\tlen2 = full_write(fd, str, len + 1);\n\tstr[len] = '\\0';\n\tclose(fd);\n\tif (len2 != len + 1)\n\t\treturn; /* \"wtf?\" */\n\n\t/* did we write so much that history file needs trimming? */\n\tstate->cnt_history_in_file++;\n\tif (state->cnt_history_in_file > MAX_HISTORY * 4) {\n\t\tFILE *fp;\n\t\tchar *new_name;\n\t\tline_input_t *st_temp;\n\t\tint i;\n\n\t\t/* we may have concurrently written entries from others.\n\t\t * load them */\n\t\tst_temp = new_line_input_t(state->flags);\n\t\tst_temp->hist_file = state->hist_file;\n\t\tload_history(st_temp);\n\n\t\t/* write out temp file and replace hist_file atomically */\n\t\tnew_name = xasprintf(\"%s.%u.new\", state->hist_file, (int) getpid());\n\t\tfp = fopen_for_write(new_name);\n\t\tif (fp) {\n\t\t\tfor (i = 0; i < st_temp->cnt_history; i++)\n\t\t\t\tfprintf(fp, \"%s\\n\", st_temp->history[i]);\n\t\t\tfclose(fp);\n\t\t\tif (rename(new_name, state->hist_file) == 0)\n\t\t\t\tstate->cnt_history_in_file = st_temp->cnt_history;\n\t\t}\n\t\tfree(new_name);\n\t\tfree_line_input_t(st_temp);\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* This function is used from NOFORK applets. It must not allocate anything */\n", "func_signal": "int FAST_FUNC bb_make_directory(char *path, long mode, int flags)", "code": "{\n\tmode_t cur_mask;\n\tmode_t org_mask;\n\tconst char *fail_msg;\n\tchar *s;\n\tchar c;\n\tstruct stat st;\n\n\t/* Happens on bb_make_directory(dirname(\"no_slashes\"),...) */\n\tif (LONE_CHAR(path, '.'))\n\t\treturn 0;\n\n\torg_mask = cur_mask = (mode_t)-1L;\n\ts = path;\n\twhile (1) {\n\t\tc = '\\0';\n\n\t\tif (flags & FILEUTILS_RECUR) {\t/* Get the parent */\n\t\t\t/* Bypass leading non-'/'s and then subsequent '/'s */\n\t\t\twhile (*s) {\n\t\t\t\tif (*s == '/') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\t++s;\n\t\t\t\t\t} while (*s == '/');\n\t\t\t\t\tc = *s; /* Save the current char */\n\t\t\t\t\t*s = '\\0'; /* and replace it with nul */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t}\n\t\t}\n\n\t\tif (c != '\\0') {\n\t\t\t/* Intermediate dirs: must have wx for user */\n\t\t\tif (cur_mask == (mode_t)-1L) { /* wasn't done yet? */\n\t\t\t\tmode_t new_mask;\n\t\t\t\torg_mask = umask(0);\n\t\t\t\tcur_mask = 0;\n\t\t\t\t/* Clear u=wx in umask - this ensures\n\t\t\t\t * they won't be cleared on mkdir */\n\t\t\t\tnew_mask = (org_mask & ~(mode_t)0300);\n\t\t\t\t//bb_error_msg(\"org_mask:%o cur_mask:%o\", org_mask, new_mask);\n\t\t\t\tif (new_mask != cur_mask) {\n\t\t\t\t\tcur_mask = new_mask;\n\t\t\t\t\tumask(new_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Last component: uses original umask */\n\t\t\t//bb_error_msg(\"1 org_mask:%o\", org_mask);\n\t\t\tif (org_mask != cur_mask) {\n\t\t\t\tcur_mask = org_mask;\n\t\t\t\tumask(org_mask);\n\t\t\t}\n\t\t}\n\n\t\tif (mkdir(path, 0777) < 0) {\n\t\t\t/* If we failed for any other reason than the directory\n\t\t\t * already exists, output a diagnostic and return -1 */\n\t\t\tif (errno != EEXIST\n\t\t\t || !(flags & FILEUTILS_RECUR)\n\t\t\t || ((stat(path, &st) < 0) || !S_ISDIR(st.st_mode))\n\t\t\t) {\n\t\t\t\tfail_msg = \"create\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Since the directory exists, don't attempt to change\n\t\t\t * permissions if it was the full target.  Note that\n\t\t\t * this is not an error condition. */\n\t\t\tif (!c) {\n\t\t\t\tgoto ret0;\n\t\t\t}\n\t\t}\n\n\t\tif (!c) {\n\t\t\t/* Done.  If necessary, update perms on the newly\n\t\t\t * created directory.  Failure to update here _is_\n\t\t\t * an error. */\n\t\t\tif ((mode != -1) && (chmod(path, mode) < 0)) {\n\t\t\t\tfail_msg = \"set permissions of\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Remove any inserted nul from the path (recursive mode) */\n\t\t*s = c;\n\t} /* while (1) */\n\n\tbb_perror_msg(\"can't %s directory '%s'\", fail_msg, path);\n\tflags = -1;\n\tgoto ret;\n ret0:\n\tflags = 0;\n ret:\n\t//bb_error_msg(\"2 org_mask:%o\", org_mask);\n\tif (org_mask != cur_mask)\n\t\tumask(org_mask);\n\treturn flags;\n}", "path": "libbb\\make_directory.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Move back one character */\n/* (optimized for slow terminals) */\n", "func_signal": "static void input_backward(unsigned num)", "code": "{\n\tint count_y;\n\n\tif (num > cursor)\n\t\tnum = cursor;\n\tif (!num)\n\t\treturn;\n\tcursor -= num;\n\n\tif (cmdedit_x >= num) {\n\t\tcmdedit_x -= num;\n\t\tif (num <= 4) {\n\t\t\t/* This is longer by 5 bytes on x86.\n\t\t\t * Also gets miscompiled for ARM users\n\t\t\t * (busybox.net/bugs/view.php?id=2274).\n\t\t\t * printf((\"\\b\\b\\b\\b\" + 4) - num);\n\t\t\t * return;\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tbb_putchar('\\b');\n\t\t\t} while (--num);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\033[%uD\", num);\n\t\treturn;\n\t}\n\n\t/* Need to go one or more lines up */\n\tnum -= cmdedit_x;\n\t{\n\t\tunsigned w = cmdedit_termw; /* volatile var */\n\t\tcount_y = 1 + (num / w);\n\t\tcmdedit_y -= count_y;\n\t\tcmdedit_x = w * count_y - num;\n\t}\n\t/* go to 1st column; go up; go to correct column */\n\tprintf(\"\\r\" \"\\033[%dA\" \"\\033[%dC\", count_y, cmdedit_x);\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* FEATURE_COMMAND_SAVEHISTORY */\n", "func_signal": "static void remember_in_history(char *str)", "code": "{\n\tint i;\n\n\tif (!(state->flags & DO_HISTORY))\n\t\treturn;\n\tif (str[0] == '\\0')\n\t\treturn;\n\ti = state->cnt_history;\n\t/* Don't save dupes */\n\tif (i && strcmp(state->history[i-1], str) == 0)\n\t\treturn;\n\n\tfree(state->history[MAX_HISTORY]); /* redundant, paranoia */\n\tstate->history[MAX_HISTORY] = NULL; /* redundant, paranoia */\n\n\t/* If history[] is full, remove the oldest command */\n\t/* we need to keep history[MAX_HISTORY] empty, hence >=, not > */\n\tif (i >= MAX_HISTORY) {\n\t\tfree(state->history[0]);\n\t\tfor (i = 0; i < MAX_HISTORY-1; i++)\n\t\t\tstate->history[i] = state->history[i+1];\n\t\t/* i == MAX_HISTORY-1 */\n\t}\n\t/* i <= MAX_HISTORY-1 */\n\tstate->history[i++] = xstrdup(str);\n\t/* i <= MAX_HISTORY */\n\tstate->cur_history = i;\n\tstate->cnt_history = i;\n# if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY\n\tif ((state->flags & SAVE_HISTORY) && state->hist_file)\n\t\tsave_history(str);\n# endif\n\tIF_FEATURE_EDITING_FANCY_PROMPT(num_ok_lines++;)\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/*\n * display by column (original idea from ls applet,\n * very optimized by me :)\n */\n", "func_signal": "static void showfiles(void)", "code": "{\n\tint ncols, row;\n\tint column_width = 0;\n\tint nfiles = num_matches;\n\tint nrows = nfiles;\n\tint l;\n\n\t/* find the longest file name - use that as the column width */\n\tfor (row = 0; row < nrows; row++) {\n\t\tl = unicode_strlen(matches[row]);\n\t\tif (column_width < l)\n\t\t\tcolumn_width = l;\n\t}\n\tcolumn_width += 2;              /* min space for columns */\n\tncols = cmdedit_termw / column_width;\n\n\tif (ncols > 1) {\n\t\tnrows /= ncols;\n\t\tif (nfiles % ncols)\n\t\t\tnrows++;        /* round up fractionals */\n\t} else {\n\t\tncols = 1;\n\t}\n\tfor (row = 0; row < nrows; row++) {\n\t\tint n = row;\n\t\tint nc;\n\n\t\tfor (nc = 1; nc < ncols && n+nrows < nfiles; n += nrows, nc++) {\n\t\t\tprintf(\"%s%-*s\", matches[n],\n\t\t\t\t(int)(column_width - unicode_strlen(matches[n])), \"\"\n\t\t\t);\n\t\t}\n\t\tputs(matches[n]);\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* draw prompt, editor line, and clear tail */\n", "func_signal": "static void redraw(int y, int back_cursor)", "code": "{\n\tif (y > 0)  /* up to start y */\n\t\tprintf(\"\\033[%uA\", y);\n\tbb_putchar('\\r');\n\tput_prompt();\n\tinput_end();      /* rewrite */\n\tprintf(\"\\033[J\"); /* erase after cursor */\n\tinput_backward(back_cursor);\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* is must be <= in */\n", "func_signal": "static void collapse_pos(int is, int in)", "code": "{\n\tmemmove(int_buf+is, int_buf+in, (MAX_LINELEN+1-in)*sizeof(int_buf[0]));\n\tmemmove(pos_buf+is, pos_buf+in, (MAX_LINELEN+1-in)*sizeof(pos_buf[0]));\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* I thought just fputwc(c, stdout) would work. But no... */\n", "func_signal": "static void BB_PUTCHAR(wchar_t c)", "code": "{\n\tchar buf[MB_CUR_MAX + 1];\n\tmbstate_t mbst = { 0 };\n\tssize_t len = wcrtomb(buf, c, &mbst);\n\n\tif (len > 0) {\n\t\tbuf[len] = '\\0';\n\t\tfputs(buf, stdout);\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Delete the char in back of the cursor */\n", "func_signal": "static void input_backspace(void)", "code": "{\n\tif (cursor > 0) {\n\t\tinput_backward(1);\n\t\tinput_delete(0);\n\t}\n}", "path": "libbb\\lineedit.c", "repo_name": "cvpcs/android_external_busybox", "stars": 16, "license": "other", "language": "c", "size": 19449}
{"docstring": "/* Dumps the contents of the buffer to stderr. */\n", "func_signal": "void\nbuffer_dump(Buffer *buffer)", "code": "{\n\tu_int i;\n\tu_char *ucp = buffer->buf;\n\n\tfor (i = buffer->offset; i < buffer->end; i++) {\n\t\tfprintf(stderr, \"%02x\", ucp[i]);\n\t\tif ((i-buffer->offset)%16==15)\n\t\t\tfprintf(stderr, \"\\r\\n\");\n\t\telse if ((i-buffer->offset)%2==1)\n\t\t\tfprintf(stderr, \" \");\n\t}\n\tfprintf(stderr, \"\\r\\n\");\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* skips all whitespace anywhere.\n   converts characters, four at a time, starting at (or after)\n   src from base - 64 numbers into three 8 bit bytes in the target area.\n   it returns the number of data bytes stored at the target, or -1 on error.\n */\n", "func_signal": "int\nxb64_pton(char const *src, u_char *target, size_t targsize)", "code": "{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}", "path": "xssh\\base64.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* random number r:  0 <= r < range */\n", "func_signal": "int xBN_rand_range(BIGNUM *r, BIGNUM *range)", "code": "{\n\tint n;\n\tint count = 100;\n\n\tn = BN_num_bits(range); /* n > 0 */\n\n\t/* BN_is_bit_set(range, n - 1) always holds */\n\n\tif (n == 1)\n\t\tBN_zero(r);\n\telse if (!BN_is_bit_set(range, n - 2) && !BN_is_bit_set(range, n - 3)) {\n\t\t/* range = 100..._2,\n\t\t * so  3*range (= 11..._2)  is exactly one bit longer than  range */\n\t\tdo {\n\t\t\tif (!xBN_rand(r, n + 1, -1, 0))\n\t\t\t\treturn 0;\n\t\t\t/* If  r < 3*range,  use  r := r MOD range\n\t\t\t * (which is either  r, r - range,  or  r - 2*range).\n\t\t\t * Otherwise, iterate once more.\n\t\t\t * Since  3*range = 11..._2, each iteration succeeds with\n\t\t\t * probability >= .75. */\n\t\t\tif (BN_cmp(r, range) >= 0) {\n\t\t\t\tif (!BN_sub(r, r, range))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (BN_cmp(r, range) >= 0)\n\t\t\t\t\tif (!BN_sub(r, r, range))\n\t\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!--count) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t} while (BN_cmp(r, range) >= 0);\n\t} else {\n\t\tdo {\n\t\t\t/* range = 11..._2  or  range = 101..._2 */\n\t\t\tif (!xBN_rand(r, n, -1, 0))\n\t\t\t\treturn 0;\n\n\t\t\tif (!--count) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while (BN_cmp(r, range) >= 0);\n\t}\n\n\treturn 1;\n}", "path": "xcrypt\\xbn_rand.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Initializes the buffer structure. */\n", "func_signal": "void\nbuffer_init(Buffer *buffer)", "code": "{\n\tconst u_int len = 4096;\n\n\tbuffer->alloc = 0;\n\tbuffer->buf = xmalloc(len);\n\tbuffer->alloc = len;\n\tbuffer->offset = 0;\n\tbuffer->end = 0;\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Consumes the given number of bytes from the beginning of the buffer. */\n", "func_signal": "int\nbuffer_consume_ret(Buffer *buffer, u_int bytes)", "code": "{\n\tif (bytes > buffer->end - buffer->offset) {\n\t\terror(\"buffer_consume_ret: trying to get more bytes than in buffer\");\n\t\treturn (-1);\n\t}\n\tbuffer->offset += bytes;\n\treturn (0);\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Appends data to the buffer, expanding it if necessary. */\n", "func_signal": "void\nbuffer_append(Buffer *buffer, const void *data, u_int len)", "code": "{\n\tvoid *p;\n\tp = buffer_append_space(buffer, len);\n\tmemcpy(p, data, len);\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Check whether an allocation of 'len' will fit in the buffer\n * This must follow the same math as buffer_append_space\n */\n", "func_signal": "int\nbuffer_check_alloc(Buffer *buffer, u_int len)", "code": "{\n\tif (buffer->offset == buffer->end) {\n\t\tbuffer->offset = 0;\n\t\tbuffer->end = 0;\n\t}\n restart:\n\tif (buffer->end + len < buffer->alloc)\n\t\treturn (1);\n\tif (buffer_compact(buffer))\n\t\tgoto restart;\n\tif (roundup(buffer->alloc + len, BUFFER_ALLOCSZ) <= BUFFER_MAX_LEN)\n\t\treturn (1);\n\treturn (0);\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Consumes the given number of bytes from the end of the buffer. */\n", "func_signal": "int\nbuffer_consume_end_ret(Buffer *buffer, u_int bytes)", "code": "{\n\tif (bytes > buffer->end - buffer->offset)\n\t\treturn (-1);\n\tbuffer->end -= bytes;\n\treturn (0);\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Stores integers in the buffer, msb first.\n */\n", "func_signal": "void\nbuffer_put_short(Buffer *buffer, u_short value)", "code": "{\n\tchar buf[2];\n\n\tput_u16(buf, value);\n\tbuffer_append(buffer, buf, 2);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Frees any memory used for the buffer. */\n", "func_signal": "void\nbuffer_free(Buffer *buffer)", "code": "{\n\tif (buffer->alloc > 0) {\n\t\tmemset(buffer->buf, 0, buffer->alloc);\n\t\tbuffer->alloc = 0;\n\t\txfree(buffer->buf);\n\t}\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Returns integers from the buffer (msb first).\n */\n", "func_signal": "int\nbuffer_get_short_ret(u_short *ret, Buffer *buffer)", "code": "{\n\tu_char buf[2];\n\n\tif (buffer_get_ret(buffer, (char *) buf, 2) == -1)\n\t\treturn (-1);\n\t*ret = get_u16(buf);\n\treturn (0);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Appends space to the buffer, expanding the buffer if necessary. This does\n * not actually copy the data into the buffer, but instead returns a pointer\n * to the allocated region.\n */\n", "func_signal": "void *\nbuffer_append_space(Buffer *buffer, u_int len)", "code": "{\n\tu_int newlen;\n\tvoid *p;\n\n\tif (len > BUFFER_MAX_CHUNK)\n\t\t;//fatal(\"buffer_append_space: len %u not supported\", len);\n\n\t/* If the buffer is empty, start using it from the beginning. */\n\tif (buffer->offset == buffer->end) {\n\t\tbuffer->offset = 0;\n\t\tbuffer->end = 0;\n\t}\nrestart:\n\t/* If there is enough space to store all data, store it now. */\n\tif (buffer->end + len < buffer->alloc) {\n\t\tp = buffer->buf + buffer->end;\n\t\tbuffer->end += len;\n\t\treturn p;\n\t}\n\n\t/* Compact data back to the start of the buffer if necessary */\n\tif (buffer_compact(buffer))\n\t\tgoto restart;\n\n\t/* Increase the size of the buffer and retry. */\n\tnewlen = roundup(buffer->alloc + len, BUFFER_ALLOCSZ);\n\tif (newlen > BUFFER_MAX_LEN)\n\t\tfatal(\"buffer_append_space: alloc %u not supported\",\n\t\t    newlen);\n\tbuffer->buf = xrealloc(buffer->buf, 1, newlen);\n\tbuffer->alloc = newlen;\n\tgoto restart;\n\t/* NOTREACHED */\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Clears any data from the buffer, making it empty.  This does not actually\n * zero the memory.\n */\n", "func_signal": "void\nbuffer_clear(Buffer *buffer)", "code": "{\n\tbuffer->offset = 0;\n\tbuffer->end = 0;\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Stores a character in the buffer.\n */\n", "func_signal": "void\nbuffer_put_char(Buffer *buffer, int value)", "code": "{\n\tchar ch = value;\n\n\tbuffer_append(buffer, &ch, 1);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Gets data from the beginning of the buffer. */\n", "func_signal": "int\nbuffer_get_ret(Buffer *buffer, void *buf, u_int len)", "code": "{\n\tif (len > buffer->end - buffer->offset) {\n\t\terror(\"buffer_get_ret: trying to get more bytes %d than in buffer %d\",\n\t\t    len, buffer->end - buffer->offset);\n\t\treturn (-1);\n\t}\n\tmemcpy(buf, buffer->buf + buffer->offset, len);\n\tbuffer->offset += len;\n\treturn (0);\n}", "path": "xssh\\buffer.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * buffer must be at least target_long_size in length\n */\n", "func_signal": "static void pack(long n, unsigned char *buffer)", "code": "{\n\tunsigned char *p;\n\tmemset(buffer, 0, target_long_size);\n\tp = buffer;\n\t\n\t/*\n\t * n = ABCD\n\t * \n\t * 32 bit little endian\n\t * DCBA....\n\t * \n\t * 64 bit little endian\n\t * DCBA0000\n\t * \n\t * 32 bit big endian\n\t * ABCD....\n\t * \n\t * 64 bit big endian\n\t * 0000ABCD\n\t */\n\tif(mode_bits == TARGET_BITS_64 && mode_endian == TARGET_BIG_ENDIAN) {\n\t\tp += 4;\n\t} \n\t\n\tif(mode_endian == TARGET_BIG_ENDIAN) {\n\t\tp[0] = (unsigned char) (n >> 24);\n\t\tp[1] = (unsigned char) (n >> 16);\n\t\tp[2] = (unsigned char) (n >> 8);\n\t\tp[3] = (unsigned char) (n);\n\t} else {\n\t\tp[3] = (unsigned char) (n >> 24);\n\t\tp[2] = (unsigned char) (n >> 16);\n\t\tp[1] = (unsigned char) (n >> 8);\n\t\tp[0] = (unsigned char) (n);\n\t}\n\t\n\n}", "path": "xcrypt\\xrand.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Returns a character from the buffer (0 - 255).\n */\n", "func_signal": "int\nbuffer_get_char_ret(char *ret, Buffer *buffer)", "code": "{\n\tif (buffer_get_ret(buffer, ret, 1) == -1) {\n\t\t;//error(\"buffer_get_char_ret: buffer_get_ret failed\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Stores and arbitrary binary string in the buffer.\n */\n", "func_signal": "void\nbuffer_put_string(Buffer *buffer, const void *buf, u_int len)", "code": "{\n\tbuffer_put_int(buffer, len);\n\tbuffer_append(buffer, buf, len);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * returns number of bytes consumed\n */\n", "func_signal": "static int client_data(char *data, int length)", "code": "{\n\tint bytes_consumed = 0;\n\tprintf(\"client data %d bytes\\n\", length);\n\t\n\tif(!have_client_banner) {\n\t\tif((bytes_consumed = parse_banner(data, length, client_banner)) > 0) {\n\t\t\thave_client_banner = 1;\n\t\t\tprintf(\"client banner: %s\\n\", client_banner);\n\t\t}\n\t\treturn bytes_consumed;\n\t}\n\t\n\tbytes_consumed = parse_record((unsigned char *)data, length);\n\treturn bytes_consumed;\n\t\n}", "path": "sshtool.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/*\n * Returns an arbitrary binary string from the buffer.  The string cannot\n * be longer than 256k.  The returned value points to memory allocated\n * with xmalloc; it is the responsibility of the calling function to free\n * the data.  If length_ptr is non-NULL, the length of the returned data\n * will be stored there.  A null character will be automatically appended\n * to the returned string, and is not counted in length.\n */\n", "func_signal": "void *\nbuffer_get_string_ret(Buffer *buffer, u_int *length_ptr)", "code": "{\n\tu_char *value;\n\tu_int len;\n\n\t/* Get the length. */\n\tlen = buffer_get_int(buffer);\n\tif (len > 256 * 1024) {\n\t\t//error(\"buffer_get_string_ret: bad string length %u\", len);\n\t\treturn (NULL);\n\t}\n\t/* Allocate space for the string.  Add one byte for a null character. */\n\tvalue = xmalloc(len + 1);\n\t/* Get the string. */\n\tif (buffer_get_ret(buffer, value, len) == -1) {\n\t\t;//error(\"buffer_get_string_ret: buffer_get failed\");\n\t\txfree(value);\n\t\treturn (NULL);\n\t}\n\t/* Append a null character to make processing easier. */\n\tvalue[len] = 0;\n\t/* Optionally return the length of the string. */\n\tif (length_ptr)\n\t\t*length_ptr = len;\n\treturn (value);\n}", "path": "xssh\\bufaux.c", "repo_name": "brl/exegesis", "stars": 30, "license": "mit", "language": "c", "size": 8311}
{"docstring": "/* Read from an inode in the filesystem */\n", "func_signal": "unsigned int read_fs(struct fs_node* node, unsigned int offset, unsigned int size, unsigned char* buffer)", "code": "{\n\tif (node->read != 0)\n\t\treturn node->read(node, offset, size, buffer);\n\telse\n\t\treturn 0;\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Closes an inode in the filesystem */\n", "func_signal": "void close_fs(struct fs_node* node)", "code": "{\n\tif (node->close != 0)\n\t\treturn node->close(node);\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* This is a very simple main() function.  All it does is sit in an\n * infinite loop.  This will be like our 'idle' loop */\n", "func_signal": "void _main(struct multiboot_info* mbt, addr stack)", "code": "{\n\t/* Store the stack position in a global variable */\n\tinitial_esp = stack;\n\n\t/* Setup the very core components of the kernel / CPU operation */\n\tunsigned char itoa_buffer[256];\n\tgdt_install();\n\tidt_install();\n\tisrs_install();\n\tirq_install();\n\tinit_video();\n\n\t/* Enable IRQs */\n\tasm volatile(\"sti\");\n\n\t/* Install the initrd filesystem before memory management\n\t * so that it doesn't get overwritten before we read it */\n\tASSERT(mbt->mods_count > 0);\n\tputs(\"Initializing initrd... \");\n\tfs_root = initrd_install(*((addr*)(mbt->mods_addr)));\n\tputs(\"done.\\n\");\n\n\t/* Install memory and task management */\n\tkmem_install(mbt);\n\tpage_install();\n\ttask_install();\n\n\t/* Install and handle various devices in the system */\n\tputs(\"Enabling devices... \");\n\ttimer_install();\n\tkb_install();\n\tputs(\"done.\\n\");\n\n\t/* Test user-mode */\n\tputs(\"Entering user-mode... \\n\");\n\tint a;\n\tfor (a = 0; a < 16; a += 1)\n\t\tputs(\"=====\");\n\tputs(\"\\n\");\n\ttss_switch();\n\tentry();\n\n\tfor (;;);\n\n\t/* Test the task management system */\n\tputs(\"Forking kernel...\\n\");\n\tint ret = fork();\n\tputs(\"fork() returned \");\n\tputs(itoa(ret, itoa_buffer, 10));\n\tputs(\", and getpid() returned \");\n\tputs(itoa(getpid(), itoa_buffer, 10));\n\tputs(\"\\n==========================================\\n\");\n\n\t/* The next section of code is not re-entrant (because the initrd\n\t * VFS uses global variables which will be shared between both\n\t * processes), so make sure we aren't interrupted during listing\n\t * the contents of /. */\n\tasm volatile(\"cli\");\n\n\t/* List the contents of the initrd */\n\tint i = 0;\n\tstruct dirent* node = 0;\n\twhile ((node = readdir_fs(fs_root, i)) != 0)\n\t{\n\t\tputs(\"Found file \");\n\t\tputs(node->name);\n\t\tstruct fs_node* fsnode = finddir_fs(fs_root, node->name);\n\n\t\tif ((fsnode->flags & 0x7) == FS_DIRECTORY)\n\t\t\tputs(\"\\n\\t(directory)\\n\");\n\t\telse\n\t\t{\n\t\t\tputs(\"\\n\\t contents: \\\"\");\n\t\t\tchar buf[256];\n\t\t\tunsigned int sz = read_fs(fsnode, 0, 256, buf);\n\t\t\tint j;\n\t\t\tfor (j = 0; j < sz; j++)\n\t\t\t\tputch(buf[j]);\n\t\t\tputs(\"\\\"\\n\");\n\t\t}\n\t\ti++;\n\t}\n\tputs(\"\\n\");\n\n\t/* Re-enable interrupts */\n\tasm volatile(\"sti\");\n\n\tret = fork();\n\tputs(\"This message SHOULD BE REPEATED 4 TIMES!\\n\");\n\t\n\t/* ...and leave this loop in.  There is an endless loop in\n\t * 'start.asm' also, if you accidently delete this next line */\n\tfor (;;);\n}", "path": "main.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* String reverse function\n * Sourced from: http://www.daniweb.com/software-development/c/threads/11049 */\n", "func_signal": "unsigned char* strrev(unsigned char* str)", "code": "{\n\tunsigned char* p1;\n\tunsigned char* p2;\n\n\tif (!str || !*str)\n\t\treturn str;\n\n\tfor (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)\n\t{\n\t\t*p1 ^= *p2;\n\t\t*p2 ^= *p1;\n\t\t*p1 ^= *p2;\n\t}\n\n\treturn str;\n}", "path": "string.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Normally, IRQs 0 to 7 are mapped to entries 8 to 15.  This\n * is a problem in protected mode, because IDT entry 8 is a\n * Double Fault!  Without remapping, every time IRQ0 fires,\n * you get a Double Fault Exception, which is NOT actually\n * what's happening.  We send commands to the PIC in order to\n * make IRQ0 to 15 be remapped to IDT entries 32 to 47 */\n", "func_signal": "void irq_remap()", "code": "{\n\toutportb(0x20, 0x11);\n\toutportb(0xA0, 0x11);\n\toutportb(0x21, 0x20);\n\toutportb(0xA1, 0x28);\n\toutportb(0x21, 0x04);\n\toutportb(0xA1, 0x02);\n\toutportb(0x21, 0x01);\n\toutportb(0xA1, 0x01);\n\toutportb(0x21, 0x0);\n\toutportb(0xA1, 0x0);\n}", "path": "irq.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Write to an inode in the filesystem */\n", "func_signal": "unsigned int write_fs(struct fs_node* node, unsigned int offset, unsigned int size, unsigned char* buffer)", "code": "{\n\tif (node->write != 0)\n\t\treturn node->write(node, offset, size, buffer);\n\telse\n\t\treturn 0;\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Function to allocate a frame */\n", "func_signal": "void frame_alloc(struct page* p, int is_kernel, int is_writable)", "code": "{\n\tif (p->frame != 0)\n\t{\n\t\t/* Frame was already allocated */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\taddr idx = first_frame(); /* The first free frame */\n\t\tif (idx == (addr) - 1)\n\t\t\tPANIC(\"No free frames!\");\n\t\tset_frame(idx*0x1000);\t\t/* This frame is now ours */\n\t\tp->present = 1;\t\t\t/* Mark it as present */\n\t\tp->rw = (is_writable)?1:0;\t/* Should the page be writable? */\n\t\tp->user = (is_kernel)?0:1;\t/* Should the page be user-mode? */\n\t\tp->frame = idx;\n\t}\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Reads from a directory in the filesystem */\n", "func_signal": "struct dirent* readdir_fs(struct fs_node* node, unsigned int index)", "code": "{\n\tif ((node->flags & 0x7) == FS_DIRECTORY && node->readdir != 0)\n\t\treturn node->readdir(node, index);\n\telse\n\t\treturn 0;\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Static function to find the first free frame */\n", "func_signal": "static addr first_frame()", "code": "{\n\tunsigned int i, j;\n\tfor (i = 0; i < INDEX_FROM_BIT(nframes); i++)\n\t{\n\t\tif (frames[i] != 0xFFFFFFFF)\n\t\t{\n\t\t\tfor (j = 0; j < 32; j++)\n\t\t\t{\n\t\t\t\tunsigned int test = 0x1 << j;\n\t\t\t\tif ( !(frames[i]&test) )\n\t\t\t\t{\n\t\t\t\t\treturn i*4*8+j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (addr) - 1;\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Opens an inode in the filesystem */\n", "func_signal": "void open_fs(struct fs_node* node, unsigned char read, unsigned char write)", "code": "{\n\tif (node->open != 0)\n\t\treturn node->open(node);\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* String length function */\n", "func_signal": "int strlen(const unsigned char* str)", "code": "{\n\t/* This loops through character array 'str', returning how\n\t * many characters it needs to check before it finds a 0.\n\t * In simple words, it returns the length in bytes of a string */\n\t\n\t// strlen implementation from FreeBSD 6.2\n\tconst unsigned char* s;\n\tfor (s = str; *s; ++s);\n\treturn (s - str);\n}", "path": "string.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Function to deallocate a frame */\n", "func_signal": "void frame_free(struct page* p)", "code": "{\n\taddr frame;\n\tif (!(frame = p->frame))\n\t{\n\t\t/* The given page didn't actually have an allocate frame */\n\t}\n\telse\n\t{\n\t\tclear_frame(frame);\t\t/* Frame is now free again */\n\t\tp->frame = 0x0;\t\t\t/* Page now doesn't have a frame */\n\t}\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* We first remap the interrupt controllers, and then we install\n * the appropriate ISRs to the correct entries in the IDT.  This\n * is just like installing the exception handlers */\n", "func_signal": "void irq_install()", "code": "{\n\tirq_remap();\n\n\tidt_set_gate(32, (unsigned)_irq0, 0x08, 0x8E);\n\tidt_set_gate(33, (unsigned)_irq1, 0x08, 0x8E);\n\tidt_set_gate(34, (unsigned)_irq2, 0x08, 0x8E);\n\tidt_set_gate(35, (unsigned)_irq3, 0x08, 0x8E);\n\tidt_set_gate(36, (unsigned)_irq4, 0x08, 0x8E);\n\tidt_set_gate(37, (unsigned)_irq5, 0x08, 0x8E);\n\tidt_set_gate(38, (unsigned)_irq6, 0x08, 0x8E);\n\tidt_set_gate(39, (unsigned)_irq7, 0x08, 0x8E);\n\tidt_set_gate(40, (unsigned)_irq8, 0x08, 0x8E);\n\tidt_set_gate(41, (unsigned)_irq9, 0x08, 0x8E);\n\tidt_set_gate(42, (unsigned)_irq10, 0x08, 0x8E);\n\tidt_set_gate(43, (unsigned)_irq11, 0x08, 0x8E);\n\tidt_set_gate(44, (unsigned)_irq12, 0x08, 0x8E);\n\tidt_set_gate(45, (unsigned)_irq13, 0x08, 0x8E);\n\tidt_set_gate(46, (unsigned)_irq14, 0x08, 0x8E);\n\tidt_set_gate(47, (unsigned)_irq15, 0x08, 0x8E);\n}", "path": "irq.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Static function to set a bit in the frames bitset */\n", "func_signal": "static void set_frame(addr frame_addr)", "code": "{\n\taddr frame = frame_addr/0x1000;\n\taddr idx = INDEX_FROM_BIT(frame);\n\taddr off = OFFSET_FROM_BIT(frame);\n\tframes[idx] |= (0x1 << off);\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Finds a child in a directory in the filesystem */\n", "func_signal": "struct fs_node* finddir_fs(struct fs_node* node, char* name)", "code": "{\n\tif ((node->flags & 0x7) == FS_DIRECTORY && node->readdir != 0)\n\t\treturn node->finddir(node, name);\n\telse\n\t\treturn 0;\n}", "path": "vfs.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* String compare function */\n", "func_signal": "int strcmp(const unsigned char* a, const unsigned char* b)", "code": "{\n\tint i = 0;\n\tif (strlen(a) > strlen(b)) return 1;\n\tif (strlen(a) < strlen(b)) return -1;\n\tfor (i = 0; i < strlen(a); i++)\n\t\tif (a[i] != b[i])\n\t\t\treturn (a[i] > b[i]) ? 1 : -1;\n\treturn 0;\n}", "path": "string.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Each of the IRQ ISRs point to this function, rather than\n * the 'fault_handler' in 'isrs.c'.  The IRQ controllers\n * need to be told when you are done servicing them, so you\n * need to send them an \"End of Interrupt\" command (0x20).\n * There are two 8259 chips: The first exists at 0x20, the\n * second exist at 0xA0.  If the second controller (an IRQ\n * from 8 to 15) gets an interrupt, you need to acknowledge\n * the interrupt at BOTH controllers, otherwise, you only\n * send an EOI command to the first controller.  If you\n * don't send an EOI, you won't raise any more IRQs */\n", "func_signal": "void _irq_handler(struct regs r)", "code": "{\n\t/* This is a blank function pointer */\n\tvoid (*handler)(struct regs* r);\n\n\t/* Find out if we have a custom handler to run\n\t * for this IRQ, and then finally, run it */\n\thandler = irq_routines[r.int_no - 32];\n\tif (handler && r.int_no - 32 != 0)\n\t\thandler(&r);\n\n\t/* If the IDT entry that was invoked was greater\n\t * than 40 (meaning IRQ8 - 15), then we need to\n\t * send an EOI to the slave controller */\n\tif (r.int_no >= 40)\n\t\toutportb(0xA0, 0x20);\n\n\t/* In either case, we need to send an EOI to the\n\t * master interrupt controller too */\n\toutportb(0x20, 0x20);\n\n\t/* In the event of a timer interrupt, we might be\n\t * task switching, so we can only perform the task\n\t * switch AFTER we have sent the EOI to the\n\t * interrupt controller, hence we called the handler\n\t * for a timer interrupt here instead */\n\tif (handler && r.int_no - 32 == 0)\n\t\thandler(&r);\n}", "path": "irq.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Static function to test if a bit is set */\n", "func_signal": "static unsigned int test_frame(addr frame_addr)", "code": "{\n\taddr frame = frame_addr/0x1000;\n\taddr idx = INDEX_FROM_BIT(frame);\n\taddr off = OFFSET_FROM_BIT(frame);\n\treturn (frames[idx] & (0x1 << off));\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* Static function to clear a bit in the frames bitset */\n", "func_signal": "static void clear_frame(addr frame_addr)", "code": "{\n\taddr frame = frame_addr/0x1000;\n\taddr idx = INDEX_FROM_BIT(frame);\n\taddr off = OFFSET_FROM_BIT(frame);\n\tframes[idx] &= ~(0x1 << off);\n}", "path": "frame.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* We will use this later on for reading from the I/O ports to get data\n * from devices such as the keyboard.  We are using what is called\n * 'inline assembly' in these routines to actually do the work */\n", "func_signal": "unsigned char inportb(unsigned short _port)", "code": "{\n\tunsigned char rv;\n\t__asm__ __volatile__ (\"inb %1, %0\" : \"=a\" (rv) : \"dN\" (_port));\n\treturn rv;\n}", "path": "main.c", "repo_name": "hach-que/Kernel", "stars": 29, "license": "None", "language": "c", "size": 160}
{"docstring": "/* The rest of these were automatically generated from the test vectors\n   provided by NIST. */\n", "func_signal": "void\n__CUT__sha512_len_0(void)", "code": "{\n    int i;\n    const size_t len = 0 / 8; // bits -> bytes\n    const char msg[] = { 0x00 };\n    const char exp[64] = { 0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd, 0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07, 0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc, 0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce, 0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0, 0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f, 0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81, 0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e };\n    char out[64] = { };\n\n    sha512(msg, len, out, 64);\n    for (i = 0; i < 64; i++) ASSERT(out[i] == exp[i], \"should match\");\n}", "path": "check-sha512.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* This function uses privately allocated static memory. Caution is advised. */\n", "func_signal": "static uint32_t *\nmanager_next_key(uint32_t *prev)", "code": "{\n    static uint32_t next[3];\n\n    sha512((char *) prev, 12, next, 12);\n    return next;\n}", "path": "manager.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* This is the meat of the distributed linking algorithm. */\n", "func_signal": "void\nprot_link(manager m, uint32_t *key, int len, peer_id *peer_ids, uint8_t rank,\n        prot_link_fn cb, void *data)", "code": "{\n    dirent de;\n    if (rank < DIRENT_W) {\n        node nodes[rank + 2];\n        int n = manager_find_owners(m, key, rank + 2, nodes,\n                manager_find_owners_none);\n\n        // Oops, they claim we have rank rank, but we don't even know that many\n        // distinct nodes. We must be missing some nodes.\n        if (rank >= n) {\n          // TODO something useful\n          return cb(m, key, error_code_insufficient_nodes, data);\n        }\n\n        // We seem to disagree about our proper rank.\n        if (!node_is_local(nodes[rank])) {\n          // TODO something useful\n          return cb(m, key, error_code_rank_mismatch, data);\n        }\n\n        node next = nodes[rank + 1];\n\n        // store entry for T under key K at rank R\n        de = manager_add_links(m, key, rank, len, peer_ids);\n        if (!de) return cb(m, key, error_code_add_links, data);\n\n        // No more nodes? We are last in the known order of succession.\n        if (rank + 1 >= n) return cb(m, key, error_code_success, data);\n\n        // LINK(K, T, R + 1) -> C\n        // when LINKED(K) <- C\n        //   LINKED(K) -> A\n        // Pass our continuation directly to this tail call.\n        prot_send_link(m, &next->peer, de, rank + 1, cb, data);\n\n        // Are we the primary owner? We are in charge of replication.\n        if (rank == 0) prot_start_copies(m, de);\n    } else if ((de = spht_get(m->directory, key))) {\n        // delete entry under key K\n        // C = next closest node\n        // LINK(K, T, R + 1) -> C\n        // when LINKED(K) <- C\n        // LINKED(K) -> A\n    } else {\n        return cb(m, key, error_code_success, data);\n    }\n}", "path": "prot.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* This will REMOVE a region from the free pool. The caller is responsible for\n   putting it back. */\n", "func_signal": "region\nmanager_pick_region(manager m, size_t size)", "code": "{\n    region r, tmp = 0;\n\n    // Pull out regions until we find one that's got enough space.\n    r = heap_take(&m->region_pool);\n    while (r && !region_has_space_for_blob(r, size)) {\n        r->next = tmp;\n        tmp = r;\n        r = heap_take(&m->region_pool);\n    }\n\n    // Put back the ones we didn't use.\n    for (; tmp; tmp = tmp->next) heap_give(&m->region_pool, tmp);\n\n    return r;\n}", "path": "manager.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "// Assumes correct type.\n", "func_signal": "static void\ncpkt_ping_handle(cpkt generic, peer p)", "code": "{\n    cpkt_ping c = (cpkt_ping) cpkt_check_size(generic, 0);\n\n    if (!c) return warnx(\"generic %p is not a ping packet\", generic);\n\n    manager_merge_nodes(p->manager, c->chain_len, c->root_key, p);\n\n    peer_send_pong(p);\n}", "path": "cpkt.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Sparse Array */\n", "func_signal": "sparr\nmake_sparr(int cap)", "code": "{\n    sparr a;\n    int ngroups = CEILDIV(cap, GROUP_SIZE);\n\n    a = malloc(sizeof(struct sparr) + ngroups * sizeof(spgroup));\n    if (!a) return warn(\"malloc\"), (sparr) 0;\n\n    a->cap = cap;\n    a->fill = 0;\n    memset(a->groups, 0, ngroups * sizeof(spgroup));\n\n    return a;\n}", "path": "sparr.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Keys must be little-endian. */\n", "func_signal": "int\nkey_distance_cmp(uint32_t *x, uint32_t *a, uint32_t *b)", "code": "{\n    uint8_t *X = (uint8_t *) x;\n    uint8_t *A = (uint8_t *) a;\n    uint8_t *B = (uint8_t *) b;\n\n    for (int i = 0; i < KEY_LEN; i++) {\n        uint8_t da = X[i] ^ A[i];\n        uint8_t db = X[i] ^ B[i];\n        if (da < db) return -1;\n        if (da > db) return 1;\n    }\n    return 0;\n}", "path": "key.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* returns port in network order */\n", "func_signal": "static int\nparse_port(const char *portstr)", "code": "{\n    int port;\n    char *end;\n\n    errno = 0;\n    port = strtol(portstr, &end, 10);\n    if (end == portstr) usage(\"invalid port\", portstr);\n    if (end[0] != 0) usage(\"invalid port\", portstr);\n    if (errno) usage(\"invalid port\", portstr);\n\n    return htons(port);\n}", "path": "cubbyd.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* assumes there is at least one item in the heap */\n", "func_signal": "static void\ndelete_min(heap hp)", "code": "{\n    hp->heap[0] = hp->heap[--hp->used];\n    if (hp->used) bubble_down(hp, 0);\n}", "path": "heap.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Test Progress Accounting functions */\n", "func_signal": "static void\ncut_mark_point(char out, char *filename, int lineNumber )", "code": "{\n  if ((count % 10) == 0) {\n    if ((count % 50) == 0) new_line();\n    print_integer_in_field( count, 5 );\n  }\n\n  print_character(out);\n  count++;\n\n  if( count == breakpoint )\n  {\n    print_string_as_error( filename, lineNumber, \"Breakpoint hit\" );\n    new_line();\n    cut_exit();\n  }\n}", "path": "cut.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "// Give up ownership of this dirent, if applicable.\n", "func_signal": "static void\nmanager_rebalance_dirent(manager mgr, dirent de)", "code": "{\n    // Continue only if we are the old owner.\n    if (de->rank != 0) return;\n\n    node owners[DIRENT_W];\n    int n = manager_find_owners(mgr, de->key, DIRENT_W, owners,\n            manager_find_owners_none);\n    if (n < 1) return warnx(\"no owners\"); // can't happen\n\n    // Check if there are any new bootstrapping owners.\n    int needs_work = 0;\n    for (int i = 0; i < n; i++) {\n        if (!owners[i]->peer->state == peer_state_in_rebalance) {\n            needs_work = 1;\n        }\n    }\n\n    if (needs_work) {\n        // Assume we are out of range. If this is wrong, our closer neighbor\n        // will correct us.\n        de->rank = DIRENT_W;\n\n        // We will check for necessary file copies on the other side.\n        prot_send_primary_link(mgr, de, manager_rebalance_dirent_cb, 0);\n    } else {\n        prot_start_copies(mgr, de);\n    }\n}", "path": "manager.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* defined as extern in util.h */\n", "func_signal": "static void\nraw_vwarnx(const char *err, const char *fmt, va_list args)", "code": "{\n    fprintf(stderr, \"%s:%d: \", progname, util_id);\n    if (fmt) {\n        vfprintf(stderr, fmt, args);\n        if (err) fprintf(stderr, \": %s\", strerror(errno));\n    }\n    fputc('\\n', stderr);\n    fflush(stderr);\n}", "path": "util.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* I/O Functions */\n", "func_signal": "static void print_string( char *string )", "code": "{\n  printf( \"%s\", string );\n  fflush( stdout );\n}", "path": "cut.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* CUT Initialization and Takedown  Functions */\n", "func_signal": "void cut_init(const char *prog_name, int brkpoint )", "code": "{\n  breakpoint = brkpoint;\n  count = 0;\n  program = prog_name;\n\n  if( brkpoint >= 0 )\n  {\n    print_string( \"Breakpoint at test \" );\n    print_integer( brkpoint );\n    new_line();\n  }\n}", "path": "cut.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* If the peer does not exist, it will be created. */\n", "func_signal": "peer\nmanager_get_peer(manager m, in_addr_t addr, uint16_t port)", "code": "{\n    for (int i = 0; i < m->peers_fill; i++) {\n        peer p = m->peers[i];\n        if (p->addr == addr && p->cp_port == port) return p;\n    }\n\n    peer p = make_peer(m, addr, port);\n    if (!p) return warnx(\"make_peer\"), (peer) 0;\n\n    int r = manager_insert_peer(m, p);\n    if (r == -1) return warnx(\"manager_insert_peer\"), (peer) 0;\n\n    return p;\n}", "path": "manager.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Sparse Group */\n", "func_signal": "spgroup\nmake_spgroup()", "code": "{\n    spgroup g;\n\n    g = malloc(sizeof(struct spgroup));\n    if (!g) return warn(\"malloc\"), (spgroup) 0;\n\n    memset(g, 0, sizeof(*g));\n\n    return g;\n}", "path": "sparr.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "// Assume ownership of this dirent, if applicable.\n", "func_signal": "static void\nmanager_recover_dirent(manager mgr, dirent de)", "code": "{\n    node owners[DIRENT_W], active_owner = 0;\n    int n = manager_find_owners(mgr, de->key, DIRENT_W, owners,\n            manager_find_owners_include_inactive);\n    if (n < 1) return warnx(\"no owners\"); // can't happen\n\n    // Check if there are any broken owners in recovery.\n    int needs_work = 0;\n    for (int i = 0; i < n; i++) {\n        if (node_is_active(owners[i])) {\n            // Find the first active owner.\n            if (!active_owner) active_owner = owners[i];\n        } else if (owners[i]->peer->state == peer_state_in_recovery) {\n            needs_work = 1;\n        }\n    }\n\n    if (needs_work) {\n        if (!active_owner) return warnx(\"no active owners\"); // can't happen\n\n        // Continue only if we are the (possibly new) owner.\n        if (active_owner->peer != mgr->self) return;\n\n        // We will check for necessary file copies on the other side.\n        prot_send_primary_link(mgr, de, manager_rebalance_dirent_cb, 0);\n    } else {\n        // Continue only if we are the owner.\n        if (de->rank != 0) return;\n\n        prot_start_copies(mgr, de);\n    }\n}", "path": "manager.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Expects ADDR and PORT to be in network order (big-endian). */\n/* Fills in 12 bytes starting at KEY. */\n", "func_signal": "void\nkey_for_peer(uint32_t *key, in_addr_t addr, uint16_t port)", "code": "{\n    struct __attribute__ ((__packed__)) {\n        uint32_t addr; // always big-endian\n        uint16_t port; // always big-endian\n    } buf = { addr, port };\n    sha512((char *) &buf, sizeof(buf), key, sizeof(uint32_t) * 3);\n}", "path": "util.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* count the bits up to, but not including, index i */\n", "func_signal": "static uint16_t\nbmcount(uint8_t *bm, uint16_t i)", "code": "{\n    uint16_t c, res = 0;\n    static const char cbits[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n    };\n\n    for (c = i / 8; c; c--) res += cbits[*bm++];\n    return res + cbits[*bm & ((1 << (i % 8)) - 1)];\n}", "path": "sparr.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* return 0 on success, -1 on failure */\n", "func_signal": "static int\nensure_cap(spht h, size_t delta)", "code": "{\n    int r;\n    size_t i;\n    sparr new_table;\n\n    if (h->table->fill + delta <= h->enlarge_threshold) return 0;\n\n    // Don't allocate space for deleted items. This means we might shrink if\n    // there are a lot of deleted items, but that's okay.\n    new_table = make_sparr(valid_size(h->table->fill + delta - h->ndel));\n    if (!new_table) return warnx(\"make_sparr\"), -1;\n\n    // Jumping through all these hoops just to avoid some unnecessary checks\n    // while rehashing. With good branch prediction it might be better just to\n    // use the normal make_spht, spht_set, etc.\n    for (i = 0; i < h->table->cap; i++) {\n        struct position pos;\n        dirent v = sparr_get(h->table, i);\n\n        // Possibly could speed up this loop by skipping over empty buckets,\n        // with assistance from sparr/spgroup.\n        if (!v || v == invalid_dirent) continue;\n\n        find_position(new_table, &pos, v->key);\n        r = sparr_set(new_table, pos.insert, v);\n        if (r == -1) {\n            warnx(\"sparr_set\");\n            sparr_free(new_table);\n            return -1;\n        }\n    }\n\n    // Become the new table.\n    sparr_free(h->table);\n    h->ndel = 0;\n    h->table = new_table;\n    h->enlarge_threshold = h->table->cap * FILL_RATIO;\n\n    return 0;\n}", "path": "spht.c", "repo_name": "kr/cubby", "stars": 16, "license": "gpl-3.0", "language": "c", "size": 1628}
{"docstring": "/* Queues each chunk of a file to be written to contiguous data block\n   regions */\n", "func_signal": "static void extent_create_backing_file(struct block_allocation *alloc,\n\tu64 backing_len, const char *filename)", "code": "{\n\toff_t offset = 0;\n\tfor (; alloc != NULL && backing_len > 0; get_next_region(alloc)) {\n\t\tu32 region_block;\n\t\tu32 region_len;\n\t\tu32 len;\n\t\tget_region(alloc, &region_block, &region_len);\n\n\t\tlen = min(region_len * info.block_size, backing_len);\n\n\t\tqueue_data_file(filename, offset, len, region_block);\n\t\toffset += len;\n\t\tbacking_len -= len;\n\t}\n}", "path": "extent.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Marks a the first num_blocks blocks in a block group as used, and accounts\n for them in the block group free block info. */\n", "func_signal": "static int reserve_blocks(struct block_group_info *bg, u32 start, u32 num)", "code": "{\n\tunsigned int i = 0;\n\n\tu32 block = start;\n\tif (num > bg->free_blocks)\n\t\treturn -1;\n\n\tfor (i = 0; i < num && block % 8 != 0; i++, block++) {\n\t\tif (bitmap_set_bit(bg->block_bitmap, block)) {\n\t\t\terror(\"attempted to reserve already reserved block\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (; i + 8 <= (num & ~7); i += 8, block += 8) {\n\t\tif (bitmap_set_8_bits(bg->block_bitmap, block)) {\n\t\t\terror(\"attempted to reserve already reserved block\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (; i < num; i++, block++) {\n\t\tif (bitmap_set_bit(bg->block_bitmap, block)) {\n\t\t\terror(\"attempted to reserve already reserved block\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbg->free_blocks -= num;\n\tif (start == bg->first_free_block)\n\t\tbg->first_free_block = start + num;\n\n\treturn 0;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocates enough blocks to hold len bytes, queues them to be written\n   from a file, and connects them to an inode. */\n", "func_signal": "void inode_allocate_file_extents(struct ext4_inode *inode, u64 len,\n\tconst char *filename)", "code": "{\n\tstruct block_allocation *alloc;\n\n\talloc = do_inode_allocate_extents(inode, len);\n\tif (alloc == NULL) {\n\t\terror(\"failed to allocate extents for %llu bytes\", len);\n\t\treturn;\n\t}\n\n\textent_create_backing_file(alloc, len, filename);\n\n\tfree_alloc(alloc);\n}", "path": "extent.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocate a single block and return its block number */\n", "func_signal": "u32 allocate_block()", "code": "{\n\tunsigned int i;\n\tfor (i = 0; i < aux_info.groups; i++) {\n\t\tu32 block = ext4_allocate_blocks_from_block_group(1, i);\n\n\t\tif (block != EXT4_ALLOCATE_FAILED)\n\t\t\treturn block;\n\t}\n\n\treturn EXT4_ALLOCATE_FAILED;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Returns 1 if the bg contains a backup superblock.  On filesystems with\n   the sparse_super feature, only block groups 0, 1, and powers of 3, 5,\n   and 7 have backup superblocks.  Otherwise, all block groups have backup\n   superblocks */\n", "func_signal": "int ext4_bg_has_super_block(int bg)", "code": "{\n\t/* Without sparse_super, every block group has a superblock */\n\tif (!(info.feat_ro_compat & EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\n\tif (bg == 0 || bg == 1)\n\t\treturn 1;\n\n\tif (is_power_of(bg, 3) || is_power_of(bg, 5) || is_power_of(bg, 7))\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "ext4_utils.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Creates data buffers for the first backing_len bytes of a block allocation\n   and queues them to be written */\n", "func_signal": "static u8 *extent_create_backing(struct block_allocation *alloc,\n\tu64 backing_len)", "code": "{\n\tu8 *data = calloc(backing_len, 1);\n\tif (!data)\n\t\tcritical_error_errno(\"calloc\");\n\n\tu8 *ptr = data;\n\tfor (; alloc != NULL && backing_len > 0; get_next_region(alloc)) {\n\t\tu32 region_block;\n\t\tu32 region_len;\n\t\tu32 len;\n\t\tget_region(alloc, &region_block, &region_len);\n\n\t\tlen = min(region_len * info.block_size, backing_len);\n\n\t\tqueue_data_block(ptr, len, region_block);\n\t\tptr += len;\n\t\tbacking_len -= len;\n\t}\n\n\treturn data;\n}", "path": "extent.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Increments the directory count of the block group that contains inode */\n", "func_signal": "void add_directory(u32 inode)", "code": "{\n\tint bg = (inode - 1) / info.inodes_per_group;\n\taux_info.bgs[bg].used_dirs += 1;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocates enough blocks to hold len bytes and connects them to an inode */\n", "func_signal": "void inode_allocate_extents(struct ext4_inode *inode, u64 len)", "code": "{\n\tstruct block_allocation *alloc;\n\n\talloc = do_inode_allocate_extents(inode, len);\n\tif (alloc == NULL) {\n\t\terror(\"failed to allocate extents for %llu bytes\", len);\n\t\treturn;\n\t}\n\n\tfree_alloc(alloc);\n}", "path": "extent.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Gets the starting block and length in blocks of the first region\n   of an allocation */\n", "func_signal": "void get_region(struct block_allocation *alloc, u32 *block, u32 *len)", "code": "{\n\t*block = alloc->list.iter->block;\n\t*len = alloc->list.iter->len - alloc->list.partial_iter;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Returns the first free inode number\n   TODO: Inodes should be allocated in the block group of the data? */\n", "func_signal": "u32 allocate_inode()", "code": "{\n\tunsigned int bg;\n\tu32 inode;\n\n\tfor (bg = 0; bg < aux_info.groups; bg++) {\n\t\tinode = reserve_inodes(bg, 1);\n\t\tif (inode != EXT4_ALLOCATE_FAILED)\n\t\t\treturn bg * info.inodes_per_group + inode;\n\t}\n\n\treturn EXT4_ALLOCATE_FAILED;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Returns the block number of the block'th block in an allocation */\n", "func_signal": "u32 get_block(struct block_allocation *alloc, u32 block)", "code": "{\n\tstruct region *reg = alloc->list.iter;\n\tblock += alloc->list.partial_iter;\n\n\tfor (; reg; reg = reg->next) {\n\t\tif (block < reg->len)\n\t\t\treturn reg->block + block;\n\t\tblock -= reg->len;\n\t}\n\treturn EXT4_ALLOCATE_FAILED;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Returns an ext4_inode structure for an inode number */\n", "func_signal": "struct ext4_inode *get_inode(u32 inode)", "code": "{\n\tinode -= 1;\n\tint bg = inode / info.inodes_per_group;\n\tinode %= info.inodes_per_group;\n\n\tallocate_bg_inode_table(&aux_info.bgs[bg]);\n\treturn (struct ext4_inode *)(aux_info.bgs[bg].inode_table + inode *\n\t\tinfo.inode_size);\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocates enough blocks to hold len bytes, with backing_len bytes in a data\n   buffer, and connects them to an inode.  Returns a pointer to the data\n   buffer. */\n", "func_signal": "u8 *inode_allocate_data_extents(struct ext4_inode *inode, u64 len,\n\tu64 backing_len)", "code": "{\n\tstruct block_allocation *alloc;\n\tu8 *data = NULL;\n\n\talloc = do_inode_allocate_extents(inode, len);\n\tif (alloc == NULL) {\n\t\terror(\"failed to allocate extents for %llu bytes\", len);\n\t\treturn NULL;\n\t}\n\n\tif (backing_len) {\n\t\tdata = extent_create_backing(alloc, backing_len);\n\t\tif (!data)\n\t\t\terror(\"failed to create backing for %llu bytes\", backing_len);\n\t}\n\n\tfree_alloc(alloc);\n\n\treturn data;\n}", "path": "extent.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Update the number of free blocks and inodes in the filesystem and in each\n   block group */\n", "func_signal": "void ext4_update_free()", "code": "{\n\tunsigned int i;\n\n\tfor (i = 0; i < aux_info.groups; i++) {\n\t\tu32 bg_free_blocks = get_free_blocks(i);\n\t\tu32 bg_free_inodes = get_free_inodes(i);\n\n\t\taux_info.bg_desc[i].bg_free_blocks_count = bg_free_blocks;\n\t\taux_info.sb->s_free_blocks_count_lo += bg_free_blocks;\n\n\t\taux_info.bg_desc[i].bg_free_inodes_count = bg_free_inodes;\n\t\taux_info.sb->s_free_inodes_count += bg_free_inodes;\n\n\t\taux_info.bg_desc[i].bg_used_dirs_count += get_directories(i);\n\t}\n}", "path": "ext4_utils.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Compute the rest of the parameters of the filesystem from the basic info */\n", "func_signal": "void ext4_create_fs_aux_info()", "code": "{\n\taux_info.first_data_block = (info.block_size > 1024) ? 0 : 1;\n\taux_info.len_blocks = info.len / info.block_size;\n\taux_info.inode_table_blocks = DIV_ROUND_UP(info.inodes_per_group * info.inode_size,\n\t\tinfo.block_size);\n\taux_info.groups = DIV_ROUND_UP(aux_info.len_blocks - aux_info.first_data_block,\n\t\tinfo.blocks_per_group);\n\taux_info.blocks_per_ind = info.block_size / sizeof(u32);\n\taux_info.blocks_per_dind = aux_info.blocks_per_ind * aux_info.blocks_per_ind;\n\taux_info.blocks_per_tind = aux_info.blocks_per_dind * aux_info.blocks_per_dind;\n\n\taux_info.bg_desc_blocks =\n\t\tDIV_ROUND_UP(aux_info.groups * sizeof(struct ext2_group_desc),\n\t\t\tinfo.block_size);\n\n\taux_info.bg_desc_reserve_blocks =\n\t\tDIV_ROUND_UP(aux_info.groups * 1024 * sizeof(struct ext2_group_desc),\n\t\t\tinfo.block_size) - aux_info.bg_desc_blocks;\n\n\tif (aux_info.bg_desc_reserve_blocks > aux_info.blocks_per_ind)\n\t\taux_info.bg_desc_reserve_blocks = aux_info.blocks_per_ind;\n\n\taux_info.default_i_flags = EXT4_NOATIME_FL;\n\n\tu32 last_group_size = aux_info.len_blocks % info.blocks_per_group;\n\tu32 last_header_size = 2 + aux_info.inode_table_blocks;\n\tif (ext4_bg_has_super_block(aux_info.groups - 1))\n\t\tlast_header_size += 1 + aux_info.bg_desc_blocks +\n\t\t\taux_info.bg_desc_reserve_blocks;\n\tif (last_group_size > 0 && last_group_size < last_header_size) {\n\t\taux_info.groups--;\n\t\taux_info.len_blocks -= last_group_size;\n\t}\n\n\taux_info.sb = calloc(info.block_size, 1);\n\tif (!aux_info.sb)\n\t\tcritical_error_errno(\"calloc\");\n\n\taux_info.bg_desc = calloc(info.block_size, aux_info.bg_desc_blocks);\n\tif (!aux_info.bg_desc)\n\t\tcritical_error_errno(\"calloc\");\n}", "path": "ext4_utils.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Splits an allocation into two allocations.  The returned allocation will\n   point to the first half, and the original allocation ptr will point to the\n   second half. */\n", "func_signal": "static struct region *split_allocation(struct block_allocation *alloc, u32 len)", "code": "{\n\t/* First make sure there is a split at the current ptr */\n\tdo_split_allocation(alloc, alloc->list.partial_iter);\n\n\t/* Then split off len blocks */\n\tstruct region *middle = do_split_allocation(alloc, len);\n\talloc->list.partial_iter = 0;\n\treturn middle;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocate the blocks to hold a journal inode and connect them to the\n   reserved journal inode */\n", "func_signal": "void ext4_create_journal_inode()", "code": "{\n\tstruct ext4_inode *inode = get_inode(EXT4_JOURNAL_INO);\n\tif (inode == NULL) {\n\t\terror(\"failed to get journal inode\");\n\t\treturn;\n\t}\n\n\tu8 *journal_data = inode_allocate_data_extents(inode,\n\t\t\tinfo.journal_blocks * info.block_size,\n\t\t\tinfo.journal_blocks * info.block_size);\n\tif (!journal_data) {\n\t\terror(\"failed to allocate extents for journal data\");\n\t\treturn;\n\t}\n\n\tinode->i_mode = S_IFREG | S_IRUSR | S_IWUSR;\n\tinode->i_links_count = 1;\n\n\tjournal_superblock_t *jsb = (journal_superblock_t *)journal_data;\n\tjsb->s_header.h_magic = htonl(JBD2_MAGIC_NUMBER);\n\tjsb->s_header.h_blocktype = htonl(JBD2_SUPERBLOCK_V2);\n\tjsb->s_blocksize = htonl(info.block_size);\n\tjsb->s_maxlen = htonl(info.journal_blocks);\n\tjsb->s_nr_users = htonl(1);\n\tjsb->s_first = htonl(1);\n\tjsb->s_sequence = htonl(1);\n\n\tmemcpy(aux_info.sb->s_jnl_blocks, &inode->i_block, sizeof(inode->i_block));\n}", "path": "ext4_utils.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Returns the number of discontiguous regions used by an allocation */\n", "func_signal": "int block_allocation_num_regions(struct block_allocation *alloc)", "code": "{\n\tunsigned int i;\n\tstruct region *reg = alloc->list.first;\n\n\tfor (i = 0; reg != NULL; reg = reg->next)\n\t\ti++;\n\n\treturn i;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* returns 1 if a is a power of b */\n", "func_signal": "static int is_power_of(int a, int b)", "code": "{\n\twhile (a > b) {\n\t\tif (a % b)\n\t\t\treturn 0;\n\t\ta /= b;\n\t}\n\n\treturn (a == b) ? 1 : 0;\n}", "path": "ext4_utils.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "/* Allocate len blocks.  The blocks may be spread across multiple block groups,\n   and are returned in a linked list of the blocks in each block group.  The\n   allocation algorithm is:\n      1.  Try to allocate the entire block len in each block group\n      2.  If the request doesn't fit in any block group, allocate as many\n          blocks as possible into each block group that is completely empty\n      3.  Put the last set of blocks in the first block group they fit in\n*/\n", "func_signal": "struct block_allocation *allocate_blocks(u32 len)", "code": "{\n\tstruct region *reg = do_allocate(len);\n\n\tif (reg == NULL)\n\t\treturn NULL;\n\n\tstruct block_allocation *alloc = create_allocation();\n\talloc->list.first = reg;\n\talloc->list.last = reg;\n\talloc->list.iter = alloc->list.first;\n\talloc->list.partial_iter = 0;\n\treturn alloc;\n}", "path": "allocate.c", "repo_name": "YuLaw/ext4-utils", "stars": 21, "license": "other", "language": "c", "size": 252}
{"docstring": "//\n//  Set noise frequency\n//\n", "func_signal": "static void SetNoiseFrequency(int frequency)", "code": "{\n   start = 1;\n   B = frequency;\n   BM = B-1;\n}", "path": "noise.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Initialize Noise\n//\n", "func_signal": "static void InitNoise(void)", "code": "{\n   int i,j,k;\n\n   srand(30757);\n   for (i=0;i<B;i++)\n   {\n      p[i] = i;\n      for (j=0;j<3;j++)\n         g3[i][j] = (double)((rand() % (B + B)) - B) / B;\n      normalize3(g3[i]);\n   }\n\n   while (--i)\n   {\n      k = p[i];\n      p[i] = p[j = rand() % B];\n      p[j] = k;\n   }\n\n   for (i=0;i<B+2;i++)\n   {\n      p[B+i] = p[i];\n      for (j=0;j<3;j++)\n         g3[B+i][j] = g3[i][j];\n   }\n}", "path": "noise.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//  Internal storage for line\n", "func_signal": "static char* readline(FILE* f)", "code": "{\n   char ch;  //  Character read\n   int k=0;  //  Character count\n   while ((ch = fgetc(f)) != EOF)\n   {\n      //  Allocate more memory for long strings\n      if (k>=linelen)\n      {\n         linelen += 8192;\n         line = (char*)realloc(line,linelen);\n         if (!line) Fatal(\"Out of memory in readline\\n\");\n      }\n      //  End of Line\n      if (CRLF(ch))\n      {\n         // Eat extra CR or LF characters (if any)\n         while ((ch = fgetc(f)) != EOF)\n           if (!CRLF(ch)) break;\n         //  Stick back the overrun\n         if (ch != EOF) ungetc(ch,f);\n         //  Bail\n         break;\n      }\n      //  Pad character to line\n      else\n         line[k++] = ch;\n   }\n   //  Terminate line if anything was read\n   if (k>0) line[k] = 0;\n   //  Return pointer to line or NULL on EOF\n   return k>0 ? line : NULL;\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  GLUT calls this routine when the window is resized\n */\n", "func_signal": "void reshape(int width,int height)", "code": "{\n   //  Ratio of the width to the height of the window\n   asp = (height>0) ? (double)width/height : 1;\n   //  Set the viewport to the entire window\n   glViewport(0,0, width,height);\n   //  Set image dimensions\n   W1 = width;\n   H1 = height;\n}", "path": "cvglsl.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Load OBJ file\n//\n", "func_signal": "int LoadOBJ(const char* file)", "code": "{\n   int k;\n   int  Nv,Nn,Nt;  //  Number of vertex, normal and textures\n   int  Mv,Mn,Mt;  //  Maximum vertex, normal and textures\n   float* V;       //  Array of vertexes\n   float* N;       //  Array of normals\n   float* T;       //  Array if textures coordinates\n   char*  line;    //  Line pointer\n   char*  str;     //  String pointer\n\n   //  Open file\n   FILE* f = fopen(file,\"r\");\n   if (!f) Fatal(\"Cannot open file %s\\n\",file);\n\n   // Reset materials\n   mtl = NULL;\n   Nmtl = 0;\n\n   //  Start new displaylist\n   int list = glGenLists(1);\n   glNewList(list,GL_COMPILE);\n   //  Push attributes for textures\n   glPushAttrib(GL_TEXTURE_BIT);\n\n   //  Read vertexes and facets\n   V  = N  = T  = NULL;\n   Nv = Nn = Nt = 0;\n   Mv = Mn = Mt = 0;\n   while ((line = readline(f)))\n   {\n      //  Vertex coordinates (always 3)\n      if (line[0]=='v' && line[1]==' ')\n         readcoord(line+2,3,&V,&Nv,&Mv);\n      //  Normal coordinates (always 3)\n      else if (line[0]=='v' && line[1] == 'n')\n         readcoord(line+2,3,&N,&Nn,&Mn);\n      //  Texture coordinates (always 2)\n      else if (line[0]=='v' && line[1] == 't')\n         readcoord(line+2,2,&T,&Nt,&Mt);\n      //  Read and draw facets\n      else if (line[0]=='f')\n      {\n         line++;\n         //  Read Vertex/Texture/Normal triplets\n         glBegin(GL_POLYGON);\n         while ((str = getword(&line)))\n         {\n            int Kv,Kt,Kn;\n            //  Try Vertex/Texture/Normal triplet\n            if (sscanf(str,\"%d/%d/%d\",&Kv,&Kt,&Kn)==3)\n            {\n               if (Kv<0 || Kv>Nv/3) Fatal(\"Vertex %d out of range 1-%d\\n\",Kv,Nv/3);\n               if (Kn<0 || Kn>Nn/3) Fatal(\"Normal %d out of range 1-%d\\n\",Kn,Nn/3);\n               if (Kt<0 || Kt>Nt/2) Fatal(\"Texture %d out of range 1-%d\\n\",Kt,Nt/2);\n            }\n            //  Try Vertex//Normal pairs\n            else if (sscanf(str,\"%d//%d\",&Kv,&Kn)==2)\n            {\n               if (Kv<0 || Kv>Nv/3) Fatal(\"Vertex %d out of range 1-%d\\n\",Kv,Nv/3);\n               if (Kn<0 || Kn>Nn/3) Fatal(\"Normal %d out of range 1-%d\\n\",Kn,Nn/3);\n               Kt = 0;\n            }\n            //  Try Vertex index\n            else if (sscanf(str,\"%d\",&Kv)==1)\n            {\n               if (Kv<0 || Kv>Nv/3) Fatal(\"Vertex %d out of range 1-%d\\n\",Kv,Nv/3);\n               Kn = 0;\n               Kt = 0;\n            }\n            //  This is an error\n            else\n               Fatal(\"Invalid facet %s\\n\",str);\n            //  Draw vectors\n            if (Kt) glTexCoord2fv(T+2*(Kt-1));\n            if (Kn) glNormal3fv(N+3*(Kn-1));\n            if (Kv) glVertex3fv(V+3*(Kv-1));\n         }\n         glEnd();\n      }\n      //  Use material\n      else if ((str = readstr(line,\"usemtl\")))\n         SetMaterial(str);\n      //  Load materials\n      else if ((str = readstr(line,\"mtllib\")))\n         LoadMaterial(str);\n      //  Skip this line\n   }\n   fclose(f);\n   //  Pop attributes (textures)\n   glPopAttrib();\n   glEndList();\n\n   //  Free materials\n   for (k=0;k<Nmtl;k++)\n      free(mtl[k].name);\n   free(mtl);\n\n   //  Free arrays\n   free(V);\n   free(T);\n   free(N);\n\n   return list;\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Read coordinates\n//    n is how many coordiantes to read\n//    N is the coordinate index\n//    M is the number of coordinates\n//    x is the array\n//    This function adds more memory as needed in 8192 work chunks\n//\n", "func_signal": "static void readcoord(char* line,int n,float* x[],int* N,int* M)", "code": "{\n   //  Allocate memory if necessary\n   if (*N+n > *M)\n   {\n      *M += 8192;\n      *x = (float*)realloc(*x,(*M)*sizeof(float));\n      if (!*x) Fatal(\"Cannot allocate memory\\n\");\n   }\n   //  Read n coordinates\n   readfloat(line,n,(*x)+*N);\n   (*N)+=n;\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Read to next non-whitespace word\n//  Note that this destroys line in the process\n//\n", "func_signal": "static char* getword(char** line)", "code": "{\n   char* word;\n   //  Skip leading whitespace\n   while (**line && isspace(**line))\n      (*line)++;\n   if (!**line) return NULL;\n   //  Start of word\n   word = *line;\n   //  Read until next whitespace\n   while (**line && !isspace(**line))\n      (*line)++;\n   //  Mark end of word if not NULL\n   if (**line)\n   {\n      **line = 0;\n      (*line)++;\n   }\n   return word;\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Read string conditionally\n//     Line must start with skip string\n//     After skip sting return first word\n//     getword terminates the line\n//\n", "func_signal": "static char* readstr(char* line,const char* skip)", "code": "{\n   //  Check for a match on the skip string\n   while (*skip && *line && *skip==*line)\n   {\n      skip++;\n      line++;\n   }\n   //  Skip must be NULL for a match\n   if (*skip || !isspace(*line)) return NULL;\n   //  Read string\n   return getword(&line);\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  GLUT calls this routine when a key is pressed\n */\n", "func_signal": "void key(unsigned char ch,int x,int y)", "code": "{\n   //  Exit on ESC\n   if (ch == 27)\n      exit(0);\n   //  Reset view\n   else if (ch == '0')\n      X = Y = 0;\n   //  Cycle modes\n   else if (ch == 'm')\n      mode = (mode+1)%MODE;\n   else if (ch == 'M')\n      mode = (mode+MODE-1)%MODE;\n   //  Passes\n   else if (ch == 'N' && N>1)\n      N--;\n   else if (ch == 'n')\n      N++;\n   //  Toggle axes\n   else if (ch == 'a')\n      axes = !axes;\n   //  Tell GLUT it is necessary to redisplay the scene\n   glutPostRedisplay();\n}", "path": "cvglsl.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Read n floats\n//\n", "func_signal": "static void readfloat(char* line,int n,float x[])", "code": "{\n   int i;\n   for (i=0;i<n;i++)\n   {\n      char* str = getword(&line);\n      if (!str)  Fatal(\"Premature EOL reading %d floats\\n\",n);\n      if (sscanf(str,\"%f\",x+i)!=1) Fatal(\"Error reading float %d\\n\",i);\n   }\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  Function called to capture images at 20ms intervals\n */\n", "func_signal": "void capture(int k)", "code": "{\n   //  Capture image\n   IplImage* img = cvQueryFrame(cv); \n   if (!img) Fatal(\"Image capture failed\\n\");\n\n   /* tests\n//   printf(\":%d\\n\",img->);\n   printf(\"nSize:%d\\n\",img->nSize);\n   printf(\"nChannels:%d\\n\",img->nChannels);\n   printf(\"alphaChannel:%d\\n\",img->alphaChannel);\n   printf(\"depth:%d\\n\",img->depth);\n   printf(\"colorModel:%s\\n\",img->colorModel);\n   printf(\"channelSeq:%s\\n\",img->channelSeq);\n   printf(\"dataOrder:%d\\n\",img->dataOrder);\n   printf(\"origin:%d\\n\",img->origin);\n   printf(\"align:%d\\n\",img->align);\n   printf(\"step:%d\\n\",img->widthStep);\n   printf(\"width:%d\\n\",img->width);\n   printf(\"channels:%d\\n\",img->nChannels);\n   printf(\"---\\n\\n\");\n   //cvShowImage(\"Live Cam\", img);\n   */\n   \n   //  Copy image to texture\n   glBindTexture(GL_TEXTURE_2D,cvtex);\n   \n   int mode = GL_RGB;\n   int type = GL_UNSIGNED_BYTE;\n   \n   if (strcmp(img->channelSeq,\"BGR\") == 0) {\n\t   mode = GL_BGR;\n   }\n   \n   // functional mac approach is from here:\n   // http://www.alecjacobson.com/weblog/?p=1875\n   // Image is memory aligned which means we there may be extra space at the end\n   // of each row. gluBuild2DMipmaps needs contiguous data, so we buffer it here\n   char * buffer = malloc (sizeof(char) * img->width * img->height * img->nChannels);\n   int step     = img->widthStep;\n   int height   = img->height;\n   int width    = img->width;\n   int channels = img->nChannels;\n   char * data  = (char *)img->imageData;\n   int i = 0;\n   for(;i<height;i++) {\n  \t memcpy(&buffer[i*width*channels],&(data[i*step]),width*channels);\n   }\n   glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,img->width,img->height,0,mode,type,buffer);\n   \n   ErrCheck(\"Capture\");\n   W0 = img->width;\n   H0 = img->height;\n\n   //  Set timer\n   glutTimerFunc(20,capture,0);\n\n   //  Display\n   glutPostRedisplay();\n   \n   free(buffer);\n}", "path": "cvglsl.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  Reverse n bytes\n */\n", "func_signal": "static void Reverse(void* x,const int n)", "code": "{\n   int k;\n   char* ch = (char*)x;\n   for (k=0;k<n/2;k++)\n   {\n      char tmp = ch[k];\n      ch[k] = ch[n-1-k];\n      ch[n-1-k] = tmp;\n   }\n}", "path": "loadtexbmp.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  GLUT calls this routine when an arrow key is pressed\n */\n", "func_signal": "void special(int key,int x,int y)", "code": "{\n   //  Right arrow key - increase angle by 5 degrees\n   if (key == GLUT_KEY_RIGHT)\n      X -= 0.03/zoom;\n   //  Left arrow key - decrease angle by 5 degrees\n   else if (key == GLUT_KEY_LEFT)\n      X += 0.03/zoom;\n   //  Up arrow key - increase elevation by 5 degrees\n   else if (key == GLUT_KEY_UP)\n      Y -= 0.03/zoom;\n   //  Down arrow key - decrease elevation by 5 degrees\n   else if (key == GLUT_KEY_DOWN)\n      Y += 0.03/zoom;\n   //  PageUp key - increase zoom\n   else if (key == GLUT_KEY_PAGE_DOWN)\n      zoom /= 1.1;\n   //  PageDown key - decrease zoom\n   else if (key == GLUT_KEY_PAGE_UP)\n      zoom *= 1.1;\n   //  Limit zoom\n   if (zoom<1)\n   {\n      zoom = 1;\n      X = Y = 0;\n   }\n   //  Tell GLUT it is necessary to redisplay the scene\n   glutPostRedisplay();\n}", "path": "cvglsl.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  Start up GLUT and tell it what to do\n */\n", "func_signal": "int main(int argc,char* argv[])", "code": "{\n   //  Initialize GLUT\n   glutInit(&argc,argv);\n   //  Request double buffered, true color window with Z buffering at 600x600\n   glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);\n   glutInitWindowSize(600, 600);\n   glutCreateWindow(\"CVGLSL\");\n#ifdef USEGLEW\n   //  Initialize GLEW\n   if (glewInit()!=GLEW_OK) Fatal(\"Error initializing GLEW\\n\");\n   if (!GLEW_VERSION_2_0) Fatal(\"OpenGL 2.0 not supported\\n\");\n#endif\n   //  Set callbacks\n   glutDisplayFunc(display);\n   glutReshapeFunc(reshape);\n   glutSpecialFunc(special);\n   glutKeyboardFunc(key);\n   //  Initialize OpenCV\n   cv = cvCreateCameraCapture(0);\n   if (!cv) Fatal(\"Could not initialize OpenCV\\n\");\n   //  Texture to store image\n     \n   glGenTextures(1,&cvtex);\n   glBindTexture(GL_TEXTURE_2D,cvtex);\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);\n   \n   //  Texture to post-process image\n   glGenTextures(1,&imtex);\n   glBindTexture(GL_TEXTURE_2D,imtex);\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);\n\n   //  Start image capture\n   capture(0);\n   \n   //  Create Shader Programs\n   shader[1] = CreateShaderProg(NULL,\"copy.frag\");\n   shader[2] = CreateShaderProg(NULL,\"sharpen.frag\");\n   shader[3] = CreateShaderProg(NULL,\"blur.frag\");\n   shader[4] = CreateShaderProg(NULL,\"erosion.frag\");\n   shader[5] = CreateShaderProg(NULL,\"dilation.frag\");\n   shader[6] = CreateShaderProg(NULL,\"laplacian.frag\");\n   shader[7] = CreateShaderProg(NULL,\"prewitt.frag\");\n   shader[8] = CreateShaderProg(NULL,\"sobel.frag\");\n   \n   shader[9] = CreateShaderProg(NULL,\"vignette.frag\");\n   shader[10] = CreateShaderProg(NULL,\"crosshatch.frag\");\n   shader[11] = CreateShaderProg(NULL,\"crosshatch2.frag\");\n   shader[12] = CreateShaderProg(NULL,\"nvscope.frag\");\n   shader[13] = CreateShaderProg(NULL,\"thermal.frag\");\n   shader[14] = CreateShaderProg(NULL,\"posterize.frag\");\n   shader[15] = CreateShaderProg(NULL,\"dream.frag\");\n   shader[16] = CreateShaderProg(NULL,\"pixelation.frag\");\n   shader[17] = CreateShaderProg(\"toon.vert\",\"toon.frag\");\n   shader[18] = CreateShaderProg(\"billboard.vert\",\"billboard.frag\");\n   shader[19] = CreateShaderProg(\"grayscale.vert\",\"grayscale.frag\");\n   shader[20] = CreateShaderProg(\"sepia.vert\",\"sepia.frag\");\n   shader[21] = CreateShaderProg(\"invert.vert\",\"invert.frag\");\n   shader[22] = CreateShaderProg(NULL,\"halftone.frag\");\n   shader[23] = CreateShaderProg(NULL,\"hexpix.frag\");\n   shader[24] = CreateShaderProg(\"line.vert\",\"line.frag\");\n   shader[25] = CreateShaderProg(\"line2.vert\",\"line2.frag\");\n//   shader[26] = CreateShaderProg(\"roto.vert\",\"roto.frag\"); // CANT GET THIS ONE WORKING, PUNTING FOR NOW\n   shader[26] = CreateShaderProg(\"scanlines.vert\",\"scanlines.frag\");\n   shader[27] = CreateShaderProg(\"worhol.vert\",\"worhol.frag\");\n   \n   //  Pass control to GLUT so it can interact with the user\n   ErrCheck(\"init\");\n   glutMainLoop();\n   return 0;\n}", "path": "cvglsl.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//  Maximum length of text string\n", "func_signal": "void Print(const char* format , ...)", "code": "{\n   char    buf[LEN];\n   char*   ch=buf;\n   va_list args;\n   //  Turn the parameters into a character string\n   va_start(args,format);\n   vsnprintf(buf,LEN,format,args);\n   va_end(args);\n   //  Display the characters one at a time at the current raster position\n   while (*ch)\n      glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,*ch++);\n}", "path": "print.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  3D noise\n//\n", "func_signal": "static double noise3(double vec[3])", "code": "{\n   int bx0, bx1, by0, by1, bz0, bz1, b00, b10, b01, b11;\n   double rx0, rx1, ry0, ry1, rz0, rz1, *q, sy, sz, a, b, c, d, t, u, v;\n   int i, j;\n\n   if (start)\n   {\n      start = 0;\n      InitNoise();\n   }\n\n   setup(0, bx0, bx1, rx0, rx1);\n   setup(1, by0, by1, ry0, ry1);\n   setup(2, bz0, bz1, rz0, rz1);\n\n   i = p[bx0];\n   j = p[bx1];\n\n   b00 = p[i + by0];\n   b10 = p[j + by0];\n   b01 = p[i + by1];\n   b11 = p[j + by1];\n\n   t  = s_curve(rx0);\n   sy = s_curve(ry0);\n   sz = s_curve(rz0);\n\n   q = g3[b00 + bz0]; u = at3(rx0, ry0, rz0);\n   q = g3[b10 + bz0]; v = at3(rx1, ry0, rz0);\n   a = lerp(t,u,v);\n\n   q = g3[b01 + bz0]; u = at3(rx0, ry1, rz0);\n   q = g3[b11 + bz0]; v = at3(rx1, ry1, rz0);\n   b = lerp(t, u, v);\n\n   c = lerp(sy,a,b);\n\n   q = g3[b00 + bz1]; u = at3(rx0, ry0, rz1);\n   q = g3[b10 + bz1]; v = at3(rx1, ry0, rz1);\n   a = lerp(t, u, v);\n\n   q = g3[b01 + bz1]; u = at3(rx0, ry1, rz1);\n   q = g3[b11 + bz1]; v = at3(rx1, ry1, rz1);\n   b = lerp(t, u, v);\n\n   d = lerp(sy,a,b);\n\n   return lerp(sz,c,d);\n}", "path": "noise.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Set material\n//\n", "func_signal": "static void SetMaterial(const char* name)", "code": "{\n   int k;\n   //  Search materials for a matching name\n   for (k=0;k<Nmtl;k++)\n      if (!strcmp(mtl[k].name,name))\n      {\n         //  Set material colors\n         glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT  ,mtl[k].Ka);\n         glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE  ,mtl[k].Kd);\n         glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR ,mtl[k].Ks);\n         glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,&mtl[k].Ns);\n         //  Bind texture if specified\n         if (mtl[k].map)\n         {\n            glEnable(GL_TEXTURE_2D);\n            glBindTexture(GL_TEXTURE_2D,mtl[k].map);\n         }\n         else\n            glDisable(GL_TEXTURE_2D);\n         return;\n      }\n   //  No matches\n   fprintf(stderr,\"Unknown material %s\\n\",name);\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Load materials from file\n//\n", "func_signal": "static void LoadMaterial(const char* file)", "code": "{\n   int k=-1;\n   char* line;\n   char* str;\n\n   //  Open file or return with warning on error\n   FILE* f = fopen(file,\"r\");\n   if (!f)\n   {\n      fprintf(stderr,\"Cannot open material file %s\\n\",file);\n      return;\n   }\n\n   //  Read lines\n   while ((line = readline(f)))\n   {\n      //  New material\n      if ((str = readstr(line,\"newmtl\")))\n      {\n         int l = strlen(str);\n         //  Allocate memory for structure\n         k = Nmtl++;\n         mtl = (mtl_t*)realloc(mtl,Nmtl*sizeof(mtl_t));\n         //  Store name\n         mtl[k].name = (char*)malloc(l+1);\n         if (!mtl[k].name) Fatal(\"Cannot allocate %d for name\\n\",l+1);\n         strcpy(mtl[k].name,str);\n         //  Initialize materials\n         mtl[k].Ka[0] = mtl[k].Ka[1] = mtl[k].Ka[2] = 0;   mtl[k].Ka[3] = 1;\n         mtl[k].Kd[0] = mtl[k].Kd[1] = mtl[k].Kd[2] = 0;   mtl[k].Kd[3] = 1;\n         mtl[k].Ks[0] = mtl[k].Ks[1] = mtl[k].Ks[2] = 0;   mtl[k].Ks[3] = 1;\n         mtl[k].Ns  = 0;\n         mtl[k].d   = 0;\n         mtl[k].map = 0;\n      }\n      //  If no material short circuit here\n      else if (k<0)\n      {}\n      //  Ambient color\n      else if (line[0]=='K' && line[1]=='a')\n         readfloat(line+2,3,mtl[k].Ka);\n      //  Diffuse color\n      else if (line[0]=='K' && line[1] == 'd')\n         readfloat(line+2,3,mtl[k].Kd);\n      //  Specular color\n      else if (line[0]=='K' && line[1] == 's')\n         readfloat(line+2,3,mtl[k].Ks);\n      //  Material Shininess\n      else if (line[0]=='N' && line[1]=='s')\n         readfloat(line+2,1,&mtl[k].Ns);\n      //  Textures (must be BMP - will fail if not)\n      else if ((str = readstr(line,\"map_Kd\")))\n         mtl[k].map = LoadTexBMP(str);\n      //  Ignore line if we get here\n   }\n   fclose(f);\n}", "path": "object.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "//\n//  Normalize 3D vector\n//\n", "func_signal": "static void normalize3(double v[3])", "code": "{\n   double s;\n\n   s = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n   v[0] /=  s;\n   v[1] /=  s;\n   v[2] /=  s;\n}", "path": "noise.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n *  Load texture from BMP file\n */\n", "func_signal": "unsigned int LoadTexBMP(const char* file)", "code": "{\n   unsigned int   texture;    // Texture name\n   FILE*          f;          // File pointer\n   unsigned short magic;      // Image magic\n   unsigned int   dx,dy,size; // Image dimensions\n   unsigned short nbp,bpp;    // Planes and bits per pixel\n   unsigned char* image;      // Image data\n   unsigned int   k;          // Counter\n\n   //  Open file\n   f = fopen(file,\"rb\");\n   if (!f) Fatal(\"Cannot open file %s\\n\",file);\n   //  Check image magic\n   if (fread(&magic,2,1,f)!=1) Fatal(\"Cannot read magic from %s\\n\",file);\n   if (magic!=0x4D42 && magic!=0x424D) Fatal(\"Image magic not BMP in %s\\n\",file);\n   //  Seek to and read header\n   if (fseek(f,16,SEEK_CUR) || fread(&dx ,4,1,f)!=1 || fread(&dy ,4,1,f)!=1 ||\n       fread(&nbp,2,1,f)!=1 || fread(&bpp,2,1,f)!=1 || fread(&k,4,1,f)!=1)\n     Fatal(\"Cannot read header from %s\\n\",file);\n   //  Reverse bytes on big endian hardware (detected by backwards magic)\n   if (magic==0x424D)\n   {\n      Reverse(&dx,4);\n      Reverse(&dy,4);\n      Reverse(&nbp,2);\n      Reverse(&bpp,2);\n      Reverse(&k,4);\n   }\n   //  Check image parameters\n   if (dx<1 || dx>65536) Fatal(\"%s image width out of range: %d\\n\",file,dx);\n   if (dy<1 || dy>65536) Fatal(\"%s image height out of range: %d\\n\",file,dy);\n   if (nbp!=1)  Fatal(\"%s bit planes is not 1: %d\\n\",file,nbp);\n   if (bpp!=24) Fatal(\"%s bits per pixel is not 24: %d\\n\",file,bpp);\n   if (k!=0)    Fatal(\"%s compressed files not supported\\n\",file);\n#ifndef GL_VERSION_2_0\n   //  OpenGL 2.0 lifts the restriction that texture size must be a power of two\n   for (k=1;k<dx;k*=2);\n   if (k!=dx) Fatal(\"%s image width not a power of two: %d\\n\",file,dx);\n   for (k=1;k<dy;k*=2);\n   if (k!=dy) Fatal(\"%s image height not a power of two: %d\\n\",file,dy);\n#endif\n\n   //  Allocate image memory\n   size = 3*dx*dy;\n   image = (unsigned char*) malloc(size);\n   if (!image) Fatal(\"Cannot allocate %d bytes of memory for image %s\\n\",size,file);\n   //  Seek to and read image\n   if (fseek(f,20,SEEK_CUR) || fread(image,size,1,f)!=1) Fatal(\"Error reading data from image %s\\n\",file);\n   fclose(f);\n   //  Reverse colors (BGR -> RGB)\n   for (k=0;k<size;k+=3)\n   {\n      unsigned char temp = image[k];\n      image[k]   = image[k+2];\n      image[k+2] = temp;\n   }\n\n   //  Sanity check\n   ErrCheck(\"LoadTexBMP\");\n   //  Generate 2D texture\n   glGenTextures(1,&texture);\n   glBindTexture(GL_TEXTURE_2D,texture);\n   //  Copy image\n   glTexImage2D(GL_TEXTURE_2D,0,3,dx,dy,0,GL_RGB,GL_UNSIGNED_BYTE,image);\n   if (glGetError()) Fatal(\"Error in glTexImage2D %s %dx%d\\n\",file,dx,dy);\n   //  Scale linearly when image size doesn't match\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n\n   //  Free image memory\n   free(image);\n   //  Return texture name\n   return texture;\n}", "path": "loadtexbmp.c", "repo_name": "elespuru/elespuru-cvglsl", "stars": 30, "license": "None", "language": "c", "size": 113}
{"docstring": "/*\n * Modulo: R = A mod B\n */\n", "func_signal": "int mpi_mod_mpi(mpi * R, mpi * A, mpi * B)", "code": "{\n\tint ret;\n\n\tMPI_CHK(mpi_div_mpi(NULL, R, A, B));\n\n\twhile (mpi_cmp_int(R, 0) < 0)\n\t\tMPI_CHK(mpi_add_mpi(R, R, B));\n\n\twhile (mpi_cmp_mpi(R, B) >= 0)\n\t\tMPI_CHK(mpi_sub_mpi(R, R, B));\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Unallocate one or more mpi\n */\n", "func_signal": "void mpi_free(mpi * X, ...)", "code": "{\n\tva_list args;\n\n\tva_start(args, X);\n\n\twhile (X != NULL) {\n\t\tif (X->p != NULL) {\n\t\t\tmemset(X->p, 0, X->n * ciL);\n\t\t\tfree(X->p);\n\t\t}\n\n\t\tX->s = 1;\n\t\tX->n = 0;\n\t\tX->p = NULL;\n\n\t\tX = va_arg(args, mpi *);\n\t}\n\n\tva_end(args);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Write X into an opened file (or stdout if fout == NULL)\n */\n", "func_signal": "int mpi_write_file(char *p, mpi * X, int radix, FILE * fout)", "code": "{\n\tint n, ret;\n\tsize_t slen;\n\tsize_t plen;\n\tchar s[1024];\n\n\tn = sizeof(s);\n\tmemset(s, 0, n);\n\tn -= 2;\n\n\tMPI_CHK(mpi_write_string(X, radix, s, (int *)&n));\n\n\tif (p == NULL)\n\t\tp = \"\";\n\n\tplen = strlen(p);\n\tslen = strlen(s);\n\ts[slen++] = '\\r';\n\ts[slen++] = '\\n';\n\n\tif (fout != NULL) {\n\t\tif (fwrite(p, 1, plen, fout) != plen ||\n\t\t    fwrite(s, 1, slen, fout) != slen)\n\t\t\treturn (TROPICSSL_ERR_MPI_FILE_IO_ERROR);\n\t} else\n\t\tprintf(\"%s%s\", p, s);\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Although this PRNG has good statistical properties (eg. passes\n * DIEHARD), it is not cryptographically secure.\n */\n", "func_signal": "unsigned long int lcppm5(unsigned long int *state)", "code": "{\n\tunsigned long int u, v;\n\n\tu = v = state[4] ^ 1;\n\tstate[u & 3] ^= u;\n\tu ^= (v << 12) ^ (v >> 12);\n\tu ^= v * state[0];\n\tv >>= 8;\n\tu ^= v * state[1];\n\tv >>= 8;\n\tu ^= v * state[2];\n\tv >>= 8;\n\tu ^= v * state[3];\n\tu &= 0xFFFFFFFF;\n\tstate[4] = u;\n\n\treturn (u);\n}", "path": "programs\\test\\ssl_test.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int mpi_self_test(int verbose)", "code": "{\n\tint ret, i;\n\tmpi A, E, N, X, Y, U, V;\n\n\tmpi_init(&A, &E, &N, &X, &Y, &U, &V, NULL);\n\n\tMPI_CHK(mpi_read_string(&A, 16,\n\t\t\t\t\"EFE021C2645FD1DC586E69184AF4A31E\"\n\t\t\t\t\"D5F53E93B5F123FA41680867BA110131\"\n\t\t\t\t\"944FE7952E2517337780CB0DB80E61AA\"\n\t\t\t\t\"E7C8DDC6C5C6AADEB34EB38A2F40D5E6\"));\n\n\tMPI_CHK(mpi_read_string(&E, 16,\n\t\t\t\t\"B2E7EFD37075B9F03FF989C7C5051C20\"\n\t\t\t\t\"34D2A323810251127E7BF8625A4F49A5\"\n\t\t\t\t\"F3E27F4DA8BD59C47D6DAABA4C8127BD\"\n\t\t\t\t\"5B5C25763222FEFCCFC38B832366C29E\"));\n\n\tMPI_CHK(mpi_read_string(&N, 16,\n\t\t\t\t\"0066A198186C18C10B2F5ED9B522752A\"\n\t\t\t\t\"9830B69916E535C8F047518A889A43A5\"\n\t\t\t\t\"94B6BED27A168D31D4A52F88925AA8F5\"));\n\n\tMPI_CHK(mpi_mul_mpi(&X, &A, &N));\n\n\tMPI_CHK(mpi_read_string(&U, 16,\n\t\t\t\t\"602AB7ECA597A3D6B56FF9829A5E8B85\"\n\t\t\t\t\"9E857EA95A03512E2BAE7391688D264A\"\n\t\t\t\t\"A5663B0341DB9CCFD2C4C5F421FEC814\"\n\t\t\t\t\"8001B72E848A38CAE1C65F78E56ABDEF\"\n\t\t\t\t\"E12D3C039B8A02D6BE593F0BBBDA56F1\"\n\t\t\t\t\"ECF677152EF804370C1A305CAF3B5BF1\"\n\t\t\t\t\"30879B56C61DE584A0F53A2447A51E\"));\n\n\tif (verbose != 0)\n\t\tprintf(\"  MPI test #1 (mul_mpi): \");\n\n\tif (mpi_cmp_mpi(&X, &U) != 0) {\n\t\tif (verbose != 0)\n\t\t\tprintf(\"failed\\n\");\n\n\t\treturn (1);\n\t}\n\n\tif (verbose != 0)\n\t\tprintf(\"passed\\n\");\n\n\tMPI_CHK(mpi_div_mpi(&X, &Y, &A, &N));\n\n\tMPI_CHK(mpi_read_string(&U, 16, \"256567336059E52CAE22925474705F39A94\"));\n\n\tMPI_CHK(mpi_read_string(&V, 16,\n\t\t\t\t\"6613F26162223DF488E9CD48CC132C7A\"\n\t\t\t\t\"0AC93C701B001B092E4E5B9F73BCD27B\"\n\t\t\t\t\"9EE50D0657C77F374E903CDFA4C642\"));\n\n\tif (verbose != 0)\n\t\tprintf(\"  MPI test #2 (div_mpi): \");\n\n\tif (mpi_cmp_mpi(&X, &U) != 0 || mpi_cmp_mpi(&Y, &V) != 0) {\n\t\tif (verbose != 0)\n\t\t\tprintf(\"failed\\n\");\n\n\t\treturn (1);\n\t}\n\n\tif (verbose != 0)\n\t\tprintf(\"passed\\n\");\n\n\tMPI_CHK(mpi_exp_mod(&X, &A, &E, &N, NULL));\n\n\tMPI_CHK(mpi_read_string(&U, 16,\n\t\t\t\t\"36E139AEA55215609D2816998ED020BB\"\n\t\t\t\t\"BD96C37890F65171D948E9BC7CBAA4D9\"\n\t\t\t\t\"325D24D6A3C12710F10A09FA08AB87\"));\n\n\tif (verbose != 0)\n\t\tprintf(\"  MPI test #3 (exp_mod): \");\n\n\tif (mpi_cmp_mpi(&X, &U) != 0) {\n\t\tif (verbose != 0)\n\t\t\tprintf(\"failed\\n\");\n\n\t\treturn (1);\n\t}\n\n\tif (verbose != 0)\n\t\tprintf(\"passed\\n\");\n\n\tMPI_CHK(mpi_inv_mod(&X, &A, &N));\n\n\tMPI_CHK(mpi_read_string(&U, 16,\n\t\t\t\t\"003A0AAEDD7E784FC07D8F9EC6E3BFD5\"\n\t\t\t\t\"C3DBA76456363A10869622EAC2DD84EC\"\n\t\t\t\t\"C5B8A74DAC4D09E03B5E0BE779F2DF61\"));\n\n\tif (verbose != 0)\n\t\tprintf(\"  MPI test #4 (inv_mod): \");\n\n\tif (mpi_cmp_mpi(&X, &U) != 0) {\n\t\tif (verbose != 0)\n\t\t\tprintf(\"failed\\n\");\n\n\t\treturn (1);\n\t}\n\n\tif (verbose != 0)\n\t\tprintf(\"passed\\n\");\n\n\tif (verbose != 0)\n\t\tprintf(\"  MPI test #5 (simple gcd): \");\n\n\tfor (i = 0; i < GCD_PAIR_COUNT; i++) {\n\t\tMPI_CHK(mpi_lset(&X, gcd_pairs[i][0]));\n\t\tMPI_CHK(mpi_lset(&Y, gcd_pairs[i][1]));\n\n\t\tMPI_CHK(mpi_gcd(&A, &X, &Y));\n\n\t\tif (mpi_cmp_int(&A, gcd_pairs[i][2]) != 0) {\n\t\t\tif (verbose != 0)\n\t\t\t\tprintf(\"failed at %d\\n\", i);\n\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (verbose != 0)\n\t\tprintf(\"passed\\n\");\n\ncleanup:\n\n\tif (ret != 0 && verbose != 0)\n\t\tprintf(\"Unexpected error, return code = %08X\\n\", ret);\n\n\tmpi_free(&V, &U, &Y, &X, &N, &E, &A, NULL);\n\n\tif (verbose != 0)\n\t\tprintf(\"\\n\");\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Record layer functions\n */\n", "func_signal": "int ssl_write_record(ssl_context * ssl)", "code": "{\n\tint ret, len = ssl->out_msglen;\n\n\tSSL_DEBUG_MSG(2, (\"=> write record\"));\n\n\tssl->out_hdr[0] = (unsigned char)ssl->out_msgtype;\n\tssl->out_hdr[1] = (unsigned char)ssl->major_ver;\n\tssl->out_hdr[2] = (unsigned char)ssl->minor_ver;\n\tssl->out_hdr[3] = (unsigned char)(len >> 8);\n\tssl->out_hdr[4] = (unsigned char)(len);\n\n\tif (ssl->out_msgtype == SSL_MSG_HANDSHAKE) {\n\t\tssl->out_msg[1] = (unsigned char)((len - 4) >> 16);\n\t\tssl->out_msg[2] = (unsigned char)((len - 4) >> 8);\n\t\tssl->out_msg[3] = (unsigned char)((len - 4));\n\n\t\tmd5_update(&ssl->fin_md5, ssl->out_msg, len);\n\t\tsha1_update(&ssl->fin_sha1, ssl->out_msg, len);\n\t}\n\n\tif (ssl->do_crypt != 0) {\n\t\tif ((ret = ssl_encrypt_buf(ssl)) != 0) {\n\t\t\tSSL_DEBUG_RET(1, \"ssl_encrypt_buf\", ret);\n\t\t\treturn (ret);\n\t\t}\n\n\t\tlen = ssl->out_msglen;\n\t\tssl->out_hdr[3] = (unsigned char)(len >> 8);\n\t\tssl->out_hdr[4] = (unsigned char)(len);\n\t}\n\n\tssl->out_left = 5 + ssl->out_msglen;\n\n\tSSL_DEBUG_MSG(3, (\"output record: msgtype = %d, \"\n\t\t\t  \"version = [%d:%d], msglen = %d\",\n\t\t\t  ssl->out_hdr[0], ssl->out_hdr[1], ssl->out_hdr[2],\n\t\t\t  (ssl->out_hdr[3] << 8) | ssl->out_hdr[4]));\n\n\tSSL_DEBUG_BUF(4, \"output record sent to network\",\n\t\t      ssl->out_hdr, 5 + ssl->out_msglen);\n\n\tif ((ret = ssl_flush_output(ssl)) != 0) {\n\t\tSSL_DEBUG_RET(1, \"ssl_flush_output\", ret);\n\t\treturn (ret);\n\t}\n\n\tSSL_DEBUG_MSG(2, (\"<= write record\"));\n\n\treturn (0);\n}", "path": "library\\ssl_tls.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Enlarge to the specified number of limbs\n */\n", "func_signal": "int mpi_grow(mpi * X, int nblimbs)", "code": "{\n\tt_int *p;\n\n\tif (X->n < nblimbs) {\n\t\tif ((p = (t_int *) malloc(nblimbs * ciL)) == NULL)\n\t\t\treturn (1);\n\n\t\tmemset(p, 0, nblimbs * ciL);\n\n\t\tif (X->p != NULL) {\n\t\t\tmemcpy(p, X->p, X->n * ciL);\n\t\t\tmemset(X->p, 0, X->n * ciL);\n\t\t\tfree(X->p);\n\t\t}\n\n\t\tX->n = nblimbs;\n\t\tX->p = p;\n\t}\n\n\treturn (0);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Compare signed values\n */\n", "func_signal": "int mpi_cmp_mpi(mpi * X, mpi * Y)", "code": "{\n\tint i, j;\n\n\tfor (i = X->n - 1; i >= 0; i--)\n\t\tif (X->p[i] != 0)\n\t\t\tbreak;\n\n\tfor (j = Y->n - 1; j >= 0; j--)\n\t\tif (Y->p[j] != 0)\n\t\t\tbreak;\n\n\tif (i < 0 && j < 0)\n\t\treturn (0);\n\n\tif (i > j)\n\t\treturn (X->s);\n\tif (j > i)\n\t\treturn (-X->s);\n\n\tif (X->s > 0 && Y->s < 0)\n\t\treturn (1);\n\tif (Y->s > 0 && X->s < 0)\n\t\treturn (-1);\n\n\tfor (; i >= 0; i--) {\n\t\tif (X->p[i] > Y->p[i])\n\t\t\treturn (X->s);\n\t\tif (X->p[i] < Y->p[i])\n\t\t\treturn (-X->s);\n\t}\n\n\treturn (0);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Signed substraction: X = A - b\n */\n", "func_signal": "int mpi_sub_int(mpi * X, mpi * A, int b)", "code": "{\n\tmpi _B;\n\tt_int p[1];\n\n\tp[0] = (b < 0) ? -b : b;\n\t_B.s = (b < 0) ? -1 : 1;\n\t_B.n = 1;\n\t_B.p = p;\n\n\treturn (mpi_sub_mpi(X, A, &_B));\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Signed substraction: X = A - B\n */\n", "func_signal": "int mpi_sub_mpi(mpi * X, mpi * A, mpi * B)", "code": "{\n\tint ret, s = A->s;\n\n\tif (A->s * B->s > 0) {\n\t\tif (mpi_cmp_abs(A, B) >= 0) {\n\t\t\tMPI_CHK(mpi_sub_abs(X, A, B));\n\t\t\tX->s = s;\n\t\t} else {\n\t\t\tMPI_CHK(mpi_sub_abs(X, B, A));\n\t\t\tX->s = -s;\n\t\t}\n\t} else {\n\t\tMPI_CHK(mpi_add_abs(X, A, B));\n\t\tX->s = s;\n\t}\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Signed addition: X = A + b\n */\n", "func_signal": "int mpi_add_int(mpi * X, mpi * A, int b)", "code": "{\n\tmpi _B;\n\tt_int p[1];\n\n\tp[0] = (b < 0) ? -b : b;\n\t_B.s = (b < 0) ? -1 : 1;\n\t_B.n = 1;\n\t_B.p = p;\n\n\treturn (mpi_add_mpi(X, A, &_B));\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Import from an ASCII string\n */\n", "func_signal": "int mpi_read_string(mpi * X, int radix, char *s)", "code": "{\n\tint ret, i, j, n;\n\tt_int d;\n\tmpi T;\n\n\tif (radix < 2 || radix > 16)\n\t\treturn (TROPICSSL_ERR_MPI_BAD_INPUT_DATA);\n\n\tmpi_init(&T, NULL);\n\n\tif (radix == 16) {\n\t\tn = BITS_TO_LIMBS(strlen(s) << 2);\n\n\t\tMPI_CHK(mpi_grow(X, n));\n\t\tMPI_CHK(mpi_lset(X, 0));\n\n\t\tfor (i = strlen(s) - 1, j = 0; i >= 0; i--, j++) {\n\t\t\tif (i == 0 && s[i] == '-') {\n\t\t\t\tX->s = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tMPI_CHK(mpi_get_digit(&d, radix, s[i]));\n\t\t\tX->p[j / (2 * ciL)] |= d << ((j % (2 * ciL)) << 2);\n\t\t}\n\t} else {\n\t\tMPI_CHK(mpi_lset(X, 0));\n\n\t\tfor (i = 0; i < (int)strlen(s); i++) {\n\t\t\tif (i == 0 && s[i] == '-') {\n\t\t\t\tX->s = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tMPI_CHK(mpi_get_digit(&d, radix, s[i]));\n\t\t\tMPI_CHK(mpi_mul_int(&T, X, radix));\n\t\t\tMPI_CHK(mpi_add_int(X, &T, d));\n\t\t}\n\t}\n\ncleanup:\n\n\tmpi_free(&T, NULL);\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Convert an ASCII character to digit value\n */\n", "func_signal": "static int mpi_get_digit(t_int * d, int radix, char c)", "code": "{\n\t*d = 255;\n\n\tif (c >= 0x30 && c <= 0x39)\n\t\t*d = c - 0x30;\n\tif (c >= 0x41 && c <= 0x46)\n\t\t*d = c - 0x37;\n\tif (c >= 0x61 && c <= 0x66)\n\t\t*d = c - 0x57;\n\n\tif (*d >= (t_int) radix)\n\t\treturn (TROPICSSL_ERR_MPI_INVALID_CHARACTER);\n\n\treturn (0);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Signed addition: X = A + B\n */\n", "func_signal": "int mpi_add_mpi(mpi * X, mpi * A, mpi * B)", "code": "{\n\tint ret, s = A->s;\n\n\tif (A->s * B->s < 0) {\n\t\tif (mpi_cmp_abs(A, B) >= 0) {\n\t\t\tMPI_CHK(mpi_sub_abs(X, A, B));\n\t\t\tX->s = s;\n\t\t} else {\n\t\t\tMPI_CHK(mpi_sub_abs(X, B, A));\n\t\t\tX->s = -s;\n\t\t}\n\t} else {\n\t\tMPI_CHK(mpi_add_abs(X, A, B));\n\t\tX->s = s;\n\t}\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * SSL handshake -- server side\n */\n", "func_signal": "int ssl_handshake_server(ssl_context * ssl)", "code": "{\n\tint ret = 0;\n\n\tSSL_DEBUG_MSG(2, (\"=> handshake server\"));\n\n\twhile (ssl->state != SSL_HANDSHAKE_OVER) {\n\t\tSSL_DEBUG_MSG(2, (\"server state: %d\", ssl->state));\n\n\t\tif ((ret = ssl_flush_output(ssl)) != 0)\n\t\t\tbreak;\n\n\t\tswitch (ssl->state) {\n\t\tcase SSL_HELLO_REQUEST:\n\t\t\tssl->state = SSL_CLIENT_HELLO;\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *  <==   ClientHello\n\t\t\t */\n\t\tcase SSL_CLIENT_HELLO:\n\t\t\tret = ssl_parse_client_hello(ssl);\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *  ==>   ServerHello\n\t\t\t *        Certificate\n\t\t\t *      ( ServerKeyExchange  )\n\t\t\t *      ( CertificateRequest )\n\t\t\t *        ServerHelloDone\n\t\t\t */\n\t\tcase SSL_SERVER_HELLO:\n\t\t\tret = ssl_write_server_hello(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_SERVER_CERTIFICATE:\n\t\t\tret = ssl_write_certificate(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_SERVER_KEY_EXCHANGE:\n\t\t\tret = ssl_write_server_key_exchange(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_CERTIFICATE_REQUEST:\n\t\t\tret = ssl_write_certificate_request(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_SERVER_HELLO_DONE:\n\t\t\tret = ssl_write_server_hello_done(ssl);\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *  <== ( Certificate/Alert  )\n\t\t\t *        ClientKeyExchange\n\t\t\t *      ( CertificateVerify  )\n\t\t\t *        ChangeCipherSpec\n\t\t\t *        Finished\n\t\t\t */\n\t\tcase SSL_CLIENT_CERTIFICATE:\n\t\t\tret = ssl_parse_certificate(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_CLIENT_KEY_EXCHANGE:\n\t\t\tret = ssl_parse_client_key_exchange(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_CERTIFICATE_VERIFY:\n\t\t\tret = ssl_parse_certificate_verify(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_CLIENT_CHANGE_CIPHER_SPEC:\n\t\t\tret = ssl_parse_change_cipher_spec(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_CLIENT_FINISHED:\n\t\t\tret = ssl_parse_finished(ssl);\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *  ==>   ChangeCipherSpec\n\t\t\t *        Finished\n\t\t\t */\n\t\tcase SSL_SERVER_CHANGE_CIPHER_SPEC:\n\t\t\tret = ssl_write_change_cipher_spec(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_SERVER_FINISHED:\n\t\t\tret = ssl_write_finished(ssl);\n\t\t\tbreak;\n\n\t\tcase SSL_FLUSH_BUFFERS:\n\t\t\tSSL_DEBUG_MSG(2, (\"handshake: done\"));\n\t\t\tssl->state = SSL_HANDSHAKE_OVER;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tSSL_DEBUG_MSG(1, (\"invalid state %d\", ssl->state));\n\t\t\treturn (TROPICSSL_ERR_SSL_BAD_INPUT_DATA);\n\t\t}\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t}\n\n\tSSL_DEBUG_MSG(2, (\"<= handshake server\"));\n\n\treturn (ret);\n}", "path": "library\\ssl_srv.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Prime number generation\n */\n", "func_signal": "int mpi_gen_prime(mpi * X, int nbits, int dh_flag,\n\t\t  int (*f_rng) (void *), void *p_rng)", "code": "{\n\tint ret, k, n;\n\tunsigned char *p;\n\tmpi Y;\n\n\tif (nbits < 3)\n\t\treturn (TROPICSSL_ERR_MPI_BAD_INPUT_DATA);\n\n\tmpi_init(&Y, NULL);\n\n\tn = BITS_TO_LIMBS(nbits);\n\n\tMPI_CHK(mpi_grow(X, n));\n\tMPI_CHK(mpi_lset(X, 0));\n\n\tp = (unsigned char *)X->p;\n\tfor (k = 0; k < X->n * ciL; k++)\n\t\t*p++ = (unsigned char)f_rng(p_rng);\n\n\tk = mpi_msb(X);\n\tif (k < nbits)\n\t\tMPI_CHK(mpi_shift_l(X, nbits - k));\n\tif (k > nbits)\n\t\tMPI_CHK(mpi_shift_r(X, k - nbits));\n\n\tX->p[0] |= 3;\n\n\tif (dh_flag == 0) {\n\t\twhile ((ret = mpi_is_prime(X, f_rng, p_rng)) != 0) {\n\t\t\tif (ret != TROPICSSL_ERR_MPI_NOT_ACCEPTABLE)\n\t\t\t\tgoto cleanup;\n\n\t\t\tMPI_CHK(mpi_add_int(X, X, 2));\n\t\t}\n\t} else {\n\t\tMPI_CHK(mpi_sub_int(&Y, X, 1));\n\t\tMPI_CHK(mpi_shift_r(&Y, 1));\n\n\t\twhile (1) {\n\t\t\tif ((ret = mpi_is_prime(X, f_rng, p_rng)) == 0) {\n\t\t\t\tif ((ret = mpi_is_prime(&Y, f_rng, p_rng)) == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (ret != TROPICSSL_ERR_MPI_NOT_ACCEPTABLE)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (ret != TROPICSSL_ERR_MPI_NOT_ACCEPTABLE)\n\t\t\t\tgoto cleanup;\n\n\t\t\tMPI_CHK(mpi_add_int(&Y, X, 1));\n\t\t\tMPI_CHK(mpi_add_int(X, X, 2));\n\t\t\tMPI_CHK(mpi_shift_r(&Y, 1));\n\t\t}\n\t}\n\ncleanup:\n\n\tmpi_free(&Y, NULL);\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Division by mpi: A = Q * B + R  (HAC 14.20)\n */\n", "func_signal": "int mpi_div_mpi(mpi * Q, mpi * R, mpi * A, mpi * B)", "code": "{\n\tint ret, i, n, t, k;\n\tmpi X, Y, Z, T1, T2;\n\n\tif (mpi_cmp_int(B, 0) == 0)\n\t\treturn (TROPICSSL_ERR_MPI_DIVISION_BY_ZERO);\n\n\tmpi_init(&X, &Y, &Z, &T1, &T2, NULL);\n\n\tif (mpi_cmp_abs(A, B) < 0) {\n\t\tif (Q != NULL)\n\t\t\tMPI_CHK(mpi_lset(Q, 0));\n\t\tif (R != NULL)\n\t\t\tMPI_CHK(mpi_copy(R, A));\n\t\treturn (0);\n\t}\n\n\tMPI_CHK(mpi_copy(&X, A));\n\tMPI_CHK(mpi_copy(&Y, B));\n\tX.s = Y.s = 1;\n\n\tMPI_CHK(mpi_grow(&Z, A->n + 2));\n\tMPI_CHK(mpi_lset(&Z, 0));\n\tMPI_CHK(mpi_grow(&T1, 2));\n\tMPI_CHK(mpi_grow(&T2, 3));\n\n\tk = mpi_msb(&Y) % biL;\n\tif (k < (int)biL - 1) {\n\t\tk = biL - 1 - k;\n\t\tMPI_CHK(mpi_shift_l(&X, k));\n\t\tMPI_CHK(mpi_shift_l(&Y, k));\n\t} else\n\t\tk = 0;\n\n\tn = X.n - 1;\n\tt = Y.n - 1;\n\tmpi_shift_l(&Y, biL * (n - t));\n\n\twhile (mpi_cmp_mpi(&X, &Y) >= 0) {\n\t\tZ.p[n - t]++;\n\t\tmpi_sub_mpi(&X, &X, &Y);\n\t}\n\tmpi_shift_r(&Y, biL * (n - t));\n\n\tfor (i = n; i > t; i--) {\n\t\tif (X.p[i] >= Y.p[t])\n\t\t\tZ.p[i - t - 1] = ~0;\n\t\telse {\n#if defined(TROPICSSL_HAVE_LONGLONG)\n\t\t\tt_dbl r;\n\n\t\t\tr = (t_dbl) X.p[i] << biL;\n\t\t\tr |= (t_dbl) X.p[i - 1];\n\t\t\tr /= Y.p[t];\n\t\t\tif (r > ((t_dbl) 1 << biL) - 1)\n\t\t\t\tr = ((t_dbl) 1 << biL) - 1;\n\n\t\t\tZ.p[i - t - 1] = (t_int) r;\n#else\n\t\t\t/*\n\t\t\t * __udiv_qrnnd_c, from gmp/longlong.h\n\t\t\t */\n\t\t\tt_int q0, q1, r0, r1;\n\t\t\tt_int d0, d1, d, m;\n\n\t\t\td = Y.p[t];\n\t\t\td0 = (d << biH) >> biH;\n\t\t\td1 = (d >> biH);\n\n\t\t\tq1 = X.p[i] / d1;\n\t\t\tr1 = X.p[i] - d1 * q1;\n\t\t\tr1 <<= biH;\n\t\t\tr1 |= (X.p[i - 1] >> biH);\n\n\t\t\tm = q1 * d0;\n\t\t\tif (r1 < m) {\n\t\t\t\tq1--, r1 += d;\n\t\t\t\twhile (r1 >= d && r1 < m)\n\t\t\t\t\tq1--, r1 += d;\n\t\t\t}\n\t\t\tr1 -= m;\n\n\t\t\tq0 = r1 / d1;\n\t\t\tr0 = r1 - d1 * q0;\n\t\t\tr0 <<= biH;\n\t\t\tr0 |= (X.p[i - 1] << biH) >> biH;\n\n\t\t\tm = q0 * d0;\n\t\t\tif (r0 < m) {\n\t\t\t\tq0--, r0 += d;\n\t\t\t\twhile (r0 >= d && r0 < m)\n\t\t\t\t\tq0--, r0 += d;\n\t\t\t}\n\t\t\tr0 -= m;\n\n\t\t\tZ.p[i - t - 1] = (q1 << biH) | q0;\n#endif\n\t\t}\n\n\t\tZ.p[i - t - 1]++;\n\t\tdo {\n\t\t\tZ.p[i - t - 1]--;\n\n\t\t\tMPI_CHK(mpi_lset(&T1, 0));\n\t\t\tT1.p[0] = (t < 1) ? 0 : Y.p[t - 1];\n\t\t\tT1.p[1] = Y.p[t];\n\t\t\tMPI_CHK(mpi_mul_int(&T1, &T1, Z.p[i - t - 1]));\n\n\t\t\tMPI_CHK(mpi_lset(&T2, 0));\n\t\t\tT2.p[0] = (i < 2) ? 0 : X.p[i - 2];\n\t\t\tT2.p[1] = (i < 1) ? 0 : X.p[i - 1];\n\t\t\tT2.p[2] = X.p[i];\n\t\t} while (mpi_cmp_mpi(&T1, &T2) > 0);\n\n\t\tMPI_CHK(mpi_mul_int(&T1, &Y, Z.p[i - t - 1]));\n\t\tMPI_CHK(mpi_shift_l(&T1, biL * (i - t - 1)));\n\t\tMPI_CHK(mpi_sub_mpi(&X, &X, &T1));\n\n\t\tif (mpi_cmp_int(&X, 0) < 0) {\n\t\t\tMPI_CHK(mpi_copy(&T1, &Y));\n\t\t\tMPI_CHK(mpi_shift_l(&T1, biL * (i - t - 1)));\n\t\t\tMPI_CHK(mpi_add_mpi(&X, &X, &T1));\n\t\t\tZ.p[i - t - 1]--;\n\t\t}\n\t}\n\n\tif (Q != NULL) {\n\t\tmpi_copy(Q, &Z);\n\t\tQ->s = A->s * B->s;\n\t}\n\n\tif (R != NULL) {\n\t\tmpi_shift_r(&X, k);\n\t\tmpi_copy(R, &X);\n\n\t\tR->s = A->s;\n\t\tif (mpi_cmp_int(R, 0) == 0)\n\t\t\tR->s = 1;\n\t}\n\ncleanup:\n\n\tmpi_free(&X, &Y, &Z, &T1, &T2, NULL);\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Division by int: A = Q * b + R\n *\n * Returns 0 if successful\n *\t\t   1 if memory allocation failed\n *\t\t   TROPICSSL_ERR_MPI_DIVISION_BY_ZERO if b == 0\n */\n", "func_signal": "int mpi_div_int(mpi * Q, mpi * R, mpi * A, int b)", "code": "{\n\tmpi _B;\n\tt_int p[1];\n\n\tp[0] = (b < 0) ? -b : b;\n\t_B.s = (b < 0) ? -1 : 1;\n\t_B.n = 1;\n\t_B.p = p;\n\n\treturn (mpi_div_mpi(Q, R, A, &_B));\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Helper to write the digits high-order first\n */\n", "func_signal": "static int mpi_write_hlp(mpi * X, int radix, char **p)", "code": "{\n\tint ret;\n\tt_int r;\n\n\tif (radix < 2 || radix > 16)\n\t\treturn (TROPICSSL_ERR_MPI_BAD_INPUT_DATA);\n\n\tMPI_CHK(mpi_mod_int(&r, X, radix));\n\tMPI_CHK(mpi_div_int(X, NULL, X, radix));\n\n\tif (mpi_cmp_int(X, 0) != 0)\n\t\tMPI_CHK(mpi_write_hlp(X, radix, p));\n\n\tif (r < 10)\n\t\t*(*p)++ = (char)(r + 0x30);\n\telse\n\t\t*(*p)++ = (char)(r + 0x37);\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/*\n * Set value from integer\n */\n", "func_signal": "int mpi_lset(mpi * X, int z)", "code": "{\n\tint ret;\n\n\tMPI_CHK(mpi_grow(X, 1));\n\tmemset(X->p, 0, X->n * ciL);\n\n\tX->p[0] = (z < 0) ? -z : z;\n\tX->s = (z < 0) ? -1 : 1;\n\ncleanup:\n\n\treturn (ret);\n}", "path": "library\\bignum.c", "repo_name": "axic/tropicssl", "stars": 20, "license": "other", "language": "c", "size": 1281}
{"docstring": "/* int\n * inet_pton(af, src, dst)\n *\tconvert from presentation format (which usually means ASCII printable)\n *\tto network format (which is usually some kind of binary format).\n * return:\n *\t1 if the address was valid for the specified address family\n *\t0 if the address wasn't valid (`dst' is untouched in this case)\n *\t-1 if some other error occurred (`dst' is untouched in this case, too)\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "int\ninet_pton(int af,\n\t  const char *src,\n\t  void *dst)", "code": "{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_pton4(src, dst));\n\tcase AF_INET6:\n\t\treturn (inet_pton6(src, dst));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\t/* NOTREACHED */\n}", "path": "libmnetutil\\inet_pton.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* !NO_IPHLPAPI */\n", "func_signal": "static int dns_initns_registry(struct dns_ctx *ctx)", "code": "{\n  LONG res;\n  HKEY hk;\n  DWORD type = REG_EXPAND_SZ | REG_SZ;\n  DWORD len;\n  char valBuf[1024];\n\n#define REGKEY_WINNT \"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\"\n#define REGKEY_WIN9x \"SYSTEM\\\\CurrentControlSet\\\\Services\\\\VxD\\\\MSTCP\"\n  res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WINNT, 0, KEY_QUERY_VALUE, &hk);\n  if (res != ERROR_SUCCESS)\n    res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WIN9x,\n                       0, KEY_QUERY_VALUE, &hk);\n  if (res != ERROR_SUCCESS)\n    return -1;\n  len = sizeof(valBuf) - 1;\n  res = RegQueryValueEx(hk, \"NameServer\", NULL, &type, valBuf, &len);\n  if (res != ERROR_SUCCESS || !len || !valBuf[0]) {\n    len = sizeof(valBuf) - 1;\n    res = RegQueryValueEx(hk, \"DhcpNameServer\", NULL, &type, valBuf, &len);\n  }\n  RegCloseKey(hk);\n  if (res != ERROR_SUCCESS || !len || !valBuf[0])\n    return -1;\n  valBuf[len] = '\\0';\n  /* nameservers are stored as a whitespace-seperate list:\n   * \"192.168.1.1 123.21.32.12\" */\n  dns_set_serv_internal(ctx, valBuf);\n  return 0;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* int\n * inet_pton4(src, dst)\n *\tlike inet_aton() but without all the hexadecimal and shorthand.\n * return:\n *\t1 if `src' is a valid dotted quad, else 0.\n * notice:\n *\tdoes not touch `dst' unless it's returning 1.\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "static int\ninet_pton4(const char *src,\n\t   u_char *dst)", "code": "{\n\tstatic const char digits[] = \"0123456789\";\n\tint saw_digit, octets, ch;\n\tu_char tmp[INADDRSZ], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tconst char *pch;\n\n\t\tif ((pch = (char *) strchr(digits, ch)) != NULL) {\n\t\t  unsigned int temp = *tp * 10 + (pch - digits);\nuint8_t newv;\n\t\t\tif (temp > 255)\n\t\t\t\treturn (0);\n\t\t\tnewv = (uint8_t) temp;\n\t\t\t*tp = newv;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets > 4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\t/* bcopy(tmp, dst, INADDRSZ); */\n\tmemcpy(dst, tmp, INADDRSZ);\n\treturn (1);\n}", "path": "libmnetutil\\inet_pton.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* !WIN32 */\n", "func_signal": "static int dns_init_internal(struct dns_ctx *ctx)", "code": "{\n  char *v;\n  char buf[2049];\t/* this buffer is used to hold /etc/resolv.conf */\n\n  /* read resolv.conf... */\n  { int fd = open(\"/etc/resolv.conf\", O_RDONLY);\n    if (fd >= 0) {\n      int l = read(fd, buf, sizeof(buf) - 1);\n      close(fd);\n      buf[l < 0 ? 0 : l] = '\\0';\n    }\n    else\n      buf[0] = '\\0';\n  }\n  if (buf[0]) {\t/* ...and parse it */\n    char *line, *nextline;\n    line = buf;\n    do {\n      nextline = strchr(line, '\\n');\n      if (nextline) *nextline++ = '\\0';\n      v = line;\n      while(*v && !ISSPACE(*v)) ++v;\n      if (!*v) continue;\n      *v++ = '\\0';\n      while(ISSPACE(*v)) ++v;\n      if (!*v) continue;\n      if (strcmp(line, \"domain\") == 0)\n        dns_set_srch_internal(ctx, strtok(v, space));\n      else if (strcmp(line, \"search\") == 0)\n        dns_set_srch_internal(ctx, v);\n      else if (strcmp(line, \"nameserver\") == 0)\n        dns_add_serv_internal(ctx, strtok(v, space));\n      else if (strcmp(line, \"options\") == 0)\n        dns_set_opts_internal(ctx, v);\n    } while((line = nextline) != NULL);\n  }\n\n  buf[sizeof(buf)-1] = '\\0';\n\n  /* get list of nameservers from env. vars. */\n  if ((v = getenv(\"NSCACHEIP\")) != NULL ||\n      (v = getenv(\"NAMESERVERS\")) != NULL) {\n    strncpy(buf, v, sizeof(buf) - 1);\n    dns_set_serv_internal(ctx, buf);\n  }\n  /* if $LOCALDOMAIN is set, use it for search list */\n  if ((v = getenv(\"LOCALDOMAIN\")) != NULL) {\n    strncpy(buf, v, sizeof(buf) - 1);\n    dns_set_srch_internal(ctx, buf);\n  }\n  if ((v = getenv(\"RES_OPTIONS\")) != NULL)\n    dns_set_opts_internal(ctx, v);\n\n  /* if still no search list, use local domain name */\n  if (!ctx->dnsc_nsrch &&\n      gethostname(buf, sizeof(buf) - 1) == 0 &&\n      (v = strchr(buf, '.')) != NULL &&\n      *++v != '\\0')\n    dns_add_srch_internal(ctx, v);\n\n  return 0;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* char *\n * inet_ntop(af, src, dst, size)\n *\tconvert a network format address to presentation format.\n * return:\n *\tpointer to presentation format address (`dst'), or NULL (see errno).\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "const char *\ninet_ntop(int af,\n\t  const void *src,\n\t  char *dst,\n\t  size_t size)", "code": "{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}", "path": "libmnetutil\\inet_ntop.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* process readable fd condition.\n * To be usable in edge-triggered environment, the routine\n * should consume all input so it should loop over.\n * Note it isn't really necessary to loop here, because\n * an application may perform the loop just fine by it's own,\n * but in this case we should return some sensitive result,\n * to indicate when to stop calling and error conditions.\n * Note also we may encounter all sorts of recvfrom()\n * errors which aren't fatal, and at the same time we may\n * loop forever if an error IS fatal.\n * Current loop/goto looks just terrible... */\n", "func_signal": "void dns_ioevent(struct dns_ctx *ctx, time_t now)", "code": "{\n  int r;\n  unsigned servi, l;\n  struct dns_query *q;\n  dnsc_t *pbuf;\n  dnscc_t *pend, *pcur;\n  void *result;\n  union sockaddr_ns sns;\n  socklen_t slen;\n\n  SETCTX(ctx);\n  if (!CTXOPEN(ctx))\n    return;\n  dns_assert_ctx(ctx);\n  pbuf = ctx->dnsc_pbuf;\n\n  if (!now) now = time(NULL);\n\nagain:\n\n  for(;;) { /* receive the reply */\n    dnsc_t dn[DNS_MAXDN];\n\n    slen = sizeof(sns);\n    r = recvfrom(ctx->dnsc_udpsock, pbuf, ctx->dnsc_udpbuf, 0, &sns.sa, &slen);\n    if (r < 0) {\n      /*XXX just ignore recvfrom() errors for now.\n       * in the future it may be possible to determine which\n       * query failed and requeue it.\n       * Note there may be various error conditions, triggered\n       * by both local problems and remote problems.  It isn't\n       * quite trivial to determine whenever an error is local\n       * or remote.  On local errors, we should stop, while\n       * remote errors should be ignored (for now anyway).\n       */\n#ifdef WIN32\n      if (WSAGetLastError() == WSAEWOULDBLOCK)\n#else\n      if (errno == EAGAIN)\n#endif\n      {\n        dns_request_utm(ctx, now);\n\treturn;\n      }\n      continue;\n    }\n    /* ignore replies from wrong server */\n#if HAVE_INET6\n    if (sns.sa.sa_family == AF_INET6 && slen >= sizeof(sns.sin6)) {\n      for (servi = 0; servi < ctx->dnsc_nserv; ++servi)\n        if (ctx->dnsc_serv[servi].sin6.sin6_port == sns.sin6.sin6_port &&\n            memcmp(&ctx->dnsc_serv[servi].sin6.sin6_addr,\n                   &sns.sin6.sin6_addr, sizeof(sns.sin6.sin6_addr)) == 0)\n          break;\n    }\n    else\n#endif\n    if (sns.sa.sa_family == AF_INET && slen >= sizeof(sns.sin)) {\n      for (servi = 0; servi < ctx->dnsc_nserv; ++servi)\n        if (ctx->dnsc_serv[servi].sin.sin_addr.s_addr == sns.sin.sin_addr.s_addr &&\n            ctx->dnsc_serv[servi].sin.sin_port == sns.sin.sin_port)\n          break;\n    }\n    else {\n      DNS_DBG(ctx, -1, &sns.sa, slen, pbuf, r);\n      continue;\n    }\n    if (servi >= ctx->dnsc_nserv) {\n      DNS_DBG(ctx, -2, &sns.sa, slen, pbuf, r);\n      continue;\n    }\n\n    pend = pbuf + r;\n    pcur = dns_payload(pbuf);\n    if (pcur >= pend || dns_numqd(pbuf) != 1 || dns_opcode(pbuf) != 0 ||\n        dns_getdn(pbuf, &pcur, pend, dn, sizeof(dn)) < 0 ||\n        pcur + 4 > pend) {\n      /*XXX ignore non-query replies and replies with numqd!=1? */\n      DNS_DBG(ctx, -3, &sns.sa, slen, pbuf, r);\n      continue;\n    }\n\n    /* truncation bit (TC).  Ooh, we don't handle TCP (yet?),\n     * but we do handle larger UDP sizes.\n     * Note that e.g. djbdns will only send header if resp.\n     * does not fit, not whatever is fit in 512 bytes. */\n    if (dns_tc(pbuf)) {\n      DNS_DBG(ctx, -4, &sns.sa, slen, pbuf, r);\n      continue;\t/* just ignore response for now.. any hope? */\n    }\n\n    /* find the request for this reply in active queue\n     * Note we pick any request, even queued for another\n     * server - in case first server replies a bit later\n     * than we expected. */\n    for (q = QLIST_FIRST(&ctx->dnsc_qactive, next);; q = QLIST_NEXT(q, next)) {\n      if (QLIST_ISLAST(&ctx->dnsc_qactive, q)) {\n        /* no more requests: old reply? */\n        DNS_DBG(ctx, -5, &sns.sa, slen, pbuf, r);\n        goto again;\n      }\n      /* ignore replies that has not been sent to this server.\n       * Note dnsq_servi is the *next* server to try. */\n      if (!q->dnsq_try && q->dnsq_servi <= servi)\n        continue;\n      /*XXX ignore replies from servers we're ignoring? o/\n      if (q->dnsq_servskip & (1 << servi))\n        continue; */\n      /* check qID */\n      if (q->dnsq_buf[DNS_H_QID1] != pbuf[DNS_H_QID1] ||\n          q->dnsq_buf[DNS_H_QID2] != pbuf[DNS_H_QID2])\n        continue;\n      /* check qDN, qCLS and qTYP */\n      if (!(l = dns_dnequal(dn, dns_payload(q->dnsq_buf))) ||\n          memcmp(pcur, dns_payload(q->dnsq_buf) + l, 4) != 0)\n        continue;\n      /* ok, this is expected reply with matching query. */\n      break;\n    }\n\n    break;\n\n  }\n\n  DNS_DBGQ(ctx, q, 0, &sns.sa, slen, pbuf, r);\n\n  /* we got a reply for our query */\n  q->dnsq_servwait &= ~(1 << servi);\t/* don't expect reply from this serv */\n\n  /* process the RCODE */\n  switch(dns_rcode(pbuf)) {\n\n  case DNS_R_NOERROR:\n    qlist_remove(q);\n    if (!dns_numan(pbuf)) {\t/* no data of requested type */\n      q->dnsq_flags |= DNS_SEEN_NODATA;\n      r = DNS_E_NODATA;\n      break;\n    }\n    /* the only case where we may succeed */\n    if (q->dnsq_parse) {\n      r = q->dnsq_parse(dns_payload(q->dnsq_buf), pbuf, pcur, pend, &result);\n      if (r < 0)\n        result = NULL;\n    }\n    else if ((result = malloc(r)) != NULL)\n      memcpy(result, pbuf, r);\n    else\n      r = DNS_E_NOMEM;\n    /* (maybe) successeful answer (modulo nomem and parsing probs) */\n    /* note we pass DNS_E_NODATA here */\n    dns_end_query(ctx, q, r, result);\n    goto again;\n\n  case DNS_R_NXDOMAIN:\n    qlist_remove(q);\n    r = DNS_E_NXDOMAIN;\n    break;\n\n  case DNS_R_SERVFAIL:\n    q->dnsq_flags |= DNS_SEEN_FAIL;\n  case DNS_R_NOTIMPL:\n  case DNS_R_REFUSED:\n    /* for these rcodes, advance this request\n     * to the next server and reschedule */\n  default: /* unknown rcode? hmmm... */\n    /* try next server */\n    q->dnsq_servskip |= 1 << servi;\t/* don't retry this server */\n    if (!q->dnsq_servwait) {\n      qlist_remove(q);\n      dns_send(ctx, q, now);\n    }\n    else {\n      /* else this is the only place where q will be left unconnected\n       * if we will move qlist_remove() before the switch{}. */\n    }\n    goto again;\n\n  }\n\n  /* here we have either NODATA or NXDOMAIN */\n  if (!(q->dnsq_flags & DNS_NOSRCH)) {\n    /* try next element from search list */\n    unsigned sl;\n\n    l = dns_dnlen(dns_payload(q->dnsq_buf)) + DNS_HSIZE;\t/* past qDN */\n    /* save qcls, qtyp and EDNS0 stuff (of len sl) in pbuf */\n    sl = q->dnsq_len - l;\n    memcpy(pbuf, q->dnsq_buf + l, sl);\n    /* try next search list */\n    l = dns_next_srch(ctx, q);\n    if (l) {\t/* something else to try, of len l */\n      l += DNS_HSIZE;\n      memcpy(q->dnsq_buf + l, pbuf, sl);\n      q->dnsq_len = l + sl;\n      q->dnsq_try = 0; q->dnsq_servi = 0;\n      q->dnsq_servwait = q->dnsq_servskip = 0;\n      dns_send(ctx, q, now);\n      goto again;\n    }\n    /* else we have nothing more to search, end the query. */\n    if (q->dnsq_flags & DNS_SEEN_FAIL)\n      /* at least one server/query failed, fail the query */\n      r = DNS_E_TEMPFAIL;\n    else if (q->dnsq_flags & DNS_SEEN_NODATA)\n      /* for one domain we have seen NODATA, return it */\n      r = DNS_E_NODATA;\n    else /* else all should be NXDOMAINs */\n      r = DNS_E_NXDOMAIN;\n  }\n\n  dns_end_query(ctx, q, r, 0);\n  goto again;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* insert q between prev and next */\n", "func_signal": "static __inline void\nqlist_insert(struct dns_query *q,\n             struct dns_query *prev, struct dns_query *next)", "code": "{\n  q->dnsq_link.next = next;\n  q->dnsq_link.prev = prev;\n  prev->dnsq_link.next = next->dnsq_link.prev = q;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* dns_init_internal() for !WIN32 */\n", "func_signal": "int dns_init(int do_open)", "code": "{\n  struct dns_ctx *ctx = &dns_defctx;\n  assert(!CTXINITED(ctx));\n  memset(ctx, 0, sizeof(*ctx));\n  ctx->dnsc_timeout = 4;\n  ctx->dnsc_ntries = 3;\n  ctx->dnsc_ndots = 1;\n  ctx->dnsc_udpbuf = DNS_EDNS0PACKET;\n  ctx->dnsc_port = DNS_PORT;\n  ctx->dnsc_udpsock = -1;\n  qlist_init(&ctx->dnsc_qactive);\n  if (dns_init_internal(ctx) != 0)\n    return -1;\n  dns_firstid(ctx);\n  ctx->dnsc_flags |= DNS_INITED;\n  return do_open ? dns_open(ctx) : 0;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* Convert the dn into asciiz string.\n * Keep in sync with dns_dntop_size() above.\n */\n", "func_signal": "int dns_dntop(dnscc_t *dn, char *name, unsigned namesiz)", "code": "{\n  char *np = name;\t\t\t/* current name ptr */\n  char *const ne = name + namesiz;\t/* end of name */\n  dnscc_t *le;\t\t/* label end */\n\n  while(*dn) {\n    /* *dn is the length of the next label, non-zero */\n    if (np != name) {\n      if (np >= ne) goto toolong;\n      *np++ = '.';\n    }\n    le = dn + *dn + 1;\n    ++dn;\n    do {\n      switch(*dn) {\n      case '.':\n      case '\\\\':\n      /* Special modifiers in zone files. */\n      case '\"':\n      case ';':\n      case '@':\n      case '$':\n        if (np + 2 > ne) goto toolong;\n        *np++ = '\\\\';\n        *np++ = *dn;\n        break;\n      default:\n        if (*dn <= 0x20 || *dn >= 0x7f) {\n          /* \\ddd decimal notation */\n          if (np + 4 >= ne) goto toolong;\n          *np++ = '\\\\';\n          *np++ = '0' + (*dn / 100);\n          *np++ = '0' + ((*dn % 100) / 10);\n          *np++ = '0' + (*dn % 10);\n        }\n        else {\n          if (np >= ne) goto toolong;\n          *np++ = *dn;\n        }\n      }\n    } while(++dn < le);\n  }\n  if (np >= ne) goto toolong;\n  *np++ = '\\0';\n  return np - name;\ntoolong:\n  return namesiz >= DNS_MAXNAME ? -1 : 0;\n}", "path": "libmnetutil\\udns\\source\\udns_dn.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* dbgcb will only be called if verbose > 1 */\n", "func_signal": "static void\ndbgcb(int code, const struct sockaddr *sa, unsigned slen,\n      const unsigned char *pkt, int r,\n      const struct dns_query *unused_q, void *unused_data)", "code": "{\n  struct dns_parse p;\n  const unsigned char *cur, *end;\n  int numqd;\n\n  if (code > 0)\t{\n    printf(\";; trying %s.\\n\", dns_dntosp(dns_payload(pkt)));\n    printf(\";; sending %d bytes query to \", r);\n  }\n  else\n    printf(\";; received %d bytes response from \", r);\n  if (sa->sa_family == AF_INET && slen >= sizeof(struct sockaddr_in)) {\n    char buf[4*4];\n    printf(\"%s port %d\\n\",\n           inet_ntop(AF_INET, &((struct sockaddr_in*)sa)->sin_addr,\n                     buf, sizeof(buf)),\n           htons(((struct sockaddr_in*)sa)->sin_port));\n  }\n#ifdef AF_INET6\n  else if (sa->sa_family == AF_INET6 && slen >= sizeof(struct sockaddr_in6)) {\n    char buf[6*5+4*4];\n    printf(\"%s port %d\\n\",\n           inet_ntop(AF_INET6, &((struct sockaddr_in6*)sa)->sin6_addr,\n                     buf, sizeof(buf)),\n           htons(((struct sockaddr_in6*)sa)->sin6_port));\n  }\n#endif\n  else\n    printf(\"<<unknown socket type %d>>\\n\", sa->sa_family);\n  if (code > 0 && verbose < 3) {\n    putchar('\\n');\n    return;\n  }\n\n  if (code == -2) printf(\";; reply from unexpected source\\n\");\n  if (code == -5) printf(\";; reply to a query we didn't sent (or old)\\n\");\n  if (r < DNS_HSIZE) {\n    printf(\";; short packet (%d bytes)\\n\", r);\n    return;\n  }\n  if (dns_opcode(pkt) != 0)\n    printf(\";; unexpected opcode %d\\n\", dns_opcode(pkt));\n  if (dns_tc(pkt) != 0)\n    printf(\";; warning: TC bit set, probably incomplete reply\\n\");\n\n  printf(\";; ->>HEADER<<- opcode: \");\n  switch(dns_opcode(pkt)) {\n  case 0: printf(\"QUERY\"); break;\n  case 1: printf(\"IQUERY\"); break;\n  case 2: printf(\"STATUS\"); break;\n  default: printf(\"UNKNOWN(%u)\", dns_opcode(pkt)); break;\n  }\n  printf(\", status: %s, id: %d, size: %d\\n;; flags:\",\n         dns_rcodename(dns_rcode(pkt)), dns_qid(pkt), r);\n  if (dns_qr(pkt)) printf(\" qr\");\n  if (dns_rd(pkt)) printf(\" rd\");\n  if (dns_ra(pkt)) printf(\" ra\");\n  if (dns_aa(pkt)) printf(\" aa\");\n  if (dns_tc(pkt)) printf(\" tc\");\n  numqd = dns_numqd(pkt);\n  printf(\"; QUERY: %d, ANSWER: %d, AUTHORITY: %d, ADDITIONAL: %d\\n\",\n         numqd, dns_numan(pkt), dns_numns(pkt), dns_numar(pkt));\n  if (numqd != 1)\n    printf(\";; unexpected number of entries in QUERY section: %d\\n\",\n           numqd);\n  printf(\"\\n;; QUERY SECTION (%d):\\n\", numqd);\n  cur = dns_payload(pkt);\n  end = pkt + r;\n  while(numqd--) {\n    if (dns_getdn(pkt, &cur, end, p.dnsp_dnbuf, DNS_MAXDN) <= 0 ||\n        cur + 4 > end) {\n      printf(\"; invalid query section\\n\");\n      return;\n    }\n    r = printf(\";%s.\", dns_dntosp(p.dnsp_dnbuf));\n    printf(\"%s%s\\t%s\\n\",\n           r > 23 ? \"\\t\" : r > 15 ? \"\\t\\t\" : r > 7 ? \"\\t\\t\\t\" : \"\\t\\t\\t\\t\",\n           dns_classname(dns_get16(cur+2)), dns_typename(dns_get16(cur)));\n    cur += 4;\n  }\n\n  p.dnsp_pkt = pkt;\n  p.dnsp_cur = p.dnsp_ans = cur;\n  p.dnsp_end = end;\n  p.dnsp_qdn = NULL;\n  p.dnsp_qcls = p.dnsp_qtyp = 0;\n  p.dnsp_ttl = 0xffffffffu;\n  p.dnsp_nrr = 0;\n\n  r = printsection(&p, dns_numan(pkt), \"ANSWER\");\n  if (r == 0)\n    r = printsection(&p, dns_numns(pkt), \"AUTHORITY\");\n  if (r == 0)\n    r = printsection(&p, dns_numar(pkt), \"ADDITIONAL\");\n  putchar('\\n');\n}", "path": "libmnetutil\\udns\\source\\dnsget.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* Get a single string for NAPTR record, pretty much like a DN label.\n * String length is in first byte in *cur, so it can't be >255.\n */\n", "func_signal": "static int dns_getstr(dnscc_t **cur, dnscc_t *ep, char *buf)", "code": "{\n  unsigned l;\n  dnscc_t *cp = *cur;\n\n  l = *cp++;\n  if (cp + l > ep)\n    return DNS_E_PROTOCOL;\n  if (buf) {\n    memcpy(buf, cp, l);\n    buf[l] = '\\0';\n  }\n  cp += l;\n\n  *cur = cp;\n  return l + 1;\n}", "path": "libmnetutil\\udns\\source\\udns_rr_naptr.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* Add a single service or proto name prepending an undescore (_),\n * according to rfc2782 rules.\n * Return 0 or the label length.\n * Routing assumes dn holds enouth space for a single DN label. */\n", "func_signal": "static unsigned add_sname(dnsc_t *dn, const char *sn)", "code": "{\n  unsigned l;\n  l = dns_ptodn(sn, 0, dn + 1, DNS_MAXLABEL-1, NULL);\n  if (l <= 1 || l - 2 != dn[1])\n    /* Should we really check if sn is exactly one label?  Do we care? */\n    return 0;\n  dn[0] = l - 1;\n  dn[1] = '_';\n  return l;\n}", "path": "libmnetutil\\udns\\source\\udns_rr_srv.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* int\n * inet_pton6(src, dst)\n *\tconvert presentation level address to network order binary form.\n * return:\n *\t1 if `src' is a valid [RFC1884 2.2] address, else 0.\n * notice:\n *\t(1) does not touch `dst' unless it's returning 1.\n *\t(2) :: in a full address is silently ignored.\n * credit:\n *\tinspired by Mark Andrews.\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "static int\ninet_pton6(const char *src,\n\t   u_char *dst)", "code": "{\n\tstatic const char xdigits_l[] = \"0123456789abcdef\",\n\t\t\t  xdigits_u[] = \"0123456789ABCDEF\";\n\tu_char tmp[IN6ADDRSZ], *tp, *endp, *colonp;\n\tconst char *xdigits, *curtok;\n\tint ch, saw_xdigit;\n\tunsigned val;\n\n\tmemset((tp = tmp), 0, IN6ADDRSZ);\n\tendp = tp + IN6ADDRSZ;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\treturn (0);\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tconst char *pch;\n\n\t\tif ((pch = (char *) strchr((xdigits = xdigits_l), ch)) == NULL)\n\t\t\tpch = (char *) strchr((xdigits = xdigits_u), ch);\n\t\tif (pch != NULL) {\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (val > 0xffff)\n\t\t\t\treturn (0);\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':') {\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit) {\n\t\t\t\tif (colonp)\n\t\t\t\t\treturn (0);\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tp + INT16SZ > endp)\n\t\t\t\treturn (0);\n\t\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + INADDRSZ) <= endp) &&\n\t\t    inet_pton4(curtok, tp) > 0) {\n\t\t\ttp += INADDRSZ;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\treturn (0);\n\t}\n\tif (saw_xdigit) {\n\t\tif (tp + INT16SZ > endp)\n\t\t\treturn (0);\n\t\t*tp++ = (u_char) (val >> 8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (colonp != NULL) {\n\t\t/*\n\t\t * Since some memmove()'s erroneously fail to handle\n\t\t * overlapping regions, we'll do the shift by hand.\n\t\t */\n\t\tconst int n = tp - colonp;\n\t\tint i;\n\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tendp[- i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\treturn (0);\n\t/* bcopy(tmp, dst, IN6ADDRSZ); */\n\tmemcpy(dst, tmp, IN6ADDRSZ);\n\treturn (1);\n}", "path": "libmnetutil\\inet_pton.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* End the query and return the result to the caller.\n */\n", "func_signal": "static void\ndns_end_query(struct dns_ctx *ctx, struct dns_query *q,\n              int status, void *result)", "code": "{\n  dns_query_fn *cbck = q->dnsq_cbck;\n  void *cbdata = q->dnsq_cbdata;\n  ctx->dnsc_qstatus = status;\n  assert((status < 0 && result == 0) || (status >= 0 && result != 0));\n  assert(cbck != 0);\t/*XXX callback may be NULL */\n  assert(ctx->dnsc_nactive > 0);\n  --ctx->dnsc_nactive;\n  /* force the query to be unconnected */\n  /*memset(q, 0, sizeof(*q));*/\n#ifndef NDEBUG\n  q->dnsq_ctx = NULL;\n#endif\n  free(q);\n  cbck(ctx, result, cbdata);\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* find the next server which isn't skipped starting from current.\n * return 0 if ok, >0 if ok but we started next cycle, or <0 if\n * number of tries exceeded or no more servers.\n */\n", "func_signal": "static int dns_find_serv(const struct dns_ctx *ctx, struct dns_query *q)", "code": "{\n  int cycle;\n  if (q->dnsq_try < ctx->dnsc_ntries) for(cycle = 0;;) {\n    if (q->dnsq_servi < ctx->dnsc_nserv) {\n      if (!(q->dnsq_servskip & (1 << q->dnsq_servi)))\n        return cycle;\n      ++q->dnsq_servi;\n    }\n    else if (cycle || ++q->dnsq_try >= ctx->dnsc_ntries)\n      break;\n    else {\n      cycle = 1;\n      q->dnsq_servi = 0;\n    }\n  }\n  return -1;\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "// borrowed from tcpdump\n", "func_signal": "int\ninet_aton(const char *cp, struct in_addr *addr)", "code": "{\n    addr->s_addr = inet_addr(cp);\n    return (addr->s_addr == INADDR_NONE) ? 0 : 1;\n}", "path": "libmnetutil\\inet_aton.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* send the query out and add it to the active list. */\n", "func_signal": "static void dns_send(struct dns_ctx *ctx, struct dns_query *q, time_t now)", "code": "{\n  int n;\n  struct dns_query *p;\n\n  /* if we can't send the query, return TEMPFAIL even when searching:\n   * we can't be sure whenever the name we tried to search exists or not,\n   * so don't continue searching, or we may find the wrong name. */\n\n  /* if there's no more servers, fail the query */\n  n = dns_find_serv(ctx, q);\n  if (n < 0) {\n    dns_end_query(ctx, q, DNS_E_TEMPFAIL, 0);\n    return;\n  }\n\n  /* send the query */\n  n = 10;\n  while (sendto(ctx->dnsc_udpsock, q->dnsq_buf, q->dnsq_len, 0,\n                &ctx->dnsc_serv[q->dnsq_servi].sa, ctx->dnsc_salen) < 0) {\n    /*XXX just ignore the sendto() error for now and try again.\n     * In the future, it may be possible to retrieve the error code\n     * and find which operation/query failed.\n     *XXX try the next server too?\n     */\n    if (--n) continue;\n    /* if we can't send the query, fail it. */\n    dns_end_query(ctx, q, DNS_E_TEMPFAIL, 0);\n    return;\n  }\n  DNS_DBGQ(ctx, q, 1,\n           &ctx->dnsc_serv[q->dnsq_servi].sa, sizeof(union sockaddr_ns),\n           q->dnsq_buf, q->dnsq_len);\n  q->dnsq_servwait |= 1 << q->dnsq_servi;\t/* expect reply from this ns */\n\n  /* advance to the next server, and choose a timeout.\n   * we will try next server in 1 secound, but start next\n   * cycle waiting for proper timeout. */\n  ++q->dnsq_servi;\n  n = dns_find_serv(ctx, q) ? ctx->dnsc_timeout << (q->dnsq_try - 1) : 1;\n\n  q->dnsq_deadline = now = now + n;\n\n  /* insert the query to the tail of the list */\n  QLIST_FOR_EACH(&ctx->dnsc_qactive, p, prev)\n    if (p->dnsq_deadline <= now)\n      break;\n  qlist_insert_after(q, p);\n\n}", "path": "libmnetutil\\udns\\source\\udns_resolver.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* return size of buffer required to convert the dn into asciiz string.\n * Keep in sync with dns_dntop() below.\n */\n", "func_signal": "unsigned dns_dntop_size(dnscc_t *dn)", "code": "{\n  unsigned size = 0;\t\t/* the size reqd */\n  dnscc_t *le;\t\t\t/* label end */\n\n  while(*dn) {\n    /* *dn is the length of the next label, non-zero */\n    if (size)\n      ++size;\t\t/* for the dot */\n    le = dn + *dn + 1;\n    ++dn;\n    do {\n      switch(*dn) {\n      case '.':\n      case '\\\\':\n      /* Special modifiers in zone files. */\n      case '\"':\n      case ';':\n      case '@':\n      case '$':\n        size += 2;\n        break;\n      default:\n        if (*dn <= 0x20 || *dn >= 0x7f)\n          /* \\ddd decimal notation */\n          size += 4;\n        else\n          size += 1;\n      }\n    } while(++dn < le);\n  }\n  size += 1;\t/* zero byte at the end - string terminator */\n  return size > DNS_MAXNAME ? 0 : size;\n}", "path": "libmnetutil\\udns\\source\\udns_dn.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* const char *\n * inet_ntop6(src, dst, size)\n *\tconvert IPv6 binary address into presentation (printable) format\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "static const char *\ninet_ntop6(const u_char *src,\n\t   char *dst,\n\t   size_t size)", "code": "{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n\tstruct { int base, len; } best, cur;\n\tuint32_t words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, 0, sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tbest.len = 0;\n\tcur.base = -1;\n\tcur.len = 0;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(tp, \"%x\", words[i]);\n\t\ttp += strlen(tp);\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((size_t) (tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrcpy(dst, tmp);\n\treturn (dst);\n}", "path": "libmnetutil\\inet_ntop.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/* const char *\n * inet_ntop4(src, dst, size)\n *\tformat an IPv4 address, more or less like inet_ntoa()\n * return:\n *\t`dst' (as a const)\n * notes:\n *\t(1) uses no statics\n *\t(2) takes a u_char* not an in_addr as input\n * author:\n *\tPaul Vixie, 1996.\n */\n", "func_signal": "static const char *\ninet_ntop4(const u_char *src,\n\t   char *dst,\n\t   size_t size)", "code": "{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\n\tsprintf(tmp, fmt, src[0], src[1], src[2], src[3]);\n\tif ((size_t)strlen(tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrcpy(dst, tmp);\n\treturn (dst);\n}", "path": "libmnetutil\\inet_ntop.c", "repo_name": "csd/minisip", "stars": 25, "license": "None", "language": "c", "size": 8392}
{"docstring": "/*\n=>   login           = \"LOGIN\" SP userid SP password\n*/\n", "func_signal": "int mailimap_login_send(mailstream * fd,\n\t\t\t\tconst char * userid, const char * password)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"LOGIN\");\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_userid_send(fd, userid);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_password_send(fd, password);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   date            = date-text / DQUOTE date-text DQUOTE\n*/\n", "func_signal": "static int mailimap_date_send(mailstream * fd,\n\t\t\t      struct mailimap_date * date)", "code": "{\n  int r;\n\n  r = mailimap_date_day_send(fd, date->dt_day);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_char_send(fd, '-');\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_date_month_send(fd, date->dt_month);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_char_send(fd, '-');\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_date_year_send(fd, date->dt_year);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/* if sequence_num == 0 then \"*\" */\n", "func_signal": "static int\nmailimap_sequence_num_send(mailstream * fd, uint32_t sequence_num)", "code": "{\n  if (sequence_num == 0)\n    return mailimap_char_send(fd, '*');\n  else\n    return mailimap_number_send(fd, sequence_num);\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   section-text    = section-msgtext / \"MIME\"\n                       ; text other than actual body part (headers, etc.)\n*/\n", "func_signal": "static int\nmailimap_section_text_send(mailstream * fd,\n    struct mailimap_section_text * section_text)", "code": "{\n  switch (section_text->sec_type) {\n  case MAILIMAP_SECTION_TEXT_SECTION_MSGTEXT:\n    return mailimap_section_msgtext_send(fd, section_text->sec_msgtext);\n\n  case MAILIMAP_SECTION_TEXT_MIME:\n    return mailimap_token_send(fd, \"MIME\");\n\n  default:\n    /* should not happen */\n    return MAILIMAP_NO_ERROR;\n  }\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   section-msgtext = \"HEADER\" / \"HEADER.FIELDS\" [\".NOT\"] SP header-list /\n                     \"TEXT\"\n                       ; top-level or MESSAGE/RFC822 part\n*/\n", "func_signal": "static int\nmailimap_section_msgtext_send(mailstream * fd,\n\t\t\t      struct mailimap_section_msgtext *\n\t\t\t      section_msgtext)", "code": "{\n  int r;\n  \n  switch (section_msgtext->sec_type) {\n  case MAILIMAP_SECTION_MSGTEXT_HEADER:\n    return mailimap_token_send(fd, \"HEADER\");\n\n  case MAILIMAP_SECTION_MSGTEXT_HEADER_FIELDS:\n    r = mailimap_token_send(fd, \"HEADER.FIELDS\");\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    r = mailimap_space_send(fd);\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    r = mailimap_header_list_send(fd, section_msgtext->sec_header_list);\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    return MAILIMAP_NO_ERROR;\n\n  case MAILIMAP_SECTION_MSGTEXT_HEADER_FIELDS_NOT:\n    r = mailimap_token_send(fd, \"HEADER.FIELDS.NOT\");\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    r = mailimap_space_send(fd);\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    r = mailimap_header_list_send(fd, section_msgtext->sec_header_list);\n\tif (r != MAILIMAP_NO_ERROR)\n      return r;\n    return MAILIMAP_NO_ERROR;\n\n  case MAILIMAP_SECTION_MSGTEXT_TEXT:\n    return mailimap_token_send(fd, \"TEXT\");\n\n  default:\n    /* should not happend */\n    return MAILIMAP_ERROR_INVAL;\n  }\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   section-spec    = section-msgtext / (section-part [\".\" section-text])\n*/\n", "func_signal": "static int\nmailimap_section_spec_send(mailstream * fd,\n\t\t\t   struct mailimap_section_spec * section_spec)", "code": "{\n  int r;\n  \n  switch (section_spec->sec_type) {\n  case MAILIMAP_SECTION_SPEC_SECTION_MSGTEXT:\n    return mailimap_section_msgtext_send(fd,\n        section_spec->sec_data.sec_msgtext);\n\n  case MAILIMAP_SECTION_SPEC_SECTION_PART:\n    r = mailimap_section_part_send(fd, section_spec->sec_data.sec_part);\n    if (r != MAILIMAP_NO_ERROR)\n      return r;\n\n    if (section_spec->sec_text != NULL) {\n      r = mailimap_char_send(fd, '.');\n      if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n      r = mailimap_section_text_send(fd,\n          section_spec->sec_text);\n      if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n    }\n\n    return MAILIMAP_NO_ERROR;\n\n  default:\n    /* should not happen */\n    return MAILIMAP_ERROR_INVAL;\n  }\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   list            = \"LIST\" SP mailbox SP list-mailbox\n*/\n", "func_signal": "int mailimap_list_send(mailstream * fd,\n\t\t\t\tconst char * mb,\n\t\t\t\tconst char * list_mb)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"LIST\");\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_mailbox_send(fd, mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_list_mailbox_send(fd, list_mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   store           = \"STORE\" SP set SP store-att-flags\n*/\n", "func_signal": "int\nmailimap_store_send(mailstream * fd,\n\t\t    struct mailimap_set * set,\n\t\t    struct mailimap_store_att_flags * store_att_flags)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"STORE\");\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_set_send(fd, set);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_store_att_flags_send(fd, store_att_flags);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   copy            = \"COPY\" SP set SP mailbox\n*/\n", "func_signal": "int mailimap_copy_send(mailstream * fd,\n\t\t       struct mailimap_set * set,\n\t\t       const char * mb)", "code": "{\n  int r;\n\n  r = mailimap_token_send(fd, \"COPY\");\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_set_send(fd, set);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  \n  r = mailimap_mailbox_send(fd, mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n  this is one of the imap commands annotatemore adds. setannotation is\n  yet to be implemented.\n*/\n", "func_signal": "LIBETPAN_EXPORT\nint mailimap_annotatemore_getannotation(mailimap * session,\n    const char * list_mb,\n    struct mailimap_annotatemore_entry_match_list * entries,\n    struct mailimap_annotatemore_attrib_match_list * attribs,\n    clist ** result)", "code": "{\n  struct mailimap_response * response;\n  struct mailimap_extension_data * ext_data;\n  clistiter * cur;\n  int r;\n  int error_code;\n\n  if (session->imap_state != MAILIMAP_STATE_AUTHENTICATED)\n    return MAILIMAP_ERROR_BAD_STATE;\n\n  r = mailimap_send_current_tag(session);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_annotatemore_getannotation_send(session->imap_stream,\n    list_mb, entries, attribs);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_crlf_send(session->imap_stream);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  if (mailstream_flush(session->imap_stream) == -1)\n    return MAILIMAP_ERROR_STREAM;\n\n  if (mailimap_read_line(session) == NULL)\n    return MAILIMAP_ERROR_STREAM;\n\n  r = mailimap_parse_response(session, &response);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  * result = clist_new();\n  if (* result == NULL)\n    return MAILIMAP_ERROR_MEMORY;\n\n  /* copy all annotate_data to the result-list */\n  for (cur = clist_begin(session->imap_response_info->rsp_extension_list);\n    cur != NULL; cur = clist_next(cur)) {\n      ext_data = (struct mailimap_extension_data *) clist_content(cur);\n      if (\n        ext_data->ext_extension->ext_id == MAILIMAP_EXTENSION_ANNOTATEMORE &&\n        ext_data->ext_type == MAILIMAP_ANNOTATEMORE_TYPE_ANNOTATE_DATA) {\n          r = clist_append((* result), ext_data->ext_data);\n          if (r != 0)\n            return MAILIMAP_ERROR_MEMORY;\n\n          ext_data->ext_data = NULL;\n          ext_data->ext_type = -1;\n      }\n  }\n\n  clist_foreach(session->imap_response_info->rsp_extension_list,\n        (clist_func) mailimap_extension_data_free, NULL);\n  clist_free(session->imap_response_info->rsp_extension_list);\n  session->imap_response_info->rsp_extension_list = NULL;\n\n  error_code = response->rsp_resp_done->rsp_data.rsp_tagged->rsp_cond_state->rsp_type;\n\n  mailimap_response_free(response);\n\n  switch (error_code) {\n  case MAILIMAP_RESP_COND_STATE_OK:\n    return MAILIMAP_NO_ERROR;\n\n  default:\n    return MAILIMAP_ERROR_EXTENSION;\n  }\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\annotatemore.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\nenum {\n  FLAG_ANSWERED,\n  FLAG_FLAGGED,\n  FLAG_DELETED,\n  FLAG_SEEN,\n  FLAG_DRAFT,\n  FLAG_KEYWORD,\n  FLAG_EXTENSION\n};\n\nstruct mailimap_flag {\n  gint type;\n  gchar * flag_keyword;\n  gchar * flag_extension;\n};\n*/\n", "func_signal": "static int mailimap_flag_send(mailstream * fd,\n\t \t\t\tstruct mailimap_flag * flag)", "code": "{\n  switch(flag->fl_type) {\n  case MAILIMAP_FLAG_ANSWERED:\n    return mailimap_token_send(fd, \"\\\\Answered\");\n  case MAILIMAP_FLAG_FLAGGED:\n    return mailimap_token_send(fd, \"\\\\Flagged\");\n  case MAILIMAP_FLAG_DELETED:\n    return mailimap_token_send(fd, \"\\\\Deleted\");\n  case MAILIMAP_FLAG_SEEN:\n    return mailimap_token_send(fd, \"\\\\Seen\");\n  case MAILIMAP_FLAG_DRAFT:\n    return mailimap_token_send(fd, \"\\\\Draft\");\n  case MAILIMAP_FLAG_KEYWORD:\n    return mailimap_flag_keyword_send(fd, flag->fl_data.fl_keyword);\n  case MAILIMAP_FLAG_EXTENSION:\n    return mailimap_flag_extension_send(fd, flag->fl_data.fl_extension);\n  default:\n    /* should not happen */\n    return MAILIMAP_ERROR_INVAL;\n  }\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   date-month      = \"Jan\" / \"Feb\" / \"Mar\" / \"Apr\" / \"May\" / \"Jun\" /\n                     \"Jul\" / \"Aug\" / \"Sep\" / \"Oct\" / \"Nov\" / \"Dec\"\n*/\n", "func_signal": "static int mailimap_date_month_send(mailstream * fd, int month)", "code": "{\n  const char * name;\n  int r;\n\n  name = mailimap_month_get_token_str(month);\n  \n  if (name == NULL)\n    return MAILIMAP_ERROR_INVAL;\n    \n  r = mailimap_token_send(fd, name);\n    if (r != MAILIMAP_NO_ERROR)\n      return r;\n  \n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   lsub            = \"LSUB\" SP mailbox SP list-mailbox\n*/\n", "func_signal": "int mailimap_lsub_send(mailstream * fd,\n\t\t\t\tconst char * mb, const char * list_mb)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"LSUB\");\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n\n  r = mailimap_mailbox_send(fd, mb);\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_list_mailbox_send(fd, list_mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\nstatic int in_mapped_zone(MMAPString * string, char * val)\n{\n  return (val >= string->str) && (val < string->str + string->mmapped_size);\n}\n*/\n", "func_signal": "MMAPString*\nmmap_string_insert_len (MMAPString     *string,\n\t\t\tsize_t       pos,    \n\t\t\tconst char *val,\n\t\t\tsize_t       len)", "code": "{\n  if (mmap_string_maybe_expand (string, len) == NULL)\n    return NULL;\n    \n  if (pos < string->len)\n    memmove (string->str + pos + len, string->str + pos, string->len - pos);\n\n  /* insert the new string */\n  memmove (string->str + pos, val, len);\n\n  string->len += len;\n\n  string->str[string->len] = 0;\n\n  return string;\n}", "path": "Externals\\libetpan\\src\\data-types\\mmapstring.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/* folders operations */\n", "func_signal": "static int mhdriver_cached_build_folder_name(mailsession * session, const char * mb,\n\t\t\t\t\t     const char * name, char ** result)", "code": "{\n  return mailsession_build_folder_name(get_ancestor(session),\n      mb, name, result);\n}", "path": "Externals\\libetpan\\src\\driver\\implementation\\mh\\mhdriver_cached.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   unsubscribe     = \"UNSUBSCRIBE\" SP mailbox\n*/\n", "func_signal": "int mailimap_unsubscribe_send(mailstream * fd,\n\t\t\t\tconst char * mb)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"UNSUBSCRIBE\");\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_mailbox_send(fd, mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/* messages operations */\n", "func_signal": "static int mhdriver_cached_append_message(mailsession * session,\n\t\t\t\t\t  const char * message, size_t size)", "code": "{\n  return mhdriver_cached_append_message_flags(session,\n      message, size, NULL);\n}", "path": "Externals\\libetpan\\src\\driver\\implementation\\mh\\mhdriver_cached.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   rename          = \"RENAME\" SP mailbox SP mailbox\n                       ; Use of INBOX as a destination gives a NO error\n*/\n", "func_signal": "int mailimap_rename_send(mailstream * fd, const char * mb,\n\t\t\t\tconst char * new_name)", "code": "{\n  int r;\n  \n  r = mailimap_token_send(fd, \"RENAME\");\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_mailbox_send(fd, mb);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_space_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  r = mailimap_mailbox_send(fd, new_name);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/*\n=>   date-year       = 4DIGIT\n*/\n", "func_signal": "static int mailimap_fixed_digit_send(mailstream * fd,\n\t\t\t\t     int num, int count)", "code": "{\n  int r;\n  \n  if (count == 0)\n    return MAILIMAP_NO_ERROR;\n  \n  r = mailimap_fixed_digit_send(fd, num / 10, count - 1);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_digit_send(fd, num % 10);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n  \n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/* currently porting */\n", "func_signal": "static int\nmailimap_fetch_att_list_send(mailstream * fd, clist * fetch_att_list)", "code": "{\n  int r;\n  \n  r = mailimap_oparenth_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n\treturn r;\n\n  r = mailimap_struct_spaced_list_send(fd, fetch_att_list,\n  \t\t\t\t  (mailimap_struct_sender *)\n\t\t\t\t  mailimap_fetch_att_send);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  r = mailimap_cparenth_send(fd);\n  if (r != MAILIMAP_NO_ERROR)\n    return r;\n\n  return MAILIMAP_NO_ERROR;\n}", "path": "Externals\\libetpan\\src\\low-level\\imap\\mailimap_sender.c", "repo_name": "jpm/etPanKit", "stars": 16, "license": "None", "language": "c", "size": 2215}
{"docstring": "/* CONFIG_NO_STDOUT_DEBUG */\n", "func_signal": "static void eap_sim_state(struct eap_sim_data *data, int state)", "code": "{\n\twpa_printf(MSG_DEBUG, \"EAP-SIM: %s -> %s\",\n\t\t   eap_sim_state_txt(data->state),\n\t\t   eap_sim_state_txt(state));\n\tdata->state = state;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\eap_peer\\eap_sim.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/* CONFIG_WPS_UPNP */\n", "func_signal": "static int wps_build_ap_setup_locked(struct wps_context *wps,\n\t\t\t\t     struct wpabuf *msg)", "code": "{\n\tif (wps->ap_setup_locked) {\n\t\twpa_printf(MSG_DEBUG, \"WPS:  * AP Setup Locked\");\n\t\twpabuf_put_be16(msg, ATTR_AP_SETUP_LOCKED);\n\t\twpabuf_put_be16(msg, 1);\n\t\twpabuf_put_u8(msg, 1);\n\t}\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_probe_req_rx - Notify Registrar of Probe Request\n * @reg: Registrar data from wps_registrar_init()\n * @addr: MAC address of the Probe Request sender\n * @wps_data: WPS IE contents\n *\n * This function is called on an AP when a Probe Request with WPS IE is\n * received. This is used to track PBC mode use and to detect possible overlap\n * situation with other WPS APs.\n */\n", "func_signal": "void wps_registrar_probe_req_rx(struct wps_registrar *reg, const u8 *addr,\n\t\t\t\tconst struct wpabuf *wps_data)", "code": "{\n\tstruct wps_parse_attr attr;\n\tu16 methods;\n\n\twpa_hexdump_buf(MSG_MSGDUMP,\n\t\t\t\"WPS: Probe Request with WPS data received\",\n\t\t\twps_data);\n\n\tif (wps_parse_msg(wps_data, &attr) < 0)\n\t\treturn;\n\tif (!wps_version_supported(attr.version)) {\n\t\twpa_printf(MSG_DEBUG, \"WPS: Unsupported ProbeReq WPS IE \"\n\t\t\t   \"version 0x%x\", attr.version ? *attr.version : 0);\n\t\treturn;\n\t}\n\n\tif (attr.config_methods == NULL) {\n\t\twpa_printf(MSG_DEBUG, \"WPS: No Config Methods attribute in \"\n\t\t\t   \"Probe Request\");\n\t\treturn;\n\t}\n\n\tmethods = WPA_GET_BE16(attr.config_methods);\n\tif (!(methods & WPS_CONFIG_PUSHBUTTON))\n\t\treturn; /* Not PBC */\n\n\twpa_printf(MSG_DEBUG, \"WPS: Probe Request for PBC received from \"\n\t\t   MACSTR, MAC2STR(addr));\n\n\twps_registrar_add_pbc_session(reg, addr, attr.uuid_e);\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * milenage_auts - Milenage AUTS validation\n * @opc: OPc = 128-bit operator variant algorithm configuration field (encr.)\n * @k: K = 128-bit subscriber key\n * @_rand: RAND = 128-bit random challenge\n * @auts: AUTS = 112-bit authentication token from client\n * @sqn: Buffer for SQN = 48-bit sequence number\n * Returns: 0 = success (sqn filled), -1 on failure\n */\n", "func_signal": "int milenage_auts(const u8 *opc, const u8 *k, const u8 *_rand, const u8 *auts,\n\t\t  u8 *sqn)", "code": "{\n\tu8 amf[2] = { 0x00, 0x00 }; /* TS 33.102 v7.0.0, 6.3.3 */\n\tu8 ak[6], mac_s[8];\n\tint i;\n\n\tif (milenage_f2345(opc, k, _rand, NULL, NULL, NULL, NULL, ak))\n\t\treturn -1;\n\tfor (i = 0; i < 6; i++)\n\t\tsqn[i] = auts[i] ^ ak[i];\n\tif (milenage_f1(opc, k, _rand, sqn, amf, NULL, mac_s) ||\n\t    memcmp(mac_s, auts + 6, 8) != 0)\n\t\treturn -1;\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\hlr_auc_gw\\milenage.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_button_pushed - Notify Registrar that AP button was pushed\n * @reg: Registrar data from wps_registrar_init()\n * Returns: 0 on success, -1 on failure\n *\n * This function is called on an AP when a push button is pushed to activate\n * PBC mode. The PBC mode will be stopped after walk time (2 minutes) timeout\n * or when a PBC registration is completed.\n */\n", "func_signal": "int wps_registrar_button_pushed(struct wps_registrar *reg)", "code": "{\n\tif (wps_registrar_pbc_overlap(reg, NULL, NULL)) {\n\t\twpa_printf(MSG_DEBUG, \"WPS: PBC overlap - do not start PBC \"\n\t\t\t   \"mode\");\n\t\treturn -1;\n\t}\n\twpa_printf(MSG_DEBUG, \"WPS: Button pushed - PBC mode started\");\n\treg->selected_registrar = 1;\n\treg->pbc = 1;\n\twps_set_ie(reg);\n\n\teloop_cancel_timeout(wps_registrar_pbc_timeout, reg, NULL);\n\teloop_register_timeout(WPS_PBC_WALK_TIME, 0, wps_registrar_pbc_timeout,\n\t\t\t       reg, NULL);\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_invalidate_pin - Invalidate a PIN for a specific UUID-E\n * @reg: Registrar data from wps_registrar_init()\n * @uuid: UUID-E\n * Returns: 0 on success, -1 on failure (e.g., PIN not found)\n */\n", "func_signal": "int wps_registrar_invalidate_pin(struct wps_registrar *reg, const u8 *uuid)", "code": "{\n\tstruct wps_uuid_pin *pin, *prev;\n\n\tprev = NULL;\n\tpin = reg->pins;\n\twhile (pin) {\n\t\tif (os_memcmp(pin->uuid, uuid, WPS_UUID_LEN) == 0) {\n\t\t\tif (prev == NULL)\n\t\t\t\treg->pins = pin->next;\n\t\t\telse\n\t\t\t\tprev->next = pin->next;\n\t\t\twpa_hexdump(MSG_DEBUG, \"WPS: Invalidated PIN for UUID\",\n\t\t\t\t    pin->uuid, WPS_UUID_LEN);\n\t\t\twps_free_pin(pin);\n\t\t\treturn 0;\n\t\t}\n\t\tprev = pin;\n\t\tpin = pin->next;\n\t}\n\n\treturn -1;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/*\n * Utility routine to adjust the inode counts on an inode.\n */\n", "func_signal": "errcode_t e2fsck_adjust_inode_count(e2fsck_t ctx, ext2_ino_t ino, int adj)", "code": "{\n\text2_filsys fs = ctx->fs;\n\terrcode_t\t\tretval;\n\tstruct ext2_inode \tinode;\n\n\tif (!ino)\n\t\treturn 0;\n\n\tretval = ext2fs_read_inode(fs, ino, &inode);\n\tif (retval)\n\t\treturn retval;\n\n#if 0\n\tprintf(\"Adjusting link count for inode %lu by %d (from %d)\\n\", ino, adj,\n\t       inode.i_links_count);\n#endif\n\n\tif (adj == 1) {\n\t\text2fs_icount_increment(ctx->inode_count, ino, 0);\n\t\tif (inode.i_links_count == (__u16) ~0)\n\t\t\treturn 0;\n\t\text2fs_icount_increment(ctx->inode_link_info, ino, 0);\n\t\tinode.i_links_count++;\n\t} else if (adj == -1) {\n\t\text2fs_icount_decrement(ctx->inode_count, ino, 0);\n\t\tif (inode.i_links_count == 0)\n\t\t\treturn 0;\n\t\text2fs_icount_decrement(ctx->inode_link_info, ino, 0);\n\t\tinode.i_links_count--;\n\t}\n\n\tretval = ext2fs_write_inode(fs, ino, &inode);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}", "path": "src\\third_party\\e2fsprogs\\files\\e2fsck\\pass3.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/* Encapsulate WPS IE data with one (or more, if needed) IE headers */\n", "func_signal": "static struct wpabuf * wps_ie_encapsulate(struct wpabuf *data)", "code": "{\n\tstruct wpabuf *ie;\n\tconst u8 *pos, *end;\n\n\tie = wpabuf_alloc(wpabuf_len(data) + 100);\n\tif (ie == NULL) {\n\t\twpabuf_free(data);\n\t\treturn NULL;\n\t}\n\n\tpos = wpabuf_head(data);\n\tend = pos + wpabuf_len(data);\n\n\twhile (end > pos) {\n\t\tsize_t frag_len = end - pos;\n\t\tif (frag_len > 251)\n\t\t\tfrag_len = 251;\n\t\twpabuf_put_u8(ie, WLAN_EID_VENDOR_SPECIFIC);\n\t\twpabuf_put_u8(ie, 4 + frag_len);\n\t\twpabuf_put_be32(ie, WPS_DEV_OUI_WFA);\n\t\twpabuf_put_data(ie, pos, frag_len);\n\t\tpos += frag_len;\n\t}\n\n\twpabuf_free(data);\n\n\treturn ie;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * gsm_milenage - Generate GSM-Milenage (3GPP TS 55.205) authentication triplet\n * @opc: OPc = 128-bit operator variant algorithm configuration field (encr.)\n * @k: K = 128-bit subscriber key\n * @_rand: RAND = 128-bit random challenge\n * @sres: Buffer for SRES = 32-bit SRES\n * @kc: Buffer for Kc = 64-bit Kc\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "int gsm_milenage(const u8 *opc, const u8 *k, const u8 *_rand, u8 *sres, u8 *kc)", "code": "{\n\tu8 res[8], ck[16], ik[16];\n\tint i;\n\n\tif (milenage_f2345(opc, k, _rand, res, ck, ik, NULL, NULL))\n\t\treturn -1;\n\n\tfor (i = 0; i < 8; i++)\n\t\tkc[i] = ck[i] ^ ck[i + 8] ^ ik[i] ^ ik[i + 8];\n\n#ifdef GSM_MILENAGE_ALT_SRES\n\tos_memcpy(sres, res, 4);\n#else /* GSM_MILENAGE_ALT_SRES */\n\tfor (i = 0; i < 4; i++)\n\t\tsres[i] = res[i] ^ res[i + 4];\n#endif /* GSM_MILENAGE_ALT_SRES */\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\hlr_auc_gw\\milenage.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_init - Initialize WPS Registrar data\n * @wps: Pointer to longterm WPS context\n * @cfg: Registrar configuration\n * Returns: Pointer to allocated Registrar data or %NULL on failure\n *\n * This function is used to initialize WPS Registrar functionality. It can be\n * used for a single Registrar run (e.g., when run in a supplicant) or multiple\n * runs (e.g., when run as an internal Registrar in an AP). Caller is\n * responsible for freeing the returned data with wps_registrar_deinit() when\n * Registrar functionality is not needed anymore.\n */\n", "func_signal": "struct wps_registrar *\nwps_registrar_init(struct wps_context *wps,\n\t\t   const struct wps_registrar_config *cfg)", "code": "{\n\tstruct wps_registrar *reg = os_zalloc(sizeof(*reg));\n\tif (reg == NULL)\n\t\treturn NULL;\n\n\treg->wps = wps;\n\treg->new_psk_cb = cfg->new_psk_cb;\n\treg->set_ie_cb = cfg->set_ie_cb;\n\treg->pin_needed_cb = cfg->pin_needed_cb;\n\treg->reg_success_cb = cfg->reg_success_cb;\n\treg->cb_ctx = cfg->cb_ctx;\n\treg->skip_cred_build = cfg->skip_cred_build;\n\tif (cfg->extra_cred) {\n\t\treg->extra_cred = wpabuf_alloc_copy(cfg->extra_cred,\n\t\t\t\t\t\t    cfg->extra_cred_len);\n\t\tif (reg->extra_cred == NULL) {\n\t\t\tos_free(reg);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treg->disable_auto_conf = cfg->disable_auto_conf;\n\treg->sel_reg_dev_password_id_override = -1;\n\treg->sel_reg_config_methods_override = -1;\n\treg->static_wep_only = cfg->static_wep_only;\n\n\tif (wps_set_ie(reg)) {\n\t\twps_registrar_deinit(reg);\n\t\treturn NULL;\n\t}\n\n\treturn reg;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/*\n * This routine will connect a file to lost+found\n */\n", "func_signal": "int e2fsck_reconnect_file(e2fsck_t ctx, ext2_ino_t ino)", "code": "{\n\text2_filsys fs = ctx->fs;\n\terrcode_t\tretval;\n\tchar\t\tname[80];\n\tstruct problem_context\tpctx;\n\tstruct ext2_inode \tinode;\n\tint\t\tfile_type = 0;\n\n\tclear_problem_context(&pctx);\n\tpctx.ino = ino;\n\n\tif (!ctx->bad_lost_and_found && !ctx->lost_and_found) {\n\t\tif (e2fsck_get_lost_and_found(ctx, 1) == 0)\n\t\t\tctx->bad_lost_and_found++;\n\t}\n\tif (ctx->bad_lost_and_found) {\n\t\tfix_problem(ctx, PR_3_NO_LPF, &pctx);\n\t\treturn 1;\n\t}\n\n\tsprintf(name, \"#%u\", ino);\n\tif (ext2fs_read_inode(fs, ino, &inode) == 0)\n\t\tfile_type = ext2_file_type(inode.i_mode);\n\tretval = ext2fs_link(fs, ctx->lost_and_found, name, ino, file_type);\n\tif (retval == EXT2_ET_DIR_NO_SPACE) {\n\t\tif (!fix_problem(ctx, PR_3_EXPAND_LF_DIR, &pctx))\n\t\t\treturn 1;\n\t\tretval = e2fsck_expand_directory(ctx, ctx->lost_and_found,\n\t\t\t\t\t\t 1, 0);\n\t\tif (retval) {\n\t\t\tpctx.errcode = retval;\n\t\t\tfix_problem(ctx, PR_3_CANT_EXPAND_LPF, &pctx);\n\t\t\treturn 1;\n\t\t}\n\t\tretval = ext2fs_link(fs, ctx->lost_and_found, name,\n\t\t\t\t     ino, file_type);\n\t}\n\tif (retval) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_CANT_RECONNECT, &pctx);\n\t\treturn 1;\n\t}\n\te2fsck_adjust_inode_count(ctx, ino, 1);\n\n\treturn 0;\n}", "path": "src\\third_party\\e2fsprogs\\files\\e2fsck\\pass3.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * milenage_f1 - Milenage f1 and f1* algorithms\n * @opc: OPc = 128-bit value derived from OP and K\n * @k: K = 128-bit subscriber key\n * @_rand: RAND = 128-bit random challenge\n * @sqn: SQN = 48-bit sequence number\n * @amf: AMF = 16-bit authentication management field\n * @mac_a: Buffer for MAC-A = 64-bit network authentication code, or %NULL\n * @mac_s: Buffer for MAC-S = 64-bit resync authentication code, or %NULL\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "static int milenage_f1(const u8 *opc, const u8 *k, const u8 *_rand,\n\t\t       const u8 *sqn, const u8 *amf, u8 *mac_a, u8 *mac_s)", "code": "{\n\tu8 tmp1[16], tmp2[16], tmp3[16];\n\tint i;\n\n\t/* tmp1 = TEMP = E_K(RAND XOR OP_C) */\n\tfor (i = 0; i < 16; i++)\n\t\ttmp1[i] = _rand[i] ^ opc[i];\n\tif (aes_128_encrypt_block(k, tmp1, tmp1))\n\t\treturn -1;\n\n\t/* tmp2 = IN1 = SQN || AMF || SQN || AMF */\n\tos_memcpy(tmp2, sqn, 6);\n\tos_memcpy(tmp2 + 6, amf, 2);\n\tos_memcpy(tmp2 + 8, tmp2, 8);\n\n\t/* OUT1 = E_K(TEMP XOR rot(IN1 XOR OP_C, r1) XOR c1) XOR OP_C */\n\n\t/* rotate (tmp2 XOR OP_C) by r1 (= 0x40 = 8 bytes) */\n\tfor (i = 0; i < 16; i++)\n\t\ttmp3[(i + 8) % 16] = tmp2[i] ^ opc[i];\n\t/* XOR with TEMP = E_K(RAND XOR OP_C) */\n\tfor (i = 0; i < 16; i++)\n\t\ttmp3[i] ^= tmp1[i];\n\t/* XOR with c1 (= ..00, i.e., NOP) */\n\n\t/* f1 || f1* = E_K(tmp3) XOR OP_c */\n\tif (aes_128_encrypt_block(k, tmp3, tmp1))\n\t\treturn -1;\n\tfor (i = 0; i < 16; i++)\n\t\ttmp1[i] ^= opc[i];\n\tif (mac_a)\n\t\tos_memcpy(mac_a, tmp1, 8); /* f1 */\n\tif (mac_s)\n\t\tos_memcpy(mac_s, tmp1 + 8, 8); /* f1* */\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\hlr_auc_gw\\milenage.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/* Coglbox implementation\n *--------------------------------------------------*/\n", "func_signal": "static void\ntest_coglbox_paint (ClutterActor *self)", "code": "{\n  TestCoglboxPrivate *priv = TEST_COGLBOX_GET_PRIVATE (self);\n  gfloat texcoords[4] = { 0.0f, 0.0f, 1.0f, 1.0f };\n  gfloat angle;\n  gfloat frac;\n  gint t;\n\n  angle = priv->animation_progress * 2 * G_PI;\n\n  frac = ((priv->animation_progress <= 0.5f\n           ? priv->animation_progress\n           : 1.0f - priv->animation_progress) + 0.5f) * 2.0f;\n\n  for (t=0; t<4; t+=2)\n    {\n      texcoords[t]   += cos (angle);\n      texcoords[t+1] += sin (angle);\n\n      texcoords[t]   *= frac;\n      texcoords[t+1] *= frac;\n    }\n\n  priv = TEST_COGLBOX_GET_PRIVATE (self);\n\n  cogl_push_matrix ();\n\n  cogl_set_source_color4ub (0x66, 0x66, 0xdd, 0xff);\n  cogl_rectangle (0, 0, 400, 400);\n\n  cogl_translate (100, 100, 0);\n  cogl_set_source_texture (priv->cogl_tex_id);\n  cogl_rectangle_with_texture_coords (0, 0, 200, 213,\n                                      texcoords[0], texcoords[1],\n                                      texcoords[2], texcoords[3]);\n\n  cogl_pop_matrix();\n}", "path": "src\\third_party\\clutter\\files\\tests\\interactive\\test-cogl-tex-tile.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_add_pin - Configure a new PIN for Registrar\n * @reg: Registrar data from wps_registrar_init()\n * @uuid: UUID-E or %NULL for wildcard (any UUID)\n * @pin: PIN (Device Password)\n * @pin_len: Length of pin in octets\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "int wps_registrar_add_pin(struct wps_registrar *reg, const u8 *uuid,\n\t\t\t  const u8 *pin, size_t pin_len)", "code": "{\n\tstruct wps_uuid_pin *p;\n\n\tp = os_zalloc(sizeof(*p));\n\tif (p == NULL)\n\t\treturn -1;\n\tif (uuid == NULL)\n\t\tp->wildcard_uuid = 1;\n\telse\n\t\tos_memcpy(p->uuid, uuid, WPS_UUID_LEN);\n\tp->pin = os_malloc(pin_len);\n\tif (p->pin == NULL) {\n\t\tos_free(p);\n\t\treturn -1;\n\t}\n\tos_memcpy(p->pin, pin, pin_len);\n\tp->pin_len = pin_len;\n\n\tp->next = reg->pins;\n\treg->pins = p;\n\n\twpa_printf(MSG_DEBUG, \"WPS: A new PIN configured\");\n\twpa_hexdump(MSG_DEBUG, \"WPS: UUID\", uuid, WPS_UUID_LEN);\n\twpa_hexdump_ascii_key(MSG_DEBUG, \"WPS: PIN\", pin, pin_len);\n\treg->selected_registrar = 1;\n\treg->pbc = 0;\n\twps_set_ie(reg);\n\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/*\n * This makes sure the root inode is present; if not, we ask if the\n * user wants us to create it.  Not creating it is a fatal error.\n */\n", "func_signal": "static void check_root(e2fsck_t ctx)", "code": "{\n\text2_filsys fs = ctx->fs;\n\tblk64_t\t\t\tblk;\n\tstruct ext2_inode\tinode;\n\tchar *\t\t\tblock;\n\tstruct problem_context\tpctx;\n\n\tclear_problem_context(&pctx);\n\n\tif (ext2fs_test_inode_bitmap2(ctx->inode_used_map, EXT2_ROOT_INO)) {\n\t\t/*\n\t\t * If the root inode is not a directory, die here.  The\n\t\t * user must have answered 'no' in pass1 when we\n\t\t * offered to clear it.\n\t\t */\n\t\tif (!(ext2fs_test_inode_bitmap2(ctx->inode_dir_map,\n\t\t\t\t\t       EXT2_ROOT_INO))) {\n\t\t\tfix_problem(ctx, PR_3_ROOT_NOT_DIR_ABORT, &pctx);\n\t\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!fix_problem(ctx, PR_3_NO_ROOT_INODE, &pctx)) {\n\t\tfix_problem(ctx, PR_3_NO_ROOT_INODE_ABORT, &pctx);\n\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\treturn;\n\t}\n\n\te2fsck_read_bitmaps(ctx);\n\n\t/*\n\t * First, find a free block\n\t */\n\tpctx.errcode = ext2fs_new_block2(fs, 0, ctx->block_found_map, &blk);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_new_block\";\n\t\tfix_problem(ctx, PR_3_CREATE_ROOT_ERROR, &pctx);\n\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\treturn;\n\t}\n\text2fs_mark_block_bitmap2(ctx->block_found_map, blk);\n\text2fs_mark_block_bitmap2(fs->block_map, blk);\n\text2fs_mark_bb_dirty(fs);\n\n\t/*\n\t * Now let's create the actual data block for the inode\n\t */\n\tpctx.errcode = ext2fs_new_dir_block(fs, EXT2_ROOT_INO, EXT2_ROOT_INO,\n\t\t\t\t\t    &block);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_new_dir_block\";\n\t\tfix_problem(ctx, PR_3_CREATE_ROOT_ERROR, &pctx);\n\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\treturn;\n\t}\n\n\tpctx.errcode = ext2fs_write_dir_block(fs, blk, block);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_write_dir_block\";\n\t\tfix_problem(ctx, PR_3_CREATE_ROOT_ERROR, &pctx);\n\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\treturn;\n\t}\n\text2fs_free_mem(&block);\n\n\t/*\n\t * Set up the inode structure\n\t */\n\tmemset(&inode, 0, sizeof(inode));\n\tinode.i_mode = 040755;\n\tinode.i_size = fs->blocksize;\n\tinode.i_atime = inode.i_ctime = inode.i_mtime = ctx->now;\n\tinode.i_links_count = 2;\n\text2fs_iblk_set(fs, &inode, 1);\n\tinode.i_block[0] = blk;\n\n\t/*\n\t * Write out the inode.\n\t */\n\tpctx.errcode = ext2fs_write_new_inode(fs, EXT2_ROOT_INO, &inode);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_write_inode\";\n\t\tfix_problem(ctx, PR_3_CREATE_ROOT_ERROR, &pctx);\n\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\treturn;\n\t}\n\n\t/*\n\t * Miscellaneous bookkeeping...\n\t */\n\te2fsck_add_dir_info(ctx, EXT2_ROOT_INO, EXT2_ROOT_INO);\n\text2fs_icount_store(ctx->inode_count, EXT2_ROOT_INO, 2);\n\text2fs_icount_store(ctx->inode_link_info, EXT2_ROOT_INO, 2);\n\n\text2fs_mark_inode_bitmap2(ctx->inode_used_map, EXT2_ROOT_INO);\n\text2fs_mark_inode_bitmap2(ctx->inode_dir_map, EXT2_ROOT_INO);\n\text2fs_mark_inode_bitmap2(fs->inode_map, EXT2_ROOT_INO);\n\text2fs_mark_ib_dirty(fs);\n}", "path": "src\\third_party\\e2fsprogs\\files\\e2fsck\\pass3.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/*\n * This routine gets the lost_and_found inode, making it a directory\n * if necessary\n */\n", "func_signal": "ext2_ino_t e2fsck_get_lost_and_found(e2fsck_t ctx, int fix)", "code": "{\n\text2_filsys fs = ctx->fs;\n\text2_ino_t\t\t\tino;\n\tblk64_t\t\t\tblk;\n\terrcode_t\t\tretval;\n\tstruct ext2_inode\tinode;\n\tchar *\t\t\tblock;\n\tstatic const char\tname[] = \"lost+found\";\n\tstruct \tproblem_context\tpctx;\n\n\tif (ctx->lost_and_found)\n\t\treturn ctx->lost_and_found;\n\n\tclear_problem_context(&pctx);\n\n\tretval = ext2fs_lookup(fs, EXT2_ROOT_INO, name,\n\t\t\t       sizeof(name)-1, 0, &ino);\n\tif (retval && !fix)\n\t\treturn 0;\n\tif (!retval) {\n\t\tif (ext2fs_test_inode_bitmap2(ctx->inode_dir_map, ino)) {\n\t\t\tctx->lost_and_found = ino;\n\t\t\treturn ino;\n\t\t}\n\n\t\t/* Lost+found isn't a directory! */\n\t\tif (!fix)\n\t\t\treturn 0;\n\t\tpctx.ino = ino;\n\t\tif (!fix_problem(ctx, PR_3_LPF_NOTDIR, &pctx))\n\t\t\treturn 0;\n\n\t\t/* OK, unlink the old /lost+found file. */\n\t\tpctx.errcode = ext2fs_unlink(fs, EXT2_ROOT_INO, name, ino, 0);\n\t\tif (pctx.errcode) {\n\t\t\tpctx.str = \"ext2fs_unlink\";\n\t\t\tfix_problem(ctx, PR_3_CREATE_LPF_ERROR, &pctx);\n\t\t\treturn 0;\n\t\t}\n\t\t(void) e2fsck_dir_info_set_parent(ctx, ino, 0);\n\t\te2fsck_adjust_inode_count(ctx, ino, -1);\n\t} else if (retval != EXT2_ET_FILE_NOT_FOUND) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_ERR_FIND_LPF, &pctx);\n\t}\n\tif (!fix_problem(ctx, PR_3_NO_LF_DIR, 0))\n\t\treturn 0;\n\n\t/*\n\t * Read the inode and block bitmaps in; we'll be messing with\n\t * them.\n\t */\n\te2fsck_read_bitmaps(ctx);\n\n\t/*\n\t * First, find a free block\n\t */\n\tretval = ext2fs_new_block2(fs, 0, ctx->block_found_map, &blk);\n\tif (retval) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_ERR_LPF_NEW_BLOCK, &pctx);\n\t\treturn 0;\n\t}\n\text2fs_mark_block_bitmap2(ctx->block_found_map, blk);\n\text2fs_block_alloc_stats(fs, blk, +1);\n\n\t/*\n\t * Next find a free inode.\n\t */\n\tretval = ext2fs_new_inode(fs, EXT2_ROOT_INO, 040700,\n\t\t\t\t  ctx->inode_used_map, &ino);\n\tif (retval) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_ERR_LPF_NEW_INODE, &pctx);\n\t\treturn 0;\n\t}\n\text2fs_mark_inode_bitmap2(ctx->inode_used_map, ino);\n\text2fs_mark_inode_bitmap2(ctx->inode_dir_map, ino);\n\text2fs_inode_alloc_stats2(fs, ino, +1, 1);\n\n\t/*\n\t * Now let's create the actual data block for the inode\n\t */\n\tretval = ext2fs_new_dir_block(fs, ino, EXT2_ROOT_INO, &block);\n\tif (retval) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_ERR_LPF_NEW_DIR_BLOCK, &pctx);\n\t\treturn 0;\n\t}\n\n\tretval = ext2fs_write_dir_block(fs, blk, block);\n\text2fs_free_mem(&block);\n\tif (retval) {\n\t\tpctx.errcode = retval;\n\t\tfix_problem(ctx, PR_3_ERR_LPF_WRITE_BLOCK, &pctx);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Set up the inode structure\n\t */\n\tmemset(&inode, 0, sizeof(inode));\n\tinode.i_mode = 040700;\n\tinode.i_size = fs->blocksize;\n\tinode.i_atime = inode.i_ctime = inode.i_mtime = ctx->now;\n\tinode.i_links_count = 2;\n\text2fs_iblk_set(fs, &inode, 1);\n\tinode.i_block[0] = blk;\n\n\t/*\n\t * Next, write out the inode.\n\t */\n\tpctx.errcode = ext2fs_write_new_inode(fs, ino, &inode);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_write_inode\";\n\t\tfix_problem(ctx, PR_3_CREATE_LPF_ERROR, &pctx);\n\t\treturn 0;\n\t}\n\t/*\n\t * Finally, create the directory link\n\t */\n\tpctx.errcode = ext2fs_link(fs, EXT2_ROOT_INO, name, ino, EXT2_FT_DIR);\n\tif (pctx.errcode) {\n\t\tpctx.str = \"ext2fs_link\";\n\t\tfix_problem(ctx, PR_3_CREATE_LPF_ERROR, &pctx);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Miscellaneous bookkeeping that needs to be kept straight.\n\t */\n\te2fsck_add_dir_info(ctx, ino, EXT2_ROOT_INO);\n\te2fsck_adjust_inode_count(ctx, EXT2_ROOT_INO, 1);\n\text2fs_icount_store(ctx->inode_count, ino, 2);\n\text2fs_icount_store(ctx->inode_link_info, ino, 2);\n\tctx->lost_and_found = ino;\n#if 0\n\tprintf(\"/lost+found created; inode #%lu\\n\", ino);\n#endif\n\treturn ino;\n}", "path": "src\\third_party\\e2fsprogs\\files\\e2fsck\\pass3.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/*\n * This subroutine is responsible for making sure that a particular\n * directory is connected to the root; if it isn't we trace it up as\n * far as we can go, and then offer to connect the resulting parent to\n * the lost+found.  We have to do loop detection; if we ever discover\n * a loop, we treat that as a disconnected directory and offer to\n * reparent it to lost+found.\n *\n * However, loop detection is expensive, because for very large\n * filesystems, the inode_loop_detect bitmap is huge, and clearing it\n * is non-trivial.  Loops in filesystems are also a rare error case,\n * and we shouldn't optimize for error cases.  So we try two passes of\n * the algorithm.  The first time, we ignore loop detection and merely\n * increment a counter; if the counter exceeds some extreme threshold,\n * then we try again with the loop detection bitmap enabled.\n */\n", "func_signal": "static int check_directory(e2fsck_t ctx, ext2_ino_t dir,\n\t\t\t   struct problem_context *pctx)", "code": "{\n\text2_filsys \tfs = ctx->fs;\n\text2_ino_t\tino = dir, parent;\n\tint\t\tloop_pass = 0, parent_count = 0;\n\n\twhile (1) {\n\t\t/*\n\t\t * Mark this inode as being \"done\"; by the time we\n\t\t * return from this function, the inode we either be\n\t\t * verified as being connected to the directory tree,\n\t\t * or we will have offered to reconnect this to\n\t\t * lost+found.\n\t\t *\n\t\t * If it was marked done already, then we've reached a\n\t\t * parent we've already checked.\n\t\t */\n\t  \tif (ext2fs_mark_inode_bitmap2(inode_done_map, ino))\n\t\t\tbreak;\n\n\t\tif (e2fsck_dir_info_get_parent(ctx, ino, &parent)) {\n\t\t\tfix_problem(ctx, PR_3_NO_DIRINFO, pctx);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If this directory doesn't have a parent, or we've\n\t\t * seen the parent once already, then offer to\n\t\t * reparent it to lost+found\n\t\t */\n\t\tif (!parent ||\n\t\t    (loop_pass &&\n\t\t     (ext2fs_test_inode_bitmap2(inode_loop_detect,\n\t\t\t\t\t       parent)))) {\n\t\t\tpctx->ino = ino;\n\t\t\tif (fix_problem(ctx, PR_3_UNCONNECTED_DIR, pctx)) {\n\t\t\t\tif (e2fsck_reconnect_file(ctx, pctx->ino))\n\t\t\t\t\text2fs_unmark_valid(fs);\n\t\t\t\telse {\n\t\t\t\t\tfix_dotdot(ctx, pctx->ino,\n\t\t\t\t\t\t   ctx->lost_and_found);\n\t\t\t\t\tparent = ctx->lost_and_found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tino = parent;\n\t\tif (loop_pass) {\n\t\t\text2fs_mark_inode_bitmap2(inode_loop_detect, ino);\n\t\t} else if (parent_count++ > 2048) {\n\t\t\t/*\n\t\t\t * If we've run into a path depth that's\n\t\t\t * greater than 2048, try again with the inode\n\t\t\t * loop bitmap turned on and start from the\n\t\t\t * top.\n\t\t\t */\n\t\t\tloop_pass = 1;\n\t\t\tif (inode_loop_detect)\n\t\t\t\text2fs_clear_inode_bitmap(inode_loop_detect);\n\t\t\telse {\n\t\t\t\tpctx->errcode = ext2fs_allocate_inode_bitmap(fs, _(\"inode loop detection bitmap\"), &inode_loop_detect);\n\t\t\t\tif (pctx->errcode) {\n\t\t\t\t\tpctx->num = 1;\n\t\t\t\t\tfix_problem(ctx,\n\t\t\t\t    PR_3_ALLOCATE_IBITMAP_ERROR, pctx);\n\t\t\t\t\tctx->flags |= E2F_FLAG_ABORT;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tino = dir;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that .. and the parent directory are the same;\n\t * offer to fix it if not.\n\t */\n\tpctx->ino = dir;\n\tif (e2fsck_dir_info_get_dotdot(ctx, dir, &pctx->ino2) ||\n\t    e2fsck_dir_info_get_parent(ctx, dir, &pctx->dir)) {\n\t\tfix_problem(ctx, PR_3_NO_DIRINFO, pctx);\n\t\treturn 0;\n\t}\n\tif (pctx->ino2 != pctx->dir) {\n\t\tif (fix_problem(ctx, PR_3_BAD_DOT_DOT, pctx))\n\t\t\tfix_dotdot(ctx, dir, pctx->dir);\n\t}\n\treturn 0;\n}", "path": "src\\third_party\\e2fsprogs\\files\\e2fsck\\pass3.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * milenage_f2345 - Milenage f2, f3, f4, f5, f5* algorithms\n * @opc: OPc = 128-bit value derived from OP and K\n * @k: K = 128-bit subscriber key\n * @_rand: RAND = 128-bit random challenge\n * @res: Buffer for RES = 64-bit signed response (f2), or %NULL\n * @ck: Buffer for CK = 128-bit confidentiality key (f3), or %NULL\n * @ik: Buffer for IK = 128-bit integrity key (f4), or %NULL\n * @ak: Buffer for AK = 48-bit anonymity key (f5), or %NULL\n * @akstar: Buffer for AK = 48-bit anonymity key (f5*), or %NULL\n * Returns: 0 on success, -1 on failure\n */\n", "func_signal": "static int milenage_f2345(const u8 *opc, const u8 *k, const u8 *_rand,\n\t\t\t  u8 *res, u8 *ck, u8 *ik, u8 *ak, u8 *akstar)", "code": "{\n\tu8 tmp1[16], tmp2[16], tmp3[16];\n\tint i;\n\n\t/* tmp2 = TEMP = E_K(RAND XOR OP_C) */\n\tfor (i = 0; i < 16; i++)\n\t\ttmp1[i] = _rand[i] ^ opc[i];\n\tif (aes_128_encrypt_block(k, tmp1, tmp2))\n\t\treturn -1;\n\n\t/* OUT2 = E_K(rot(TEMP XOR OP_C, r2) XOR c2) XOR OP_C */\n\t/* OUT3 = E_K(rot(TEMP XOR OP_C, r3) XOR c3) XOR OP_C */\n\t/* OUT4 = E_K(rot(TEMP XOR OP_C, r4) XOR c4) XOR OP_C */\n\t/* OUT5 = E_K(rot(TEMP XOR OP_C, r5) XOR c5) XOR OP_C */\n\n\t/* f2 and f5 */\n\t/* rotate by r2 (= 0, i.e., NOP) */\n\tfor (i = 0; i < 16; i++)\n\t\ttmp1[i] = tmp2[i] ^ opc[i];\n\ttmp1[15] ^= 1; /* XOR c2 (= ..01) */\n\t/* f5 || f2 = E_K(tmp1) XOR OP_c */\n\tif (aes_128_encrypt_block(k, tmp1, tmp3))\n\t\treturn -1;\n\tfor (i = 0; i < 16; i++)\n\t\ttmp3[i] ^= opc[i];\n\tif (res)\n\t\tos_memcpy(res, tmp3 + 8, 8); /* f2 */\n\tif (ak)\n\t\tos_memcpy(ak, tmp3, 6); /* f5 */\n\n\t/* f3 */\n\tif (ck) {\n\t\t/* rotate by r3 = 0x20 = 4 bytes */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\ttmp1[(i + 12) % 16] = tmp2[i] ^ opc[i];\n\t\ttmp1[15] ^= 2; /* XOR c3 (= ..02) */\n\t\tif (aes_128_encrypt_block(k, tmp1, ck))\n\t\t\treturn -1;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tck[i] ^= opc[i];\n\t}\n\n\t/* f4 */\n\tif (ik) {\n\t\t/* rotate by r4 = 0x40 = 8 bytes */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\ttmp1[(i + 8) % 16] = tmp2[i] ^ opc[i];\n\t\ttmp1[15] ^= 4; /* XOR c4 (= ..04) */\n\t\tif (aes_128_encrypt_block(k, tmp1, ik))\n\t\t\treturn -1;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tik[i] ^= opc[i];\n\t}\n\n\t/* f5* */\n\tif (akstar) {\n\t\t/* rotate by r5 = 0x60 = 12 bytes */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\ttmp1[(i + 4) % 16] = tmp2[i] ^ opc[i];\n\t\ttmp1[15] ^= 8; /* XOR c5 (= ..08) */\n\t\tif (aes_128_encrypt_block(k, tmp1, tmp1))\n\t\t\treturn -1;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\takstar[i] = tmp1[i] ^ opc[i];\n\t}\n\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\hlr_auc_gw\\milenage.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * wps_registrar_set_selected_registrar - Notification of SetSelectedRegistrar\n * @reg: Registrar data from wps_registrar_init()\n * @msg: Received message from SetSelectedRegistrar\n * Returns: 0 on success, -1 on failure\n *\n * This function is called when an AP receives a SetSelectedRegistrar UPnP\n * message.\n */\n", "func_signal": "int wps_registrar_set_selected_registrar(struct wps_registrar *reg,\n\t\t\t\t\t const struct wpabuf *msg)", "code": "{\n\tstruct wps_parse_attr attr;\n\n\twpa_hexdump_buf(MSG_MSGDUMP, \"WPS: SetSelectedRegistrar attributes\",\n\t\t\tmsg);\n\n\tif (wps_parse_msg(msg, &attr) < 0)\n\t\treturn -1;\n\tif (!wps_version_supported(attr.version)) {\n\t\twpa_printf(MSG_DEBUG, \"WPS: Unsupported SetSelectedRegistrar \"\n\t\t\t   \"version 0x%x\", attr.version ? *attr.version : 0);\n\t\treturn -1;\n\t}\n\n\tif (attr.selected_registrar == NULL ||\n\t    *attr.selected_registrar == 0) {\n\t\twpa_printf(MSG_DEBUG, \"WPS: SetSelectedRegistrar: Disable \"\n\t\t\t   \"Selected Registrar\");\n\t\teloop_cancel_timeout(wps_registrar_set_selected_timeout, reg,\n\t\t\t\t     NULL);\n\t\twps_registrar_set_selected_timeout(reg, NULL);\n\t\treturn 0;\n\t}\n\n\treg->selected_registrar = 1;\n\treg->sel_reg_dev_password_id_override = attr.dev_password_id ?\n\t\tWPA_GET_BE16(attr.dev_password_id) : DEV_PW_DEFAULT;\n\treg->sel_reg_config_methods_override = attr.sel_reg_config_methods ?\n\t\tWPA_GET_BE16(attr.sel_reg_config_methods) : -1;\n\twps_set_ie(reg);\n\n\teloop_cancel_timeout(wps_registrar_set_selected_timeout, reg, NULL);\n\teloop_register_timeout(WPS_PBC_WALK_TIME, 0,\n\t\t\t       wps_registrar_set_selected_timeout,\n\t\t\t       reg, NULL);\n\treturn 0;\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\wps\\wps_registrar.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/**\n * milenage_generate - Generate AKA AUTN,IK,CK,RES\n * @opc: OPc = 128-bit operator variant algorithm configuration field (encr.)\n * @amf: AMF = 16-bit authentication management field\n * @k: K = 128-bit subscriber key\n * @sqn: SQN = 48-bit sequence number\n * @_rand: RAND = 128-bit random challenge\n * @autn: Buffer for AUTN = 128-bit authentication token\n * @ik: Buffer for IK = 128-bit integrity key (f4), or %NULL\n * @ck: Buffer for CK = 128-bit confidentiality key (f3), or %NULL\n * @res: Buffer for RES = 64-bit signed response (f2), or %NULL\n * @res_len: Max length for res; set to used length or 0 on failure\n */\n", "func_signal": "void milenage_generate(const u8 *opc, const u8 *amf, const u8 *k,\n\t\t       const u8 *sqn, const u8 *_rand, u8 *autn, u8 *ik,\n\t\t       u8 *ck, u8 *res, size_t *res_len)", "code": "{\n\tint i;\n\tu8 mac_a[8], ak[6];\n\n\tif (*res_len < 8) {\n\t\t*res_len = 0;\n\t\treturn;\n\t}\n\tif (milenage_f1(opc, k, _rand, sqn, amf, mac_a, NULL) ||\n\t    milenage_f2345(opc, k, _rand, res, ck, ik, ak, NULL)) {\n\t\t*res_len = 0;\n\t\treturn;\n\t}\n\t*res_len = 8;\n\n\t/* AUTN = (SQN ^ AK) || AMF || MAC */\n\tfor (i = 0; i < 6; i++)\n\t\tautn[i] = sqn[i] ^ ak[i];\n\tos_memcpy(autn + 6, amf, 2);\n\tos_memcpy(autn + 8, mac_a, 8);\n}", "path": "src\\third_party\\hostapd\\hostapd-0.6.9\\src\\hlr_auc_gw\\milenage.c", "repo_name": "JackDanger/chromiumos", "stars": 16, "license": "None", "language": "c", "size": 167309}
{"docstring": "/* yuck, just for the parser anyway.. */\n", "func_signal": "int ffsb_stats_str2syscall(char *str, syscall_t *sys)", "code": "{\n\tint i;\n\tint ret;\n\tfor (i = 0; i < FFSB_NUM_SYSCALLS; i++) {\n\t\tret = strncasecmp(syscall_names[i], str,\n\t\t\t\t  strlen(syscall_names[i]));\n\t\t/* printf(\"%s = syscall_names[%d] vs %str ret = %d\\n\",\n\t\t * syscall_names[i],i,str,ret);\n\t\t */\n\t\tif (0 == ret) {\n\t\t\t*sys = (syscall_t)i; /* ewww */\n\t\t\t/* printf(\"matched syscall %s\\n\",syscall_names[i]); */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tprintf(\"warning: failed to get match for syscall %s\\n\", str);\n\treturn 0;\n}", "path": "ffsb_stats.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Insert an object into the rb-tree */\n", "func_signal": "rb_node *rbtree_insert(rb_tree *tree, datatype object)", "code": "{\n\trb_node *cur_node;\n\trb_node *new_node;\n\tint comp_result = 0;\n\n\tif (!(tree->root)) {\n\t\t/* Assign a new root node (the root is always\n\t\t * black)\n\t\t */\n\t\tnew_node = rbnode_construct(object, black);\n\t\tif (!new_node)\n\t\t\treturn NULL;\n\t\ttree->root = new_node;\n\t\ttree->isize = 1;\n\t\treturn new_node;\n\t}\n\n\t/* Find a spot for the new object, insert the object as a red\n\t * leaf\n\t */\n\n\tcur_node = tree->root;\n\tnew_node = rbnode_construct(object, red);\n\tif (!new_node)\n\t\treturn NULL;\n\n\twhile (cur_node) {\n\t\t/* Compare inserted object with the object stored in\n\t\t * the current node\n\t\t */\n\t\tcomp_result = COMP_NODES(object, cur_node->object);\n\t\tif (comp_result == 0) {\n\t\t\tprintf(\"Attempted to insert duplicate node, aborting\\n\");\n\t\t\tfree(new_node);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (comp_result > 0) {\n\t\t\tif (!(cur_node->left)) {\n\t\t\t\t/* Insert the new leaf as the left\n\t\t\t\t * child of the current node\n\t\t\t\t */\n\t\t\t\tcur_node->left = new_node;\n\t\t\t\tnew_node->parent = cur_node;\n\t\t\t\tcur_node = NULL; /* Terminate the while loop */\n\t\t\t} else {\n\t\t\t\t /* Go to the left subtree */\n\t\t\t\tcur_node = cur_node->left;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(cur_node->right)) {\n\t\t\t\t/* Insert the new leaf as the right\n\t\t\t\t * child of the current node\n\t\t\t\t */\n\t\t\t\tcur_node->right = new_node;\n\t\t\t\tnew_node->parent = cur_node;\n\t\t\t\tcur_node = NULL; /* Terminate the while loop */\n\t\t\t} else {\n\t\t\t\t/* Go to the right subtree */\n\t\t\t\tcur_node = cur_node->right;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark the fact that a new node was added */\n\ttree->isize++;\n\n\t/* Fix the tree properties */\n\trbtree_insert_fixup(tree, new_node);\n\n\treturn new_node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* returns 32 random bits */\n", "func_signal": "static uint32_t genrand32(randdata_t *state)", "code": "{\n\tuint8_t bytes[4];\n\tuint32_t ret = 0;\n\n\tbytes[0] = genrand8(state);\n\tbytes[1] = genrand8(state);\n\tbytes[2] = genrand8(state);\n\tbytes[3] = genrand8(state);\n\n\tret = *((uint32_t *)bytes); /* !!! hack */\n\treturn ret;\n}", "path": "rand.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Return a pointer to a duplication of the given node */\n", "func_signal": "rb_node *rbnode_duplicate(rb_node *node)", "code": "{\n\t/* Create a node of the same color, containing the same\n\t * object\n\t */\n\trb_node *dup_node = rbnode_construct(node->object, node->color);\n\tif (!dup_node)\n\t\treturn NULL;\n\n\t/* Duplicate the children recursively */\n\tif (node->right) {\n\t\tdup_node->right = rbnode_duplicate(node->right);\n\t\tdup_node->right->parent = dup_node;\n\t} else {\n\t\tdup_node->right = NULL;\n\t}\n\n\tif (node->left) {\n\t\tdup_node->left = rbnode_duplicate(node->left);\n\t\tdup_node->left->parent = dup_node;\n\t} else {\n\t\tdup_node->left = NULL;\n\t}\n\n\treturn dup_node; /* Return the duplicated node */\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* not perfect, in case we are somehow interrupted it's borked */\n", "func_signal": "void ffsb_sleep(unsigned secs)", "code": "{\n\tstruct timeval tv = { 0 , 0 };\n\ttv.tv_sec = secs;\n\tselect(0, NULL, NULL, NULL, &tv);\n}", "path": "util.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Insert a new object to the tree as the a predecessor of a given node */\n", "func_signal": "rb_node *insert_predecessor_at(rb_tree *tree, rb_node *at_node, datatype object)", "code": "{\n\trb_node *parent;\n\trb_node *new_node;\n\n\tif (!(tree->root)) {\n\t\t/* Assign a new root node (the root is always\n\t\t * black)\n\t\t */\n\t\tnew_node = rbnode_construct(object, black);\n\t\tif (!new_node)\n\t\t\treturn NULL;\n\t\ttree->root = new_node;\n\t\ttree->isize = 1;\n\t\treturn new_node;\n\t}\n\n\t/* Insert the new object as a red leaf, being the predecessor\n\t * of at_node\n\t */\n\tnew_node = rbnode_construct(object, red);\n\tif (!new_node)\n\t\treturn NULL;\n\n\tif (!at_node) {\n\t\t/* The new node should become the tree maximum. Place\n\t\t * is as the right child of the current maximal leaf\n\t\t */\n\t\tparent = rbnode_maximum(tree->root);\n\t\tparent->right = new_node;\n\t} else {\n\t\t/* Make sure the insertion does not violate the tree\n\t\t * order In case given node has no left child, place\n\t\t * the new node as its left child. Otherwise, place it\n\t\t * at the rightmost position at the sub-tree rooted at\n\t\t * its left side.\n\t\t */\n\t\tif (!(at_node->left)) {\n\t\t\tparent = at_node;\n\t\t\tparent->left = new_node;\n\t\t} else {\n\t\t\tparent = rbnode_maximum(at_node->left);\n\t\t\tparent->right = new_node;\n\t\t}\n\t}\n\n\tnew_node->parent = parent;\n\n\t/* Mark that a new node was added */\n\ttree->isize++;\n\n\t/* Fix the tree properties */\n\trbtree_insert_fixup(tree, new_node);\n\n\treturn new_node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Traverse a red-black subtree */\n", "func_signal": "void rbnode_traverse(rb_node *node, opr *op)", "code": "{\n\tif (!node)\n\t\treturn;\n\trbnode_traverse(node->left, op);\n\top(node->object);\n\trbnode_traverse(node->right, op);\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Return the leftmost leaf in the tree */\n", "func_signal": "rb_node *rbnode_minimum(rb_node *node)", "code": "{\n\twhile (node->left)\n\t\tnode = node->left;\n\treturn node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* We fill up the array with random bits from RANDSRC here and set index */\n/* to 0 */\n/* pre: state->size must be set and state->mt must be allocated! */\n", "func_signal": "static void sgenrand(randdata_t *state)", "code": "{\n\tint got = 0;\n\tgot = read(randfd, state->mt, state->size);\n\tif (got != state->size) {\n\t\tint i ;\n\t\t/* fall back on lrand48 */\n\t\t/* printf(\"fallback_rand\\n\"); */\n\n\t\tfor (i = got ; i < state->size ; i += 4) {\n\t\t\tlong int  rand = 0;\n#ifdef HAVE_LRAND48\n\t\t\tlrand48_r(&(state->data), &rand);\n#else\n\t\t\trand = random();\n#endif\n\t\t\tassert(rand != 0);\n\t\t\tstate->mt[i]   = (rand >> 24) & (512 - 1);\n\t\t\tstate->mt[i+1] = (rand >> 16) & (512 - 1);\n\t\t\tstate->mt[i+2] = (rand >>  8) & (512 - 1);\n\t\t\tstate->mt[i+3] = (rand) & (512 - 1);\n\t\t}\n\n\t}\n\tstate->mti = 0;\n}", "path": "rand.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Fix the tree so it maintains the red-black properties after an insert */\n", "func_signal": "void rbtree_insert_fixup(rb_tree *tree, rb_node *node)", "code": "{\n\t/* Fix the red-black propreties. We may have inserted a red\n\t * leaf as the child of a red parent - so we have to fix the\n\t * coloring of the parent recursively.\n\t */\n\trb_node *curr_node = node;\n\trb_node *grandparent;\n\trb_node *uncle;\n\n\tassert(node && node->color == red);\n\n\twhile (curr_node != tree->root && curr_node->parent->color == red) {\n\t\t/* Get a pointer to the current node's grandparent\n\t\t * (the root is always black, so the red parent must\n\t\t * have a parent).\n\t\t */\n\n\t\tgrandparent = curr_node->parent->parent;\n\n\t\tif (curr_node->parent == grandparent->left) {\n\t\t\t/* If the red parent is a left child, the\n\t\t\t* uncle is the right child of the grandparent.\n\t\t\t*/\n\t\t\tuncle = grandparent->right;\n\n\t\t\tif (uncle && uncle->color == red) {\n\n\t\t\t\t/* If both parent and uncle are red,\n\t\t\t\t * color them black and color the\n\t\t\t\t * grandparent red. In case of a NULL\n\t\t\t\t * uncle, treat it as a black node\n\t\t\t\t */\n\t\t\t\tcurr_node->parent->color = black;\n\t\t\t\tuncle->color = black;\n\t\t\t\tgrandparent->color = red;\n\n\t\t\t\t/* Move to the grandparent */\n\t\t\t\tcurr_node = grandparent;\n\t\t\t} else {\n\t\t\t\t/* Make sure the current node is a\n\t\t\t\t* right child. If not, left-rotate the\n\t\t\t\t* parent's sub-tree so the parent\n\t\t\t\t* becomes the right child of the\n\t\t\t\t* current node (see _rotate_left).\n\t\t\t\t*/\n\t\t\t\tif (curr_node == curr_node->parent->right) {\n\t\t\t\t\tcurr_node = curr_node->parent;\n\t\t\t\t\trbtree_rotate_left(tree, curr_node);\n\t\t\t\t}\n\n\t\t\t\t/* Color the parent black and the\n\t\t\t\t * grandparent red\n\t\t\t\t */\n\t\t\t\tcurr_node->parent->color = black;\n\t\t\t\tgrandparent->color = red;\n\n\t\t\t\t/* Right-rotate the grandparent's\n\t\t\t\t * sub-tree\n\t\t\t\t */\n\t\t\t\trbtree_rotate_right(tree, grandparent);\n\t\t\t}\n\t\t} else {\n\t\t\t/* If the red parent is a right child, the\n\t\t\t * uncle is the left child of the grandparent.\n\t\t\t */\n\t\t\tuncle = grandparent->left;\n\n\t\t\tif (uncle && uncle->color == red) {\n\t\t\t\t/* If both parent and uncle are red,\n\t\t\t\t * color them black and color the\n\t\t\t\t * grandparent red. In case of a NULL\n\t\t\t\t * uncle, treat it as a black node\n\t\t\t\t */\n\t\t\t\tcurr_node->parent->color = black;\n\t\t\t\tuncle->color = black;\n\t\t\t\tgrandparent->color = red;\n\n\t\t\t\t/* Move to the grandparent */\n\t\t\t\tcurr_node = grandparent;\n\t\t\t} else {\n\t\t\t\t/* Make sure the current node is a\n\t\t\t\t * left child. If not, right-rotate\n\t\t\t\t * the parent's sub-tree so the parent\n\t\t\t\t * becomes the left child of the\n\t\t\t\t * current node.\n\t\t\t\t*/\n\t\t\t\tif (curr_node == curr_node->parent->left) {\n\t\t\t\t\tcurr_node = curr_node->parent;\n\t\t\t\t\trbtree_rotate_right(tree, curr_node);\n\t\t\t\t}\n\n\t\t\t\t/* Color the parent black and the\n\t\t\t\t * grandparent red\n\t\t\t\t */\n\t\t\t\tcurr_node->parent->color = black;\n\t\t\t\tgrandparent->color = red;\n\n\t\t\t\t/* Left-rotate the grandparent's\n\t\t\t\t * sub-tree\n\t\t\t\t */\n\t\t\t\trbtree_rotate_left(tree, grandparent);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make sure that the root is black */\n\ttree->root->color = black;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Right-rotate the sub-tree spanned by the given node */\n", "func_signal": "void rbtree_rotate_right(rb_tree *tree, rb_node *y_node)", "code": "{\n\t/* Get the left child of the node */\n\trb_node *x_node = y_node->left;\n\n\t/* Change its right subtree (T2) to y's left subtree */\n\ty_node->left = x_node->right;\n\n\t/* Link T2 to its new parent y */\n\tif (x_node->right != NULL)\n\t\tx_node->right->parent = y_node;\n\n\t/* Assign y's parent to be x's parent */\n\tx_node->parent = y_node->parent;\n\n\tif (!(y_node->parent)) {\n\t\t/* Make x the new tree root */\n\t\ttree->root = x_node;\n\t} else  {\n\t\t/* Assign a pointer to x from y's parent */\n\t\tif (y_node == y_node->parent->left)\n\t\t\ty_node->parent->left = x_node;\n\t\telse\n\t\t\ty_node->parent->right = x_node;\n\t}\n\n\t/* Assign y to be x's right child */\n\tx_node->right = y_node;\n\ty_node->parent = x_node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Returns the depth of the tree */\n", "func_signal": "int rbtree_depth(rb_tree *tree)", "code": "{\n\tif (!(tree->root))\n\t\treturn 0;\n\treturn rbnode_depth(tree->root);\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Do all the dirty work of recursing through a directory structure\n * check everything for validitiy and update everything properly.\n * Note it does not check filesizes !!!, it doesn't know anything\n * about them\n */\n", "func_signal": "static int add_dir_to_filelist(struct benchfiles *bf, DIR *subdir,\n\t\t\t       char *subdir_path, fl_validation_func_t vfunc,\n\t\t\t       void *vf_data)", "code": "{\n\tint retval = 0;\n\tstruct dirent *d_ent = NULL;\n\n\twhile ((d_ent = readdir(subdir)) != NULL) {\n\t\tDIR *tmp = NULL;\n\t\tchar filename_buf[FILENAME_MAX*2];\n\n\t\tif (FILENAME_MAX < snprintf(filename_buf, FILENAME_MAX, \"%s/%s\",\n\t\t\t\t\t    subdir_path, d_ent->d_name)) {\n\t\t\tprintf(\"filename \\\"%s\\\" too long aborting\\n\",\n\t\t\t       filename_buf);\n\t\t\treturn -1;\n\t\t}\n\t\ttmp = opendir(filename_buf);\n\t\tif (tmp == NULL) {\n\t\t\tstruct ffsb_file *ffsb_file = NULL;\n\n\t\t\tif (validate_filename(bf, d_ent->d_name) < 0) {\n\t\t\t\tprintf(\"filename \\\"%s\\\" is invalid aborting\\n\",\n\t\t\t\t       d_ent->d_name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Verify size/other attributes via callback  */\n\t\t\tif (vfunc(bf, filename_buf, vf_data)) {\n\t\t\t\tprintf(\"filename \\\"%s\\\" didn't pass \"\n\t\t\t\t       \"validation\\n\", d_ent->d_name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Add file to data structure */\n\t\t\tffsb_file = add_file_named(bf, ffsb_get_filesize(filename_buf),\n\t\t\t\t       filename_buf);\n\t\t\tunlock_file_writer(ffsb_file);\n\t\t} else {\n\t\t\t/* Check for the usual suspects and skip them */\n\t\t\tif ((0 == strcmp(\".\", d_ent->d_name)) ||\n\t\t\t    (0 == strcmp(\"..\", d_ent->d_name))) {\n\t\t\t\tclosedir(tmp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (validate_dirname(bf, d_ent->d_name) < 0) {\n\t\t\t\tprintf(\"dirname \\\"%s\\\" is invalid aborting\\n\",\n\t\t\t\t       d_ent->d_name);\n\t\t\t\tclosedir(tmp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (vfunc(bf, filename_buf, vf_data)) {\n\t\t\t\tprintf(\"dir \\\"%s\\\" didn't pass validation\\n\",\n\t\t\t\t       d_ent->d_name);\n\t\t\t\tclosedir(tmp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Update filelist */\n\t\t\tbf->numsubdirs++;\n\n\t\t\t/* recurse */\n\t\t\tretval += add_dir_to_filelist(bf, tmp, filename_buf,\n\t\t\t\t\t\t      vfunc, vf_data);\n\n\t\t\t/* clean up */\n\t\t\tclosedir(tmp);\n\t\t}\n\t}\n\treturn retval;\n}", "path": "filelist.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Testing */\n", "func_signal": "void *ffsb_malloc(size_t s)", "code": "{\n\tvoid *p = malloc(s);\n\tassert(p != NULL);\n\treturn p;\n}", "path": "ffsb_stats.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* !!!! check portability */\n", "func_signal": "float getfsutil(char *dirname)", "code": "{\n\tstruct statvfs64 fsdata;\n\n\tstatvfs64(dirname, &fsdata);\n\n/* \treturn (float)(fsdata.f_blocks-fsdata.f_bfree)/ */\n/* \t\t(float)(fsdata.f_blocks-fsdata.f_bfree+fsdata.f_bavail); */\n\treturn (float) (((float)(fsdata.f_blocks - fsdata.f_bfree)) /\n\t\t\t((float)fsdata.f_blocks));\n}", "path": "util.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/*\n * I've taken the liberty of slightly redesigning this stuff.\n * Instead of simply getting the full word of random bits\n * and throwing away most of it using the mod operator,\n * we should only get byte-sized chunks of random bits and\n * construct our random number that way with less wasteage - SR\n */\n", "func_signal": "uint32_t getrandom(randdata_t *state, uint32_t mod)", "code": "{\n\n    uint8_t bytes[4] = { 0, 0, 0, 0 };\n    uint32_t ret;\n    int num_bytes = 4;\n    int i;\n\n    if ((mod == 0) || (mod == 1))\n\t    return 0;\n\n    if (!(mod >> 8))\n\t    num_bytes = 1;\n    else if (!(mod >> 16))\n\t    num_bytes = 2;\n    else if (!(mod >> 24))\n\t    num_bytes = 3;\n\n    for (i = 0; i < num_bytes; i++)\n\t    bytes[i] = genrand8(state);\n\n    ret = (bytes[3] << 24) + (bytes[2] << 16) + (bytes[1] << 8) + bytes[0];\n\n    return ret % mod;\n}", "path": "rand.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Construct a red-black tree node */\n", "func_signal": "rb_node *rbnode_construct(datatype object, rb_color color)", "code": "{\n\trb_node *node = (rb_node *) malloc(sizeof(rb_node));\n\tif (!node) {\n\t\tfprintf(stderr, \"Memory Shortage - No Execution Possible\\n\");\n\t\treturn NULL;\n\t}\n\tnode->object = object;\n\tnode->color = color;\n\tnode->parent = node->right = node->left = NULL;\n\treturn node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Determine the depth of the subtree spanned by a given node */\n", "func_signal": "int rbnode_depth(rb_node *node)", "code": "{\n\t/* Recursively determine the depth of the left and right\n\t * subtrees\n\t */\n\tint  irightdepth = (node->right) ? rbnode_depth(node->right) : 0;\n\tint  ileftdepth = (node->left) ? rbnode_depth(node->left) : 0;\n\n\t/* Return the maximal child depth + 1 (the current node) */\n\treturn ((irightdepth > ileftdepth) ? (irightdepth + 1) : (ileftdepth + 1));\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Remove the object pointed by the given node. */\n", "func_signal": "void rbtree_remove_at(rb_tree *tree, rb_node *node, destructor d)", "code": "{\n\trb_node *child = NULL;\n\n\t/* In case of deleting the single object stored in the tree,\n\t * free the root, thus emptying the tree\n\t */\n\tif (tree->isize == 1) {\n\t\trbnode_destruct(tree->root, d);\n\t\ttree->root = NULL;\n\t\ttree->isize = 0;\n\t\treturn;\n\t}\n\n\t/* Remove the given node from the tree */\n\tif (node->left && node->right) {\n\t\t/* If the node we want to remove has two children,\n\t\t * find its successor, which is the leftmost child in\n\t\t * its right sub-tree and has at most one child (it\n\t\t * may have a right child).\n\t\t */\n\t\trb_node *succ_node = rbnode_minimum(node->right);\n\n\t\t/* Now physically swap node and its successor. Notice\n\t\t * this may temporarily violate the tree properties,\n\t\t * but we are going to remove node anyway.  This way\n\t\t * we have moved node to a position were it is more\n\t\t * convinient to delete it.\n\t\t */\n\t\tint immediate_succ = (node->right == succ_node);\n\t\trb_node *succ_parent = succ_node->parent;\n\t\trb_node *succ_left = succ_node->left;\n\t\trb_node *succ_right = succ_node->right;\n\t\trb_color succ_color = succ_node->color;\n\n\t\tsucc_node->parent = node->parent;\n\t\tsucc_node->left = node->left;\n\t\tsucc_node->right = immediate_succ ? node : node->right;\n\t\tsucc_node->color = node->color;\n\n\t\tnode->parent = immediate_succ ? succ_node : succ_parent;\n\t\tnode->left = succ_left;\n\t\tnode->right = succ_right;\n\t\tnode->color = succ_color;\n\n\t\tif (!immediate_succ) {\n\t\t\tif (succ_node == node->parent->left)\n\t\t\t\tnode->parent->left = node;\n\t\t\telse\n\t\t\t\tnode->parent->right = node;\n\t\t}\n\n\t\tif (node->left)\n\t\t\tnode->left->parent = node;\n\t\tif (node->right)\n\t\t\tnode->right->parent = node;\n\n\t\tif (succ_node->parent) {\n\t\t\tif (node == succ_node->parent->left)\n\t\t\t\tsucc_node->parent->left = succ_node;\n\t\t\telse\n\t\t\t\tsucc_node->parent->right = succ_node;\n\t\t} else {\n\t\t\ttree->root = succ_node;\n\t\t}\n\n\t\tif (succ_node->left)\n\t\t\tsucc_node->left->parent = succ_node;\n\t\tif (succ_node->right)\n\t\t\tsucc_node->right->parent = succ_node;\n\t}\n\n\t/* At this stage, the node we are going to remove has at most\n\t * one child\n\t */\n\tchild = (node->left) ? node->left : node->right;\n\n\t/* Splice out the node to be removed, by linking its parent\n\t * straight to the removed node's single child.\n\t */\n\tif (child)\n\t\tchild->parent = node->parent;\n\n\tif (!(node->parent)) {\n\t\t/* If we are deleting the root, make the child the new\n\t\t * tree node\n\t\t */\n\t\ttree->root = child;\n\t} else {\n\t\t/* Link the removed node parent to its child */\n\t\tif (node == node->parent->left)\n\t\t\tnode->parent->left = child;\n\t\telse\n\t\t\tnode->parent->right = child;\n\t}\n\n\t/* Fix-up the red-black properties that may have been damaged:\n\t * If we have just removed a black node, the black-depth\n\t * property is no longer valid\n\t */\n\tif (node->color == black && child)\n\t\trbtree_remove_fixup(tree, child);\n\n\t/* Delete the un-necessary node (nullify both its children\n\t * because the node's destructor is recursive).\n\t */\n\tnode->left = NULL;\n\tnode->right = NULL;\n\tfree(node);\n\n\t/* Decrease the number of objects in the tree */\n\ttree->isize--;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/* Insert a new object to the tree as the a successor of a given\n * node\n */\n", "func_signal": "rb_node *insert_successor_at(rb_tree *tree, rb_node *at_node, datatype object)", "code": "{\n\trb_node *parent;\n\trb_node *new_node;\n\n\tif (!(tree->root)) {\n\t\t/* Assign a new root node (the root is always\n\t\t * black)\n\t\t */\n\t\tnew_node = rbnode_construct(object, black);\n\t\tif (!new_node)\n\t\t\treturn NULL;\n\t\ttree->root = new_node;\n\t\ttree->isize = 1;\n\t\treturn new_node;\n\t}\n\n\t/* Insert the new object as a red leaf, being the successor of\n\t * node\n\t */\n\tnew_node = rbnode_construct(object, red);\n\tif (!new_node)\n\t\treturn NULL;\n\n\tif (!at_node) {\n\t\t/* The new node should become the tree's minimum Place\n\t\t * is as the left child of the current minimal leaf\n\t\t*/\n\t\tparent = rbnode_minimum(tree->root);\n\t\tparent->left = new_node;\n\t} else {\n\t\t/* Make sure the insertion does not violate the tree\n\t\t * order In case given node has no right child, place\n\t\t * the new node as its right child. Otherwise, place\n\t\t * it at the leftmost position at the sub-tree rooted\n\t\t * at its right side.\n\t\t */\n\t\tif (!at_node->right) {\n\t\t\tparent = at_node;\n\t\t\tparent->right = new_node;\n\t\t} else {\n\t\t\tparent = rbnode_minimum(at_node->right);\n\t\t\tparent->left = new_node;\n\t\t}\n\t}\n\n\tnew_node->parent = parent;\n\n\t/* Mark that a new node was added */\n\ttree->isize++;\n\n\t/* Fix the tree properties */\n\trbtree_insert_fixup(tree, new_node);\n\n\treturn new_node;\n}", "path": "rbt.c", "repo_name": "FFSB-Prime/ffsb", "stars": 17, "license": "other", "language": "c", "size": 269}
{"docstring": "/*\n * Expect ALIAS.\n */\n", "func_signal": "static int\nyaml_emitter_emit_alias(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    emitter->state = POP(emitter, emitter->states);\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Write a tag.\n */\n", "func_signal": "static int\nyaml_emitter_process_tag(yaml_emitter_t *emitter)", "code": "{\n    if (!emitter->tag_data.handle && !emitter->tag_data.suffix)\n        return 1;\n\n    if (emitter->tag_data.handle)\n    {\n        if (!yaml_emitter_write_tag_handle(emitter, emitter->tag_data.handle,\n                    emitter->tag_data.handle_length))\n            return 0;\n        if (emitter->tag_data.suffix) {\n            if (!yaml_emitter_write_tag_content(emitter, emitter->tag_data.suffix,\n                        emitter->tag_data.suffix_length, 0))\n                return 0;\n        }\n    }\n    else\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"!<\", 1, 0, 0))\n            return 0;\n        if (!yaml_emitter_write_tag_content(emitter, emitter->tag_data.suffix,\n                    emitter->tag_data.suffix_length, 0))\n            return 0;\n        if (!yaml_emitter_write_indicator(emitter, \">\", 0, 0, 0))\n            return 0;\n    }\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Check if an anchor is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_anchor(yaml_emitter_t *emitter,\n        yaml_char_t *anchor, int alias)", "code": "{\n    size_t anchor_length;\n    yaml_string_t string;\n    \n    anchor_length = strlen((char *)anchor);\n    STRING_ASSIGN(string, anchor, anchor_length);\n\n    if (string.start == string.end) {\n        return yaml_emitter_set_emitter_error(emitter, alias ?\n                \"alias value must not be empty\" :\n                \"anchor value must not be empty\");\n    }\n\n    while (string.pointer != string.end) {\n        if (!IS_ALPHA(string)) {\n            return yaml_emitter_set_emitter_error(emitter, alias ?\n                    \"alias value must contain alphanumerical characters only\" :\n                    \"anchor value must contain alphanumerical characters only\");\n        }\n        MOVE(string);\n    }\n\n    emitter->anchor_data.anchor = string.start;\n    emitter->anchor_data.anchor_length = string.end - string.start;\n    emitter->anchor_data.alias = alias;\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect DOCUMENT-END.\n */\n", "func_signal": "static int\nyaml_emitter_emit_document_end(yaml_emitter_t *emitter,\n        yaml_event_t *event)", "code": "{\n    if (event->type == YAML_DOCUMENT_END_EVENT)\n    {\n        if (!yaml_emitter_write_indent(emitter))\n            return 0;\n        if (!event->data.document_end.implicit) {\n            if (!yaml_emitter_write_indicator(emitter, \"...\", 1, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_flush(emitter))\n            return 0;\n\n        emitter->state = YAML_EMIT_DOCUMENT_START_STATE;\n\n        while (!STACK_EMPTY(emitter, emitter->tag_directives)) {\n            yaml_tag_directive_t tag_directive = POP(emitter,\n                    emitter->tag_directives);\n            yaml_free(tag_directive.handle);\n            yaml_free(tag_directive.prefix);\n        }\n\n        return 1;\n    }\n\n    return yaml_emitter_set_emitter_error(emitter,\n            \"expected DOCUMENT-END\");\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect MAPPING-START.\n */\n", "func_signal": "static int\nyaml_emitter_emit_mapping_start(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n\n    if (emitter->flow_level || emitter->canonical\n            || event->data.mapping_start.style == YAML_FLOW_MAPPING_STYLE\n            || yaml_emitter_check_empty_mapping(emitter)) {\n        emitter->state = YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE;\n    }\n    else {\n        emitter->state = YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE;\n    }\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * State dispatcher.\n */\n", "func_signal": "static int\nyaml_emitter_state_machine(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    switch (emitter->state)\n    {\n        case YAML_EMIT_STREAM_START_STATE:\n            return yaml_emitter_emit_stream_start(emitter, event);\n\n        case YAML_EMIT_FIRST_DOCUMENT_START_STATE:\n            return yaml_emitter_emit_document_start(emitter, event, 1);\n\n        case YAML_EMIT_DOCUMENT_START_STATE:\n            return yaml_emitter_emit_document_start(emitter, event, 0);\n\n        case YAML_EMIT_DOCUMENT_CONTENT_STATE:\n            return yaml_emitter_emit_document_content(emitter, event);\n\n        case YAML_EMIT_DOCUMENT_END_STATE:\n            return yaml_emitter_emit_document_end(emitter, event);\n\n        case YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:\n            return yaml_emitter_emit_flow_sequence_item(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE:\n            return yaml_emitter_emit_flow_sequence_item(emitter, event, 0);\n\n        case YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:\n            return yaml_emitter_emit_flow_mapping_key(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_MAPPING_KEY_STATE:\n            return yaml_emitter_emit_flow_mapping_key(emitter, event, 0);\n\n        case YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:\n            return yaml_emitter_emit_flow_mapping_value(emitter, event, 1);\n\n        case YAML_EMIT_FLOW_MAPPING_VALUE_STATE:\n            return yaml_emitter_emit_flow_mapping_value(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:\n            return yaml_emitter_emit_block_sequence_item(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE:\n            return yaml_emitter_emit_block_sequence_item(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:\n            return yaml_emitter_emit_block_mapping_key(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_MAPPING_KEY_STATE:\n            return yaml_emitter_emit_block_mapping_key(emitter, event, 0);\n\n        case YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:\n            return yaml_emitter_emit_block_mapping_value(emitter, event, 1);\n\n        case YAML_EMIT_BLOCK_MAPPING_VALUE_STATE:\n            return yaml_emitter_emit_block_mapping_value(emitter, event, 0);\n\n        case YAML_EMIT_END_STATE:\n            return yaml_emitter_set_emitter_error(emitter,\n                    \"expected nothing after STREAM-END\");\n\n        default:\n            assert(1);      /* Invalid state. */\n    }\n\n    return 0;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Determine an acceptable scalar style.\n */\n", "func_signal": "static int\nyaml_emitter_select_scalar_style(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    yaml_scalar_style_t style = event->data.scalar.style;\n    int no_tag = (!emitter->tag_data.handle && !emitter->tag_data.suffix);\n\n    if (no_tag && !event->data.scalar.plain_implicit\n            && !event->data.scalar.quoted_implicit) {\n        return yaml_emitter_set_emitter_error(emitter,\n                \"neither tag nor implicit flags are specified\");\n    }\n\n    if (style == YAML_ANY_SCALAR_STYLE)\n        style = YAML_PLAIN_SCALAR_STYLE;\n\n    if (emitter->canonical)\n        style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;\n\n    if (emitter->simple_key_context && emitter->scalar_data.multiline)\n        style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;\n\n    if (style == YAML_PLAIN_SCALAR_STYLE)\n    {\n        if ((emitter->flow_level && !emitter->scalar_data.flow_plain_allowed)\n                || (!emitter->flow_level && !emitter->scalar_data.block_plain_allowed))\n            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;\n        if (!emitter->scalar_data.length\n                && (emitter->flow_level || emitter->simple_key_context))\n            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;\n        if (no_tag && !event->data.scalar.plain_implicit)\n            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;\n    }\n\n    if (style == YAML_SINGLE_QUOTED_SCALAR_STYLE)\n    {\n        if (!emitter->scalar_data.single_quoted_allowed)\n            style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;\n    }\n\n    if (style == YAML_LITERAL_SCALAR_STYLE || style == YAML_FOLDED_SCALAR_STYLE)\n    {\n        if (!emitter->scalar_data.block_allowed\n                || emitter->flow_level || emitter->simple_key_context)\n            style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;\n    }\n\n    if (no_tag && !event->data.scalar.quoted_implicit\n            && style != YAML_PLAIN_SCALAR_STYLE)\n    {\n        emitter->tag_data.handle = (yaml_char_t *)\"!\";\n        emitter->tag_data.handle_length = 1;\n    }\n\n    emitter->scalar_data.style = style;\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect a block key node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_block_mapping_key(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (first)\n    {\n        if (!yaml_emitter_increase_indent(emitter, 0, 0))\n            return 0;\n    }\n\n    if (event->type == YAML_MAPPING_END_EVENT)\n    {\n        emitter->indent = POP(emitter, emitter->indents);\n        emitter->state = POP(emitter, emitter->states);\n\n        return 1;\n    }\n\n    if (!yaml_emitter_write_indent(emitter))\n        return 0;\n\n    if (yaml_emitter_check_simple_key(emitter))\n    {\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 1);\n    }\n    else\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"?\", 1, 0, 1))\n            return 0;\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_BLOCK_MAPPING_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n    }\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect a flow value node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_flow_mapping_value(yaml_emitter_t *emitter,\n        yaml_event_t *event, int simple)", "code": "{\n    if (simple) {\n        if (!yaml_emitter_write_indicator(emitter, \":\", 0, 0, 0))\n            return 0;\n    }\n    else {\n        if (emitter->canonical || emitter->column > emitter->best_width) {\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_write_indicator(emitter, \":\", 1, 0, 0))\n            return 0;\n    }\n    if (!PUSH(emitter, emitter->states, YAML_EMIT_FLOW_MAPPING_KEY_STATE))\n        return 0;\n    return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * \n * Expect a flow item node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_flow_sequence_item(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (first)\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"[\", 1, 1, 0))\n            return 0;\n        if (!yaml_emitter_increase_indent(emitter, 1, 0))\n            return 0;\n        emitter->flow_level ++;\n    }\n\n    if (event->type == YAML_SEQUENCE_END_EVENT)\n    {\n        emitter->flow_level --;\n        emitter->indent = POP(emitter, emitter->indents);\n        if (emitter->canonical && !first) {\n            if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_write_indicator(emitter, \"]\", 0, 0, 0))\n            return 0;\n        emitter->state = POP(emitter, emitter->states);\n\n        return 1;\n    }\n\n    if (!first) {\n        if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n            return 0;\n    }\n\n    if (emitter->canonical || emitter->column > emitter->best_width) {\n        if (!yaml_emitter_write_indent(emitter))\n            return 0;\n    }\n    if (!PUSH(emitter, emitter->states, YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE))\n        return 0;\n\n    return yaml_emitter_emit_node(emitter, event, 0, 1, 0, 0);\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Check if a %TAG directive is valid.\n */\n", "func_signal": "static int\nyaml_emitter_analyze_tag_directive(yaml_emitter_t *emitter,\n        yaml_tag_directive_t tag_directive)", "code": "{\n    yaml_string_t handle;\n    yaml_string_t prefix;\n    size_t handle_length;\n    size_t prefix_length;\n\n    handle_length = strlen((char *)tag_directive.handle);\n    prefix_length = strlen((char *)tag_directive.prefix);\n    STRING_ASSIGN(handle, tag_directive.handle, handle_length);\n    STRING_ASSIGN(prefix, tag_directive.prefix, prefix_length);\n\n    if (handle.start == handle.end) {\n        return yaml_emitter_set_emitter_error(emitter,\n                \"tag handle must not be empty\");\n    }\n\n    if (handle.start[0] != '!') {\n        return yaml_emitter_set_emitter_error(emitter,\n                \"tag handle must start with '!'\");\n    }\n\n    if (handle.end[-1] != '!') {\n        return yaml_emitter_set_emitter_error(emitter,\n                \"tag handle must end with '!'\");\n    }\n\n    handle.pointer ++;\n\n    while (handle.pointer < handle.end-1) {\n        if (!IS_ALPHA(handle)) {\n            return yaml_emitter_set_emitter_error(emitter,\n                    \"tag handle must contain alphanumerical characters only\");\n        }\n        MOVE(handle);\n    }\n\n    if (prefix.start == prefix.end) {\n        return yaml_emitter_set_emitter_error(emitter,\n                \"tag prefix must not be empty\");\n    }\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Write an achor.\n */\n", "func_signal": "static int\nyaml_emitter_process_anchor(yaml_emitter_t *emitter)", "code": "{\n    if (!emitter->anchor_data.anchor)\n        return 1;\n\n    if (!yaml_emitter_write_indicator(emitter,\n                (emitter->anchor_data.alias ? \"*\" : \"&\"), 1, 0, 0))\n        return 0;\n\n    return yaml_emitter_write_anchor(emitter,\n            emitter->anchor_data.anchor, emitter->anchor_data.anchor_length);\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect a flow key node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_flow_mapping_key(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (first)\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"{\", 1, 1, 0))\n            return 0;\n        if (!yaml_emitter_increase_indent(emitter, 1, 0))\n            return 0;\n        emitter->flow_level ++;\n    }\n\n    if (event->type == YAML_MAPPING_END_EVENT)\n    {\n        emitter->flow_level --;\n        emitter->indent = POP(emitter, emitter->indents);\n        if (emitter->canonical && !first) {\n            if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n                return 0;\n            if (!yaml_emitter_write_indent(emitter))\n                return 0;\n        }\n        if (!yaml_emitter_write_indicator(emitter, \"}\", 0, 0, 0))\n            return 0;\n        emitter->state = POP(emitter, emitter->states);\n\n        return 1;\n    }\n\n    if (!first) {\n        if (!yaml_emitter_write_indicator(emitter, \",\", 0, 0, 0))\n            return 0;\n    }\n    if (emitter->canonical || emitter->column > emitter->best_width) {\n        if (!yaml_emitter_write_indent(emitter))\n            return 0;\n    }\n\n    if (!emitter->canonical && yaml_emitter_check_simple_key(emitter))\n    {\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 1);\n    }\n    else\n    {\n        if (!yaml_emitter_write_indicator(emitter, \"?\", 1, 0, 0))\n            return 0;\n        if (!PUSH(emitter, emitter->states,\n                    YAML_EMIT_FLOW_MAPPING_VALUE_STATE))\n            return 0;\n\n        return yaml_emitter_emit_node(emitter, event, 0, 0, 1, 0);\n    }\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Check if the next events represent an empty mapping.\n */\n", "func_signal": "static int\nyaml_emitter_check_empty_mapping(yaml_emitter_t *emitter)", "code": "{\n    if (emitter->events.tail - emitter->events.head < 2)\n        return 0;\n\n    return (emitter->events.head[0].type == YAML_MAPPING_START_EVENT\n            && emitter->events.head[1].type == YAML_MAPPING_END_EVENT);\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect a block item node.\n */\n", "func_signal": "static int\nyaml_emitter_emit_block_sequence_item(yaml_emitter_t *emitter,\n        yaml_event_t *event, int first)", "code": "{\n    if (first)\n    {\n        if (!yaml_emitter_increase_indent(emitter, 0,\n                    (emitter->mapping_context && !emitter->indention)))\n            return 0;\n    }\n\n    if (event->type == YAML_SEQUENCE_END_EVENT)\n    {\n        emitter->indent = POP(emitter, emitter->indents);\n        emitter->state = POP(emitter, emitter->states);\n\n        return 1;\n    }\n\n    if (!yaml_emitter_write_indent(emitter))\n        return 0;\n    if (!yaml_emitter_write_indicator(emitter, \"-\", 1, 0, 1))\n        return 0;\n    if (!PUSH(emitter, emitter->states,\n                YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE))\n        return 0;\n\n    return yaml_emitter_emit_node(emitter, event, 0, 1, 0, 0);\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect STREAM-START.\n */\n", "func_signal": "static int\nyaml_emitter_emit_stream_start(yaml_emitter_t *emitter,\n        yaml_event_t *event)", "code": "{\n    if (event->type == YAML_STREAM_START_EVENT)\n    {\n        if (!emitter->encoding) {\n            emitter->encoding = event->data.stream_start.encoding;\n        }\n\n        if (!emitter->encoding) {\n            emitter->encoding = YAML_UTF8_ENCODING;\n        }\n\n        if (emitter->best_indent < 2 || emitter->best_indent > 9) {\n            emitter->best_indent  = 2;\n        }\n\n        if (emitter->best_width >= 0\n                && emitter->best_width <= emitter->best_indent*2) {\n            emitter->best_width = 80;\n        }\n\n        if (emitter->best_width < 0) {\n            emitter->best_width = INT_MAX;\n        }\n        \n        if (!emitter->line_break) {\n            emitter->line_break = YAML_LN_BREAK;\n        }\n\n        emitter->indent = -1;\n\n        emitter->line = 0;\n        emitter->column = 0;\n        emitter->whitespace = 1;\n        emitter->indention = 1;\n\n        if (emitter->encoding != YAML_UTF8_ENCODING) {\n            if (!yaml_emitter_write_bom(emitter))\n                return 0;\n        }\n\n        emitter->state = YAML_EMIT_FIRST_DOCUMENT_START_STATE;\n\n        return 1;\n    }\n\n    return yaml_emitter_set_emitter_error(emitter,\n            \"expected STREAM-START\");\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Set an emitter error and return 0.\n */\n", "func_signal": "static int\nyaml_emitter_set_emitter_error(yaml_emitter_t *emitter, const char *problem)", "code": "{\n    emitter->error = YAML_EMITTER_ERROR;\n    emitter->problem = problem;\n\n    return 0;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect SEQUENCE-START.\n */\n", "func_signal": "static int\nyaml_emitter_emit_sequence_start(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n\n    if (emitter->flow_level || emitter->canonical\n            || event->data.sequence_start.style == YAML_FLOW_SEQUENCE_STYLE\n            || yaml_emitter_check_empty_sequence(emitter)) {\n        emitter->state = YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE;\n    }\n    else {\n        emitter->state = YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE;\n    }\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Expect SCALAR.\n */\n", "func_signal": "static int\nyaml_emitter_emit_scalar(yaml_emitter_t *emitter, yaml_event_t *event)", "code": "{\n    if (!yaml_emitter_select_scalar_style(emitter, event))\n        return 0;\n    if (!yaml_emitter_process_anchor(emitter))\n        return 0;\n    if (!yaml_emitter_process_tag(emitter))\n        return 0;\n    if (!yaml_emitter_increase_indent(emitter, 1, 0))\n        return 0;\n    if (!yaml_emitter_process_scalar(emitter))\n        return 0;\n    emitter->indent = POP(emitter, emitter->indents);\n    emitter->state = POP(emitter, emitter->states);\n\n    return 1;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*\n * Append a directive to the directives stack.\n */\n", "func_signal": "static int\nyaml_emitter_append_tag_directive(yaml_emitter_t *emitter,\n        yaml_tag_directive_t value, int allow_duplicates)", "code": "{\n    yaml_tag_directive_t *tag_directive;\n    yaml_tag_directive_t copy = { NULL, NULL };\n\n    for (tag_directive = emitter->tag_directives.start;\n            tag_directive != emitter->tag_directives.top; tag_directive ++) {\n        if (strcmp((char *)value.handle, (char *)tag_directive->handle) == 0) {\n            if (allow_duplicates)\n                return 1;\n            return yaml_emitter_set_emitter_error(emitter,\n                    \"duplicate %TAG directive\");\n        }\n    }\n\n    copy.handle = yaml_strdup(value.handle);\n    copy.prefix = yaml_strdup(value.prefix);\n    if (!copy.handle || !copy.prefix) {\n        emitter->error = YAML_MEMORY_ERROR;\n        goto error;\n    }\n\n    if (!PUSH(emitter, emitter->tag_directives, copy))\n        goto error;\n\n    return 1;\n\nerror:\n    yaml_free(copy.handle);\n    yaml_free(copy.prefix);\n    return 0;\n}", "path": "packages\\yaml\\emitter.c", "repo_name": "clementfarabet/xLearn", "stars": 20, "license": "other", "language": "c", "size": 11405}
{"docstring": "/*HAVE_SSL*/\n", "func_signal": "BOOLEAN\nSSL_initialize(CONN *C)", "code": "{\n#ifdef HAVE_SSL\n  int  i;\n  int  serr;\n  \n  C->ssl    = NULL;\n  C->ctx    = NULL;\n  C->method = NULL;\n  C->cert   = NULL; \n  \n  /** \n   * XXX: SSL_library_init(); \n   *      SSL_load_error_strings();\n   * moved to ssl.c:235 - use once \n   */\n  if(!my.ssl_key && my.ssl_cert) {\n    my.ssl_key = my.ssl_cert;\n  }\n  if(!my.ssl_ciphers) {\n    my.ssl_ciphers = stralloc(SSL_DEFAULT_CIPHER_LIST);\n  } \n\n  C->method = SSLv23_client_method();\n  if(C->method==NULL){\n    SSL_error_stack();\n    return FALSE;\n  } \n  C->ctx = SSL_CTX_new(C->method);\n  if(C->ctx==NULL){\n    SSL_error_stack();\n    return FALSE;\n  } \n\n  SSL_CTX_set_mode(C->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE|SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n  SSL_CTX_set_session_cache_mode(C->ctx, SSL_SESS_CACHE_BOTH);\n  SSL_CTX_set_timeout(C->ctx, my.ssl_timeout);\n  if(my.ssl_ciphers){\n    if(!SSL_CTX_set_cipher_list(C->ctx, my.ssl_ciphers)){\n      NOTIFY(ERROR, \"SSL_CTX_set_cipher_list\");\n      return FALSE;\n    }\n  }\n\n  if(my.ssl_cert){\n    if(!SSL_CTX_use_certificate_chain_file(C->ctx, my.ssl_cert)){\n      SSL_error_stack(); /* dump the error stack */\n      NOTIFY(ERROR, \"Error reading certificate file: %s\", my.ssl_cert);\n    }\n    for(i=0; i<3; i++){\n      if(SSL_CTX_use_PrivateKey_file(C->ctx, my.ssl_key, SSL_FILETYPE_PEM))\n        break;\n      if(i<2 && ERR_GET_REASON(ERR_peek_error())==EVP_R_BAD_DECRYPT){\n        SSL_error_stack(); /* dump the error stack */\n        NOTIFY(WARNING, \"Wrong pass phrase: retrying\");\n        continue;\n      }\n    }\n\n    if(!SSL_CTX_check_private_key(C->ctx)){\n      NOTIFY(ERROR, \"Private key does not match the certificate\");\n      return FALSE;\n    }\n  }  \n\n  C->ssl = SSL_new(C->ctx);\n  if(C->ssl==NULL){\n    SSL_error_stack();\n    return FALSE;\n  }\n  SSL_set_fd(C->ssl, C->sock);\n  serr = SSL_connect(C->ssl);\n  return TRUE;\n#else\n  C->nossl = TRUE;\n  return FALSE;\n#endif/*HAVE_SSL*/\n}", "path": "src\\ssl.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * local function\n * set socket to non-blocking\n */\n", "func_signal": "private int\n__socket_block(int sock, BOOLEAN block)", "code": "{\n#if HAVE_FCNTL_H \n  int flags;\n  int retval;\n#elif defined(FIONBIO)\n  ioctl_t status;\n#else \n  return sock;\n#endif\n\n  if(sock==-1){\n    return sock;\n  }\n\n#if HAVE_FCNTL_H \n  if((flags = fcntl(sock, F_GETFL, 0)) < 0){\n    switch(errno){\n      case EACCES: { NOTIFY(ERROR, \"EACCES %s:%d\",                 __FILE__, __LINE__); break; }\n      case EBADF:  { NOTIFY(ERROR, \"bad file descriptor %s:%d\",    __FILE__, __LINE__); break; }\n      case EAGAIN: { NOTIFY(ERROR, \"address is unavailable %s:%d\", __FILE__, __LINE__); break; }\n      default:     { NOTIFY(ERROR, \"unknown network error %s:%d\",  __FILE__, __LINE__); break; }\n    } return -1;\n  }\n\n  if(block){ \n    flags &= ~O_NDELAY;\n  } else {\n    flags |=  O_NDELAY;\n    #if (defined(hpux) || defined(__hpux) || defined(__osf__)) || defined(__sun)\n    #else\n    flags |=  O_NONBLOCK;\n    #endif\n  }\n\n  if((retval = fcntl(sock, F_SETFL, flags)) < 0){\n    NOTIFY(ERROR, \"unable to set fcntl flags %s:%d\", __FILE__, __LINE__);\n    return -1;\n  } \n  return retval;\n\n#elif defined(FIONBIO)\n  status = block ? 0 : 1;\n  return ioctl(sock, FIONBIO, &status);\n#endif\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * parses the -t/--time option for a timed\n * interval.  The option requires a modifier,\n * H, M, or S, hours, minutes or seconds    \n */\n", "func_signal": "void\nparse_time(char *p)", "code": "{\n  size_t x = 0;\n  my.time = my.secs = 0;\n\n  while(ISDIGIT(p[x]))\n    x++;\n  if (x==0) return;\n  my.time = atoi(substring(p, 0, x));\n\n  for(; x < strlen(p); x ++)\n    switch(TOLOWER(p[x])){\n      case 's':\n        my.secs = my.time;\n        my.time = 1;\n        return;\n      case 'm':\n        my.secs = my.time * 60;\n        my.time = 1;\n        return;\n      case 'h':\n        my.secs = my.time * 3600;\n        my.time = 1;\n        return;\n      default:\n        break;\n    }\n  if((my.time > 0) && (my.secs <= 0)){\n    my.secs = my.time * 60;\n  }\n\n  return;\n}", "path": "src\\util.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/* marks the siege.log with a user defined \n   message.  checks for the existence of a\n   log and creates one if not found.      */\n", "func_signal": "void\nmark_log_file(char *message)", "code": "{\n  int  fd;\n  char entry[512];\n\n  /* if the file does NOT exist then create it.  */\n  if(!file_exists(my.logfile)){\n    if(!create_logfile(my.logfile)){\n      NOTIFY(ERROR, \"unable to create log file\");\n      return;\n    }\n  }\n\n  /* create the log file entry */\n  snprintf(entry, sizeof entry, \"**** %s ****\\n\", message);\n\n  if ((fd = open( my.logfile, O_WRONLY | O_APPEND, 0644 )) < 0) {\n    NOTIFY(ERROR, \"Unable to write to file\" );\n  }\n\n  write(fd, entry, strlen(entry));\n  close(fd);\n\n  return; \n}", "path": "src\\log.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns int, ( < 0 == error )\n * formats and sends an HTTP/1.0 request\n */\n", "func_signal": "int\nhttp_post(CONN *C, URL *U)", "code": "{\n  int  rlen;\n  char hoststr[128];\n  char authwww[128];\n  char authpxy[128]; \n  char request[REQBUF+POSTBUF+MAX_COOKIE_SIZE+8]; \n  char portstr[16];\n  char *protocol; \n  char *keepalive;\n  char cookie[MAX_COOKIE_SIZE];\n  char fullpath[4096];\n\n  memset(hoststr, 0, sizeof(hoststr));\n  memset(cookie,  0, sizeof(cookie));\n  memset(request, 0, sizeof(request));\n  memset(portstr, 0, sizeof portstr);\n\n  if(my.proxy.required){\n   sprintf(\n      fullpath, \n      \"%s://%s:%d%s\", \n      C->prot == 0?\"http\":\"https\", U->hostname, U->port, U->pathname\n    ); \n  } else {\n    sprintf(fullpath, \"%s\", U->pathname);\n  }\n\n  if((U->port==80 && C->prot==HTTP) || (U->port==443 && C->prot==HTTPS)){\n    portstr[0] = '\\0';  ;\n  } else {\n    snprintf(portstr, sizeof portstr, \":%d\", U->port);\n  }\n\n  /* HTTP protocol string */\n  protocol  = (my.protocol == TRUE)?\"HTTP/1.1\":\"HTTP/1.0\";\n  keepalive = (C->connection.keepalive == TRUE)?\"keep-alive\":\"close\";\n  get_cookie_header(pthread_self(), U->hostname, cookie);\n  if( C->auth.www ){\n    if(C->auth.type.www==DIGEST){\n      char *tmp;\n\n      tmp = digest_generate_authorization(C->auth.wwwchlg, C->auth.wwwcred, \"GET\", fullpath);\n      rlen = snprintf( authwww, sizeof(authwww), \"Authorization: %s\\015\\012\", tmp);\n      free(tmp);\n    } else {\n      rlen = snprintf( authwww, sizeof(authwww), \"Authorization: Basic %s\\015\\012\", my.auth.encode);\n    }\n  }\n  if( C->auth.proxy ){\n    if(C->auth.type.proxy==DIGEST){\n      char *tmp;\n\n      tmp = digest_generate_authorization(C->auth.proxychlg, C->auth.proxycred, \"GET\", fullpath);\n      rlen = snprintf( authpxy, sizeof(authpxy), \"Proxy-Authorization: %s\\015\\012\", tmp);\n      free(tmp);\n    } else  {\n      rlen = snprintf( authpxy, sizeof(authpxy), \"Proxy-Authorization: Basic %s\\015\\012\", my.proxy.encode);\n    }\n  }\n\n  /* Only send the Host header if one wasn't provided. */\n  if(strncasestr(my.extra, \"host:\", sizeof(my.extra)) == NULL){\n    rlen = snprintf(hoststr, sizeof(hoststr), \"Host: %s%s\\015\\012\", U->hostname, portstr);\n  }\n\n  /* build a request string to\n     pass to the server       */\n  rlen = snprintf(\n    request, sizeof(request),\n    \"POST %s %s\\015\\012\"\n    \"%s\"\n    \"%s\"\n    \"%s\"\n    \"%s\"\n    \"Accept: */*\\015\\012\"\n    \"Accept-Encoding: %s\\015\\012\"\n    \"User-Agent: %s\\015\\012%s\"\n    \"Connection: %s\\015\\012\"\n    \"Content-type: %s\\015\\012\"\n    \"Content-length: %ld\\015\\012\\015\\012\",\n    fullpath, protocol, hoststr,\n    (C->auth.www==TRUE)?authwww:\"\",\n    (C->auth.proxy==TRUE)?authpxy:\"\",\n    (strlen(cookie) > 8)?cookie:\"\", \n    my.encoding, my.uagent, my.extra, keepalive, U->conttype, (long)U->postlen\n  ); \n\n  if(rlen + U->postlen < sizeof(request)){\n    memcpy(request + rlen, U->postdata, U->postlen);\n    request[rlen+U->postlen] = 0;\n  }\n  rlen += U->postlen;\n  \n  if(my.debug || my.get){ printf(\"%s\\n\", request); fflush(stdout); }\n  if(rlen<0 || rlen>(int)sizeof(request)){\n    NOTIFY(FATAL, \"HTTP POST: request buffer overrun! Unable to continue...\"); \n  }\n  if((socket_write(C, request, rlen)) < 0){\n    return -1;\n  }\n\n  return 0;\n}", "path": "src\\http.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns void\n * frees ssl resources if using ssl and\n * closes the connection and the socket.\n */\n", "func_signal": "void\nsocket_close(CONN *C)", "code": "{\n  int   type;\n  int   ret   = 0;\n#ifdef  HAVE_SSL\n  int tries = 0;\n#endif/*HAVE_SSL*/\n\n  if(C==NULL) return;\n\n  /* XXX Is this necessary? */ \n  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &type); \n\n  if(C->encrypt == TRUE){\n#ifdef  HAVE_SSL\n    if(!C->connection.reuse || C->connection.max == 1){\n      if(C->ssl != NULL){\n        do{\n          if((ret = SSL_shutdown(C->ssl))==1) \n            break;\n          tries++;\n        } while(tries < 5);\n      }\n      SSL_free(C->ssl);\n      C->ssl = NULL;\n      SSL_CTX_free(C->ctx);\n      C->ctx = NULL;\n      close(C->sock);\n      C->sock              = -1;\n      C->connection.status =  0;\n      C->connection.max    =  0;\n      C->connection.tested =  0;\n    }\n#endif/*HAVE_SSL*/\n  } else {\n    if(C->connection.reuse == 0 || C->connection.max == 1){\n      if(C->sock != -1){\n        if((__socket_block(C->sock, FALSE)) < 0)\n          NOTIFY(ERROR, \"unable to set to non-blocking %s:%d\", __FILE__, __LINE__);\n        if((C->connection.status > 1)&&(ret = shutdown(C->sock, 2)) < 0)\n          NOTIFY(ERROR, \"unable to shutdown the socket %s:%d\", __FILE__, __LINE__);\n        if((ret = close(C->sock)) < 0)\n          NOTIFY(ERROR, \"unable to close the socket %s:%d\",    __FILE__, __LINE__);\n      }\n      C->sock                 = -1;\n      C->connection.status    =  0;\n      C->connection.max       =  0;\n      C->connection.tested    =  0;\n    }\n  }\n  C = NULL;\n  pthread_setcanceltype(type,NULL);\n  pthread_testcancel(); \n\n  return;\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * writes the output from siege to a formatted\n * log file.  checks if the log exists, if not\n * it creates a new formatted file and appends\n * text to it.  If a file does exist,  then it\n * simply appends to it. \n */\n", "func_signal": "void\nlog_transaction(DATA D)", "code": "{\n  write_to_log(\n    data_get_count(D),\n    data_get_elapsed(D),\n    data_get_megabytes(D),\n    data_get_total(D),\n    data_get_code(D),\n    my.failed\n  );\n  return;\n}", "path": "src\\log.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/*HAVE_SSL*/\n", "func_signal": "ssize_t\nsocket_read(CONN *C, void *vbuf, size_t len)", "code": "{\n  int type;\n  size_t      n;\n  ssize_t     r;\n  char *buf;\n  int ret_eof = 0;\n \n  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &type);\n \n  buf = vbuf;\n  n   = len;\n  if(C->encrypt == TRUE){\n  #ifdef HAVE_SSL\n    while(n > 0){\n      if(__socket_check(C, READ) == FALSE){\n\treturn -1;\n      }\n      if((r = SSL_read(C->ssl, buf, n)) < 0){\n        if( errno == EINTR )\n          r = 0;\n        else\n          return -1;\n      }\n      else if(r == 0) break;\n      n   -= r;\n      buf += r;\n    }   /* end of while    */\n  #endif/*HAVE_SSL*/\n  } else { \n    while(n > 0){\n      if(C->inbuffer < len){\n        if(__socket_check(C, READ) == FALSE){\n          return -1;\n        }\n      }\n      if(C->inbuffer <  n){\n        int lidos;\n        memmove(C->buffer,&C->buffer[C->pos_ini],C->inbuffer);\n        C->pos_ini = 0;\n\tif(__socket_check(C, READ) == FALSE){\n\t  return -1;\n\t}\n        lidos = read(C->sock, &C->buffer[C->inbuffer], sizeof(C->buffer)-C->inbuffer);\n        if(lidos == 0)\n          ret_eof = 1;\n        if(lidos < 0){\n          if(errno==EINTR || errno==EAGAIN)\n            lidos = 0;\n          if(errno==EPIPE){\n            return 0;\n          } else {\n            NOTIFY(ERROR, \"socket: read error %s %s:%d\", strerror(errno), __FILE__, __LINE__);\n            return 0; /* was return -1 */\n          }\n        }\n        C->inbuffer += lidos;\n      }\n      if(C->inbuffer >= n){\n        r = n;\n      } else {\n        r = C->inbuffer;\n      }\n      if(r == 0) break;\n      memmove(buf,&C->buffer[C->pos_ini],r);\n      C->pos_ini  += r;\n      C->inbuffer -= r;\n      n   -= r;\n      buf += r;\n      if(ret_eof) break;\n    } /* end of while */\n  }   /* end of else  */\n \n  pthread_setcanceltype(type,NULL);\n  pthread_testcancel();\n  return(len - n);\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns int, ( < 0 == error )\n * formats and sends an HTTP/1.0 request\n */\n", "func_signal": "int\nhttp_get(CONN *C, URL *U)", "code": "{\n  int  rlen;\n  char *protocol; \n  char *keepalive;\n  char hoststr[512];\n  char authwww[512];\n  char authpxy[512];\n  char request[REQBUF+MAX_COOKIE_SIZE+8];  \n  char portstr[16];\n  char fullpath[4096];\n  char cookie[MAX_COOKIE_SIZE+8];\n  time_t now;\n  char *ifmod = url_get_if_modified_since(U);\n  char *ifnon = url_get_etag(U);\n\n  now = time(NULL);\n\n  memset(hoststr, 0, sizeof hoststr);\n  memset(cookie,  0, sizeof cookie);\n  memset(request, 0, sizeof request);\n  memset(portstr, 0, sizeof portstr);\n\n  /* Request path based on proxy settings */\n  if(my.proxy.required){\n    sprintf(\n      fullpath, \"%s://%s:%d%s\", C->prot == HTTP?\"http\":\"https\", U->hostname, U->port, U->pathname \n    );\n  } else {\n    sprintf(fullpath, \"%s\", U->pathname);\n  }\n\n  if((U->port==80 && C->prot==HTTP) || (U->port==443 && C->prot==HTTPS)){\n    portstr[0] = '\\0';  \n  } else {\n    snprintf(portstr, sizeof portstr, \":%d\", U->port);\n  }\n\n  /* HTTP protocol string */\n  protocol  = (my.protocol == TRUE)?\"HTTP/1.1\":\"HTTP/1.0\";\n  keepalive = (C->connection.keepalive == TRUE)?\"keep-alive\":\"close\";\n  get_cookie_header(pthread_self(), U->hostname, cookie); \n  if(C->auth.www){\n    if(C->auth.type.www==DIGEST){\n      char *tmp;\n      tmp = digest_generate_authorization(C->auth.wwwchlg, C->auth.wwwcred, \"GET\", fullpath);\n      rlen = snprintf(authwww, sizeof(authwww), \"Authorization: %s\\015\\012\", tmp);\n      free(tmp);\n    } else {\n      rlen = snprintf(authwww, sizeof(authwww), \"Authorization: Basic %s\\015\\012\", my.auth.encode);\n    }\n  }\n  if(C->auth.proxy){\n    if(C->auth.type.proxy==DIGEST){\n      char *tmp;\n\n      tmp = digest_generate_authorization(C->auth.proxychlg, C->auth.proxycred, \"GET\", fullpath);\n      rlen = snprintf( authpxy, sizeof(authpxy), \"Proxy-Authorization: %s\\015\\012\", tmp);\n      free(tmp);\n    } else  {\n      rlen = snprintf( authpxy, sizeof(authpxy), \"Proxy-Authorization: Basic %s\\015\\012\", my.proxy.encode);\n    }\n  }\n\n  /* Only send the Host header if one wasn't provided. */\n  if(strncasestr(my.extra, \"host:\", sizeof(my.extra)) == NULL){\n    rlen = snprintf(hoststr, sizeof(hoststr), \"Host: %s%s\\015\\012\", U->hostname, portstr);\n  }\n\n  /** \n   * build a request string to pass to the server       \n   */\n  rlen = snprintf(\n    request, sizeof( request ),\n    \"GET %s %s\\015\\012\"                    /* fullpath, protocol     */\n    \"%s\"                                   /* hoststr                */\n    \"%s\"                                   /* authwww   or empty str */\n    \"%s\"                                   /* authproxy or empty str */\n    \"%s\"                                   /* cookie    or empty str */\n    \"%s\"                                   /* ifmod     or empty str */\n    \"%s\"                                   /* ifnon     or empty str */\n    \"Accept: */*\\015\\012\"                  /*             */\n    \"Accept-Encoding: %s\\015\\012\"          /* my.encoding */\n    \"User-Agent: %s\\015\\012\"               /* my uagent   */\n    \"%s\"                                   /* my.extra    */\n    \"Connection: %s\\015\\012\\015\\012\",      /* keepalive   */\n    fullpath, protocol, hoststr,\n    (C->auth.www==TRUE)?authwww:\"\",\n    (C->auth.proxy==TRUE)?authpxy:\"\",\n    (strlen(cookie) > 8)?cookie:\"\", \n    (ifmod!=NULL)?ifmod:\"\",\n    (ifnon!=NULL)?ifnon:\"\",\n    my.encoding, my.uagent, my.extra, keepalive \n  );\n \n  if(my.debug || my.get){ printf(\"%s\\n\", request); fflush(stdout); }\n  if(rlen < 0 || rlen > (int)sizeof(request)){ \n    NOTIFY(FATAL, \"HTTP GET: request buffer overrun!\");\n  }\n  if((socket_write(C, request, rlen)) < 0){\n    xfree(ifmod);\n    xfree(ifnon);\n    return -1;\n  }\n   \n  xfree(ifmod);\n  xfree(ifnon);\n  return 0;\n}", "path": "src\\http.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns void\n * socket_write wrapper function.\n */\n", "func_signal": "int\nsocket_write(CONN *C, const void *buf, size_t len)", "code": "{\n  int     type;\n  size_t bytes;\n\n  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &type); \n#if 0\n  if(__socket_check(C, READ) == WRITE){\n    return -1;\n  }\n#endif\n  if(C->encrypt == TRUE){\n    /* handle HTTPS protocol */\n    #ifdef HAVE_SSL\n    /** \n     * Yeah, sure, this looks like a potential \n     * endless loop, (see: Loop, endless), but \n     * a socket timeout will break it...\n     */\n    do{\n      if((bytes = __ssl_socket_write(C, buf, len)) != len){\n        if(bytes == 0)\n          ;\n        else \n          return -1;\n      }\n    } while(bytes == 0);\n    #else\n    NOTIFY(ERROR, \"%s:%d protocol NOT supported\", __FILE__, __LINE__);\n    return -1;\n    #endif/*HAVE_SSL*/\n  } else {\n    /* assume HTTP */\n    if((bytes = __socket_write(C->sock, buf, len)) != len){\n      NOTIFY(ERROR, \"unable to write to socket %s:%d\", __FILE__, __LINE__);\n      return -1;\n    }\n  }\n\n  pthread_setcanceltype(type,NULL); \n  pthread_testcancel(); \n\n  return bytes;\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns ssize_t\n */\n", "func_signal": "ssize_t\nhttp_read(CONN *C)", "code": "{ \n  int    n      = 0;\n  int    chunk  = 0;\n  size_t bytes  = 0;\n  size_t length = 0;\n  static char body[MAXFILE];\n\n  if(C == NULL) NOTIFY(FATAL, \"Connection is NULL! Unable to proceded\"); \n\n  if(C->content.length > 0){\n    length = (C->content.length < MAXFILE)?C->content.length:MAXFILE;\n    do {\n      memset(body, 0, sizeof(body));\n      if(( n = socket_read(C, body, length)) == 0 )\n        break;\n      bytes += n;\n      length = (C->content.length - bytes < MAXFILE)?C->content.length-bytes:MAXFILE;\n    } while(bytes < C->content.length); \n  } else if(my.chunked && C->content.transfer == CHUNKED) {\n    int tries = 0;\n    while(tries < 256) {\n      chunk = http_chunk_size(C);\n      if(chunk == 0)\n        break;\n      else if(chunk < 0) {\n        tries ++;\n        continue;\n      }\n      do {\n        int n;\n        memset(body, 0, MAXFILE);\n        n = socket_read(C, body, (chunk>MAXFILE)?MAXFILE:chunk);\n        chunk -= n;\n        bytes += n;\n      } while(chunk > 0);\n    }\n  } else {\n    do {\n      memset(body, 0, sizeof(body));\n      if((n = socket_read(C, body, sizeof(body))) == 0)\n        break;\n      bytes += n;\n    } while(TRUE);\n  }\n\n  return(bytes);\n}", "path": "src\\http.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns ssize_t\n * writes vbuf to sock\n */\n", "func_signal": "private ssize_t\n__socket_write( int sock, const void *vbuf, size_t len )", "code": "{\n  size_t      n;\n  ssize_t     w;\n  const char *buf;\n \n  buf = vbuf;\n  n   = len;\n  while(n > 0){\n    if((w = write( sock, buf, n)) <= 0){\n      if(errno == EINTR){\n        w = 0;\n      } else {\n        return -1;\n      }\n    }\n    n   -= w;\n    buf += w;\n  }\n  return len;\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * maps a file to our address space \n * and returns it the calling function.\n */\n", "func_signal": "void \nload_file(URL *U, char *file)", "code": "{\n  FILE     *fp;\n  size_t   len = 0;\n  struct   stat st; \n  char     *filename;\n  char     postdata[POSTBUF]; \n  size_t   postlen = 0;\n\n  filename = trim(file);\n  memset(postdata, 0, POSTBUF);\n\n  if((lstat(filename, &st) == 0) || (errno != ENOENT)){ \n    len = (st.st_size >= POSTBUF) ? POSTBUF : st.st_size;  \n    if(len < (unsigned)st.st_size){\n      NOTIFY(WARNING, \"Truncated file: %s exceeds the post limit of %d bytes.\\n\", filename, POSTBUF);\n    }\n    if((fp = fopen(filename, \"r\")) == NULL){\n      NOTIFY(ERROR, \"could not open file: %s\", filename);\n      return;\n    }\n    if ((fread(postdata, 1, len, fp )) == len) {\n      if (is_ascii(filename)) {\n        trim(postdata);\n        postlen = strlen(postdata);\n      } else {\n        postlen = len;\n      }\n    } else {\n      NOTIFY(ERROR, \"unable to read file: %s\", filename );\n    }\n    fclose(fp);\n  }\n\n  if(strlen(postdata) > 0){\n    U->conttype = xstrdup(get_content_type(filename));\n    U->postlen  = postlen; //strlen(postdata);\n    U->postdata = malloc(U->postlen);\n    memcpy(U->postdata, postdata, U->postlen);\n    U->postdata[U->postlen] = 0;\n  } \n  return;\n}", "path": "src\\load.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns TRUE if the file exists,\n */\n", "func_signal": "BOOLEAN\nfile_exists(char *file)", "code": "{\n  int  fd;\n\n  /* open the file read only  */\n  if((fd = open(file, O_RDONLY)) < 0){\n  /* the file does NOT exist  */\n    close(fd);\n    return FALSE;\n  } else {\n  /* party on Garth... */\n    close(fd);\n    return TRUE;\n  }\n\n  return FALSE;\n}", "path": "src\\log.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * this function is used for chunked\n * encoding transfers to acquire the \n * size of the message check.\n */\n", "func_signal": "ssize_t\nsocket_readline(CONN *C, char *ptr, size_t maxlen)", "code": "{\n  int type;\n  int n, len, res;\n  char c;\n\n  len = maxlen;\n  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &type); \n\n  for(n = 1; n < len; n ++){\n    if((res = socket_read(C, &c, 1)) == 1){\n      *ptr++ = c;\n      if(c=='\\n') break;\n    }\n    else if(res == 0){\n      if(n == 1) \n        return 0; \n      else \n        break; \n    } else {\n      return -1; /* something bad happened */\n    }\n  } /* end of for loop */\n\n  *ptr=0;\n  \n  pthread_setcanceltype(type,NULL);\n  pthread_testcancel(); \n\n  return n;\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * return TRUE upon the successful\n * creation of the file, FALSE if not.  The\n * function adds a header at the top of the\n * file, format is comma separated text for\n * spreadsheet import.\n */\n", "func_signal": "BOOLEAN\ncreate_logfile(const char *file)", "code": "{\n  int   fd;\n  char *head = (char*)\"      Date & Time,  Trans,  Elap Time,  Data Trans,  \"\n               \"Resp Time,  Trans Rate,  Throughput,  Concurrent,    OKAY,   Failed\\n\"; \n \n  if((fd = open(file, O_CREAT | O_WRONLY, 0644)) < 0){\n    return FALSE;\n  }\n\n  /* write the header to the file */\n  write(fd, head, strlen(head));\n  close(fd);\n  \n  return TRUE;\n}", "path": "src\\log.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * returns HEADERS struct\n * reads from http/https socket and parses\n * header information into the struct.\n */\n", "func_signal": "HEADERS *\nhttp_read_headers(CONN *C, URL *U)", "code": "{ \n  int  x;           /* while loop index      */\n  int  n;           /* assign socket_read    */\n  char c;           /* assign char read      */\n  HEADERS *h;       /* struct to hold it all */\n  char line[MAX_COOKIE_SIZE];  /* assign chars read     */\n  \n  h = xcalloc(sizeof(HEADERS), 1);\n  \n  while(TRUE){\n    x = 0;\n    memset(&line, 0, MAX_COOKIE_SIZE);\n    while((n = socket_read(C, &c, 1)) == 1){\n      if(x < MAX_COOKIE_SIZE - 1)\n        line[x] = c; \n      else \n        line[x] = '\\n';\n      if(my.debug || my.get){ printf(\"%c\", c ); fflush(stdout); }\n      if((line[0] == '\\n') || (line[1] == '\\n')){ \n        return h;\n      }\n      if(line[x] == '\\n') break;\n      x ++;\n    }\n    line[x]=0;\n    /* strip trailing CR */\n    if(x > 0 && line[x-1] == '\\r') line[x-1]=0;\n    if( strncasecmp(line, \"http\", 4) == 0){\n      strncpy( h->head, line, 8);\n      h->code = atoi(line + 9); \n    }\n    if(strncasecmp(line, \"content-length: \", 16) == 0){ \n      C->content.length = atoi(line + 16); \n    }\n    if(strncasecmp(line, \"set-cookie: \", 12) == 0){\n      if(my.cookies){\n        memset(h->cookie, 0, sizeof(h->cookie));\n        strncpy(h->cookie, line+12, strlen(line));\n        add_cookie(pthread_self(), U->hostname, h->cookie);\n      }\n    }\n    if(strncasecmp(line, \"connection: \", 12 ) == 0){\n      if(strncasecmp(line+12, \"keep-alive\", 10) == 0){\n        h->keepalive = 1;\n      } else if(strncasecmp(line+12, \"close\", 5) == 0){\n        h->keepalive = 0;\n      }\n    }\n    if(strncasecmp(line, \"keep-alive: \", 12) == 0){\n      char *tmp    = \"\";\n      char *option = \"\", *value = \"\";\n      char *newline = (char*)line;\n      while((tmp = __parse_pair(&newline)) != NULL){\n        option = tmp;\n        while(*tmp && !ISSPACE((int)*tmp) && !ISSEPARATOR(*tmp))\n          tmp++;\n        *tmp++=0;\n        while(ISSPACE((int)*tmp) || ISSEPARATOR(*tmp))\n          tmp++;\n        value  = tmp;\n        while(*tmp)\n          tmp++;  \n        if(!strncasecmp(option, \"timeout\", 7)){\n          if(value != NULL){\n            C->connection.timeout = atoi(value);\n          } else {\n            C->connection.timeout = 15;\n          }\n        }\n        if(!strncasecmp(option, \"max\", 3)){\n          if(value != NULL){\n            C->connection.max = atoi(value);\n          } else {\n            C->connection.max = 0;\n          }\n        }\n      }\n    }\n    if(strncasecmp(line, \"location: \", 10) == 0){\n      size_t len  = strlen(line);\n      h->redirect = xmalloc(len);\n      memcpy(h->redirect, line+10, len-10);\n      h->redirect[len-10] = 0;\n    }\n    if(strncasecmp(line, \"last-modified: \", 15) == 0){\n      char *date;\n      size_t len = strlen(line);\n      if(my.cache){\n        date = xmalloc(len);\n        memcpy(date, line+15, len-14);\n        url_set_last_modified(U, date);\n        xfree(date); \n      }\n    }\n    if(strncasecmp(line, \"etag: \", 6) == 0){\n      char   *etag;\n      size_t len = strlen(line);\n      if(my.cache){\n        etag = xmalloc(len);\n        memcpy(etag, line+6, len-5);\n        etag[len-1] = '\\0';\n        url_set_etag(U, etag);\n        xfree(etag);\n      }\n    }\n    if(strncasecmp(line, \"www-authenticate: \", 18) == 0){\n      char *tmp     = \"\"; \n      char *option  = \"\", *value = \"\";\n      char *newline = (char*)line;\n      if(strncasecmp(line+18, \"digest\", 6) == 0){\n        newline += 24;\n        h->auth.type.www      = DIGEST;\n        h->auth.challenge.www = xstrdup(line+18);\n      } else {\n        newline += 23;\n        h->auth.type.www = BASIC;\n      }\n      while((tmp = __parse_pair(&newline)) != NULL){\n        option = tmp; \n        while(*tmp && !ISSPACE((int)*tmp) && !ISSEPARATOR(*tmp))\n          tmp++;\n        *tmp++=0;\n        while(ISSPACE((int)*tmp) || ISSEPARATOR(*tmp))\n          tmp++; \n        value  = tmp;\n        while(*tmp)\n          tmp++;\n        if(!strncasecmp(option, \"realm\", 5)){\n          if(value != NULL){\n\t    h->auth.realm.www = xstrdup(__dequote(value));\n          } else {\n            h->auth.realm.www = xstrdup(\"\");\n          }\n        }\n      } /* end of parse pairs */\n    } \n    if(strncasecmp(line, \"proxy-authenticate: \", 20) == 0){\n      char *tmp     = \"\"; \n      char *option  = \"\", *value = \"\";\n      char *newline = (char*)line;\n      if(strncasecmp(line+20, \"digest\", 6) == 0){\n        newline += 26;\n        h->auth.type.proxy      = DIGEST;\n        h->auth.challenge.proxy = xstrdup(line+20);\n      } else {\n        newline += 25;\n        h->auth.type.proxy = BASIC;\n      }\n      while((tmp = __parse_pair(&newline)) != NULL){\n        option = tmp; \n        while(*tmp && !ISSPACE((int)*tmp) && !ISSEPARATOR(*tmp))\n          tmp++;\n        *tmp++=0;\n        while(ISSPACE((int)*tmp) || ISSEPARATOR(*tmp))\n          tmp++; \n        value  = tmp;\n        while(*tmp)\n          tmp++;\n        if(!strncasecmp(option, \"realm\", 5)){\n          if(value != NULL){\n\t    h->auth.realm.proxy = xstrdup(__dequote(value));\n          } else {\n            h->auth.realm.proxy = xstrdup(\"\");\n          }\n        }\n      } /* end of parse pairs */\n    }\n    if(strncasecmp(line, \"transfer-encoding: \", 19) == 0){\n      if(strncasecmp(line+20, \"chunked\", 7)){\n        C->content.transfer = CHUNKED; \n      } else if(strncasecmp(line+20, \"trailer\", 7)){\n        C->content.transfer = TRAILER; \n      } else {\n        C->content.transfer = NONE;\n      }\n    }\n    if(strncasecmp(line, \"expires: \", 9) == 0){\n      /* printf(\"%s\\n\", line+10);  */\n    }\n    if(strncasecmp(line, \"cache-control: \", 15) == 0){\n      /* printf(\"%s\\n\", line+15); */\n    }\n    if(n <=  0){ \n      debug(\"read error: %s:%d\", __FILE__, __LINE__);\n      http_free_headers(h);\n      return(NULL); \n    } /* socket closed */\n  } /* end of while TRUE */\n\n  return h;\n}", "path": "src\\http.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * HTTPS tunnel; set up a secure tunnel with the\n * proxy server. CONNECT server:port HTTP/1.0\n */\n", "func_signal": "BOOLEAN\nhttps_tunnel_request(CONN *C, char *host, int port)", "code": "{\n  size_t  rlen, n;\n  char    request[256];\n\n  if(C->prot == HTTPS && my.proxy.required){\n    snprintf(\n      request, sizeof(request),\n      \"CONNECT %s:%d HTTP/1.0\\015\\012\"\n      \"User-agent: Proxy-User\\015\\012\"\n      \"\\015\\012\",\n      host, port\n    );    \n    rlen = strlen(request); \n    if(my.debug || my.get){fprintf(stdout, \"%s\", request); fflush(stdout);}\n    if((n = socket_write(C, request, rlen)) != rlen){\n      NOTIFY(ERROR, \"HTTP: unable to write to socket.\" );\n      return FALSE;\n    }\n  } else {\n    return FALSE; \n  }\n  return TRUE;\n}", "path": "src\\http.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * new_socket\n * returns int, socket handle\n */\n", "func_signal": "int\nnew_socket(CONN *C, const char *hostparam, int portparam)", "code": "{\n  int conn;\n  int res;\n  int opt;\n  int herrno;\n  struct sockaddr_in cli; \n  struct hostent     *hp;\n  char   hn[512];\n  int    port;\n#if defined(_AIX)\n  char *aixbuf;\n  int  rc;\n#endif/*_AIX*/ \n\n  C->encrypt = FALSE;\n\n  memset(hn, '\\0', sizeof hn);\n \n  /* if we are using a proxy, then we make a socket\n     connection to that server rather then a httpd */ \n  if(my.proxy.required){\n    snprintf(hn, sizeof(hn), \"%s\", my.proxy.hostname);\n    port = my.proxy.port;\n  } else {\n    snprintf(hn, sizeof(hn), \"%s\", hostparam);\n    port = portparam;\n  }\n\n  /* create a socket, return -1 on failure */\n  if((C->sock = socket(AF_INET, SOCK_STREAM, 0)) < 0){\n    switch(errno){\n      case EPROTONOSUPPORT: { NOTIFY(ERROR, \"unsupported protocol %s:%d\",  __FILE__, __LINE__); break; }\n      case EMFILE:          { NOTIFY(ERROR, \"descriptor table full %s:%d\", __FILE__, __LINE__); break; }\n      case ENFILE:          { NOTIFY(ERROR, \"file table full %s:%d\",       __FILE__, __LINE__); break; }\n      case EACCES:          { NOTIFY(ERROR, \"permission denied %s:%d\",     __FILE__, __LINE__); break; }\n      case ENOBUFS:         { NOTIFY(ERROR, \"insufficient buffer %s:%d\",   __FILE__, __LINE__); break; }\n      default:              { NOTIFY(ERROR, \"unknown socket error %s:%d\",  __FILE__, __LINE__); break; }\n    } socket_close(C); return -1;\n  }\n  if(fcntl(C->sock, F_SETFD, O_NDELAY) < 0){\n    NOTIFY(ERROR, \"unable to set close control %s:%d\", __FILE__, __LINE__);\n  }\n\n#if defined(__GLIBC__)\n  {\n    struct hostent hent;\n    char hbf[8192]; \n    memset(hbf, '\\0', sizeof hbf);\n    /* for systems using GNU libc */\n    if((gethostbyname_r(hostparam, &hent, hbf, sizeof(hbf), &hp, &herrno) < 0)){\n      hp = NULL;\n    }\n  }\n#elif defined(sun)\n# ifdef HAVE_GETIPNODEBYNAME\n  hp = getipnodebyname(hn, AF_INET, 0, &herrno);\n# else /* default use gethostbyname_r*/\n  {\n    struct hostent hent;\n    char hbf[8192]; \n    memset(hbf, '\\0', sizeof hbf);\n    hp = gethostbyname_r(hn, &hent, hbf, sizeof(hbf), &herrno); \n  }\n# endif/*HAVE_GETIPNODEBYNAME*/\n#elif defined(_AIX)\n  aixbuf = (char*)xmalloc(8192);\n  rc  = gethostbyname_r(hn, (struct hostent *)aixbuf,\n                       (struct hostent_data *)(aixbuf + sizeof(struct hostent)));\n  hp = (struct hostent*)aixbuf;\n#elif ( defined(hpux) || defined(__hpux) || defined(__osf__) )\n  hp = gethostbyname(hn);\n  herrno = h_errno;\n#else\n  /* simply hoping that gethostbyname is thread-safe */\n  hp = gethostbyname(hn);\n  herrno = h_errno;\n#endif/*OS SPECIFICS*/ \n\n  if(hp == NULL){ return -1; } \n  memset((void*) &cli, 0, sizeof(cli));\n  memcpy(&cli.sin_addr, hp->h_addr, hp->h_length);\n#if defined(sun)\n# ifdef  HAVE_FREEHOSTENT\n  freehostent(hp);\n# endif/*HAVE_FREEHOSTENT*/ \n#endif\n  cli.sin_family = AF_INET;\n  cli.sin_port = htons(port);\n\n  if(C->connection.keepalive){\n    opt = 1; \n    if(setsockopt(C->sock,SOL_SOCKET,SO_KEEPALIVE,(char *)&opt,sizeof(opt))<0){\n      switch( errno ){\n        case EBADF:       { NOTIFY(ERROR, \"invalid descriptor %s:%d\",    __FILE__, __LINE__); break; }\n        case ENOTSOCK:    { NOTIFY(ERROR, \"not a socket %s:%d\",          __FILE__, __LINE__); break; }\n        case ENOPROTOOPT: { NOTIFY(ERROR, \"not a protocol option %s:%d\", __FILE__, __LINE__); break; }\n        case EFAULT:      { NOTIFY(ERROR, \"setsockopt unknown %s:%d\",    __FILE__, __LINE__); break; }\n        default:          { NOTIFY(ERROR, \"unknown sockopt error %s:%d\", __FILE__, __LINE__); break; }\n      } socket_close(C); return -1;\n    }\n  }\n\n  if((__socket_block(C->sock, FALSE)) < 0){\n    NOTIFY(ERROR, \"socket: unable to set socket to non-blocking %s:%d\", __FILE__, __LINE__);\n    return -1; \n  }\n\n  /**\n   * connect to the host \n   * evaluate the server response and check for\n   * readability/writeability of the socket....\n   */ \n  conn = connect(C->sock, (struct sockaddr *)&cli, sizeof(struct sockaddr_in));\n  pthread_testcancel();\n  if(conn < 0 && errno != EINPROGRESS){\n    switch(errno){\n      case EACCES:        {NOTIFY(ERROR, \"socket: %d EACCES\",                  pthread_self()); break;}\n      case EADDRNOTAVAIL: {NOTIFY(ERROR, \"socket: %d address is unavailable.\", pthread_self()); break;}\n      case ETIMEDOUT:     {NOTIFY(ERROR, \"socket: %d connection timed out.\",   pthread_self()); break;}\n      case ECONNREFUSED:  {NOTIFY(ERROR, \"socket: %d connection refused.\",     pthread_self()); break;}\n      case ENETUNREACH:   {NOTIFY(ERROR, \"socket: %d network is unreachable.\", pthread_self()); break;}\n      case EISCONN:       {NOTIFY(ERROR, \"socket: %d already connected.\",      pthread_self()); break;}\n      default:            {NOTIFY(ERROR, \"socket: %d unknown network error.\",  pthread_self()); break;}\n    } socket_close(C); return -1;\n  } else {\n    struct timeval timeout;\n    fd_set rs;\n    fd_set ws; \n    FD_ZERO(&rs);\n    FD_ZERO(&ws);\n    FD_SET(C->sock, &rs);\n    FD_SET(C->sock, &ws);\n    memset((void *)&timeout, '\\0', sizeof(struct timeval));\n    timeout.tv_sec  = (my.timeout > 0)?my.timeout:30;\n    timeout.tv_usec = 0;\n    res = select(C->sock+1, &rs, &ws, NULL, &timeout);\n    if(res < 1){\n      fprintf(stderr, \"socket: connection timed out\\n\");\n      socket_close(C);\n      return -1; \n    } else { \n      /**\n       * If we reconnect and receive EISCONN, then we have a successful connection\n       */\n      res = connect(C->sock, (struct sockaddr *)&cli, sizeof(struct sockaddr_in)); \n      if((res < 0)&&(errno != EISCONN)){\n        NOTIFY(ERROR, \"socket: unable to connect %s:%d\", __FILE__, __LINE__);\n        socket_close(C);\n        return -1; \n      }\n      C->status = S_READING; \n    }\n  } /* end of connect conditional */\n\n  if((__socket_block(C->sock, TRUE)) < 0){\n    NOTIFY(ERROR, \"socket: unable to set socket to non-blocking %s:%d\", __FILE__, __LINE__);\n    return -1; \n  }\n\n  C->connection.status = 1; \n  return(C->sock);\n}", "path": "src\\sock.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/**\n * sleep and usleep work on all supported\n * platforms except solaris, so we'll use\n * those functions on non-solaris, but we\n * still need to sleep. The macro handles\n * that for us.\n */\n", "func_signal": "void\npthread_sleep_np( unsigned int secs )", "code": "{\n#if defined( SOLARIS ) || defined( sun )\n  /* Theoretically, this could fail for sizeof(int)==sizeof(long) and\n   * very large values of secs due to an overflow.\n   * NB: for 64-bit int, that would mean waiting until the year 584543.\n   */\n  pthread_usleep_np (secs*1000000);\n#else\n  sleep(secs);\n#endif/*pthread_sleep_np*/\n\n  return;\n}", "path": "src\\util.c", "repo_name": "tail/siege", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1064}
{"docstring": "/*\n * Initialise the expansion card system.\n * Locate all hardware - interrupt management and\n * actual cards.\n */\n", "func_signal": "static int __init ecard_init(void)", "code": "{\n\tstruct task_struct *task;\n\tint slot, irqhw;\n\n\ttask = kthread_run(ecard_task, NULL, \"kecardd\");\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"Ecard: unable to create kernel thread: %ld\\n\",\n\t\t       PTR_ERR(task));\n\t\treturn PTR_ERR(task);\n\t}\n\n\tprintk(\"Probing expansion cards\\n\");\n\n\tfor (slot = 0; slot < 8; slot ++) {\n\t\tif (ecard_probe(slot, ECARD_EASI) == -ENODEV)\n\t\t\tecard_probe(slot, ECARD_IOC);\n\t}\n\n#ifdef IO_EC_MEMC8_BASE\n\tecard_probe(8, ECARD_IOC);\n#endif\n\n\tirqhw = ecard_probeirqhw();\n\n\tset_irq_chained_handler(IRQ_EXPANSIONCARD,\n\t\t\t\tirqhw ? ecard_irqexp_handler : ecard_irq_handler);\n\n\tecard_proc_init();\n\n\treturn 0;\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Set up the expansion card daemon's page tables.\n */\n", "func_signal": "static void ecard_init_pgtables(struct mm_struct *mm)", "code": "{\n\tstruct vm_area_struct vma;\n\n\t/* We want to set up the page tables for the following mapping:\n\t *  Virtual\tPhysical\n\t *  0x03000000\t0x03000000\n\t *  0x03010000\tunmapped\n\t *  0x03210000\t0x03210000\n\t *  0x03400000\tunmapped\n\t *  0x08000000\t0x08000000\n\t *  0x10000000\tunmapped\n\t *\n\t * FIXME: we don't follow this 100% yet.\n\t */\n\tpgd_t *src_pgd, *dst_pgd;\n\n\tsrc_pgd = pgd_offset(mm, (unsigned long)IO_BASE);\n\tdst_pgd = pgd_offset(mm, IO_START);\n\n\tmemcpy(dst_pgd, src_pgd, sizeof(pgd_t) * (IO_SIZE / PGDIR_SIZE));\n\n\tsrc_pgd = pgd_offset(mm, EASI_BASE);\n\tdst_pgd = pgd_offset(mm, EASI_START);\n\n\tmemcpy(dst_pgd, src_pgd, sizeof(pgd_t) * (EASI_SIZE / PGDIR_SIZE));\n\n\tvma.vm_mm = mm;\n\n\tflush_tlb_range(&vma, IO_START, IO_START + IO_SIZE);\n\tflush_tlb_range(&vma, EASI_START, EASI_START + EASI_SIZE);\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Print a new page of text. Called by dialog_textbox().\n */\n", "func_signal": "static void print_page(WINDOW * win, int height, int width)", "code": "{\n\tint i, passed_end = 0;\n\n\tpage_length = 0;\n\tfor (i = 0; i < height; i++) {\n\t\tprint_line(win, i, width);\n\t\tif (!passed_end)\n\t\t\tpage_length++;\n\t\tif (end_reached && !passed_end)\n\t\t\tpassed_end = 1;\n\t}\n\twnoutrefresh(win);\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* ======================= Interrupt control ============================ */\n", "func_signal": "static void ecard_def_irq_enable(ecard_t *ec, int irqnr)", "code": "{\n#ifdef HAS_EXPMASK\n\tif (irqnr < 4 && have_expmask) {\n\t\thave_expmask |= 1 << irqnr;\n\t\t__raw_writeb(have_expmask, EXPMASK_ENABLE);\n\t}\n#endif\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Enable and disable interrupts from expansion cards.\n * (interrupts are disabled for these functions).\n *\n * They are not meant to be called directly, but via enable/disable_irq.\n */\n", "func_signal": "static void ecard_irq_unmask(unsigned int irqnr)", "code": "{\n\tecard_t *ec = slot_to_ecard(irqnr - 32);\n\n\tif (ec) {\n\t\tif (!ec->ops)\n\t\t\tec->ops = &ecard_default_ops;\n\n\t\tif (ec->claimed && ec->ops->irqenable)\n\t\t\tec->ops->irqenable(ec, irqnr);\n\t\telse\n\t\t\tprintk(KERN_ERR \"ecard: rejecting request to \"\n\t\t\t\t\"enable IRQs for %d\\n\", irqnr);\n\t}\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* ===================== Expansion card daemon ======================== */\n/*\n * Since the loader programs on the expansion cards need to be run\n * in a specific environment, create a separate task with this\n * environment up, and pass requests to this task as and when we\n * need to.\n *\n * This should allow 99% of loaders to be called from Linux.\n *\n * From a security standpoint, we trust the card vendors.  This\n * may be a misplaced trust.\n */\n", "func_signal": "static void ecard_task_reset(struct ecard_request *req)", "code": "{\n\tstruct expansion_card *ec = req->ec;\n\tstruct resource *res;\n\n\tres = ec->slot_no == 8\n\t\t? &ec->resource[ECARD_RES_MEMC]\n\t\t: ec->easi\n\t\t  ? &ec->resource[ECARD_RES_EASI]\n\t\t  : &ec->resource[ECARD_RES_IOCSYNC];\n\n\tecard_loader_reset(res->start, ec->loader);\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * refresh window content\n */\n", "func_signal": "static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,\n\t\t\t\t\t\t\t  int cur_y, int cur_x)", "code": "{\n\tprint_page(box, boxh, boxw);\n\tprint_position(dialog);\n\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\twrefresh(dialog);\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Probe for an expansion card.\n *\n * If bit 1 of the first byte of the card is set, then the\n * card does not exist.\n */\n", "func_signal": "static int __init\necard_probe(int slot, card_type_t type)", "code": "{\n\tecard_t **ecp;\n\tecard_t *ec;\n\tstruct ex_ecid cid;\n\tint i, rc;\n\n\tec = ecard_alloc_card(type, slot);\n\tif (IS_ERR(ec)) {\n\t\trc = PTR_ERR(ec);\n\t\tgoto nomem;\n\t}\n\n\trc = -ENODEV;\n\tif ((ec->podaddr = __ecard_address(ec, type, ECARD_SYNC)) == 0)\n\t\tgoto nodev;\n\n\tcid.r_zero = 1;\n\tecard_readbytes(&cid, ec, 0, 16, 0);\n\tif (cid.r_zero)\n\t\tgoto nodev;\n\n\tec->cid.id\t= cid.r_id;\n\tec->cid.cd\t= cid.r_cd;\n\tec->cid.is\t= cid.r_is;\n\tec->cid.w\t= cid.r_w;\n\tec->cid.manufacturer = ecard_getu16(cid.r_manu);\n\tec->cid.product = ecard_getu16(cid.r_prod);\n\tec->cid.country = cid.r_country;\n\tec->cid.irqmask = cid.r_irqmask;\n\tec->cid.irqoff  = ecard_gets24(cid.r_irqoff);\n\tec->cid.fiqmask = cid.r_fiqmask;\n\tec->cid.fiqoff  = ecard_gets24(cid.r_fiqoff);\n\tec->fiqaddr\t=\n\tec->irqaddr\t= (void __iomem *)ioaddr(ec->podaddr);\n\n\tif (ec->cid.is) {\n\t\tec->irqmask = ec->cid.irqmask;\n\t\tec->irqaddr += ec->cid.irqoff;\n\t\tec->fiqmask = ec->cid.fiqmask;\n\t\tec->fiqaddr += ec->cid.fiqoff;\n\t} else {\n\t\tec->irqmask = 1;\n\t\tec->fiqmask = 4;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(blacklist); i++)\n\t\tif (blacklist[i].manufacturer == ec->cid.manufacturer &&\n\t\t    blacklist[i].product == ec->cid.product) {\n\t\t\tec->card_desc = blacklist[i].type;\n\t\t\tbreak;\n\t\t}\n\n\t/*\n\t * hook the interrupt handlers\n\t */\n\tif (slot < 8) {\n\t\tec->irq = 32 + slot;\n\t\tset_irq_chip(ec->irq, &ecard_chip);\n\t\tset_irq_handler(ec->irq, handle_level_irq);\n\t\tset_irq_flags(ec->irq, IRQF_VALID);\n\t}\n\n#ifdef IO_EC_MEMC8_BASE\n\tif (slot == 8)\n\t\tec->irq = 11;\n#endif\n#ifdef CONFIG_ARCH_RPC\n\t/* On RiscPC, only first two slots have DMA capability */\n\tif (slot < 2)\n\t\tec->dma = 2 + slot;\n#endif\n\n\tfor (ecp = &cards; *ecp; ecp = &(*ecp)->next);\n\n\t*ecp = ec;\n\tslot_to_expcard[slot] = ec;\n\n\tdevice_register(&ec->dev);\n\n\treturn 0;\n\n nodev:\n\tecard_free_card(ec);\n nomem:\n\treturn rc;\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* ======================= Mid-level card control ===================== */\n", "func_signal": "static void\necard_readbytes(void *addr, ecard_t *ec, int off, int len, int useld)", "code": "{\n\tstruct ecard_request req;\n\n\treq.fn\t\t= ecard_task_readbytes;\n\treq.ec\t\t= ec;\n\treq.address\t= off;\n\treq.length\t= len;\n\treq.use_loader\t= useld;\n\treq.buffer\t= addr;\n\n\tecard_call(&req);\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Wake the expansion card daemon to action our request.\n *\n * FIXME: The test here is not sufficient to detect if the\n * kcardd is running.\n */\n", "func_signal": "static void ecard_call(struct ecard_request *req)", "code": "{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\n\treq->complete = &completion;\n\n\tmutex_lock(&ecard_mutex);\n\tecard_req = req;\n\twake_up(&ecard_wait);\n\n\t/*\n\t * Now wait for kecardd to run.\n\t */\n\twait_for_completion(&completion);\n\tmutex_unlock(&ecard_mutex);\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Display text from a file in a dialog box.\n */\n", "func_signal": "int dialog_textbox(const char *title, const char *tbuf,\n\t\t   int initial_height, int initial_width)", "code": "{\n\tint i, x, y, cur_x, cur_y, key = 0;\n\tint height, width, boxh, boxw;\n\tint passed_end;\n\tWINDOW *dialog, *box;\n\n\tbegin_reached = 1;\n\tend_reached = 0;\n\tpage_length = 0;\n\thscroll = 0;\n\tbuf = tbuf;\n\tpage = buf;\t/* page is pointer to start of page to be displayed */\n\ndo_resize:\n\tgetmaxyx(stdscr, height, width);\n\tif (height < 8 || width < 8)\n\t\treturn -ERRDISPLAYTOOSMALL;\n\tif (initial_height != 0)\n\t\theight = initial_height;\n\telse\n\t\tif (height > 4)\n\t\t\theight -= 4;\n\t\telse\n\t\t\theight = 0;\n\tif (initial_width != 0)\n\t\twidth = initial_width;\n\telse\n\t\tif (width > 5)\n\t\t\twidth -= 5;\n\t\telse\n\t\t\twidth = 0;\n\n\t/* center dialog box on screen */\n\tx = (COLS - width) / 2;\n\ty = (LINES - height) / 2;\n\n\tdraw_shadow(stdscr, y, x, height, width);\n\n\tdialog = newwin(height, width, y, x);\n\tkeypad(dialog, TRUE);\n\n\t/* Create window for box region, used for scrolling text */\n\tboxh = height - 4;\n\tboxw = width - 2;\n\tbox = subwin(dialog, boxh, boxw, y + 1, x + 1);\n\twattrset(box, dlg.dialog.atr);\n\twbkgdset(box, dlg.dialog.atr & A_COLOR);\n\n\tkeypad(box, TRUE);\n\n\t/* register the new window, along with its borders */\n\tdraw_box(dialog, 0, 0, height, width,\n\t\t dlg.dialog.atr, dlg.border.atr);\n\n\twattrset(dialog, dlg.border.atr);\n\tmvwaddch(dialog, height - 3, 0, ACS_LTEE);\n\tfor (i = 0; i < width - 2; i++)\n\t\twaddch(dialog, ACS_HLINE);\n\twattrset(dialog, dlg.dialog.atr);\n\twbkgdset(dialog, dlg.dialog.atr & A_COLOR);\n\twaddch(dialog, ACS_RTEE);\n\n\tprint_title(dialog, title, width);\n\n\tprint_button(dialog, gettext(\" Exit \"), height - 2, width / 2 - 4, TRUE);\n\twnoutrefresh(dialog);\n\tgetyx(dialog, cur_y, cur_x);\t/* Save cursor position */\n\n\t/* Print first page of text */\n\tattr_clear(box, boxh, boxw, dlg.dialog.atr);\n\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\n\twhile ((key != KEY_ESC) && (key != '\\n')) {\n\t\tkey = wgetch(dialog);\n\t\tswitch (key) {\n\t\tcase 'E':\t/* Exit */\n\t\tcase 'e':\n\t\tcase 'X':\n\t\tcase 'x':\n\t\t\tdelwin(box);\n\t\t\tdelwin(dialog);\n\t\t\treturn 0;\n\t\tcase 'g':\t/* First page */\n\t\tcase KEY_HOME:\n\t\t\tif (!begin_reached) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\tpage = buf;\n\t\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t\t cur_y, cur_x);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'G':\t/* Last page */\n\t\tcase KEY_END:\n\n\t\t\tend_reached = 1;\n\t\t\t/* point to last char in buf */\n\t\t\tpage = buf + strlen(buf);\n\t\t\tback_lines(boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'K':\t/* Previous line */\n\t\tcase 'k':\n\t\tcase KEY_UP:\n\t\t\tif (!begin_reached) {\n\t\t\t\tback_lines(page_length + 1);\n\n\t\t\t\t/* We don't call print_page() here but use\n\t\t\t\t * scrolling to ensure faster screen update.\n\t\t\t\t * However, 'end_reached' and 'page_length'\n\t\t\t\t * should still be updated, and 'page' should\n\t\t\t\t * point to start of next page. This is done\n\t\t\t\t * by calling get_line() in the following\n\t\t\t\t * 'for' loop. */\n\t\t\t\tscrollok(box, TRUE);\n\t\t\t\twscrl(box, -1);\t/* Scroll box region down one line */\n\t\t\t\tscrollok(box, FALSE);\n\t\t\t\tpage_length = 0;\n\t\t\t\tpassed_end = 0;\n\t\t\t\tfor (i = 0; i < boxh; i++) {\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\t/* print first line of page */\n\t\t\t\t\t\tprint_line(box, 0, boxw);\n\t\t\t\t\t\twnoutrefresh(box);\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* Called to update 'end_reached' and 'page' */\n\t\t\t\t\t\tget_line();\n\t\t\t\t\tif (!passed_end)\n\t\t\t\t\t\tpage_length++;\n\t\t\t\t\tif (end_reached && !passed_end)\n\t\t\t\t\t\tpassed_end = 1;\n\t\t\t\t}\n\n\t\t\t\tprint_position(dialog);\n\t\t\t\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\t\t\t\twrefresh(dialog);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'B':\t/* Previous page */\n\t\tcase 'b':\n\t\tcase KEY_PPAGE:\n\t\t\tif (begin_reached)\n\t\t\t\tbreak;\n\t\t\tback_lines(page_length + boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'J':\t/* Next line */\n\t\tcase 'j':\n\t\tcase KEY_DOWN:\n\t\t\tif (!end_reached) {\n\t\t\t\tbegin_reached = 0;\n\t\t\t\tscrollok(box, TRUE);\n\t\t\t\tscroll(box);\t/* Scroll box region up one line */\n\t\t\t\tscrollok(box, FALSE);\n\t\t\t\tprint_line(box, boxh - 1, boxw);\n\t\t\t\twnoutrefresh(box);\n\t\t\t\tprint_position(dialog);\n\t\t\t\twmove(dialog, cur_y, cur_x);\t/* Restore cursor position */\n\t\t\t\twrefresh(dialog);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\t/* Next page */\n\t\tcase ' ':\n\t\t\tif (end_reached)\n\t\t\t\tbreak;\n\n\t\t\tbegin_reached = 0;\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase '0':\t/* Beginning of line */\n\t\tcase 'H':\t/* Scroll left */\n\t\tcase 'h':\n\t\tcase KEY_LEFT:\n\t\t\tif (hscroll <= 0)\n\t\t\t\tbreak;\n\n\t\t\tif (key == '0')\n\t\t\t\thscroll = 0;\n\t\t\telse\n\t\t\t\thscroll--;\n\t\t\t/* Reprint current page to scroll horizontally */\n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'L':\t/* Scroll right */\n\t\tcase 'l':\n\t\tcase KEY_RIGHT:\n\t\t\tif (hscroll >= MAX_LEN)\n\t\t\t\tbreak;\n\t\t\thscroll++;\n\t\t\t/* Reprint current page to scroll horizontally */\n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\tkey = on_key_esc(dialog);\n\t\t\tbreak;\n\t\tcase KEY_RESIZE:\n\t\t\tback_lines(height);\n\t\t\tdelwin(box);\n\t\t\tdelwin(dialog);\n\t\t\ton_key_resize();\n\t\t\tgoto do_resize;\n\t\t}\n\t}\n\tdelwin(box);\n\tdelwin(dialog);\n\treturn key;\t\t/* ESC pressed */\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* do some startup allocations not currently performed by usb_serial_probe() */\n", "func_signal": "static int belkin_sa_startup(struct usb_serial *serial)", "code": "{\n\tstruct usb_device *dev = serial->dev;\n\tstruct belkin_sa_private *priv;\n\n\t/* allocate the private data structure */\n\tpriv = kmalloc(sizeof(struct belkin_sa_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -1; /* error */\n\t/* set initial values for control structures */\n\tspin_lock_init(&priv->lock);\n\tpriv->control_state = 0;\n\tpriv->last_lsr = 0;\n\tpriv->last_msr = 0;\n\t/* see comments at top of file */\n\tpriv->bad_flow_control =\n\t\t(le16_to_cpu(dev->descriptor.bcdDevice) <= 0x0206) ? 1 : 0;\n\tdev_info(&dev->dev, \"bcdDevice: %04x, bfc: %d\\n\",\n\t\t\t\t\tle16_to_cpu(dev->descriptor.bcdDevice),\n\t\t\t\t\tpriv->bad_flow_control);\n\n\tinit_waitqueue_head(&serial->port[0]->write_wait);\n\tusb_set_serial_port_data(serial->port[0], priv);\n\n\treturn 0;\n}", "path": "drivers\\usb\\serial\\belkin_sa.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* belkin_sa_open */\n", "func_signal": "static void belkin_sa_close(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct file *filp)", "code": "{\n\tdbg(\"%s port %d\", __func__, port->number);\n\n\t/* shutdown our bulk reads and writes */\n\tusb_kill_urb(port->write_urb);\n\tusb_kill_urb(port->read_urb);\n\tusb_kill_urb(port->interrupt_in_urb);\n}", "path": "drivers\\usb\\serial\\belkin_sa.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Go back 'n' lines in text. Called by dialog_textbox().\n * 'page' will be updated to point to the desired line in 'buf'.\n */\n", "func_signal": "static void back_lines(int n)", "code": "{\n\tint i;\n\n\tbegin_reached = 0;\n\t/* Go back 'n' lines */\n\tfor (i = 0; i < n; i++) {\n\t\tif (*page == '\\0') {\n\t\t\tif (end_reached) {\n\t\t\t\tend_reached = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (page == buf) {\n\t\t\tbegin_reached = 1;\n\t\t\treturn;\n\t\t}\n\t\tpage--;\n\t\tdo {\n\t\t\tif (page == buf) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpage--;\n\t\t} while (*page != '\\n');\n\t\tpage++;\n\t}\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Print current position\n */\n", "func_signal": "static void print_position(WINDOW * win)", "code": "{\n\tint percent;\n\n\twattrset(win, dlg.position_indicator.atr);\n\twbkgdset(win, dlg.position_indicator.atr & A_COLOR);\n\tpercent = (page - buf) * 100 / strlen(buf);\n\twmove(win, getmaxy(win) - 3, getmaxx(win) - 9);\n\twprintw(win, \"(%3d%%)\", percent);\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Return current line of text. Called by dialog_textbox() and print_line().\n * 'page' should point to start of current line before calling, and will be\n * updated to point to start of next line.\n */\n", "func_signal": "static char *get_line(void)", "code": "{\n\tint i = 0;\n\tstatic char line[MAX_LEN + 1];\n\n\tend_reached = 0;\n\twhile (*page != '\\n') {\n\t\tif (*page == '\\0') {\n\t\t\tif (!end_reached) {\n\t\t\t\tend_reached = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (i < MAX_LEN)\n\t\t\tline[i++] = *(page++);\n\t\telse {\n\t\t\t/* Truncate lines longer than MAX_LEN characters */\n\t\t\tif (i == MAX_LEN)\n\t\t\t\tline[i++] = '\\0';\n\t\t\tpage++;\n\t\t}\n\t}\n\tif (i <= MAX_LEN)\n\t\tline[i] = '\\0';\n\tif (!end_reached)\n\t\tpage++;\t\t/* move pass '\\n' */\n\n\treturn line;\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Before rebooting, we must make sure that the expansion card is in a\n * sensible state, so it can be re-detected.  This means that the first\n * page of the ROM must be visible.  We call the expansion cards reset\n * handler, if any.\n */\n", "func_signal": "static void ecard_drv_shutdown(struct device *dev)", "code": "{\n\tstruct expansion_card *ec = ECARD_DEV(dev);\n\tstruct ecard_driver *drv = ECARD_DRV(dev->driver);\n\tstruct ecard_request req;\n\n\tif (dev->driver) {\n\t\tif (drv->shutdown)\n\t\t\tdrv->shutdown(ec);\n\t\tec->claimed = 0;\n\t}\n\n\t/*\n\t * If this card has a loader, call the reset handler.\n\t */\n\tif (ec->loader) {\n\t\treq.fn = ecard_task_reset;\n\t\treq.ec = ec;\n\t\tecard_call(&req);\n\t}\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/* belkin_sa_set_termios */\n", "func_signal": "static void belkin_sa_break_ctl(struct tty_struct *tty, int break_state)", "code": "{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\n\tif (BSA_USB_CMD(BELKIN_SA_SET_BREAK_REQUEST, break_state ? 1 : 0) < 0)\n\t\tdev_err(&port->dev, \"Set break_ctl %d\\n\", break_state);\n}", "path": "drivers\\usb\\serial\\belkin_sa.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n * Print a new line of text. Called by dialog_textbox() and print_page().\n */\n", "func_signal": "static void print_line(WINDOW * win, int row, int width)", "code": "{\n\tint y, x;\n\tchar *line;\n\n\tline = get_line();\n\tline += MIN(strlen(line), hscroll);\t/* Scroll horizontally */\n\twmove(win, row, 0);\t/* move cursor to correct line */\n\twaddch(win, ' ');\n\twaddnstr(win, line, MIN(strlen(line), width - 2));\n\n\tgetyx(win, y, x);\n\t/* Clear 'residue' of previous line */\n#if OLD_NCURSES\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < width - x; i++)\n\t\t\twaddch(win, ' ');\n\t}\n#else\n\twclrtoeol(win);\n#endif\n}", "path": "scripts\\kconfig\\lxdialog\\textbox.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/*\n *\tECARD \"bus\"\n */\n", "func_signal": "static const struct ecard_id *\necard_match_device(const struct ecard_id *ids, struct expansion_card *ec)", "code": "{\n\tint i;\n\n\tfor (i = 0; ids[i].manufacturer != 65535; i++)\n\t\tif (ec->cid.manufacturer == ids[i].manufacturer &&\n\t\t    ec->cid.product == ids[i].product)\n\t\t\treturn ids + i;\n\n\treturn NULL;\n}", "path": "arch\\arm\\kernel\\ecard.c", "repo_name": "erasmux/hero-2.6.29-flykernel", "stars": 22, "license": "other", "language": "c", "size": 85648}
{"docstring": "/**\n * Allocate and initialize default word boundary bytes to all 7-bit\n * ascii characters except letters, numbers, and underscore.\n */\n", "func_signal": "void bw_initialize_default_word_boundary_bytes()", "code": "{\n    if (default_word_boundary_bytes == NULL) {\n        default_word_boundary_bytes = calloc(256, 1);\n    }\n\n    /* Initialize word boundary chars: all single bytes < 128 except\n       letters, numbers, and underscore */\n    memset(default_word_boundary_bytes, 1, 128);\n    set_byte_mask(default_word_boundary_bytes, default_word_boundary_exceptions, 0);\n    default_word_boundary_bytes[default_html_token] = 1;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Add a byte sequence to the list of words this trie can replace. Any\n * bytes are allowed and no case folding is applied.\n *\n * @param trie the trie to add the byte sequence to\n * @param bytes the bytes to add\n * @param c the length of the byte sequence\n * @return integer number of nodes added to the trie to support this byte sequence\n */\n", "func_signal": "int bw_add_bytes(struct bw_trie_t *trie, byte *bytes, unsigned int c)", "code": "{\n    unsigned int i = 0, added = 0;\n    struct bw_node_t *node = trie->root;\n\n    while (i < c) {\n        if (node->next[ bytes[i] ] == NULL) {\n            node->next[ bytes[i] ] = bw_create_node();\n            added++;\n            node->has_next = 1;\n        }\n        node = node->next[ bytes[i] ];\n        i++;\n    }\n    node->is_terminal = 1;\n    return added;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/*\n    start at root of trie and first byte\n    if byte is not in trie, go to next byte and repeat\n    if byte is in trie, save position as bad_word_start_maybe, advance byte and advance down trie\n      while byte is in trie, continue advancing each\n      if we get to the point where there is nothing in the next[] array on the trie node, we've reached the end of the\n        word, so replace from bad_word_start_maybe+1 to current byte with *s, and resume with root of trie and next byte\n      if we get to the point where the next[] array is not empty but does not contain an entry for the current byte\n        then we've diverged from the stem that matches, so don't do any replacement and start re-parsing at\n        bad_word_start_maybe+1\n\n    */\n", "func_signal": "static int bw_replace_proper(struct bw_node_t *root, byte *modified_bytes, byte *bytes_to_walk, int len, byte replacement, int check_multibyte, byte *word_boundary_chars)", "code": "{\n    int match_start_maybe, i = 0, shrunk_bytes = 0, previous_terminal = 0;\n    int endok = 0;\n    struct bw_node_t *current_node;\n\n    while (i < len) {\n        if ((! bw_node_has_next(root, bytes_to_walk[i])) // no matches at start\n            || (! boundary_before_word(word_boundary_chars, i, bytes_to_walk)))\n            {\n                i++;\n            }\n        else {\n            match_start_maybe = i;\n            current_node = root;\n            previous_terminal = 0;\n            do {\n                current_node = current_node->next[bytes_to_walk[i]];\n                i++;\n                if (current_node->is_terminal\n                    && boundary_after_word(word_boundary_chars, i, len, bytes_to_walk))\n                    {\n                        previous_terminal = i;\n                    }\n            }\n            while (bw_node_has_next(current_node, bytes_to_walk[i]));\n\n            /* If we've stopped advancing because we've reached a character in the\n             * text which doesn't match the next byte in the trie -- then check to\n             * see if there was a previous node on our traversal that was marked\n             * as terminal -- that means even though we didn't match the longer\n             * word, there was a previous shorter prefix that we should treat as\n             * a match \n             */\n            if ((! current_node->is_terminal) && previous_terminal) {\n                i = previous_terminal;\n            }\n\n            /* if we've reached the end of the word, replace */\n            if (((! current_node->has_next) && boundary_after_word(word_boundary_chars, i, len, bytes_to_walk)) || previous_terminal) {\n                /* BAZ-23266:\n                 * i and match_start_maybe are positions in bytes_to_walk -- the byte array that is not shrunken when\n                 * we replace multibyte characters with the single-byte replacement character. So when subtracting one\n                 * from the other, we don't need to *also* subtract shrunk_bytes, we just want the difference in position.\n                 * shrunk_bytes is only necessary when comparing or correlating positions in bytes_to_walk (which\n                 * hasn't been shrunk) and modified_bytes (which may have been shrunk) */\n                if (check_multibyte && string_is_multibyte(modified_bytes + match_start_maybe - shrunk_bytes, i - match_start_maybe)) {\n                    int j = match_start_maybe - shrunk_bytes + character_length(modified_bytes + match_start_maybe - shrunk_bytes);\n                    /* Now j is on the second character */\n                    while (j < (i - shrunk_bytes)) {\n                        int char_len = character_length(modified_bytes + j);\n                        modified_bytes[j] = replacement;\n                        memmove(modified_bytes + j + 1, modified_bytes + j + char_len, len - (j + char_len) - shrunk_bytes);\n                        j += 1; /* advance j past the 1-byte '*' which is now the current char */\n                        shrunk_bytes += char_len - 1;\n                    }\n                } else {\n                    /* BAZ-23266: i and match_start_maybe are both positions in bytes_to_walk -- so there's no need to\n                     * subtract shrunk_bytes when calculating the length of the non-multibyte string to replace here */\n                    memset(modified_bytes + match_start_maybe + 1 - shrunk_bytes, replacement, i - (match_start_maybe + 1));\n                }\n            }\n            else { /* diverging from stem, start reparsing */\n                i = match_start_maybe + 1;\n            }\n        }\n    }\n\n    if (check_multibyte && (shrunk_bytes > 0)) {\n        memset(modified_bytes + len - shrunk_bytes, 0, shrunk_bytes);\n    }\n\n    return len - shrunk_bytes;\n\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Replace sequences in text that match words added to the trie. If the trie\n * has a folding trie, then it is used to make the replacements case-insensitive.\n *\n * @param trie Trie containing words to replace and optional folding trie\n * @param text text to process for replacements\n * @param replacement byte to use for replacements in matches\n * @return byte* newly allocated copy of the text with replacements\n */\n", "func_signal": "byte *bw_replace_text(struct bw_trie_t *trie, byte *text, byte replacement, int wordbound)", "code": "{\n  int text_len = strlen((char *)text);\n\n    byte *modified_text = (byte *) calloc(1, text_len + 1); /* allocate extra byte for trailing null */\n    memcpy(modified_text, text, text_len);\n\n    byte *text_to_walk;\n    if (trie->case_insensitive && trie->folding_trie) {\n        text_to_walk = case_fold_lower(trie->folding_trie, text, text_len);\n    } else {\n        text_to_walk = text;\n    }\n\n    bw_replace_proper(trie->root, modified_text, text_to_walk, text_len, replacement, 1, wordbound ? trie->word_boundary_chars : NULL);\n\n    if (text_to_walk != text) {\n        free(text_to_walk);\n    }\n\n    return modified_text;\n\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Deallocate default word boundary bytes\n */\n", "func_signal": "void bw_free_default_word_boundary_bytes()", "code": "{\n    if (default_word_boundary_bytes) {\n        free(default_word_boundary_bytes);\n        default_word_boundary_bytes = NULL;\n    }\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Checks for a word boundary after the current word (at i)\n */\n", "func_signal": "static inline int boundary_after_word(byte *boundaries, int i, int len, byte *bytes)", "code": "{\n    return (! boundaries)        /* no boundaries to check */\n        || (i >= len)            /* string end is a boundary */\n        || boundaries[bytes[i]]; /* followed by a boundary */\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Set the entries in the mask indicated by the bytes of text to\n * value.\n */\n", "func_signal": "void set_byte_mask(byte *mask, byte *text, int value)", "code": "{\n    byte *b = text;\n    if (mask && text) {\n        while (*b) {\n            mask[*b] = value;\n            b++;\n        }\n    }\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Free the memory allocated for a trie and all of its nodes. This\n * does NOT free the memory allocated for the folding trie the\n * trie may be using, if any.\n *\n * @param trie the trie to free\n */\n", "func_signal": "void bw_free_trie(struct bw_trie_t *trie)", "code": "{\n    if (trie) {\n        if (trie->root) {\n            bw_free_node(trie->root);\n        }\n        if (trie->word_boundary_chars && trie->word_boundary_chars != default_word_boundary_bytes) {\n            free(trie->word_boundary_chars);\n        }\n        free(trie);\n    }\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Add an uppercase -> lowercase mapping to a case folding trie.\n *\n * @param root the case folding trie to operate on\n * @param upper uppercase byte sequence\n * @param lower corresponding lowercase byte sequence\n */\n", "func_signal": "void case_fold_map_add(struct case_fold_branch_t *root, byte *upper, byte *lower)", "code": "{\n    int i;\n    int upper_length = strlen((char *) upper);\n    int lower_length = strlen((char *) lower);\n\n    assert(upper_length <= 4);\n    assert(lower_length <= 4);\n\n    for (i = 0; i < upper_length; i++) {\n        if (root->next[upper[i]] == NULL) {\n            root->next[upper[i]] = (struct case_fold_branch_t *) calloc(1, sizeof(struct case_fold_branch_t));\n        }\n        root = root->next[upper[i]];\n    }\n    /* Now we're at the last branch, add the leaf info */\n    root->leaf = (struct case_fold_leaf_t *) calloc(1, sizeof(struct case_fold_leaf_t));\n    root->leaf->folded_length = lower_length;\n    memcpy(root->leaf->folded, lower, lower_length);\n}", "path": "case-fold.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Helper function for bw_walk_trie, requires\n * explicit level to be specified\n *\n * @param n node to invoke callback on\n * @param level descent level into trie\n * @param callback callback function to invoke on each node\n */\n", "func_signal": "static void bw_walk_trie_proper(struct bw_node_t *n, int level, void (callback)(int, byte))", "code": "{\n    int i;\n    for (i = 0; i < 255; i++) {\n        if (n->next[i] != NULL) {\n            callback(level, i);\n            bw_walk_trie_proper(n->next[i], level + 1, callback);\n        }\n    }\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Find a leaf that holds the lowercase byte sequence corresponding to the uppercase\n * sequence that starts at char_start\n *\n * @param root the case folding trie to operate on\n * @param char_start the start of the uppercase sequence\n * @return NULL if there's no match\n * @return case_fold_leaf_t containing lowercase sequence and length if there's a match\n */\n", "func_signal": "struct case_fold_leaf_t *case_fold_find(struct case_fold_branch_t *root, byte *char_start)", "code": "{\n    while (1) {\n        if (root->next[*char_start]) {\n            root = root->next[*char_start];\n            char_start++;\n        }\n        else {\n            if (root->leaf) {\n                return root->leaf;\n            } \n            else {\n                return NULL;\n            }\n        }\n    }\n\n}", "path": "case-fold.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Create a new boxwood node. \n * The new node is marked as a leaf since it starts out having\n * nothing in its \"next\" array.\n *\n * @return bw_node_t*\n */\n", "func_signal": "static struct bw_node_t *bw_create_node()", "code": "{\n    struct bw_node_t *n = (struct bw_node_t *) calloc(1, sizeof(struct bw_node_t));\n    n->has_next = 0;\n    n->is_terminal = 0;\n    return n;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Add a word to the list of words this trie can replace. The text must be a\n * valid UTF-8 string. If the trie has a folding trie, the word will be\n * matched case-insensitively when replacement is done.\n *\n * @param trie the trie to add the word to\n * @param text the text of the word to add\n * @return integer number of nodes added to the trie to support this word\n */\n", "func_signal": "int bw_add_text(struct bw_trie_t *trie, byte *text)", "code": "{\n    byte *text_to_add = (trie->case_insensitive && trie->folding_trie) ? case_fold_lower(trie->folding_trie, text, strlen((char *)text)) : text;\n    int added = bw_add_bytes(trie, text_to_add, strlen((char *)text_to_add));\n    \n    if (text_to_add != text) {\n        free(text_to_add);\n    }\n    \n    return added;\n\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Create a new boxwood trie, providing a folding trie if you want the trie\n * to do case-insensitive matching.\n * \n * @param folding_trie if provided, the replacements will be case-insensitive\n *  as per the mappings in this trie\n * @return bw_trie_t*\n */\n", "func_signal": "struct bw_trie_t *bw_create_trie(struct case_fold_branch_t *folding_trie)", "code": "{\n    struct bw_trie_t *trie = (struct bw_trie_t *) calloc(1, sizeof(struct bw_trie_t));\n    trie->root = bw_create_node();\n    if (folding_trie) {\n        trie->case_insensitive = 1;\n        trie->folding_trie = folding_trie;\n    } else {\n        trie->case_insensitive = 0;\n    }\n\n    trie->word_boundary_chars = default_word_boundary_bytes;\n\n    return trie;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Determine whether a string contains at least one multibyte character.\n * The string must be encoded as UTF-8.\n * @see http://canonical.org/~kragen/strlen-utf8.html\n *\n * @param s the string to scan\n * @param len the length of s in bytes\n * @return integer\n */\n", "func_signal": "static inline int string_is_multibyte(unsigned char *s, int len)", "code": "{\n    int i = 0;\n    while (i < len) {\n        if ((s[i] & 0x80) > 0) { return 1; }\n        i++;\n    }\n    return 0;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Replace sub-sequences in the byte sequence that match words added to the trie. No\n * case-sensitivity is applied and the byte sequences are not treated as UTF-8\n * characters.\n *\n * @param trie Trie containing words to replace and optional folding trie\n * @param bytes bytes to process for replacements\n * @param c length of bytes\n * @param replacement byte to use for replacements in matches\n * @return byte* newly allocated copy of the byte sequence with replacements\n */\n", "func_signal": "byte *bw_replace_binary(struct bw_trie_t *trie, byte *bytes, int c, byte replacement, int wordbound)", "code": "{\n    \n    byte *modified_bytes = (byte *) calloc(1, c);\n    memcpy(modified_bytes, bytes, c);\n\n    bw_replace_proper(trie->root, modified_bytes, bytes, c, replacement, 0, wordbound ? trie->word_boundary_chars : NULL);\n    \n    return modified_bytes;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Create a word boundary byte mask from the supplied character list\n * and assign it to the trie.\n */\n", "func_signal": "void bw_set_word_boundary_bytes(struct bw_trie_t *trie, byte *text)", "code": "{\n    if (trie->word_boundary_chars && trie->word_boundary_chars != default_word_boundary_bytes) {\n        free(trie->word_boundary_chars);\n    }\n    trie->word_boundary_chars = calloc(256, 1);\n    set_byte_mask(trie->word_boundary_chars, text, 1);\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/* }}} */\n", "func_signal": "PHP_FUNCTION(boxwood_new)", "code": "{\n    zend_bool case_sensitive = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &case_sensitive) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    struct bw_trie_t *trie = bw_create_trie((struct case_fold_branch_t *) (case_sensitive ? NULL : BOXWOOD_G(folding_trie)));\n    ZEND_REGISTER_RESOURCE(return_value, trie, le_bw_trie);\n}", "path": "php_boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Compute the length (in bytes) of the UTF-8 character whose\n * first byte is pointed to by s. \n *\n * @param s byte to check\n * @return integer\n */\n", "func_signal": "static inline int character_length(byte *s)", "code": "{\n    if (s[0] < 0x80) {\n        return 1;\n    }\n    else if ((s[0] & 0xE0) == 0xC0) {\n        return 2;\n    } \n    else if ((s[0] & 0xF0) == 0xE0) {\n        return 3;\n    }\n    else if ((s[0] & 0xF8) == 0xF0) {\n        return 4;\n    }\n    else {\n        // uh oh\n        return 1;\n    }\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/**\n * Free the memory allocated for a node and all of its child nodes\n *\n * @param node the node to free\n */\n", "func_signal": "void bw_free_node(struct bw_node_t *node)", "code": "{\n    int i;\n    if (NULL == node) {\n        return;\n    }\n    for (i = 0; i < 255; i++) {\n        if (node->next[i] != NULL) {\n            bw_free_node(node->next[i]);\n        }\n    }\n    free(node);\n    return;\n}", "path": "boxwood.c", "repo_name": "ning/boxwood", "stars": 27, "license": "None", "language": "c", "size": 123}
{"docstring": "/*\n * convert from string to TCP port number\n */\n", "func_signal": "static int get_port(char *service)", "code": "{\n\tstruct servent *sp;\n\n\tif ((sp = getservbyname(service, \"tcp\")) == NULL){\n\t\tfprintf(stderr, _(\"service '%s' is not found in /etc/services\\n\"), service);\n\t\treturn -1;\n\t}\n\treturn sp->s_port;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/* expected size used to encode one unicode char */\n", "func_signal": "static int utf8_unichar_to_encoded_len(int unichar)", "code": "{\n\tif (unichar < 0x80)\n\t\treturn 1;\n\tif (unichar < 0x800)\n\t\treturn 2;\n\tif (unichar < 0x10000)\n\t\treturn 3;\n\tif (unichar < 0x200000)\n\t\treturn 4;\n\tif (unichar < 0x4000000)\n\t\treturn 5;\n\treturn 6;\n}", "path": "alsactl\\init_utils_string.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * print usage\n */\n", "func_signal": "static void usage(void)", "code": "{\n\tprintf(_(\"aseqnet - network client/server on ALSA sequencer\\n\"));\n\tprintf(_(\"  Copyright (C) 1999 Takashi Iwai\\n\"));\n\tprintf(_(\"usage:\\n\"));\n\tprintf(_(\"  server mode: aseqnet [-options]\\n\"));\n\tprintf(_(\"  client mode: aseqnet [-options] server_host\\n\"));\n\tprintf(_(\"options:\\n\"));\n\tprintf(_(\"  -p,--port # : sepcify TCP port (digit or service name)\\n\"));\n\tprintf(_(\"  -s,--source addr : read from given addr (client:port)\\n\"));\n\tprintf(_(\"  -d,--dest addr : write to given addr (client:port)\\n\"));\n\tprintf(_(\"  -v, --verbose : print verbose messages\\n\"));\n\tprintf(_(\"  -i, --info : print certain received events\\n\"));\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * list subscribers\n */\n", "func_signal": "static void list_subscribers(snd_seq_t *seq, const snd_seq_addr_t *addr)", "code": "{\n\tsnd_seq_query_subscribe_t *subs;\n\tsnd_seq_query_subscribe_alloca(&subs);\n\tsnd_seq_query_subscribe_set_root(subs, addr);\n\tlist_each_subs(seq, subs, SND_SEQ_QUERY_SUBS_READ, _(\"Connecting To\"));\n\tlist_each_subs(seq, subs, SND_SEQ_QUERY_SUBS_WRITE, _(\"Connected From\"));\n}", "path": "seq\\aconnect\\aconnect.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * remove all (exported) connections\n */\n", "func_signal": "static void remove_connection(snd_seq_t *seq, snd_seq_client_info_t *cinfo,\n\t\t\t      snd_seq_port_info_t *pinfo, int count)", "code": "{\n\tsnd_seq_query_subscribe_t *query;\n\tsnd_seq_port_info_t *port;\n\tsnd_seq_port_subscribe_t *subs;\n\n\tsnd_seq_query_subscribe_alloca(&query);\n\tsnd_seq_query_subscribe_set_root(query, snd_seq_port_info_get_addr(pinfo));\n\tsnd_seq_query_subscribe_set_type(query, SND_SEQ_QUERY_SUBS_READ);\n\tsnd_seq_query_subscribe_set_index(query, 0);\n\n\tsnd_seq_port_info_alloca(&port);\n\tsnd_seq_port_subscribe_alloca(&subs);\n\n\twhile (snd_seq_query_port_subscribers(seq, query) >= 0) {\n\t\tconst snd_seq_addr_t *sender = snd_seq_query_subscribe_get_root(query);\n\t\tconst snd_seq_addr_t *dest = snd_seq_query_subscribe_get_addr(query);\n\n\t\tif (snd_seq_get_any_port_info(seq, dest->client, dest->port, port) < 0 ||\n\t\t    !(snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_SUBS_WRITE) ||\n\t\t    (snd_seq_port_info_get_capability(port) & SND_SEQ_PORT_CAP_NO_EXPORT)) {\n\t\t\tsnd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tsnd_seq_port_subscribe_set_queue(subs, snd_seq_query_subscribe_get_queue(query));\n\t\tsnd_seq_port_subscribe_set_sender(subs, sender);\n\t\tsnd_seq_port_subscribe_set_dest(subs, dest);\n\t\tif (snd_seq_unsubscribe_port(seq, subs) < 0) {\n\t\t\tsnd_seq_query_subscribe_set_index(query, snd_seq_query_subscribe_get_index(query) + 1);\n\t\t}\n\t}\n}", "path": "seq\\aconnect\\aconnect.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * list subscribers of specified type\n */\n", "func_signal": "static void list_each_subs(snd_seq_t *seq, snd_seq_query_subscribe_t *subs, int type, const char *msg)", "code": "{\n\tint count = 0;\n\tsnd_seq_query_subscribe_set_type(subs, type);\n\tsnd_seq_query_subscribe_set_index(subs, 0);\n\twhile (snd_seq_query_port_subscribers(seq, subs) >= 0) {\n\t\tconst snd_seq_addr_t *addr;\n\t\tif (count++ == 0)\n\t\t\tprintf(\"\\t%s: \", msg);\n\t\telse\n\t\t\tprintf(\", \");\n\t\taddr = snd_seq_query_subscribe_get_addr(subs);\n\t\tprintf(\"%d:%d\", addr->client, addr->port);\n\t\tif (snd_seq_query_subscribe_get_exclusive(subs))\n\t\t\tprintf(\"[ex]\");\n\t\tif (snd_seq_query_subscribe_get_time_update(subs))\n\t\t\tprintf(\"[%s:%d]\",\n\t\t\t       (snd_seq_query_subscribe_get_time_real(subs) ? \"real\" : \"tick\"),\n\t\t\t       snd_seq_query_subscribe_get_queue(subs));\n\t\tsnd_seq_query_subscribe_set_index(subs, snd_seq_query_subscribe_get_index(subs) + 1);\n\t}\n\tif (count > 0)\n\t\tprintf(\"\\n\");\n}", "path": "seq\\aconnect\\aconnect.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/* extract possible format length and move str behind it*/\n", "func_signal": "static int get_format_len(struct space *space, char **str)", "code": "{\n\tint num;\n\tchar *tail;\n\n\tif (isdigit(*str[0])) {\n\t\tnum = (int) strtoul(*str, &tail, 10);\n\t\tif (num > 0) {\n\t\t\t*str = tail;\n\t\t\tdbg(\"format length=%i\", num);\n\t\t\treturn num;\n\t\t} else {\n\t\t\tPerror(space, \"format parsing error '%s'\", *str);\n\t\t}\n\t}\n\treturn -1;\n}", "path": "alsactl\\init_parse.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * copy events from sequencer to port(s)\n */\n", "func_signal": "static int copy_local_to_remote(void)", "code": "{\n\tint rc;\n\tsnd_seq_event_t *ev;\n\tchar *buf;\n\n\twhile ((rc = snd_seq_event_input(handle, &ev)) >= 0 && ev) {\n\t\tif (ev->type >= SND_SEQ_EVENT_CLIENT_START &&\n\t\t    ! snd_seq_ev_is_variable_type(ev)) {\n\t\t\tsnd_seq_free_event(ev);\n\t\t\tcontinue;\n\t\t}\n\t\tif (snd_seq_ev_is_variable(ev)) {\n\t\t\tint len;\n\t\t\tlen = EVENT_PACKET_SIZE + ev->data.ext.len;\n\t\t\tbuf = get_writebuf(len);\n\t\t\tmemcpy(buf, ev, sizeof(snd_seq_event_t));\n\t\t\tmemcpy(buf + EVENT_PACKET_SIZE, ev->data.ext.ptr, ev->data.ext.len);\n\t\t} else {\n\t\t\tbuf = get_writebuf(EVENT_PACKET_SIZE);\n\t\t\tmemcpy(buf, ev, EVENT_PACKET_SIZE);\n\t\t}\n\t\tif (info)\n\t\t\tprint_event(ev);\n\t\tsnd_seq_free_event(ev);\n\t}\n\tflush_writebuf();\n\treturn 0;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/************************************************************/\n/* Calculate pseudo-random 32 bit number based on linear congruential method. */\n", "func_signal": "static unsigned long generate_random_number( void )", "code": "{\n    static unsigned long rand_seed = 22222;  /* Change this for different random sequences. */\n    rand_seed = (rand_seed * 196314165) + 907633515;\n    return rand_seed;\n}", "path": "speaker-test\\pink.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/* generate Pink noise values between -1.0 and +1.0 */\n", "func_signal": "float generate_pink_noise_sample( pink_noise_t *pink )", "code": "{\n    long new_random;\n    long sum;\n    float output;\n\n/* Increment and mask index. */\n    pink->pink_index = (pink->pink_index + 1) & pink->pink_index_mask;\n\n/* If index is zero, don't update any random values. */\n    if( pink->pink_index != 0 )\n    {\n\t/* Determine how many trailing zeros in PinkIndex. */\n\t/* This algorithm will hang if n==0 so test first. */\n\tint num_zeros = 0;\n\tint n = pink->pink_index;\n\twhile( (n & 1) == 0 )\n\t{\n\t    n = n >> 1;\n\t    num_zeros++;\n\t}\n\n\t/* Replace the indexed ROWS random value.\n\t * Subtract and add back to Running_sum instead of adding all the random\n\t * values together. Only one changes each time.\n\t */\n\tpink->pink_running_sum -= pink->pink_rows[num_zeros];\n\tnew_random = ((long)generate_random_number()) >> PINK_RANDOM_SHIFT;\n\tpink->pink_running_sum += new_random;\n\tpink->pink_rows[num_zeros] = new_random;\n    }\n\t\n/* Add extra white noise value. */\n    new_random = ((long)generate_random_number()) >> PINK_RANDOM_SHIFT;\n    sum = pink->pink_running_sum + new_random;\n\n/* Scale to range of -1.0 to 0.9999. */\n    output = pink->pink_scalar * sum;\n\n    return output;\n}", "path": "speaker-test\\pink.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * initialize sequencer\n */\n", "func_signal": "static void init_seq(char *source, char *dest)", "code": "{\n\tsnd_seq_addr_t addr;\n\tint err, counti, counto;\n\n\tif (snd_seq_open(&handle, \"default\", SND_SEQ_OPEN_DUPLEX, 0) < 0) {\n\t\tperror(\"snd_seq_open\");\n\t\texit(1);\n\t}\n\tif (seqifds)\n\t\tfree(seqifds);\n\tif (seqofds)\n\t\tfree(seqofds);\n\tcounti = seqifds_count = snd_seq_poll_descriptors_count(handle, POLLIN);\n\tassert(counti > 0);\n\tcounto = seqofds_count = snd_seq_poll_descriptors_count(handle, POLLOUT);\n\tassert(counto > 0);\n\tseqifds = (struct pollfd *)calloc(counti, sizeof(struct pollfd));\n\tassert(seqifds);\n\tseqofds = (struct pollfd *)calloc(counto, sizeof(struct pollfd));\n\tassert(seqofds);\n\terr = snd_seq_poll_descriptors(handle, seqifds, counti, POLLIN);\n\tassert(err == counti);\n\terr = snd_seq_poll_descriptors(handle, seqofds, counto, POLLOUT);\n\tassert(err == counto);\n\n\tsnd_seq_nonblock(handle, 1);\n\n\t/* set client info */\n\tif (server_mode)\n\t\tsnd_seq_set_client_name(handle, \"Net Server\");\n\telse\n\t\tsnd_seq_set_client_name(handle, \"Net Client\");\n\n\t/* create a port */\n\tseq_port = snd_seq_create_simple_port(handle, \"Network\",\n\t\t\t\t\t      SND_SEQ_PORT_CAP_READ |\n\t\t\t\t\t      SND_SEQ_PORT_CAP_WRITE |\n\t\t\t\t\t      SND_SEQ_PORT_CAP_SUBS_READ |\n\t\t\t\t\t      SND_SEQ_PORT_CAP_SUBS_WRITE,\n\t\t\t\t\t      SND_SEQ_PORT_TYPE_MIDI_GENERIC);\n\tif (seq_port < 0) {\n\t\tperror(\"create seq port\");\n\t\texit(1);\n\t}\n\tif (verbose)\n\t\tfprintf(stderr, _(\"sequencer opened: %d:%d\\n\"),\n\t\t\tsnd_seq_client_id(handle), seq_port);\n\n\t/* explicit subscriptions */\n\tif (source) {\n\t\t/* read subscription */\n\t\tif (snd_seq_parse_address(handle, &addr, source) < 0) {\n\t\t\tfprintf(stderr, _(\"invalid source address %s\\n\"), source);\n\t\t\texit(1);\n\t\t}\n\t\tif (snd_seq_connect_from(handle, seq_port, addr.client, addr.port)) {\n\t\t\tperror(\"read subscription\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (dest) {\n\t\t/* write subscription */\n\t\tif (snd_seq_parse_address(handle, &addr, dest) < 0) {\n\t\t\tfprintf(stderr, _(\"invalid destination address %s\\n\"), dest);\n\t\t\texit(1);\n\t\t}\n\t\tif (snd_seq_connect_to(handle, seq_port, addr.client, addr.port)) {\n\t\t\tperror(\"write subscription\");\n\t\t\texit(1);\n\t\t}\n\t}\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/* check if unicode char has a valid numeric range */\n", "func_signal": "static int utf8_unichar_valid_range(int unichar)", "code": "{\n\tif (unichar > 0x10ffff)\n\t\treturn 0;\n\tif ((unichar & 0xfffff800) == 0xd800)\n\t\treturn 0;\n\tif ((unichar > 0xfdcf) && (unichar < 0xfdf0))\n\t\treturn 0;\n\tif ((unichar & 0xffff) == 0xffff)\n\t\treturn 0;\n\treturn 1;\n}", "path": "alsactl\\init_utils_string.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * initialize network client\n */\n", "func_signal": "static void init_client(char *server, int port)", "code": "{\n\tstruct sockaddr_in addr;\n\tstruct hostent *host;\n\tint curstate = 1;\n\tint fd;\n\n\tif ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0){\n\t\tperror(\"create socket\");\n\t\texit(1);\n\t}\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &curstate, sizeof(curstate)) < 0) {\n\t\tperror(\"setsockopt\");\n\t\texit(1);\n\t}\n\tif ((host = gethostbyname(server)) == NULL){\n\t\tfprintf(stderr, _(\"can't get address %s\\n\"), server);\n\t\texit(1);\n\t}\n\taddr.sin_port = htons(port);\n\taddr.sin_family = AF_INET;\n\tmemcpy(&addr.sin_addr, host->h_addr, host->h_length);\n\tif (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n\tif (verbose)\n\t\tfprintf(stderr, _(\"ok.. connected\\n\"));\n\tnetfd[0] = fd;\n\tcur_connected = 1;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * allocate and initialize buffers\n */\n", "func_signal": "static void init_buf(void)", "code": "{\n\tmax_wrlen = MAX_BUF_EVENTS * sizeof(snd_seq_event_t);\n\tmax_rdlen = MAX_BUF_EVENTS * sizeof(snd_seq_event_t);\n\twritebuf = malloc(max_wrlen);\n\treadbuf = malloc(max_rdlen);\n\tif (writebuf == NULL || readbuf == NULL) {\n\t\tfprintf(stderr, _(\"can't malloc\\n\"));\n\t\texit(1);\n\t}\n\tmemset(writebuf, 0, max_wrlen);\n\tmemset(readbuf, 0, max_rdlen);\n\tcur_wrlen = 0;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * Copyright (C) 2004-2005 Kay Sievers <kay.sievers@vrfy.org>\n *\n *\tThis program is free software; you can redistribute it and/or modify it\n *\tunder the terms of the GNU General Public License as published by the\n *\tFree Software Foundation version 2 of the License.\n * \n *\tThis program is distributed in the hope that it will be useful, but\n *\tWITHOUT ANY WARRANTY; without even the implied warranty of\n *\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *\tGeneral Public License for more details.\n * \n *\tYou should have received a copy of the GNU General Public License along\n *\twith this program; if not, write to the Free Software Foundation, Inc.,\n *\t51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n */\n", "func_signal": "static void remove_trailing_chars(char *path, char c)", "code": "{\n\tsize_t len;\n\n\tlen = strlen(path);\n\twhile (len > 0 && path[len-1] == c)\n\t\tpath[--len] = '\\0';\n}", "path": "alsactl\\init_utils_string.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * start connection on server\n */\n", "func_signal": "static void start_connection(void)", "code": "{\n\tstruct sockaddr_in addr;\n\tint i;\n\tsocklen_t addr_len;\n\n\tfor (i = 0; i < max_connection; i++) {\n\t\tif (netfd[i] < 0)\n\t\t\tbreak;\n\t}\n\tif (i >= max_connection) {\n\t\tfprintf(stderr, _(\"too many connections!\\n\"));\n\t\texit(1);\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr_len = sizeof(addr);\n\tnetfd[i] = accept(sockfd, (struct sockaddr *)&addr, &addr_len);\n\tif (netfd[i] < 0) {\n\t\tperror(\"accept\");\n\t\texit(1);\n\t}\n\tif (verbose)\n\t\tfprintf(stderr, _(\"accepted[%d]\\n\"), netfd[i]);\n\tcur_connected++;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/* Setup PinkNoise structure for N rows of generators. */\n", "func_signal": "void initialize_pink_noise( pink_noise_t *pink, int num_rows )", "code": "{\n    int i;\n    long pmax;\n    pink->pink_index = 0;\n    pink->pink_index_mask = (1<<num_rows) - 1;\n/* Calculate maximum possible signed random value. Extra 1 for white noise always added. */\n    pmax = (num_rows + 1) * (1<<(PINK_RANDOM_BITS-1));\n    pink->pink_scalar = 1.0f / pmax;\n/* Initialize rows. */\n    for( i=0; i<num_rows; i++ ) pink->pink_rows[i] = 0;\n    pink->pink_running_sum = 0;\n}", "path": "speaker-test\\pink.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * flush write buffer - send data to the socket\n */\n", "func_signal": "static void flush_writebuf(void)", "code": "{\n\tif (cur_wrlen) {\n\t\tint i;\n\t\tfor (i = 0; i < max_connection; i++) {\n\t\t\tif (netfd[i] >= 0)\n\t\t\t\twrite(netfd[i], writebuf, cur_wrlen);\n\t\t}\n\t\tcur_wrlen = 0;\n\t}\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * get space from write buffer\n */\n", "func_signal": "static char *get_writebuf(int len)", "code": "{\n\tchar *buf;\n\tif (cur_wrlen + len >= max_wrlen)\n\t\tflush_writebuf();\n\tbuf = writebuf + cur_wrlen;\n\tcur_wrlen += len;\n\treturn buf;\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/*\n * event loop\n */\n", "func_signal": "static void do_loop(void)", "code": "{\n\tint i, rc, width;\n\tint seqifd_ptr, sockfd_ptr = -1, netfd_ptr;\n\n\tfor (;;) {\n\t\tmemset(pollfds, 0, pollfds_count * sizeof(struct pollfd));\n\t\tseqifd_ptr = 0;\n\t\tmemcpy(pollfds, seqifds, sizeof(*seqifds)*(width = seqifds_count));\n\t\tif (server_mode) {\n\t\t\tsockfd_ptr = width;\n\t\t\tpollfds[width].fd = sockfd;\n\t\t\tpollfds[width].events = POLLIN;\n\t\t\twidth++;\n\t\t}\n\t\tnetfd_ptr = width;\n\t\tfor (i = 0; i < max_connection; i++) {\n\t\t\tif (netfd[i] >= 0) {\n\t\t\t\tpollfds[width].fd = netfd[i];\n\t\t\t\tpollfds[width].events = POLLIN;\n\t\t\t\twidth++;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\trc = poll(pollfds, width, -1);\n\t\t} while (rc <= 0 && errno == EINTR);\n\t\tif (rc <= 0) {\n\t\t\tperror(\"poll\");\n\t\t\texit(1);\n\t\t}\n\t\tif (server_mode) {\n\t\t\tif (pollfds[sockfd_ptr].revents & (POLLIN|POLLOUT))\n\t\t\t\tstart_connection();\n\t\t}\n\t\tfor (i = 0; i < seqifds_count; i++)\n\t\t\tif (pollfds[seqifd_ptr + i].revents & (POLLIN|POLLOUT)) {\n\t\t\t\tif (copy_local_to_remote())\n\t\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (i = 0; i < max_connection; i++) {\n\t\t\tif (netfd[i] < 0)\n\t\t\t\tcontinue;\n\t\t\tif (pollfds[netfd_ptr + i].revents & (POLLIN|POLLOUT)) {\n\t\t\t\tif (copy_remote_to_local(netfd[i])) {\n\t\t\t\t\tnetfd[i] = -1;\n\t\t\t\t\tcur_connected--;\n\t\t\t\t\tif (cur_connected <= 0)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "seq\\aseqnet\\aseqnet.c", "repo_name": "bear24rw/alsa-utils", "stars": 24, "license": "gpl-2.0", "language": "c", "size": 2182}
{"docstring": "/**\n * call timer source repeatedly and record delta between samples\n * in histogram and samples array\n *\n * @param duration          maximum number of seconds for whole run\n * @param min_increase      first slot in histogram is for values < 0,\n *                          second for >=0 and < min_increase\n * @param bin_size          width of all following bins\n * @param histogram_size    number of slots, including special ones\n * @param histogram         buffer for histogram, filled by this function\n * @return number of calls to systicks()\n */\n", "func_signal": "static unsigned int genhistogram(seconds_t duration,\n                                 ticks_t min_increase,\n                                 ticks_t bin_size,\n                                 unsigned int histogram_size,\n                                 unsigned int *histogram)", "code": "{\n    ticks_t increase;\n    ticks_t startticks, lastticks, nextticks;\n    ticks_t endticks = duration / clockperiod;\n    unsigned int calls = 0;\n\n    startticks = systicks();\n    lastticks = 0;\n    count = 0;\n    memset(histogram, 0, sizeof(*histogram) * histogram_size);\n    do {\n        calls++;\n        nextticks = systicks() - startticks;\n        increase = nextticks - lastticks;\n        if( increase < 0 ) {\n            histogram[0]++;\n        } else if( increase > 0 ) {\n            unsigned int index;\n\n            if( count < MAX_SAMPLES ) {\n                samples[count] = increase;\n                count++;\n            }\n\n            if( increase < min_increase ) {\n                index = 1;\n            } else {\n                index = (unsigned int)( ( increase - min_increase ) / bin_size ) + 2;\n                if( index >= histogram_size ) {\n                    index = histogram_size - 1;\n                }\n            }\n            histogram[index]++;\n        }\n        lastticks = nextticks;\n    } while( lastticks < endticks );\n\n    return calls;\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/** returns system time as number of seconds since common epoch */\n", "func_signal": "static seconds_t systime(void)", "code": "{\n    ticks_t ticks = systicks();\n    return ticks * clockperiod;\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* start all of the UDP stuff */\n/* must specify 'subdomainName', optionally 'ifaceName', if not then pass ifaceName == \"\" */\n/* returns other args */\n/* on socket options, see the 'socket(7)' and 'ip' man pages */\n", "func_signal": "Boolean netInit(PtpClock *ptpClock)", "code": "{\n  int temp, i;\n  struct in_addr interfaceAddr, netAddr;\n  struct sockaddr_in addr;\n  struct ip_mreq imr;\n  char addrStr[NET_ADDRESS_LENGTH];\n  char *s;\n  Boolean useSystemTimeStamps = ptpClock->runTimeOpts.time == TIME_SYSTEM;\n  \n  DBG(\"netInit\\n\");\n  \n  /* open sockets */\n  if( (ptpClock->netPath.eventSock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP) ) < 0\n    || (ptpClock->netPath.generalSock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP) ) < 0 )\n  {\n    PERROR(\"failed to initalize sockets\");\n    return FALSE;\n  }\n\n  /* find a network interface */\n  if( !(interfaceAddr.s_addr = findIface(ptpClock->runTimeOpts.ifaceName, &ptpClock->port_communication_technology,\n    ptpClock->port_uuid_field, ptpClock)) )\n    return FALSE;\n  \n  temp = 1;  /* allow address reuse */\n  if( setsockopt(ptpClock->netPath.eventSock, SOL_SOCKET, SO_REUSEADDR, &temp, sizeof(int)) < 0\n    || setsockopt(ptpClock->netPath.generalSock, SOL_SOCKET, SO_REUSEADDR, &temp, sizeof(int)) < 0 )\n  {\n    DBG(\"failed to set socket reuse\\n\");\n  }\n\n  /* bind sockets */\n  /* need INADDR_ANY to allow receipt of multi-cast and uni-cast messages */\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  addr.sin_port = htons(PTP_EVENT_PORT);\n  if(bind(ptpClock->netPath.eventSock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in)) < 0)\n  {\n    PERROR(\"failed to bind event socket\");\n    return FALSE;\n  }\n  \n  addr.sin_port = htons(PTP_GENERAL_PORT);\n  if(bind(ptpClock->netPath.generalSock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in)) < 0)\n  {\n    PERROR(\"failed to bind general socket\");\n    return FALSE;\n  }\n  \n  /* set general and port address */\n  *(Integer16*)ptpClock->event_port_address = PTP_EVENT_PORT;\n  *(Integer16*)ptpClock->general_port_address = PTP_GENERAL_PORT;\n  \n  /* send a uni-cast address if specified (useful for testing) */\n  if(ptpClock->runTimeOpts.unicastAddress[0])\n  {\n    if(!inet_aton(ptpClock->runTimeOpts.unicastAddress, &netAddr))\n    {\n      ERROR(\"failed to encode uni-cast address: %s\\n\", ptpClock->runTimeOpts.unicastAddress);\n      return FALSE;\n    }\n    \n    ptpClock->netPath.unicastAddr = netAddr.s_addr;\n  }\n  else\n    ptpClock->netPath.unicastAddr = 0;\n  \n  /* resolve PTP subdomain */\n  if(!lookupSubdomainAddress(ptpClock->runTimeOpts.subdomainName, addrStr))\n    return FALSE;\n  \n  if(!inet_aton(addrStr, &netAddr))\n  {\n    ERROR(\"failed to encode multi-cast address: %s\\n\", addrStr);\n    return FALSE;\n  }\n  \n  ptpClock->netPath.multicastAddr = netAddr.s_addr;\n  \n  s = addrStr;\n  for(i = 0; i < SUBDOMAIN_ADDRESS_LENGTH; ++i)\n  {\n    ptpClock->subdomain_address[i] = strtol(s, &s, 0);\n    \n    if(!s)\n      break;\n    \n    ++s;\n  }\n  \n  /* multicast send only on specified interface */\n  imr.imr_multiaddr.s_addr = netAddr.s_addr;\n  imr.imr_interface.s_addr = interfaceAddr.s_addr;\n  if( setsockopt(ptpClock->netPath.eventSock, IPPROTO_IP, IP_MULTICAST_IF, &imr.imr_interface.s_addr, sizeof(struct in_addr)) < 0\n    || setsockopt(ptpClock->netPath.generalSock, IPPROTO_IP, IP_MULTICAST_IF, &imr.imr_interface.s_addr, sizeof(struct in_addr)) < 0 )\n  {\n    PERROR(\"failed to enable multi-cast on the interface\");\n    return FALSE;\n  }\n  \n  /* join multicast group (for receiving) on specified interface */\n  if( setsockopt(ptpClock->netPath.eventSock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(struct ip_mreq))  < 0\n    || setsockopt(ptpClock->netPath.generalSock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(struct ip_mreq)) < 0 )\n  {\n    PERROR(\"failed to join the multi-cast group\");\n    return FALSE;\n  }\n\n  /* set socket time-to-live to 1 */\n  temp = 1;\n  if( setsockopt(ptpClock->netPath.eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0\n    || setsockopt(ptpClock->netPath.generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0 )\n  {\n    PERROR(\"failed to set the multi-cast time-to-live\");\n    return FALSE;\n  }\n  \n  /* set loopback: needed only for time stamping with the system clock */\n  temp = useSystemTimeStamps;\n  if( setsockopt(ptpClock->netPath.eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0\n    || setsockopt(ptpClock->netPath.generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0 )\n  {\n    PERROR(\"failed to enable multi-cast loopback\");\n    return FALSE;\n  }\n\n  /* make timestamps available through recvmsg() (only needed for time stamping with system clock) */\n  temp = useSystemTimeStamps;\n  if( setsockopt(ptpClock->netPath.eventSock, SOL_SOCKET, SO_TIMESTAMP, &temp, sizeof(int)) < 0\n    || setsockopt(ptpClock->netPath.generalSock, SOL_SOCKET, SO_TIMESTAMP, &temp, sizeof(int)) < 0 )\n  {\n    PERROR(\"failed to enable receive time stamps\");\n    return FALSE;\n  }\n\n  return TRUE;\n}", "path": "src\\dep\\net.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* handle actions and events for 'port_state' */\n", "func_signal": "void doState(PtpClock *ptpClock)", "code": "{\n  UInteger8 state;\n  \n  ptpClock->message_activity = FALSE;\n  \n  switch(ptpClock->port_state)\n  {\n  case PTP_LISTENING:\n  case PTP_PASSIVE:\n  case PTP_SLAVE:\n  case PTP_MASTER:\n    if(ptpClock->record_update)\n    {\n      ptpClock->record_update = FALSE;\n      state = bmc(ptpClock->foreign, ptpClock);\n      if(state != ptpClock->port_state)\n        toState(state, ptpClock);\n    }\n    break;\n    \n  default:\n    break;\n  }\n  \n  switch(ptpClock->port_state)\n  {\n  case PTP_FAULTY:\n    /* imaginary troubleshooting */\n    \n    DBG(\"event FAULT_CLEARED\\n\");\n    toState(PTP_INITIALIZING, ptpClock);\n    return;\n    \n  case PTP_LISTENING:\n  case PTP_PASSIVE:\n  case PTP_UNCALIBRATED:\n  case PTP_SLAVE:\n    handle(ptpClock);\n    \n    if(timerExpired(SYNC_RECEIPT_TIMER, ptpClock->itimer))\n    {\n      DBG(\"event SYNC_RECEIPT_TIMEOUT_EXPIRES\\n\");\n      ptpClock->number_foreign_records = 0;\n      ptpClock->foreign_record_i = 0;\n      if(!ptpClock->runTimeOpts.slaveOnly && ptpClock->clock_stratum != 255)\n      {\n        m1(ptpClock);\n        toState(PTP_MASTER, ptpClock);\n      }\n      else if(ptpClock->port_state != PTP_LISTENING)\n        toState(PTP_LISTENING, ptpClock);\n    }\n    \n    break;\n    \n  case PTP_MASTER:\n    if(timerExpired(SYNC_INTERVAL_TIMER, ptpClock->itimer))\n    {\n      DBGV(\"event SYNC_INTERVAL_TIMEOUT_EXPIRES\\n\");\n      issueSync(ptpClock);\n    }\n    \n    handle(ptpClock);\n    \n    if(ptpClock->runTimeOpts.slaveOnly || ptpClock->clock_stratum == 255)\n      toState(PTP_LISTENING, ptpClock);\n    \n    break;\n    \n  case PTP_DISABLED:\n    handle(ptpClock);\n    break;\n    \n  default:\n    DBG(\"do unrecognized state\\n\");\n    break;\n  }\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/** qsort comparison function for sorting by increasing duration of samples */\n", "func_signal": "static int compare_duration( const void *a, const void *b )", "code": "{\n    const struct sample *sa = a, *sb = b;\n    seconds_t tmp = (sb->t_recv - sb->t_send) - (sa->t_recv - sa->t_send);\n\n    if( tmp < 0 ) {\n        return -1;\n    } else if( tmp > 0 ) {\n        return 1;\n    } else {\n        return 0;\n    }\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* add or update an entry in the foreign master data set */\n", "func_signal": "MsgSync * addForeign(Octet *buf, MsgHeader *header, PtpClock *ptpClock)", "code": "{\n  int i, j;\n  Boolean found = FALSE;\n  \n  DBGV(\"updateForeign\\n\");\n  \n  j = ptpClock->foreign_record_best;\n  for(i = 0; i < ptpClock->number_foreign_records; ++i)\n  {\n    if(header->sourceCommunicationTechnology == ptpClock->foreign[j].foreign_master_communication_technology\n      && header->sourcePortId == ptpClock->foreign[j].foreign_master_port_id\n      && !memcmp(header->sourceUuid, ptpClock->foreign[j].foreign_master_uuid, PTP_UUID_LENGTH))\n    {\n      ++ptpClock->foreign[j].foreign_master_syncs;\n      found = TRUE;\n      DBGV(\"updateForeign: update record %d\\n\", j);\n      break;\n    }\n    \n    j = (j + 1)%ptpClock->number_foreign_records;\n  }\n  \n  if(!found)\n  {\n    if(ptpClock->number_foreign_records < ptpClock->max_foreign_records)\n      ++ptpClock->number_foreign_records;\n    \n    j = ptpClock->foreign_record_i;\n    \n    ptpClock->foreign[j].foreign_master_communication_technology =\n      header->sourceCommunicationTechnology;\n    ptpClock->foreign[j].foreign_master_port_id =\n      header->sourcePortId;\n    memcpy(ptpClock->foreign[j].foreign_master_uuid,\n      header->sourceUuid, PTP_UUID_LENGTH);\n    \n    DBG(\"updateForeign: new record (%d,%d) %d %d %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\\n\",\n      ptpClock->foreign_record_i, ptpClock->number_foreign_records,\n      ptpClock->foreign[j].foreign_master_communication_technology,\n      ptpClock->foreign[j].foreign_master_port_id,\n      ptpClock->foreign[j].foreign_master_uuid[0], ptpClock->foreign[j].foreign_master_uuid[1],\n      ptpClock->foreign[j].foreign_master_uuid[2], ptpClock->foreign[j].foreign_master_uuid[3],\n      ptpClock->foreign[j].foreign_master_uuid[4], ptpClock->foreign[j].foreign_master_uuid[5]);\n    \n    ptpClock->foreign_record_i = (ptpClock->foreign_record_i + 1)%ptpClock->max_foreign_records;\n  }\n  \n  msgUnpackHeader(buf, &ptpClock->foreign[j].header);\n  msgUnpackSync(buf, &ptpClock->foreign[j].sync);\n  \n  return &ptpClock->foreign[j].sync;\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/**\n * runs a timer performance test for the given duration\n *\n * @param duration    duration of test in seconds\n */\n", "func_signal": "void timerperformance(seconds_t duration)", "code": "{\n    unsigned int i;\n    unsigned int max = 0;\n    char buffer[3][256];\n    double average = 0, median = 0;\n    unsigned int calls;\n    unsigned int simple_histogram[3];\n    ticks_t min_increase, bin_size, max_increase;\n    unsigned int histogram_size;\n    unsigned int *clockhistogram;\n\n    /* determine range of clock increases for real run */\n    calls = genhistogram(2.0, 1, 1, 3, simple_histogram);\n    qsort(samples, count, sizeof(samples[0]), compare_ticks);\n\n    /* shoot for 10 slots, but allow for some extra slots at both ends as needed */\n    min_increase = samples[0] == 1 ? 1 : samples[0] * 9 / 10;\n    max_increase = samples[count - 1];\n    bin_size = (max_increase - min_increase) / 10;\n    if (bin_size * clockperiod <= 1e-9) {\n        bin_size = 1e-9 / clockperiod;\n    }\n    histogram_size = (max_increase - min_increase) / bin_size + 3 + 5;\n    clockhistogram = malloc(histogram_size * sizeof(*clockhistogram));\n    calls = genhistogram(duration, min_increase, bin_size, histogram_size, clockhistogram);\n    qsort(samples, count, sizeof(samples[0]), compare_ticks);\n\n    /* print average and medium increase */\n    for( i = 0; i < count; i++ ) {\n        average += samples[i];\n    }\n    average /= count;\n    qsort(samples, count, sizeof(samples[0]), compare_ticks);\n    median = samples[count/2];\n    syslog(LOG_INFO, \"average clock increase %s -> %.3fHz, median clock increase %s -> %3.fHz, %s/call\",\n           prettyprintseconds(average * clockperiod, 0, 3, buffer[0]), 1/average/clockperiod,\n           prettyprintseconds(median * clockperiod, 0, 3, buffer[1]), 1/median/clockperiod,\n           prettyprintseconds(duration / calls, 0, 3, buffer[2]));\n\n    for( i = 0; i < histogram_size; i++ ) {\n        if( clockhistogram[i] > max ) {\n            max = clockhistogram[i];\n        }\n    }\n    syslog(LOG_INFO, \" < %11.3fus: %s %u\",\n           0.0,\n           printbar(clockhistogram[0] * 20 / max),\n           clockhistogram[0]);\n    syslog(LOG_INFO, \" < %11.3fus: %s %u\",\n           min_increase * clockperiod * 1e6,\n           printbar( clockhistogram[1] * 20 / max ),\n           clockhistogram[1]);\n    for( i = 2; i < histogram_size; i++ ) {\n        syslog(LOG_INFO, \">= %11.3fus: %s %u\",\n               ( ( i - 2 ) * bin_size + min_increase ) * clockperiod * 1e6,\n               printbar( clockhistogram[i] * 20 / max ),\n               clockhistogram[i]);\n    }\n    printf( \"\\n\" );\n\n    free(clockhistogram);\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/**\n * format number of seconds with ns/us/ms/s suffix (depending on magnitude)\n * and configurable number of digits before the decimal point (width) and after\n * it (precision)\n */\n", "func_signal": "static const char *prettyprintseconds( seconds_t seconds, int width, int precision, char *buffer )", "code": "{\n    static char localbuffer[80];\n    seconds_t absseconds = fabs( seconds );\n\n    if( !buffer ) {\n        buffer = localbuffer;\n    }\n\n    if( absseconds < 1e-6 ) {\n        sprintf( buffer, \"%*.*fns\", width, precision, seconds * 1e9 );\n    } else if( absseconds < 1e-3 ) {\n        sprintf( buffer, \"%*.*fus\", width, precision, seconds * 1e6 );\n    } else if( absseconds < 1 ) {\n        sprintf( buffer, \"%*.*fms\", width, precision, seconds * 1e3 );\n    } else {\n        sprintf( buffer, \"%*.*fs\", width, precision, seconds );\n    }\n\n    return buffer;\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/**\n * send messages back and forth between two process in MPI_COMM_WORLD\n * without time stamping\n */\n", "func_signal": "static void simplepingpong( int source, int target, int tag, int num )", "code": "{\n    MPI_Status status;\n    int i, rank;\n    char buffer[1];\n \n    MPI_Comm_rank( MPI_COMM_WORLD, &rank );\n \n    /* message exchange */\n    for( i = 0; i < num; i++ ) {\n        if( rank == target ) {\n            MPI_Recv( buffer, 0, MPI_BYTE, source, tag, MPI_COMM_WORLD, &status );\n            MPI_Send( buffer, 0, MPI_BYTE, source, tag, MPI_COMM_WORLD );\n        } else if( rank == source ) {\n            MPI_Send( buffer, 0, MPI_BYTE, target, tag, MPI_COMM_WORLD );\n            MPI_Recv( buffer, 0, MPI_BYTE, target, tag, MPI_COMM_WORLD, &status );\n        }\n    }\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* see spec table 18 */\n", "func_signal": "void m1(PtpClock *ptpClock)", "code": "{\n  /* Default data set */\n  ptpClock->steps_removed = 0;\n  ptpClock->offset_from_master.seconds = 0;\n  ptpClock->offset_from_master.nanoseconds = 0;\n  ptpClock->one_way_delay.seconds = 0;\n  ptpClock->one_way_delay.nanoseconds = 0;\n  \n  /* Parent data set */\n  ptpClock->parent_communication_technology = ptpClock->clock_communication_technology;\n  memcpy(ptpClock->parent_uuid, ptpClock->clock_uuid_field, PTP_UUID_LENGTH);\n  ptpClock->parent_port_id = ptpClock->clock_port_id_field;\n  ptpClock->parent_last_sync_sequence_number = 0;\n  ptpClock->parent_followup_capable = ptpClock->clock_followup_capable;\n  ptpClock->parent_external_timing = ptpClock->external_timing;\n  ptpClock->parent_variance = ptpClock->clock_variance;\n  ptpClock->grandmaster_communication_technology = ptpClock->clock_communication_technology;\n  memcpy(ptpClock->grandmaster_uuid_field, ptpClock->clock_uuid_field, PTP_UUID_LENGTH);\n  ptpClock->grandmaster_port_id_field  = ptpClock->clock_port_id_field;\n  ptpClock->grandmaster_stratum = ptpClock->clock_stratum;\n  memcpy(ptpClock->grandmaster_identifier, ptpClock->clock_identifier, PTP_CODE_STRING_LENGTH);\n  ptpClock->grandmaster_variance = ptpClock->clock_variance;\n  ptpClock->grandmaster_preferred  = ptpClock->preferred;\n  ptpClock->grandmaster_is_boundary_clock  = ptpClock->is_boundary_clock;\n  ptpClock->grandmaster_sequence_number = ptpClock->last_sync_event_sequence_number;\n}", "path": "src\\bmc.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/** qsort routine for increasing sort of doubles */\n", "func_signal": "static int compare_ticks( const void *a, const void *b )", "code": "{\n    ticks_t delta = *(const ticks_t *)a - *(const ticks_t *)b;\n\n    return delta < 0 ? -1 :\n        delta > 0 ? 1 :\n        0;\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/** generates a string of 'width' many hash signs */\n", "func_signal": "static const char *printbar( int width )", "code": "{\n    static char buffer[80];\n\n    if( width > sizeof(buffer) - 1 ) {\n        width = sizeof(buffer) - 1;\n    }\n    memset( buffer, '#', width );\n    buffer[width] = 0;\n    return buffer;\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* check and handle received messages */\n", "func_signal": "void handle(PtpClock *ptpClock)", "code": "{\n  int ret;\n  ssize_t length;\n  Boolean isFromSelf;\n  Boolean isEvent;\n  Boolean badTime = FALSE;\n  TimeInternal time = { 0, 0 };\n  \n  if(!ptpClock->message_activity)\n  {\n    ret = netSelect(0, ptpClock);\n    if(ret < 0)\n    {\n      PERROR(\"failed to poll sockets\");\n      toState(PTP_FAULTY, ptpClock);\n      return;\n    }\n    else if(!ret)\n    {\n      DBGV(\"handle: nothing\\n\");\n      return;\n    }\n    /* else length > 0 */\n  }\n  \n  DBGV(\"handle: something\\n\");\n\n  isEvent = TRUE;\n  length = netRecvEvent(ptpClock->msgIbuf,\n                        ptpClock->delayedTiming ? NULL : &time,\n                        ptpClock);\n  if(length < 0)\n  {\n    PERROR(\"failed to receive on the event socket\");\n    toState(PTP_FAULTY, ptpClock);\n    return;\n  }\n  else if(!length)\n  {\n    isEvent = FALSE;\n    length = netRecvGeneral(ptpClock->msgIbuf, ptpClock);\n    if(length < 0)\n    {\n      PERROR(\"failed to receive on the general socket\");\n      toState(PTP_FAULTY, ptpClock);\n      return;\n    }\n    else if(!length)\n      return;\n  }\n  \n  ptpClock->message_activity = TRUE;\n  \n  if(!msgPeek(ptpClock->msgIbuf, length))\n    return;\n  \n  if(length < HEADER_LENGTH)\n  {\n    ERROR(\"message shorter than header length\\n\");\n    toState(PTP_FAULTY, ptpClock);\n    return;\n  }\n  \n  msgUnpackHeader(ptpClock->msgIbuf, &ptpClock->msgTmpHeader);\n\n  if(isEvent && ptpClock->delayedTiming)\n  {\n    /* query hardware for matching receive time stamp */\n    if(!getReceiveTime(&time, ptpClock->msgTmpHeader.sourceUuid, ptpClock->msgTmpHeader.sequenceId, ptpClock))\n    {\n      /*\n       * Incoming packets without hardware time stamp cannot be ignored outright because\n       * a master might only be able to time stamp DelayReq packets; ignoring the Sync\n       * packets from another, better clock would break the clock selection protocol.\n       * Therefore set system time as fallback and decide below what to do.\n       */\n      DBGV(\"*** message with no time stamp ***\\n\");\n      getTime(&time, ptpClock);\n      badTime = TRUE;\n    }\n  }\n  \n  DBGV(\"%s Receipt of Message\\n\"\n    \"   version %d\\n\"\n    \"   type %d\\n\"\n    \"   uuid %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\\n\"\n    \"   sequence %d\\n\"\n    \"   time %us %dns\\n\",\n    isEvent ? \"event\" : \"control\",\n    ptpClock->msgTmpHeader.versionPTP,\n    ptpClock->msgTmpHeader.control,\n    ptpClock->msgTmpHeader.sourceUuid[0], ptpClock->msgTmpHeader.sourceUuid[1],\n    ptpClock->msgTmpHeader.sourceUuid[2], ptpClock->msgTmpHeader.sourceUuid[3],\n    ptpClock->msgTmpHeader.sourceUuid[4], ptpClock->msgTmpHeader.sourceUuid[5],\n    ptpClock->msgTmpHeader.sequenceId,\n    time.seconds, time.nanoseconds);\n  \n  if(ptpClock->msgTmpHeader.versionPTP != VERSION_PTP)\n  {\n    DBGV(\"ignore version %d message\\n\", ptpClock->msgTmpHeader.versionPTP);\n    return;\n  }\n  \n  if( memcmp(ptpClock->msgTmpHeader.subdomain, ptpClock->subdomain_name,\n    PTP_SUBDOMAIN_NAME_LENGTH) )\n  {\n    DBGV(\"ignore message from subdomain %s\\n\", ptpClock->msgTmpHeader.subdomain);\n    return;\n  }\n  \n  isFromSelf = ptpClock->msgTmpHeader.sourceCommunicationTechnology == ptpClock->port_communication_technology\n    && ptpClock->msgTmpHeader.sourcePortId == ptpClock->port_id_field\n    && !memcmp(ptpClock->msgTmpHeader.sourceUuid, ptpClock->port_uuid_field, PTP_UUID_LENGTH);\n  \n  /* subtract the inbound latency adjustment if it is not a loop back and the\n     time stamp seems reasonable */\n  if(!isFromSelf && time.seconds > 0)\n    subTime(&time, &time, &ptpClock->runTimeOpts.inboundLatency);\n  \n  switch(ptpClock->msgTmpHeader.control)\n  {\n  case PTP_SYNC_MESSAGE:\n    handleSync(&ptpClock->msgTmpHeader, ptpClock->msgIbuf, length, &time, badTime, isFromSelf, ptpClock);\n    break;\n    \n  case PTP_FOLLOWUP_MESSAGE:\n    handleFollowUp(&ptpClock->msgTmpHeader, ptpClock->msgIbuf, length, isFromSelf, ptpClock);\n    break;\n    \n  case PTP_DELAY_REQ_MESSAGE:\n    handleDelayReq(&ptpClock->msgTmpHeader, ptpClock->msgIbuf, length, &time, badTime, isFromSelf, ptpClock);\n    break;\n    \n  case PTP_DELAY_RESP_MESSAGE:\n    handleDelayResp(&ptpClock->msgTmpHeader, ptpClock->msgIbuf, length, isFromSelf, ptpClock);\n    break;\n    \n  case PTP_MANAGEMENT_MESSAGE:\n    handleManagement(&ptpClock->msgTmpHeader, ptpClock->msgIbuf, length, isFromSelf, ptpClock);\n    break;\n    \n   default:\n    DBG(\"handle: unrecognized message\\n\");\n    break;\n  }\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* shut down the UDP stuff */\n", "func_signal": "Boolean netShutdown(PtpClock *ptpClock)", "code": "{\n  struct ip_mreq imr;\n\n#ifdef HAVE_LINUX_NET_TSTAMP_H\n  if (ptpClock->runTimeOpts.time == TIME_SYSTEM_LINUX_HW &&\n      ptpClock->netPath.eventSock > 0) {\n      struct hwtstamp_config hwconfig;\n\n      ptpClock->netPath.eventSockIFR.ifr_data = (void *)&hwconfig;\n      memset(&hwconfig, 0, sizeof(&hwconfig));\n\n      hwconfig.tx_type = HWTSTAMP_TX_OFF;\n      hwconfig.rx_filter = HWTSTAMP_FILTER_NONE;\n      if (ioctl(ptpClock->netPath.eventSock, SIOCSHWTSTAMP, &ptpClock->netPath.eventSockIFR) < 0) {\n          PERROR(\"turning off net_tstamp SIOCSHWTSTAMP: %s\", strerror(errno));\n      }\n  }\n#endif\n\n  imr.imr_multiaddr.s_addr = ptpClock->netPath.multicastAddr;\n  imr.imr_interface.s_addr = htonl(INADDR_ANY);\n\n  setsockopt(ptpClock->netPath.eventSock, IPPROTO_IP, IP_DROP_MEMBERSHIP, &imr, sizeof(struct ip_mreq));\n  setsockopt(ptpClock->netPath.generalSock, IPPROTO_IP, IP_DROP_MEMBERSHIP, &imr, sizeof(struct ip_mreq));\n  \n  ptpClock->netPath.multicastAddr = 0;\n  ptpClock->netPath.unicastAddr = 0;\n  \n  if(ptpClock->netPath.eventSock > 0)\n    close(ptpClock->netPath.eventSock);\n  ptpClock->netPath.eventSock = -1;\n  \n  if(ptpClock->netPath.generalSock > 0)\n    close(ptpClock->netPath.generalSock);\n  ptpClock->netPath.generalSock = -1;\n    \n  return TRUE;\n}", "path": "src\\dep\\net.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* loop forever. doState() has a switch for the actions and events to be\n   checked for 'port_state'. the actions and events may or may not change\n   'port_state' by calling toState(), but once they are done we loop around\n   again and perform the actions required for the new 'port_state'. */\n", "func_signal": "void protocol(PtpClock *ptpClock)", "code": "{\n  DBG(\"event POWERUP\\n\");\n  \n  toState(PTP_INITIALIZING, ptpClock);\n  \n  for(;;)\n  {\n    if(ptpClock->port_state != PTP_INITIALIZING)\n      doState(ptpClock);\n    else if(!doInit(ptpClock))\n      return;\n    \n    if(ptpClock->message_activity)\n      DBGV(\"activity\\n\");\n    else\n    {\n      DBGV(\"no activity\\n\");\n      timeNoActivity(ptpClock);\n    }\n  }\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/** returns system time as number of ticks since common epoch */\n", "func_signal": "static ticks_t systicks(void)", "code": "{\n#ifdef _WIN32\n    struct _timeb timebuffer;\n    _ftime( &timebuffer );\n    return (ticks_t)timebuffer.time * 1000 + timebuffer.millitm;\n#else\n    if (usetod) {\n        struct timeval cur_time;\n        my_gettimeofday( &cur_time, NULL );\n        return (ticks_t)cur_time.tv_sec * 1000000 + cur_time.tv_usec;\n    } else {\n        struct timespec cur_time;\n        my_clock_gettime(CLOCK_REALTIME, &cur_time);\n        return (ticks_t)cur_time.tv_sec * 1000000000ul + cur_time.tv_nsec;\n    }\n#endif\n}", "path": "extras\\timertest.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* from annex C of the spec */\n", "func_signal": "UInteger32 crc_algorithm(Octet *buf, Integer16 length)", "code": "{\n  Integer16 i;\n  UInteger8 data;\n  UInteger32 polynomial = 0xedb88320, crc = 0xffffffff;\n  \n  while(length-- > 0)\n  {\n    data = *(UInteger8 *)(buf++);\n    \n    for(i=0; i<8; i++)\n    {\n      if((crc^data)&1)\n      {\n        crc = (crc>>1);\n        crc ^= polynomial;\n      }\n      else\n      {\n        crc = (crc>>1);\n      }\n      data >>= 1;\n    }\n  }\n  \n  return crc^0xffffffff;\n}", "path": "src\\arith.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* pack and send various messages */\n", "func_signal": "void issueSync(PtpClock *ptpClock)", "code": "{\n  TimeInternal internalTime;\n  TimeRepresentation originTimestamp;\n  \n  ++ptpClock->last_sync_event_sequence_number;\n  ptpClock->grandmaster_sequence_number = ptpClock->last_sync_event_sequence_number;\n\n  /* try to predict outgoing time stamp */\n  getTime(&internalTime, ptpClock);\n  fromInternalTime(&internalTime, &originTimestamp, ptpClock->halfEpoch);\n  msgPackSync(ptpClock->msgObuf, FALSE, TRUE, &originTimestamp, ptpClock);\n  \n  if(!netSendEvent(ptpClock->msgObuf, SYNC_PACKET_LENGTH,\n                   ptpClock->delayedTiming ? &internalTime : NULL,\n                   ptpClock))\n    toState(PTP_FAULTY, ptpClock);\n  else\n  {\n    DBGV(\"sent sync message\\n\");\n    if(ptpClock->delayedTiming)\n    {\n      if (internalTime.seconds || internalTime.nanoseconds) {\n        /* compensate with configurable latency, then tell client real time stamp */\n        addTime(&internalTime, &internalTime, &ptpClock->runTimeOpts.outboundLatency);\n        issueFollowup(&internalTime, ptpClock);\n      } else {\n        NOTIFY(\"WARNING: sync message without hardware time stamp, skipped followup\\n\");\n      }\n    }\n  }\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* return similar to memcmp()s\n   note: communicationTechnology can be ignored because \n   if they differed they would not have made it here */\n", "func_signal": "Integer8 bmcDataSetComparison(MsgHeader *headerA, MsgSync *syncA,\n  MsgHeader *headerB, MsgSync *syncB, PtpClock *ptpClock)", "code": "{\n  DBGV(\"bmcDataSetComparison: start\\n\");\n  if( !( syncA->grandmasterPortId == syncB->grandmasterPortId\n    && !memcmp(syncA->grandmasterClockUuid, syncB->grandmasterClockUuid, PTP_UUID_LENGTH) ) )\n  {\n    if(syncA->grandmasterClockStratum < syncB->grandmasterClockStratum)\n      goto A;\n    else if(syncA->grandmasterClockStratum > syncB->grandmasterClockStratum)\n      goto B;\n    \n    /* grandmasterClockStratums same */\n    if(getIdentifierOrder(syncA->grandmasterClockIdentifier) < getIdentifierOrder(syncB->grandmasterClockIdentifier))\n      goto A;\n    if(getIdentifierOrder(syncA->grandmasterClockIdentifier) > getIdentifierOrder(syncB->grandmasterClockIdentifier))\n      goto B;\n    \n    /* grandmasterClockIdentifiers same */\n    if(syncA->grandmasterClockStratum > 2)\n    {\n      if(syncA->grandmasterClockVariance > syncB->grandmasterClockVariance + PTP_LOG_VARIANCE_THRESHOLD\n        || syncA->grandmasterClockVariance < syncB->grandmasterClockVariance - PTP_LOG_VARIANCE_THRESHOLD)\n      {\n        /* grandmasterClockVariances are not similar */\n        if(syncA->grandmasterClockVariance < syncB->grandmasterClockVariance)\n          goto A;\n        else\n          goto B;\n      }\n      /* grandmasterClockVariances are similar */\n      if(!syncA->grandmasterIsBoundaryClock != !syncB->grandmasterIsBoundaryClock) /* XOR */\n      {\n        if(syncA->grandmasterIsBoundaryClock)\n          goto A;\n        else\n          goto B;\n      }\n      /* neither is grandmasterIsBoundaryClock */\n      if(memcmp(syncA->grandmasterClockUuid, syncB->grandmasterClockUuid, PTP_UUID_LENGTH) < 0)\n        goto A;\n      else\n        goto B;\n    }\n    \n    /* syncA->grandmasterClockStratum <= 2 */\n    if(!syncA->grandmasterPreferred != !syncB->grandmasterPreferred) /* XOR */\n    {\n      if(syncA->grandmasterPreferred)\n        return 1;  /* A1 */\n      else\n        return -1;  /* B1 */\n    }\n    /* neither or both grandmasterPreferred */\n  }\n  \n  DBGV(\"bmcDataSetComparison: X\\n\");\n  if(syncA->localStepsRemoved > syncB->localStepsRemoved + 1\n    || syncA->localStepsRemoved < syncB->localStepsRemoved -1)\n  {\n    /* localStepsRemoved not within 1 */\n    if(syncA->localStepsRemoved < syncB->localStepsRemoved)\n      return 1;  /* A1 */\n    else\n      return -1;  /* B1 */\n  }\n  \n  /* localStepsRemoved within 1 */\n  if(syncA->localStepsRemoved < syncB->localStepsRemoved)\n  {\n    DBGV(\"bmcDataSetComparison: A3\\n\");\n    if(memcmp(ptpClock->port_uuid_field, headerB->sourceUuid, PTP_UUID_LENGTH) < 0)\n      return 1;  /* A1 */\n    else if(memcmp(ptpClock->port_uuid_field, headerB->sourceUuid, PTP_UUID_LENGTH) > 0)\n      return 2;  /* A2 */\n    \n    /* this port_uuid_field same as headerB->sourceUuid */\n    if(ptpClock->port_id_field < headerB->sourcePortId)\n      return 1;  /* A1 */\n    else if(ptpClock->port_id_field > headerB->sourcePortId)\n      return 2;  /* A2 */\n    \n    /* this port_id_field same as headerB->sourcePortId */\n    return 0;  /* same */\n  }\n  if(syncA->localStepsRemoved > syncB->localStepsRemoved)\n  {\n    DBGV(\"bmcDataSetComparison: B3\\n\");\n    if(memcmp(ptpClock->port_uuid_field, headerA->sourceUuid, PTP_UUID_LENGTH) < 0)\n      return -1;  /* B1 */\n    else if(memcmp(ptpClock->port_uuid_field, headerB->sourceUuid, PTP_UUID_LENGTH) > 0)\n      return -2;  /* B2 */\n    \n    /* this port_uuid_field same as headerA->sourceUuid */\n    if(ptpClock->port_id_field < headerA->sourcePortId)\n      return -1;  /* B1 */\n    else if(ptpClock->port_id_field > headerA->sourcePortId)\n      return -2;  /* B2 */\n    \n    /* this port_id_field same as headerA->sourcePortId */\n    return 0;  /* same */\n  }\n  \n  /* localStepsRemoved same */\n  if(memcmp(headerA->sourceUuid, headerB->sourceUuid, PTP_UUID_LENGTH) < 0)\n    return 2;  /* A2 */\n  else if(memcmp(headerA->sourceUuid, headerB->sourceUuid, PTP_UUID_LENGTH) > 0)\n    return -2;  /* B2 */\n  \n  /* sourceUuid same */\n  DBGV(\"bmcDataSetComparison: Z\\n\");\n  if(syncA->grandmasterSequenceId > syncB->grandmasterSequenceId)\n    return 3;\n  else if(syncA->grandmasterSequenceId < syncB->grandmasterSequenceId)\n    return -3;\n  \n  /* grandmasterSequenceId same */\n  if(headerA->sequenceId > headerB->sequenceId)\n    return 3;\n  else if(headerA->sequenceId < headerB->sequenceId)\n    return -3;\n  \n  /* sequenceId same */\n  return 0;  /* same */\n  \n  /* oh no, a goto label! the horror! */\nA:\n  if(!syncA->grandmasterPreferred && syncB->grandmasterPreferred)\n    return -1;  /* B1 */\n  else\n    return 1;  /* A1 */\nB:\n  if(syncA->grandmasterPreferred && !syncB->grandmasterPreferred)\n    return 1;  /* A1 */\n  else\n    return -1;  /* B1 */\n}", "path": "src\\bmc.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* perform actions required when leaving 'port_state' and entering 'state' */\n", "func_signal": "void toState(UInteger8 state, PtpClock *ptpClock)", "code": "{\n  ptpClock->message_activity = TRUE;\n\n  /* leaving state tasks */\n  switch(ptpClock->port_state)\n  {\n  case PTP_MASTER:\n    timerStop(SYNC_INTERVAL_TIMER, ptpClock->itimer);\n    timerStart(SYNC_RECEIPT_TIMER, PTP_SYNC_RECEIPT_TIMEOUT(ptpClock->sync_interval), ptpClock->itimer);\n    break;\n    \n  case PTP_SLAVE:\n    initClock(ptpClock);\n    break;\n    \n  default:\n    break;\n  }\n\n  timeToState(state, ptpClock);\n  \n  /* entering state tasks */\n  switch(state)\n  {\n  case PTP_INITIALIZING:\n    DBG(\"state PTP_INITIALIZING\\n\");\n    timerStop(SYNC_RECEIPT_TIMER, ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_INITIALIZING;\n    break;\n    \n  case PTP_FAULTY:\n    DBG(\"state PTP_FAULTY\\n\");\n    timerStop(SYNC_RECEIPT_TIMER, ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_FAULTY;\n    break;\n    \n  case PTP_DISABLED:\n    DBG(\"state change to PTP_DISABLED\\n\");\n    timerStop(SYNC_RECEIPT_TIMER, ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_DISABLED;\n    break;\n    \n  case PTP_LISTENING:\n    DBG(\"state PTP_LISTENING\\n\");\n    \n    timerStart(SYNC_RECEIPT_TIMER, PTP_SYNC_RECEIPT_TIMEOUT(ptpClock->sync_interval), ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_LISTENING;\n    break;\n    \n  case PTP_MASTER:\n    DBG(\"state PTP_MASTER\\n\");\n    \n    if(ptpClock->port_state != PTP_PRE_MASTER)\n      timerStart(SYNC_INTERVAL_TIMER, PTP_SYNC_INTERVAL_TIMEOUT(ptpClock->sync_interval), ptpClock->itimer);\n    \n    timerStop(SYNC_RECEIPT_TIMER, ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_MASTER;\n    break;\n    \n  case PTP_PASSIVE:\n    DBG(\"state PTP_PASSIVE\\n\");\n    ptpClock->port_state = PTP_PASSIVE;\n    break;\n    \n  case PTP_UNCALIBRATED:\n    DBG(\"state PTP_UNCALIBRATED\\n\");\n    ptpClock->port_state = PTP_UNCALIBRATED;\n    break;\n    \n  case PTP_SLAVE:\n    DBG(\"state PTP_PTP_SLAVE\\n\");\n    \n    initClock(ptpClock);\n    \n    /* R is chosen to allow a few syncs before we first get a one-way delay estimate */\n    /* this is to allow the offset filter to fill for an accurate initial clock reset */\n    ptpClock->Q = 0;\n    ptpClock->R = getRand(&ptpClock->random_seed)%4 + 4;\n    DBG(\"Q = %d, R = %d\\n\", ptpClock->Q, ptpClock->R);\n    \n    ptpClock->waitingForFollow = FALSE;\n    ptpClock->delay_req_send_time.seconds = 0;\n    ptpClock->delay_req_send_time.nanoseconds = 0;\n    ptpClock->delay_req_receive_time.seconds = 0;\n    ptpClock->delay_req_receive_time.nanoseconds = 0;\n    \n    timerStart(SYNC_RECEIPT_TIMER, PTP_SYNC_RECEIPT_TIMEOUT(ptpClock->sync_interval), ptpClock->itimer);\n    \n    ptpClock->port_state = PTP_SLAVE;\n    break;\n    \n  default:\n    DBG(\"to unrecognized state\\n\");\n    break;\n  }\n  \n  if(ptpClock->runTimeOpts.displayStats)\n    displayStats(ptpClock);\n}", "path": "src\\protocol.c", "repo_name": "pohly/ptpd", "stars": 16, "license": "other", "language": "c", "size": 522}
{"docstring": "/* usbBuildTxBlock() is called when we have data to transmit and the\n * interrupt routine's transmit buffer is empty.\n */\n", "func_signal": "static inline void usbBuildTxBlock(void)", "code": "{\nusbMsgLen_t wantLen;\nuchar       len;\n\n    wantLen = usbMsgLen;\n    if(wantLen > 8)\n        wantLen = 8;\n    usbMsgLen -= wantLen;\n    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */\n    len = usbDeviceRead(usbTxBuf + 1, wantLen);\n    if(len <= 8){           /* valid data packet */\n        usbCrc16Append(&usbTxBuf[1], len);\n        len += 4;           /* length including sync byte */\n        if(len < 12)        /* a partial package identifies end of message */\n            usbMsgLen = USB_NO_MSG;\n    }else{\n        len = USBPID_STALL;   /* stall the endpoint */\n        usbMsgLen = USB_NO_MSG;\n    }\n    usbTxLen = len;\n    DBG2(0x20, usbTxBuf, len-1);\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for\n * standard requests instead of class and custom requests.\n */\n", "func_signal": "static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)", "code": "{\nuchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */\nuchar   value = rq->wValue.bytes[0];\n#if USB_CFG_IMPLEMENT_HALT\nuchar   index = rq->wIndex.bytes[0];\n#endif\n\n    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */\n    SWITCH_START(rq->bRequest)\n    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */\n        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */\n        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)\n            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;\n#if USB_CFG_IMPLEMENT_HALT\n        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */\n            dataPtr[0] = usbTxLen1 == USBPID_STALL;\n#endif\n        dataPtr[1] = 0;\n        len = 2;\n#if USB_CFG_IMPLEMENT_HALT\n    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */\n        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */\n            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;\n            usbResetDataToggling();\n        }\n#endif\n    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */\n        usbNewDeviceAddr = value;\n        USB_SET_ADDRESS_HOOK();\n    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */\n        len = usbDriverDescriptor(rq);\n        goto skipMsgPtrAssignment;\n    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */\n        dataPtr = &usbConfiguration;  /* send current configuration value */\n        len = 1;\n    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */\n        usbConfiguration = value;\n        usbResetStall();\n    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */\n        len = 1;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */\n        usbResetDataToggling();\n        usbResetStall();\n#endif\n    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */\n        /* Should we add an optional hook here? */\n    SWITCH_END\n    usbMsgPtr = dataPtr;\nskipMsgPtrAssignment:\n    return len;\n}", "path": "firmware-keyboard\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void usbHandleResetHook(uchar notResetState)", "code": "{\n#ifdef USB_RESET_HOOK\nstatic uchar    wasReset;\nuchar           isReset = !notResetState;\n\n    if(wasReset != isReset){\n        USB_RESET_HOOK(isReset);\n        wasReset = isReset;\n    }\n#endif\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for\n * standard requests instead of class and custom requests.\n */\n", "func_signal": "static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)", "code": "{\nuchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */\nuchar   value = rq->wValue.bytes[0];\n#if USB_CFG_IMPLEMENT_HALT\nuchar   index = rq->wIndex.bytes[0];\n#endif\n\n    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */\n    SWITCH_START(rq->bRequest)\n    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */\n        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */\n        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)\n            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;\n#if USB_CFG_IMPLEMENT_HALT\n        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */\n            dataPtr[0] = usbTxLen1 == USBPID_STALL;\n#endif\n        dataPtr[1] = 0;\n        len = 2;\n#if USB_CFG_IMPLEMENT_HALT\n    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */\n        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */\n            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;\n            usbResetDataToggling();\n        }\n#endif\n    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */\n        usbNewDeviceAddr = value;\n        USB_SET_ADDRESS_HOOK();\n    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */\n        len = usbDriverDescriptor(rq);\n        goto skipMsgPtrAssignment;\n    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */\n        dataPtr = &usbConfiguration;  /* send current configuration value */\n        len = 1;\n    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */\n        usbConfiguration = value;\n        usbResetStall();\n    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */\n        len = 1;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */\n        usbResetDataToggling();\n        usbResetStall();\n#endif\n    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */\n        /* Should we add an optional hook here? */\n    SWITCH_END\n    usbMsgPtr = dataPtr;\nskipMsgPtrAssignment:\n    return len;\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void  usbResetDataToggling(void)", "code": "{\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   endif\n#endif\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbBuildTxBlock() is called when we have data to transmit and the\n * interrupt routine's transmit buffer is empty.\n */\n", "func_signal": "static inline void usbBuildTxBlock(void)", "code": "{\nusbMsgLen_t wantLen;\nuchar       len;\n\n    wantLen = usbMsgLen;\n    if(wantLen > 8)\n        wantLen = 8;\n    usbMsgLen -= wantLen;\n    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */\n    len = usbDeviceRead(usbTxBuf + 1, wantLen);\n    if(len <= 8){           /* valid data packet */\n        usbCrc16Append(&usbTxBuf[1], len);\n        len += 4;           /* length including sync byte */\n        if(len < 12)        /* a partial package identifies end of message */\n            usbMsgLen = USB_NO_MSG;\n    }else{\n        len = USBPID_STALL;   /* stall the endpoint */\n        usbMsgLen = USB_NO_MSG;\n    }\n    usbTxLen = len;\n    DBG2(0x20, usbTxBuf, len-1);\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void usbHandleResetHook(uchar notResetState)", "code": "{\n#ifdef USB_RESET_HOOK\nstatic uchar    wasReset;\nuchar           isReset = !notResetState;\n\n    if(wasReset != isReset){\n        USB_RESET_HOOK(isReset);\n        wasReset = isReset;\n    }\n#endif\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* This function is similar to usbFunctionRead(), but it's also called for\n * data handled automatically by the driver (e.g. descriptor reads).\n */\n", "func_signal": "static uchar usbDeviceRead(uchar *data, uchar len)", "code": "{\n    if(len > 0){    /* don't bother app with 0 sized reads */\n#if USB_CFG_IMPLEMENT_FN_READ\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            len = usbFunctionRead(data, len);\n        }else\n#endif\n        {\n            uchar i = len, *r = usbMsgPtr;\n            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */\n                do{\n                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */\n                    *data++ = c;\n                    r++;\n                }while(--i);\n            }else{  /* RAM data */\n                do{\n                    *data++ = *r++;\n                }while(--i);\n            }\n            usbMsgPtr = r;\n        }\n    }\n    return len;\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void  usbResetDataToggling(void)", "code": "{\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   endif\n#endif\n}", "path": "firmware-keyboard\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbPoll(void)", "code": "{\nschar   len;\nuchar   i;\n\n    len = usbRxLen - 3;\n    if(len >= 0){\n/* We could check CRC16 here -- but ACK has already been sent anyway. If you\n * need data integrity checks with this driver, check the CRC in your app\n * code and report errors back to the host. Since the ACK was already sent,\n * retries must be handled on application level.\n * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);\n */\n        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);\n#if USB_CFG_HAVE_FLOWCONTROL\n        if(usbRxLen > 0)    /* only mark as available if not inactivated */\n            usbRxLen = 0;\n#else\n        usbRxLen = 0;       /* mark rx buffer as available */\n#endif\n    }\n    if(usbTxLen & 0x10){    /* transmit system idle */\n        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */\n            usbBuildTxBlock();\n        }\n    }\n    for(i = 20; i > 0; i--){\n        uchar usbLineStatus = USBIN & USBMASK;\n        if(usbLineStatus != 0)  /* SE0 has ended */\n            goto isNotReset;\n    }\n    /* RESET condition, called multiple times during reset */\n    usbNewDeviceAddr = 0;\n    usbDeviceAddr = 0;\n    usbResetStall();\n    DBG1(0xff, 0, 0);\nisNotReset:\n    usbHandleResetHook(i);\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for\n * standard requests instead of class and custom requests.\n */\n", "func_signal": "static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)", "code": "{\nuchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */\nuchar   value = rq->wValue.bytes[0];\n#if USB_CFG_IMPLEMENT_HALT\nuchar   index = rq->wIndex.bytes[0];\n#endif\n\n    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */\n    SWITCH_START(rq->bRequest)\n    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */\n        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */\n        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)\n            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;\n#if USB_CFG_IMPLEMENT_HALT\n        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */\n            dataPtr[0] = usbTxLen1 == USBPID_STALL;\n#endif\n        dataPtr[1] = 0;\n        len = 2;\n#if USB_CFG_IMPLEMENT_HALT\n    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */\n        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */\n            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;\n            usbResetDataToggling();\n        }\n#endif\n    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */\n        usbNewDeviceAddr = value;\n        USB_SET_ADDRESS_HOOK();\n    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */\n        len = usbDriverDescriptor(rq);\n        goto skipMsgPtrAssignment;\n    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */\n        dataPtr = &usbConfiguration;  /* send current configuration value */\n        len = 1;\n    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */\n        usbConfiguration = value;\n        usbResetStall();\n    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */\n        len = 1;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */\n        usbResetDataToggling();\n        usbResetStall();\n#endif\n    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */\n        /* Should we add an optional hook here? */\n    SWITCH_END\n    usbMsgPtr = dataPtr;\nskipMsgPtrAssignment:\n    return len;\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void usbHandleResetHook(uchar notResetState)", "code": "{\n#ifdef USB_RESET_HOOK\nstatic uchar    wasReset;\nuchar           isReset = !notResetState;\n\n    if(wasReset != isReset){\n        USB_RESET_HOOK(isReset);\n        wasReset = isReset;\n    }\n#endif\n}", "path": "firmware-keyboard\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbProcessRx() is called for every message received by the interrupt\n * routine. It distinguishes between SETUP and DATA packets and processes\n * them accordingly.\n */\n", "func_signal": "static inline void usbProcessRx(uchar *data, uchar len)", "code": "{\nusbRequest_t    *rq = (void *)data;\n\n/* usbRxToken can be:\n * 0x2d 00101101 (USBPID_SETUP for setup data)\n * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)\n * 0...0x0f for OUT on endpoint X\n */\n    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */\n    USB_RX_USER_HOOK(data, len)\n#if USB_CFG_IMPLEMENT_FN_WRITEOUT\n    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */\n        usbFunctionWriteOut(data, len);\n        return;\n    }\n#endif\n    if(usbRxToken == (uchar)USBPID_SETUP){\n        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */\n            return;\n        usbMsgLen_t replyLen;\n        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */\n        usbTxLen = USBPID_NAK;              /* abort pending transmit */\n        usbMsgFlags = 0;\n        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;\n        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */\n            replyLen = usbFunctionSetup(data);\n        }else{\n            replyLen = usbDriverSetup(rq);\n        }\n#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE\n        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */\n            /* do some conditioning on replyLen, but on IN transfers only */\n            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){\n                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n                    replyLen = rq->wLength.bytes[0];\n                }else{\n                    replyLen = rq->wLength.word;\n                }\n            }\n            usbMsgFlags = USB_FLG_USE_USER_RW;\n        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */\n#endif\n        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */\n                replyLen = rq->wLength.bytes[0];\n        }else{\n            if(replyLen > rq->wLength.word)     /* limit length to max */\n                replyLen = rq->wLength.word;\n        }\n        usbMsgLen = replyLen;\n    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */\n#if USB_CFG_IMPLEMENT_FN_WRITE\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            uchar rval = usbFunctionWrite(data, len);\n            if(rval == 0xff){   /* an error occurred */\n                usbTxLen = USBPID_STALL;\n            }else if(rval != 0){    /* This was the final package */\n                usbMsgLen = 0;  /* answer with a zero-sized data packet */\n            }\n        }\n#endif\n    }\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbInit(void)", "code": "{\n#if USB_INTR_CFG_SET != 0\n    USB_INTR_CFG |= USB_INTR_CFG_SET;\n#endif\n#if USB_INTR_CFG_CLR != 0\n    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);\n#endif\n    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);\n    usbResetDataToggling();\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    usbTxLen1 = USBPID_NAK;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    usbTxLen3 = USBPID_NAK;\n#endif\n#endif\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbPoll(void)", "code": "{\nschar   len;\nuchar   i;\n\n    len = usbRxLen - 3;\n    if(len >= 0){\n/* We could check CRC16 here -- but ACK has already been sent anyway. If you\n * need data integrity checks with this driver, check the CRC in your app\n * code and report errors back to the host. Since the ACK was already sent,\n * retries must be handled on application level.\n * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);\n */\n        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);\n#if USB_CFG_HAVE_FLOWCONTROL\n        if(usbRxLen > 0)    /* only mark as available if not inactivated */\n            usbRxLen = 0;\n#else\n        usbRxLen = 0;       /* mark rx buffer as available */\n#endif\n    }\n    if(usbTxLen & 0x10){    /* transmit system idle */\n        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */\n            usbBuildTxBlock();\n        }\n    }\n    for(i = 20; i > 0; i--){\n        uchar usbLineStatus = USBIN & USBMASK;\n        if(usbLineStatus != 0)  /* SE0 has ended */\n            goto isNotReset;\n    }\n    /* RESET condition, called multiple times during reset */\n    usbNewDeviceAddr = 0;\n    usbDeviceAddr = 0;\n    usbResetStall();\n    DBG1(0xff, 0, 0);\nisNotReset:\n    usbHandleResetHook(i);\n}", "path": "firmware-keyboard\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbPoll(void)", "code": "{\nschar   len;\nuchar   i;\n\n    len = usbRxLen - 3;\n    if(len >= 0){\n/* We could check CRC16 here -- but ACK has already been sent anyway. If you\n * need data integrity checks with this driver, check the CRC in your app\n * code and report errors back to the host. Since the ACK was already sent,\n * retries must be handled on application level.\n * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);\n */\n        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);\n#if USB_CFG_HAVE_FLOWCONTROL\n        if(usbRxLen > 0)    /* only mark as available if not inactivated */\n            usbRxLen = 0;\n#else\n        usbRxLen = 0;       /* mark rx buffer as available */\n#endif\n    }\n    if(usbTxLen & 0x10){    /* transmit system idle */\n        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */\n            usbBuildTxBlock();\n        }\n    }\n    for(i = 20; i > 0; i--){\n        uchar usbLineStatus = USBIN & USBMASK;\n        if(usbLineStatus != 0)  /* SE0 has ended */\n            goto isNotReset;\n    }\n    /* RESET condition, called multiple times during reset */\n    usbNewDeviceAddr = 0;\n    usbDeviceAddr = 0;\n    usbResetStall();\n    DBG1(0xff, 0, 0);\nisNotReset:\n    usbHandleResetHook(i);\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static inline void  usbResetDataToggling(void)", "code": "{\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */\n#   endif\n#endif\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* This function is similar to usbFunctionRead(), but it's also called for\n * data handled automatically by the driver (e.g. descriptor reads).\n */\n", "func_signal": "static uchar usbDeviceRead(uchar *data, uchar len)", "code": "{\n    if(len > 0){    /* don't bother app with 0 sized reads */\n#if USB_CFG_IMPLEMENT_FN_READ\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            len = usbFunctionRead(data, len);\n        }else\n#endif\n        {\n            uchar i = len, *r = usbMsgPtr;\n            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */\n                do{\n                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */\n                    *data++ = c;\n                    r++;\n                }while(--i);\n            }else{  /* RAM data */\n                do{\n                    *data++ = *r++;\n                }while(--i);\n            }\n            usbMsgPtr = r;\n        }\n    }\n    return len;\n}", "path": "firmware-sensor\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* usbProcessRx() is called for every message received by the interrupt\n * routine. It distinguishes between SETUP and DATA packets and processes\n * them accordingly.\n */\n", "func_signal": "static inline void usbProcessRx(uchar *data, uchar len)", "code": "{\nusbRequest_t    *rq = (void *)data;\n\n/* usbRxToken can be:\n * 0x2d 00101101 (USBPID_SETUP for setup data)\n * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)\n * 0...0x0f for OUT on endpoint X\n */\n    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */\n    USB_RX_USER_HOOK(data, len)\n#if USB_CFG_IMPLEMENT_FN_WRITEOUT\n    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */\n        usbFunctionWriteOut(data, len);\n        return;\n    }\n#endif\n    if(usbRxToken == (uchar)USBPID_SETUP){\n        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */\n            return;\n        usbMsgLen_t replyLen;\n        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */\n        usbTxLen = USBPID_NAK;              /* abort pending transmit */\n        usbMsgFlags = 0;\n        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;\n        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */\n            replyLen = usbFunctionSetup(data);\n        }else{\n            replyLen = usbDriverSetup(rq);\n        }\n#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE\n        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */\n            /* do some conditioning on replyLen, but on IN transfers only */\n            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){\n                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n                    replyLen = rq->wLength.bytes[0];\n                }else{\n                    replyLen = rq->wLength.word;\n                }\n            }\n            usbMsgFlags = USB_FLG_USE_USER_RW;\n        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */\n#endif\n        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */\n            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */\n                replyLen = rq->wLength.bytes[0];\n        }else{\n            if(replyLen > rq->wLength.word)     /* limit length to max */\n                replyLen = rq->wLength.word;\n        }\n        usbMsgLen = replyLen;\n    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */\n#if USB_CFG_IMPLEMENT_FN_WRITE\n        if(usbMsgFlags & USB_FLG_USE_USER_RW){\n            uchar rval = usbFunctionWrite(data, len);\n            if(rval == 0xff){   /* an error occurred */\n                usbTxLen = USBPID_STALL;\n            }else if(rval != 0){    /* This was the final package */\n                usbMsgLen = 0;  /* answer with a zero-sized data packet */\n            }\n        }\n#endif\n    }\n}", "path": "firmware-keyboard\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "USB_PUBLIC void usbInit(void)", "code": "{\n#if USB_INTR_CFG_SET != 0\n    USB_INTR_CFG |= USB_INTR_CFG_SET;\n#endif\n#if USB_INTR_CFG_CLR != 0\n    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);\n#endif\n    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);\n    usbResetDataToggling();\n#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE\n    usbTxLen1 = USBPID_NAK;\n#if USB_CFG_HAVE_INTRIN_ENDPOINT3\n    usbTxLen3 = USBPID_NAK;\n#endif\n#endif\n}", "path": "firmware\\usbdrv\\usbdrv.c", "repo_name": "fabiobaltieri/avr-micro-usb", "stars": 28, "license": "gpl-3.0", "language": "c", "size": 394}
{"docstring": "/*\n  memc_list_hash_types\n  this is informational so the user doesn't have to know the values by heart\n*/\n", "func_signal": "char *memc_list_hash_types(UDF_INIT *initid,\n                          __attribute__ ((unused)) UDF_ARGS *args,\n                          __attribute__ ((unused)) char *result,\n                          unsigned long *length,\n                          __attribute__ ((unused)) char *is_null,\n                          __attribute__ ((unused)) char *error)", "code": "{\n  *length= HASH_TYPES_STRING_LENGTH + 1;\n  return (HASH_TYPES_STRING);\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_server_count\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "long long memc_server_count(__attribute__ ((unused)) UDF_INIT *initid,\n                       __attribute__ ((unused)) UDF_ARGS *args,\n                       __attribute__ ((unused)) char *result,\n                       __attribute__ ((unused)) unsigned long *length,\n                       __attribute__ ((unused)) char *is_null,\n                       __attribute__ ((unused)) char *error)", "code": "{\n\n  unsigned int count;\n  pthread_mutex_lock(&memc_servers_mutex);\n\n  if (master_memc == NULL)\n    master_memc= memcached_create(NULL);\n\n  count= memcached_server_count(master_memc);\n\n  pthread_mutex_unlock(&memc_servers_mutex);\n\n  return ((long long) count);\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  @@brief\n  memc_get_servers() take a memc structure and clones the master structures into it.\n  Each UDF calls this to gain access to the information it needs to speak\n  with memcached.\n*/\n", "func_signal": "int memc_get_servers(memcached_st *clone)", "code": "{\n  int retval;\n  memcached_st *test;\n  unsigned int count;\n  memcached_return rc= 0;\n\n  pthread_mutex_lock(&memc_servers_mutex);\n  if (master_memc == NULL)\n    master_memc= memcached_create(NULL);\n  count= memcached_server_count(master_memc);\n  if (count == 0)\n  {\n      memcached_server_st *servers;\n\n      servers = memcached_servers_parse(\"127.0.0.1:22201\");\n      if (servers != NULL)\n      {\n          rc= memcached_server_push(master_memc, servers);\n          if (rc == MEMCACHED_SUCCESS)\n          {\n          }\n          memcached_server_list_free(servers);\n      }\n  }\n  test= memcached_clone(clone, master_memc);\n  pthread_mutex_unlock(&memc_servers_mutex);\n  retval= test ? 1 : 0;\n\n  return retval ;\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* de-init UDF */\n", "func_signal": "void memc_get_by_key_deinit(UDF_INIT *initid)", "code": "{\n  /* if we allocated initid->ptr, free it here */\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  memcached_result_free(&container->results);\n  memcached_free(&container->memc);\n  free(container);\n\n  return;\n}", "path": "src\\get.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* memc_servers_behavior_set_init */\n", "func_signal": "my_bool memc_servers_behavior_get_init(__attribute__ ((unused)) UDF_INIT *initid,\n                                       UDF_ARGS *args,\n                                       char *message)", "code": "{\n  unsigned int count;\n  /* Fail if not two args */\n  if (args->arg_count != 1)\n  {\n    strncpy(message,\n            \"one argument must be supplied: memc_servers_behavior_get('<behavior type>')\",\n            MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n  pthread_mutex_lock(&memc_servers_mutex);\n  if (master_memc == NULL)\n    master_memc= memcached_create(NULL);\n  count= memcached_server_count(master_memc);\n\n  pthread_mutex_unlock(&memc_servers_mutex);\n\n  if (!count) {\n    strncpy(message,\n            \"Servers not set! memc_servers_set('server:port,...')\",\n            MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n  args->arg_type[0]= STRING_RESULT;\n\n  /* make sure valid behavior */\n  if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SUPPORT_CAS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_NO_BLOCK\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_POLL_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_RETRY_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_USER_DATA\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SORT_HOSTS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_VERIFY_KEY\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_TCP_NODELAY\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_DISTRIBUTION\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA_HASH\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_HASH\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_POLL_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_RETRY_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK\"))\n  {\n        return 0;\n  }\n  else\n  {\n    strncpy(message, \"UNKNOWN BEHAVIOR TYPE! try memc_list_behaviors() for a list of behaviors.\", MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_mget\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "char *memc_mget(UDF_INIT *initid, UDF_ARGS *args,\n                __attribute__ ((unused)) char *result,\n               unsigned long *length,\n                __attribute__ ((unused)) char *is_null,\n                __attribute__ ((unused)) char *error)", "code": "{\n  /* how do I utilise this? Print out in case of error? */\n  memcached_return rc;\n  /* We'll just hard-code now? */\n\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  rc= memcached_mget(&container->memc, args->args,\n                     (size_t *)args->lengths,\n                     args->arg_count);\n\n  return ((long long)rc);\n}", "path": "src\\mget.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_servers_set\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "char *memc_udf_version(__attribute__ ((unused)) UDF_INIT *initid,\n                       __attribute__ ((unused)) UDF_ARGS *args,\n                       __attribute__ ((unused)) char *result,\n                       __attribute__ ((unused)) unsigned long *length,\n                       __attribute__ ((unused)) char *is_null,\n                       __attribute__ ((unused)) char *error)", "code": "{\n  char *version_string= initid->ptr;\n  *length= VERSION_STRING_LENGTH;\n  return (version_string);\n}", "path": "src\\version.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_prefix_get - obtaincurrent prefix\n*/\n", "func_signal": "char *memc_prefix_get(__attribute__ ((unused)) UDF_INIT *initid,\n                          UDF_ARGS *args,\n                          __attribute__ ((unused)) char *is_null,\n                          char *error)", "code": "{\n  memcached_return rc;\n  char *prefix;\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  prefix= memcached_callback_get(&container->memc,\n                             MEMCACHED_CALLBACK_PREFIX_KEY,\n                             &rc);\n\n  if (rc != MEMCACHED_SUCCESS)\n  {\n    sprintf(error,\"Failure getting prefix\\n\");\n    return ((char *)NULL);\n  }\n\n  return (prefix);\n\n}", "path": "src\\prefix.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* de-init UDF */\n", "func_signal": "void memc_stat_get_value_deinit(UDF_INIT *initid)", "code": "{\n  /* if we allocated initid->ptr, free it here */\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  memcached_free(&container->memc);\n  free(container);\n\n  return;\n}", "path": "src\\stats.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* de-init UDF */\n", "func_signal": "void memc_get_deinit(UDF_INIT *initid)", "code": "{\n  /* if we allocated initid->ptr, free it here */\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  memcached_result_free(&container->results);\n  memcached_free(&container->memc);\n  free(container);\n\n  return;\n}", "path": "src\\get.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_servers_set\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "long long memc_servers_set(__attribute__ ((unused)) UDF_INIT *initid,\n                       UDF_ARGS *args,\n                       __attribute__ ((unused)) char *result,\n                       __attribute__ ((unused)) unsigned long *length,\n                       char *is_null,\n                       __attribute__ ((unused)) char *error)", "code": "{\n  uint64_t set= 1;\n  memcached_return rc= 0;\n  memcached_server_st *servers;\n  uint version;\n\n\n  pthread_mutex_lock(&memc_servers_mutex);\n\n  if (master_memc == NULL)\n    master_memc= memcached_create(NULL);\n  if (master_memc == NULL)\n  {\n    *is_null= 1;\n    return 0;\n  }\n\n  servers= memcached_servers_parse(args->args[0]);\n  if (servers == NULL)\n  {\n    *is_null= 1;\n    return 0;\n  }\n  rc= memcached_server_push(master_memc, servers);\n  if (rc != MEMCACHED_SUCCESS)\n  {\n    *is_null= 1;\n    return 0;\n  }\n  /*\n    enable cas by default. This can be undonw with\n    memc_behavior_set\n  */\n  memcached_version(master_memc);\n\n  /*\n   * don't enable CAS anyway, this breaks MemcacheQ\n   *\n   * If server pool is heterogenous for some reason,\n   * (memcached was added as first server and CAS\n   * was enabled, then MemcacheQ added).\n   */\n\n  /*if (master_memc->hosts[0].major_version >= 1 &&\n      master_memc->hosts[0].minor_version >= 2 &&\n      master_memc->hosts[0].micro_version >= 4)\n    memcached_behavior_set(master_memc, MEMCACHED_BEHAVIOR_SUPPORT_CAS, set);\n    fprintf(stderr, \"version %d.%d.%d\\n\", master_memc->hosts[0].major_version,\n            master_memc->hosts[0].minor_version,\n            master_memc->hosts[0].micro_version);*/\n\n  memcached_server_list_free(servers);\n\n  pthread_mutex_unlock(&memc_servers_mutex);\n\n  fprintf(stderr, \"rc %d\\n\", rc);\n  return ((long long) rc == MEMCACHED_SUCCESS ? 0 : rc);\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_list_distribution_types\n  this is informational so the user doesn't have to know the values by heart\n*/\n", "func_signal": "char *memc_list_distribution_types(UDF_INIT *initid,\n                          __attribute__ ((unused)) UDF_ARGS *args,\n                          __attribute__ ((unused)) char *result,\n                          unsigned long *length,\n                          __attribute__ ((unused)) char *is_null,\n                          __attribute__ ((unused)) char *error)", "code": "{\n  *length= DISTRIBUTION_TYPES_STRING_LENGTH + 1;\n  return (DISTRIBUTION_TYPES_STRING);\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* de-init UDF */\n", "func_signal": "void memc_stat_get_keys_deinit(UDF_INIT *initid)", "code": "{\n  /* if we allocated initid->ptr, free it here */\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  free_string(container->stats_string);\n  memcached_free(&container->memc);\n  free(container);\n\n  return;\n}", "path": "src\\stats.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_ge\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "char *memc_mget_by_key(UDF_INIT *initid, UDF_ARGS *args,\n                __attribute__ ((unused)) char *result,\n               unsigned long *length,\n                __attribute__ ((unused)) char *is_null,\n                __attribute__ ((unused)) char *error)", "code": "{\n  /* how do I utilise this? Print out in case of error? */\n  memcached_return rc;\n  char *value;\n  char **keys;\n  size_t *lengths;\n  keys= args->args;\n  keys++;\n  lengths= (size_t*)args->lengths;\n  lengths++;\n\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  rc= memcached_mget_by_key(&container->memc,\n                              args->args[0],\n                              (size_t )args->lengths[0],\n                              keys,\n                              lengths,\n                              args->arg_count - 1);\n\n  memcached_fetch_result(&container->memc, &container->results, &rc);\n  *length= memcached_result_length(&container->results);\n\n  return (memcached_result_value(&container->results));\n}", "path": "src\\mget.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_ge\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "char *memc_get_by_key(UDF_INIT *initid, UDF_ARGS *args,\n                      __attribute__ ((unused)) char *result,\n                      unsigned long *length,\n                      char *is_null,\n                      __attribute__ ((unused)) char *error)", "code": "{\n  /* how do I utilise this? Print out in case of error? */\n  memcached_return rc;\n  char *value;\n  char **keys;\n  size_t *lengths;\n  keys= args->args;\n  keys++;\n  lengths= (size_t*)args->lengths;\n  lengths++;\n\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  rc= memcached_mget_by_key(&container->memc,\n                              args->args[0],\n                              (size_t )args->lengths[0],\n                              keys,\n                              lengths,\n                              args->arg_count - 1);\n\n  memcached_fetch_result(&container->memc, &container->results, &rc);\n  *length= memcached_result_length(&container->results);\n  if (! *length)\n  {\n    *is_null= 1;\n  }\n\n  return (memcached_result_value(&container->results));\n}", "path": "src\\get.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* de-init UDF */\n", "func_signal": "void memc_get_cas_deinit(UDF_INIT *initid)", "code": "{\n  /* if we allocated initid->ptr, free it here */\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  memcached_result_free(&container->results);\n  free(container);\n\n  return;\n}", "path": "src\\get_cas.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* memc_servers_behavior_set */\n", "func_signal": "long long memc_servers_behavior_set(__attribute__ ((unused)) UDF_INIT *initid,\n                                    UDF_ARGS *args,\n                                    __attribute__ ((unused)) char *is_null,\n                                    __attribute__ ((unused)) char *error)", "code": "{\n  memcached_return rc;\n  memcached_behavior behavior;\n  uint64_t setting;\n\n  if (args->arg_type[1] == INT_RESULT)\n    setting= *(uint64_t*) args->args[1];\n  else if (args->arg_type[1] == STRING_RESULT)\n    setting= (uint64_t)atoi(args->args[1]);\n\n  if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SUPPORT_CAS\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SUPPORT_CAS;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_NO_BLOCK\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_NO_BLOCK;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_TCP_NODELAY\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_TCP_NODELAY;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_HASH\"))\n  {\n    if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_DEFAULT\"))\n    {\n      setting= MEMCACHED_HASH_DEFAULT;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_MD5\"))\n    {\n      setting= MEMCACHED_HASH_MD5;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_CRC\"))\n    {\n      setting= MEMCACHED_HASH_CRC;\n    }\n    else if (! strcasecmp(args->args[1],\"MEMCACHED_HASH_FNV1_64\"))\n    {\n      setting= MEMCACHED_HASH_FNV1_64;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_64\"))\n    {\n      setting= MEMCACHED_HASH_FNV1A_64;\n    }\n    else if (! strcasecmp(args->args[1],\"MEMCACHED_HASH_FNV1_32\"))\n    {\n      setting= MEMCACHED_HASH_FNV1_32;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_32\"))\n    {\n      setting= MEMCACHED_HASH_FNV1A_32;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_JENKINS\"))\n    {\n      setting= MEMCACHED_HASH_JENKINS;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_HSIEH\"))\n    {\n      setting= MEMCACHED_HASH_HSIEH;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_MURMUR\"))\n    {\n      setting= MEMCACHED_HASH_MURMUR;\n    }\n    else {\n      setting= MEMCACHED_HASH_DEFAULT;\n    }\n    behavior= MEMCACHED_BEHAVIOR_HASH;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_CACHE_LOOKUPS;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_BUFFER_REQUESTS;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_BUFFER_REQUESTS;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_KETAMA;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_POLL_TIMEOUT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_POLL_TIMEOUT;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_RETRY_TIMEOUT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_RETRY_TIMEOUT;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_DISTRIBUTION\"))\n  {\n    if (! strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_MODULA\")) \n      setting= MEMCACHED_DISTRIBUTION_MODULA;\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_CONSISTENT\")) \n      setting= MEMCACHED_DISTRIBUTION_CONSISTENT;\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA\")) \n      setting= MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA;\n    else\n      setting= MEMCACHED_DISTRIBUTION_MODULA;\n\n    behavior= MEMCACHED_BEHAVIOR_DISTRIBUTION;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_USER_DATA\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_USER_DATA;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SORT_HOSTS\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SORT_HOSTS;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_VERIFY_KEY\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_VERIFY_KEY;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA_HASH\"))\n  {\n    if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_DEFAULT\"))\n    {\n      setting= MEMCACHED_HASH_DEFAULT;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_MD5\"))\n    {\n      setting= MEMCACHED_HASH_MD5;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_CRC\"))\n    {\n      setting= MEMCACHED_HASH_CRC;\n    }\n    else if (! strcasecmp(args->args[1],\"MEMCACHED_HASH_FNV1_64\"))\n    {\n      setting= MEMCACHED_HASH_FNV1_64;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_64\"))\n    {\n      setting= MEMCACHED_HASH_FNV1A_64;\n    }\n    else if (! strcasecmp(args->args[1],\"MEMCACHED_HASH_FNV1_32\"))\n    {\n      setting= MEMCACHED_HASH_FNV1_32;\n    }\n    else if (! strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_32\"))\n    {\n      setting= MEMCACHED_HASH_FNV1A_32;\n    }\n    else {\n      setting= MEMCACHED_HASH_DEFAULT;\n    }\n    behavior= MEMCACHED_BEHAVIOR_KETAMA_HASH;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BINARY_PROTOCOL\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_BINARY_PROTOCOL;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SND_TIMEOUT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SND_TIMEOUT;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_RCV_TIMEOUT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_RCV_TIMEOUT;\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT;\n\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK;\n\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK\"))\n  {\n    behavior= MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK;\n\n  }\n  else\n  {\n    sprintf(error, \"ERROR: UNKNOWN BEHAVIOR TYPE!\");\n    return 1;\n  }\n\n\n  /*\n    Get a lock and modify the behavior of the master_memc\n    that changes memcached_st behavior.\n  */\n  pthread_mutex_lock(&memc_servers_mutex);\n  rc= memcached_behavior_set(master_memc, behavior, setting);\n  pthread_mutex_unlock(&memc_servers_mutex);\n\n  return 0;\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_get_cas_by_key\n  get cas value of cached item, takes hash-key arg\n*/\n", "func_signal": "long long memc_get_cas_by_key(UDF_INIT *initid, UDF_ARGS *args,\n                      __attribute__ ((unused)) char *is_null,\n                      __attribute__ ((unused)) char *error)", "code": "{\n  memcached_return rc;\n  uint64_t cas = 0;\n  char **keys;\n  size_t *lengths;\n  size_t length;\n  keys= args->args;\n  keys++;\n  lengths= (size_t*)args->lengths;\n  lengths++;\n  memcached_result_st *results;\n\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  /* get the item */\n  rc= memcached_mget_by_key(&container->memc,\n                            args->args[0],\n                            (size_t )args->lengths[0],\n                            (const char **) keys,\n                            lengths,\n                            args->arg_count - 1);\n  /* create a result */\n  results= memcached_result_create(&container->memc, &container->results);\n\n  /* fetch the result */\n  memcached_fetch_result(&container->memc, results, &rc);\n\n  /* obtain length so we have something to check */\n  length= memcached_result_length(results);\n  if (! length)\n  {\n     /* function to return null if no value */\n    *is_null= 1;\n    return 0;\n  }\n\n  /* we now have the cas value */\n  cas = memcached_result_cas(results);\n\n  /* free the result */\n  //memcached_result_free(results);\n\n  /* return the cas value */\n  return (long long) cas;\n}", "path": "src\\get_cas.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* memc_servers_behavior_set_init */\n", "func_signal": "my_bool memc_servers_behavior_set_init(__attribute__ ((unused)) UDF_INIT *initid,\n                                       UDF_ARGS *args,\n                                       char *message)", "code": "{\n  uint64_t setting;\n  unsigned int count;\n\n  /* Fail if not two args */\n  if (args->arg_count != 2)\n  {\n    strncpy(message,\n            \"2 arguments must be supplied: memc_servers_behavior_set('<behavior type>', '<value>')\",\n            MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n  pthread_mutex_lock(&memc_servers_mutex);\n  if (master_memc == NULL)\n    master_memc= memcached_create(NULL);\n\n  count= memcached_server_count(master_memc);\n\n  pthread_mutex_unlock(&memc_servers_mutex);\n\n  if (!count) {\n    strncpy(message,\n            \"Servers not set! memc_servers_set('server:port,...')\",\n            MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n\n  args->arg_type[0]= STRING_RESULT;\n\n  if (args->arg_type[1] == INT_RESULT)\n    setting= *(uint64_t*) args->args[1];\n  else if (args->arg_type[1] == STRING_RESULT)\n    setting= (uint64_t)atoi(args->args[1]);\n\n  /*\n    Do some checking of supplied behavior and setting\n\n    If a 1|0 value, check. Print error if not. We need some sort of \n    check for the other non 1|0 behaviors\n  */\n  if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SUPPORT_CAS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_NO_BLOCK\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_USER_DATA\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SORT_HOSTS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_VERIFY_KEY\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_TCP_NODELAY\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS\"))\n  {\n      if (setting != 1 && setting != 0) {\n        strncpy(message, \"INALID VALUE FOR BEHAVIOR - MUST BE 1 OR 0 !\\n\", MYSQL_ERRMSG_SIZE);\n        return 1;\n      }\n  }\n  else if ( ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_DISTRIBUTION\"))\n  {\n    if (strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_MODULA\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_CONSISTENT\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA\") )\n    {\n        strncpy(message, \"INALID VALUE FOR DISTRIBUTION! see: memc_list_distribution_types();\", MYSQL_ERRMSG_SIZE);\n        return 1;\n    }\n    /* args->arg_type[1]= STRING_RESULT; */\n  }\n  else if (! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_HASH\"))\n  {\n    if (strcasecmp(args->args[1], \"MEMCACHED_HASH_DEFAULT\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_MD5\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_CRC\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1_64\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_64\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1_32\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_32\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_JENKINS\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_HSIEH\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_MURMUR\"))\n    {\n        strncpy(message, \"INVALID VALUE FOR MEMCACHED HASH ALGORITHM! see: memc_list_hash_types();\", 71);\n        return 1;\n    }\n    /*args->arg_type[1]= STRING_RESULT;*/\n  }\n  else if ( ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_KETAMA_HASH\"))\n  {\n    if (strcasecmp(args->args[1], \"MEMCACHED_HASH_DEFAULT\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_MD5\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_CRC\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1_64\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_64\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1_32\") &&\n        strcasecmp(args->args[1], \"MEMCACHED_HASH_FNV1A_32\"))\n    {\n        strncpy(message, \"INVALID VALUE FOR MEMCACHED HASH ALGORITHM! see: memc_list_hash_types();\", 71);\n        return 1;\n    }\n  }\n  else if ( ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_POLL_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_RETRY_TIMEOUT\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK\") ||\n      ! strcasecmp(args->args[0], \"MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK\"))\n  {\n    /*\n      What type of check the values passed to these behaviors?\n      Range?\n    */\n  }\n  else\n  {\n    strncpy(message, \"UNKNOWN BEHAVIOR TYPE! try memc_list_behaviors() for a list of behaviors.\", MYSQL_ERRMSG_SIZE);\n    return 1;\n  }\n\n\n\n  return 0;\n}", "path": "src\\servers.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/*\n  memc_get\n  get cached object, takes hash-key arg\n*/\n", "func_signal": "char *memc_get(UDF_INIT *initid, UDF_ARGS *args,\n                __attribute__ ((unused)) char *result,\n               unsigned long *length,\n                char *is_null,\n                __attribute__ ((unused)) char *error)", "code": "{\n  /* how do I utilise this? Print out in case of error? */\n  memcached_return rc;\n  /* We'll just hard-code now? */\n\n  memc_function_st *container= (memc_function_st *)initid->ptr;\n\n  rc= memcached_mget(&container->memc, args->args, (size_t *)args->lengths, 1);\n\n  memcached_fetch_result(&container->memc, &container->results, &rc);\n\n  *length= memcached_result_length(&container->results);\n\n  if (! *length)\n  {\n    *is_null= 1;\n  }\n\n  return  memcached_result_value(&container->results);\n}", "path": "src\\get.c", "repo_name": "smira/memcached_functions_mysql", "stars": 22, "license": "gpl-2.0", "language": "c", "size": 161}
{"docstring": "/* ONIG_DEBUG */\n", "func_signal": "static int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)", "code": "{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\n", "func_signal": "static int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)", "code": "{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\tis_num = 1;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      PFETCH(c);\n      if (c == end_code)\n\tgoto end;\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/*\n  def: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\n", "func_signal": "static int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)", "code": "{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n\tis_num = 1;\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n\tis_num = 2;\n\tsign = -1;\n\tpnum_head = p;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\t\n      }\n    }\n    else if (!ONIGENC_IS_CODE_WORD(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH(c);\n      if (c == end_code || c == ')') {\n\tif (is_num == 2) \tr = ONIGERR_INVALID_GROUP_NAME;\n\tbreak;\n      }\n\n      if (is_num != 0) {\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\t  is_num = 1;\n\t}\n\telse {\n\t  if (!ONIGENC_IS_CODE_WORD(enc, c))\n\t    r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  else\n\t    r = ONIGERR_INVALID_GROUP_NAME;\n\n\t  is_num = 0;\n\t}\n      }\n      else {\n\tif (!ONIGENC_IS_CODE_WORD(enc, c)) {\n\t  r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t}\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tgoto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n    while (!PEND) {\n      name_end = p;\n      PFETCH(c);\n      if (c == end_code || c == ')')\n\tbreak;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* dest on static area */\n", "func_signal": "static UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, int capa)", "code": "{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* divide different length alternatives in look-behind.\n  (?<=A|B) ==> (?<=A)|(?<=B)\n  (?<!A|B) ==> (?<!A)(?<!B)\n*/\n", "func_signal": "static int\ndivide_look_behind_alternatives(Node* node)", "code": "{\n  Node *head, *np, *insert_node;\n  AnchorNode* an = NANCHOR(node);\n  int anc_type = an->type;\n\n  head = an->target;\n  np = NCAR(head);\n  swap_node(node, head);\n  NCAR(node) = head;\n  NANCHOR(head)->target = np;\n\n  np = node;\n  while ((np = NCDR(np)) != NULL_NODE) {\n    insert_node = onig_node_new_anchor(anc_type);\n    CHECK_NULL_RETURN_MEMERR(insert_node);\n    NANCHOR(insert_node)->target = NCAR(np);\n    NCAR(np) = insert_node;\n  }\n\n  if (anc_type == ANCHOR_LOOK_BEHIND_NOT) {\n    np = node;\n    do {\n      SET_NTYPE(np, NT_LIST);  /* alt -> list */\n    } while ((np = NCDR(np)) != NULL_NODE);\n  }\n  return 0;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* x is not included y ==>  1 : 0 */\n", "func_signal": "static int\nis_not_included(Node* x, Node* y, regex_t* reg)", "code": "{\n  int i, len;\n  OnigCodePoint code;\n  UChar *p, c;\n  int ytype;\n\n retry:\n  ytype = NTYPE(y);\n  switch (NTYPE(x)) {\n  case NT_CTYPE:\n    {\n      switch (ytype) {\n      case NT_CTYPE:\n\tif (NCTYPE(y)->ctype == NCTYPE(x)->ctype &&\n\t    NCTYPE(y)->not   != NCTYPE(x)->not)\n\t  return 1;\n\telse\n\t  return 0;\n\tbreak;\n\n      case NT_CCLASS:\n      swap:\n\t{\n\t  Node* tmp;\n\t  tmp = x; x = y; y = tmp;\n\t  goto retry;\n\t}\n\tbreak;\n\n      case NT_STR:\n\tgoto swap;\n\tbreak;\n\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* xc = NCCLASS(x);\n      switch (ytype) {\n      case NT_CTYPE:\n\tswitch (NCTYPE(y)->ctype) {\n\tcase ONIGENC_CTYPE_WORD:\n\t  if (NCTYPE(y)->not == 0) {\n\t    if (IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) {\n\t      for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t\tif (BITSET_AT(xc->bs, i)) {\n\t\t  if (IS_CODE_SB_WORD(reg->enc, i)) return 0;\n\t\t}\n\t      }\n\t      return 1;\n\t    }\n\t    return 0;\n\t  }\n\t  else {\n\t    for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t      if (! IS_CODE_SB_WORD(reg->enc, i)) {\n\t\tif (!IS_NCCLASS_NOT(xc)) {\n\t\t  if (BITSET_AT(xc->bs, i))\n\t\t    return 0;\n\t\t}\n\t\telse {\n\t\t  if (! BITSET_AT(xc->bs, i))\n\t\t    return 0;\n\t\t}\n\t      }\n\t    }\n\t    return 1;\n\t  }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n\n      case NT_CCLASS:\n\t{\n\t  int v;\n\t  CClassNode* yc = NCCLASS(y);\n\n\t  for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n\t    v = BITSET_AT(xc->bs, i);\n\t    if ((v != 0 && !IS_NCCLASS_NOT(xc)) ||\n                (v == 0 && IS_NCCLASS_NOT(xc))) {\n\t      v = BITSET_AT(yc->bs, i);\n\t      if ((v != 0 && !IS_NCCLASS_NOT(yc)) ||\n                  (v == 0 && IS_NCCLASS_NOT(yc)))\n\t\treturn 0;\n\t    }\n\t  }\n\t  if ((IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) ||\n\t      (IS_NULL(yc->mbuf) && !IS_NCCLASS_NOT(yc)))\n\t    return 1;\n\t  return 0;\n\t}\n\tbreak;\n\n      case NT_STR:\n\tgoto swap;\n\tbreak;\n\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_STR:\n    {\n      StrNode* xs = NSTR(x);\n      if (NSTRING_LEN(x) == 0)\n\tbreak;\n\n      c = *(xs->s);\n      switch (ytype) {\n      case NT_CTYPE:\n\tswitch (NCTYPE(y)->ctype) {\n\tcase ONIGENC_CTYPE_WORD:\n\t  if (ONIGENC_IS_MBC_WORD(reg->enc, xs->s, xs->end))\n\t    return NCTYPE(y)->not;\n\t  else\n\t    return !(NCTYPE(y)->not);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n\n      case NT_CCLASS:\n\t{\n\t  CClassNode* cc = NCCLASS(y);\n\n\t  code = ONIGENC_MBC_TO_CODE(reg->enc, xs->s,\n\t\t\t\t     xs->s + ONIGENC_MBC_MAXLEN(reg->enc));\n\t  return (onig_is_code_in_cc(reg->enc, code, cc) != 0 ? 0 : 1);\n\t}\n\tbreak;\n\n      case NT_STR:\n\t{\n\t  UChar *q;\n\t  StrNode* ys = NSTR(y);\n\t  len = NSTRING_LEN(x);\n\t  if (len > NSTRING_LEN(y)) len = NSTRING_LEN(y);\n\t  if (NSTRING_IS_AMBIG(x) || NSTRING_IS_AMBIG(y)) {\n            /* tiny version */\n            return 0;\n\t  }\n\t  else {\n\t    for (i = 0, p = ys->s, q = xs->s; i < len; i++, p++, q++) {\n\t      if (*p != *q) return 1;\n\t    }\n\t  }\n\t}\n\tbreak;\n\t\n      default:\n\tbreak;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return 0;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* setup_tree does the following work.\n 1. check empty loop. (set qn->target_empty_info)\n 2. expand ignore-case in char class.\n 3. set memory status bit flags. (reg->mem_stats)\n 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].\n 5. find invalid patterns in look-behind.\n 6. expand repeated string.\n */\n", "func_signal": "static int\nsetup_tree(Node* node, regex_t* reg, int state, ScanEnv* env)", "code": "{\n  int type;\n  int r = 0;\n\n  type = NTYPE(node);\n  switch (type) {\n  case NT_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n\tr = setup_tree(NCAR(node), reg, state, env);\n\tif (IS_NOT_NULL(prev) && r == 0) {\n\t  r = next_setup(prev, NCAR(node), reg);\n\t}\n\tprev = NCAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    }\n    break;\n\n  case NT_ALT:\n    do {\n      r = setup_tree(NCAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  case NT_CCLASS:\n    break;\n\n  case NT_STR:\n    if (IS_IGNORECASE(reg->options) && !NSTRING_IS_RAW(node)) {\n      r = expand_case_fold_string(node, reg);\n    }\n    break;\n\n  case NT_CTYPE:\n  case NT_CANY:\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n    break;\n#endif\n\n  case NT_BREF:\n    {\n      int i;\n      int* p;\n      Node** nodes = SCANENV_MEM_NODES(env);\n      BRefNode* br = NBREF(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n\tif (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n\tBIT_STATUS_ON_AT(env->backrefed_mem, p[i]);\n\tBIT_STATUS_ON_AT(env->bt_mem_start, p[i]);\n#ifdef USE_BACKREF_WITH_LEVEL\n\tif (IS_BACKREF_NEST_LEVEL(br)) {\n\t  BIT_STATUS_ON_AT(env->bt_mem_end, p[i]);\n\t}\n#endif\n\tSET_ENCLOSE_STATUS(nodes[p[i]], NST_MEM_BACKREFED);\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    {\n      OnigDistance d;\n      QtfrNode* qn = NQTFR(node);\n      Node* target = qn->target;\n\n      if ((state & IN_REPEAT) != 0) {\n        qn->state |= NST_IN_REPEAT;\n      }\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 1) {\n\tr = get_min_match_length(target, &d, env);\n\tif (r) break;\n\tif (d == 0) {\n\t  qn->target_empty_info = NQ_TARGET_IS_EMPTY;\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n\t  r = quantifiers_memory_node_info(target);\n\t  if (r < 0) break;\n\t  if (r > 0) {\n\t    qn->target_empty_info = r;\n\t  }\n#endif\n#if 0\n\t  r = get_max_match_length(target, &d, env);\n\t  if (r == 0 && d == 0) {\n\t    /*  ()* ==> ()?, ()+ ==> ()  */\n\t    qn->upper = 1;\n\t    if (qn->lower > 1) qn->lower = 1;\n\t    if (NTYPE(target) == NT_STR) {\n\t      qn->upper = qn->lower = 0;  /* /(?:)+/ ==> // */\n\t    }\n\t  }\n#endif\n\t}\n      }\n\n      state |= IN_REPEAT;\n      if (qn->lower != qn->upper)\n\tstate |= IN_VAR_REPEAT;\n      r = setup_tree(target, reg, state, env);\n      if (r) break;\n\n      /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n      if (NTYPE(target) == NT_STR) {\n\tif (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&\n\t    qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n\t  int len = NSTRING_LEN(target);\n\t  StrNode* sn = NSTR(target);\n\n\t  if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n\t    int i, n = qn->lower;\n\t    onig_node_conv_to_str_node(node, NSTR(target)->flag);\n\t    for (i = 0; i < n; i++) {\n\t      r = onig_node_str_cat(node, sn->s, sn->end);\n\t      if (r) break;\n\t    }\n\t    onig_node_free(target);\n\t    break; /* break case NT_QTFR: */\n\t  }\n\t}\n      }\n\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (qn->greedy && (qn->target_empty_info != 0)) {\n\tif (NTYPE(target) == NT_QTFR) {\n\t  QtfrNode* tqn = NQTFR(target);\n\t  if (IS_NOT_NULL(tqn->head_exact)) {\n\t    qn->head_exact  = tqn->head_exact;\n\t    tqn->head_exact = NULL;\n\t  }\n\t}\n\telse {\n\t  qn->head_exact = get_head_value_node(qn->target, 1, reg);\n\t}\n      }\n#endif\n    }\n    break;\n\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n\n      switch (en->type) {\n      case ENCLOSE_OPTION:\n\t{\n\t  OnigOptionType options = reg->options;\n\t  reg->options = NENCLOSE(node)->option;\n\t  r = setup_tree(NENCLOSE(node)->target, reg, state, env);\n\t  reg->options = options;\n\t}\n\tbreak;\n\n      case ENCLOSE_MEMORY:\n\tif ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {\n\t  BIT_STATUS_ON_AT(env->bt_mem_start, en->regnum);\n\t  /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */\n\t}\n        r = setup_tree(en->target, reg, state, env);\n        break;\n\n      case ENCLOSE_STOP_BACKTRACK:\n\t{\n\t  Node* target = en->target;\n\t  r = setup_tree(target, reg, state, env);\n\t  if (NTYPE(target) == NT_QTFR) {\n\t    QtfrNode* tqn = NQTFR(target);\n\t    if (IS_REPEAT_INFINITE(tqn->upper) && tqn->lower <= 1 &&\n\t\ttqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n\t      int qtype = NTYPE(tqn->target);\n\t      if (IS_NODE_TYPE_SIMPLE(qtype))\n\t\tSET_ENCLOSE_STATUS(node, NST_STOP_BT_SIMPLE_REPEAT);\n\t    }\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_ANCHOR:\n    {\n      AnchorNode* an = NANCHOR(node);\n\n      switch (an->type) {\n      case ANCHOR_PREC_READ:\n\tr = setup_tree(an->target, reg, state, env);\n\tbreak;\n      case ANCHOR_PREC_READ_NOT:\n\tr = setup_tree(an->target, reg, (state | IN_NOT), env);\n\tbreak;\n\n/* allowed node types in look-behind */\n#define ALLOWED_TYPE_IN_LB  \\\n  ( BIT_NT_LIST | BIT_NT_ALT | BIT_NT_STR | BIT_NT_CCLASS | BIT_NT_CTYPE | \\\n    BIT_NT_CANY | BIT_NT_ANCHOR | BIT_NT_ENCLOSE | BIT_NT_QTFR | BIT_NT_CALL )\n\n#define ALLOWED_ENCLOSE_IN_LB       ( ENCLOSE_MEMORY )\n#define ALLOWED_ENCLOSE_IN_LB_NOT   0\n\n#define ALLOWED_ANCHOR_IN_LB \\\n( ANCHOR_LOOK_BEHIND | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION )\n#define ALLOWED_ANCHOR_IN_LB_NOT \\\n( ANCHOR_LOOK_BEHIND | ANCHOR_LOOK_BEHIND_NOT | ANCHOR_BEGIN_LINE | ANCHOR_END_LINE | ANCHOR_BEGIN_BUF | ANCHOR_BEGIN_POSITION )\n\n      case ANCHOR_LOOK_BEHIND:\n\t{\n\t  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,\n\t\t\t      ALLOWED_ENCLOSE_IN_LB, ALLOWED_ANCHOR_IN_LB);\n\t  if (r < 0) return r;\n\t  if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n\t  r = setup_look_behind(node, reg, env);\n\t  if (r != 0) return r;\n\t  r = setup_tree(an->target, reg, state, env);\n\t}\n\tbreak;\n\n      case ANCHOR_LOOK_BEHIND_NOT:\n\t{\n\t  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,\n\t\t      ALLOWED_ENCLOSE_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB_NOT);\n\t  if (r < 0) return r;\n\t  if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n\t  r = setup_look_behind(node, reg, env);\n\t  if (r != 0) return r;\n\t  r = setup_tree(an->target, reg, (state | IN_NOT), env);\n\t}\n\tbreak;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_COMBINATION_EXPLOSION_CHECK */\n", "func_signal": "static int\ncompile_length_quantifier_node(QtfrNode* qn, regex_t* reg)", "code": "{\n  int len, mod_tlen;\n  int infinite = IS_REPEAT_INFINITE(qn->upper);\n  int empty_info = qn->target_empty_info;\n  int tlen = compile_length_tree(qn->target, reg);\n\n  if (tlen < 0) return tlen;\n\n  /* anychar repeat */\n  if (NTYPE(qn->target) == NT_CANY) {\n    if (qn->greedy && infinite) {\n      if (IS_NOT_NULL(qn->next_head_exact))\n        return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;\n      else\n        return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;\n    }\n  }\n\n  if (empty_info != 0)\n    mod_tlen = tlen + (SIZE_OP_NULL_CHECK_START + SIZE_OP_NULL_CHECK_END);\n  else\n    mod_tlen = tlen;\n\n  if (infinite &&\n      (qn->lower <= 1 || tlen * qn->lower <= QUANTIFIER_EXPAND_LIMIT_SIZE)) {\n    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {\n      len = SIZE_OP_JUMP;\n    }\n    else {\n      len = tlen * qn->lower;\n    }\n\n    if (qn->greedy) {\n      if (IS_NOT_NULL(qn->head_exact))\n\tlen += SIZE_OP_PUSH_OR_JUMP_EXACT1 + mod_tlen + SIZE_OP_JUMP;\n      else if (IS_NOT_NULL(qn->next_head_exact))\n\tlen += SIZE_OP_PUSH_IF_PEEK_NEXT + mod_tlen + SIZE_OP_JUMP;\n      else\n\tlen += SIZE_OP_PUSH + mod_tlen + SIZE_OP_JUMP;\n    }\n    else\n      len += SIZE_OP_JUMP + mod_tlen + SIZE_OP_PUSH;\n  }\n  else if (qn->upper == 0 && qn->is_refered != 0) { /* /(?<n>..){0}/ */\n    len = SIZE_OP_JUMP + tlen;\n  }\n  else if (!infinite && qn->greedy &&\n           (qn->upper == 1 || (tlen + SIZE_OP_PUSH) * qn->upper\n                                      <= QUANTIFIER_EXPAND_LIMIT_SIZE)) {\n    len = tlen * qn->lower;\n    len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);\n  }\n  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */\n    len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;\n  }\n  else {\n    len = SIZE_OP_REPEAT_INC\n        + mod_tlen + SIZE_OPCODE + SIZE_RELADDR + SIZE_MEMNUM;\n  }\n\n  return len;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT */\n", "func_signal": "static int\nget_min_match_length(Node* node, OnigDistance *min, ScanEnv* env)", "code": "{\n  OnigDistance tmin;\n  int r = 0;\n\n  *min = 0;\n  switch (NTYPE(node)) {\n  case NT_BREF:\n    {\n      int i;\n      int* backs;\n      Node** nodes = SCANENV_MEM_NODES(env);\n      BRefNode* br = NBREF(node);\n      if (br->state & NST_RECURSION) break;\n\n      backs = BACKREFS_P(br);\n      if (backs[0] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n      r = get_min_match_length(nodes[backs[0]], min, env);\n      if (r != 0) break;\n      for (i = 1; i < br->back_num; i++) {\n\tif (backs[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n\tr = get_min_match_length(nodes[backs[i]], &tmin, env);\n\tif (r != 0) break;\n\tif (*min > tmin) *min = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n    if (IS_CALL_RECURSION(NCALL(node))) {\n      EncloseNode* en = NENCLOSE(NCALL(node)->target);\n      if (IS_ENCLOSE_MIN_FIXED(en))\n\t*min = en->min_len;\n    }\n    else\n      r = get_min_match_length(NCALL(node)->target, min, env);\n    break;\n#endif\n\n  case NT_LIST:\n    do {\n      r = get_min_match_length(NCAR(node), &tmin, env);\n      if (r == 0) *min += tmin;\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  case NT_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n\tx = NCAR(y);\n\tr = get_min_match_length(x, &tmin, env);\n\tif (r != 0) break;\n\tif (y == node) *min = tmin;\n\telse if (*min > tmin) *min = tmin;\n      } while (r == 0 && IS_NOT_NULL(y = NCDR(y)));\n    }\n    break;\n\n  case NT_STR:\n    {\n      StrNode* sn = NSTR(node);\n      *min = sn->end - sn->s;\n    }\n    break;\n\n  case NT_CTYPE:\n    *min = 1;\n    break;\n\n  case NT_CCLASS:\n  case NT_CANY:\n    *min = 1;\n    break;\n\n  case NT_QTFR:\n    {\n      QtfrNode* qn = NQTFR(node);\n\n      if (qn->lower > 0) {\n\tr = get_min_match_length(qn->target, min, env);\n\tif (r == 0)\n\t  *min = distance_multiply(*min, qn->lower);\n      }\n    }\n    break;\n\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      switch (en->type) {\n      case ENCLOSE_MEMORY:\n#ifdef USE_SUBEXP_CALL\n\tif (IS_ENCLOSE_MIN_FIXED(en))\n\t  *min = en->min_len;\n\telse {\n\t  r = get_min_match_length(en->target, min, env);\n\t  if (r == 0) {\n\t    en->min_len = *min;\n\t    SET_ENCLOSE_STATUS(node, NST_MIN_FIXED);\n\t  }\n\t}\n\tbreak;\n#endif\n      case ENCLOSE_OPTION:\n      case ENCLOSE_STOP_BACKTRACK:\n\tr = get_min_match_length(en->target, min, env);\n\tbreak;\n      }\n    }\n    break;\n\n  case NT_ANCHOR:\n  default:\n    break;\n  }\n\n  return r;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\n", "func_signal": "static int\nnew_code_range(BBuf** pbuf)", "code": "{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_NAMED_GROUP */\n", "func_signal": "static void\nCC_ESC_WARN(ScanEnv* env, UChar *c)", "code": "{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n                (UChar* )\"character class has '%s' without escape\", c);\n    (*onig_warn)((char* )buf);\n  }\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\n", "func_signal": "static int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)", "code": "{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) return r;\n\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  return r;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* else USE_NAMED_GROUP */\n", "func_signal": "extern int\nonig_noname_group_capture_is_active(regex_t* reg)", "code": "{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* ONIG_DEBUG */\n", "func_signal": "static void\nonig_free_body(regex_t* reg)", "code": "{\n  if (IS_NOT_NULL(reg->p))                xfree(reg->p);\n  if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n  if (IS_NOT_NULL(reg->int_map))          xfree(reg->int_map);\n  if (IS_NOT_NULL(reg->int_map_backward)) xfree(reg->int_map_backward);\n  if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n  if (IS_NOT_NULL(reg->chain))            onig_free(reg->chain);\n\n#ifdef USE_NAMED_GROUP\n  onig_names_free(reg);\n#endif\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_SUBEXP_CALL */\n", "func_signal": "static int\nadd_opcode(regex_t* reg, int opcode)", "code": "{\n  BBUF_ADD1(reg, opcode);\n  return 0;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_COMBINATION_EXPLOSION_CHECK */\n", "func_signal": "static int\ncompile_length_option_node(EncloseNode* node, regex_t* reg)", "code": "{\n  int tlen;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->option;\n  tlen = compile_length_tree(node->target, reg);\n  reg->options = prev;\n\n  if (tlen < 0) return tlen;\n\n  if (IS_DYNAMIC_OPTION(prev ^ node->option)) {\n    return SIZE_OP_SET_OPTION_PUSH + SIZE_OP_SET_OPTION + SIZE_OP_FAIL\n           + tlen + SIZE_OP_SET_OPTION;\n  }\n  else\n    return tlen;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* set skip map for Boyer-Moor search */\n", "func_signal": "static int\nset_bm_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t    UChar skip[], int** int_skip)", "code": "{\n  int i, len;\n\n  len = end - s;\n  if (len < ONIG_CHAR_TABLE_SIZE) {\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) skip[i] = len;\n\n    for (i = 0; i < len - 1; i++)\n      skip[s[i]] = len - 1 - i;\n  }\n  else {\n    if (IS_NULL(*int_skip)) {\n      *int_skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n      if (IS_NULL(*int_skip)) return ONIGERR_MEMORY;\n    }\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) (*int_skip)[i] = len;\n\n    for (i = 0; i < len - 1; i++)\n      (*int_skip)[s[i]] = len - 1 - i;\n  }\n  return 0;\n}", "path": "src\\3rdparty\\onig\\regcomp.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* USE_CAPTURE_HISTORY */\n", "func_signal": "extern int\nonig_capture_tree_traverse(OnigRegion* region, int at,\n                  int(*callback_func)(int,int,int,int,int,void*), void* arg)", "code": "{\n#ifdef USE_CAPTURE_HISTORY\n  return capture_tree_traverse(region->history_root, at,\n                               callback_func, 0, arg);\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}", "path": "src\\3rdparty\\onig\\regtrav.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* \\M-, \\C-, \\c, or \\... */\n", "func_signal": "static int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env)", "code": "{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH(c);\n      if (c == MC_ESC(env->syntax)) {\n\tv = fetch_escaped_value(&p, end, env);\n\tif (v < 0) return v;\n        c = (OnigCodePoint )v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH(c);\n      if (c == '?') {\n\tc = 0177;\n      }\n      else {\n        if (c == MC_ESC(env->syntax)) {\n          v = fetch_escaped_value(&p, end, env);\n          if (v < 0) return v;\n          c = (OnigCodePoint )v;\n        }\n\tc &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  return c;\n}", "path": "src\\3rdparty\\onig\\regparse.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/* CR_Katakana */\n", "func_signal": "static int\ninit_property_list(void)", "code": "{\n  int r;\n\n  PROPERTY_LIST_ADD_PROP(\"Hiragana\", CR_Hiragana);\n  PROPERTY_LIST_ADD_PROP(\"Katakana\", CR_Katakana);\n  PropertyInited = 1;\n\n end:\n  return r;\n}", "path": "src\\3rdparty\\onig\\enc\\sjis.c", "repo_name": "simonask/snow-deprecated", "stars": 21, "license": "other", "language": "c", "size": 1951}
{"docstring": "/**\n * Empty a message list, leaving it able to accept new messages\n * @param msgList the message list to empty\n */\n", "func_signal": "void MQTTProtocol_emptyMessageList(List* msgList)", "code": "{\n\tListElement* current = NULL;\n\n\tFUNC_ENTRY;\n\twhile (ListNextElement(msgList, &current))\n\t{\n\t\tMessages* m = (Messages*)(current->content);\n\t\tMQTTProtocol_removePublication(m->publish);\n\t}\n\tListEmpty(msgList);\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Process an incoming pubrec packet for a socket\n * @param pack pointer to the publish packet\n * @param sock the socket on which the packet was received\n * @return completion code\n */\n", "func_signal": "int MQTTProtocol_handlePubrecs(void* pack, int sock)", "code": "{\n\tPubrec* pubrec = (Pubrec*)pack;\n\tClients* client = NULL;\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\tclient = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);\n\tLog(LOG_PROTOCOL, 15, NULL, sock, client->clientID, pubrec->msgId);\n\n\t/* look for the message by message id in the records of outbound messages for this client */\n\tclient->outboundMsgs->current = NULL;\n\tif (ListFindItem(client->outboundMsgs, &(pubrec->msgId), messageIDCompare) == NULL)\n\t{\n\t\tif (pubrec->header.bits.dup == 0)\n\t\t\tLog(TRACE_MIN, 3, NULL, \"PUBREC\", client->clientID, pubrec->msgId);\n\t}\n\telse\n\t{\n\t\tMessages* m = (Messages*)(client->outboundMsgs->current->content);\n\t\tif (m->qos != 2)\n\t\t{\n\t\t\tif (pubrec->header.bits.dup == 0)\n\t\t\t\tLog(TRACE_MIN, 4, NULL, \"PUBREC\", client->clientID, pubrec->msgId, m->qos);\n\t\t}\n\t\telse if (m->nextMessageType != PUBREC)\n\t\t{\n\t\t\tif (pubrec->header.bits.dup == 0)\n\t\t\t\tLog(TRACE_MIN, 5, NULL, \"PUBREC\", client->clientID, pubrec->msgId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trc = MQTTPacket_send_pubrel(pubrec->msgId, 0, sock, client->clientID);\n\t\t\tm->nextMessageType = PUBCOMP;\n\t\t\ttime(&(m->lastTouch));\n\t\t}\n\t}\n\tfree(pack);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Free a client structure\n * @param client the client data to free\n */\n", "func_signal": "void MQTTProtocol_freeClient(Clients* client)", "code": "{\n\tFUNC_ENTRY;\n\t/* free up pending message lists here, and any other allocated data */\n\tMQTTProtocol_freeMessageList(client->outboundMsgs);\n\tMQTTProtocol_freeMessageList(client->inboundMsgs);\n\tListFree(client->messageQueue);\n\tfree(client->clientID);\n\t/*if (client->will != NULL)\n\t{\n\t\twillMessages* w = client->will;\n\t\tfree(w->msg);\n\t\tfree(w->topic);\n\t\tfree(client->will);\n\t}*/\n\t/* don't free the client structure itself... this is done elsewhere */\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * MQTT retry protocol and socket pending writes processing.\n * @param now current time\n * @param doRetry boolean - retries as well as pending writes?\n */\n", "func_signal": "void MQTTProtocol_retry(time_t now, int doRetry)", "code": "{\n\tListElement* current = NULL;\n\n\tFUNC_ENTRY;\n\tListNextElement(bstate->clients, &current);\n\t/* look through the outbound message list of each client, checking to see if a retry is necessary */\n\twhile (current)\n\t{\n\t\tClients* client = (Clients*)(current->content);\n\t\tListNextElement(bstate->clients, &current);\n\t\tif (client->connected == 0)\n\t\t\tcontinue;\n\t\tif (client->good == 0)\n\t\t{\n\t\t\tMQTTProtocol_closeSession(client, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (Socket_noPendingWrites(client->socket) == 0)\n\t\t\tcontinue;\n\t\tif (doRetry)\n\t\t\tMQTTProtocol_retries(now, client);\n\t}\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Process an incoming pubcomp packet for a socket\n * @param pack pointer to the publish packet\n * @param sock the socket on which the packet was received\n * @return completion code\n */\n", "func_signal": "int MQTTProtocol_handlePubcomps(void* pack, int sock)", "code": "{\n\tPubcomp* pubcomp = (Pubcomp*)pack;\n\tClients* client = NULL;\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\tclient = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);\n\tLog(LOG_PROTOCOL, 19, NULL, sock, client->clientID, pubcomp->msgId);\n\n\t/* look for the message by message id in the records of outbound messages for this client */\n\tif (ListFindItem(client->outboundMsgs, &(pubcomp->msgId), messageIDCompare) == NULL)\n\t{\n\t\tif (pubcomp->header.bits.dup == 0)\n\t\t\tLog(TRACE_MIN, 3, NULL, \"PUBCOMP\", client->clientID, pubcomp->msgId);\n\t}\n\telse\n\t{\n\t\tMessages* m = (Messages*)(client->outboundMsgs->current->content);\n\t\tif (m->qos != 2)\n\t\t\tLog(TRACE_MIN, 4, NULL, \"PUBCOMP\", client->clientID, pubcomp->msgId, m->qos);\n\t\telse\n\t\t{\n\t\t\tif (m->nextMessageType != PUBCOMP)\n\t\t\t\tLog(TRACE_MIN, 5, NULL, \"PUBCOMP\", client->clientID, pubcomp->msgId);\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(TRACE_MIN, 6, NULL, \"PUBCOMP\", client->clientID, pubcomp->msgId);\n\t\t\t\t#if !defined(NO_PERSISTENCE)\n\t\t\t\t\trc = MQTTPersistence_remove(client, PERSISTENCE_PUBLISH_SENT, m->qos, pubcomp->msgId);\n\t\t\t\t#endif\n\t\t\t\tMQTTProtocol_removePublication(m->publish);\n\t\t\t\tListRemove(client->outboundMsgs, m);\n\t\t\t\t(++state.msgs_sent);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pack);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Assign a new message id for a client.  Make sure it isn't already being used and does\n * not exceed the maximum.\n * @param client a client structure\n * @return the next message id to use\n */\n", "func_signal": "int MQTTProtocol_assignMsgId(Clients* client)", "code": "{\n\tFUNC_ENTRY;\n\t++(client->msgID);\n\twhile (ListFindItem(client->outboundMsgs, &(client->msgID), messageIDCompare) != NULL)\n\t\t++(client->msgID);\n\tif (client->msgID == MAX_MSG_ID + 1)\n\t\tclient->msgID = 1;\n\tFUNC_EXIT_RC(client->msgID);\n\treturn client->msgID;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Utility function to start a new publish exchange.\n * @param pubclient the client to send the publication to\n * @param publish the publication data\n * @param qos the MQTT QoS to use\n * @param retained boolean - whether to set the MQTT retained flag\n * @return the completion code\n */\n", "func_signal": "int MQTTProtocol_startPublishCommon(Clients* pubclient, Publish* publish, int qos, int retained)", "code": "{\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\trc = MQTTPacket_send_publish(publish, 0, qos, retained, pubclient->socket, pubclient->clientID);\n\tif (qos == 0 && rc == TCPSOCKET_INTERRUPTED)\n\t\tMQTTProtocol_storeQoS0(pubclient, publish);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Copy and store message data for retries\n * @param publish the publication data\n * @param mm - pointer to the message data to store\n * @param qos the MQTT QoS to use\n * @param retained boolean - whether to set the MQTT retained flag\n * @return pointer to the message data stored\n */\n", "func_signal": "Messages* MQTTProtocol_createMessage(Publish* publish, Messages **mm, int qos, int retained)", "code": "{\n\tMessages* m = malloc(sizeof(Messages));\n\n\tFUNC_ENTRY;\n\tm->len = sizeof(Messages);\n\tif (*mm == NULL || (*mm)->publish == NULL)\n\t{\n\t\tint len1;\n\t\t*mm = m;\n\t\tm->publish = MQTTProtocol_storePublication(publish, &len1);\n\t\tm->len += len1;\n\t}\n\telse\n\t{\n\t\t++(((*mm)->publish)->refcount);\n\t\tm->publish = (*mm)->publish;\n\t}\n\tm->msgid = publish->msgId;\n\tm->qos = qos;\n\tm->retain = retained;\n\ttime(&(m->lastTouch));\n\tif (qos == 2)\n\t\tm->nextMessageType = PUBREC;\n\tFUNC_EXIT;\n\treturn m;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Start a new publish exchange.  Store any state necessary and try to send the packet\n * @param pubclient the client to send the publication to\n * @param publish the publication data\n * @param qos the MQTT QoS to use\n * @param retained boolean - whether to set the MQTT retained flag\n * @param mm - pointer to the message to send\n * @return the completion code\n */\n", "func_signal": "int MQTTProtocol_startPublish(Clients* pubclient, Publish* publish, int qos, int retained, Messages** mm)", "code": "{\n\tPublish p = *publish;\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tif (qos > 0)\n\t{\n\t\tp.msgId = publish->msgId = MQTTProtocol_assignMsgId(pubclient);\n\t\t*mm = MQTTProtocol_createMessage(publish, mm, qos, retained);\n\t\tListAppend(pubclient->outboundMsgs, *mm, (*mm)->len);\n\t\t/* we change these pointers to the saved message location just in case the packet could not be written\n\t\tentirely; the socket buffer will use these locations to finish writing the packet */\n\t\tp.payload = (*mm)->publish->payload;\n\t\tp.topic = (*mm)->publish->topic;\n\t}\n\trc = MQTTProtocol_startPublishCommon(pubclient, &p, qos, retained);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Wrapper function to call connection lost on a separate thread.  A separate thread is needed to allow the\n * connectionLost function to make API calls (e.g. connect)\n * @param context a pointer to the relevant client\n * @return thread_return_type standard thread return value - not used here\n */\n", "func_signal": "thread_return_type WINAPI connectionLost_call(void* context)", "code": "{\n\tMQTTClients* m = (MQTTClients*)context;\n\n\t(*(m->cl))(m->context, NULL);\n\treturn 0;\n}", "path": "paho\\MQTTClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * MQTT retry processing per client\n * @param now current time\n * @param client - the client to which to apply the retry processing\n */\n", "func_signal": "void MQTTProtocol_retries(time_t now, Clients* client)", "code": "{\n\tListElement* outcurrent = NULL;\n\n\tFUNC_ENTRY;\n\n\tif (client->retryInterval <= 0) /* 0 or -ive retryInterval turns off retry */\n\t\tgoto exit;\n\n\twhile (client && ListNextElement(client->outboundMsgs, &outcurrent))\n\t{\n\t\tMessages* m = (Messages*)(outcurrent->content);\n\t\tif (difftime(now, m->lastTouch) > max(client->retryInterval, 10))\n\t\t{\n\t\t\tif (m->qos == 1 || (m->qos == 2 && m->nextMessageType == PUBREC))\n\t\t\t{\n\t\t\t\tPublish publish;\n\t\t\t\tint rc;\n\n\t\t\t\tLog(TRACE_MIN, 7, NULL, \"PUBLISH\", client->clientID, client->socket, m->msgid);\n\t\t\t\tpublish.msgId = m->msgid;\n\t\t\t\tpublish.topic = m->publish->topic;\n\t\t\t\tpublish.payload = m->publish->payload;\n\t\t\t\tpublish.payloadlen = m->publish->payloadlen;\n\t\t\t\trc = MQTTPacket_send_publish(&publish, 1, m->qos, m->retain, client->socket, client->clientID);\n\t\t\t\tif (rc == SOCKET_ERROR)\n\t\t\t\t{\n\t\t\t\t\tclient->good = 0;\n\t\t\t\t\tLog(TRACE_MIN, 8, NULL, client->clientID, client->socket,\n\t\t\t\t\t\t\t\t\t\t\t\tSocket_getpeer(client->socket));\n\t\t\t\t\tMQTTProtocol_closeSession(client, 1);\n\t\t\t\t\tclient = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m->qos == 0 && rc == TCPSOCKET_INTERRUPTED)\n\t\t\t\t\t\tMQTTProtocol_storeQoS0(client, &publish);\n\t\t\t\t\ttime(&(m->lastTouch));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m->qos && m->nextMessageType == PUBCOMP)\n\t\t\t{\n\t\t\t\tLog(TRACE_MIN, 7, NULL, \"PUBREL\", client->clientID, client->socket, m->msgid);\n\t\t\t\tif (MQTTPacket_send_pubrel(m->msgid, 1, client->socket, client->clientID) != TCPSOCKET_COMPLETE)\n\t\t\t\t{\n\t\t\t\t\tclient->good = 0;\n\t\t\t\t\tLog(TRACE_MIN, 8, NULL, client->clientID, client->socket,\n\t\t\t\t\t\t\tSocket_getpeer(client->socket));\n\t\t\t\t\tMQTTProtocol_closeSession(client, 1);\n\t\t\t\t\tclient = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttime(&(m->lastTouch));\n\t\t\t}\n\t\t\t/* break; why not do all retries at once? */\n\t\t}\n\t}\nexit:\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Empty and free up all storage used by a message list\n * @param msgList the message list to empty and free\n */\n", "func_signal": "void MQTTProtocol_freeMessageList(List* msgList)", "code": "{\n\tFUNC_ENTRY;\n\tMQTTProtocol_emptyMessageList(msgList);\n\tListFree(msgList);\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Process an incoming puback packet for a socket\n * @param pack pointer to the publish packet\n * @param sock the socket on which the packet was received\n * @return completion code\n */\n", "func_signal": "int MQTTProtocol_handlePubacks(void* pack, int sock)", "code": "{\n\tPuback* puback = (Puback*)pack;\n\tClients* client = NULL;\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\tclient = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);\n\tLog(LOG_PROTOCOL, 14, NULL, sock, client->clientID, puback->msgId);\n\n\t/* look for the message by message id in the records of outbound messages for this client */\n\tif (ListFindItem(client->outboundMsgs, &(puback->msgId), messageIDCompare) == NULL)\n\t\tLog(TRACE_MIN, 3, NULL, \"PUBACK\", client->clientID, puback->msgId);\n\telse\n\t{\n\t\tMessages* m = (Messages*)(client->outboundMsgs->current->content);\n\t\tif (m->qos != 1)\n\t\t\tLog(TRACE_MIN, 4, NULL, \"PUBACK\", client->clientID, puback->msgId, m->qos);\n\t\telse\n\t\t{\n\t\t\tLog(TRACE_MIN, 6, NULL, \"PUBACK\", client->clientID, puback->msgId);\n\t\t\t#if !defined(NO_PERSISTENCE)\n\t\t\t\trc = MQTTPersistence_remove(client, PERSISTENCE_PUBLISH_SENT, m->qos, puback->msgId);\n\t\t\t#endif\n\t\t\tMQTTProtocol_removePublication(m->publish);\n\t\t\tListRemove(client->outboundMsgs, m);\n\t\t}\n\t}\n\tfree(pack);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Store message data for possible retry\n * @param publish the publication data\n * @param len returned length of the data stored\n * @return the publication stored\n */\n", "func_signal": "Publications* MQTTProtocol_storePublication(Publish* publish, int* len)", "code": "{\n\tPublications* p = malloc(sizeof(Publications));\n\n\tFUNC_ENTRY;\n\tp->refcount = 1;\n\n\t*len = strlen(publish->topic)+1;\n\tif (Heap_findItem(publish->topic))\n\t\tp->topic = publish->topic;\n\telse\n\t{\n\t\tp->topic = malloc(*len);\n\t\tstrcpy(p->topic, publish->topic);\n\t}\n\t*len += sizeof(Publications);\n\n\tp->topiclen = publish->topiclen;\n\tp->payloadlen = publish->payloadlen;\n\tp->payload = malloc(publish->payloadlen);\n\tmemcpy(p->payload, publish->payload, p->payloadlen);\n\t*len += publish->payloadlen;\n\n\tListAppend(&(state.publications), p, *len);\n\tFUNC_EXIT;\n\treturn p;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * List callback function for comparing clients by socket\n * @param a first integer value\n * @param b second integer value\n * @return boolean indicating whether a and b are equal\n */\n", "func_signal": "int clientSockCompare(void* a, void* b)", "code": "{\n\tMQTTClients* m = (MQTTClients*)a;\n\treturn m->c->socket == *(int*)b;\n}", "path": "paho\\MQTTClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Process an incoming pubrel packet for a socket\n * @param pack pointer to the publish packet\n * @param sock the socket on which the packet was received\n * @return completion code\n */\n", "func_signal": "int MQTTProtocol_handlePubrels(void* pack, int sock)", "code": "{\n\tPubrel* pubrel = (Pubrel*)pack;\n\tClients* client = NULL;\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\tclient = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);\n\tLog(LOG_PROTOCOL, 17, NULL, sock, client->clientID, pubrel->msgId);\n\n\t/* look for the message by message id in the records of inbound messages for this client */\n\tif (ListFindItem(client->inboundMsgs, &(pubrel->msgId), messageIDCompare) == NULL)\n\t{\n\t\tif (pubrel->header.bits.dup == 0)\n\t\t\tLog(TRACE_MIN, 3, NULL, \"PUBREL\", client->clientID, pubrel->msgId);\n\t\telse\n\t\t\t/* Apparently this is \"normal\" behaviour, so we don't need to issue a warning */\n\t\t\trc = MQTTPacket_send_pubcomp(pubrel->msgId, sock, client->clientID);\n\t}\n\telse\n\t{\n\t\tMessages* m = (Messages*)(client->inboundMsgs->current->content);\n\t\tif (m->qos != 2)\n\t\t\tLog(TRACE_MIN, 4, NULL, \"PUBREL\", client->clientID, pubrel->msgId, m->qos);\n\t\telse if (m->nextMessageType != PUBREL)\n\t\t\tLog(TRACE_MIN, 5, NULL, \"PUBREL\", client->clientID, pubrel->msgId);\n\t\telse\n\t\t{\n\t\t\tPublish publish;\n\n\t\t\t/* send pubcomp before processing the publications because a lot of return publications could fill up the socket buffer */\n\t\t\trc = MQTTPacket_send_pubcomp(pubrel->msgId, sock, client->clientID);\n\t\t\tpublish.header.bits.qos = m->qos;\n\t\t\tpublish.header.bits.retain = m->retain;\n\t\t\tpublish.msgId = m->msgid;\n\t\t\tpublish.topic = m->publish->topic;\n\t\t\tpublish.topiclen = m->publish->topiclen;\n\t\t\tpublish.payload = m->publish->payload;\n\t\t\tpublish.payloadlen = m->publish->payloadlen;\n\t\t\tProtocol_processPublication(&publish, client);\n\t\t\t#if !defined(NO_PERSISTENCE)\n\t\t\t\trc = MQTTPersistence_remove(client, PERSISTENCE_PUBLISH_RECEIVED, m->qos, pubrel->msgId);\n\t\t\t#endif\n\t\t\tListRemove(&(state.publications), m->publish);\n\t\t\tListRemove(client->inboundMsgs, m);\n\t\t\t++(state.msgs_received);\n\t\t}\n\t}\n\tfree(pack);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * List callback function for comparing Message structures by message id\n * @param a first integer value\n * @param b second integer value\n * @return boolean indicating whether a and b are equal\n */\n", "func_signal": "int messageIDCompare(void* a, void* b)", "code": "{\n\tMessages* msg = (Messages*)a;\n\treturn msg->msgid == *(int*)b;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Remove stored message data.  Opposite of storePublication\n * @param p stored publication to remove\n */\n", "func_signal": "void MQTTProtocol_removePublication(Publications* p)", "code": "{\n\tFUNC_ENTRY;\n\tif (--(p->refcount) == 0)\n\t{\n\t\tfree(p->payload);\n\t\tfree(p->topic);\n\t\tListRemove(&(state.publications), p);\n\t}\n\tFUNC_EXIT;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/**\n * Process an incoming publish packet for a socket\n * @param pack pointer to the publish packet\n * @param sock the socket on which the packet was received\n * @return completion code\n */\n", "func_signal": "int MQTTProtocol_handlePublishes(void* pack, int sock)", "code": "{\n\tPublish* publish = (Publish*)pack;\n\tClients* client = NULL;\n\tchar* clientid = NULL;\n\tint rc = TCPSOCKET_COMPLETE;\n\n\tFUNC_ENTRY;\n\tclient = (Clients*)(ListFindItem(bstate->clients, &sock, clientSocketCompare)->content);\n\tclientid = client->clientID;\n\tLog(LOG_PROTOCOL, 11, NULL, sock, clientid, publish->msgId, publish->header.bits.qos,\n\t\t\t\t\tpublish->header.bits.retain, min(20, publish->payloadlen), publish->payload);\n\n\tif (publish->header.bits.qos == 0)\n\t\tProtocol_processPublication(publish, client);\n\telse if (publish->header.bits.qos == 1)\n\t{\n\t\t/* send puback before processing the publications because a lot of return publications could fill up the socket buffer */\n\t\trc = MQTTPacket_send_puback(publish->msgId, sock, client->clientID);\n\t\t/* if we get a socket error from sending the puback, should we ignore the publication? */\n\t\tProtocol_processPublication(publish, client);\n\t}\n\telse if (publish->header.bits.qos == 2)\n\t{\n\t\t/* store publication in inbound list */\n\t\tint len;\n\t\tListElement* listElem = NULL;\n\t\tMessages* m = malloc(sizeof(Messages));\n\t\tPublications* p = MQTTProtocol_storePublication(publish, &len);\n\t\tm->publish = p;\n\t\tm->msgid = publish->msgId;\n\t\tm->qos = publish->header.bits.qos;\n\t\tm->retain = publish->header.bits.retain;\n\t\tm->nextMessageType = PUBREL;\n\t\tif ( ( listElem = ListFindItem(client->inboundMsgs, &(m->msgid), messageIDCompare) ) != NULL )\n\t\t{   /* discard queued publication with same msgID that the current incoming message */\n\t\t\tMessages* msg = (Messages*)(listElem->content);\n\t\t\tMQTTProtocol_removePublication(msg->publish);\n\t\t\tListInsert(client->inboundMsgs, m, sizeof(Messages) + len, listElem);\n\t\t\tListRemove(client->inboundMsgs, msg);\n\t\t} else\n\t\t\tListAppend(client->inboundMsgs, m, sizeof(Messages) + len);\n\t\trc = MQTTPacket_send_pubrec(publish->msgId, sock, client->clientID);\n\t\tpublish->topic = NULL;\n\t}\n\tMQTTPacket_freePublish(publish);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}", "path": "paho\\MQTTProtocolClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/* This is the thread function that handles the calling of callback functions if set */\n", "func_signal": "thread_return_type WINAPI MQTTClient_run(void* n)", "code": "{\n\tlong timeout = 10L; /* first time in we have a small timeout.  Gets things started more quickly */\n\n\tFUNC_ENTRY;\n\trunning = 1;\n\trun_id = Thread_getid();\n\n\tThread_lock_mutex(mqttclient_mutex);\n\twhile (!tostop)\n\t{\n\t\tint rc = SOCKET_ERROR;\n\t\tint sock = -1;\n\t\tMQTTClients* m = NULL;\n\t\tMQTTPacket* pack = NULL;\n\n\t\tThread_unlock_mutex(mqttclient_mutex);\n\t\tpack = MQTTClient_cycle(&sock, timeout, &rc);\n\t\tThread_lock_mutex(mqttclient_mutex);\n\t\tif (tostop)\n\t\t\tbreak;\n\t\ttimeout = 1000L;\n\n\t\t/* find client corresponding to socket */\n\t\tif (ListFindItem(handles, &sock, clientSockCompare) == NULL)\n\t\t{\n\t\t\t/* assert: should not happen */\n\t\t\tcontinue;\n\t\t}\n\t\tm = (MQTTClient)(handles->current->content);\n\t\tif (m == NULL)\n\t\t{\n\t\t\t/* assert: should not happen */\n\t\t\tcontinue;\n\t\t}\n\t\tif (rc == SOCKET_ERROR)\n\t\t{\n\t\t\tThread_unlock_mutex(mqttclient_mutex);\n\t\t\tMQTTClient_disconnect_internal(m, 0);\n\t\t\tThread_lock_mutex(mqttclient_mutex);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m->c->messageQueue->count > 0)\n\t\t\t{\n\t\t\t\tqEntry* qe = (qEntry*)(m->c->messageQueue->first->content);\n\t\t\t\tint topicLen = qe->topicLen;\n\t\t\t\tvoid* payload_ptr = qe->msg->payload; /* saved so we can unlink it after a successful messageArrived call,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbecause it is held in a structure which might be freed */\n\n\t\t\t\tif (strlen(qe->topicName) == topicLen)\n\t\t\t\t\ttopicLen = 0;\n\n\t\t\t\tLog(TRACE_MIN, -1, \"Calling messageArrived for client %s, queue depth %d\",\n\t\t\t\t\tm->c->clientID, m->c->messageQueue->count);\n\t\t\t\tThread_unlock_mutex(mqttclient_mutex);\n\t\t\t\trc = (*(m->ma))(m->context, qe->topicName, topicLen, qe->msg);\n\t\t\t\tThread_lock_mutex(mqttclient_mutex);\n\t\t\t\t/* if 0 (false) is returned by the callback then it failed, so we don't remove the message from\n\t\t\t\t * the queue, and it will be retried later.  If 1 is returned then the message data may have been freed,\n\t\t\t\t * so we must be careful how we use it.\n\t\t\t\t */\n\t\t\t\tif (rc)\n\t\t\t\t{\n\t\t\t\t\tHeap_unlink(__FILE__, __LINE__, qe->topicName);\n\t\t\t\t\tHeap_unlink(__FILE__, __LINE__, payload_ptr);\n\t\t\t\t\tHeap_unlink(__FILE__, __LINE__, qe->msg);\n\t\t\t\t\tListRemove(m->c->messageQueue, qe);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tLog(TRACE_MIN, -1, \"False returned from messageArrived for client %s, message remains on queue\",\n\t\t\t\t\t\tm->c->clientID);\n\t\t\t}\n\t\t\tif (pack)\n\t\t\t{\n\t\t\t\tif (pack->header.bits.type == CONNACK)\n\t\t\t\t{\n\t\t\t\t\tLog(TRACE_MIN, -1, \"Posting connack semaphore for client %s\", m->c->clientID);\n\t\t\t\t\tm->pack = pack;\n\t\t\t\t\tThread_post_sem(m->connack_sem);\n\t\t\t\t}\n\t\t\t\telse if (pack->header.bits.type == SUBACK)\n\t\t\t\t{\n\t\t\t\t\tLog(TRACE_MIN, -1, \"Posting suback semaphore for client %s\", m->c->clientID);\n\t\t\t\t\tm->pack = pack;\n\t\t\t\t\tThread_post_sem(m->suback_sem);\n\t\t\t\t}\n\t\t\t\telse if (pack->header.bits.type == UNSUBACK)\n\t\t\t\t{\n\t\t\t\t\tLog(TRACE_MIN, -1, \"Posting unsuback semaphore for client %s\", m->c->clientID);\n\t\t\t\t\tm->pack = pack;\n\t\t\t\t\tThread_post_sem(m->unsuback_sem);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m->c->connect_state == 1 && !Thread_check_sem(m->connect_sem))\n\t\t\t{\n\t\t\t\tint error;\n\t\t\t\tsocklen_t len = sizeof(error);\n\n\t\t\t\tif ((m->rc = getsockopt(m->c->socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len)) == 0)\n\t\t\t\t\tm->rc = error;\n\t\t\t\tLog(TRACE_MIN, -1, \"Posting connect semaphore for client %s rc %d\", m->c->clientID, m->rc);\n\t\t\t\tThread_post_sem(m->connect_sem);\n\t\t\t}\n\t\t}\n\t}\n\trun_id = 0;\n\trunning = 0;\n\tThread_unlock_mutex(mqttclient_mutex);\n\tFUNC_EXIT;\n\treturn 0;\n}", "path": "paho\\MQTTClient.c", "repo_name": "dc-square/SimpleMessage", "stars": 20, "license": "apache-2.0", "language": "c", "size": 432}
{"docstring": "/*\n * IBM E325 needs a different resource map\n *\n */\n", "func_signal": "static void setup_ibm_e325_resource_map(void)", "code": "{\n\tstatic const unsigned int register_values[] = {\n\t/* Careful set limit registers before base registers which contain the enables */\n\t/* DRAM Limit i Registers\n\t * F1:0x44 i = 0\n\t * F1:0x4C i = 1\n\t * F1:0x54 i = 2\n\t * F1:0x5C i = 3\n\t * F1:0x64 i = 4\n\t * F1:0x6C i = 5\n\t * F1:0x74 i = 6\n\t * F1:0x7C i = 7\n\t * [ 2: 0] Destination Node ID\n\t *\t   000 = Node 0\n\t *\t   001 = Node 1\n\t *\t   010 = Node 2\n\t *\t   011 = Node 3\n\t *\t   100 = Node 4\n\t *\t   101 = Node 5\n\t *\t   110 = Node 6\n\t *\t   111 = Node 7\n\t * [ 7: 3] Reserved\n\t * [10: 8] Interleave select\n\t *\t   specifies the values of A[14:12] to use with interleave enable.\n\t * [15:11] Reserved\n\t * [31:16] DRAM Limit Address i Bits 39-24\n\t *\t   This field defines the upper address bits of a 40 bit  address\n\t *\t   that define the end of the DRAM region.\n\t */\n\tPCI_ADDR(0, 0x18, 1, 0x44), 0x0000f8f8, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x4C), 0x0000f8f8, 0x00000001,\n\tPCI_ADDR(0, 0x18, 1, 0x54), 0x0000f8f8, 0x00000002,\n\tPCI_ADDR(0, 0x18, 1, 0x5C), 0x0000f8f8, 0x00000003,\n\tPCI_ADDR(0, 0x18, 1, 0x64), 0x0000f8f8, 0x00000004,\n\tPCI_ADDR(0, 0x18, 1, 0x6C), 0x0000f8f8, 0x00000005,\n\tPCI_ADDR(0, 0x18, 1, 0x74), 0x0000f8f8, 0x00000006,\n\tPCI_ADDR(0, 0x18, 1, 0x7C), 0x0000f8f8, 0x00000007,\n\t/* DRAM Base i Registers\n\t * F1:0x40 i = 0\n\t * F1:0x48 i = 1\n\t * F1:0x50 i = 2\n\t * F1:0x58 i = 3\n\t * F1:0x60 i = 4\n\t * F1:0x68 i = 5\n\t * F1:0x70 i = 6\n\t * F1:0x78 i = 7\n\t * [ 0: 0] Read Enable\n\t *\t   0 = Reads Disabled\n\t *\t   1 = Reads Enabled\n\t * [ 1: 1] Write Enable\n\t *\t   0 = Writes Disabled\n\t *\t   1 = Writes Enabled\n\t * [ 7: 2] Reserved\n\t * [10: 8] Interleave Enable\n\t *\t   000 = No interleave\n\t *\t   001 = Interleave on A[12] (2 nodes)\n\t *\t   010 = reserved\n\t *\t   011 = Interleave on A[12] and A[14] (4 nodes)\n\t *\t   100 = reserved\n\t *\t   101 = reserved\n\t *\t   110 = reserved\n\t *\t   111 = Interleve on A[12] and A[13] and A[14] (8 nodes)\n\t * [15:11] Reserved\n\t * [13:16] DRAM Base Address i Bits 39-24\n\t *\t   This field defines the upper address bits of a 40-bit address\n\t *\t   that define the start of the DRAM region.\n\t */\n\tPCI_ADDR(0, 0x18, 1, 0x40), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x48), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x50), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x58), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x60), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x68), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x70), 0x0000f8fc, 0x00000000,\n\tPCI_ADDR(0, 0x18, 1, 0x78), 0x0000f8fc, 0x00000000,\n\t/* Memory-Mapped I/O Limit i Registers\n\t * F1:0x84 i = 0\n\t * F1:0x8C i = 1\n\t * F1:0x94 i = 2\n\t * F1:0x9C i = 3\n\t * F1:0xA4 i = 4\n\t * F1:0xAC i = 5\n\t * F1:0xB4 i = 6\n\t * F1:0xBC i = 7\n\t * [ 2: 0] Destination Node ID\n\t *\t   000 = Node 0\n\t *\t   001 = Node 1\n\t *\t   010 = Node 2\n\t *\t   011 = Node 3\n\t *\t   100 = Node 4\n\t *\t   101 = Node 5\n\t *\t   110 = Node 6\n\t *\t   111 = Node 7\n\t * [ 3: 3] Reserved\n\t * [ 5: 4] Destination Link ID\n\t *\t   00 = Link 0\n\t *\t   01 = Link 1\n\t *\t   10 = Link 2\n\t *\t   11 = Reserved\n\t * [ 6: 6] Reserved\n\t * [ 7: 7] Non-Posted\n\t *\t   0 = CPU writes may be posted\n\t *\t   1 = CPU writes must be non-posted\n\t * [31: 8] Memory-Mapped I/O Limit Address i (39-16)\n\t *\t   This field defines the upp adddress bits of a 40-bit address that\n\t *\t   defines the end of a memory-mapped I/O region n\n\t */\n\t/* Memory-Mapped I/O Base i Registers\n\t * F1:0x80 i = 0\n\t * F1:0x88 i = 1\n\t * F1:0x90 i = 2\n\t * F1:0x98 i = 3\n\t * F1:0xA0 i = 4\n\t * F1:0xA8 i = 5\n\t * F1:0xB0 i = 6\n\t * F1:0xB8 i = 7\n\t * [ 0: 0] Read Enable\n\t *\t   0 = Reads disabled\n\t *\t   1 = Reads Enabled\n\t * [ 1: 1] Write Enable\n\t *\t   0 = Writes disabled\n\t *\t   1 = Writes Enabled\n\t * [ 2: 2] Cpu Disable\n\t *\t   0 = Cpu can use this I/O range\n\t *\t   1 = Cpu requests do not use this I/O range\n\t * [ 3: 3] Lock\n\t *\t   0 = base/limit registers i are read/write\n\t *\t   1 = base/limit registers i are read-only\n\t * [ 7: 4] Reserved\n\t * [31: 8] Memory-Mapped I/O Base Address i (39-16)\n\t *\t   This field defines the upper address bits of a 40bit address\n\t *\t   that defines the start of memory-mapped I/O region i\n\t */\n\n\tPCI_ADDR(0, 0x18, 1, 0xbc), 0x48, 0xfe2f10,\n\tPCI_ADDR(0, 0x18, 1, 0xb8), 0xf0, 0xfc0003,\n\t//PCI_ADDR(0, 0x18, 1, 0xbc), 0x48, 0x0,\n\t// PCI_ADDR(0, 0x18, 1, 0xb8), 0xf0, 0x0,\n\n\tPCI_ADDR(0, 0x18, 1, 0xb4), 0x48, 0xfec010,\n\tPCI_ADDR(0, 0x18, 1, 0xb0), 0xf0, 0xfec003,\n\t//PCI_ADDR(0, 0x18, 1, 0xb4), 0x48, 0x0,\n\t//PCI_ADDR(0, 0x18, 1, 0xb0), 0xf0, 0x0,\n\n\tPCI_ADDR(0, 0x18, 1, 0xac), 0x48, 0xb10,\n\tPCI_ADDR(0, 0x18, 1, 0xa8), 0xf0, 0xa03,\n\t//PCI_ADDR(0, 0x18, 1, 0xac), 0x48, 0x0,\n\t//PCI_ADDR(0, 0x18, 1, 0xa8), 0xf0, 0x0,\n\n\tPCI_ADDR(0, 0x18, 1, 0xa4), 0x48, 0xfed010,\n\tPCI_ADDR(0, 0x18, 1, 0xa0), 0xf0, 0xfed003,\n\t//PCI_ADDR(0, 0x18, 1, 0xa4), 0x48, 0x0,\n\t//PCI_ADDR(0, 0x18, 1, 0xa0), 0xf0, 0x0,\n\n\tPCI_ADDR(0, 0x18, 1, 0x9c), 0x48, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x98), 0xf0, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x94), 0x48, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x90), 0xf0, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x8c), 0x48, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x88), 0xf0, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x84), 0x48, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0x80), 0xf0, 0x0,\n\t/* PCI I/O Limit i Registers\n\t * F1:0xC4 i = 0\n\t * F1:0xCC i = 1\n\t * F1:0xD4 i = 2\n\t * F1:0xDC i = 3\n\t * [ 2: 0] Destination Node ID\n\t *\t   000 = Node 0\n\t *\t   001 = Node 1\n\t *\t   010 = Node 2\n\t *\t   011 = Node 3\n\t *\t   100 = Node 4\n\t *\t   101 = Node 5\n\t *\t   110 = Node 6\n\t *\t   111 = Node 7\n\t * [ 3: 3] Reserved\n\t * [ 5: 4] Destination Link ID\n\t *\t   00 = Link 0\n\t *\t   01 = Link 1\n\t *\t   10 = Link 2\n\t *\t   11 = reserved\n\t * [11: 6] Reserved\n\t * [24:12] PCI I/O Limit Address i\n\t *\t   This field defines the end of PCI I/O region n\n\t * [31:25] Reserved\n\t */\n\t/* PCI I/O Base i Registers\n\t * F1:0xC0 i = 0\n\t * F1:0xC8 i = 1\n\t * F1:0xD0 i = 2\n\t * F1:0xD8 i = 3\n\t * [ 0: 0] Read Enable\n\t *\t   0 = Reads Disabled\n\t *\t   1 = Reads Enabled\n\t * [ 1: 1] Write Enable\n\t *\t   0 = Writes Disabled\n\t *\t   1 = Writes Enabled\n\t * [ 3: 2] Reserved\n\t * [ 4: 4] VGA Enable\n\t *\t   0 = VGA matches Disabled\n\t *\t   1 = matches all address < 64K and where A[9:0] is in the\n\t *\t       range 3B0-3BB or 3C0-3DF independen of the base & limit registers\n\t * [ 5: 5] ISA Enable\n\t *\t   0 = ISA matches Disabled\n\t *\t   1 = Blocks address < 64K and in the last 768 bytes of eack 1K block\n\t *\t       from matching agains this base/limit pair\n\t * [11: 6] Reserved\n\t * [24:12] PCI I/O Base i\n\t *\t   This field defines the start of PCI I/O region n\n\t * [31:25] Reserved\n\t */\n\tPCI_ADDR(0, 0x18, 1, 0xdc), 0xFE000FC8, 0x1fff010,\n\tPCI_ADDR(0, 0x18, 1, 0xd8), 0xFE000FCC, 0x33,\n\tPCI_ADDR(0, 0x18, 1, 0xd4), 0xFE000FC8, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0xd0), 0xFE000FCC, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0xcc), 0xFE000FC8, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0xc8), 0xFE000FCC, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0xc4), 0xFE000FC8, 0x0,\n\tPCI_ADDR(0, 0x18, 1, 0xc0), 0xFE000FCC, 0x0,\n\t/* Config Base and Limit i Registers\n\t * F1:0xE0 i = 0\n\t * F1:0xE4 i = 1\n\t * F1:0xE8 i = 2\n\t * F1:0xEC i = 3\n\t * [ 0: 0] Read Enable\n\t *\t   0 = Reads Disabled\n\t *\t   1 = Reads Enabled\n\t * [ 1: 1] Write Enable\n\t *\t   0 = Writes Disabled\n\t *\t   1 = Writes Enabled\n\t * [ 2: 2] Device Number Compare Enable\n\t *\t   0 = The ranges are based on bus number\n\t *\t   1 = The ranges are ranges of devices on bus 0\n\t * [ 3: 3] Reserved\n\t * [ 6: 4] Destination Node\n\t *\t   000 = Node 0\n\t *\t   001 = Node 1\n\t *\t   010 = Node 2\n\t *\t   011 = Node 3\n\t *\t   100 = Node 4\n\t *\t   101 = Node 5\n\t *\t   110 = Node 6\n\t *\t   111 = Node 7\n\t * [ 7: 7] Reserved\n\t * [ 9: 8] Destination Link\n\t *\t   00 = Link 0\n\t *\t   01 = Link 1\n\t *\t   10 = Link 2\n\t *\t   11 - Reserved\n\t * [15:10] Reserved\n\t * [23:16] Bus Number Base i\n\t *\t   This field defines the lowest bus number in configuration region i\n\t * [31:24] Bus Number Limit i\n\t *\t   This field defines the highest bus number in configuration regin i\n\t */\n\tPCI_ADDR(0, 0x18, 1, 0xe0), 0x0000FC88, 0xff040103,\n\tPCI_ADDR(0, 0x18, 1, 0xe4), 0x0000FC88, 0,\n\tPCI_ADDR(0, 0x18, 1, 0xe8), 0x0000FC88, 0,\n\tPCI_ADDR(0, 0x18, 1, 0xec), 0x0000FC88, 0,\n        };\n        int max;\n        max = ARRAY_SIZE(register_values);\n        setup_resource_map(register_values, max);\n}", "path": "src\\mainboard\\ibm\\e325\\resourcemap.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* Enable the serial ports on the IT8671F Super I/O chip. */\n", "func_signal": "static void it8671f_enable_serial(device_t dev, unsigned iobase)", "code": "{\n\tit8671f_enter_conf();\n\n\t/* Allow all devices to be enabled. Bits: FDC (0), Com1 (1), Com2 (2),\n           PP (3), Reserved (4), KBCK (5), KBCM (6), Reserved (7). */\n\tit8671f_sio_write(0x00, IT8671F_CONFIG_REG_LDE, 0x6f);\n\n\t/* Enable serial port(s). */\n\tit8671f_sio_write(IT8671F_SP1, 0x30, 0x01); /* Serial port 1 */\n\tit8671f_sio_write(IT8671F_SP2, 0x30, 0x01); /* Serial port 2 */\n\n\tit8671f_exit_conf();\n}", "path": "src\\superio\\ite\\it8671f\\it8671f_early_serial.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n * This file is part of the coreboot project.\n *\n * Copyright (C) 2003 Ronald G. Minnich\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n */\n", "func_signal": "static void print_debug_pci_dev(unsigned dev)", "code": "{\n\tprint_debug(\"PCI: \");\n\tprint_debug_hex8((dev >> 20) & 0xff);\n\tprint_debug_char(':');\n\tprint_debug_hex8((dev >> 15) & 0x1f);\n\tprint_debug_char('.');\n\tprint_debug_hex8((dev >> 12) & 0x07);\n}", "path": "src\\northbridge\\intel\\i855\\debug.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n * The content of IT8671F_CONFIG_REG_LDN (index 0x07) must be set to the\n * LDN the register belongs to, before you can access the register.\n */\n", "func_signal": "static void it8671f_sio_write(uint8_t ldn, uint8_t index, uint8_t value)", "code": "{\n\toutb(IT8671F_CONFIG_REG_LDN, SIO_BASE);\n\toutb(ldn, SIO_DATA);\n\toutb(index, SIO_BASE);\n\toutb(value, SIO_DATA);\n}", "path": "src\\superio\\ite\\it8671f\\it8671f_early_serial.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/**********************************************************************************/\n/*                              PRIVATE FUNCTIONS                                 */\n/**********************************************************************************/\n", "func_signal": "static void lpc47n227_pnp_set_resource(device_t dev, struct resource *resource)", "code": "{\n\tif (!(resource->flags & IORESOURCE_ASSIGNED)) {\n\t\tprintk(BIOS_ERR, \"ERROR: %s %02lx not allocated\\n\",\n\t\t\t   dev_path(dev), resource->index);\n\t\treturn;\n\t}\n\n\t/* Now store the resource */\n\t// NOTE: Cannot use pnp_set_XXX() here because they assume chip\n\t// support for logical devices, which the LPC47N227 doesn't have\n\n\tif (resource->flags & IORESOURCE_IO) {\n\t\tlpc47n227_pnp_set_iobase(dev, resource->base);\n\t} else if (resource->flags & IORESOURCE_DRQ) {\n\t\tlpc47n227_pnp_set_drq(dev, resource->base);\n\t} else if (resource->flags & IORESOURCE_IRQ) {\n\t\tlpc47n227_pnp_set_irq(dev, resource->base);\n\t} else {\n\t\tprintk(BIOS_ERR, \"ERROR: %s %02lx unknown resource type\\n\",\n\t\t\t   dev_path(dev), resource->index);\n\t\treturn;\n\t}\n\tresource->flags |= IORESOURCE_STORED;\n\n\treport_resource_stored(dev, resource, \"\");\n}", "path": "src\\superio\\smsc\\lpc47n227\\superio.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n  #include \"lib/generic_sdram.c\"\n*/\n", "func_signal": "static void enable_mainboard_devices(void)", "code": "{\n\tdevice_t dev;\n\t/* dev 0 for southbridge */\n\n\tdev = pci_locate_device(PCI_ID(0x1106,0x8231), 0);\n\n\tif (dev == PCI_DEV_INVALID) {\n\t\tdie(\"Southbridge not found!!!\\n\");\n\t}\n\n\tpci_write_config8(dev, 0x50, 7);\n\tpci_write_config8(dev, 0x51, 0xff);\n#if 0\n\t// This early setup switches IDE into compatibility mode before PCI gets\n\t// a chance to assign I/Os\n\t//   movl    $CONFIG_ADDR(0, 0x89, 0x42), %eax\n\t//   movb    $0x09, %dl\n\t//   movb    $0x00, %dl\n\t//   PCI_WRITE_CONFIG_BYTE\n\t//\n#endif\n\t/* we do this here as in V2, we can not yet do raw operations\n\t * to pci!\n\t */\n\t/* changed this to work correctly on later revisions of LB.\n\t* The original dev += 0x100; stopped working. It also appears\n\t* that if this is not set here, but in ide_init() only, the IDE\n\t* does not work at all. I assume it needs to be set before something else,\n\t* possibly before enabling the IDE peripheral, or it is a timing issue.\n\t* Ben Hewson 29 Apr 2007.\n\t*/\n\n\tdev = pci_locate_device(PCI_ID(0x1106,0x0571), 0);\n\tpci_write_config8(dev, 0x42, 0);\n}", "path": "src\\mainboard\\via\\epia\\romstage.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/**\n * Normally this function is defined in lapic.h as an always inline function\n * that just keeps the CPU in a hlt() loop. This does not work on all CPUs.\n * I think all hyperthreading CPUs might need this version, but I could only\n * verify this on the Intel Core Duo\n */\n", "func_signal": "void stop_this_cpu(void)", "code": "{\n\tint timeout;\n\tunsigned long send_status;\n\tunsigned long id;\n\n\tid = lapic_read(LAPIC_ID) >> 24;\n\n\tprintk(BIOS_DEBUG, \"CPU %ld going down...\\n\", id);\n\n\t/* send an LAPIC INIT to myself */\n\tlapic_write_around(LAPIC_ICR2, SET_LAPIC_DEST_FIELD(id));\n\tlapic_write_around(LAPIC_ICR, LAPIC_INT_LEVELTRIG | LAPIC_INT_ASSERT | LAPIC_DM_INIT);\n\n\t/* wait for the ipi send to finish */\n#if 0\n\t// When these two printk(BIOS_SPEW, ...) calls are not removed, the\n\t// machine will hang when log level is SPEW. Why?\n\tprintk(BIOS_SPEW, \"Waiting for send to finish...\\n\");\n#endif\n\ttimeout = 0;\n\tdo {\n#if 0\n\t\tprintk(BIOS_SPEW, \"+\");\n#endif\n\t\tudelay(100);\n\t\tsend_status = lapic_read(LAPIC_ICR) & LAPIC_ICR_BUSY;\n\t} while (send_status && (timeout++ < 1000));\n\tif (timeout >= 1000) {\n\t\tprintk(BIOS_ERR, \"timed out\\n\");\n\t}\n\tmdelay(10);\n\n\tprintk(BIOS_SPEW, \"Deasserting INIT.\\n\");\n\t/* Deassert the LAPIC INIT */\n\tlapic_write_around(LAPIC_ICR2, SET_LAPIC_DEST_FIELD(id));\n\tlapic_write_around(LAPIC_ICR, LAPIC_INT_LEVELTRIG | LAPIC_DM_INIT);\n\n\tprintk(BIOS_SPEW, \"Waiting for send to finish...\\n\");\n\ttimeout = 0;\n\tdo {\n\t\tprintk(BIOS_SPEW, \"+\");\n\t\tudelay(100);\n\t\tsend_status = lapic_read(LAPIC_ICR) & LAPIC_ICR_BUSY;\n\t} while (send_status && (timeout++ < 1000));\n\tif (timeout >= 1000) {\n\t\tprintk(BIOS_ERR, \"timed out\\n\");\n\t}\n\n\twhile(1) {\n\t\thlt();\n\t}\n}", "path": "src\\cpu\\x86\\lapic\\lapic_cpu_init.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "// Copy GDT to new location and reload it\n", "func_signal": "void move_gdt(void)", "code": "{\n\tvoid *newgdt;\n\tu16 num_gdt_bytes = &gdt_end - &gdt;\n\tstruct gdtarg gdtarg;\n\n\tnewgdt = cbmem_find(CBMEM_ID_GDT);\n\tif (!newgdt) {\n\t\tnewgdt = cbmem_add(CBMEM_ID_GDT, ALIGN(num_gdt_bytes, 512));\n\t\tif (!newgdt) {\n\t\t\tprintk(BIOS_ERR, \"Error: Could not relocate GDT.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tprintk(BIOS_DEBUG, \"Moving GDT to %p...\", newgdt);\n\t\tmemcpy((void*)newgdt, &gdt, num_gdt_bytes);\n\t}\n\n\tgdtarg.base = (u32)newgdt;\n\tgdtarg.limit = num_gdt_bytes - 1;\n\n\t__asm__ __volatile__ (\"lgdt %0\\n\\t\" : : \"m\" (gdtarg));\n\tprintk(BIOS_DEBUG, \"ok\\n\");\n}", "path": "src\\arch\\i386\\boot\\gdt.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n\t2005.11 yhlu add let the real sb to use small unitid\n*/\n// only for sb ht chain\n", "func_signal": "static void enumerate_ht_chain(void)", "code": "{\n#if CONFIG_HT_CHAIN_UNITID_BASE != 0\n/* CONFIG_HT_CHAIN_UNITID_BASE could be 0 (only one ht device in the ht chain), if so, don't need to go through the chain  */\n\n\t/* Assumption the HT chain that is bus 0 has the HT I/O Hub on it.\n\t * On most boards this just happens.  If a cpu has multiple\n\t * non Coherent links the appropriate bus registers for the\n\t * links needs to be programed to point at bus 0.\n\t */\n\tunsigned next_unitid, last_unitid;\n\tdevice_t dev;\n#if CONFIG_HT_CHAIN_END_UNITID_BASE != 0x20\n\t//let't record the device of last ht device, So we can set the Unitid to CONFIG_HT_CHAIN_END_UNITID_BASE\n\tunsigned real_last_unitid;\n\tuint8_t real_last_pos;\n\tint ht_dev_num = 0; // except host_bridge\n\tuint8_t end_used = 0;\n#endif\n\n\tdev = PCI_DEV(0,0,0);\n\tnext_unitid = CONFIG_HT_CHAIN_UNITID_BASE;\n\tdo {\n\t\tuint32_t id;\n\t\tuint8_t hdr_type, pos;\n\t\tlast_unitid = next_unitid;\n\n\t\tid = pci_read_config32(dev, PCI_VENDOR_ID);\n\t\t/* If the chain is enumerated quit */\n\t\tif (((id & 0xffff) == 0x0000) || ((id & 0xffff) == 0xffff) ||\n\t\t\t(((id >> 16) & 0xffff) == 0xffff) ||\n\t\t\t(((id >> 16) & 0xffff) == 0x0000))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\thdr_type = pci_read_config8(dev, PCI_HEADER_TYPE);\n\t\tpos = 0;\n\t\thdr_type &= 0x7f;\n\n\t\tif ((hdr_type == PCI_HEADER_TYPE_NORMAL) ||\n\t\t\t(hdr_type == PCI_HEADER_TYPE_BRIDGE))\n\t\t{\n\t\t\tpos = pci_read_config8(dev, PCI_CAPABILITY_LIST);\n\t\t}\n\t\twhile(pos != 0) {\n\t\t\tuint8_t cap;\n\t\t\tcap = pci_read_config8(dev, pos + PCI_CAP_LIST_ID);\n\t\t\tif (cap == PCI_CAP_ID_HT) {\n\t\t\t\tuint16_t flags;\n\t\t\t\t/* Read and write and reread flags so the link\n\t\t\t\t * direction bit is valid.\n\t\t\t\t */\n\t\t\t\tflags = pci_read_config16(dev, pos + PCI_CAP_FLAGS);\n\t\t\t\tpci_write_config16(dev, pos + PCI_CAP_FLAGS, flags);\n\t\t\t\tflags = pci_read_config16(dev, pos + PCI_CAP_FLAGS);\n\t\t\t\tif ((flags >> 13) == 0) {\n\t\t\t\t\tunsigned count;\n\t\t\t\t\tunsigned ctrl, ctrl_off;\n\t\t\t\t\tdevice_t devx;\n\n#if CONFIG_HT_CHAIN_END_UNITID_BASE != 0x20\n\t\t\t\t\tif(next_unitid>=0x18) { // don't get mask out by k8, at this time BSP, RT is not enabled, it will response from 0x18,0--0x1f.\n\t\t\t\t\t\tif(!end_used) {\n\t\t\t\t\t\t\tnext_unitid = CONFIG_HT_CHAIN_END_UNITID_BASE;\n\t\t\t\t\t\t\tend_used = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treal_last_unitid = next_unitid;\n\t\t\t\t\treal_last_pos = pos;\n\t\t\t\t\tht_dev_num++;\n#endif\n\n\t\t\t\t\tflags &= ~0x1f;\n\t\t\t\t\tflags |= next_unitid & 0x1f;\n\t\t\t\t\tcount = (flags >> 5) & 0x1f;\n\n\t\t\t\t\tdevx = PCI_DEV(0, next_unitid, 0);\n\t\t\t\t\tpci_write_config16(dev, pos + PCI_CAP_FLAGS, flags);\n\n\t\t\t\t\tnext_unitid += count;\n\n\t\t\t\t\tflags = pci_read_config16(devx, pos + PCI_CAP_FLAGS);\n\t\t\t\t\t/* Test for end of chain */\n\t\t\t\t\tctrl_off = ((flags >> 10) & 1)?\n\t\t\t\t\t\tPCI_HT_CAP_SLAVE_CTRL0 : PCI_HT_CAP_SLAVE_CTRL1; // another end\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tctrl = pci_read_config16(devx, pos + ctrl_off);\n\t\t\t\t\t\t/* Is this the end of the hypertransport chain? */\n\t\t\t\t\t\tif (ctrl & (1 << 6)) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ctrl & ((1 << 4) | (1 << 8))) {\n\t\t\t\t\t\t       /*\n\t\t\t\t\t\t\t* Either the link has failed, or we have\n\t\t\t\t\t\t\t* a CRC error.\n\t\t\t\t\t\t\t* Sometimes this can happen due to link\n\t\t\t\t\t\t\t* retrain, so lets knock it down and see\n\t\t\t\t\t\t\t* if its transient\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tctrl |= ((1 << 4) | (1 <<8)); // Link fail + Crc\n\t\t\t\t\t\t\tpci_write_config16(devx, pos + ctrl_off, ctrl);\n\t\t\t\t\t\t\tctrl = pci_read_config16(devx, pos + ctrl_off);\n\t\t\t\t\t\t\tif (ctrl & ((1 << 4) | (1 << 8))) {\n\t\t\t\t\t\t\t\t// can not clear the error\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while((ctrl & (1 << 5)) == 0);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = pci_read_config8(dev, pos + PCI_CAP_LIST_NEXT);\n\t\t}\n\t} while(last_unitid != next_unitid);\n\nout:\n\t;\n\n#if CONFIG_HT_CHAIN_END_UNITID_BASE != 0x20\n\tif((ht_dev_num>1) && (real_last_unitid != CONFIG_HT_CHAIN_END_UNITID_BASE) && !end_used) {\n\t\tuint16_t flags;\n\t\tdev = PCI_DEV(0,real_last_unitid, 0);\n\t\tflags = pci_read_config16(dev, real_last_pos + PCI_CAP_FLAGS);\n\t        flags &= ~0x1f;\n\t        flags |= CONFIG_HT_CHAIN_END_UNITID_BASE & 0x1f;\n\t\tpci_write_config16(dev, real_last_pos + PCI_CAP_FLAGS, flags);\n\t}\n#endif\n\n#endif\n\n}", "path": "src\\northbridge\\amd\\amdk8\\early_ht.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n * This file is part of the coreboot project.\n *\n * Copyright (C) 2007 AMD\n * Written by Yinghai Lu <yinghailu@amd.com> for AMD.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n */\n", "func_signal": "static void setup_mb_resource_map(void)", "code": "{\n\tstatic const unsigned int register_values[] = {\n\t\t/* Careful set limit registers before base registers which contain the enables */\n\t\t/* DRAM Limit i Registers\n\t\t * F1:0x44 i = 0\n\t\t * F1:0x4C i = 1\n\t\t * F1:0x54 i = 2\n\t\t * F1:0x5C i = 3\n\t\t * F1:0x64 i = 4\n\t\t * F1:0x6C i = 5\n\t\t * F1:0x74 i = 6\n\t\t * F1:0x7C i = 7\n\t\t * [ 2: 0] Destination Node ID\n\t\t *\t   000 = Node 0\n\t\t *\t   001 = Node 1\n\t\t *\t   010 = Node 2\n\t\t *\t   011 = Node 3\n\t\t *\t   100 = Node 4\n\t\t *\t   101 = Node 5\n\t\t *\t   110 = Node 6\n\t\t *\t   111 = Node 7\n\t\t * [ 7: 3] Reserved\n\t\t * [10: 8] Interleave select\n\t\t *\t   specifies the values of A[14:12] to use with interleave enable.\n\t\t * [15:11] Reserved\n\t\t * [31:16] DRAM Limit Address i Bits 39-24\n\t\t *\t   This field defines the upper address bits of a 40 bit  address\n\t\t *\t   that define the end of the DRAM region.\n\t\t */\n\t\t// PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x44), 0x0000f8f8, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x4C), 0x0000f8f8, 0x00000001,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x54), 0x0000f8f8, 0x00000002,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x5C), 0x0000f8f8, 0x00000003,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x64), 0x0000f8f8, 0x00000004,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x6C), 0x0000f8f8, 0x00000005,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x74), 0x0000f8f8, 0x00000006,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x7C), 0x0000f8f8, 0x00000007,\n\n\t\t/* DRAM Base i Registers\n\t\t * F1:0x40 i = 0\n\t\t * F1:0x48 i = 1\n\t\t * F1:0x50 i = 2\n\t\t * F1:0x58 i = 3\n\t\t * F1:0x60 i = 4\n\t\t * F1:0x68 i = 5\n\t\t * F1:0x70 i = 6\n\t\t * F1:0x78 i = 7\n\t\t * [ 0: 0] Read Enable\n\t\t *\t   0 = Reads Disabled\n\t\t *\t   1 = Reads Enabled\n\t\t * [ 1: 1] Write Enable\n\t\t *\t   0 = Writes Disabled\n\t\t *\t   1 = Writes Enabled\n\t\t * [ 7: 2] Reserved\n\t\t * [10: 8] Interleave Enable\n\t\t *\t   000 = No interleave\n\t\t *\t   001 = Interleave on A[12] (2 nodes)\n\t\t *\t   010 = reserved\n\t\t *\t   011 = Interleave on A[12] and A[14] (4 nodes)\n\t\t *\t   100 = reserved\n\t\t *\t   101 = reserved\n\t\t *\t   110 = reserved\n\t\t *\t   111 = Interleve on A[12] and A[13] and A[14] (8 nodes)\n\t\t * [15:11] Reserved\n\t\t * [13:16] DRAM Base Address i Bits 39-24\n\t\t *\t   This field defines the upper address bits of a 40-bit address\n\t\t *\t   that define the start of the DRAM region.\n\t\t */\n\t\t// PCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x40), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x48), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x50), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x58), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x60), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x68), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x70), 0x0000f8fc, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x78), 0x0000f8fc, 0x00000000,\n\n\t\t/* Memory-Mapped I/O Limit i Registers\n\t\t * F1:0x84 i = 0\n\t\t * F1:0x8C i = 1\n\t\t * F1:0x94 i = 2\n\t\t * F1:0x9C i = 3\n\t\t * F1:0xA4 i = 4\n\t\t * F1:0xAC i = 5\n\t\t * F1:0xB4 i = 6\n\t\t * F1:0xBC i = 7\n\t\t * [ 2: 0] Destination Node ID\n\t\t *\t   000 = Node 0\n\t\t *\t   001 = Node 1\n\t\t *\t   010 = Node 2\n\t\t *\t   011 = Node 3\n\t\t *\t   100 = Node 4\n\t\t *\t   101 = Node 5\n\t\t *\t   110 = Node 6\n\t\t *\t   111 = Node 7\n\t\t * [ 3: 3] Reserved\n\t\t * [ 5: 4] Destination Link ID\n\t\t *\t   00 = Link 0\n\t\t *\t   01 = Link 1\n\t\t *\t   10 = Link 2\n\t\t *\t   11 = Reserved\n\t\t * [ 6: 6] Reserved\n\t\t * [ 7: 7] Non-Posted\n\t\t *\t   0 = CPU writes may be posted\n\t\t *\t   1 = CPU writes must be non-posted\n\t\t * [31: 8] Memory-Mapped I/O Limit Address i (39-16)\n\t\t *\t   This field defines the upp adddress bits of a 40-bit address that\n\t\t *\t   defines the end of a memory-mapped I/O region n\n\t\t */\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x84), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x8C), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x94), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x9C), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA4), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xAC), 0x00000048, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB4), 0x00000048, 0x00000000,\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xBC), 0x00000048, 0x00ffff00,\n\n\t\t/* Memory-Mapped I/O Base i Registers\n\t\t * F1:0x80 i = 0\n\t\t * F1:0x88 i = 1\n\t\t * F1:0x90 i = 2\n\t\t * F1:0x98 i = 3\n\t\t * F1:0xA0 i = 4\n\t\t * F1:0xA8 i = 5\n\t\t * F1:0xB0 i = 6\n\t\t * F1:0xB8 i = 7\n\t\t * [ 0: 0] Read Enable\n\t\t *\t   0 = Reads disabled\n\t\t *\t   1 = Reads Enabled\n\t\t * [ 1: 1] Write Enable\n\t\t *\t   0 = Writes disabled\n\t\t *\t   1 = Writes Enabled\n\t\t * [ 2: 2] Cpu Disable\n\t\t *\t   0 = Cpu can use this I/O range\n\t\t *\t   1 = Cpu requests do not use this I/O range\n\t\t * [ 3: 3] Lock\n\t\t *\t   0 = base/limit registers i are read/write\n\t\t *\t   1 = base/limit registers i are read-only\n\t\t * [ 7: 4] Reserved\n\t\t * [31: 8] Memory-Mapped I/O Base Address i (39-16)\n\t\t *\t   This field defines the upper address bits of a 40bit address\n\t\t *\t   that defines the start of memory-mapped I/O region i\n\t\t */\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x80), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x88), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x90), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0x98), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA0), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xA8), 0x000000f0, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB0), 0x000000f0, 0x00000000,\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xB8), 0x000000f0, 0x00fc0003,\n\n\t\t/* PCI I/O Limit i Registers\n\t\t * F1:0xC4 i = 0\n\t\t * F1:0xCC i = 1\n\t\t * F1:0xD4 i = 2\n\t\t * F1:0xDC i = 3\n\t\t * [ 2: 0] Destination Node ID\n\t\t *\t   000 = Node 0\n\t\t *\t   001 = Node 1\n\t\t *\t   010 = Node 2\n\t\t *\t   011 = Node 3\n\t\t *\t   100 = Node 4\n\t\t *\t   101 = Node 5\n\t\t *\t   110 = Node 6\n\t\t *\t   111 = Node 7\n\t\t * [ 3: 3] Reserved\n\t\t * [ 5: 4] Destination Link ID\n\t\t *\t   00 = Link 0\n\t\t *\t   01 = Link 1\n\t\t *\t   10 = Link 2\n\t\t *\t   11 = reserved\n\t\t * [11: 6] Reserved\n\t\t * [24:12] PCI I/O Limit Address i\n\t\t *\t   This field defines the end of PCI I/O region n\n\t\t * [31:25] Reserved\n\t\t */\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC4), 0xFE000FC8, 0x00007000,\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xCC), 0xFE000FC8, 0x01fff020, // need to talk to ANALOG of second CK804 to release PCI E reset\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD4), 0xFE000FC8, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xDC), 0xFE000FC8, 0x00000000,\n\n\t\t/* PCI I/O Base i Registers\n\t\t * F1:0xC0 i = 0\n\t\t * F1:0xC8 i = 1\n\t\t * F1:0xD0 i = 2\n\t\t * F1:0xD8 i = 3\n\t\t * [ 0: 0] Read Enable\n\t\t *\t   0 = Reads Disabled\n\t\t *\t   1 = Reads Enabled\n\t\t * [ 1: 1] Write Enable\n\t\t *\t   0 = Writes Disabled\n\t\t *\t   1 = Writes Enabled\n\t\t * [ 3: 2] Reserved\n\t\t * [ 4: 4] VGA Enable\n\t\t *\t   0 = VGA matches Disabled\n\t\t *\t   1 = matches all address < 64K and where A[9:0] is in the\n\t\t *\t       range 3B0-3BB or 3C0-3DF independen of the base & limit registers\n\t\t * [ 5: 5] ISA Enable\n\t\t *\t   0 = ISA matches Disabled\n\t\t *\t   1 = Blocks address < 64K and in the last 768 bytes of eack 1K block\n\t\t *\t       from matching agains this base/limit pair\n\t\t * [11: 6] Reserved\n\t\t * [24:12] PCI I/O Base i\n\t\t *\t   This field defines the start of PCI I/O region n\n\t\t * [31:25] Reserved\n\t\t */\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC0), 0xFE000FCC, 0x00000033,\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xC8), 0xFE000FCC, 0x00008033,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD0), 0xFE000FCC, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xD8), 0xFE000FCC, 0x00000000,\n\n\t\t/* Config Base and Limit i Registers\n\t\t * F1:0xE0 i = 0\n\t\t * F1:0xE4 i = 1\n\t\t * F1:0xE8 i = 2\n\t\t * F1:0xEC i = 3\n\t\t * [ 0: 0] Read Enable\n\t\t *\t   0 = Reads Disabled\n\t\t *\t   1 = Reads Enabled\n\t\t * [ 1: 1] Write Enable\n\t\t *\t   0 = Writes Disabled\n\t\t *\t   1 = Writes Enabled\n\t\t * [ 2: 2] Device Number Compare Enable\n\t\t *\t   0 = The ranges are based on bus number\n\t\t *\t   1 = The ranges are ranges of devices on bus 0\n\t\t * [ 3: 3] Reserved\n\t\t * [ 6: 4] Destination Node\n\t\t *\t   000 = Node 0\n\t\t *\t   001 = Node 1\n\t\t *\t   010 = Node 2\n\t\t *\t   011 = Node 3\n\t\t *\t   100 = Node 4\n\t\t *\t   101 = Node 5\n\t\t *\t   110 = Node 6\n\t\t *\t   111 = Node 7\n\t\t * [ 7: 7] Reserved\n\t\t * [ 9: 8] Destination Link\n\t\t *\t   00 = Link 0\n\t\t *\t   01 = Link 1\n\t\t *\t   10 = Link 2\n\t\t *\t   11 - Reserved\n\t\t * [15:10] Reserved\n\t\t * [23:16] Bus Number Base i\n\t\t *\t   This field defines the lowest bus number in configuration region i\n\t\t * [31:24] Bus Number Limit i\n\t\t *\t   This field defines the highest bus number in configuration region i\n\t\t */\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE0), 0x0000FC88, 0x3f000003, /* link 0 of cpu 0 --> Nvidia MCP55 Pro */\n//\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE4), 0x0000FC88, 0x7f400203, /* link 2 of cpu 0 --> nvidia io55 \t*/\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xE8), 0x0000FC88, 0x00000000,\n\t\tPCI_ADDR(CONFIG_CBB, CONFIG_CDB, 1, 0xEC), 0x0000FC88, 0x00000000,\n\n\t};\n\n\tint max;\n\tmax = ARRAY_SIZE(register_values);\n\tsetup_resource_map(register_values, max);\n}", "path": "src\\mainboard\\tyan\\s2912_fam10\\resourcemap.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* Enter the configuration state (MB PnP mode). */\n", "func_signal": "static void it8671f_enter_conf(void)", "code": "{\n\tuint8_t i;\n\n\t/* Perform MB PnP setup to put the SIO chip at 0x3f0. */\n\t/* Base address 0x3f0: 0x86 0x80 0x55 0x55. */\n\t/* Base address 0x3bd: 0x86 0x80 0x55 0xaa. */\n\t/* Base address 0x370: 0x86 0x80 0xaa 0x55. */\n\toutb(0x86, IT8671F_CONFIGURATION_PORT);\n\toutb(0x80, IT8671F_CONFIGURATION_PORT);\n\toutb(0x55, IT8671F_CONFIGURATION_PORT);\n\toutb(0x55, IT8671F_CONFIGURATION_PORT);\n\n\t/* Sequentially write the 32 special values. */\n\tfor (i = 0; i < 32; i++)\n\t\toutb(init_values[i], SIO_BASE);\n}", "path": "src\\superio\\ite\\it8671f\\it8671f_early_serial.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n * Do the uncompression!\n */\n", "func_signal": "int gunzip(void)", "code": "{\n    uch flags;\n    unsigned char magic[2]; /* magic header */\n    char method;\n    ulg orig_crc = 0;       /* original crc */\n    ulg orig_len = 0;       /* original uncompressed length */\n    int res;\n\n    magic[0] = (unsigned char)get_byte();\n    magic[1] = (unsigned char)get_byte();\n    method = (unsigned char)get_byte();\n\n    if (magic[0] != 037 ||\n\t((magic[1] != 0213) && (magic[1] != 0236))) {\n\t    error(\"bad gzip magic numbers\");\n\t    return -1;\n    }\n\n    /* We only support method #8, DEFLATED */\n    if (method != 8)  {\n\t    error(\"internal error, invalid method\");\n\t    return -1;\n    }\n\n    flags  = (uch)get_byte();\n    if ((flags & ENCRYPTED) != 0) {\n\t    error(\"Input is encrypted\\n\");\n\t    return -1;\n    }\n    if ((flags & CONTINUATION) != 0) {\n\t    error(\"Multi part input\\n\");\n\t    return -1;\n    }\n    if ((flags & RESERVED) != 0) {\n\t    error(\"Input has invalid flags\\n\");\n\t    return -1;\n    }\n    (ulg)get_byte();\t/* Get timestamp */\n    ((ulg)get_byte()) << 8;\n    ((ulg)get_byte()) << 16;\n    ((ulg)get_byte()) << 24;\n\n    (void)get_byte();  /* Ignore extra flags for the moment */\n    (void)get_byte();  /* Ignore OS type for the moment */\n\n    if ((flags & EXTRA_FIELD) != 0) {\n\t    unsigned len = (unsigned)get_byte();\n\t    len |= ((unsigned)get_byte())<<8;\n\t    while (len--) (void)get_byte();\n    }\n\n    /* Get original file name if it was truncated */\n    if ((flags & ORIG_NAME) != 0) {\n\t    /* Discard the old name */\n\t    while (get_byte() != 0) /* null */ ;\n    }\n\n    /* Discard file comment if any */\n    if ((flags & COMMENT) != 0) {\n\t    while (get_byte() != 0) /* null */ ;\n    }\n\n    /* Decompress */\n    if ((res = inflate())) {\n\t    switch (res) {\n\t    case 0:\n\t\t    break;\n\t    case 1:\n\t\t    error(\"invalid compressed format (err=1)\");\n\t\t    break;\n\t    case 2:\n\t\t    error(\"invalid compressed format (err=2)\");\n\t\t    break;\n\t    case 3:\n\t\t    error(\"out of memory\");\n\t\t    break;\n\t    default:\n\t\t    error(\"invalid compressed format (other)\");\n\t    }\n\t    return -1;\n    }\n\n    /* Get the crc and original length */\n    /* crc32  (see algorithm.doc)\n     * uncompressed input size modulo 2^32\n     */\n    orig_crc = (ulg) get_byte();\n    orig_crc |= (ulg) get_byte() << 8;\n    orig_crc |= (ulg) get_byte() << 16;\n    orig_crc |= (ulg) get_byte() << 24;\n\n    orig_len = (ulg) get_byte();\n    orig_len |= (ulg) get_byte() << 8;\n    orig_len |= (ulg) get_byte() << 16;\n    orig_len |= (ulg) get_byte() << 24;\n\n    /* Validate decompression */\n    if (orig_crc != CRC_VALUE) {\n\t    error(\"crc error\");\n\t    return -1;\n    }\n    if (orig_len != bytes_out) {\n\t    error(\"length error\");\n\t    return -1;\n    }\n    return 0;\n}", "path": "util\\mkelfImage\\kunzip_src\\lib\\inflate.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* Select 48MHz CLKIN (24MHz is the default). */\n", "func_signal": "void it8671f_48mhz_clkin(void)", "code": "{\n\tit8671f_enter_conf();\n\tit8671f_sio_write(0x00, IT8671F_CONFIG_REG_SWSUSP, (1 << 6));\n\tit8671f_exit_conf();\n}", "path": "src\\superio\\ite\\it8671f\\it8671f_early_serial.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "//----------------------------------------------------------------------------------\n// Function:            enable_dev\n// Parameters:          dev - pointer to structure describing a Super I/O device\n// Return Value:        None\n// Description:         Create device structures and allocate resources to devices\n//                      specified in the pnp_dev_info array (above).\n//\n", "func_signal": "static void enable_dev(device_t dev)", "code": "{\n\tpnp_enable_devices(dev, &pnp_ops,\n\t\t\t   ARRAY_SIZE(pnp_dev_info), pnp_dev_info);\n}", "path": "src\\superio\\smsc\\lpc47n227\\superio.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* for UMA internal graphics */\n", "func_signal": "void avoid_lpc_dma_deadlock(device_t nb_dev, device_t sb_dev)", "code": "{\n\tdevice_t cpu_f0;\n\tu8 reg;\n\n\tcpu_f0 = dev_find_slot(0, PCI_DEVFN(0x18, 0));\n\tset_nbcfg_enable_bits(cpu_f0, 0x68, 3 << 21, 1 << 21);\n\n\treg = nbpcie_p_read_index(sb_dev, 0x10);\n\treg |= 0x100;\t\t/* bit9=1 */\n\tnbpcie_p_write_index(sb_dev, 0x10, reg);\n\n\treg = nbpcie_p_read_index(nb_dev, 0x10);\n\treg |= 0x100;\t\t/* bit9=1 */\n\tnbpcie_p_write_index(nb_dev, 0x10, reg);\n\n\t/* Enable NP protocol over PCIE for memory-mapped writes targeting LPC\n\t * Set this bit to avoid a deadlock condition. */\n\treg = htiu_read_index(nb_dev, 0x6);\n\treg |= 0x1000000;\t/* bit26 */\n\thtiu_write_index(nb_dev, 0x6, reg);\n}", "path": "src\\southbridge\\amd\\rs780\\rs780_ht.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* by yhlu 2005.10 */\n", "func_signal": "static unsigned get_sbdn(unsigned bus)", "code": "{\n        device_t dev;\n\n        /* Find the device.\n         * There can only be one 8111 on a hypertransport chain/bus.\n         */\n        dev = pci_locate_device_on_bus(\n                PCI_ID(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_PCI),\n                bus);\n\n        return (dev>>15) & 0x1f;\n\n}", "path": "src\\southbridge\\amd\\amd8111\\amd8111_early_ctrl.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* C entry point of secondary cpus */\n", "func_signal": "void secondary_cpu_init(void)", "code": "{\n\tatomic_inc(&active_cpus);\n#if CONFIG_SERIAL_CPU_INIT == 1\n  #if CONFIG_MAX_CPUS>2\n\tspin_lock(&start_cpu_lock);\n  #endif\n#endif\n\tcpu_initialize();\n#if CONFIG_SERIAL_CPU_INIT == 1\n  #if CONFIG_MAX_CPUS>2\n\tspin_unlock(&start_cpu_lock);\n  #endif\n#endif\n\n\tatomic_dec(&active_cpus);\n\n\tstop_this_cpu();\n}", "path": "src\\cpu\\x86\\lapic\\lapic_cpu_init.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*\n * Code to compute the CRC-32 table. Borrowed from\n * gzip-1.0.3/makecrc.c.\n */\n", "func_signal": "static void\nmakecrc(void)", "code": "{\n/* Not copyrighted 1990 Mark Adler\t*/\n\n  unsigned long c;      /* crc shift register */\n  unsigned long e;      /* polynomial exclusive-or pattern */\n  int i;                /* counter for all possible eight bit values */\n  int k;                /* byte being shifted into crc apparatus */\n\n  /* terms of polynomial defining this crc (except x^32): */\n  static const int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n  /* Make exclusive-or pattern from polynomial */\n  e = 0;\n  for (i = 0; i < sizeof(p)/sizeof(int); i++)\n    e |= 1L << (31 - p[i]);\n\n  crc_32_tab[0] = 0;\n\n  for (i = 1; i < 256; i++)\n  {\n    c = 0;\n    for (k = i | 256; k != 1; k >>= 1)\n    {\n      c = c & 1 ? (c >> 1) ^ e : c >> 1;\n      if (k & 1)\n        c ^= e;\n    }\n    crc_32_tab[i] = c;\n  }\n\n  /* this is initialized here so this code could reside in ROM */\n  crc = (ulg)0xffffffffL; /* shift register contents */\n}", "path": "util\\mkelfImage\\kunzip_src\\lib\\inflate.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "//----------------------------------------------------------------------------------\n// Function:            lpc47n227_pnp_set_resources\n// Parameters:          dev - pointer to structure describing a Super I/O device\n// Return Value:        None\n// Description:         Configure the specified Super I/O device with the resources\n//                      (I/O space, etc.) that have been allocate for it.\n//\n", "func_signal": "void lpc47n227_pnp_set_resources(device_t dev)", "code": "{\n\tstruct resource *res;\n\n\tpnp_enter_conf_state(dev);\n\n\t// NOTE: Cannot use pnp_set_resources() here because it assumes chip\n\t// support for logical devices, which the LPC47N227 doesn't have\n\tfor (res = dev->resource_list; res; res = res->next)\n\t\tlpc47n227_pnp_set_resource(dev, res);\n\n\tpnp_exit_conf_state(dev);\n}", "path": "src\\superio\\smsc\\lpc47n227\\superio.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/*----------------------------------------------------------------------------\n * FUNCTION: getMinNbCOF\n * INPUT: None\n * OUTPUT: minNbCOF (in multiple of half of CLKIN, 100MHz)\n * DESCRIPTION:\n * This function returns the minimum possible NbCOF (in 100MHz)\n * for the system .\n * This function can be run on any core and is used by the HT & Memory init code\n * in Phase 1.\n * ----------------------------------------------------------------------------\n */\n", "func_signal": "u8 getMinNbCOF(void)", "code": "{\n\tu8 numOfNode, i, j, deviceId, nbDid, nbFid, nextNbFid;\n\tu32 dtemp;\n\n\tnbDid = 0;\n\tnbFid = 0;\n\n\t/* get number of node in the system */\n\tnumOfNode = getNumOfNodeNb();\n\n\t/* go through each node for the minimum NbCOF (in multiple of CLKIN/2) */\n\tfor(i=0; i < numOfNode; i++)\n\t{\n\t\t/* stub function for APIC ID virtualization for large MP system later */\n\t\tdeviceId = translateNodeIdToDeviceIdNb(i);\n\n\t\t/* read all P-state spec registers for NbDid=1 */\n\t\tfor(j=0; j < 5; j++)\n\t\t{\n\t\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_4,PS_SPEC_REG+(j*PCI_REG_LEN)), &dtemp); /*F4x1E0 + j*4 */\n\t\t\t/* get NbDid */\n\t\t\tif(dtemp & NB_DID_MASK)\n\t\t\t\tnbDid = 1;\n\t\t}\n\t\t/* if F3x1FC[NbCofVidUpdate]=0, NbFid =  default value */\n\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_3,PRCT_INFO), &dtemp); /*F3x1FC*/\n\t\tif(!(dtemp & NB_CV_UPDATE)) /* F3x1FC[NbCofVidUpdated]=0, use default VID */\n\t\t{\n\t\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_3,CPTC0), &dtemp); /*F3xD4*/\n\t\t\tnextNbFid = (u8) (dtemp & BIT_MASK_5);\n\t\t\tif(nbDid)\n\t\t\t\tnextNbFid = (u8) (nextNbFid >> 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* check PVI/SPI */\n\t\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_3,PW_CTL_MISC), &dtemp); /*F3xA0*/\n\t\t\tif(dtemp & PVI_MODE) /* PVI */\n\t\t\t{\n\t\t\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_3,PRCT_INFO), &dtemp); /*F3x1FC*/\n\t\t\t\tnextNbFid = (u8) (dtemp >> UNI_NB_FID_BIT);\n\t\t\t\tnextNbFid &= BIT_MASK_5;\n\t\t\t\t/* if(nbDid)\n\t\t\t\t\tnextNbFid = nextNbFid  >> 1; */\n\t\t\t}\n\t\t\telse /* SVI */\n\t\t\t{\n\t\t\t\tAmdPCIRead(MAKE_SBDFO(0,0,deviceId,FN_3,PRCT_INFO), &dtemp); /*F3x1FC*/\n\t\t\t\tnextNbFid = (u8) ((dtemp >> UNI_NB_FID_BIT) & BIT_MASK_5);\n\t\t\t\tnextNbFid = (u8) (nextNbFid + ((dtemp >> SPLT_NB_FID_OFFSET) & BIT_MASK_3));\n\t\t\t\t/* if(nbDid)\n\t\t\t\t\tnextNbFid = nextNbFid >> 1; */\n\t\t\t}\n\t\t}\n\t\tif( i == 0)\n\t\t\tnbFid = nextNbFid;\n\t\telse if( nbFid > nextNbFid )\n\t\tnbFid = nextNbFid;\n\t}\n\n\t/* add the base and convert to 100MHz divide by 2 if DID=1 */\n\tif(nbDid)\n\t\tnbFid = (u8) (nbFid + 4);\n\telse\n\t\tnbFid = (u8) ((nbFid + 4) << 1);\n\treturn nbFid;\n}", "path": "src\\northbridge\\amd\\amdht\\AsPsNb.c", "repo_name": "wt/coreboot", "stars": 20, "license": "gpl-2.0", "language": "c", "size": 24504}
{"docstring": "/* IGNORE_MTAB */\n", "func_signal": "static int begins_with(const char *s, const char *beg)", "code": "{\n    if (strncmp(s, beg, strlen(beg)) == 0)\n        return 1;\n    else\n        return 0;\n}", "path": "libfuse-lite\\fusermount.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_handler_fprintf - Basic logging handler\n * @function:\tFunction in which the log line occurred\n * @file:\tFile in which the log line occurred\n * @line:\tLine number on which the log line occurred\n * @level:\tLevel at which the line is logged\n * @data:\tUser specified data, possibly specific to a handler\n * @format:\tprintf-style formatting string\n * @args:\tArguments to be formatted\n *\n * A simple logging handler.  This is where the log line is finally displayed.\n * It is more likely that you will want to set the handler to either\n * ntfs_log_handler_outerr or ntfs_log_handler_stderr.\n *\n * Note: For this handler, @data is a pointer to a FILE output stream.\n *       If @data is NULL, nothing will be displayed.\n *\n * Returns:  -1  Error occurred\n *            0  Message wasn't logged\n *          num  Number of output characters\n */\n", "func_signal": "int ntfs_log_handler_fprintf(const char *function, const char *file,\n\tint line, u32 level, void *data, const char *format, va_list args)", "code": "{\n#ifdef DEBUG\n\tint i;\n#endif\n\tint ret = 0;\n\tint olderr = errno;\n\tFILE *stream;\n\n\tif (!data)\t\t/* Interpret data as a FILE stream. */\n\t\treturn 0;\t/* If it's NULL, we can't do anything. */\n\tstream = (FILE*)data;\n\n#ifdef DEBUG\n\tif (level == NTFS_LOG_LEVEL_LEAVE) {\n\t\tif (tab)\n\t\t\ttab--;\n\t\treturn 0;\n\t}\n\t\n\tfor (i = 0; i < tab; i++)\n\t\tret += fprintf(stream, \" \");\n#endif\t\n\tif ((ntfs_log.flags & NTFS_LOG_FLAG_ONLYNAME) &&\n\t    (strchr(file, PATH_SEP)))\t\t/* Abbreviate the filename */\n\t\tfile = strrchr(file, PATH_SEP) + 1;\n\n\tif (ntfs_log.flags & NTFS_LOG_FLAG_PREFIX)\t/* Prefix the output */\n\t\tret += fprintf(stream, \"%s\", ntfs_log_get_prefix(level));\n\n\tif (ntfs_log.flags & NTFS_LOG_FLAG_FILENAME)\t/* Source filename */\n\t\tret += fprintf(stream, \"%s \", file);\n\n\tif (ntfs_log.flags & NTFS_LOG_FLAG_LINE)\t/* Source line number */\n\t\tret += fprintf(stream, \"(%d) \", line);\n\n\tif ((ntfs_log.flags & NTFS_LOG_FLAG_FUNCTION) || /* Source function */\n\t    (level & NTFS_LOG_LEVEL_TRACE) || (level & NTFS_LOG_LEVEL_ENTER))\n\t\tret += fprintf(stream, \"%s(): \", function);\n\n\tret += vfprintf(stream, format, args);\n\n\tif (level & NTFS_LOG_LEVEL_PERROR)\n\t\tret += fprintf(stream, \": %s\\n\", strerror(olderr));\n\n#ifdef DEBUG\n\tif (level == NTFS_LOG_LEVEL_ENTER)\n\t\ttab++;\n#endif\t\n\tfflush(stream);\n\terrno = olderr;\n\treturn ret;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_device_unix_io_open - Open a device and lock it exclusively\n * @dev:\n * @flags:\n *\n * Description...\n *\n * Returns:\n */\n", "func_signal": "static int ntfs_device_unix_io_open(struct ntfs_device *dev, int flags)", "code": "{\n\tstruct flock flk;\n\tstruct stat sbuf;\n\tint err;\n\n\tif (NDevOpen(dev)) {\n\t\terrno = EBUSY;\n\t\treturn -1;\n\t}\n\tif (stat(dev->d_name, &sbuf)) {\n\t\tntfs_log_perror(\"Failed to access '%s'\", dev->d_name);\n\t\treturn -1;\n\t}\n\tif (S_ISBLK(sbuf.st_mode))\n\t\tNDevSetBlock(dev);\n\t\n\tdev->d_private = ntfs_malloc(sizeof(int));\n\tif (!dev->d_private)\n\t\treturn -1;\n\t/*\n\t * Open file for exclusive access if mounting r/w.\n\t * Fuseblk takes care about block devices.\n\t */ \n\tif (!NDevBlock(dev) && (flags & O_RDWR) == O_RDWR)\n\t\tflags |= O_EXCL;\n\t*(int*)dev->d_private = open(dev->d_name, flags);\n\tif (*(int*)dev->d_private == -1) {\n\t\terr = errno;\n\t\tgoto err_out;\n\t}\n\t\n\tif ((flags & O_RDWR) != O_RDWR)\n\t\tNDevSetReadOnly(dev);\n\t\n\tmemset(&flk, 0, sizeof(flk));\n\tif (NDevReadOnly(dev))\n\t\tflk.l_type = F_RDLCK;\n\telse\n\t\tflk.l_type = F_WRLCK;\n\tflk.l_whence = SEEK_SET;\n\tflk.l_start = flk.l_len = 0LL;\n\tif (fcntl(DEV_FD(dev), F_SETLK, &flk)) {\n\t\terr = errno;\n\t\tntfs_log_perror(\"Failed to %s lock '%s'\", NDevReadOnly(dev) ? \n\t\t\t\t\"read\" : \"write\", dev->d_name);\n\t\tif (close(DEV_FD(dev)))\n\t\t\tntfs_log_perror(\"Failed to close '%s'\", dev->d_name);\n\t\tgoto err_out;\n\t}\n\t\n\tNDevSetOpen(dev);\n\treturn 0;\nerr_out:\n\tfree(dev->d_private);\n\tdev->d_private = NULL;\n\terrno = err;\n\treturn -1;\n}", "path": "libntfs-3g\\unix_io.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/*\n *\t\t\tEarly logging before the logs are redirected\n *\n *\t(not quite satisfactory : this appears before the ntfs-g banner,\n *\tand with a different pid)\n */\n", "func_signal": "void ntfs_log_early_error(const char *format, ...)", "code": "{\n\tva_list args;\n\n\tva_start(args, format);\n#ifdef HAVE_SYSLOG_H\n\topenlog(\"ntfs-3g\", LOG_PID, LOG_USER);\n\tntfs_log_handler_syslog(NULL, NULL, 0,\n\t\tNTFS_LOG_LEVEL_ERROR, NULL,\n\t\tformat, args);\n#else\n\tvfprintf(stderr,format,args);\n#endif\n\tva_end(args);\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_clear_flags - Disable some logging styles\n * @flags:\t32-bit field of logging flags to clear\n *\n * Disable one or more logging flags.\n * The log flags are named: NTFS_LOG_LEVEL_*.\n *\n * Returns:  Logging flags that were enabled before the call\n */\n", "func_signal": "u32 ntfs_log_clear_flags(u32 flags)", "code": "{\n\tu32 old;\n\told = ntfs_log.flags;\n\tntfs_log.flags &= (~flags);\n\treturn old;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_device_unix_io_write - Write to the device, at the current location\n * @dev:\n * @buf:\n * @count:\n *\n * Description...\n *\n * Returns:\n */\n", "func_signal": "static s64 ntfs_device_unix_io_write(struct ntfs_device *dev, const void *buf,\n\t\ts64 count)", "code": "{\n\tif (NDevReadOnly(dev)) {\n\t\terrno = EROFS;\n\t\treturn -1;\n\t}\n\tNDevSetDirty(dev);\n\treturn write(DEV_FD(dev), buf, count);\n}", "path": "libntfs-3g\\unix_io.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_device_unix_io_close - Close the device, releasing the lock\n * @dev:\n *\n * Description...\n *\n * Returns:\n */\n", "func_signal": "static int ntfs_device_unix_io_close(struct ntfs_device *dev)", "code": "{\n\tstruct flock flk;\n\n\tif (!NDevOpen(dev)) {\n\t\terrno = EBADF;\n\t\tntfs_log_perror(\"Device %s is not open\", dev->d_name);\n\t\treturn -1;\n\t}\n\tif (NDevDirty(dev))\n\t\tif (ntfs_fsync(DEV_FD(dev))) {\n\t\t\tntfs_log_perror(\"Failed to fsync device %s\", dev->d_name);\n\t\t\treturn -1;\n\t\t}\n\n\tmemset(&flk, 0, sizeof(flk));\n\tflk.l_type = F_UNLCK;\n\tflk.l_whence = SEEK_SET;\n\tflk.l_start = flk.l_len = 0LL;\n\tif (fcntl(DEV_FD(dev), F_SETLK, &flk))\n\t\tntfs_log_perror(\"Could not unlock %s\", dev->d_name);\n\tif (close(DEV_FD(dev))) {\n\t\tntfs_log_perror(\"Failed to close device %s\", dev->d_name);\n\t\treturn -1;\n\t}\n\tNDevClearOpen(dev);\n\tfree(dev->d_private);\n\tdev->d_private = NULL;\n\treturn 0;\n}", "path": "libntfs-3g\\unix_io.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_handler_stdout - All logs go to stdout\n * @function:\tFunction in which the log line occurred\n * @file:\tFile in which the log line occurred\n * @line:\tLine number on which the log line occurred\n * @level:\tLevel at which the line is logged\n * @data:\tUser specified data, possibly specific to a handler\n * @format:\tprintf-style formatting string\n * @args:\tArguments to be formatted\n *\n * Display a log message to stdout.\n *\n * Note: For this handler, @data is a pointer to a FILE output stream.\n *       If @data is NULL, then stdout will be used.\n *\n * Note: This function calls ntfs_log_handler_fprintf to do the main work.\n *\n * Returns:  -1  Error occurred\n *            0  Message wasn't logged\n *          num  Number of output characters\n */\n", "func_signal": "int ntfs_log_handler_stdout(const char *function, const char *file,\n\tint line, u32 level, void *data, const char *format, va_list args)", "code": "{\n\tif (!data)\n\t\tdata = stdout;\n\n\treturn ntfs_log_handler_fprintf(function, file, line, level, data, format, args);\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_redirect - Pass on the request to the real handler\n * @function:\tFunction in which the log line occurred\n * @file:\tFile in which the log line occurred\n * @line:\tLine number on which the log line occurred\n * @level:\tLevel at which the line is logged\n * @data:\tUser specified data, possibly specific to a handler\n * @format:\tprintf-style formatting string\n * @...:\tArguments to be formatted\n *\n * This is just a redirector function.  The arguments are simply passed to the\n * main logging handler (as defined in the global logging struct @ntfs_log).\n *\n * Returns:  -1  Error occurred\n *            0  Message wasn't logged\n *          num  Number of output characters\n */\n", "func_signal": "int ntfs_log_redirect(const char *function, const char *file,\n\tint line, u32 level, void *data, const char *format, ...)", "code": "{\n\tint olderr = errno;\n\tint ret;\n\tva_list args;\n\n\tif (!(ntfs_log.levels & level))\t\t/* Don't log this message */\n\t\treturn 0;\n\n\tva_start(args, format);\n\terrno = olderr;\n\tret = ntfs_log.handler(function, file, line, level, data, format, args);\n\tva_end(args);\n\n\terrno = olderr;\n\treturn ret;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_clear_levels - Disable some logging levels\n * @levels:\t32-bit field of log levels to clear\n *\n * Disable one or more logging levels.\n * The logging levels are named: NTFS_LOG_LEVEL_*.\n *\n * Returns:  Log levels that were enabled before the call\n */\n", "func_signal": "u32 ntfs_log_clear_levels(u32 levels)", "code": "{\n\tu32 old;\n\told = ntfs_log.levels;\n\tntfs_log.levels &= (~levels);\n\treturn old;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_set_handler - Provide an alternate logging handler\n * @handler:\tfunction to perform the logging\n *\n * This alternate handler will be called for all future logging requests.\n * If no @handler is specified, logging will revert to the default handler.\n */\n", "func_signal": "void ntfs_log_set_handler(ntfs_log_handler *handler)", "code": "{\n\tif (handler) {\n\t\tntfs_log.handler = handler;\n#ifdef HAVE_SYSLOG_H\n\t\tif (handler == ntfs_log_handler_syslog)\n\t\t\topenlog(\"ntfs-3g\", LOG_PID, LOG_USER);\n#endif\n\t} else\n\t\tntfs_log.handler = ntfs_log_handler_null;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_device_unix_io_pwrite - Perform a positioned write to the device\n * @dev:\n * @buf:\n * @count:\n * @offset:\n *\n * Description...\n *\n * Returns:\n */\n", "func_signal": "static s64 ntfs_device_unix_io_pwrite(struct ntfs_device *dev, const void *buf,\n\t\ts64 count, s64 offset)", "code": "{\n\tif (NDevReadOnly(dev)) {\n\t\terrno = EROFS;\n\t\treturn -1;\n\t}\n\tNDevSetDirty(dev);\n\treturn pwrite(DEV_FD(dev), buf, count, offset);\n}", "path": "libntfs-3g\\unix_io.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_handler_stderr - All logs go to stderr\n * @function:\tFunction in which the log line occurred\n * @file:\tFile in which the log line occurred\n * @line:\tLine number on which the log line occurred\n * @level:\tLevel at which the line is logged\n * @data:\tUser specified data, possibly specific to a handler\n * @format:\tprintf-style formatting string\n * @args:\tArguments to be formatted\n *\n * Display a log message to stderr.\n *\n * Note: For this handler, @data is a pointer to a FILE output stream.\n *       If @data is NULL, then stdout will be used.\n *\n * Note: This function calls ntfs_log_handler_fprintf to do the main work.\n *\n * Returns:  -1  Error occurred\n *            0  Message wasn't logged\n *          num  Number of output characters\n */\n", "func_signal": "int ntfs_log_handler_stderr(const char *function, const char *file,\n\tint line, u32 level, void *data, const char *format, va_list args)", "code": "{\n\tif (!data)\n\t\tdata = stderr;\n\n\treturn ntfs_log_handler_fprintf(function, file, line, level, data, format, args);\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_set_flags - Enable extra logging style flags\n * @flags:\t32-bit field of logging flags to set\n *\n * Enable one or more logging flags.\n * The log flags are named: NTFS_LOG_LEVEL_*.\n *\n * Returns:  Logging flags that were enabled before the call\n */\n", "func_signal": "u32 ntfs_log_set_flags(u32 flags)", "code": "{\n\tu32 old;\n\told = ntfs_log.flags;\n\tntfs_log.flags |= flags;\n\treturn old;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_get_prefix - Default prefixes for logging levels\n * @level:\tLog level to be prefixed\n *\n * Prefixing the logging output can make it easier to parse.\n *\n * Returns:  \"string\"  Prefix to be used\n */\n", "func_signal": "static const char * ntfs_log_get_prefix(u32 level)", "code": "{\n\tconst char *prefix;\n\n\tswitch (level) {\n\t\tcase NTFS_LOG_LEVEL_DEBUG:\n\t\t\tprefix = \"DEBUG: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_TRACE:\n\t\t\tprefix = \"TRACE: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_QUIET:\n\t\t\tprefix = \"QUIET: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_INFO:\n\t\t\tprefix = \"INFO: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_VERBOSE:\n\t\t\tprefix = \"VERBOSE: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_PROGRESS:\n\t\t\tprefix = \"PROGRESS: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_WARNING:\n\t\t\tprefix = \"WARNING: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_ERROR:\n\t\t\tprefix = \"ERROR: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_PERROR:\n\t\t\tprefix = \"ERROR: \";\n\t\t\tbreak;\n\t\tcase NTFS_LOG_LEVEL_CRITICAL:\n\t\t\tprefix = \"CRITICAL: \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_handler_outerr - Logs go to stdout/stderr depending on level\n * @function:\tFunction in which the log line occurred\n * @file:\tFile in which the log line occurred\n * @line:\tLine number on which the log line occurred\n * @level:\tLevel at which the line is logged\n * @data:\tUser specified data, possibly specific to a handler\n * @format:\tprintf-style formatting string\n * @args:\tArguments to be formatted\n *\n * Display a log message.  The output stream will be determined by the log\n * level.\n *\n * Note: For this handler, @data is a pointer to a FILE output stream.\n *       If @data is NULL, the function ntfs_log_get_stream will be called\n *\n * Note: This function calls ntfs_log_handler_fprintf to do the main work.\n *\n * Returns:  -1  Error occurred\n *            0  Message wasn't logged\n *          num  Number of output characters\n */\n", "func_signal": "int ntfs_log_handler_outerr(const char *function, const char *file,\n\tint line, u32 level, void *data, const char *format, va_list args)", "code": "{\n\tif (!data)\n\t\tdata = ntfs_log_get_stream(level);\n\n\treturn ntfs_log_handler_fprintf(function, file, line, level, data, format, args);\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_parse_option - Act upon command line options\n * @option:\tOption flag\n *\n * Delegate some of the work of parsing the command line.  All the options begin\n * with \"--log-\".  Options cause log levels to be enabled in @ntfs_log (the\n * global logging structure).\n *\n * Note: The \"colour\" option changes the logging handler.\n *\n * Returns:  TRUE  Option understood\n *          FALSE  Invalid log option\n */\n", "func_signal": "BOOL ntfs_log_parse_option(const char *option)", "code": "{\n\tif (strcmp(option, \"--log-debug\") == 0) {\n\t\tntfs_log_set_levels(NTFS_LOG_LEVEL_DEBUG);\n\t\treturn TRUE;\n\t} else if (strcmp(option, \"--log-verbose\") == 0) {\n\t\tntfs_log_set_levels(NTFS_LOG_LEVEL_VERBOSE);\n\t\treturn TRUE;\n\t} else if (strcmp(option, \"--log-quiet\") == 0) {\n\t\tntfs_log_clear_levels(NTFS_LOG_LEVEL_QUIET);\n\t\treturn TRUE;\n\t} else if (strcmp(option, \"--log-trace\") == 0) {\n\t\tntfs_log_set_levels(NTFS_LOG_LEVEL_TRACE);\n\t\treturn TRUE;\n\t}\n\n\tntfs_log_debug(\"Unknown logging option '%s'\\n\", option);\n\treturn FALSE;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_get_stream - Default output streams for logging levels\n * @level:\tLog level\n *\n * By default, urgent messages are sent to \"stderr\".\n * Other messages are sent to \"stdout\".\n *\n * Returns:  \"string\"  Prefix to be used\n */\n", "func_signal": "static FILE * ntfs_log_get_stream(u32 level)", "code": "{\n\tFILE *stream;\n\n\tswitch (level) {\n\t\tcase NTFS_LOG_LEVEL_INFO:\n\t\tcase NTFS_LOG_LEVEL_QUIET:\n\t\tcase NTFS_LOG_LEVEL_PROGRESS:\n\t\tcase NTFS_LOG_LEVEL_VERBOSE:\n\t\t\tstream = stdout;\n\t\t\tbreak;\n\n\t\tcase NTFS_LOG_LEVEL_DEBUG:\n\t\tcase NTFS_LOG_LEVEL_TRACE:\n\t\tcase NTFS_LOG_LEVEL_ENTER:\n\t\tcase NTFS_LOG_LEVEL_LEAVE:\n\t\tcase NTFS_LOG_LEVEL_WARNING:\n\t\tcase NTFS_LOG_LEVEL_ERROR:\n\t\tcase NTFS_LOG_LEVEL_CRITICAL:\n\t\tcase NTFS_LOG_LEVEL_PERROR:\n\t\tdefault:\n\t\t\tstream = stderr;\n\t\t\tbreak;\n\t}\n\n\treturn stream;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_device_unix_io_sync - Flush any buffered changes to the device\n * @dev:\n *\n * Description...\n *\n * Returns:\n */\n", "func_signal": "static int ntfs_device_unix_io_sync(struct ntfs_device *dev)", "code": "{\n\tint res = 0;\n\t\n\tif (!NDevReadOnly(dev)) {\n\t\tres = ntfs_fsync(DEV_FD(dev));\n\t\tif (res)\n\t\t\tntfs_log_perror(\"Failed to sync device %s\", dev->d_name);\n\t\telse\n\t\t\tNDevClearDirty(dev);\n\t}\n\treturn res;\n}", "path": "libntfs-3g\\unix_io.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/**\n * ntfs_log_set_levels - Enable extra logging levels\n * @levels:\t32-bit field of log levels to set\n *\n * Enable one or more logging levels.\n * The logging levels are named: NTFS_LOG_LEVEL_*.\n *\n * Returns:  Log levels that were enabled before the call\n */\n", "func_signal": "u32 ntfs_log_set_levels(u32 levels)", "code": "{\n\tu32 old;\n\told = ntfs_log.levels;\n\tntfs_log.levels |= levels;\n\treturn old;\n}", "path": "libntfs-3g\\logging.c", "repo_name": "sakuramilk/ntfs-3g_ntfsprogs", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 1256}
{"docstring": "/*\n *\tFuntion to replace all ocurrences of a \"old\" string for a \"new\" string\n *\tinside a \"str\" string\n */\n", "func_signal": "char *str_replace(const char *str, const char *old, const char *new)", "code": "{\n\tchar *ret, *r;\n\tconst char *p, *q;\n\tsize_t len_str = strlen(str);\n\tsize_t len_old = strlen(old);\n\tsize_t len_new = strlen(new);\n\tsize_t count;\n\n\tfor(count = 0, p = str; (p = strstr(p, old)); p += len_old)\n\t\tcount++;\n\n\tret = malloc(count * (len_new - len_old) + len_str + 1);\n\tif(!ret)\n\t\treturn NULL;\n\n\tfor(r = ret, p = str; (q = strstr(p, old)); p = q + len_old) {\n\t\tcount = q - p;\n\t\tmemcpy(r, p, count);\n\t\tr += count;\n\t\tstrcpy(r, new);\n\t\tr += len_new;\n\t}\n\tstrcpy(r, p);\n\treturn ret;\n}", "path": "wmediumd\\config.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tSet a tx_rate struct to not valid values\n */\n", "func_signal": "void set_all_rates_invalid(struct hwsim_tx_rate* tx_rate)", "code": "{\n\tint i;\n\t/* set up all unused rates to be -1 */\n\tfor (i=0; i < IEEE80211_MAX_RATES_PER_TX; i++) {\n        \ttx_rate[i].idx = -1;\n\t\ttx_rate[i].count = 0;\n\t}\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tSend a tx_info frame to the kernel space.\n */\n", "func_signal": "int send_tx_info_frame_nl(struct mac_address *src,\n\t\t\t  unsigned int flags, int signal,\n\t\t\t  struct hwsim_tx_rate *tx_attempts,\n\t\t\t  unsigned long cookie)", "code": "{\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tprintf(\"Error allocating new message MSG!\\n\");\n\t\tgoto out;\n\t}\n\n\tgenlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, genl_family_get_id(family),\n\t\t    0, NLM_F_REQUEST, HWSIM_CMD_TX_INFO_FRAME, VERSION_NR);\n\n\tint rc;\n\trc = nla_put(msg, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t     sizeof(struct mac_address), src);\n\trc = nla_put_u32(msg, HWSIM_ATTR_FLAGS, flags);\n\trc = nla_put_u32(msg, HWSIM_ATTR_SIGNAL, signal);\n\trc = nla_put(msg, HWSIM_ATTR_TX_INFO,\n\t\t     IEEE80211_MAX_RATES_PER_TX *\n\t\t     sizeof(struct hwsim_tx_rate), tx_attempts);\n\n\trc = nla_put_u64(msg, HWSIM_ATTR_COOKIE, cookie);\n\n\tif(rc!=0) {\n\t\tprintf(\"Error filling payload\\n\");\n\t\tgoto out;\n\t}\n\n\tnl_send_auto_complete(sock,msg);\n\tnlmsg_free(msg);\n\treturn 0;\nout:\n\tnlmsg_free(msg);\n\treturn -1;\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tWrites a char* buffer to a destination file\n */\n", "func_signal": "int write_buffer_to_file(char *file, char *buffer)", "code": "{\n\tFILE *p = NULL;\n\n\tp = fopen(file, \"w\");\n\tif (p== NULL) {\n\t\treturn 1;\n\t}\n\n\tfwrite(buffer, strlen(buffer), 1, p);\n\tfclose(p);\n\n\treturn 0;\n}", "path": "wmediumd\\config.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tDetermine whether we should be jamming this transmitting mac.\n */\n", "func_signal": "int jam_mac(struct jammer_cfg *jcfg, struct mac_address *src)", "code": "{\n\tint jam = 0, i;\n\n\tfor (i = 0; i < jcfg->nmacs; i++) {\n\t\tif (!memcmp(&jcfg->macs[i], src, sizeof(struct mac_address))) {\n\t\t\tjam = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn jam;\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tPrint the CLI help\n */\n", "func_signal": "void print_help(int exval)", "code": "{\n\tprintf(\"wmediumd v%s - a wireless medium simulator\\n\", VERSION_STR);\n\tprintf(\"wmediumd [-h] [-V] [-c FILE] [-o FILE]\\n\\n\");\n\n\tprintf(\"  -h              print this help and exit\\n\");\n\tprintf(\"  -V              print version and exit\\n\\n\");\n\n\tprintf(\"  -c FILE         set intput config file\\n\");\n\tprintf(\"  -o FILE         set output config file\\n\\n\");\n\n\texit(exval);\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tInit netlink\n */\n", "func_signal": "void init_netlink()", "code": "{\n\n\tcb = nl_cb_alloc(NL_CB_CUSTOM);\n\tif (!cb) {\n\t\tprintf(\"Error allocating netlink callbacks\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsock = nl_socket_alloc_cb(cb);\n\tif (!sock) {\n\t\tprintf(\"Error allocationg netlink socket\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tgenl_connect(sock);\n\tgenl_ctrl_alloc_cache(sock, &cache);\n\n\tfamily = genl_ctrl_search_by_name(cache, \"MAC80211_HWSIM\");\n\n\tif (!family) {\n\t\tprintf(\"Family MAC80211_HWSIM not registered\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tnl_cb_set(cb, NL_CB_MSG_IN, NL_CB_CUSTOM, process_messages_cb, NULL);\n\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tCallback function to process messages received from kernel\n */\n", "func_signal": "static int process_messages_cb(struct nl_msg *msg, void *arg)", "code": "{\n\n\tstruct nlattr *attrs[HWSIM_ATTR_MAX+1];\n\t/* netlink header */\n\tstruct nlmsghdr *nlh = nlmsg_hdr(msg);\n\t/* generic netlink header*/\n\tstruct genlmsghdr *gnlh = nlmsg_data(nlh);\n\n\tif(gnlh->cmd == HWSIM_CMD_FRAME) {\n\t\t/* we get the attributes*/\n\t\tgenlmsg_parse(nlh, 0, attrs, HWSIM_ATTR_MAX, NULL);\n\t\tif (attrs[HWSIM_ATTR_ADDR_TRANSMITTER]) {\n\t\t\tstruct mac_address *src = (struct mac_address*)\n\t\t\t\tnla_data(attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\n\n\t\t\tunsigned int data_len =\n\t\t\t\tnla_len(attrs[HWSIM_ATTR_FRAME]);\n\t\t\tchar* data = (char*)nla_data(attrs[HWSIM_ATTR_FRAME]);\n\t\t\tunsigned int flags =\n\t\t\t\tnla_get_u32(attrs[HWSIM_ATTR_FLAGS]);\n\t\t//\tprintf(\"flags: %d\\n\", flags);\n\t\t\tstruct hwsim_tx_rate *tx_rates =\n\t\t\t\t(struct hwsim_tx_rate*)\n\t\t\t\tnla_data(attrs[HWSIM_ATTR_TX_INFO]);\n\t\t\tunsigned long cookie = nla_get_u64(attrs[HWSIM_ATTR_COOKIE]);\n\t\t\treceived++;\n\n\t\t\tprintf(\"frame [%d] length:%d\\n\",received,data_len);\n\t\t\tsend_frames_to_radios_with_retries(src, data,\n\t\t\t\t\tdata_len, flags, tx_rates, cookie);\n\t\t\t//printf(\"\\rreceived: %d tried: %d sent: %d acked: %d\",\n\t\t\t//\t\treceived, dropped+sent, sent, acked);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tFills the probability matrix with a given value\n */\n", "func_signal": "void fill_prob_matrix(double *aMatrix,double aValue)", "code": "{\n\tint i =0 , j=0 , k=0;\n\n\n\tfor (k=0; k < IEEE80211_AVAILABLE_RATES; k++) {\n\t\tfor (i = 0 ; i < array_size  ; i++ ) {\n\t\t\tfor (j = 0; j < array_size; j++) {\n\t\t\t\tif (i==j)\n\t\t\t\t\tMATRIX_PROB(aMatrix,array_size,i,j,k)=-1;\n\t\t\t\telse {\n\t\t\t\t\tdouble prob_per_link = aValue + (aValue / 15) * k;\n\t\t\t\t\tprob_per_link = prob_per_link > 1.0 ? 1.0 : prob_per_link;\n\t\t\t\t\tMATRIX_PROB(aMatrix,array_size,i,j,k)=prob_per_link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tPrints the values of the Mac Adress Array\n */\n", "func_signal": "void print_mac_address_array()", "code": "{\n\n\tint i=0;\n\tvoid * ptr = indexer;\n\n\twhile (i < array_size) {\n\t\tstruct mac_address *a = malloc(sizeof(struct mac_address));\n\t\tmemcpy(a,ptr,sizeof(struct mac_address));\n\t\tprintf(\"A[%d]:%02X:%02X:%02X:%02X:%02X:%02X\\n\",\n\t\t       i,a->addr[0], a->addr[1], a->addr[2],\n\t\t       a->addr[3], a->addr[4], a->addr[5]);\n\t\ti++;\n\t\tptr = ptr + sizeof(struct mac_address);\n\t}\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tPrints the values of the probability matrix\n */\n", "func_signal": "void print_prob_matrix (double *aMatrix)", "code": "{\n\n\tint i,j,k;\n\n\tfor (k=0; k < IEEE80211_AVAILABLE_RATES; k++) {\n\t\tfor (i=0; i < array_size ; i++) {\n\t\t\tfor (j=0; j < array_size; j++) {\n\t\t\t\tprintf(\"[%10f]\",MATRIX_PROB(aMatrix,array_size,i,j,k));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"Matrix rate = %d\\n\",k);\n\t}\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tGet a signal value by rate index\n */\n", "func_signal": "int get_signal_by_rate(int rate_idx)", "code": "{\n\tconst int rate2signal [] =\n\t\t{ -80,-77,-74,-71,-69,-66,-64,-62,-59,-56,-53,-50 };\n\tif (rate_idx >= 0 || rate_idx < IEEE80211_AVAILABLE_RATES)\n\t\treturn rate2signal[rate_idx];\n\treturn 0;\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tWrites a sample configuration with matrix filled with a value to a file\n */\n", "func_signal": "int write_config(char *file, int ifaces, float value)", "code": "{\n\tFILE *out;\n\tchar *ptr, *ptr2;\n\tsize_t size;\n\tconfig_t cfg;\n\tconfig_setting_t *root, *setting, *group, *array, *list;\n\tint i, j, rates = 12;\n\n\t/*Init tmp file stream*/\n\tout = open_memstream(&ptr, &size);\n\tif (out == NULL) {\n\t\tprintf(\"Error generating stream\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\t/*Init config*/\n\tconfig_init(&cfg);\n\n\t/*Create a sample config schema*/\n\troot = config_root_setting(&cfg);\n\t/* Add some settings to the ifaces group. */\n\tgroup = config_setting_add(root, \"ifaces\", CONFIG_TYPE_GROUP);\n\tsetting = config_setting_add(group, \"count\", CONFIG_TYPE_INT);\n\tconfig_setting_set_int(setting, ifaces);\n\tarray = config_setting_add(group, \"ids\", CONFIG_TYPE_ARRAY);\n\n\tfor(i = 0; i < ifaces; ++i) {\n\t\tsetting = config_setting_add(array, NULL, CONFIG_TYPE_STRING);\n\t\tchar buffer[25];\n\t\tsprintf (buffer, \"42:00:00:00:%02d:00\", i);\n\t\tconfig_setting_set_string(setting, buffer);\n\t}\n\n\t/* Add some settings to the prob group. */\n\tgroup = config_setting_add(root, \"prob\", CONFIG_TYPE_GROUP);\n\tsetting = config_setting_add(group, \"rates\", CONFIG_TYPE_INT);\n\tconfig_setting_set_int(setting, rates);\n\tlist = config_setting_add(group, \"matrix_list\", CONFIG_TYPE_LIST);\n\tfor (j = 0; j < rates ; j++) {\n\t\tarray = config_setting_add(list, NULL, CONFIG_TYPE_ARRAY);\n\t\tint diag_count = 0;\n\t\tfor(i = 0; i < ifaces*ifaces; ++i) {\n\t\t\tsetting = config_setting_add(array, NULL,\n\t\t\t\t\t\t     CONFIG_TYPE_FLOAT);\n\t\t\tif (diag_count == 0)\n\t\t\t\tconfig_setting_set_float(setting, -1.0);\n\t\t\telse\n\t\t\t\tconfig_setting_set_float(setting, value);\n\t\t\tdiag_count++;\n\t\t\tif (diag_count > ifaces)\n\t\t\t\tdiag_count = 0;\n\t\t}\n\t}\n\t/* Write in memory out file */\n\tconfig_write(&cfg, out);\n\tconfig_destroy(&cfg);\n\tfclose(out);\n\n\t/* Let's do some post processing */\n\tptr2 = str_replace(ptr, \"], \", \"],\\n\\t\");\n\tfree(ptr);\n\tptr = str_replace(ptr2, \"( \", \"(\\n\\t\");\n\tfree(ptr2);\n\t/* Let's add comments to the config file */\n\tptr2 = str_replace(ptr, \"ifaces :\", \"#\\n# wmediumd sample config file\\n#\\n\\nifaces :\");\n\tfree(ptr);\n\tptr = str_replace(ptr2, \"prob :\", \"\\n#\\n# probability matrices are defined in a rowcentric way \\n# probability matrices are ordered from slower to fastest, check wmediumd documentation for more info\\n#\\n\\nprob :\");\n\tprintf(\"%s\",ptr);\n\n\t/*write the string to a file*/\n\tif(write_buffer_to_file(file, ptr)) {\n\t\tprintf(\"Error while writing file.\\n\");\n\t\tfree(ptr);\n\t\texit(EXIT_FAILURE);\n\t}\n\tprintf(\"New configuration successfully written to: %s\\n\", file);\n\n\t/*free ptr*/\n\tfree(ptr);\n\texit(EXIT_SUCCESS);\n}", "path": "wmediumd\\config.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tLoads a config file into memory\n */\n", "func_signal": "int load_config(const char *file)", "code": "{\n\n\tconfig_t cfg, *cf;\n\tconst config_setting_t *ids, *prob_list, *mat_array, *jammer_s;\n\tint count_ids, rates_prob, i, j;\n\tlong int count_value, rates_value;\n\n\t/*initialize the config file*/\n\tcf = &cfg;\n\tconfig_init(cf);\n\n\t/*read the file*/\n\tif (!config_read_file(cf, file)) {\n\t\tprintf(\"Error loading file %s at line:%d, reason: %s\\n\",\n\t\tfile,\n\t\tconfig_error_line(cf),\n\t\tconfig_error_text(cf));\n\t\tconfig_destroy(cf);\n\t\texit(EXIT_FAILURE);\n    \t}\n\n\t/* get jammer settings */\n\tif (!(jammer_s = config_lookup(cf, \"jam\"))) {\n\t\tprintf(\"Error, malformed config!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tswitch (config_setting_type(jammer_s)) {\n\tcase CONFIG_TYPE_STRING:\n\t\tif (!strcmp(config_setting_get_string(jammer_s), \"all\")) {\n\t\t\tjam_cfg.jam_all = 1;\n\t\t}\n\t\tbreak;\n\tcase CONFIG_TYPE_ARRAY:\n\t\tjam_cfg.nmacs = config_setting_length(jammer_s);\n\t\tjam_cfg.macs = malloc(sizeof(struct mac_address) * jam_cfg.nmacs);\n\t\tif (!jam_cfg.macs) {\n\t\t\tprintf(\"couldn't allocate jamming mac table!\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tfor (i = 0; i < jam_cfg.nmacs; i++) {\n\t\t\tjam_cfg.macs[i] = string_to_mac_address(\n\t\t\t\t\t      config_setting_get_string_elem(jammer_s, i));\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*let's parse the values*/\n\tconfig_lookup_int(cf, \"ifaces.count\", &count_value);\n\tids = config_lookup(cf, \"ifaces.ids\");\n\tcount_ids = config_setting_length(ids);\n\n\t/*cross check*/\n\tif (count_value != count_ids) {\n\t\tprintf(\"Error on ifaces.count\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsize = count_ids;\n\tprintf(\"#_if = %d\\n\",count_ids);\n\t/*Initialize the probability*/\n\tprob_matrix = init_probability(count_ids);\n\n\t/*Fill the mac_addr*/\n\tfor (i = 0; i < count_ids; i++) {\n    \t\tconst char *str =  config_setting_get_string_elem(ids, i);\n    \t\tput_mac_address(string_to_mac_address(str),i);\n    \t}\n\t/*Print the mac_addr array*/\n\tprint_mac_address_array();\n\n\tconfig_lookup_int(cf, \"prob.rates\", &rates_value);\n\tprob_list = config_lookup(cf,\"prob.matrix_list\");\n\n\t/*Get rates*/\n\trates_prob = config_setting_length(prob_list);\n\n\t/*Some checks*/\n\tif(!config_setting_is_list(prob_list)\n\t   && rates_prob != rates_value) {\n\t\tprintf(\"Error on prob_list\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/*Iterate all matrix arrays*/\n\tfor (i=0; i < rates_prob ; i++) {\n\t\tint x = 0, y = 0;\n\t\tmat_array = config_setting_get_elem(prob_list,i);\n\t\t/*If any error break execution*/\n\t\tif (config_setting_length(mat_array) != count_ids*count_ids) {\n    \t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t/*Iterate all values on matrix array*/\n\t\tfor (j=0; j < config_setting_length(mat_array); ) {\n\t\t\tMATRIX_PROB(prob_matrix,count_ids,x,y,i) =\n\t\t\tconfig_setting_get_float_elem(mat_array,j);\n\t\t\t//printf(\"%f, \", config_setting_get_float_elem(mat_array,j));\n\t\t\tx++;\n\t\t\tj++;\n\t\t\t/* if we finalized this row */\n\t\t\tif (j%count_ids==0) {\n\t\t\t\ty++;\n\t\t\t\tx=0;\n\t\t\t\t//printf(\"*******j:%d,count_ids:%d \\n\",j,count_ids);\n\t\t\t}\n\t\t}\n\t}\n\n\tconfig_destroy(cf);\n\treturn (EXIT_SUCCESS);\n}", "path": "wmediumd\\config.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tSend a cloned frame to the kernel space.\n */\n", "func_signal": "int send_cloned_frame_msg(struct mac_address *dst,\n\t\t\t  char *data, int data_len, int rate_idx, int signal)", "code": "{\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tprintf(\"Error allocating new message MSG!\\n\");\n\t\tgoto out;\n\t}\n\n\tgenlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, genl_family_get_id(family),\n\t\t    0, NLM_F_REQUEST, HWSIM_CMD_FRAME, VERSION_NR);\n\n\tint rc;\n\trc = nla_put(msg, HWSIM_ATTR_ADDR_RECEIVER,\n\t\t     sizeof(struct mac_address), dst);\n\trc = nla_put(msg, HWSIM_ATTR_FRAME, data_len, data);\n\trc = nla_put_u32(msg, HWSIM_ATTR_RX_RATE, rate_idx);\n\trc = nla_put_u32(msg, HWSIM_ATTR_SIGNAL, signal);\n\n\tif(rc!=0) {\n\t\tprintf(\"Error filling payload\\n\");\n\t\tgoto out;\n\t}\n\n\tnl_send_auto_complete(sock,msg);\n\tnlmsg_free(msg);\n\treturn 0;\nout:\n\tnlmsg_free(msg);\n\treturn -1;\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tInit all the probability data\n *\tReturns a pointer to the probability matrix\n */\n", "func_signal": "double * init_probability(int size)", "code": "{\n\n\tarray_size = size;\n\tindexer = malloc(sizeof(struct mac_address)*array_size);\n\n\tif (indexer==NULL) {\n\t\tprintf(\"Problem allocating vector\");\n\t\texit(1);\n\t}\n\n \t/*Let's create the matrix */\n \tdouble * mat = malloc(sizeof(double)*(size*size)*IEEE80211_AVAILABLE_RATES);\n \t/* Zero-it */\n \tmemset(mat,0,sizeof(double)*(size*size)*IEEE80211_AVAILABLE_RATES);\n \treturn mat;\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n *\tReturns the loss probability for a given radio link, and rate\n * \tIf an error occurs returns -1;\n */\n", "func_signal": "double find_prob_by_addrs_and_rate (double *aMatrix, struct mac_address *src,\n\t\t\t\t    struct mac_address *dst, int rate_idx)", "code": "{\n\n\tint x = find_pos_by_mac_address(src);\n\tint y = find_pos_by_mac_address(dst);\n\n\tprintf(\"[%d][%d] rate:%d ploss=%f \",x,y,rate_idx,MATRIX_PROB(aMatrix,array_size,x,y,rate_idx));\n\n\tif (x == -1 || y ==-1)\n\t\treturn -1;\n\treturn MATRIX_PROB(aMatrix,array_size,x,y,rate_idx);\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tReturns the position of the address in the array.\n * \tIf the mac_address is not found returns -1\n */\n", "func_signal": "int find_pos_by_mac_address(struct mac_address *addr)", "code": "{\n\n\tint i=0;\n\n\tvoid * ptr = indexer;\n\twhile(memcmp(ptr,addr,sizeof(struct mac_address)) && i < array_size)\n\t{\n\t\ti++;\n\t\tptr = ptr + sizeof(struct mac_address);\n\t}\n\n\treturn ((i >= array_size) ?  -1 :  i);\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * returns the a mac_address ptr for a given index\n */\n", "func_signal": "struct mac_address * get_mac_address(int pos)", "code": "{\n\n\tvoid * ptr = indexer;\n\tptr = ptr + (sizeof(struct mac_address)*pos);\n\n\treturn ((pos >= array_size) ?  NULL : (struct mac_address*)ptr);\n}", "path": "wmediumd\\probability.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*\n * \tSend a register message to kernel\n */\n", "func_signal": "int send_register_msg()", "code": "{\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tprintf(\"Error allocating new message MSG!\\n\");\n\t\treturn -1;\n\t}\n\n\tgenlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, genl_family_get_id(family),\n\t\t    0, NLM_F_REQUEST, HWSIM_CMD_REGISTER, VERSION_NR);\n\tnl_send_auto_complete(sock,msg);\n\tnlmsg_free(msg);\n\n\treturn 0;\n\n}", "path": "wmediumd\\wmediumd.c", "repo_name": "jlopex/mac80211_hwsim", "stars": 16, "license": "None", "language": "c", "size": 8713}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_send_rs(void)", "code": "{\n  if((uip_nd6_choose_defrouter() == NULL) && (rs_count < UIP_ND6_MAX_RTR_SOLICITATIONS)){\n    //PRINTF(\"Sending RS %d\\n\", rs_count);\n    uip_nd6_io_rs_output();\n    rs_count++;\n    etimer_set(&uip_netif_timer_rs, tcpip_process, UIP_ND6_RTR_SOLICITATION_INTERVAL * CLOCK_SECOND);     \n  } else {\n    PRINTF(\"Router found ? (boolean): %d\\n\", (uip_nd6_choose_defrouter() != NULL));\n    etimer_stop(&uip_netif_timer_rs);\n    rs_count = 0;\n  }\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "struct uip_netif_addr *\nuip_netif_addr_lookup(uip_ipaddr_t *ipaddr, u8_t length, uip_netif_type type)", "code": "{\n  for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++) {\n    if((uip_netif_physical_if.addresses[i].state != NOT_USED) &&\n       (uip_netif_physical_if.addresses[i].type == type || type == 0) &&\n       (uip_ipaddr_prefixcmp(&(uip_netif_physical_if.addresses[i].ipaddr), ipaddr, length))) { \n      return &uip_netif_physical_if.addresses[i]; \n    }\n  }\n  return NULL; \n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_sched_dad(struct uip_netif_addr *ifaddr)", "code": "{    \n  if(ifaddr->state != TENTATIVE){\n    UIP_LOG(\"DAD called with non tentative address\");\n    return;\n  }\n  /*\n   * check dad is not running\n   */\n  if(dad_ifaddr != NULL){\n    UIP_LOG(\"DAD already running\");\n    return;\n  }\n  /*\n   * Set the interface address that is going through DAD\n   */\n  dad_ifaddr = ifaddr;\n\n  PRINTF(\"Scheduling DAD for ipaddr:\");\n  PRINT6ADDR(&dad_ifaddr->ipaddr);\n  PRINTF(\"\\n\");\n\n  etimer_set(&uip_netif_timer_dad, tcpip_process, random_rand()%(UIP_ND6_MAX_RTR_SOLICITATION_DELAY*CLOCK_SECOND)); \n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_process(u8_t flag)", "code": "{\n#if UIP_TCP\n  register struct uip_conn *uip_connr = uip_conn;\n#endif /* UIP_TCP */\n#if UIP_UDP\n  if(flag == UIP_UDP_SEND_CONN) {\n    goto udp_send;\n  }  \n#endif /* UIP_UDP */\n  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];\n\n  /* Check if we were invoked because of a poll request for a\n     particular connection. */\n  if(flag == UIP_POLL_REQUEST) {\n#if UIP_TCP\n    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&\n       !uip_outstanding(uip_connr)) {\n      uip_flags = UIP_POLL;\n      UIP_APPCALL();\n      goto appsend;\n    }\n    goto drop;\n#endif /* UIP_TCP */\n    /* Check if we were invoked because of the perodic timer fireing. */\n  } else if(flag == UIP_TIMER) {\n    /* Reset the length variables. */\n#if UIP_TCP\n    uip_len = 0;\n    uip_slen = 0;\n    \n    /* Increase the initial sequence number. */\n    if(++iss[3] == 0) {\n      if(++iss[2] == 0) {\n        if(++iss[1] == 0) {\n          ++iss[0];\n        }\n      }\n    }\n    \n    /*\n     * Check if the connection is in a state in which we simply wait\n     * for the connection to time out. If so, we increase the\n     * connection's timer and remove the connection if it times\n     * out.\n     */\n    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||\n       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {\n      ++(uip_connr->timer);\n      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {\n        uip_connr->tcpstateflags = UIP_CLOSED;\n      }\n    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {\n      /*\n       * If the connection has outstanding data, we increase the\n       * connection's timer and see if it has reached the RTO value\n       * in which case we retransmit.\n       */\n      if(uip_outstanding(uip_connr)) {\n        if(uip_connr->timer-- == 0) {\n          if(uip_connr->nrtx == UIP_MAXRTX ||\n             ((uip_connr->tcpstateflags == UIP_SYN_SENT ||\n               uip_connr->tcpstateflags == UIP_SYN_RCVD) &&\n              uip_connr->nrtx == UIP_MAXSYNRTX)) {\n            uip_connr->tcpstateflags = UIP_CLOSED;\n                  \n            /*\n             * We call UIP_APPCALL() with uip_flags set to\n             * UIP_TIMEDOUT to inform the application that the\n             * connection has timed out.\n             */\n            uip_flags = UIP_TIMEDOUT;\n            UIP_APPCALL();\n                  \n            /* We also send a reset packet to the remote host. */\n            UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;\n            goto tcp_send_nodata;\n          }\n               \n          /* Exponential backoff. */\n          uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?\n                                         4:\n                                         uip_connr->nrtx);\n          ++(uip_connr->nrtx);\n               \n          /*\n           * Ok, so we need to retransmit. We do this differently\n           * depending on which state we are in. In ESTABLISHED, we\n           * call upon the application so that it may prepare the\n           * data for the retransmit. In SYN_RCVD, we resend the\n           * SYNACK that we sent earlier and in LAST_ACK we have to\n           * retransmit our FINACK.\n           */\n          UIP_STAT(++uip_stat.tcp.rexmit);\n          switch(uip_connr->tcpstateflags & UIP_TS_MASK) {\n            case UIP_SYN_RCVD:\n              /* In the SYN_RCVD state, we should retransmit our SYNACK. */\n              goto tcp_send_synack;\n                     \n#if UIP_ACTIVE_OPEN\n            case UIP_SYN_SENT:\n              /* In the SYN_SENT state, we retransmit out SYN. */\n              UIP_TCP_BUF->flags = 0;\n              goto tcp_send_syn;\n#endif /* UIP_ACTIVE_OPEN */\n                     \n            case UIP_ESTABLISHED:\n              /*\n               * In the ESTABLISHED state, we call upon the application\n               * to do the actual retransmit after which we jump into\n               * the code for sending out the packet (the apprexmit\n               * label).\n               */\n              uip_flags = UIP_REXMIT;\n              UIP_APPCALL();\n              goto apprexmit;\n                     \n            case UIP_FIN_WAIT_1:\n            case UIP_CLOSING:\n            case UIP_LAST_ACK:\n              /* In all these states we should retransmit a FINACK. */\n              goto tcp_send_finack;\n          }\n        }\n      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {\n        /*\n         * If there was no need for a retransmission, we poll the\n         * application for new data.\n         */\n        uip_flags = UIP_POLL;\n        UIP_APPCALL();\n        goto appsend;\n      }\n    }\n    goto drop;\n#endif /* UIP_TCP */\n  }\n#if UIP_UDP\n  if(flag == UIP_UDP_TIMER) {\n    if(uip_udp_conn->lport != 0) {\n      uip_conn = NULL;\n      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];\n      uip_len = uip_slen = 0;\n      uip_flags = UIP_POLL;\n      UIP_UDP_APPCALL();\n      goto udp_send;\n    } else {\n      goto drop;\n    }\n  }\n#endif /* UIP_UDP */\n   \n  /* This is where the input processing starts. */\n  UIP_STAT(++uip_stat.ip.recv);\n   \n  /* Start of IP input header processing code. */\n\n  /* Check validity of the IP header. */\n  if((UIP_IP_BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */\n    UIP_STAT(++uip_stat.ip.drop);\n    UIP_STAT(++uip_stat.ip.vhlerr);\n    UIP_LOG(\"ipv6: invalid version.\");\n    goto drop;\n  }\n   \n  /*\n   * Check the size of the packet. If the size reported to us in\n   * uip_len is smaller the size reported in the IP header, we assume\n   * that the packet has been corrupted in transit. If the size of\n   * uip_len is larger than the size reported in the IP packet header,\n   * the packet has been padded and we set uip_len to the correct\n   * value..\n   */\n   \n  if((UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] <= uip_len) {\n    uip_len = (UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] + UIP_IPH_LEN;\n    /*\n     * The length reported in the IPv6 header is the\n     * length of the payload that follows the\n     * header. However, uIP uses the uip_len variable\n     * for holding the size of the entire packet,\n     * including the IP header. For IPv4 this is not a\n     * problem as the length field in the IPv4 header\n     * contains the length of the entire packet. But\n     * for IPv6 we need to add the size of the IPv6\n     * header (40 bytes).\n     */\n  } else {\n    UIP_LOG(\"ip: packet shorter than reported in IP header.\");\n    goto drop;\n  }\n   \n\n  if(uip_is_addr_mcast(&UIP_IP_BUF->srcipaddr)){\n    UIP_STAT(++uip_stat.ip.drop);\n    goto drop;\n  }\n      \n  if(!uip_netif_is_addr_my_unicast(&UIP_IP_BUF->destipaddr) &&\n     !uip_netif_is_addr_my_solicited(&UIP_IP_BUF->destipaddr) &&\n     !uip_is_addr_linklocal_allnodes_mcast(&UIP_IP_BUF->destipaddr)){\n    UIP_STAT(++uip_stat.ip.drop);\n    goto drop;\n  }\n  \n \n  /*\n   * Next header field processing. In IPv6, we can have extension headers,\n   * they are processed here\n   */\n  uip_next_hdr = &UIP_IP_BUF->proto;\n  uip_ext_len = 0;\n  uip_ext_bitmap = 0;\n  while(1) {\n    switch(*uip_next_hdr){\n#if UIP_TCP\n      case UIP_PROTO_TCP:\n        /* TCP, for both IPv4 and IPv6 */\n        goto tcp_input;\n#endif /* UIP_TCP */\n#if UIP_UDP\n      case UIP_PROTO_UDP:\n        /* UDP, for both IPv4 and IPv6 */\n        goto udp_input;\n#endif /* UIP_UDP */\n      case UIP_PROTO_ICMP6:\n        /* ICMPv6 */\n        goto icmp6_input;\n      case UIP_PROTO_HBHO:\n        PRINTF(\"Processing hbh header\\n\");\n        /* Hop by hop option header */\n#if UIP_CONF_IPV6_CHECKS\n        /* Hop by hop option header. If we saw one HBH already, drop */\n        if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_HBHO) {\n          goto bad_hdr;\n        } else {\n          uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;\n        }\n#endif /*UIP_CONF_IPV6_CHECKS*/\n        switch(ext_hdr_options_process()) {\n          case 0:\n            /*continue*/\n            uip_next_hdr = &UIP_EXT_BUF->next;\n            uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;\n            break;\n          case 1:\n            /*silently discard*/\n            goto drop;\n          case 2:\n            /* send icmp error message (created in ext_hdr_options_process)\n             * and discard*/\n            goto send;\n        }\n        break;\n      case UIP_PROTO_DESTO:\n#if UIP_CONF_IPV6_CHECKS\n        /* Destination option header. if we saw two already, drop */\n        PRINTF(\"Processing desto header\\n\");\n        if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO1) {\n          if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO2) {\n            goto bad_hdr;\n          } else{\n            uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO2;\n          }\n        } else {\n          uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO1;\n        }\n#endif /*UIP_CONF_IPV6_CHECKS*/\n        switch(ext_hdr_options_process()) {\n          case 0:\n            /*continue*/\n            uip_next_hdr = &UIP_EXT_BUF->next;\n            uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;\n            break;\n          case 1:\n            /*silently discard*/\n            goto drop;\n          case 2:\n            /* send icmp error message (created in ext_hdr_options_process)\n             * and discard*/\n            goto send;\n        }\n        break;\n      case UIP_PROTO_ROUTING:\n#if UIP_CONF_IPV6_CHECKS\n        /* Routing header. If we saw one already, drop */\n        if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_ROUTING) {\n          goto bad_hdr;\n        } else {\n          uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_ROUTING;\n        }\n#endif /*UIP_CONF_IPV6_CHECKS*/\n        /*\n         * Routing Header  length field is in units of 8 bytes, excluding\n         * As per RFC2460 section 4.4, if routing type is unrecognized:\n         * if segments left = 0, ignore the header\n         * if segments left > 0, discard packet and send icmp error pointing\n         * to the routing type\n         */\n\n        PRINTF(\"Processing Routing header\\n\");\n        if(UIP_ROUTING_BUF->seg_left > 0) {\n          uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, UIP_IPH_LEN + uip_ext_len + 2);\n          UIP_STAT(++uip_stat.ip.drop);\n          UIP_LOG(\"ip6: unrecognized routing type\");\n          goto send;\n        }\n        uip_next_hdr = &UIP_EXT_BUF->next;\n        uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;\n        break;\n      case UIP_PROTO_FRAG:\n        /* Fragmentation header:call the reassembly function, then leave */\n#if UIP_CONF_IPV6_REASSEMBLY\n        PRINTF(\"Processing frag header\\n\");\n        uip_len = uip_reass();\n        if(uip_len == 0) {\n          goto drop;\n        }\n        if(uip_reassflags & UIP_REASS_FLAG_ERROR_MSG){\n          /* we are not done with reassembly, this is an error message */\n          goto send;\n        }\n        /*packet is reassembled, reset the next hdr to the beginning\n           of the IP header and restart the parsing of the reassembled pkt*/\n        PRINTF(\"Processing reassembled packet\\n\");\n        uip_ext_len = 0;\n        uip_ext_bitmap = 0;\n        uip_next_hdr = &UIP_IP_BUF->proto;\n        break;\n#else /* UIP_CONF_IPV6_REASSEMBLY */\n        UIP_STAT(++uip_stat.ip.drop);\n        UIP_STAT(++uip_stat.ip.fragerr);\n        UIP_LOG(\"ip: fragment dropped.\");\n        goto drop;\n#endif /* UIP_CONF_IPV6_REASSEMBLY */\n      case UIP_PROTO_NONE:\n        goto drop;\n      default:\n        goto bad_hdr;\n    }\n  }\n  bad_hdr:\n  /*\n   * RFC 2460 send error message parameterr problem, code unrecognized\n   * next header, pointing to the next header field\n   */\n  uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER, (u32_t)((void *)uip_next_hdr - (void *)UIP_IP_BUF));\n  UIP_STAT(++uip_stat.ip.drop);\n  UIP_STAT(++uip_stat.ip.protoerr);\n  UIP_LOG(\"ip6: unrecognized header\");\n  goto send;\n  /* End of headers processing */\n  \n  icmp6_input:\n  /* This is IPv6 ICMPv6 processing code. */\n  PRINTF(\"icmp6_input: length %d\\n\", uip_len);\n\n#if UIP_CONF_IPV6_CHECKS\n  /* Compute and check the ICMP header checksum */\n  if(uip_icmp6chksum() != 0xffff) {\n    UIP_STAT(++uip_stat.icmp.drop);\n    UIP_STAT(++uip_stat.icmp.chkerr);\n    UIP_LOG(\"icmpv6: bad checksum.\");\n    goto drop;\n  }\n#endif /*UIP_CONF_IPV6_CHECKS*/\n\n  UIP_STAT(++uip_stat.icmp.recv);\n  /*\n   * Here we process incoming ICMPv6 packets\n   * For echo request, we send echo reply\n   * For ND pkts, we call the appropriate function in uip-nd6-io.c\n   * We do not treat Error messages for now\n   * If no pkt is to be sent as an answer to the incoming one, we\n   * \"goto drop\". Else we just break; then at the after the \"switch\"\n   * we \"goto send\"\n   */\n#if UIP_CONF_ICMP6\n  UIP_ICMP6_APPCALL(UIP_ICMP_BUF->type);\n#endif /*UIP_CONF_ICMP6*/\n\n  switch(UIP_ICMP_BUF->type) {\n    case ICMP6_NS:\n      uip_nd6_io_ns_input();\n      break;\n    case ICMP6_NA:\n      uip_nd6_io_na_input();\n      break;\n    case ICMP6_RA:\n      uip_nd6_io_ra_input();\n      break;\n    case ICMP6_ECHO_REQUEST:\n      uip_icmp6_echo_request_input();\n      break;\n    case ICMP6_ECHO_REPLY:\n      /** \\note We don't implement any application callback for now */\n      PRINTF(\"Received an icmp6 echo reply\\n\");\n      UIP_STAT(++uip_stat.icmp.recv);\n      uip_len = 0;\n      break;\n    default:\n      PRINTF(\"Unknown icmp6 message type %d\\n\", UIP_ICMP_BUF->type);\n      UIP_STAT(++uip_stat.icmp.drop);\n      UIP_STAT(++uip_stat.icmp.typeerr);\n      UIP_LOG(\"icmp6: unknown ICMP message.\");\n      uip_len = 0;\n      break;\n  }\n  \n  if(uip_len > 0) {\n    goto send;\n  } else {\n    goto drop;\n  }\n  /* End of IPv6 ICMP processing. */\n   \n\n#if UIP_UDP\n  /* UDP input processing. */\n udp_input:\n  PRINTF(\"Receiving UDP packet\\n\");\n  UIP_STAT(++uip_stat.udp.recv);\n \n  /* UDP processing is really just a hack. We don't do anything to the\n     UDP/IP headers, but let the UDP application do all the hard\n     work. If the application sets uip_slen, it has a packet to\n     send. */\n#if UIP_UDP_CHECKSUMS\n  uip_len = uip_len - UIP_IPUDPH_LEN;\n  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];\n  if(UIP_UDP_BUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {\n    UIP_STAT(++uip_stat.udp.drop);\n    UIP_STAT(++uip_stat.udp.chkerr);\n    UIP_LOG(\"udp: bad checksum.\");\n    goto drop;\n  }\n#else /* UIP_UDP_CHECKSUMS */\n  uip_len = uip_len - UIP_IPUDPH_LEN;\n#endif /* UIP_UDP_CHECKSUMS */\n\n  /* Demultiplex this UDP packet between the UDP \"connections\". */\n  for(uip_udp_conn = &uip_udp_conns[0];\n      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];\n      ++uip_udp_conn) {\n    /* If the local UDP port is non-zero, the connection is considered\n       to be used. If so, the local port number is checked against the\n       destination port number in the received packet. If the two port\n       numbers match, the remote port number is checked if the\n       connection is bound to a remote port. Finally, if the\n       connection is bound to a remote IP address, the source IP\n       address of the packet is checked. */\n    if(uip_udp_conn->lport != 0 &&\n       UIP_UDP_BUF->destport == uip_udp_conn->lport &&\n       (uip_udp_conn->rport == 0 ||\n        UIP_UDP_BUF->srcport == uip_udp_conn->rport) &&\n       (uip_is_addr_unspecified(&uip_udp_conn->ripaddr) ||\n        uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_udp_conn->ripaddr))) {\n      goto udp_found;\n    }\n  }\n  PRINTF(\"udp: no matching connection found\\n\");\n  goto drop;\n  \n udp_found:\n  PRINTF(\"In udp_found\\n\");\n \n  uip_conn = NULL;\n  uip_flags = UIP_NEWDATA;\n  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];\n  uip_slen = 0;\n  UIP_UDP_APPCALL();\n\n udp_send:\n  PRINTF(\"In udp_send\\n\");\n\n  if(uip_slen == 0) {\n    goto drop;\n  }\n  uip_len = uip_slen + UIP_IPUDPH_LEN;\n\n  /* For IPv6, the IP length field does not include the IPv6 IP header\n     length. */\n  UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);\n  UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);\n\n  UIP_IP_BUF->ttl = uip_udp_conn->ttl;\n  UIP_IP_BUF->proto = UIP_PROTO_UDP;\n\n  UIP_UDP_BUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);\n  UIP_UDP_BUF->udpchksum = 0;\n\n  UIP_TCP_BUF->srcport  = uip_udp_conn->lport;\n  UIP_TCP_BUF->destport = uip_udp_conn->rport;\n\n  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_udp_conn->ripaddr);\n  uip_netif_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);\n\n  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];\n\n#if UIP_UDP_CHECKSUMS\n  /* Calculate UDP checksum. */\n  UIP_UDP_BUF->udpchksum = ~(uip_udpchksum());\n  if(UIP_UDP_BUF->udpchksum == 0) {\n    UIP_UDP_BUF->udpchksum = 0xffff;\n  }\n#endif /* UIP_UDP_CHECKSUMS */\n  UIP_STAT(++uip_stat.udp.sent);\n  goto ip_send_nolen;\n#endif /* UIP_UDP */\n\n#if UIP_TCP\n  /* TCP input processing. */\n tcp_input:\n\n  UIP_STAT(++uip_stat.tcp.recv);\n  PRINTF(\"Receiving TCP packet\\n\");\n  /* Start of TCP input header processing code. */\n    \n  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP\n                                       checksum. */\n    UIP_STAT(++uip_stat.tcp.drop);\n    UIP_STAT(++uip_stat.tcp.chkerr);\n    UIP_LOG(\"tcp: bad checksum.\");\n    goto drop;\n  }\n  \n  /* Demultiplex this segment. */\n  /* First check any active connections. */\n  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];\n      ++uip_connr) {\n    if(uip_connr->tcpstateflags != UIP_CLOSED &&\n       UIP_TCP_BUF->destport == uip_connr->lport &&\n       UIP_TCP_BUF->srcport == uip_connr->rport &&\n       uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_connr->ripaddr)\n//FIXME add ifdef\n       && uip_ipaddr_cmp(&UIP_IP_BUF->destipaddr, &uip_connr->lipaddr)) {\n      goto found;\n    }\n  }\n\n  /* If we didn't find and active connection that expected the packet,\n     either this packet is an old duplicate, or this is a SYN packet\n     destined for a connection in LISTEN. If the SYN flag isn't set,\n     it is an old packet and we send a RST. */\n  if((UIP_TCP_BUF->flags & TCP_CTL) != TCP_SYN) {\n    goto reset;\n  }\n  \n  tmp16 = UIP_TCP_BUF->destport;\n  /* Next, check listening connections. */\n  for(c = 0; c < UIP_LISTENPORTS; ++c) {\n    if(tmp16 == uip_listenports[c]) {\n      goto found_listen;\n    }\n  }\n  \n  /* No matching connection found, so we send a RST packet. */\n  UIP_STAT(++uip_stat.tcp.synrst);\n\n reset:\n  PRINTF(\"In reset\\n\");\n  /* We do not send resets in response to resets. */\n  if(UIP_TCP_BUF->flags & TCP_RST) {\n    goto drop;\n  }\n\n  UIP_STAT(++uip_stat.tcp.rst);\n  \n  UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;\n  uip_len = UIP_IPTCPH_LEN;\n  UIP_TCP_BUF->tcpoffset = 5 << 4;\n\n  /* Flip the seqno and ackno fields in the TCP header. */\n  c = UIP_TCP_BUF->seqno[3];\n  UIP_TCP_BUF->seqno[3] = UIP_TCP_BUF->ackno[3];\n  UIP_TCP_BUF->ackno[3] = c;\n  \n  c = UIP_TCP_BUF->seqno[2];\n  UIP_TCP_BUF->seqno[2] = UIP_TCP_BUF->ackno[2];\n  UIP_TCP_BUF->ackno[2] = c;\n  \n  c = UIP_TCP_BUF->seqno[1];\n  UIP_TCP_BUF->seqno[1] = UIP_TCP_BUF->ackno[1];\n  UIP_TCP_BUF->ackno[1] = c;\n  \n  c = UIP_TCP_BUF->seqno[0];\n  UIP_TCP_BUF->seqno[0] = UIP_TCP_BUF->ackno[0];\n  UIP_TCP_BUF->ackno[0] = c;\n\n  /* We also have to increase the sequence number we are\n     acknowledging. If the least significant byte overflowed, we need\n     to propagate the carry to the other bytes as well. */\n  if(++UIP_TCP_BUF->ackno[3] == 0) {\n    if(++UIP_TCP_BUF->ackno[2] == 0) {\n      if(++UIP_TCP_BUF->ackno[1] == 0) {\n        ++UIP_TCP_BUF->ackno[0];\n      }\n    }\n  }\n \n  /* Swap port numbers. */\n  tmp16 = UIP_TCP_BUF->srcport;\n  UIP_TCP_BUF->srcport = UIP_TCP_BUF->destport;\n  UIP_TCP_BUF->destport = tmp16;\n  \n  /* Swap IP addresses. */\n  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);\n  uip_netif_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);\n  /* And send out the RST packet! */\n  goto tcp_send_noconn;\n\n  /* This label will be jumped to if we matched the incoming packet\n     with a connection in LISTEN. In that case, we should create a new\n     connection and send a SYNACK in return. */\n found_listen:\n  PRINTF(\"In found listen\\n\");\n  /* First we check if there are any connections avaliable. Unused\n     connections are kept in the same table as used connections, but\n     unused ones have the tcpstate set to CLOSED. Also, connections in\n     TIME_WAIT are kept track of and we'll use the oldest one if no\n     CLOSED connections are found. Thanks to Eddie C. Dost for a very\n     nice algorithm for the TIME_WAIT search. */\n  uip_connr = 0;\n  for(c = 0; c < UIP_CONNS; ++c) {\n    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {\n      uip_connr = &uip_conns[c];\n      break;\n    }\n    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {\n      if(uip_connr == 0 ||\n         uip_conns[c].timer > uip_connr->timer) {\n        uip_connr = &uip_conns[c];\n      }\n    }\n  }\n\n  if(uip_connr == 0) {\n    /* All connections are used already, we drop packet and hope that\n       the remote end will retransmit the packet at a time when we\n       have more spare connections. */\n    UIP_STAT(++uip_stat.tcp.syndrop);\n    UIP_LOG(\"tcp: found no unused connections.\");\n    goto drop;\n  }\n  uip_conn = uip_connr;\n  \n  /* Fill in the necessary fields for the new connection. */\n  uip_connr->rto = uip_connr->timer = UIP_RTO;\n  uip_connr->sa = 0;\n  uip_connr->sv = 4;\n  uip_connr->nrtx = 0;\n  uip_connr->lport = UIP_TCP_BUF->destport;\n  uip_connr->rport = UIP_TCP_BUF->srcport;\n  uip_ipaddr_copy(&uip_connr->ripaddr, &UIP_IP_BUF->srcipaddr);\n  //FIXME add ifdef (aliases)\n  uip_ipaddr_copy(&uip_connr->lipaddr, &UIP_IP_BUF->destipaddr);\n  uip_connr->tcpstateflags = UIP_SYN_RCVD;\n\n  uip_connr->snd_nxt[0] = iss[0];\n  uip_connr->snd_nxt[1] = iss[1];\n  uip_connr->snd_nxt[2] = iss[2];\n  uip_connr->snd_nxt[3] = iss[3];\n  uip_connr->len = 1;\n\n  /* rcv_nxt should be the seqno from the incoming packet + 1. */\n  uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];\n  uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];\n  uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];\n  uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];\n  uip_add_rcv_nxt(1);\n\n  /* Parse the TCP MSS option, if present. */\n  if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {\n    for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {\n      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];\n      if(opt == TCP_OPT_END) {\n        /* End of options. */\n        break;\n      } else if(opt == TCP_OPT_NOOP) {\n        ++c;\n        /* NOP option. */\n      } else if(opt == TCP_OPT_MSS &&\n                uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {\n        /* An MSS option with the right option length. */\n        tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |\n          (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];\n        uip_connr->initialmss = uip_connr->mss =\n          tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;\n   \n        /* And we are done processing options. */\n        break;\n      } else {\n        /* All other options have a length field, so that we easily\n           can skip past them. */\n        if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {\n          /* If the length field is zero, the options are malformed\n             and we don't process them further. */\n          break;\n        }\n        c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];\n      }\n    }\n  }\n  \n  /* Our response will be a SYNACK. */\n#if UIP_ACTIVE_OPEN\n tcp_send_synack:\n  UIP_TCP_BUF->flags = TCP_ACK;\n  \n tcp_send_syn:\n  UIP_TCP_BUF->flags |= TCP_SYN;\n#else /* UIP_ACTIVE_OPEN */\n tcp_send_synack:\n  UIP_TCP_BUF->flags = TCP_SYN | TCP_ACK;\n#endif /* UIP_ACTIVE_OPEN */\n  \n  /* We send out the TCP Maximum Segment Size option with our\n     SYNACK. */\n  UIP_TCP_BUF->optdata[0] = TCP_OPT_MSS;\n  UIP_TCP_BUF->optdata[1] = TCP_OPT_MSS_LEN;\n  UIP_TCP_BUF->optdata[2] = (UIP_TCP_MSS) / 256;\n  UIP_TCP_BUF->optdata[3] = (UIP_TCP_MSS) & 255;\n  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;\n  UIP_TCP_BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;\n  goto tcp_send;\n\n  /* This label will be jumped to if we found an active connection. */\n found:\n  PRINTF(\"In found\\n\");\n   \n  uip_conn = uip_connr;\n  uip_flags = 0;\n  /* We do a very naive form of TCP reset processing; we just accept\n     any RST and kill our connection. We should in fact check if the\n     sequence number of this reset is wihtin our advertised window\n     before we accept the reset. */\n  if(UIP_TCP_BUF->flags & TCP_RST) {\n    uip_connr->tcpstateflags = UIP_CLOSED;\n    UIP_LOG(\"tcp: got reset, aborting connection.\");\n    uip_flags = UIP_ABORT;\n    UIP_APPCALL();\n    goto drop;\n  }\n  /* Calculate the length of the data, if the application has sent\n     any data to us. */\n  c = (UIP_TCP_BUF->tcpoffset >> 4) << 2;\n  /* uip_len will contain the length of the actual TCP data. This is\n     calculated by subtracing the length of the TCP header (in\n     c) and the length of the IP header (20 bytes). */\n  uip_len = uip_len - c - UIP_IPH_LEN;\n\n  /* First, check if the sequence number of the incoming packet is\n     what we're expecting next. If not, we send out an ACK with the\n     correct numbers in. */\n  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&\n       ((UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {\n    if((uip_len > 0 || ((UIP_TCP_BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&\n       (UIP_TCP_BUF->seqno[0] != uip_connr->rcv_nxt[0] ||\n        UIP_TCP_BUF->seqno[1] != uip_connr->rcv_nxt[1] ||\n        UIP_TCP_BUF->seqno[2] != uip_connr->rcv_nxt[2] ||\n        UIP_TCP_BUF->seqno[3] != uip_connr->rcv_nxt[3])) {\n      goto tcp_send_ack;\n    }\n  }\n\n  /* Next, check if the incoming segment acknowledges any outstanding\n     data. If so, we update the sequence number, reset the length of\n     the outstanding data, calculate RTT estimations, and reset the\n     retransmission timer. */\n  if((UIP_TCP_BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {\n    uip_add32(uip_connr->snd_nxt, uip_connr->len);\n\n    if(UIP_TCP_BUF->ackno[0] == uip_acc32[0] &&\n       UIP_TCP_BUF->ackno[1] == uip_acc32[1] &&\n       UIP_TCP_BUF->ackno[2] == uip_acc32[2] &&\n       UIP_TCP_BUF->ackno[3] == uip_acc32[3]) {\n      /* Update sequence number. */\n      uip_connr->snd_nxt[0] = uip_acc32[0];\n      uip_connr->snd_nxt[1] = uip_acc32[1];\n      uip_connr->snd_nxt[2] = uip_acc32[2];\n      uip_connr->snd_nxt[3] = uip_acc32[3];\n   \n      /* Do RTT estimation, unless we have done retransmissions. */\n      if(uip_connr->nrtx == 0) {\n        signed char m;\n        m = uip_connr->rto - uip_connr->timer;\n        /* This is taken directly from VJs original code in his paper */\n        m = m - (uip_connr->sa >> 3);\n        uip_connr->sa += m;\n        if(m < 0) {\n          m = -m;\n        }\n        m = m - (uip_connr->sv >> 2);\n        uip_connr->sv += m;\n        uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;\n\n      }\n      /* Set the acknowledged flag. */\n      uip_flags = UIP_ACKDATA;\n      /* Reset the retransmission timer. */\n      uip_connr->timer = uip_connr->rto;\n\n      /* Reset length of outstanding data. */\n      uip_connr->len = 0;\n    }\n    \n  }\n\n  /* Do different things depending on in what state the connection is. */\n  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {\n    /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not\n       implemented, since we force the application to close when the\n       peer sends a FIN (hence the application goes directly from\n       ESTABLISHED to LAST_ACK). */\n    case UIP_SYN_RCVD:\n      /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and\n         we are waiting for an ACK that acknowledges the data we sent\n         out the last time. Therefore, we want to have the UIP_ACKDATA\n         flag set. If so, we enter the ESTABLISHED state. */\n      if(uip_flags & UIP_ACKDATA) {\n        uip_connr->tcpstateflags = UIP_ESTABLISHED;\n        uip_flags = UIP_CONNECTED;\n        uip_connr->len = 0;\n        if(uip_len > 0) {\n          uip_flags |= UIP_NEWDATA;\n          uip_add_rcv_nxt(uip_len);\n        }\n        uip_slen = 0;\n        UIP_APPCALL();\n        goto appsend;\n      }\n      goto drop;\n#if UIP_ACTIVE_OPEN\n    case UIP_SYN_SENT:\n      /* In SYN_SENT, we wait for a SYNACK that is sent in response to\n         our SYN. The rcv_nxt is set to sequence number in the SYNACK\n         plus one, and we send an ACK. We move into the ESTABLISHED\n         state. */\n      if((uip_flags & UIP_ACKDATA) &&\n         (UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {\n\n        /* Parse the TCP MSS option, if present. */\n        if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {\n          for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {\n            opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];\n            if(opt == TCP_OPT_END) {\n              /* End of options. */\n              break;\n            } else if(opt == TCP_OPT_NOOP) {\n              ++c;\n              /* NOP option. */\n            } else if(opt == TCP_OPT_MSS &&\n                      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {\n              /* An MSS option with the right option length. */\n              tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |\n                uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];\n              uip_connr->initialmss =\n                uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;\n\n              /* And we are done processing options. */\n              break;\n            } else {\n              /* All other options have a length field, so that we easily\n                 can skip past them. */\n              if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {\n                /* If the length field is zero, the options are malformed\n                   and we don't process them further. */\n                break;\n              }\n              c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];\n            }\n          }\n        }\n        uip_connr->tcpstateflags = UIP_ESTABLISHED;\n        uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];\n        uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];\n        uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];\n        uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];\n        uip_add_rcv_nxt(1);\n        uip_flags = UIP_CONNECTED | UIP_NEWDATA;\n        uip_connr->len = 0;\n        uip_len = 0;\n        uip_slen = 0;\n        UIP_APPCALL();\n        goto appsend;\n      }\n      /* Inform the application that the connection failed */\n      uip_flags = UIP_ABORT;\n      UIP_APPCALL();\n      /* The connection is closed after we send the RST */\n      uip_conn->tcpstateflags = UIP_CLOSED;\n      goto reset;\n#endif /* UIP_ACTIVE_OPEN */\n    \n    case UIP_ESTABLISHED:        \n    \n      /* In the ESTABLISHED state, we call upon the application to feed\n         data into the uip_buf. If the UIP_ACKDATA flag is set, the\n         application should put new data into the buffer, otherwise we are\n         retransmitting an old segment, and the application should put that\n         data into the buffer.\n\n         If the incoming packet is a FIN, we should close the connection on\n         this side as well, and we send out a FIN and enter the LAST_ACK\n         state. We require that there is no outstanding data; otherwise the\n         sequence numbers will be screwed up. */\n\n      if(UIP_TCP_BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {\n        if(uip_outstanding(uip_connr)) {\n          goto drop;\n        }\n        uip_add_rcv_nxt(1 + uip_len);\n        uip_flags |= UIP_CLOSE;\n        if(uip_len > 0) {\n          uip_flags |= UIP_NEWDATA;\n        }\n        UIP_APPCALL();\n        uip_connr->len = 1;\n        uip_connr->tcpstateflags = UIP_LAST_ACK;\n        uip_connr->nrtx = 0;\n      tcp_send_finack:\n        UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;\n        goto tcp_send_nodata;\n      }\n\n      /* Check the URG flag. If this is set, the segment carries urgent\n         data that we must pass to the application. */\n      if((UIP_TCP_BUF->flags & TCP_URG) != 0) {\n#if UIP_URGDATA > 0\n        uip_urglen = (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];\n        if(uip_urglen > uip_len) {\n          /* There is more urgent data in the next segment to come. */\n          uip_urglen = uip_len;\n        }\n        uip_add_rcv_nxt(uip_urglen);\n        uip_len -= uip_urglen;\n        uip_urgdata = uip_appdata;\n        uip_appdata += uip_urglen;\n      } else {\n        uip_urglen = 0;\n#else /* UIP_URGDATA > 0 */\n        uip_appdata = ((char *)uip_appdata) + ((UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1]);\n        uip_len -= (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];\n#endif /* UIP_URGDATA > 0 */\n      }\n\n      /* If uip_len > 0 we have TCP data in the packet, and we flag this\n         by setting the UIP_NEWDATA flag and update the sequence number\n         we acknowledge. If the application has stopped the dataflow\n         using uip_stop(), we must not accept any data packets from the\n         remote host. */\n      if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {\n        uip_flags |= UIP_NEWDATA;\n        uip_add_rcv_nxt(uip_len);\n      }\n\n      /* Check if the available buffer space advertised by the other end\n         is smaller than the initial MSS for this connection. If so, we\n         set the current MSS to the window size to ensure that the\n         application does not send more data than the other end can\n         handle.\n\n         If the remote host advertises a zero window, we set the MSS to\n         the initial MSS so that the application will send an entire MSS\n         of data. This data will not be acknowledged by the receiver,\n         and the application will retransmit it. This is called the\n         \"persistent timer\" and uses the retransmission mechanim.\n      */\n      tmp16 = ((u16_t)UIP_TCP_BUF->wnd[0] << 8) + (u16_t)UIP_TCP_BUF->wnd[1];\n      if(tmp16 > uip_connr->initialmss ||\n         tmp16 == 0) {\n        tmp16 = uip_connr->initialmss;\n      }\n      uip_connr->mss = tmp16;\n\n      /* If this packet constitutes an ACK for outstanding data (flagged\n         by the UIP_ACKDATA flag, we should call the application since it\n         might want to send more data. If the incoming packet had data\n         from the peer (as flagged by the UIP_NEWDATA flag), the\n         application must also be notified.\n\n         When the application is called, the global variable uip_len\n         contains the length of the incoming data. The application can\n         access the incoming data through the global pointer\n         uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN\n         bytes into the uip_buf array.\n\n         If the application wishes to send any data, this data should be\n         put into the uip_appdata and the length of the data should be\n         put into uip_len. If the application don't have any data to\n         send, uip_len must be set to 0. */\n                  \n      if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {\n      \n        uip_slen = 0;\n        UIP_APPCALL();\n\n      appsend:\n      \n        if(uip_flags & UIP_ABORT) {\n          uip_slen = 0;\n          uip_connr->tcpstateflags = UIP_CLOSED;\n          UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;\n          goto tcp_send_nodata;\n        }\n\n        if(uip_flags & UIP_CLOSE) {\n          uip_slen = 0;\n          uip_connr->len = 1;\n          uip_connr->tcpstateflags = UIP_FIN_WAIT_1;\n          uip_connr->nrtx = 0;\n          UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;\n          goto tcp_send_nodata;\n        }\n\n        /* If uip_slen > 0, the application has data to be sent. */\n        if(uip_slen > 0) {\n\n          /* If the connection has acknowledged data, the contents of\n             the ->len variable should be discarded. */\n          if((uip_flags & UIP_ACKDATA) != 0) {\n            uip_connr->len = 0;\n          }\n\n          /* If the ->len variable is non-zero the connection has\n             already data in transit and cannot send anymore right\n             now. */\n          if(uip_connr->len == 0) {\n\n            /* The application cannot send more than what is allowed by\n               the mss (the minumum of the MSS and the available\n               window). */\n            if(uip_slen > uip_connr->mss) {\n              uip_slen = uip_connr->mss;\n            }\n\n            /* Remember how much data we send out now so that we know\n               when everything has been acknowledged. */\n            uip_connr->len = uip_slen;\n          } else {\n\n            /* If the application already had unacknowledged data, we\n               make sure that the application does not send (i.e.,\n               retransmit) out more than it previously sent out. */\n            uip_slen = uip_connr->len;\n          }\n        }\n        uip_connr->nrtx = 0;\n      apprexmit:\n        uip_appdata = uip_sappdata;\n      \n        /* If the application has data to be sent, or if the incoming\n           packet had new data in it, we must send out a packet. */\n        if(uip_slen > 0 && uip_connr->len > 0) {\n          /* Add the length of the IP and TCP headers. */\n          uip_len = uip_connr->len + UIP_TCPIP_HLEN;\n          /* We always set the ACK flag in response packets. */\n          UIP_TCP_BUF->flags = TCP_ACK | TCP_PSH;\n          /* Send the packet. */\n          goto tcp_send_noopts;\n        }\n        /* If there is no data to send, just send out a pure ACK if\n           there is newdata. */\n        if(uip_flags & UIP_NEWDATA) {\n          uip_len = UIP_TCPIP_HLEN;\n          UIP_TCP_BUF->flags = TCP_ACK;\n          goto tcp_send_noopts;\n        }\n      }\n      goto drop;\n    case UIP_LAST_ACK:\n      /* We can close this connection if the peer has acknowledged our\n         FIN. This is indicated by the UIP_ACKDATA flag. */\n      if(uip_flags & UIP_ACKDATA) {\n        uip_connr->tcpstateflags = UIP_CLOSED;\n        uip_flags = UIP_CLOSE;\n        UIP_APPCALL();\n      }\n      break;\n    \n    case UIP_FIN_WAIT_1:\n      /* The application has closed the connection, but the remote host\n         hasn't closed its end yet. Thus we do nothing but wait for a\n         FIN from the other side. */\n      if(uip_len > 0) {\n        uip_add_rcv_nxt(uip_len);\n      }\n      if(UIP_TCP_BUF->flags & TCP_FIN) {\n        if(uip_flags & UIP_ACKDATA) {\n          uip_connr->tcpstateflags = UIP_TIME_WAIT;\n          uip_connr->timer = 0;\n          uip_connr->len = 0;\n        } else {\n          uip_connr->tcpstateflags = UIP_CLOSING;\n        }\n        uip_add_rcv_nxt(1);\n        uip_flags = UIP_CLOSE;\n        UIP_APPCALL();\n        goto tcp_send_ack;\n      } else if(uip_flags & UIP_ACKDATA) {\n        uip_connr->tcpstateflags = UIP_FIN_WAIT_2;\n        uip_connr->len = 0;\n        goto drop;\n      }\n      if(uip_len > 0) {\n        goto tcp_send_ack;\n      }\n      goto drop;\n      \n    case UIP_FIN_WAIT_2:\n      if(uip_len > 0) {\n        uip_add_rcv_nxt(uip_len);\n      }\n      if(UIP_TCP_BUF->flags & TCP_FIN) {\n        uip_connr->tcpstateflags = UIP_TIME_WAIT;\n        uip_connr->timer = 0;\n        uip_add_rcv_nxt(1);\n        uip_flags = UIP_CLOSE;\n        UIP_APPCALL();\n        goto tcp_send_ack;\n      }\n      if(uip_len > 0) {\n        goto tcp_send_ack;\n      }\n      goto drop;\n\n    case UIP_TIME_WAIT:\n      goto tcp_send_ack;\n    \n    case UIP_CLOSING:\n      if(uip_flags & UIP_ACKDATA) {\n        uip_connr->tcpstateflags = UIP_TIME_WAIT;\n        uip_connr->timer = 0;\n      }\n  }\n  goto drop;\n  \n  /* We jump here when we are ready to send the packet, and just want\n     to set the appropriate TCP sequence numbers in the TCP header. */\n tcp_send_ack:\n  UIP_TCP_BUF->flags = TCP_ACK;\n\n tcp_send_nodata:\n  uip_len = UIP_IPTCPH_LEN;\n\n tcp_send_noopts:\n  UIP_TCP_BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;\n\n  /* We're done with the input processing. We are now ready to send a\n     reply. Our job is to fill in all the fields of the TCP and IP\n     headers before calculating the checksum and finally send the\n     packet. */\n tcp_send:\n  PRINTF(\"In tcp_send\\n\");\n   \n  UIP_TCP_BUF->ackno[0] = uip_connr->rcv_nxt[0];\n  UIP_TCP_BUF->ackno[1] = uip_connr->rcv_nxt[1];\n  UIP_TCP_BUF->ackno[2] = uip_connr->rcv_nxt[2];\n  UIP_TCP_BUF->ackno[3] = uip_connr->rcv_nxt[3];\n  \n  UIP_TCP_BUF->seqno[0] = uip_connr->snd_nxt[0];\n  UIP_TCP_BUF->seqno[1] = uip_connr->snd_nxt[1];\n  UIP_TCP_BUF->seqno[2] = uip_connr->snd_nxt[2];\n  UIP_TCP_BUF->seqno[3] = uip_connr->snd_nxt[3];\n\n  UIP_IP_BUF->proto = UIP_PROTO_TCP;\n  \n  UIP_TCP_BUF->srcport  = uip_connr->lport;\n  UIP_TCP_BUF->destport = uip_connr->rport;\n\n\n  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_connr->ripaddr);\n//FIXME ifdef\n  uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &uip_connr->lipaddr);\n  uip_netif_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);\n  PRINTF(\"Sending TCP packet to\");\n  PRINT6ADDR(&UIP_IP_BUF->destipaddr);\n  PRINTF(\"from\");\n  PRINT6ADDR(&UIP_IP_BUF->srcipaddr);\n  PRINTF(\"\\n\");\n      \n  if(uip_connr->tcpstateflags & UIP_STOPPED) {\n    /* If the connection has issued uip_stop(), we advertise a zero\n       window so that the remote host will stop sending data. */\n    UIP_TCP_BUF->wnd[0] = UIP_TCP_BUF->wnd[1] = 0;\n  } else {\n    UIP_TCP_BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);\n    UIP_TCP_BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);\n  }\n\n tcp_send_noconn:\n  UIP_IP_BUF->ttl = uip_netif_physical_if.cur_hop_limit;\n  UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);\n  UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);\n\n  UIP_TCP_BUF->urgp[0] = UIP_TCP_BUF->urgp[1] = 0;\n  \n  /* Calculate TCP checksum. */\n  UIP_TCP_BUF->tcpchksum = 0;\n  UIP_TCP_BUF->tcpchksum = ~(uip_tcpchksum());\n  UIP_STAT(++uip_stat.tcp.sent);\n\n#endif /* UIP_TCP */\n#if UIP_UDP\n ip_send_nolen:\n#endif\n  UIP_IP_BUF->vtc = 0x60;\n  UIP_IP_BUF->tcflow = 0x00;\n  UIP_IP_BUF->flow = 0x00;\n send:\n  PRINTF(\"Sending packet with length %d (%d)\\n\", uip_len,\n         (UIP_IP_BUF->len[0] << 8) | UIP_IP_BUF->len[1]);\n  \n  UIP_STAT(++uip_stat.ip.sent);\n  /* Return and let the caller do the actual transmission. */\n  uip_flags = 0;\n  return;\n\n drop:\n  uip_len = 0;\n  uip_ext_len = 0;\n  uip_ext_bitmap = 0;\n  uip_flags = 0;\n  return;\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\netimer_set(struct etimer *et, etimer_cb cb, clock_time_t interval)", "code": "{\n  timer_set(&et->timer, interval);\n  et->p = cb;\n  add_timer(et);\n}", "path": "etimer.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "u8_t\nget_match_length(uip_ipaddr_t *src, uip_ipaddr_t *dst)", "code": "{\n  u8_t j, k, x_or;\n  u8_t len = 0;\n  for(j = 0; j < 16; j ++) {\n    if(src->u8[j] == dst->u8[j]) {\n      len += 8;\n    } else {\n      x_or = src->u8[j] ^ dst->u8[j];\n      for(k = 0; k < 8; k ++) {\n        if((x_or & 0x80) == 0){\n          len ++;\n          x_or <<= 1;\n        }\n        else {\n          break;\n        }\n      } \n      break;\n    }\n  }\n  return len;\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_addr_add(uip_ipaddr_t *ipaddr, u8_t length, clock_time_t vlifetime, uip_netif_type type)", "code": "{\n  \n  /* check prefix has the right length if we are doing autoconf */\n  if((type == AUTOCONF) && (length != UIP_DEFAULT_PREFIX_LEN)) {\n    UIP_LOG(\"Error: UNSUPPORTED PREFIX LENGTH\");\n    return;\n  }\n     \n  /* check if addr does not already exist and find a free entry */\n  for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; ++i) {\n    if(uip_netif_physical_if.addresses[i].state == NOT_USED){\n      /*\n       * Copying address\n       * If we are doing autoconf, ipaddr is a prefix, we copy the 128 bits\n       * of it, then overwrite the last 64 bits with the interface ID at \n       * next if statement.\n       * Otherwise ipaddr is an address, we just copy it\n       */\n      uip_ipaddr_copy(&uip_netif_physical_if.addresses[i].ipaddr, ipaddr);\n      if(type == AUTOCONF) {\n        /* construct address from prefix and layer2 id */\n        uip_netif_addr_autoconf_set(&uip_netif_physical_if.addresses[i].ipaddr, &uip_lladdr);\n      } \n      /* setting state, type */\n      uip_netif_physical_if.addresses[i].state = TENTATIVE;\n      uip_netif_physical_if.addresses[i].type = type;\n      /* setting lifetime timer if lieftime is not infinite */\n      if(vlifetime != 0) {\n        timer_set(&(uip_netif_physical_if.addresses[i].vlifetime), vlifetime);\n        uip_netif_physical_if.addresses[i].is_infinite = 0;\n      } else {\n        uip_netif_physical_if.addresses[i].is_infinite = 1;\n      }\n      PRINTF(\"Created new address\");\n      arduino_debug(\"created new address\");\n      arduino_debug_address((unsigned char*) uip_netif_physical_if.addresses[i].ipaddr.u8);\n\n      PRINT6ADDR(&uip_netif_physical_if.addresses[i].ipaddr);\n      PRINTF(\"for interface\\n\");\n\n      /* schedule DAD */\n      uip_netif_sched_dad(&uip_netif_physical_if.addresses[i]);\n      \n      return;\n    }\n  }\n \n  /* If we did not find space, log */ \n  UIP_LOG(\"ADDRESS LIST FULL\");\n  return;\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\netimer_adjust(struct etimer *et, int timediff)", "code": "{\n  et->timer.start += timediff;\n  update_time();\n}", "path": "etimer.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\netimer_restart(struct etimer *et)", "code": "{\n  timer_restart(&et->timer);\n  add_timer(et);\n}", "path": "etimer.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_send(const void *data, int len)", "code": "{\n  int copylen;\n#define MIN(a,b) ((a) < (b)? (a): (b))\n  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -\n                (int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));\n  if(copylen > 0) {\n    uip_slen = copylen;\n    if(data != uip_sappdata) {\n      memcpy(uip_sappdata, (data), uip_slen);\n    }\n  }\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\netimer_stop(struct etimer *et)", "code": "{\n  struct etimer *t;\n\n  /* First check if et is the first event timer on the list. */\n  if(et == timerlist) {\n    timerlist = timerlist->next;\n    update_time();\n  } else {\n    /* Else walk through the list and try to find the item before the\n       et timer. */\n    for(t = timerlist; t != NULL && t->next != et; t = t->next);\n\n    if(t != NULL) {\n      /* We've found the item before the event timer that we are about\n\t to remove. We point the items next pointer to the event after\n\t the removed item. */\n      t->next = et->next;\n\n      update_time();\n    }\n  }\n\n  /* Remove the next pointer from the item to be removed. */\n  et->next = NULL;\n  /* Set the timer as expired */\n  et->p = NULL; \n}", "path": "etimer.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static u16_t\nupper_layer_chksum(u8_t proto)", "code": "{\n/* gcc 4.4.0 - 4.6.1 (maybe 4.3...) with -Os on 8 bit CPUS incorrectly compiles:\n * int bar (int);\n * int foo (unsigned char a, unsigned char b) {\n *   int len = (a << 8) + b; //len becomes 0xff00&<random>+b\n *   return len + bar (len);\n * }\n * upper_layer_len triggers this bug unless it is declared volatile.\n * See https://sourceforge.net/apps/mantisbt/contiki/view.php?id=3\n */\n  volatile u16_t upper_layer_len;\n  u16_t sum;\n  \n  upper_layer_len = (((u16_t)(UIP_IP_BUF->len[0]) << 8) + UIP_IP_BUF->len[1] - uip_ext_len) ;\n  \n  /* First sum pseudoheader. */\n  /* IP protocol and length fields. This addition cannot carry. */\n  sum = upper_layer_len + proto;\n  /* Sum IP source and destination addresses. */\n  sum = chksum(sum, (u8_t *)&UIP_IP_BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));\n\n  /* Sum TCP header and data. */\n  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN + uip_ext_len],\n               upper_layer_len);\n    \n  return (sum == 0) ? 0xffff : htons(sum);\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "static u16_t\nchksum(u16_t sum, const u8_t *data, u16_t len)", "code": "{\n  u16_t t;\n  const u8_t *dataptr;\n  const u8_t *last_byte;\n\n  dataptr = data;\n  last_byte = data + len - 1;\n  \n  while(dataptr < last_byte) {   /* At least two more bytes */\n    t = (dataptr[0] << 8) + dataptr[1];\n    sum += t;\n    if(sum < t) {\n      sum++;      /* carry */\n    }\n    dataptr += 2;\n  }\n  \n  if(dataptr == last_byte) {\n    t = (dataptr[0] << 8) + 0;\n    sum += t;\n    if(sum < t) {\n      sum++;      /* carry */\n    }\n  }\n\n  /* Return sum in host byte order. */\n  return sum;\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_select_src(uip_ipaddr_t *src, uip_ipaddr_t *dst)", "code": "{   \n  u8_t best = 0; /* number of bit in common with best match*/\n  u8_t n = 0;\n  u8_t index = 0;\n  \n  if(!uip_is_addr_link_local(dst) && !uip_is_addr_mcast(dst)) {\n    for(i = 1; i < UIP_CONF_NETIF_MAX_ADDRESSES; ++i) {\n      if(uip_netif_physical_if.addresses[i].state == PREFERRED){\n        if (uip_ipaddr_cmp(src, &(uip_netif_physical_if.addresses[i].ipaddr)))\n          return;\n        n = get_match_length(dst, &(uip_netif_physical_if.addresses[i].ipaddr));\n        if(n >= best){\n          best = n;\n          index = i;\n        }\n      }\n    }\n  }\n\n  uip_ipaddr_copy(src, &(uip_netif_physical_if.addresses[index].ipaddr));\n  return;\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/**\n * \\brief Process the options in Destination and Hop By Hop extension headers\n */\n", "func_signal": "static u8_t\next_hdr_options_process()", "code": "{\n /*\n  * Length field in the extension header: length of th eheader in units of\n  * 8 bytes, excluding the first 8 bytes\n  * length field in an option : the length of data in the option\n  */\n  uip_ext_opt_offset = 2;\n  while(uip_ext_opt_offset  < ((UIP_EXT_BUF->len << 3) + 8)) {\n    switch (UIP_EXT_HDR_OPT_BUF->type) {\n      /*\n       * for now we do not support any options except padding ones\n       * PAD1 does not make sense as the header must be 8bytes aligned,\n       * hence we can only have\n       */\n      case UIP_EXT_HDR_OPT_PAD1:\n        PRINTF(\"Processing PAD1 option\\n\");\n        uip_ext_opt_offset += 1;\n        break;\n      case UIP_EXT_HDR_OPT_PADN:\n        PRINTF(\"Processing PADN option\\n\");\n        uip_ext_opt_offset += UIP_EXT_HDR_OPT_PADN_BUF->opt_len + 2;\n        break;\n      default:\n        /*\n         * check the two highest order bits of the option\n         * - 00 skip over this option and continue processing the header.\n         * - 01 discard the packet.\n         * - 10 discard the packet and, regardless of whether or not the\n         *   packet's Destination Address was a multicast address, send an\n         *   ICMP Parameter Problem, Code 2, message to the packet's\n         *   Source Address, pointing to the unrecognized Option Type.\n         * - 11 discard the packet and, only if the packet's Destination\n         *   Address was not a multicast address, send an ICMP Parameter\n         *   Problem, Code 2, message to the packet's Source Address,\n         *   pointing to the unrecognized Option Type.\n         */\n        PRINTF(\"MSB %x\\n\", UIP_EXT_HDR_OPT_BUF->type);\n        switch(UIP_EXT_HDR_OPT_BUF->type & 0xC0) {\n          case 0:\n            break;\n          case 0x40:\n            return 1;\n          case 0xC0:\n            if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {\n              return 1;\n            }\n          case 0x80:\n            uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION,\n                             (u32_t)UIP_IPH_LEN + uip_ext_len + uip_ext_opt_offset);\n            return 2;\n        }\n        /* in the cases were we did not discard, update ext_opt* */\n        uip_ext_opt_offset += UIP_EXT_HDR_OPT_BUF->len + 2;\n        break;\n    }\n  }\n  return 0;\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\netimer_reset(struct etimer *et)", "code": "{\n  timer_reset(&et->timer);\n  add_timer(et);\n}", "path": "etimer.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_dad(void)", "code": "{\n  /*\n   * check if dad is running\n   */\n  if(dad_ifaddr == NULL){\n    PRINTF(\"uip_netif_dad: DAD not running\\n\");\n    return;\n  }\n  /*\n   * send dup_addr_detect_transmit NS for DAD\n   */\n  if(dad_ns < uip_netif_physical_if.dup_addr_detect_transmit) {\n    uip_nd6_io_ns_output(NULL, NULL, &dad_ifaddr->ipaddr);\n    dad_ns++;\n    etimer_set(&uip_netif_timer_dad, tcpip_process, uip_netif_physical_if.retrans_timer/1000*CLOCK_SECOND);\n    return;\n  }\n  /*\n   * If we arrive here it means DAD succeeded, otherwise the dad process\n   * would have been interrupted in nd6_dad_ns/na_input\n   */\n  PRINTF(\"DAD succeeded for ipaddr:\");\n  PRINT6ADDR(&(dad_ifaddr->ipaddr));\n  PRINTF(\"\\n\");\n\n  etimer_stop(&uip_netif_timer_dad);\n  dad_ifaddr->state = PREFERRED;\n  dad_ifaddr = NULL;\n  dad_ns = 0;\n  /*\n   * check if we need to run DAD on another address\n   * This is necessary because if you receive a RA,\n   * you might want to run DAD for several addresses\n   * Considering that we have structures to do DAD \n   * for one address only, we start DAD for the subsequent\n   * addresses here\n   */\n  PRINTF(\"END of DAD\\n\");\n  for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++){\n    if(uip_netif_physical_if.addresses[i].state != NOT_USED){\n      PRINTF(\"address %d : \",i);\n      PRINT6ADDR(&(uip_netif_physical_if.addresses[i].ipaddr));\n      PRINTF(\"\\n\");\n    }\n    if(uip_netif_physical_if.addresses[i].state == TENTATIVE){\n      uip_netif_sched_dad(&uip_netif_physical_if.addresses[i]);\n      return;   \n    }\n  }\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_dad_failed(uip_ipaddr_t *ipaddr)", "code": "{\n\n  UIP_LOG(\"DAD FAILED\");\n  UIP_LOG(\"THE STACK IS GOING TO SHUT DOWN\");\n  UIP_LOG(\"THE HOST WILL BE UNREACHABLE\");\n  \n  if(uip_ipaddr_cmp(&dad_ifaddr->ipaddr, ipaddr)){\n    etimer_stop(&uip_netif_timer_dad);\n    dad_ifaddr->state = NOT_USED;\n    dad_ifaddr = NULL;\n    dad_ns = 0;\n  }\n  \n  exit(-1);\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_netif_addr_autoconf_set(uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr)", "code": "{\n  /* We consider only links with IEEE EUI-64 identifier or\n     IEEE 48-bit MAC addresses */\n#if (UIP_LLADDR_LEN == 8)\n  memcpy(ipaddr->u8 + 8, lladdr, UIP_LLADDR_LEN);\n  ipaddr->u8[8] ^= 0x02;  \n#elif (UIP_LLADDR_LEN == 6)\n  memcpy(ipaddr->u8 + 8, lladdr, 3);\n  ipaddr->u8[11] = 0xff;\n  ipaddr->u8[12] = 0xfe;\n  memcpy(ipaddr->u8 + 13, (u8_t*)lladdr + 3, 3);\n  ipaddr->u8[8] ^= 0x02;\n#else\n  UIP_LOG(\"CAN NOT BUIL INTERFACE IDENTIFIER\");\n  UIP_LOG(\"THE STACK IS GOING TO SHUT DOWN\");\n  UIP_LOG(\"THE HOST WILL BE UNREACHABLE\");\n  exit(-1);\n#endif\n}", "path": "uip-netif.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*---------------------------------------------------------------------------*/\n", "func_signal": "void\nuip_listen(u16_t port)", "code": "{\n  for(c = 0; c < UIP_LISTENPORTS; ++c) {\n    if(uip_listenports[c] == 0) {\n      uip_listenports[c] = port;\n      return;\n    }\n  }\n}", "path": "uip6.c", "repo_name": "ghoelzl/IPv6EtherShield", "stars": 16, "license": "None", "language": "c", "size": 195}
{"docstring": "/*mask module methods*/\n", "func_signal": "static PyObject* Mask(PyObject* self, PyObject* args)", "code": "{\n    bitmask_t *mask;\n    int w,h;\n    PyMaskObject *maskobj;\n    if(!PyArg_ParseTuple(args, \"(ii)\", &w, &h))\n        return NULL;\n    mask = bitmask_create(w,h);\n\n    if(!mask)\n      return NULL; /*RAISE(PyExc_Error, \"cannot create bitmask\");*/\n\n        /*create the new python object from mask*/\n    maskobj = PyObject_New(PyMaskObject, &PyMask_Type);\n    if(maskobj)\n        maskobj->mask = mask;\n    return (PyObject*)maskobj;\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* get the current master clock value */\n", "func_signal": "double get_master_clock(PyMovie *movie)", "code": "{\n    double val;\n\n    if (movie->av_sync_type == AV_SYNC_VIDEO_MASTER)\n    {\n        if (movie->video_st)\n            val = get_video_clock(movie);\n        else\n            val = get_audio_clock(movie);\n    }\n    else if (movie->av_sync_type == AV_SYNC_AUDIO_MASTER)\n    {\n        if (movie->audio_st)\n            val = get_audio_clock(movie);\n        else\n            val = get_video_clock(movie);\n    }\n    else\n    {\n        val = get_external_clock(movie);\n    }\n    return val;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* pause or resume the video */\n", "func_signal": "void stream_pause(PyMovie *movie)", "code": "{\n    ALLOC_COMMAND(pauseCommand, pause);\n    addCommand(movie->commands, (Command *)pause);\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* Sets the value of the variable width. Acts like a macro */\n", "func_signal": "void inline get_width(PyMovie *movie, int *width)", "code": "{\n    if(movie->resize_w)\n    {\n        *width=movie->width;\n    }\n    else\n    {\n        if(movie->video_st)\n            *width=movie->video_st->codec->width;\n    }\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "//transfers data from the AVPicture written to by swscale to a surface\n", "func_signal": "void WritePicture2Surface(AVPicture *picture, SDL_Surface *surface, int w, int h)", "code": "{\n    /* AVPicture initialized with PIX_FMT_RGBA only fills pict->data[0]\n     *  This however is only in {R,G,B, A} format. So we just copy the data over. \n     */\n    /* Loop unrolling:\n     * \tWe define a blocksize, and so we increment the index counter by blocksize*rgbstep\n     * \tAll common resolutions are nicely divisible by 8(because 8 is a power of 2...)\n     *  An uncommon resolution  could have between 1 and 7 bytes left to convert... \n     *   which I guess we'll leave alone. Its just 1-2 pixels in the lower right corner.\n     *  So we repeat the same actions blocksize times.  \n     */\n    int64_t   blocksize     = 8;\n    uint32_t *rgb           = surface->pixels;\n    int       BytesPerPixel = RGBSTEP;\n    int64_t   size          = w*h*BytesPerPixel;\n    int64_t   ix            = 0;\n    int64_t   blocklimit    = (size/blocksize)*blocksize;\n    while(ix<blocklimit)\n    {\n        //this will be unrolled by the compiler, meaning that we do less comparisons by a factor of blocksize\n        int i =0;\n        for(;i<blocksize;i++)\n        {\n            jamPixels(ix, picture, rgb, surface);\n            rgb++;\n            ix+=RGBSTEP;\n        }\n    }\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/*\nreturns -2 on memory allocation error, otherwise 0 on success.\n\ninput - the input mask.\nnum_bounding_boxes - returns the number of bounding rects found.\nrects - returns the rects that are found.  Allocates the memory for the rects.\n\n*/\n", "func_signal": "static int get_bounding_rects(bitmask_t *input, int *num_bounding_boxes, GAME_Rect** ret_rects)", "code": "{\n    unsigned int *image, *ufind, *largest, *buf;\n    int x, y, w, h, temp, label, relabel;\n    GAME_Rect* rects;\n\n    rects = NULL;\n    label = 0;\n\n    w = input->w;\n    h = input->h;\n\n    /* a temporary image to assign labels to each bit of the mask */\n    image = (unsigned int *) malloc(sizeof(int)*w*h);\n    if(!image) { return -2; }\n\n    /* allocate enough space for the maximum possible connected components */\n    /* the union-find array. see wikipedia for info on union find */\n    ufind = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!ufind) { return -2; }\n\n    largest = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!largest) { return -2; }\n\n\n    /* do the initial labelling */\n    label = cc_label(input, image, ufind, largest);\n\n    relabel = 0;\n    /* flatten and relabel the union-find equivalence array.  Start at label 1\n       because label 0 indicates an unset pixel.  For this reason, we also use\n       <= label rather than < label. */\n    for (x = 1; x <= label; x++) {\n         if (ufind[x] < x) {             /* is it a union find root? */\n             ufind[x] = ufind[ufind[x]]; /* relabel it to its root */\n         } else {                 /* its a root */\n             relabel++;\n             ufind[x] = relabel;  /* assign the lowest label available */\n         }\n    }\n\n    *num_bounding_boxes = relabel;\n\n    if (relabel == 0) {\n    /* early out, as we didn't find anything. */\n        free(image);\n        free(ufind);\n        free(largest);\n        *ret_rects = rects;\n        return 0;\n    }\n\n    /* the bounding rects, need enough space for the number of labels */\n    rects = (GAME_Rect *) malloc(sizeof(GAME_Rect) * (relabel +1));\n    if(!rects) { return -2; }\n\n    for (temp = 0; temp <= relabel; temp++) {\n        rects[temp].h = 0;        /* so we know if its a new rect or not */\n    }\n\n    /* find the bounding rect of each connected component */\n    buf = image;\n    for (y = 0; y < h; y++) {\n        for (x = 0; x < w; x++) {\n            if (ufind[*buf]) {         /* if the pixel is part of a component */\n                if (rects[ufind[*buf]].h) {   /* the component has a rect */\n                    temp = rects[ufind[*buf]].x;\n                    rects[ufind[*buf]].x = MIN(x, temp);\n                    rects[ufind[*buf]].y = MIN(y, rects[ufind[*buf]].y);\n                    rects[ufind[*buf]].w = MAX(rects[ufind[*buf]].w + temp, x + 1) - rects[ufind[*buf]].x;\n                    rects[ufind[*buf]].h = MAX(rects[ufind[*buf]].h, y - rects[ufind[*buf]].y + 1);\n                } else {                      /* otherwise, start the rect */\n                    rects[ufind[*buf]].x = x;\n                    rects[ufind[*buf]].y = y;\n                    rects[ufind[*buf]].w = 1;\n                    rects[ufind[*buf]].h = 1;\n                }\n            }\n            buf++;\n        }\n    }\n\n    free(image);\n    free(ufind);\n    free(largest);\n    *ret_rects = rects;\n\n    return 0;\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* mouse module functions */\n", "func_signal": "static PyObject*\nmouse_set_pos (PyObject* self, PyObject* args)", "code": "{\n    int x, y;\n\n    if (!TwoIntsFromObj (args, &x, &y))\n        return RAISE (PyExc_TypeError, \"invalid position argument for set_pos\");\n\n    VIDEO_INIT_CHECK ();\n\n    SDL_WarpMouse ((Uint16)x, (Uint16)y);\n    Py_RETURN_NONE;\n}", "path": "src\\mouse.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* return < 0 if aborted, 0 if no packet and > 0 if packet.  */\n", "func_signal": "int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block)", "code": "{\n    AVPacketList *pkt1;\n    int ret;\n\n    if(q->mutex)\n        SDL_LockMutex(q->mutex);\n\n    for(;;)\n    {\n        if (q->abort_request)\n        {\n            ret = -1;\n            break;\n        }\n\n        pkt1 = q->first_pkt;\n        if (pkt1)\n        {\n            q->first_pkt = pkt1->next;\n            if (!q->first_pkt)\n                q->last_pkt = NULL;\n            q->nb_packets--;\n            q->size -= pkt1->pkt.size;\n            *pkt = pkt1->pkt;\n            PyMem_Free(pkt1);\n            ret = 1;\n            break;\n        }\n        else if (!block)\n        {\n            ret = 0;\n            break;\n        }\n        else\n        {\n            ret=0;\n            break;\n        }\n    }\n    if(q->mutex)\n        SDL_UnlockMutex(q->mutex);\n\n    return ret;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* get the current video clock value */\n", "func_signal": "double get_video_clock(PyMovie *movie)", "code": "{\n    double delta;\n\n    if (movie->paused)\n    {\n        delta = 0;\n    }\n    else\n    {\n        delta = (av_gettime() - movie->video_current_pts_time) / 1000000.0;\n    }\n    double temp = movie->video_current_pts+delta;\n    return temp;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/*\nreturns the number of connected components.\nreturns -2 on memory allocation error.\nAllocates memory for components.\n\n*/\n", "func_signal": "static int get_connected_components(bitmask_t *mask, bitmask_t ***components, int min)", "code": "{\n    unsigned int *image, *ufind, *largest, *buf;\n    int x, y, w, h, label, relabel;\n    bitmask_t** comps;\n\n    label = 0;\n\n    w = mask->w;\n    h = mask->h;\n\n    /* a temporary image to assign labels to each bit of the mask */\n    image = (unsigned int *) malloc(sizeof(int)*w*h);\n    if(!image) { return -2; }\n\n    /* allocate enough space for the maximum possible connected components */\n    /* the union-find array. see wikipedia for info on union find */\n    ufind = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!ufind) { \n        free(image);\n        return -2; \n    }\n\n    largest = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!largest) { \n        free(image);\n        free(ufind);\n        return -2; \n    }\n\n    /* do the initial labelling */\n    label = cc_label(mask, image, ufind, largest);\n\n    for (x = 1; x <= label; x++) {\n        if (ufind[x] < x) {\n            largest[ufind[x]] += largest[x];\n        }\n    }\n\n    relabel = 0;\n    /* flatten and relabel the union-find equivalence array.  Start at label 1\n       because label 0 indicates an unset pixel.  For this reason, we also use\n       <= label rather than < label. */\n    for (x = 1; x <= label; x++) {\n        if (ufind[x] < x) {             /* is it a union find root? */\n            ufind[x] = ufind[ufind[x]]; /* relabel it to its root */\n        } else {                 /* its a root */\n            if (largest[x] >= min) {\n                relabel++;\n                ufind[x] = relabel;  /* assign the lowest label available */\n            } else {\n                ufind[x] = 0;\n            }\n        }\n    }\n\n    if (relabel == 0) {\n    /* early out, as we didn't find anything. */\n        free(image);\n        free(ufind);\n        free(largest);\n        return 0;\n    }\n\n    /* allocate space for the mask array */\n    comps = (bitmask_t **) malloc(sizeof(bitmask_t *) * (relabel +1));\n    if(!comps) { \n        free(image);\n        free(ufind);\n        free(largest);\n        return -2; \n    }\n\n    /* create the empty masks */\n    for (x = 1; x <= relabel; x++) {\n        comps[x] = bitmask_create(w, h);\n    }\n\n    /* set the bits in each mask */\n    buf = image;\n    for (y = 0; y < h; y++) {\n        for (x = 0; x < w; x++) {\n            if (ufind[*buf]) {         /* if the pixel is part of a component */\n                bitmask_setbit(comps[ufind[*buf]], x, y);\n            }\n            buf++;\n        }\n    }\n\n    free(image);\n    free(ufind);\n    free(largest);\n\n    *components = comps;\n\n    return relabel;\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/*\nreturns -2 on memory allocation error.\n*/\n", "func_signal": "static int largest_connected_comp(bitmask_t* input, bitmask_t* output, int ccx, int ccy)", "code": "{\n    unsigned int *image, *ufind, *largest, *buf;\n    unsigned int max, x, y, w, h, label;\n\n    w = input->w;\n    h = input->h;\n\n    /* a temporary image to assign labels to each bit of the mask */\n    image = (unsigned int *) malloc(sizeof(int)*w*h);\n    if(!image) { return -2; }\n    /* allocate enough space for the maximum possible connected components */\n    /* the union-find array. see wikipedia for info on union find */\n    ufind = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!ufind) {\n        free(image);\n        return -2;\n    }\n    /* an array to track the number of pixels associated with each label */\n    largest = (unsigned int *) malloc(sizeof(int)*(w/2 + 1)*(h/2 + 1));\n    if(!largest) {\n        free(image);\n        free(ufind);\n        return -2;\n    }\n\n    /* do the initial labelling */\n    label = cc_label(input, image, ufind, largest);\n\n    max = 1;\n    /* flatten the union-find equivalence array */\n    for (x = 2; x <= label; x++) {\n         if (ufind[x] != x) {                 /* is it a union find root? */\n             largest[ufind[x]] += largest[x]; /* add its pixels to its root */\n             ufind[x] = ufind[ufind[x]];      /* relabel it to its root */\n         }\n         if (largest[ufind[x]] > largest[max]) { /* is it the new biggest? */\n             max = ufind[x];\n         }\n    }\n\n    /* write out the final image */\n    buf = image;\n    if (ccx >= 0)\n        max = ufind[*(buf+ccy*w+ccx)];\n    for (y = 0; y < h; y++) {\n        for (x = 0; x < w; x++) {\n            if (ufind[*buf] == max) {         /* if the label is the max one */\n                bitmask_setbit(output, x, y); /* set the bit in the mask */\n            }\n            buf++;\n        }\n    }\n\n    free(image);\n    free(ufind);\n    free(largest);\n\n    return 0;\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* open a given stream. Return 0 if OK */\n", "func_signal": "int stream_component_open(PyMovie *movie, int stream_index, int threaded)", "code": "{\n    DECLAREGIL\n    if(threaded)\n    {\n        GRABGIL\n    }\n    Py_INCREF( movie);\n    if(threaded)\n    {\n        RELEASEGIL\n    }\n\n    AVFormatContext *ic = movie->ic;\n    AVCodecContext *enc;\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n    {\n        if(threaded)\n            {GRABGIL}\n        Py_DECREF(movie);\n        if(threaded)\n            {RELEASEGIL}\n        return -1;\n    }\n\n    initialize_codec(movie, stream_index, threaded);\n\n    enc = ic->streams[stream_index]->codec;\n    switch(enc->codec_type)\n    {\n    case CODEC_TYPE_AUDIO:\n        movie->audio_stream = stream_index;\n        movie->audio_st = ic->streams[stream_index];\n        break;\n    case CODEC_TYPE_VIDEO:\n        movie->video_stream = stream_index;\n        movie->video_st = ic->streams[stream_index];\n        break;\n#if 0\n\n    case CODEC_TYPE_SUBTITLE:\n        movie->sub_stream = stream_index;\n        movie->sub_st     = ic->streams[stream_index];\n#endif\n\n    default:\n        break;\n    }\n    if(threaded)\n    {\n        GRABGIL\n    }\n    Py_DECREF( movie);\n    if(threaded)\n    {\n        RELEASEGIL\n    }\n    return 0;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* get the current external clock value */\n", "func_signal": "double get_external_clock(PyMovie *movie)", "code": "{\n    int64_t ti;\n    ti = av_gettime();\n    double res = movie->external_clock + ((ti - movie->external_clock_time) * 1e-6);\n    return res;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* packet queue handling */\n", "func_signal": "void packet_queue_init(PacketQueue *q)", "code": "{\n    if(!q)\n    {\n        q=(PacketQueue *)PyMem_Malloc(sizeof(PacketQueue));\n    }\n    if(!q->mutex)\n        q->mutex = SDL_CreateMutex();\n    q->abort_request=0;\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* seek in the stream */\n", "func_signal": "void stream_seek(PyMovie *movie, int64_t pos, int rel)", "code": "{\n    ALLOC_COMMAND(seekCommand, seek)\n    seek->pos = pos;\n    seek->rel = rel;\n    addCommand(movie->commands, (Command *)seek);\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/*mask object internals*/\n", "func_signal": "static void mask_dealloc(PyObject* self)", "code": "{\n    bitmask_t *mask = PyMask_AsBitmap(self);\n    bitmask_free(mask);\n    PyObject_DEL(self);\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* the initial labelling phase of the connected components algorithm\n\nReturns: The highest label in the labelled image\n\ninput - The input Mask\nimage - An array to store labelled pixels\nufind - The union-find label equivalence array\nlargest - An array to store the number of pixels for each label\n\n*/\n", "func_signal": "unsigned int cc_label(bitmask_t *input, unsigned int* image, unsigned int* ufind, unsigned int* largest)", "code": "{\n    unsigned int *buf;\n    unsigned int x, y, w, h, root, aroot, croot, temp, label;\n\n    label = 0;\n    w = input->w;\n    h = input->h;\n\n    ufind[0] = 0;\n    buf = image;\n\n    /* special case for first pixel */\n    if(bitmask_getbit(input, 0, 0)) { /* process for a new connected comp: */\n        label++;              /* create a new label */\n        *buf = label;         /* give the pixel the label */\n        ufind[label] = label; /* put the label in the equivalence array */\n        largest[label] = 1;   /* the label has 1 pixel associated with it */\n    } else {\n        *buf = 0;\n    }\n    buf++;\n\n\n\n    /* special case for first row.\n           Go over the first row except the first pixel.\n    */\n    for(x = 1; x < w; x++) {\n        if (bitmask_getbit(input, x, 0)) {\n            if (*(buf-1)) {                    /* d label */\n                *buf = *(buf-1);\n            } else {                           /* create label */\n                label++;\n                *buf = label;\n                ufind[label] = label;\n                largest[label] = 0;\n            }\n            largest[*buf]++;\n        } else {\n            *buf = 0;\n        }\n        buf++;\n    }\n\n\n\n    /* the rest of the image */\n    for(y = 1; y < h; y++) {\n        /* first pixel of the row */\n        if (bitmask_getbit(input, 0, y)) {\n            if (*(buf-w)) {                    /* b label */\n                *buf = *(buf-w);\n            } else if (*(buf-w+1)) {           /* c label */\n                *buf = *(buf-w+1);\n            } else {                           /* create label */\n                label++;\n                *buf = label;\n                ufind[label] = label;\n                largest[label] = 0;\n            }\n            largest[*buf]++;\n        } else {\n            *buf = 0;\n        }\n        buf++;\n        /* middle pixels of the row */\n        for(x = 1; x < (w-1); x++) {\n            if (bitmask_getbit(input, x, y)) {\n                if (*(buf-w)) {                /* b label */\n                    *buf = *(buf-w);\n                } else if (*(buf-w+1)) {       /* c branch of tree */\n                    if (*(buf-w-1)) {                      /* union(c, a) */\n                        croot = root = *(buf-w+1);\n                        while (ufind[root] < root) {       /* find root */\n                            root = ufind[root];\n                        }\n                        if (croot != *(buf-w-1)) {\n                            temp = aroot = *(buf-w-1);\n                            while (ufind[aroot] < aroot) { /* find root */\n                                aroot = ufind[aroot];\n                            }\n                            if (root > aroot) {\n                                root = aroot;\n                            }\n                            while (ufind[temp] > root) {   /* set root */\n                                aroot = ufind[temp];\n                                ufind[temp] = root;\n                                temp = aroot;\n                            }\n                        }\n                        while (ufind[croot] > root) {      /* set root */\n                            temp = ufind[croot];\n                            ufind[croot] = root;\n                            croot = temp;\n                        }\n                        *buf = root;\n                    } else if (*(buf-1)) {                 /* union(c, d) */\n                        croot = root = *(buf-w+1);\n                        while (ufind[root] < root) {       /* find root */\n                            root = ufind[root];\n                        }\n                        if (croot != *(buf-1)) {\n                            temp = aroot = *(buf-1);\n                            while (ufind[aroot] < aroot) { /* find root */\n                                aroot = ufind[aroot];\n                            }\n                            if (root > aroot) {\n                                root = aroot;\n                            }\n                            while (ufind[temp] > root) {   /* set root */\n                                aroot = ufind[temp];\n                                ufind[temp] = root;\n                                temp = aroot;\n                            }\n                        }\n                        while (ufind[croot] > root) {      /* set root */\n                            temp = ufind[croot];\n                            ufind[croot] = root;\n                            croot = temp;\n                        }\n                        *buf = root;\n                    } else {                   /* c label */\n                        *buf = *(buf-w+1);\n                    }\n                } else if (*(buf-w-1)) {       /* a label */\n                    *buf = *(buf-w-1);\n                } else if (*(buf-1)) {         /* d label */\n                    *buf = *(buf-1);\n                } else {                       /* create label */\n                    label++;\n                    *buf = label;\n                    ufind[label] = label;\n                    largest[label] = 0;\n                }\n                largest[*buf]++;\n            } else {\n                *buf = 0;\n            }\n            buf++;\n        }\n        /* last pixel of the row, if its not also the first pixel of the row */\n        if (w > 1) {\n            if (bitmask_getbit(input, x, y)) {\n                if (*(buf-w)) {                /* b label */\n                    *buf = *(buf-w);\n                } else if (*(buf-w-1)) {       /* a label */\n                    *buf = *(buf-w-1);\n                } else if (*(buf-1)) {         /* d label */\n                    *buf = *(buf-1);\n                } else {                       /* create label */\n                    label++;\n                    *buf = label;\n                    ufind[label] = label;\n                    largest[label] = 0;\n                }\n                largest[*buf]++;\n            } else {\n                *buf = 0;\n            }\n            buf++;\n        }\n    }\n\n    return label;\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* Sets the value of the variable height. Acts like a macro */\n", "func_signal": "void inline get_height(PyMovie *movie, int *height)", "code": "{\n    if(movie->resize_h)\n    {\n        *height=movie->height;\n    }\n    else\n    {\n        if(movie->video_st)\n            *height=movie->video_st->codec->height;\n    }\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* mask object methods */\n", "func_signal": "static PyObject* mask_get_size(PyObject* self, PyObject* args)", "code": "{\n    bitmask_t *mask = PyMask_AsBitmap(self);\n\n    if(!PyArg_ParseTuple(args, \"\"))\n        return NULL;\n\n    return Py_BuildValue(\"(ii)\", mask->w, mask->h);\n}", "path": "src\\mask.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/* called to determine a time to show each frame */\n", "func_signal": "void video_refresh_timer(PyMovie* movie)", "code": "{\n    DECLAREGIL\n    double actual_delay, delay, sync_threshold, ref_clock, diff;\n    VidPicture *vp;\n\n    double cur_time=av_gettime();\n\n    if (movie->video_st)\n    { /*shouldn't ever even get this far if no video_st*/\n        movie->diff_co ++;\n\n        /* dequeue the picture */\n        vp = &movie->pictq[movie->pictq_rindex];\n\n        /* update current video pts */\n        movie->video_current_pts = vp->pts;\n        movie->video_current_pts_time = cur_time;\n\n        /* compute nominal delay */\n        delay = movie->video_current_pts - movie->frame_last_pts;\n        if (delay <= 0 || delay >= 10.0)\n        {\n            /* if incorrect delay, use previous one */\n            delay = movie->frame_last_delay;\n        }\n        else\n        {\n            movie->frame_last_delay = delay;\n        }\n        movie->frame_last_pts = movie->video_current_pts;\n\n        /* update delay to follow master synchronisation source */\n        if (((movie->av_sync_type == AV_SYNC_AUDIO_MASTER && movie->audio_st) ||\n                movie->av_sync_type == AV_SYNC_EXTERNAL_CLOCK))\n        {\n            /* if video is slave, we try to correct big delays by\n               duplicating or deleting a frame */\n            ref_clock = getAudioClock();\n            diff = movie->video_current_pts - ref_clock;\n            /* skip or repeat frame. We take into account the\n               delay to compute the threshold. I still don't know\n               if it is the best guess */\n\n            sync_threshold = FFMAX(AV_SYNC_THRESHOLD, delay);\n            if (fabs(diff) < AV_NOSYNC_THRESHOLD)\n            {\n                if (diff <= -sync_threshold)\n                {\n                    movie->skip_frame=1;\n                    delay = 0;\n                }\n                else if (diff >= sync_threshold)\n                    delay = 2 * delay;\n            }\n        }\n\n        movie->frame_timer += delay;\n        /* compute the REAL delay (we need to do that to avoid\n           long term errors */\n        actual_delay = movie->frame_timer - (cur_time / 1000000.0);\n        if (actual_delay < 0.010)\n        {\n            /* XXX: should skip picture */\n            actual_delay = 0.010;\n        }\n\n        GRABGIL\n        //PySys_WriteStdout(\"Actual Delay: %f\\tdelay: %f\\tdiff: %f\\tpts: %f\\tFrame-timer: %f\\tCurrent_time: %f\\tsync_thres: %f\\n\", (actual_delay*1000.0)+10, delay, diff, movie->video_current_pts, movie->frame_timer, (cur_time / 1000000.0), sync_threshold);\n        //double audio = getAudioClock();\n        //PySys_WriteStdout(\"Audio_Clock: %f\\tVideo_Clock: %f\\tDiff: %f\\n\", ref_clock, movie->video_current_pts, ref_clock-movie->video_current_pts);\n        movie->timing = (actual_delay*1000.0)+10;\n        RELEASEGIL\n    }\n\n}", "path": "src\\_gmovie.c", "repo_name": "atizo/pygame", "stars": 21, "license": "None", "language": "c", "size": 3028}
{"docstring": "/*\n * Set breakpoint.\n */\n", "func_signal": "int\nptrace_set_bpt(struct task_struct * child)", "code": "{\n\tint displ, i, res, reg_b, nsaved = 0;\n\tunsigned int insn, op_code;\n\tunsigned long pc;\n\n\tpc  = get_reg(child, REG_PC);\n\tres = read_int(child, pc, (int *) &insn);\n\tif (res < 0)\n\t\treturn res;\n\n\top_code = insn >> 26;\n\tif (op_code >= 0x30) {\n\t\t/*\n\t\t * It's a branch: instead of trying to figure out\n\t\t * whether the branch will be taken or not, we'll put\n\t\t * a breakpoint at either location.  This is simpler,\n\t\t * more reliable, and probably not a whole lot slower\n\t\t * than the alternative approach of emulating the\n\t\t * branch (emulation can be tricky for fp branches).\n\t\t */\n\t\tdispl = ((s32)(insn << 11)) >> 9;\n\t\ttask_thread_info(child)->bpt_addr[nsaved++] = pc + 4;\n\t\tif (displ)\t\t/* guard against unoptimized code */\n\t\t\ttask_thread_info(child)->bpt_addr[nsaved++]\n\t\t\t  = pc + 4 + displ;\n\t\tDBG(DBG_BPT, (\"execing branch\\n\"));\n\t} else if (op_code == 0x1a) {\n\t\treg_b = (insn >> 16) & 0x1f;\n\t\ttask_thread_info(child)->bpt_addr[nsaved++] = get_reg(child, reg_b);\n\t\tDBG(DBG_BPT, (\"execing jump\\n\"));\n\t} else {\n\t\ttask_thread_info(child)->bpt_addr[nsaved++] = pc + 4;\n\t\tDBG(DBG_BPT, (\"execing normal insn\\n\"));\n\t}\n\n\t/* install breakpoints: */\n\tfor (i = 0; i < nsaved; ++i) {\n\t\tres = read_int(child, task_thread_info(child)->bpt_addr[i],\n\t\t\t       (int *) &insn);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\ttask_thread_info(child)->bpt_insn[i] = insn;\n\t\tDBG(DBG_BPT, (\"    -> next_pc=%lx\\n\",\n\t\t\t      task_thread_info(child)->bpt_addr[i]));\n\t\tres = write_int(child, task_thread_info(child)->bpt_addr[i],\n\t\t\t\tBREAKINST);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\ttask_thread_info(child)->bpt_nsaved = nsaved;\n\treturn 0;\n}", "path": "arch\\alpha\\kernel\\ptrace.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Write function is similar for the four protocols used\n   with only a minor change for usa90 (usa19hs) required */\n", "func_signal": "static int keyspan_write(struct tty_struct *tty,\n\tstruct usb_serial_port *port, const unsigned char *buf, int count)", "code": "{\n\tstruct keyspan_port_private \t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tint\t\t\t\tflip;\n\tint \t\t\t\tleft, todo;\n\tstruct urb\t\t\t*this_urb;\n\tint \t\t\t\terr, maxDataLen, dataOffset;\n\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = p_priv->device_details;\n\n\tif (d_details->msg_format == msg_usa90) {\n\t\tmaxDataLen = 64;\n\t\tdataOffset = 0;\n\t} else {\n\t\tmaxDataLen = 63;\n\t\tdataOffset = 1;\n\t}\n\n\tdbg(\"%s - for port %d (%d chars), flip=%d\",\n\t    __func__, port->number, count, p_priv->out_flip);\n\n\tfor (left = count; left > 0; left -= todo) {\n\t\ttodo = left;\n\t\tif (todo > maxDataLen)\n\t\t\ttodo = maxDataLen;\n\n\t\tflip = p_priv->out_flip;\n\n\t\t/* Check we have a valid urb/endpoint before we use it... */\n\t\tthis_urb = p_priv->out_urbs[flip];\n\t\tif (this_urb == NULL) {\n\t\t\t/* no bulk out, so return 0 bytes written */\n\t\t\tdbg(\"%s - no output urb :(\", __func__);\n\t\t\treturn count;\n\t\t}\n\n\t\tdbg(\"%s - endpoint %d flip %d\",\n\t\t\t__func__, usb_pipeendpoint(this_urb->pipe), flip);\n\n\t\tif (this_urb->status == -EINPROGRESS) {\n\t\t\tif (time_before(jiffies,\n\t\t\t\t\tp_priv->tx_start_time[flip] + 10 * HZ))\n\t\t\t\tbreak;\n\t\t\tusb_unlink_urb(this_urb);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* First byte in buffer is \"last flag\" (except for usa19hx)\n\t\t   - unused so for now so set to zero */\n\t\t((char *)this_urb->transfer_buffer)[0] = 0;\n\n\t\tmemcpy(this_urb->transfer_buffer + dataOffset, buf, todo);\n\t\tbuf += todo;\n\n\t\t/* send the data out the bulk port */\n\t\tthis_urb->transfer_buffer_length = todo + dataOffset;\n\n\t\tthis_urb->dev = port->serial->dev;\n\t\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\t\tif (err != 0)\n\t\t\tdbg(\"usb_submit_urb(write bulk) failed (%d)\", err);\n\t\tp_priv->tx_start_time[flip] = jiffies;\n\n\t\t/* Flip for next time if usa26 or usa28 interface\n\t\t   (not used on usa49) */\n\t\tp_priv->out_flip = (flip + 1) & d_details->outdat_endp_flip;\n\t}\n\n\treturn count - left;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* This is actually called glostat in the Keyspan\n\t   doco */\n", "func_signal": "static void\tusa49_instat_callback(struct urb *urb)", "code": "{\n\tint\t\t\t\t\terr;\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa49_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state;\n\tint status = urb->status;\n\n\tdbg(\"%s\", __func__);\n\n\tserial =  urb->context;\n\n\tif (status) {\n\t\tdbg(\"%s - nonzero status: %x\", __func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length !=\n\t\t\tsizeof(struct keyspan_usa49_portStatusMessage)) {\n\t\tdbg(\"%s - bad length %d\", __func__, urb->actual_length);\n\t\tgoto exit;\n\t}\n\n\t/*dbg(\" %x %x %x %x %x %x %x %x %x %x %x\", __func__,\n\t    data[0], data[1], data[2], data[3], data[4], data[5],\n\t    data[6], data[7], data[8], data[9], data[10]);*/\n\n\t/* Now do something useful with the data */\n\tmsg = (struct keyspan_usa49_portStatusMessage *)data;\n\n\t/* Check port number from message and retrieve private data */\n\tif (msg->portNumber >= serial->num_ports) {\n\t\tdbg(\"%s - Unexpected port number %d\",\n\t\t\t\t\t__func__, msg->portNumber);\n\t\tgoto exit;\n\t}\n\tport = serial->port[msg->portNumber];\n\tp_priv = usb_get_serial_port_data(port);\n\n\t/* Update handshaking pin state information */\n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->cts) ? 1 : 0);\n\tp_priv->dsr_state = ((msg->dsr) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->dcd) ? 1 : 0);\n\tp_priv->ri_state = ((msg->ri) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state) {\n\t\tstruct tty_struct *tty = tty_port_tty_get(&port->port);\n\t\tif (tty && !C_CLOCAL(tty))\n\t\t\ttty_hangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\t/* Resubmit urb so we continue receiving */\n\turb->dev = serial->dev;\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdbg(\"%s - resubmit read urb failed. (%d)\", __func__, err);\nexit:\t;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Allocate and register gendisk structure for device.\n */\n", "func_signal": "int dasd_gendisk_alloc(struct dasd_block *block)", "code": "{\n\tstruct gendisk *gdp;\n\tstruct dasd_device *base;\n\tint len;\n\n\t/* Make sure the minor for this device exists. */\n\tbase = block->base;\n\tif (base->devindex >= DASD_PER_MAJOR)\n\t\treturn -EBUSY;\n\n\tgdp = alloc_disk(1 << DASD_PARTN_BITS);\n\tif (!gdp)\n\t\treturn -ENOMEM;\n\n\t/* Initialize gendisk structure. */\n\tgdp->major = DASD_MAJOR;\n\tgdp->first_minor = base->devindex << DASD_PARTN_BITS;\n\tgdp->fops = &dasd_device_operations;\n\tgdp->driverfs_dev = &base->cdev->dev;\n\n\t/*\n\t * Set device name.\n\t *   dasda - dasdz : 26 devices\n\t *   dasdaa - dasdzz : 676 devices, added up = 702\n\t *   dasdaaa - dasdzzz : 17576 devices, added up = 18278\n\t *   dasdaaaa - dasdzzzz : 456976 devices, added up = 475252\n\t */\n\tlen = sprintf(gdp->disk_name, \"dasd\");\n\tif (base->devindex > 25) {\n\t\tif (base->devindex > 701) {\n\t\t\tif (base->devindex > 18277)\n\t\t\t        len += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t\t\t       'a'+(((base->devindex-18278)\n\t\t\t\t\t\t     /17576)%26));\n\t\t\tlen += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t\t       'a'+(((base->devindex-702)/676)%26));\n\t\t}\n\t\tlen += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t       'a'+(((base->devindex-26)/26)%26));\n\t}\n\tlen += sprintf(gdp->disk_name + len, \"%c\", 'a'+(base->devindex%26));\n\n\tif (base->features & DASD_FEATURE_READONLY ||\n\t    test_bit(DASD_FLAG_DEVICE_RO, &base->flags))\n\t\tset_disk_ro(gdp, 1);\n\tdasd_add_link_to_gendisk(gdp, base);\n\tgdp->queue = block->request_queue;\n\tblock->gdp = gdp;\n\tset_capacity(block->gdp, 0);\n\tadd_disk(block->gdp);\n\treturn 0;\n}", "path": "drivers\\s390\\block\\dasd_genhd.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Functions used by new usb-serial code. */\n", "func_signal": "static int __init keyspan_init(void)", "code": "{\n\tint retval;\n\tretval = usb_serial_register(&keyspan_pre_device);\n\tif (retval)\n\t\tgoto failed_pre_device_register;\n\tretval = usb_serial_register(&keyspan_1port_device);\n\tif (retval)\n\t\tgoto failed_1port_device_register;\n\tretval = usb_serial_register(&keyspan_2port_device);\n\tif (retval)\n\t\tgoto failed_2port_device_register;\n\tretval = usb_serial_register(&keyspan_4port_device);\n\tif (retval)\n\t\tgoto failed_4port_device_register;\n\tretval = usb_register(&keyspan_driver);\n\tif (retval)\n\t\tgoto failed_usb_register;\n\n\tprintk(KERN_INFO KBUILD_MODNAME \": \" DRIVER_VERSION \":\"\n\t       DRIVER_DESC \"\\n\");\n\n\treturn 0;\nfailed_usb_register:\n\tusb_serial_deregister(&keyspan_4port_device);\nfailed_4port_device_register:\n\tusb_serial_deregister(&keyspan_2port_device);\nfailed_2port_device_register:\n\tusb_serial_deregister(&keyspan_1port_device);\nfailed_1port_device_register:\n\tusb_serial_deregister(&keyspan_pre_device);\nfailed_pre_device_register:\n\treturn retval;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Init and deinit driver\n */\n", "func_signal": "static unsigned int __devinit phantom_get_free(void)", "code": "{\n\tunsigned int i;\n\n\tfor (i = 0; i < PHANTOM_MAX_MINORS; i++)\n\t\tif (phantom_devices[i] == 0)\n\t\t\tbreak;\n\n\treturn i;\n}", "path": "drivers\\misc\\phantom.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Write contents of register REGNO in task TASK.\n */\n", "func_signal": "static int\nput_reg(struct task_struct *task, unsigned long regno, unsigned long data)", "code": "{\n\tif (regno == 63) {\n\t\ttask_thread_info(task)->ieee_state\n\t\t  = ((task_thread_info(task)->ieee_state & ~IEEE_SW_MASK)\n\t\t     | (data & IEEE_SW_MASK));\n\t\tdata = (data & FPCR_DYN_MASK) | ieee_swcr_to_fpcr(data);\n\t}\n\t*get_reg_addr(task, regno) = data;\n\treturn 0;\n}", "path": "arch\\alpha\\kernel\\ptrace.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Remove all inodes in the system for a device, delete the\n * partitions and make device unusable by setting its size to zero.\n */\n", "func_signal": "void dasd_destroy_partitions(struct dasd_block *block)", "code": "{\n\t/* The two structs have 168/176 byte on 31/64 bit. */\n\tstruct blkpg_partition bpart;\n\tstruct blkpg_ioctl_arg barg;\n\tstruct block_device *bdev;\n\n\t/*\n\t * Get the bdev pointer from the device structure and clear\n\t * device->bdev to lower the offline open_count limit again.\n\t */\n\tbdev = block->bdev;\n\tblock->bdev = NULL;\n\n\t/*\n\t * See fs/partition/check.c:delete_partition\n\t * Can't call delete_partitions directly. Use ioctl.\n\t * The ioctl also does locking and invalidation.\n\t */\n\tmemset(&bpart, 0, sizeof(struct blkpg_partition));\n\tmemset(&barg, 0, sizeof(struct blkpg_ioctl_arg));\n\tbarg.data = (void __force __user *) &bpart;\n\tbarg.op = BLKPG_DEL_PARTITION;\n\tfor (bpart.pno = block->gdp->minors - 1; bpart.pno > 0; bpart.pno--)\n\t\tioctl_by_bdev(bdev, BLKPG, (unsigned long) &barg);\n\n\tinvalidate_partition(block->gdp, 0);\n\t/* Matching blkdev_put to the blkdev_get in dasd_scan_partitions. */\n\tblkdev_put(bdev, FMODE_READ);\n\tset_capacity(block->gdp, 0);\n}", "path": "drivers\\s390\\block\\dasd_genhd.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* USA-28 supports different maximum baud rates on each port */\n", "func_signal": "static int keyspan_usa28_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t    u8 *rate_low, u8 *prescaler, int portnum)", "code": "{\n\tu32 \tb16,\t/* baud rate times 16 (actual rate used internally) */\n\t\tdiv,\t/* divisor */\n\t\tcnt;\t/* inverse of divisor (programmed into 8051) */\n\n\tdbg(\"%s - %d.\", __func__, baud_rate);\n\n\t\t/* prevent divide by zero */\n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t/* calculate the divisor and the counter (its inverse) */\n\tdiv = KEYSPAN_USA28_BAUDCLK / b16;\n\tif (div == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\telse\n\t\tcnt = 0 - div;\n\n\t/* check for out of range, based on portnum,\n\t   and return result */\n\tif (portnum == 0) {\n\t\tif (div > 0xffff)\n\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t} else {\n\t\tif (portnum == 1) {\n\t\t\tif (div > 0xff)\n\t\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t\t} else\n\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t}\n\n\t\t/* return the counter values if not NULL\n\t\t   (port 1 will ignore retHi) */\n\tif (rate_low)\n\t\t*rate_low = (u8) (cnt & 0xff);\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((cnt >> 8) & 0xff);\n\tdbg(\"%s - %d OK.\", __func__, baud_rate);\n\treturn KEYSPAN_BAUD_RATE_OK;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Unregister and free gendisk structure for device.\n */\n", "func_signal": "void dasd_gendisk_free(struct dasd_block *block)", "code": "{\n\tif (block->gdp) {\n\t\tdel_gendisk(block->gdp);\n\t\tblock->gdp->queue = NULL;\n\t\tblock->gdp->private_data = NULL;\n\t\tput_disk(block->gdp);\n\t\tblock->gdp = NULL;\n\t}\n}", "path": "drivers\\s390\\block\\dasd_genhd.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Get address of register REGNO in task TASK.\n */\n", "func_signal": "static unsigned long *\nget_reg_addr(struct task_struct * task, unsigned long regno)", "code": "{\n\tunsigned long *addr;\n\n\tif (regno == 30) {\n\t\taddr = &task_thread_info(task)->pcb.usp;\n\t} else if (regno == 65) {\n\t\taddr = &task_thread_info(task)->pcb.unique;\n\t} else if (regno == 31 || regno > 65) {\n\t\tzero = 0;\n\t\taddr = &zero;\n\t} else {\n\t\taddr = task_stack_page(task) + regoff[regno];\n\t}\n\treturn addr;\n}", "path": "arch\\alpha\\kernel\\ptrace.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * File ops\n */\n", "func_signal": "static long phantom_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)", "code": "{\n\tstruct phantom_device *dev = file->private_data;\n\tstruct phm_regs rs;\n\tstruct phm_reg r;\n\tvoid __user *argp = (void __user *)arg;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tswitch (cmd) {\n\tcase PHN_SETREG:\n\tcase PHN_SET_REG:\n\t\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\t\treturn -EFAULT;\n\n\t\tif (r.reg > 7)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (r.reg == PHN_CONTROL && (r.value & PHN_CTL_IRQ) &&\n\t\t\t\tphantom_status(dev, dev->status | PHB_RUNNING)){\n\t\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr_debug(\"phantom: writing %x to %u\\n\", r.value, r.reg);\n\n\t\t/* preserve amp bit (don't allow to change it when in NOT_OH) */\n\t\tif (r.reg == PHN_CONTROL && (dev->status & PHB_NOT_OH)) {\n\t\t\tr.value &= ~PHN_CTL_AMP;\n\t\t\tr.value |= dev->ctl_reg & PHN_CTL_AMP;\n\t\t\tdev->ctl_reg = r.value;\n\t\t}\n\n\t\tiowrite32(r.value, dev->iaddr + r.reg);\n\t\tioread32(dev->iaddr); /* PCI posting */\n\n\t\tif (r.reg == PHN_CONTROL && !(r.value & PHN_CTL_IRQ))\n\t\t\tphantom_status(dev, dev->status & ~PHB_RUNNING);\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tcase PHN_SETREGS:\n\tcase PHN_SET_REGS:\n\t\tif (copy_from_user(&rs, argp, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\n\t\tpr_debug(\"phantom: SRS %u regs %x\\n\", rs.count, rs.mask);\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (dev->status & PHB_NOT_OH)\n\t\t\tmemcpy(&dev->oregs, &rs, sizeof(rs));\n\t\telse {\n\t\t\tu32 m = min(rs.count, 8U);\n\t\t\tfor (i = 0; i < m; i++)\n\t\t\t\tif (rs.mask & BIT(i))\n\t\t\t\t\tiowrite32(rs.values[i], dev->oaddr + i);\n\t\t\tioread32(dev->iaddr); /* PCI posting */\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tcase PHN_GETREG:\n\tcase PHN_GET_REG:\n\t\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\t\treturn -EFAULT;\n\n\t\tif (r.reg > 7)\n\t\t\treturn -EINVAL;\n\n\t\tr.value = ioread32(dev->iaddr + r.reg);\n\n\t\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase PHN_GETREGS:\n\tcase PHN_GET_REGS: {\n\t\tu32 m;\n\n\t\tif (copy_from_user(&rs, argp, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\n\t\tm = min(rs.count, 8U);\n\n\t\tpr_debug(\"phantom: GRS %u regs %x\\n\", rs.count, rs.mask);\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tif (rs.mask & BIT(i))\n\t\t\t\trs.values[i] = ioread32(dev->iaddr + i);\n\t\tatomic_set(&dev->counter, 0);\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\n\t\tif (copy_to_user(argp, &rs, sizeof(rs)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t} case PHN_NOT_OH:\n\t\tspin_lock_irqsave(&dev->regs_lock, flags);\n\t\tif (dev->status & PHB_RUNNING) {\n\t\t\tprintk(KERN_ERR \"phantom: you need to set NOT_OH \"\n\t\t\t\t\t\"before you start the device!\\n\");\n\t\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev->status |= PHB_NOT_OH;\n\t\tspin_unlock_irqrestore(&dev->regs_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}", "path": "drivers\\misc\\phantom.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Status messages from the 28xg */\n", "func_signal": "static void\tusa67_instat_callback(struct urb *urb)", "code": "{\n\tint\t\t\t\t\terr;\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa67_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state;\n\tint status = urb->status;\n\n\tdbg(\"%s\", __func__);\n\n\tserial = urb->context;\n\n\tif (status) {\n\t\tdbg(\"%s - nonzero status: %x\", __func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length !=\n\t\t\tsizeof(struct keyspan_usa67_portStatusMessage)) {\n\t\tdbg(\"%s - bad length %d\", __func__, urb->actual_length);\n\t\treturn;\n\t}\n\n\n\t/* Now do something useful with the data */\n\tmsg = (struct keyspan_usa67_portStatusMessage *)data;\n\n\t/* Check port number from message and retrieve private data */\n\tif (msg->port >= serial->num_ports) {\n\t\tdbg(\"%s - Unexpected port number %d\", __func__, msg->port);\n\t\treturn;\n\t}\n\n\tport = serial->port[msg->port];\n\tp_priv = usb_get_serial_port_data(port);\n\n\t/* Update handshaking pin state information */\n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->hskia_cts) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->gpia_dcd) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state) {\n\t\tstruct tty_struct *tty = tty_port_tty_get(&port->port);\n\t\tif (tty && !C_CLOCAL(tty))\n\t\t\ttty_hangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\t/* Resubmit urb so we continue receiving */\n\turb->dev = serial->dev;\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdbg(\"%s - resubmit read urb failed. (%d)\", __func__, err);\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* usa19hs function doesn't require prescaler */\n", "func_signal": "static int keyspan_usa19hs_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t   u8 *rate_low, u8 *prescaler, int portnum)", "code": "{\n\tu32 \tb16,\t/* baud rate times 16 (actual rate used internally) */\n\t\t\tdiv;\t/* divisor */\n\n\tdbg(\"%s - %d.\", __func__, baud_rate);\n\n\t/* prevent divide by zero...  */\n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t/* calculate the divisor */\n\tdiv = baudclk / b16;\n\tif (div == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\tif (div > 0xffff)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t/* return the counter values if non-null */\n\tif (rate_low)\n\t\t*rate_low = (u8) (div & 0xff);\n\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((div >> 8) & 0xff);\n\n\tif (rate_low && rate_hi)\n\t\tdbg(\"%s - %d %02x %02x.\",\n\t\t\t__func__, baud_rate, *rate_hi, *rate_low);\n\n\treturn KEYSPAN_BAUD_RATE_OK;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Outdat handling is common for all devices */\n", "func_signal": "static void\tusa2x_outdat_callback(struct urb *urb)", "code": "{\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\tdbg(\"%s - urb %d\", __func__, urb == p_priv->out_urbs[1]);\n\n\tusb_serial_port_softint(port);\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Helper functions used by keyspan_setup_urbs */\n", "func_signal": "static struct usb_endpoint_descriptor const *find_ep(struct usb_serial const *serial,\n\t\t\t\t\t\t     int endpoint)", "code": "{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *ep;\n\tint i;\n\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tep = &iface_desc->endpoint[i].desc;\n\t\tif (ep->bEndpointAddress == endpoint)\n\t\t\treturn ep;\n\t}\n\tdev_warn(&serial->interface->dev, \"found no endpoint descriptor for \"\n\t\t \"endpoint %x\\n\", endpoint);\n\treturn NULL;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* download the firmware to a pre-renumeration device */\n", "func_signal": "static int keyspan_fake_startup(struct usb_serial *serial)", "code": "{\n\tint \t\t\t\tresponse;\n\tconst struct ihex_binrec \t*record;\n\tchar\t\t\t\t*fw_name;\n\tconst struct firmware\t\t*fw;\n\n\tdbg(\"Keyspan startup version %04x product %04x\",\n\t    le16_to_cpu(serial->dev->descriptor.bcdDevice),\n\t    le16_to_cpu(serial->dev->descriptor.idProduct));\n\n\tif ((le16_to_cpu(serial->dev->descriptor.bcdDevice) & 0x8000)\n\t\t\t\t\t\t\t\t!= 0x8000) {\n\t\tdbg(\"Firmware already loaded.  Quitting.\");\n\t\treturn 1;\n\t}\n\n\t\t/* Select firmware image on the basis of idProduct */\n\tswitch (le16_to_cpu(serial->dev->descriptor.idProduct)) {\n\tcase keyspan_usa28_pre_product_id:\n\t\tfw_name = \"keyspan/usa28.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28x_pre_product_id:\n\t\tfw_name = \"keyspan/usa28x.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28xa_pre_product_id:\n\t\tfw_name = \"keyspan/usa28xa.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28xb_pre_product_id:\n\t\tfw_name = \"keyspan/usa28xb.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19_pre_product_id:\n\t\tfw_name = \"keyspan/usa19.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19qi_pre_product_id:\n\t\tfw_name = \"keyspan/usa19qi.fw\";\n\t\tbreak;\n\n\tcase keyspan_mpr_pre_product_id:\n\t\tfw_name = \"keyspan/mpr.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19qw_pre_product_id:\n\t\tfw_name = \"keyspan/usa19qw.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa18x_pre_product_id:\n\t\tfw_name = \"keyspan/usa18x.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19w_pre_product_id:\n\t\tfw_name = \"keyspan/usa19w.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa49w_pre_product_id:\n\t\tfw_name = \"keyspan/usa49w.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa49wlc_pre_product_id:\n\t\tfw_name = \"keyspan/usa49wlc.fw\";\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&serial->dev->dev, \"Unknown product ID (%04x)\\n\",\n\t\t\tle16_to_cpu(serial->dev->descriptor.idProduct));\n\t\treturn 1;\n\t}\n\n\tif (request_ihex_firmware(&fw, fw_name, &serial->dev->dev)) {\n\t\tdev_err(&serial->dev->dev, \"Required keyspan firmware image (%s) unavailable.\\n\", fw_name);\n\t\treturn(1);\n\t}\n\n\tdbg(\"Uploading Keyspan %s firmware.\", fw_name);\n\n\t\t/* download the firmware image */\n\tresponse = ezusb_set_reset(serial, 1);\n\n\trecord = (const struct ihex_binrec *)fw->data;\n\n\twhile (record) {\n\t\tresponse = ezusb_writememory(serial, be32_to_cpu(record->addr),\n\t\t\t\t\t     (unsigned char *)record->data,\n\t\t\t\t\t     be16_to_cpu(record->len), 0xa0);\n\t\tif (response < 0) {\n\t\t\tdev_err(&serial->dev->dev, \"ezusb_writememory failed for Keyspan firmware (%d %04X %p %d)\\n\",\n\t\t\t\tresponse, be32_to_cpu(record->addr),\n\t\t\t\trecord->data, be16_to_cpu(record->len));\n\t\t\tbreak;\n\t\t}\n\t\trecord = ihex_next_binrec(record);\n\t}\n\trelease_firmware(fw);\n\t\t/* bring device out of reset. Renumeration will occur in a\n\t\t   moment and the new device will bind to the real driver */\n\tresponse = ezusb_set_reset(serial, 0);\n\n\t/* we don't want this device to have a driver assigned to it. */\n\treturn 1;\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Get contents of register REGNO in task TASK.\n */\n", "func_signal": "static unsigned long\nget_reg(struct task_struct * task, unsigned long regno)", "code": "{\n\t/* Special hack for fpcr -- combine hardware and software bits.  */\n\tif (regno == 63) {\n\t\tunsigned long fpcr = *get_reg_addr(task, regno);\n\t\tunsigned long swcr\n\t\t  = task_thread_info(task)->ieee_state & IEEE_SW_MASK;\n\t\tswcr = swcr_update_status(swcr, fpcr);\n\t\treturn fpcr | swcr;\n\t}\n\treturn *get_reg_addr(task, regno);\n}", "path": "arch\\alpha\\kernel\\ptrace.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/* Generic setup urbs function that uses\n\t   data in device_details */\n", "func_signal": "static void keyspan_setup_urbs(struct usb_serial *serial)", "code": "{\n\tint\t\t\t\ti, j;\n\tstruct keyspan_serial_private \t*s_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct usb_serial_port\t\t*port;\n\tstruct keyspan_port_private\t*p_priv;\n\tstruct callbacks\t\t*cback;\n\tint\t\t\t\tendp;\n\n\tdbg(\"%s\", __func__);\n\n\ts_priv = usb_get_serial_data(serial);\n\td_details = s_priv->device_details;\n\n\t/* Setup values for the various callback routines */\n\tcback = &keyspan_callbacks[d_details->msg_format];\n\n\t/* Allocate and set up urbs for each one that is in use,\n\t   starting with instat endpoints */\n\ts_priv->instat_urb = keyspan_setup_urb\n\t\t(serial, d_details->instat_endpoint, USB_DIR_IN,\n\t\t serial, s_priv->instat_buf, INSTAT_BUFLEN,\n\t\t cback->instat_callback);\n\n\ts_priv->indat_urb = keyspan_setup_urb\n\t\t(serial, d_details->indat_endpoint, USB_DIR_IN,\n\t\t serial, s_priv->indat_buf, INDAT49W_BUFLEN,\n\t\t usa49wg_indat_callback);\n\n\ts_priv->glocont_urb = keyspan_setup_urb\n\t\t(serial, d_details->glocont_endpoint, USB_DIR_OUT,\n\t\t serial, s_priv->glocont_buf, GLOCONT_BUFLEN,\n\t\t cback->glocont_callback);\n\n\t/* Setup endpoints for each port specific thing */\n\tfor (i = 0; i < d_details->num_ports; i++) {\n\t\tport = serial->port[i];\n\t\tp_priv = usb_get_serial_port_data(port);\n\n\t\t/* Do indat endpoints first, once for each flip */\n\t\tendp = d_details->indat_endpoints[i];\n\t\tfor (j = 0; j <= d_details->indat_endp_flip; ++j, ++endp) {\n\t\t\tp_priv->in_urbs[j] = keyspan_setup_urb\n\t\t\t\t(serial, endp, USB_DIR_IN, port,\n\t\t\t\t p_priv->in_buffer[j], 64,\n\t\t\t\t cback->indat_callback);\n\t\t}\n\t\tfor (; j < 2; ++j)\n\t\t\tp_priv->in_urbs[j] = NULL;\n\n\t\t/* outdat endpoints also have flip */\n\t\tendp = d_details->outdat_endpoints[i];\n\t\tfor (j = 0; j <= d_details->outdat_endp_flip; ++j, ++endp) {\n\t\t\tp_priv->out_urbs[j] = keyspan_setup_urb\n\t\t\t\t(serial, endp, USB_DIR_OUT, port,\n\t\t\t\t p_priv->out_buffer[j], 64,\n\t\t\t\t cback->outdat_callback);\n\t\t}\n\t\tfor (; j < 2; ++j)\n\t\t\tp_priv->out_urbs[j] = NULL;\n\n\t\t/* inack endpoint */\n\t\tp_priv->inack_urb = keyspan_setup_urb\n\t\t\t(serial, d_details->inack_endpoints[i], USB_DIR_IN,\n\t\t\t port, p_priv->inack_buffer, 1, cback->inack_callback);\n\n\t\t/* outcont endpoint */\n\t\tp_priv->outcont_urb = keyspan_setup_urb\n\t\t\t(serial, d_details->outcont_endpoints[i], USB_DIR_OUT,\n\t\t\t port, p_priv->outcont_buffer, 64,\n\t\t\t cback->outcont_callback);\n\t}\n}", "path": "drivers\\usb\\serial\\keyspan.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "/*\n * Trigger a partition detection.\n */\n", "func_signal": "int dasd_scan_partitions(struct dasd_block *block)", "code": "{\n\tstruct block_device *bdev;\n\n\tbdev = bdget_disk(block->gdp, 0);\n\tif (!bdev || blkdev_get(bdev, FMODE_READ, NULL) < 0)\n\t\treturn -ENODEV;\n\t/*\n\t * See fs/partition/check.c:register_disk,rescan_partitions\n\t * Can't call rescan_partitions directly. Use ioctl.\n\t */\n\tioctl_by_bdev(bdev, BLKRRPART, 0);\n\t/*\n\t * Since the matching blkdev_put call to the blkdev_get in\n\t * this function is not called before dasd_destroy_partitions\n\t * the offline open_count limit needs to be increased from\n\t * 0 to 1. This is done by setting device->bdev (see\n\t * dasd_generic_set_offline). As long as the partition\n\t * detection is running no offline should be allowed. That\n\t * is why the assignment to device->bdev is done AFTER\n\t * the BLKRRPART ioctl.\n\t */\n\tblock->bdev = bdev;\n\treturn 0;\n}", "path": "drivers\\s390\\block\\dasd_genhd.c", "repo_name": "myfluxi/xxICSKernel", "stars": 23, "license": "other", "language": "c", "size": 476154}
{"docstring": "// allows out to be the same as in\n", "func_signal": "static void neg128(CFSInt128Struct *out, CFSInt128Struct *in)", "code": "{\n    uint64_t tmplow = ~in->low;\n    out->low = tmplow + 1;\n    out->high = ~in->high;\n    if (UINT64_MAX == tmplow) {\n\tout->high++;\n    }\n}", "path": "CFNumber.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/* BINARY_SUPPORT_DYLD */\n", "func_signal": "static Boolean _CFBundleGrokFileTypeForZipMimeType(const unsigned char *bytes, CFIndex length, const char **ext)", "code": "{\n    unsigned namelength = CFSwapInt16HostToLittle(*((UInt16 *)(bytes + 26))), extralength = CFSwapInt16HostToLittle(*((UInt16 *)(bytes + 28)));\n    const unsigned char *data = bytes + 30 + namelength + extralength;\n    int i = -1;\n    if (bytes < data && data + 56 <= bytes + length && 0 == CFSwapInt16HostToLittle(*((UInt16 *)(bytes + 8))) && (0 == ustrncasecmp(data, \"application/vnd.\", 16) || 0 == ustrncasecmp(data, \"application/x-vnd.\", 18))) {\n        data += ('.' == *(data + 15)) ? 16 : 18;\n        if (0 == ustrncasecmp(data, \"sun.xml.\", 8)) {\n            data += 8;\n            if (0 == ustrncasecmp(data, \"calc\", 4)) i = 0;\n            else if (0 == ustrncasecmp(data, \"draw\", 4)) i = 1;\n            else if (0 == ustrncasecmp(data, \"writer.global\", 13)) i = 2;\n            else if (0 == ustrncasecmp(data, \"impress\", 7)) i = 3;\n            else if (0 == ustrncasecmp(data, \"math\", 4)) i = 4;\n            else if (0 == ustrncasecmp(data, \"writer\", 6)) i = 5;\n            if (i >= 0 && ext) *ext = __CFBundleOOExtensionsArray + i * EXTENSION_LENGTH;\n        } else if (0 == ustrncasecmp(data, \"oasis.opendocument.\", 19)) {\n            data += 19;\n            if (0 == ustrncasecmp(data, \"chart\", 5)) i = 0;\n            else if (0 == ustrncasecmp(data, \"formula\", 7)) i = 1;\n            else if (0 == ustrncasecmp(data, \"graphics\", 8)) i = 2;\n            else if (0 == ustrncasecmp(data, \"text-web\", 8)) i = 3;\n            else if (0 == ustrncasecmp(data, \"image\", 5)) i = 4;\n            else if (0 == ustrncasecmp(data, \"text-master\", 11)) i = 5;\n            else if (0 == ustrncasecmp(data, \"presentation\", 12)) i = 6;\n            else if (0 == ustrncasecmp(data, \"spreadsheet\", 11)) i = 7;\n            else if (0 == ustrncasecmp(data, \"text\", 4)) i = 8;\n            if (i >= 0 && ext) *ext = __CFBundleODExtensionsArray + i * EXTENSION_LENGTH;\n        }\n    } else if (bytes < data && data + 41 <= bytes + length && 8 == CFSwapInt16HostToLittle(*((UInt16 *)(bytes + 8))) && 0x4b2c28c8 == CFSwapInt32HostToBig(*((UInt32 *)data)) && 0xc94c4e2c == CFSwapInt32HostToBig(*((UInt32 *)(data + 4)))) {\n        // AbiWord compressed mimetype odt\n        if (ext) *ext = \"odt\";\n    }\n    return (i >= 0);\n}", "path": "CFBundle.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// Used by NSHashTables/NSMapTables and KVO\n", "func_signal": "void _CFDictionarySetContext(CFHashRef hc, any_pointer_t context)", "code": "{\n    __CFGenericValidateType(hc, __kCFHashTypeID);\n    CF_WRITE_BARRIER_BASE_ASSIGN(__CFGetAllocator(hc), hc, hc->_context, context);\n}", "path": "CFDictionary.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// The function pointers for the allocator context\n", "func_signal": "static void *rmRealloc(void *oPtr, CFIndex size, CFOptionFlags hint, void *actualInfo)", "code": "{\n    rmInfo *info = (rmInfo *)actualInfo;\n    if (isRMBlock(info, oPtr)) {\n\tvoid *ptr;\n        if (size <= info->size) return oPtr;\t// Easy case...\n\tptr = CFAllocatorAllocate(info->allocator, size, hint);\n\tmemmove(ptr, oPtr, info->size);\n\trmMarkBlockAsAvailable(info, rmBlockNumber(info, oPtr));\n\tinfo->numAdditionalAllocations++;\n\treturn ptr;\n    } else {\n\treturn CFAllocatorReallocate(info->allocator, oPtr, size, hint);\n    }\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// Returns info about the number of outstanding allocations\n", "func_signal": "static CFIndex NumOutstandingAllocations(CFAllocatorRef alloc)", "code": "{\n    CFAllocatorContext context;\n    context.version = 0;\n    CFAllocatorGetContext(alloc, &context);\n    return (*(int *)(context.info));\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// This function is used to free the above structure when the allocator is deallocated\n", "func_signal": "void rmInfoFree(const void *actualInfo)", "code": "{\n    rmInfo *info = (rmInfo *)actualInfo;\n    CFAllocatorRef allocator = info->allocator;\n    CFAllocatorDeallocate(allocator, info);\n    CFRelease(allocator);\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/*\n * Copy src to string dst of size siz.  At most siz-1 characters\n * will be copied.  Always NUL terminates (unless siz == 0).\n * Returns strlen(src); if retval >= siz, truncation occurred.\n */\n", "func_signal": "size_t strlcpy(char *dst, const char *src, size_t siz)", "code": "{\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0) {\n        while (--n != 0) {\n            if ((*d++ = *s++) == '\\0')\n                break;\n        }\n    }\n\n    /* Not enough room in dst, add NUL and traverse rest of src */\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\0';\t\t/* NUL-terminate dst */\n        while (*s++)\n            ;\n    }\n\n    return(s - src - 1);\t/* count does not include NUL */\n}", "path": "compat\\strlcpy.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/* BINARY_SUPPORT_DYLD && BINARY_SUPPORT_CFM */\n", "func_signal": "static void _CFBundleAddToTables(CFBundleRef bundle, Boolean alreadyLocked)", "code": "{\n    CFStringRef bundleID = CFBundleGetIdentifier(bundle);\n\n    if (!alreadyLocked) __CFSpinLock(&CFBundleGlobalDataLock);\n    \n    // Add to the _allBundles list\n    if (!_allBundles) {\n        // Create this from the default allocator\n        CFArrayCallBacks nonRetainingArrayCallbacks = kCFTypeArrayCallBacks;\n        nonRetainingArrayCallbacks.retain = NULL;\n        nonRetainingArrayCallbacks.release = NULL;\n        _allBundles = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &nonRetainingArrayCallbacks);\n    }\n    CFArrayAppendValue(_allBundles, bundle);\n    \n    // Add to the table that maps urls to bundles\n    if (!_bundlesByURL) {\n        // Create this from the default allocator\n        CFDictionaryValueCallBacks nonRetainingDictionaryValueCallbacks = kCFTypeDictionaryValueCallBacks;\n        nonRetainingDictionaryValueCallbacks.retain = NULL;\n        nonRetainingDictionaryValueCallbacks.release = NULL;\n        _bundlesByURL = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &nonRetainingDictionaryValueCallbacks);\n    }\n    CFDictionarySetValue(_bundlesByURL, bundle->_url, bundle);\n\n    // Add to the table that maps identifiers to bundles\n    if (bundleID) {\n        CFMutableArrayRef bundlesWithThisID = NULL;\n        CFBundleRef existingBundle = NULL;\n        if (!_bundlesByIdentifier) {\n            // Create this from the default allocator\n            _bundlesByIdentifier = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        }\n        bundlesWithThisID = (CFMutableArrayRef)CFDictionaryGetValue(_bundlesByIdentifier, bundleID);\n        if (bundlesWithThisID) {\n            CFIndex i, count = CFArrayGetCount(bundlesWithThisID);\n            UInt32 existingVersion, newVersion = CFBundleGetVersionNumber(bundle);\n            for (i = 0; i < count; i++) {\n                existingBundle = (CFBundleRef)CFArrayGetValueAtIndex(bundlesWithThisID, i);\n                existingVersion = CFBundleGetVersionNumber(existingBundle);\n                // If you load two bundles with the same identifier and the same version, the last one wins.\n                if (newVersion >= existingVersion) break;\n            }\n            CFArrayInsertValueAtIndex(bundlesWithThisID, i, bundle);\n        } else {\n            // Create this from the default allocator\n            CFArrayCallBacks nonRetainingArrayCallbacks = kCFTypeArrayCallBacks;\n            nonRetainingArrayCallbacks.retain = NULL;\n            nonRetainingArrayCallbacks.release = NULL;\n            bundlesWithThisID = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &nonRetainingArrayCallbacks);\n            CFArrayAppendValue(bundlesWithThisID, bundle);\n            CFDictionarySetValue(_bundlesByIdentifier, bundleID, bundlesWithThisID);\n            CFRelease(bundlesWithThisID);\n        }\n    }\n    if (!alreadyLocked) __CFSpinUnlock(&CFBundleGlobalDataLock);\n}", "path": "CFBundle.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// This function will print the provided arguments (printf style varargs) out to the console.\n// Note that the CFString formatting function accepts \"%@\" as a way to display CF types.\n// For types other than CFString and CFNumber, the result of %@ is mostly for debugging\n// and can differ between releases and different platforms.\n", "func_signal": "void show(CFStringRef formatString, ...)", "code": "{\n    CFStringRef resultString;\n    CFDataRef data;\n    va_list argList;\n\n    va_start(argList, formatString);\n    resultString = CFStringCreateWithFormatAndArguments(NULL, NULL, formatString, argList);\n    va_end(argList);\n\n    data = CFStringCreateExternalRepresentation(NULL, resultString, CFStringGetSystemEncoding(), '?');\n\n    if (data != NULL) {\n    \tprintf (\"%.*s\\n\\n\", (int)CFDataGetLength(data), CFDataGetBytePtr(data));\n    \tCFRelease(data);\n    }\n       \n    CFRelease(resultString);\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// allows out to be the same as in1 or in2\n", "func_signal": "static void add128(CFSInt128Struct *out, CFSInt128Struct *in1, CFSInt128Struct *in2)", "code": "{\n    CFSInt128Struct tmp;\n    tmp.low = in1->low + in2->low;\n    tmp.high = in1->high + in2->high;\n    if (UINT64_MAX - in1->low < in2->low) {\n        tmp.high++;\n    }\n    *out = tmp;\n}", "path": "CFNumber.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// Creates a \"counting allocator\" --- keeps track of number of\n// outstanding allocations and also uses guards to catch out of bound writes\n", "func_signal": "static CFAllocatorRef CreateCountingAllocator(CFAllocatorRef alloc)", "code": "{\n    CFAllocatorContext context = {0, NULL, NULL, (CFAllocatorReleaseCallBack)free, NULL, countingAlloc, countingRealloc, countingDealloc, NULL};\n    context.info = malloc(sizeof(int));\n    // The info field points to an int which keeps number of allocations/deallocations\n    // The \"free\" in slot 3 of the context assures the info field is properly freed when the allocator is\n    *(int *)(context.info) = 0;\n    // Create and return the allocator\n    return CFAllocatorCreate(alloc, &context);\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// This function is for Foundation's benefit; no one else should use it.\n", "func_signal": "void _CFDictionarySetCapacity(CFMutableHashRef hc, CFIndex cap)", "code": "{\n    if (CF_IS_OBJC(__kCFHashTypeID, hc)) return;\n    __CFGenericValidateType(hc, __kCFHashTypeID);\n    CFAssert1(__CFHashGetType(hc) != __kCFHashImmutable, __kCFLogAssertion, \"%s(): collection is immutable\", __PRETTY_FUNCTION__);\n    CFAssert3(hc->_bucketsUsed <= cap, __kCFLogAssertion, \"%s(): desired capacity (%ld) is less than bucket count (%ld)\", __PRETTY_FUNCTION__, cap, hc->_bucketsUsed);\n    __CFDictionaryGrow(hc, cap - hc->_bucketsUsed);\n}", "path": "CFDictionary.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// rounds offset to nearest minute\n", "func_signal": "CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)", "code": "{\n    CFTimeZoneRef result;\n    CFStringRef name;\n    int32_t seconds, minute, hour;\n    if (allocator == NULL) allocator = __CFGetDefaultAllocator();\n    __CFGenericValidateType(allocator, CFAllocatorGetTypeID());\n    if (ti < -18.0 * 3600 || 18.0 * 3600 < ti) return NULL;\n    ti = (ti < 0.0) ? ceil((ti / 60.0) - 0.5) * 60.0 : floor((ti / 60.0) + 0.5) * 60.0;\n    seconds = (int32_t)ti;\n    hour = (ti < 0) ? (-seconds / 3600) : (seconds / 3600);\n    seconds -= ((ti < 0) ? -hour : hour) * 3600;\n    minute = (ti < 0) ? (-seconds / 60) : (seconds / 60);\n    if (fabs(ti) < 1.0) {\n\tname = (CFStringRef)CFRetain(CFSTR(\"GMT\"));\n    } else {\n\tname = CFStringCreateWithFormat(allocator, NULL, CFSTR(\"GMT%c%02d%02d\"), (ti < 0.0 ? '-' : '+'), hour, minute);\n    }\n    result = __CFTimeZoneCreateFixed(allocator, (int32_t)ti, name, 0);\n    CFRelease(name);\n    return result;\n}", "path": "CFTimeZone.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// returns 0.0 if there is no data for the next switch after 'at'\n", "func_signal": "CFAbsoluteTime _CFTimeZoneGetNextDSTSwitch(CFTimeZoneRef tz, CFAbsoluteTime at)", "code": "{\n#if !DEPLOYMENT_TARGET_WINDOWS\n// #warning this does not work for non-CFTimeZoneRefs\n    CFIndex idx;\n    idx = __CFBSearchTZPeriods(tz, at);\n    if (tz->_periodCnt <= idx + 1) {\n        return 0.0;\n    }\n    return (CFAbsoluteTime)__CFTZPeriodStartSeconds(&(tz->_periods[idx + 1]));\n#endif\n    return 0.0;\n}", "path": "CFTimeZone.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// This function will print the provided arguments (printf style varargs) out to the console.\n// Note that the CFString formatting function accepts \"%@\" as a way to display CF types.\n// For types other than CFString and CFNumber, the result of %@ is mostly for debugging\n// and can differ between releases and different platforms.\n", "func_signal": "void show(CFStringRef formatString, ...)", "code": "{\n    CFStringRef resultString;\n    CFDataRef data;\n    va_list argList;\n\n    va_start(argList, formatString);\n    resultString = CFStringCreateWithFormatAndArguments(NULL, NULL, formatString, argList);\n    va_end(argList);\n\n    data = CFStringCreateExternalRepresentation(NULL, resultString, CFStringGetSystemEncoding(), '?');\n\n    if (data != NULL) {\n        printf (\"%.*s\\n\\n\", (int)CFDataGetLength(data), CFDataGetBytePtr(data));\n        CFRelease(data);\n    }\n\n    CFRelease(resultString);\n}", "path": "examples\\StringExample\\StringExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// Now some example code which uses these allocators\n", "func_signal": "void countingAllocatorExample(void)", "code": "{\n\n    CFStringRef str1, str2, str3;\n    CFMutableStringRef mStr;\n\n    CFAllocatorRef countingAllocator;\n\n    show(CFSTR(\"Counting Allocator Test\"));\n\n    countingAllocator = CreateCountingAllocator(NULL);\n\n    show(CFSTR(\"At start, number of allocations: %d\"), NumOutstandingAllocations(countingAllocator));\n\n    str1 = CFStringCreateWithCString(countingAllocator, \"Hello World\", kCFStringEncodingASCII);\n#if defined(__APPLE__)\n    str2 = CFStringCreateWithPascalString(countingAllocator, \"\\pHello World\", kCFStringEncodingASCII);\n#else\n    str2 = CFStringCreateWithCString(countingAllocator, \"Hello World\", kCFStringEncodingASCII);\n#endif\n    mStr = CFStringCreateMutableCopy(countingAllocator, 0, str1);\n    str3 = CFStringCreateCopy(countingAllocator, mStr);\n\n    show(CFSTR(\"After creation, number of allocations: %d\"), NumOutstandingAllocations(countingAllocator));\n\n    CFStringAppend(mStr, str1);\n    CFStringAppend(mStr, str1);\n    CFStringAppend(mStr, str1);\n\n    show(CFSTR(\"After mutations, number of allocations: %d\"), NumOutstandingAllocations(countingAllocator));\n\n    CFRelease(str1);\n    CFRelease(str2);\n    CFRelease(mStr);\n    CFRelease(str3);\n\n    show(CFSTR(\"After releasing, number of allocations: %d\"), NumOutstandingAllocations(countingAllocator));\n\n    CFRelease(countingAllocator);\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/* Although named \"prolog\", for leafs of the tree, this is the only XML generation function called.  This is why Comments, Processing Instructions, etc. generate their XML during this function.  REW, 2/11/2000 */\n", "func_signal": "static void _CFAppendXMLProlog(CFMutableStringRef str, const CFXMLTreeRef tree)", "code": "{\n    switch (CFXMLNodeGetTypeCode(CFXMLTreeGetNode(tree))) {\n        case kCFXMLNodeTypeDocument:\n            break;\n        case kCFXMLNodeTypeElement:\n            appendElementProlog(str, tree);\n            break;\n        case kCFXMLNodeTypeAttribute:\n            // Should never be encountered\n            break;\n        case kCFXMLNodeTypeProcessingInstruction: {\n            CFXMLProcessingInstructionInfo *data = (CFXMLProcessingInstructionInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree));\n            if (data->dataString) {\n                CFStringAppendFormat(str, NULL, CFSTR(\"<?%@ %@?>\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)), data->dataString);\n            } else {\n                CFStringAppendFormat(str, NULL, CFSTR(\"<?%@?>\"));\n            }\n            break;\n        }\n        case kCFXMLNodeTypeComment:\n            CFStringAppendFormat(str, NULL, CFSTR(\"<!--%@-->\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            break;\n        case kCFXMLNodeTypeText:\n            CFStringAppend(str, CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            break;\n        case kCFXMLNodeTypeCDATASection:\n            CFStringAppendFormat(str, NULL, CFSTR(\"<![CDATA[%@]]>\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            break;\n        case kCFXMLNodeTypeDocumentFragment:\n            break;\n        case kCFXMLNodeTypeEntity: {\n            CFXMLEntityInfo *data = (CFXMLEntityInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree));\n            CFStringAppendCString(str, \"<!ENTITY \", kCFStringEncodingASCII);\n            if (data->entityType == kCFXMLEntityTypeParameter) {\n                CFStringAppend(str, CFSTR(\"% \"));\n            }\n            CFStringAppend(str, CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            CFStringAppend(str, CFSTR(\" \"));\n            if (data->replacementText) {\n                appendQuotedString(str, data->replacementText);\n                CFStringAppendCString(str, \">\", kCFStringEncodingASCII);\n            } else {\n                appendExternalID(str, &(data->entityID));\n                if (data->notationName) {\n                    CFStringAppendFormat(str, NULL, CFSTR(\" NDATA %@\"), data->notationName);\n                }\n                CFStringAppendCString(str, \">\", kCFStringEncodingASCII);\n            }\n                break;\n        }\n        case kCFXMLNodeTypeEntityReference:\n        {\n            CFXMLEntityTypeCode entityType = ((CFXMLEntityReferenceInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree)))->entityType;\n            if (entityType == kCFXMLEntityTypeParameter) {\n                CFStringAppendFormat(str, NULL, CFSTR(\"%%%@;\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            } else {\n                CFStringAppendFormat(str, NULL, CFSTR(\"&%@;\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            }\n            break;\n        }\n        case kCFXMLNodeTypeDocumentType:\n            CFStringAppendCString(str, \"<!DOCTYPE \", kCFStringEncodingASCII);\n            CFStringAppend(str, CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            if (CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree))) {\n                CFXMLExternalID *extID = &((CFXMLDocumentTypeInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree)))->externalID;\n                appendExternalID(str, extID);\n            }\n                CFStringAppendCString(str, \" [\", kCFStringEncodingASCII);\n            break;\n        case kCFXMLNodeTypeWhitespace:\n            CFStringAppend(str, CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            break;\n        case kCFXMLNodeTypeNotation: {\n            CFXMLNotationInfo *data = (CFXMLNotationInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree));\n            CFStringAppendFormat(str, NULL, CFSTR(\"<!NOTATION %@ \"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            appendExternalID(str, &(data->externalID));\n                CFStringAppendCString(str, \">\", kCFStringEncodingASCII);\n            break;\n        }\n        case kCFXMLNodeTypeElementTypeDeclaration:\n            CFStringAppendFormat(str, NULL, CFSTR(\"<!ELEMENT %@ %@>\"), CFXMLNodeGetString(CFXMLTreeGetNode(tree)), ((CFXMLElementTypeDeclarationInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree)))->contentDescription);\n            break;\n        case kCFXMLNodeTypeAttributeListDeclaration: {\n            CFXMLAttributeListDeclarationInfo *attListData = (CFXMLAttributeListDeclarationInfo *)CFXMLNodeGetInfoPtr(CFXMLTreeGetNode(tree));\n            CFIndex idx;\n            CFStringAppendCString(str, \"<!ATTLIST \", kCFStringEncodingASCII);\n            CFStringAppend(str, CFXMLNodeGetString(CFXMLTreeGetNode(tree)));\n            for (idx = 0; idx < attListData->numberOfAttributes; idx ++) {\n                CFXMLAttributeDeclarationInfo *attr = &(attListData->attributes[idx]);\n                CFStringAppendFormat(str, NULL, CFSTR(\"\\n\\t%@ %@ %@\"), attr->attributeName, attr->typeString, attr->defaultString);\n            }\n            CFStringAppendCString(str, \">\", kCFStringEncodingASCII);\n            break;\n        }\n        default:\n            CFAssert1(false, __kCFLogAssertion, \"Encountered unexpected XMLDataTypeID %d\", CFXMLNodeGetTypeCode(CFXMLTreeGetNode(tree)));\n    }\n}", "path": "CFXMLTree.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/* startSec is the whole integer seconds from a CFAbsoluteTime, giving dates\n * between 1933 and 2069; info outside these years is discarded on read-in */\n/* Bits 31-18 of the info are unused */\n/* Bit 17 of the info is used for the is-DST state */\n/* Bit 16 of the info is used for the sign of the offset (1 == negative) */\n/* Bits 15-0 of the info are used for abs(offset) in seconds from GMT */\n", "func_signal": "CF_INLINE void __CFTZPeriodInit(CFTZPeriod *period, int32_t startTime, CFStringRef abbrev, int32_t offset, Boolean isDST)", "code": "{\n    period->startSec = startTime;\n    period->abbrev = abbrev ? (CFStringRef)CFRetain(abbrev) : NULL;\n    __CFBitfieldSetValue(period->info, 15, 0, abs(offset));\n    __CFBitfieldSetValue(period->info, 16, 16, (offset < 0 ? 1 : 0));\n    __CFBitfieldSetValue(period->info, 17, 17, (isDST ? 1 : 0));\n}", "path": "CFTimeZone.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "// \"Counting\" Allocator\n// A simple custom allocator that will count memory allocations and place guards to check memory corruption.\n", "func_signal": "void verifyMemory(int *ptr)", "code": "{\n    int size = ptr[0];\n    if (ptr[1] != 0x42424242) abort();\n    if (ptr[2 + size / sizeof(int)] != 0x42424242) abort();\n    if (ptr[2 + size / sizeof(int) + 1] != 0x42424242) abort();\n    if (ptr[2 + size / sizeof(int) + 2] != 0x42424242) abort();\n    if (ptr[2 + size / sizeof(int) + 3] != 0x42424242) abort();\n}", "path": "examples\\Allocator\\AllocatorExample.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/* Creates a childless node from desc */\n", "func_signal": "CFXMLTreeRef CFXMLTreeCreateWithNode(CFAllocatorRef allocator, CFXMLNodeRef node)", "code": "{\n    CFTreeContext treeCtxt;\n    treeCtxt.version = 0;\n    treeCtxt.info = (void *)node;\n    treeCtxt.retain = CFRetain;\n    treeCtxt.release = CFRelease;\n    treeCtxt.copyDescription = CFCopyDescription;\n    return CFTreeCreate(allocator, &treeCtxt);\n}", "path": "CFXMLTree.c", "repo_name": "nevali/opencflite", "stars": 30, "license": "other", "language": "c", "size": 10477}
{"docstring": "/**\n * \\brief Convert string to number\n */\n", "func_signal": "int nmea_atoi(const char *str, int str_sz, int radix)", "code": "{\n    char *tmp_ptr;\n    char buff[NMEA_CONVSTR_BUF];\n    int res = 0;\n\n    if(str_sz < NMEA_CONVSTR_BUF)\n    {\n        memcpy(&buff[0], str, str_sz);\n        buff[str_sz] = '\\0';\n        res = strtol(&buff[0], &tmp_ptr, radix);\n    }\n\n    return res;\n}", "path": "src\\tok.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Define packet type by header (nmeaPACKTYPE).\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @return The defined packet type\n * @see nmeaPACKTYPE\n */\n", "func_signal": "int nmea_pack_type(const char *buff, int buff_sz)", "code": "{\n    static const char *pheads[] = {\n        \"GPGGA\",\n        \"GPGSA\",\n        \"GPGSV\",\n        \"GPRMC\",\n        \"GPVTG\",\n    };\n\n    NMEA_ASSERT(buff);\n\n    if(buff_sz < 5)\n        return GPNON;\n    else if(0 == memcmp(buff, pheads[0], 5))\n        return GPGGA;\n    else if(0 == memcmp(buff, pheads[1], 5))\n        return GPGSA;\n    else if(0 == memcmp(buff, pheads[2], 5))\n        return GPGSV;\n    else if(0 == memcmp(buff, pheads[3], 5))\n        return GPRMC;\n    else if(0 == memcmp(buff, pheads[4], 5))\n        return GPVTG;\n\n    return GPNON;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Parse VTG packet from buffer.\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @param pack a pointer of packet which will filled by function.\n * @return 1 (true) - if parsed successfully or 0 (false) - if fail.\n */\n", "func_signal": "int nmea_parse_GPVTG(const char *buff, int buff_sz, nmeaGPVTG *pack)", "code": "{\n    NMEA_ASSERT(buff && pack);\n\n    memset(pack, 0, sizeof(nmeaGPVTG));\n\n    nmea_trace_buff(buff, buff_sz);\n\n    if(8 != nmea_scanf(buff, buff_sz,\n        \"$GPVTG,%f,%C,%f,%C,%f,%C,%f,%C*\",\n        &(pack->dir), &(pack->dir_t),\n        &(pack->dec), &(pack->dec_m),\n        &(pack->spn), &(pack->spn_n),\n        &(pack->spk), &(pack->spk_k)))\n    {\n        nmea_error(\"GPVTG parse error!\");\n        return 0;\n    }\n\n    if( pack->dir_t != 'T' ||\n        pack->dec_m != 'M' ||\n        pack->spn_n != 'N' ||\n        pack->spk_k != 'K')\n    {\n        nmea_error(\"GPVTG parse error (format error)!\");\n        return 0;\n    }\n\n    return 1;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Parse GGA packet from buffer.\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @param pack a pointer of packet which will filled by function.\n * @return 1 (true) - if parsed successfully or 0 (false) - if fail.\n */\n", "func_signal": "int nmea_parse_GPGGA(const char *buff, int buff_sz, nmeaGPGGA *pack)", "code": "{\n    char time_buff[NMEA_TIMEPARSE_BUF];\n\n    NMEA_ASSERT(buff && pack);\n\n    memset(pack, 0, sizeof(nmeaGPGGA));\n\n    nmea_trace_buff(buff, buff_sz);\n\n    if(14 != nmea_scanf(buff, buff_sz,\n        \"$GPGGA,%s,%f,%C,%f,%C,%d,%d,%f,%f,%C,%f,%C,%f,%d*\",\n        &(time_buff[0]),\n        &(pack->lat), &(pack->ns), &(pack->lon), &(pack->ew),\n        &(pack->sig), &(pack->satinuse), &(pack->HDOP), &(pack->elv), &(pack->elv_units),\n        &(pack->diff), &(pack->diff_units), &(pack->dgps_age), &(pack->dgps_sid)))\n    {\n        nmea_error(\"GPGGA parse error!\");\n        return 0;\n    }\n\n    if(0 != _nmea_parse_time(&time_buff[0], (int)strlen(&time_buff[0]), &(pack->utc)))\n    {\n        nmea_error(\"GPGGA time parse error!\");\n        return 0;\n    }\n\n    return 1;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert radians position to INFOs position\n */\n", "func_signal": "void nmea_pos2info(const nmeaPOS *pos, nmeaINFO *info)", "code": "{\n    info->lat = nmea_radian2ndeg(pos->lat);\n    info->lon = nmea_radian2ndeg(pos->lon);\n}", "path": "src\\gmath.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert position from INFO to radians position\n */\n", "func_signal": "void nmea_info2pos(const nmeaINFO *info, nmeaPOS *pos)", "code": "{\n    pos->lat = nmea_ndeg2radian(info->lat);\n    pos->lon = nmea_ndeg2radian(info->lon);\n}", "path": "src\\gmath.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Fill nmeaINFO structure by VTG packet data.\n * @param pack a pointer of packet structure.\n * @param info a pointer of summary information structure.\n */\n", "func_signal": "void nmea_GPVTG2info(nmeaGPVTG *pack, nmeaINFO *info)", "code": "{\n    NMEA_ASSERT(pack && info);\n\n    info->direction = pack->dir;\n    info->declination = pack->dec;\n    info->speed = pack->spk;\n    info->smask |= GPVTG;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert NDEG (NMEA degree) to radian\n */\n", "func_signal": "double nmea_ndeg2radian(double val)", "code": "{ return nmea_degree2radian(nmea_ndeg2degree(val)); }\n\n/**\n * \\brief Convert radian to NDEG (NMEA degree)\n */\ndouble nmea_radian2ndeg(double val)\n{ return nmea_degree2ndeg(nmea_radian2degree(val)); }\n\n/**\n * \\brief Calculate PDOP (Position Dilution Of Precision) factor\n */\ndouble nmea_calc_pdop(double hdop, double vdop)\n{\n    return sqrt(pow(hdop, 2) + pow(vdop, 2));\n}", "path": "src\\gmath.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Calculate control sum of binary buffer\n */\n", "func_signal": "int nmea_calc_crc(const char *buff, int buff_sz)", "code": "{\n    int chsum = 0,\n        it;\n\n    for(it = 0; it < buff_sz; ++it)\n        chsum ^= (int)buff[it];\n\n    return chsum;\n}", "path": "src\\tok.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Parse RMC packet from buffer.\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @param pack a pointer of packet which will filled by function.\n * @return 1 (true) - if parsed successfully or 0 (false) - if fail.\n */\n", "func_signal": "int nmea_parse_GPRMC(const char *buff, int buff_sz, nmeaGPRMC *pack)", "code": "{\n    int nsen;\n    char time_buff[NMEA_TIMEPARSE_BUF];\n\n    NMEA_ASSERT(buff && pack);\n\n    memset(pack, 0, sizeof(nmeaGPRMC));\n\n    nmea_trace_buff(buff, buff_sz);\n\n    nsen = nmea_scanf(buff, buff_sz,\n        \"$GPRMC,%s,%C,%f,%C,%f,%C,%f,%f,%2d%2d%2d,%f,%C,%C*\",\n        &(time_buff[0]),\n        &(pack->status), &(pack->lat), &(pack->ns), &(pack->lon), &(pack->ew),\n        &(pack->speed), &(pack->direction),\n        &(pack->utc.day), &(pack->utc.mon), &(pack->utc.year),\n        &(pack->declination), &(pack->declin_ew), &(pack->mode));\n\n    if(nsen != 13 && nsen != 14)\n    {\n        nmea_error(\"GPRMC parse error!\");\n        return 0;\n    }\n\n    if(0 != _nmea_parse_time(&time_buff[0], (int)strlen(&time_buff[0]), &(pack->utc)))\n    {\n        nmea_error(\"GPRMC time parse error!\");\n        return 0;\n    }\n\n    if(pack->utc.year < 90)\n        pack->utc.year += 100;\n    pack->utc.mon -= 1;\n\n    return 1;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Analyse string (specificate for NMEA sentences)\n */\n", "func_signal": "int nmea_scanf(const char *buff, int buff_sz, const char *format, ...)", "code": "{\n    const char *beg_tok;\n    const char *end_buf = buff + buff_sz;\n\n    va_list arg_ptr;\n    int tok_type = NMEA_TOKS_COMPARE;\n    int width = 0;\n    const char *beg_fmt = 0;\n    int snum = 0, unum = 0;\n\n    int tok_count = 0;\n    void *parg_target;\n\n    va_start(arg_ptr, format);\n    \n    for(; *format && buff < end_buf; ++format)\n    {\n        switch(tok_type)\n        {\n        case NMEA_TOKS_COMPARE:\n            if('%' == *format)\n                tok_type = NMEA_TOKS_PERCENT;\n            else if(*buff++ != *format)\n                goto fail;\n            break;\n        case NMEA_TOKS_PERCENT:\n            width = 0;\n            beg_fmt = format;\n            tok_type = NMEA_TOKS_WIDTH;\n            /* no break */\n        case NMEA_TOKS_WIDTH:\n            if(isdigit(*format))\n                break;\n            {\n                tok_type = NMEA_TOKS_TYPE;\n                if(format > beg_fmt)\n                    width = nmea_atoi(beg_fmt, (int)(format - beg_fmt), 10);\n            }\n            /* no break */\n        case NMEA_TOKS_TYPE:\n            beg_tok = buff;\n\n            if(!width && ('c' == *format || 'C' == *format) && *buff != format[1])\n                width = 1;\n\n            if(width)\n            {\n                if(buff + width <= end_buf)\n                    buff += width;\n                else\n                    goto fail;\n            }\n            else\n            {\n                if(!format[1] || (0 == (buff = (char *)memchr(buff, format[1], end_buf - buff))))\n                    buff = end_buf;\n            }\n\n            if(buff > end_buf)\n                goto fail;\n\n            tok_type = NMEA_TOKS_COMPARE;\n            tok_count++;\n\n            parg_target = 0; width = (int)(buff - beg_tok);\n\n            switch(*format)\n            {\n            case 'c':\n            case 'C':\n                parg_target = (void *)va_arg(arg_ptr, char *);\n                if(width && 0 != (parg_target))\n                    *((char *)parg_target) = *beg_tok;\n                break;\n            case 's':\n            case 'S':\n                parg_target = (void *)va_arg(arg_ptr, char *);\n                if(width && 0 != (parg_target))\n                {\n                    memcpy(parg_target, beg_tok, width);\n                    ((char *)parg_target)[width] = '\\0';\n                }\n                break;\n            case 'f':\n            case 'g':\n            case 'G':\n            case 'e':\n            case 'E':\n                parg_target = (void *)va_arg(arg_ptr, double *);\n                if(width && 0 != (parg_target))\n                    *((double *)parg_target) = nmea_atof(beg_tok, width);\n                break;\n            default:\n                break;\n            };\n\n            if(parg_target)\n                break;\n            if(0 == (parg_target = (void *)va_arg(arg_ptr, int *)))\n                break;\n            if(!width)\n                break;\n\n            switch(*format)\n            {\n            case 'd':\n            case 'i':\n                snum = nmea_atoi(beg_tok, width, 10);\n                memcpy(parg_target, &snum, sizeof(int));\n                break;\n            case 'u':\n                unum = nmea_atoi(beg_tok, width, 10);\n                memcpy(parg_target, &unum, sizeof(unsigned int));\n                break;\n            case 'x':\n            case 'X':\n                unum = nmea_atoi(beg_tok, width, 16);\n                memcpy(parg_target, &unum, sizeof(unsigned int));\n                break;\n            case 'o':\n                unum = nmea_atoi(beg_tok, width, 8);\n                memcpy(parg_target, &unum, sizeof(unsigned int));\n                break;\n            default:\n                goto fail;\n            };\n\n            break;\n\n        default:\n            break;\n        };\n    }\n\nfail:\n\n    va_end(arg_ptr);\n\n    return tok_count;\n}", "path": "src\\tok.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert fractional degree to NDEG (NMEA degree)\n */\n", "func_signal": "double nmea_degree2ndeg(double val)", "code": "{\n    double deg;\n    double fra_part = modf(val, &deg);\n    return ((deg * 100.0) + (fra_part * 60.0));\n}", "path": "src\\gmath.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Parse GSV packet from buffer.\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @param pack a pointer of packet which will filled by function.\n * @return 1 (true) - if parsed successfully or 0 (false) - if fail.\n */\n", "func_signal": "int nmea_parse_GPGSV(const char *buff, int buff_sz, nmeaGPGSV *pack)", "code": "{\n    int nsen, nsat;\n\n    NMEA_ASSERT(buff && pack);\n\n    memset(pack, 0, sizeof(nmeaGPGSV));\n\n    nmea_trace_buff(buff, buff_sz);\n\n    nsen = nmea_scanf(buff, buff_sz,\n        \"$GPGSV,%d,%d,%d,\"\n        \"%d,%d,%d,%d,\"\n        \"%d,%d,%d,%d,\"\n        \"%d,%d,%d,%d,\"\n        \"%d,%d,%d,%d*\",\n        &(pack->pack_count), &(pack->pack_index), &(pack->sat_count),\n        &(pack->sat_data[0].id), &(pack->sat_data[0].elv), &(pack->sat_data[0].azimuth), &(pack->sat_data[0].sig),\n        &(pack->sat_data[1].id), &(pack->sat_data[1].elv), &(pack->sat_data[1].azimuth), &(pack->sat_data[1].sig),\n        &(pack->sat_data[2].id), &(pack->sat_data[2].elv), &(pack->sat_data[2].azimuth), &(pack->sat_data[2].sig),\n        &(pack->sat_data[3].id), &(pack->sat_data[3].elv), &(pack->sat_data[3].azimuth), &(pack->sat_data[3].sig));\n\n    nsat = (pack->pack_index - 1) * NMEA_SATINPACK;\n    nsat = (nsat + NMEA_SATINPACK > pack->sat_count)?pack->sat_count - nsat:NMEA_SATINPACK;\n    nsat = nsat * 4 + 3 /* first three sentence`s */;\n\n    if(nsen < nsat || nsen > (NMEA_SATINPACK * 4 + 3))\n    {\n        nmea_error(\"GPGSV parse error!\");\n        return 0;\n    }\n\n    return 1;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert string to fraction number\n */\n", "func_signal": "double nmea_atof(const char *str, int str_sz)", "code": "{\n    char *tmp_ptr;\n    char buff[NMEA_CONVSTR_BUF];\n    double res = 0;\n\n    if(str_sz < NMEA_CONVSTR_BUF)\n    {\n        memcpy(&buff[0], str, str_sz);\n        buff[str_sz] = '\\0';\n        res = strtod(&buff[0], &tmp_ptr);\n    }\n\n    return res;\n}", "path": "src\\tok.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Parse GSA packet from buffer.\n * @param buff a constant character pointer of packet buffer.\n * @param buff_sz buffer size.\n * @param pack a pointer of packet which will filled by function.\n * @return 1 (true) - if parsed successfully or 0 (false) - if fail.\n */\n", "func_signal": "int nmea_parse_GPGSA(const char *buff, int buff_sz, nmeaGPGSA *pack)", "code": "{\n    NMEA_ASSERT(buff && pack);\n\n    memset(pack, 0, sizeof(nmeaGPGSA));\n\n    nmea_trace_buff(buff, buff_sz);\n\n    if(17 != nmea_scanf(buff, buff_sz,\n        \"$GPGSA,%C,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%f,%f,%f*\",\n        &(pack->fix_mode), &(pack->fix_type),\n        &(pack->sat_prn[0]), &(pack->sat_prn[1]), &(pack->sat_prn[2]), &(pack->sat_prn[3]), &(pack->sat_prn[4]), &(pack->sat_prn[5]),\n        &(pack->sat_prn[6]), &(pack->sat_prn[7]), &(pack->sat_prn[8]), &(pack->sat_prn[9]), &(pack->sat_prn[10]), &(pack->sat_prn[11]),\n        &(pack->PDOP), &(pack->HDOP), &(pack->VDOP)))\n    {\n        nmea_error(\"GPGSA parse error!\");\n        return 0;\n    }\n\n    return 1;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Convert degree to radian\n */\n", "func_signal": "double nmea_degree2radian(double val)", "code": "{ return (val * NMEA_PI180); }\n\n/**\n * \\brief Convert radian to degree\n */\ndouble nmea_radian2degree(double val)\n{ return (val / NMEA_PI180); }\n\n/**\n * \\brief Convert NDEG (NMEA degree) to fractional degree\n */\ndouble nmea_ndeg2degree(double val)\n{\n    double deg;\n    double fra_part = modf(val / 100.0, &deg);\n    return (deg + ((fra_part * 100.0) / 60.0));\n}", "path": "src\\gmath.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Find tail of packet (\"\\r\\n\") in buffer and check control sum (CRC).\n * @param buff a constant character pointer of packets buffer.\n * @param buff_sz buffer size.\n * @param res_crc a integer pointer for return CRC of packet (must be defined).\n * @return Number of bytes to packet tail.\n */\n", "func_signal": "int nmea_find_tail(const char *buff, int buff_sz, int *res_crc)", "code": "{\n    static const int tail_sz = 3 /* *[CRC] */ + 2 /* \\r\\n */;\n\n    const char *end_buff = buff + buff_sz;\n    int nread = 0;\n    int crc = 0;\n\n    NMEA_ASSERT(buff && res_crc);\n\n    *res_crc = -1;\n\n    for(;buff < end_buff; ++buff, ++nread)\n    {\n        if(('$' == *buff) && nread)\n        {\n            buff = 0;\n            break;\n        }\n        else if('*' == *buff)\n        {\n            if(buff + tail_sz <= end_buff && '\\r' == buff[3] && '\\n' == buff[4])\n            {\n                *res_crc = nmea_atoi(buff + 1, 2, 16);\n                nread = buff_sz - (int)(end_buff - (buff + tail_sz));\n                if(*res_crc != crc)\n                {\n                    *res_crc = -1;\n                    buff = 0;\n                }\n            }\n\n            break;\n        }\n        else if(nread)\n            crc ^= (int)*buff;\n    }\n\n    if(*res_crc < 0 && buff)\n        nread = 0;\n\n    return nread;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Fill nmeaINFO structure by GSA packet data.\n * @param pack a pointer of packet structure.\n * @param info a pointer of summary information structure.\n */\n", "func_signal": "void nmea_GPGSA2info(nmeaGPGSA *pack, nmeaINFO *info)", "code": "{\n    int i, j, nuse = 0;\n\n    NMEA_ASSERT(pack && info);\n\n    info->fix = pack->fix_type;\n    info->PDOP = pack->PDOP;\n    info->HDOP = pack->HDOP;\n    info->VDOP = pack->VDOP;\n\n    for(i = 0; i < NMEA_MAXSAT; ++i)\n    {\n        for(j = 0; j < info->satinfo.inview; ++j)\n        {\n            if(pack->sat_prn[i] && pack->sat_prn[i] == info->satinfo.sat[j].id)\n            {\n                info->satinfo.sat[j].in_use = 1;\n                nuse++;\n            }\n        }\n    }\n\n    info->satinfo.inuse = nuse;\n    info->smask |= GPGSA;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Fill nmeaINFO structure by GGA packet data.\n * @param pack a pointer of packet structure.\n * @param info a pointer of summary information structure.\n */\n", "func_signal": "void nmea_GPGGA2info(nmeaGPGGA *pack, nmeaINFO *info)", "code": "{\n    NMEA_ASSERT(pack && info);\n\n    info->utc.hour = pack->utc.hour;\n    info->utc.min = pack->utc.min;\n    info->utc.sec = pack->utc.sec;\n    info->utc.hsec = pack->utc.hsec;\n    info->sig = pack->sig;\n    info->HDOP = pack->HDOP;\n    info->elv = pack->elv;\n    info->lat = ((pack->ns == 'N')?pack->lat:-(pack->lat));\n    info->lon = ((pack->ew == 'E')?pack->lon:-(pack->lon));\n    info->smask |= GPGGA;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/**\n * \\brief Fill nmeaINFO structure by GSV packet data.\n * @param pack a pointer of packet structure.\n * @param info a pointer of summary information structure.\n */\n", "func_signal": "void nmea_GPGSV2info(nmeaGPGSV *pack, nmeaINFO *info)", "code": "{\n    int isat, isi, nsat;\n\n    NMEA_ASSERT(pack && info);\n\n    if(pack->pack_index > pack->pack_count ||\n        pack->pack_index * NMEA_SATINPACK > NMEA_MAXSAT)\n        return;\n\n    if(pack->pack_index < 1)\n        pack->pack_index = 1;\n\n    info->satinfo.inview = pack->sat_count;\n\n    nsat = (pack->pack_index - 1) * NMEA_SATINPACK;\n    nsat = (nsat + NMEA_SATINPACK > pack->sat_count)?pack->sat_count - nsat:NMEA_SATINPACK;\n\n    for(isat = 0; isat < nsat; ++isat)\n    {\n        isi = (pack->pack_index - 1) * NMEA_SATINPACK + isat;\n        info->satinfo.sat[isi].id = pack->sat_data[isat].id;\n        info->satinfo.sat[isi].elv = pack->sat_data[isat].elv;\n        info->satinfo.sat[isi].azimuth = pack->sat_data[isat].azimuth;\n        info->satinfo.sat[isi].sig = pack->sat_data[isat].sig;\n    }\n\n    info->smask |= GPGSV;\n}", "path": "src\\parse.c", "repo_name": "Paulxia/nmealib", "stars": 19, "license": "lgpl-2.1", "language": "c", "size": 1602}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_PLTE(png_structp png_ptr, png_const_colorp palette,\n    png_uint_32 num_pal)", "code": "{\n   PNG_PLTE;\n   png_uint_32 i;\n   png_const_colorp pal_ptr;\n   png_byte buf[3];\n\n   png_debug(1, \"in png_write_PLTE\");\n\n   if ((\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n       !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&\n#endif\n       num_pal == 0) || num_pal > 256)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         png_error(png_ptr, \"Invalid number of colors in palette\");\n      }\n\n      else\n      {\n         png_warning(png_ptr, \"Invalid number of colors in palette\");\n         return;\n      }\n   }\n\n   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))\n   {\n      png_warning(png_ptr,\n          \"Ignoring request to write a PLTE chunk in grayscale PNG\");\n\n      return;\n   }\n\n   png_ptr->num_palette = (png_uint_16)num_pal;\n   png_debug1(3, \"num_palette = %d\", png_ptr->num_palette);\n\n   png_write_chunk_start(png_ptr, png_PLTE, (png_uint_32)(num_pal * 3));\n#ifdef PNG_POINTER_INDEXING_SUPPORTED\n\n   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)\n   {\n      buf[0] = pal_ptr->red;\n      buf[1] = pal_ptr->green;\n      buf[2] = pal_ptr->blue;\n      png_write_chunk_data(png_ptr, buf, (png_size_t)3);\n   }\n\n#else\n   /* This is a little slower but some buggy compilers need to do this\n    * instead\n    */\n   pal_ptr=palette;\n\n   for (i = 0; i < num_pal; i++)\n   {\n      buf[0] = pal_ptr[i].red;\n      buf[1] = pal_ptr[i].green;\n      buf[2] = pal_ptr[i].blue;\n      png_write_chunk_data(png_ptr, buf, (png_size_t)3);\n   }\n\n#endif\n   png_write_chunk_end(png_ptr);\n   png_ptr->mode |= PNG_HAVE_PLTE;\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,\n    png_int_32 X1, int type, int nparams, png_const_charp units,\n    png_charpp params)", "code": "{\n   PNG_pCAL;\n   png_size_t purpose_len, units_len, total_len;\n   png_uint_32p params_len;\n   png_byte buf[10];\n   png_charp new_purpose;\n   int i;\n\n   png_debug1(1, \"in png_write_pCAL (%d parameters)\", nparams);\n\n   if (type >= PNG_EQUATION_LAST)\n      png_warning(png_ptr, \"Unrecognized equation type for pCAL chunk\");\n\n   purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;\n   png_debug1(3, \"pCAL purpose length = %d\", (int)purpose_len);\n   units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);\n   png_debug1(3, \"pCAL units length = %d\", (int)units_len);\n   total_len = purpose_len + units_len + 10;\n\n   params_len = (png_uint_32p)png_malloc(png_ptr,\n       (png_alloc_size_t)(nparams * png_sizeof(png_uint_32)));\n\n   /* Find the length of each parameter, making sure we don't count the\n    * null terminator for the last parameter.\n    */\n   for (i = 0; i < nparams; i++)\n   {\n      params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);\n      png_debug2(3, \"pCAL parameter %d length = %lu\", i,\n          (unsigned long)params_len[i]);\n      total_len += (png_size_t)params_len[i];\n   }\n\n   png_debug1(3, \"pCAL total length = %d\", (int)total_len);\n   png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);\n   png_write_chunk_data(png_ptr, (png_const_bytep)new_purpose,\n       (png_size_t)purpose_len);\n   png_save_int_32(buf, X0);\n   png_save_int_32(buf + 4, X1);\n   buf[8] = (png_byte)type;\n   buf[9] = (png_byte)nparams;\n   png_write_chunk_data(png_ptr, buf, (png_size_t)10);\n   png_write_chunk_data(png_ptr, (png_const_bytep)units, (png_size_t)units_len);\n\n   png_free(png_ptr, new_purpose);\n\n   for (i = 0; i < nparams; i++)\n   {\n      png_write_chunk_data(png_ptr, (png_const_bytep)params[i],\n          (png_size_t)params_len[i]);\n   }\n\n   png_free(png_ptr, params_len);\n   png_write_chunk_end(png_ptr);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/*\n *  pnm2png\n */\n", "func_signal": "BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha)", "code": "{\n  png_struct    *png_ptr = NULL;\n  png_info      *info_ptr = NULL;\n  png_byte      *png_pixels = NULL;\n  png_byte      **row_pointers = NULL;\n  png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n\n  char          type_token[16];\n  char          width_token[16];\n  char          height_token[16];\n  char          maxval_token[16];\n  int           color_type;\n  png_uint_32   width, alpha_width;\n  png_uint_32   height, alpha_height;\n  png_uint_32   maxval;\n  int           bit_depth = 0;\n  int           channels;\n  int           alpha_depth = 0;\n  int           alpha_present;\n  int           row, col;\n  BOOL          raw, alpha_raw = FALSE;\n  png_uint_32   tmp16;\n  int           i;\n\n  /* read header of PNM file */\n\n  get_token(pnm_file, type_token);\n  if (type_token[0] != 'P')\n  {\n    return FALSE;\n  }\n  else if ((type_token[1] == '1') || (type_token[1] == '4'))\n  {\n    raw = (type_token[1] == '4');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    bit_depth = 1;\n  }\n  else if ((type_token[1] == '2') || (type_token[1] == '5'))\n  {\n    raw = (type_token[1] == '5');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &width);\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &height);\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &maxval);\n    if (maxval <= 1)\n      bit_depth = 1;\n    else if (maxval <= 3)\n      bit_depth = 2;\n    else if (maxval <= 15)\n      bit_depth = 4;\n    else if (maxval <= 255)\n      bit_depth = 8;\n    else /* if (maxval <= 65535) */\n      bit_depth = 16;\n  }\n  else if ((type_token[1] == '3') || (type_token[1] == '6'))\n  {\n    raw = (type_token[1] == '6');\n    color_type = PNG_COLOR_TYPE_RGB;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &width);\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &height);\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &maxval);\n    if (maxval <= 1)\n      bit_depth = 1;\n    else if (maxval <= 3)\n      bit_depth = 2;\n    else if (maxval <= 15)\n      bit_depth = 4;\n    else if (maxval <= 255)\n      bit_depth = 8;\n    else /* if (maxval <= 65535) */\n      bit_depth = 16;\n  }\n  else\n  {\n    return FALSE;\n  }\n\n  /* read header of PGM file with alpha channel */\n\n  if (alpha)\n  {\n    if (color_type == PNG_COLOR_TYPE_GRAY)\n      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n    if (color_type == PNG_COLOR_TYPE_RGB)\n      color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n    get_token(alpha_file, type_token);\n    if (type_token[0] != 'P')\n    {\n      return FALSE;\n    }\n    else if ((type_token[1] == '2') || (type_token[1] == '5'))\n    {\n      alpha_raw = (type_token[1] == '5');\n      get_token(alpha_file, width_token);\n      sscanf (width_token, \"%lu\", &alpha_width);\n      if (alpha_width != width)\n        return FALSE;\n      get_token(alpha_file, height_token);\n      sscanf (height_token, \"%lu\", &alpha_height);\n      if (alpha_height != height)\n        return FALSE;\n      get_token(alpha_file, maxval_token);\n      sscanf (maxval_token, \"%lu\", &maxval);\n      if (maxval <= 1)\n        alpha_depth = 1;\n      else if (maxval <= 3)\n        alpha_depth = 2;\n      else if (maxval <= 15)\n        alpha_depth = 4;\n      else if (maxval <= 255)\n        alpha_depth = 8;\n      else /* if (maxval <= 65535) */\n        alpha_depth = 16;\n      if (alpha_depth != bit_depth)\n        return FALSE;\n    }\n    else\n    {\n      return FALSE;\n    }\n  } /* end if alpha */\n\n  /* calculate the number of channels and store alpha-presence */\n  if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n  else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n  else if (color_type == PNG_COLOR_TYPE_RGB)\n    channels = 3;\n  else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n    channels = 4;\n  else\n    channels = 0; /* should not happen */\n\n  alpha_present = (channels - 1) % 2;\n\n  /* row_bytes is the width x number of channels x (bit-depth / 8) */\n  row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);\n\n  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)\n    return FALSE;\n\n  /* read data from PNM file */\n  pix_ptr = png_pixels;\n\n  for (row = 0; row < height; row++)\n  {\n    for (col = 0; col < width; col++)\n    {\n      for (i = 0; i < (channels - alpha_present); i++)\n      {\n        if (raw)\n          *pix_ptr++ = get_data (pnm_file, bit_depth);\n        else\n          if (bit_depth <= 8)\n            *pix_ptr++ = get_value (pnm_file, bit_depth);\n          else\n          {\n            tmp16 = get_value (pnm_file, bit_depth);\n            *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);\n            pix_ptr++;\n            *pix_ptr = (png_byte) (tmp16 & 0xFF);\n            pix_ptr++;\n          }\n      }\n\n      if (alpha) /* read alpha-channel from pgm file */\n      {\n        if (alpha_raw)\n          *pix_ptr++ = get_data (alpha_file, alpha_depth);\n        else\n          if (alpha_depth <= 8)\n            *pix_ptr++ = get_value (alpha_file, bit_depth);\n          else\n          {\n            tmp16 = get_value (alpha_file, bit_depth);\n            *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);\n            *pix_ptr++ = (png_byte) (tmp16 & 0xFF);\n          }\n      } /* if alpha */\n\n    } /* end for col */\n  } /* end for row */\n\n  /* prepare the standard PNG structures */\n  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  if (!png_ptr)\n  {\n    return FALSE;\n  }\n  info_ptr = png_create_info_struct (png_ptr);\n  if (!info_ptr)\n  {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n    return FALSE;\n  }\n\n  /* setjmp() must be called in every function that calls a PNG-reading libpng function */\n  if (setjmp (png_jmpbuf(png_ptr)))\n  {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n    return FALSE;\n  }\n\n  /* initialize the png structure */\n  png_init_io (png_ptr, png_file);\n\n  /* we're going to write more or less the same PNG as the input file */\n  png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,\n    (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,\n    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n  /* write the file header information */\n  png_write_info (png_ptr, info_ptr);\n\n  /* if needed we will allocate memory for an new array of row-pointers */\n  if (row_pointers == (unsigned char**) NULL)\n  {\n    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)\n    {\n      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n      return FALSE;\n    }\n  }\n\n  /* set the individual row_pointers to point at the correct offsets */\n  for (i = 0; i < (height); i++)\n    row_pointers[i] = png_pixels + i * row_bytes;\n\n  /* write out the entire image data in one call */\n  png_write_image (png_ptr, row_pointers);\n\n  /* write the additional chuncks to the PNG file (not really needed) */\n  png_write_end (png_ptr, info_ptr);\n\n  /* clean up after the write, and free any memory allocated */\n  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n\n  if (row_pointers != (unsigned char**) NULL)\n    free (row_pointers);\n  if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n\n  return TRUE;\n}", "path": "jni\\sox\\libpng-1.5.2\\contrib\\pngminus\\pnm2png.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_check_keyword(png_structp png_ptr, png_const_charp key, png_charpp new_key)", "code": "{\n   png_size_t key_len;\n   png_const_charp ikp;\n   png_charp kp, dp;\n   int kflag;\n   int kwarn=0;\n\n   png_debug(1, \"in png_check_keyword\");\n\n   *new_key = NULL;\n\n   if (key == NULL || (key_len = png_strlen(key)) == 0)\n   {\n      png_warning(png_ptr, \"zero length keyword\");\n      return ((png_size_t)0);\n   }\n\n   png_debug1(2, \"Keyword to be checked is '%s'\", key);\n\n   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));\n\n   if (*new_key == NULL)\n   {\n      png_warning(png_ptr, \"Out of memory while procesing keyword\");\n      return ((png_size_t)0);\n   }\n\n   /* Replace non-printing characters with a blank and print a warning */\n   for (ikp = key, dp = *new_key; *ikp != '\\0'; ikp++, dp++)\n   {\n      if ((png_byte)*ikp < 0x20 ||\n         ((png_byte)*ikp > 0x7E && (png_byte)*ikp < 0xA1))\n      {\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n         char msg[40];\n\n         png_snprintf(msg, 40,\n             \"invalid keyword character 0x%02X\", (png_byte)*ikp);\n         png_warning(png_ptr, msg);\n#else\n         png_warning(png_ptr, \"invalid character in keyword\");\n#endif\n         *dp = ' ';\n      }\n\n      else\n      {\n         *dp = *ikp;\n      }\n   }\n   *dp = '\\0';\n\n   /* Remove any trailing white space. */\n   kp = *new_key + key_len - 1;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"trailing spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n         *(kp--) = '\\0';\n         key_len--;\n      }\n   }\n\n   /* Remove any leading white space. */\n   kp = *new_key;\n   if (*kp == ' ')\n   {\n      png_warning(png_ptr, \"leading spaces removed from keyword\");\n\n      while (*kp == ' ')\n      {\n         kp++;\n         key_len--;\n      }\n   }\n\n   png_debug1(2, \"Checking for multiple internal spaces in '%s'\", kp);\n\n   /* Remove multiple internal spaces. */\n   for (kflag = 0, dp = *new_key; *kp != '\\0'; kp++)\n   {\n      if (*kp == ' ' && kflag == 0)\n      {\n         *(dp++) = *kp;\n         kflag = 1;\n      }\n\n      else if (*kp == ' ')\n      {\n         key_len--;\n         kwarn = 1;\n      }\n\n      else\n      {\n         *(dp++) = *kp;\n         kflag = 0;\n      }\n   }\n   *dp = '\\0';\n   if (kwarn)\n      png_warning(png_ptr, \"extra interior spaces removed from keyword\");\n\n   if (key_len == 0)\n   {\n      png_free(png_ptr, *new_key);\n      png_warning(png_ptr, \"Zero length keyword\");\n   }\n\n   if (key_len > 79)\n   {\n      png_warning(png_ptr, \"keyword length must be 1 - 79 characters\");\n      (*new_key)[79] = '\\0';\n      key_len = 79;\n   }\n\n   return (key_len);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_tIME(png_structp png_ptr, png_const_timep mod_time)", "code": "{\n   PNG_tIME;\n   png_byte buf[7];\n\n   png_debug(1, \"in png_write_tIME\");\n\n   if (mod_time->month  > 12 || mod_time->month  < 1 ||\n       mod_time->day    > 31 || mod_time->day    < 1 ||\n       mod_time->hour   > 23 || mod_time->second > 60)\n   {\n      png_warning(png_ptr, \"Invalid time specified for tIME chunk\");\n      return;\n   }\n\n   png_save_uint_16(buf, mod_time->year);\n   buf[2] = mod_time->month;\n   buf[3] = mod_time->day;\n   buf[4] = mod_time->hour;\n   buf[5] = mod_time->minute;\n   buf[6] = mod_time->second;\n\n   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)", "code": "{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   png_debug(1, \"in png_do_write_interlace\");\n\n   /* We don't have to do anything on the last pass (6) */\n   if (pass < 6)\n   {\n      /* Each pixel depth is handled separately */\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp;\n            png_bytep dp;\n            int shift;\n            int d;\n            int value;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            dp = row;\n            d = 0;\n            shift = 7;\n\n            for (i = png_pass_start[pass]; i < row_width;\n               i += png_pass_inc[pass])\n            {\n               sp = row + (png_size_t)(i >> 3);\n               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;\n               d |= (value << shift);\n\n               if (shift == 0)\n               {\n                  shift = 7;\n                  *dp++ = (png_byte)d;\n                  d = 0;\n               }\n\n               else\n                  shift--;\n\n            }\n            if (shift != 7)\n               *dp = (png_byte)d;\n\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp;\n            png_bytep dp;\n            int shift;\n            int d;\n            int value;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            dp = row;\n            shift = 6;\n            d = 0;\n\n            for (i = png_pass_start[pass]; i < row_width;\n               i += png_pass_inc[pass])\n            {\n               sp = row + (png_size_t)(i >> 2);\n               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;\n               d |= (value << shift);\n\n               if (shift == 0)\n               {\n                  shift = 6;\n                  *dp++ = (png_byte)d;\n                  d = 0;\n               }\n\n               else\n                  shift -= 2;\n            }\n            if (shift != 6)\n               *dp = (png_byte)d;\n\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp;\n            png_bytep dp;\n            int shift;\n            int d;\n            int value;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            dp = row;\n            shift = 4;\n            d = 0;\n            for (i = png_pass_start[pass]; i < row_width;\n                i += png_pass_inc[pass])\n            {\n               sp = row + (png_size_t)(i >> 1);\n               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;\n               d |= (value << shift);\n\n               if (shift == 0)\n               {\n                  shift = 4;\n                  *dp++ = (png_byte)d;\n                  d = 0;\n               }\n\n               else\n                  shift -= 4;\n            }\n            if (shift != 4)\n               *dp = (png_byte)d;\n\n            break;\n         }\n\n         default:\n         {\n            png_bytep sp;\n            png_bytep dp;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n            png_size_t pixel_bytes;\n\n            /* Start at the beginning */\n            dp = row;\n\n            /* Find out how many bytes each pixel takes up */\n            pixel_bytes = (row_info->pixel_depth >> 3);\n\n            /* Loop through the row, only looking at the pixels that matter */\n            for (i = png_pass_start[pass]; i < row_width;\n               i += png_pass_inc[pass])\n            {\n               /* Find out where the original pixel is */\n               sp = row + (png_size_t)i * pixel_bytes;\n\n               /* Move the pixel */\n               if (dp != sp)\n                  png_memcpy(dp, sp, pixel_bytes);\n\n               /* Next pixel */\n               dp += pixel_bytes;\n            }\n            break;\n         }\n      }\n      /* Set new row width */\n      row_info->width = (row_info->width +\n          png_pass_inc[pass] - 1 -\n          png_pass_start[pass]) /\n          png_pass_inc[pass];\n\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,\n          row_info->width);\n   }\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)", "code": "{\n   PNG_gAMA;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_write_gAMA\");\n\n   /* file_gamma is saved in 1/100,000ths */\n   png_save_uint_32(buf, (png_uint_32)file_gamma);\n   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,\n    png_fixed_point white_y, png_fixed_point red_x, png_fixed_point red_y,\n    png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,\n    png_fixed_point blue_y)", "code": "{\n   PNG_cHRM;\n   png_byte buf[32];\n\n   png_debug(1, \"in png_write_cHRM\");\n\n   /* Each value is saved in 1/100,000ths */\n#ifdef PNG_CHECK_cHRM_SUPPORTED\n   if (png_check_cHRM_fixed(png_ptr, white_x, white_y, red_x, red_y,\n       green_x, green_y, blue_x, blue_y))\n#endif\n   {\n      png_save_uint_32(buf, (png_uint_32)white_x);\n      png_save_uint_32(buf + 4, (png_uint_32)white_y);\n\n      png_save_uint_32(buf + 8, (png_uint_32)red_x);\n      png_save_uint_32(buf + 12, (png_uint_32)red_y);\n\n      png_save_uint_32(buf + 16, (png_uint_32)green_x);\n      png_save_uint_32(buf + 20, (png_uint_32)green_y);\n\n      png_save_uint_32(buf + 24, (png_uint_32)blue_x);\n      png_save_uint_32(buf + 28, (png_uint_32)blue_y);\n\n      png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);\n   }\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)", "code": "{\n   PNG_bKGD;\n   png_byte buf[6];\n\n   png_debug(1, \"in png_write_bKGD\");\n\n   if (color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n          (png_ptr->num_palette ||\n          (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&\n#endif\n         back->index >= png_ptr->num_palette)\n      {\n         png_warning(png_ptr, \"Invalid background palette index\");\n         return;\n      }\n\n      buf[0] = back->index;\n      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);\n   }\n\n   else if (color_type & PNG_COLOR_MASK_COLOR)\n   {\n      png_save_uint_16(buf, back->red);\n      png_save_uint_16(buf + 2, back->green);\n      png_save_uint_16(buf + 4, back->blue);\n#ifdef PNG_WRITE_16BIT_SUPPORTED\n      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))\n#else\n      if (buf[0] | buf[2] | buf[4])\n#endif\n      {\n         png_warning(png_ptr,\n             \"Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8\");\n\n         return;\n      }\n\n      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);\n   }\n\n   else\n   {\n      if (back->gray >= (1 << png_ptr->bit_depth))\n      {\n         png_warning(png_ptr,\n             \"Ignoring attempt to write bKGD chunk out-of-range for bit_depth\");\n\n         return;\n      }\n\n      png_save_uint_16(buf, back->gray);\n      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);\n   }\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_sRGB(png_structp png_ptr, int srgb_intent)", "code": "{\n   PNG_sRGB;\n   png_byte buf[1];\n\n   png_debug(1, \"in png_write_sRGB\");\n\n   if (srgb_intent >= PNG_sRGB_INTENT_LAST)\n      png_warning(png_ptr,\n          \"Invalid sRGB rendering intent specified\");\n\n   buf[0]=(png_byte)srgb_intent;\n   png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/*\n * This is the output callback function. It is called after each frame of\n * MPEG audio data has been completely decoded. The purpose of this callback\n * is to output (or play) the decoded PCM audio.\n */\n", "func_signal": "static\nenum mad_flow output(void *data,\n\t\t     struct mad_header const *header,\n\t\t     struct mad_pcm *pcm)", "code": "{\n  unsigned int nchannels, nsamples;\n  mad_fixed_t const *left_ch, *right_ch;\n\n  /* pcm->samplerate contains the sampling frequency */\n\n  nchannels = pcm->channels;\n  nsamples  = pcm->length;\n  left_ch   = pcm->samples[0];\n  right_ch  = pcm->samples[1];\n\n  while (nsamples--) {\n    signed int sample;\n\n    /* output sample(s) in 16-bit signed little-endian PCM */\n\n    sample = scale(*left_ch++);\n    putchar((sample >> 0) & 0xff);\n    putchar((sample >> 8) & 0xff);\n\n    if (nchannels == 2) {\n      sample = scale(*right_ch++);\n      putchar((sample >> 0) & 0xff);\n      putchar((sample >> 8) & 0xff);\n    }\n  }\n\n  return MAD_FLOW_CONTINUE;\n}", "path": "jni\\sox\\libmad-0.15.1b\\minimad.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* Write the data of a PNG chunk started with png_write_chunk_start().\n * Note that multiple calls to this function are allowed, and that the\n * sum of the lengths from these calls *must* add up to the total_length\n * given to png_write_chunk_start().\n */\n", "func_signal": "void PNGAPI\npng_write_chunk_data(png_structp png_ptr, png_const_bytep data,\n    png_size_t length)", "code": "{\n   /* Write the data, and run the CRC over it */\n   if (png_ptr == NULL)\n      return;\n\n   if (data != NULL && length > 0)\n   {\n      png_write_data(png_ptr, data, length);\n\n      /* Update the CRC after writing the data,\n       * in case that the user I/O routine alters it.\n       */\n      png_calculate_crc(png_ptr, data, length);\n   }\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_sBIT(png_structp png_ptr, png_const_color_8p sbit, int color_type)", "code": "{\n   PNG_sBIT;\n   png_byte buf[4];\n   png_size_t size;\n\n   png_debug(1, \"in png_write_sBIT\");\n\n   /* Make sure we don't depend upon the order of PNG_COLOR_8 */\n   if (color_type & PNG_COLOR_MASK_COLOR)\n   {\n      png_byte maxbits;\n\n      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :\n          png_ptr->usr_bit_depth);\n\n      if (sbit->red == 0 || sbit->red > maxbits ||\n          sbit->green == 0 || sbit->green > maxbits ||\n          sbit->blue == 0 || sbit->blue > maxbits)\n      {\n         png_warning(png_ptr, \"Invalid sBIT depth specified\");\n         return;\n      }\n\n      buf[0] = sbit->red;\n      buf[1] = sbit->green;\n      buf[2] = sbit->blue;\n      size = 3;\n   }\n\n   else\n   {\n      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)\n      {\n         png_warning(png_ptr, \"Invalid sBIT depth specified\");\n         return;\n      }\n\n      buf[0] = sbit->gray;\n      size = 1;\n   }\n\n   if (color_type & PNG_COLOR_MASK_ALPHA)\n   {\n      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)\n      {\n         png_warning(png_ptr, \"Invalid sBIT depth specified\");\n         return;\n      }\n\n      buf[size++] = sbit->alpha;\n   }\n\n   png_write_chunk(png_ptr, png_sBIT, buf, size);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* The png_save_int_32 function assumes integers are stored in two's\n * complement format.  If this isn't the case, then this routine needs to\n * be modified to write data in two's complement format.  Note that,\n * the following works correctly even if png_int_32 has more than 32 bits\n * (compare the more complex code required on read for sign extention.)\n */\n", "func_signal": "void PNGAPI\npng_save_int_32(png_bytep buf, png_int_32 i)", "code": "{\n   buf[0] = (png_byte)((i >> 24) & 0xff);\n   buf[1] = (png_byte)((i >> 16) & 0xff);\n   buf[2] = (png_byte)((i >> 8) & 0xff);\n   buf[3] = (png_byte)(i & 0xff);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_zTXt(png_structp png_ptr, png_const_charp key, png_const_charp text,\n    png_size_t text_len, int compression)", "code": "{\n   PNG_zTXt;\n   png_size_t key_len;\n   png_byte buf;\n   png_charp new_key;\n   compression_state comp;\n\n   png_debug(1, \"in png_write_zTXt\");\n\n   comp.num_output_ptr = 0;\n   comp.max_output_ptr = 0;\n   comp.output_ptr = NULL;\n   comp.input = NULL;\n   comp.input_len = 0;\n\n   if ((key_len = png_check_keyword(png_ptr, key, &new_key)) == 0)\n   {\n      png_free(png_ptr, new_key);\n      return;\n   }\n\n   if (text == NULL || *text == '\\0' || compression==PNG_TEXT_COMPRESSION_NONE)\n   {\n      png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);\n      png_free(png_ptr, new_key);\n      return;\n   }\n\n   text_len = png_strlen(text);\n\n   /* Compute the compressed data; do it now for the length */\n   text_len = png_text_compress(png_ptr, text, text_len, compression,\n       &comp);\n\n   /* Write start of chunk */\n   png_write_chunk_start(png_ptr, png_zTXt,\n       (png_uint_32)(key_len+text_len + 2));\n\n   /* Write key */\n   png_write_chunk_data(png_ptr, (png_bytep)new_key,\n       (png_size_t)(key_len + 1));\n\n   png_free(png_ptr, new_key);\n\n   buf = (png_byte)compression;\n\n   /* Write compression */\n   png_write_chunk_data(png_ptr, &buf, (png_size_t)1);\n\n   /* Write the compressed data */\n   png_write_compressed_data_out(png_ptr, &comp);\n\n   /* Close the chunk */\n   png_write_chunk_end(png_ptr);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)", "code": "{\n   png_size_t avail;\n\n   png_debug(1, \"in png_write_filtered_row\");\n\n   png_debug1(2, \"filter = %d\", filtered_row[0]);\n   /* Set up the zlib input buffer */\n\n   png_ptr->zstream.next_in = filtered_row;\n   png_ptr->zstream.avail_in = 0;\n   avail = png_ptr->row_info.rowbytes + 1;\n   /* Repeat until we have compressed all the data */\n   do\n   {\n      int ret; /* Return of zlib */\n\n      /* Record the number of bytes available - zlib supports at least 65535\n       * bytes at one step, depending on the size of the zlib type 'uInt', the\n       * maximum size zlib can write at once is ZLIB_IO_MAX (from pngpriv.h).\n       * Use this because on 16 bit systems 'rowbytes' can be up to 65536 (i.e.\n       * one more than 16 bits) and, in this case 'rowbytes+1' can overflow a\n       * uInt.  ZLIB_IO_MAX can be safely reduced to cause zlib to be called\n       * with smaller chunks of data.\n       */\n      if (png_ptr->zstream.avail_in == 0)\n      {\n         if (avail > ZLIB_IO_MAX)\n         {\n            png_ptr->zstream.avail_in  = ZLIB_IO_MAX;\n            avail -= ZLIB_IO_MAX;\n         }\n\n         else\n         {\n            /* So this will fit in the available uInt space: */\n            png_ptr->zstream.avail_in = (uInt)avail;\n            avail = 0;\n         }\n      }\n\n      /* Compress the data */\n      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);\n\n      /* Check for compression errors */\n      if (ret != Z_OK)\n      {\n         if (png_ptr->zstream.msg != NULL)\n            png_error(png_ptr, png_ptr->zstream.msg);\n\n         else\n            png_error(png_ptr, \"zlib error\");\n      }\n\n      /* See if it is time to write another IDAT */\n      if (!(png_ptr->zstream.avail_out))\n      {\n         /* Write the IDAT and reset the zlib output buffer */\n         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);\n         png_ptr->zstream.next_out = png_ptr->zbuf;\n         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n      }\n   /* Repeat until all data has been compressed */\n   } while (avail > 0 || png_ptr->zstream.avail_in > 0);\n\n   /* Swap the current and previous rows */\n   if (png_ptr->prev_row != NULL)\n   {\n      png_bytep tptr;\n\n      tptr = png_ptr->prev_row;\n      png_ptr->prev_row = png_ptr->row_buf;\n      png_ptr->row_buf = tptr;\n   }\n\n   /* Finish row - updates counters and flushes zlib if last row */\n   png_write_finish_row(png_ptr);\n\n#ifdef PNG_WRITE_FLUSH_SUPPORTED\n   png_ptr->flush_rows++;\n\n   if (png_ptr->flush_dist > 0 &&\n       png_ptr->flush_rows >= png_ptr->flush_dist)\n   {\n      png_write_flush(png_ptr);\n   }\n#endif\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/*\n * get_data() - takes first byte and converts into next pixel value,\n *        taking as much bits as defined by bit-depth and\n *        using the bit-depth to fill up a byte (0Ah -> AAh)\n */\n", "func_signal": "png_uint_32 get_data (FILE *pnm_file, int depth)", "code": "{\n  static int bits_left = 0;\n  static int old_value = 0;\n  static int mask = 0;\n  int i;\n  png_uint_32 ret_value;\n\n  if (mask == 0)\n    for (i = 0; i < depth; i++)\n      mask = (mask >> 1) | 0x80;\n\n  if (bits_left <= 0)\n  {\n    old_value = fgetc (pnm_file);\n    bits_left = 8;\n  }\n\n  ret_value = old_value & mask;\n  for (i = 1; i < (8 / depth); i++)\n    ret_value = ret_value || (ret_value >> depth);\n\n  old_value = (old_value << depth) & 0xFF;\n  bits_left -= depth;\n\n  return ret_value;\n}", "path": "jni\\sox\\libpng-1.5.2\\contrib\\pngminus\\pnm2png.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_text_compress(png_structp png_ptr,\n    png_const_charp text, png_size_t text_len, int compression,\n    compression_state *comp)", "code": "{\n   int ret;\n\n   comp->num_output_ptr = 0;\n   comp->max_output_ptr = 0;\n   comp->output_ptr = NULL;\n   comp->input = NULL;\n   comp->input_len = 0;\n\n   /* We may just want to pass the text right through */\n   if (compression == PNG_TEXT_COMPRESSION_NONE)\n   {\n      comp->input = (png_const_bytep)text;\n      comp->input_len = text_len;\n      return((int)text_len);\n   }\n\n   if (compression >= PNG_TEXT_COMPRESSION_LAST)\n   {\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n      char msg[50];\n      png_snprintf(msg, 50, \"Unknown compression type %d\", compression);\n      png_warning(png_ptr, msg);\n#else\n      png_warning(png_ptr, \"Unknown compression type\");\n#endif\n   }\n\n   /* We can't write the chunk until we find out how much data we have,\n    * which means we need to run the compressor first and save the\n    * output.  This shouldn't be a problem, as the vast majority of\n    * comments should be reasonable, but we will set up an array of\n    * malloc'd pointers to be sure.\n    *\n    * If we knew the application was well behaved, we could simplify this\n    * greatly by assuming we can always malloc an output buffer large\n    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)\n    * and malloc this directly.  The only time this would be a bad idea is\n    * if we can't malloc more than 64K and we have 64K of random input\n    * data, or if the input string is incredibly large (although this\n    * wouldn't cause a failure, just a slowdown due to swapping).\n    */\n\n   /* Set up the compression buffers */\n   /* TODO: the following cast hides a potential overflow problem. */\n   png_ptr->zstream.avail_in = (uInt)text_len;\n   /* NOTE: assume zlib doesn't overwrite the input */\n   png_ptr->zstream.next_in = (Bytef *)text;\n   png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n   png_ptr->zstream.next_out = png_ptr->zbuf;\n\n   /* This is the same compression loop as in png_write_row() */\n   do\n   {\n      /* Compress the data */\n      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);\n\n      if (ret != Z_OK)\n      {\n         /* Error */\n         if (png_ptr->zstream.msg != NULL)\n            png_error(png_ptr, png_ptr->zstream.msg);\n\n         else\n            png_error(png_ptr, \"zlib error\");\n      }\n\n      /* Check to see if we need more room */\n      if (!(png_ptr->zstream.avail_out))\n      {\n         /* Make sure the output array has room */\n         if (comp->num_output_ptr >= comp->max_output_ptr)\n         {\n            int old_max;\n\n            old_max = comp->max_output_ptr;\n            comp->max_output_ptr = comp->num_output_ptr + 4;\n            if (comp->output_ptr != NULL)\n            {\n               png_bytepp old_ptr;\n\n               old_ptr = comp->output_ptr;\n\n               comp->output_ptr = (png_bytepp)png_malloc(png_ptr,\n                   (png_alloc_size_t)\n                   (comp->max_output_ptr * png_sizeof(png_charpp)));\n\n               png_memcpy(comp->output_ptr, old_ptr, old_max\n                   * png_sizeof(png_charp));\n\n               png_free(png_ptr, old_ptr);\n            }\n            else\n               comp->output_ptr = (png_bytepp)png_malloc(png_ptr,\n                   (png_alloc_size_t)\n                   (comp->max_output_ptr * png_sizeof(png_charp)));\n         }\n\n         /* Save the data */\n         comp->output_ptr[comp->num_output_ptr] =\n             (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)png_ptr->zbuf_size);\n\n         png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,\n             png_ptr->zbuf_size);\n\n         comp->num_output_ptr++;\n\n         /* and reset the buffer */\n         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n         png_ptr->zstream.next_out = png_ptr->zbuf;\n      }\n   /* Continue until we don't have any more to compress */\n   } while (png_ptr->zstream.avail_in);\n\n   /* Finish the compression */\n   do\n   {\n      /* Tell zlib we are finished */\n      ret = deflate(&png_ptr->zstream, Z_FINISH);\n\n      if (ret == Z_OK)\n      {\n         /* Check to see if we need more room */\n         if (!(png_ptr->zstream.avail_out))\n         {\n            /* Check to make sure our output array has room */\n            if (comp->num_output_ptr >= comp->max_output_ptr)\n            {\n               int old_max;\n\n               old_max = comp->max_output_ptr;\n               comp->max_output_ptr = comp->num_output_ptr + 4;\n               if (comp->output_ptr != NULL)\n               {\n                  png_bytepp old_ptr;\n\n                  old_ptr = comp->output_ptr;\n\n                  /* This could be optimized to realloc() */\n                  comp->output_ptr = (png_bytepp)png_malloc(png_ptr,\n                      (png_alloc_size_t)(comp->max_output_ptr *\n                      png_sizeof(png_charp)));\n\n                  png_memcpy(comp->output_ptr, old_ptr,\n                      old_max * png_sizeof(png_charp));\n\n                  png_free(png_ptr, old_ptr);\n               }\n\n               else\n                  comp->output_ptr = (png_bytepp)png_malloc(png_ptr,\n                      (png_alloc_size_t)(comp->max_output_ptr *\n                      png_sizeof(png_charp)));\n            }\n\n            /* Save the data */\n            comp->output_ptr[comp->num_output_ptr] =\n                (png_bytep)png_malloc(png_ptr,\n                (png_alloc_size_t)png_ptr->zbuf_size);\n\n            png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,\n                png_ptr->zbuf_size);\n\n            comp->num_output_ptr++;\n\n            /* and reset the buffer pointers */\n            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            png_ptr->zstream.next_out = png_ptr->zbuf;\n         }\n      }\n      else if (ret != Z_STREAM_END)\n      {\n         /* We got an error */\n         if (png_ptr->zstream.msg != NULL)\n            png_error(png_ptr, png_ptr->zstream.msg);\n\n         else\n            png_error(png_ptr, \"zlib error\");\n      }\n   } while (ret != Z_STREAM_END);\n\n   /* Text length is number of buffers plus last buffer */\n   text_len = png_ptr->zbuf_size * comp->num_output_ptr;\n\n   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)\n      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;\n\n   return((int)text_len);\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/*\n *  main\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n  FILE *fp_rd = stdin;\n  FILE *fp_al = NULL;\n  FILE *fp_wr = stdout;\n  BOOL interlace = FALSE;\n  BOOL alpha = FALSE;\n  int argi;\n\n  for (argi = 1; argi < argc; argi++)\n  {\n    if (argv[argi][0] == '-')\n    {\n      switch (argv[argi][1])\n      {\n        case 'i':\n          interlace = TRUE;\n          break;\n        case 'a':\n          alpha = TRUE;\n          argi++;\n          if ((fp_al = fopen (argv[argi], \"rb\")) == NULL)\n          {\n            fprintf (stderr, \"PNM2PNG\\n\");\n            fprintf (stderr, \"Error:  alpha-channel file %s does not exist\\n\",\n               argv[argi]);\n            exit (1);\n          }\n          break;\n        case 'h':\n        case '?':\n          usage();\n          exit(0);\n          break;\n        default:\n          fprintf (stderr, \"PNM2PNG\\n\");\n          fprintf (stderr, \"Error:  unknown option %s\\n\", argv[argi]);\n          usage();\n          exit(1);\n          break;\n      } /* end switch */\n    }\n    else if (fp_rd == stdin)\n    {\n      if ((fp_rd = fopen (argv[argi], \"rb\")) == NULL)\n      {\n        fprintf (stderr, \"PNM2PNG\\n\");\n        fprintf (stderr, \"Error:  file %s does not exist\\n\", argv[argi]);\n        exit (1);\n      }\n    }\n    else if (fp_wr == stdout)\n    {\n      if ((fp_wr = fopen (argv[argi], \"wb\")) == NULL)\n      {\n        fprintf (stderr, \"PNM2PNG\\n\");\n        fprintf (stderr, \"Error:  can not create PNG-file %s\\n\", argv[argi]);\n        exit (1);\n      }\n    }\n    else\n    {\n      fprintf (stderr, \"PNM2PNG\\n\");\n      fprintf (stderr, \"Error:  too many parameters\\n\");\n      usage();\n      exit (1);\n    }\n  } /* end for */\n\n#ifdef __TURBOC__\n  /* set stdin/stdout to binary, we're reading the PNM always! in binary format */\n  if (fp_rd == stdin)\n  {\n    setmode (STDIN, O_BINARY);\n  }\n  if (fp_wr == stdout)\n  {\n    setmode (STDOUT, O_BINARY);\n  }\n#endif\n\n  /* call the conversion program itself */\n  if (pnm2png (fp_rd, fp_wr, fp_al, interlace, alpha) == FALSE)\n  {\n    fprintf (stderr, \"PNM2PNG\\n\");\n    fprintf (stderr, \"Error:  unsuccessful converting to PNG-image\\n\");\n    exit (1);\n  }\n\n  /* close input file */\n  fclose (fp_rd);\n  /* close output file */\n  fclose (fp_wr);\n  /* close alpha file */\n  if (alpha)\n    fclose (fp_al);\n\n  return 0;\n}", "path": "jni\\sox\\libpng-1.5.2\\contrib\\pngminus\\pnm2png.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* Simple function to write the signature.  If we have already written\n * the magic bytes of the signature, or more likely, the PNG stream is\n * being embedded into another stream and doesn't need its own signature,\n * we should call png_set_sig_bytes() to tell libpng how many of the\n * bytes have already been written.\n */\n", "func_signal": "void PNGAPI\npng_write_sig(png_structp png_ptr)", "code": "{\n   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   /* Inform the I/O callback that the signature is being written */\n   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_SIGNATURE;\n#endif\n\n   /* Write the rest of the 8 byte signature */\n   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],\n      (png_size_t)(8 - png_ptr->sig_bytes));\n\n   if (png_ptr->sig_bytes < 3)\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n}", "path": "jni\\sox\\libpng-1.5.2\\pngwutil.c", "repo_name": "Kyborg2011/SoxPlayer", "stars": 30, "license": "None", "language": "c", "size": 100161}
{"docstring": "/* prefix_uli \u2022 returns ordered list item prefix */\n", "func_signal": "static size_t\nprefix_uli(char *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i + 1 >= size\n\t|| (data[i] != '*' && data[i] != '+' && data[i] != '-')\n\t|| (data[i + 1] != ' ' && data[i + 1] != '\\t'))\n\t\treturn 0;\n\treturn i + 2;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/***************************\n * HELPER FUNCTIONS *\n ***************************/\n", "func_signal": "int\nis_safe_link(const char *link, size_t link_len)", "code": "{\n\tstatic const size_t valid_uris_count = 4;\n\tstatic const char *valid_uris[] = {\n\t\t\"http://\", \"https://\", \"ftp://\", \"mailto://\"\n\t};\n\n\tsize_t i;\n\n\tfor (i = 0; i < valid_uris_count; ++i) {\n\t\tsize_t len = strlen(valid_uris[i]);\n\n\t\tif (link_len > len && memcmp(link, valid_uris[i], len) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* cmp_link_ref \u2022 comparison function for link_ref sorted arrays */\n", "func_signal": "static int\ncmp_link_ref(void *key, void *array_entry)", "code": "{\n\tstruct link_ref *lr = array_entry;\n\treturn bufcasecmp(key, lr->id);\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* char_link \u2022 '[': parsing a link or an image */\n", "func_signal": "static size_t\nchar_link(struct buf *ob, struct render *rndr, char *data, size_t offset, size_t size)", "code": "{\n\tint is_img = (offset && data[-1] == '!'), level;\n\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n\tstruct buf *content = 0;\n\tstruct buf *link = 0;\n\tstruct buf *title = 0;\n\tsize_t org_work_size = rndr->work.size;\n\tint text_has_nl = 0, ret = 0;\n\n\t/* checking whether the correct renderer exists */\n\tif ((is_img && !rndr->make.image) || (!is_img && !rndr->make.link))\n\t\tgoto cleanup;\n\n\t/* looking for the matching closing bracket */\n\tfor (level = 1; i < size; i += 1) {\n\t\tif (data[i] == '\\n')\n\t\t\ttext_has_nl = 1;\n\n\t\telse if (data[i - 1] == '\\\\')\n\t\t\tcontinue;\n\n\t\telse if (data[i] == '[')\n\t\t\tlevel++;\n\n\t\telse if (data[i] == ']') {\n\t\t\tlevel--;\n\t\t\tif (level <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= size)\n\t\tgoto cleanup;\n\n\ttxt_e = i;\n\ti += 1;\n\n\t/* skip any amount of whitespace or newline */\n\t/* (this is much more laxist than original markdown syntax) */\n\twhile (i < size && isspace(data[i]))\n\t\ti++;\n\n\t/* inline style link */\n\tif (i < size && data[i] == '(') {\n\t\t/* skipping initial whitespace */\n\t\ti += 1;\n\n\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\t'))\n\t\t\ti++;\n\n\t\tlink_b = i;\n\n\t\t/* looking for link end: ' \" ) */\n\t\twhile (i < size && data[i] != '\\'' && data[i] != '\"' && data[i] != ')')\n\t\t\ti++;\n\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* looking for title end if present */\n\t\tif (data[i] == '\\'' || data[i] == '\"') {\n\t\t\ti++;\n\t\t\ttitle_b = i;\n\n\t\t\twhile (i < size && data[i] != ')') i++;\n\t\t\tif (i >= size) goto cleanup;\n\n\t\t\t/* skipping whitespaces after title */\n\t\t\ttitle_e = i - 1;\n\t\t\twhile (title_e > title_b && isspace(data[title_e]))\n\t\t\t\ttitle_e--;\n\n\t\t\t/* checking for closing quote presence */\n\t\t\tif (data[title_e] != '\\'' &&  data[title_e] != '\"') {\n\t\t\t\ttitle_b = title_e = 0;\n\t\t\t\tlink_e = i;\n\t\t\t}\n\t\t}\n\n\t\t/* remove whitespace at the end of the link */\n\t\twhile (link_e > link_b && (data[link_e - 1] == ' ' || data[link_e - 1] == '\\t'))\n\t\t\tlink_e--;\n\n\t\t/* remove optional angle brackets around the link */\n\t\tif (data[link_b] == '<') link_b++;\n\t\tif (data[link_e - 1] == '>') link_e--;\n\n\t\t/* building escaped link and title */\n\t\tif (link_e > link_b) {\n\t\t\tlink = rndr_newbuf(rndr);\n\t\t\tbufput(link, data + link_b, link_e - link_b);\n\t\t}\n\n\t\tif (title_e > title_b) {\n\t\t\ttitle = rndr_newbuf(rndr);\n\t\t\tbufput(title, data + title_b, title_e - title_b);\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* reference style link */\n\telse if (i < size && data[i] == '[') {\n\t\tstruct buf id = { 0, 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* looking for the id */\n\t\ti += 1;\n\t\tlink_b = i;\n\t\twhile (i < size && data[i] != ']') i++;\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* finding the link_ref */\n\t\tif (link_b == link_e) {\n\t\t\tif (text_has_nl) {\n\t\t\t\tstruct buf *b = rndr_newbuf(rndr);\n\t\t\t\tsize_t j;\n\n\t\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\t\tbufputc(b, ' ');\n\t\t\t\t}\n\n\t\t\t\tid.data = b->data;\n\t\t\t\tid.size = b->size;\n\t\t\t} else {\n\t\t\t\tid.data = data + 1;\n\t\t\t\tid.size = txt_e - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tid.data = data + link_b;\n\t\t\tid.size = link_e - link_b;\n\t\t}\n\n\t\tlr = arr_sorted_find(&rndr->refs, &id, cmp_link_ref);\n\t\tif (!lr) goto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\t\ti += 1;\n\t}\n\n\t/* shortcut reference style link */\n\telse {\n\t\tstruct buf id = { 0, 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* crafting the id */\n\t\tif (text_has_nl) {\n\t\t\tstruct buf *b = rndr_newbuf(rndr);\n\t\t\tsize_t j;\n\n\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\tbufputc(b, ' ');\n\t\t\t}\n\n\t\t\tid.data = b->data;\n\t\t\tid.size = b->size;\n\t\t} else {\n\t\t\tid.data = data + 1;\n\t\t\tid.size = txt_e - 1;\n\t\t}\n\n\t\t/* finding the link_ref */\n\t\tlr = arr_sorted_find(&rndr->refs, &id, cmp_link_ref);\n\t\tif (!lr) goto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\n\t\t/* rewinding the whitespace */\n\t\ti = txt_e + 1;\n\t}\n\n\t/* building content: img alt is escaped, link content is parsed */\n\tif (txt_e > 1) {\n\t\tcontent = rndr_newbuf(rndr);\n\t\tif (is_img) bufput(content, data + 1, txt_e - 1);\n\t\telse parse_inline(content, rndr, data + 1, txt_e - 1);\n\t}\n\n\t/* calling the relevant rendering function */\n\tif (is_img) {\n\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n\t\t\tob->size -= 1;\n\n\t\tret = rndr->make.image(ob, link, title, content, rndr->make.opaque);\n\t} else\n\t\tret = rndr->make.link(ob, link, title, content, rndr->make.opaque);\n\n\t/* cleanup */\ncleanup:\n\trndr->work.size = (int)org_work_size;\n\treturn ret ? i : 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* cmp_html_tag \u2022 comparison function for bsearch() (stolen from discount) */\n", "func_signal": "static int\ncmp_html_tag(const void *a, const void *b)", "code": "{\n\tconst struct html_tag *hta = a;\n\tconst struct html_tag *htb = b;\n\tif (hta->size != htb->size) return (int)((ssize_t)hta->size - (ssize_t)htb->size);\n\treturn strncasecmp(hta->text, htb->text, hta->size);\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_block \u2022 parsing of one block, returning next char to parse */\n", "func_signal": "static void\nparse_block(struct buf *ob, struct render *rndr, char *data, size_t size)", "code": "{\n\tsize_t beg, end, i;\n\tchar *txt_data;\n\tbeg = 0;\n\n\tif (rndr->work.size > rndr->max_nesting)\n\t\treturn;\n\n\twhile (beg < size) {\n\t\ttxt_data = data + beg;\n\t\tend = size - beg;\n\n\t\tif (data[beg] == '#')\n\t\t\tbeg += parse_atxheader(ob, rndr, txt_data, end);\n\n\t\telse if (data[beg] == '<' && rndr->make.blockhtml &&\n\t\t\t\t(i = parse_htmlblock(ob, rndr, txt_data, end, 1)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((i = is_empty(txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (is_hrule(txt_data, end)) {\n\t\t\tif (rndr->make.hrule)\n\t\t\t\trndr->make.hrule(ob, rndr->make.opaque);\n\n\t\t\twhile (beg < size && data[beg] != '\\n')\n\t\t\t\tbeg++;\n\n\t\t\tbeg++;\n\t\t}\n\n\t\telse if ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n\t\t\t(i = parse_fencedcode(ob, rndr, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((rndr->ext_flags & MKDEXT_TABLES) != 0 &&\n\t\t\t(i = parse_table(ob, rndr, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (prefix_quote(txt_data, end))\n\t\t\tbeg += parse_blockquote(ob, rndr, txt_data, end);\n\n\t\telse if (prefix_code(txt_data, end))\n\t\t\tbeg += parse_blockcode(ob, rndr, txt_data, end);\n\n\t\telse if (prefix_uli(txt_data, end))\n\t\t\tbeg += parse_list(ob, rndr, txt_data, end, 0);\n\n\t\telse if (prefix_oli(txt_data, end))\n\t\t\tbeg += parse_list(ob, rndr, txt_data, end, MKD_LIST_ORDERED);\n\n\t\telse\n\t\t\tbeg += parse_paragraph(ob, rndr, txt_data, end);\n\t}\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* find_block_tag \u2022 returns the current block tag */\n", "func_signal": "static struct html_tag *\nfind_block_tag(char *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\tstruct html_tag key;\n\n\t/* looking for the word end */\n\twhile (i < size && ((data[i] >= '0' && data[i] <= '9')\n\t\t\t\t|| (data[i] >= 'A' && data[i] <= 'Z')\n\t\t\t\t|| (data[i] >= 'a' && data[i] <= 'z')))\n\t\ti += 1;\n\tif (i >= size) return 0;\n\n\t/* binary search of the tag */\n\tkey.text = data;\n\tkey.size = i;\n\treturn bsearch(&key, block_tags,\n\t\t\t\tsizeof block_tags / sizeof block_tags[0],\n\t\t\t\tsizeof block_tags[0], cmp_html_tag);\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n", "func_signal": "static size_t\nchar_langle_tag(struct buf *ob, struct render *rndr, char *data, size_t offset, size_t size)", "code": "{\n\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n\tsize_t end = tag_length(data, size, &altype);\n\tstruct buf work = { data, end, 0, 0, 0 };\n\tint ret = 0;\n\n\tif (end > 2) {\n\t\tif (rndr->make.autolink && altype != MKDA_NOT_AUTOLINK) {\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tret = rndr->make.autolink(ob, &work, altype, rndr->make.opaque);\n\t\t}\n\t\telse if (rndr->make.raw_html_tag)\n\t\t\tret = rndr->make.raw_html_tag(ob, &work, rndr->make.opaque);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* is_ref \u2022 returns whether a line is a reference or not */\n", "func_signal": "static int\nis_ref(char *data, size_t beg, size_t end, size_t *last, struct array *refs)", "code": "{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\tstruct link_ref *lr;\n/*\tstruct buf id = { 0, 0, 0, 0, 0 }; / * volatile buf for id search */\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti += 1;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti += 1;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti += 1;\n\tif (i >= end || data[i] != ':') return 0;\n\ti += 1;\n\twhile (i < end && (data[i] == ' ' || data[i] == '\\t')) i += 1;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti += 1;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i += 1; }\n\twhile (i < end && (data[i] == ' ' || data[i] == '\\t')) i += 1;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<') i += 1;\n\tlink_offset = i;\n\twhile (i < end && data[i] != ' ' && data[i] != '\\t'\n\t\t\t&& data[i] != '\\n' && data[i] != '\\r') i += 1;\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && (data[i] == ' ' || data[i] == '\\t')) i += 1;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && (data[i] == ' ' || data[i] == '\\t')) i += 1; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti += 1;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i += 1;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && (data[i] == ' ' || data[i] == '\\t'))\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\tif (!line_end) return 0; /* garbage after the link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last) *last = line_end;\n\tif (!refs) return 1;\n\tlr = arr_item(refs, arr_newitem(refs));\n\tlr->id = bufnew(id_end - id_offset);\n\tbufput(lr->id, data + id_offset, id_end - id_offset);\n\tlr->link = bufnew(link_end - link_offset);\n\tbufput(lr->link, data + link_offset, link_end - link_offset);\n\tif (title_end > title_offset) {\n\t\tlr->title = bufnew(title_end - title_offset);\n\t\tbufput(lr->title, data + title_offset,\n\t\t\t\t\ttitle_end - title_offset); }\n\telse lr->title = 0;\n\treturn 1; \n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* char_entity \u2022 '&' escaped when it doesn't belong to an entity */\n/* valid entities are assumed to be anything mathing &#?[A-Za-z0-9]+; */\n", "func_signal": "static size_t\nchar_entity(struct buf *ob, struct render *rndr, char *data, size_t offset, size_t size)", "code": "{\n\tsize_t end = 1;\n\tstruct buf work;\n\n\tif (end < size && data[end] == '#')\n\t\tend++;\n\n\twhile (end < size && isalnum(data[end]))\n\t\tend++;\n\n\tif (end < size && data[end] == ';')\n\t\tend += 1; /* real entity */\n\telse\n\t\treturn 0; /* lone '&' */\n\n\tif (rndr->make.entity) {\n\t\twork.data = data;\n\t\twork.size = end;\n\t\trndr->make.entity(ob, &work, rndr->make.opaque);\n\t}\n\telse bufput(ob, data, end);\n\n\treturn end;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_blockquote \u2022 hanldes parsing of a blockquote fragment */\n", "func_signal": "static size_t\nparse_blockquote(struct buf *ob, struct render *rndr, char *data, size_t size)", "code": "{\n\tsize_t beg, end = 0, pre, work_size = 0;\n\tchar *work_data = 0;\n\tstruct buf *out = 0;\n\n\tout = rndr_newbuf(rndr);\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tpre = prefix_quote(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\n\t\t/* empty line followed by non-quote line */\n\t\telse if (is_empty(data + beg, end - beg) &&\n\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n\t\t\t\t!is_empty(data + end, size - end))))\n\t\t\tbreak;\n\n\t\tif (beg < end) { /* copy into the in-place working buffer */\n\t\t\t/* bufput(work, data + beg, end - beg); */\n\t\t\tif (!work_data)\n\t\t\t\twork_data = data + beg;\n\t\t\telse if (data + beg != work_data + work_size)\n\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n\t\t\twork_size += end - beg;\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tparse_block(out, rndr, work_data, work_size);\n\tif (rndr->make.blockquote)\n\t\trndr->make.blockquote(ob, out, rndr->make.opaque);\n\trndr_popbuf(rndr);\n\treturn end;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* find_emph_char \u2022 looks for the next emph char, skipping other constructs */\n", "func_signal": "static size_t\nfind_emph_char(char *data, size_t size, char c)", "code": "{\n\tsize_t i = 1;\n\n\twhile (i < size) {\n\t\twhile (i < size && data[i] != c\n\t\t&& data[i] != '`' && data[i] != '[')\n\t\t\ti += 1;\n\t\tif (data[i] == c) return i;\n\n\t\t/* not counting escaped chars */\n\t\tif (i && data[i - 1] == '\\\\') { i += 1; continue; }\n\n\t\t/* skipping a code span */\n\t\tif (data[i] == '`') {\n\t\t\tsize_t tmp_i = 0;\n\t\t\ti += 1;\n\t\t\twhile (i < size && data[i] != '`') {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti += 1; }\n\t\t\tif (i >= size) return tmp_i;\n\t\t\ti += 1; }\n\n\t\t/* skipping a link */\n\t\telse if (data[i] == '[') {\n\t\t\tsize_t tmp_i = 0;\n\t\t\tchar cc;\n\t\t\ti += 1;\n\t\t\twhile (i < size && data[i] != ']') {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti += 1; }\n\t\t\ti += 1;\n\t\t\twhile (i < size && (data[i] == ' '\n\t\t\t|| data[i] == '\\t' || data[i] == '\\n'))\n\t\t\t\ti += 1;\n\t\t\tif (i >= size) return tmp_i;\n\t\t\tif (data[i] != '[' && data[i] != '(') { /* not a link*/\n\t\t\t\tif (tmp_i) return tmp_i;\n\t\t\t\telse continue; }\n\t\t\tcc = data[i];\n\t\t\ti += 1;\n\t\t\twhile (i < size && data[i] != cc) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti += 1; }\n\t\t\tif (i >= size) return tmp_i;\n\t\t\ti += 1; } }\n\treturn 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_list \u2022 parsing ordered or unordered list block */\n", "func_signal": "static size_t\nparse_list(struct buf *ob, struct render *rndr, char *data, size_t size, int flags)", "code": "{\n\tstruct buf *work = 0;\n\tsize_t i = 0, j;\n\n\twork = rndr_newbuf(rndr);\n\n\twhile (i < size) {\n\t\tj = parse_listitem(work, rndr, data + i, size - i, &flags);\n\t\ti += j;\n\n\t\tif (!j || (flags & MKD_LI_END))\n\t\t\tbreak;\n\t}\n\n\tif (rndr->make.list)\n\t\trndr->make.list(ob, work, flags, rndr->make.opaque);\n\trndr_popbuf(rndr);\n\treturn i;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* prefix_code \u2022 returns prefix length for block code*/\n", "func_signal": "static size_t\nprefix_code(char *data, size_t size)", "code": "{\n\tif (size > 0 && data[0] == '\\t') return 1;\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_atxheader \u2022 parsing of atx-style headers */\n", "func_signal": "static size_t\nparse_atxheader(struct buf *ob, struct render *rndr, char *data, size_t size)", "code": "{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\n\tif (!size || data[0] != '#')\n\t\treturn 0;\n\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\n\tfor (i = level; i < size && (data[i] == ' ' || data[i] == '\\t'); i++);\n\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\n\twhile (end && (data[end - 1] == ' ' || data[end - 1] == '\\t'))\n\t\tend--;\n\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr);\n\n\t\tparse_inline(work, rndr, data + i, end - i);\n\n\t\tif (rndr->make.header)\n\t\t\trndr->make.header(ob, work, (int)level, rndr->make.opaque);\n\n\t\trndr_popbuf(rndr);\n\t}\n\n\treturn skip;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* prefix_oli \u2022 returns ordered list item prefix */\n", "func_signal": "static size_t\nprefix_oli(char *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i < size && data[i] == ' ') i += 1;\n\tif (i >= size || data[i] < '0' || data[i] > '9') return 0;\n\twhile (i < size && data[i] >= '0' && data[i] <= '9') i += 1;\n\tif (i + 1 >= size || data[i] != '.'\n\t|| (data[i + 1] != ' ' && data[i + 1] != '\\t')) return 0;\n\treturn i + 2;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* is_headerline \u2022 returns whether the line is a setext-style hdr underline */\n", "func_signal": "static int\nis_headerline(char *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\n\t/* test of level 1 header */\n\tif (data[i] == '=') {\n\t\tfor (i = 1; i < size && data[i] == '='; i += 1);\n\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\t')) i += 1;\n\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n\n\t/* test of level 2 header */\n\tif (data[i] == '-') {\n\t\tfor (i = 1; i < size && data[i] == '-'; i += 1);\n\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\t')) i += 1;\n\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n\n\treturn 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_emph1 \u2022 parsing single emphase */\n/* closed by a symbol not preceded by whitespace and not followed by symbol */\n", "func_signal": "static size_t\nparse_emph1(struct buf *ob, struct render *rndr, char *data, size_t size, char c)", "code": "{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\tif (!rndr->make.emphasis) return 0;\n\n\t/* skipping one symbol if coming from emph3 */\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\n\t\tif (i + 1 < size && data[i + 1] == c) {\n\t\t\ti += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data[i] == c && !isspace(data[i - 1])) {\n\n\t\t\tif ((rndr->ext_flags & MKDEXT_LAX_EMPHASIS) == 0) {\n\t\t\t\tif (!(i + 1 == size || isspace(data[i + 1]) || ispunct(data[i + 1])))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twork = rndr_newbuf(rndr);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->make.emphasis(ob, work, c, rndr->make.opaque);\n\t\t\trndr_popbuf(rndr);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* parse_inline \u2022 parses inline markdown elements */\n", "func_signal": "static void\nparse_inline(struct buf *ob, struct render *rndr, char *data, size_t size)", "code": "{\n\tsize_t i = 0, end = 0;\n\tchar_trigger action = 0;\n\tstruct buf work = { 0, 0, 0, 0, 0 };\n\n\tif (rndr->work.size > rndr->max_nesting)\n\t\treturn;\n\n\twhile (i < size) {\n\t\t/* copying inactive chars into the output */\n\t\twhile (end < size && (action = rndr->active_char[(unsigned char)data[end]]) == 0) {\n\t\t\tend++;\n\t\t}\n\n\t\tif (rndr->make.normal_text) {\n\t\t\twork.data = data + i;\n\t\t\twork.size = end - i;\n\t\t\trndr->make.normal_text(ob, &work, rndr->make.opaque);\n\t\t}\n\t\telse\n\t\t\tbufput(ob, data + i, end - i);\n\n\t\tif (end >= size) break;\n\t\ti = end;\n\n\t\t/* calling the trigger */\n\t\tend = action(ob, rndr, data + i, i, size - i);\n\t\tif (!end) /* no action from the callback */\n\t\t\tend = i + 1;\n\t\telse { \n\t\t\ti += end;\n\t\t\tend = i;\n\t\t} \n\t}\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* cmp_link_ref_sort \u2022 comparison function for link_ref qsort */\n", "func_signal": "static int\ncmp_link_ref_sort(const void *a, const void *b)", "code": "{\n\tconst struct link_ref *lra = a;\n\tconst struct link_ref *lrb = b;\n\treturn bufcasecmp(lra->id, lrb->id);\n}", "path": "src\\markdown.c", "repo_name": "paulsmith/cMarkdown", "stars": 16, "license": "isc", "language": "c", "size": 184}
{"docstring": "/* XXX: only one transport specification is parsed */\n", "func_signal": "static void rtsp_parse_transport(RTSPMessageHeader *reply, const char *p)", "code": "{\n    char transport_protocol[16];\n    char profile[16];\n    char lower_transport[16];\n    char parameter[16];\n    RTSPTransportField *th;\n    char buf[256];\n\n    reply->nb_transports = 0;\n\n    for (;;) {\n        p += strspn(p, SPACE_CHARS);\n        if (*p == '\\0')\n            break;\n\n        th = &reply->transports[reply->nb_transports];\n\n        get_word_sep(transport_protocol, sizeof(transport_protocol),\n                     \"/\", &p);\n        if (!strcasecmp (transport_protocol, \"rtp\")) {\n            get_word_sep(profile, sizeof(profile), \"/;,\", &p);\n            lower_transport[0] = '\\0';\n            /* rtp/avp/<protocol> */\n            if (*p == '/') {\n                get_word_sep(lower_transport, sizeof(lower_transport),\n                             \";,\", &p);\n            }\n            th->transport = RTSP_TRANSPORT_RTP;\n        } else if (!strcasecmp (transport_protocol, \"x-pn-tng\") ||\n                   !strcasecmp (transport_protocol, \"x-real-rdt\")) {\n            /* x-pn-tng/<protocol> */\n            get_word_sep(lower_transport, sizeof(lower_transport), \"/;,\", &p);\n            profile[0] = '\\0';\n            th->transport = RTSP_TRANSPORT_RDT;\n        }\n        if (!strcasecmp(lower_transport, \"TCP\"))\n            th->lower_transport = RTSP_LOWER_TRANSPORT_TCP;\n        else\n            th->lower_transport = RTSP_LOWER_TRANSPORT_UDP;\n\n        if (*p == ';')\n            p++;\n        /* get each parameter */\n        while (*p != '\\0' && *p != ',') {\n            get_word_sep(parameter, sizeof(parameter), \"=;,\", &p);\n            if (!strcmp(parameter, \"port\")) {\n                if (*p == '=') {\n                    p++;\n                    rtsp_parse_range(&th->port_min, &th->port_max, &p);\n                }\n            } else if (!strcmp(parameter, \"client_port\")) {\n                if (*p == '=') {\n                    p++;\n                    rtsp_parse_range(&th->client_port_min,\n                                     &th->client_port_max, &p);\n                }\n            } else if (!strcmp(parameter, \"server_port\")) {\n                if (*p == '=') {\n                    p++;\n                    rtsp_parse_range(&th->server_port_min,\n                                     &th->server_port_max, &p);\n                }\n            } else if (!strcmp(parameter, \"interleaved\")) {\n                if (*p == '=') {\n                    p++;\n                    rtsp_parse_range(&th->interleaved_min,\n                                     &th->interleaved_max, &p);\n                }\n            } else if (!strcmp(parameter, \"multicast\")) {\n                if (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP)\n                    th->lower_transport = RTSP_LOWER_TRANSPORT_UDP_MULTICAST;\n            } else if (!strcmp(parameter, \"ttl\")) {\n                if (*p == '=') {\n                    p++;\n                    th->ttl = strtol(p, (char **)&p, 10);\n                }\n            } else if (!strcmp(parameter, \"destination\")) {\n                if (*p == '=') {\n                    p++;\n                    get_word_sep(buf, sizeof(buf), \";,\", &p);\n                    get_sockaddr(buf, &th->destination);\n                }\n            } else if (!strcmp(parameter, \"source\")) {\n                if (*p == '=') {\n                    p++;\n                    get_word_sep(buf, sizeof(buf), \";,\", &p);\n                    av_strlcpy(th->source, buf, sizeof(th->source));\n                }\n            }\n\n            while (*p != ';' && *p != '\\0' && *p != ',')\n                p++;\n            if (*p == ';')\n                p++;\n        }\n        if (*p == ',')\n            p++;\n\n        reply->nb_transports++;\n    }\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/* parse the rtpmap description: <codec_name>/<clock_rate>[/<other params>] */\n", "func_signal": "static int sdp_parse_rtpmap(AVFormatContext *s,\n                            AVStream *st, RTSPStream *rtsp_st,\n                            int payload_type, const char *p)", "code": "{\n    AVCodecContext *codec = st->codec;\n    char buf[256];\n    int i;\n    AVCodec *c;\n    const char *c_name;\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n     * see if we can handle this kind of payload.\n     * The space should normally not be there but some Real streams or\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n     * have a trailing space. */\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n    if (payload_type >= RTP_PT_PRIVATE) {\n        RTPDynamicProtocolHandler *handler =\n            ff_rtp_handler_find_by_name(buf, codec->codec_type);\n        init_rtp_handler(handler, rtsp_st, codec);\n        /* If no dynamic handler was found, check with the list of standard\n         * allocated types, if such a stream for some reason happens to\n         * use a private payload type. This isn't handled in rtpdec.c, since\n         * the format name from the rtpmap line never is passed into rtpdec. */\n        if (!rtsp_st->dynamic_handler)\n            codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    } else {\n        /* We are in a standard case\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n        /* search into AVRtpPayloadTypes[] */\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n    }\n\n    c = avcodec_find_decoder(codec->codec_id);\n    if (c && c->name)\n        c_name = c->name;\n    else\n        c_name = \"(null)\";\n\n    get_word_sep(buf, sizeof(buf), \"/\", &p);\n    i = atoi(buf);\n    switch (codec->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n        codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n        codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n        if (i > 0) {\n            codec->sample_rate = i;\n            av_set_pts_info(st, 32, 1, codec->sample_rate);\n            get_word_sep(buf, sizeof(buf), \"/\", &p);\n            i = atoi(buf);\n            if (i > 0)\n                codec->channels = i;\n            // TODO: there is a bug here; if it is a mono stream, and\n            // less than 22000Hz, faad upconverts to stereo and twice\n            // the frequency.  No problem, but the sample rate is being\n            // set here by the sdp line. Patch on its way. (rdm)\n        }\n        av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n               codec->sample_rate);\n        av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n               codec->channels);\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n        if (i > 0)\n            av_set_pts_info(st, 32, 1, i);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * Translate an FFmpeg Picture into its VA API form.\n *\n * @param[out] va_pic          A pointer to VA API's own picture struct\n * @param[in]  pic             A pointer to the FFmpeg picture struct to convert\n * @param[in]  pic_structure   The picture field type (as defined in mpegvideo.h),\n *                             supersedes pic's field type if nonzero.\n */\n", "func_signal": "static void fill_vaapi_pic(VAPictureH264 *va_pic,\n                           Picture       *pic,\n                           int            pic_structure)", "code": "{\n    if (pic_structure == 0)\n        pic_structure = pic->reference;\n\n    va_pic->picture_id = ff_vaapi_get_surface_id(pic);\n    va_pic->frame_idx  = pic->long_ref ? pic->pic_id : pic->frame_num;\n\n    va_pic->flags      = 0;\n    if (pic_structure != PICT_FRAME)\n        va_pic->flags |= (pic_structure & PICT_TOP_FIELD) ? VA_PICTURE_H264_TOP_FIELD : VA_PICTURE_H264_BOTTOM_FIELD;\n    if (pic->reference)\n        va_pic->flags |= pic->long_ref ? VA_PICTURE_H264_LONG_TERM_REFERENCE : VA_PICTURE_H264_SHORT_TERM_REFERENCE;\n\n    va_pic->TopFieldOrderCnt = 0;\n    if (pic->field_poc[0] != INT_MAX)\n        va_pic->TopFieldOrderCnt = pic->field_poc[0];\n\n    va_pic->BottomFieldOrderCnt = 0;\n    if (pic->field_poc[1] != INT_MAX)\n        va_pic->BottomFieldOrderCnt = pic->field_poc[1];\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/** Fill in VA API reference frames array. */\n", "func_signal": "static int fill_vaapi_ReferenceFrames(VAPictureParameterBufferH264 *pic_param,\n                                      H264Context                  *h)", "code": "{\n    DPB dpb;\n    int i;\n\n    dpb.size     = 0;\n    dpb.max_size = FF_ARRAY_ELEMS(pic_param->ReferenceFrames);\n    dpb.va_pics  = pic_param->ReferenceFrames;\n    for (i = 0; i < dpb.max_size; i++)\n        init_vaapi_pic(&dpb.va_pics[i]);\n\n    for (i = 0; i < h->short_ref_count; i++) {\n        Picture * const pic = h->short_ref[i];\n        if (pic && pic->reference && dpb_add(&dpb, pic) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < 16; i++) {\n        Picture * const pic = h->long_ref[i];\n        if (pic && pic->reference && dpb_add(&dpb, pic) < 0)\n            return -1;\n    }\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/* close and free RTSP streams */\n", "func_signal": "void ff_rtsp_close_streams(AVFormatContext *s)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int i;\n    RTSPStream *rtsp_st;\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n        rtsp_st = rt->rtsp_streams[i];\n        if (rtsp_st) {\n            if (rtsp_st->transport_priv) {\n                if (s->oformat) {\n                    AVFormatContext *rtpctx = rtsp_st->transport_priv;\n                    av_write_trailer(rtpctx);\n                    if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n                        uint8_t *ptr;\n                        url_close_dyn_buf(rtpctx->pb, &ptr);\n                        av_free(ptr);\n                    } else {\n                        url_fclose(rtpctx->pb);\n                    }\n                    av_metadata_free(&rtpctx->streams[0]->metadata);\n                    av_metadata_free(&rtpctx->metadata);\n                    av_free(rtpctx->streams[0]);\n                    av_free(rtpctx);\n                } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n                    ff_rdt_parse_close(rtsp_st->transport_priv);\n                else if (CONFIG_RTPDEC)\n                    rtp_parse_close(rtsp_st->transport_priv);\n            }\n            if (rtsp_st->rtp_handle)\n                url_close(rtsp_st->rtp_handle);\n            if (rtsp_st->dynamic_handler && rtsp_st->dynamic_protocol_context)\n                rtsp_st->dynamic_handler->close(\n                    rtsp_st->dynamic_protocol_context);\n        }\n    }\n    av_free(rt->rtsp_streams);\n    if (rt->asf_ctx) {\n        av_close_input_stream (rt->asf_ctx);\n        rt->asf_ctx = NULL;\n    }\n    av_free(rt->recvbuf);\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/* parse the attribute line from the fmtp a line of an sdp response. This\n * is broken out as a function because it is used in rtp_h264.c, which is\n * forthcoming. */\n", "func_signal": "int ff_rtsp_next_attr_and_value(const char **p, char *attr, int attr_size,\n                                char *value, int value_size)", "code": "{\n    *p += strspn(*p, SPACE_CHARS);\n    if (**p) {\n        get_word_sep(attr, attr_size, \"=\", p);\n        if (**p == '=')\n            (*p)++;\n        get_word_sep(value, value_size, \";\", p);\n        if (**p == ';')\n            (*p)++;\n        return 1;\n    }\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/** End a hardware decoding based frame. */\n", "func_signal": "static int end_frame(AVCodecContext *avctx)", "code": "{\n    H264Context * const h = avctx->priv_data;\n\n    dprintf(avctx, \"end_frame()\\n\");\n    return ff_vaapi_common_end_frame(&h->s);\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * Fill in VA API reference picture lists from the FFmpeg reference\n * picture list.\n *\n * @param[out] RefPicList  VA API internal reference picture list\n * @param[in]  ref_list    A pointer to the FFmpeg reference list\n * @param[in]  ref_count   The number of reference pictures in ref_list\n */\n", "func_signal": "static void fill_vaapi_RefPicList(VAPictureH264 RefPicList[32],\n                                  Picture      *ref_list,\n                                  unsigned int  ref_count)", "code": "{\n    unsigned int i, n = 0;\n    for (i = 0; i < ref_count; i++)\n        if (ref_list[i].reference)\n            fill_vaapi_pic(&RefPicList[n++], &ref_list[i], 0);\n\n    for (; n < 32; n++)\n        init_vaapi_pic(&RefPicList[n]);\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/*\n * Perform the forward 2-4-8 DCT on one block of samples.\n */\n", "func_signal": "GLOBAL(void)\nfdct_ifast248 (DCTELEM * data)", "code": "{\n  int_fast16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  int_fast16_t tmp10, tmp11, tmp12, tmp13;\n  int_fast16_t z1;\n  DCTELEM *dataptr;\n  int ctr;\n\n  row_fdct(data);\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*1];\n    tmp1 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3];\n    tmp2 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7];\n    tmp4 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*1];\n    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3];\n    tmp6 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5];\n    tmp7 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    tmp13 = tmp0 - tmp3;\n\n    dataptr[DCTSIZE*0] = tmp10 + tmp11;\n    dataptr[DCTSIZE*4] = tmp10 - tmp11;\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781);\n    dataptr[DCTSIZE*2] = tmp13 + z1;\n    dataptr[DCTSIZE*6] = tmp13 - z1;\n\n    tmp10 = tmp4 + tmp7;\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp5 - tmp6;\n    tmp13 = tmp4 - tmp7;\n\n    dataptr[DCTSIZE*1] = tmp10 + tmp11;\n    dataptr[DCTSIZE*5] = tmp10 - tmp11;\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781);\n    dataptr[DCTSIZE*3] = tmp13 + z1;\n    dataptr[DCTSIZE*7] = tmp13 - z1;\n\n    dataptr++;                        /* advance pointer to next column */\n  }\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\jfdctfst.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/** Initialize and start decoding a frame with VA API. */\n", "func_signal": "static int start_frame(AVCodecContext          *avctx,\n                       av_unused const uint8_t *buffer,\n                       av_unused uint32_t       size)", "code": "{\n    H264Context * const h = avctx->priv_data;\n    MpegEncContext * const s = &h->s;\n    struct vaapi_context * const vactx = avctx->hwaccel_context;\n    VAPictureParameterBufferH264 *pic_param;\n    VAIQMatrixBufferH264 *iq_matrix;\n\n    dprintf(avctx, \"start_frame()\\n\");\n\n    vactx->slice_param_size = sizeof(VASliceParameterBufferH264);\n\n    /* Fill in VAPictureParameterBufferH264. */\n    pic_param = ff_vaapi_alloc_pic_param(vactx, sizeof(VAPictureParameterBufferH264));\n    if (!pic_param)\n        return -1;\n    fill_vaapi_pic(&pic_param->CurrPic, s->current_picture_ptr, s->picture_structure);\n    if (fill_vaapi_ReferenceFrames(pic_param, h) < 0)\n        return -1;\n    pic_param->picture_width_in_mbs_minus1                      = s->mb_width - 1;\n    pic_param->picture_height_in_mbs_minus1                     = s->mb_height - 1;\n    pic_param->bit_depth_luma_minus8                            = h->sps.bit_depth_luma - 8;\n    pic_param->bit_depth_chroma_minus8                          = h->sps.bit_depth_chroma - 8;\n    pic_param->num_ref_frames                                   = h->sps.ref_frame_count;\n    pic_param->seq_fields.value                                 = 0; /* reset all bits */\n    pic_param->seq_fields.bits.chroma_format_idc                = h->sps.chroma_format_idc;\n    pic_param->seq_fields.bits.residual_colour_transform_flag   = h->sps.residual_color_transform_flag; /* XXX: only for 4:4:4 high profile? */\n    pic_param->seq_fields.bits.gaps_in_frame_num_value_allowed_flag = h->sps.gaps_in_frame_num_allowed_flag;\n    pic_param->seq_fields.bits.frame_mbs_only_flag              = h->sps.frame_mbs_only_flag;\n    pic_param->seq_fields.bits.mb_adaptive_frame_field_flag     = h->sps.mb_aff;\n    pic_param->seq_fields.bits.direct_8x8_inference_flag        = h->sps.direct_8x8_inference_flag;\n    pic_param->seq_fields.bits.MinLumaBiPredSize8x8             = h->sps.level_idc >= 31; /* A.3.3.2 */\n    pic_param->seq_fields.bits.log2_max_frame_num_minus4        = h->sps.log2_max_frame_num - 4;\n    pic_param->seq_fields.bits.pic_order_cnt_type               = h->sps.poc_type;\n    pic_param->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4 = h->sps.log2_max_poc_lsb - 4;\n    pic_param->seq_fields.bits.delta_pic_order_always_zero_flag = h->sps.delta_pic_order_always_zero_flag;\n    pic_param->num_slice_groups_minus1                          = h->pps.slice_group_count - 1;\n    pic_param->slice_group_map_type                             = h->pps.mb_slice_group_map_type;\n    pic_param->slice_group_change_rate_minus1                   = 0; /* XXX: unimplemented in FFmpeg */\n    pic_param->pic_init_qp_minus26                              = h->pps.init_qp - 26;\n    pic_param->pic_init_qs_minus26                              = h->pps.init_qs - 26;\n    pic_param->chroma_qp_index_offset                           = h->pps.chroma_qp_index_offset[0];\n    pic_param->second_chroma_qp_index_offset                    = h->pps.chroma_qp_index_offset[1];\n    pic_param->pic_fields.value                                 = 0; /* reset all bits */\n    pic_param->pic_fields.bits.entropy_coding_mode_flag         = h->pps.cabac;\n    pic_param->pic_fields.bits.weighted_pred_flag               = h->pps.weighted_pred;\n    pic_param->pic_fields.bits.weighted_bipred_idc              = h->pps.weighted_bipred_idc;\n    pic_param->pic_fields.bits.transform_8x8_mode_flag          = h->pps.transform_8x8_mode;\n    pic_param->pic_fields.bits.field_pic_flag                   = s->picture_structure != PICT_FRAME;\n    pic_param->pic_fields.bits.constrained_intra_pred_flag      = h->pps.constrained_intra_pred;\n    pic_param->pic_fields.bits.pic_order_present_flag           = h->pps.pic_order_present;\n    pic_param->pic_fields.bits.deblocking_filter_control_present_flag = h->pps.deblocking_filter_parameters_present;\n    pic_param->pic_fields.bits.redundant_pic_cnt_present_flag   = h->pps.redundant_pic_cnt_present;\n    pic_param->pic_fields.bits.reference_pic_flag               = h->nal_ref_idc != 0;\n    pic_param->frame_num                                        = h->frame_num;\n\n    /* Fill in VAIQMatrixBufferH264. */\n    iq_matrix = ff_vaapi_alloc_iq_matrix(vactx, sizeof(VAIQMatrixBufferH264));\n    if (!iq_matrix)\n        return -1;\n    memcpy(iq_matrix->ScalingList4x4, h->pps.scaling_matrix4, sizeof(iq_matrix->ScalingList4x4));\n    memcpy(iq_matrix->ScalingList8x8, h->pps.scaling_matrix8, sizeof(iq_matrix->ScalingList8x8));\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**< return 0 on packet, no more left, 1 on packet, 1 on partial packet... */\n", "func_signal": "static int\nrdt_parse_packet (AVFormatContext *ctx, PayloadContext *rdt, AVStream *st,\n                  AVPacket *pkt, uint32_t *timestamp,\n                  const uint8_t *buf, int len, int flags)", "code": "{\n    int seq = 1, res;\n    ByteIOContext pb;\n\n    if (rdt->audio_pkt_cnt == 0) {\n        int pos;\n\n        init_put_byte(&pb, buf, len, 0, NULL, NULL, NULL, NULL);\n        flags = (flags & RTP_FLAG_KEY) ? 2 : 0;\n        res = ff_rm_parse_packet (rdt->rmctx, &pb, st, rdt->rmst[st->index], len, pkt,\n                                  &seq, flags, *timestamp);\n        pos = url_ftell(&pb);\n        if (res < 0)\n            return res;\n        if (res > 0) {\n            if (st->codec->codec_id == CODEC_ID_AAC) {\n                memcpy (rdt->buffer, buf + pos, len - pos);\n                rdt->rmctx->pb = av_alloc_put_byte (rdt->buffer, len - pos, 0,\n                                                    NULL, NULL, NULL, NULL);\n            }\n            goto get_cache;\n        }\n    } else {\nget_cache:\n        rdt->audio_pkt_cnt =\n            ff_rm_retrieve_cache (rdt->rmctx, rdt->rmctx->pb,\n                                  st, rdt->rmst[st->index], pkt);\n        if (rdt->audio_pkt_cnt == 0 &&\n            st->codec->codec_id == CODEC_ID_AAC)\n            av_freep(&rdt->rmctx->pb);\n    }\n    pkt->stream_index = st->index;\n    pkt->pts = *timestamp;\n\n    return rdt->audio_pkt_cnt > 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rdt.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/** Parse a string p in the form of Range:npt=xx-xx, and determine the start\n *  and end time.\n *  Used for seeking in the rtp stream.\n */\n", "func_signal": "static void rtsp_parse_range_npt(const char *p, int64_t *start, int64_t *end)", "code": "{\n    char buf[256];\n\n    p += strspn(p, SPACE_CHARS);\n    if (!av_stristart(p, \"npt=\", &p))\n        return;\n\n    *start = AV_NOPTS_VALUE;\n    *end = AV_NOPTS_VALUE;\n\n    get_word_sep(buf, sizeof(buf), \"-\", &p);\n    *start = parse_date(buf, 1);\n    if (*p == '-') {\n        p++;\n        get_word_sep(buf, sizeof(buf), \"-\", &p);\n        *end = parse_date(buf, 1);\n    }\n//    av_log(NULL, AV_LOG_DEBUG, \"Range Start: %lld\\n\", *start);\n//    av_log(NULL, AV_LOG_DEBUG, \"Range End: %lld\\n\", *end);\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * Actual data handling.\n */\n", "func_signal": "int\nff_rdt_parse_header(const uint8_t *buf, int len,\n                    int *pset_id, int *pseq_no, int *pstream_id,\n                    int *pis_keyframe, uint32_t *ptimestamp)", "code": "{\n    GetBitContext gb;\n    int consumed = 0, set_id, seq_no, stream_id, is_keyframe,\n        len_included, need_reliable;\n    uint32_t timestamp;\n\n    /* skip status packets */\n    while (len >= 5 && buf[1] == 0xFF /* status packet */) {\n        int pkt_len;\n\n        if (!(buf[0] & 0x80))\n            return -1; /* not followed by a data packet */\n\n        pkt_len = AV_RB16(buf+3);\n        buf += pkt_len;\n        len -= pkt_len;\n        consumed += pkt_len;\n    }\n    if (len < 16)\n        return -1;\n    /**\n     * Layout of the header (in bits):\n     * 1:  len_included\n     *     Flag indicating whether this header includes a length field;\n     *     this can be used to concatenate multiple RDT packets in a\n     *     single UDP/TCP data frame and is used to precede RDT data\n     *     by stream status packets\n     * 1:  need_reliable\n     *     Flag indicating whether this header includes a \"reliable\n     *     sequence number\"; these are apparently sequence numbers of\n     *     data packets alone. For data packets, this flag is always\n     *     set, according to the Real documentation [1]\n     * 5:  set_id\n     *     ID of a set of streams of identical content, possibly with\n     *     different codecs or bitrates\n     * 1:  is_reliable\n     *     Flag set for certain streams deemed less tolerable for packet\n     *     loss\n     * 16: seq_no\n     *     Packet sequence number; if >=0xFF00, this is a non-data packet\n     *     containing stream status info, the second byte indicates the\n     *     type of status packet (see wireshark docs / source code [2])\n     * if (len_included) {\n     *     16: packet_len\n     * } else {\n     *     packet_len = remainder of UDP/TCP frame\n     * }\n     * 1:  is_back_to_back\n     *     Back-to-Back flag; used for timing, set for one in every 10\n     *     packets, according to the Real documentation [1]\n     * 1:  is_slow_data\n     *     Slow-data flag; currently unused, according to Real docs [1]\n     * 5:  stream_id\n     *     ID of the stream within this particular set of streams\n     * 1:  is_no_keyframe\n     *     Non-keyframe flag (unset if packet belongs to a keyframe)\n     * 32: timestamp (PTS)\n     * if (set_id == 0x1F) {\n     *     16: set_id (extended set-of-streams ID; see set_id)\n     * }\n     * if (need_reliable) {\n     *     16: reliable_seq_no\n     *         Reliable sequence number (see need_reliable)\n     * }\n     * if (stream_id == 0x3F) {\n     *     16: stream_id (extended stream ID; see stream_id)\n     * }\n     * [1] https://protocol.helixcommunity.org/files/2005/devdocs/RDT_Feature_Level_20.txt\n     * [2] http://www.wireshark.org/docs/dfref/r/rdt.html and\n     *     http://anonsvn.wireshark.org/viewvc/trunk/epan/dissectors/packet-rdt.c\n     */\n    init_get_bits(&gb, buf, len << 3);\n    len_included  = get_bits1(&gb);\n    need_reliable = get_bits1(&gb);\n    set_id        = get_bits(&gb, 5);\n    skip_bits(&gb, 1);\n    seq_no        = get_bits(&gb, 16);\n    if (len_included)\n        skip_bits(&gb, 16);\n    skip_bits(&gb, 2);\n    stream_id     = get_bits(&gb, 5);\n    is_keyframe   = !get_bits1(&gb);\n    timestamp     = get_bits_long(&gb, 32);\n    if (set_id == 0x1f)\n        set_id    = get_bits(&gb, 16);\n    if (need_reliable)\n        skip_bits(&gb, 16);\n    if (stream_id == 0x1f)\n        stream_id = get_bits(&gb, 16);\n\n    if (pset_id)      *pset_id      = set_id;\n    if (pseq_no)      *pseq_no      = seq_no;\n    if (pstream_id)   *pstream_id   = stream_id;\n    if (pis_keyframe) *pis_keyframe = is_keyframe;\n    if (ptimestamp)   *ptimestamp   = timestamp;\n\n    return consumed + (get_bits_count(&gb) >> 3);\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rdt.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/* skip a RTP/TCP interleaved packet */\n", "func_signal": "void ff_rtsp_skip_packet(AVFormatContext *s)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int ret, len, len1;\n    uint8_t buf[1024];\n\n    ret = url_read_complete(rt->rtsp_hd, buf, 3);\n    if (ret != 3)\n        return;\n    len = AV_RB16(buf + 1);\n\n    dprintf(s, \"skipping RTP packet len=%d\\n\", len);\n\n    /* skip payload */\n    while (len > 0) {\n        len1 = len;\n        if (len1 > sizeof(buf))\n            len1 = sizeof(buf);\n        ret = url_read_complete(rt->rtsp_hd, buf, len1);\n        if (ret != len1)\n            return;\n        len -= len1;\n    }\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n *\n * @return the number of bytes written\n */\n", "func_signal": "int ff_rac_terminate(RangeCoder *c)", "code": "{\n    c->range=0xFF;\n    c->low +=0xFF;\n    renorm_encoder(c);\n    c->range=0xFF;\n    renorm_encoder(c);\n\n    assert(c->low   == 0);\n    assert(c->range >= 0x100);\n\n    return c->bytestream - c->bytestream_start;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\rangecoder.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * Append picture to the decoded picture buffer, in a VA API form that\n * merges the second field picture attributes with the first, if\n * available.  The decoded picture buffer's size must be large enough\n * to receive the new VA API picture object.\n */\n", "func_signal": "static int dpb_add(DPB *dpb, Picture *pic)", "code": "{\n    int i;\n\n    if (dpb->size >= dpb->max_size)\n        return -1;\n\n    for (i = 0; i < dpb->size; i++) {\n        VAPictureH264 * const va_pic = &dpb->va_pics[i];\n        if (va_pic->picture_id == ff_vaapi_get_surface_id(pic)) {\n            VAPictureH264 temp_va_pic;\n            fill_vaapi_pic(&temp_va_pic, pic, 0);\n\n            if ((temp_va_pic.flags ^ va_pic->flags) & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD)) {\n                va_pic->flags |= temp_va_pic.flags & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD);\n                /* Merge second field */\n                if (temp_va_pic.flags & VA_PICTURE_H264_TOP_FIELD) {\n                    va_pic->TopFieldOrderCnt    = temp_va_pic.TopFieldOrderCnt;\n                } else {\n                    va_pic->BottomFieldOrderCnt = temp_va_pic.BottomFieldOrderCnt;\n                }\n            }\n            return 0;\n        }\n    }\n\n    fill_vaapi_pic(&dpb->va_pics[dpb->size++], pic, 0);\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/*\n * Perform the forward DCT on one block of samples.\n */\n", "func_signal": "GLOBAL(void)\nfdct_ifast (DCTELEM * data)", "code": "{\n  int_fast16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  int_fast16_t tmp10, tmp11, tmp12, tmp13;\n  int_fast16_t z1, z2, z3, z4, z5, z11, z13;\n  DCTELEM *dataptr;\n  int ctr;\n\n  row_fdct(data);\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];\n    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];\n    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];\n    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;        /* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[DCTSIZE*0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[DCTSIZE*4] = tmp10 - tmp11;\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */\n    dataptr[DCTSIZE*2] = tmp13 + z1; /* phase 5 */\n    dataptr[DCTSIZE*6] = tmp13 - z1;\n\n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;        /* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */\n    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */\n    z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5; /* c2+c6 */\n    z3 = MULTIPLY(tmp11, FIX_0_707106781); /* c4 */\n\n    z11 = tmp7 + z3;            /* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[DCTSIZE*5] = z13 + z2; /* phase 6 */\n    dataptr[DCTSIZE*3] = z13 - z2;\n    dataptr[DCTSIZE*1] = z11 + z4;\n    dataptr[DCTSIZE*7] = z11 - z4;\n\n    dataptr++;                  /* advance pointer to next column */\n  }\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\jfdctfst.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * @return 0 on success, <0 on error, 1 if protocol is unavailable.\n */\n", "func_signal": "static int make_setup_request(AVFormatContext *s, const char *host, int port,\n                              int lower_transport, const char *real_challenge)", "code": "{\n    RTSPState *rt = s->priv_data;\n    int rtx, j, i, err, interleave = 0;\n    RTSPStream *rtsp_st;\n    RTSPMessageHeader reply1, *reply = &reply1;\n    char cmd[2048];\n    const char *trans_pref;\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n        trans_pref = \"x-pn-tng\";\n    else\n        trans_pref = \"RTP/AVP\";\n\n    /* default timeout: 1 minute */\n    rt->timeout = 60;\n\n    /* for each stream, make the setup request */\n    /* XXX: we assume the same server is used for the control of each\n     * RTSP stream */\n\n    for (j = RTSP_RTP_PORT_MIN, i = 0; i < rt->nb_rtsp_streams; ++i) {\n        char transport[2048];\n\n        /**\n         * WMS serves all UDP data over a single connection, the RTX, which\n         * isn't necessarily the first in the SDP but has to be the first\n         * to be set up, else the second/third SETUP will fail with a 461.\n         */\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n             rt->server_type == RTSP_SERVER_WMS) {\n            if (i == 0) {\n                /* rtx first */\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n                    if (len >= 4 &&\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n                                \"/rtx\"))\n                        break;\n                }\n                if (rtx == rt->nb_rtsp_streams)\n                    return -1; /* no RTX found */\n                rtsp_st = rt->rtsp_streams[rtx];\n            } else\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n        } else\n            rtsp_st = rt->rtsp_streams[i];\n\n        /* RTP/UDP */\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n            char buf[256];\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n                port = reply->transports[0].client_port_min;\n                goto have_port;\n            }\n\n            /* first try in specified port range */\n            if (RTSP_RTP_PORT_MIN != 0) {\n                while (j <= RTSP_RTP_PORT_MAX) {\n                    ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n                                \"?localport=%d\", j);\n                    /* we will use two ports per rtp stream (rtp and rtcp) */\n                    j += 2;\n                    if (url_open(&rtsp_st->rtp_handle, buf, URL_RDWR) == 0)\n                        goto rtp_opened;\n                }\n            }\n\n#if 0\n            /* then try on any port */\n            if (url_open(&rtsp_st->rtp_handle, \"rtp://\", URL_RDONLY) < 0) {\n                err = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n#endif\n\n        rtp_opened:\n            port = rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n        have_port:\n            snprintf(transport, sizeof(transport) - 1,\n                     \"%s/UDP;\", trans_pref);\n            if (rt->server_type != RTSP_SERVER_REAL)\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n            av_strlcatf(transport, sizeof(transport),\n                     \"client_port=%d\", port);\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n        }\n\n        /* RTP/TCP */\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n            /** For WMS streams, the application streams are only used for\n             * UDP. When trying to set it up for TCP streams, the server\n             * will return an error. Therefore, we skip those streams. */\n            if (rt->server_type == RTSP_SERVER_WMS &&\n                s->streams[rtsp_st->stream_index]->codec->codec_type ==\n                    AVMEDIA_TYPE_DATA)\n                continue;\n            snprintf(transport, sizeof(transport) - 1,\n                     \"%s/TCP;\", trans_pref);\n            if (rt->server_type == RTSP_SERVER_WMS)\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n            av_strlcatf(transport, sizeof(transport),\n                        \"interleaved=%d-%d\",\n                        interleave, interleave + 1);\n            interleave += 2;\n        }\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n            snprintf(transport, sizeof(transport) - 1,\n                     \"%s/UDP;multicast\", trans_pref);\n        }\n        if (s->oformat) {\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n                   rt->server_type == RTSP_SERVER_WMS)\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n        snprintf(cmd, sizeof(cmd),\n                 \"Transport: %s\\r\\n\",\n                 transport);\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n            char real_res[41], real_csum[9];\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n                                              real_challenge);\n            av_strlcatf(cmd, sizeof(cmd),\n                        \"If-Match: %s\\r\\n\"\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n                        rt->session_id, real_res, real_csum);\n        }\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n            err = 1;\n            goto fail;\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n                   reply->nb_transports != 1) {\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        /* XXX: same protocol for all streams is required */\n        if (i > 0) {\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n                reply->transports[0].transport != rt->transport) {\n                err = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n        } else {\n            rt->lower_transport = reply->transports[0].lower_transport;\n            rt->transport = reply->transports[0].transport;\n        }\n\n        /* close RTP connection if not chosen */\n        if (reply->transports[0].lower_transport != RTSP_LOWER_TRANSPORT_UDP &&\n            (lower_transport == RTSP_LOWER_TRANSPORT_UDP)) {\n            url_close(rtsp_st->rtp_handle);\n            rtsp_st->rtp_handle = NULL;\n        }\n\n        switch(reply->transports[0].lower_transport) {\n        case RTSP_LOWER_TRANSPORT_TCP:\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n            break;\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n            char url[1024];\n\n            /* Use source address if specified */\n            if (reply->transports[0].source[0]) {\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n                            reply->transports[0].source,\n                            reply->transports[0].server_port_min, NULL);\n            } else {\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n                            reply->transports[0].server_port_min, NULL);\n            }\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n                rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n                err = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            /* Try to initialize the connection state in a\n             * potential NAT router by sending dummy packets.\n             * RTP/RTCP dummy packets are used for RDT, too.\n             */\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n                CONFIG_RTPDEC)\n                rtp_send_punch_packets(rtsp_st->rtp_handle);\n            break;\n        }\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n            char url[1024], namebuf[50];\n            struct sockaddr_storage addr;\n            int port, ttl;\n\n            if (reply->transports[0].destination.ss_family) {\n                addr      = reply->transports[0].destination;\n                port      = reply->transports[0].port_min;\n                ttl       = reply->transports[0].ttl;\n            } else {\n                addr      = rtsp_st->sdp_ip;\n                port      = rtsp_st->sdp_port;\n                ttl       = rtsp_st->sdp_ttl;\n            }\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n                        port, \"?ttl=%d\", ttl);\n            if (url_open(&rtsp_st->rtp_handle, url, URL_RDWR) < 0) {\n                err = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            break;\n        }\n        }\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n            goto fail;\n    }\n\n    if (reply->timeout > 0)\n        rt->timeout = reply->timeout;\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n        rt->need_subscription = 1;\n\n    return 0;\n\nfail:\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n        if (rt->rtsp_streams[i]->rtp_handle) {\n            url_close(rt->rtsp_streams[i]->rtp_handle);\n            rt->rtsp_streams[i]->rtp_handle = NULL;\n        }\n    }\n    return err;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavformat\\rtsp.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/** Decode the given H.264 slice with VA API. */\n", "func_signal": "static int decode_slice(AVCodecContext *avctx,\n                        const uint8_t  *buffer,\n                        uint32_t        size)", "code": "{\n    H264Context * const h = avctx->priv_data;\n    MpegEncContext * const s = &h->s;\n    VASliceParameterBufferH264 *slice_param;\n\n    dprintf(avctx, \"decode_slice(): buffer %p, size %d\\n\", buffer, size);\n\n    /* Fill in VASliceParameterBufferH264. */\n    slice_param = (VASliceParameterBufferH264 *)ff_vaapi_alloc_slice(avctx->hwaccel_context, buffer, size);\n    if (!slice_param)\n        return -1;\n    slice_param->slice_data_bit_offset          = get_bits_count(&h->s.gb) + 8; /* bit buffer started beyond nal_unit_type */\n    slice_param->first_mb_in_slice              = (s->mb_y >> FIELD_OR_MBAFF_PICTURE) * s->mb_width + s->mb_x;\n    slice_param->slice_type                     = ff_h264_get_slice_type(h);\n    slice_param->direct_spatial_mv_pred_flag    = h->slice_type == FF_B_TYPE ? h->direct_spatial_mv_pred : 0;\n    slice_param->num_ref_idx_l0_active_minus1   = h->list_count > 0 ? h->ref_count[0] - 1 : 0;\n    slice_param->num_ref_idx_l1_active_minus1   = h->list_count > 1 ? h->ref_count[1] - 1 : 0;\n    slice_param->cabac_init_idc                 = h->cabac_init_idc;\n    slice_param->slice_qp_delta                 = s->qscale - h->pps.init_qp;\n    slice_param->disable_deblocking_filter_idc  = h->deblocking_filter < 2 ? !h->deblocking_filter : h->deblocking_filter;\n    slice_param->slice_alpha_c0_offset_div2     = h->slice_alpha_c0_offset / 2 - 26;\n    slice_param->slice_beta_offset_div2         = h->slice_beta_offset     / 2 - 26;\n    slice_param->luma_log2_weight_denom         = h->luma_log2_weight_denom;\n    slice_param->chroma_log2_weight_denom       = h->chroma_log2_weight_denom;\n\n    fill_vaapi_RefPicList(slice_param->RefPicList0, h->ref_list[0], h->list_count > 0 ? h->ref_count[0] : 0);\n    fill_vaapi_RefPicList(slice_param->RefPicList1, h->ref_list[1], h->list_count > 1 ? h->ref_count[1] : 0);\n\n    fill_vaapi_plain_pred_weight_table(h, 0,\n                                       &slice_param->luma_weight_l0_flag,   slice_param->luma_weight_l0,   slice_param->luma_offset_l0,\n                                       &slice_param->chroma_weight_l0_flag, slice_param->chroma_weight_l0, slice_param->chroma_offset_l0);\n    fill_vaapi_plain_pred_weight_table(h, 1,\n                                       &slice_param->luma_weight_l1_flag,   slice_param->luma_weight_l1,   slice_param->luma_offset_l1,\n                                       &slice_param->chroma_weight_l1_flag, slice_param->chroma_weight_l1, slice_param->chroma_offset_l1);\n    return 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/**\n * Initialize an empty VA API picture.\n *\n * VA API requires a fixed-size reference picture array.\n */\n", "func_signal": "static void init_vaapi_pic(VAPictureH264 *va_pic)", "code": "{\n    va_pic->picture_id          = VA_INVALID_ID;\n    va_pic->flags               = VA_PICTURE_H264_INVALID;\n    va_pic->TopFieldOrderCnt    = 0;\n    va_pic->BottomFieldOrderCnt = 0;\n}", "path": "jni\\ffmpeg-android\\ffmpeg\\libavcodec\\vaapi_h264.c", "repo_name": "frankandrobot/GLWallpaperVideoDemo", "stars": 29, "license": "None", "language": "c", "size": 70557}
{"docstring": "/* destroy the plugin data */\n", "func_signal": "FREE_FUNC(mod_extforward_free)", "code": "{\n\tplugin_data *p = p_d;\n\n\tUNUSED(srv);\n\n\tif (!p) return HANDLER_GO_ON;\n\n\tif (p->config_storage) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\t\tplugin_config *s = p->config_storage[i];\n\n\t\t\tif (!s) continue;\n\n\t\t\tarray_free(s->forwarder);\n\t\t\tarray_free(s->headers);\n\n\t\t\tfree(s);\n\t\t}\n\t\tfree(p->config_storage);\n\t}\n\n\n\tfree(p);\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n * Return char *ip of last address of proxy that is not trusted.\n * Do not accept \"all\" keyword here.\n */\n", "func_signal": "static const char *last_not_in_array(array *a, plugin_data *p)", "code": "{\n\tarray *forwarder = p->conf.forwarder;\n\tint i;\n\n\tfor (i = a->used - 1; i >= 0; i--) {\n\t\tdata_string *ds = (data_string *)a->data[i];\n\t\tconst char *ip = ds->value->ptr;\n\n\t\tif (!array_get_element(forwarder, ip)) {\n\t\t\treturn ip;\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/**\n * handle all header and content read\n *\n * we get called by the state-engine and by the fdevent-handler\n */\n", "func_signal": "static int connection_handle_read_state(server *srv, connection *con)", "code": "{\n\tconnection_state_t ostate = con->state;\n\tchunk *c, *last_chunk;\n\toff_t last_offset;\n\tchunkqueue *cq = con->read_queue;\n\tchunkqueue *dst_cq = con->request_content_queue;\n\tint is_closed = 0; /* the connection got closed, if we don't have a complete header, -> error */\n\n\tif (con->is_readable) {\n\t\tcon->read_idle_ts = srv->cur_ts;\n\n\t\tswitch(connection_handle_read(srv, con)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase -2:\n\t\t\tis_closed = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* the last chunk might be empty */\n\tfor (c = cq->first; c;) {\n\t\tif (cq->first == c && c->mem->used == 0) {\n\t\t\t/* the first node is empty */\n\t\t\t/* ... and it is empty, move it to unused */\n\n\t\t\tcq->first = c->next;\n\t\t\tif (cq->first == NULL) cq->last = NULL;\n\n\t\t\tc->next = cq->unused;\n\t\t\tcq->unused = c;\n\t\t\tcq->unused_chunks++;\n\n\t\t\tc = cq->first;\n\t\t} else if (c->next && c->next->mem->used == 0) {\n\t\t\tchunk *fc;\n\t\t\t/* next node is the last one */\n\t\t\t/* ... and it is empty, move it to unused */\n\n\t\t\tfc = c->next;\n\t\t\tc->next = fc->next;\n\n\t\t\tfc->next = cq->unused;\n\t\t\tcq->unused = fc;\n\t\t\tcq->unused_chunks++;\n\n\t\t\t/* the last node was empty */\n\t\t\tif (c->next == NULL) {\n\t\t\t\tcq->last = c;\n\t\t\t}\n\n\t\t\tc = c->next;\n\t\t} else {\n\t\t\tc = c->next;\n\t\t}\n\t}\n\n\t/* we might have got several packets at once\n\t */\n\n\tswitch(ostate) {\n\tcase CON_STATE_READ:\n\t\t/* if there is a \\r\\n\\r\\n in the chunkqueue\n\t\t *\n\t\t * scan the chunk-queue twice\n\t\t * 1. to find the \\r\\n\\r\\n\n\t\t * 2. to copy the header-packet\n\t\t *\n\t\t */\n\n\t\tlast_chunk = NULL;\n\t\tlast_offset = 0;\n\n\t\tfor (c = cq->first; c; c = c->next) {\n\t\t\tbuffer b;\n\t\t\tsize_t i;\n\n\t\t\tb.ptr = c->mem->ptr + c->offset;\n\t\t\tb.used = c->mem->used - c->offset;\n\t\t\tif (b.used > 0) b.used--; /* buffer \"used\" includes terminating zero */\n\n\t\t\tfor (i = 0; i < b.used; i++) {\n\t\t\t\tchar ch = b.ptr[i];\n\n\t\t\t\tif ('\\r' == ch) {\n\t\t\t\t\t/* chec if \\n\\r\\n follows */\n\t\t\t\t\tsize_t j = i+1;\n\t\t\t\t\tchunk *cc = c;\n\t\t\t\t\tconst char header_end[] = \"\\r\\n\\r\\n\";\n\t\t\t\t\tint header_end_match_pos = 1;\n\n\t\t\t\t\tfor ( ; cc; cc = cc->next, j = 0 ) {\n\t\t\t\t\t\tbuffer bb;\n\t\t\t\t\t\tbb.ptr = cc->mem->ptr + cc->offset;\n\t\t\t\t\t\tbb.used = cc->mem->used - cc->offset;\n\t\t\t\t\t\tif (bb.used > 0) bb.used--; /* buffer \"used\" includes terminating zero */\n\n\t\t\t\t\t\tfor ( ; j < bb.used; j++) {\n\t\t\t\t\t\t\tch = bb.ptr[j];\n\n\t\t\t\t\t\t\tif (ch == header_end[header_end_match_pos]) {\n\t\t\t\t\t\t\t\theader_end_match_pos++;\n\t\t\t\t\t\t\t\tif (4 == header_end_match_pos) {\n\t\t\t\t\t\t\t\t\tlast_chunk = cc;\n\t\t\t\t\t\t\t\t\tlast_offset = j+1;\n\t\t\t\t\t\t\t\t\tgoto found_header_end;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto reset_search;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\nreset_search: ;\n\t\t\t}\n\t\t}\nfound_header_end:\n\n\t\t/* found */\n\t\tif (last_chunk) {\n\t\t\tbuffer_reset(con->request.request);\n\n\t\t\tfor (c = cq->first; c; c = c->next) {\n\t\t\t\tbuffer b;\n\n\t\t\t\tb.ptr = c->mem->ptr + c->offset;\n\t\t\t\tb.used = c->mem->used - c->offset;\n\n\t\t\t\tif (c == last_chunk) {\n\t\t\t\t\tb.used = last_offset + 1;\n\t\t\t\t}\n\n\t\t\t\tbuffer_append_string_buffer(con->request.request, &b);\n\n\t\t\t\tif (c == last_chunk) {\n\t\t\t\t\tc->offset += last_offset;\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* the whole packet was copied */\n\t\t\t\t\tc->offset = c->mem->used - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconnection_set_state(srv, con, CON_STATE_REQUEST_END);\n\t\t} else if (chunkqueue_length(cq) > 64 * 1024) {\n\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"s\", \"oversized request-header -> sending Status 414\");\n\n\t\t\tcon->http_status = 414; /* Request-URI too large */\n\t\t\tcon->keep_alive = 0;\n\t\t\tconnection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);\n\t\t}\n\t\tbreak;\n\tcase CON_STATE_READ_POST:\n\t\tfor (c = cq->first; c && (dst_cq->bytes_in != (off_t)con->request.content_length); c = c->next) {\n\t\t\toff_t weWant, weHave, toRead;\n\n\t\t\tweWant = con->request.content_length - dst_cq->bytes_in;\n\n\t\t\tassert(c->mem->used);\n\n\t\t\tweHave = c->mem->used - c->offset - 1;\n\n\t\t\ttoRead = weHave > weWant ? weWant : weHave;\n\n\t\t\t/* the new way, copy everything into a chunkqueue whcih might use tempfiles */\n\t\t\tif (con->request.content_length > 64 * 1024) {\n\t\t\t\tchunk *dst_c = NULL;\n\t\t\t\t/* copy everything to max 1Mb sized tempfiles */\n\n\t\t\t\t/*\n\t\t\t\t * if the last chunk is\n\t\t\t\t * - smaller than 1Mb (size < 1Mb)\n\t\t\t\t * - not read yet (offset == 0)\n\t\t\t\t * -> append to it\n\t\t\t\t * otherwise\n\t\t\t\t * -> create a new chunk\n\t\t\t\t *\n\t\t\t\t * */\n\n\t\t\t\tif (dst_cq->last &&\n\t\t\t\t    dst_cq->last->type == FILE_CHUNK &&\n\t\t\t\t    dst_cq->last->file.is_temp &&\n\t\t\t\t    dst_cq->last->offset == 0) {\n\t\t\t\t\t/* ok, take the last chunk for our job */\n\n\t\t\t \t\tif (dst_cq->last->file.length < 1 * 1024 * 1024) {\n\t\t\t\t\t\tdst_c = dst_cq->last;\n\n\t\t\t\t\t\tif (dst_c->file.fd == -1) {\n\t\t\t\t\t\t\t/* this should not happen as we cache the fd, but you never know */\n\t\t\t\t\t\t\tdst_c->file.fd = open(dst_c->file.name->ptr, O_WRONLY | O_APPEND);\n#ifdef FD_CLOEXEC\n\t\t\t\t\t\t\tfcntl(dst_c->file.fd, F_SETFD, FD_CLOEXEC);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* the chunk is too large now, close it */\n\t\t\t\t\t\tdst_c = dst_cq->last;\n\n\t\t\t\t\t\tif (dst_c->file.fd != -1) {\n\t\t\t\t\t\t\tclose(dst_c->file.fd);\n\t\t\t\t\t\t\tdst_c->file.fd = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdst_c = chunkqueue_get_append_tempfile(dst_cq);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdst_c = chunkqueue_get_append_tempfile(dst_cq);\n\t\t\t\t}\n\n\t\t\t\t/* we have a chunk, let's write to it */\n\n\t\t\t\tif (dst_c->file.fd == -1) {\n\t\t\t\t\t/* we don't have file to write to,\n\t\t\t\t\t * EACCES might be one reason.\n\t\t\t\t\t *\n\t\t\t\t\t * Instead of sending 500 we send 413 and say the request is too large\n\t\t\t\t\t *  */\n\n\t\t\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"sbs\",\n\t\t\t\t\t\t\t\"denying upload as opening to temp-file for upload failed:\",\n\t\t\t\t\t\t\tdst_c->file.name, strerror(errno));\n\n\t\t\t\t\tcon->http_status = 413; /* Request-Entity too large */\n\t\t\t\t\tcon->keep_alive = 0;\n\t\t\t\t\tconnection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (toRead != write(dst_c->file.fd, c->mem->ptr + c->offset, toRead)) {\n\t\t\t\t\t/* write failed for some reason ... disk full ? */\n\t\t\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"sbs\",\n\t\t\t\t\t\t\t\"denying upload as writing to file failed:\",\n\t\t\t\t\t\t\tdst_c->file.name, strerror(errno));\n\n\t\t\t\t\tcon->http_status = 413; /* Request-Entity too large */\n\t\t\t\t\tcon->keep_alive = 0;\n\t\t\t\t\tconnection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);\n\n\t\t\t\t\tclose(dst_c->file.fd);\n\t\t\t\t\tdst_c->file.fd = -1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdst_c->file.length += toRead;\n\n\t\t\t\tif (dst_cq->bytes_in + toRead == (off_t)con->request.content_length) {\n\t\t\t\t\t/* we read everything, close the chunk */\n\t\t\t\t\tclose(dst_c->file.fd);\n\t\t\t\t\tdst_c->file.fd = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuffer *b;\n\n\t\t\t\tif (dst_cq->last &&\n\t\t\t\t    dst_cq->last->type == MEM_CHUNK) {\n\t\t\t\t\tb = dst_cq->last->mem;\n\t\t\t\t} else {\n\t\t\t\t\tb = chunkqueue_get_append_buffer(dst_cq);\n\t\t\t\t\t/* prepare buffer size for remaining POST data; is < 64kb */\n\t\t\t\t\tbuffer_prepare_copy(b, con->request.content_length - dst_cq->bytes_in + 1);\n\t\t\t\t}\n\t\t\t\tbuffer_append_string_len(b, c->mem->ptr + c->offset, toRead);\n\t\t\t}\n\n\t\t\tc->offset += toRead;\n\t\t\tdst_cq->bytes_in += toRead;\n\t\t}\n\n\t\t/* Content is ready */\n\t\tif (dst_cq->bytes_in == (off_t)con->request.content_length) {\n\t\t\tconnection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);\n\t\t}\n\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\t/* the connection got closed and we didn't got enough data to leave one of the READ states\n\t * the only way is to leave here */\n\tif (is_closed && ostate == con->state) {\n\t\tconnection_set_state(srv, con, CON_STATE_ERROR);\n\t}\n\n\tchunkqueue_remove_finished_chunks(cq);\n\n\treturn 0;\n}", "path": "src\\connections.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* replace or insert data, return the old one with the same key */\n", "func_signal": "data_unset *array_replace(array *a, data_unset *du)", "code": "{\n\tint ndx;\n\n\tif (-1 == (ndx = array_get_index(a, du->key->ptr, du->key->used, NULL))) {\n\t\tarray_insert_unique(a, du);\n\t\treturn NULL;\n\t} else {\n\t\tdata_unset *old = a->data[ndx];\n\t\ta->data[ndx] = du;\n\t\treturn old;\n\t}\n}", "path": "src\\array.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* The following function deletes the value associated with a\n** symbol.  The symbol can be either a terminal or nonterminal.\n** \"yymajor\" is the symbol code, and \"yypminor\" is a pointer to\n** the value.\n*/\n", "func_signal": "static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor)", "code": "{\n  switch( yymajor ){\n    /* Here is inserted the actions which take place when a\n    ** terminal or non-terminal is destroyed.  This can happen\n    ** when the symbol is popped from the stack during a\n    ** reduce or during error processing or when a parser is\n    ** being destroyed before it is finished parsing.\n    **\n    ** Note: during a reduce, the only symbols destroyed are those\n    ** which appear on the RHS of the rule, but which are not used\n    ** inside the C code.\n    */\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n#line 22 \"./mod_ssi_exprparser.y\"\n{ buffer_free((yypminor->yy0)); }\n#line 352 \"mod_ssi_exprparser.c\"\n      break;\n    default:  break;   /* If no destructor action specified: do nothing */\n  }\n}", "path": "src\\mod_ssi_exprparser.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_extforward_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i = 0;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"extforward.forwarder\",       NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ \"extforward.headers\",         NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 1 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->forwarder    = array_init();\n\t\ts->headers      = array_init();\n\n\t\tcv[0].destination = s->forwarder;\n\t\tcv[1].destination = s->headers;\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n * check whether ip is trusted, return 1 for trusted , 0 for untrusted\n */\n", "func_signal": "static int is_proxy_trusted(const char *ipstr, plugin_data *p)", "code": "{\n\tdata_string* allds = (data_string *)array_get_element(p->conf.forwarder, \"all\");\n\n\tif (allds) {\n\t\tif (strcasecmp(allds->value->ptr, \"trust\") == 0) {\n\t\t\treturn IP_TRUSTED;\n\t\t} else {\n\t\t\treturn IP_UNTRUSTED;\n\t\t}\n\t}\n\n\treturn (data_string *)array_get_element(p->conf.forwarder, ipstr) ? IP_TRUSTED : IP_UNTRUSTED;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* The following function deletes the value associated with a\n** symbol.  The symbol can be either a terminal or nonterminal.\n** \"yymajor\" is the symbol code, and \"yypminor\" is a pointer to\n** the value.\n*/\n", "func_signal": "static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor)", "code": "{\n  switch( yymajor ){\n    /* Here is inserted the actions which take place when a\n    ** terminal or non-terminal is destroyed.  This can happen\n    ** when the symbol is popped from the stack during a\n    ** reduce or during error processing or when a parser is\n    ** being destroyed before it is finished parsing.\n    **\n    ** Note: during a reduce, the only symbols destroyed are those\n    ** which appear on the RHS of the rule, but which are not used\n    ** inside the C code.\n    */\n%%\n    default:  break;   /* If no destructor action specified: do nothing */\n  }\n}", "path": "src\\lempar.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* detroy the plugin data */\n", "func_signal": "FREE_FUNC(mod_setenv_free)", "code": "{\n\tplugin_data *p = p_d;\n\n\tUNUSED(srv);\n\n\tif (!p) return HANDLER_GO_ON;\n\n\tif (p->config_storage) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\t\tplugin_config *s = p->config_storage[i];\n\n\t\t\tarray_free(s->request_header);\n\t\t\tarray_free(s->response_header);\n\t\t\tarray_free(s->environment);\n\n\t\t\tfree(s);\n\t\t}\n\t\tfree(p->config_storage);\n\t}\n\n\tfree(p);\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\mod_setenv.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_skeleton_init)", "code": "{\n\tplugin_data *p;\n\n\tp = calloc(1, sizeof(*p));\n\n\tp->match_buf = buffer_init();\n\n\treturn p;\n}", "path": "src\\mod_skeleton.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* this function is called at dlopen() time and inits the callbacks */\n", "func_signal": "int mod_skeleton_plugin_init(plugin *p)", "code": "{\n\tp->version     = LIGHTTPD_VERSION_ID;\n\tp->name        = buffer_init_string(\"skeleton\");\n\n\tp->init        = mod_skeleton_init;\n\tp->handle_uri_clean  = mod_skeleton_uri_handler;\n\tp->set_defaults  = mod_skeleton_set_defaults;\n\tp->cleanup     = mod_skeleton_free;\n\n\tp->data        = NULL;\n\n\treturn 0;\n}", "path": "src\\mod_skeleton.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_setenv_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i = 0;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"setenv.add-request-header\",  NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ \"setenv.add-response-header\", NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 1 */\n\t\t{ \"setenv.add-environment\",     NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 2 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->request_header   = array_init();\n\t\ts->response_header  = array_init();\n\t\ts->environment      = array_init();\n\n\t\tcv[0].destination = s->request_header;\n\t\tcv[1].destination = s->response_header;\n\t\tcv[2].destination = s->environment;\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\mod_setenv.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n   extract a forward array from the environment\n*/\n", "func_signal": "static array *extract_forward_array(buffer *pbuffer)", "code": "{\n\tarray *result = array_init();\n\tif (pbuffer->used > 0) {\n\t\tchar *base, *curr;\n\t\t/* state variable, 0 means not in string, 1 means in string */\n\t\tint in_str = 0;\n\t\tfor (base = pbuffer->ptr, curr = pbuffer->ptr; *curr; curr++) {\n\t\t\tif (in_str) {\n\t\t\t\tif ((*curr > '9' || *curr < '0') && *curr != '.' && *curr != ':') {\n\t\t\t\t\t/* found an separator , insert value into result array */\n\t\t\t\t\tput_string_into_array_len(result, base, curr - base);\n\t\t\t\t\t/* change state to not in string */\n\t\t\t\t\tin_str = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*curr >= '0' && *curr <= '9') {\n\t\t\t\t\t/* found leading char of an IP address, move base pointer and change state */\n\t\t\t\t\tbase = curr;\n\t\t\t\t\tin_str = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* if breaking out while in str, we got to the end of string, so add it */\n\t\tif (in_str) {\n\t\t\tput_string_into_array_len(result, base, curr - base);\n\t\t}\n\t}\n\treturn result;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n** This function allocates a new parser.\n** The only argument is a pointer to a function which works like\n** malloc.\n**\n** Inputs:\n** A pointer to the function used to allocate memory.\n**\n** Outputs:\n** A pointer to a parser.  This pointer is used in subsequent calls\n** to ssiexprparser and ssiexprparserFree.\n*/\n", "func_signal": "void *ssiexprparserAlloc(void *(*mallocProc)(size_t))", "code": "{\n  yyParser *pParser;\n  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );\n  if( pParser ){\n    pParser->yyidx = -1;\n  }\n  return pParser;\n}", "path": "src\\mod_ssi_exprparser.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n** Pop the parser's stack once.\n**\n** If there is a destructor routine associated with the token which\n** is popped from the stack, then call it.\n**\n** Return the major token number for the symbol popped.\n*/\n", "func_signal": "static int yy_pop_parser_stack(yyParser *pParser)", "code": "{\n  YYCODETYPE yymajor;\n  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];\n\n  if( pParser->yyidx<0 ) return 0;\n#ifndef NDEBUG\n  if( yyTraceFILE && pParser->yyidx>=0 ){\n    fprintf(yyTraceFILE,\"%sPopping %s\\n\",\n      yyTracePrompt,\n      yyTokenName[yytos->major]);\n  }\n#endif\n  yymajor = yytos->major;\n  yy_destructor( yymajor, &yytos->minor);\n  pParser->yyidx--;\n  return yymajor;\n}", "path": "src\\lempar.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n** This function allocates a new parser.\n** The only argument is a pointer to a function which works like\n** malloc.\n**\n** Inputs:\n** A pointer to the function used to allocate memory.\n**\n** Outputs:\n** A pointer to a parser.  This pointer is used in subsequent calls\n** to Parse and ParseFree.\n*/\n", "func_signal": "void *ParseAlloc(void *(*mallocProc)(size_t))", "code": "{\n  yyParser *pParser;\n  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );\n  if( pParser ){\n    pParser->yyidx = -1;\n  }\n  return pParser;\n}", "path": "src\\lempar.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_skeleton_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i = 0;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"skeleton.array\",             NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->match    = array_init();\n\n\t\tcv[0].destination = s->match;\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\mod_skeleton.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/*\n** Pop the parser's stack once.\n**\n** If there is a destructor routine associated with the token which\n** is popped from the stack, then call it.\n**\n** Return the major token number for the symbol popped.\n*/\n", "func_signal": "static int yy_pop_parser_stack(yyParser *pParser)", "code": "{\n  YYCODETYPE yymajor;\n  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];\n\n  if( pParser->yyidx<0 ) return 0;\n#ifndef NDEBUG\n  if( yyTraceFILE && pParser->yyidx>=0 ){\n    fprintf(yyTraceFILE,\"%sPopping %s\\n\",\n      yyTracePrompt,\n      yyTokenName[yytos->major]);\n  }\n#endif\n  yymajor = yytos->major;\n  yy_destructor( yymajor, &yytos->minor);\n  pParser->yyidx--;\n  return yymajor;\n}", "path": "src\\mod_ssi_exprparser.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_setenv_init)", "code": "{\n\tplugin_data *p;\n\n\tp = calloc(1, sizeof(*p));\n\n\treturn p;\n}", "path": "src\\mod_setenv.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_extforward_init)", "code": "{\n\tplugin_data *p;\n\tp = calloc(1, sizeof(*p));\n\treturn p;\n}", "path": "src\\mod_extforward.c", "repo_name": "wangmh/lighttpd-fastdfs", "stars": 23, "license": "bsd-3-clause", "language": "c", "size": 1215}
{"docstring": "/* Helper function to make the disconnect happen and clean up. */\n", "func_signal": "static void __redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n    int status;\n\n    /* Make sure error is accessible if there is any */\n    __redisAsyncCopyError(ac);\n    status = (ac->err == 0) ? REDIS_OK : REDIS_ERR;\n\n    if (status == REDIS_OK) {\n        /* When the connection is cleanly disconnected, there should not\n         * be pending callbacks. */\n        assert(__redisShiftCallback(&ac->replies,NULL) == REDIS_ERR);\n    } else {\n        /* Callbacks should not be able to issue new commands. */\n        c->flags |= REDIS_DISCONNECTING;\n\n        /* Execute pending callbacks with NULL reply. */\n        while (__redisShiftCallback(&ac->replies,&cb) == REDIS_OK) {\n            if (cb.fn != NULL)\n                cb.fn(ac,NULL,cb.privdata);\n        }\n    }\n\n    /* Signal event lib to clean up */\n    if (ac->evCleanup) ac->evCleanup(ac->data);\n\n    /* Execute callback with proper status */\n    if (ac->onDisconnect) ac->onDisconnect(ac,status);\n\n    /* Cleanup self */\n    redisFree(c);\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* We want the error field to be accessible directly instead of requiring\n * an indirection to the redisContext struct. */\n", "func_signal": "static void __redisAsyncCopyError(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    ac->err = c->err;\n    ac->errstr = c->errstr;\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Helper function for the redisAsyncCommand* family of functions.\n *\n * Write a formatted command to the output buffer and register the provided\n * callback function with the context.\n */\n", "func_signal": "static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, char *cmd, size_t len)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n\n    /* Don't accept new commands when the connection is lazily closed. */\n    if (c->flags & REDIS_DISCONNECTING) return REDIS_ERR;\n    __redisAppendCommand(c,cmd,len);\n\n    /* Store callback */\n    cb.fn = fn;\n    cb.privdata = privdata;\n    __redisPushCallback(&ac->replies,&cb);\n\n    /* Always schedule a write when the write buffer is non-empty */\n    if (ac->evAddWrite) ac->evAddWrite(ac->data);\n\n    return REDIS_OK;\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Helper function for redisvFormatCommand(). */\n", "func_signal": "static void addArgument(sds a, char ***argv, int *argc, int *totlen)", "code": "{\n    (*argc)++;\n    if ((*argv = realloc(*argv, sizeof(char*)*(*argc))) == NULL) redisOOM();\n    if (totlen) *totlen = *totlen+1+intlen(sdslen(a))+2+sdslen(a)+2;\n    (*argv)[(*argc)-1] = a;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Use this function to handle a read event on the descriptor. It will try\n * and read some bytes from the socket and feed them to the reply parser.\n *\n * After this function is called, you may use redisContextReadReply to\n * see if there is a reply available. */\n", "func_signal": "int redisBufferRead(redisContext *c)", "code": "{\n    char buf[2048];\n    int nread = read(c->fd,buf,sizeof(buf));\n    if (nread == -1) {\n        if (errno == EAGAIN) {\n            /* Try again later */\n        } else {\n            __redisSetError(c,REDIS_ERR_IO,NULL);\n            return REDIS_ERR;\n        }\n    } else if (nread == 0) {\n        __redisSetError(c,REDIS_ERR_EOF,\n            sdsnew(\"Server closed the connection\"));\n        return REDIS_ERR;\n    } else {\n        __redisCreateReplyReader(c);\n        redisReplyReaderFeed(c->reader,buf,nread);\n    }\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Read a long long value starting at *s, under the assumption that it will be\n * terminated by \\r\\n. Ambiguously returns -1 for unexpected input. */\n", "func_signal": "static long long readLongLong(char *s)", "code": "{\n    long long v = 0;\n    int dec, mult = 1;\n    char c;\n\n    if (*s == '-') {\n        mult = -1;\n        s++;\n    } else if (*s == '+') {\n        mult = 1;\n        s++;\n    }\n\n    while ((c = *(s++)) != '\\r') {\n        dec = c - '0';\n        if (dec >= 0 && dec < 10) {\n            v *= 10;\n            v += dec;\n        } else {\n            /* Should not happen... */\n            return -1;\n        }\n    }\n\n    return mult*v;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\n", "func_signal": "sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count)", "code": "{\n    int elements = 0, slots = 5, start = 0, j;\n\n    sds *tokens = malloc(sizeof(sds)*slots);\n#ifdef SDS_ABORT_ON_OOM\n    if (tokens == NULL) sdsOomAbort();\n#endif\n    if (seplen < 1 || len < 0 || tokens == NULL) return NULL;\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        if (slots < elements+2) {\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) {\n#ifdef SDS_ABORT_ON_OOM\n                sdsOomAbort();\n#else\n                goto cleanup;\n#endif\n            }\n            tokens = newtokens;\n        }\n        /* search the separator */\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start);\n            if (tokens[elements] == NULL) {\n#ifdef SDS_ABORT_ON_OOM\n                sdsOomAbort();\n#else\n                goto cleanup;\n#endif\n            }\n            elements++;\n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start);\n    if (tokens[elements] == NULL) {\n#ifdef SDS_ABORT_ON_OOM\n                sdsOomAbort();\n#else\n                goto cleanup;\n#endif\n    }\n    elements++;\n    *count = elements;\n    return tokens;\n\n#ifndef SDS_ABORT_ON_OOM\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        free(tokens);\n        return NULL;\n    }\n#endif\n}", "path": "hiredis\\sds.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Format a command according to the Redis protocol. This function\n * takes a format similar to printf:\n *\n * %s represents a C null terminated string you want to interpolate\n * %b represents a binary safe string\n *\n * When using %b you need to provide both the pointer to the string\n * and the length in bytes. Examples:\n *\n * len = redisFormatCommand(target, \"GET %s\", mykey);\n * len = redisFormatCommand(target, \"SET %s %b\", mykey, myval, myvallen);\n */\n", "func_signal": "int redisFormatCommand(char **target, const char *format, ...)", "code": "{\n    va_list ap;\n    int len;\n    va_start(ap,format);\n    len = redisvFormatCommand(target,format,ap);\n    va_end(ap);\n    return len;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* This function should be called when the socket is readable.\n * It processes all replies that can be read and executes their callbacks.\n */\n", "func_signal": "void redisAsyncHandleRead(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    if (redisBufferRead(c) == REDIS_ERR) {\n        __redisAsyncDisconnect(ac);\n    } else {\n        /* Always re-schedule reads */\n        if (ac->evAddRead) ac->evAddRead(ac->data);\n        redisProcessCallbacks(ac);\n    }\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Tries to do a clean disconnect from Redis, meaning it stops new commands\n * from being issued, but tries to flush the output buffer and execute\n * callbacks for all remaining replies.\n *\n * This functions is generally called from within a callback, so the\n * processCallbacks function will pick up the flag when there are no\n * more replies. */\n", "func_signal": "void redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    c->flags |= REDIS_DISCONNECTING;\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Set the private data field that is used in the read tasks. This argument can\n * be used to curry arbitrary data to the custom reply object functions. */\n", "func_signal": "int redisReplyReaderSetPrivdata(void *reader, void *privdata)", "code": "{\n    redisReader *r = reader;\n    if (r->reply == NULL) {\n        r->privdata = privdata;\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Helper function to lazily create a reply reader. */\n", "func_signal": "static void __redisCreateReplyReader(redisContext *c)", "code": "{\n    if (c->reader == NULL) {\n        c->reader = redisReplyReaderCreate();\n        assert(redisReplyReaderSetReplyObjectFunctions(c->reader,c->fn) == REDIS_OK);\n    }\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned. The caller should sdsfree() all the returned\n * strings and finally free() the array itself.\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n */\n", "func_signal": "sds *sdssplitargs(char *line, int *argc)", "code": "{\n    char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0; /* set to 1 if we are in \"quotes\" */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    free(vector);\n    if (current) sdsfree(current);\n    return NULL;\n}", "path": "hiredis\\sds.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Free a reply object */\n", "func_signal": "void freeReplyObject(void *reply)", "code": "{\n    redisReply *r = reply;\n    size_t j;\n\n    switch(r->type) {\n    case REDIS_REPLY_INTEGER:\n        break; /* Nothing to free */\n    case REDIS_REPLY_ARRAY:\n        for (j = 0; j < r->elements; j++)\n            if (r->element[j]) freeReplyObject(r->element[j]);\n        free(r->element);\n        break;\n    case REDIS_REPLY_ERROR:\n    case REDIS_REPLY_STATUS:\n    case REDIS_REPLY_STRING:\n        free(r->str);\n        break;\n    }\n    free(r);\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Helper function for the redisCommand* family of functions.\n *\n * Write a formatted command to the output buffer. If the given context is\n * blocking, immediately read the reply into the \"reply\" pointer. When the\n * context is non-blocking, the \"reply\" pointer will not be used and the\n * command is simply appended to the write buffer.\n *\n * Returns the reply when a reply was succesfully retrieved. Returns NULL\n * otherwise. When NULL is returned in a blocking context, the error field\n * in the context will be set.\n */\n", "func_signal": "static void *__redisCommand(redisContext *c, char *cmd, size_t len)", "code": "{\n    void *aux = NULL;\n    __redisAppendCommand(c,cmd,len);\n\n    if (c->flags & REDIS_BLOCK) {\n        if (redisGetReply(c,&aux) == REDIS_OK)\n            return aux;\n        return NULL;\n    }\n    return NULL;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Set the replyObjectFunctions to use. Returns REDIS_ERR when the reader\n * was already initialized and the function set could not be re-set.\n * Return REDIS_OK when they could be set. */\n", "func_signal": "int redisSetReplyObjectFunctions(redisContext *c, redisReplyObjectFunctions *fn)", "code": "{\n    if (c->reader != NULL)\n        return REDIS_ERR;\n    c->fn = fn;\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Write the output buffer to the socket.\n *\n * Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was\n * succesfully written to the socket. When the buffer is empty after the\n * write operation, \"wdone\" is set to 1 (if given).\n *\n * Returns REDIS_ERR if an error occured trying to write and sets\n * c->error to hold the appropriate error string.\n */\n", "func_signal": "int redisBufferWrite(redisContext *c, int *done)", "code": "{\n    int nwritten;\n    if (sdslen(c->obuf) > 0) {\n        nwritten = write(c->fd,c->obuf,sdslen(c->obuf));\n        if (nwritten == -1) {\n            if (errno == EAGAIN) {\n                /* Try again later */\n            } else {\n                __redisSetError(c,REDIS_ERR_IO,NULL);\n                return REDIS_ERR;\n            }\n        } else if (nwritten > 0) {\n            if (nwritten == (signed)sdslen(c->obuf)) {\n                sdsfree(c->obuf);\n                c->obuf = sdsempty();\n            } else {\n                c->obuf = sdsrange(c->obuf,nwritten,-1);\n            }\n        }\n    }\n    if (done != NULL) *done = (sdslen(c->obuf) == 0);\n    return REDIS_OK;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Set the function set to build the reply. Returns REDIS_OK when there\n * is no temporary object and it can be set, REDIS_ERR otherwise. */\n", "func_signal": "int redisReplyReaderSetReplyObjectFunctions(void *reader, redisReplyObjectFunctions *fn)", "code": "{\n    redisReader *r = reader;\n    if (r->reply == NULL) {\n        r->fn = fn;\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Helper functions to push/shift callbacks */\n", "func_signal": "static int __redisPushCallback(redisCallbackList *list, redisCallback *source)", "code": "{\n    redisCallback *cb;\n\n    /* Copy callback from stack to heap */\n    cb = calloc(1,sizeof(*cb));\n    if (!cb) redisOOM();\n    if (source != NULL) {\n        cb->fn = source->fn;\n        cb->privdata = source->privdata;\n    }\n\n    /* Store callback in list */\n    if (list->head == NULL)\n        list->head = cb;\n    if (list->tail != NULL)\n        list->tail->next = cb;\n    list->tail = cb;\n    return REDIS_OK;\n}", "path": "hiredis\\async.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/* Format a command according to the Redis protocol. This function takes the\n * number of arguments, an array with arguments and an array with their\n * lengths. If the latter is set to NULL, strlen will be used to compute the\n * argument lengths.\n */\n", "func_signal": "int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen)", "code": "{\n    char *cmd = NULL; /* final command */\n    int pos; /* position in final command */\n    size_t len;\n    int totlen, j;\n\n    /* Calculate number of bytes needed for the command */\n    totlen = 1+intlen(argc)+2;\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        totlen += 1+intlen(len)+2+len+2;\n    }\n\n    /* Build the command at protocol level */\n    cmd = malloc(totlen+1);\n    if (!cmd) redisOOM();\n    pos = sprintf(cmd,\"*%d\\r\\n\",argc);\n    for (j = 0; j < argc; j++) {\n        len = argvlen ? argvlen[j] : strlen(argv[j]);\n        pos += sprintf(cmd+pos,\"$%zu\\r\\n\",len);\n        memcpy(cmd+pos,argv[j],len);\n        pos += len;\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[totlen] = '\\0';\n    *target = cmd;\n    return totlen;\n}", "path": "hiredis\\hiredis.c", "repo_name": "nicolasff/php-hiredis", "stars": 21, "license": "None", "language": "c", "size": 574}
{"docstring": "/**\n  * @brief Enable the UART1 peripheral.\n  * @par Full description:\n  * Enable the UART1 peripheral.\n  * @param[in] NewState new state of the UART1 Communication.\n  * This parameter can be:\n  * - ENABLE\n  * - DISABLE\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_Cmd(FunctionalState NewState)", "code": "{\n    if (NewState != DISABLE)\n    {\n        UART1->CR1 &= (u8)(~UART1_CR1_UARTD); /**< UART1 Enable */\n    }\n    else\n    {\n        UART1->CR1 |= UART1_CR1_UARTD;  /**< UART1 Disable (for low power consumption) */\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Configures the Leds and the Buttons IO.\n  * @par Parameters:\n  * None\n  * @retval \n  * None\n  */\n", "func_signal": "void GPIO_Configuration(void)", "code": "{\n  \n\n  /* LEDS: Initialize I/Os in Output Mode */\n  GPIO_Init(LEDS_PORT, (LED1_PIN | LED2_PIN | LED3_PIN | LED4_PIN), GPIO_MODE_OUT_PP_LOW_FAST);\n\t\n\t/* Button: Initialize I/O in Input Mode with No Interrupt */\n\n  GPIO_Init(BUTTON_PORT, BUTTON_PIN, GPIO_MODE_IN_FL_NO_IT);\n\t\n\t/* JOYSTICK_SEL: Initialize I/O in Input Mode with No Interrupt */\n  GPIO_Init(JOYSTICK_SEL_PORT, JOYSTICK_SEL_PIN, GPIO_MODE_IN_FL_NO_IT);\n}", "path": "FWLib\\examples\\WWDG\\WWDG_RearmReset\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Enables or disables the UART1s LIN mode.\n  * @par Full description:\n  * Enables or disables the UART1s LIN mode.\n  * @param[in] NewState is new state of the UART1 LIN mode.\n  * This parameter can be: ENABLE or DISABLE.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_LINCmd(FunctionalState NewState)", "code": "{\n    assert_param(IS_FUNCTIONALSTATE_OK(NewState));\n\n    if (NewState != DISABLE)\n    {\n        /* Enable the LIN mode by setting the LINE bit in the CR2 register */\n        UART1->CR3 |= UART1_CR3_LINEN;\n    }\n    else\n    {\n        /* Disable the LIN mode by clearing the LINE bit in the CR2 register */\n        UART1->CR3 &= ((u8)~UART1_CR3_LINEN);\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Transmits 9 bit data through the UART1 peripheral.\n  * @par Full description:\n  * Transmits 9 bit data through the UART1 peripheral.\n  * @param[in] Data: the data to transmit.\n  * @retval\n  * None\n  * @par Required preconditions:\n  * UART1_Cmd(ENABLE);\n  */\n", "func_signal": "void UART1_SendData9(u16 Data)", "code": "{\n    /**< Clear the transmit data bit 8 [8]  */\n    UART1->CR1 &= ((u8)~UART1_CR1_T8);\n    /**< Write the transmit data bit [8]  */\n    UART1->CR1 |= (u8)(((u8)(Data >> 2)) & UART1_CR1_T8);\n    /**< Write the transmit data bit [0:7] */\n    UART1->DR   = (u8)(Data);\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Sets the UART1 LIN Break detection length.\n  * @par Full description:\n  * Sets the UART1 LIN Break detection length.\n  * @param[in] UART1_LINBreakDetectionLength specifies the LIN break detection length.\n  * This parameter can be any of the @ref UART1_LINBreakDetectionLength_TypeDef values.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_LINBreakDetectionConfig(UART1_LINBreakDetectionLength_TypeDef UART1_LINBreakDetectionLength)", "code": "{\n    assert_param(IS_UART1_LINBREAKDETECTIONLENGTH_OK(UART1_LINBreakDetectionLength));\n\n    if (UART1_LINBreakDetectionLength != UART1_LINBREAKDETECTIONLENGTH_10BITS)\n    {\n        UART1->CR4 |= UART1_CR4_LBDL;\n    }\n    else\n    {\n        UART1->CR4 &= ((u8)~UART1_CR4_LBDL);\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Enables or disables the UART1s Half Duplex communication.\n  * @par Full description:\n  * Enables or disables the UART1s Half Duplex communication.\n  * @param[in] NewState new state of the UART1 Communication.\n  *                    This parameter can be: ENABLE or DISABLE.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_HalfDuplexCmd(FunctionalState NewState)", "code": "{\n    assert_param(IS_FUNCTIONALSTATE_OK(NewState));\n\n    if (NewState != DISABLE)\n    {\n        UART1->CR5 |= UART1_CR5_HDSEL;  /**< UART1 Half Duplex Enable  */\n    }\n    else\n    {\n        UART1->CR5 &= (u8)~UART1_CR5_HDSEL; /**< UART1 Half Duplex Disable */\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief  Reports the name of the source file and the source line number\n  *   where the assert_param error has occurred.\n  * @param file: pointer to the source file name\n  * @param line: assert_param error line source number\n  * @retval \n  * None\n  */\n", "func_signal": "void assert_failed(u8* file, u32 line)", "code": "{ \n  /* User can add his own implementation to report the file name and line number,\n     ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\n\n  /* Infinite loop */\n  while (1)\n  {\n  }\n}", "path": "FWLib\\examples\\SPI\\SPI_SimplexLCD\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Delay.\n  * @param[in] nCount\n  * @retval \n  * None\n  */\n", "func_signal": "void Delay(u16 nCount)", "code": "{\n    /* Decrement nCount value */\n    while (nCount != 0)\n    {\n        nCount--;\n    }\n}", "path": "FWLib\\examples\\SPI\\SPI_SimplexLCD\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief  Reports the name of the source file and the source line number\n  *   where the assert_param error has occurred.\n  * @param file: pointer to the source file name\n  * @param line: assert_param error line source number\n  * @retval \n  * None\n  */\n", "func_signal": "void assert_failed(u8* file, u32 line)", "code": "{ \n  /* User can add his own implementation to report the file name and line number,\n     ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\n\n  /* Infinite loop */\n  while (1)\n  {\n  }\n}", "path": "FWLib\\examples\\WWDG\\WWDG_RearmReset\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/* Private functions ---------------------------------------------------------*/\n", "func_signal": "void Delay(u16 nCount)", "code": "{\n  /* Decrement nCount value */\n  while (nCount != 0)\n  {\n    nCount--;\n  }\n}", "path": "FWLib\\examples\\WWDG\\WWDG_RearmReset\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Enables or disables the UART1s IrDA interface.\n  * @par Full description:\n  * Enables or disables the UART1s IrDA interface.\n  * @par This function is related to IrDA mode.\n  * @param[in] NewState new state of the IrDA mode.\n  * This parameter can be: ENABLE or DISABLE.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_IrDACmd(FunctionalState NewState)", "code": "{\n\n    /* Check parameters */\n    assert_param(IS_FUNCTIONALSTATE_OK(NewState));\n\n    if (NewState != DISABLE)\n    {\n        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */\n        UART1->CR5 |= UART1_CR5_IREN;\n    }\n    else\n    {\n        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */\n        UART1->CR5 &= ((u8)~UART1_CR5_IREN);\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Configures the UART1s IrDA interface.\n  * @par Full description:\n  * Configures the UART1s IrDA interface.\n  * @par This function is valid only for UART1.\n  * @param[in] UART1_IrDAMode specifies the IrDA mode.\n  * This parameter can be any of the @ref UART1_IrDAMode_TypeDef values.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_IrDAConfig(UART1_IrDAMode_TypeDef UART1_IrDAMode)", "code": "{\n    assert_param(IS_UART1_IRDAMODE_OK(UART1_IrDAMode));\n\n    if (UART1_IrDAMode != UART1_IRDAMODE_NORMAL)\n    {\n        UART1->CR5 |= UART1_CR5_IRLP;\n    }\n    else\n    {\n        UART1->CR5 &= ((u8)~UART1_CR5_IRLP);\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Enables or disables the specified UART1 interrupts.\n  * @par Full description:\n  * Enables or disables the specified UART1 interrupts.\n  * @param[in] UART1_IT specifies the UART1 interrupt sources to be enabled or disabled.\n  * This parameter can be one of the following values:\n  *   - UART1_IT_LBDF:  LIN Break detection interrupt\n  *   - UART1_IT_TXE:  Tansmit Data Register empty interrupt\n  *   - UART1_IT_TC:   Transmission complete interrupt\n  *   - UART1_IT_RXNE_OR: Receive Data register not empty/Over run error interrupt\n  *   - UART1_IT_IDLE: Idle line detection interrupt\n  *   - UART1_IT_PE:   Parity Error interrupt\n  * @param[in] NewState new state of the specified UART1 interrupts.\n  * This parameter can be: ENABLE or DISABLE.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_ITConfig(UART1_IT_TypeDef UART1_IT, FunctionalState NewState)", "code": "{\n    u8 uartreg, itpos = 0x00;\n    assert_param(IS_UART1_CONFIG_IT_OK(UART1_IT));\n    assert_param(IS_FUNCTIONALSTATE_OK(NewState));\n\n    /* Get the UART1 register index */\n    uartreg = (u8)(UART1_IT >> (u8)0x08);\n    /* Get the UART1 IT index */\n    itpos = (u8)((u8)1 << (u8)((u8)UART1_IT & (u8)0x0F));\n\n    if (NewState != DISABLE)\n    {\n        /**< Enable the Interrupt bits according to UART1_IT mask */\n        if (uartreg == 0x01)\n        {\n            UART1->CR1 |= itpos;\n        }\n        else if (uartreg == 0x02)\n        {\n            UART1->CR2 |= itpos;\n        }\n        else\n        {\n            UART1->CR4 |= itpos;\n        }\n    }\n    else\n    {\n        /**< Disable the interrupt bits according to UART1_IT mask */\n        if (uartreg == 0x01)\n        {\n            UART1->CR1 &= (u8)(~itpos);\n        }\n        else if (uartreg == 0x02)\n        {\n            UART1->CR2 &= (u8)(~itpos);\n        }\n        else\n        {\n            UART1->CR4 &= (u8)(~itpos);\n        }\n    }\n\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Tests if the Microcontroller has occured an WWDG Reset, If Yes, Leds are Toggled n times.\n  * @par Parameters:\n  * None\n  * @retval \n  * None\n  */\n", "func_signal": "void Test_WWDGReset(void)", "code": "{\n  FlagStatus WwdgFlag;\n\tu8 i=0;\n\tu8 n=2;\n  u8 Leds = (LED1_PIN | LED2_PIN | LED3_PIN | LED4_PIN);\n  \n  /*Get WWDG Reset Status */ \n\tWwdgFlag = RST_GetFlagStatus(RST_FLAG_WWDGF);\n\n  \n  /* Test if a WWDG Reset has occured */\n\tif (WwdgFlag)\n  {\n\t\t /* Clear IWDGF Flag */\n\t\tRST_ClearFlag(RST_FLAG_WWDGF);\n\t\t\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\t/* ---------- An WWDG Reset has occured, Toggles LD1, LD2, LD3 and LD4 ------- */\n\t\t\t/* LEDs on */\n\t\t\tGPIO_WriteHigh(LEDS_PORT, Leds);\n\t\t\t/* delay */\t\t\n\t\t\tDelay(TIME);\n\t\t\tDelay(TIME);\n\t\t\t/* LEDs off */\n\t\t\tGPIO_WriteLow(LEDS_PORT, Leds); \n\t\t\t/* Delay */\t\t\n\t\t\tDelay(TIME);\n\t\t\tDelay(TIME);\n\t\t}\n\t}\n}", "path": "FWLib\\examples\\WWDG\\WWDG_RearmReset\\main.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Selects the UART1 WakeUp method.\n  * @par Full description:\n  * Selects the UART1 WakeUp method.\n  * @param[in] UART1_WakeUp: specifies the UART1 wakeup method.\n  * This parameter can be any of the @ref UART1_WakeUp_TypeDef values.\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_WakeUpConfig(UART1_WakeUp_TypeDef UART1_WakeUp)", "code": "{\n    assert_param(IS_UART1_WAKEUP_OK(UART1_WakeUp));\n\n    UART1->CR1 &= ((u8)~UART1_CR1_WAKE);\n    UART1->CR1 |= (u8)UART1_WakeUp;\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Sets IWDG Prescaler value.\n  * @par Full description:\n  * IWDG_Prescaler: specifies the IWDG Prescaler value.\n  * This parameter can be one of the following values:\n  *  - IWDG_Prescaler_4: IWDG prescaler set to 4\n  *  - IWDG_Prescaler_8: IWDG prescaler set to 8\n  *  - IWDG_Prescaler_16: IWDG prescaler set to 16\n  *  - IWDG_Prescaler_32: IWDG prescaler set to 32\n  *  - IWDG_Prescaler_64: IWDG prescaler set to 64\n  *  - IWDG_Prescaler_128: IWDG prescaler set to 128\n  *  - IWDG_Prescaler_256: IWDG prescaler set to 256\n  * @param[in] IWDG_Prescaler set the value of the prescaler register.\n  * @retval None\n  * @par Required preconditions:\n  * Write access enabled\n  */\n", "func_signal": "void IWDG_SetPrescaler(IWDG_Prescaler_TypeDef IWDG_Prescaler)", "code": "{\n    /* Check the parameters */\n    assert_param(IS_IWDG_PRESCALER_OK(IWDG_Prescaler));\n\n    IWDG->PR = (u8)IWDG_Prescaler;\n}", "path": "FWLib\\library\\src\\stm8s_iwdg.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Enables or disables NACK transmission.\n  * @par Full description:\n  * Enables or disables NACK transmission.\n  * @par This function is valid only for UART1 because is related to SmartCard mode.\n  * @param[in] NewState: new state of the Smart Card mode.\n  * This parameter can be: ENABLE or DISABLE.\n  */\n", "func_signal": "void UART1_SmartCardNACKCmd(FunctionalState NewState)", "code": "{\n    assert_param(IS_FUNCTIONALSTATE_OK(NewState));\n\n    if (NewState != DISABLE)\n    {\n        /* Enable the NACK transmission by setting the NACK bit in the CR5 register */\n        UART1->CR5 |= UART1_CR5_NACK;\n    }\n    else\n    {\n        /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */\n        UART1->CR5 &= ((u8)~(UART1_CR5_NACK));\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Checks whether the specified UART1 interrupt has occurred or not.\n  * @par Full description:\n  * Checks whether the specified UART1 interrupt has occurred or not.\n  * @param[in] UART1_IT: Specifies the UART1 interrupt pending bit to check.\n  * This parameter can be one of the following values:\n  *   - UART1_IT_LBDF:  LIN Break detection interrupt\n  *   - UART1_IT_TXE:  Tansmit Data Register empty interrupt\n  *   - UART1_IT_TC:   Transmission complete interrupt\n  *   - UART1_IT_RXNE: Receive Data register not empty interrupt\n  *   - UART1_IT_IDLE: Idle line detection interrupt\n  *   - UART1_IT_OR:  OverRun Error interrupt\n  *   - UART1_IT_PE:   Parity Error interrupt\n  * @retval\n  * ITStatus The new state of UART1_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus UART1_GetITStatus(UART1_IT_TypeDef UART1_IT)", "code": "{\n    ITStatus pendingbitstatus = RESET;\n    u8 itpos = 0;\n    u8 itmask1 = 0;\n    u8 itmask2 = 0;\n    u8 enablestatus = 0;\n\n    /* Check parameters */\n    assert_param(IS_UART1_GET_IT_OK(UART1_IT));\n\n    /* Get the UART1 IT index */\n    itpos = (u8)((u8)1 << (u8)((u8)UART1_IT & (u8)0x0F));\n    /* Get the UART1 IT index */\n    itmask1 = (u8)((u8)UART1_IT >> (u8)4);\n    /* Set the IT mask*/\n    itmask2 = (u8)((u8)1 << itmask1);\n\n\n    /* Check the status of the specified UART1 pending bit*/\n    if (UART1_IT == UART1_IT_PE)\n    {\n        /* Get the UART1_IT enable bit status*/\n        enablestatus = (u8)((u8)UART1->CR1 & itmask2);\n        /* Check the status of the specified UART1 interrupt*/\n\n        if (((UART1->SR & itpos) != (u8)0x00) && enablestatus)\n        {\n            /* Interrupt occurred*/\n            pendingbitstatus = SET;\n        }\n        else\n        {\n            /* Interrupt not occurred*/\n            pendingbitstatus = RESET;\n        }\n    }\n\n    else if (UART1_IT == UART1_IT_LBDF)\n    {\n        /* Get the UART1_IT enable bit status*/\n        enablestatus = (u8)((u8)UART1->CR4 & itmask2);\n        /* Check the status of the specified UART1 interrupt*/\n        if (((UART1->CR4 & itpos) != (u8)0x00) && enablestatus)\n        {\n            /* Interrupt occurred*/\n            pendingbitstatus = SET;\n        }\n        else\n        {\n            /* Interrupt not occurred*/\n            pendingbitstatus = RESET;\n        }\n    }\n    else\n    {\n        /* Get the UART1_IT enable bit status*/\n        enablestatus = (u8)((u8)UART1->CR2 & itmask2);\n        /* Check the status of the specified UART1 interrupt*/\n        if (((UART1->SR & itpos) != (u8)0x00) && enablestatus)\n        {\n            /* Interrupt occurred*/\n            pendingbitstatus = SET;\n        }\n        else\n        {\n            /* Interrupt not occurred*/\n            pendingbitstatus = RESET;\n        }\n    }\n\n    /* Return the UART1_IT status*/\n    return  pendingbitstatus;\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Checks whether the specified UART1 flag is set or not.\n  * @par Full description:\n  * Checks whether the specified UART1 flag is set or not.\n  * @param[in] UART1_FLAG specifies the flag to check.\n  * This parameter can be any of the @ref UART1_Flag_TypeDef enumeration.\n  * @retval FlagStatus (SET or RESET)\n  */\n", "func_signal": "FlagStatus UART1_GetFlagStatus(UART1_Flag_TypeDef UART1_FLAG)", "code": "{\n    FlagStatus status = RESET;\n\n    /* Check parameters */\n    assert_param(IS_UART1_FLAG_OK(UART1_FLAG));\n\n\n    /* Check the status of the specified UART1 flag*/\n    if (UART1_FLAG == UART1_FLAG_LBDF)\n    {\n        if ((UART1->CR4 & (u8)UART1_FLAG) != (u8)0x00)\n        {\n            /* UART1_FLAG is set*/\n            status = SET;\n        }\n        else\n        {\n            /* UART1_FLAG is reset*/\n            status = RESET;\n        }\n    }\n    else if (UART1_FLAG == UART1_FLAG_SBK)\n    {\n        if ((UART1->CR2 & (u8)UART1_FLAG) != (u8)0x00)\n        {\n            /* UART1_FLAG is set*/\n            status = SET;\n        }\n        else\n        {\n            /* UART1_FLAG is reset*/\n            status = RESET;\n        }\n    }\n    else\n    {\n        if ((UART1->SR & (u8)UART1_FLAG) != (u8)0x00)\n        {\n            /* UART1_FLAG is set*/\n            status = SET;\n        }\n        else\n        {\n            /* UART1_FLAG is reset*/\n            status = RESET;\n        }\n    }\n    /* Return the UART1_FLAG status*/\n    return status;\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/**\n  * @brief Initializes the UART1 according to the specified parameters.\n  * @param[in] BaudRate: The baudrate.\n  * @param[in] WordLength : This parameter can be any of the @ref UART1_WordLength_TypeDef enumeration.\n  * @param[in] StopBits: This parameter can be any of the @ref UART1_StopBits_TypeDef enumeration.\n  * @param[in] Parity: This parameter can be any of the @ref UART1_Parity_TypeDef enumeration.\n  * @param[in] SyncMode: This parameter can be any of the @ref UART1_SyncMode_TypeDef values.\n  * @param[in] Mode: This parameter can be any of the @ref UART1_Mode_TypeDef values\n  * @retval\n  * None\n  */\n", "func_signal": "void UART1_Init(u32 BaudRate, UART1_WordLength_TypeDef WordLength, UART1_StopBits_TypeDef StopBits, UART1_Parity_TypeDef Parity, UART1_SyncMode_TypeDef SyncMode, UART1_Mode_TypeDef Mode)", "code": "{\n    u32 BaudRate_Mantissa, BaudRate_Mantissa100 = 0;\n\n    /* assert_param: BaudRate value should be <= 625000 bps */\n    assert_param(IS_UART1_BAUDRATE_OK(BaudRate));\n\n    assert_param(IS_UART1_WORDLENGTH_OK(WordLength));\n\n    assert_param(IS_UART1_STOPBITS_OK(StopBits));\n\n    assert_param(IS_UART1_PARITY_OK(Parity));\n\n    /* assert_param: UART1_Mode value should exclude values such as  UART1_ModeTx_Enable|UART1_ModeTx_Disable */\n    assert_param(IS_UART1_MODE_OK((u8)Mode));\n\n    /* assert_param: UART1_SyncMode value should exclude values such as\n       UART1_CLOCK_ENABLE|UART1_CLOCK_DISABLE */\n    assert_param(IS_UART1_SYNCMODE_OK((u8)SyncMode));\n\n    UART1->CR1 &= (u8)(~UART1_CR1_M);  /**< Clear the word length bit */\n    UART1->CR1 |= (u8)WordLength; /**< Set the word length bit according to UART1_WordLength value */\n\n    UART1->CR3 &= (u8)(~UART1_CR3_STOP);  /**< Clear the STOP bits */\n    UART1->CR3 |= (u8)StopBits;  /**< Set the STOP bits number according to UART1_StopBits value  */\n\n    UART1->CR1 &= (u8)(~(UART1_CR1_PCEN | UART1_CR1_PS  ));  /**< Clear the Parity Control bit */\n    UART1->CR1 |= (u8)Parity;  /**< Set the Parity Control bit to UART1_Parity value */\n\n    UART1->BRR1 &= (u8)(~UART1_BRR1_DIVM);  /**< Clear the LSB mantissa of UART1DIV  */\n    UART1->BRR2 &= (u8)(~UART1_BRR2_DIVM);  /**< Clear the MSB mantissa of UART1DIV  */\n    UART1->BRR2 &= (u8)(~UART1_BRR2_DIVF);  /**< Clear the Fraction bits of UART1DIV */\n\n    /**< Set the UART1 BaudRates in BRR1 and BRR2 registers according to UART1_BaudRate value */\n    BaudRate_Mantissa    = ((u32)CLK_GetClockFreq() / (BaudRate << 4));\n    BaudRate_Mantissa100 = (((u32)CLK_GetClockFreq() * 100) / (BaudRate << 4));\n    UART1->BRR2 |= (u8)((u8)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100)) << 4) / 100) & (u8)0x0F); /**< Set the fraction of UART1DIV  */\n    UART1->BRR2 |= (u8)((BaudRate_Mantissa >> 4) & (u8)0xF0); /**< Set the MSB mantissa of UART1DIV  */\n    UART1->BRR1 |= (u8)BaudRate_Mantissa;           /**< Set the LSB mantissa of UART1DIV  */\n\n    UART1->CR2 &= (u8)~(UART1_CR2_TEN | UART1_CR2_REN); /**< Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */\n    UART1->CR3 &= (u8)~(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL); /**< Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */\n    UART1->CR3 |= (u8)((u8)SyncMode & (u8)(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL));  /**< Set the Clock Polarity, lock Phase, Last Bit Clock pulse */\n\n    if ((u8)Mode & (u8)UART1_MODE_TX_ENABLE)\n    {\n        UART1->CR2 |= (u8)UART1_CR2_TEN;  /**< Set the Transmitter Enable bit */\n    }\n    else\n    {\n        UART1->CR2 &= (u8)(~UART1_CR2_TEN);  /**< Clear the Transmitter Disable bit */\n    }\n    if ((u8)Mode & (u8)UART1_MODE_RX_ENABLE)\n    {\n        UART1->CR2 |= (u8)UART1_CR2_REN;  /**< Set the Receiver Enable bit */\n    }\n    else\n    {\n        UART1->CR2 &= (u8)(~UART1_CR2_REN);  /**< Clear the Receiver Disable bit */\n    }\n    /**< Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock pulse bits according to UART1_Mode value */\n    if ((u8)SyncMode&(u8)UART1_SYNCMODE_CLOCK_DISABLE)\n    {\n        UART1->CR3 &= (u8)(~UART1_CR3_CKEN); /**< Clear the Clock Enable bit */\n        /**< configure in Push Pull or Open Drain mode the Tx I/O line by setting the correct I/O Port register according the product package and line configuration*/\n    }\n    else\n    {\n        UART1->CR3 |= (u8)((u8)SyncMode & UART1_CR3_CKEN);\n    }\n}", "path": "FWLib\\library\\src\\stm8s_uart1.c", "repo_name": "joaquimorg/STM8SProjects", "stars": 31, "license": "None", "language": "c", "size": 576}
{"docstring": "/*\n  Translate SPACE to \"\\\\040\", etc.\n */\n", "func_signal": "static void\ngradient_name_encode (gchar       *dest,\n                      const gchar *src)", "code": "{\n  gint cnt = GRADIENT_NAME_MAX - 1;\n\n  while (*src && cnt--)\n    {\n      if (g_ascii_iscntrl (*src) || g_ascii_isspace (*src) || *src == '\\\\')\n        {\n          sprintf (dest, \"\\\\%03o\", *src++);\n          dest += 4;\n        }\n      else\n        *dest++ = *src++;\n    }\n  *dest = '\\0';\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n *      \"New\" button in Selector page\n */\n", "func_signal": "static void\ndlg_selector_new_callback (GtkWidget *widget,\n                           gpointer   data)", "code": "{\n  GtkWidget *query_box;\n\n  query_box = gimp_query_string_box (_(\"New Gradient Flare\"),\n                                     gtk_widget_get_toplevel (widget),\n                                     gimp_standard_help_func, PLUG_IN_PROC,\n                                     _(\"Enter a name for the new GFlare\"),\n                                     _(\"Unnamed\"),\n                                     NULL, NULL,\n                                     dlg_selector_new_ok_callback, dlg);\n  gtk_widget_show (query_box);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  Convert RGBA to RGB with rendering gray check if needed.\n        (from nova.c)\n  input:  guchar src[4]         RGBA pixel\n  output: guchar dest[3]        RGB pixel\n */\n", "func_signal": "static void\npreview_rgba_to_rgb (guchar *dest,\n                     gint    x,\n                     gint    y,\n                     guchar *src)", "code": "{\n  gint src_a;\n  gint check;\n  gint b;\n\n  src_a = src[3];\n\n  if (src_a == OPAQUE)  /* full opaque */\n    {\n      for (b = 0; b < 3; b++)\n        dest[b] = src[b];\n    }\n  else\n    {\n      if ((x % (GIMP_CHECK_SIZE) < GIMP_CHECK_SIZE_SM) ^\n          (y % (GIMP_CHECK_SIZE) < GIMP_CHECK_SIZE_SM))\n        check = GIMP_CHECK_LIGHT * 255;\n      else\n        check = GIMP_CHECK_DARK * 255;\n\n      if (src_a == 0)   /* full transparent */\n        {\n          for (b = 0; b < 3; b++)\n            dest[b] = check;\n        }\n      else\n        {\n          for (b = 0; b < 3; b++)\n            dest[b] = (src[b] * src_a + check * (OPAQUE-src_a)) / OPAQUE;\n        }\n    }\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  puts gradient menu with caption into table\n  occupies 1 row and 3 cols in table\n */\n", "func_signal": "static void\ned_put_gradient_menu (GtkWidget    *table,\n                      gint          x,\n                      gint          y,\n                      const gchar  *caption,\n                      GradientMenu *gm)", "code": "{\n  GtkWidget *label;\n\n  label = gtk_label_new (caption);\n  gtk_misc_set_alignment (GTK_MISC (label), 1.0, 0.5);\n  gtk_widget_show (label);\n\n  gtk_table_attach (GTK_TABLE (table), label,\n                    x    , x + 1, y, y + 1,\n                    GTK_FILL, 0, 0, 0);\n  gtk_table_attach (GTK_TABLE (table), gm->preview,\n                    x + 1, x + 2, y, y + 1,\n                    0, 0, 0, 0);\n  gtk_table_attach (GTK_TABLE (table), gm->combo,\n                    x + 2, x + 3, y, y + 1,\n                    0, 0, 0, 0);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n    Routines to render the preview in background\n */\n", "func_signal": "static Preview *\npreview_new (gint                  width,\n             gint                  height,\n             PreviewInitFunc       init_func,\n             gpointer              init_data,\n             PreviewRenderFunc     render_func,\n             gpointer              render_data,\n             PreviewDeinitFunc     deinit_func,\n             gpointer              deinit_data)", "code": "{\n  Preview *preview;\n\n  preview = g_new0 (Preview, 1);\n\n  preview->widget = gimp_preview_area_new ();\n  gtk_widget_set_size_request (preview->widget, width, height);\n  gtk_widget_show (preview->widget);\n\n  preview->width           = width;\n  preview->height          = height;\n  preview->init_func       = init_func;\n  preview->init_data       = init_data;\n  preview->render_func     = render_func;\n  preview->render_data     = render_data;\n  preview->deinit_func     = deinit_func;\n  preview->deinit_data     = deinit_data;\n  preview->idle_tag        = 0;\n  preview->buffer          = g_new (guchar, width * 3);\n  preview->full_image_buffer = g_new (guchar, width * height * 3);\n\n  return preview;\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n * Load all gflares, which are founded in gflare-path-list, into gflares_list.\n */\n", "func_signal": "static void\ngflares_list_load_one (const GimpDatafileData *file_data,\n                       gpointer                user_data)", "code": "{\n  GFlare *gflare;\n\n  gflare = gflare_load (file_data->filename, file_data->basename);\n\n  if (gflare)\n    gflares_list_insert (gflare);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  Start rendering of the preview in background using an idle event.\n  If already started and not yet finished, stop it first.\n */\n", "func_signal": "static void\npreview_render_start (Preview *preview)", "code": "{\n  preview_render_end (preview);\n\n  preview->init_done = FALSE;\n  preview->current_y = 0;\n  preview->drawn_y = 0;\n  preview->timeout_tag = g_timeout_add (100,\n                                        (GSourceFunc) preview_render_start_2,\n                                        preview);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n *  Calc glow's pixel (RGBA) value\n *  INPUT:\n *      gdouble x, y                    image coordinates\n *  OUTPUT:\n *      guchar  pix[4]\n */\n", "func_signal": "static void\ncalc_glow_pix (guchar *dest_pix, gdouble x, gdouble y)", "code": "{\n  gdouble radius, angle;\n  gdouble angular_size;\n  guchar  radial_pix[4], angular_pix[4], size_pix[4];\n  gint    i;\n\n  if ((calc.type & CALC_GLOW) == 0\n      || x < calc.glow_bounds.x0 || x > calc.glow_bounds.x1\n      || y < calc.glow_bounds.y0 || y > calc.glow_bounds.y1)\n    {\n      memset (dest_pix, 0, 4);\n      return;\n    }\n\n  x -= calc.xcenter;\n  y -= calc.ycenter;\n  radius = sqrt (x*x + y*y) / calc.glow_radius;\n  angle = (atan2 (-y, x) + calc.glow_rotation ) / (2 * G_PI);\n  angle = fmod_positive (angle, 1.0);\n\n  calc_get_gradient (size_pix, calc.glow_angular_size, angle);\n  /* angular_size gradient was grayfied already */\n  angular_size = size_pix[0] / 255.0;\n  radius /= (angular_size+0.0001);      /* in case angular_size == 0.0 */\n  if (radius < 0 || radius > 1)\n    {\n      memset (dest_pix, 0, 4);\n      return;\n    }\n\n  calc_get_gradient (radial_pix, calc.glow_radial, radius);\n  calc_get_gradient (angular_pix, calc.glow_angular, angle);\n\n  for (i = 0; i < 4; i++)\n    dest_pix[i] = radial_pix[i] * angular_pix[i] / 255;\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n    Manage both internal and external gradients: list up, cache,\n    sampling, etc.\n\n    External gradients are cached.\n */\n", "func_signal": "static void\ngradient_name_copy (gchar       *dest,\n                    const gchar *src)", "code": "{\n  strncpy (dest, src, GRADIENT_NAME_MAX);\n  dest[GRADIENT_NAME_MAX-1] = '\\0';\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*      preview callbacks       */\n", "func_signal": "static gint\ndlg_preview_init_func (Preview *preview, gpointer data)", "code": "{\n  /* call init_params first, and iterate init_progress while\n     it returns true */\n  if (dlg->init_params_done == FALSE)\n    {\n      calc_init_params (dlg->gflare,\n                        CALC_GLOW | CALC_RAYS | CALC_SFLARE,\n                        pvals.xcenter, pvals.ycenter,\n                        pvals.radius, pvals.rotation, pvals.hue,\n                        pvals.vangle, pvals.vlength);\n      dlg->init_params_done = TRUE;\n      return TRUE;\n    }\n  return calc_init_progress ();\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n   Store samples of gradient into an array\n   this routine is called during Calc initialization\n   this code is very messy... :( */\n", "func_signal": "static int\ncalc_sample_one_gradient (void)", "code": "{\n  static struct\n  {\n    guchar **values;\n    gint     name_offset;\n    gint     hue_offset;\n    gint     gray;\n  } table[] = {\n    {\n      &calc.glow_radial,\n      G_STRUCT_OFFSET (GFlare, glow_radial),\n      G_STRUCT_OFFSET (GFlare, glow_hue),\n      FALSE\n    },\n    {\n      &calc.glow_angular,\n      G_STRUCT_OFFSET (GFlare, glow_angular),\n      0,\n      FALSE\n    },\n    {\n      &calc.glow_angular_size,\n      G_STRUCT_OFFSET (GFlare, glow_angular_size),\n      0,\n      TRUE\n    },\n    {\n      &calc.rays_radial,\n      G_STRUCT_OFFSET (GFlare, rays_radial),\n      G_STRUCT_OFFSET (GFlare, rays_hue),\n      FALSE\n    },\n    {\n      &calc.rays_angular,\n      G_STRUCT_OFFSET (GFlare, rays_angular),\n      0,\n      FALSE\n    },\n    {\n      &calc.rays_angular_size,\n      G_STRUCT_OFFSET (GFlare, rays_angular_size),\n      0,\n      TRUE\n    },\n    {\n      &calc.sflare_radial,\n      G_STRUCT_OFFSET (GFlare, sflare_radial),\n      G_STRUCT_OFFSET (GFlare, sflare_hue),\n      FALSE\n    },\n    {\n      &calc.sflare_sizefac,\n      G_STRUCT_OFFSET (GFlare, sflare_sizefac),\n      0,\n      TRUE\n    },\n    {\n      &calc.sflare_probability,\n      G_STRUCT_OFFSET (GFlare, sflare_probability),\n      0,\n      TRUE\n    }\n  };\n  GFlare        *gflare = calc.gflare;\n  GradientName  *grad_name;\n  guchar        *gradient;\n  gdouble       hue_deg;\n  gint          i, j, hue;\n\n  for (i = 0; i < G_N_ELEMENTS (table); i++)\n    {\n      if (*(table[i].values) == NULL)\n        {\n          /* @GRADIENT_NAME */\n          grad_name = (GradientName *) ((char*) gflare + table[i].name_offset);\n          gradient = *(table[i].values) = g_new (guchar, 4 * GRADIENT_RESOLUTION);\n          gradient_get_values (*grad_name, gradient, GRADIENT_RESOLUTION);\n\n          /*\n           * Do hue rotation, if needed\n           */\n\n          if (table[i].hue_offset != 0)\n            {\n              hue_deg = calc.hue + *(gdouble *) ((char*) gflare + table[i].hue_offset);\n              hue = (gint) (hue_deg / 360.0 * 256.0) % 256;\n              if (hue < 0)\n                hue += 256;\n              g_assert (0 <= hue && hue < 256);\n\n              if (hue > 0)\n                {\n                  for (j = 0; j < GRADIENT_RESOLUTION; j++)\n                    {\n                      gint      r, g, b;\n\n                      r = gradient[j*4];\n                      g = gradient[j*4+1];\n                      b = gradient[j*4+2];\n\n                      gimp_rgb_to_hsv_int (&r, &g, &b);\n                      r = (r + hue) % 256;\n                      gimp_hsv_to_rgb_int (&r, &g, &b);\n\n                      gradient[j*4] = r;\n                      gradient[j*4+1] = g;\n                      gradient[j*4+2] = b;\n                    }\n                }\n            }\n\n          /*\n           *    Grayfy gradient, if needed\n           */\n\n          if (table[i].gray)\n            {\n              for (j = 0; j < GRADIENT_RESOLUTION; j++)\n                /* the first byte is enough */\n                gradient[j*4] = LUMINOSITY ((gradient + j*4));\n\n            }\n\n          /* sampling of one gradient is done */\n          return TRUE;\n        }\n    }\n  return FALSE;\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  Adaptive supersampling callback functions\n\n  These routines may look messy, since adaptive supersampling needs\n  pixel values in `double' (from 0.0 to 1.0) but calc_*_pix () returns\n  guchar values. */\n", "func_signal": "static void\nplugin_render_func (gdouble   x,\n                    gdouble   y,\n                    GimpRGB  *color,\n                    gpointer  data)", "code": "{\n  guchar        src_pix[4];\n  guchar        flare_pix[4];\n  guchar        src[4];\n  gint          b;\n  gint          ix, iy;\n\n  /* translate (0.5, 0.5) before convert to `int' so that it can surely\n     point the center of pixel */\n  ix = floor (x + 0.5);\n  iy = floor (y + 0.5);\n\n  gimp_pixel_fetcher_get_pixel (tk_read, ix, iy, src);\n\n  for (b = 0; b < 3; b++)\n    src_pix[b] = dinfo.is_color ? src[b] : src[0];\n  src_pix[3] = dinfo.has_alpha ? src[drawable->bpp - 1] : OPAQUE;\n\n  calc_gflare_pix (flare_pix, x, y, src_pix);\n\n  color->r = flare_pix[0] / 255.0;\n  color->g = flare_pix[1] / 255.0;\n  color->b = flare_pix[2] / 255.0;\n  color->a = flare_pix[3] / 255.0;\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  Caching gradients is really needed. It really takes 0.2 seconds each\n  time to resample an external gradient. (And this plug-in has\n  currently 6 gradient menus.)\n\n  However, this caching routine is not too good. It picks up just\n  GRADIENT_RESOLUTION samples everytime, and rescales it later.  And\n  cached values are stored in guchar array. No accuracy.\n */\n", "func_signal": "static void\ngradient_get_values_external (const gchar *gradient_name,\n                              guchar      *values,\n                              gint         nvalues)", "code": "{\n  GradientCacheItem *ci;\n  gboolean           found;\n#ifdef DEBUG\n  clock_t            clk = clock ();\n#endif\n\n  g_return_if_fail (nvalues >= 2);\n\n  ci = gradient_cache_lookup (gradient_name, &found);\n  if (!found)\n    {\n      /* FIXME: \"reverse\" hardcoded to FALSE. */\n      gradient_get_values_real_external (gradient_name, ci->values,\n                                         GRADIENT_RESOLUTION, FALSE);\n    }\n  if (nvalues == GRADIENT_RESOLUTION)\n    {\n      memcpy (values, ci->values, 4 * GRADIENT_RESOLUTION);\n    }\n  else\n    {\n      double    pos, frac;\n      int       ipos;\n      int       i, j;\n\n      for (i = 0; i < nvalues; i++)\n        {\n          pos = ((double) i / (nvalues - 1)) * (GRADIENT_RESOLUTION - 1);\n          g_assert (0 <= pos && pos <= GRADIENT_RESOLUTION - 1);\n          ipos = (int) pos; frac = pos - ipos;\n          if (frac == 0.0)\n            {\n              memcpy (&values[4 * i], &ci->values[4 * ipos], 4);\n            }\n          else\n            for (j = 0; j < 4; j++)\n              values[4 * i + j] = ci->values[4 * ipos + j] * (1 - frac)\n                                + ci->values[4 * (ipos + 1) + j] * frac;\n        }\n    }\n\n#ifdef DEBUG\n  get_values_external_clock += clock () - clk;\n  get_values_external_count ++;\n#endif\n\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n        This is gflare editor dilaog, one which opens by clicking\n        \"Edit\" button on the selector page in the main dialog.\n */\n", "func_signal": "static void\ned_run (GtkWindow            *parent,\n        GFlare               *target_gflare,\n        GFlareEditorCallback  callback,\n        gpointer              calldata)", "code": "{\n  GtkWidget *shell;\n  GtkWidget *hbox;\n  GtkWidget *frame;\n  GtkWidget *abox;\n  GtkWidget *notebook;\n\n  if (!ed)\n    ed = g_new0 (GFlareEditor, 1);\n  ed->init          = TRUE;\n  ed->run           = FALSE;\n  ed->target_gflare = target_gflare;\n  ed->gflare        = gflare_dup (target_gflare, target_gflare->name);\n  ed->callback      = callback;\n  ed->calldata      = calldata;\n\n  /*\n   *    Dialog Shell\n   */\n  ed->shell =\n    shell = gimp_dialog_new (_(\"Gradient Flare Editor\"), PLUG_IN_ROLE,\n                             GTK_WIDGET (parent), 0,\n                             gimp_standard_help_func, PLUG_IN_PROC,\n\n                             _(\"Rescan Gradients\"), RESPONSE_RESCAN,\n                             GTK_STOCK_CANCEL,      GTK_RESPONSE_CANCEL,\n                             GTK_STOCK_OK,          GTK_RESPONSE_OK,\n\n                             NULL);\n\n  gtk_dialog_set_alternative_button_order (GTK_DIALOG (shell),\n                                           RESPONSE_RESCAN,\n                                           GTK_RESPONSE_OK,\n                                           GTK_RESPONSE_CANCEL,\n                                           -1);\n\n  g_signal_connect (shell, \"response\",\n                    G_CALLBACK (ed_response),\n                    ed);\n  g_signal_connect (shell, \"destroy\",\n                    G_CALLBACK (ed_destroy_callback),\n                    ed);\n\n  /*\n   *    main hbox\n   */\n\n  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);\n  gtk_container_set_border_width (GTK_CONTAINER (hbox), 12);\n  gtk_box_pack_start (GTK_BOX (gtk_dialog_get_content_area (GTK_DIALOG (shell))),\n                      hbox, FALSE, FALSE, 0);\n  gtk_widget_show (hbox);\n\n  /*\n   *    Preview\n   */\n\n  abox = gtk_alignment_new (0.0, 0.0, 0.0, 0.0);\n  gtk_box_pack_start (GTK_BOX (hbox), abox, FALSE, FALSE, 0);\n  gtk_widget_show (abox);\n\n  frame = gtk_frame_new (NULL);\n  gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);\n  gtk_container_add (GTK_CONTAINER (abox), frame);\n  gtk_widget_show (frame);\n\n  ed->preview = preview_new (ED_PREVIEW_WIDTH, ED_PREVIEW_HEIGHT,\n                             ed_preview_init_func, NULL,\n                             ed_preview_render_func, NULL,\n                             ed_preview_deinit_func, NULL);\n  gtk_widget_set_events (GTK_WIDGET (ed->preview->widget), DLG_PREVIEW_MASK);\n  gtk_container_add (GTK_CONTAINER (frame), ed->preview->widget);\n  g_signal_connect (ed->preview->widget, \"event\",\n                    G_CALLBACK (dlg_preview_handle_event),\n                    NULL);\n  ed_preview_calc_window ();\n\n  /*\n   *    Notebook\n   */\n  notebook = ed->notebook = gtk_notebook_new ();\n  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_TOP);\n  gtk_box_pack_start (GTK_BOX (hbox), notebook, TRUE, TRUE, 0);\n  gtk_widget_show (notebook);\n\n  ed_make_page_general (ed, notebook);\n  ed_make_page_glow (ed, notebook);\n  ed_make_page_rays (ed, notebook);\n  ed_make_page_sflare (ed, notebook);\n\n  gtk_widget_show (shell);\n\n  ed->init = FALSE;\n  ed_preview_update ();\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*************************************************************************/\n/**                                                                     **/\n/**                     +++ Gradient Menu                               **/\n/**                     +++ gm                                          **/\n/**                                                                     **/\n/*************************************************************************/\n", "func_signal": "static void\ngradient_menu_init (void)", "code": "{\n  gm_gradient_get_list ();\n  gradient_menus = NULL;\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n  NOTE: This is hack, because this code depends on internal \"map\"\n  signal of changing pages of gtknotebook.\n */\n", "func_signal": "static void\ned_page_map_callback (GtkWidget *widget,\n                      gpointer   data)", "code": "{\n  gint page_num = GPOINTER_TO_INT (data);\n\n  DEBUG_PRINT((\"ed_page_map_callback\\n\"));\n\n  ed->cur_page = page_num;\n  ed_preview_update ();\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*************************************************************************/\n/**                                                                     **/\n/**             +++ Plug-in Interfaces                                  **/\n/**                                                                     **/\n/*************************************************************************/\n", "func_signal": "MAIN ()\n\nvoid\nplugin_query (void)", "code": "{\n  static const GimpParamDef args[]=\n  {\n    { GIMP_PDB_INT32,    \"run-mode\", \"The run mode { RUN-INTERACTIVE (0), RUN-NONINTERACTIVE (1) }\" },\n    { GIMP_PDB_IMAGE,    \"image\",    \"Input image (unused)\" },\n    { GIMP_PDB_DRAWABLE, \"drawable\", \"Input drawable\" },\n    { GIMP_PDB_STRING,   \"gflare-name\", \"The name of GFlare\" },\n    { GIMP_PDB_INT32,    \"xcenter\",  \"X coordinate of center of GFlare\" },\n    { GIMP_PDB_INT32,    \"ycenter\",  \"Y coordinate of center of GFlare\" },\n    { GIMP_PDB_FLOAT,    \"radius\",   \"Radius of GFlare (pixel)\" },\n    { GIMP_PDB_FLOAT,    \"rotation\", \"Rotation of GFlare (degree)\" },\n    { GIMP_PDB_FLOAT,    \"hue\",      \"Hue rotation of GFlare (degree)\" },\n    { GIMP_PDB_FLOAT,    \"vangle\",   \"Vector angle for second flares (degree)\" },\n    { GIMP_PDB_FLOAT,    \"vlength\",  \"Vector length for second flares (percentage to Radius)\" },\n    { GIMP_PDB_INT32,    \"use-asupsample\", \"Whether it uses or not adaptive supersampling while rendering (boolean)\" },\n    { GIMP_PDB_INT32,    \"asupsample-max-depth\", \"Max depth for adaptive supersampling\"},\n    { GIMP_PDB_FLOAT,    \"asupsample-threshold\", \"Threshold for adaptive supersampling\"}\n  };\n\n  const gchar *help_string =\n    \"This plug-in produces a lense flare effect using custom gradients. \"\n    \"In interactive call, the user can edit his/her own favorite lense flare \"\n    \"(GFlare) and render it. Edited gflare is saved automatically to \"\n    \"the folder in gflare-path, if it is defined in gimprc. \"\n    \"In non-interactive call, the user can only render one of GFlare \"\n    \"which has been stored in gflare-path already.\";\n\n  gimp_install_procedure (PLUG_IN_PROC,\n                          N_(\"Produce a lense flare effect using gradients\"),\n                          help_string,\n                          \"Eiichi Takamori\",\n                          \"Eiichi Takamori, and a lot of GIMP people\",\n                          \"1997\",\n                          N_(\"_Gradient Flare...\"),\n                          \"RGB*, GRAY*\",\n                          GIMP_PLUGIN,\n                          G_N_ELEMENTS (args), 0,\n                          args, NULL);\n\n  gimp_plugin_menu_register (PLUG_IN_PROC,\n                             \"<Image>/Filters/Light and Shadow/Light\");\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n *  \"Edit\" button in Selector page\n */\n", "func_signal": "static void\ndlg_selector_edit_callback (GtkWidget *widget,\n                            gpointer   data)", "code": "{\n  preview_render_end (dlg->preview);\n  gtk_widget_set_sensitive (dlg->shell, FALSE);\n  ed_run (GTK_WINDOW (dlg->shell),\n          dlg->gflare, dlg_selector_edit_done_callback, NULL);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*\n *  \"Copy\" button in Selector page\n */\n", "func_signal": "static void\ndlg_selector_copy_callback (GtkWidget *widget,\n                            gpointer   data)", "code": "{\n  GtkWidget *query_box;\n  gchar     *name;\n\n  name = g_strdup_printf (\"%s copy\", dlg->gflare->name);\n\n  query_box = gimp_query_string_box (_(\"Copy Gradient Flare\"),\n                                     gtk_widget_get_toplevel (widget),\n                                     gimp_standard_help_func, PLUG_IN_PROC,\n                                     _(\"Enter a name for the copied GFlare\"),\n                                     name,\n                                     NULL, NULL,\n                                     dlg_selector_copy_ok_callback, dlg);\n  g_free (name);\n\n  gtk_widget_show (query_box);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/*****************************************/\n/**     Main Dialog / Settings Page     **/\n/*****************************************/\n", "func_signal": "static void\ndlg_make_page_settings (GFlareDialog *dlg,\n                        GtkWidget    *notebook)", "code": "{\n  GtkWidget *main_vbox;\n  GtkWidget *frame;\n  GtkWidget *center;\n  GtkWidget *chain;\n  GtkWidget *table;\n  GtkWidget *button;\n  GtkWidget *asup_table;\n  GtkObject *adj;\n  gdouble    xres, yres;\n  gint       row;\n\n  main_vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);\n  gtk_container_set_border_width (GTK_CONTAINER (main_vbox), 12);\n\n  frame = gimp_frame_new (_(\"Center\"));\n  gtk_box_pack_start (GTK_BOX (main_vbox), frame, FALSE, FALSE, 0);\n  gtk_widget_show (frame);\n\n  gimp_image_get_resolution (image_ID, &xres, &yres);\n\n  center = dlg->sizeentry =\n    gimp_coordinates_new (gimp_image_get_unit (image_ID), \"%a\",\n                          TRUE, TRUE, 75, GIMP_SIZE_ENTRY_UPDATE_SIZE,\n\n                          FALSE, FALSE,\n\n                          _(\"_X:\"), pvals.xcenter, xres,\n                          -GIMP_MAX_IMAGE_SIZE, GIMP_MAX_IMAGE_SIZE,\n                          0, gimp_drawable_width (drawable->drawable_id),\n\n                          _(\"_Y:\"), pvals.ycenter, yres,\n                          -GIMP_MAX_IMAGE_SIZE, GIMP_MAX_IMAGE_SIZE,\n                          0, gimp_drawable_height (drawable->drawable_id));\n\n  chain = GTK_WIDGET (GIMP_COORDINATES_CHAINBUTTON (center));\n\n  gtk_container_add (GTK_CONTAINER (frame), center);\n  g_signal_connect (center, \"value-changed\",\n                    G_CALLBACK (dlg_position_entry_callback),\n                    NULL);\n  g_signal_connect (center, \"refval-changed\",\n                    G_CALLBACK (dlg_position_entry_callback),\n                    NULL);\n  gtk_widget_hide (chain);\n  gtk_widget_show (center);\n\n  frame = gimp_frame_new (_(\"Parameters\"));\n  gtk_box_pack_start (GTK_BOX (main_vbox), frame, FALSE, FALSE, 0);\n  gtk_widget_show (frame);\n\n  table = gtk_table_new (5, 3, FALSE);\n  gtk_table_set_row_spacings (GTK_TABLE (table), 6);\n  gtk_table_set_col_spacings (GTK_TABLE (table), 6);\n  gtk_container_add (GTK_CONTAINER (frame), table);\n  gtk_widget_show (table);\n\n  row = 0;\n\n  adj = gimp_scale_entry_new (GTK_TABLE (table), 0, row++,\n                              _(\"_Radius:\"), SCALE_WIDTH, 6,\n                              pvals.radius, 0.0, drawable->width / 2,\n                              1.0, 10.0, 1,\n                              FALSE, 0.0, GIMP_MAX_IMAGE_SIZE,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.radius);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (dlg_preview_update),\n                    NULL);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (table), 0, row++,\n                              _(\"Ro_tation:\"), SCALE_WIDTH, 6,\n                              pvals.rotation, -180.0, 180.0, 1.0, 15.0, 1,\n                              TRUE, 0, 0,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.rotation);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (dlg_preview_update),\n                    NULL);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (table), 0, row++,\n                              _(\"_Hue rotation:\"), SCALE_WIDTH, 6,\n                              pvals.hue, -180.0, 180.0, 1.0, 15.0, 1,\n                              TRUE, 0, 0,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.hue);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (dlg_preview_update),\n                    NULL);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (table), 0, row++,\n                              _(\"Vector _angle:\"), SCALE_WIDTH, 6,\n                              pvals.vangle, 0.0, 359.0, 1.0, 15.0, 1,\n                              TRUE, 0, 0,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.vangle);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (dlg_preview_update),\n                    NULL);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (table), 0, row++,\n                              _(\"Vector _length:\"), SCALE_WIDTH, 6,\n                              pvals.vlength, 1, 1000, 1.0, 10.0, 1,\n                              FALSE, 1, GIMP_MAX_IMAGE_SIZE,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.vlength);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (dlg_preview_update),\n                    NULL);\n\n  /**\n  ***   Asupsample settings\n  ***   This code is stolen from gimp-0.99.x/app/blend.c\n  **/\n\n  /*  asupsample frame */\n  frame = dlg->asupsample_frame = gimp_frame_new (NULL);\n  gtk_box_pack_start (GTK_BOX (main_vbox), frame, FALSE, FALSE, 0);\n  gtk_widget_show (frame);\n\n  button = gtk_check_button_new_with_mnemonic (_(\"A_daptive supersampling\"));\n  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button),\n                                pvals.use_asupsample);\n  gtk_frame_set_label_widget (GTK_FRAME (frame), button);\n  gtk_widget_show (button);\n\n  asup_table = gtk_table_new (2, 3, FALSE);\n  gtk_table_set_col_spacings (GTK_TABLE (asup_table), 6);\n  gtk_table_set_row_spacings (GTK_TABLE (asup_table), 6);\n  gtk_container_add (GTK_CONTAINER (frame), asup_table);\n  gtk_widget_show (asup_table);\n\n  g_signal_connect (button, \"toggled\",\n                    G_CALLBACK (gimp_toggle_button_update),\n                    &pvals.use_asupsample);\n\n  g_object_bind_property (button,     \"active\",\n                          asup_table, \"sensitive\",\n                          G_BINDING_SYNC_CREATE);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (asup_table), 0, 0,\n                              _(\"_Max depth:\"), -1, 4,\n                              pvals.asupsample_max_depth,\n                              1.0, 10.0, 1.0, 1.0, 0,\n                              TRUE, 0.0, 0.0,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_int_adjustment_update),\n                    &pvals.asupsample_max_depth);\n\n  adj = gimp_scale_entry_new (GTK_TABLE (asup_table), 0, 1,\n                              _(\"_Threshold\"), -1, 4,\n                              pvals.asupsample_threshold,\n                              0.0, 4.0, 0.01, 0.01, 2,\n                              TRUE, 0.0, 0.0,\n                              NULL, NULL);\n  g_signal_connect (adj, \"value-changed\",\n                    G_CALLBACK (gimp_double_adjustment_update),\n                    &pvals.asupsample_threshold);\n\n  gtk_notebook_append_page (GTK_NOTEBOOK (notebook), main_vbox,\n                            gtk_label_new_with_mnemonic (_(\"_Settings\")));\n  gtk_widget_show (main_vbox);\n}", "path": "gradient-flare\\gradient-flare.c", "repo_name": "MichaelMure/gimp-plugins", "stars": 19, "license": "None", "language": "c", "size": 21400}
{"docstring": "/**\n * mux_startup - Initialize the port.\n * @port: Ptr to the uart_port.\n *\n * Grab any resources needed for this port and start the\n * mux timer.\n */\n", "func_signal": "static int mux_startup(struct uart_port *port)", "code": "{\n\tmux_ports[port->line].enabled = 1;\n\treturn 0;\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * Read from PCI config space\n */\n", "func_signal": "static void crp_read(u32 ad_cbe, u32 *data)", "code": "{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ixp4xx_pci_lock, flags);\n\t*PCI_CRP_AD_CBE = ad_cbe;\n\t*data = *PCI_CRP_RDATA;\n\tspin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_read - Read chars from the mux fifo.\n * @port: Ptr to the uart_port.\n *\n * This reads all available data from the mux's fifo and pushes\n * the data to the tty layer.\n */\n", "func_signal": "static void mux_read(struct uart_port *port)", "code": "{\n\tint data;\n\tstruct tty_struct *tty = port->state->port.tty;\n\t__u32 start_count = port->icount.rx;\n\n\twhile(1) {\n\t\tdata = __raw_readl(port->membase + IO_DATA_REG_OFFSET);\n\n\t\tif (MUX_STATUS(data))\n\t\t\tcontinue;\n\n\t\tif (MUX_EOFIFO(data))\n\t\t\tbreak;\n\n\t\tport->icount.rx++;\n\n\t\tif (MUX_BREAK(data)) {\n\t\t\tport->icount.brk++;\n\t\t\tif(uart_handle_break(port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (uart_handle_sysrq_char(port, data & 0xffu))\n\t\t\tcontinue;\n\n\t\ttty_insert_flip_char(tty, data & 0xFF, TTY_NORMAL);\n\t}\n\t\n\tif (start_count != port->icount.rx) {\n\t\ttty_flip_buffer_push(tty);\n\t}\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_init - Serial MUX initialization procedure.\n *\n * Register the Serial MUX driver.\n */\n", "func_signal": "static int __init mux_init(void)", "code": "{\n\tregister_parisc_driver(&builtin_serial_mux_driver);\n\tregister_parisc_driver(&serial_mux_driver);\n\n\tif(port_cnt > 0) {\n\t\t/* Start the Mux timer */\n\t\tinit_timer(&mux_timer);\n\t\tmux_timer.function = mux_poll;\n\t\tmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\n\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\n\t        register_console(&mux_console);\n#endif\n\t}\n\n\treturn 0;\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * PCI abort handler\n */\n", "func_signal": "static int abort_handler(unsigned long addr, unsigned int fsr, struct pt_regs *regs)", "code": "{\n\tu32 isr, status;\n\n\tisr = *PCI_ISR;\n\tlocal_read_config(PCI_STATUS, 2, &status);\n\tpr_debug(\"PCI: abort_handler addr = %#lx, isr = %#x, \"\n\t\t\"status = %#x\\n\", addr, isr, status);\n\n\t/* make sure the Master Abort bit is reset */    \n\t*PCI_ISR = PCI_ISR_PFE;\n\tstatus |= PCI_STATUS_REC_MASTER_ABORT;\n\tlocal_write_config(PCI_STATUS, 2, status);\n\n\t/*\n\t * If it was an imprecise abort, then we need to correct the\n\t * return address to be _after_ the instruction.\n\t */\n\tif (fsr & (1 << 10))\n\t\tregs->ARM_pc += 4;\n\n\treturn 0;\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*  0  */\n", "func_signal": "void\nbefs_dump_index_entry(const struct super_block *sb, befs_disk_btree_super * super)", "code": "{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_debug(sb, \"Btree super structure\");\n\tbefs_debug(sb, \"  magic %08x\", fs32_to_cpu(sb, super->magic));\n\tbefs_debug(sb, \"  node_size %u\", fs32_to_cpu(sb, super->node_size));\n\tbefs_debug(sb, \"  max_depth %08x\", fs32_to_cpu(sb, super->max_depth));\n\n\tbefs_debug(sb, \"  data_type %08x\", fs32_to_cpu(sb, super->data_type));\n\tbefs_debug(sb, \"  root_node_pointer %016LX\",\n\t\t   fs64_to_cpu(sb, super->root_node_ptr));\n\tbefs_debug(sb, \"  free_node_pointer %016LX\",\n\t\t   fs64_to_cpu(sb, super->free_node_ptr));\n\tbefs_debug(sb, \"  maximum size %016LX\",\n\t\t   fs64_to_cpu(sb, super->max_size));\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}", "path": "fs\\befs\\debug.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * Only first 64MB of memory can be accessed via PCI.\n * We use GFP_DMA to allocate safe buffers to do map/unmap.\n * This is really ugly and we need a better way of specifying\n * DMA-capable regions of memory.\n */\n", "func_signal": "void __init ixp4xx_adjust_zones(int node, unsigned long *zone_size,\n\tunsigned long *zhole_size)", "code": "{\n\tunsigned int sz = SZ_64M >> PAGE_SHIFT;\n\n\t/*\n\t * Only adjust if > 64M on current system\n\t */\n\tif (node || (zone_size[0] <= sz))\n\t\treturn;\n\n\tzone_size[1] = zone_size[0] - sz;\n\tzone_size[0] = sz;\n\tzhole_size[1] = zhole_size[0];\n\tzhole_size[0] = 0;\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*****************************************************************/\n", "func_signal": "u32 initialize_cx231xx(struct cx231xx *dev)", "code": "{\n\tu32 config_info = 0;\n\tstruct pcb_config *p_pcb_info;\n\tu8 usb_speed = 1;\t/* from register,1--HS, 0--FS  */\n\tu8 data[4] = { 0, 0, 0, 0 };\n\tu32 ts1_source = 0;\n\tu32 ts2_source = 0;\n\tu32 analog_source = 0;\n\tu8 _current_scenario_idx = 0xff;\n\n\tts1_source = SOURCE_TS_BDA;\n\tts2_source = SOURCE_TS_BDA;\n\n\t/* read board config register to find out which\n\tpcb config it is related to */\n\tcx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, BOARD_CFG_STAT, data, 4);\n\n\tconfig_info = *((u32 *) data);\n\tusb_speed = (u8) (config_info & 0x1);\n\n\t/* Verify this device belongs to Bus power or Self power device */\n\tif (config_info & BUS_POWER) {\t/* bus-power */\n\t\tswitch (config_info & BUSPOWER_MASK) {\n\t\tcase TS1_PORT | BUS_POWER:\n\t\t\tcx231xx_Scenario[INDEX_BUSPOWER_DIGITAL_ONLY].speed =\n\t\t\t    usb_speed;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_BUSPOWER_DIGITAL_ONLY];\n\t\t\t_current_scenario_idx = INDEX_BUSPOWER_DIGITAL_ONLY;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | BUS_POWER:\n\t\t\tcx231xx_Scenario[INDEX_BUSPOWER_ANALOG_ONLY].speed =\n\t\t\t    usb_speed;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_BUSPOWER_ANALOG_ONLY];\n\t\t\t_current_scenario_idx = INDEX_BUSPOWER_ANALOG_ONLY;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | BUS_POWER | TS1_PORT:\n\t\t\tcx231xx_Scenario[INDEX_BUSPOWER_DIF_ONLY].speed =\n\t\t\t    usb_speed;\n\t\t\tp_pcb_info = &cx231xx_Scenario[INDEX_BUSPOWER_DIF_ONLY];\n\t\t\t_current_scenario_idx = INDEX_BUSPOWER_DIF_ONLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcx231xx_info(\"bad config in buspower!!!!\\n\");\n\t\t\tcx231xx_info(\"config_info=%x\\n\",\n\t\t\t\t     (config_info & BUSPOWER_MASK));\n\t\t\treturn 1;\n\t\t}\n\t} else {\t\t/* self-power */\n\n\t\tswitch (config_info & SELFPOWER_MASK) {\n\t\tcase TS1_PORT | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DIGITAL_ONLY].speed =\n\t\t\t    usb_speed;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_SELFPOWER_DIGITAL_ONLY];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_DIGITAL_ONLY;\n\t\t\tbreak;\n\t\tcase TS1_TS2_PORT | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DUAL_DIGITAL].speed =\n\t\t\t    usb_speed;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DUAL_DIGITAL].\n\t\t\t    ts2_source = ts2_source;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_SELFPOWER_DUAL_DIGITAL];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_DUAL_DIGITAL;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_ANALOG_ONLY].speed =\n\t\t\t    usb_speed;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_ANALOG_ONLY].\n\t\t\t    analog_source = analog_source;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_SELFPOWER_ANALOG_ONLY];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_ANALOG_ONLY;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | TS1_PORT | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DUAL].speed =\n\t\t\t    usb_speed;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DUAL].ts1_source =\n\t\t\t    ts1_source;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_DUAL].analog_source =\n\t\t\t    analog_source;\n\t\t\tp_pcb_info = &cx231xx_Scenario[INDEX_SELFPOWER_DUAL];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_DUAL;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | TS1_TS2_PORT | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_TRIPLE].speed =\n\t\t\t    usb_speed;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_TRIPLE].ts1_source =\n\t\t\t    ts1_source;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_TRIPLE].ts2_source =\n\t\t\t    ts2_source;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_TRIPLE].analog_source =\n\t\t\t    analog_source;\n\t\t\tp_pcb_info = &cx231xx_Scenario[INDEX_SELFPOWER_TRIPLE];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_TRIPLE;\n\t\t\tbreak;\n\t\tcase AVDEC_ENABLE | TS1VIP_TS2_PORT | SELF_POWER:\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_COMPRESSOR].speed =\n\t\t\t    usb_speed;\n\t\t\tcx231xx_Scenario[INDEX_SELFPOWER_COMPRESSOR].\n\t\t\t    analog_source = analog_source;\n\t\t\tp_pcb_info =\n\t\t\t    &cx231xx_Scenario[INDEX_SELFPOWER_COMPRESSOR];\n\t\t\t_current_scenario_idx = INDEX_SELFPOWER_COMPRESSOR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcx231xx_info(\"bad senario!!!!!\\n\");\n\t\t\tcx231xx_info(\"config_info=%x\\n\",\n\t\t\t\t     (config_info & SELFPOWER_MASK));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tdev->current_scenario_idx = _current_scenario_idx;\n\n\tmemcpy(&dev->current_pcb_config, p_pcb_info,\n\t\t   sizeof(struct pcb_config));\n\n\tif (pcb_debug) {\n\t\tcx231xx_info(\"SC(0x00) register = 0x%x\\n\", config_info);\n\t\tcx231xx_info(\"scenario %d\\n\",\n\t\t\t    (dev->current_pcb_config.index) + 1);\n\t\tcx231xx_info(\"type=%x\\n\", dev->current_pcb_config.type);\n\t\tcx231xx_info(\"mode=%x\\n\", dev->current_pcb_config.mode);\n\t\tcx231xx_info(\"speed=%x\\n\", dev->current_pcb_config.speed);\n\t\tcx231xx_info(\"ts1_source=%x\\n\",\n\t\t\t     dev->current_pcb_config.ts1_source);\n\t\tcx231xx_info(\"ts2_source=%x\\n\",\n\t\t\t     dev->current_pcb_config.ts2_source);\n\t\tcx231xx_info(\"analog_source=%x\\n\",\n\t\t\t     dev->current_pcb_config.analog_source);\n\t}\n\n\treturn 0;\n}", "path": "drivers\\media\\video\\cx231xx\\cx231xx-pcb-cfg.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * We override these so we properly do dmabounce otherwise drivers\n * are able to set the dma_mask to 0xffffffff and we can no longer\n * trap bounces. :(\n *\n * We just return true on everyhing except for < 64MB in which case \n * we will fail miseralby and die since we can't handle that case.\n */\n", "func_signal": "int\npci_set_dma_mask(struct pci_dev *dev, u64 mask)", "code": "{\n\tif (mask >= SZ_64M - 1 )\n\t\treturn 0;\n\n\treturn -EIO;\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * Write to PCI config space\n */\n", "func_signal": "static void crp_write(u32 ad_cbe, u32 data)", "code": "{ \n\tunsigned long flags;\n\tspin_lock_irqsave(&ixp4xx_pci_lock, flags);\n\t*PCI_CRP_AD_CBE = CRP_AD_CBE_WRITE | ad_cbe;\n\t*PCI_CRP_WDATA = data;\n\tspin_unlock_irqrestore(&ixp4xx_pci_lock, flags);\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_exit - Serial MUX cleanup procedure.\n *\n * Unregister the Serial MUX driver from the tty layer.\n */\n", "func_signal": "static void __exit mux_exit(void)", "code": "{\n\t/* Delete the Mux timer. */\n\tif(port_cnt > 0) {\n\t\tdel_timer(&mux_timer);\n#ifdef CONFIG_SERIAL_MUX_CONSOLE\n\t\tunregister_console(&mux_console);\n#endif\n\t}\n\n\tunregister_parisc_driver(&builtin_serial_mux_driver);\n\tunregister_parisc_driver(&serial_mux_driver);\n\tuart_unregister_driver(&mux_driver);\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * get_mux_port_count - Get the number of available ports on the Mux.\n * @dev: The parisc device.\n *\n * This function is used to determine the number of ports the Mux\n * supports.  The IODC data reports the number of ports the Mux\n * can support, but there are cases where not all the Mux ports\n * are connected.  This function can override the IODC and\n * return the true port count.\n */\n", "func_signal": "static int __init get_mux_port_count(struct parisc_device *dev)", "code": "{\n\tint status;\n\tu8 iodc_data[32];\n\tunsigned long bytecnt;\n\n\t/* If this is the built-in Mux for the K-Class (Eole CAP/MUX),\n\t * we only need to allocate resources for 1 port since the\n\t * other 7 ports are not connected.\n\t */\n\tif(dev->id.hversion == 0x15)\n\t\treturn 1;\n\n\tstatus = pdc_iodc_read(&bytecnt, dev->hpa.start, 0, iodc_data, 32);\n\tBUG_ON(status != PDC_OK);\n\n\t/* Return the number of ports specified in the iodc data. */\n\treturn ((((iodc_data)[4] & 0xf0) >> 4) * 8) + 8;\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * Setup DMA mask to 64MB on PCI devices. Ignore all other devices.\n */\n", "func_signal": "static int ixp4xx_pci_platform_notify(struct device *dev)", "code": "{\n\tif(dev->bus == &pci_bus_type) {\n\t\t*dev->dma_mask =  SZ_64M - 1;\n\t\tdev->coherent_dma_mask = SZ_64M - 1;\n\t\tdmabounce_register_dev(dev, 2048, 4096);\n\t}\n\treturn 0;\n}", "path": "arch\\arm\\mach-ixp4xx\\common-pci.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/* CONFIG_PNP */\n", "func_signal": "static irqreturn_t snd_wavefront_ics2115_interrupt(int irq, void *dev_id)", "code": "{\n\tsnd_wavefront_card_t *acard;\n\n\tacard = (snd_wavefront_card_t *) dev_id;\n\n\tif (acard == NULL) \n\t\treturn IRQ_NONE;\n\n\tif (acard->wavefront.interrupts_are_midi) {\n\t\tsnd_wavefront_midi_interrupt (acard);\n\t} else {\n\t\tsnd_wavefront_internal_interrupt (acard);\n\t}\n\treturn IRQ_HANDLED;\n}", "path": "sound\\isa\\wavefront\\wavefront.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/* Reset the MFGPT timers. This is required by some broken BIOSes which already\n * do the same and leave the system in an unstable state. TinyBIOS 0.98 is\n * affected at least (0.99 is OK with MFGPT workaround left to off).\n */\n", "func_signal": "static int __init mfgpt_fix(char *s)", "code": "{\n\tu32 val, dummy;\n\n\t/* The following udocumented bit resets the MFGPT timers */\n\tval = 0xFF; dummy = 0;\n\twrmsr(MSR_MFGPT_SETUP, val, dummy);\n\treturn 1;\n}", "path": "arch\\x86\\kernel\\mfgpt_32.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/* unused */\n", "func_signal": "void\nbefs_dump_run(const struct super_block *sb, befs_disk_block_run run)", "code": "{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run n = fsrun_to_cpu(sb, run);\n\n\tbefs_debug(sb, \"[%u, %hu, %hu]\", n.allocation_group, n.start, n.len);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}", "path": "fs\\befs\\debug.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*\n * Display super block structure for debug.\n */\n", "func_signal": "void\nbefs_dump_super_block(const struct super_block *sb, befs_super_block * sup)", "code": "{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_super_block information\");\n\n\tbefs_debug(sb, \"  name %s\", sup->name);\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, sup->magic1));\n\tbefs_debug(sb, \"  fs_byte_order %08x\",\n\t\t   fs32_to_cpu(sb, sup->fs_byte_order));\n\n\tbefs_debug(sb, \"  block_size %u\", fs32_to_cpu(sb, sup->block_size));\n\tbefs_debug(sb, \"  block_shift %u\", fs32_to_cpu(sb, sup->block_shift));\n\n\tbefs_debug(sb, \"  num_blocks %Lu\", fs64_to_cpu(sb, sup->num_blocks));\n\tbefs_debug(sb, \"  used_blocks %Lu\", fs64_to_cpu(sb, sup->used_blocks));\n\n\tbefs_debug(sb, \"  magic2 %08x\", fs32_to_cpu(sb, sup->magic2));\n\tbefs_debug(sb, \"  blocks_per_ag %u\",\n\t\t   fs32_to_cpu(sb, sup->blocks_per_ag));\n\tbefs_debug(sb, \"  ag_shift %u\", fs32_to_cpu(sb, sup->ag_shift));\n\tbefs_debug(sb, \"  num_ags %u\", fs32_to_cpu(sb, sup->num_ags));\n\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, sup->flags));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->log_blocks);\n\tbefs_debug(sb, \"  log_blocks %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  log_start %Ld\", fs64_to_cpu(sb, sup->log_start));\n\tbefs_debug(sb, \"  log_end %Ld\", fs64_to_cpu(sb, sup->log_end));\n\n\tbefs_debug(sb, \"  magic3 %08x\", fs32_to_cpu(sb, sup->magic3));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->root_dir);\n\tbefs_debug(sb, \"  root_dir %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, sup->indices);\n\tbefs_debug(sb, \"  indices %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}", "path": "fs\\befs\\debug.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_probe - Determine if the Serial Mux should claim this device.\n * @dev: The parisc device.\n *\n * Deterimine if the Serial Mux should claim this chip (return 0)\n * or not (return 1).\n */\n", "func_signal": "static int __init mux_probe(struct parisc_device *dev)", "code": "{\n\tint i, status;\n\n\tint port_count = get_mux_port_count(dev);\n\tprintk(KERN_INFO \"Serial mux driver (%d ports) Revision: 0.6\\n\", port_count);\n\n\tdev_set_drvdata(&dev->dev, (void *)(long)port_count);\n\trequest_mem_region(dev->hpa.start + MUX_OFFSET,\n                           port_count * MUX_LINE_OFFSET, \"Mux\");\n\n\tif(!port_cnt) {\n\t\tmux_driver.cons = MUX_CONSOLE;\n\n\t\tstatus = uart_register_driver(&mux_driver);\n\t\tif(status) {\n\t\t\tprintk(KERN_ERR \"Serial mux: Unable to register driver.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor(i = 0; i < port_count; ++i, ++port_cnt) {\n\t\tstruct uart_port *port = &mux_ports[port_cnt].port;\n\t\tport->iobase\t= 0;\n\t\tport->mapbase\t= dev->hpa.start + MUX_OFFSET +\n\t\t\t\t\t\t(i * MUX_LINE_OFFSET);\n\t\tport->membase\t= ioremap_nocache(port->mapbase, MUX_LINE_OFFSET);\n\t\tport->iotype\t= UPIO_MEM;\n\t\tport->type\t= PORT_MUX;\n\t\tport->irq\t= NO_IRQ;\n\t\tport->uartclk\t= 0;\n\t\tport->fifosize\t= MUX_FIFO_SIZE;\n\t\tport->ops\t= &mux_pops;\n\t\tport->flags\t= UPF_BOOT_AUTOCONF;\n\t\tport->line\t= port_cnt;\n\n\t\t/* The port->timeout needs to match what is present in\n\t\t * uart_wait_until_sent in serial_core.c.  Otherwise\n\t\t * the time spent in msleep_interruptable will be very\n\t\t * long, causing the appearance of a console hang.\n\t\t */\n\t\tport->timeout   = HZ / 50;\n\t\tspin_lock_init(&port->lock);\n\n\t\tstatus = uart_add_one_port(&mux_driver, port);\n\t\tBUG_ON(status);\n\t}\n\n\treturn 0;\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_verify_port - Verify the port information.\n * @port: Ptr to the uart_port.\n * @ser: Ptr to the serial information.\n *\n * Verify the new serial port information contained within serinfo is\n * suitable for this port type.\n */\n", "func_signal": "static int mux_verify_port(struct uart_port *port, struct serial_struct *ser)", "code": "{\n\tif(port->membase == NULL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/**\n * mux_drv_poll - Mux poll function.\n * @unused: Unused variable\n *\n * This function periodically polls the Serial MUX to check for new data.\n */\n", "func_signal": "static void mux_poll(unsigned long unused)", "code": "{  \n\tint i;\n\n\tfor(i = 0; i < port_cnt; ++i) {\n\t\tif(!mux_ports[i].enabled)\n\t\t\tcontinue;\n\n\t\tmux_read(&mux_ports[i].port);\n\t\tmux_write(&mux_ports[i].port);\n\t}\n\n\tmod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);\n}", "path": "drivers\\serial\\mux.c", "repo_name": "faux123/kernel-MB860", "stars": 17, "license": "other", "language": "c", "size": 303870}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_GenerateSTART\n* Description    : Generates I2Cx communication START condition.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C START condition generation.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Generate a START condition */\n    I2Cx->CR1 |= CR1_START_Set;\n  }\n  else\n  {\n    /* Disable the START condition generation */\n    I2Cx->CR1 &= CR1_START_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_FastModeDutyCycleConfig\n* Description    : Selects the specified I2C fast mode duty cycle.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - I2C_DutyCycle: specifies the fast mode duty cycle.\n*                    This parameter can be one of the following values:\n*                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2\n*                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));\n\n  if (I2C_DutyCycle != I2C_DutyCycle_16_9)\n  {\n    /* I2C fast mode Tlow/Thigh=2 */\n    I2Cx->CCR &= I2C_DutyCycle_2;\n  }\n  else\n  {\n    /* I2C fast mode Tlow/Thigh=16/9 */\n    I2Cx->CCR |= I2C_DutyCycle_16_9;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_SendData\n* Description    : Sends a data byte through the I2Cx peripheral.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - Data: Byte to be transmitted..\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  /* Write in the DR register the data to be sent */\n  I2Cx->DR = Data;\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_SoftwareResetCmd\n* Description    : Enables or disables the specified I2C software reset.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C software reset.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Peripheral under reset */\n    I2Cx->CR1 |= CR1_SWRST_Set;\n  }\n  else\n  {\n    /* Peripheral not under reset */\n    I2Cx->CR1 &= CR1_SWRST_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_StructInit\n* Description    : Fills each I2C_InitStruct member with its default value.\n* Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure\n*                    which will be initialized.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)", "code": "{\n/*---------------- Reset I2C init structure parameters values ----------------*/\n  /* Initialize the I2C_Mode member */\n  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;\n\n  /* Initialize the I2C_DutyCycle member */\n  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;\n\n  /* Initialize the I2C_OwnAddress1 member */\n  I2C_InitStruct->I2C_OwnAddress1 = 0;\n\n  /* Initialize the I2C_Ack member */\n  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;\n\n  /* Initialize the I2C_AcknowledgedAddress member */\n  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n\n  /* initialize the I2C_ClockSpeed member */\n  I2C_InitStruct->I2C_ClockSpeed = 5000;\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_ARPCmd\n* Description    : Enables or disables the specified I2C ARP.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2Cx ARP. \n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected I2C ARP */\n    I2Cx->CR1 |= CR1_ENARP_Set;\n  }\n  else\n  {\n    /* Disable the selected I2C ARP */\n    I2Cx->CR1 &= CR1_ENARP_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_AcknowledgeConfig\n* Description    : Enables or disables the specified I2C acknowledge feature.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C Acknowledgement.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the acknowledgement */\n    I2Cx->CR1 |= CR1_ACK_Set;\n  }\n  else\n  {\n    /* Disable the acknowledgement */\n    I2Cx->CR1 &= CR1_ACK_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_SMBusAlertConfig\n* Description    : Drives the SMBusAlert pin high or low for the specified I2C.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - I2C_SMBusAlert: specifies SMBAlert pin level. \n*                    This parameter can be one of the following values:\n*                       - I2C_SMBusAlert_Low: SMBAlert pin driven low\n*                       - I2C_SMBusAlert_High: SMBAlert pin driven high\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));\n\n  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)\n  {\n    /* Drive the SMBusAlert pin Low */\n    I2Cx->CR1 |= I2C_SMBusAlert_Low;\n  }\n  else\n  {\n    /* Drive the SMBusAlert pin High  */\n    I2Cx->CR1 &= I2C_SMBusAlert_High;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_StretchClockCmd\n* Description    : Enables or disables the specified I2C Clock stretching.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2Cx Clock stretching.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState == DISABLE)\n  {\n    /* Enable the selected I2C Clock stretching */\n    I2Cx->CR1 |= CR1_NOSTRETCH_Set;\n  }\n  else\n  {\n    /* Disable the selected I2C Clock stretching */\n    I2Cx->CR1 &= CR1_NOSTRETCH_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_DeInit\n* Description    : Deinitializes the I2Cx peripheral registers to their default\n*                  reset values.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_DeInit(I2C_TypeDef* I2Cx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  switch (*(u32*)&I2Cx)\n  {\n    case I2C1_BASE:\n      /* Enable I2C1 reset state */\n      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);\n      /* Release I2C1 from reset state */\n      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);\n      break;\n\n    case I2C2_BASE:\n      /* Enable I2C2 reset state */\n      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);\n      /* Release I2C2 from reset state */\n      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);\n      break;\n\n    default:\n      break;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_GetPEC\n* Description    : Returns the PEC value for the specified I2C.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n* Output         : None\n* Return         : The PEC value.\n*******************************************************************************/\n", "func_signal": "u8 I2C_GetPEC(I2C_TypeDef* I2Cx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  /* Return the selected I2C PEC value */\n  return ((I2Cx->SR2) >> 8);\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_GetLastEvent\n* Description    : Returns the last I2Cx Event.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n* Output         : None\n* Return         : The last event\n*******************************************************************************/\n", "func_signal": "u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)", "code": "{\n  u32 lastevent = 0;\n  u32 flag1 = 0, flag2 = 0;\n\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  /* Read the I2Cx status register */\n  flag1 = I2Cx->SR1;\n  flag2 = I2Cx->SR2;\n  flag2 = flag2 << 16;\n\n  /* Get the last event value from I2C status register */\n  lastevent = (flag1 | flag2) & FLAG_Mask;\n\n  /* Return status */\n  return lastevent;\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_TransmitPEC\n* Description    : Enables or disables the specified I2C PEC transfer.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C PEC transmission.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected I2C PEC transmission */\n    I2Cx->CR1 |= CR1_PEC_Set;\n  }\n  else\n  {\n    /* Disable the selected I2C PEC transmission */\n    I2Cx->CR1 &= CR1_PEC_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_DMALastTransferCmd\n* Description    : Specifies that the next DMA transfer is the last one.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C DMA last transfer.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Next DMA transfer is the last transfer */\n    I2Cx->CR2 |= CR2_LAST_Set;\n  }\n  else\n  {\n    /* Next DMA transfer is not the last transfer */\n    I2Cx->CR2 &= CR2_LAST_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_Init\n* Description    : Initializes the I2Cx peripheral according to the specified \n*                  parameters in the I2C_InitStruct.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that\n*                    contains the configuration information for the specified\n*                    I2C peripheral.\n* Output         : None\n* Return         : None\n******************************************************************************/\n", "func_signal": "void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)", "code": "{\n  u16 tmpreg = 0, freqrange = 0;\n  u16 result = 0x04;\n  u32 pclk1 = 8000000;\n  RCC_ClocksTypeDef  rcc_clocks;\n\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));\n  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));\n  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));\n  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));\n  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));\n  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));\n\n/*---------------------------- I2Cx CR2 Configuration ------------------------*/\n  /* Get the I2Cx CR2 value */\n  tmpreg = I2Cx->CR2;\n  /* Clear frequency FREQ[5:0] bits */\n  tmpreg &= CR2_FREQ_Reset;\n  /* Get pclk1 frequency value */\n  RCC_GetClocksFreq(&rcc_clocks);\n  pclk1 = rcc_clocks.PCLK1_Frequency;\n  /* Set frequency bits depending on pclk1 value */\n  freqrange = (u16)(pclk1 / 1000000);\n  tmpreg |= freqrange;\n  /* Write to I2Cx CR2 */\n  I2Cx->CR2 = tmpreg;\n\n/*---------------------------- I2Cx CCR Configuration ------------------------*/\n  /* Disable the selected I2C peripheral to configure TRISE */\n  I2Cx->CR1 &= CR1_PE_Reset;\n\n  /* Reset tmpreg value */\n  /* Clear F/S, DUTY and CCR[11:0] bits */\n  tmpreg = 0;\n\n  /* Configure speed in standard mode */\n  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)\n  {\n    /* Standard mode speed calculate */\n    result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));\n    /* Test if CCR value is under 0x4*/\n    if (result < 0x04)\n    {\n      /* Set minimum allowed value */\n      result = 0x04;  \n    }\n    /* Set speed value for standard mode */\n    tmpreg |= result;\t  \n    /* Set Maximum Rise Time for standard mode */\n    I2Cx->TRISE = freqrange + 1; \n  }\n  /* Configure speed in fast mode */\n  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/\n  {\n    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)\n    {\n      /* Fast mode speed calculate: Tlow/Thigh = 2 */\n      result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));\n    }\n    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/\n    {\n      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */\n      result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));\n      /* Set DUTY bit */\n      result |= I2C_DutyCycle_16_9;\n    }\n    /* Test if CCR value is under 0x1*/\n    if ((result & CCR_CCR_Set) == 0)\n    {\n      /* Set minimum allowed value */\n      result |= (u16)0x0001;  \n    }\n    /* Set speed value and set F/S bit for fast mode */\n    tmpreg |= result | CCR_FS_Set;\n    /* Set Maximum Rise Time for fast mode */\n    I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  \n  }\n  /* Write to I2Cx CCR */\n  I2Cx->CCR = tmpreg;\n\n  /* Enable the selected I2C peripheral */\n  I2Cx->CR1 |= CR1_PE_Set;\n\n/*---------------------------- I2Cx CR1 Configuration ------------------------*/\n  /* Get the I2Cx CR1 value */\n  tmpreg = I2Cx->CR1;\n  /* Clear ACK, SMBTYPE and  SMBUS bits */\n  tmpreg &= CR1_CLEAR_Mask;\n  /* Configure I2Cx: mode and acknowledgement */\n  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */\n  /* Set ACK bit according to I2C_Ack value */\n  tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);\n  /* Write to I2Cx CR1 */\n  I2Cx->CR1 = tmpreg;\n\n/*---------------------------- I2Cx OAR1 Configuration -----------------------*/\n  /* Set I2Cx Own Address1 and acknowledged address */\n  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_OwnAddress2Config\n* Description    : Configures the specified I2C own address2.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - Address: specifies the 7bit I2C own address2.\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)", "code": "{\n  u16 tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  /* Get the old register value */\n  tmpreg = I2Cx->OAR2;\n  /* Reset I2Cx Own address2 bit [7:1] */\n  tmpreg &= OAR2_ADD2_Reset;\n  /* Set I2Cx Own address2 */\n  tmpreg |= (u16)(Address & (u16)0x00FE);\n  /* Store the new register value */\n  I2Cx->OAR2 = tmpreg;\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_ITConfig\n* Description    : Enables or disables the specified I2C interrupts.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - I2C_IT: specifies the I2C interrupts sources to be enabled\n*                    or disabled. \n*                    This parameter can be any combination of the following values:\n*                       - I2C_IT_BUF: Buffer interrupt mask\n*                       - I2C_IT_EVT: Event interrupt mask\n*                       - I2C_IT_ERR: Error interrupt mask\n*                  - NewState: new state of the specified I2C interrupts.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_I2C_CONFIG_IT(I2C_IT));\n  \n  if (NewState != DISABLE)\n  {\n    /* Enable the selected I2C interrupts */\n    I2Cx->CR2 |= I2C_IT;\n  }\n  else\n  {\n    /* Disable the selected I2C interrupts */\n    I2Cx->CR2 &= (u16)~I2C_IT;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_PECPositionConfig\n* Description    : Selects the specified I2C PEC position.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - I2C_PECPosition: specifies the PEC position. \n*                    This parameter can be one of the following values:\n*                       - I2C_PECPosition_Next: indicates that the next\n*                         byte is PEC\n*                       - I2C_PECPosition_Current: indicates that current\n*                         byte is PEC\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));\n\n  if (I2C_PECPosition == I2C_PECPosition_Next)\n  {\n    /* Next byte in shift register is PEC */\n    I2Cx->CR1 |= I2C_PECPosition_Next;\n  }\n  else\n  {\n    /* Current byte in shift register is PEC */\n    I2Cx->CR1 &= I2C_PECPosition_Current;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_GenerateSTOP\n* Description    : Generates I2Cx communication STOP condition.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - NewState: new state of the I2C STOP condition generation.\n*                    This parameter can be: ENABLE or DISABLE.\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Generate a STOP condition */\n    I2Cx->CR1 |= CR1_STOP_Set;\n  }\n  else\n  {\n    /* Disable the STOP condition generation */\n    I2Cx->CR1 &= CR1_STOP_Reset;\n  }\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*******************************************************************************\n* Function Name  : I2C_Send7bitAddress\n* Description    : Transmits the address byte to select the slave device.\n* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.\n*                  - Address: specifies the slave address which will be transmitted\n*                  - I2C_Direction: specifies whether the I2C device will be a\n*                    Transmitter or a Receiver. \n*                    This parameter can be one of the following values\n*                       - I2C_Direction_Transmitter: Transmitter mode\n*                       - I2C_Direction_Receiver: Receiver mode\n* Output         : None\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_DIRECTION(I2C_Direction));\n\n  /* Test on the direction to set/reset the read/write bit */\n  if (I2C_Direction != I2C_Direction_Transmitter)\n  {\n    /* Set the address bit0 for read */\n    Address |= OAR1_ADD0_Set;\n  }\n  else\n  {\n    /* Reset the address bit0 for write */\n    Address &= OAR1_ADD0_Reset;\n  }\n  /* Send the address */\n  I2Cx->DR = Address;\n}", "path": "lib\\src\\stm32f10x_i2c.c", "repo_name": "adamgreig/followingrobot", "stars": 16, "license": "None", "language": "c", "size": 378}
{"docstring": "/*\n** Check to see if the i-th bit is set.  Return true or false.\n** If p is NULL (if the bitmap has not been created) or if\n** i is out of range, then return false.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i)", "code": "{\n  if( p==0 ) return 0;\n  if( i>p->iSize || i==0 ) return 0;\n  i--;\n  while( p->iDivisor ){\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    p = p->u.apSub[bin];\n    if (!p) {\n      return 0;\n    }\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;\n  } else{\n    u32 h = BITVEC_HASH(i++);\n    while( p->u.aHash[h] ){\n      if( p->u.aHash[h]==i ) return 1;\n      h = (h+1) % BITVEC_NINT;\n    }\n    return 0;\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Create a new tokenizer instance.\n*/\n", "func_signal": "static int porterCreate(\n  int argc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n)", "code": "{\n  porter_tokenizer *t;\n\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n\n  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));\n  if( t==NULL ) return SQLITE_NOMEM;\n  memset(t, 0, sizeof(*t));\n  *ppTokenizer = &t->base;\n  return SQLITE_OK;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Deinitialize the memory allocation subsystem.\n*/\n", "func_signal": "static void sqlite3MemShutdown(void *NotUsed)", "code": "{\n  UNUSED_PARAMETER(NotUsed);\n  mem.mutex = 0;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Convert zDate into one or more integers.  Additional arguments\n** come in groups of 5 as follows:\n**\n**       N       number of digits in the integer\n**       min     minimum allowed value of the integer\n**       max     maximum allowed value of the integer\n**       nextC   first character after the integer\n**       pVal    where to write the integers value.\n**\n** Conversions continue until one with nextC==0 is encountered.\n** The function returns the number of successful conversions.\n*/\n", "func_signal": "static int getDigits(const char *zDate, ...)", "code": "{\n  va_list ap;\n  int val;\n  int N;\n  int min;\n  int max;\n  int nextC;\n  int *pVal;\n  int cnt = 0;\n  va_start(ap, zDate);\n  do{\n    N = va_arg(ap, int);\n    min = va_arg(ap, int);\n    max = va_arg(ap, int);\n    nextC = va_arg(ap, int);\n    pVal = va_arg(ap, int*);\n    val = 0;\n    while( N-- ){\n      if( !sqlite3Isdigit(*zDate) ){\n        goto end_getDigits;\n      }\n      val = val*10 + *zDate - '0';\n      zDate++;\n    }\n    if( val<min || val>max || (nextC!=0 && nextC!=*zDate) ){\n      goto end_getDigits;\n    }\n    *pVal = val;\n    zDate++;\n    cnt++;\n  }while( nextC );\nend_getDigits:\n  va_end(ap);\n  return cnt;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Decrement the reference count on a page. If the page is clean and the\n** reference count drops to 0, then it is made elible for recycling.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr *p)", "code": "{\n  assert( p->nRef>0 );\n  p->nRef--;\n  if( p->nRef==0 ){\n    PCache *pCache = p->pCache;\n    pCache->nRef--;\n    if( (p->flags&PGHDR_DIRTY)==0 ){\n      pcacheUnpin(p);\n    }else{\n      /* Move the page to the head of the dirty list. */\n      pcacheRemoveFromDirtyList(p);\n      pcacheAddToDirtyList(p);\n    }\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Link the chunk at mem3.aPool[i] so that is on the list rooted\n** at *pRoot.\n*/\n", "func_signal": "static void memsys3LinkIntoList(u32 i, u32 *pRoot)", "code": "{\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  mem3.aPool[i].u.list.next = *pRoot;\n  mem3.aPool[i].u.list.prev = 0;\n  if( *pRoot ){\n    mem3.aPool[*pRoot].u.list.prev = i;\n  }\n  *pRoot = i;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/* Return the value to pass to a sqlite3_wal_hook callback, the\n** number of frames in the WAL at the point of the last commit since\n** sqlite3WalCallback() was called.  If no commits have occurred since\n** the last call, then return 0.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal)", "code": "{\n  u32 ret = 0;\n  if( pWal ){\n    ret = pWal->iCallback;\n    pWal->iCallback = 0;\n  }\n  return (int)ret;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Close all cursors.\n**\n** Also release any dynamic memory held by the VM in the Vdbe.aMem memory \n** cell array. This is necessary as the memory cell array may contain\n** pointers to VdbeFrame objects, which may in turn contain pointers to\n** open cursors.\n*/\n", "func_signal": "static void closeAllCursors(Vdbe *p)", "code": "{\n  if( p->pFrame ){\n    VdbeFrame *pFrame;\n    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n    sqlite3VdbeFrameRestore(pFrame);\n  }\n  p->pFrame = 0;\n  p->nFrame = 0;\n\n  if( p->apCsr ){\n    int i;\n    for(i=0; i<p->nCursor; i++){\n      VdbeCursor *pC = p->apCsr[i];\n      if( pC ){\n        sqlite3VdbeFreeCursor(p, pC);\n        p->apCsr[i] = 0;\n      }\n    }\n  }\n  if( p->aMem ){\n    releaseMemArray(&p->aMem[1], p->nMem);\n  }\n  while( p->pDelFrame ){\n    VdbeFrame *pDel = p->pDelFrame;\n    p->pDelFrame = pDel->pParent;\n    sqlite3VdbeFrameDelete(pDel);\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** If pExpr is a constant expression that is appropriate for\n** factoring out of a loop, then evaluate the expression\n** into a register and convert the expression into a TK_REGISTER\n** expression.\n*/\n", "func_signal": "static int evalConstExpr(Walker *pWalker, Expr *pExpr)", "code": "{\n  Parse *pParse = pWalker->pParse;\n  switch( pExpr->op ){\n    case TK_IN:\n    case TK_REGISTER: {\n      return WRC_Prune;\n    }\n    case TK_FUNCTION:\n    case TK_AGG_FUNCTION:\n    case TK_CONST_FUNC: {\n      /* The arguments to a function have a fixed destination.\n      ** Mark them this way to avoid generated unneeded OP_SCopy\n      ** instructions. \n      */\n      ExprList *pList = pExpr->x.pList;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( pList ){\n        int i = pList->nExpr;\n        struct ExprList_item *pItem = pList->a;\n        for(; i>0; i--, pItem++){\n          if( ALWAYS(pItem->pExpr) ) pItem->pExpr->flags |= EP_FixedDest;\n        }\n      }\n      break;\n    }\n  }\n  if( isAppropriateForFactoring(pExpr) ){\n    int r1 = ++pParse->nMem;\n    int r2;\n    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);\n    if( NEVER(r1!=r2) ) sqlite3ReleaseTempReg(pParse, r1);\n    pExpr->op2 = pExpr->op;\n    pExpr->op = TK_REGISTER;\n    pExpr->iTable = r2;\n    return WRC_Prune;\n  }\n  return WRC_Continue;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Interface to the testing logic.\n*/\n", "func_signal": "SQLITE_API int sqlite3_test_control(int op, ...)", "code": "{\n  int rc = 0;\n#ifndef SQLITE_OMIT_BUILTIN_TEST\n  va_list ap;\n  va_start(ap, op);\n  switch( op ){\n\n    /*\n    ** Save the current state of the PRNG.\n    */\n    case SQLITE_TESTCTRL_PRNG_SAVE: {\n      sqlite3PrngSaveState();\n      break;\n    }\n\n    /*\n    ** Restore the state of the PRNG to the last state saved using\n    ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then\n    ** this verb acts like PRNG_RESET.\n    */\n    case SQLITE_TESTCTRL_PRNG_RESTORE: {\n      sqlite3PrngRestoreState();\n      break;\n    }\n\n    /*\n    ** Reset the PRNG back to its uninitialized state.  The next call\n    ** to sqlite3_randomness() will reseed the PRNG using a single call\n    ** to the xRandomness method of the default VFS.\n    */\n    case SQLITE_TESTCTRL_PRNG_RESET: {\n      sqlite3PrngResetState();\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(BITVEC_TEST, size, program)\n    **\n    ** Run a test against a Bitvec object of size.  The program argument\n    ** is an array of integers that defines the test.  Return -1 on a\n    ** memory allocation error, 0 on success, or non-zero for an error.\n    ** See the sqlite3BitvecBuiltinTest() for additional information.\n    */\n    case SQLITE_TESTCTRL_BITVEC_TEST: {\n      int sz = va_arg(ap, int);\n      int *aProg = va_arg(ap, int*);\n      rc = sqlite3BitvecBuiltinTest(sz, aProg);\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)\n    **\n    ** Register hooks to call to indicate which malloc() failures \n    ** are benign.\n    */\n    case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {\n      typedef void (*void_function)(void);\n      void_function xBenignBegin;\n      void_function xBenignEnd;\n      xBenignBegin = va_arg(ap, void_function);\n      xBenignEnd = va_arg(ap, void_function);\n      sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)\n    **\n    ** Set the PENDING byte to the value in the argument, if X>0.\n    ** Make no changes if X==0.  Return the value of the pending byte\n    ** as it existing before this routine was called.\n    **\n    ** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in\n    ** an incompatible database file format.  Changing the PENDING byte\n    ** while any database connection is open results in undefined and\n    ** dileterious behavior.\n    */\n    case SQLITE_TESTCTRL_PENDING_BYTE: {\n      rc = PENDING_BYTE;\n#ifndef SQLITE_OMIT_WSD\n      {\n        unsigned int newVal = va_arg(ap, unsigned int);\n        if( newVal ) sqlite3PendingByte = newVal;\n      }\n#endif\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)\n    **\n    ** This action provides a run-time test to see whether or not\n    ** assert() was enabled at compile-time.  If X is true and assert()\n    ** is enabled, then the return value is true.  If X is true and\n    ** assert() is disabled, then the return value is zero.  If X is\n    ** false and assert() is enabled, then the assertion fires and the\n    ** process aborts.  If X is false and assert() is disabled, then the\n    ** return value is zero.\n    */\n    case SQLITE_TESTCTRL_ASSERT: {\n      volatile int x = 0;\n      assert( (x = va_arg(ap,int))!=0 );\n      rc = x;\n      break;\n    }\n\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)\n    **\n    ** This action provides a run-time test to see how the ALWAYS and\n    ** NEVER macros were defined at compile-time.\n    **\n    ** The return value is ALWAYS(X).  \n    **\n    ** The recommended test is X==2.  If the return value is 2, that means\n    ** ALWAYS() and NEVER() are both no-op pass-through macros, which is the\n    ** default setting.  If the return value is 1, then ALWAYS() is either\n    ** hard-coded to true or else it asserts if its argument is false.\n    ** The first behavior (hard-coded to true) is the case if\n    ** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second\n    ** behavior (assert if the argument to ALWAYS() is false) is the case if\n    ** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.\n    **\n    ** The run-time test procedure might look something like this:\n    **\n    **    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){\n    **      // ALWAYS() and NEVER() are no-op pass-through macros\n    **    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){\n    **      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.\n    **    }else{\n    **      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.\n    **    }\n    */\n    case SQLITE_TESTCTRL_ALWAYS: {\n      int x = va_arg(ap,int);\n      rc = ALWAYS(x);\n      break;\n    }\n\n    /*   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N)\n    **\n    ** Set the nReserve size to N for the main database on the database\n    ** connection db.\n    */\n    case SQLITE_TESTCTRL_RESERVE: {\n      sqlite3 *db = va_arg(ap, sqlite3*);\n      int x = va_arg(ap,int);\n      sqlite3_mutex_enter(db->mutex);\n      sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);\n      sqlite3_mutex_leave(db->mutex);\n      break;\n    }\n\n    /*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)\n    **\n    ** Enable or disable various optimizations for testing purposes.  The \n    ** argument N is a bitmask of optimizations to be disabled.  For normal\n    ** operation N should be 0.  The idea is that a test program (like the\n    ** SQL Logic Test or SLT test module) can run the same SQL multiple times\n    ** with various optimizations disabled to verify that the same answer\n    ** is obtained in every case.\n    */\n    case SQLITE_TESTCTRL_OPTIMIZATIONS: {\n      sqlite3 *db = va_arg(ap, sqlite3*);\n      int x = va_arg(ap,int);\n      db->flags = (x & SQLITE_OptMask) | (db->flags & ~SQLITE_OptMask);\n      break;\n    }\n\n#ifdef SQLITE_N_KEYWORD\n    /* sqlite3_test_control(SQLITE_TESTCTRL_ISKEYWORD, const char *zWord)\n    **\n    ** If zWord is a keyword recognized by the parser, then return the\n    ** number of keywords.  Or if zWord is not a keyword, return 0.\n    ** \n    ** This test feature is only available in the amalgamation since\n    ** the SQLITE_N_KEYWORD macro is not defined in this file if SQLite\n    ** is built using separate source files.\n    */\n    case SQLITE_TESTCTRL_ISKEYWORD: {\n      const char *zWord = va_arg(ap, const char*);\n      int n = sqlite3Strlen30(zWord);\n      rc = (sqlite3KeywordCode((u8*)zWord, n)!=TK_ID) ? SQLITE_N_KEYWORD : 0;\n      break;\n    }\n#endif \n\n    /* sqlite3_test_control(SQLITE_TESTCTRL_PGHDRSZ)\n    **\n    ** Return the size of a pcache header in bytes.\n    */\n    case SQLITE_TESTCTRL_PGHDRSZ: {\n      rc = sizeof(PgHdr);\n      break;\n    }\n\n    /* sqlite3_test_control(SQLITE_TESTCTRL_SCRATCHMALLOC, sz, &pNew, pFree);\n    **\n    ** Pass pFree into sqlite3ScratchFree(). \n    ** If sz>0 then allocate a scratch buffer into pNew.  \n    */\n    case SQLITE_TESTCTRL_SCRATCHMALLOC: {\n      void *pFree, **ppNew;\n      int sz;\n      sz = va_arg(ap, int);\n      ppNew = va_arg(ap, void**);\n      pFree = va_arg(ap, void*);\n      if( sz ) *ppNew = sqlite3ScratchMalloc(sz);\n      sqlite3ScratchFree(pFree);\n      break;\n    }\n\n  }\n  va_end(ap);\n#endif /* SQLITE_OMIT_BUILTIN_TEST */\n  return rc;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Implementation of the sqlite3_pcache.xUnpin method.\n**\n** Mark a page as unpinned (eligible for asynchronous recycling).\n*/\n", "func_signal": "static void pcache1Unpin(sqlite3_pcache *p, void *pPg, int reuseUnlikely)", "code": "{\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = PAGE_TO_PGHDR1(pCache, pPg);\n  PGroup *pGroup = pCache->pGroup;\n \n  assert( pPage->pCache==pCache );\n  pcache1EnterMutex(pGroup);\n\n  /* It is an error to call this function if the page is already \n  ** part of the PGroup LRU list.\n  */\n  assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );\n  assert( pGroup->pLruHead!=pPage && pGroup->pLruTail!=pPage );\n\n  if( reuseUnlikely || pGroup->nCurrentPage>pGroup->nMaxPage ){\n    pcache1RemoveFromHash(pPage);\n    pcache1FreePage(pPage);\n  }else{\n    /* Add the page to the PGroup LRU list. */\n    if( pGroup->pLruHead ){\n      pGroup->pLruHead->pLruPrev = pPage;\n      pPage->pLruNext = pGroup->pLruHead;\n      pGroup->pLruHead = pPage;\n    }else{\n      pGroup->pLruTail = pPage;\n      pGroup->pLruHead = pPage;\n    }\n    pCache->nRecyclable++;\n  }\n\n  pcache1LeaveMutex(pCache->pGroup);\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Release a reference to a node. If the node is dirty and the reference\n** count drops to zero, the node data is written to the database.\n*/\n", "func_signal": "static int\nnodeRelease(Rtree *pRtree, RtreeNode *pNode)", "code": "{\n  int rc = SQLITE_OK;\n  if( pNode ){\n    assert( pNode->nRef>0 );\n    pNode->nRef--;\n    if( pNode->nRef==0 ){\n      if( pNode->iNode==1 ){\n        pRtree->iDepth = -1;\n      }\n      if( pNode->pParent ){\n        rc = nodeRelease(pRtree, pNode->pParent);\n      }\n      if( rc==SQLITE_OK ){\n        rc = nodeWrite(pRtree, pNode);\n      }\n      nodeHashDelete(pRtree, pNode);\n      sqlite3_free(pNode);\n    }\n  }\n  return rc;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Allocate and zero memory.  If the allocation fails, make\n** the mallocFailed flag in the connection pointer.\n**\n** If db!=0 and db->mallocFailed is true (indicating a prior malloc\n** failure on the same database connection) then always return 0.\n** Hence for a particular database connection, once malloc starts\n** failing, it fails consistently until mallocFailed is reset.\n** This is an important assumption.  There are many places in the\n** code that do things like this:\n**\n**         int *a = (int*)sqlite3DbMallocRaw(db, 100);\n**         int *b = (int*)sqlite3DbMallocRaw(db, 200);\n**         if( b ) a[10] = 9;\n**\n** In other words, if a subsequent malloc (ex: \"b\") worked, it is assumed\n** that all prior mallocs (ex: \"a\") worked too.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, int n)", "code": "{\n  void *p;\n  assert( db==0 || sqlite3_mutex_held(db->mutex) );\n  assert( db==0 || db->pnBytesFreed==0 );\n#ifndef SQLITE_OMIT_LOOKASIDE\n  if( db ){\n    LookasideSlot *pBuf;\n    if( db->mallocFailed ){\n      return 0;\n    }\n    if( db->lookaside.bEnabled ){\n      if( n>db->lookaside.sz ){\n        db->lookaside.anStat[1]++;\n      }else if( (pBuf = db->lookaside.pFree)==0 ){\n        db->lookaside.anStat[2]++;\n      }else{\n        db->lookaside.pFree = pBuf->pNext;\n        db->lookaside.nOut++;\n        db->lookaside.anStat[0]++;\n        if( db->lookaside.nOut>db->lookaside.mxOut ){\n          db->lookaside.mxOut = db->lookaside.nOut;\n        }\n        return (void*)pBuf;\n      }\n    }\n  }\n#else\n  if( db && db->mallocFailed ){\n    return 0;\n  }\n#endif\n  p = sqlite3Malloc(n);\n  if( !p && db ){\n    db->mallocFailed = 1;\n  }\n  sqlite3MemdebugSetType(p, MEMTYPE_DB |\n         ((db && db->lookaside.bEnabled) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));\n  return p;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** A call to this routine tells the pager that it is not necessary to\n** write the information on page pPg back to the disk, even though\n** that page might be marked as dirty.  This happens, for example, when\n** the page has been added as a leaf of the freelist and so its\n** content no longer matters.\n**\n** The overlying software layer calls this routine when all of the data\n** on the given page is unused. The pager marks the page as clean so\n** that it does not get written to disk.\n**\n** Tests show that this optimization can quadruple the speed of large \n** DELETE operations.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg)", "code": "{\n  Pager *pPager = pPg->pPager;\n  if( (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){\n    PAGERTRACE((\"DONT_WRITE page %d of %d\\n\", pPg->pgno, PAGERID(pPager)));\n    IOTRACE((\"CLEAN %p %d\\n\", pPager, pPg->pgno))\n    pPg->flags |= PGHDR_DONT_WRITE;\n    pager_set_pagehash(pPg);\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Lock the database file to level eLock, which must be either SHARED_LOCK,\n** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set the\n** Pager.eLock variable to the new locking state. \n**\n** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is \n** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. \n** See the comment above the #define of UNKNOWN_LOCK for an explanation \n** of this.\n*/\n", "func_signal": "static int pagerLockDb(Pager *pPager, int eLock)", "code": "{\n  int rc = SQLITE_OK;\n\n  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );\n  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){\n    rc = sqlite3OsLock(pPager->fd, eLock);\n    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){\n      pPager->eLock = (u8)eLock;\n      IOTRACE((\"LOCK %p %d\\n\", pPager, eLock))\n    }\n  }\n  return rc;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Return non-zero if a transaction is active.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree *p)", "code": "{\n  assert( p==0 || sqlite3_mutex_held(p->db->mutex) );\n  return (p && (p->inTrans==TRANS_WRITE));\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** *pRoot is the head of a list of free chunks of the same size\n** or same size hash.  In other words, *pRoot is an entry in either\n** mem3.aiSmall[] or mem3.aiHash[].  \n**\n** This routine examines all entries on the given list and tries\n** to coalesce each entries with adjacent free chunks.  \n**\n** If it sees a chunk that is larger than mem3.iMaster, it replaces \n** the current mem3.iMaster with the new larger chunk.  In order for\n** this mem3.iMaster replacement to work, the master chunk must be\n** linked into the hash tables.  That is not the normal state of\n** affairs, of course.  The calling routine must link the master\n** chunk before invoking this routine, then must unlink the (possibly\n** changed) master chunk once this routine has finished.\n*/\n", "func_signal": "static void memsys3Merge(u32 *pRoot)", "code": "{\n  u32 iNext, prev, size, i, x;\n\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  for(i=*pRoot; i>0; i=iNext){\n    iNext = mem3.aPool[i].u.list.next;\n    size = mem3.aPool[i-1].u.hdr.size4x;\n    assert( (size&1)==0 );\n    if( (size&2)==0 ){\n      memsys3UnlinkFromList(i, pRoot);\n      assert( i > mem3.aPool[i-1].u.hdr.prevSize );\n      prev = i - mem3.aPool[i-1].u.hdr.prevSize;\n      if( prev==iNext ){\n        iNext = mem3.aPool[prev].u.list.next;\n      }\n      memsys3Unlink(prev);\n      size = i + size/4 - prev;\n      x = mem3.aPool[prev-1].u.hdr.size4x & 2;\n      mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;\n      mem3.aPool[prev+size-1].u.hdr.prevSize = size;\n      memsys3Link(prev);\n      i = prev;\n    }else{\n      size /= 4;\n    }\n    if( size>mem3.szMaster ){\n      mem3.iMaster = i;\n      mem3.szMaster = size;\n    }\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Select a currently unused rowid for a new r-tree record.\n*/\n", "func_signal": "static int newRowid(Rtree *pRtree, i64 *piRowid)", "code": "{\n  int rc;\n  sqlite3_bind_null(pRtree->pWriteRowid, 1);\n  sqlite3_bind_null(pRtree->pWriteRowid, 2);\n  sqlite3_step(pRtree->pWriteRowid);\n  rc = sqlite3_reset(pRtree->pWriteRowid);\n  *piRowid = sqlite3_last_insert_rowid(pRtree->db);\n  return rc;\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Convert a DbPage obtained from the pager into a MemPage used by\n** the btree layer.\n*/\n", "func_signal": "static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt)", "code": "{\n  MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);\n  pPage->aData = sqlite3PagerGetData(pDbPage);\n  pPage->pDbPage = pDbPage;\n  pPage->pBt = pBt;\n  pPage->pgno = pgno;\n  pPage->hdrOffset = pPage->pgno==1 ? 100 : 0;\n  return pPage; \n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n** Invoke the OP_AggFinalize opcode for every aggregate function\n** in the AggInfo structure.\n*/\n", "func_signal": "static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo)", "code": "{\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp4(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0, 0,\n                      (void*)pF->pFunc, P4_FUNCDEF);\n  }\n}", "path": "src\\sqlite\\sqlite3.c", "repo_name": "erlehmann/minetest-delta", "stars": 27, "license": "None", "language": "c", "size": 11526}
{"docstring": "/*\n * ubicom32vfb_exit\n */\n", "func_signal": "static void __exit ubicom32vfb_exit(void)", "code": "{\n\tplatform_device_unregister(ubicom32vfb_platform_device);\n\tplatform_driver_unregister(&ubicom32vfb_platform_driver);\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciIfTypeGet - \n*\n* DESCRIPTION:\n*\n* INPUT:\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*\n*******************************************************************************/\n", "func_signal": "MV_U32  mvPciRealIfNumGet(MV_U32 pciIf)", "code": "{\n\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\treturn (pciIf - MV_PCI_START_IF);\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\treturn (pciIf - MV_PEX_START_IF);\n\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn 0xffffffff;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_init\n */\n", "func_signal": "static int __devinit ubicom32vfb_init(void)", "code": "{\n\tint ret;\n\n#ifndef MODULE\n\t/*\n\t * Get kernel boot options (in 'video=ubicom32vfb:<options>')\n\t */\n\tchar *option = NULL;\n\n\tif (fb_get_options(DRIVER_NAME, &option)) {\n\t\treturn -ENODEV;\n\t}\n\tubicom32vfb_setup(option);\n#endif /* MODULE */\n\n\tret = platform_driver_register(&ubicom32vfb_platform_driver);\n\n#ifdef CONFIG_FB_UBICOM32_VIRTUAL_NOAUTO\n\treturn ret;\n#else\n\tif (!ret) {\n\t\tubicom32vfb_platform_device = platform_device_alloc(DRIVER_NAME, 0);\n\n\t\tif (ubicom32vfb_platform_device)\n\t\t\tret = platform_device_add(ubicom32vfb_platform_device);\n\t\telse\n\t\t\tret = -ENOMEM;\n\n\t\tif (ret) {\n\t\t\tplatform_device_put(ubicom32vfb_platform_device);\n\t\t\tplatform_driver_unregister(&ubicom32vfb_platform_driver);\n\t\t}\n\t}\n\n\treturn ret;\n#endif\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_pan_display\n *\tPans the display to a given location.  Supports only y direction panning.\n */\n", "func_signal": "static int ubicom32vfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)", "code": "{\n\tstruct ubicom32vfb_drvdata *ud = (struct ubicom32vfb_drvdata *)fbi->par;\n\tvoid *new_addr;\n\n\t/*\n\t * Get the last y line that would be displayed.  Since we don't support YWRAP,\n\t * it must be less than our virtual y size.\n\t */\n\tu32 lasty = var->yoffset + var->yres;\n\tif (lasty > fbi->var.yres_virtual) {\n\t\t/*\n\t\t * We would fall off the end of our frame buffer if we panned here.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset) {\n\t\t/*\n\t\t * We don't support panning in the x direction\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Everything looks sane, go ahead and pan\n\t *\n\t * We have to calculate a new address for the VDC to look at\n\t */\n\tnew_addr = ud->fb_aligned + (var->yoffset * fbi->fix.line_length);\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciLocalBusNumSet - Set PCI interface local bus number.\n*\n* DESCRIPTION:\n*       This function sets given PCI interface its local bus number.\n*       Note: In case the PCI interface is PCI-X, the information is read-only.\n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*       busNum - Bus number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_NOT_ALLOWED in case PCI interface is PCI-X. \n*\t\tMV_BAD_PARAM on bad parameters ,\n*       otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPciIfLocalBusNumSet(MV_U32 pciIf, MV_U32 busNum)", "code": "{\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciLocalBusNumSet(pciIf - MV_PCI_START_IF,\n\t\t\t\t\t\t\t\tbusNum);\t\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n    }\n    else if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexLocalBusNumSet(pciIf - MV_PEX_START_IF,\n\t\t\t\t\t\t\t\tbusNum);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn MV_FAIL;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciSlaveEnable - Enable/disale PCI interface slave transactions.\n*\n* DESCRIPTION:\n*       This function performs read modified write to PCI command status \n*       (offset 0x4) to set/reset bit 0 and 1. After those bits are set, \n*       the PCI slave is allowed to respond to PCI IO space access (bit 0) \n*       and PCI memory space access (bit 1). \n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*       dev     - PCI device number.\n*       enable - Enable/disable parameter.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPciIfSlaveEnable(MV_U32 pciIf,MV_U32 bus, MV_U32 dev, MV_BOOL enable)", "code": "{\n\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciSlaveEnable(pciIf - MV_PCI_START_IF,bus,dev,\n\t\t\t\t\t\t\t\tenable);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexSlaveEnable(pciIf - MV_PEX_START_IF,bus,dev,\n\t\t\t\t\t\t\t\tenable);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn MV_FAIL;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_platform_remove\n */\n", "func_signal": "static int ubicom32vfb_platform_remove(struct platform_device *pdev)", "code": "{\n\tdev_info(&(pdev->dev), \"Ubicom32 FB Driver Remove\\n\");\n\treturn ubicom32vfb_release(&pdev->dev);\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciInit - Initialize PCI interfaces\n*\n* DESCRIPTION:\n*\n* INPUT:\n*\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPciIfInit(MV_U32 pciIf, PCI_IF_MODE pciIfmode)", "code": "{\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\t\n        MV_PCI_MOD pciMod;\n\t\t\n        if (PCI_IF_MODE_HOST == pciIfmode)\n        {\n            pciMod = MV_PCI_MOD_HOST;\n        }\n        else if (PCI_IF_MODE_DEVICE == pciIfmode)\n        {\n            pciMod = MV_PCI_MOD_DEVICE;\n        }\n        else\n        {\n            mvOsPrintf(\"%s: ERROR!!! Bus %d mode %d neither host nor device!\\n\", \n                        __FUNCTION__, pciIf, pciIfmode);\n            return MV_FAIL;\n        }\n        \n        return mvPciInit(pciIf - MV_PCI_START_IF, pciMod);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\t\n        MV_PEX_TYPE pexType;\n\t\t\n        if (PCI_IF_MODE_HOST == pciIfmode)\n        {\n            pexType = MV_PEX_ROOT_COMPLEX;\n        }\n        else if (PCI_IF_MODE_DEVICE == pciIfmode)\n        {\n            pexType = MV_PEX_END_POINT;\n        }\n        else\n        {\n            mvOsPrintf(\"%s: ERROR!!! Bus %d type %d neither root complex nor\" \\\n                       \" end point\\n\", __FUNCTION__, pciIf, pciIfmode);\n            return MV_FAIL;\n        }\n\t\treturn mvPexInit(pciIf - MV_PEX_START_IF, pexType);\n\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn MV_FAIL;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_set_par\n *\tSet the video mode according to info->var\n */\n", "func_signal": "static int ubicom32vfb_set_par(struct fb_info *info)", "code": "{\n\t/*\n\t * Anything changed?\n\t */\n\tif ((xres == info->var.xres) && (yres == info->var.yres)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Implement changes\n\t */\n\txres = info->var.xres;\n\tyres = info->var.yres;\n\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\tinfo->fix.xpanstep = 0;\n\tinfo->fix.ypanstep = 1;\n\tinfo->fix.line_length = xres * (BITS_PER_PIXEL / 8);\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciIfTypeGet - \n*\n* DESCRIPTION:\n*\n* INPUT:\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*\n*******************************************************************************/\n", "func_signal": "PCI_IF_TYPE mvPciIfTypeGet(MV_U32 pciIf)", "code": "{\n\n\tif ((pciIf >= MV_PCI_START_IF)&&(pciIf < MV_PCI_MAX_IF + MV_PCI_START_IF))\n\t{\n\t\treturn PCI_IF_TYPE_CONVEN_PCIX;\n\t}\n\telse if ((pciIf >= MV_PEX_START_IF) &&\n\t\t\t (pciIf < MV_PEX_MAX_IF + MV_PEX_START_IF))\n\t{\n\t\treturn PCI_IF_TYPE_PEX;\n\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn 0xffffffff;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciLocalDevNumSet - Set PCI interface local device number.\n*\n* DESCRIPTION:\n*       This function sets given PCI interface its local device number.\n*       Note: In case the PCI interface is PCI-X, the information is read-only.\n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*       devNum - Device number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_NOT_ALLOWED in case PCI interface is PCI-X. MV_BAD_PARAM on bad parameters ,\n*       otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPciIfLocalDevNumSet(MV_U32 pciIf, MV_U32 devNum)", "code": "{\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciLocalDevNumSet(pciIf - MV_PCI_START_IF,\n\t\t\t\t\t\t\t\tdevNum);\t\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexLocalDevNumSet(pciIf - MV_PEX_START_IF,\n\t\t\t\t\t\t\t\tdevNum);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn MV_FAIL;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_check_var\n *\tCheck the var, tweak it but don't change operational parameters.\n */\n", "func_signal": "static int ubicom32vfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)", "code": "{\n\tstruct ubicom32vfb_drvdata *ud = (struct ubicom32vfb_drvdata *)info->par;\n\tu32 line_size = var->xres * (BITS_PER_PIXEL / 8);\n\n\t/*\n\t * See if we can handle this bpp\n\t */\n\tif (var->bits_per_pixel > BITS_PER_PIXEL) {\n\t\treturn -EINVAL;\n\t}\n\tvar->bits_per_pixel = BITS_PER_PIXEL;\n\n\t/*\n\t * See if we have enough memory to handle this resolution\n\t */\n\tif ((line_size * var->yres * BITS_PER_PIXEL / 8) > ud->total_vram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = ud->total_vram_size / line_size;\n\n\tvar->red.length = 5;\n\tvar->green.length = 6;\n\tvar->green.offset = 5;\n\tvar->blue.length = 5;\n\tvar->transp.offset = var->transp.length = 0;\n\n\tif (bgr) {\n\t\tvar->red.offset = 0;\n\t\tvar->blue.offset = 11;\n\t} else {\n\t\tvar->red.offset = 11;\n\t\tvar->blue.offset = 0;\n\t}\n\n\tvar->nonstd = 0;\n\tvar->height = -1;\n\tvar->width = -1;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\tvar->sync = 0;\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_setcolreg\n *\tSets a color in our virtual palette\n */\n", "func_signal": "static int ubicom32vfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)", "code": "{\n\tu32 *palette = fbi->pseudo_palette;\n\n\tif (regno >= PALETTE_ENTRIES_NO) {\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * We only use 8 bits from each color\n\t */\n\tred >>= 8;\n\tgreen >>= 8;\n\tblue >>= 8;\n\n\t/*\n\t * Convert any grayscale values\n\t */\n\tif (fbi->var.grayscale) {\n\t\tu16 gray = red + green + blue;\n\t\tgray += (gray >> 2) + (gray >> 3) - (gray >> 7);\n\t\tgray >>= 2;\n\t\tif (gray > 255) {\n\t\t\tgray = 255;\n\t\t}\n\t\tred = gray;\n\t\tblue = gray;\n\t\tgreen = gray;\n\t}\n\n\tpalette[regno] = (red << fbi->var.red.offset) | (green << fbi->var.green.offset) |\n\t\t\t (blue << fbi->var.blue.offset);\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciLocalDevNumGet - Get PCI interface local device number.\n*\n* DESCRIPTION:\n*       This function gets the local device number of a given PCI interface.\n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       Local device number. 0xffffffff on Error\n*\n*******************************************************************************/\n", "func_signal": "MV_U32 mvPciIfLocalDevNumGet(MV_U32 pciIf)", "code": "{\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciLocalDevNumGet(pciIf - MV_PCI_START_IF);\n\t\t#else\n\t\treturn 0xFFFFFFFF;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexLocalDevNumGet(pciIf - MV_PEX_START_IF);\n\t\t#else\n\t\treturn 0xFFFFFFFF;\n\t\t#endif\n\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn 0;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_mmap\n */\n", "func_signal": "static int ubicom32vfb_mmap(struct fb_info *info, struct vm_area_struct *vma)", "code": "{\n\tstruct ubicom32vfb_drvdata *ud = (struct ubicom32vfb_drvdata *)info->par;\n\n\tvma->vm_start = (unsigned long)(ud->fb_aligned);\n\n\tvma->vm_end = vma->vm_start + info->fix.smem_len;\n\n\t/* For those who don't understand how mmap works, go read\n\t *   Documentation/nommu-mmap.txt.\n\t * For those that do, you will know that the VM_MAYSHARE flag\n\t * must be set in the vma->vm_flags structure on noMMU\n\t *   Other flags can be set, and are documented in\n\t *   include/linux/mm.h\n\t */\n\n\tvma->vm_flags |=  VM_MAYSHARE | VM_SHARED;\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_release\n */\n", "func_signal": "static int ubicom32vfb_release(struct device *dev)", "code": "{\n\tstruct ubicom32vfb_drvdata *ud = dev_get_drvdata(dev);\n\n\tunregister_framebuffer(ud->fbinfo);\n\n\tif (ud->cmap_alloc) {\n\t\tfb_dealloc_cmap(&ud->fbinfo->cmap);\n\t}\n\n\tif (ud->fb) {\n\t\tkfree(ud->fb);\n\t}\n\n\tframebuffer_release(ud->fbinfo);\n\tdev_set_drvdata(dev, NULL);\n\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciMasterEnable - Enable/disale PCI interface master transactions.\n*\n* DESCRIPTION:\n*       This function performs read modified write to PCI command status \n*       (offset 0x4) to set/reset bit 2. After this bit is set, the PCI \n*       master is allowed to gain ownership on the bus, otherwise it is \n*       incapable to do so.\n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*       enable - Enable/disable parameter.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK\n*\n*******************************************************************************/\n", "func_signal": "MV_STATUS mvPciIfMasterEnable(MV_U32 pciIf, MV_BOOL enable)", "code": "{\n\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciMasterEnable(pciIf - MV_PCI_START_IF,\n\t\t\t\t\t\t\t\tenable);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexMasterEnable(pciIf - MV_PEX_START_IF,\n\t\t\t\t\t\t\t\tenable);\n\t\t#else\n\t\treturn MV_OK;\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\", __FUNCTION__, pciIf);\n\t}\n\n\treturn MV_FAIL;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_platform_probe\n */\n", "func_signal": "static int __init ubicom32vfb_platform_probe(struct platform_device *pdev)", "code": "{\n\tstruct ubicom32vfb_drvdata *ud;\n\tstruct fb_info *fbinfo;\n\tint rc;\n\tsize_t fbsize;\n\tstruct device *dev = &pdev->dev;\n\tint offset;\n\n\t/*\n\t * This is the minimum VRAM size\n\t */\n\tfbsize = xres * yres * 2;\n\tif (!vram_size) {\n\t\tvram_size = (fbsize + 1023) / 1024;\n\t} else {\n\t\tif (fbsize > (vram_size * 1024)) {\n\t\t\tdev_err(dev, \"Not enough VRAM for display, need >= %u bytes\\n\", fbsize);\n\t\t\treturn -ENOMEM; // should be ebadparam?\n\t\t}\n\t}\n\n\t/*\n\t * Allocate the framebuffer instance + our private data\n\t */\n\tfbinfo = framebuffer_alloc(sizeof(struct ubicom32vfb_drvdata), &pdev->dev);\n\tif (!fbinfo) {\n\t\tdev_err(dev, \"Not enough memory to allocate instance.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Fill in our private data.\n\t */\n\tud = (struct ubicom32vfb_drvdata *)fbinfo->par;\n\tud->fbinfo = fbinfo;\n\tdev_set_drvdata(dev, ud);\n\n\t/*\n\t * Allocate and align the requested amount of VRAM\n\t */\n\tud->total_vram_size = (vram_size * 1024) + UBICOM32VFB_ALIGNMENT;\n\tud->fb = kmalloc(ud->total_vram_size, GFP_KERNEL);\n\tif (ud->fb == NULL) {\n\t\tdev_err(dev, \"Couldn't allocate VRAM\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\toffset = (u32_t)ud->fb & (UBICOM32VFB_ALIGNMENT - 1);\n\tif (!offset) {\n\t\tud->fb_aligned = ud->fb;\n\t} else {\n\t\toffset =  UBICOM32VFB_ALIGNMENT - offset;\n\t\tud->fb_aligned = ud->fb + offset;\n\t}\n\n\t/*\n\t * Clear the entire frame buffer\n\t */\n\tmemset(ud->fb_aligned, 0, vram_size * 1024);\n\n\t/*\n\t * Fill in the fb_var_screeninfo structure\n\t */\n\tmemset(&ubicom32vfb_var, 0, sizeof(ubicom32vfb_var));\n\tubicom32vfb_var.bits_per_pixel = BITS_PER_PIXEL;\n\tubicom32vfb_var.red.length = 5;\n\tubicom32vfb_var.green.length = 6;\n\tubicom32vfb_var.green.offset = 5;\n\tubicom32vfb_var.blue.length = 5;\n\tubicom32vfb_var.activate = FB_ACTIVATE_NOW;\n\n\tif (bgr) {\n\t\tubicom32vfb_var.red.offset = 0;\n\t\tubicom32vfb_var.blue.offset = 11;\n\t} else {\n\t\tubicom32vfb_var.red.offset = 11;\n\t\tubicom32vfb_var.blue.offset = 0;\n\t}\n\n\t/*\n\t * Fill in the fb_info structure\n\t */\n\tud->fbinfo->device = dev;\n\tud->fbinfo->screen_base = (void *)ud->fb_aligned;\n\tud->fbinfo->fbops = &ubicom32vfb_ops;\n\tud->fbinfo->fix = ubicom32vfb_fix;\n\tud->fbinfo->fix.smem_start = (u32)ud->fb_aligned;\n\tud->fbinfo->fix.smem_len = vram_size * 1024;\n\tud->fbinfo->fix.line_length = xres * 2;\n\tud->fbinfo->fix.mmio_start = (u32)ud;\n\tud->fbinfo->fix.mmio_len = sizeof(struct ubicom32vfb_drvdata);\n\n\t/*\n\t * We support panning in the y direction only\n\t */\n\tud->fbinfo->fix.xpanstep = 0;\n\tud->fbinfo->fix.ypanstep = 1;\n\n\tud->fbinfo->pseudo_palette = ud->pseudo_palette;\n\tud->fbinfo->flags = FBINFO_DEFAULT;\n\tud->fbinfo->var = ubicom32vfb_var;\n\tud->fbinfo->var.xres = xres;\n\tud->fbinfo->var.yres = yres;\n\n\t/*\n\t * We cannot pan in the X direction, so xres_virtual is xres\n\t * We can pan in the Y direction, so yres_virtual is vram_size / ud->fbinfo->fix.line_length\n\t */\n\tud->fbinfo->var.xres_virtual = xres;\n\tud->fbinfo->var.yres_virtual = (vram_size * 1024) / ud->fbinfo->fix.line_length;\n\n\t/*\n\t * Allocate a color map\n\t */\n\trc = fb_alloc_cmap(&ud->fbinfo->cmap, PALETTE_ENTRIES_NO, 0);\n\tif (rc) {\n\t\tdev_err(dev, \"Fail to allocate colormap (%d entries)\\n\",\n\t\t\tPALETTE_ENTRIES_NO);\n\t\tgoto fail;\n\t}\n\tud->cmap_alloc = true;\n\n\t/*\n\t * Register new frame buffer\n\t */\n\trc = register_framebuffer(ud->fbinfo);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not register frame buffer\\n\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Tell the log we are here\n\t */\n\tdev_info(dev, \"fbaddr=%p align=%p, size=%uKB screen(%ux%u) virt(%ux%u)\\n\",\n\t\tud->fb, ud->fb_aligned, vram_size, ud->fbinfo->var.xres, ud->fbinfo->var.yres,\n\t\tud->fbinfo->var.xres_virtual, ud->fbinfo->var.yres_virtual);\n\n\t/*\n\t * Success\n\t */\n\treturn 0;\n\nfail:\n\tubicom32vfb_release(dev);\n\treturn rc;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*******************************************************************************\n* mvPciLocalBusNumGet - Get PCI interface local bus number.\n*\n* DESCRIPTION:\n*       This function gets the local bus number of a given PCI interface.\n*\n* INPUT:\n*       pciIf  - PCI interface number.\n*\n* OUTPUT:\n*       None.\n*\n* RETURN:\n*       Local bus number.0xffffffff on Error\n*\n*******************************************************************************/\n", "func_signal": "MV_U32 mvPciIfLocalBusNumGet(MV_U32 pciIf)", "code": "{\n\tPCI_IF_TYPE pciIfType = mvPciIfTypeGet(pciIf);\n\n\tif (PCI_IF_TYPE_CONVEN_PCIX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PCI)\n\t\treturn mvPciLocalBusNumGet(pciIf - MV_PCI_START_IF);\n\t\t#else\n\t\treturn 0xFFFFFFFF;\n\t\t#endif\n\t}\n\telse if (PCI_IF_TYPE_PEX == pciIfType)\n\t{\n\t\t#if defined(MV_INCLUDE_PEX)\n\t\treturn mvPexLocalBusNumGet(pciIf - MV_PEX_START_IF);\n\t\t#else\n\t\treturn 0xFFFFFFFF;\n\t\t#endif\n\n\t}\n\telse\n\t{\n\t\tmvOsPrintf(\"%s: ERROR!!! Invalid pciIf %d\\n\",__FUNCTION__, pciIf);\n\t}\n\n\treturn 0;\n\n}", "path": "target\\linux\\generic\\files\\crypto\\ocf\\kirkwood\\mvHal\\mv_hal\\pci-if\\mvPciIf.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/*\n * ubicom32vfb_setup\n *\tProcess kernel boot options\n */\n", "func_signal": "static int __init ubicom32vfb_setup(char *options)", "code": "{\n\tchar *this_opt;\n\n\tif (!options || !*options) {\n\t\treturn 0;\n\t}\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\tif (!*this_opt) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(this_opt, \"vram_size=\", 10)) {\n\t\t\tvram_size = simple_strtoul(this_opt + 10, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(this_opt, \"bgr=\", 4)) {\n\t\t\tbgr = simple_strtoul(this_opt + 4, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(this_opt, \"xres=\", 5)) {\n\t\t\txres = simple_strtoul(this_opt + 5, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(this_opt, \"yres=\", 5)) {\n\t\t\tyres = simple_strtoul(this_opt + 5, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "target\\linux\\ubicom32\\files\\drivers\\video\\ubicom32vfb.c", "repo_name": "derlunz/openwrt-raspberrypi", "stars": 21, "license": "gpl-2.0", "language": "c", "size": 84020}
{"docstring": "/* This should grow an order= keyword to be consistent\n */\n", "func_signal": "static PyObject *\narray_tofile(PyArrayObject *self, PyObject *args, PyObject *kwds)", "code": "{\n    int ret;\n    PyObject *file;\n    FILE *fd;\n    char *sep = \"\";\n    char *format = \"\";\n    static char *kwlist[] = {\"file\", \"sep\", \"format\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|ss\", kwlist,\n                                     &file, &sep, &format)) {\n        return NULL;\n    }\n\n    if (PyBytes_Check(file) || PyUnicode_Check(file)) {\n        file = npy_PyFile_OpenFile(file, \"wb\");\n        if (file == NULL) {\n            return NULL;\n        }\n    }\n    else {\n        Py_INCREF(file);\n    }\n#if defined(NPY_PY3K)\n    fd = npy_PyFile_Dup(file, \"wb\");\n#else\n    fd = PyFile_AsFile(file);\n#endif\n    if (fd == NULL) {\n        PyErr_SetString(PyExc_IOError, \"first argument must be a \" \\\n                        \"string or open file\");\n        Py_DECREF(file);\n        return NULL;\n    }\n    ret = PyArray_ToFile(self, fd, sep, format);\n#if defined(NPY_PY3K)\n    fclose(fd);\n#endif\n    Py_DECREF(file);\n    if (ret < 0) {\n        return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * Sets core_num_dim_ix, core_num_dims, core_dim_ixs, core_offsets,\n * and core_signature in PyUFuncObject \"self\".  Returns 0 unless an\n * error occured.\n */\n", "func_signal": "static int\n_parse_signature(NpyUFuncObject *self, const char *signature)", "code": "{\n    size_t len;\n    char const **var_names;\n    int nd = 0;             /* number of dimension of the current argument */\n    int cur_arg = 0;        /* index into core_num_dims&core_offsets */\n    int cur_core_dim = 0;   /* index into core_dim_ixs */\n    int i = 0;\n    char *parse_error = NULL;\n\n    if (signature == NULL) {\n        NpyErr_SetString(NpyExc_RuntimeError,\n                         \"_parse_signature with NULL signature\");\n        return -1;\n    }\n\n    len = strlen(signature);\n    self->core_signature = malloc(sizeof(char) * (len+1));\n    if (self->core_signature) {\n        strcpy(self->core_signature, signature);\n    }\n    /* Allocate sufficient memory to store pointers to all dimension names */\n    var_names = malloc(sizeof(char const*) * len);\n    if (var_names == NULL) {\n        NpyErr_MEMORY;\n        return -1;\n    }\n\n    self->core_enabled = 1;\n    self->core_num_dim_ix = 0;\n    self->core_num_dims = malloc(sizeof(int) * self->nargs);\n    self->core_dim_ixs = malloc(sizeof(int) * len); /* shrink this later */\n    self->core_offsets = malloc(sizeof(int) * self->nargs);\n    if (self->core_num_dims == NULL || self->core_dim_ixs == NULL\n        || self->core_offsets == NULL) {\n        NpyErr_MEMORY;\n        goto fail;\n    }\n\n    i = _next_non_white_space(signature, 0);\n    while (signature[i] != '\\0') {\n        /* loop over input/output arguments */\n        if (cur_arg == self->nin) {\n            /* expect \"->\" */\n            if (signature[i] != '-' || signature[i+1] != '>') {\n                parse_error = \"expect '->'\";\n                goto fail;\n            }\n            i = _next_non_white_space(signature, i + 2);\n        }\n\n        /*\n         * parse core dimensions of one argument,\n         * e.g. \"()\", \"(i)\", or \"(i,j)\"\n         */\n        if (signature[i] != '(') {\n            parse_error = \"expect '('\";\n            goto fail;\n        }\n        i = _next_non_white_space(signature, i + 1);\n        while (signature[i] != ')') {\n            /* loop over core dimensions */\n            int j = 0;\n            if (!_is_alpha_underscore(signature[i])) {\n                parse_error = \"expect dimension name\";\n                goto fail;\n            }\n            while (j < self->core_num_dim_ix) {\n                if (_is_same_name(signature+i, var_names[j])) {\n                    break;\n                }\n                j++;\n            }\n            if (j >= self->core_num_dim_ix) {\n                var_names[j] = signature+i;\n                self->core_num_dim_ix++;\n            }\n            self->core_dim_ixs[cur_core_dim] = j;\n            cur_core_dim++;\n            nd++;\n            i = _get_end_of_name(signature, i);\n            i = _next_non_white_space(signature, i);\n            if (signature[i] != ',' && signature[i] != ')') {\n                parse_error = \"expect ',' or ')'\";\n                goto fail;\n            }\n            if (signature[i] == ',')\n            {\n                i = _next_non_white_space(signature, i + 1);\n                if (signature[i] == ')') {\n                    parse_error = \"',' must not be followed by ')'\";\n                    goto fail;\n                }\n            }\n        }\n        self->core_num_dims[cur_arg] = nd;\n        self->core_offsets[cur_arg] = cur_core_dim-nd;\n        cur_arg++;\n        nd = 0;\n\n        i = _next_non_white_space(signature, i + 1);\n        if (cur_arg != self->nin && cur_arg != self->nargs) {\n            /*\n             * The list of input arguments (or output arguments) was\n             * only read partially\n             */\n            if (signature[i] != ',') {\n                parse_error = \"expect ','\";\n                goto fail;\n            }\n            i = _next_non_white_space(signature, i + 1);\n        }\n    }\n    if (cur_arg != self->nargs) {\n        parse_error = \"incomplete signature: not all arguments found\";\n        goto fail;\n    }\n    self->core_dim_ixs = realloc(self->core_dim_ixs,\n                                 sizeof(int)*cur_core_dim);\n    /* check for trivial core-signature, e.g. \"(),()->()\" */\n    if (cur_core_dim == 0) {\n        self->core_enabled = 0;\n    }\n    free((void*)var_names);\n    return 0;\n\nfail:\n    free((void*)var_names);\n    if (parse_error) {\n        char *buf = malloc(sizeof(char) * (len + 200));\n        if (buf) {\n            sprintf(buf, \"%s at position %d in \\\"%s\\\"\",\n                    parse_error, i, signature);\n            NpyErr_SetString(NpyExc_ValueError, signature);\n            free(buf);\n        }\n        else {\n            NpyErr_MEMORY;\n        }\n    }\n    return -1;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * Concatenate the loop and core dimensions of\n * PyArrayMultiIterObject's iarg-th argument, to recover a full\n * dimension array (used for output arguments).\n */\n", "func_signal": "static npy_intp*\n_compute_output_dims(NpyUFuncLoopObject *loop, int iarg,\n                     int *out_nd, npy_intp *tmp_dims)", "code": "{\n    int i;\n    NpyUFuncObject *ufunc = loop->ufunc;\n\n    if (ufunc->core_enabled == 0) {\n        /* case of ufunc with trivial core-signature */\n        *out_nd = loop->iter->nd;\n        return loop->iter->dimensions;\n    }\n\n    *out_nd = loop->iter->nd + ufunc->core_num_dims[iarg];\n    if (*out_nd > NPY_MAXARGS) {\n        NpyErr_SetString(NpyExc_ValueError,\n                         \"dimension of output variable exceeds limit\");\n        return NULL;\n    }\n\n    /* copy loop dimensions */\n    memcpy(tmp_dims, loop->iter->dimensions, sizeof(npy_intp) * loop->iter->nd);\n\n    /* copy core dimension */\n    for (i = 0; i < ufunc->core_num_dims[iarg]; i++) {\n        tmp_dims[loop->iter->nd + i] = loop->core_dim_sizes[\n            1 + ufunc->core_dim_ixs[ufunc->core_offsets[iarg] + i]];\n    }\n    return tmp_dims;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*NUMPY_API*/\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_Dump(PyObject *self, PyObject *file, int protocol)", "code": "{\n    PyObject *cpick = NULL;\n    PyObject *ret;\n    if (protocol < 0) {\n        protocol = 2;\n    }\n\n#if defined(NPY_PY3K)\n    cpick = PyImport_ImportModule(\"pickle\");\n#else\n    cpick = PyImport_ImportModule(\"cPickle\");\n#endif\n    if (cpick == NULL) {\n        return -1;\n    }\n    if (PyBytes_Check(file) || PyUnicode_Check(file)) {\n        file = npy_PyFile_OpenFile(file, \"wb\");\n        if (file == NULL) {\n            return -1;\n        }\n    }\n    else {\n        Py_INCREF(file);\n    }\n    ret = PyObject_CallMethod(cpick, \"dump\", \"OOi\", self, file, protocol);\n    Py_XDECREF(ret);\n    Py_DECREF(file);\n    Py_DECREF(cpick);\n    if (PyErr_Occurred()) {\n        return -1;\n    }\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* Convert Array to flat list (using getitem) */\n", "func_signal": "static PyObject *\n_getlist_pkl(PyArrayObject *self)", "code": "{\n    PyObject *theobject;\n    NpyArrayIterObject *iter = NULL;\n    PyObject *list;\n    PyArray_GetItemFunc *getitem;\n\n    getitem = PyArray_DESCR(self)->f->getitem;\n    iter = NpyArray_IterNew(PyArray_ARRAY(self));\n    if (iter == NULL) {\n        return NULL;\n    }\n    list = PyList_New(iter->size);\n    if (list == NULL) {\n        Npy_DECREF(iter);\n        return NULL;\n    }\n    while (iter->index < iter->size) {\n        theobject = getitem(iter->dataptr, PyArray_ARRAY(self));\n        PyList_SET_ITEM(list, (int) iter->index, theobject);\n        NpyArray_ITER_NEXT(iter);\n    }\n    Npy_DECREF(iter);\n    return list;\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*NUMPY_API\n * Reshape\n */\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_Reshape(PyArrayObject *self, PyObject *shape)", "code": "{\n    PyObject *ret;\n    PyArray_Dims newdims;\n\n    if (!PyArray_IntpConverter(shape, &newdims)) {\n        return NULL;\n    }\n    ret = PyArray_Newshape(self, &newdims, PyArray_CORDER);\n    PyDimMem_FREE(newdims.ptr);\n    return ret;\n}", "path": "numpy\\core\\src\\multiarray\\shape.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*NUMPY_API*/\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_Dumps(PyObject *self, int protocol)", "code": "{\n    PyObject *cpick = NULL;\n    PyObject *ret;\n    if (protocol < 0) {\n        protocol = 2;\n    }\n#if defined(NPY_PY3K)\n    cpick = PyImport_ImportModule(\"pickle\");\n#else\n    cpick = PyImport_ImportModule(\"cPickle\");\n#endif\n    if (cpick == NULL) {\n        return NULL;\n    }\n    ret = PyObject_CallMethod(cpick, \"dumps\", \"Oi\", self, protocol);\n    Py_DECREF(cpick);\n    return ret;\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* Return typenumber from dtype2 unless it is NULL, then return\n   NPY_DOUBLE if dtype1->type_num is integer or bool\n   and dtype1->type_num otherwise.\n*/\n", "func_signal": "static int\n_get_type_num_double(NpyArray_Descr *dtype1, NpyArray_Descr *dtype2)", "code": "{\n    if (dtype2 != NULL) {\n        return dtype2->type_num;\n    }\n    /* For integer or bool data-types */\n    if (dtype1->type_num < NPY_FLOAT) {\n        return NPY_DOUBLE;\n    }\n    else {\n        return dtype1->type_num;\n    }\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * Called for non-NULL user-defined functions.\n * The object should be a CObject pointing to a linked-list of functions\n * storing the function, data, and signature of all user-defined functions.\n * There must be a match with the input argument types or an error\n * will occur.\n */\n", "func_signal": "static int\n_find_matching_userloop(NpyUFunc_Loop1d *funcdata, int *arg_types,\n                        NPY_SCALARKIND *scalars,\n                        NpyUFuncGenericFunction *function, void **data,\n                        int nargs, int nin)", "code": "{\n    int i;\n\n    while (funcdata != NULL) {\n        for (i = 0; i < nin; i++) {\n            if (!NpyArray_CanCoerceScalar(arg_types[i],\n                                          funcdata->arg_types[i],\n                                          scalars[i]))\n                break;\n        }\n        if (i == nin) {\n            /* match found */\n            *function = funcdata->func;\n            *data = funcdata->data;\n            /* Make sure actual arg_types supported by the loop are used */\n            for (i = 0; i < nargs; i++) {\n                arg_types[i] = funcdata->arg_types[i];\n            }\n            return 0;\n        }\n        funcdata = funcdata->next;\n    }\n    return -1;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * We have two basic kinds of loops. One is used when arr is not-swapped\n * and aligned and output type is the same as input type.  The other uses\n * buffers when one of these is not satisfied.\n *\n *  Zero-length and one-length axes-to-be-reduced are handled separately.\n */\n", "func_signal": "NpyArray *\nNpyUFunc_Reduce(NpyUFuncObject *self, NpyArray *arr, NpyArray *out,\n               int axis, int otype)", "code": "{\n    NpyArray *ret = NULL;\n    NpyUFuncReduceObject *loop;\n    npy_intp i, n;\n    char *dptr;\n//    NPY_BEGIN_THREADS_DEF\n\n    assert(arr == NULL ||\n           (NPY_VALID_MAGIC == arr->nob_magic_number &&\n            NPY_VALID_MAGIC == NpyArray_DESCR(arr)->nob_magic_number));\n    assert(NPY_VALID_MAGIC == self->nob_magic_number);\n\n    /* Construct loop object */\n    loop = construct_reduce(self, &arr, out, axis, otype, NPY_UFUNC_REDUCE, 0);\n    if (!loop) {\n        return NULL;\n    }\n\n//    NPY_LOOP_BEGIN_THREADS;\n    switch(loop->meth) {\n        case ZERO_EL_REDUCELOOP:\n            /* fprintf(stderr, \"ZERO..%d\\n\", loop->size); */\n            for (i = 0; i < loop->size; i++) {\n                if (loop->obj & NPY_UFUNC_OBJ_ISOBJECT) {\n                    void** pDest = (void**)loop->bufptr[0];\n                    *pDest = NpyInterface_INCREF(*((void **)loop->idptr));\n                } else {\n                    memmove(loop->bufptr[0], loop->idptr, loop->outsize);\n                }\n                loop->bufptr[0] += loop->outsize;\n            }\n            break;\n        case ONE_EL_REDUCELOOP:\n            /*fprintf(stderr, \"ONEDIM..%d\\n\", loop->size); */\n            while (loop->index < loop->size) {\n                if (loop->obj & NPY_UFUNC_OBJ_ISOBJECT) {\n                    void** pDest = (void**)loop->bufptr[0];\n                    *pDest = NpyInterface_INCREF(*((void **)loop->it->dataptr));\n                } else {\n                    memmove(loop->bufptr[0], loop->it->dataptr, loop->outsize);\n                }\n                NpyArray_ITER_NEXT(loop->it);\n                loop->bufptr[0] += loop->outsize;\n                loop->index++;\n            }\n            break;\n        case NOBUFFER_UFUNCLOOP:\n            /*fprintf(stderr, \"NOBUFFER..%d\\n\", loop->size); */\n            while (loop->index < loop->size) {\n                /* Copy first element to output */\n                if (loop->obj & NPY_UFUNC_OBJ_ISOBJECT) {\n                    void** pDest = (void**)loop->bufptr[0];\n                    *pDest = NpyInterface_INCREF(*((void **)loop->it->dataptr));\n                } else {\n                    memmove(loop->bufptr[0], loop->it->dataptr, loop->outsize);\n                }\n                /* Adjust input pointer */\n                loop->bufptr[1] = loop->it->dataptr+loop->steps[1];\n                loop->function((char **)loop->bufptr, &(loop->N),\n                               loop->steps, loop->funcdata);\n                NPY_UFUNC_CHECK_ERROR(loop);\n                NpyArray_ITER_NEXT(loop->it);\n                loop->bufptr[0] += loop->outsize;\n                loop->bufptr[2] = loop->bufptr[0];\n                loop->index++;\n            }\n            break;\n        case BUFFER_UFUNCLOOP:\n            /*\n             * use buffer for arr\n             *\n             * For each row to reduce\n             * 1. copy first item over to output (casting if necessary)\n             * 2. Fill inner buffer\n             * 3. When buffer is filled or end of row\n             * a. Cast input buffers if needed\n             * b. Call inner function.\n             * 4. Repeat 2 until row is done.\n             */\n            /* fprintf(stderr, \"BUFFERED..%d %d\\n\", loop->size, loop->swap); */\n            while(loop->index < loop->size) {\n                loop->inptr = loop->it->dataptr;\n                /* Copy (cast) First term over to output */\n                if (loop->cast) {\n                    /* A little tricky because we need to cast it first */\n                    NpyArray_DESCR(arr)->f->copyswap(loop->buffer, loop->inptr,\n                                                     loop->swap, NULL);\n                    loop->cast(loop->buffer, loop->castbuf, 1, NULL, NULL);\n                    if ((loop->obj & NPY_UFUNC_OBJ_ISOBJECT) &&\n                        !NpyArray_ISOBJECT(arr)) {\n                        /*\n                         * In this case the cast function is creating\n                         * an object reference so we need to incref\n                         * it since we care copying it to bufptr[0].\n                         */\n                        void** pDest = (void**)loop->bufptr[0];\n                        *pDest = NpyInterface_INCREF(*((void **)loop->castbuf));\n                    } else {\n                        memcpy(loop->bufptr[0], loop->castbuf, loop->outsize);\n                    }\n                }\n                else {\n                    /* Simple copy */\n                    NpyArray_DESCR(arr)->f->copyswap(loop->bufptr[0],\n                                                     loop->inptr,\n                                                     loop->swap, NULL);\n                }\n                loop->inptr += loop->instrides;\n                n = 1;\n                while(n < loop->N) {\n                    /* Copy up to loop->bufsize elements to buffer */\n                    dptr = loop->buffer;\n                    for (i = 0; i < loop->bufsize; i++, n++) {\n                        if (n == loop->N) {\n                            break;\n                        }\n                        NpyArray_DESCR(arr)->f->copyswap(dptr, loop->inptr,\n                                                         loop->swap, NULL);\n                        loop->inptr += loop->instrides;\n                        dptr += loop->insize;\n                    }\n                    if (loop->cast) {\n                        loop->cast(loop->buffer, loop->castbuf, i, NULL, NULL);\n                    }\n                    loop->function((char **)loop->bufptr, &i,\n                                   loop->steps, loop->funcdata);\n                    loop->bufptr[0] += loop->steps[0]*i;\n                    loop->bufptr[2] += loop->steps[2]*i;\n                    NPY_UFUNC_CHECK_ERROR(loop);\n                }\n                NpyArray_ITER_NEXT(loop->it);\n                loop->bufptr[0] += loop->outsize;\n                loop->bufptr[2] = loop->bufptr[0];\n                loop->index++;\n            }\n\n            if (loop->obj & NPY_UFUNC_OBJ_ISOBJECT) {\n                /*\n                 * DECREF left-over objects if buffering was used.\n                 * There are 2 cases here.\n                 * 1. The output is an object. In this case the\n                 * castfunc will produce objects and castbuf needs\n                 * to be decrefed.\n                 * 2. The input is an object array.  In this case\n                 * the copyswap will produce object references and\n                 * the buffer needs to be decrefed.\n                 */\n                if (!NpyArray_ISOBJECT(arr)) {\n                    for (i=0; i<loop->bufsize; i++) {\n                        NpyInterface_CLEAR(((void **)loop->castbuf)[i]);\n                    }\n                } else {\n                    for (i=0; i<loop->bufsize; i++) {\n                        NpyInterface_CLEAR(((void **)loop->buffer)[i]);\n                    }\n                }\n            }\n    }\n\n//    NPY_LOOP_END_THREADS;\n    /* Hang on to this reference -- will be decref'd with loop */\n    if (loop->retbase) {\n        ret = loop->ret->base_arr;\n        NpyArray_ForceUpdate(loop->ret);\n    }\n    else {\n        ret = loop->ret;\n    }\n    Npy_INCREF(ret);\n    ufuncreduce_dealloc(loop);\n    return ret;\n\nfail:\n//    NPY_LOOP_END_THREADS;\n    if (loop) {\n        ufuncreduce_dealloc(loop);\n    }\n    return NULL;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * Userloops dictionary implementation\n */\n", "func_signal": "static int\ncompare_ints(const void *a, const void *b)", "code": "{\n    if (a < b ) return -1;\n    else if ( a > b ) return 1;\n    return 0;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* default sub-type implementation */\n", "func_signal": "static PyObject *\narray_wraparray(PyArrayObject *self, PyObject *args)", "code": "{\n    PyObject *arr;\n\n    if (PyTuple_Size(args) < 1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"only accepts 1 argument\");\n        return NULL;\n    }\n    arr = PyTuple_GET_ITEM(args, 0);\n    if (arr == NULL) {\n        return NULL;\n    }\n    if (!PyArray_Check(arr)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can only be called with ndarray object\");\n        return NULL;\n    }\n\n    if (Py_TYPE(self) != Py_TYPE(arr)){\n        Npy_INCREF(PyArray_DESCR(arr));\n        RETURN_PYARRAY(NpyArray_NewView(PyArray_DESCR(arr),\n                                        PyArray_NDIM(arr),\n                                        PyArray_DIMS(arr),\n                                        PyArray_STRIDES(arr),\n                                        PyArray_ARRAY(arr), 0,\n                                        NPY_FALSE));\n    } else {\n        /*The type was set in __array_prepare__*/\n        Py_INCREF(arr);\n        return arr;\n    }\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* Return the position of next non-white-space char in the string */\n", "func_signal": "static int\n_next_non_white_space(const char* str, int offset)", "code": "{\n    int ret = offset;\n    while (str[ret] == ' ' || str[ret] == '\\t') {\n        ret++;\n    }\n    return ret;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/************************* copy_ND_array *******************************/\n", "func_signal": "extern\nint copy_ND_array(const PyArrayObject *arr, PyArrayObject *out)", "code": "{\n    F2PY_REPORT_ON_ARRAY_COPY_FROMARR;\n    return PyArray_CopyInto(out, (PyArrayObject *)arr);\n}", "path": "numpy\\f2py\\src\\fortranobject.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* save pointer of an allocatable array */\n", "func_signal": "static void set_data(char *d,npy_intp *f)", "code": "{  /* callback from Fortran */\n    if (*f)                               /* In fortran f=allocated(d) */\n        save_def->data = d;\n    else\n        save_def->data = NULL;\n    /* printf(\"set_data: d=%p,f=%d\\n\",d,*f); */\n}", "path": "numpy\\f2py\\src\\fortranobject.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*\n * Return the ending position of a variable name\n */\n", "func_signal": "static int\n_get_end_of_name(const char* str, int offset)", "code": "{\n    int ret = offset;\n    while (_is_alnum_underscore(str[ret])) {\n        ret++;\n    }\n    return ret;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* Fortran methods */\n", "func_signal": "static void\nfortran_dealloc(PyFortranObject *fp)", "code": "{\n    Py_XDECREF(fp->dict);\n    PyMem_Del(fp);\n}", "path": "numpy\\f2py\\src\\fortranobject.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/*NUMPY_API\n * Resize (reallocate data).  Only works if nothing else is referencing this\n * array and it is contiguous.  If refcheck is 0, then the reference count is\n * not checked and assumed to be 1.  You still must own this data and have no\n * weak-references and no base object.\n */\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int refcheck,\n               NPY_ORDER fortran)", "code": "{\n    intp newsize, oldsize;\n\n    oldsize = PyArray_SIZE(self);\n    newsize = NpyArray_MultiplyList(newshape->ptr, newshape->len);\n    if (newsize != oldsize) {\n        int refcnt;\n        if (refcheck) {\n            refcnt = Py_REFCNT(self);\n        } else {\n            refcnt = 1;\n        }\n            \n        if (refcnt > 2 || self->weakreflist != NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                    \"cannot resize an array references or is referenced\\n\"\\\n                    \"by another array in this way.  Use the resize function\");\n            return NULL;\n        }\n    }\n    if (NpyArray_Resize(PyArray_ARRAY(self), newshape, refcheck, fortran) != 0) {\n        return NULL;\n    }\n    if (newsize > oldsize && \n        NpyDataType_FLAGCHK(PyArray_DESCR(self), NPY_ITEM_REFCOUNT)) {\n        /* Fill with zeros. */\n        int n, k;\n        char *optr;\n        int elsize = PyArray_ITEMSIZE(self);\n        PyObject *zero = PyInt_FromLong(0);\n\n        optr = PyArray_BYTES(self) + oldsize*elsize;\n        n = newsize - oldsize;\n        for (k = 0; k < n; k++) {\n            _putzero((char *)optr, zero, PyArray_DESCR(self));\n            optr += elsize;\n        }\n        Py_DECREF(zero);\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}", "path": "numpy\\core\\src\\multiarray\\shape.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* Return a view of array \"ap\" with \"core_nd\" dimensions cut from tail. */\n", "func_signal": "static NpyArray *\n_trunc_coredim(NpyArray *ap, int core_nd)", "code": "{\n    NpyArray *ret;\n    int nd = NpyArray_NDIM(ap) - core_nd;\n\n    if (nd < 0) {\n        nd = 0;\n    }\n    /* The following code is basically taken from PyArray_Transpose */\n    /* NewFromDescr will steal this reference */\n    Npy_INCREF(ap->descr);\n    ret = NpyArray_NewFromDescr(ap->descr,\n                                nd, ap->dimensions,\n                                ap->strides,\n                                ap->data,\n                                ap->flags,\n                                NPY_FALSE, NULL, Npy_INTERFACE(ap));\n    if (ret == NULL) {\n        return NULL;\n    }\n    /* point at true owner of memory: */\n    NpyArray_BASE_ARRAY(ret) = ap;\n    Npy_INCREF(ap);\n    assert(NULL == NpyArray_BASE(ret));\n    NpyArray_UpdateFlags(ret, NPY_CONTIGUOUS | NPY_FORTRAN);\n    return ret;\n}", "path": "libndarray\\src\\npy_ufunc_object.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* steals typed reference */\n/*NUMPY_API\n  Get a subset of bytes from each element of the array\n*/\n", "func_signal": "NPY_NO_EXPORT PyObject *\nPyArray_GetField(PyArrayObject *self, PyArray_Descr *typed, int offset)", "code": "{\n    NpyArray_Descr *typedWrap;\n    \n    /* Move reference to the core object. */\n    PyArray_Descr_REF_TO_CORE(typed, typedWrap);\n    \n    RETURN_PYARRAY(NpyArray_GetField(PyArray_ARRAY(self), typedWrap, offset));\n}", "path": "numpy\\core\\src\\multiarray\\methods.c", "repo_name": "teoliphant/numpy-refactor", "stars": 20, "license": "bsd-3-clause", "language": "c", "size": 48938}
{"docstring": "/* buffersize event */\n/**\n * gst_event_new_buffer_size:\n * @format: buffer format\n * @minsize: minimum buffer size\n * @maxsize: maximum buffer size\n * @async: thread behavior\n *\n * Create a new buffersize event. The event is sent downstream and notifies\n * elements that they should provide a buffer of the specified dimensions.\n *\n * When the @async flag is set, a thread boundary is prefered.\n *\n * Returns: a new #GstEvent\n */\n", "func_signal": "GstEvent *\ngst_event_new_buffer_size (GstFormat format, gint64 minsize,\n    gint64 maxsize, gboolean async)", "code": "{\n  GstEvent *event;\n  GstStructure *structure;\n\n  GST_CAT_INFO (GST_CAT_EVENT,\n      \"creating buffersize format %s, minsize %\" G_GINT64_FORMAT\n      \", maxsize %\" G_GINT64_FORMAT \", async %d\", gst_format_get_name (format),\n      minsize, maxsize, async);\n\n  structure = gst_structure_empty_new (\"GstEventBufferSize\");\n  gst_structure_id_set (structure,\n      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n      GST_QUARK (MINSIZE), G_TYPE_INT64, minsize,\n      GST_QUARK (MAXSIZE), G_TYPE_INT64, maxsize,\n      GST_QUARK (ASYNC), G_TYPE_BOOLEAN, async, NULL);\n  event = gst_event_new_custom (GST_EVENT_BUFFERSIZE, structure);\n\n  return event;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_new_segment:\n * @event: The event to query\n * @update: A pointer to the update flag of the segment\n * @rate: A pointer to the rate of the segment\n * @format: A pointer to the format of the newsegment values\n * @start: A pointer to store the start value in\n * @stop: A pointer to store the stop value in\n * @position: A pointer to store the stream time in\n *\n * Get the update flag, rate, format, start, stop and position in the \n * newsegment event. In general, gst_event_parse_new_segment_full() should\n * be used instead of this, to also retrieve the applied_rate value of the\n * segment. See gst_event_new_new_segment_full() for a full description \n * of the newsegment event.\n */\n", "func_signal": "void\ngst_event_parse_new_segment (GstEvent * event, gboolean * update,\n    gdouble * rate, GstFormat * format, gint64 * start,\n    gint64 * stop, gint64 * position)", "code": "{\n  gst_event_parse_new_segment_full (event, update, rate, NULL, format, start,\n      stop, position);\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_new_tag:\n * @taglist: metadata list. The event will take ownership of @taglist.\n *\n * Generates a metadata tag event from the given @taglist.\n *\n * Returns: a new #GstEvent\n */\n", "func_signal": "GstEvent *\ngst_event_new_tag (GstTagList * taglist)", "code": "{\n  g_return_val_if_fail (taglist != NULL, NULL);\n\n  return gst_event_new_custom (GST_EVENT_TAG, (GstStructure *) taglist);\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_get_structure:\n * @event: The #GstEvent.\n *\n * Access the structure of the event.\n *\n * Returns: The structure of the event. The structure is still\n * owned by the event, which means that you should not free it and\n * that the pointer becomes invalid when you free the event.\n *\n * MT safe.\n */\n", "func_signal": "const GstStructure *\ngst_event_get_structure (GstEvent * event)", "code": "{\n  g_return_val_if_fail (GST_IS_EVENT (event), NULL);\n\n  return event->structure;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_type_get_flags:\n * @type: a #GstEventType\n *\n * Gets the #GstEventTypeFlags associated with @type.\n *\n * Returns: a #GstEventTypeFlags.\n */\n", "func_signal": "GstEventTypeFlags\ngst_event_type_get_flags (GstEventType type)", "code": "{\n  GstEventTypeFlags ret;\n\n  ret = type & ((1 << GST_EVENT_TYPE_SHIFT) - 1);\n\n  return ret;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_latency:\n * @event: The event to query\n * @latency: A pointer to store the latency in.\n *\n * Get the latency in the latency event.\n *\n * Since: 0.10.12\n */\n", "func_signal": "void\ngst_event_parse_latency (GstEvent * event, GstClockTime * latency)", "code": "{\n  const GstStructure *structure;\n\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_LATENCY);\n\n  structure = gst_event_get_structure (event);\n  if (latency)\n    *latency =\n        g_value_get_uint64 (gst_structure_id_get_value (structure,\n            GST_QUARK (LATENCY)));\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_set_seqnum:\n * @event: A #GstEvent.\n * @seqnum: A sequence number.\n *\n * Set the sequence number of a event.\n *\n * This function might be called by the creator of a event to indicate that the\n * event relates to other events or messages. See gst_event_get_seqnum() for\n * more information.\n *\n * MT safe.\n *\n * Since: 0.10.22\n */\n", "func_signal": "void\ngst_event_set_seqnum (GstEvent * event, guint32 seqnum)", "code": "{\n  g_return_if_fail (GST_IS_EVENT (event));\n\n  GST_EVENT_SEQNUM (event) = seqnum;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_new_navigation:\n * @structure: description of the event. The event will take ownership of the\n *     structure.\n *\n * Create a new navigation event from the given description.\n *\n * Returns: a new #GstEvent\n */\n", "func_signal": "GstEvent *\ngst_event_new_navigation (GstStructure * structure)", "code": "{\n  g_return_val_if_fail (structure != NULL, NULL);\n\n  return gst_event_new_custom (GST_EVENT_NAVIGATION, structure);\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_type_get_name:\n * @type: the event type\n *\n * Get a printable name for the given event type. Do not modify or free.\n *\n * Returns: a reference to the static name of the event.\n */\n", "func_signal": "const gchar *\ngst_event_type_get_name (GstEventType type)", "code": "{\n  gint i;\n\n  for (i = 0; event_quarks[i].name; i++) {\n    if (type == event_quarks[i].type)\n      return event_quarks[i].name;\n  }\n  return \"unknown\";\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_tag:\n * @event: a tag event\n * @taglist: pointer to metadata list\n *\n * Parses a tag @event and stores the results in the given @taglist location.\n */\n", "func_signal": "void\ngst_event_parse_tag (GstEvent * event, GstTagList ** taglist)", "code": "{\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TAG);\n\n  if (taglist)\n    *taglist = (GstTagList *) event->structure;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_new_latency:\n * @latency: the new latency value\n *\n * Create a new latency event. The event is sent upstream from the sinks and\n * notifies elements that they should add an additional @latency to the\n * timestamps before synchronising against the clock.\n *\n * The latency is mostly used in live sinks and is always expressed in\n * the time format.\n *\n * Returns: a new #GstEvent\n *\n * Since: 0.10.12\n */\n", "func_signal": "GstEvent *\ngst_event_new_latency (GstClockTime latency)", "code": "{\n  GstEvent *event;\n  GstStructure *structure;\n\n  GST_CAT_INFO (GST_CAT_EVENT,\n      \"creating latency event %\" GST_TIME_FORMAT, GST_TIME_ARGS (latency));\n\n  structure = gst_structure_empty_new (\"GstEventLatency\");\n  gst_structure_id_set (structure,\n      GST_QUARK (LATENCY), G_TYPE_UINT64, latency, NULL);\n  event = gst_event_new_custom (GST_EVENT_LATENCY, structure);\n\n  return event;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/* This algorithm differs from libc bsearch in the handling\n   of non-exact matches. */\n", "func_signal": "static gboolean\n_fc_bsearch (GArray * ary,\n    gint stride,\n    gint * ret,\n    GCompareDataFunc compare, gconstpointer sample, gpointer user_data)", "code": "{\n  gint first, last;\n  gint mid;\n  gint midsize;\n  gint cmp;\n  gint tx;\n\n  g_return_val_if_fail (compare, FALSE);\n\n  if (!ary->len) {\n    if (ret)\n      *ret = 0;\n    return FALSE;\n  }\n\n  first = 0;\n  last = ary->len - 1;\n\n  midsize = last - first;\n\n  while (midsize > 1) {\n    mid = first + midsize / 2;\n\n    cmp = (*compare) (sample, ary->data + mid * stride, user_data);\n\n    if (cmp == 0) {\n      /* if there are multiple matches then scan for the first match */\n      while (mid > 0 &&\n          (*compare) (sample, ary->data + (mid - 1) * stride, user_data) == 0)\n        --mid;\n\n      if (ret)\n        *ret = mid;\n      return TRUE;\n    }\n\n    if (cmp < 0)\n      last = mid - 1;\n    else\n      first = mid + 1;\n\n    midsize = last - first;\n  }\n\n  for (tx = first; tx <= last; tx++) {\n    cmp = (*compare) (sample, ary->data + tx * stride, user_data);\n\n    if (cmp < 0) {\n      if (ret)\n        *ret = tx;\n      return FALSE;\n    }\n    if (cmp == 0) {\n      if (ret)\n        *ret = tx;\n      return TRUE;\n    }\n  }\n\n  if (ret)\n    *ret = last + 1;\n  return FALSE;\n}", "path": "plugins\\indexers\\gstfileindex.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_seek:\n * @event: a seek event\n * @rate: result location for the rate\n * @format: result location for the stream format\n * @flags:  result location for the #GstSeekFlags\n * @start_type: result location for the #GstSeekType of the start position\n * @start: result location for the start postion expressed in @format\n * @stop_type:  result location for the #GstSeekType of the stop position\n * @stop: result location for the stop postion expressed in @format\n *\n * Parses a seek @event and stores the results in the given result locations.\n */\n", "func_signal": "void\ngst_event_parse_seek (GstEvent * event, gdouble * rate,\n    GstFormat * format, GstSeekFlags * flags, GstSeekType * start_type,\n    gint64 * start, GstSeekType * stop_type, gint64 * stop)", "code": "{\n  const GstStructure *structure;\n\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);\n\n  structure = gst_event_get_structure (event);\n  if (rate)\n    *rate =\n        g_value_get_double (gst_structure_id_get_value (structure,\n            GST_QUARK (RATE)));\n  if (format)\n    *format =\n        g_value_get_enum (gst_structure_id_get_value (structure,\n            GST_QUARK (FORMAT)));\n  if (flags)\n    *flags =\n        g_value_get_flags (gst_structure_id_get_value (structure,\n            GST_QUARK (FLAGS)));\n  if (start_type)\n    *start_type =\n        g_value_get_enum (gst_structure_id_get_value (structure,\n            GST_QUARK (CUR_TYPE)));\n  if (start)\n    *start =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (CUR)));\n  if (stop_type)\n    *stop_type =\n        g_value_get_enum (gst_structure_id_get_value (structure,\n            GST_QUARK (STOP_TYPE)));\n  if (stop)\n    *stop =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (STOP)));\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/*\n  We have to save the whole set of indexes into a single file\n  so it doesn't make sense to commit only a single writer.\n\n  i suggest:\n\n  gst_index_commit (index, -1);\n*/\n", "func_signal": "static void\ngst_file_index_commit (GstIndex * _index, gint _writer_id)", "code": "{\n  GstFileIndex *index = GST_FILE_INDEX (_index);\n  xmlDocPtr doc;\n  xmlNodePtr writers;\n  GError *err = NULL;\n  gchar *path;\n  GIOChannel *tocfile;\n\n  g_return_if_fail (index->location);\n  g_return_if_fail (!index->is_loaded);\n\n  GST_OBJECT_FLAG_UNSET (index, GST_INDEX_WRITABLE);\n\n  doc = xmlNewDoc ((xmlChar *) \"1.0\");\n  doc->xmlRootNode =\n      xmlNewDocNode (doc, NULL, (xmlChar *) \"gstfileindex\", NULL);\n  xmlSetProp (doc->xmlRootNode, (xmlChar *) \"version\", (xmlChar *) \"1\");\n\n  writers = xmlNewChild (doc->xmlRootNode, NULL, (xmlChar *) \"writers\", NULL);\n  g_hash_table_foreach (index->id_index,\n      (GHFunc) _file_index_id_save_xml, writers);\n\n  if (mkdir (index->location, 0777) && errno != EEXIST) {\n    GST_ERROR_OBJECT (index, \"mkdir %s: %s\", index->location,\n        g_strerror (errno));\n    return;\n  }\n\n  path = g_strdup_printf (\"%s/gstindex.xml\", index->location);\n  tocfile = g_io_channel_new_file (path, \"w\", &err);\n  g_free (path);\n  if (err) {\n    GST_ERROR_OBJECT (index, \"%s\", err->message);\n    return;\n  }\n\n  g_io_channel_set_encoding (tocfile, NULL, &err);\n  if (err) {\n    GST_ERROR_OBJECT (index, \"%s\", err->message);\n    return;\n  }\n\n  {\n    xmlChar *xmlmem;\n    int xmlsize;\n\n    xmlDocDumpMemory (doc, &xmlmem, &xmlsize);\n    g_io_channel_write_chars (tocfile, (gchar *) xmlmem, xmlsize, NULL, &err);\n    if (err) {\n      GST_ERROR_OBJECT (index, \"%s\", err->message);\n      return;\n    }\n    xmlFreeDoc (doc);\n    free (xmlmem);\n  }\n\n  g_io_channel_shutdown (tocfile, TRUE, &err);\n  if (err) {\n    GST_ERROR_OBJECT (index, \"%s\", err->message);\n    return;\n  }\n\n  g_io_channel_unref (tocfile);\n\n  g_hash_table_foreach (index->id_index,\n      (GHFunc) _file_index_id_save_entries, index->location);\n}", "path": "plugins\\indexers\\gstfileindex.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_has_name:\n * @event: The #GstEvent.\n * @name: name to check\n *\n * Checks if @event has the given @name. This function is usually used to\n * check the name of a custom event.\n *\n * Returns: %TRUE if @name matches the name of the event structure.\n *\n * Since: 0.10.20\n */\n", "func_signal": "gboolean\ngst_event_has_name (GstEvent * event, const gchar * name)", "code": "{\n  g_return_val_if_fail (GST_IS_EVENT (event), FALSE);\n\n  if (event->structure == NULL)\n    return FALSE;\n\n  return gst_structure_has_name (event->structure, name);\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_buffer_size:\n * @event: The event to query\n * @format: A pointer to store the format in\n * @minsize: A pointer to store the minsize in\n * @maxsize: A pointer to store the maxsize in\n * @async: A pointer to store the async-flag in\n *\n * Get the format, minsize, maxsize and async-flag in the buffersize event.\n */\n", "func_signal": "void\ngst_event_parse_buffer_size (GstEvent * event, GstFormat * format,\n    gint64 * minsize, gint64 * maxsize, gboolean * async)", "code": "{\n  const GstStructure *structure;\n\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_BUFFERSIZE);\n\n  structure = gst_event_get_structure (event);\n  if (format)\n    *format =\n        g_value_get_enum (gst_structure_id_get_value (structure,\n            GST_QUARK (FORMAT)));\n  if (minsize)\n    *minsize =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (MINSIZE)));\n  if (maxsize)\n    *maxsize =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (MAXSIZE)));\n  if (async)\n    *async =\n        g_value_get_boolean (gst_structure_id_get_value (structure,\n            GST_QUARK (ASYNC)));\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_new_new_segment:\n * @update: is this segment an update to a previous one\n * @rate: a new rate for playback\n * @format: The format of the segment values\n * @start: the start value of the segment\n * @stop: the stop value of the segment\n * @position: stream position\n *\n * Allocate a new newsegment event with the given format/values tripplets\n *\n * This method calls gst_event_new_new_segment_full() passing a default\n * value of 1.0 for applied_rate\n *\n * Returns: A new newsegment event.\n */\n", "func_signal": "GstEvent *\ngst_event_new_new_segment (gboolean update, gdouble rate, GstFormat format,\n    gint64 start, gint64 stop, gint64 position)", "code": "{\n  return gst_event_new_new_segment_full (update, rate, 1.0, format, start,\n      stop, position);\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_new_custom:\n * @type: The type of the new event\n * @structure: The structure for the event. The event will take ownership of\n * the structure.\n *\n * Create a new custom-typed event. This can be used for anything not\n * handled by other event-specific functions to pass an event to another\n * element.\n *\n * Make sure to allocate an event type with the #GST_EVENT_MAKE_TYPE macro,\n * assigning a free number and filling in the correct direction and\n * serialization flags.\n *\n * New custom events can also be created by subclassing the event type if\n * needed.\n *\n * Returns: The new custom event.\n */\n", "func_signal": "GstEvent *\ngst_event_new_custom (GstEventType type, GstStructure * structure)", "code": "{\n  GstEvent *event;\n\n  /* structure must not have a parent */\n  if (structure)\n    g_return_val_if_fail (structure->parent_refcount == NULL, NULL);\n\n  event = gst_event_new (type);\n  if (structure) {\n    gst_structure_set_parent_refcount (structure, &event->mini_object.refcount);\n    event->structure = structure;\n  }\n  return event;\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_qos:\n * @event: The event to query\n * @proportion: A pointer to store the proportion in\n * @diff: A pointer to store the diff in\n * @timestamp: A pointer to store the timestamp in\n *\n * Get the proportion, diff and timestamp in the qos event. See\n * gst_event_new_qos() for more information about the different QoS values.\n */\n", "func_signal": "void\ngst_event_parse_qos (GstEvent * event, gdouble * proportion,\n    GstClockTimeDiff * diff, GstClockTime * timestamp)", "code": "{\n  const GstStructure *structure;\n\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_QOS);\n\n  structure = gst_event_get_structure (event);\n  if (proportion)\n    *proportion =\n        g_value_get_double (gst_structure_id_get_value (structure,\n            GST_QUARK (PROPORTION)));\n  if (diff)\n    *diff =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (DIFF)));\n  if (timestamp)\n    *timestamp =\n        g_value_get_uint64 (gst_structure_id_get_value (structure,\n            GST_QUARK (TIMESTAMP)));\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/**\n * gst_event_parse_new_segment_full:\n * @event: The event to query\n * @update: A pointer to the update flag of the segment\n * @rate: A pointer to the rate of the segment\n * @applied_rate: A pointer to the applied_rate of the segment\n * @format: A pointer to the format of the newsegment values\n * @start: A pointer to store the start value in\n * @stop: A pointer to store the stop value in\n * @position: A pointer to store the stream time in\n *\n * Get the update, rate, applied_rate, format, start, stop and \n * position in the newsegment event. See gst_event_new_new_segment_full() \n * for a full description of the newsegment event.\n *\n * Since: 0.10.6\n */\n", "func_signal": "void\ngst_event_parse_new_segment_full (GstEvent * event, gboolean * update,\n    gdouble * rate, gdouble * applied_rate, GstFormat * format,\n    gint64 * start, gint64 * stop, gint64 * position)", "code": "{\n  const GstStructure *structure;\n\n  g_return_if_fail (GST_IS_EVENT (event));\n  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_NEWSEGMENT);\n\n  structure = gst_event_get_structure (event);\n  if (G_LIKELY (update))\n    *update =\n        g_value_get_boolean (gst_structure_id_get_value (structure,\n            GST_QUARK (UPDATE)));\n  if (G_LIKELY (rate))\n    *rate =\n        g_value_get_double (gst_structure_id_get_value (structure,\n            GST_QUARK (RATE)));\n  if (G_LIKELY (applied_rate))\n    *applied_rate =\n        g_value_get_double (gst_structure_id_get_value (structure,\n            GST_QUARK (APPLIED_RATE)));\n  if (G_LIKELY (format))\n    *format =\n        g_value_get_enum (gst_structure_id_get_value (structure,\n            GST_QUARK (FORMAT)));\n  if (G_LIKELY (start))\n    *start =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (START)));\n  if (G_LIKELY (stop))\n    *stop =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (STOP)));\n  if (G_LIKELY (position))\n    *position =\n        g_value_get_int64 (gst_structure_id_get_value (structure,\n            GST_QUARK (POSITION)));\n}", "path": "gst\\gstevent.c", "repo_name": "prajnashi/gstreamer", "stars": 21, "license": "other", "language": "c", "size": 17810}
{"docstring": "/* Return the import directory from a PE file, or NULL on error.\n   (This is really the first import descriptor - there is no separate\n   directory, as with the exports.) */\n", "func_signal": "PIMAGE_IMPORT_DESCRIPTOR PeGetFirstImportDescriptor(PVOID PeFile)", "code": "{\n  PIMAGE_NT_HEADERS PeHeaders;\n\n  if (!(PeHeaders = PeGetNtHeaders(PeFile)))\n    return NULL;\n\n  return PeConvertRva(PeFile,\n    PeHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* The entry point - this is called when kexec.sys is loaded, and it\n   runs to completion before the associated userspace call to\n   StartService() returns, no matter what. */\n", "func_signal": "NTSTATUS DDKAPI DriverEntry(PDRIVER_OBJECT DriverObject,\n  PUNICODE_STRING RegistryPath KEXEC_UNUSED)", "code": "{\n  NTSTATUS status;\n  UNICODE_STRING DeviceName;\n  UNICODE_STRING SymlinkName;\n  PDEVICE_OBJECT DeviceObject;\n\n  DbgPrint(\"Loading kexec driver\\n\");\n\n  /* Allow kexec.sys to be unloaded. */\n  DriverObject->DriverUnload = DriverUnload;\n\n  /* Init the buffers. */\n  KexecInitBuffer(&KexecKernel);\n  KexecInitBuffer(&KexecInitrd);\n  KexecInitBuffer(&KexecKernelCommandLine);\n\n  RtlInitUnicodeString(&DeviceName, L\"\\\\Device\\\\Kexec\");\n  RtlInitUnicodeString(&SymlinkName, L\"\\\\??\\\\kexec\");\n\n  /* Register \\\\.\\kexec with the Windows kernel. */\n  status = IoCreateDevice(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN,\n    0, FALSE, &DeviceObject);\n  if (NT_SUCCESS(status)) {\n    /* Set our handlers for I/O operations on \\\\.\\kexec. */\n    DriverObject->MajorFunction[IRP_MJ_CREATE] = KexecOpen;\n    DriverObject->MajorFunction[IRP_MJ_CLOSE] = KexecClose;\n    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KexecIoctl;\n    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = KexecShutdown;\n    status = IoCreateSymbolicLink(&SymlinkName, &DeviceName);\n    if (NT_SUCCESS(status)) {\n      status = IoRegisterShutdownNotification(DeviceObject);\n      if (!NT_SUCCESS(status)) {\n        IoDeleteSymbolicLink(&SymlinkName);\n        IoDeleteDevice(DeviceObject);\n      }\n    } else\n      IoDeleteDevice(DeviceObject);\n  }\n\n  return status;\n}", "path": "driver\\entry.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Get the KexecCommon error message. */\n", "func_signal": "KEXEC_DLLEXPORT const char* KxcGetErrorMessage(void)", "code": "{\n  if (KxcErrorOccurred())\n    return kxciLastErrorMsg;\n  else\n    return NULL;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Called before shutdown - use this chance to hook HalReturnToFirmware() */\n", "func_signal": "NTSTATUS DDKAPI KexecShutdown(PDEVICE_OBJECT DeviceObject KEXEC_UNUSED, PIRP Irp)", "code": "{\n  NTSTATUS status;\n\n  status = KexecHookReboot();\n\n  Irp->IoStatus.Status = status;\n  Irp->IoStatus.Information = 0;\n  IoCompleteRequest(Irp, IO_NO_INCREMENT);\n  return status;\n}", "path": "driver\\io.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Called just before kexec.sys is unloaded. */\n", "func_signal": "void DDKAPI DriverUnload(PDRIVER_OBJECT DriverObject)", "code": "{\n  UNICODE_STRING SymlinkName;\n\n  DbgPrint(\"Unloading kexec driver\\n\");\n\n  /* Unregister \\\\.\\kexec with the Windows kernel. */\n  RtlInitUnicodeString(&SymlinkName, L\"\\\\??\\\\kexec\");\n  IoDeleteSymbolicLink(&SymlinkName);\n  IoDeleteDevice(DriverObject->DeviceObject);\n\n  /* Don't waste kernel memory! */\n  KexecDestroyBuffer(&KexecKernel);\n  KexecDestroyBuffer(&KexecInitrd);\n  KexecDestroyBuffer(&KexecKernelCommandLine);\n}", "path": "driver\\entry.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Read a file into memory. */\n", "func_signal": "KEXEC_DLLEXPORT PVOID KxcLoadFile(const char* filename, DWORD* length)", "code": "{\n  HANDLE hFile;\n  PVOID buf;\n  DWORD filelen, readlen;\n\n  /* Open it... */\n  if ((hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE) {\n    KxciBuildErrorMessage(\"Failed to load file\");\n    return NULL;\n  }\n\n  /* ...get the size... */\n  if ((filelen = GetFileSize(hFile, NULL)) == INVALID_FILE_SIZE) {\n    KxciBuildErrorMessage(\"Failed to get file size\");\n    CloseHandle(hFile);\n    return NULL;\n  }\n\n  /* ...grab a buffer... */\n  if ((buf = malloc(filelen)) == NULL) {\n    snprintf(kxciLastErrorMsg, 255, \"%s: %s\", \"Could not allocate buffer for file\", strerror(errno));\n    kxciLastErrorMsg[255] = '\\0';\n    CloseHandle(hFile);\n    return NULL;\n  }\n  /* ...read it in... */\n  if (!ReadFile(hFile, buf, filelen, &readlen, NULL)) {\n    KxciBuildErrorMessage(\"Could not read file\");\n    CloseHandle(hFile);\n    return NULL;\n  }\n  assert(filelen == readlen);\n  /* ...and close it. */\n  CloseHandle(hFile);\n\n  *length = readlen;\n  return buf;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Return the PIMAGE_NT_HEADERS for a loaded PE file.\n   Returns NULL on error. */\n", "func_signal": "PIMAGE_NT_HEADERS PeGetNtHeaders(PVOID PeFile)", "code": "{\n  PIMAGE_NT_HEADERS PeHeaders;\n\n  /* Verify the MZ magic number. */\n  if (((PIMAGE_DOS_HEADER)PeFile)->e_magic != 0x5a4d)\n    return NULL;\n\n  /* Get to the PE header.\n     Verify the magic number (\"PE\\0\\0\") while we're here. */\n  PeHeaders = PeFile + ((PIMAGE_DOS_HEADER)PeFile)->e_lfanew;\n  if (PeHeaders->Signature != 0x00004550)\n    return NULL;\n\n  return PeHeaders;\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Convert a relative virtual address (RVA) into a usable pointer\n   into the raw PE file data.  Returns NULL on error. */\n", "func_signal": "PVOID PeConvertRva(PVOID PeFile, DWORD Rva)", "code": "{\n  PIMAGE_SECTION_HEADER RelevantSection;\n\n  if (!(RelevantSection = PeFindSectionHeaderForAddress(PeFile, Rva)))\n    return NULL;\n\n  return RelevantSection->PointerToRawData - RelevantSection->VirtualAddress +\n    PeFile + Rva;\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Is the kexec driver loaded? */\n", "func_signal": "KEXEC_DLLEXPORT BOOL KxcIsDriverLoaded(void)", "code": "{\n  SC_HANDLE Scm;\n  SC_HANDLE KexecService;\n  SERVICE_STATUS_PROCESS ServiceStatus;\n  BOOL retval;\n  DWORD ExtraBytes;\n\n  KxciResetErrorMessage();\n\n  Scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n  if (!Scm) {\n    KxciBuildErrorMessage(\"Could not open SCM\");\n    KxcReportErrorMsgbox(NULL);\n    exit(EXIT_FAILURE);\n  }\n\n  KexecService = OpenService(Scm, \"kexec\", SERVICE_ALL_ACCESS);\n  if (!KexecService) {\n    KxciBuildErrorMessage(\"Could not open the kexec service\");\n    KxcReportErrorMsgbox(NULL);\n    CloseServiceHandle(Scm);\n    exit(EXIT_FAILURE);\n  }\n\n  if (!QueryServiceStatusEx(KexecService, SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus,\n    sizeof(ServiceStatus), &ExtraBytes))\n  {\n    KxciBuildErrorMessage(\"Could not query the kexec service\");\n    KxcReportErrorMsgbox(NULL);\n    CloseServiceHandle(KexecService);\n    CloseServiceHandle(Scm);\n    exit(EXIT_FAILURE);\n  }\n\n  retval = (ServiceStatus.dwCurrentState == SERVICE_RUNNING);\n  CloseServiceHandle(KexecService);\n  CloseServiceHandle(Scm);\n  return retval;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Return a pointer to the first PE section header, or NULL on error. */\n", "func_signal": "PIMAGE_SECTION_HEADER PeGetFirstSectionHeader(PVOID PeFile)", "code": "{\n  if (!PeGetNtHeaders(PeFile))\n    return NULL;\n\n  return (PIMAGE_SECTION_HEADER)(PeGetNtHeaders(PeFile) + 1);\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Convenient wrapper around FormatMessage() and GetLastError() */\n", "func_signal": "static LPSTR KxciTranslateError(void)", "code": "{\n  static LPSTR msgbuf = NULL;\n\n  if (msgbuf) {\n    LocalFree(msgbuf);\n    msgbuf = NULL;\n  }\n\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,\n    NULL, GetLastError(), LANG_USER_DEFAULT, (LPSTR)&msgbuf, 0, NULL);\n\n  return msgbuf;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Handle an ioctl^H^H^H^H^HDeviceIoControl on /dev/^H^H^H^H^H\\\\.\\kexec */\n", "func_signal": "NTSTATUS DDKAPI KexecIoctl(PDEVICE_OBJECT DeviceObject KEXEC_UNUSED, PIRP Irp)", "code": "{\n  PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);\n  NTSTATUS status;\n  ULONG IoctlCode;\n  DWORD info;\n  PKEXEC_BUFFER buf;\n\n  status = STATUS_SUCCESS;\n\n  IoctlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;\n\n  /* Select the buffer we are operating on. */\n  switch (IoctlCode & KEXEC_BUFFER_MASK) {\n    case KEXEC_KERNEL:\n      buf = &KexecKernel;\n      break;\n    case KEXEC_INITRD:\n      buf = &KexecInitrd;\n      break;\n    case KEXEC_KERNEL_COMMAND_LINE:\n      buf = &KexecKernelCommandLine;\n      break;\n    default:\n      status = STATUS_INVALID_PARAMETER;\n      info = 0;\n      goto end;\n  }\n  /* Perform the requested operation. */\n  switch (IoctlCode & KEXEC_OPERATION_MASK) {\n    case KEXEC_SET:\n      status = KexecLoadBuffer(buf,\n        IrpStack->Parameters.DeviceIoControl.InputBufferLength,\n        Irp->AssociatedIrp.SystemBuffer);\n      info = 0;\n      break;\n    case KEXEC_GET:\n      status = KexecGetBuffer(buf,\n        IrpStack->Parameters.DeviceIoControl.OutputBufferLength,\n        Irp->AssociatedIrp.SystemBuffer, &info);\n      break;\n    case KEXEC_GET_SIZE:\n      if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(DWORD)) {\n        status = STATUS_INVALID_PARAMETER;\n        info = 0;\n      } else {\n        *(DWORD*)(Irp->AssociatedIrp.SystemBuffer) = KexecGetBufferSize(buf);\n        status = STATUS_SUCCESS;\n        info = sizeof(DWORD);\n      }\n      break;\n    default:\n      status = STATUS_INVALID_PARAMETER;\n      goto end;\n  }\n\n  /* Return the results. */\nend:\n  Irp->IoStatus.Status = status;\n  Irp->IoStatus.Information = info;\n  IoCompleteRequest(Irp, IO_NO_INCREMENT);\n  return status;\n}", "path": "driver\\io.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Report an error to stderr. */\n", "func_signal": "KEXEC_DLLEXPORT void KxcReportErrorStderr(void)", "code": "{\n  if (KxcErrorOccurred())\n    fprintf(stderr, \"%s\\n\", kxciLastErrorMsg);\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Return the address of an exported function, or NULL on error. */\n", "func_signal": "DWORD PeGetExportFunction(PVOID PeFile, PCHAR FunctionName)", "code": "{\n  PIMAGE_EXPORT_DIRECTORY ExportDirectory;\n  DWORD * Functions;\n  DWORD * Names;\n  WORD * Ordinals;\n  DWORD i;\n\n  if (!(ExportDirectory = PeGetExportDirectory(PeFile)))\n    return (DWORD)NULL;\n\n  Functions = PeConvertRva(PeFile, ExportDirectory->AddressOfFunctions);\n  Names = PeConvertRva(PeFile, ExportDirectory->AddressOfNames);\n  Ordinals = PeConvertRva(PeFile, ExportDirectory->AddressOfNameOrdinals);\n\n  for (i = 0; i < ExportDirectory->NumberOfFunctions; i++) {\n    if (!strcmp(PeConvertRva(PeFile, Names[i]), FunctionName))\n      return Functions[Ordinals[ExportDirectory->Base + i - 1]];\n  }\n  return (DWORD)NULL;\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Load kexec.sys into the kernel, if it isn't already. */\n", "func_signal": "KEXEC_DLLEXPORT BOOL KxcLoadDriver(void)", "code": "{\n  SC_HANDLE Scm;\n  SC_HANDLE KexecService;\n\n  KxciResetErrorMessage();\n\n  if (KxcIsDriverLoaded())\n    return TRUE;\n\n  Scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n  if (!Scm) {\n    KxciBuildErrorMessage(\"Could not open SCM\");\n    return FALSE;\n  }\n\n  KexecService = OpenService(Scm, \"kexec\", SERVICE_ALL_ACCESS);\n  if (!KexecService) {\n    KxciBuildErrorMessage(\"Could not open the kexec service\");\n    CloseServiceHandle(Scm);\n    return FALSE;\n  }\n\n  /* This does not return until DriverEntry() has completed in kexec.sys. */\n  if (!StartService(KexecService, 0, NULL)) {\n    KxciBuildErrorMessage(\"Could not start the kexec service\");\n    CloseServiceHandle(KexecService);\n    CloseServiceHandle(Scm);\n    return FALSE;\n  }\n\n  CloseServiceHandle(KexecService);\n  CloseServiceHandle(Scm);\n  return TRUE;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* If kexec.sys is loaded into the kernel, unload it. */\n", "func_signal": "KEXEC_DLLEXPORT BOOL KxcUnloadDriver(void)", "code": "{\n  SC_HANDLE Scm;\n  SC_HANDLE KexecService;\n  SERVICE_STATUS ServiceStatus;\n\n  KxciResetErrorMessage();\n\n  if (!KxcIsDriverLoaded())\n    return TRUE;\n\n  Scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n  if (!Scm) {\n    KxciBuildErrorMessage(\"Could not open SCM\");\n    return FALSE;\n  }\n\n  KexecService = OpenService(Scm, \"kexec\", SERVICE_ALL_ACCESS);\n  if (!KexecService) {\n    KxciBuildErrorMessage(\"Could not open the kexec service\");\n    CloseServiceHandle(Scm);\n    return FALSE;\n  }\n\n  /* This does not return until DriverUnload() has completed in kexec.sys. */\n  if (!ControlService(KexecService, SERVICE_CONTROL_STOP, &ServiceStatus)) {\n    KxciBuildErrorMessage(\"Could not stop the kexec service\");\n    CloseServiceHandle(KexecService);\n    CloseServiceHandle(Scm);\n    return FALSE;\n  }\n\n  CloseServiceHandle(KexecService);\n  CloseServiceHandle(Scm);\n  return TRUE;\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Return the address of the import pointer, or NULL on error. */\n", "func_signal": "DWORD PeGetImportPointer(PVOID PeFile, PCHAR DllName, PCHAR FunctionName)", "code": "{\n  PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;\n  PIMAGE_THUNK_DATA NameThunk, CallThunk;\n  PIMAGE_IMPORT_BY_NAME NamedImport;\n\n  if (!(ImportDescriptor = PeGetFirstImportDescriptor(PeFile)))\n    return (DWORD)NULL;\n\n  while (ImportDescriptor->Name) {\n    if (!strcasecmp(PeConvertRva(PeFile, ImportDescriptor->Name), DllName))\n      goto FoundDll;\n    ImportDescriptor++;\n  }\n  return (DWORD)NULL;\n\nFoundDll:\n  for (NameThunk = PeConvertRva(PeFile, ImportDescriptor->OriginalFirstThunk),\n       CallThunk = (PIMAGE_THUNK_DATA)ImportDescriptor->FirstThunk;\n    NameThunk->u1.AddressOfData; NameThunk++, CallThunk++)\n  {\n    NamedImport = PeConvertRva(PeFile, NameThunk->u1.AddressOfData);\n    if (!strcmp(NamedImport->Name, FunctionName))\n      return (DWORD)CallThunk;\n  }\n  return (DWORD)NULL;\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Called when \\\\.\\kexec is opened. */\n", "func_signal": "NTSTATUS DDKAPI KexecOpen(PDEVICE_OBJECT DeviceObject KEXEC_UNUSED, PIRP Irp)", "code": "{\n  Irp->IoStatus.Status = STATUS_SUCCESS;\n  Irp->IoStatus.Information = 0;\n  IoCompleteRequest(Irp, IO_NO_INCREMENT);\n  return STATUS_SUCCESS;\n}", "path": "driver\\io.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Report an error to stderr. */\n", "func_signal": "KEXEC_DLLEXPORT void KxcReportErrorMsgbox(HWND parent)", "code": "{\n  if (KxcErrorOccurred())\n    MessageBox(parent, kxciLastErrorMsg, \"KexecCommon\", MB_ICONERROR | MB_OK);\n}", "path": "clientdll\\KexecCommon.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/* Return a the number of PE section headers, or zero on error. */\n", "func_signal": "WORD PeGetSectionCount(PVOID PeFile)", "code": "{\n  if (!PeGetNtHeaders(PeFile))\n    return 0;\n\n  return PeGetNtHeaders(PeFile)->FileHeader.NumberOfSections;\n}", "path": "driver\\libpe.c", "repo_name": "Sha0/winkexec", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 332}
{"docstring": "/*\n *\tAC97 Reset\n */\n", "func_signal": "static int snd_ali_reset_5451(struct snd_ali *codec)", "code": "{\n\tstruct pci_dev *pci_dev;\n\tunsigned short wCount, wReg;\n\tunsigned int   dwVal;\n\t\n\tpci_dev = codec->pci_m1533;\n\tif (pci_dev) {\n\t\tpci_read_config_dword(pci_dev, 0x7c, &dwVal);\n\t\tpci_write_config_dword(pci_dev, 0x7c, dwVal | 0x08000000);\n\t\tudelay(5000);\n\t\tpci_read_config_dword(pci_dev, 0x7c, &dwVal);\n\t\tpci_write_config_dword(pci_dev, 0x7c, dwVal & 0xf7ffffff);\n\t\tudelay(5000);\n\t}\n\t\n\tpci_dev = codec->pci;\n\tpci_read_config_dword(pci_dev, 0x44, &dwVal);\n\tpci_write_config_dword(pci_dev, 0x44, dwVal | 0x000c0000);\n\tudelay(500);\n\tpci_read_config_dword(pci_dev, 0x44, &dwVal);\n\tpci_write_config_dword(pci_dev, 0x44, dwVal & 0xfffbffff);\n\tudelay(5000);\n\t\n\twCount = 200;\n\twhile(wCount--) {\n\t\twReg = snd_ali_codec_peek(codec, 0, AC97_POWERDOWN);\n\t\tif ((wReg & 0x000f) == 0x000f)\n\t\t\treturn 0;\n\t\tudelay(5000);\n\t}\n\n\t/* non-fatal if you have a non PM capable codec */\n\t/* snd_printk(KERN_WARNING \"ali5451: reset time out\\n\"); */\n\treturn 0;\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n**  Unregister I/O and register it with new name,\n**  based on Serial Number\n*/\n", "func_signal": "static int diva_bri_reregister_io(diva_os_xdi_adapter_t * a)", "code": "{\n\tint i;\n\n\tfor (i = 1; i < 3; i++) {\n\t\tdiva_os_register_io_port(a, 0, a->resources.pci.bar[i],\n\t\t\t\t\t a->resources.pci.length[i],\n\t\t\t\t\t &a->port_name[0], i);\n\t\ta->resources.pci.addr[i] = NULL;\n\t}\n\n\tsprintf(a->port_name, \"DIVA BRI %ld\",\n\t\t(long) a->xdi_adapter.serialNo);\n\n\tfor (i = 1; i < 3; i++) {\n\t\tif (diva_os_register_io_port(a, 1, a->resources.pci.bar[i],\n\t\t\t\t\t     a->resources.pci.length[i],\n\t\t\t\t\t     &a->port_name[0], i)) {\n\t\t\tDBG_ERR((\"A: failed to reregister BAR[%d]\", i))\n\t\t\treturn (-1);\n\t\t}\n\t\ta->resources.pci.addr[i] =\n\t\t    (void *) (unsigned long) a->resources.pci.bar[i];\n\t}\n\n\treturn (0);\n}", "path": "kernel\\drivers\\isdn\\hardware\\eicon\\os_bri.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* this function runs through the i2c-messages and prepares the data to be\n   sent through the saa7146. have a look at the specifications p. 122 ff\n   to understand this. it returns the number of u32s to send, or -1\n   in case of an error. */\n", "func_signal": "static int saa7146_i2c_msg_prepare(const struct i2c_msg *m, int num, __le32 *op)", "code": "{\n\tint h1, h2;\n\tint i, j, addr;\n\tint mem = 0, op_count = 0;\n\n\t/* first determine size of needed memory */\n\tfor(i = 0; i < num; i++) {\n\t\tmem += m[i].len + 1;\n\t}\n\n\t/* worst case: we need one u32 for three bytes to be send\n\t   plus one extra byte to address the device */\n\tmem = 1 + ((mem-1) / 3);\n\n\t/* we assume that op points to a memory of at least SAA7146_I2C_MEM bytes\n\t   size. if we exceed this limit... */\n\tif ( (4*mem) > SAA7146_I2C_MEM ) {\n//fm\t\tDEB_I2C((\"cannot prepare i2c-message.\\n\"));\n\t\treturn -ENOMEM;\n\t}\n\n\t/* be careful: clear out the i2c-mem first */\n\tmemset(op,0,sizeof(__le32)*mem);\n\n\t/* loop through all messages */\n\tfor(i = 0; i < num; i++) {\n\n\t\t/* insert the address of the i2c-slave.\n\t\t   note: we get 7 bit i2c-addresses,\n\t\t   so we have to perform a translation */\n\t\taddr = (m[i].addr*2) + ( (0 != (m[i].flags & I2C_M_RD)) ? 1 : 0);\n\t\th1 = op_count/3; h2 = op_count%3;\n\t\top[h1] |= cpu_to_le32(\t    (u8)addr << ((3-h2)*8));\n\t\top[h1] |= cpu_to_le32(SAA7146_I2C_START << ((3-h2)*2));\n\t\top_count++;\n\n\t\t/* loop through all bytes of message i */\n\t\tfor(j = 0; j < m[i].len; j++) {\n\t\t\t/* insert the data bytes */\n\t\t\th1 = op_count/3; h2 = op_count%3;\n\t\t\top[h1] |= cpu_to_le32( (u32)((u8)m[i].buf[j]) << ((3-h2)*8));\n\t\t\top[h1] |= cpu_to_le32(       SAA7146_I2C_CONT << ((3-h2)*2));\n\t\t\top_count++;\n\t\t}\n\n\t}\n\n\t/* have a look at the last byte inserted:\n\t  if it was: ...CONT change it to ...STOP */\n\th1 = (op_count-1)/3; h2 = (op_count-1)%3;\n\tif ( SAA7146_I2C_CONT == (0x3 & (le32_to_cpu(op[h1]) >> ((3-h2)*2))) ) {\n\t\top[h1] &= ~cpu_to_le32(0x2 << ((3-h2)*2));\n\t\top[h1] |= cpu_to_le32(SAA7146_I2C_STOP << ((3-h2)*2));\n\t}\n\n\t/* return the number of u32s to send */\n\treturn mem;\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* utility functions */\n", "func_signal": "static int saa7146_i2c_xfer(struct i2c_adapter* adapter, struct i2c_msg *msg, int num)", "code": "{\n\tstruct v4l2_device *v4l2_dev = i2c_get_adapdata(adapter);\n\tstruct saa7146_dev *dev = to_saa7146_dev(v4l2_dev);\n\n\t/* use helper function to transfer data */\n\treturn saa7146_i2c_transfer(dev, msg, num, adapter->retries);\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* proc for register dump */\n", "func_signal": "static void snd_ali_proc_read(struct snd_info_entry *entry,\n\t\t\t      struct snd_info_buffer *buf)", "code": "{\n\tstruct snd_ali *codec = entry->private_data;\n\tint i;\n\tfor (i = 0; i < 256 ; i+= 4)\n\t\tsnd_iprintf(buf, \"%02x: %08x\\n\", i, inl(ALI_REG(codec, i)));\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n *    S/PDIF Part\n */\n", "func_signal": "static void snd_ali_delay(struct snd_ali *codec,int interval)", "code": "{\n\tunsigned long  begintimer,currenttimer;\n\n\tbegintimer   = inl(ALI_REG(codec, ALI_STIMER));\n\tcurrenttimer = inl(ALI_REG(codec, ALI_STIMER));\n\n\twhile (currenttimer < begintimer + interval) {\n\t\tif (snd_ali_stimer_ready(codec) < 0)\n\t\t\tbreak;\n\t\tcurrenttimer = inl(ALI_REG(codec,  ALI_STIMER));\n\t\tcpu_relax();\n\t}\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n *  PCM part\n */\n", "func_signal": "static int snd_ali_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd)", "code": "{\n\tstruct snd_ali *codec = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tunsigned int what, whati, capture_flag;\n\tstruct snd_ali_voice *pvoice, *evoice;\n\tunsigned int val;\n\tint do_start;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tdo_start = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdo_start = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twhat = whati = capture_flag = 0;\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif ((struct snd_ali *) snd_pcm_substream_chip(s) == codec) {\n\t\t\tpvoice = s->runtime->private_data;\n\t\t\tevoice = pvoice->extra;\n\t\t\twhat |= 1 << (pvoice->number & 0x1f);\n\t\t\tif (evoice == NULL)\n\t\t\t\twhati |= 1 << (pvoice->number & 0x1f);\n\t\t\telse {\n\t\t\t\twhati |= 1 << (evoice->number & 0x1f);\n\t\t\t\twhat |= 1 << (evoice->number & 0x1f);\n\t\t\t}\n\t\t\tif (do_start) {\n\t\t\t\tpvoice->running = 1;\n\t\t\t\tif (evoice != NULL)\n\t\t\t\t\tevoice->running = 1;\n\t\t\t} else {\n\t\t\t\tpvoice->running = 0;\n\t\t\t\tif (evoice != NULL)\n\t\t\t\t\tevoice->running = 0;\n\t\t\t}\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\tif (pvoice->mode)\n\t\t\t\tcapture_flag = 1;\n\t\t}\n\t}\n\tspin_lock(&codec->reg_lock);\n\tif (!do_start)\n\t\toutl(what, ALI_REG(codec, ALI_STOP));\n\tval = inl(ALI_REG(codec, ALI_AINTEN));\n\tif (do_start)\n\t\tval |= whati;\n\telse\n\t\tval &= ~whati;\n\toutl(val, ALI_REG(codec, ALI_AINTEN));\n\tif (do_start)\n\t\toutl(what, ALI_REG(codec, ALI_START));\n\tsnd_ali_printk(\"trigger: what=%xh whati=%xh\\n\", what, whati);\n\tspin_unlock(&codec->reg_lock);\n\n\treturn 0;\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* PRISM2_NO_PROCFS_DEBUG */\n", "func_signal": "static int prism2_stats_proc_read(char *page, char **start, off_t off,\n\t\t\t\t  int count, int *eof, void *data)", "code": "{\n\tchar *p = page;\n\tlocal_info_t *local = (local_info_t *) data;\n\tstruct comm_tallies_sums *sums = (struct comm_tallies_sums *)\n\t\t&local->comm_tallies;\n\n\tif (off != 0) {\n\t\t*eof = 1;\n\t\treturn 0;\n\t}\n\n\tp += sprintf(p, \"TxUnicastFrames=%u\\n\", sums->tx_unicast_frames);\n\tp += sprintf(p, \"TxMulticastframes=%u\\n\", sums->tx_multicast_frames);\n\tp += sprintf(p, \"TxFragments=%u\\n\", sums->tx_fragments);\n\tp += sprintf(p, \"TxUnicastOctets=%u\\n\", sums->tx_unicast_octets);\n\tp += sprintf(p, \"TxMulticastOctets=%u\\n\", sums->tx_multicast_octets);\n\tp += sprintf(p, \"TxDeferredTransmissions=%u\\n\",\n\t\t     sums->tx_deferred_transmissions);\n\tp += sprintf(p, \"TxSingleRetryFrames=%u\\n\",\n\t\t     sums->tx_single_retry_frames);\n\tp += sprintf(p, \"TxMultipleRetryFrames=%u\\n\",\n\t\t     sums->tx_multiple_retry_frames);\n\tp += sprintf(p, \"TxRetryLimitExceeded=%u\\n\",\n\t\t     sums->tx_retry_limit_exceeded);\n\tp += sprintf(p, \"TxDiscards=%u\\n\", sums->tx_discards);\n\tp += sprintf(p, \"RxUnicastFrames=%u\\n\", sums->rx_unicast_frames);\n\tp += sprintf(p, \"RxMulticastFrames=%u\\n\", sums->rx_multicast_frames);\n\tp += sprintf(p, \"RxFragments=%u\\n\", sums->rx_fragments);\n\tp += sprintf(p, \"RxUnicastOctets=%u\\n\", sums->rx_unicast_octets);\n\tp += sprintf(p, \"RxMulticastOctets=%u\\n\", sums->rx_multicast_octets);\n\tp += sprintf(p, \"RxFCSErrors=%u\\n\", sums->rx_fcs_errors);\n\tp += sprintf(p, \"RxDiscardsNoBuffer=%u\\n\",\n\t\t     sums->rx_discards_no_buffer);\n\tp += sprintf(p, \"TxDiscardsWrongSA=%u\\n\", sums->tx_discards_wrong_sa);\n\tp += sprintf(p, \"RxDiscardsWEPUndecryptable=%u\\n\",\n\t\t     sums->rx_discards_wep_undecryptable);\n\tp += sprintf(p, \"RxMessageInMsgFragments=%u\\n\",\n\t\t     sums->rx_message_in_msg_fragments);\n\tp += sprintf(p, \"RxMessageInBadMsgFragments=%u\\n\",\n\t\t     sums->rx_message_in_bad_msg_fragments);\n\t/* FIX: this may grow too long for one page(?) */\n\n\treturn (p - page);\n}", "path": "kernel\\drivers\\net\\wireless\\hostap\\hostap_proc.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* this functions writes out the data-byte 'dword' to the i2c-device.\n   it returns 0 if ok, -1 if the transfer failed, -2 if the transfer\n   failed badly (e.g. address error) */\n", "func_signal": "static int saa7146_i2c_writeout(struct saa7146_dev *dev, __le32 *dword, int short_delay)", "code": "{\n\tu32 status = 0, mc2 = 0;\n\tint trial = 0;\n\tunsigned long timeout;\n\n\t/* write out i2c-command */\n\tDEB_I2C((\"before: 0x%08x (status: 0x%08x), %d\\n\",*dword,saa7146_read(dev, I2C_STATUS), dev->i2c_op));\n\n\tif( 0 != (SAA7146_USE_I2C_IRQ & dev->ext->flags)) {\n\n\t\tsaa7146_write(dev, I2C_STATUS,\t dev->i2c_bitrate);\n\t\tsaa7146_write(dev, I2C_TRANSFER, le32_to_cpu(*dword));\n\n\t\tdev->i2c_op = 1;\n\t\tSAA7146_ISR_CLEAR(dev, MASK_16|MASK_17);\n\t\tSAA7146_IER_ENABLE(dev, MASK_16|MASK_17);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\n\t\ttimeout = HZ/100 + 1; /* 10ms */\n\t\ttimeout = wait_event_interruptible_timeout(dev->i2c_wq, dev->i2c_op == 0, timeout);\n\t\tif (timeout == -ERESTARTSYS || dev->i2c_op) {\n\t\t\tSAA7146_IER_DISABLE(dev, MASK_16|MASK_17);\n\t\t\tSAA7146_ISR_CLEAR(dev, MASK_16|MASK_17);\n\t\t\tif (timeout == -ERESTARTSYS)\n\t\t\t\t/* a signal arrived */\n\t\t\t\treturn -ERESTARTSYS;\n\n\t\t\tprintk(KERN_WARNING \"%s %s [irq]: timed out waiting for end of xfer\\n\",\n\t\t\t\tdev->name, __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tstatus = saa7146_read(dev, I2C_STATUS);\n\t} else {\n\t\tsaa7146_write(dev, I2C_STATUS,\t dev->i2c_bitrate);\n\t\tsaa7146_write(dev, I2C_TRANSFER, le32_to_cpu(*dword));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\n\t\t/* do not poll for i2c-status before upload is complete */\n\t\ttimeout = jiffies + HZ/100 + 1; /* 10ms */\n\t\twhile(1) {\n\t\t\tmc2 = (saa7146_read(dev, MC2) & 0x1);\n\t\t\tif( 0 != mc2 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (time_after(jiffies,timeout)) {\n\t\t\t\tprintk(KERN_WARNING \"%s %s: timed out waiting for MC2\\n\",\n\t\t\t\t\tdev->name, __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\t/* wait until we get a transfer done or error */\n\t\ttimeout = jiffies + HZ/100 + 1; /* 10ms */\n\t\t/* first read usually delivers bogus results... */\n\t\tsaa7146_i2c_status(dev);\n\t\twhile(1) {\n\t\t\tstatus = saa7146_i2c_status(dev);\n\t\t\tif ((status & 0x3) != 1)\n\t\t\t\tbreak;\n\t\t\tif (time_after(jiffies,timeout)) {\n\t\t\t\t/* this is normal when probing the bus\n\t\t\t\t * (no answer from nonexisistant device...)\n\t\t\t\t */\n\t\t\t\tprintk(KERN_WARNING \"%s %s [poll]: timed out waiting for end of xfer\\n\",\n\t\t\t\t\tdev->name, __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (++trial < 50 && short_delay)\n\t\t\t\tudelay(10);\n\t\t\telse\n\t\t\t\tmsleep(1);\n\t\t}\n\t}\n\n\t/* give a detailed status report */\n\tif ( 0 != (status & (SAA7146_I2C_SPERR | SAA7146_I2C_APERR |\n\t\t\t     SAA7146_I2C_DTERR | SAA7146_I2C_DRERR |\n\t\t\t     SAA7146_I2C_AL    | SAA7146_I2C_ERR   |\n\t\t\t     SAA7146_I2C_BUSY)) ) {\n\n\t\tif ( 0 == (status & SAA7146_I2C_ERR) ||\n\t\t     0 == (status & SAA7146_I2C_BUSY) ) {\n\t\t\t/* it may take some time until ERR goes high - ignore */\n\t\t\tDEB_I2C((\"unexpected i2c status %04x\\n\", status));\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_SPERR) ) {\n\t\t\tDEB_I2C((\"error due to invalid start/stop condition.\\n\"));\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_DTERR) ) {\n\t\t\tDEB_I2C((\"error in data transmission.\\n\"));\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_DRERR) ) {\n\t\t\tDEB_I2C((\"error when receiving data.\\n\"));\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_AL) ) {\n\t\t\tDEB_I2C((\"error because arbitration lost.\\n\"));\n\t\t}\n\n\t\t/* we handle address-errors here */\n\t\tif( 0 != (status & SAA7146_I2C_APERR) ) {\n\t\t\tDEB_I2C((\"error in address phase.\\n\"));\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\treturn -EIO;\n\t}\n\n\t/* read back data, just in case we were reading ... */\n\t*dword = cpu_to_le32(saa7146_read(dev, I2C_TRANSFER));\n\n\tDEB_I2C((\"after: 0x%08x\\n\",*dword));\n\treturn 0;\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* this function returns the status-register of our i2c-device */\n", "func_signal": "static inline u32 saa7146_i2c_status(struct saa7146_dev *dev)", "code": "{\n\tu32 iicsta = saa7146_read(dev, I2C_STATUS);\n/*\n\tDEB_I2C((\"status: 0x%08x\\n\",iicsta));\n*/\n\treturn iicsta;\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n**  Stop card\n*/\n", "func_signal": "static int diva_bri_stop_adapter(diva_os_xdi_adapter_t * a)", "code": "{\n\tPISDN_ADAPTER IoAdapter = &a->xdi_adapter;\n\tint i = 100;\n\n\tif (!IoAdapter->port) {\n\t\treturn (-1);\n\t}\n\tif (!IoAdapter->Initialized) {\n\t\tDBG_ERR((\"A: A(%d) can't stop BRI adapter - not running\",\n\t\t\t IoAdapter->ANum))\n\t\treturn (-1);\t/* nothing to stop */\n\t}\n\tIoAdapter->Initialized = 0;\n\n\t/*\n\t   Disconnect Adapter from DIDD\n\t */\n\tdiva_xdi_didd_remove_adapter(IoAdapter->ANum);\n\n\t/*\n\t   Stop interrupts\n\t */\n\ta->clear_interrupts_proc = diva_bri_clear_interrupts;\n\tIoAdapter->a.ReadyInt = 1;\n\tIoAdapter->a.ram_inc(&IoAdapter->a, &PR_RAM->ReadyInt);\n\tdo {\n\t\tdiva_os_sleep(10);\n\t} while (i-- && a->clear_interrupts_proc);\n\tif (a->clear_interrupts_proc) {\n\t\tdiva_bri_clear_interrupts(a);\n\t\ta->clear_interrupts_proc = NULL;\n\t\tDBG_ERR((\"A: A(%d) no final interrupt from BRI adapter\",\n\t\t\t IoAdapter->ANum))\n\t}\n\tIoAdapter->a.ReadyInt = 0;\n\n\t/*\n\t   Stop and reset adapter\n\t */\n\tIoAdapter->stop(IoAdapter);\n\n\treturn (0);\n}", "path": "kernel\\drivers\\isdn\\hardware\\eicon\\os_bri.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n *  ALI 5451 Controller\n */\n", "func_signal": "static void snd_ali_enable_special_channel(struct snd_ali *codec,\n\t\t\t\t\t   unsigned int channel)", "code": "{\n\tunsigned long dwVal;\n\n\tdwVal  = inl(ALI_REG(codec, ALI_GLOBAL_CONTROL));\n\tdwVal |= 1 << (channel & 0x0000001f);\n\toutl(dwVal, ALI_REG(codec, ALI_GLOBAL_CONTROL));\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n**  Process command from user mode\n*/\n", "func_signal": "static int\ndiva_bri_cmd_card_proc(struct _diva_os_xdi_adapter *a,\n\t\t       diva_xdi_um_cfg_cmd_t * cmd, int length)", "code": "{\n\tint ret = -1;\n\n\tif (cmd->adapter != a->controller) {\n\t\tDBG_ERR((\"A: pri_cmd, invalid controller=%d != %d\",\n\t\t\t cmd->adapter, a->controller))\n\t\treturn (-1);\n\t}\n\n\tswitch (cmd->command) {\n\tcase DIVA_XDI_UM_CMD_GET_CARD_ORDINAL:\n\t\ta->xdi_mbox.data_length = sizeof(dword);\n\t\ta->xdi_mbox.data =\n\t\t    diva_os_malloc(0, a->xdi_mbox.data_length);\n\t\tif (a->xdi_mbox.data) {\n\t\t\t*(dword *) a->xdi_mbox.data =\n\t\t\t    (dword) a->CardOrdinal;\n\t\t\ta->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_GET_SERIAL_NR:\n\t\ta->xdi_mbox.data_length = sizeof(dword);\n\t\ta->xdi_mbox.data =\n\t\t    diva_os_malloc(0, a->xdi_mbox.data_length);\n\t\tif (a->xdi_mbox.data) {\n\t\t\t*(dword *) a->xdi_mbox.data =\n\t\t\t    (dword) a->xdi_adapter.serialNo;\n\t\t\ta->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_GET_PCI_HW_CONFIG:\n\t\ta->xdi_mbox.data_length = sizeof(dword) * 9;\n\t\ta->xdi_mbox.data =\n\t\t    diva_os_malloc(0, a->xdi_mbox.data_length);\n\t\tif (a->xdi_mbox.data) {\n\t\t\tint i;\n\t\t\tdword *data = (dword *) a->xdi_mbox.data;\n\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t*data++ = a->resources.pci.bar[i];\n\t\t\t}\n\t\t\t*data++ = (dword) a->resources.pci.irq;\n\t\t\ta->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_GET_CARD_STATE:\n\t\ta->xdi_mbox.data_length = sizeof(dword);\n\t\ta->xdi_mbox.data =\n\t\t    diva_os_malloc(0, a->xdi_mbox.data_length);\n\t\tif (a->xdi_mbox.data) {\n\t\t\tdword *data = (dword *) a->xdi_mbox.data;\n\t\t\tif (!a->xdi_adapter.port) {\n\t\t\t\t*data = 3;\n\t\t\t} else if (a->xdi_adapter.trapped) {\n\t\t\t\t*data = 2;\n\t\t\t} else if (a->xdi_adapter.Initialized) {\n\t\t\t\t*data = 1;\n\t\t\t} else {\n\t\t\t\t*data = 0;\n\t\t\t}\n\t\t\ta->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_RESET_ADAPTER:\n\t\tret = diva_bri_reset_adapter(&a->xdi_adapter);\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_WRITE_SDRAM_BLOCK:\n\t\tret = diva_bri_write_sdram_block(&a->xdi_adapter,\n\t\t\t\t\t\t cmd->command_data.\n\t\t\t\t\t\t write_sdram.offset,\n\t\t\t\t\t\t (byte *) & cmd[1],\n\t\t\t\t\t\t cmd->command_data.\n\t\t\t\t\t\t write_sdram.length);\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_START_ADAPTER:\n\t\tret = diva_bri_start_adapter(&a->xdi_adapter,\n\t\t\t\t\t     cmd->command_data.start.\n\t\t\t\t\t     offset,\n\t\t\t\t\t     cmd->command_data.start.\n\t\t\t\t\t     features);\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_SET_PROTOCOL_FEATURES:\n\t\ta->xdi_adapter.features =\n\t\t    cmd->command_data.features.features;\n\t\ta->xdi_adapter.a.protocol_capabilities =\n\t\t    a->xdi_adapter.features;\n\t\tDBG_TRC(\n\t\t\t(\"Set raw protocol features (%08x)\",\n\t\t\t a->xdi_adapter.features)) ret = 0;\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_STOP_ADAPTER:\n\t\tret = diva_bri_stop_adapter(a);\n\t\tbreak;\n\n\tcase DIVA_XDI_UM_CMD_READ_XLOG_ENTRY:\n\t\tret = diva_card_read_xlog(a);\n\t\tbreak;\n\n\tdefault:\n\t\tDBG_ERR(\n\t\t\t(\"A: A(%d) invalid cmd=%d\", a->controller,\n\t\t\t cmd->command))}\n\n\treturn (ret);\n}", "path": "kernel\\drivers\\isdn\\hardware\\eicon\\os_bri.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n * Modem PCM\n */\n", "func_signal": "static int snd_ali_modem_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)", "code": "{\n\tstruct snd_ali *chip = snd_pcm_substream_chip(substream);\n\tunsigned int modem_num = chip->num_of_codecs - 1;\n\tsnd_ac97_write(chip->ac97[modem_num], AC97_LINE1_RATE,\n\t\t       params_rate(hw_params));\n\tsnd_ac97_write(chip->ac97[modem_num], AC97_LINE1_LEVEL, 0);\n\treturn snd_ali_hw_params(substream, hw_params);\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* CONFIG_PM */\n", "func_signal": "static int snd_ali_free(struct snd_ali * codec)", "code": "{\n\tif (codec->hw_initialized)\n\t\tsnd_ali_disable_address_interrupt(codec);\n\tif (codec->irq >= 0)\n\t\tfree_irq(codec->irq, codec);\n\tif (codec->port)\n\t\tpci_release_regions(codec->pci);\n\tpci_disable_device(codec->pci);\n#ifdef CONFIG_PM\n\tkfree(codec->image);\n#endif\n\tpci_dev_put(codec->pci_m1533);\n\tpci_dev_put(codec->pci_m7101);\n\tkfree(codec);\n\treturn 0;\n}", "path": "kernel\\sound\\pci\\ali5451\\ali5451.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n**  Get serial number\n*/\n", "func_signal": "static dword diva_bri_get_serial_number(diva_os_xdi_adapter_t * a)", "code": "{\n\tdword serNo = 0;\n\tbyte __iomem *confIO;\n\tword serHi, serLo;\n\tword __iomem *confMem;\n\n\tconfIO = DIVA_OS_MEM_ATTACH_CFG(&a->xdi_adapter);\n\tserHi = (word) (inppw(&confIO[0x22]) & 0x0FFF);\n\tserLo = (word) (inppw(&confIO[0x26]) & 0x0FFF);\n\tserNo = ((dword) serHi << 16) | (dword) serLo;\n\tDIVA_OS_MEM_DETACH_CFG(&a->xdi_adapter, confIO);\n\n\tif ((serNo == 0) || (serNo == 0xFFFFFFFF)) {\n\t\tDBG_FTL((\"W: BRI use BAR[0] to get card serial number\"))\n\n\t\tconfMem = (word __iomem *)DIVA_OS_MEM_ATTACH_RAM(&a->xdi_adapter);\n\t\tserHi = (word) (READ_WORD(&confMem[0x11]) & 0x0FFF);\n\t\tserLo = (word) (READ_WORD(&confMem[0x13]) & 0x0FFF);\n\t\tserNo = (((dword) serHi) << 16) | ((dword) serLo);\n\t\tDIVA_OS_MEM_DETACH_RAM(&a->xdi_adapter, confMem);\n\t}\n\n\tDBG_LOG((\"Serial Number=%ld\", serNo))\n\n\treturn (serNo);\n}", "path": "kernel\\drivers\\isdn\\hardware\\eicon\\os_bri.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/*\n**  BAR0 - MEM Addr  - 0x80  - NOT USED\n**  BAR1 - I/O Addr  - 0x80\n**  BAR2 - I/O Addr  - 0x20\n*/\n", "func_signal": "int diva_bri_init_card(diva_os_xdi_adapter_t * a)", "code": "{\n\tint bar;\n\tdword bar2 = 0, bar2_length = 0xffffffff;\n\tword cmd = 0, cmd_org;\n\tbyte Bus, Slot;\n\tvoid *hdev;\n\tbyte __iomem *p;\n\n\t/*\n\t   Set properties\n\t */\n\ta->xdi_adapter.Properties = CardProperties[a->CardOrdinal];\n\tDBG_LOG((\"Load %s\", a->xdi_adapter.Properties.Name))\n\n\t    /*\n\t       Get resources\n\t     */\n\t    for (bar = 0; bar < 3; bar++) {\n\t\ta->resources.pci.bar[bar] =\n\t\t    divasa_get_pci_bar(a->resources.pci.bus,\n\t\t\t\t       a->resources.pci.func, bar,\n\t\t\t\t       a->resources.pci.hdev);\n\t\tif (!a->resources.pci.bar[bar]) {\n\t\t\tDBG_ERR((\"A: can't get BAR[%d]\", bar))\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\ta->resources.pci.irq =\n\t    (byte) divasa_get_pci_irq(a->resources.pci.bus,\n\t\t\t\t      a->resources.pci.func,\n\t\t\t\t      a->resources.pci.hdev);\n\tif (!a->resources.pci.irq) {\n\t\tDBG_ERR((\"A: invalid irq\"));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t   Get length of I/O bar 2 - it is different by older\n\t   EEPROM version\n\t */\n\tBus = a->resources.pci.bus;\n\tSlot = a->resources.pci.func;\n\thdev = a->resources.pci.hdev;\n\n\t/*\n\t   Get plain original values of the BAR2 CDM registers\n\t */\n\tPCIread(Bus, Slot, 0x18, &bar2, sizeof(bar2), hdev);\n\tPCIread(Bus, Slot, 0x04, &cmd_org, sizeof(cmd_org), hdev);\n\t/*\n\t   Disable device and get BAR2 length\n\t */\n\tPCIwrite(Bus, Slot, 0x04, &cmd, sizeof(cmd), hdev);\n\tPCIwrite(Bus, Slot, 0x18, &bar2_length, sizeof(bar2_length), hdev);\n\tPCIread(Bus, Slot, 0x18, &bar2_length, sizeof(bar2_length), hdev);\n\t/*\n\t   Restore BAR2 and CMD registers\n\t */\n\tPCIwrite(Bus, Slot, 0x18, &bar2, sizeof(bar2), hdev);\n\tPCIwrite(Bus, Slot, 0x04, &cmd_org, sizeof(cmd_org), hdev);\n\n\t/*\n\t   Calculate BAR2 length\n\t */\n\tbar2_length = (~(bar2_length & ~7)) + 1;\n\tDBG_LOG((\"BAR[2] length=%lx\", bar2_length))\n\n\t    /*\n\t       Map and register resources\n\t     */\n\t    if (!(a->resources.pci.addr[0] =\n\t\t divasa_remap_pci_bar(a, 0, a->resources.pci.bar[0],\n\t\t\t\t      bri_bar_length[0]))) {\n\t\tDBG_ERR((\"A: BRI, can't map BAR[0]\"))\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\n\tsprintf(&a->port_name[0], \"BRI %02x:%02x\",\n\t\ta->resources.pci.bus, a->resources.pci.func);\n\n\tif (diva_os_register_io_port(a, 1, a->resources.pci.bar[1],\n\t\t\t\t     bri_bar_length[1], &a->port_name[0], 1)) {\n\t\tDBG_ERR((\"A: BRI, can't register BAR[1]\"))\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\ta->resources.pci.addr[1] = (void *) (unsigned long) a->resources.pci.bar[1];\n\ta->resources.pci.length[1] = bri_bar_length[1];\n\n\tif (diva_os_register_io_port(a, 1, a->resources.pci.bar[2],\n\t\t\t\t     bar2_length, &a->port_name[0], 2)) {\n\t\tDBG_ERR((\"A: BRI, can't register BAR[2]\"))\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\ta->resources.pci.addr[2] = (void *) (unsigned long) a->resources.pci.bar[2];\n\ta->resources.pci.length[2] = bar2_length;\n\n\t/*\n\t   Set all memory areas\n\t */\n\tdiva_bri_set_addresses(a);\n\n\t/*\n\t   Get Serial Number\n\t */\n\ta->xdi_adapter.serialNo = diva_bri_get_serial_number(a);\n\n\t/*\n\t   Register I/O ports with correct name now\n\t */\n\tif (diva_bri_reregister_io(a)) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t   Initialize OS dependent objects\n\t */\n\tif (diva_os_initialize_spin_lock\n\t    (&a->xdi_adapter.isr_spin_lock, \"isr\")) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\tif (diva_os_initialize_spin_lock\n\t    (&a->xdi_adapter.data_spin_lock, \"data\")) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\n\tstrcpy(a->xdi_adapter.req_soft_isr.dpc_thread_name, \"kdivasbrid\");\n\n\tif (diva_os_initialize_soft_isr(&a->xdi_adapter.req_soft_isr,\n\t\t\t\t\tDIDpcRoutine, &a->xdi_adapter)) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\t/*\n\t   Do not initialize second DPC - only one thread will be created\n\t */\n\ta->xdi_adapter.isr_soft_isr.object = a->xdi_adapter.req_soft_isr.object;\n\n\t/*\n\t   Create entity table\n\t */\n\ta->xdi_adapter.Channels = CardProperties[a->CardOrdinal].Channels;\n\ta->xdi_adapter.e_max = CardProperties[a->CardOrdinal].E_info;\n\ta->xdi_adapter.e_tbl = diva_os_malloc(0, a->xdi_adapter.e_max * sizeof(E_INFO));\n\tif (!a->xdi_adapter.e_tbl) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\tmemset(a->xdi_adapter.e_tbl, 0x00, a->xdi_adapter.e_max * sizeof(E_INFO));\n\n\t/*\n\t   Set up interface\n\t */\n\ta->xdi_adapter.a.io = &a->xdi_adapter;\n\ta->xdi_adapter.DIRequest = request;\n\ta->interface.cleanup_adapter_proc = diva_bri_cleanup_adapter;\n\ta->interface.cmd_proc = diva_bri_cmd_card_proc;\n\n\tp = DIVA_OS_MEM_ATTACH_RESET(&a->xdi_adapter);\n\toutpp(p, 0x41);\n\tDIVA_OS_MEM_DETACH_RESET(&a->xdi_adapter, p);\n\n\tprepare_maestra_functions(&a->xdi_adapter);\n\n\ta->dsp_mask = 0x00000003;\n\n\t/*\n\t   Set IRQ handler\n\t */\n\ta->xdi_adapter.irq_info.irq_nr = a->resources.pci.irq;\n\tsprintf(a->xdi_adapter.irq_info.irq_name, \"DIVA BRI %ld\",\n\t\t(long) a->xdi_adapter.serialNo);\n\tif (diva_os_register_irq(a, a->xdi_adapter.irq_info.irq_nr,\n\t\t\t\t a->xdi_adapter.irq_info.irq_name)) {\n\t\tdiva_bri_cleanup_adapter(a);\n\t\treturn (-1);\n\t}\n\ta->xdi_adapter.irq_info.registered = 1;\n\n\tdiva_log_info(\"%s IRQ:%d SerNo:%d\", a->xdi_adapter.Properties.Name,\n\t\t      a->resources.pci.irq, a->xdi_adapter.serialNo);\n\n\treturn (0);\n}", "path": "kernel\\drivers\\isdn\\hardware\\eicon\\os_bri.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* this functions loops through all i2c-messages. normally, it should determine\n   which bytes were read through the adapter and write them back to the corresponding\n   i2c-message. but instead, we simply write back all bytes.\n   fixme: this could be improved. */\n", "func_signal": "static int saa7146_i2c_msg_cleanup(const struct i2c_msg *m, int num, __le32 *op)", "code": "{\n\tint i, j;\n\tint op_count = 0;\n\n\t/* loop through all messages */\n\tfor(i = 0; i < num; i++) {\n\n\t\top_count++;\n\n\t\t/* loop through all bytes of message i */\n\t\tfor(j = 0; j < m[i].len; j++) {\n\t\t\t/* write back all bytes that could have been read */\n\t\t\tm[i].buf[j] = (le32_to_cpu(op[op_count/3]) >> ((3-(op_count%3))*8));\n\t\t\top_count++;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* this functions resets the i2c-device and returns 0 if everything was fine, otherwise -1 */\n", "func_signal": "static int saa7146_i2c_reset(struct saa7146_dev *dev)", "code": "{\n\t/* get current status */\n\tu32 status = saa7146_i2c_status(dev);\n\n\t/* clear registers for sure */\n\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\tsaa7146_write(dev, I2C_TRANSFER, 0);\n\n\t/* check if any operation is still in progress */\n\tif ( 0 != ( status & SAA7146_I2C_BUSY) ) {\n\n\t\t/* yes, kill ongoing operation */\n\t\tDEB_I2C((\"busy_state detected.\\n\"));\n\n\t\t/* set \"ABORT-OPERATION\"-bit (bit 7)*/\n\t\tsaa7146_write(dev, I2C_STATUS, (dev->i2c_bitrate | MASK_07));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t/* clear all error-bits pending; this is needed because p.123, note 1 */\n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\t}\n\n\t/* check if any error is (still) present. (this can be necessary because p.123, note 1) */\n\tstatus = saa7146_i2c_status(dev);\n\n\tif ( dev->i2c_bitrate != status ) {\n\n\t\tDEB_I2C((\"error_state detected. status:0x%08x\\n\",status));\n\n\t\t/* Repeat the abort operation. This seems to be necessary\n\t\t   after serious protocol errors caused by e.g. the SAA7740 */\n\t\tsaa7146_write(dev, I2C_STATUS, (dev->i2c_bitrate | MASK_07));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t/* clear all error-bits pending */\n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t/* the data sheet says it might be necessary to clear the status\n\t\t   twice after an abort */\n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\t}\n\n\t/* if any error is still present, a fatal error has occured ... */\n\tstatus = saa7146_i2c_status(dev);\n\tif ( dev->i2c_bitrate != status ) {\n\t\tDEB_I2C((\"fatal error. status:0x%08x\\n\",status));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "kernel\\drivers\\media\\common\\saa7146_i2c.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* PRISM2_NO_STATION_MODES */\n", "func_signal": "void hostap_init_proc(local_info_t *local)", "code": "{\n\tlocal->proc = NULL;\n\n\tif (hostap_proc == NULL) {\n\t\tprintk(KERN_WARNING \"%s: hostap proc directory not created\\n\",\n\t\t       local->dev->name);\n\t\treturn;\n\t}\n\n\tlocal->proc = proc_mkdir(local->ddev->name, hostap_proc);\n\tif (local->proc == NULL) {\n\t\tprintk(KERN_INFO \"/proc/net/hostap/%s creation failed\\n\",\n\t\t       local->ddev->name);\n\t\treturn;\n\t}\n\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\tcreate_proc_read_entry(\"debug\", 0, local->proc,\n\t\t\t       prism2_debug_proc_read, local);\n#endif /* PRISM2_NO_PROCFS_DEBUG */\n\tcreate_proc_read_entry(\"stats\", 0, local->proc,\n\t\t\t       prism2_stats_proc_read, local);\n\tcreate_proc_read_entry(\"wds\", 0, local->proc,\n\t\t\t       prism2_wds_proc_read, local);\n\tcreate_proc_read_entry(\"pda\", 0, local->proc,\n\t\t\t       prism2_pda_proc_read, local);\n\tcreate_proc_read_entry(\"aux_dump\", 0, local->proc,\n\t\t\t       prism2_aux_dump_proc_read, local);\n\tcreate_proc_read_entry(\"bss_list\", 0, local->proc,\n\t\t\t       prism2_bss_list_proc_read, local);\n\tcreate_proc_read_entry(\"crypt\", 0, local->proc,\n\t\t\t       prism2_crypt_proc_read, local);\n#ifdef PRISM2_IO_DEBUG\n\tcreate_proc_read_entry(\"io_debug\", 0, local->proc,\n\t\t\t       prism2_io_debug_proc_read, local);\n#endif /* PRISM2_IO_DEBUG */\n#ifndef PRISM2_NO_STATION_MODES\n\tcreate_proc_read_entry(\"scan_results\", 0, local->proc,\n\t\t\t       prism2_scan_results_proc_read, local);\n#endif /* PRISM2_NO_STATION_MODES */\n}", "path": "kernel\\drivers\\net\\wireless\\hostap\\hostap_proc.c", "repo_name": "tegrak/lulz-kernel_gt-i9100", "stars": 16, "license": "None", "language": "c", "size": 106909}
{"docstring": "/* copy mpq object */\n", "func_signal": "static PyObject *\nPympq_copy(PyObject *self, PyObject *args)", "code": "{\n    PyObject* temp;\n    if(self && Pympq_Check(self)) {\n        if(PyTuple_GET_SIZE(args) != 0) {\n            PyErr_SetString(PyExc_TypeError, \"function takes exactly 1 argument\");\n            return NULL;\n        }\n        return (PyObject*)Pympq2Pympq((PympqObject*)self);\n    } else {\n        if(PyTuple_GET_SIZE(args) != 1){\n            PyErr_SetString(PyExc_TypeError, \"function takes exactly 1 argument\");\n            return NULL;\n        }\n        temp = PyTuple_GET_ITEM(args, 0);\n        if(Pympq_Check(temp)) {\n            return (PyObject*)Pympq2Pympq((PympqObject*)temp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"unsupported operand type for _qcopy(): mpq required\");\n            return NULL;\n        }\n    }\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Classify an object as a type of number. If an object is recognized as a\n * number, it must be properly converted by the routines below.\n */\n", "func_signal": "static int isNumber(PyObject* obj)", "code": "{\n    if(options.debug)\n        fprintf(stderr, \"isNumber: object type is %s\\n\", Py_TYPE(obj)->tp_name);\n    if(Pympz_Check(obj)) {\n        return 1;\n    } else if(PyLong_Check(obj)) {\n        return 1;\n#if PY_MAJOR_VERSION == 2\n    } else if(PyInt_Check(obj)) {\n        return 1;\n#endif\n    } else if(Pympq_Check(obj)) {\n        return 1;\n    } else if(Pympf_Check(obj)) {\n        return 1;\n    } else if(PyFloat_Check(obj)) {\n        return 1;\n    } else if(!strcmp(Py_TYPE(obj)->tp_name, \"Decimal\")) {\n        return 1;\n    } else if(!strcmp(Py_TYPE(obj)->tp_name, \"Fraction\")) {\n        return 1;\n    }\n    return 0;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* CONVERSIONS AND COPIES */\n", "func_signal": "static PympzObject *\nPympz2Pympz(PympzObject *i)", "code": "{\n    PympzObject *newob;\n\n    assert(Pympz_Check(i));\n    if(!(newob = Pympz_new()))\n        return NULL;\n    mpz_set(newob->z, i->z);\n    return newob;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* clear-or-cache macro & function -- stash into cache, else clear, an MPF */\n", "func_signal": "static void\nmpf_cloc(mpf_t oldo)", "code": "{\n    if(in_fcache<options.cache_size && mpf_size(oldo) <= options.cache_obsize) {\n        (fcache[in_fcache++])[0] = oldo[0];\n        if(options.debug)\n            fprintf(stderr, \"Stashed %d to fcache\\n\", in_fcache);\n    } else {\n        if(options.debug)\n            fprintf(stderr, \"Not placing in full fcache(%d/%ld)\\n\",\n                    in_fcache, options.cache_size);\n        mpf_clear(oldo);\n    }\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* This function was originally from netlib, package bmp, by\n * Richard P. Brent. Paulo Cesar Pereira de Andrade converted\n * it to C and used it in his LISP interpreter.\n *\n * Original comments:\n *\n *   sets mp pi = 3.14159... to the available precision.\n *   uses the gauss-legendre algorithm.\n *   this method requires time o(ln(t)m(t)), so it is slower\n *   than mppi if m(t) = o(t**2), but would be faster for\n *   large t if a faster multiplication algorithm were used\n *   (see comments in mpmul).\n *   for a description of the method, see - multiple-precision\n *   zero-finding and the complexity of elementary function\n *   evaluation (by r. p. brent), in analytic computational\n *   complexity (edited by j. f. traub), academic press, 1976, 151-176.\n *   rounding options not implemented, no guard digits used.\n*/\n", "func_signal": "static PyObject *\nPygmpy_pi(PyObject *self, PyObject *args)", "code": "{\n    PympfObject *pi;\n    int precision;\n    mpf_t r_i2, r_i3, r_i4;\n    mpf_t ix;\n\n    ONE_ARG(\"pi\", \"i\", &precision);\n    if(!(pi = Pympf_new(precision))) {\n        return NULL;\n    }\n\n    mpf_set_si(pi->f, 1);\n\n    mpf_init(ix);\n    mpf_set_ui(ix, 1);\n\n    mpf_init2(r_i2, precision);\n\n    mpf_init2(r_i3, precision);\n    mpf_set_d(r_i3, 0.25);\n\n    mpf_init2(r_i4, precision);\n    mpf_set_d(r_i4, 0.5);\n    mpf_sqrt(r_i4, r_i4);\n\n    for (;;) {\n        mpf_set(r_i2, pi->f);\n        mpf_add(pi->f, pi->f, r_i4);\n        mpf_div_ui(pi->f, pi->f, 2);\n        mpf_mul(r_i4, r_i2, r_i4);\n        mpf_sub(r_i2, pi->f, r_i2);\n        mpf_mul(r_i2, r_i2, r_i2);\n        mpf_mul(r_i2, r_i2, ix);\n        mpf_sub(r_i3, r_i3, r_i2);\n        mpf_sqrt(r_i4, r_i4);\n        mpf_mul_ui(ix, ix, 2);\n        /* Check for convergence */\n        if (!(mpf_cmp_si(r_i2, 0) &&\n              mpf_get_prec(r_i2) >= (unsigned)precision)) {\n            mpf_mul(pi->f, pi->f, r_i4);\n            mpf_div(pi->f, pi->f, r_i3);\n            break;\n        }\n    }\n\n    mpf_clear(ix);\n    mpf_clear(r_i2);\n    mpf_clear(r_i3);\n    mpf_clear(r_i4);\n\n    Pympf_normalize(pi);\n    return (PyObject*)pi;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Assume digits points to a chunk of size size\n * where size >= mpn_pylong_size(up, un)\n */\n", "func_signal": "void\nmpn_get_pylong (digit *digits, size_t size, mp_ptr up, size_t un)", "code": "{\n  mp_limb_t n1, n0;\n  size_t i;\n  ssize_t bit_pos;\n  /* point past the allocated chunk */\n  digit * s = digits + size;\n\n  /* input length 0 is special ! */\n  if (un == 0) {\n    while (size) digits[--size]=0;\n    return;\n  }\n\n  i = un - 1;\n  n1 = up[i];\n  bit_pos = size * PyLong_SHIFT - i * GMP_NUMB_BITS;\n\n  for (;;)\n    {\n      bit_pos -= PyLong_SHIFT;\n      while (bit_pos >= 0)\n        {\n          *--s = (n1 >> bit_pos) & PyLong_MASK;\n          bit_pos -= PyLong_SHIFT;\n        }\n      if (i == 0)\n        break;\n      n0 = (n1 << -bit_pos) & PyLong_MASK;\n      n1 = up[--i];\n      bit_pos += GMP_NUMB_BITS;\n      *--s = (digit)(n0 | (n1 >> bit_pos));\n    }\n}", "path": "gmpy-1.15\\src\\mpz_pylong.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Pympz_pow is called by Pympany_pow after verifying that all the\n * arguments are integers, but not necessarily mpz.\n */\n", "func_signal": "static PyObject *\nPympz_pow(PyObject *in_b, PyObject *in_e, PyObject *in_m)", "code": "{\n    PympzObject *r, *b, *e, *m;\n\n    b = Pympz_From_Integer(in_b);\n    e = Pympz_From_Integer(in_e);\n\n    /* m will either be an number or Py_None. */\n    if(in_m != Py_None) {\n        m = Pympz_From_Integer(in_m);\n    } else {\n        m = (PympzObject*) in_m;\n        Py_INCREF((PyObject*)m);\n    }\n\n    if(!b || !e || (!m && ((PyObject*)m != Py_None))) {\n        PyErr_Clear();\n        Py_XDECREF((PyObject*)b);\n        Py_XDECREF((PyObject*)e);\n        Py_XDECREF((PyObject*)m);\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if(options.debug)\n        fprintf(stderr, \"Pympz_pow: %p, %p, %p\\n\", (void *)b, (void *)e, (void *)m);\n\n    if(mpz_sgn(e->z) < 0) {\n        PyErr_SetString(PyExc_ValueError, \"mpz.pow with negative power\");\n        Py_XDECREF((PyObject*)b);\n        Py_XDECREF((PyObject*)e);\n        Py_XDECREF((PyObject*)m);\n        return NULL;\n    }\n\n    if((PyObject*)in_m == Py_None) {\n        /* When no modulo is present, the exponent must fit in C ulong */\n        unsigned long el;\n        if(!mpz_fits_slong_p(e->z)) {\n            PyErr_SetString(PyExc_ValueError, \"mpz.pow outrageous exponent\");\n            Py_XDECREF((PyObject*)b);\n            Py_XDECREF((PyObject*)e);\n            Py_XDECREF((PyObject*)m);\n            return NULL;\n        }\n        el = mpz_get_ui(e->z);\n        if(!(r = Pympz_new())) {\n            Py_XDECREF((PyObject*)b);\n            Py_XDECREF((PyObject*)e);\n            Py_XDECREF((PyObject*)m);\n            return NULL;\n        }\n        mpz_pow_ui(r->z, b->z, el);\n        if(options.debug)\n            fprintf(stderr, \"Pympz_pow (ui) -> %p\\n\", (void *)r);\n    } else { /* Modulo exponentiation */\n        int sign;\n        mpz_t mm;\n\n        sign = mpz_sgn(m->z);\n        if(sign == 0) {\n            PyErr_SetString(PyExc_ValueError, \"mpz.pow divide by zero\");\n            Py_XDECREF((PyObject*)b);\n            Py_XDECREF((PyObject*)e);\n            Py_XDECREF((PyObject*)m);\n            return NULL;\n        }\n        if(!(r = Pympz_new())) {\n            Py_XDECREF((PyObject*)b);\n            Py_XDECREF((PyObject*)e);\n            Py_XDECREF((PyObject*)m);\n            return NULL;\n        }\n        mpz_inoc(mm);\n        mpz_abs(mm, m->z);\n        mpz_powm(r->z, b->z, e->z, mm);\n        mpz_cloc(mm);\n        if((sign<0) && (mpz_sgn(r->z) > 0)) {\n        /* Python uses a rather peculiar convention for negative modulos\n         * If the modulo is negative, result should be in the interval\n         * m < r <= 0 .\n         */\n            mpz_add(r->z, r->z, m->z);\n        }\n        if(options.debug)\n            fprintf(stderr, \"Pympz_pow -> %p\\n\", (void *)r);\n    }\n    Py_XDECREF((PyObject*)b);\n    Py_XDECREF((PyObject*)e);\n    Py_XDECREF((PyObject*)m);\n    return (PyObject*)r;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n * mpf->long delegates via mpf->mpz->long to avoid duplicating\n * the above-seen thorny dependencies; ditto mpq->long\n */\n", "func_signal": "static PyObject *\nPympf2PyLong(PympfObject *x)", "code": "{\n    PyObject* result;\n\n    PympzObject *intermediate = Pympf2Pympz((PyObject*)x);\n    if(!intermediate) return 0;\n\n    result = Pympz2PyLong(intermediate);\n    Py_DECREF((PyObject*)intermediate);\n    return result;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Pympz_dealloc */\n", "func_signal": "static void\nPympq_dealloc(PympqObject *self)", "code": "{\n    if(options.debug)\n        fprintf(stderr, \"Pympq_dealloc: %p\\n\", (void *)self);\n    if(in_pympqcache<options.cache_size\n            && mpq_numref(self->q)->_mp_alloc <= options.cache_obsize\n            && mpq_denref(self->q)->_mp_alloc <= options.cache_obsize) {\n        (pympqcache[in_pympqcache++]) = self;\n    } else {\n        mpq_cloc(self->q);\n        PyObject_Del(self);\n    }\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n * Convert an Integer-like object (as determined by isInteger) to\n * a C long. Returns -1 and raises OverflowError if the the number is\n * too large. Returns -1 and raises TypeError if obj was not an\n * Integer-like object.\n */\n", "func_signal": "static long\nclong_From_Integer(PyObject *obj)", "code": "{\n    if(PyLong_Check(obj)) {\n        return PyLong_AsLong(obj);\n#if PY_MAJOR_VERSION == 2\n    } else if(PyInt_Check(obj)) {\n        return PyInt_AS_LONG(obj);\n#endif\n    } else if(Pympz_Check(obj)) {\n        if(mpz_fits_slong_p(Pympz_AS_MPZ(obj))) {\n            return mpz_get_si(Pympz_AS_MPZ(obj));\n        }\n    }\n    PyErr_SetString(PyExc_TypeError,\n        \"conversion error in clong_From_Integer\");\n    return -1;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* copy mpf object */\n", "func_signal": "static PyObject *\nPympf_copy(PyObject *self, PyObject *args)", "code": "{\n    PyObject *s;\n    size_t bits=0;\n    SELF_MPF_ONE_ARG(\"|n\",&bits);\n\n    assert(Pympf_Check(self));\n    if(!bits) bits = ((PympfObject*)self)->rebits;\n    s = (PyObject*)Pympf2Pympf((PympfObject*)self, bits);\n    Py_DECREF(self);\n    return s;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n *  build binary representation of mpq (base-256 little-endian\n *  for num, then den; before those, 4 bytes for _length_ of\n *  numerator, which also encode sign as the single top bit).\n */\n", "func_signal": "static PyObject *\nPympq2binary(PympqObject *x)", "code": "{\n    size_t sizenum, sizeden, size, sizetemp;\n    int negative=0;\n    char *buffer;\n    size_t i;\n    PyObject *s;\n\n    assert(Pympq_Check( (PyObject *) x));\n\n    if(mpq_sgn(x->q) < 0) {\n        negative = 1;\n        mpz_abs(mpq_numref(x->q), mpq_numref(x->q));\n    } else {\n        negative = 0;\n    }\n    assert(mpz_sgn(mpq_denref(x->q))>0);\n\n    sizenum = (mpz_sizeinbase(mpq_numref(x->q), 2) + 7) / 8;\n    sizeden = (mpz_sizeinbase(mpq_denref(x->q), 2) + 7) / 8;\n    size = sizenum+sizeden+4;\n\n    TEMP_ALLOC(buffer, size);\n\n    sizetemp = sizenum;\n    for(i=0; i<4; i++) {\n        buffer[i] = (char)(sizetemp & 0xff);\n        sizetemp >>= 8;\n    }\n    if(negative) buffer[3] |= 0x80;\n    buffer[4] = 0x00;\n\n    mpz_export(buffer+4, NULL, -1, sizeof(char), 0, 0, mpq_numref(x->q));\n    mpz_export(buffer+sizenum+4, NULL, -1, sizeof(char), 0, 0, mpq_denref(x->q));\n    if(negative) {\n        mpz_neg( mpq_numref(x->q), mpq_numref(x->q));\n    }\n    s = Py2or3Bytes_FromStringAndSize(buffer, size);\n\n    TEMP_FREE(buffer, size);\n\n    return s;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n *  build binary representation of mpz (base-256 little-endian)\n *  Note: design limitation used to forbid binary repr of <0 mpz;\n *  this has now been remedied, but at the price of full compatibility\n *  with files saved in gmpy releases 0.6 and earlier.\n */\n", "func_signal": "static PyObject *\nPympz2binary(PympzObject *x)", "code": "{\n    size_t size, usize;\n    int negative, needtrail;\n    char *buffer;\n    PyObject *s;\n\n    assert(Pympz_Check( (PyObject *) x));\n\n    if(mpz_sgn(x->z) < 0) {\n        negative = 1;\n        mpz_neg(x->z, x->z); /* Change the sign temporarily! */\n    } else {\n        negative = 0;\n    }\n\n    size = mpz_sizeinbase(x->z, 2);\n    needtrail = (size%8)==0;\n    usize = size = (size + 7) / 8;\n    if(negative || needtrail)\n        ++size;\n\n    TEMP_ALLOC(buffer, size);\n    buffer[0] = 0x00;\n    mpz_export(buffer, NULL, -1, sizeof(char), 0, 0, x->z);\n    if(usize < size) {\n        buffer[usize] = negative?0xff:0x00;\n    }\n    if(negative) {\n        mpz_neg(x->z, x->z);\n    }\n    s = Py2or3Bytes_FromStringAndSize(buffer, size);\n    TEMP_FREE(buffer, size);\n    return s;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* MPQ_MONOP(mpq_inv) */\n", "func_signal": "MPQ_MONOP(mpq_neg)\n\nstatic PyObject *\nPympq_abs(PympqObject *x)", "code": "{\n    PympqObject *r;\n    if (options.debug) fprintf(stderr, \"Pympq_abs: %p\\n\", (void *)x);\n    if (!(r = Pympq_new())) return NULL;\n    mpq_set(r->q, x->q);\n    mpz_abs(mpq_numref(r->q),mpq_numref(r->q));\n    if (options.debug) fprintf(stderr, \"Pympq_abs-> %p\\n\", (void *)r);\n    return (PyObject *) r;\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* mpz -> pylong conversion */\n", "func_signal": "PyObject *\nmpz_get_PyLong(mpz_srcptr z)", "code": "{\n  size_t size = mpn_pylong_size(z->_mp_d, ABS(z->_mp_size));\n  PyLongObject *lptr = PyObject_NEW_VAR(PyLongObject, &PyLong_Type, size);\n\n  if (lptr != NULL)\n  {\n    mpn_get_pylong(lptr->ob_digit, size, z->_mp_d, ABS(z->_mp_size));\n    if (z->_mp_size < 0)\n      Py_SIZE(lptr) = -(Py_SIZE(lptr));\n  }\n\n  return (PyObject *) lptr;\n}", "path": "gmpy-1.15\\src\\mpz_pylong.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* init-or-cache macro & function -- fetch from cache, else init, an MPF */\n", "func_signal": "static void\nmpf_inoc(mpf_t newo)", "code": "{\n    if(in_fcache) {\n        if(options.debug)\n            fprintf(stderr, \"Getting %d from fcache\\n\", in_fcache);\n        newo[0] = (fcache[--in_fcache])[0];\n    } else {\n        if(options.debug)\n            fprintf(stderr, \"Initing new not in fcache\\n\");\n        mpf_init(newo);\n    }\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* pylong -> mpz conversion */\n", "func_signal": "int\nmpz_set_PyLong(mpz_ptr z, PyObject * lsrc)", "code": "{\n  register PyLongObject * lptr = (PyLongObject *) lsrc;\n  ssize_t size;\n\n  if (lptr==NULL || !PyLong_Check(lptr)) {\n    PyErr_BadInternalCall();\n    return -1;\n  }\n\n  size = (ssize_t)mpn_size_from_pylong(lptr->ob_digit, ABS(Py_SIZE(lptr)));\n\n  if (z->_mp_alloc < size)\n    _mpz_realloc (z, (mp_size_t)size);\n\n  mpn_set_pylong(z->_mp_d, size, lptr->ob_digit, ABS(Py_SIZE(lptr)));\n  z->_mp_size = (int)(Py_SIZE(lptr) < 0 ? -size : size);\n\n  return (int)size;\n}", "path": "gmpy-1.15\\src\\mpz_pylong.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/*\n * for an mpz, this number has to be multiplied by the sign\n * also remember to catch -1 and map it to -2 !\n */\n", "func_signal": "long\nmpn_pythonhash (mp_ptr up, mp_size_t un)", "code": "{\n  mp_limb_t n1, n0;\n  mp_size_t i;\n  ssize_t bit_pos;\n  long x = 0;\n\n  /* input length 0 is special ! */\n  if (un == 0) return 0;\n\n  i = un - 1;\n  n1 = up[i];\n  {\n    size_t bits;\n    bits = mpn_sizebits(up, un) + PyLong_SHIFT - 1;\n    bits -= bits % PyLong_SHIFT;\n    /* position of the MSW in base 2^SHIFT, counted from the MSW in\n     * the GMP representation (in base 2^GMP_NUMB_BITS)\n     */\n    bit_pos = bits - i * GMP_NUMB_BITS;\n  }\n\n  for (;;)\n    {\n      while (bit_pos >= 0)\n        {\n          /* Force a native long #-bits (32 or 64) circular shift */\n          x = ((x << PyLong_SHIFT) & ~(long)PyLong_MASK) | ((x >> LONG_BIT_SHIFT) & (long)PyLong_MASK);\n          /* Shifting to the right by more than wordsize bits\n             actually shifts by (wordsize % 32) bits -- which is\n             *not* the intended behavior here. */\n      if (bit_pos <= 8*sizeof(mp_limb_t))\n            x += (n1 >> bit_pos) & (long)PyLong_MASK;\n          bit_pos -= PyLong_SHIFT;\n        }\n      i--;\n      if (i < 0)\n        break;\n      n0 = (n1 << -bit_pos) & (long)PyLong_MASK;\n      n1 = up[i];\n      bit_pos += GMP_NUMB_BITS;\n      /* Force a native long #-bits (32 or 64) circular shift */\n      x = ((x << PyLong_SHIFT) & ~(long)PyLong_MASK) | ((x >> LONG_BIT_SHIFT) & (long)PyLong_MASK);\n      x += (long)(n0 | (n1 >> bit_pos));\n      bit_pos -= PyLong_SHIFT;\n    }\n\n  return x;\n}", "path": "gmpy-1.15\\src\\mpz_pylong.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Pympq_dealloc */\n", "func_signal": "static void\nPympf_dealloc(PympfObject *self)", "code": "{\n    if(options.debug)\n        fprintf(stderr, \"Pympf_dealloc: %p\\n\", (void *)self);\n    mpf_clear(self->f);\n    PyObject_Del(self);\n}", "path": "gmpy-1.15\\src\\gmpy.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/* Pympany_truediv follows the / semantics from Python 3.x. The result types\n * are:\n *   mpz / mpz -> mpf\n *   mpq / mpq -> mpq\n *   mpf / mpf -> mpf\n *\n * The behavior of mpq now mimics the behavior of fractions.Fraction.\n */\n", "func_signal": "static PyObject *\nPympany_truediv(PyObject *a, PyObject *b)", "code": "{\n    PyObject *r = 0;\n    PympqObject *rq = 0, *paq = 0, *pbq = 0;\n    PympfObject *rf = 0, *paf = 0, *pbf = 0;\n    size_t bits;\n\n    if(Pympz_Check(b) && (mpz_sgn(Pympz_AS_MPZ(b)) == 0)) {\n        PyErr_SetString(PyExc_ZeroDivisionError, \"mpz division by zero\");\n        return NULL;\n    }\n\n    if(Pympq_Check(b) && (mpq_sgn(Pympq_AS_MPQ(b)) == 0)) {\n        PyErr_SetString(PyExc_ZeroDivisionError, \"mpq division by zero\");\n        return NULL;\n    }\n\n    if(isInteger(a) && isInteger(b)) {\n        if(options.debug) fprintf(stderr, \"True divide (integer,integer)\\n\");\n        paf = anynum2Pympf(a, 0);\n        pbf = anynum2Pympf(b, 0);\n        if(!paf || !pbf) {\n            PyErr_SetString(PyExc_SystemError, \"Can not convert number to mpf\");\n            Py_XDECREF((PyObject*)paf); Py_XDECREF((PyObject*)pbf);\n            return NULL;\n        }\n        if(mpf_sgn(pbf->f)==0) {\n            PyErr_SetString(PyExc_ZeroDivisionError, \"mpz division by zero\");\n            Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n            return NULL;\n        }\n        if (!(rf = Pympf_new(0))) {\n            Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n            return NULL;\n        }\n        mpf_div(rf->f, paf->f, pbf->f);\n        Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n        return (PyObject *) rf;\n    }\n\n    if(isRational(a) && isRational(b)) {\n        if(options.debug) fprintf(stderr, \"True divide (rational,rational)\\n\");\n        paq = anyrational2Pympq(a);\n        pbq = anyrational2Pympq(b);\n        if(!paq || !pbq) {\n            PyErr_SetString(PyExc_SystemError, \"Can not convert rational to mpq\");\n            Py_XDECREF((PyObject*)paq); Py_XDECREF((PyObject*)pbq);\n            return NULL;\n        }\n        if(mpq_sgn(pbq->q)==0) {\n            PyErr_SetString(PyExc_ZeroDivisionError, \"mpq division by zero\");\n            Py_DECREF((PyObject*)paq); Py_DECREF((PyObject*)pbq);\n            return NULL;\n        }\n        if (!(rq = Pympq_new())) {\n            Py_DECREF((PyObject*)paq); Py_DECREF((PyObject*)pbq);\n            return NULL;\n        }\n        mpq_div(rq->q, paq->q, pbq->q);\n        Py_DECREF((PyObject*)paq); Py_DECREF((PyObject*)pbq);\n        return (PyObject *) rq;\n    }\n\n    if(isNumber(a) && isNumber(b)) {\n        if(options.debug) fprintf(stderr, \"True divide (number,number)\\n\");\n        if(Pympf_Check(a) && Pympf_Check(b)) {\n            paf = anynum2Pympf(a, 0);\n            pbf = anynum2Pympf(b, 0);\n        } else if(Pympf_Check(a)) {\n            paf = anynum2Pympf(a, 0);\n            pbf = anynum2Pympf(b, paf->rebits);\n        } else if(Pympf_Check(b)) {\n            pbf = anynum2Pympf(b, 0);\n            paf = anynum2Pympf(a, pbf->rebits);\n        } else {\n            pbf = anynum2Pympf(b, 0);\n            paf = anynum2Pympf(a, 0);\n        }\n        if(!paf || !pbf) {\n            if(PyErr_Occurred()) {\n                PyErr_Clear();\n            } else {\n                PyErr_SetString(PyExc_SystemError,\n                    \"Internal error status is confused.\");\n                return NULL;\n            }\n            /* Need to handle special float values. */\n            if(pbf && !paf && PyFloat_Check(a)) {\n                double d = PyFloat_AS_DOUBLE(a);\n                if(isnan(d)) {\n                    if(mpf_sgn(pbf->f) == 0) {\n                        PyErr_SetString(PyExc_ZeroDivisionError,\n                            \"mpf division by zero\");\n                        r = NULL;\n                    } else {\n                        r = PyFloat_FromDouble(d);\n                    }\n                    Py_DECREF((PyObject*)pbf);\n                    return r;\n                } else if(isinf(d)) {\n                    if(mpf_sgn(pbf->f) == 0) {\n                        PyErr_SetString(PyExc_ZeroDivisionError,\n                            \"mpf division by zero\");\n                        r = NULL;\n                    } else if(mpf_sgn(pbf->f) < 0) {\n                        r = PyFloat_FromDouble(-d);\n                    } else {\n                        r = PyFloat_FromDouble(d);\n                    }\n                    Py_DECREF((PyObject*)pbf);\n                    return r;\n                }\n            } else if(paf && !pbf && PyFloat_Check(b)) {\n                double d = PyFloat_AS_DOUBLE(b);\n                if(isnan(d)) {\n                    r = PyFloat_FromDouble(d);\n                    Py_DECREF((PyObject*)paf);\n                    return r;\n                } else if(isinf(d)) {\n                    mpf_set_d(paf->f, 0.0);\n                    return (PyObject*)paf;\n                }\n            } else {\n                PyErr_SetString(PyExc_SystemError, \"Can not convert number to mpf\");\n                Py_XDECREF((PyObject*)paf);\n                Py_XDECREF((PyObject*)pbf);\n                return NULL;\n            }\n        }\n        if(mpf_sgn(pbf->f)==0) {\n            PyErr_SetString(PyExc_ZeroDivisionError, \"mpf division by zero\");\n            Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n            return NULL;\n        }\n        bits = paf->rebits;\n        if(pbf->rebits<bits) bits=pbf->rebits;\n        if (!(rf = Pympf_new(bits))) {\n            Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n            return NULL;\n        }\n        mpf_div(rf->f, paf->f, pbf->f);\n        Py_DECREF((PyObject*)paf); Py_DECREF((PyObject*)pbf);\n        mpf_normalize(rf->f);\n        return (PyObject *) rf;\n    }\n\n    r = Py_NotImplemented;\n    Py_INCREF(r);\n    return r;\n}", "path": "gmpy-1.15\\src\\gmpy_basic.c", "repo_name": "LetsUnlockiPhone/iPhone-Baseband-Memory-Decryptor", "stars": 17, "license": "None", "language": "c", "size": 226}
{"docstring": "/**********************************/\n/* Hw Reset and Channel Switching */\n/**********************************/\n", "func_signal": "static inline void jaldi_hw_set_dma(struct jaldi_hw *hw)", "code": "{\n\tu32 regval;\n\n\tENABLE_REGWRITE_BUFFER(hw);\n\n\t/*\n\t * set AHB_MODE not to do cacheline prefetches\n\t*/\n\tif (!AR_SREV_9300_20_OR_LATER(hw)) {\n\t\tregval = REG_READ(hw, AR_AHB_MODE);\n\t\tREG_WRITE(hw, AR_AHB_MODE, regval | AR_AHB_PREFETCH_RD_EN);\n\t}\n\n\t/*\n\t * let mac dma reads be in 128 byte chunks\n\t */\n\tregval = REG_READ(hw, AR_TXCFG) & ~AR_TXCFG_DMASZ_MASK;\n\tREG_WRITE(hw, AR_TXCFG, regval | AR_TXCFG_DMASZ_128B);\n\n\tREGWRITE_BUFFER_FLUSH(hw);\n\tDISABLE_REGWRITE_BUFFER(hw);\n\n\t/*\n\t * Restore TX Trigger Level to its pre-reset value.\n\t * The initial value depends on whether aggregation is enabled, and is\n\t * adjusted whenever underruns are detected.\n\t */\n\tif (!AR_SREV_9300_20_OR_LATER(hw))\n\t\tREG_RMW_FIELD(hw, AR_TXCFG, AR_FTRIG, hw->tx_trig_level);\n\n\tENABLE_REGWRITE_BUFFER(hw);\n\n\t/*\n\t * let mac dma writes be in 128 byte chunks\n\t */\n\tregval = REG_READ(hw, AR_RXCFG) & ~AR_RXCFG_DMASZ_MASK;\n\tREG_WRITE(hw, AR_RXCFG, regval | AR_RXCFG_DMASZ_128B);\n\n\t/*\n\t * Setup receive FIFO threshold to hold off TX activities\n\t */\n\tREG_WRITE(hw, AR_RXFIFO_CFG, 0x200);\n\n\t/*\n\t * reduce the number of usable entries in PCU TXBUF to avoid\n\t * wrap around issues.\n\t */\n\tif (AR_SREV_9285(hw)) {\n\t\t/* For AR9285 the number of Fifos are reduced to half.\n\t\t * So set the usable tx buf size also to half to\n\t\t * avoid data/delimiter underruns\n\t\t */\n\t\tREG_WRITE(hw, AR_PCU_TXBUF_CTRL,\n\t\t\t  AR_9285_PCU_TXBUF_CTRL_USABLE_SIZE);\n\t} else if (!AR_SREV_9271(hw)) {\n\t\tREG_WRITE(hw, AR_PCU_TXBUF_CTRL,\n\t\t\t  AR_PCU_TXBUF_CTRL_USABLE_SIZE);\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(hw);\n\tDISABLE_REGWRITE_BUFFER(hw);\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "//static void jaldi_hw_fill_txdesc(struct jaldi_hw *hw, struct jaldi_desc *ds, u32 seglen,\n", "func_signal": "void jaldi_hw_fill_txdesc(struct jaldi_hw *hw, struct jaldi_desc *ds, u32 seglen,\n\t\t\t\t  bool is_firstseg, bool is_lastseg,\n\t\t\t\t  const struct jaldi_desc *ds0, dma_addr_t buf_addr,\n\t\t\t\t  unsigned int qcu)", "code": "{\n\tstruct ar5416_desc *ads = AR5416DESC(ds);\n\n\tads->ds_data = buf_addr;\n\n\tif (is_firstseg) {\n\t\tads->ds_ctl1 |= seglen | (is_lastseg ? 0 : AR_TxMore);\n\t} else if (is_lastseg) {\n\t\tads->ds_ctl0 = 0;\n\t\tads->ds_ctl1 = seglen;\n\t\tads->ds_ctl2 = AR5416DESC_CONST(ds0)->ds_ctl2;\n\t\tads->ds_ctl3 = AR5416DESC_CONST(ds0)->ds_ctl3;\n\t} else {\n\t\tads->ds_ctl0 = 0;\n\t\tads->ds_ctl1 = seglen | AR_TxMore;\n\t\tads->ds_ctl2 = 0;\n\t\tads->ds_ctl3 = 0;\n\t}\n\tads->ds_txstatus0 = ads->ds_txstatus1 = 0;\n\tads->ds_txstatus2 = ads->ds_txstatus3 = 0;\n\tads->ds_txstatus4 = ads->ds_txstatus5 = 0;\n\tads->ds_txstatus6 = ads->ds_txstatus7 = 0;\n\tads->ds_txstatus8 = ads->ds_txstatus9 = 0;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/***************/\n/* MAC (RX/TX) */\n/***************/\n", "func_signal": "u32 jaldi_hw_getrxfilter(struct jaldi_hw *hw)", "code": "{\n\tu32 bits = REG_READ(hw, AR_RX_FILTER);\n\tu32 phybits = REG_READ(hw, AR_PHY_ERR);\n\n\tif (phybits & AR_PHY_ERR_RADAR)\n\t\tbits |= JALDI_RX_FILTER_PHYRADAR;\n\tif (phybits & (AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING))\n\t\tbits |= JALDI_RX_FILTER_PHYERR;\n\n\treturn bits;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/******/\n/* RX */\n/******/\n/*\n * Calculate the receive filter according to the\n * operating mode and state:\n * o Just grab everything: we want it all. Handle processing at higher level.\n * o Always maintain current state of phy error reception (the hal\n *   may enable phy error frames for (future) noise immunity work)\n */\n", "func_signal": "u32 jaldi_calcrxfilter(struct jaldi_softc *sc)", "code": "{\n#define\tRX_FILTER_PRESERVE (JALDI_RX_FILTER_PHYERR | JALDI_RX_FILTER_PHYRADAR)\n\n\tu32 rfilt;\n\n\trfilt = (jaldi_hw_getrxfilter(sc->hw) & RX_FILTER_PRESERVE)\n\t\t| JALDI_RX_FILTER_UCAST | JALDI_RX_FILTER_BCAST\n\t\t| JALDI_RX_FILTER_MCAST | JALDI_RX_FILTER_CONTROL\n\t\t| JALDI_RX_FILTER_BEACON | JALDI_RX_FILTER_PROM\n\t\t| JALDI_RX_FILTER_PROBEREQ | JALDI_RX_FILTER_MYBEACON \n\t\t| JALDI_RX_FILTER_COMP_BAR | JALDI_RX_FILTER_PSPOLL\n\t\t| JALDI_RX_FILTER_MCAST_BCAST_ALL;\n\n\treturn rfilt;\n\n#undef RX_FILTER_PRESERVE\n}", "path": "kerneldriver\\main.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "//static void jaldi_hw_set11n_txdesc(struct jaldi_hw *hw, void *ds,\n", "func_signal": "void jaldi_hw_set11n_txdesc(struct jaldi_hw *hw, void *ds,\n\t\t\t\t    u32 pktLen, enum jaldi_pkt_type type,\n\t\t\t\t    u32 txPower, u32 flags)", "code": "{\n\tstruct ar5416_desc *ads = AR5416DESC(ds);\n\n\tif (txPower > 63)\n\t\ttxPower = 63;\n\n\tads->ds_ctl0 = (pktLen & AR_FrameLen)\n\t\t| (flags & ATH9K_TXDESC_VMF ? AR_VirtMoreFrag : 0)\n\t\t| SM(txPower, AR_XmitPower)\n\t\t| (flags & ATH9K_TXDESC_VEOL ? AR_VEOL : 0)\n\t\t| (flags & ATH9K_TXDESC_CLRDMASK ? AR_ClrDestMask : 0)\n\t\t| (flags & ATH9K_TXDESC_INTREQ ? AR_TxIntrReq : 0);\n\n\tif (type != JALDI_PKT_TYPE_NORMAL)\n\t\tjaldi_print(JALDI_DEBUG, \"uh-oh! sending a packet of type %d in set11n_txdesc, should be 0.\\n\", type); \n\t\t\n\tads->ds_ctl1 =\n\t\t SM(type, AR_FrameType) \n\t\t| (flags & ATH9K_TXDESC_NOACK ? AR_NoAck : 0)\n\t\t| (flags & ATH9K_TXDESC_EXT_ONLY ? AR_ExtOnly : 0)\n\t\t| (flags & ATH9K_TXDESC_EXT_AND_CTL ? AR_ExtAndCtl : 0);\n\n\t/* We only support unencrypted traffic for now. */\n#define JALDI_KEY_TYPE_CLEAR 0\n\tads->ds_ctl6 = SM(JALDI_KEY_TYPE_CLEAR, AR_EncrType);\n\n\tif (AR_SREV_9285(hw) || AR_SREV_9271(hw)) {\n\t\tads->ds_ctl8 = 0;\n\t\tads->ds_ctl9 = 0;\n\t\tads->ds_ctl10 = 0;\n\t\tads->ds_ctl11 = 0;\n\t}\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* wait for a register value to be set to some desired value */\n", "func_signal": "bool jaldi_hw_wait(struct jaldi_hw *hw, u32 reg, u32 mask, u32 val, u32 timeout)", "code": "{\n\tint i;\n\n\tBUG_ON(timeout < JALDI_TIME_QUANTUM);\n\n\tfor (i = 0; i < (timeout / JALDI_TIME_QUANTUM); i++) {\n\t\tif ((REG_READ(hw, reg) & mask) == val)\n\t\t\treturn true;\n\n\t\tudelay(JALDI_TIME_QUANTUM);\n\t}\n\n\tjaldi_print(JALDI_WARN,\n\t\t  \"timeout (%d us) on reg 0x%x: 0x%08x & 0x%08x != 0x%08x\\n\",\n\t\t  timeout, reg, REG_READ(hw, reg), mask, val);\n\n\treturn false;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* Checks to see if we have a pending interrupt in hw \n * We use this when we're on a shared IRQ to identify our interrupts\n */\n", "func_signal": "bool jaldi_hw_intrpend(struct jaldi_hw *hw)", "code": "{\n\tu32 host_isr;\n\n\thost_isr = REG_READ(hw, AR_INTR_ASYNC_CAUSE);\n\n\tif ((host_isr & AR_INTR_MAC_IRQ) \n\t\t&& (host_isr != AR_INTR_SPURIOUS)) { return true; }\n\t\n\thost_isr = REG_READ(hw, AR_INTR_SYNC_CAUSE);\n\tif ((host_isr & AR_INTR_SYNC_DEFAULT) \n\t\t&& (host_isr != AR_INTR_SPURIOUS)) { return true; }\n\n\treturn false;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* hw init container. checks device is supported, then runs private init */\n", "func_signal": "int jaldi_hw_init(struct jaldi_hw *hw)", "code": "{\n\tint ret;\n\n\tDBG_START_MSG;\t\n\t/* These are all the AR5008/AR9001/AR9002 hardware family of chipsets */\n\tswitch (hw->hw_version.devid) {\n\tcase AR5416_DEVID_PCI:\n\tcase AR5416_DEVID_PCIE:\n\tcase AR5416_AR9100_DEVID:\n\tcase AR9160_DEVID_PCI:\n\tcase AR9280_DEVID_PCI:\n\tcase AR9280_DEVID_PCIE:\n\tcase AR9285_DEVID_PCIE:\n\tcase AR9287_DEVID_PCI:\n\tcase AR9287_DEVID_PCIE:\n\tcase AR2427_DEVID_PCIE:\n\tcase AR9300_DEVID_PCIE:\n\t\tbreak;\n\tdefault:\n\t\tif (hw->bus_ops->type == JALDI_USB)\n\t\t\tbreak;\n\t\tjaldi_print(JALDI_FATAL,\n\t\t\t  \"Hardware device ID 0x%04x not supported\\n\",\n\t\t\t  hw->hw_version.devid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = __jaldi_hw_init(hw);\n\tif (ret) {\n\t\tjaldi_print(JALDI_FATAL,\n\t\t\t  \"Unable to initialize hardware; \"\n\t\t\t  \"initialization status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/*****************************/\n/*     De-Initialization     */\n/*****************************/\n", "func_signal": "static void jaldi_deinit_softc(struct jaldi_softc *sc)", "code": "{\n\tDBG_START_MSG;\t\n\tint i = 0;\n\n\tfor (i = 0; i < JALDI_NUM_TX_QUEUES; i++)\n\t\tif (JALDI_TXQ_SETUP(sc, i))\n\t\t\tjaldi_tx_cleanupq(sc, &sc->tx.txq[i]);\n\n\tjaldi_hw_deinit(sc->hw);\n\n\ttasklet_kill(&sc->intr_tq);\n\n\tkfree(sc->hw);\n\tsc->hw = NULL;\n}", "path": "kerneldriver\\init.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/*\n * This can stop or re-enables RX.\n *\n * If bool is set this will kill any frame which is currently being\n * transferred between the MAC and baseband and also prevent any new\n * frames from getting started.\n */\n", "func_signal": "bool jaldi_hw_setrxabort(struct jaldi_hw *hw, bool set)", "code": "{\n\tu32 reg;\n\n\tDBG_START_MSG;\t\n\tif (set) {\n\t\tREG_SET_BIT(hw, AR_DIAG_SW,\n\t\t\t    (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));\n\n\t\tif (!jaldi_hw_wait(hw, AR_OBS_BUS_1, AR_OBS_BUS_1_RX_STATE,\n\t\t\t\t   0, JALDI_WAIT_TIMEOUT)) {\n\t\t\tREG_CLR_BIT(hw, AR_DIAG_SW,\n\t\t\t\t    (AR_DIAG_RX_DIS |\n\t\t\t\t     AR_DIAG_RX_ABORT));\n\n\t\t\treg = REG_READ(hw, AR_OBS_BUS_1);\n\t\t\tjaldi_print(JALDI_FATAL,\n\t\t\t\t  \"RX failed to go idle in 10 ms RXSM=0x%x\\n\",\n\t\t\t\t  reg);\n\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tREG_CLR_BIT(hw, AR_DIAG_SW,\n\t\t\t    (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));\n\t}\n\n\treturn true;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/************\n * ar5008 phy\n ************/\n", "func_signal": "static void jaldi_hw_init_baseband(struct jaldi_hw *hw,\n\t\t\t      struct jaldi_channel *chan)", "code": "{\n\tu32 synthDelay;\n\n\tsynthDelay = REG_READ(hw, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;\n\tif (IS_CHAN_B(chan))\n\t\tsynthDelay = (4 * synthDelay) / 22;\n\telse\n\t\tsynthDelay /= 10;\n\n\t/* Enables the phy */\n\tREG_WRITE(hw, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);\n\n\tudelay(synthDelay + BASE_ACTIVATE_DELAY);\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* bus ops */\n", "func_signal": "static void jaldi_pci_read_cachesize(struct jaldi_softc *sc, int *csz)", "code": "{\n\tu8 u8tmp;\n\tDBG_START_MSG;\n\tpci_read_config_byte(to_pci_dev(sc->dev), PCI_CACHE_LINE_SIZE, &u8tmp);\n\t*csz = (int)u8tmp;\n\n\t/* Apparently cache line size register sometimes is not set, so we check here */\n\tif (*csz == 0) { *csz = DEFAULT_CACHELINE >> 2; }\n}", "path": "kerneldriver\\pci.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/************\n * ar9002\n ************/\n", "func_signal": "void jaldi_hw_enable_async_fifo(struct jaldi_hw *hw)", "code": "{\n\tif (AR_SREV_9287_13_OR_LATER(hw)) {\n\t\tREG_SET_BIT(hw, AR_MAC_PCU_ASYNC_FIFO_REG3,\n\t\t\t\tAR_MAC_PCU_ASYNC_FIFO_REG3_DATAPATH_SEL);\n\t\tREG_SET_BIT(hw, AR_PHY_MODE, AR_PHY_MODE_ASYNCFIFO);\n\t\tREG_CLR_BIT(hw, AR_MAC_PCU_ASYNC_FIFO_REG3,\n\t\t\t\tAR_MAC_PCU_ASYNC_FIFO_REG3_SOFT_RESET);\n\t\tREG_SET_BIT(hw, AR_MAC_PCU_ASYNC_FIFO_REG3,\n\t\t\t\tAR_MAC_PCU_ASYNC_FIFO_REG3_SOFT_RESET);\n\t}\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* This function reads hardware version information from the device. It is \n * closely based upon ath9k_hw_read_revisions in a9k/hw.c. This is essentially\n * reading directly from HW registers, so its operation is a bit opaque.\n */\n", "func_signal": "static void jaldi_hw_read_versions(struct jaldi_hw *hw)", "code": "{\n\tu32 val;\n\tval = REG_READ(hw, AR_SREV) & AR_SREV_ID;\n\n\tif (val == 0xFF) {\n\t\tval = REG_READ(hw, AR_SREV);\n\t\thw->hw_version.macVersion =\n\t\t\t(val & AR_SREV_VERSION2) >> AR_SREV_TYPE2_S;\n\t\thw->hw_version.macRev = MS(val, AR_SREV_REVISION2); // TODO: unclear what this is doing, needs doc\n\t\thw->is_pciexpress = (val & AR_SREV_TYPE2_HOST_MODE) ? 0 : 1;\n\t} else {\n\t\tif (!AR_SREV_9100(hw))\n\t\t\thw->hw_version.macVersion = MS(val, AR_SREV_VERSION);\n\n\t\thw->hw_version.macRev = val & AR_SREV_REVISION;\n\n\t\tif (hw->hw_version.macVersion == AR_SREV_VERSION_5416_PCIE)\n\t\t\thw->is_pciexpress = true;\n\t}\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/************************************/\n/* HW Attach, Detach, Init Routines */\n/************************************/\n", "func_signal": "static void jaldi_hw_disablepcie(struct jaldi_hw *hw)", "code": "{\n\tif (AR_SREV_9100(hw))\n\t\treturn;\n\n\tENABLE_REGWRITE_BUFFER(hw);\n\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x9248fc00);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x24924924);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x28000029);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x57160824);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x25980579);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x00000000);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x1aaabe40);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0xbe105554);\n\tREG_WRITE(hw, AR_PCIE_SERDES, 0x000e1007);\n\n\tREG_WRITE(hw, AR_PCIE_SERDES2, 0x00000000);\n\n\tREGWRITE_BUFFER_FLUSH(hw);\n\tDISABLE_REGWRITE_BUFFER(hw);\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* We should not be putting device to sleep, so this should not be used */\n", "func_signal": "static void jaldi_set_power_sleep(struct jaldi_hw *hw, int setChip)", "code": "{\n\tREG_SET_BIT(hw, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\n\tif (setChip) {\n\t\t/*\n\t\t * Clear the RTC force wake bit to allow the\n\t\t * mac to go to sleep.\n\t\t */\n\t\tREG_CLR_BIT(hw, AR_RTC_FORCE_WAKE,\n\t\t\t    AR_RTC_FORCE_WAKE_EN);\n\t\tif (!AR_SREV_9100(hw) && !AR_SREV_9300_20_OR_LATER(hw))\n\t\t\tREG_WRITE(hw, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);\n\n\t\t/* Shutdown chip. Active low */\n\t\tif (!AR_SREV_5416(hw) && !AR_SREV_9271(hw))\n\t\t\tREG_CLR_BIT(hw, (AR_RTC_RESET),\n\t\t\t\t    AR_RTC_RESET_EN);\n\t}\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* XXX There's a lot of \"ATH9K\" in here: that means I haven't really studied \n * is going on here. However, they are mostly just constants, so I've left them\n * as is for expediency's sake. We're not looking at most of this anyway. */\n", "func_signal": "int jaldi_hw_rxprocdesc(struct jaldi_hw *hw, struct jaldi_desc *ds,\n\t\t\tstruct jaldi_rx_status *rs, u64 tsf)", "code": "{\n\tstruct ar5416_desc ads;\n\tstruct ar5416_desc *adsp = AR5416DESC(ds);\n\tu32 phyerr;\n\n\tif ((adsp->ds_rxstatus8 & AR_RxDone) == 0)\n\t\treturn -EINPROGRESS;\n\n\tads.u.rx = adsp->u.rx;\n\n\trs->rs_status = 0;\n\trs->rs_flags = 0;\n\n\trs->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;\n\trs->rs_tstamp = ads.AR_RcvTimestamp;\n\n\tif (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {\n\t\trs->rs_rssi = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ctl0 = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ctl1 = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ctl2 = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ext0 = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ext1 = JALDI_RSSI_BAD;\n\t\trs->rs_rssi_ext2 = JALDI_RSSI_BAD;\n\t} else {\n\t\trs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);\n\t\trs->rs_rssi_ctl0 = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt00);\n\t\trs->rs_rssi_ctl1 = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt01);\n\t\trs->rs_rssi_ctl2 = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt02);\n\t\trs->rs_rssi_ext0 = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt10);\n\t\trs->rs_rssi_ext1 = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt11);\n\t\trs->rs_rssi_ext2 = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt12);\n\t}\n\n\trs->rs_rate = RXSTATUS_RATE(hw, (&ads));\n\trs->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;\n\n\trs->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;\n\trs->rs_moreaggr =\n\t\t(ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;\n\trs->rs_antenna = MS(ads.ds_rxstatus3, AR_RxAntenna);\n\trs->rs_flags =\n\t\t(ads.ds_rxstatus3 & AR_GI) ? ATH9K_RX_GI : 0;\n\trs->rs_flags |=\n\t\t(ads.ds_rxstatus3 & AR_2040) ? ATH9K_RX_2040 : 0;\n\n\tif (ads.ds_rxstatus8 & AR_PreDelimCRCErr)\n\t\trs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;\n\tif (ads.ds_rxstatus8 & AR_PostDelimCRCErr)\n\t\trs->rs_flags |= ATH9K_RX_DELIM_CRC_POST;\n\tif (ads.ds_rxstatus8 & AR_DecryptBusyErr)\n\t\trs->rs_flags |= ATH9K_RX_DECRYPT_BUSY;\n\n\tif ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {\n\t\tif (ads.ds_rxstatus8 & AR_CRCErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_CRC;\n\t\telse if (ads.ds_rxstatus8 & AR_PHYErr) {\n\t\t\trs->rs_status |= ATH9K_RXERR_PHY;\n\t\t\tphyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);\n\t\t\trs->rs_phyerr = phyerr;\n\t\t} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_DECRYPT;\n\t\telse if (ads.ds_rxstatus8 & AR_MichaelErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_MIC;\n\t}\n\n\treturn 0;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/*******************/\n/* HW Capabilities */\n/*******************/\n", "func_signal": "int jaldi_hw_fill_cap_info(struct jaldi_hw *hw)", "code": "{\n\tDBG_START_MSG;\n\tstruct jaldi_hw_capabilities *pCap = &hw->caps;\n\tu16 capField = 0, eeval;\n\n\tcapField = hw->eep_ops->get_eeprom(hw, EEP_OP_CAP);\n\n\t/* Make sure at least one band is marked as supported */\n\teeval = hw->eep_ops->get_eeprom(hw, EEP_OP_MODE);\n\tif ((eeval & (AR5416_OPFLAGS_11G | AR5416_OPFLAGS_11A)) == 0) {\n\t\tjaldi_print(JALDI_FATAL,\n\t\t\t  \"no band has been marked as supported in EEPROM.\\n\");\n\t\treturn -EINVAL;\n\t} else if ((eeval & AR5416_OPFLAGS_11G) != 0) {\n\t\tjaldi_print(JALDI_WARN, \"This hardware only supports the 2GHz band.\\n\");\t\n\t}\n\n\t/* Read the wireless modes we support */\n\tbitmap_zero(pCap->wireless_modes, JALDI_MODE_MAX);\n\t\n\tif (eeval & AR5416_OPFLAGS_11A) {\n\t\tset_bit(JALDI_MODE_11A, pCap->wireless_modes);\n\t\tif (hw->ht_enable) {\n\t\t\tif (!(eeval & AR5416_OPFLAGS_N_5G_HT20))\n\t\t\t\tset_bit(JALDI_MODE_11NA_HT20,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\tif (!(eeval & AR5416_OPFLAGS_N_5G_HT40)) {\n\t\t\t\tset_bit(JALDI_MODE_11NA_HT40PLUS,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\t\tset_bit(JALDI_MODE_11NA_HT40MINUS,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (eeval & AR5416_OPFLAGS_11G) {\n\t\tset_bit(JALDI_MODE_11G, pCap->wireless_modes);\n\t\tif (hw->ht_enable) {\n\t\t\tif (!(eeval & AR5416_OPFLAGS_N_2G_HT20))\n\t\t\t\tset_bit(JALDI_MODE_11NG_HT20,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\tif (!(eeval & AR5416_OPFLAGS_N_2G_HT40)) {\n\t\t\t\tset_bit(JALDI_MODE_11NG_HT40PLUS,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\t\tset_bit(JALDI_MODE_11NG_HT40MINUS,\n\t\t\t\t\tpCap->wireless_modes);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ath9k does some special handling for setting up a temp rx chainmask for\n\t * ar9271 devices; pretty sure we don't need to do this for our purposes. */\n\tpCap->tx_chainmask = hw->eep_ops->get_eeprom(hw, EEP_TX_MASK);\n\tpCap->rx_chainmask = hw->eep_ops->get_eeprom(hw, EEP_RX_MASK);\n\n\tpCap->low_2ghz_chan = 2312;\n\tpCap->high_2ghz_chan = 2732;\n\n\tpCap->low_5ghz_chan = 4920;\n\tpCap->high_5ghz_chan = 6100;\n\t\n\t/* ath9k sets up crypto capabilities here (no eeprom read... just defaults \n\t * apparently), but we're omitting those here. */\n\n\tif (hw->ht_enable) /* set during hw_config_init */\n\t\tpCap->hw_caps |= JALDI_HW_CAP_HT;\n\telse\n\t\tpCap->hw_caps &= ~JALDI_HW_CAP_HT;\n\n\tpCap->hw_caps |= JALDI_HW_CAP_GTT;\n\tpCap->hw_caps |= JALDI_HW_CAP_VEOL;\n\tpCap->hw_caps |= JALDI_HW_CAP_BSSIDMASK;\n\tpCap->hw_caps &= ~JALDI_HW_CAP_MCAST_KEYSEARCH;\n\n\tif (capField & AR_EEPROM_EEPCAP_MAXQCU)\n\t\tpCap->total_queues =\n\t\t\tMS(capField, AR_EEPROM_EEPCAP_MAXQCU);\n\telse\n\t\tpCap->total_queues = JALDI_NUM_TX_QUEUES;\n\n\tpCap->hw_caps |= JALDI_HW_CAP_FASTCC;\n\n\tif (AR_SREV_9285(hw) || AR_SREV_9271(hw))\n\t\tpCap->tx_triglevel_max = MAX_TX_FIFO_THRESHOLD >> 1;\n\telse\n\t\tpCap->tx_triglevel_max = MAX_TX_FIFO_THRESHOLD;\n\n\tif (AR_SREV_9271(hw))\n\t\tpCap->num_gpio_pins = AR9271_NUM_GPIO;\n\telse if (AR_SREV_9285_10_OR_LATER(hw))\n\t\tpCap->num_gpio_pins = AR9285_NUM_GPIO;\n\telse if (AR_SREV_9280_10_OR_LATER(hw))\n\t\tpCap->num_gpio_pins = AR928X_NUM_GPIO;\n\telse\n\t\tpCap->num_gpio_pins = AR_NUM_GPIO;\n\n\tif (AR_SREV_9160_10_OR_LATER(hw) || AR_SREV_9100(hw)) {\n\t\tpCap->hw_caps |= JALDI_HW_CAP_CST;\n\t\tpCap->rts_aggr_limit = JALDI_AMPDU_LIMIT_MAX;\n\t} else {\n\t\tpCap->rts_aggr_limit = (8 * 1024);\n\t}\n\n\tpCap->hw_caps |= JALDI_HW_CAP_ENHANCEDPM;\n/* This is throwing a compile error for some reason... we don't really care about rfkill for our purposes though.\n#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))\n\thw->rfsilent = hw->eep_ops->get_eeprom(hw, EEP_RF_SILENT);\n\tif (hw->rfsilent & EEP_RFSILENT_ENABLED) {\n\t\thw->rfkill_gpio =\n\t\t\tMS(hw->rfsilent, EEP_RFSILENT_GPIO_SEL);\n\t\thw->rfkill_polarity =\n\t\t\tMS(hw->rfsilent, EEP_RFSILENT_POLARITY);\n\n\t\tpCap->hw_caps |= JALDI_HW_CAP_RFSILENT;\n\t}\n#endif\n\t*/\n\tif (AR_SREV_9271(hw) || AR_SREV_9300_20_OR_LATER(hw))\n\t\tpCap->hw_caps |= JALDI_HW_CAP_AUTOSLEEP;\n\telse\n\t\tpCap->hw_caps &= ~JALDI_HW_CAP_AUTOSLEEP;\n\n\tif (AR_SREV_9280(hw) || AR_SREV_9285(hw))\n\t\tpCap->hw_caps &= ~JALDI_HW_CAP_4KB_SPLITTRANS;\n\telse\n\t\tpCap->hw_caps |= JALDI_HW_CAP_4KB_SPLITTRANS;\n\t\n\t/* Removed regulatory (reg_cap) init here */\n\n\tpCap->num_antcfg_5ghz =\n\t\thw->eep_ops->get_num_ant_config(hw, JALDI_HAL_FREQ_BAND_5GHZ);\n\tpCap->num_antcfg_2ghz =\n\t\thw->eep_ops->get_num_ant_config(hw, JALDI_HAL_FREQ_BAND_2GHZ);\n\n\tif (AR_SREV_9300_20_OR_LATER(hw)) {\n\t\tpCap->hw_caps |= JALDI_HW_CAP_EDMA | JALDI_HW_CAP_LDPC |\n\t\t\t\t JALDI_HW_CAP_FASTCLOCK;\n\t\tpCap->rx_hp_qdepth = JALDI_HW_RX_HP_QDEPTH;\n\t\tpCap->rx_lp_qdepth = JALDI_HW_RX_LP_QDEPTH;\n\t\t/* We're ignoring ar9003 for now */\n//\t\tpCap->rx_status_len = sizeof(struct ar9003_rxs);\n//\t\tpCap->tx_desc_len = sizeof(struct ar9003_txc);\n//\t\tpCap->txs_len = sizeof(struct ar9003_txs);\n\t} else {\n\t\tpCap->tx_desc_len = sizeof(struct jaldi_desc);\n\t\tif (AR_SREV_9280_20(hw) &&\n\t\t    ((hw->eep_ops->get_eeprom(hw, EEP_MINOR_REV) <=\n\t\t      AR5416_EEP_MINOR_VER_16) ||\n\t\t     hw->eep_ops->get_eeprom(hw, EEP_FSTCLK_5G)))\n\t\t\tpCap->hw_caps |= JALDI_HW_CAP_FASTCLOCK;\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(hw))\n\t\tpCap->hw_caps |= JALDI_HW_CAP_RAC_SUPPORTED;\n\n\tif (AR_SREV_9287_10_OR_LATER(hw) || AR_SREV_9271(hw))\n\t\tpCap->hw_caps |= JALDI_HW_CAP_SGI_20;\n\n\treturn 0;\n}", "path": "kerneldriver\\hw.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/******/\n/* TX */\n/******/\n", "func_signal": "struct jaldi_txq *jaldi_txq_setup(struct jaldi_softc *sc, int qtype, int subtype)", "code": "{\n\tstruct jaldi_hw *hw = sc->hw;\n\tstruct jaldi_tx_queue_info qi;\n\tint qnum, i;\n\n\tmemset(&qi, 0, sizeof(qi));\n\tqi.tqi_subtype = subtype;\n\tqi.tqi_aifs = JALDI_TXQ_USEDEFAULT;\n\tqi.tqi_cwmin = JALDI_TXQ_USEDEFAULT;\n\tqi.tqi_cwmax = JALDI_TXQ_USEDEFAULT;\n\tqi.tqi_physCompBuf = 0;\n\n\t/* From ath9k:\n\t * \"Enable interrupts only for EOL and DESC conditions.\n\t * We mark tx descriptors to receive a DESC interrupt\n\t * when a tx queue gets deep; otherwise waiting for the\n\t * EOL to reap descriptors.  Note that this is done to\n\t * reduce interrupt load and this only defers reaping\n\t * descriptors, never transmitting frames.  Aside from\n\t * reducing interrupts this also permits more concurrency.\n\t * The only potential downside is if the tx queue backs\n\t * up in which case the top half of the kernel may backup\n\t * due to a lack of tx descriptors.\n\t *\n\t * The UAPSD queue is an exception, since we take a desc-\n\t * based intr on the EOSP frames.\" (note, we don't have uapsd)\n\t */\n\tif (hw->caps.hw_caps & JALDI_HW_CAP_EDMA) {\n\t\tqi.tqi_qflags = TXQ_FLAG_TXOKINT_ENABLE |\n\t\t\t\tTXQ_FLAG_TXERRINT_ENABLE;\n\t} else {\n\t\tqi.tqi_qflags = TXQ_FLAG_TXEOLINT_ENABLE |\n\t\t\t\tTXQ_FLAG_TXDESCINT_ENABLE;\n\t}\n\tqnum = jaldi_hw_setuptxqueue(hw, qtype, &qi);\n\tif (qnum == -1) {\n\t\t/*\n\t\t * NB: don't print a message, this happens\n\t\t * normally on parts with too few tx queues\n\t\t */\n\t\tjaldi_print(JALDI_DEBUG, \"txq setup failed.\\n\"); /* just for debugging... */\n\t\treturn NULL;\n\t}\n\tif (qnum >= ARRAY_SIZE(sc->tx.txq)) {\n\t\tjaldi_print(JALDI_FATAL,\n\t\t\t  \"qnum %u out of range, max %u!\\n\",\n\t\t\t  qnum, (unsigned int)ARRAY_SIZE(sc->tx.txq));\n\t\tjaldi_hw_releasetxqueue(hw, qnum);\n\t\treturn NULL;\n\t}\n\tif (!JALDI_TXQ_SETUP(sc, qnum)) {\n\t\tstruct jaldi_txq *txq = &sc->tx.txq[qnum];\n\n\t\ttxq->axq_qnum = qnum;\n\t\ttxq->axq_link = NULL;\n\t\tINIT_LIST_HEAD(&txq->axq_q);\n\t\tINIT_LIST_HEAD(&txq->axq_acq);\n\t\tspin_lock_init(&txq->axq_lock);\n\t\ttxq->axq_depth = 0;\n\t\ttxq->axq_tx_inprogress = false;\n\t\tsc->tx.txqsetup |= 1<<qnum;\n\n\t\ttxq->txq_headidx = txq->txq_tailidx = 0;\n\t\tfor (i = 0; i < JALDI_TXFIFO_DEPTH; i++)\n\t\t\tINIT_LIST_HEAD(&txq->txq_fifo[i]);\n\t\tINIT_LIST_HEAD(&txq->txq_fifo_pending);\n\t}\n\treturn &sc->tx.txq[qnum];\n}", "path": "kerneldriver\\main.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/*\n * TODO: this is where ifconfig starts our driver. we need to integrate this \n * with the rest of the driver. Should establish DMA, do the hw reset, all that\n * jazz. This should also be where we call whatever actually disables the acks\n * and carrier sense: that should not be done during HW initialization.\n */\n", "func_signal": "int jaldi_open(struct net_device *dev)", "code": "{\n\tstruct jaldi_softc *sc = netdev_priv(dev);\n\tstruct jaldi_hw *hw = sc->hw;\n\tstruct jaldi_channel *init_chan;\n\tint r;\n\n\tDBG_START_MSG;\n\n\tmutex_lock(&sc->mutex);\n\n\t/* set default channel if none specified */\n\tif (!hw->curchan) {\n\t\tinit_chan = &sc->chans[JALDI_5GHZ][0]; /* default is chan 36 (5180Mhz, 14) */\n\t\thw->curchan = init_chan;\n\t}\n\n\tmemcpy(dev->dev_addr, sc->macaddr, ETH_ALEN);\n\n\tspin_lock_bh(&sc->sc_resetlock);\n\tr = jaldi_hw_reset(hw, init_chan, true); /* we're settnig channel for first time so always true */\n\tif (r) {\n\t\tjaldi_print(JALDI_FATAL, \"Unable to reset hw; reset status %d (freq %u MHz)\\n\",\n\t\t\t\tr, init_chan->center_freq);\n\t\tspin_unlock_bh(&sc->sc_resetlock);\n\t\tgoto mutex_unlock;\n\t}\n\tspin_unlock_bh(&sc->sc_resetlock);\n\n\tif (jaldi_startrecv(sc) != 0) {\n\t\tjaldi_print(JALDI_FATAL,\n\t\t\t  \"Unable to restart recv logic\\n\");\n\t\tr = -EIO;\n\t\tgoto mutex_unlock;\n\t}\n\n\tOHAI;\n\n\thw->imask = JALDI_INT_TX | JALDI_INT_RXEOL | JALDI_INT_RXORN \n\t\t\t| JALDI_INT_RX | JALDI_INT_FATAL | JALDI_INT_GLOBAL;\n\n\tjaldi_radio_enable(sc);\n\n\tnetif_start_queue(dev);\n\nmutex_unlock:\n\tmutex_unlock(&sc->mutex);\n\n\treturn r;\n}", "path": "kerneldriver\\main.c", "repo_name": "shaddi/jaldimac", "stars": 21, "license": "None", "language": "c", "size": 1415}
{"docstring": "/* send test pattern to remote device */\n/* gfxtest <dst8> */\n", "func_signal": "static void cmd_gfxtest(void)", "code": "{\n    argc--;\n    if (argc == 1)\n    {\n        data uint8_t *buf;\n        uint8_t x, y;\n        uint8_t dst = parse_number(argv[1]);\n        const uint8_t patt[8] = {0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F};\n\n        for (y=0;y<8;y++)\n        {\n            for (x=0;x<16;x++)\n            {\n                buf = packet_build(PACKET_TYPE_GFXPLOTLINE, 8 + 2);\n                *buf++ = x << 3;\n                *buf++ = y;\n                *buf++ = patt[0];\n                *buf++ = patt[1];\n                *buf++ = patt[2];\n                *buf++ = patt[3];\n                *buf++ = patt[4];\n                *buf++ = patt[5];\n                *buf++ = patt[6];\n                *buf++ = patt[7];\n                packet_send(parse_number(argv[1]), 0x00);\n            }\n        }\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* get/set ram */\n/* pdata <addr16> [data8] */\n", "func_signal": "static void cmd_pdata(void)", "code": "{\n    uint16_t addr, val;\n\n    switch(argc)\n    {\n        case 1: /* get */\n            if (addr = parse_number(argv[1]))\n            {\n                __pdata volatile unsigned char *p = (__pdata volatile unsigned char *)(addr);\n                \n                console_putc('*');\n                console_puthex16(addr);\n                console_putc('=');\n                console_puthex8(*p);\n                console_newline();\n            }\n            else\n            {\n                return;\n            }\n\n        /* DROP THROUGH */\n\n        case 2: /* set */\n            if (val = parse_number(argv[2]))\n            {\n                __pdata volatile unsigned char *p = (__pdata volatile unsigned char *)(val);\n                *p = val;\n            }\n        break;\n\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* in key mode, poll for keypress */\n", "func_signal": "bool console_key_poll(uint8_t *c)", "code": "{\n    if (got_key)\n    {\n        *c = last_key;\n        got_key = false;\n        return true;\n    }\n    return false;\n}", "path": "common\\console.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* get/set xram */\n/* xdata <addr16> [data8] */\n", "func_signal": "static void cmd_xdata(void)", "code": "{\n    uint16_t addr, val;\n\n    argc--;\n\n    if (argc < 1)\n        return;\n\n    addr = parse_number(argv[1]);\n\n    switch(argc)\n    {\n        case 1: /* get */\n            console_putc('*');\n            console_puthex16(addr);\n            console_putc('=');\n            console_puthex8(*((__xdata volatile unsigned char *)addr));\n            console_newline();\n\n        /* DROP THROUGH */\n\n        case 2: /* set */\n            val = parse_number(argv[2]);\n            *((__xdata volatile unsigned char *)addr) = val;\n        break;\n\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* build and send a packet */\n/* tx <dst8> <seq8> <typ8> <str> */\n", "func_signal": "static void cmd_tx(void)", "code": "{\n    argc--;\n    if (argc > 3)\n    {\n        uint8_t len;\n        data uint8_t *buf;\n\n        len = strlen(argv[4]);\n        buf = packet_build(parse_number(argv[3]), len);\n        while(*argv[4])\n            *buf++ = *argv[4]++;\n        packet_send(parse_number(argv[1]), parse_number(argv[2]));\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* check for complete line buffer and execute */\n", "func_signal": "void console_tick(void)", "code": "{\n    if (linemode)\n    {\n        if (got_eol)\n        {\n            if (linebuf_tail > 0)\n            {\n                linebuf[linebuf_tail] = 0; // terminate it\n                shell_exec(linebuf);\n            }\n            linebuf_tail = 0;\n            console_prompt();\n            got_eol = false;\n        }\n    }\n}", "path": "common\\console.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/*\n * All this DMA and clock nonsense is based on the Errata Note (swrz022b) which\n * describes a workaround for \"Part May Hang in Power Mode.\"  Timing is\n * critical here.  Do not edit this function without reading the Errata Note.\n */\n", "func_signal": "void sleep()", "code": "{\n\tvolatile u8 desc_high = DMA0CFGH;\n\tvolatile u8 desc_low = DMA0CFGL;\n\txdata u8 dma_buf[7] = {0x07,0x07,0x07,0x07,0x07,0x07,0x04};\n\txdata u8 dma_desc[8] = {0x00,0x00,0xDF,0xBE,0x00,0x07,0x20,0x42};\n\n\t/* switch to HS RCOSC */\n\tSLEEP &= ~SLEEP_OSC_PD;\n\twhile (!(SLEEP & SLEEP_HFRC_S));\n\tCLKCON = (CLKCON & ~CLKCON_CLKSPD) | CLKCON_OSC | CLKSPD_DIV_2;\n\twhile (!(CLKCON & CLKCON_OSC));\n\tSLEEP |= SLEEP_OSC_PD;\n\n\tsetup_pm_interrupt();\n\n\t/* store descriptors and abort any transfers */\n\tdesc_high = DMA0CFGH;\n\tdesc_low = DMA0CFGL;\n\tDMAARM |= (DMAARM_ABORT | DMAARM0);\n\n\t/* DMA prep */\n\tdma_desc[0] = (u16)&dma_buf >> 8;\n\tdma_desc[1] = (u16)&dma_buf;\n\tDMA0CFGH = (u16)&dma_desc >> 8;\n\tDMA0CFGL = (u16)&dma_desc;\n\tDMAARM = DMAARM0;\n\n\t/*\n\t * Any interrupts not intended to wake from sleep should be\n\t * disabled by this point.\n\t */\n\n\t/* disable flash cache */\n\tMEMCTR |= MEMCTR_CACHD;\n\n\t/* select sleep mode PM3 and power down XOSC */\n\tSLEEP |= (SLEEP_MODE_PM3 | SLEEP_OSC_PD);\n\n\t__asm\n   \tnop\n   \tnop\n   \tnop\n\t__endasm;\n\n\tif (SLEEP & SLEEP_MODE_PM3) {\n\t\t__asm\n\t\tmov 0xD7,#0x01 /* DMAREQ */\n\t\tnop\n\t\torl 0x87,#0x01 /* last instruction before sleep */\n\t\tnop            /* first instruction after wake */\n\t\t__endasm;\n\t}\n\n\t/* enable flash cache */\n\tMEMCTR &= ~MEMCTR_CACHD;\n\n\t/* restore DMA */\n\tDMA0CFGH = desc_high;\n\tDMA0CFGL = desc_low;\n\tDMAARM = DMAARM0;\n\n\t/* make sure HS RCOSC is stable */\n\twhile (!(SLEEP & SLEEP_HFRC_S));\n}", "path": "apps\\speccan\\pm.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* set a remote led */\n/* teleled <dst8> <bool> */\n", "func_signal": "static void cmd_teleled(void)", "code": "{\n    argc--;\n    if (argc == 2)\n    {\n        data uint8_t *buf;\n\n        buf = packet_build(PACKET_TYPE_LED, 1);\n        *buf = parse_number(argv[2]);\n        packet_send(parse_number(argv[1]), PACKET_SEQ_REQ_ACK);\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* send a control byte */\n", "func_signal": "static void txCtl(uint8_t ch)", "code": "{\n    LCD_A0 = 0;\n    spi_tx(ch);\n}", "path": "common\\lcd.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* control local led */\n/* led <bool> */\n", "func_signal": "static void cmd_led(void)", "code": "{\n    if (argc > 1)\n    {\n        switch(parse_number(argv[1]))\n        {\n            case 0: led_off(); return;\n            case 1: led_on(); return;\n            default: led_toggle(); return;\n        }\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* receive a character, called under interrupt */\n", "func_signal": "void console_rx_callback(uint8_t c)", "code": "{\n    if (!linemode)\n    {\n        got_key = true;\n        last_key = c;\n    }\n    else\n    {\n        if (got_eol) /* throw away characters until line is processed */\n            return;\n\n        switch(c)\n        {\n            case 0x0D:\n                got_eol = true;\n                pending = PENDING_NEWLINE;\n                break;\n            case '\\b': /* backspace */\n            case 0x7F: /* delete */\n                if (linebuf_tail > 0)\n                {\n                    linebuf_tail--;\n                    pending = PENDING_BACKSPACE;\n                }\n                break;\n            default:\n                if (linebuf_tail < sizeof(linebuf)-1)\n                {\n                    pending = PENDING_CHAR;\n                    linebuf[linebuf_tail++] = c;\n                }\n                else\n                {\n                    pending = PENDING_BELL;\n                }\n                break;\n        }\n    }\n\n    /* FIXME shouldn't be doing this in ISR */\n    handle_pending();\n}", "path": "common\\console.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* is console ready to receive? */\n", "func_signal": "bool console_rx_ready_callback(void)", "code": "{\n    if (linemode)\n        return !got_eol;\n    else\n        return true;\n}", "path": "common\\console.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* plot 8x8 pixels on remote device */\n/* gfxplot <dst8> <x> <y> HHHHHHHHHHHHHHHH */\n", "func_signal": "static void cmd_gfxplot(void)", "code": "{\n    // addr x y <hexdata*8>\n    argc--;\n    if (argc == 4)\n    {\n        data uint8_t *buf;\n\n        buf = packet_build(PACKET_TYPE_GFXPLOTLINE, 8 + 2);\n        *buf++ = parse_number(argv[2]);\n        *buf++ = parse_number(argv[3]);\n        parse_hexdata(argv[4], buf, 8);\n        packet_send(parse_number(argv[1]), 0x00);\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* set cursor position */\n", "func_signal": "void lcd_setPos(uint8_t x, uint8_t y)", "code": "{\n    txCtl(0xb0 + y);\n    txCtl(0x00 + (x & 0x0f));\n    txCtl(0x10 + ( (x>>4) & 0x0f));\n}", "path": "common\\lcd.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* clear every pixel - even on the edge */\n", "func_signal": "void lcd_cls(uint8_t ch)", "code": "{\n    uint8_t y, x;\n    for (y=0;y<9;y++)\n    {\n        lcd_setPos(0, y);\n        for (x=0;x<132;x++)\n            lcd_txData(ch);\n    }\n}", "path": "common\\lcd.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* power button interrupt service routine */\n", "func_signal": "void port1_isr() __interrupt (P1INT_VECTOR)", "code": "{\n\t/* clear the interrupt flags */\n\tP1IFG &= ~BIT6;\n\tP1IF = 0;\n\n\t/* clear sleep mode bits */\n\tSLEEP &= ~SLEEP_MODE;\n}", "path": "apps\\speccan\\pm.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* send a data byte */\n", "func_signal": "void lcd_txData(uint8_t ch)", "code": "{\n    LCD_A0 = 1;\n    spi_tx(ch);\n}", "path": "common\\lcd.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* write pending control character responses */\n", "func_signal": "static void handle_pending(void)", "code": "{\n    switch(pending)\n    {\n        case PENDING_BELL:\n        console_putc('\\a');\n        break;\n\n        case PENDING_NEWLINE:\n        console_newline();\n        break;\n\n        case PENDING_CHAR:\n        console_putc(linebuf[linebuf_tail-1]);\n        break;\n\n        case PENDING_BACKSPACE:\n        console_putc('\\b');\n        console_putc(' ');\n        console_putc('\\b');\n        break;\n\n        default:\n        case PENDING_NONE:\n        break;\n    }\n    pending = PENDING_NONE;\n}", "path": "common\\console.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* enable graphics mode on a remote device */\n/* gfxinit <dst8> */\n", "func_signal": "static void cmd_gfxinit(void)", "code": "{\n    argc--;\n    if (argc == 1)\n    {\n        packet_build(PACKET_TYPE_GFXINIT, 0);\n        packet_send(parse_number(argv[1]), PACKET_SEQ_REQ_ACK);\n    }\n}", "path": "pinkos\\shell.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* prepare an interrupt for the power button so it will wake us up */\n", "func_signal": "void setup_pm_interrupt()", "code": "{\n\t/* clear the interrupt flags */\n\tP1IFG &= ~BIT6;\n\tP1IF = 0;\n\n\t/* enable interrupt on power button */\n\tP1IEN = BIT6;\n\n\t/* enable interrupts on the port */\n\tIEN2 |= IEN2_P1IE;\n\n\t/* produce interrupts on falling edge */\n\tPICTL |= PICTL_P1ICON;\n\n\t/* enable interrupts globally */\n\tEA = 1;\n}", "path": "apps\\speccan\\pm.c", "repo_name": "tobyjaffey/pinkos", "stars": 17, "license": "None", "language": "c", "size": 172}
{"docstring": "/* One receiver per fd */\n", "func_signal": "static void *receiver(struct receiver_context* ctx)", "code": "{\n\tunsigned int i;\n\n\treset_worker_signals();\n\tif (process_mode == PROCESS_MODE)\n\t\tclose(ctx->in_fds[1]);\n\n\t/* Wait for start... */\n\tready(ctx->ready_out, ctx->wakefd);\n\n\t/* Receive them all */\n\tfor (i = 0; i < ctx->num_packets; i++) {\n\t\tchar data[datasize];\n\t\tint ret, done = 0;\n\nagain:\n\t\tret = read(ctx->in_fds[0], data + done, datasize - done);\n\t\tif (ret < 0)\n\t\t\tbarf(\"SERVER: read\");\n\t\tdone += ret;\n\t\tif (done < datasize)\n\t\t\tgoto again;\n\t}\n\tif (ctx) {\n\t\tfree(ctx);\n\t}\n\treturn NULL;\n}", "path": "src\\hackbench\\hackbench.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* clear all watchdog counters */\n", "func_signal": "void watchdog_clear(void)", "code": "{\n\tint i;\n\tfor (i = 0; i < ngroups; i++)\n\t\tgroups[i].watchdog = 0;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* Process commandline options */\n", "func_signal": "static void process_options (int argc, char *argv[])", "code": "{\n\tint error = 0;\n\tfor (;;) {\n\t\tint option_index = 0;\n\t\t/** Options for getopt */\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"breaktrace\", required_argument, NULL, 'b'},\n\t\t\t{\"loops\", required_argument, NULL, 'l'},\n\t\t\t{\"priority\", required_argument, NULL, 'p'},\n\t\t\t{\"quiet\", no_argument, NULL, 'q'},\n\t\t\t{\"threads\", required_argument, NULL, 't'},\n\t\t\t{\"verbose\", no_argument, NULL, 'v'},\n\t\t\t{\"mlockall\", no_argument, NULL, 'm'},\n\t\t\t{\"help\", no_argument, NULL, '?'},\n\t\t\t{NULL, 0, NULL, 0}\n\t\t};\n\t\tint c = getopt_long (argc, argv, \"b:c:d:i:l:np:qrsmt:v\",\n\t\t\tlong_options, &option_index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'b': tracelimit = atoi(optarg); break;\n\t\tcase 'l': max_cycles = atoi(optarg); break;\n\t\tcase 'p': priority = atoi(optarg); break;\n\t\tcase 'q': quiet = 1; break;\n\t\tcase 't': num_threads = atoi(optarg); break;\n\t\tcase 'm': lockall = 1; break;\n\t\tcase 'v': verbose = 1; break;\n\t\tcase '?': error = 1; break;\n\t\t}\n\t}\n\n\tif (priority < 0 || priority > 99)\n\t\terror = 1;\n\n\tif (num_threads < 2)\n\t\terror = 1;\n\n\tif (error)\n\t\tdisplay_help ();\n}", "path": "src\\signaltest\\signaltest.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* Process commandline options */\n", "func_signal": "static void process_options (int argc, char *argv[])", "code": "{\n\tint error = 0;\n\tint max_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\tfor (;;) {\n\t\tint option_index = 0;\n\t\t/** Options for getopt */\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"affinity\", optional_argument, NULL, 'a'},\n\t\t\t{\"breaktrace\", required_argument, NULL, 'b'},\n\t\t\t{\"preemptirqs\", no_argument, NULL, 'B'},\n\t\t\t{\"clock\", required_argument, NULL, 'c'},\n\t\t\t{\"context\", no_argument, NULL, 'C'},\n\t\t\t{\"distance\", required_argument, NULL, 'd'},\n\t\t\t{\"event\", no_argument, NULL, 'E'},\n\t\t\t{\"ftrace\", no_argument, NULL, 'f'},\n\t\t\t{\"histogram\", required_argument, NULL, 'h'},\n\t\t\t{\"histofall\", required_argument, NULL, 'H'},\n\t\t\t{\"interval\", required_argument, NULL, 'i'},\n\t\t\t{\"irqsoff\", no_argument, NULL, 'I'},\n\t\t\t{\"loops\", required_argument, NULL, 'l'},\n\t\t\t{\"mlockall\", no_argument, NULL, 'm' },\n\t\t\t{\"refresh_on_max\", no_argument, NULL, 'M' },\n\t\t\t{\"nanosleep\", no_argument, NULL, 'n'},\n\t\t\t{\"nsecs\", no_argument, NULL, 'N'},\n\t\t\t{\"oscope\", required_argument, NULL, 'o'},\n\t\t\t{\"priority\", required_argument, NULL, 'p'},\n                        {\"policy\", required_argument, NULL, 'y'},\n\t\t\t{\"preemptoff\", no_argument, NULL, 'P'},\n\t\t\t{\"quiet\", no_argument, NULL, 'q'},\n\t\t\t{\"relative\", no_argument, NULL, 'r'},\n\t\t\t{\"system\", no_argument, NULL, 's'},\n\t\t\t{\"threads\", optional_argument, NULL, 't'},\n\t\t\t{\"unbuffered\", no_argument, NULL, 'u'},\n\t\t\t{\"verbose\", no_argument, NULL, 'v'},\n\t\t\t{\"duration\",required_argument, NULL, 'D'},\n                        {\"wakeup\", no_argument, NULL, 'w'},\n                        {\"wakeuprt\", no_argument, NULL, 'W'},\n\t\t\t{\"help\", no_argument, NULL, '?'},\n\t\t\t{\"tracer\", required_argument, NULL, 'T'},\n\t\t\t{\"traceopt\", required_argument, NULL, 'O'},\n\t\t\t{\"smp\", no_argument, NULL, 'S'},\n\t\t\t{\"numa\", no_argument, NULL, 'U'},\n\t\t\t{\"latency\", required_argument, NULL, 'e'},\n\t\t\t{NULL, 0, NULL, 0}\n\t\t};\n\t\tint c = getopt_long(argc, argv, \"a::b:Bc:Cd:Efh:H:i:Il:MnNo:O:p:PmqrsSt::uUvD:wWT:y:e:\",\n\t\t\t\t    long_options, &option_index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tif (smp) {\n\t\t\t\twarn(\"-a ignored due to --smp\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (optarg != NULL) {\n\t\t\t\taffinity = atoi(optarg);\n\t\t\t\tsetaffinity = AFFINITY_SPECIFIED;\n\t\t\t} else if (optind<argc && atoi(argv[optind])) {\n\t\t\t\taffinity = atoi(argv[optind]);\n\t\t\t\tsetaffinity = AFFINITY_SPECIFIED;\n\t\t\t} else {\n\t\t\t\tsetaffinity = AFFINITY_USEALL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': tracelimit = atoi(optarg); break;\n\t\tcase 'B': tracetype = PREEMPTIRQSOFF; break;\n\t\tcase 'c': clocksel = atoi(optarg); break;\n\t\tcase 'C': tracetype = CTXTSWITCH; break;\n\t\tcase 'd': distance = atoi(optarg); break;\n\t\tcase 'E': enable_events = 1; break;\n\t\tcase 'f': tracetype = FUNCTION; ftrace = 1; break;\n\t\tcase 'H': histofall = 1; /* fall through */\n\t\tcase 'h': histogram = atoi(optarg); break;\n\t\tcase 'i': interval = atoi(optarg); break;\n\t\tcase 'I':\n\t\t\tif (tracetype == PREEMPTOFF) {\n\t\t\t\ttracetype = PREEMPTIRQSOFF;\n\t\t\t\tstrncpy(tracer, \"preemptirqsoff\", sizeof(tracer));\n\t\t\t} else {\n\t\t\t\ttracetype = IRQSOFF;\n\t\t\t\tstrncpy(tracer, \"irqsoff\", sizeof(tracer));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': max_cycles = atoi(optarg); break;\n\t\tcase 'n': use_nanosleep = MODE_CLOCK_NANOSLEEP; break;\n\t\tcase 'N': use_nsecs = 1; break;\n\t\tcase 'o': oscope_reduction = atoi(optarg); break;\n\t\tcase 'O': traceopt(optarg); break;\n\t\tcase 'p': \n\t\t\tpriority = atoi(optarg); \n\t\t\tif (policy != SCHED_FIFO && policy != SCHED_RR)\n\t\t\t\tpolicy = SCHED_FIFO;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (tracetype == IRQSOFF) {\n\t\t\t\ttracetype = PREEMPTIRQSOFF;\n\t\t\t\tstrncpy(tracer, \"preemptirqsoff\", sizeof(tracer));\n\t\t\t} else {\n\t\t\t\ttracetype = PREEMPTOFF;\n\t\t\t\tstrncpy(tracer, \"preemptoff\", sizeof(tracer));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': quiet = 1; break;\n\t\tcase 'r': timermode = TIMER_RELTIME; break;\n\t\tcase 's': use_system = MODE_SYS_OFFSET; break;\n\t\tcase 't':\n\t\t\tif (smp) {\n\t\t\t\twarn(\"-t ignored due to --smp\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (optarg != NULL)\n\t\t\t\tnum_threads = atoi(optarg);\n\t\t\telse if (optind<argc && atoi(argv[optind]))\n\t\t\t\tnum_threads = atoi(argv[optind]);\n\t\t\telse\n\t\t\t\tnum_threads = max_cpus;\n\t\t\tbreak;\n\t\tcase 'T': \n\t\t\ttracetype = CUSTOM;\n\t\t\tstrncpy(tracer, optarg, sizeof(tracer)); \n\t\t\tbreak;\n\t\tcase 'u': setvbuf(stdout, NULL, _IONBF, 0); break;\n\t\tcase 'v': verbose = 1; break;\n\t\tcase 'm': lockall = 1; break;\n\t\tcase 'M': refresh_on_max = 1; break;\n\t\tcase 'D': duration = parse_time_string(optarg);\n\t\t\tbreak;\n                case 'w': tracetype = WAKEUP; break;\n                case 'W': tracetype = WAKEUPRT; break;\n                case 'y': handlepolicy(optarg); break;\n\t\tcase 'S':  /* SMP testing */\n\t\t\tif (numa)\n\t\t\t\tfatal(\"numa and smp options are mutually exclusive\\n\");\n\t\t\tsmp = 1;\n\t\t\tnum_threads = max_cpus;\n\t\t\tsetaffinity = AFFINITY_USEALL;\n\t\t\tuse_nanosleep = MODE_CLOCK_NANOSLEEP;\n\t\t\tbreak;\n\t\tcase 'U':  /* NUMA testing */\n\t\t\tif (smp)\n\t\t\t\tfatal(\"numa and smp options are mutually exclusive\\n\");\n#ifdef NUMA\n\t\t\tnuma = 1;\n\t\t\tnum_threads = max_cpus;\n\t\t\tsetaffinity = AFFINITY_USEALL;\n\t\t\tuse_nanosleep = MODE_CLOCK_NANOSLEEP;\n#else\n\t\t\twarn(\"cyclictest was not built with the numa option\\n\");\n\t\t\twarn(\"ignoring --numa or -U\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'e': /* power management latency target value */\n\t\t\t  /* note: default is 0 (zero) */\n\t\t\tlatency_target_value = atoi(optarg);\n\t\t\tif (latency_target_value < 0)\n\t\t\t\tlatency_target_value = 0;\n\t\t\tbreak;\n\n\t\tcase '?': display_help(0); break;\n\t\t}\n\t}\n\n\tif (setaffinity == AFFINITY_SPECIFIED) {\n\t\tif (affinity < 0)\n\t\t\terror = 1;\n\t\tif (affinity >= max_cpus) {\n\t\t\twarn(\"CPU #%d not found, only %d CPUs available\\n\",\n\t\t\t    affinity, max_cpus);\n\t\t\terror = 1;\n\t\t}\n\t} else if (tracelimit)\n\t\tfileprefix = procfileprefix;\n\n\tif (clocksel < 0 || clocksel > ARRAY_SIZE(clocksources))\n\t\terror = 1;\n\n\tif (oscope_reduction < 1)\n\t\terror = 1;\n\n\tif (oscope_reduction > 1 && !verbose) {\n\t\twarn(\"-o option only meaningful, if verbose\\n\");\n\t\terror = 1;\n\t}\n\n\tif (histogram < 0)\n\t\terror = 1;\n\n\tif (histogram > HIST_MAX)\n\t\thistogram = HIST_MAX;\n\n\tif (histogram && distance != -1)\n\t\twarn(\"distance is ignored and set to 0, if histogram enabled\\n\");\n\tif (distance == -1)\n\t\tdistance = DEFAULT_DISTANCE;\n\n\tif (priority < 0 || priority > 99)\n\t\terror = 1;\n\n\tif (priority && (policy != SCHED_FIFO && policy != SCHED_RR)) {\n\t\tfprintf(stderr, \"policy and priority don't match: setting policy to SCHED_FIFO\\n\");\n\t\tpolicy = SCHED_FIFO;\n\t}\n\n\tif ((policy == SCHED_FIFO || policy == SCHED_RR) && priority == 0) {\n\t\tfprintf(stderr, \"defaulting realtime priority to %d\\n\", \n\t\t\tnum_threads+1);\n\t\tpriority = num_threads+1;\n\t}\n\n\tif (num_threads < 1)\n\t\terror = 1;\n\n\tif (error)\n\t\tdisplay_help(1);\n}", "path": "src\\cyclictest\\cyclictest.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* print an error message and return */\n", "func_signal": "void err_msg(char *fmt, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap, fmt);\n\terr_doit(0, fmt, ap);\n\tva_end(ap);\n\treturn;\n}", "path": "src\\lib\\error.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* set up a test group */\n", "func_signal": "int initialize_group(struct group_parameters *group)", "code": "{\n\tint status;\n\tpthread_mutexattr_t mutex_attr;\n\n\tgroup->inversions = inversions;\n\n\t/* setup default attributes for the group mutex */\n\t/* (make it a PI mutex) */\n\tstatus = pthread_mutexattr_init(&mutex_attr);\n\tif (status) {\n\t\terror(\"initializing mutex attribute: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\n\t/* set priority inheritance attribute for mutex */\n\tstatus = pthread_mutexattr_setprotocol(&mutex_attr,\n\t\t\t\t\t       PTHREAD_PRIO_INHERIT);\n\tif (status) {\n\t\terror(\"setting mutex attribute policy: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\t/* initialize the group mutex */\n\tstatus = pthread_mutex_init(&group->mutex, &mutex_attr);\n\tif (status) {\n\t\terror(\"initializing mutex: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\n\t/* initialize the group barriers */\n\tif (barrier_init(&group->start_barrier, NULL, NUM_TEST_THREADS,\n\t\t\t \"start_barrier\"))\n\t\treturn FAILURE;\n\n\tif (barrier_init(&group->locked_barrier, NULL, 2, \"locked_barrier\"))\n\t\treturn FAILURE;\n\n\tif (barrier_init(&group->elevate_barrier, NULL, 2, \"elevate_barrier\"))\n\t\treturn FAILURE;\n\n\tif (barrier_init\n\t    (&group->finish_barrier, NULL, NUM_TEST_THREADS, \"finish_barrier\"))\n\t\treturn FAILURE;\n\n\tif (barrier_init(&group->loop_barr, NULL, NUM_TEST_THREADS,\n\t\t\t \"loop_barrier\"))\n\t\treturn FAILURE;\n\n\tif ((status = pthread_mutex_init(&group->loop_mtx, NULL)) != 0) {\n\t\terror(\"pthread_mutex_init, status = %d\\n\", status);\n\t\treturn FAILURE;\n\t}\n\n\tif ((status = pthread_mutex_lock(&group->loop_mtx)) != 0) {\n\t\terror(\"pthread_mutex_lock, status = %d\\n\", status);\n\t\treturn FAILURE;\n\t}\n\n\tgroup->loop = 1;\n\n\tif ((status = pthread_mutex_unlock(&group->loop_mtx)) != 0) {\n\t\terror(\"pthread_mutex_unlock, status = %d\\n\", status);\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* allow SIGTERM delivery (called from worker threads) */\n", "func_signal": "int allow_sigterm(void)", "code": "{\n\tint status;\n\tsigset_t sigset;\n\n\tstatus = sigemptyset(&sigset);\n\tif (status) {\n\t\terror(\"creating empty signal set: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\tstatus = sigaddset(&sigset, SIGTERM);\n\tif (status) {\n\t\terror(\"adding SIGTERM to signal set: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\tstatus = pthread_sigmask(SIG_UNBLOCK, &sigset, NULL);\n\tif (status) {\n\t\terror(\"unblocking SIGTERM: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* setup and create a groups threads */\n", "func_signal": "int create_group(struct group_parameters *group)", "code": "{\n\tint status;\n\tpthread_attr_t thread_attr;\n\tcpu_set_t mask;\n\n\t/* initialize group structure */\n\tstatus = initialize_group(group);\n\tif (status) {\n\t\terror(\"initializing group %d\\n\", group->id);\n\t\treturn FAILURE;\n\t}\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(group->cpu, &mask);\n\n\tdebug(\"group %d bound to cpu %ld\\n\", group->id, group->cpu);\n\n\t/* start the low priority thread */\n\tdebug(\"creating low priority thread\\n\");\n\tif (setup_thread_attr(&thread_attr, LOW_PRIO(), &mask, policy))\n\t\treturn FAILURE;\n\tstatus = pthread_create(&group->low_tid,\n\t\t\t\t&thread_attr, low_priority, group);\n\tif (status != 0) {\n\t\terror(\"creating low_priority thread: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\n\t/* create the medium priority thread */\n\tdebug(\"creating medium priority thread\\n\");\n\tif (setup_thread_attr(&thread_attr, MED_PRIO(), &mask, policy))\n\t\treturn FAILURE;\n\tstatus = pthread_create(&group->med_tid,\n\t\t\t\t&thread_attr, med_priority, group);\n\tif (status != 0) {\n\t\terror(\"creating med_priority thread: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\n\t/* create the high priority thread */\n\tdebug(\"creating high priority thread\\n\");\n\tif (setup_thread_attr(&thread_attr, HIGH_PRIO(), &mask, policy))\n\t\treturn FAILURE;\n\tstatus = pthread_create(&group->high_tid,\n\t\t\t\t&thread_attr, high_priority, group);\n\tif (status != 0) {\n\t\terror(\"creating high_priority thread: %s\\n\", strerror(status));\n\t\tset_shutdown_flag();\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* One group of senders and receivers */\n", "func_signal": "static unsigned int group(childinfo_t *child,\n\t\t\t  unsigned int tab_offset,\n\t\t\t  unsigned int num_fds,\n\t\t\t  int ready_out,\n\t\t\t  int wakefd)", "code": "{\n\tunsigned int i;\n\tstruct sender_context* snd_ctx = malloc (sizeof(struct sender_context)\n\t\t\t+num_fds*sizeof(int));\n\n\tif (!snd_ctx) {\n\t\tsneeze(\"malloc() [sender ctx]\");\n\t\treturn 0;\n\t}\n\n\n\tfor (i = 0; i < num_fds; i++) {\n\t\tint fds[2];\n\t\tstruct receiver_context* ctx = malloc (sizeof(*ctx));\n\n\t\tif (!ctx) {\n\t\t\tsneeze(\"malloc() [receiver ctx]\");\n\t\t\treturn (i > 0 ? i-1 : 0);\n\t\t}\n\n\n\t\t/* Create the pipe between client and server */\n\t\tfdpair(fds);\n\n\t\tctx->num_packets = num_fds*loops;\n\t\tctx->in_fds[0] = fds[0];\n\t\tctx->in_fds[1] = fds[1];\n\t\tctx->ready_out = ready_out;\n\t\tctx->wakefd = wakefd;\n\n\t\tchild[tab_offset+i] = create_worker(ctx, (void *)(void *)receiver);\n\t\tif( child[tab_offset+i].error < 0 ) {\n\t\t\treturn (i > 0 ? i-1 : 0);\n\t\t}\n\t\tsnd_ctx->out_fds[i] = fds[1];\n\t\tif (process_mode == PROCESS_MODE)\n\t\t\tclose(fds[0]);\n\t}\n\n\t/* Now we have all the fds, fork the senders */\n\tfor (i = 0; i < num_fds; i++) {\n\t\tsnd_ctx->ready_out = ready_out;\n\t\tsnd_ctx->wakefd = wakefd;\n\t\tsnd_ctx->num_fds = num_fds;\n\n\t\tchild[tab_offset+num_fds+i] = create_worker(snd_ctx, (void *)(void *)sender);\n\t\tif( child[tab_offset+num_fds+i].error < 0 ) {\n\t\t\treturn (num_fds+i)-1;\n\t\t}\n\t}\n\n\t/* Close the fds we have left */\n\tif (process_mode == PROCESS_MODE)\n\t\tfor (i = 0; i < num_fds; i++)\n\t\t\tclose(snd_ctx->out_fds[i]);\n\n\t/* Return number of children to reap */\n\treturn num_fds * 2;\n}", "path": "src\\hackbench\\hackbench.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* Print an error message, plus a message for err, and return */\n", "func_signal": "void err_msg_n(int err, char *fmt, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap, fmt);\n\terr_doit(err, fmt, ap);\n\tva_end(ap);\n\treturn;\n}", "path": "src\\lib\\error.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/*\n * These are the file operation function for user access to /dev/backfire\n */\n", "func_signal": "static ssize_t\nbackfire_read(struct file *file, char *buf, size_t count, loff_t *ppos)", "code": "{\n\treturn snprintf(buf, count, \"%d,%d\\n\", (int) sendtime.tv_sec,\n\t\t(int) sendtime.tv_usec);\n}", "path": "src\\backfire\\backfire.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/*\n * signal thread\n *\n */\n", "func_signal": "void *signalthread(void *param)", "code": "{\n\tstruct thread_param *par = param;\n\tstruct sched_param schedp;\n\tsigset_t sigset;\n\tstruct timespec before, after;\n\tstruct thread_stat *stat = par->stats;\n\tint policy = par->prio ? SCHED_FIFO : SCHED_OTHER;\n\tint stopped = 0;\n\tint first = 1;\n\n\tif (tracelimit) {\n\t\tsystem(\"echo 1 > /proc/sys/kernel/trace_all_cpus\");\n\t\tsystem(\"echo 1 > /proc/sys/kernel/trace_enabled\");\n\t\tsystem(\"echo 1 > /proc/sys/kernel/trace_freerunning\");\n\t\tsystem(\"echo 0 > /proc/sys/kernel/trace_print_at_crash\");\n\t\tsystem(\"echo 1 > /proc/sys/kernel/trace_user_triggered\");\n\t\tsystem(\"echo -1 > /proc/sys/kernel/trace_user_trigger_irq\");\n\t\tsystem(\"echo 0 > /proc/sys/kernel/trace_verbose\");\n\t\tsystem(\"echo 0 > /proc/sys/kernel/preempt_thresh\");\n\t\tsystem(\"echo 0 > /proc/sys/kernel/wakeup_timing\");\n\t\tsystem(\"echo 0 > /proc/sys/kernel/preempt_max_latency\");\n\t}\n\n\tstat->tid = gettid();\n\n\tsigemptyset(&sigset);\n\tsigaddset(&sigset, par->signal);\n\tsigprocmask(SIG_BLOCK, &sigset, NULL);\n\n\tmemset(&schedp, 0, sizeof(schedp));\n\tschedp.sched_priority = par->prio;\n\tsched_setscheduler(0, policy, &schedp);\n\n\tstat->threadstarted++;\n\n\tif (tracelimit) {\n\t\tif (oldtrace)\n\t\t\tgettimeofday(0,(struct timezone *)1);\n\t\telse\n\t\t\tprctl(0, 1);\n\t}\n\n\tclock_gettime(CLOCK_MONOTONIC, &before);\n\n\twhile (!shutdown) {\n\t\tstruct timespec now;\n\t\tlong diff;\n\t\tint sigs;\n\n\t\tif (sigwait(&sigset, &sigs) < 0)\n\t\t\tgoto out;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &after);\n\n\t\t/*\n\t\t * If it is the first thread, sleep after every 16\n\t\t * round trips.\n\t\t */\n\t\tif (!par->id && !(stat->cycles & 0x0F))\n\t\t\tusleep(10000);\n\n\t\t/* Get current time */\n\t\tclock_gettime(CLOCK_MONOTONIC, &now);\n\t\tpthread_kill(stat->tothread, SIGUSR1);\n\n\t\t/* Skip the first cycle */\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tbefore = now;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdiff = calcdiff(after, before);\n\t\tbefore = now;\n\t\tif (diff < stat->min)\n\t\t\tstat->min = diff;\n\t\tif (diff > stat->max)\n\t\t\tstat->max = diff;\n\t\tstat->avg += (double) diff;\n\n\t\tif (!stopped && tracelimit && (diff > tracelimit)) {\n\t\t\tstopped++;\n\t\t\tif (oldtrace)\n\t\t\t\tgettimeofday(0,0);\n\t\t\telse\n\t\t\t\tprctl(0, 0);\n\t\t\tshutdown++;\n\t\t}\n\t\tstat->act = diff;\n\t\tstat->cycles++;\n\n\t\tif (par->bufmsk)\n\t\t\tstat->values[stat->cycles & par->bufmsk] = diff;\n\n\t\tif (par->max_cycles && par->max_cycles == stat->cycles)\n\t\t\tbreak;\n\t}\n\nout:\n\t/* switch to normal */\n\tschedp.sched_priority = 0;\n\tsched_setscheduler(0, SCHED_OTHER, &schedp);\n\n\tstat->threadstarted = -1;\n\n\treturn NULL;\n}", "path": "src\\signaltest\\signaltest.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* check for zero watchdog counters */\n", "func_signal": "int watchdog_check(void)", "code": "{\n\tint i;\n\tint failures = 0;\n\tstruct group_parameters *g;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tg = &groups[i];\n\t\tif (g->watchdog == 0) {\n\t\t\t/* don't report deadlock if group is finished */\n\t\t\tif (g->inversions == g->total)\n\t\t\t\tcontinue;\n\t\t\tif (++g->watchdog_hits >= WATCHDOG_LIMIT) {\n\t\t\t\terror\n\t\t\t\t    (\"WATCHDOG triggered: group %d is deadlocked!\\n\",\n\t\t\t\t     i);\n\t\t\t\tfailures++;\n\t\t\t}\n\t\t} else\n\t\t\tg->watchdog_hits = 0;\n\t}\n\treturn failures ? FAILURE : SUCCESS;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/*\n * parse an input value as a base10 value followed by an optional\n * suffix. The input value is presumed to be in seconds, unless\n * followed by a modifier suffix: m=minutes, h=hours, d=days\n *\n * the return value is a value in seconds\n */\n", "func_signal": "int\nparse_time_string(char *val)", "code": "{\n\tchar *end;\n\tint t = strtol(val, &end, 10);\n\tif (end) {\n\t\tswitch (*end) {\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tt *= 60;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tt *= 60*60;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tt *= 24*60*60;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn t;\n}", "path": "src\\cyclictest\\cyclictest.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* Print an error message, plus a message for err and exit with error err */\n", "func_signal": "void err_exit(int err, char *fmt, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap, fmt);\n\terr_doit(err, fmt, ap);\n\tva_end(ap);\n\texit(err);\n}", "path": "src\\lib\\error.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* total the number of inversions that have been performed */\n", "func_signal": "unsigned long total_inversions(void)", "code": "{\n\tint i;\n\tunsigned long total = 0;\n\n\tfor (i = 0; i < ngroups; i++)\n\t\ttotal += groups[i].total;\n\treturn total;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* print an error message and quit */\n", "func_signal": "void err_quit(char *fmt, ...)", "code": "{\n\tva_list ap;\n\tva_start(ap, fmt);\n\terr_doit(0, fmt, ap);\n\tva_end(ap);\n\texit(1);\n}", "path": "src\\lib\\error.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* clean up before exiting */\n", "func_signal": "void set_shutdown_flag(void)", "code": "{\n\tpthread_mutex_lock(&shutdown_mtx);\n\tif (shutdown == 0) {\n\t\t/* tell anyone that's looking that we're done */\n\t\tinfo(\"setting shutdown flag\\n\");\n\t\tshutdown = 1;\n\t}\n\tpthread_mutex_unlock(&shutdown_mtx);\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* Block until we're ready to go */\n", "func_signal": "static void ready(int ready_out, int wakefd)", "code": "{\n\tchar dummy = '*';\n\tstruct pollfd pollfd = { .fd = wakefd, .events = POLLIN };\n\n\t/* Tell them we're ready. */\n\tif (write(ready_out, &dummy, 1) != 1)\n\t\tbarf(\"CLIENT: ready write\");\n\n\t/* Wait for \"GO\" signal */\n\tif (poll(&pollfd, 1, -1) != 1)\n\t\tbarf(\"poll\");\n}", "path": "src\\hackbench\\hackbench.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/* block all signals (called from main) */\n", "func_signal": "int block_signals(void)", "code": "{\n\tint status;\n\tsigset_t sigset;\n\n\t/* mask off all signals */\n\tstatus = sigfillset(&sigset);\n\tif (status) {\n\t\terror(\"setting up full signal set %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\tstatus = pthread_sigmask(SIG_BLOCK, &sigset, NULL);\n\tif (status) {\n\t\terror(\"setting signal mask: %s\\n\", strerror(status));\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "path": "src\\pi_tests\\pi_stress.c", "repo_name": "clrkwllms/rt-tests", "stars": 29, "license": "gpl-2.0", "language": "c", "size": 511}
{"docstring": "/*\n\tWrite from FLASH\n\n\tExtensions to output flash memory pointers. This prevents the data to\n\tbecome part of the .data segment instead of the .code segment. That means\n\tless memory is consumed for multi-character writes.\n\n\tFor single character writes (i.e. '\\n' instead of \"\\n\"), using\n\tserial_writechar() directly is the better choice.\n*/\n", "func_signal": "void serial_writeblock_P(PGM_P data, int datalen)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < datalen; i++)\n\t\tserial_writechar(pgm_read_byte(&data[i]));\n}", "path": "mendel\\serial.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nloops while lcd is busy, returns address counter\n*************************************************************************/\n", "func_signal": "static uint8_t lcd_waitbusy(void)", "code": "{\n\t/* wait until busy flag is cleared */\n\tfor (; lcd_read(0) & (1 << LCD_BUSY); );\n\n\t/* the address counter is updated 4us after the busy flag is cleared */\n\tdelay(2);\n\n\t/* now read the address counter */\n\treturn (lcd_read(0));  // return address counter\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSet cursor to specified position\nInput:\tx  horizontal position  (0: left most position)\n\t\t  y  vertical position\t(0: first line)\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_gotoxy(uint8_t x, uint8_t y)", "code": "{\n#if LCD_LINES==1\n\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n#endif\n#if LCD_LINES==2\n\tif ( y==0 )\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n\telse\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE2 + x);\n#endif\n#if LCD_LINES==4\n\tif ( y==0 )\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n\telse if ( y==1)\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE2 + x);\n\telse if ( y==2)\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE3 + x);\n\telse /* y==3 */\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE4 + x);\n#endif\n\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/* toggle Enable Pin to initiate write */\n", "func_signal": "static void toggle_e(void)", "code": "{\n\tlcd_e_high();\n\tlcd_e_delay();\n\tlcd_e_low();\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nloops while lcd is busy, returns address counter\n*************************************************************************/\n", "func_signal": "static uint8_t lcd_waitbusy(void)", "code": "{\n\t/* wait until busy flag is cleared */\n\tfor (; lcd_read(0) & (1 << LCD_BUSY); );\n\n\t/* the address counter is updated 4us after the busy flag is cleared */\n\tdelay(2);\n\n\t/* now read the address counter */\n\treturn (lcd_read(0));  // return address counter\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nMove cursor to the start of next line or to the first line if the cursor\nis already on the last line.\n*************************************************************************/\n", "func_signal": "static inline void lcd_newline(uint8_t pos)", "code": "{\n\tregister uint8_t addressCounter;\n\n#if LCD_LINES==1\n\taddressCounter = 0;\n#endif\n#if LCD_LINES==2\n\tif ( pos < (LCD_START_LINE2) )\n\t\taddressCounter = LCD_START_LINE2;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#endif\n#if LCD_LINES==4\n#if KS0073_4LINES_MODE\n\tif ( pos < LCD_START_LINE2 )\n\t\taddressCounter = LCD_START_LINE2;\n\telse if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE3) )\n\t\taddressCounter = LCD_START_LINE3;\n\telse if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE4) )\n\t\taddressCounter = LCD_START_LINE4;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#else\n\tif ( pos < LCD_START_LINE3 )\n\t\taddressCounter = LCD_START_LINE2;\n\telse if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE4) )\n\t\taddressCounter = LCD_START_LINE3;\n\telse if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE2) )\n\t\taddressCounter = LCD_START_LINE4;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#endif\n#endif\n\tlcd_command((1 << LCD_DDRAM) + addressCounter);\n\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSend data byte to LCD controller\nInput:   data to send to LCD controller, see HD44780 data sheet\nReturns: none\n*************************************************************************/\n", "func_signal": "void lcd_data(uint8_t data)", "code": "{\n\tlcd_waitbusy();\n\tlcd_write(data,1);\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nDisplay character at current cursor position\nInput:\tcharacter to be displayed\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_putc(char c)", "code": "{\n\tuint8_t pos;\n\n\tpos = lcd_waitbusy();   // read busy-flag and address counter\n\tif (c=='\\n')\n\t\tlcd_newline(pos);\n\telse\n\t{\n#if LCD_WRAP_LINES==1\n#if LCD_LINES==1\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#elif LCD_LINES==2\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE2,0);\n\t\telse if ( pos == LCD_START_LINE2 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#elif LCD_LINES==4\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE2,0);\n\t\telse if ( pos == LCD_START_LINE2 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE3,0);\n\t\telse if ( pos == LCD_START_LINE3 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE4,0);\n\t\telse if ( pos == LCD_START_LINE4 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#endif\n\t\tlcd_waitbusy();\n#endif\n\t\tlcd_write(c, 1);\n\t}\n\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSend LCD controller instruction command\nInput:   instruction to send to LCD controller, see HD44780 data sheet\nReturns: none\n*************************************************************************/\n", "func_signal": "void lcd_command(uint8_t cmd)", "code": "{\n\tlcd_waitbusy();\n\tlcd_write(cmd,0);\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nMove cursor to the start of next line or to the first line if the cursor\nis already on the last line.\n*************************************************************************/\n", "func_signal": "static inline void lcd_newline(uint8_t pos)", "code": "{\n\tregister uint8_t addressCounter;\n\n#if LCD_LINES==1\n\taddressCounter = 0;\n#endif\n#if LCD_LINES==2\n\tif ( pos < (LCD_START_LINE2) )\n\t\taddressCounter = LCD_START_LINE2;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#endif\n#if LCD_LINES==4\n#if KS0073_4LINES_MODE\n\tif ( pos < LCD_START_LINE2 )\n\t\taddressCounter = LCD_START_LINE2;\n\telse if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE3) )\n\t\taddressCounter = LCD_START_LINE3;\n\telse if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE4) )\n\t\taddressCounter = LCD_START_LINE4;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#else\n\tif ( pos < LCD_START_LINE3 )\n\t\taddressCounter = LCD_START_LINE2;\n\telse if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE4) )\n\t\taddressCounter = LCD_START_LINE3;\n\telse if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE2) )\n\t\taddressCounter = LCD_START_LINE4;\n\telse\n\t\taddressCounter = LCD_START_LINE1;\n#endif\n#endif\n\tlcd_command((1 << LCD_DDRAM) + addressCounter);\n\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nInitialize display and select type of cursor\nInput:\tdispAttr LCD_DISP_OFF\t\t\tdisplay off\n\t\t\t\t   LCD_DISP_ON\t\t\t display on, cursor off\n\t\t\t\t   LCD_DISP_ON_CURSOR\t  display on, cursor on\n\t\t\t\t   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_init(uint8_t dispAttr)", "code": "{\n#if LCD_IO_MODE\n\t/*\n\t *  Initialize LCD to 4 bit I/O mode\n\t */\n\n\tif (\n\t\t( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )\n\t\t&& ( &LCD_RS_PORT == &LCD_DATA0_PORT) && ( &LCD_RW_PORT == &LCD_DATA0_PORT) && (&LCD_E_PORT == &LCD_DATA0_PORT)\n\t)\n\t{\n\t\t/* configure all port bits as output (all LCD lines on same port) */\n\t\tDDR(LCD_DATA0_PORT) |= (1 << LCD_DATA0_PIN) | (1 << LCD_DATA1_PIN) | (1 << LCD_DATA2_PIN) | (1 << LCD_DATA3_PIN) | (1 << LCD_RS_PIN) | (1 << LCD_RW_PIN) | (1 << LCD_E_PIN);\n\t}\n\telse if (\n\t\t( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )\n\t)\n\t{\n\t\t/* configure all port bits as output (all LCD data lines on same port, but control lines on different ports) */\n\t\tDDR(LCD_DATA0_PORT) |= (1 << LCD_DATA0_PIN) | (1 << LCD_DATA1_PIN) | (1 << LCD_DATA2_PIN) | (1 << LCD_DATA3_PIN);\n\t\tDDR(LCD_RS_PORT)\t|= _BV(LCD_RS_PIN);\n\t\tDDR(LCD_RW_PORT)\t|= _BV(LCD_RW_PIN);\n\t\tDDR(LCD_E_PORT)\t\t|= _BV(LCD_E_PIN);\n\t}\n\telse\n\t{\n\t\t/* configure all port bits as output (LCD data and control lines on different ports */\n\t\tDDR(LCD_RS_PORT)\t|= _BV(LCD_RS_PIN);\n\t\tDDR(LCD_RW_PORT)\t|= _BV(LCD_RW_PIN);\n\t\tDDR(LCD_E_PORT)\t\t|= _BV(LCD_E_PIN);\n\t\tDDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);\n\t\tDDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);\n\t\tDDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);\n\t\tDDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);\n\t}\n\tdelay(16000);\t\t\t\t\t\t\t/* wait 16ms or more after power-on\t   */\n\n\t/* initial write to lcd is 8bit */\n\tLCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);\t// _BV(LCD_FUNCTION)>>4;\n\tLCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);\t// _BV(LCD_FUNCTION_8BIT)>>4;\n\tlcd_e_toggle();\n\tdelay(4992);\t\t /* delay, busy flag can't be checked here */\n\n\t/* repeat last command */\n\tlcd_e_toggle();\t\t\tdelay(64);\t\t/* delay, busy flag can't be checked here */\n\n\t/* repeat last command a third time */\n\tlcd_e_toggle();\t\t\tdelay(64);\t\t/* delay, busy flag can't be checked here */\n\n\t/* now configure for 4bit mode */\n\tLCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);\t// LCD_FUNCTION_4BIT_1LINE>>4\n\tlcd_e_toggle();\n\tdelay(64);\t\t\t\t\t\t\t\t/* some displays need this additional delay */\n\n\t/* from now the LCD only accepts 4 bit I/O, we can use lcd_command() */\n#else\n\t/*\n\t * Initialize LCD to 8 bit memory mapped mode\n\t */\n\n\t/* enable external SRAM (memory mapped lcd) and one wait state */\n\tMCUCR = _BV(SRE) | _BV(SRW);\n\n\t/* reset LCD */\n\tdelay(16000);\t\t\t\t\t\t\t/* wait 16ms after power-on\t */\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(4992);\t\t\t\t\t\t\t/* wait 5ms\t\t\t\t\t */\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(64);\t\t\t\t\t\t\t\t/* wait 64us\t\t\t\t\t*/\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(64);\t\t\t\t\t\t\t\t/* wait 64us\t\t\t\t\t*/\n#endif\n\n#if KS0073_4LINES_MODE\n\t/* Display with KS0073 controller requires special commands for enabling 4 line mode */\n\tlcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);\n\tlcd_command(KS0073_4LINES_MODE);\n\tlcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);\n#else\n\tlcd_command(LCD_FUNCTION_DEFAULT);\t\t/* function set: display lines  */\n#endif\n\n\tlcd_command(LCD_DISP_OFF);\t\t\t\t/* display off\t\t\t\t  */\n\tlcd_clrscr();\t\t\t\t\t\t\t/* display clear\t\t\t\t*/\n\tlcd_command(LCD_MODE_DEFAULT);\t\t\t/* set entry mode\t\t\t   */\n\tlcd_command(dispAttr);\t\t\t\t\t/* display/cursor control\t   */\n\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSet cursor to specified position\nInput:\tx  horizontal position  (0: left most position)\n\t\t  y  vertical position\t(0: first line)\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_gotoxy(uint8_t x, uint8_t y)", "code": "{\n#if LCD_LINES==1\n\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n#endif\n#if LCD_LINES==2\n\tif ( y==0 )\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n\telse\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE2 + x);\n#endif\n#if LCD_LINES==4\n\tif ( y==0 )\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE1 + x);\n\telse if ( y==1)\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE2 + x);\n\telse if ( y==2)\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE3 + x);\n\telse /* y==3 */\n\t\tlcd_command((1 << LCD_DDRAM) + LCD_START_LINE4 + x);\n#endif\n\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/* toggle Enable Pin to initiate write */\n", "func_signal": "static void toggle_e(void)", "code": "{\n\tlcd_e_high();\n\tlcd_e_delay();\n\tlcd_e_low();\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSend LCD controller instruction command\nInput:   instruction to send to LCD controller, see HD44780 data sheet\nReturns: none\n*************************************************************************/\n", "func_signal": "void lcd_command(uint8_t cmd)", "code": "{\n\tlcd_waitbusy();\n\tlcd_write(cmd,0);\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nDisplay character at current cursor position\nInput:\tcharacter to be displayed\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_putc(char c)", "code": "{\n\tuint8_t pos;\n\n\tpos = lcd_waitbusy();   // read busy-flag and address counter\n\tif (c=='\\n')\n\t\tlcd_newline(pos);\n\telse\n\t{\n#if LCD_WRAP_LINES==1\n#if LCD_LINES==1\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#elif LCD_LINES==2\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE2,0);\n\t\telse if ( pos == LCD_START_LINE2 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#elif LCD_LINES==4\n\t\tif ( pos == LCD_START_LINE1 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE2,0);\n\t\telse if ( pos == LCD_START_LINE2 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE3,0);\n\t\telse if ( pos == LCD_START_LINE3 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE4,0);\n\t\telse if ( pos == LCD_START_LINE4 + LCD_DISP_LENGTH )\n\t\t\tlcd_write((1 << LCD_DDRAM) + LCD_START_LINE1,0);\n#endif\n\t\tlcd_waitbusy();\n#endif\n\t\tlcd_write(c, 1);\n\t}\n\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nInitialize display and select type of cursor\nInput:\tdispAttr LCD_DISP_OFF\t\t\tdisplay off\n\t\t\t\t   LCD_DISP_ON\t\t\t display on, cursor off\n\t\t\t\t   LCD_DISP_ON_CURSOR\t  display on, cursor on\n\t\t\t\t   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing\nReturns:  none\n*************************************************************************/\n", "func_signal": "void lcd_init(uint8_t dispAttr)", "code": "{\n#if LCD_IO_MODE\n\t/*\n\t *  Initialize LCD to 4 bit I/O mode\n\t */\n\n\tif (\n\t\t( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )\n\t\t&& ( &LCD_RS_PORT == &LCD_DATA0_PORT) && ( &LCD_RW_PORT == &LCD_DATA0_PORT) && (&LCD_E_PORT == &LCD_DATA0_PORT)\n\t)\n\t{\n\t\t/* configure all port bits as output (all LCD lines on same port) */\n\t\tDDR(LCD_DATA0_PORT) |= (1 << LCD_DATA0_PIN) | (1 << LCD_DATA1_PIN) | (1 << LCD_DATA2_PIN) | (1 << LCD_DATA3_PIN) | (1 << LCD_RS_PIN) | (1 << LCD_RW_PIN) | (1 << LCD_E_PIN);\n\t}\n\telse if (\n\t\t( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )\n\t)\n\t{\n\t\t/* configure all port bits as output (all LCD data lines on same port, but control lines on different ports) */\n\t\tDDR(LCD_DATA0_PORT) |= (1 << LCD_DATA0_PIN) | (1 << LCD_DATA1_PIN) | (1 << LCD_DATA2_PIN) | (1 << LCD_DATA3_PIN);\n\t\tDDR(LCD_RS_PORT)\t|= _BV(LCD_RS_PIN);\n\t\tDDR(LCD_RW_PORT)\t|= _BV(LCD_RW_PIN);\n\t\tDDR(LCD_E_PORT)\t\t|= _BV(LCD_E_PIN);\n\t}\n\telse\n\t{\n\t\t/* configure all port bits as output (LCD data and control lines on different ports */\n\t\tDDR(LCD_RS_PORT)\t|= _BV(LCD_RS_PIN);\n\t\tDDR(LCD_RW_PORT)\t|= _BV(LCD_RW_PIN);\n\t\tDDR(LCD_E_PORT)\t\t|= _BV(LCD_E_PIN);\n\t\tDDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);\n\t\tDDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);\n\t\tDDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);\n\t\tDDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);\n\t}\n\tdelay(16000);\t\t\t\t\t\t\t/* wait 16ms or more after power-on\t   */\n\n\t/* initial write to lcd is 8bit */\n\tLCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);\t// _BV(LCD_FUNCTION)>>4;\n\tLCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);\t// _BV(LCD_FUNCTION_8BIT)>>4;\n\tlcd_e_toggle();\n\tdelay(4992);\t\t /* delay, busy flag can't be checked here */\n\n\t/* repeat last command */\n\tlcd_e_toggle();\t\t\tdelay(64);\t\t/* delay, busy flag can't be checked here */\n\n\t/* repeat last command a third time */\n\tlcd_e_toggle();\t\t\tdelay(64);\t\t/* delay, busy flag can't be checked here */\n\n\t/* now configure for 4bit mode */\n\tLCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);\t// LCD_FUNCTION_4BIT_1LINE>>4\n\tlcd_e_toggle();\n\tdelay(64);\t\t\t\t\t\t\t\t/* some displays need this additional delay */\n\n\t/* from now the LCD only accepts 4 bit I/O, we can use lcd_command() */\n#else\n\t/*\n\t * Initialize LCD to 8 bit memory mapped mode\n\t */\n\n\t/* enable external SRAM (memory mapped lcd) and one wait state */\n\tMCUCR = _BV(SRE) | _BV(SRW);\n\n\t/* reset LCD */\n\tdelay(16000);\t\t\t\t\t\t\t/* wait 16ms after power-on\t */\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(4992);\t\t\t\t\t\t\t/* wait 5ms\t\t\t\t\t */\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(64);\t\t\t\t\t\t\t\t/* wait 64us\t\t\t\t\t*/\n\tlcd_write(LCD_FUNCTION_8BIT_1LINE,0);\t/* function set: 8bit interface */\n\tdelay(64);\t\t\t\t\t\t\t\t/* wait 64us\t\t\t\t\t*/\n#endif\n\n#if KS0073_4LINES_MODE\n\t/* Display with KS0073 controller requires special commands for enabling 4 line mode */\n\tlcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);\n\tlcd_command(KS0073_4LINES_MODE);\n\tlcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);\n#else\n\tlcd_command(LCD_FUNCTION_DEFAULT);\t\t/* function set: display lines  */\n#endif\n\n\tlcd_command(LCD_DISP_OFF);\t\t\t\t/* display off\t\t\t\t  */\n\tlcd_clrscr();\t\t\t\t\t\t\t/* display clear\t\t\t\t*/\n\tlcd_command(LCD_MODE_DEFAULT);\t\t\t/* set entry mode\t\t\t   */\n\tlcd_command(dispAttr);\t\t\t\t\t/* display/cursor control\t   */\n\n}", "path": "skel\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n\tInterrupts\n*/\n", "func_signal": "ISR(USART_RX_vect)", "code": "{\n\tif (buf_canwrite(rx))\n\t\tbuf_push(rx, UDR0);\n}", "path": "mendel\\serial.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\n delay loop for small accurate delays: 16-bit counter, 4 cycles/loop\n*************************************************************************/\n", "func_signal": "static inline void _delayFourCycles(unsigned int __count)", "code": "{\n\tif ( __count == 0 )\n\t\t__asm__ __volatile__( \"rjmp 1f\\n 1:\" );\t// 2 cycles\n\telse\n\t\t__asm__ __volatile__ (\n\t\t\t\"1: sbiw %0,1\" \"\\n\\t\"\n\t\t\t\"brne 1b\"\t\t\t\t\t\t\t  // 4 cycles/loop\n\t\t\t: \"=w\" (__count)\n\t\t\t: \"0\" (__count)\n\t\t);\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "// write to lcd function for fdev_setup_stream\n", "func_signal": "static int lcd_putc_fdev(char c, FILE *stream)", "code": "{\n\tlcd_putc(c);\n\treturn 0;\n}", "path": "freq-counter\\freq-counter.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*************************************************************************\nSend data byte to LCD controller\nInput:   data to send to LCD controller, see HD44780 data sheet\nReturns: none\n*************************************************************************/\n", "func_signal": "void lcd_data(uint8_t data)", "code": "{\n\tlcd_waitbusy();\n\tlcd_write(data,1);\n}", "path": "stepper\\lcd.c", "repo_name": "triffid/ATmega-Skeleton", "stars": 21, "license": "None", "language": "c", "size": 312}
{"docstring": "/*\n * Implements the interactive session with the server.  This is called after\n * the user has been authenticated, and a command has been started on the\n * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character\n * used as an escape character for terminating or suspending the session.\n */\n", "func_signal": "int\nclient_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)", "code": "{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tdouble start_time, total_time;\n\tint max_fd = 0, max_fd2 = 0, len, rekeying = 0;\n\tu_int64_t ibytes, obytes;\n\tu_int nalloc = 0;\n\tchar buf[100];\n\n\tdebug(\"Entering interactive session.\");\n\n\tstart_time = get_current_time();\n\n\t/* Initialize variables. */\n\tescape_pending1 = 0;\n\tlast_was_cr = 1;\n\texit_status = -1;\n\tstdin_eof = 0;\n\tbuffer_high = 64 * 1024;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\tmax_fd = MAX(connection_in, connection_out);\n\n\tif (!compat20) {\n\t\t/* enable nonblocking unless tty */\n\t\tif (!isatty(fileno(stdin)))\n\t\t\tset_nonblock(fileno(stdin));\n\t\tif (!isatty(fileno(stdout)))\n\t\t\tset_nonblock(fileno(stdout));\n\t\tif (!isatty(fileno(stderr)))\n\t\t\tset_nonblock(fileno(stderr));\n\t\tmax_fd = MAX(max_fd, fileno(stdin));\n\t\tmax_fd = MAX(max_fd, fileno(stdout));\n\t\tmax_fd = MAX(max_fd, fileno(stderr));\n\t}\n\tquit_pending = 0;\n\tescape_char1 = escape_char_arg;\n\n\t/* Initialize buffers. */\n\tbuffer_init(&stdin_buffer);\n\tbuffer_init(&stdout_buffer);\n\tbuffer_init(&stderr_buffer);\n\n\tclient_init_dispatch();\n\n\t/*\n\t * Set signal handlers, (e.g. to restore non-blocking mode)\n\t * but don't overwrite SIG_IGN, matches behaviour from rsh(1)\n\t */\n\tif (signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGHUP, signal_handler);\n\tif (signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGINT, signal_handler);\n\tif (signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGQUIT, signal_handler);\n\tif (signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (compat20) {\n\t\tsession_ident = ssh2_chan_id;\n\t\tif (session_ident != -1) {\n\t\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\t\tchannel_register_filter(session_ident,\n\t\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t\t    client_filter_cleanup,\n\t\t\t\t    client_new_escape_filter_ctx(\n\t\t\t\t    escape_char_arg));\n\t\t\t}\n\t\t\tchannel_register_cleanup(session_ident,\n\t\t\t    client_channel_closed, 0);\n\t\t}\n\t} else {\n\t\t/* Check if we should immediately send eof on stdin. */\n\t\tclient_check_initial_eof_on_stdin();\n\t}\n\n\t/* Main loop of the client for the interactive session mode. */\n\twhile (!quit_pending) {\n\n\t\t/* Process buffered packets sent by the server. */\n\t\tclient_process_buffered_input_packets();\n\n\t\tif (compat20 && session_closed && !channel_still_open())\n\t\t\tbreak;\n\n\t\trekeying = (xxx_kex != NULL && !xxx_kex->done);\n\n\t\tif (rekeying) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make packets of buffered stdin data, and buffer\n\t\t\t * them for sending to the server.\n\t\t\t */\n\t\t\tif (!compat20)\n\t\t\t\tclient_make_packets_from_stdin_data();\n\n\t\t\t/*\n\t\t\t * Make packets from buffered channel data, and\n\t\t\t * enqueue them for sending to the server.\n\t\t\t */\n\t\t\tif (packet_not_very_much_data_to_write())\n\t\t\t\tchannel_output_poll();\n\n\t\t\t/*\n\t\t\t * Check if the window size has changed, and buffer a\n\t\t\t * message about it to the server if so.\n\t\t\t */\n\t\t\tclient_check_window_change();\n\n\t\t\tif (quit_pending)\n\t\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Wait until we have something to do (something becomes\n\t\t * available on one of the descriptors).\n\t\t */\n\t\tmax_fd2 = max_fd;\n\t\tclient_wait_until_can_do_something(&readset, &writeset,\n\t\t    &max_fd2, &nalloc, rekeying);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t/* Do channel operations unless rekeying in progress. */\n\t\tif (!rekeying) {\n\t\t\tchannel_after_select(readset, writeset);\n\t\t\tif (need_rekeying || packet_need_rekeying()) {\n\t\t\t\tdebug(\"need rekeying\");\n\t\t\t\txxx_kex->done = 0;\n\t\t\t\tkex_send_kexinit(xxx_kex);\n\t\t\t\tneed_rekeying = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Buffer input from the connection.  */\n\t\tclient_process_net_input(readset);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\tif (!compat20) {\n\t\t\t/* Buffer data from stdin */\n\t\t\tclient_process_input(readset);\n\t\t\t/*\n\t\t\t * Process output to stdout and stderr.  Output to\n\t\t\t * the connection is processed elsewhere (above).\n\t\t\t */\n\t\t\tclient_process_output(writeset);\n\t\t}\n\n\t\tif (session_resumed) {\n\t\t\tconnection_in = packet_get_connection_in();\n\t\t\tconnection_out = packet_get_connection_out();\n\t\t\tmax_fd = MAX(max_fd, connection_out);\n\t\t\tmax_fd = MAX(max_fd, connection_in);\n\t\t\tsession_resumed = 0;\n\t\t}\n\n\t\t/*\n\t\t * Send as much buffered packet data as possible to the\n\t\t * sender.\n\t\t */\n\t\tif (FD_ISSET(connection_out, writeset))\n\t\t\tpacket_write_poll();\n\n\t\t/*\n\t\t * If we are a backgrounded control master, and the\n\t\t * timeout has expired without any active client\n\t\t * connections, then quit.\n\t\t */\n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (time(NULL) >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (readset)\n\t\txfree(readset);\n\tif (writeset)\n\t\txfree(writeset);\n\n\t/* Terminate the session. */\n\n\t/* Stop watching for window change. */\n\tsignal(SIGWINCH, SIG_DFL);\n\n\tif (compat20) {\n\t\tpacket_start(SSH2_MSG_DISCONNECT);\n\t\tpacket_put_int(SSH2_DISCONNECT_BY_APPLICATION);\n\t\tpacket_put_cstring(\"disconnected by user\");\n\t\tpacket_put_cstring(\"\"); /* language tag */\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\n\tchannel_free_all();\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t/* restore blocking io */\n\tif (!isatty(fileno(stdin)))\n\t\tunset_nonblock(fileno(stdin));\n\tif (!isatty(fileno(stdout)))\n\t\tunset_nonblock(fileno(stdout));\n\tif (!isatty(fileno(stderr)))\n\t\tunset_nonblock(fileno(stderr));\n\n\t/*\n\t * If there was no shell or command requested, there will be no remote\n\t * exit status to be returned.  In that case, clear error code if the\n\t * connection was deliberately terminated at this end.\n\t */\n\tif (no_shell_flag && received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal)\n\t\tfatal(\"Killed by signal %d.\", (int) received_signal);\n\n\t/*\n\t * In interactive mode (with pseudo tty) display a message indicating\n\t * that the connection has been closed.\n\t */\n\tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n\t\tsnprintf(buf, sizeof buf,\n\t\t    \"Connection to %.64s closed.\\r\\n\", host);\n\t\tbuffer_append(&stderr_buffer, buf, strlen(buf));\n\t}\n\n\t/* Output any buffered data for stdout. */\n\tif (buffer_len(&stdout_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stdout),\n\t\t    buffer_ptr(&stdout_buffer), buffer_len(&stdout_buffer));\n\t\tif (len < 0 || (u_int)len != buffer_len(&stdout_buffer))\n\t\t\terror(\"Write failed flushing stdout buffer.\");\n\t\telse\n\t\t\tbuffer_consume(&stdout_buffer, len);\n\t}\n\n\t/* Output any buffered data for stderr. */\n\tif (buffer_len(&stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    buffer_ptr(&stderr_buffer), buffer_len(&stderr_buffer));\n\t\tif (len < 0 || (u_int)len != buffer_len(&stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse\n\t\t\tbuffer_consume(&stderr_buffer, len);\n\t}\n\n\t/* Clear and free any buffers. */\n\tmemset(buf, 0, sizeof(buf));\n\tbuffer_free(&stdin_buffer);\n\tbuffer_free(&stdout_buffer);\n\tbuffer_free(&stderr_buffer);\n\n\t/* Report bytes transferred, and transfer rates. */\n\ttotal_time = get_current_time() - start_time;\n\tpacket_get_state(MODE_IN, NULL, NULL, NULL, &ibytes);\n\tpacket_get_state(MODE_OUT, NULL, NULL, NULL, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t/* Return the exit status of the program. */\n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*********/\n", "func_signal": "static void\nclient_input_stdout_data(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tu_int data_len;\n\tchar *data = packet_get_string(&data_len);\n\tpacket_check_eom();\n\tbuffer_append(&stdout_buffer, data, data_len);\n\tmemset(data, 0, data_len);\n\txfree(data);\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Returns the number of the token pointed to by cp or sBadOption.\n */\n", "func_signal": "static ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)", "code": "{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}", "path": "externals\\openssh-5.9p1-orig\\servconf.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Signal handler for signals that cause the program to terminate.  These\n * signals must be trapped to restore terminal modes.\n */\n/*ARGSUSED */\n", "func_signal": "static void\nsignal_handler(int sig)", "code": "{\n\treceived_signal = sig;\n\tquit_pending = 1;\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* \n * Process the characters one by one, call with c==NULL for proto1 case.\n */\n", "func_signal": "static int\nprocess_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,\n    char *buf, int len)", "code": "{\n\tchar string[1024];\n\tpid_t pid;\n\tint bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tint *escape_pendingp, escape_char;\n\tstruct escape_filter_ctx *efc;\n\n\tif (c == NULL) {\n\t\tescape_pendingp = &escape_pending1;\n\t\tescape_char = escape_char1;\n\t} else {\n\t\tif (c->filter_ctx == NULL)\n\t\t\treturn 0;\n\t\tefc = (struct escape_filter_ctx *)c->filter_ctx;\n\t\tescape_pendingp = &efc->escape_pending;\n\t\tescape_char = efc->escape_char;\n\t}\n\t\n\tif (len <= 0)\n\t\treturn (0);\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t/* Get one character at a time. */\n\t\tch = buf[i];\n\n\t\tif (*escape_pendingp) {\n\t\t\t/* We have previously seen an escape character. */\n\t\t\t/* Clear the flag now. */\n\t\t\t*escape_pendingp = 0;\n\n\t\t\t/* Process the escaped character. */\n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t/* Terminate the connection. */\n\t\t\t\tsnprintf(string, sizeof string, \"%c.\\r\\n\",\n\t\t\t\t    escape_char);\n\t\t\t\tbuffer_append(berr, string, strlen(string));\n\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchan_read_failed(c);\n\t\t\t\t\tchan_write_failed(c);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t/* XXX support this for mux clients */\n\t\t\t\tif (c && c->ctl_chan != -1) {\n noescape:\n\t\t\t\t\tsnprintf(string, sizeof string,\n\t\t\t\t\t    \"%c%c escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    escape_char, ch);\n\t\t\t\t\tbuffer_append(berr, string,\n\t\t\t\t\t    strlen(string));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Suspend the program. Inform the user */\n\t\t\t\tsnprintf(string, sizeof string,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\", escape_char);\n\t\t\t\tbuffer_append(berr, string, strlen(string));\n\n\t\t\t\t/* Restore terminal modes and suspend. */\n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t/* We have been continued. */\n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif (compat20) {\n\t\t\t\t\tsnprintf(string, sizeof string,\n\t\t\t\t\t    \"%cB\\r\\n\", escape_char);\n\t\t\t\t\tbuffer_append(berr, string,\n\t\t\t\t\t    strlen(string));\n\t\t\t\t\tchannel_request_start(session_ident,\n\t\t\t\t\t    \"break\", 0);\n\t\t\t\t\tpacket_put_int(1000);\n\t\t\t\t\tpacket_send();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (compat20) {\n\t\t\t\t\tif (datafellows & SSH_BUG_NOREKEY)\n\t\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t\t    \"support re-keying\");\n\t\t\t\t\telse\n\t\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t/*\n\t\t\t\t * Detach the program (continue to serve\n\t\t\t\t * connections, but put in background and no\n\t\t\t\t * more new connections).\n\t\t\t\t */\n\t\t\t\t/* Restore tty modes. */\n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t/* Stop listening for new connections. */\n\t\t\t\tchannel_stop_listening();\n\n\t\t\t\tsnprintf(string, sizeof string,\n\t\t\t\t    \"%c& [backgrounded]\\n\", escape_char);\n\t\t\t\tbuffer_append(berr, string, strlen(string));\n\n\t\t\t\t/* Fork into background. */\n\t\t\t\tpid = fork();\n\t\t\t\tif (pid < 0) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t/* This is the parent. */\n\t\t\t\t\t/* The parent just exits. */\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t/* The child continues serving connections. */\n\t\t\t\tif (compat20) {\n\t\t\t\t\tbuffer_append(bin, \"\\004\", 1);\n\t\t\t\t\t/* fake EOF on stdin */\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (!stdin_eof) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Sending SSH_CMSG_EOF alone does not\n\t\t\t\t\t * always appear to be enough.  So we\n\t\t\t\t\t * try to send an EOF character first.\n\t\t\t\t\t */\n\t\t\t\t\tpacket_start(SSH_CMSG_STDIN_DATA);\n\t\t\t\t\tpacket_put_string(\"\\004\", 1);\n\t\t\t\t\tpacket_send();\n\t\t\t\t\t/* Close stdin. */\n\t\t\t\t\tstdin_eof = 1;\n\t\t\t\t\tif (buffer_len(bin) == 0) {\n\t\t\t\t\t\tpacket_start(SSH_CMSG_EOF);\n\t\t\t\t\t\tpacket_send();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\n\t\t\tcase '?':\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tsnprintf(string, sizeof string,\n\"%c?\\r\\n\\\nSupported escape sequences:\\r\\n\\\n  %c.  - terminate session\\r\\n\\\n  %cB  - send a BREAK to the remote system\\r\\n\\\n  %cR  - Request rekey (SSH protocol 2 only)\\r\\n\\\n  %c#  - list forwarded connections\\r\\n\\\n  %c?  - this message\\r\\n\\\n  %c%c  - send the escape character by typing it twice\\r\\n\\\n(Note that escapes are only recognized immediately after newline.)\\r\\n\",\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(string, sizeof string,\n\"%c?\\r\\n\\\nSupported escape sequences:\\r\\n\\\n  %c.  - terminate connection (and any multiplexed sessions)\\r\\n\\\n  %cB  - send a BREAK to the remote system\\r\\n\\\n  %cC  - open a command line\\r\\n\\\n  %cR  - Request rekey (SSH protocol 2 only)\\r\\n\\\n  %c^Z - suspend ssh\\r\\n\\\n  %c#  - list forwarded connections\\r\\n\\\n  %c&  - background ssh (when waiting for connections to terminate)\\r\\n\\\n  %c?  - this message\\r\\n\\\n  %c%c  - send the escape character by typing it twice\\r\\n\\\n(Note that escapes are only recognized immediately after newline.)\\r\\n\",\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char, escape_char,\n\t\t\t\t\t    escape_char);\n\t\t\t\t}\n\t\t\t\tbuffer_append(berr, string, strlen(string));\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tsnprintf(string, sizeof string, \"%c#\\r\\n\",\n\t\t\t\t    escape_char);\n\t\t\t\tbuffer_append(berr, string, strlen(string));\n\t\t\t\ts = channel_open_message();\n\t\t\t\tbuffer_append(berr, s, strlen(s));\n\t\t\t\txfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tprocess_cmdline();\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != escape_char) {\n\t\t\t\t\tbuffer_put_char(bin, escape_char);\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t/* Escaped characters fall through here */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The previous character was not an escape char.\n\t\t\t * Check if this is an escape.\n\t\t\t */\n\t\t\tif (last_was_cr && ch == escape_char) {\n\t\t\t\t/*\n\t\t\t\t * It is. Set the flag and continue to\n\t\t\t\t * next character.\n\t\t\t\t */\n\t\t\t\t*escape_pendingp = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal character.  Record whether it was a newline,\n\t\t * and append it to the buffer.\n\t\t */\n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tbuffer_put_char(bin, ch);\n\t\tbytes++;\n\t}\n\treturn bytes;\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Sets control_persist_exit_time to the absolute time when the\n * backgrounded control master should exit due to expiry of the\n * ControlPersist timeout.  Sets it to 0 if we are not a backgrounded\n * control master process, or if there is no ControlPersist timeout.\n */\n", "func_signal": "static void\nset_control_persist_exit_time(void)", "code": "{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t/* not using a ControlPersist timeout */\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open()) {\n\t\t/* some client connections are still open */\n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2(\"%s: cancel scheduled exit\", __func__);\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t/* a client connection has recently closed */\n\t\tcontrol_persist_exit_time = time(NULL) +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2(\"%s: schedule exit in %d seconds\", __func__,\n\t\t    options.control_persist_timeout);\n\t}\n\t/* else we are already counting down to the timeout */\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * This is called when the interactive is entered.  This checks if there is\n * an EOF coming on stdin.  We must check this explicitly, as select() does\n * not appear to wake up when redirecting from /dev/null.\n */\n", "func_signal": "static void\nclient_check_initial_eof_on_stdin(void)", "code": "{\n\tint len;\n\tchar buf[1];\n\n\t/*\n\t * If standard input is to be \"redirected from /dev/null\", we simply\n\t * mark that we have seen an EOF and send an EOF message to the\n\t * server. Otherwise, we try to read a single character; it appears\n\t * that for some files, such /dev/null, select() never wakes up for\n\t * read for this descriptor, which means that we never get EOF.  This\n\t * way we will get the EOF if stdin comes from /dev/null or similar.\n\t */\n\tif (stdin_null_flag) {\n\t\t/* Fake EOF on stdin. */\n\t\tdebug(\"Sending eof.\");\n\t\tstdin_eof = 1;\n\t\tpacket_start(SSH_CMSG_EOF);\n\t\tpacket_send();\n\t} else {\n\t\tenter_non_blocking();\n\n\t\t/* Check for immediate EOF on stdin. */\n\t\tlen = read(fileno(stdin), buf, 1);\n\t\tif (len == 0) {\n\t\t\t/*\n\t\t\t * EOF.  Record that we have seen it and send\n\t\t\t * EOF to server.\n\t\t\t */\n\t\t\tdebug(\"Sending eof.\");\n\t\t\tstdin_eof = 1;\n\t\t\tpacket_start(SSH_CMSG_EOF);\n\t\t\tpacket_send();\n\t\t} else if (len > 0) {\n\t\t\t/*\n\t\t\t * Got data.  We must store the data in the buffer,\n\t\t\t * and also process it as an escape character if\n\t\t\t * appropriate.\n\t\t\t */\n\t\t\tif ((u_char) buf[0] == escape_char1)\n\t\t\t\tescape_pending1 = 1;\n\t\t\telse\n\t\t\t\tbuffer_append(&stdin_buffer, buf, 1);\n\t\t}\n\t\tleave_non_blocking();\n\t}\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Make packets from buffered stdin data, and buffer them for sending to the\n * connection.\n */\n", "func_signal": "static void\nclient_make_packets_from_stdin_data(void)", "code": "{\n\tu_int len;\n\n\t/* Send buffered stdin data to the server. */\n\twhile (buffer_len(&stdin_buffer) > 0 &&\n\t    packet_not_very_much_data_to_write()) {\n\t\tlen = buffer_len(&stdin_buffer);\n\t\t/* Keep the packets at reasonable size. */\n\t\tif (len > packet_get_maxsize())\n\t\t\tlen = packet_get_maxsize();\n\t\tpacket_start(SSH_CMSG_STDIN_DATA);\n\t\tpacket_put_string(buffer_ptr(&stdin_buffer), len);\n\t\tpacket_send();\n\t\tbuffer_consume(&stdin_buffer, len);\n\t\t/* If we have a pending EOF, send it now. */\n\t\tif (stdin_eof && buffer_len(&stdin_buffer) == 0) {\n\t\t\tpacket_start(SSH_CMSG_EOF);\n\t\t\tpacket_send();\n\t\t}\n\t}\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* Initializes the server options to their default values. */\n", "func_signal": "void\ninitialize_server_options(ServerOptions *options)", "code": "{\n\tmemset(options, 0, sizeof(*options));\n\n\t/* Portable-specific options */\n\toptions->use_pam = -1;\n\n\t/* Standard Options */\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->listen_addrs = NULL;\n\toptions->address_family = -1;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->pid_file = NULL;\n\toptions->server_key_bits = -1;\n\toptions->login_grace_time = -1;\n\toptions->key_regeneration_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->rhosts_rsa_authentication = -1;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->rsa_authentication = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->use_login = -1;\n\toptions->compression = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->protocol = SSH_PROTO_UNKNOWN;\n\toptions->gateway_ports = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->permit_tun = -1;\n\toptions->num_permitted_opens = -1;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->zero_knowledge_password_authentication = -1;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n}", "path": "externals\\openssh-5.9p1-orig\\servconf.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* Puts stdin terminal in non-blocking mode. */\n", "func_signal": "static void\nenter_non_blocking(void)", "code": "{\n\tin_non_blocking_mode = 1;\n\tset_nonblock(fileno(stdin));\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Signal handler for the window change signal (SIGWINCH).  This just sets a\n * flag indicating that the window has changed.\n */\n/*ARGSUSED */\n", "func_signal": "static void\nwindow_change_handler(int sig)", "code": "{\n\treceived_window_change_signal = 1;\n\tsignal(SIGWINCH, window_change_handler);\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* Helper: allocate a new escape_filter_ctx and fill in its escape char */\n", "func_signal": "void *\nclient_new_escape_filter_ctx(int escape_char)", "code": "{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xmalloc(sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Returns current time in seconds from Jan 1, 1970 with the maximum\n * available resolution.\n */\n", "func_signal": "static double\nget_current_time(void)", "code": "{\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn (double) tv.tv_sec + (double) tv.tv_usec / 1000000.0;\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Waits until the client can do something (some data becomes available on\n * one of the file descriptors).\n */\n", "func_signal": "static void\nclient_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,\n    int *maxfdp, u_int *nallocp, int rekeying)", "code": "{\n\tstruct timeval tv, *tvp;\n\tint timeout_secs;\n\tint ret;\n\n\t/* Add any selections by the channel mechanism. */\n\tchannel_prepare_select(readsetp, writesetp, maxfdp, nallocp, rekeying);\n\n\tif (!compat20) {\n\t\t/* Read from the connection, unless our buffers are full. */\n\t\tif (buffer_len(&stdout_buffer) < buffer_high &&\n\t\t    buffer_len(&stderr_buffer) < buffer_high &&\n\t\t    channel_not_very_much_buffered_data())\n\t\t\tFD_SET(connection_in, *readsetp);\n\t\t/*\n\t\t * Read from stdin, unless we have seen EOF or have very much\n\t\t * buffered data to send to the server.\n\t\t */\n\t\tif (!stdin_eof && packet_not_very_much_data_to_write())\n\t\t\tFD_SET(fileno(stdin), *readsetp);\n\n\t\t/* Select stdout/stderr if have data in buffer. */\n\t\tif (buffer_len(&stdout_buffer) > 0)\n\t\t\tFD_SET(fileno(stdout), *writesetp);\n\t\tif (buffer_len(&stderr_buffer) > 0)\n\t\t\tFD_SET(fileno(stderr), *writesetp);\n\t} else {\n\t\t/* channel_prepare_select could have closed the last channel */\n\t\tif (session_closed && !channel_still_open() &&\n\t\t    !packet_have_data_to_write()) {\n\t\t\t/* clear mask since we did not call select() */\n\t\t\tmemset(*readsetp, 0, *nallocp);\n\t\t\tmemset(*writesetp, 0, *nallocp);\n\t\t\treturn;\n\t\t} else {\n\t\t\tFD_SET(connection_in, *readsetp);\n\t\t}\n\t}\n\n\t/* Select server connection if have data to write to the server. */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * Wait for something to happen.  This will suspend the process until\n\t * some selected descriptor can be read, written, or has some other\n\t * event pending, or a timeout expires.\n\t */\n\n\ttimeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */\n\tif (options.server_alive_interval > 0 && compat20)\n\t\ttimeout_secs = options.server_alive_interval;\n\tset_control_persist_exit_time();\n\tif (control_persist_exit_time > 0) {\n\t\ttimeout_secs = MIN(timeout_secs,\n\t\t\tcontrol_persist_exit_time - time(NULL));\n\t\tif (timeout_secs < 0)\n\t\t\ttimeout_secs = 0;\n\t}\n\tif (timeout_secs == INT_MAX)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = timeout_secs;\n\t\ttv.tv_usec = 0;\n\t\ttvp = &tv;\n\t}\n\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\tif (ret < 0) {\n\t\tchar buf[100];\n\n\t\t/*\n\t\t * We have to clear the select masks, because we return.\n\t\t * We have to return, because the mainloop checks for the flags\n\t\t * set by the signal handlers.\n\t\t */\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t/* Note: we might still have data in the buffers. */\n\t\tsnprintf(buf, sizeof buf, \"select: %s\\r\\n\", strerror(errno));\n\t\tbuffer_append(&stderr_buffer, buf, strlen(buf));\n\t\tquit_pending = 1;\n\t} else if (ret == 0)\n\t\tserver_alive_check();\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Checks if the client window has changed, and sends a packet about it to\n * the server if so.  The actual change is detected elsewhere (by a software\n * interrupt on Unix); this just checks the flag and sends a message if\n * appropriate.\n */\n", "func_signal": "static void\nclient_check_window_change(void)", "code": "{\n\tstruct winsize ws;\n\n\tif (! received_window_change_signal)\n\t\treturn;\n\t/** XXX race */\n\treceived_window_change_signal = 0;\n\n\tdebug2(\"client_check_window_change: changed\");\n\n\tif (compat20) {\n\t\tchannel_send_window_changes();\n\t} else {\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)\n\t\t\treturn;\n\t\tpacket_start(SSH_CMSG_WINDOW_SIZE);\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\t\tpacket_send();\n\t}\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* client specific fatal cleanup */\n", "func_signal": "void\ncleanup_exit(int i)", "code": "{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tleave_non_blocking();\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* XXXX move to generic input handler */\n", "func_signal": "static void\nclient_input_channel_open(int type, u_int32_t seq, void *ctxt)", "code": "{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tint rchan;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"client_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"forwarded-tcpip\") == 0) {\n\t\tc = client_request_forwarded_tcpip(ctype, rchan);\n\t} else if (strcmp(ctype, \"x11\") == 0) {\n\t\tc = client_request_x11(ctype, rchan);\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) {\n\t\tc = client_request_agent(ctype, rchan);\n\t}\n/* XXX duplicate : */\n\tif (c != NULL) {\n\t\tdebug(\"confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"failure %s\", ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\n\t\tif (!(datafellows & SSH_BUG_OPENFAILURE)) {\n\t\t\tpacket_put_cstring(\"open failed\");\n\t\t\tpacket_put_cstring(\"\");\n\t\t}\n\t\tpacket_send();\n\t}\n\txfree(ctype);\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* Restores stdin to blocking mode. */\n", "func_signal": "static void\nleave_non_blocking(void)", "code": "{\n\tif (in_non_blocking_mode) {\n\t\tunset_nonblock(fileno(stdin));\n\t\tin_non_blocking_mode = 0;\n\t}\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/*\n * Get packets from the connection input buffer, and process them as long as\n * there are packets available.\n *\n * Any unknown packets received during the actual\n * session cause the session to terminate.  This is\n * intended to make debugging easier since no\n * confirmations are sent.  Any compatible protocol\n * extensions must be negotiated during the\n * preparatory phase.\n */\n", "func_signal": "static void\nclient_process_buffered_input_packets(void)", "code": "{\n\tdispatch_run(DISPATCH_NONBLOCK, &quit_pending,\n\t    compat20 ? xxx_kex : NULL);\n}", "path": "openssh-5.9p1\\clientloop.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/* Reads the server configuration file. */\n", "func_signal": "void\nload_server_config(const char *filename, Buffer *conf)", "code": "{\n\tchar line[1024], *cp;\n\tFILE *f;\n\n\tdebug2(\"%s: filename %s\", __func__, filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tbuffer_clear(conf);\n\twhile (fgets(line, sizeof(line), f)) {\n\t\t/*\n\t\t * Trim out comments and strip whitespace\n\t\t * NB - preserve newlines, they are needed to reproduce\n\t\t * line numbers later for error messages\n\t\t */\n\t\tif ((cp = strchr(line, '#')) != NULL)\n\t\t\tmemcpy(cp, \"\\n\", 2);\n\t\tcp = line + strspn(line, \" \\t\\r\");\n\n\t\tbuffer_append(conf, cp, strlen(cp));\n\t}\n\tbuffer_append(conf, \"\\0\", 1);\n\tfclose(f);\n\tdebug2(\"%s: done config len = %d\", __func__, buffer_len(conf));\n}", "path": "externals\\openssh-5.9p1-orig\\servconf.c", "repo_name": "epriestley/sshd-vcs", "stars": 16, "license": "None", "language": "c", "size": 2361}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *OrOrExp::toElem(IRState *irs)", "code": "{\n    tym_t tym = type->totym();\n\n    elem *el = e1->toElem(irs);\n    elem *er = e2->toElemDtor(irs);\n    elem *e = el_bin(OPoror,tym,el,er);\n\n    el_setLoc(e,loc);\n\n    if (global.params.cov && e2->loc.linnum)\n        e->E2 = el_combine(incUsageElem(irs, e2->loc), e->E2);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *ThisExp::toElem(IRState *irs)", "code": "{   elem *ethis;\n    FuncDeclaration *fd;\n\n    //printf(\"ThisExp::toElem()\\n\");\n    assert(irs->sthis);\n\n    if (var)\n    {\n        assert(var->parent);\n        fd = var->toParent2()->isFuncDeclaration();\n        assert(fd);\n        ethis = getEthis(loc, irs, fd);\n    }\n    else\n        ethis = el_var(irs->sthis);\n\n#if STRUCTTHISREF\n    if (type->ty == Tstruct)\n    {   ethis = el_una(OPind, TYstruct, ethis);\n        ethis->ET = type->toCtype();\n    }\n#endif\n    el_setLoc(ethis,loc);\n    return ethis;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *AddExp::toElem(IRState *irs)", "code": "{\n    elem *e = toElemBin(irs,OPadd);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/********************************* ConditionalDeclaration ****************************/\n", "func_signal": "ConditionalDeclaration::ConditionalDeclaration(Condition *condition, Dsymbols *decl, Dsymbols *elsedecl)\n        : AttribDeclaration(decl)", "code": "{\n    //printf(\"ConditionalDeclaration::ConditionalDeclaration()\\n\");\n    this->condition = condition;\n    this->elsedecl = elsedecl;\n}", "path": "attrib.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *Expression::toElem(IRState *irs)", "code": "{\n    print();\n    assert(0);\n    return NULL;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/****************************************\n */\n", "func_signal": "elem *CommaExp::toElem(IRState *irs)", "code": "{\n    assert(e1 && e2);\n    elem *eleft  = e1->toElem(irs);\n    elem *eright = e2->toElem(irs);\n    elem *e = el_combine(eleft, eright);\n    if (e)\n        el_setLoc(e, loc);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/********************************************\n */\n", "func_signal": "elem *BinExp::toElemBin(IRState *irs,int op)", "code": "{\n    //printf(\"toElemBin() '%s'\\n\", toChars());\n\n    Type *tb1 = e1->type->toBasetype();\n    Type *tb2 = e2->type->toBasetype();\n\n    if ((tb1->ty == Tarray || tb1->ty == Tsarray ||\n         tb2->ty == Tarray || tb2->ty == Tsarray) &&\n        tb2->ty != Tvoid &&\n        op != OPeq && op != OPandand && op != OPoror\n       )\n    {\n        error(\"Array operation %s not implemented\", toChars());\n        return el_long(type->totym(), 0);  // error recovery\n    }\n\n    tym_t tym = type->totym();\n\n    elem *el = e1->toElem(irs);\n    elem *er = e2->toElem(irs);\n    elem *e = el_bin(op,tym,el,er);\n\n    el_setLoc(e,loc);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *CatExp::toElem(IRState *irs)", "code": "{   elem *e;\n\n#if 0\n    printf(\"CatExp::toElem()\\n\");\n    print();\n#endif\n\n    Type *tb1 = e1->type->toBasetype();\n    Type *tb2 = e2->type->toBasetype();\n\n    Type *ta = (tb1->ty == Tarray || tb1->ty == Tsarray) ? tb1 : tb2;\n    Type *tn = ta->nextOf();\n\n    if (e1->op == TOKcat)\n    {\n        elem *ep;\n        CatExp *ce = this;\n        int n = 2;\n\n        ep = eval_Darray(irs, ce->e2);\n        do\n        {\n            n++;\n            ce = (CatExp *)ce->e1;\n            ep = el_param(ep, eval_Darray(irs, ce->e2));\n        } while (ce->e1->op == TOKcat);\n        ep = el_param(ep, eval_Darray(irs, ce->e1));\n        ep = el_params(\n                       ep,\n                       el_long(TYsize_t, n),\n                       ta->getTypeInfo(NULL)->toElem(irs),\n                       NULL);\n        e = el_bin(OPcall, TYdarray, el_var(rtlsym[RTLSYM_ARRAYCATNT]), ep);\n        e->Eflags |= EFLAGS_variadic;\n    }\n    else\n    {\n        elem *e1;\n        elem *e2;\n        elem *ep;\n\n        e1 = eval_Darray(irs, this->e1);\n        e2 = eval_Darray(irs, this->e2);\n        ep = el_params(e2, e1, ta->getTypeInfo(NULL)->toElem(irs), NULL);\n        e = el_bin(OPcall, TYdarray, el_var(rtlsym[RTLSYM_ARRAYCATT]), ep);\n    }\n    el_setLoc(e,loc);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *InExp::toElem(IRState *irs)", "code": "{   elem *e;\n    elem *key = e1->toElem(irs);\n    elem *aa = e2->toElem(irs);\n    elem *ep;\n    elem *keyti;\n    TypeAArray *taa = (TypeAArray *)e2->type->toBasetype();\n\n    // aaInX(aa, keyti, key);\n    key = addressElem(key, e1->type);\n    Symbol *s = taa->aaGetSymbol(\"InX\", 0);\n    keyti = taa->index->getInternalTypeInfo(NULL)->toElem(irs);\n    ep = el_params(key, keyti, aa, NULL);\n    e = el_bin(OPcall, type->totym(), el_var(s), ep);\n\n    el_setLoc(e,loc);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************** StaticIfDeclaration ****************************/\n", "func_signal": "StaticIfDeclaration::StaticIfDeclaration(Condition *condition,\n        Dsymbols *decl, Dsymbols *elsedecl)\n        : ConditionalDeclaration(condition, decl, elsedecl)", "code": "{\n    //printf(\"StaticIfDeclaration::StaticIfDeclaration()\\n\");\n    sd = NULL;\n    addisdone = 0;\n}", "path": "attrib.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/************************************\n */\n", "func_signal": "elem *sarray_toDarray(Loc loc, Type *tfrom, Type *tto, elem *e)", "code": "{\n    //printf(\"sarray_toDarray()\\n\");\n    //elem_print(e);\n\n    dinteger_t dim = ((TypeSArray *)tfrom)->dim->toInteger();\n\n    if (tto)\n    {\n        unsigned fsize = tfrom->nextOf()->size();\n        unsigned tsize = tto->nextOf()->size();\n\n        if ((dim * fsize) % tsize != 0)\n        {\n            error(loc, \"cannot cast %s to %s since sizes don't line up\", tfrom->toChars(), tto->toChars());\n        }\n        dim = (dim * fsize) / tsize;\n    }\n    elem *elen = el_long(TYsize_t, dim);\n    e = addressElem(e, tfrom);\n    e = el_pair(TYdarray, elen, e);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/*******************************************\n * Generate elem to zero fill contents of Symbol stmp\n * from *poffset..offset2.\n * May store anywhere from 0..maxoff, as this function\n * tries to use aligned int stores whereever possible.\n * Update *poffset to end of initialized hole; *poffset will be >= offset2.\n */\n", "func_signal": "elem *fillHole(Symbol *stmp, size_t *poffset, size_t offset2, size_t maxoff)", "code": "{   elem *e = NULL;\n    int basealign = 1;\n\n    while (*poffset < offset2)\n    {   tym_t ty;\n        elem *e1;\n\n        if (tybasic(stmp->Stype->Tty) == TYnptr)\n            e1 = el_var(stmp);\n        else\n            e1 = el_ptr(stmp);\n        if (basealign)\n            *poffset &= ~3;\n        basealign = 1;\n        size_t sz = maxoff - *poffset;\n        switch (sz)\n        {   case 1: ty = TYchar;        break;\n            case 2: ty = TYshort;       break;\n            case 3:\n                ty = TYshort;\n                basealign = 0;\n                break;\n            default:\n                ty = TYlong;\n                break;\n        }\n        e1 = el_bin(OPadd, TYnptr, e1, el_long(TYsize_t, *poffset));\n        e1 = el_una(OPind, ty, e1);\n        e1 = el_bin(OPeq, ty, e1, el_long(ty, 0));\n        e = el_combine(e, e1);\n        *poffset += tysize[ty];\n    }\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/*******************************************\n * Evaluate Expression, then call destructors on any temporaries in it.\n */\n", "func_signal": "elem *Expression::toElemDtor(IRState *irs)", "code": "{\n    //printf(\"Expression::toElemDtor() %s\\n\", toChars());\n    size_t starti = irs->varsInScope ? irs->varsInScope->dim : 0;\n    elem *er = toElem(irs);\n    size_t endi = irs->varsInScope ? irs->varsInScope->dim : 0;\n\n    // Add destructors\n    er = appendDtors(irs, er, starti, endi);\n    return er;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/*****************************************\n * Convert array to a pointer to the data.\n */\n", "func_signal": "elem *array_toPtr(Type *t, elem *e)", "code": "{\n    //printf(\"array_toPtr()\\n\");\n    //elem_print(e);\n    t = t->toBasetype();\n    switch (t->ty)\n    {\n        case Tpointer:\n            break;\n\n        case Tarray:\n        case Tdelegate:\n            if (e->Eoper == OPcomma)\n            {\n                e->Ety = TYnptr;\n                e->E2 = array_toPtr(t, e->E2);\n            }\n            else if (e->Eoper == OPpair)\n            {\n                e->Eoper = OPcomma;\n                e->Ety = TYnptr;\n            }\n            else\n            {\n#if 1\n                e = el_una(OPmsw, TYnptr, e);\n#else\n                e = el_una(OPaddr, TYnptr, e);\n                e = el_bin(OPadd, TYnptr, e, el_long(TYsize_t, 4));\n                e = el_una(OPind, TYnptr, e);\n#endif\n            }\n            break;\n\n        case Tsarray:\n            e = el_una(OPaddr, TYnptr, e);\n            break;\n\n        default:\n            t->print();\n            assert(0);\n    }\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/**************************************\n * Mirrors logic in Dsymbol_canThrow().\n */\n", "func_signal": "elem *Dsymbol_toElem(Dsymbol *s, IRState *irs)", "code": "{\n    elem *e = NULL;\n    Symbol *sp;\n    AttribDeclaration *ad;\n    VarDeclaration *vd;\n    ClassDeclaration *cd;\n    StructDeclaration *sd;\n    FuncDeclaration *fd;\n    TemplateMixin *tm;\n    TupleDeclaration *td;\n    TypedefDeclaration *tyd;\n\n    //printf(\"Dsymbol_toElem() %s\\n\", s->toChars());\n    ad = s->isAttribDeclaration();\n    if (ad)\n    {\n        Dsymbols *decl = ad->include(NULL, NULL);\n        if (decl && decl->dim)\n        {\n            for (size_t i = 0; i < decl->dim; i++)\n            {\n                s = decl->tdata()[i];\n                e = el_combine(e, Dsymbol_toElem(s, irs));\n            }\n        }\n    }\n    else if ((vd = s->isVarDeclaration()) != NULL)\n    {\n        s = s->toAlias();\n        if (s != vd)\n            return Dsymbol_toElem(s, irs);\n        if (vd->storage_class & STCmanifest)\n            return NULL;\n        else if (vd->isStatic() || vd->storage_class & (STCextern | STCtls | STCgshared))\n            vd->toObjFile(0);\n        else\n        {\n            sp = s->toSymbol();\n            symbol_add(sp);\n            //printf(\"\\tadding symbol '%s'\\n\", sp->Sident);\n            if (vd->init)\n            {\n                ExpInitializer *ie;\n\n                ie = vd->init->isExpInitializer();\n                if (ie)\n                    e = ie->exp->toElem(irs);\n            }\n\n            /* Mark the point of construction of a variable that needs to be destructed.\n             */\n            if (vd->edtor && !vd->noscope)\n            {\n                e = el_dctor(e, vd);\n\n                // Put vd on list of things needing destruction\n                if (!irs->varsInScope)\n                    irs->varsInScope = new VarDeclarations();\n                irs->varsInScope->push(vd);\n            }\n        }\n    }\n    else if ((cd = s->isClassDeclaration()) != NULL)\n    {\n        irs->deferToObj->push(s);\n    }\n    else if ((sd = s->isStructDeclaration()) != NULL)\n    {\n        irs->deferToObj->push(sd);\n    }\n    else if ((fd = s->isFuncDeclaration()) != NULL)\n    {\n        //printf(\"function %s\\n\", fd->toChars());\n        irs->deferToObj->push(fd);\n    }\n    else if ((tm = s->isTemplateMixin()) != NULL)\n    {\n        //printf(\"%s\\n\", tm->toChars());\n        if (tm->members)\n        {\n            for (size_t i = 0; i < tm->members->dim; i++)\n            {\n                Dsymbol *sm = tm->members->tdata()[i];\n                e = el_combine(e, Dsymbol_toElem(sm, irs));\n            }\n        }\n    }\n    else if ((td = s->isTupleDeclaration()) != NULL)\n    {\n        for (size_t i = 0; i < td->objects->dim; i++)\n        {   Object *o = td->objects->tdata()[i];\n            if (o->dyncast() == DYNCAST_EXPRESSION)\n            {   Expression *eo = (Expression *)o;\n                if (eo->op == TOKdsymbol)\n                {   DsymbolExp *se = (DsymbolExp *)eo;\n                    e = el_combine(e, Dsymbol_toElem(se->s, irs));\n                }\n            }\n        }\n    }\n    else if ((tyd = s->isTypedefDeclaration()) != NULL)\n    {\n        irs->deferToObj->push(tyd);\n    }\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/*******************************************\n * Take address of an elem.\n */\n", "func_signal": "elem *addressElem(elem *e, Type *t)", "code": "{\n    elem **pe;\n\n    //printf(\"addressElem()\\n\");\n\n    for (pe = &e; (*pe)->Eoper == OPcomma; pe = &(*pe)->E2)\n        ;\n    if ((*pe)->Eoper != OPvar && (*pe)->Eoper != OPind)\n    {   Symbol *stmp;\n        elem *eeq;\n        elem *e2 = *pe;\n        type *tx;\n\n        // Convert to ((tmp=e2),tmp)\n        TY ty;\n        if (t && ((ty = t->toBasetype()->ty) == Tstruct || ty == Tsarray))\n            tx = t->toCtype();\n        else\n            tx = type_fake(e2->Ety);\n        stmp = symbol_genauto(tx);\n        eeq = el_bin(OPeq,e2->Ety,el_var(stmp),e2);\n        if (tybasic(e2->Ety) == TYstruct)\n        {\n            eeq->Eoper = OPstreq;\n            eeq->ET = e2->ET;\n        }\n        else if (tybasic(e2->Ety) == TYarray)\n        {\n            eeq->Eoper = OPstreq;\n            eeq->Ejty = eeq->Ety = TYstruct;\n            eeq->ET = t ? t->toCtype() : tx;\n        }\n        *pe = el_bin(OPcomma,e2->Ety,eeq,el_var(stmp));\n    }\n    e = el_una(OPaddr,TYnptr,e);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *AndAndExp::toElem(IRState *irs)", "code": "{\n    tym_t tym = type->totym();\n\n    elem *el = e1->toElem(irs);\n    elem *er = e2->toElemDtor(irs);\n    elem *e = el_bin(OPandand,tym,el,er);\n\n    el_setLoc(e,loc);\n\n    if (global.params.cov && e2->loc.linnum)\n        e->E2 = el_combine(incUsageElem(irs, e2->loc), e->E2);\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "// Decide if 'then' or 'else' code should be included\n", "func_signal": "Dsymbols *ConditionalDeclaration::include(Scope *sc, ScopeDsymbol *sd)", "code": "{\n    //printf(\"ConditionalDeclaration::include()\\n\");\n    assert(condition);\n    return condition->include(sc, sd) ? decl : elsedecl;\n}", "path": "attrib.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/***************************************\n */\n", "func_signal": "elem *CmpExp::toElem(IRState *irs)", "code": "{\n    elem *e;\n    enum OPER eop;\n    Type *t1 = e1->type->toBasetype();\n    Type *t2 = e2->type->toBasetype();\n\n    switch (op)\n    {\n        case TOKlt:     eop = OPlt;     break;\n        case TOKgt:     eop = OPgt;     break;\n        case TOKle:     eop = OPle;     break;\n        case TOKge:     eop = OPge;     break;\n        case TOKequal:  eop = OPeqeq;   break;\n        case TOKnotequal: eop = OPne;   break;\n\n        // NCEG floating point compares\n        case TOKunord:  eop = OPunord;  break;\n        case TOKlg:     eop = OPlg;     break;\n        case TOKleg:    eop = OPleg;    break;\n        case TOKule:    eop = OPule;    break;\n        case TOKul:     eop = OPul;     break;\n        case TOKuge:    eop = OPuge;    break;\n        case TOKug:     eop = OPug;     break;\n        case TOKue:     eop = OPue;     break;\n        default:\n            dump(0);\n            assert(0);\n    }\n    if (!t1->isfloating())\n    {\n        // Convert from floating point compare to equivalent\n        // integral compare\n        eop = (enum OPER)rel_integral(eop);\n    }\n    if ((int)eop > 1 && t1->ty == Tclass && t2->ty == Tclass)\n    {\n#if 1\n        assert(0);\n#else\n        elem *ec1;\n        elem *ec2;\n\n        ec1 = e1->toElem(irs);\n        ec2 = e2->toElem(irs);\n        e = el_bin(OPcall,TYint,el_var(rtlsym[RTLSYM_OBJ_CMP]),el_param(ec1, ec2));\n        e = el_bin(eop, TYint, e, el_long(TYint, 0));\n#endif\n    }\n    else if ((int)eop > 1 &&\n             (t1->ty == Tarray || t1->ty == Tsarray) &&\n             (t2->ty == Tarray || t2->ty == Tsarray))\n    {\n        elem *ea1;\n        elem *ea2;\n        elem *ep;\n        Type *telement = t1->nextOf()->toBasetype();\n        int rtlfunc;\n\n        ea1 = e1->toElem(irs);\n        ea1 = array_toDarray(t1, ea1);\n        ea2 = e2->toElem(irs);\n        ea2 = array_toDarray(t2, ea2);\n\n#if DMDV2\n        ep = el_params(telement->arrayOf()->getInternalTypeInfo(NULL)->toElem(irs),\n                ea2, ea1, NULL);\n        rtlfunc = RTLSYM_ARRAYCMP2;\n#else\n        ep = el_params(telement->getInternalTypeInfo(NULL)->toElem(irs), ea2, ea1, NULL);\n        rtlfunc = RTLSYM_ARRAYCMP;\n#endif\n        e = el_bin(OPcall, TYint, el_var(rtlsym[rtlfunc]), ep);\n        e = el_bin(eop, TYint, e, el_long(TYint, 0));\n        el_setLoc(e,loc);\n    }\n    else\n    {\n        if ((int)eop <= 1)\n        {\n            /* The result is determinate, create:\n             *   (e1 , e2) , eop\n             */\n            e = toElemBin(irs,OPcomma);\n            e = el_bin(OPcomma,e->Ety,e,el_long(e->Ety,(int)eop));\n        }\n        else\n            e = toElemBin(irs,eop);\n    }\n    return e;\n}", "path": "e2ir.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/****************************************\n */\n", "func_signal": "void AttribDeclaration::addLocalClass(ClassDeclarations *aclasses)", "code": "{\n    Dsymbols *d = include(NULL, NULL);\n\n    if (d)\n    {\n        for (unsigned i = 0; i < d->dim; i++)\n        {   Dsymbol *s = d->tdata()[i];\n            s->addLocalClass(aclasses);\n        }\n    }\n}", "path": "attrib.c", "repo_name": "adamdruppe/dtojs", "stars": 19, "license": "None", "language": "c", "size": 1037}
{"docstring": "/*!\n *  make8To1DitherTables()\n *\n *      Input: &tabval (value assigned to output pixel; 0 or 1)\n *             &tab38  (amount propagated to pixels left and below)\n *             &tab14  (amount propagated to pixel to left and down)\n *             lowerclip (values near 0 where the excess is not propagated)\n *             upperclip (values near 255 where the deficit is not propagated)\n *\n *      Return: 0 if OK, 1 on error\n */\n", "func_signal": "l_int32\nmake8To1DitherTables(l_int32 **ptabval,\n                     l_int32 **ptab38,\n                     l_int32 **ptab14,\n                     l_int32   lowerclip,\n                     l_int32   upperclip)", "code": "{\nl_int32   i;\nl_int32  *tabval, *tab38, *tab14;\n\n    PROCNAME(\"make8To1DitherTables\");\n\n    if (!ptabval || !ptab38 || !ptab14)\n        return ERROR_INT(\"table ptrs not all defined\", procName, 1);\n\n        /* 3 lookup tables: 1-bit value, (3/8)excess, and (1/4)excess */\n    if ((tabval = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tabval not made\", procName, 1);\n    if ((tab38 = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tab38 not made\", procName, 1);\n    if ((tab14 = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tab14 not made\", procName, 1);\n    *ptabval = tabval;\n    *ptab38 = tab38;\n    *ptab14 = tab14;\n\n    for (i = 0; i < 256; i++) {\n        if (i <= lowerclip) {\n            tabval[i] = 1;\n            tab38[i] = 0;\n            tab14[i] = 0;\n        }\n        else if (i < 128) {\n            tabval[i] = 1;\n            tab38[i] = (3 * i + 4) / 8;\n            tab14[i] = (i + 2) / 4;\n        }\n        else if (i < 255 - upperclip) {\n            tabval[i] = 0;\n            tab38[i] = (3 * (i - 255) + 4) / 8;\n            tab14[i] = ((i - 255) + 2) / 4;\n        }\n        else {  /* i >= 255 - upperclip */\n            tabval[i] = 0;\n            tab38[i] = 0;\n            tab14[i] = 0;\n        }\n    }\n\n    return 0;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  partelDestroy()\n *\n *      Input:  &partel (<will be set to null before returning>)\n *      Return: void\n */\n", "func_signal": "static void\npartelDestroy(PARTEL  **ppartel)", "code": "{\nPARTEL  *partel;\n\n    PROCNAME(\"partelDestroy\");\n\n    if (ppartel == NULL) {\n        L_WARNING(\"ptr address is null!\", procName);\n        return;\n    }\n\n    if ((partel = *ppartel) == NULL)\n        return;\n\n    boxDestroy(&partel->box);\n    boxaDestroy(&partel->boxa);\n    FREE(partel);\n    *ppartel = NULL;\n    return;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixFindEqualValues()\n *\n *      Input:  pixs1 (8 bpp)\n *              pixs2 (8 bpp)\n *      Return: pixd (1 bpp mask), or null on error\n *\n *  Notes:\n *      (1) The two images are aligned at the UL corner, and the returned\n *          image has ON pixels where the pixels in pixs1 and pixs2\n *          have equal values.\n */\n", "func_signal": "PIX *\npixFindEqualValues(PIX  *pixs1,\n                   PIX  *pixs2)", "code": "{\nl_int32    w1, h1, w2, h2, w, h;\nl_int32    i, j, val1, val2, wpls1, wpls2, wpld;\nl_uint32  *datas1, *datas2, *datad, *lines1, *lines2, *lined;\nPIX       *pixd;\n\n    PROCNAME(\"pixFindEqualValues\");\n\n    if (!pixs1 || pixGetDepth(pixs1) != 8)\n        return (PIX *)ERROR_PTR(\"pixs1 undefined or not 8 bpp\", procName, NULL);\n    if (!pixs2 || pixGetDepth(pixs2) != 8)\n        return (PIX *)ERROR_PTR(\"pixs2 undefined or not 8 bpp\", procName, NULL);\n    pixGetDimensions(pixs1, &w1, &h1, NULL);\n    pixGetDimensions(pixs2, &w2, &h2, NULL);\n    w = L_MIN(w1, w2);\n    h = L_MIN(h1, h2);\n    pixd = pixCreate(w, h, 1);\n    datas1 = pixGetData(pixs1);\n    datas2 = pixGetData(pixs2);\n    datad = pixGetData(pixd);\n    wpls1 = pixGetWpl(pixs1);\n    wpls2 = pixGetWpl(pixs2);\n    wpld = pixGetWpl(pixd);\n\n    for (i = 0; i < h; i++) {\n        lines1 = datas1 + i * wpls1;\n        lines2 = datas2 + i * wpls2;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            val1 = GET_DATA_BYTE(lines1, j);\n            val2 = GET_DATA_BYTE(lines2, j);\n            if (val1 == val2)\n                SET_DATA_BIT(lined, j);\n        }\n    }\n\n    return pixd;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixSelectMinInConnComp()\n *\n *      Input:  pixs (8 bpp)\n *              pixm (1 bpp)\n *              &nav (<optional return> numa of minima values)\n *      Return: pta (of min pixels), or null on error\n *\n *  Notes:\n *      (1) For each 8 connected component in pixm, this finds\n *          a pixel in pixs that has the lowest value, and saves\n *          it in a Pta.  If several pixels in pixs have the same\n *          minimum value, it picks the first one found.\n *      (2) For a mask pixm of true local minima, all pixels in each\n *          connected component have the same value in pixs, so it is\n *          fastest to select one of them using a special seedfill\n *          operation.  Not yet implemented.\n */\n", "func_signal": "PTA *\npixSelectMinInConnComp(PIX    *pixs,\n                       PIX    *pixm,\n                       NUMA  **pnav)", "code": "{\nl_int32    ws, hs, wm, hm, w, h, bx, by, bw, bh, i, j, c, n;\nl_int32    xs, ys, minx, miny, wpls, wplt, val, minval;\nl_uint32  *datas, *datat, *lines, *linet;\nBOXA      *boxa;\nNUMA      *nav;\nPIX       *pixt;\nPIXA      *pixa;\nPTA       *pta;\n\n    PROCNAME(\"pixSelectMinInConnComp\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PTA *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (!pixm || pixGetDepth(pixm) != 1)\n        return (PTA *)ERROR_PTR(\"pixm undefined or not 1 bpp\", procName, NULL);\n    pixGetDimensions(pixs, &ws, &hs, NULL);\n    pixGetDimensions(pixm, &wm, &hm, NULL);\n    w = L_MIN(ws, wm);\n    h = L_MIN(hs, hm);\n\n    boxa = pixConnComp(pixm, &pixa, 8);\n    n = boxaGetCount(boxa);\n    pta = ptaCreate(n);\n    nav = numaCreate(n);\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    for (c = 0; c < n; c++) {\n        pixt = pixaGetPix(pixa, c, L_CLONE);\n        boxaGetBoxGeometry(boxa, c, &bx, &by, &bw, &bh);\n        if (bw == 1 && bh == 1) {\n            ptaAddPt(pta, bx, by);\n            numaAddNumber(nav, GET_DATA_BYTE(datas + by * wpls, bx));\n            pixDestroy(&pixt);\n            continue;\n        }\n        datat = pixGetData(pixt);\n        wplt = pixGetWpl(pixt);\n        minx = miny = 1000000;\n        minval = 256;\n        for (i = 0; i < bh; i++) {\n            ys = by + i;\n            lines = datas + ys * wpls;\n            linet = datat + i * wplt;\n            for (j = 0; j < bw; j++) {\n                xs = bx + j;\n                if (GET_DATA_BIT(linet, j)) {\n                    val = GET_DATA_BYTE(lines, xs);\n                    if (val < minval) {\n                        minval = val;\n                        minx = xs;\n                        miny = ys;\n                    }\n                }\n            }\n        }\n        ptaAddPt(pta, minx, miny);\n        numaAddNumber(nav, GET_DATA_BYTE(datas + miny * wpls, minx));\n        pixDestroy(&pixt);\n    }\n\n    boxaDestroy(&boxa);\n    pixaDestroy(&pixa);\n    if (pnav)\n        *pnav = nav;\n    else\n        numaDestroy(&nav);\n    return pta;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  boxaGenerateSubboxes()\n *\n *      Input:  box (region to be split into up to four overlapping subregions)\n *              boxa (boxes of rectangles intersecting the box)\n *              maxperim (maximum half-perimeter for which pivot\n *                        is selected by proximity to box centroid)\n *              fract (fraction of box diagonal that is an acceptable\n *                     distance from the box centroid to select the pivot)\n *      Return: boxa (of four or less overlapping subrectangles of the box),\n *              or null on error\n */\n", "func_signal": "static BOXA *\nboxaGenerateSubboxes(BOX       *box,\n                     BOXA      *boxa,\n                     l_int32    maxperim,\n                     l_float32  fract)", "code": "{\nl_int32  x, y, w, h, xp, yp, wp, hp;\nBOX     *boxp;  /* pivot box */\nBOX     *boxsub;\nBOXA    *boxa4;\n\n    PROCNAME(\"boxaGenerateSubboxes\");\n\n    if (!box)\n        return (BOXA *)ERROR_PTR(\"box not defined\", procName, NULL);\n    if (!boxa)\n        return (BOXA *)ERROR_PTR(\"boxa not defined\", procName, NULL);\n\n    boxa4 = boxaCreate(4);\n    boxp = boxaSelectPivotBox(box, boxa, maxperim, fract);\n    boxGetGeometry(box, &x, &y, &w, &h);\n    boxGetGeometry(boxp, &xp, &yp, &wp, &hp);\n    boxDestroy(&boxp);\n    if (xp > x) {   /* left sub-box */\n        boxsub = boxCreate(x, y, xp - x, h);\n        boxaAddBox(boxa4, boxsub, L_INSERT);\n    }\n    if (yp > y) {   /* top sub-box */\n        boxsub = boxCreate(x, y, w, yp - y);\n        boxaAddBox(boxa4, boxsub, L_INSERT);\n    }\n    if (xp + wp < x + w) {   /* right sub-box */\n        boxsub = boxCreate(xp + wp, y, x + w - xp - wp, h);\n        boxaAddBox(boxa4, boxsub, L_INSERT);\n    }\n    if (yp + hp < y + h) {   /* bottom sub-box */\n        boxsub = boxCreate(x, yp + hp, w, y + h - yp - hp);\n        boxaAddBox(boxa4, boxsub, L_INSERT);\n    }\n\n    return boxa4;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*------------------------------------------------------------------*\n *             Simple binarization with fixed threshold             *\n *------------------------------------------------------------------*/\n/*\n *  thresholdToBinaryLow()\n *\n *  If the source pixel is less than thresh,\n *  the dest will be 1; otherwise, it will be 0\n */\n", "func_signal": "void\nthresholdToBinaryLow(l_uint32  *datad,\n                     l_int32    w,\n                     l_int32    h,\n                     l_int32    wpld,\n                     l_uint32  *datas,\n                     l_int32    d,\n                     l_int32    wpls,\n                     l_int32    thresh)", "code": "{\nl_int32    i;\nl_uint32  *lines, *lined;\n\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lined = datad + i * wpld;\n        thresholdToBinaryLineLow(lined, w, lines, d, thresh);\n    }\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  boxaPruneSortedOnOverlap()\n *\n *      Input:  boxas (sorted by size in decreasing order)\n *              maxoverlap (maximum fractional overlap of a box by any\n *                          of the larger boxes)\n *      Return: boxad (pruned), or null on error\n *\n *  Notes:\n *      (1) This selectively removes smaller boxes when they are overlapped\n *          by any larger box by more than the input 'maxoverlap' fraction.\n *      (2) To avoid all pruning, use maxoverlap = 1.0.  To select only\n *          boxes that have no overlap with each other (maximal pruning),\n *          set maxoverlap = 0.0.\n *      (3) If there are no boxes in boxas, returns an empty boxa.\n */\n", "func_signal": "BOXA *\nboxaPruneSortedOnOverlap(BOXA      *boxas,\n                         l_float32  maxoverlap)", "code": "{\nl_int32    i, j, n, remove;\nl_float32  fract;\nBOX       *box1, *box2;\nBOXA      *boxad;\n\n    PROCNAME(\"boxaPruneSortedOnOverlap\");\n\n    if (!boxas)\n        return (BOXA *)ERROR_PTR(\"boxas not defined\", procName, NULL);\n    if (maxoverlap < 0.0 || maxoverlap > 1.0)\n        return (BOXA *)ERROR_PTR(\"invalid maxoverlap\", procName, NULL);\n\n    n = boxaGetCount(boxas);\n    if (n == 0 || maxoverlap == 1.0)\n        return boxaCopy(boxas, L_COPY);\n\n    boxad = boxaCreate(0);\n    box2 = boxaGetBox(boxas, 0, L_COPY);\n    boxaAddBox(boxad, box2, L_INSERT);\n    for (j = 1; j < n; j++) {   /* prune on j */\n        box2 = boxaGetBox(boxas, j, L_COPY);\n        remove = FALSE;\n        for (i = 0; i < j; i++) {   /* test on i */\n            box1 = boxaGetBox(boxas, i, L_CLONE);\n            boxOverlapFraction(box1, box2, &fract);\n            boxDestroy(&box1);\n            if (fract > maxoverlap) {\n                remove = TRUE;\n                break;\n            }\n        }\n        if (remove == TRUE)\n            boxDestroy(&box2);\n        else\n            boxaAddBox(boxad, box2, L_INSERT);\n    }\n\n    return boxad;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixExtractBorderConnComps()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd  (all pixels in the src that are in connected\n *                     components touching the border), or null on error\n */\n", "func_signal": "PIX *\npixExtractBorderConnComps(PIX     *pixs,\n                          l_int32  connectivity)", "code": "{\nPIX  *pixd;\n\n    PROCNAME(\"pixExtractBorderConnComps\");\n\n    if (!pixs || pixGetDepth(pixs) != 1)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 1 bpp\", procName, NULL);\n    if (connectivity != 4 && connectivity != 8)\n        return (PIX *)ERROR_PTR(\"connectivity not 4 or 8\", procName, NULL);\n\n        /* Start with 1 pixel wide black border as seed in pixd */\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixSetOrClearBorder(pixd, 1, 1, 1, 1, PIX_SET);\n\n       /* Fill in pixd from the seed, using pixs as the filling mask.\n        * This fills all components from pixs that are touching the border. */\n    pixSeedfillBinary(pixd, pixd, pixs, connectivity);\n\n    return pixd;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*------------------------------------------------------------------*\n *                               Helpers                            *\n *------------------------------------------------------------------*/\n/*!\n *  partelCreate()\n *\n *      Input:  box (region; inserts a copy)\n *      Return: partel, or null on error\n */\n", "func_signal": "static PARTEL *\npartelCreate(BOX  *box)", "code": "{\nPARTEL  *partel;\n\n    PROCNAME(\"partelCreate\");\n\n    if ((partel = (PARTEL *)CALLOC(1, sizeof(PARTEL))) == NULL)\n        return (PARTEL *)ERROR_PTR(\"partel not made\", procName, NULL);\n\n    partel->box = boxCopy(box);\n    return partel;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  ditherToBinaryLineLUTLow()\n *   \n *      Input:  lined  (ptr to beginning of dest line\n *              w   (width of image in pixels)\n *              bufs1 (buffer of current source line)\n *              bufs2 (buffer of next source line)\n *              tabval (value to assign for current pixel)\n *              tab38 (excess value to give to neighboring 3/8 pixels)\n *              tab14 (excess value to give to neighboring 1/4 pixel)\n *              lastlineflag  (0 if not last dest line, 1 if last dest line)\n *      Return: void\n */\n", "func_signal": "void\nditherToBinaryLineLUTLow(l_uint32  *lined,\n                         l_int32    w,\n                         l_uint32  *bufs1,\n                         l_uint32  *bufs2,\n                         l_int32   *tabval,\n                         l_int32   *tab38,\n                         l_int32   *tab14,\n                         l_int32    lastlineflag)", "code": "{\nl_int32  j;\nl_int32  oval, tab38val, tab14val;\nl_uint8  rval, bval, dval;\n\n    if (lastlineflag == 0) {\n        for (j = 0; j < w - 1; j++) {\n            oval = GET_DATA_BYTE(bufs1, j);\n            if (tabval[oval])\n                SET_DATA_BIT(lined, j);\n            rval = GET_DATA_BYTE(bufs1, j + 1);\n            bval = GET_DATA_BYTE(bufs2, j);\n            dval = GET_DATA_BYTE(bufs2, j + 1);\n            tab38val = tab38[oval];\n            if (tab38val == 0)\n                continue;\n            tab14val = tab14[oval];\n            if (tab38val < 0) {\n                rval = L_MAX(0, rval + tab38val);\n                bval = L_MAX(0, bval + tab38val);\n                dval = L_MAX(0, dval + tab14val);\n            }\n            else  {\n                rval = L_MIN(255, rval + tab38val);\n                bval = L_MIN(255, bval + tab38val);\n                dval = L_MIN(255, dval + tab14val);\n            }\n            SET_DATA_BYTE(bufs1, j + 1, rval);\n            SET_DATA_BYTE(bufs2, j, bval);\n            SET_DATA_BYTE(bufs2, j + 1, dval);\n        }\n\n            /* do last column: j = w - 1 */\n        oval = GET_DATA_BYTE(bufs1, j);\n        if (tabval[oval])\n            SET_DATA_BIT(lined, j);\n        bval = GET_DATA_BYTE(bufs2, j);\n        tab38val = tab38[oval];\n        if (tab38val < 0) {\n            bval = L_MAX(0, bval + tab38val);\n            SET_DATA_BYTE(bufs2, j, bval);\n        }\n        else if (tab38val > 0 ) {\n            bval = L_MIN(255, bval + tab38val);\n            SET_DATA_BYTE(bufs2, j, bval);\n        }\n    }\n    else {   /* lastlineflag == 1 */\n        for (j = 0; j < w - 1; j++) {\n            oval = GET_DATA_BYTE(bufs1, j);\n            if (tabval[oval])\n                SET_DATA_BIT(lined, j);\n            rval = GET_DATA_BYTE(bufs1, j + 1);\n            tab38val = tab38[oval];\n            if (tab38val == 0)\n                continue;\n            if (tab38val < 0)\n                rval = L_MAX(0, rval + tab38val);\n            else\n                rval = L_MIN(255, rval + tab38val);\n            SET_DATA_BYTE(bufs1, j + 1, rval);\n        }\n\n            /* do last pixel: (i, j) = (h - 1, w - 1) */\n        oval = GET_DATA_BYTE(bufs1, j);\n        if (tabval[oval])\n            SET_DATA_BIT(lined, j);\n    }\n\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixQualifyLocalMinima()\n *\n *      Input:  pixs  (8 bpp)\n *              pixm  (1 bpp mask of values equal to min in 3x3 neighborhood)\n *              maxval (max allowed for the min in a 3x3 neighborhood;\n *                      use 0 for default which is to have no upper bound)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function acts in-place to remove all c.c. in pixm\n *          that are not true local minima.  See notes in pixLocalExtrema().\n *      (2) The maximum allowed value for each local minimum can be\n *          bounded with @maxval.  Use 0 for default, which is to have\n *          no upper bound (equivalent to maxval == 254).\n */\n", "func_signal": "static l_int32\npixQualifyLocalMinima(PIX     *pixs,\n                      PIX     *pixm,\n                      l_int32  maxval)", "code": "{\nl_int32    n, i, j, k, x, y, w, h, xc, yc, wc, hc, xon, yon;\nl_int32    vals, wpls, wplc, ismin;\nl_uint32   val;\nl_uint32  *datas, *datac, *lines, *linec;\nBOXA      *boxa;\nPIX       *pixt1, *pixt2, *pixc;\nPIXA      *pixa;\n\n    PROCNAME(\"pixQualifyLocalMinima\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (!pixm || pixGetDepth(pixm) != 1)\n        return ERROR_INT(\"pixm not defined or not 1 bpp\", procName, 1);\n    if (maxval <= 0) maxval = 254;\n\n    pixGetDimensions(pixs, &w, &h, NULL);\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    boxa = pixConnComp(pixm, &pixa, 8);\n    n = pixaGetCount(pixa);\n    for (k = 0; k < n; k++) {\n        boxaGetBoxGeometry(boxa, k, &xc, &yc, &wc, &hc);\n        pixt1 = pixaGetPix(pixa, k, L_COPY);\n        pixt2 = pixAddBorder(pixt1, 1, 0);\n        pixc = pixDilateBrick(NULL, pixt2, 3, 3);\n        pixXor(pixc, pixc, pixt2);  /* exterior boundary pixels */\n        datac = pixGetData(pixc);\n        wplc = pixGetWpl(pixc);\n        nextOnPixelInRaster(pixt1, 0, 0, &xon, &yon);\n        pixGetPixel(pixs, xc + xon, yc + yon, &val);\n        if (val > maxval) {  /* too large; erase */\n            pixRasterop(pixm, xc, yc, wc, hc, PIX_XOR, pixt1, 0, 0);\n            pixDestroy(&pixt1);\n            pixDestroy(&pixt2);\n            pixDestroy(&pixc);\n            continue;\n        }\n        ismin = TRUE;\n        for (i = 0, y = yc - 1; i < hc + 2 && y >= 0 && y < h; i++, y++) {\n            lines = datas + y * wpls;\n            linec = datac + i * wplc;\n            for (j = 0, x = xc - 1; j < wc + 2 && x >= 0 && x < w; j++, x++) {\n                if (GET_DATA_BIT(linec, j)) {\n                    vals = GET_DATA_BYTE(lines, x);\n                    if (vals <= val) {  /* not a minimum! */\n                        ismin = FALSE;\n                        break;\n                    }\n                }\n            }\n            if (!ismin)\n                break;\n        }\n        if (!ismin)  /* erase it */\n            pixRasterop(pixm, xc, yc, wc, hc, PIX_XOR, pixt1, 0, 0);\n        pixDestroy(&pixt1);\n        pixDestroy(&pixt2);\n        pixDestroy(&pixc);\n    }\n\n    boxaDestroy(&boxa);\n    pixaDestroy(&pixa);\n    return 0;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixFillClosedBorders()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd  (all topologically outer closed borders are filled\n *                     as connected comonents), or null on error\n *\n *  Notes:\n *      (1) Start with 1-pixel black border on otherwise white pixd\n *      (2) Subtract input pixs to remove border pixels that were\n *          also on the closed border\n *      (3) Use the inverted pixs as the filling mask to fill in\n *          all the pixels from the outer border to the closed border\n *          on pixs\n *      (4) Invert the result to get the filled component, including\n *          the input border\n *      (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.\n *      (6) Closed borders within c.c. that represent holes, etc., are filled.\n */\n", "func_signal": "PIX *\npixFillClosedBorders(PIX     *pixs,\n                     l_int32  connectivity)", "code": "{\nPIX  *pixsi, *pixd;\n\n    PROCNAME(\"pixFillClosedBorders\");\n\n    if (!pixs || pixGetDepth(pixs) != 1)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 1 bpp\", procName, NULL);\n    if (connectivity != 4 && connectivity != 8)\n        return (PIX *)ERROR_PTR(\"connectivity not 4 or 8\", procName, NULL);\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixSetOrClearBorder(pixd, 1, 1, 1, 1, PIX_SET);\n    pixSubtract(pixd, pixd, pixs);\n    if ((pixsi = pixInvert(NULL, pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsi not made\", procName, NULL);\n\n    pixSeedfillBinary(pixd, pixd, pixsi, connectivity);\n    pixInvert(pixd, pixd);\n    pixDestroy(&pixsi);\n\n    return pixd;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*------------------------------------------------------------------*\n *             Binarization by Floyd-Steinberg Dithering            *\n *------------------------------------------------------------------*/\n/*\n *  ditherToBinaryLow()\n *\n *  See comments in pixDitherToBinary() in binarize.c\n */\n", "func_signal": "void\nditherToBinaryLow(l_uint32  *datad,\n                  l_int32    w,\n                  l_int32    h,\n                  l_int32    wpld,\n                  l_uint32  *datas,\n                  l_int32    wpls,\n                  l_uint32  *bufs1,\n                  l_uint32  *bufs2,\n                  l_int32    lowerclip,\n                  l_int32    upperclip)", "code": "{\nl_int32      i;\nl_uint32    *lined;\n\n        /* do all lines except last line */\n    memcpy(bufs2, datas, 4 * wpls);  /* prime the buffer */\n    for (i = 0; i < h - 1; i++) {\n        memcpy(bufs1, bufs2, 4 * wpls);\n        memcpy(bufs2, datas + (i + 1) * wpls, 4 * wpls);\n        lined = datad + i * wpld;\n        ditherToBinaryLineLow(lined, w, bufs1, bufs2, lowerclip, upperclip, 0);\n    }\n\n        /* do last line */\n    memcpy(bufs1, bufs2, 4 * wpls);\n    lined = datad + (h - 1) * wpld;\n    ditherToBinaryLineLow(lined, w, bufs1, bufs2, lowerclip, upperclip, 1);\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  boxCheckIfOverlapIsBig()\n *\n *      Input:  box (to be tested)\n *              boxa (of boxes already stored)\n *              maxoverlap (maximum fractional overlap of the input box\n *                          by any of the boxes in boxa)\n *      Return: 0 if box has small overlap with every box in boxa;\n *              1 otherwise or on error\n */\n", "func_signal": "static l_int32\nboxCheckIfOverlapIsBig(BOX       *box,\n                       BOXA      *boxa,\n                       l_float32  maxoverlap)", "code": "{\nl_int32    i, n, bigoverlap;\nl_float32  fract;\nBOX       *boxt;\n\n    PROCNAME(\"boxCheckIfOverlapIsBig\");\n\n    if (!box)\n        return ERROR_INT(\"box not defined\", procName, 1);\n    if (!boxa)\n        return ERROR_INT(\"boxa not defined\", procName, 1);\n    if (maxoverlap < 0.0 || maxoverlap > 1.0)\n        return ERROR_INT(\"invalid maxoverlap\", procName, 1);\n\n    n = boxaGetCount(boxa);\n    if (n == 0 || maxoverlap == 1.0)\n        return 0;\n\n    bigoverlap = 0;\n    for (i = 0; i < n; i++) {\n        boxt = boxaGetBox(boxa, i, L_CLONE);\n        boxOverlapFraction(boxt, box, &fract);\n        boxDestroy(&boxt);\n        if (fract > maxoverlap) {\n            bigoverlap = 1;\n            break;\n        }\n    }\n\n    return bigoverlap;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*------------------------------------------------------------------*\n *                   Simple thresholding to 2 bpp                   *\n *------------------------------------------------------------------*/\n/*\n *  thresholdTo2bppLow()\n *\n *  Low-level function for thresholding from 8 bpp (datas) to\n *  2 bpp (datad), using thresholds implicitly defined through @tab,\n *  a 256-entry lookup table that gives a 2-bit output value\n *  for each possible input.\n *\n *  For each line, unroll the loop so that for each 32 bit src word,\n *  representing four consecutive 8-bit pixels, we compose one byte\n *  of output consisiting of four 2-bit pixels.\n */\n", "func_signal": "void\nthresholdTo2bppLow(l_uint32  *datad,\n                   l_int32    h,\n                   l_int32    wpld,\n                   l_uint32  *datas,\n                   l_int32    wpls,\n                   l_int32   *tab)", "code": "{\nl_uint8    sval1, sval2, sval3, sval4, dval;\nl_int32    i, j, k;\nl_uint32  *lines, *lined;\n\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lined = datad + i * wpld;\n        for (j = 0; j < wpls; j++) {\n            k = 4 * j;\n            sval1 = GET_DATA_BYTE(lines, k);\n            sval2 = GET_DATA_BYTE(lines, k + 1);\n            sval3 = GET_DATA_BYTE(lines, k + 2);\n            sval4 = GET_DATA_BYTE(lines, k + 3);\n            dval = (tab[sval1] << 6) | (tab[sval2] << 4) |\n                   (tab[sval3] << 2) | tab[sval4];\n            SET_DATA_BYTE(lined, j, dval);\n        }\n    }\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*------------------------------------------------------------------*\n *                   Simple thresholding to 4 bpp                   *\n *------------------------------------------------------------------*/\n/*\n *  thresholdTo4bppLow()\n *\n *  Low-level function for thresholding from 8 bpp (datas) to\n *  4 bpp (datad), using thresholds implicitly defined through @tab,\n *  a 256-entry lookup table that gives a 4-bit output value\n *  for each possible input.\n *  \n *  For each line, unroll the loop so that for each 32 bit src word,\n *  representing four consecutive 8-bit pixels, we compose two bytes\n *  of output consisiting of four 4-bit pixels.\n */\n", "func_signal": "void\nthresholdTo4bppLow(l_uint32  *datad,\n                   l_int32    h,\n                   l_int32    wpld,\n                   l_uint32  *datas,\n                   l_int32    wpls,\n                   l_int32   *tab)", "code": "{\nl_uint8    sval1, sval2, sval3, sval4;\nl_uint16   dval;\nl_int32    i, j, k;\nl_uint32  *lines, *lined;\n\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lined = datad + i * wpld;\n        for (j = 0; j < wpls; j++) {\n            k = 4 * j;\n            sval1 = GET_DATA_BYTE(lines, k);\n            sval2 = GET_DATA_BYTE(lines, k + 1);\n            sval3 = GET_DATA_BYTE(lines, k + 2);\n            sval4 = GET_DATA_BYTE(lines, k + 3);\n            dval = (tab[sval1] << 12) | (tab[sval2] << 8) |\n                   (tab[sval3] << 4) | tab[sval4];\n            SET_DATA_TWO_BYTES(lined, j, dval);\n        }\n    }\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  make8To2DitherTables()\n *\n *      Input: &tabval (value assigned to output pixel; 0, 1, 2 or 3)\n *             &tab38  (amount propagated to pixels left and below)\n *             &tab14  (amount propagated to pixel to left and down)\n *             cliptoblack (values near 0 where the excess is not propagated)\n *             cliptowhite (values near 255 where the deficit is not propagated)\n *\n *      Return: 0 if OK, 1 on error\n */\n", "func_signal": "l_int32\nmake8To2DitherTables(l_int32 **ptabval,\n                     l_int32 **ptab38,\n                     l_int32 **ptab14,\n                     l_int32   cliptoblack,\n                     l_int32   cliptowhite)", "code": "{\nl_int32   i;\nl_int32  *tabval, *tab38, *tab14;\n\n    PROCNAME(\"make8To2DitherTables\");\n\n        /* 3 lookup tables: 2-bit value, (3/8)excess, and (1/4)excess */\n    if ((tabval = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tabval not made\", procName, 1);\n    if ((tab38 = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tab38 not made\", procName, 1);\n    if ((tab14 = (l_int32 *)CALLOC(256, sizeof(l_int32))) == NULL)\n        return ERROR_INT(\"tab14 not made\", procName, 1);\n    *ptabval = tabval;\n    *ptab38 = tab38;\n    *ptab14 = tab14;\n\n    for (i = 0; i < 256; i++) {\n        if (i <= cliptoblack) {\n            tabval[i] = 0;\n            tab38[i] = 0;\n            tab14[i] = 0;\n        }\n        else if (i < 43) {\n            tabval[i] = 0;\n            tab38[i] = (3 * i + 4) / 8;\n            tab14[i] = (i + 2) / 4;\n        }\n        else if (i < 85) {\n            tabval[i] = 1;\n            tab38[i] = (3 * (i - 85) - 4) / 8;\n            tab14[i] = ((i - 85) - 2) / 4;\n        }\n        else if (i < 128) {\n            tabval[i] = 1;\n            tab38[i] = (3 * (i - 85) + 4) / 8;\n            tab14[i] = ((i - 85) + 2) / 4;\n        }\n        else if (i < 170) {\n            tabval[i] = 2;\n            tab38[i] = (3 * (i - 170) - 4) / 8;\n            tab14[i] = ((i - 170) - 2) / 4;\n        }\n        else if (i < 213) {\n            tabval[i] = 2;\n            tab38[i] = (3 * (i - 170) + 4) / 8;\n            tab14[i] = ((i - 170) + 2) / 4;\n        }\n        else if (i < 255 - cliptowhite) {\n            tabval[i] = 3;\n            tab38[i] = (3 * (i - 255) - 4) / 8;\n            tab14[i] = ((i - 255) - 2) / 4;\n        }\n        else {  /* i >= 255 - cliptowhite */\n            tabval[i] = 3;\n            tab38[i] = 0;\n            tab14[i] = 0;\n        }\n    }\n\n#if 0\n    for (i = 0; i < 256; i++)\n        fprintf(stderr, \"tabval[%d] = %d, tab38[%d] = %d, tab14[%d] = %d\\n\",\n                i, tabval[i], i, tab38[i], i, tab14[i]);\n#endif\n\n    return 0;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  pixHolesByFilling()\n *\n *      Input:  pixs (1 bpp)\n *              connectivity (4 or 8)\n *      Return: pixd  (inverted image of all holes), or null on error\n *\n * Action:\n *     (1) Start with 1-pixel black border on otherwise white pixd\n *     (2) Use the inverted pixs as the filling mask to fill in\n *         all the pixels from the border to the pixs foreground\n *     (3) OR the result with pixs to have an image with all\n *         ON pixels except for the holes.\n *     (4) Invert the result to get the holes as foreground\n *\n * Notes:\n *     (1) To get 4-c.c. holes of the 8-c.c. as foreground, use\n *         4-connected filling; to get 8-c.c. holes of the 4-c.c.\n *         as foreground, use 8-connected filling.\n */\n", "func_signal": "PIX *\npixHolesByFilling(PIX     *pixs,\n                  l_int32  connectivity)", "code": "{\nPIX  *pixsi, *pixd;\n\n    PROCNAME(\"pixHolesByFilling\");\n\n    if (!pixs || pixGetDepth(pixs) != 1)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 1 bpp\", procName, NULL);\n    if (connectivity != 4 && connectivity != 8)\n        return (PIX *)ERROR_PTR(\"connectivity not 4 or 8\", procName, NULL);\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    if ((pixsi = pixInvert(NULL, pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsi not made\", procName, NULL);\n\n    pixSetOrClearBorder(pixd, 1, 1, 1, 1, PIX_SET);\n    pixSeedfillBinary(pixd, pixd, pixsi, connectivity);\n    pixOr(pixd, pixd, pixs);\n    pixInvert(pixd, pixd);\n    pixDestroy(&pixsi);\n\n    return pixd;\n}", "path": "src\\seedfill.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*\n *  thresholdToBinaryLineLow()\n *\n */\n", "func_signal": "void\nthresholdToBinaryLineLow(l_uint32  *lined,\n                         l_int32    w,\n                         l_uint32  *lines,\n                         l_int32    d,\n                         l_int32    thresh)", "code": "{\nl_int32  j, k, gval, scount, dcount;\nl_uint32 sword, dword;\n\n    PROCNAME(\"thresholdToBinaryLineLow\");\n\n    switch (d)\n    {\n    case 4:\n            /* Unrolled as 4 source words, 1 dest word */\n        for (j = 0, scount = 0, dcount = 0; j + 31 < w; j += 32) {\n            dword = 0;\n            for (k = 0; k < 4; k++) {\n                sword = lines[scount++];\n                dword <<= 8;\n                gval = (sword >> 28) & 0xf;\n                    /* Trick used here and below: if gval < thresh then\n                     * gval - thresh < 0, so its high-order bit is 1, and\n                     * ((gval - thresh) >> 31) & 1 == 1; likewise, if\n                     * gval >= thresh, then ((gval - thresh) >> 31) & 1 == 0\n                     * Doing it this way avoids a random (and thus easily\n                     * mispredicted) branch on each pixel. */\n                dword |= ((gval - thresh) >> 24) & 128;\n                gval = (sword >> 24) & 0xf;\n                dword |= ((gval - thresh) >> 25) & 64;\n                gval = (sword >> 20) & 0xf;\n                dword |= ((gval - thresh) >> 26) & 32;\n                gval = (sword >> 16) & 0xf;\n                dword |= ((gval - thresh) >> 27) & 16;\n                gval = (sword >> 12) & 0xf;\n                dword |= ((gval - thresh) >> 28) & 8;\n                gval = (sword >> 8) & 0xf;\n                dword |= ((gval - thresh) >> 29) & 4;\n                gval = (sword >> 4) & 0xf;\n                dword |= ((gval - thresh) >> 30) & 2;\n                gval = sword & 0xf;\n                dword |= ((gval - thresh) >> 31) & 1;\n            }\n            lined[dcount++] = dword;\n        }\n\n        if (j < w) {\n          dword = 0;\n          for (; j < w; j++) {\n              if ((j & 7) == 0) {\n                  sword = lines[scount++];\n              }\n              gval = (sword >> 28) & 0xf;\n              sword <<= 4;\n              dword |= (((gval - thresh) >> 31) & 1) << (31 - (j & 31));\n          }\n          lined[dcount] = dword;\n        }\n#if DEBUG_UNROLLING\n#define CHECK_BIT(a, b, c) if (GET_DATA_BIT(a, b) != c) { \\\n    fprintf(stderr, \"Error: mismatch at %d/%d(%d), %d vs %d\\n\", \\\n            j, w, d, GET_DATA_BIT(a, b), c); }\n        for (j = 0; j < w; j++) {\n            gval = GET_DATA_QBIT(lines, j);\n            CHECK_BIT(lined, j, gval < thresh ? 1 : 0);\n        }\n#endif\n        break;\n    case 8:\n            /* Unrolled as 8 source words, 1 dest word */\n        for (j = 0, scount = 0, dcount = 0; j + 31 < w; j += 32) {\n            dword = 0;\n            for (k = 0; k < 8; k++) {\n                sword = lines[scount++];\n                dword <<= 4;\n                gval = (sword >> 24) & 0xff;\n                dword |= ((gval - thresh) >> 28) & 8;\n                gval = (sword >> 16) & 0xff;\n                dword |= ((gval - thresh) >> 29) & 4;\n                gval = (sword >> 8) & 0xff;\n                dword |= ((gval - thresh) >> 30) & 2;\n                gval = sword & 0xff;\n                dword |= ((gval - thresh) >> 31) & 1;\n            }\n            lined[dcount++] = dword;\n        }\n\n        if (j < w) {\n            dword = 0;\n            for (; j < w; j++) {\n                if ((j & 3) == 0) {\n                    sword = lines[scount++];\n                }\n                gval = (sword >> 24) & 0xff;\n                sword <<= 8;\n                dword |= (((gval - thresh) >> 31) & 1) << (31 - (j & 31));\n            }\n            lined[dcount] = dword;\n        }\n#if DEBUG_UNROLLING\n        for (j = 0; j < w; j++) {\n            gval = GET_DATA_BYTE(lines, j);\n            CHECK_BIT(lined, j, gval < thresh ? 1 : 0);\n        }\n#undef CHECK_BIT\n#endif\n        break;\n    default:\n        L_ERROR(\"src depth not 4 or 8 bpp\", procName);\n        break;\n    }\n    return;\n}", "path": "src\\grayquantlow.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/*!\n *  partelSetSize()\n *\n *      Input:  partel\n *              sortflag (L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,\n *                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,\n *                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA)\n *      Return: 0 if OK, 1 on error\n */\n", "func_signal": "static l_int32\npartelSetSize(PARTEL  *partel,\n              l_int32  sortflag)", "code": "{\nl_int32  w, h;\n\n    PROCNAME(\"partelSetSize\");\n\n    if (!partel)\n        return ERROR_INT(\"partel not defined\", procName, 1);\n\n    boxGetGeometry(partel->box, NULL, NULL, &w, &h);\n    if (sortflag == L_SORT_BY_WIDTH)\n        partel->size = (l_float32)w;\n    else if (sortflag == L_SORT_BY_HEIGHT)\n        partel->size = (l_float32)h;\n    else if (sortflag == L_SORT_BY_MIN_DIMENSION)\n        partel->size = (l_float32)L_MIN(w, h);\n    else if (sortflag == L_SORT_BY_MAX_DIMENSION)\n        partel->size = (l_float32)L_MAX(w, h);\n    else if (sortflag == L_SORT_BY_PERIMETER)\n        partel->size = (l_float32)(w + h);\n    else if (sortflag == L_SORT_BY_AREA)\n        partel->size = (l_float32)(w * h);\n    else\n        return ERROR_INT(\"invalid sortflag\", procName, 1);\n    return 0;\n}", "path": "src\\partition.c", "repo_name": "horndude77/leptonica", "stars": 20, "license": "other", "language": "c", "size": 7904}
{"docstring": "/* ------ LDISC part ------ */\n/* hci_uart_tty_open\n * \n *     Called when line discipline changed to HCI_UART.\n *\n * Arguments:\n *     tty    pointer to tty info structure\n * Return Value:    \n *     0 if success, otherwise error code\n */\n", "func_signal": "static int hci_uart_tty_open(struct tty_struct *tty)", "code": "{\n\tstruct hci_uart *hu = (void *) tty->disc_data;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t/* FIXME: This btw is bogus, nothing requires the old ldisc to clear\n\t   the pointer */\n\tif (hu)\n\t\treturn -EEXIST;\n\n\t/* Error if the tty has no write op instead of leaving an exploitable\n\t   hole */\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(hu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL))) {\n\t\tBT_ERR(\"Can't allocate control structure\");\n\t\treturn -ENFILE;\n\t}\n\n\ttty->disc_data = hu;\n\thu->tty = tty;\n\ttty->receive_room = 65536;\n\n\tspin_lock_init(&hu->rx_lock);\n\n\t/* Flush any pending characters in the driver and line discipline. */\n\n\t/* FIXME: why is this needed. Note don't use ldisc_ref here as the\n\t   open path is before the ldisc is referencable */\n\n\tif (tty->ldisc->ops->flush_buffer)\n\t\ttty->ldisc->ops->flush_buffer(tty);\n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/*\n * module entry\n */\n", "func_signal": "static int __init snd_mem_init(void)", "code": "{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = proc_create(SND_MEM_PROC_FILE, 0644, NULL,\n\t\t\t\t   &snd_mem_proc_fops);\n#endif\n\treturn 0;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* Set input bus gain (one unit is 0.5dB !) */\n", "func_signal": "static int set_input_gain(struct echoaudio *chip, u16 input, int gain)", "code": "{\n\tif (snd_BUG_ON(input >= num_busses_in(chip)))\n\t\treturn -EINVAL;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->input_gain[input] = gain;\n\tgain += GL20_INPUT_GAIN_MAGIC_NUMBER;\n\tchip->comm_page->line_in_level[input] = gain;\n\treturn 0;\n}", "path": "sound\\pci\\echoaudio\\gina20_dsp.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* Tell the DSP to reread the flags from the comm page */\n", "func_signal": "static int update_flags(struct echoaudio *chip)", "code": "{\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_FLAGS);\n}", "path": "sound\\pci\\echoaudio\\gina20_dsp.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/*\n * purge all reserved buffers\n */\n", "func_signal": "static void free_all_reserved_pages(void)", "code": "{\n\tstruct list_head *p;\n\tstruct snd_mem_list *mem;\n\n\tmutex_lock(&list_mutex);\n\twhile (! list_empty(&mem_list_head)) {\n\t\tp = mem_list_head.next;\n\t\tmem = list_entry(p, struct snd_mem_list, list);\n\t\tlist_del(p);\n\t\tsnd_dma_free_pages(&mem->buffer);\n\t\tkfree(mem);\n\t}\n\tmutex_unlock(&list_mutex);\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* CONFIG_PPC_I8259 */\n", "func_signal": "void __init mpc86xx_init_irq(void)", "code": "{\n\tstruct mpic *mpic;\n\tstruct device_node *np;\n\tstruct resource res;\n#ifdef CONFIG_PPC_I8259\n\tstruct device_node *cascade_node = NULL;\n\tint cascade_irq;\n#endif\n\n\t/* Determine PIC address. */\n\tnp = of_find_node_by_type(NULL, \"open-pic\");\n\tif (np == NULL)\n\t\treturn;\n\tof_address_to_resource(np, 0, &res);\n\n\tmpic = mpic_alloc(np, res.start,\n\t\t\tMPIC_PRIMARY | MPIC_WANTS_RESET |\n\t\t\tMPIC_BIG_ENDIAN | MPIC_BROKEN_FRR_NIRQS |\n\t\t\tMPIC_SINGLE_DEST_CPU,\n\t\t\t0, 256, \" MPIC     \");\n\tof_node_put(np);\n\tBUG_ON(mpic == NULL);\n\n\tmpic_init(mpic);\n\n#ifdef CONFIG_PPC_I8259\n\t/* Initialize i8259 controller */\n\tfor_each_node_by_type(np, \"interrupt-controller\")\n\t\tif (of_device_is_compatible(np, \"chrp,iic\")) {\n\t\t\tcascade_node = np;\n\t\t\tbreak;\n\t\t}\n\n\tif (cascade_node == NULL) {\n\t\tprintk(KERN_DEBUG \"Could not find i8259 PIC\\n\");\n\t\treturn;\n\t}\n\n\tcascade_irq = irq_of_parse_and_map(cascade_node, 0);\n\tif (cascade_irq == NO_IRQ) {\n\t\tprintk(KERN_ERR \"Failed to map cascade interrupt\\n\");\n\t\treturn;\n\t}\n\n\ti8259_init(cascade_node, 0);\n\tof_node_put(cascade_node);\n\n\tset_irq_chained_handler(cascade_irq, mpc86xx_8259_cascade);\n#endif\n}", "path": "arch\\powerpc\\platforms\\86xx\\pic.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* ------- Interface to HCI layer ------ */\n/* Initialize device */\n", "func_signal": "static int hci_uart_open(struct hci_dev *hdev)", "code": "{\n\tBT_DBG(\"%s %p\", hdev->name, hdev);\n\n\t/* Nothing to do for UART driver */\n\n\tset_bit(HCI_RUNNING, &hdev->flags);\n\n\treturn 0;\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* hci_uart_tty_receive()\n * \n *     Called by tty low level driver when receive data is\n *     available.\n *     \n * Arguments:  tty          pointer to tty isntance data\n *             data         pointer to received data\n *             flags        pointer to flags for data\n *             count        count of received data in bytes\n *     \n * Return Value:    None\n */\n", "func_signal": "static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *flags, int count)", "code": "{\n\tstruct hci_uart *hu = (void *)tty->disc_data;\n\n\tif (!hu || tty != hu->tty)\n\t\treturn;\n\n\tif (!test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\treturn;\n\n\tspin_lock(&hu->rx_lock);\n\thu->proto->recv(hu, (void *) data, count);\n\thu->hdev->stat.byte_rx += count;\n\tspin_unlock(&hu->rx_lock);\n\n\ttty_unthrottle(tty);\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* Reset device */\n", "func_signal": "static int hci_uart_flush(struct hci_dev *hdev)", "code": "{\n\tstruct hci_uart *hu  = (struct hci_uart *) hdev->driver_data;\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t/* Flush any pending characters in the driver and discipline. */\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\treturn 0;\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* Send frames from HCI layer */\n", "func_signal": "static int hci_uart_send_frame(struct sk_buff *skb)", "code": "{\n\tstruct hci_dev* hdev = (struct hci_dev *) skb->dev;\n\tstruct hci_uart *hu;\n\n\tif (!hdev) {\n\t\tBT_ERR(\"Frame for unknown device (hdev=NULL)\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn -EBUSY;\n\n\thu = (struct hci_uart *) hdev->driver_data;\n\n\tBT_DBG(\"%s: type %d len %d\", hdev->name, bt_cb(skb)->pkt_type, skb->len);\n\n\thu->proto->enqueue(hu, skb);\n\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* This syscall gets its arguments in A0 (mem), D2 (oldval) and\n   D1 (newval).  */\n", "func_signal": "asmlinkage int\nsys_atomic_cmpxchg_32(unsigned long newval, int oldval, int d3, int d4, int d5,\n\t\t      unsigned long __user * mem)", "code": "{\n\t/* This was borrowed from ARM's implementation.  */\n\tfor (;;) {\n\t\tstruct mm_struct *mm = current->mm;\n\t\tpgd_t *pgd;\n\t\tpmd_t *pmd;\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl;\n\t\tunsigned long mem_value;\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tpgd = pgd_offset(mm, (unsigned long)mem);\n\t\tif (!pgd_present(*pgd))\n\t\t\tgoto bad_access;\n\t\tpmd = pmd_offset(pgd, (unsigned long)mem);\n\t\tif (!pmd_present(*pmd))\n\t\t\tgoto bad_access;\n\t\tpte = pte_offset_map_lock(mm, pmd, (unsigned long)mem, &ptl);\n\t\tif (!pte_present(*pte) || !pte_dirty(*pte)\n\t\t    || !pte_write(*pte)) {\n\t\t\tpte_unmap_unlock(pte, ptl);\n\t\t\tgoto bad_access;\n\t\t}\n\n\t\tmem_value = *mem;\n\t\tif (mem_value == oldval)\n\t\t\t*mem = newval;\n\n\t\tpte_unmap_unlock(pte, ptl);\n\t\tup_read(&mm->mmap_sem);\n\t\treturn mem_value;\n\n\t      bad_access:\n\t\tup_read(&mm->mmap_sem);\n\t\t/* This is not necessarily a bad access, we can get here if\n\t\t   a memory we're trying to write to should be copied-on-write.\n\t\t   Make the kernel do the necessary page stuff, then re-iterate.\n\t\t   Simulate a write access fault to do that.  */\n\t\t{\n\t\t\t/* The first argument of the function corresponds to\n\t\t\t   D1, which is the first field of struct pt_regs.  */\n\t\t\tstruct pt_regs *fp = (struct pt_regs *)&newval;\n\n\t\t\t/* '3' is an RMW flag.  */\n\t\t\tif (do_page_fault(fp, (unsigned long)mem, 3))\n\t\t\t\t/* If the do_page_fault() failed, we don't\n\t\t\t\t   have anything meaningful to return.\n\t\t\t\t   There should be a SIGSEGV pending for\n\t\t\t\t   the process.  */\n\t\t\t\treturn 0xdeadbeef;\n\t\t}\n\t}\n}", "path": "arch\\m68k\\kernel\\sys_m68k.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/**\n * snd_dma_alloc_pages_fallback - allocate the buffer area according to the given type with fallback\n * @type: the DMA buffer type\n * @device: the device pointer\n * @size: the buffer size to allocate\n * @dmab: buffer allocation record to store the allocated data\n *\n * Calls the memory-allocator function for the corresponding\n * buffer type.  When no space is left, this function reduces the size and\n * tries to allocate again.  The size actually allocated is stored in\n * res_size argument.\n * \n * Returns zero if the buffer with the given size is allocated successfuly,\n * other a negative value at error.\n */\n", "func_signal": "int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,\n\t\t\t\t struct snd_dma_buffer *dmab)", "code": "{\n\tint err;\n\n\twhile ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {\n\t\tsize_t aligned_size;\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tif (size <= PAGE_SIZE)\n\t\t\treturn -ENOMEM;\n\t\taligned_size = PAGE_SIZE << get_order(size);\n\t\tif (size != aligned_size)\n\t\t\tsize = aligned_size;\n\t\telse\n\t\t\tsize >>= 1;\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* sys_cacheflush -- flush (part of) the processor cache.  */\n", "func_signal": "asmlinkage int\nsys_cacheflush (unsigned long addr, int scope, int cache, unsigned long len)", "code": "{\n\tstruct vm_area_struct *vma;\n\tint ret = -EINVAL;\n\n\tlock_kernel();\n\tif (scope < FLUSH_SCOPE_LINE || scope > FLUSH_SCOPE_ALL ||\n\t    cache & ~FLUSH_CACHE_BOTH)\n\t\tgoto out;\n\n\tif (scope == FLUSH_SCOPE_ALL) {\n\t\t/* Only the superuser may explicitly flush the whole cache. */\n\t\tret = -EPERM;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t * Verify that the specified address region actually belongs\n\t\t * to this process.\n\t\t */\n\t\tvma = find_vma (current->mm, addr);\n\t\tret = -EINVAL;\n\t\t/* Check for overflow.  */\n\t\tif (addr + len < addr)\n\t\t\tgoto out;\n\t\tif (vma == NULL || addr < vma->vm_start || addr + len > vma->vm_end)\n\t\t\tgoto out;\n\t}\n\n\tif (CPU_IS_020_OR_030) {\n\t\tif (scope == FLUSH_SCOPE_LINE && len < 256) {\n\t\t\tunsigned long cacr;\n\t\t\t__asm__ (\"movec %%cacr, %0\" : \"=r\" (cacr));\n\t\t\tif (cache & FLUSH_CACHE_INSN)\n\t\t\t\tcacr |= 4;\n\t\t\tif (cache & FLUSH_CACHE_DATA)\n\t\t\t\tcacr |= 0x400;\n\t\t\tlen >>= 2;\n\t\t\twhile (len--) {\n\t\t\t\t__asm__ __volatile__ (\"movec %1, %%caar\\n\\t\"\n\t\t\t\t\t\t      \"movec %0, %%cacr\"\n\t\t\t\t\t\t      : /* no outputs */\n\t\t\t\t\t\t      : \"r\" (cacr), \"r\" (addr));\n\t\t\t\taddr += 4;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Flush the whole cache, even if page granularity requested. */\n\t\t\tunsigned long cacr;\n\t\t\t__asm__ (\"movec %%cacr, %0\" : \"=r\" (cacr));\n\t\t\tif (cache & FLUSH_CACHE_INSN)\n\t\t\t\tcacr |= 8;\n\t\t\tif (cache & FLUSH_CACHE_DATA)\n\t\t\t\tcacr |= 0x800;\n\t\t\t__asm__ __volatile__ (\"movec %0, %%cacr\" : : \"r\" (cacr));\n\t\t}\n\t\tret = 0;\n\t\tgoto out;\n\t} else {\n\t    /*\n\t     * 040 or 060: don't blindly trust 'scope', someone could\n\t     * try to flush a few megs of memory.\n\t     */\n\n\t    if (len>=3*PAGE_SIZE && scope<FLUSH_SCOPE_PAGE)\n\t        scope=FLUSH_SCOPE_PAGE;\n\t    if (len>=10*PAGE_SIZE && scope<FLUSH_SCOPE_ALL)\n\t        scope=FLUSH_SCOPE_ALL;\n\t    if (CPU_IS_040) {\n\t\tret = cache_flush_040 (addr, scope, cache, len);\n\t    } else if (CPU_IS_060) {\n\t\tret = cache_flush_060 (addr, scope, cache, len);\n\t    }\n\t}\nout:\n\tunlock_kernel();\n\treturn ret;\n}", "path": "arch\\m68k\\kernel\\sys_m68k.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* hci_uart_tty_ioctl()\n *\n *    Process IOCTL system call for the tty device.\n *\n * Arguments:\n *\n *    tty        pointer to tty instance data\n *    file       pointer to open file object for device\n *    cmd        IOCTL command code\n *    arg        argument for IOCTL call (cmd dependent)\n *\n * Return Value:    Command dependent\n */\n", "func_signal": "static int hci_uart_tty_ioctl(struct tty_struct *tty, struct file * file,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)", "code": "{\n\tstruct hci_uart *hu = (void *)tty->disc_data;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\t/* Verify the status of the device */\n\tif (!hu)\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase HCIUARTSETPROTO:\n\t\tif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\n\t\t\terr = hci_uart_set_proto(hu, arg);\n\t\t\tif (err) {\n\t\t\t\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else\n\t\t\treturn -EBUSY;\n\t\tbreak;\n\n\tcase HCIUARTGETPROTO:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\treturn hu->proto->id;\n\t\treturn -EUNATCH;\n\n\tcase HCIUARTGETDEVICE:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\treturn hu->hdev->id;\n\t\treturn -EUNATCH;\n\n\tcase HCIUARTSETFLAGS:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\treturn -EBUSY;\n\t\thu->hdev_flags = arg;\n\t\tbreak;\n\n\tcase HCIUARTGETFLAGS:\n\t\treturn hu->hdev_flags;\n\n\tdefault:\n\t\terr = n_tty_ioctl_helper(tty, file, cmd, arg);\n\t\tbreak;\n\t};\n\n\treturn err;\n}", "path": "drivers\\bluetooth\\hci_ldisc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/**\n * snd_dma_get_reserved - get the reserved buffer for the given device\n * @dmab: the buffer allocation record to store\n * @id: the buffer id\n *\n * Looks for the reserved-buffer list and re-uses if the same buffer\n * is found in the list.  When the buffer is found, it's removed from the free list.\n *\n * Returns the size of buffer if the buffer is found, or zero if not found.\n */\n", "func_signal": "size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)", "code": "{\n\tstruct snd_mem_list *mem;\n\n\tif (WARN_ON(!dmab))\n\t\treturn 0;\n\n\tmutex_lock(&list_mutex);\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tif (mem->id == id &&\n\t\t    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||\n\t\t     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {\n\t\t\tstruct device *dev = dmab->dev.dev;\n\t\t\tlist_del(&mem->list);\n\t\t\t*dmab = mem->buffer;\n\t\t\tif (dmab->dev.dev == NULL)\n\t\t\t\tdmab->dev.dev = dev;\n\t\t\tkfree(mem);\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn dmab->bytes;\n\t\t}\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* allocate the coherent DMA pages */\n", "func_signal": "static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)", "code": "{\n\tint pg;\n\tvoid *res;\n\tgfp_t gfp_flags;\n\n\tif (WARN_ON(!dma))\n\t\treturn NULL;\n\tpg = get_order(size);\n\tgfp_flags = GFP_KERNEL\n\t\t| __GFP_COMP\t/* compound page lets parts be mapped */\n\t\t| __GFP_NORETRY /* don't trigger OOM-killer */\n\t\t| __GFP_NOWARN; /* no stack trace print - this call is non-critical */\n\tres = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);\n\tif (res != NULL)\n\t\tinc_snd_pages(pg);\n\n\treturn res;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/* free the coherent DMA pages */\n", "func_signal": "static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,\n\t\t\t       dma_addr_t dma)", "code": "{\n\tint pg;\n\n\tif (ptr == NULL)\n\t\treturn;\n\tpg = get_order(size);\n\tdec_snd_pages(pg);\n\tdma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/**\n * snd_dma_reserve_buf - reserve the buffer\n * @dmab: the buffer to reserve\n * @id: the buffer id\n *\n * Reserves the given buffer as a reserved buffer.\n * \n * Returns zero if successful, or a negative code at error.\n */\n", "func_signal": "int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)", "code": "{\n\tstruct snd_mem_list *mem;\n\n\tif (WARN_ON(!dmab))\n\t\treturn -EINVAL;\n\tmem = kmalloc(sizeof(*mem), GFP_KERNEL);\n\tif (! mem)\n\t\treturn -ENOMEM;\n\tmutex_lock(&list_mutex);\n\tmem->buffer = *dmab;\n\tmem->id = id;\n\tlist_add_tail(&mem->list, &mem_list_head);\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/**\n * snd_free_pages - release the pages\n * @ptr: the buffer pointer to release\n * @size: the allocated buffer size\n *\n * Releases the buffer allocated via snd_malloc_pages().\n */\n", "func_signal": "void snd_free_pages(void *ptr, size_t size)", "code": "{\n\tint pg;\n\n\tif (ptr == NULL)\n\t\treturn;\n\tpg = get_order(size);\n\tdec_snd_pages(pg);\n\tfree_pages((unsigned long) ptr, pg);\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/**\n * snd_malloc_pages - allocate pages with the given size\n * @size: the size to allocate in bytes\n * @gfp_flags: the allocation conditions, GFP_XXX\n *\n * Allocates the physically contiguous pages with the given size.\n *\n * Returns the pointer of the buffer, or NULL if no enoguh memory.\n */\n", "func_signal": "void *snd_malloc_pages(size_t size, gfp_t gfp_flags)", "code": "{\n\tint pg;\n\tvoid *res;\n\n\tif (WARN_ON(!size))\n\t\treturn NULL;\n\tif (WARN_ON(!gfp_flags))\n\t\treturn NULL;\n\tgfp_flags |= __GFP_COMP;\t/* compound page lets parts be mapped */\n\tpg = get_order(size);\n\tif ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL)\n\t\tinc_snd_pages(pg);\n\treturn res;\n}", "path": "sound\\core\\memalloc.c", "repo_name": "pershoot/galaxy-2636", "stars": 18, "license": "other", "language": "c", "size": 119384}
{"docstring": "/*\n * NAME:\tI_sample()\n * DESCRIPTION:\tdecode one requantized Layer I sample from a bitstream\n */\n", "func_signal": "static\nmad_fixed_t I_sample(struct mad_bitptr *ptr, unsigned int nb)", "code": "{\n  mad_fixed_t sample;\n\n  sample = mad_bit_read(ptr, nb);\n\n  /* invert most significant bit, extend sign, then scale to fixed format */\n\n  sample ^= 1 << (nb - 1);\n  sample |= -(sample & (1 << (nb - 1)));\n\n  sample <<= MAD_F_FRACBITS - (nb - 1);\n\n  /* requantize the sample */\n\n  /* s'' = (2^nb / (2^nb - 1)) * (s''' + 2^(-nb + 1)) */\n\n  sample += MAD_F_ONE >> (nb - 1);\n\n  return mad_f_mul(sample, linear_table[nb - 2]);\n\n  /* s' = factor * s'' */\n  /* (to be performed by caller) */\n}", "path": "layer12.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tframe->init()\n * DESCRIPTION:\tinitialize frame struct\n */\n", "func_signal": "void mad_frame_init(struct mad_frame *frame)", "code": "{\n  mad_header_init(&frame->header);\n\n  frame->options = 0;\n\n  frame->overlap = 0;\n  mad_frame_mute(frame);\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tdecode_header()\n * DESCRIPTION:\tread header data and following CRC word\n */\n", "func_signal": "static\nint decode_header(struct mad_header *header, struct mad_stream *stream)", "code": "{\n  unsigned int index;\n\n  header->flags        = 0;\n  header->private_bits = 0;\n\n  /* header() */\n\n  /* syncword */\n  mad_bit_skip(&stream->ptr, 11);\n\n  /* MPEG 2.5 indicator (really part of syncword) */\n  if (mad_bit_read(&stream->ptr, 1) == 0)\n    header->flags |= MAD_FLAG_MPEG_2_5_EXT;\n\n  /* ID */\n  if (mad_bit_read(&stream->ptr, 1) == 0)\n    header->flags |= MAD_FLAG_LSF_EXT;\n  else if (header->flags & MAD_FLAG_MPEG_2_5_EXT) {\n    stream->error = MAD_ERROR_LOSTSYNC;\n    return -1;\n  }\n\n  /* layer */\n  header->layer = 4 - mad_bit_read(&stream->ptr, 2);\n\n  if (header->layer == 4) {\n    stream->error = MAD_ERROR_BADLAYER;\n    return -1;\n  }\n\n  /* protection_bit */\n  if (mad_bit_read(&stream->ptr, 1) == 0) {\n    header->flags    |= MAD_FLAG_PROTECTION;\n    header->crc_check = mad_bit_crc(stream->ptr, 16, 0xffff);\n  }\n\n  /* bitrate_index */\n  index = mad_bit_read(&stream->ptr, 4);\n\n  if (index == 15) {\n    stream->error = MAD_ERROR_BADBITRATE;\n    return -1;\n  }\n\n  if (header->flags & MAD_FLAG_LSF_EXT)\n    header->bitrate = bitrate_table[3 + (header->layer >> 1)][index];\n  else\n    header->bitrate = bitrate_table[header->layer - 1][index];\n\n  /* sampling_frequency */\n  index = mad_bit_read(&stream->ptr, 2);\n\n  if (index == 3) {\n    stream->error = MAD_ERROR_BADSAMPLERATE;\n    return -1;\n  }\n\n  header->samplerate = samplerate_table[index];\n\n  if (header->flags & MAD_FLAG_LSF_EXT) {\n    header->samplerate /= 2;\n\n    if (header->flags & MAD_FLAG_MPEG_2_5_EXT)\n      header->samplerate /= 2;\n  }\n\n  /* padding_bit */\n  if (mad_bit_read(&stream->ptr, 1))\n    header->flags |= MAD_FLAG_PADDING;\n\n  /* private_bit */\n  if (mad_bit_read(&stream->ptr, 1))\n    header->private_bits |= MAD_PRIVATE_HEADER;\n\n  /* mode */\n  header->mode = 3 - mad_bit_read(&stream->ptr, 2);\n\n  /* mode_extension */\n  header->mode_extension = mad_bit_read(&stream->ptr, 2);\n\n  /* copyright */\n  if (mad_bit_read(&stream->ptr, 1))\n    header->flags |= MAD_FLAG_COPYRIGHT;\n\n  /* original/copy */\n  if (mad_bit_read(&stream->ptr, 1))\n    header->flags |= MAD_FLAG_ORIGINAL;\n\n  /* emphasis */\n  header->emphasis = mad_bit_read(&stream->ptr, 2);\n\n# if defined(OPT_STRICT)\n  /*\n   * ISO/IEC 11172-3 says this is a reserved emphasis value, but\n   * streams exist which use it anyway. Since the value is not important\n   * to the decoder proper, we allow it unless OPT_STRICT is defined.\n   */\n  if (header->emphasis == MAD_EMPHASIS_RESERVED) {\n    stream->error = MAD_ERROR_BADEMPHASIS;\n    return -1;\n  }\n# endif\n\n  /* error_check() */\n\n  /* crc_check */\n  if (header->flags & MAD_FLAG_PROTECTION)\n    header->crc_target = mad_bit_read(&stream->ptr, 16);\n\n  return 0;\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tfree_bitrate()\n * DESCRIPTION:\tattempt to discover the bitstream's free bitrate\n */\n", "func_signal": "static\nint free_bitrate(struct mad_stream *stream, struct mad_header const *header)", "code": "{\n  struct mad_bitptr keep_ptr;\n  unsigned long rate = 0;\n  unsigned int pad_slot, slots_per_frame;\n  unsigned char const *ptr = 0;\n\n  keep_ptr = stream->ptr;\n\n  pad_slot = (header->flags & MAD_FLAG_PADDING) ? 1 : 0;\n  slots_per_frame = (header->layer == MAD_LAYER_III &&\n\t\t     (header->flags & MAD_FLAG_LSF_EXT)) ? 72 : 144;\n\n  while (mad_stream_sync(stream) == 0) {\n    struct mad_stream peek_stream;\n    struct mad_header peek_header;\n\n    peek_stream = *stream;\n    peek_header = *header;\n\n    if (decode_header(&peek_header, &peek_stream) == 0 &&\n\tpeek_header.layer == header->layer &&\n\tpeek_header.samplerate == header->samplerate) {\n      unsigned int N;\n\n      ptr = mad_bit_nextbyte(&stream->ptr);\n\n      N = ptr - stream->this_frame;\n\n      if (header->layer == MAD_LAYER_I) {\n\trate = (unsigned long) header->samplerate *\n\t  (N - 4 * pad_slot + 4) / 48 / 1000;\n      }\n      else {\n\trate = (unsigned long) header->samplerate *\n\t  (N - pad_slot + 1) / slots_per_frame / 1000;\n      }\n\n      if (rate >= 8)\n\tbreak;\n    }\n\n    mad_bit_skip(&stream->ptr, 8);\n  }\n\n  stream->ptr = keep_ptr;\n\n  if (rate < 8 || (header->layer == MAD_LAYER_III && rate > 640)) {\n    stream->error = MAD_ERROR_LOSTSYNC;\n    return -1;\n  }\n\n  stream->freerate = rate * 1000;\n\n  return 0;\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->multiply()\n * DESCRIPTION:\tmultiply a timer by a scalar value\n */\n", "func_signal": "void mad_timer_multiply(mad_timer_t *timer, signed long scalar)", "code": "{\n  mad_timer_t addend;\n  unsigned long factor;\n\n  factor = scalar;\n  if (scalar < 0) {\n    factor = -scalar;\n    mad_timer_negate(timer);\n  }\n\n  addend = *timer;\n  *timer = mad_timer_zero;\n\n  while (factor) {\n    if (factor & 1)\n      mad_timer_add(timer, addend);\n\n    mad_timer_add(&addend, addend);\n    factor >>= 1;\n  }\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tframe->finish()\n * DESCRIPTION:\tdeallocate any dynamic memory associated with frame\n */\n", "func_signal": "void mad_frame_finish(struct mad_frame *frame)", "code": "{\n  mad_header_finish(&frame->header);\n\n  if (frame->overlap) {\n    free(frame->overlap);\n    frame->overlap = 0;\n  }\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->count()\n * DESCRIPTION:\treturn timer value in selected units\n */\n", "func_signal": "signed long mad_timer_count(mad_timer_t timer, enum mad_units units)", "code": "{\n  switch (units) {\n  case MAD_UNITS_HOURS:\n    return timer.seconds / 60 / 60;\n\n  case MAD_UNITS_MINUTES:\n    return timer.seconds / 60;\n\n  case MAD_UNITS_SECONDS:\n    return timer.seconds;\n\n  case MAD_UNITS_DECISECONDS:\n  case MAD_UNITS_CENTISECONDS:\n  case MAD_UNITS_MILLISECONDS:\n\n  case MAD_UNITS_8000_HZ:\n  case MAD_UNITS_11025_HZ:\n  case MAD_UNITS_12000_HZ:\n  case MAD_UNITS_16000_HZ:\n  case MAD_UNITS_22050_HZ:\n  case MAD_UNITS_24000_HZ:\n  case MAD_UNITS_32000_HZ:\n  case MAD_UNITS_44100_HZ:\n  case MAD_UNITS_48000_HZ:\n\n  case MAD_UNITS_24_FPS:\n  case MAD_UNITS_25_FPS:\n  case MAD_UNITS_30_FPS:\n  case MAD_UNITS_48_FPS:\n  case MAD_UNITS_50_FPS:\n  case MAD_UNITS_60_FPS:\n  case MAD_UNITS_75_FPS:\n    return timer.seconds * (signed long) units +\n      (signed long) scale_rational(timer.fraction, MAD_TIMER_RESOLUTION,\n\t\t\t\t   units);\n\n  case MAD_UNITS_23_976_FPS:\n  case MAD_UNITS_24_975_FPS:\n  case MAD_UNITS_29_97_FPS:\n  case MAD_UNITS_47_952_FPS:\n  case MAD_UNITS_49_95_FPS:\n  case MAD_UNITS_59_94_FPS:\n    return (mad_timer_count(timer, -units) + 1) * 1000 / 1001;\n  }\n\n  /* unsupported units */\n  return 0;\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tlayer->I()\n * DESCRIPTION:\tdecode a single Layer I frame\n */\n", "func_signal": "int mad_layer_I(struct mad_stream *stream, struct mad_frame *frame)", "code": "{\n  struct mad_header *header = &frame->header;\n  unsigned int nch, bound, ch, s, sb, nb;\n  unsigned char allocation[2][32], scalefactor[2][32];\n\n  nch = MAD_NCHANNELS(header);\n\n  bound = 32;\n  if (header->mode == MAD_MODE_JOINT_STEREO) {\n    header->flags |= MAD_FLAG_I_STEREO;\n    bound = 4 + header->mode_extension * 4;\n  }\n\n  /* check CRC word */\n\n  if (header->flags & MAD_FLAG_PROTECTION) {\n    header->crc_check =\n      mad_bit_crc(stream->ptr, 4 * (bound * nch + (32 - bound)),\n\t\t  header->crc_check);\n\n    if (header->crc_check != header->crc_target &&\n\t!(frame->options & MAD_OPTION_IGNORECRC)) {\n      stream->error = MAD_ERROR_BADCRC;\n      return -1;\n    }\n  }\n\n  /* decode bit allocations */\n\n  for (sb = 0; sb < bound; ++sb) {\n    for (ch = 0; ch < nch; ++ch) {\n      nb = mad_bit_read(&stream->ptr, 4);\n\n      if (nb == 15) {\n\tstream->error = MAD_ERROR_BADBITALLOC;\n\treturn -1;\n      }\n\n      allocation[ch][sb] = nb ? nb + 1 : 0;\n    }\n  }\n\n  for (sb = bound; sb < 32; ++sb) {\n    nb = mad_bit_read(&stream->ptr, 4);\n\n    if (nb == 15) {\n      stream->error = MAD_ERROR_BADBITALLOC;\n      return -1;\n    }\n\n    allocation[0][sb] =\n    allocation[1][sb] = nb ? nb + 1 : 0;\n  }\n\n  /* decode scalefactors */\n\n  for (sb = 0; sb < 32; ++sb) {\n    for (ch = 0; ch < nch; ++ch) {\n      if (allocation[ch][sb]) {\n\tscalefactor[ch][sb] = mad_bit_read(&stream->ptr, 6);\n\n# if defined(OPT_STRICT)\n\t/*\n\t * Scalefactor index 63 does not appear in Table B.1 of\n\t * ISO/IEC 11172-3. Nonetheless, other implementations accept it,\n\t * so we only reject it if OPT_STRICT is defined.\n\t */\n\tif (scalefactor[ch][sb] == 63) {\n\t  stream->error = MAD_ERROR_BADSCALEFACTOR;\n\t  return -1;\n\t}\n# endif\n      }\n    }\n  }\n\n  /* decode samples */\n\n  for (s = 0; s < 12; ++s) {\n    for (sb = 0; sb < bound; ++sb) {\n      for (ch = 0; ch < nch; ++ch) {\n\tnb = allocation[ch][sb];\n\tframe->sbsample[ch][s][sb] = nb ?\n\t  mad_f_mul(I_sample(&stream->ptr, nb),\n\t\t    sf_table[scalefactor[ch][sb]]) : 0;\n      }\n    }\n\n    for (sb = bound; sb < 32; ++sb) {\n      if ((nb = allocation[0][sb])) {\n\tmad_fixed_t sample;\n\n\tsample = I_sample(&stream->ptr, nb);\n\n\tfor (ch = 0; ch < nch; ++ch) {\n\t  frame->sbsample[ch][s][sb] =\n\t    mad_f_mul(sample, sf_table[scalefactor[ch][sb]]);\n\t}\n      }\n      else {\n\tfor (ch = 0; ch < nch; ++ch)\n\t  frame->sbsample[ch][s][sb] = 0;\n      }\n    }\n  }\n\n  return 0;\n}", "path": "layer12.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\treduce_rational()\n * DESCRIPTION:\tconvert rational expression to lowest terms\n */\n", "func_signal": "static\nvoid reduce_rational(unsigned long *numer, unsigned long *denom)", "code": "{\n  unsigned long factor;\n\n  factor = gcd(*numer, *denom);\n\n  assert(factor != 0);\n\n  *numer /= factor;\n  *denom /= factor;\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tgcd()\n * DESCRIPTION:\tcompute greatest common denominator\n */\n", "func_signal": "static\nunsigned long gcd(unsigned long num1, unsigned long num2)", "code": "{\n  unsigned long tmp;\n\n  while (num2) {\n    tmp  = num2;\n    num2 = num1 % num2;\n    num1 = tmp;\n  }\n\n  return num1;\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tlayer->II()\n * DESCRIPTION:\tdecode a single Layer II frame\n */\n", "func_signal": "int mad_layer_II(struct mad_stream *stream, struct mad_frame *frame)", "code": "{\n  struct mad_header *header = &frame->header;\n  struct mad_bitptr start;\n  unsigned int index, sblimit, nbal, nch, bound, gr, ch, s, sb;\n  unsigned char const *offsets;\n  unsigned char allocation[2][32], scfsi[2][32], scalefactor[2][32][3];\n  mad_fixed_t samples[3];\n\n  nch = MAD_NCHANNELS(header);\n\n  if (header->flags & MAD_FLAG_LSF_EXT)\n    index = 4;\n  else if (header->flags & MAD_FLAG_FREEFORMAT)\n    goto freeformat;\n  else {\n    unsigned long bitrate_per_channel;\n\n    bitrate_per_channel = header->bitrate;\n    if (nch == 2) {\n      bitrate_per_channel /= 2;\n\n# if defined(OPT_STRICT)\n      /*\n       * ISO/IEC 11172-3 allows only single channel mode for 32, 48, 56, and\n       * 80 kbps bitrates in Layer II, but some encoders ignore this\n       * restriction. We enforce it if OPT_STRICT is defined.\n       */\n      if (bitrate_per_channel <= 28000 || bitrate_per_channel == 40000) {\n\tstream->error = MAD_ERROR_BADMODE;\n\treturn -1;\n      }\n# endif\n    }\n    else {  /* nch == 1 */\n      if (bitrate_per_channel > 192000) {\n\t/*\n\t * ISO/IEC 11172-3 does not allow single channel mode for 224, 256,\n\t * 320, or 384 kbps bitrates in Layer II.\n\t */\n\tstream->error = MAD_ERROR_BADMODE;\n\treturn -1;\n      }\n    }\n\n    if (bitrate_per_channel <= 48000)\n      index = (header->samplerate == 32000) ? 3 : 2;\n    else if (bitrate_per_channel <= 80000)\n      index = 0;\n    else {\n    freeformat:\n      index = (header->samplerate == 48000) ? 0 : 1;\n    }\n  }\n\n  sblimit = sbquant_table[index].sblimit;\n  offsets = sbquant_table[index].offsets;\n\n  bound = 32;\n  if (header->mode == MAD_MODE_JOINT_STEREO) {\n    header->flags |= MAD_FLAG_I_STEREO;\n    bound = 4 + header->mode_extension * 4;\n  }\n\n  if (bound > sblimit)\n    bound = sblimit;\n\n  start = stream->ptr;\n\n  /* decode bit allocations */\n\n  for (sb = 0; sb < bound; ++sb) {\n    nbal = bitalloc_table[offsets[sb]].nbal;\n\n    for (ch = 0; ch < nch; ++ch)\n      allocation[ch][sb] = mad_bit_read(&stream->ptr, nbal);\n  }\n\n  for (sb = bound; sb < sblimit; ++sb) {\n    nbal = bitalloc_table[offsets[sb]].nbal;\n\n    allocation[0][sb] =\n    allocation[1][sb] = mad_bit_read(&stream->ptr, nbal);\n  }\n\n  /* decode scalefactor selection info */\n\n  for (sb = 0; sb < sblimit; ++sb) {\n    for (ch = 0; ch < nch; ++ch) {\n      if (allocation[ch][sb])\n\tscfsi[ch][sb] = mad_bit_read(&stream->ptr, 2);\n    }\n  }\n\n  /* check CRC word */\n\n  if (header->flags & MAD_FLAG_PROTECTION) {\n    header->crc_check =\n      mad_bit_crc(start, mad_bit_length(&start, &stream->ptr),\n\t\t  header->crc_check);\n\n    if (header->crc_check != header->crc_target &&\n\t!(frame->options & MAD_OPTION_IGNORECRC)) {\n      stream->error = MAD_ERROR_BADCRC;\n      return -1;\n    }\n  }\n\n  /* decode scalefactors */\n\n  for (sb = 0; sb < sblimit; ++sb) {\n    for (ch = 0; ch < nch; ++ch) {\n      if (allocation[ch][sb]) {\n\tscalefactor[ch][sb][0] = mad_bit_read(&stream->ptr, 6);\n\n\tswitch (scfsi[ch][sb]) {\n\tcase 2:\n\t  scalefactor[ch][sb][2] =\n\t  scalefactor[ch][sb][1] =\n\t  scalefactor[ch][sb][0];\n\t  break;\n\n\tcase 0:\n\t  scalefactor[ch][sb][1] = mad_bit_read(&stream->ptr, 6);\n\t  /* fall through */\n\n\tcase 1:\n\tcase 3:\n\t  scalefactor[ch][sb][2] = mad_bit_read(&stream->ptr, 6);\n\t}\n\n\tif (scfsi[ch][sb] & 1)\n\t  scalefactor[ch][sb][1] = scalefactor[ch][sb][scfsi[ch][sb] - 1];\n\n# if defined(OPT_STRICT)\n\t/*\n\t * Scalefactor index 63 does not appear in Table B.1 of\n\t * ISO/IEC 11172-3. Nonetheless, other implementations accept it,\n\t * so we only reject it if OPT_STRICT is defined.\n\t */\n\tif (scalefactor[ch][sb][0] == 63 ||\n\t    scalefactor[ch][sb][1] == 63 ||\n\t    scalefactor[ch][sb][2] == 63) {\n\t  stream->error = MAD_ERROR_BADSCALEFACTOR;\n\t  return -1;\n\t}\n# endif\n      }\n    }\n  }\n\n  /* decode samples */\n\n  for (gr = 0; gr < 12; ++gr) {\n    for (sb = 0; sb < bound; ++sb) {\n      for (ch = 0; ch < nch; ++ch) {\n\tif ((index = allocation[ch][sb])) {\n\t  index = offset_table[bitalloc_table[offsets[sb]].offset][index - 1];\n\n\t  II_samples(&stream->ptr, &qc_table[index], samples);\n\n\t  for (s = 0; s < 3; ++s) {\n\t    frame->sbsample[ch][3 * gr + s][sb] =\n\t      mad_f_mul(samples[s], sf_table[scalefactor[ch][sb][gr / 4]]);\n\t  }\n\t}\n\telse {\n\t  for (s = 0; s < 3; ++s)\n\t    frame->sbsample[ch][3 * gr + s][sb] = 0;\n\t}\n      }\n    }\n\n    for (sb = bound; sb < sblimit; ++sb) {\n      if ((index = allocation[0][sb])) {\n\tindex = offset_table[bitalloc_table[offsets[sb]].offset][index - 1];\n\n\tII_samples(&stream->ptr, &qc_table[index], samples);\n\n\tfor (ch = 0; ch < nch; ++ch) {\n\t  for (s = 0; s < 3; ++s) {\n\t    frame->sbsample[ch][3 * gr + s][sb] =\n\t      mad_f_mul(samples[s], sf_table[scalefactor[ch][sb][gr / 4]]);\n\t  }\n\t}\n      }\n      else {\n\tfor (ch = 0; ch < nch; ++ch) {\n\t  for (s = 0; s < 3; ++s)\n\t    frame->sbsample[ch][3 * gr + s][sb] = 0;\n\t}\n      }\n    }\n\n    for (ch = 0; ch < nch; ++ch) {\n      for (s = 0; s < 3; ++s) {\n\tfor (sb = sblimit; sb < 32; ++sb)\n\t  frame->sbsample[ch][3 * gr + s][sb] = 0;\n      }\n    }\n  }\n\n  return 0;\n}", "path": "layer12.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->string()\n * DESCRIPTION:\twrite a string representation of a timer using a template\n */\n", "func_signal": "void mad_timer_string(mad_timer_t timer,\n\t\t      char *dest, char const *format, enum mad_units units,\n\t\t      enum mad_units fracunits, unsigned long subparts)", "code": "{\n  unsigned long hours, minutes, seconds, sub;\n  unsigned int frac;\n\n  timer = mad_timer_abs(timer);\n\n  seconds = timer.seconds;\n  frac = sub = 0;\n\n  switch (fracunits) {\n  case MAD_UNITS_HOURS:\n  case MAD_UNITS_MINUTES:\n  case MAD_UNITS_SECONDS:\n    break;\n\n  case MAD_UNITS_DECISECONDS:\n  case MAD_UNITS_CENTISECONDS:\n  case MAD_UNITS_MILLISECONDS:\n\n  case MAD_UNITS_8000_HZ:\n  case MAD_UNITS_11025_HZ:\n  case MAD_UNITS_12000_HZ:\n  case MAD_UNITS_16000_HZ:\n  case MAD_UNITS_22050_HZ:\n  case MAD_UNITS_24000_HZ:\n  case MAD_UNITS_32000_HZ:\n  case MAD_UNITS_44100_HZ:\n  case MAD_UNITS_48000_HZ:\n\n  case MAD_UNITS_24_FPS:\n  case MAD_UNITS_25_FPS:\n  case MAD_UNITS_30_FPS:\n  case MAD_UNITS_48_FPS:\n  case MAD_UNITS_50_FPS:\n  case MAD_UNITS_60_FPS:\n  case MAD_UNITS_75_FPS:\n    {\n      unsigned long denom;\n\n      denom = MAD_TIMER_RESOLUTION / fracunits;\n\n      frac = timer.fraction / denom;\n      sub  = scale_rational(timer.fraction % denom, denom, subparts);\n    }\n    break;\n\n  case MAD_UNITS_23_976_FPS:\n  case MAD_UNITS_24_975_FPS:\n  case MAD_UNITS_29_97_FPS:\n  case MAD_UNITS_47_952_FPS:\n  case MAD_UNITS_49_95_FPS:\n  case MAD_UNITS_59_94_FPS:\n    /* drop-frame encoding */\n    /* N.B. this is only well-defined for MAD_UNITS_29_97_FPS */\n    {\n      unsigned long frame, cycle, d, m;\n\n      frame = mad_timer_count(timer, fracunits);\n\n      cycle = -fracunits * 60 * 10 - (10 - 1) * 2;\n\n      d = frame / cycle;\n      m = frame % cycle;\n      frame += (10 - 1) * 2 * d;\n      if (m > 2)\n\tframe += 2 * ((m - 2) / (cycle / 10));\n\n      frac    = frame % -fracunits;\n      seconds = frame / -fracunits;\n    }\n    break;\n  }\n\n  switch (units) {\n  case MAD_UNITS_HOURS:\n    minutes = seconds / 60;\n    hours   = minutes / 60;\n\n    sprintf(dest, format,\n\t    hours,\n\t    (unsigned int) (minutes % 60),\n\t    (unsigned int) (seconds % 60),\n\t    frac, sub);\n    break;\n\n  case MAD_UNITS_MINUTES:\n    minutes = seconds / 60;\n\n    sprintf(dest, format,\n\t    minutes,\n\t    (unsigned int) (seconds % 60),\n\t    frac, sub);\n    break;\n\n  case MAD_UNITS_SECONDS:\n    sprintf(dest, format,\n\t    seconds,\n\t    frac, sub);\n    break;\n\n  case MAD_UNITS_23_976_FPS:\n  case MAD_UNITS_24_975_FPS:\n  case MAD_UNITS_29_97_FPS:\n  case MAD_UNITS_47_952_FPS:\n  case MAD_UNITS_49_95_FPS:\n  case MAD_UNITS_59_94_FPS:\n    if (fracunits < 0) {\n      /* not yet implemented */\n      sub = 0;\n    }\n\n    /* fall through */\n\n  case MAD_UNITS_DECISECONDS:\n  case MAD_UNITS_CENTISECONDS:\n  case MAD_UNITS_MILLISECONDS:\n\n  case MAD_UNITS_8000_HZ:\n  case MAD_UNITS_11025_HZ:\n  case MAD_UNITS_12000_HZ:\n  case MAD_UNITS_16000_HZ:\n  case MAD_UNITS_22050_HZ:\n  case MAD_UNITS_24000_HZ:\n  case MAD_UNITS_32000_HZ:\n  case MAD_UNITS_44100_HZ:\n  case MAD_UNITS_48000_HZ:\n\n  case MAD_UNITS_24_FPS:\n  case MAD_UNITS_25_FPS:\n  case MAD_UNITS_30_FPS:\n  case MAD_UNITS_48_FPS:\n  case MAD_UNITS_50_FPS:\n  case MAD_UNITS_60_FPS:\n  case MAD_UNITS_75_FPS:\n    sprintf(dest, format, mad_timer_count(timer, units), sub);\n    break;\n  }\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tframe->mute()\n * DESCRIPTION:\tzero all subband values so the frame becomes silent\n */\n", "func_signal": "void mad_frame_mute(struct mad_frame *frame)", "code": "{\n  unsigned int s, sb;\n\n  for (s = 0; s < 36; ++s) {\n    for (sb = 0; sb < 32; ++sb) {\n      frame->sbsample[0][s][sb] =\n      frame->sbsample[1][s][sb] = 0;\n    }\n  }\n\n  if (frame->overlap) {\n    for (s = 0; s < 18; ++s) {\n      for (sb = 0; sb < 32; ++sb) {\n\t(*frame->overlap)[0][sb][s] =\n\t(*frame->overlap)[1][sb][s] = 0;\n      }\n    }\n  }\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tframe->decode()\n * DESCRIPTION:\tdecode a single frame from a bitstream\n */\n", "func_signal": "int mad_frame_decode(struct mad_frame *frame, struct mad_stream *stream)", "code": "{\n  frame->options = stream->options;\n\n  /* header() */\n  /* error_check() */\n\n  if (!(frame->header.flags & MAD_FLAG_INCOMPLETE) &&\n      mad_header_decode(&frame->header, stream) == -1)\n    goto fail;\n\n  /* audio_data() */\n\n  frame->header.flags &= ~MAD_FLAG_INCOMPLETE;\n\n  if (decoder_table[frame->header.layer - 1](stream, frame) == -1) {\n    if (!MAD_RECOVERABLE(stream->error))\n      stream->next_frame = stream->this_frame;\n\n    goto fail;\n  }\n\n  /* ancillary_data() */\n\n  if (frame->header.layer != MAD_LAYER_III) {\n    struct mad_bitptr next_frame;\n\n    mad_bit_init(&next_frame, stream->next_frame);\n\n    stream->anc_ptr    = stream->ptr;\n    stream->anc_bitlen = mad_bit_length(&stream->ptr, &next_frame);\n\n    mad_bit_finish(&next_frame);\n  }\n\n  return 0;\n\n fail:\n  stream->anc_bitlen = 0;\n  return -1;\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\tscale_rational()\n * DESCRIPTION:\tsolve numer/denom == ?/scale avoiding overflowing\n */\n", "func_signal": "static\nunsigned long scale_rational(unsigned long numer, unsigned long denom,\n\t\t\t     unsigned long scale)", "code": "{\n  reduce_rational(&numer, &denom);\n  reduce_rational(&scale, &denom);\n\n  assert(denom != 0);\n\n  if (denom < scale)\n    return numer * (scale / denom) + numer * (scale % denom) / denom;\n  if (denom < numer)\n    return scale * (numer / denom) + scale * (numer % denom) / denom;\n\n  return numer * scale / denom;\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\theader->init()\n * DESCRIPTION:\tinitialize header struct\n */\n", "func_signal": "void mad_header_init(struct mad_header *header)", "code": "{\n  header->layer          = 0;\n  header->mode           = 0;\n  header->mode_extension = 0;\n  header->emphasis       = 0;\n\n  header->bitrate        = 0;\n  header->samplerate     = 0;\n\n  header->crc_check      = 0;\n  header->crc_target     = 0;\n\n  header->flags          = 0;\n  header->private_bits   = 0;\n\n  header->duration       = mad_timer_zero;\n}", "path": "frame.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->add()\n * DESCRIPTION:\tadd one timer to another\n */\n", "func_signal": "void mad_timer_add(mad_timer_t *timer, mad_timer_t incr)", "code": "{\n  timer->seconds  += incr.seconds;\n  timer->fraction += incr.fraction;\n\n  if (timer->fraction >= MAD_TIMER_RESOLUTION)\n    reduce_timer(timer);\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->set()\n * DESCRIPTION:\tset timer to specific (positive) value\n */\n", "func_signal": "void mad_timer_set(mad_timer_t *timer, unsigned long seconds,\n\t\t   unsigned long numer, unsigned long denom)", "code": "{\n  timer->seconds = seconds;\n  if (numer >= denom && denom > 0) {\n    timer->seconds += numer / denom;\n    numer %= denom;\n  }\n\n  switch (denom) {\n  case 0:\n  case 1:\n    timer->fraction = 0;\n    break;\n\n  case MAD_TIMER_RESOLUTION:\n    timer->fraction = numer;\n    break;\n\n  case 1000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION /  1000);\n    break;\n\n  case 8000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION /  8000);\n    break;\n\n  case 11025:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 11025);\n    break;\n\n  case 12000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 12000);\n    break;\n\n  case 16000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 16000);\n    break;\n\n  case 22050:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 22050);\n    break;\n\n  case 24000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 24000);\n    break;\n\n  case 32000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 32000);\n    break;\n\n  case 44100:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 44100);\n    break;\n\n  case 48000:\n    timer->fraction = numer * (MAD_TIMER_RESOLUTION / 48000);\n    break;\n\n  default:\n    timer->fraction = scale_rational(numer, denom, MAD_TIMER_RESOLUTION);\n    break;\n  }\n\n  if (timer->fraction >= MAD_TIMER_RESOLUTION)\n    reduce_timer(timer);\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\ttimer->negate()\n * DESCRIPTION:\tinvert the sign of a timer\n */\n", "func_signal": "void mad_timer_negate(mad_timer_t *timer)", "code": "{\n  timer->seconds = -timer->seconds;\n\n  if (timer->fraction) {\n    timer->seconds -= 1;\n    timer->fraction = MAD_TIMER_RESOLUTION - timer->fraction;\n  }\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * NAME:\treduce_timer()\n * DESCRIPTION:\tcarry timer fraction into seconds\n */\n", "func_signal": "static\nvoid reduce_timer(mad_timer_t *timer)", "code": "{\n  timer->seconds  += timer->fraction / MAD_TIMER_RESOLUTION;\n  timer->fraction %= MAD_TIMER_RESOLUTION;\n}", "path": "timer.c", "repo_name": "prajnashi/libmad", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 1727}
{"docstring": "/*\n * Transmit as many characters to the HW as possible.\n *\n * This function will attempt to stuff of all the characters from the\n * kernel's transmit buffer into TX BDs.\n *\n * A return value of non-zero indicates that it successfully stuffed all\n * characters from the kernel buffer.\n *\n * A return value of zero indicates that there are still characters in the\n * kernel's buffer that have not been transmitted, but there are no more BDs\n * available.  This function should be called again after a BD has been made\n * available.\n */\n", "func_signal": "static int qe_uart_tx_pump(struct uart_qe_port *qe_port)", "code": "{\n\tstruct qe_bd *bdp;\n\tunsigned char *p;\n\tunsigned int count;\n\tstruct uart_port *port = &qe_port->port;\n\tstruct circ_buf *xmit = &port->state->xmit;\n\n\tbdp = qe_port->rx_cur;\n\n\t/* Handle xon/xoff */\n\tif (port->x_char) {\n\t\t/* Pick next descriptor and fill from buffer */\n\t\tbdp = qe_port->tx_cur;\n\n\t\tp = qe2cpu_addr(bdp->buf, qe_port);\n\n\t\t*p++ = port->x_char;\n\t\tout_be16(&bdp->length, 1);\n\t\tsetbits16(&bdp->status, BD_SC_READY);\n\t\t/* Get next BD. */\n\t\tif (in_be16(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t\tqe_port->tx_cur = bdp;\n\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn 1;\n\t}\n\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\n\t\tqe_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\t/* Pick next descriptor and fill from buffer */\n\tbdp = qe_port->tx_cur;\n\n\twhile (!(in_be16(&bdp->status) & BD_SC_READY) &&\n\t       (xmit->tail != xmit->head)) {\n\t\tcount = 0;\n\t\tp = qe2cpu_addr(bdp->buf, qe_port);\n\t\twhile (count < qe_port->tx_fifosize) {\n\t\t\t*p++ = xmit->buf[xmit->tail];\n\t\t\txmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\n\t\t\tport->icount.tx++;\n\t\t\tcount++;\n\t\t\tif (xmit->head == xmit->tail)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tout_be16(&bdp->length, count);\n\t\tsetbits16(&bdp->status, BD_SC_READY);\n\n\t\t/* Get next BD. */\n\t\tif (in_be16(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->tx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\t}\n\tqe_port->tx_cur = bdp;\n\n\tif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\n\t\tuart_write_wakeup(port);\n\n\tif (uart_circ_empty(xmit)) {\n\t\t/* The kernel buffer is empty, so turn off TX interrupts.  We\n\t\t   don't need to be told when the QE is finished transmitting\n\t\t   the data. */\n\t\tqe_uart_stop_tx(port);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/* Interrupt handler\n *\n * This interrupt handler is called after a BD is processed.\n */\n", "func_signal": "static irqreturn_t qe_uart_int(int irq, void *data)", "code": "{\n\tstruct uart_qe_port *qe_port = (struct uart_qe_port *) data;\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tu16 events;\n\n\t/* Clear the interrupts */\n\tevents = in_be16(&uccp->ucce);\n\tout_be16(&uccp->ucce, events);\n\n\tif (events & UCC_UART_UCCE_BRKE)\n\t\tuart_handle_break(&qe_port->port);\n\n\tif (events & UCC_UART_UCCE_RX)\n\t\tqe_uart_int_rx(qe_port);\n\n\tif (events & UCC_UART_UCCE_TX)\n\t\tqe_uart_tx_pump(qe_port);\n\n\treturn events ? IRQ_HANDLED : IRQ_NONE;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/* Initialize buffer descriptors\n *\n * This function initializes all of the RX and TX buffer descriptors.\n */\n", "func_signal": "static void qe_uart_initbd(struct uart_qe_port *qe_port)", "code": "{\n\tint i;\n\tvoid *bd_virt;\n\tstruct qe_bd *bdp;\n\n\t/* Set the physical address of the host memory buffers in the buffer\n\t * descriptors, and the virtual address for us to work with.\n\t */\n\tbd_virt = qe_port->bd_virt;\n\tbdp = qe_port->rx_bd_base;\n\tqe_port->rx_cur = qe_port->rx_bd_base;\n\tfor (i = 0; i < (qe_port->rx_nrfifos - 1); i++) {\n\t\tout_be16(&bdp->status, BD_SC_EMPTY | BD_SC_INTRPT);\n\t\tout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\n\t\tout_be16(&bdp->length, 0);\n\t\tbd_virt += qe_port->rx_fifosize;\n\t\tbdp++;\n\t}\n\n\t/* */\n\tout_be16(&bdp->status, BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT);\n\tout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\n\tout_be16(&bdp->length, 0);\n\n\t/* Set the physical address of the host memory\n\t * buffers in the buffer descriptors, and the\n\t * virtual address for us to work with.\n\t */\n\tbd_virt = qe_port->bd_virt +\n\t\tL1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\n\tqe_port->tx_cur = qe_port->tx_bd_base;\n\tbdp = qe_port->tx_bd_base;\n\tfor (i = 0; i < (qe_port->tx_nrfifos - 1); i++) {\n\t\tout_be16(&bdp->status, BD_SC_INTRPT);\n\t\tout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\n\t\tout_be16(&bdp->length, 0);\n\t\tbd_virt += qe_port->tx_fifosize;\n\t\tbdp++;\n\t}\n\n\t/* Loopback requires the preamble bit to be set on the first TX BD */\n#ifdef LOOPBACK\n\tsetbits16(&qe_port->tx_cur->status, BD_SC_P);\n#endif\n\n\tout_be16(&bdp->status, BD_SC_WRAP | BD_SC_INTRPT);\n\tout_be32(&bdp->buf, cpu2qe_addr(bd_virt, qe_port));\n\tout_be16(&bdp->length, 0);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Allocate any memory and I/O resources required by the port.\n */\n", "func_signal": "static int qe_uart_request_port(struct uart_port *port)", "code": "{\n\tint ret;\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow_info *us_info = &qe_port->us_info;\n\tstruct ucc_slow_private *uccs;\n\tunsigned int rx_size, tx_size;\n\tvoid *bd_virt;\n\tdma_addr_t bd_dma_addr = 0;\n\n\tret = ucc_slow_init(us_info, &uccs);\n\tif (ret) {\n\t\tdev_err(port->dev, \"could not initialize UCC%u\\n\",\n\t\t       qe_port->ucc_num);\n\t\treturn ret;\n\t}\n\n\tqe_port->us_private = uccs;\n\tqe_port->uccp = uccs->us_regs;\n\tqe_port->uccup = (struct ucc_uart_pram *) uccs->us_pram;\n\tqe_port->rx_bd_base = uccs->rx_bd;\n\tqe_port->tx_bd_base = uccs->tx_bd;\n\n\t/*\n\t * Allocate the transmit and receive data buffers.\n\t */\n\n\trx_size = L1_CACHE_ALIGN(qe_port->rx_nrfifos * qe_port->rx_fifosize);\n\ttx_size = L1_CACHE_ALIGN(qe_port->tx_nrfifos * qe_port->tx_fifosize);\n\n\tbd_virt = dma_alloc_coherent(port->dev, rx_size + tx_size, &bd_dma_addr,\n\t\tGFP_KERNEL);\n\tif (!bd_virt) {\n\t\tdev_err(port->dev, \"could not allocate buffer descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqe_port->bd_virt = bd_virt;\n\tqe_port->bd_dma_addr = bd_dma_addr;\n\tqe_port->bd_size = rx_size + tx_size;\n\n\tqe_port->rx_buf = bd_virt;\n\tqe_port->tx_buf = qe_port->rx_buf + rx_size;\n\n\treturn 0;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*==========================================================================*/\n", "func_signal": "void ov2640_init_settings(struct gspca_dev *gspca_dev)", "code": "{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsd->vcur.backlight  =  32;\n\tsd->vcur.brightness =   0;\n\tsd->vcur.sharpness  =   6;\n\tsd->vcur.contrast   =   0;\n\tsd->vcur.gamma      =  32;\n\tsd->vcur.hue        =   0;\n\tsd->vcur.saturation = 128;\n\tsd->vcur.whitebal   =  64;\n\tsd->vcur.mirror     =   0;\n\tsd->vcur.flip       =   0;\n\n\tsd->vmax.backlight  =  64;\n\tsd->vmax.brightness = 255;\n\tsd->vmax.sharpness  =  31;\n\tsd->vmax.contrast   = 255;\n\tsd->vmax.gamma      =  64;\n\tsd->vmax.hue        = 254 + 2;\n\tsd->vmax.saturation = 255;\n\tsd->vmax.whitebal   = 128;\n\tsd->vmax.mirror     = 1;\n\tsd->vmax.flip       = 1;\n\tsd->vmax.AC50Hz     = 0;\n\n\tsd->dev_camera_settings = ov2640_camera_settings;\n\tsd->dev_init_at_startup = ov2640_init_at_startup;\n\tsd->dev_configure_alt   = ov2640_configure_alt;\n\tsd->dev_init_pre_alt    = ov2640_init_pre_alt;\n\tsd->dev_post_unset_alt  = ov2640_post_unset_alt;\n}", "path": "drivers\\media\\video\\gspca\\gl860\\gl860-ov2640.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Verify that the data in serial_struct is suitable for this device.\n */\n", "func_signal": "static int qe_uart_verify_port(struct uart_port *port,\n\t\t\t       struct serial_struct *ser)", "code": "{\n\tif (ser->type != PORT_UNKNOWN && ser->type != PORT_CPM)\n\t\treturn -EINVAL;\n\n\tif (ser->irq < 0 || ser->irq >= nr_irqs)\n\t\treturn -EINVAL;\n\n\tif (ser->baud_base < 9600)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Release any memory and I/O resources that were allocated in\n * qe_uart_request_port().\n */\n", "func_signal": "static void qe_uart_release_port(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow_private *uccs = qe_port->us_private;\n\n\tdma_free_coherent(port->dev, qe_port->bd_size, qe_port->bd_virt,\n\t\t\t  qe_port->bd_dma_addr);\n\n\tucc_slow_free(uccs);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/* Start or stop sending  break signal\n *\n * This function controls the sending of a break signal.  If break_state=1,\n * then we start sending a break signal.  If break_state=0, then we stop\n * sending the break signal.\n */\n", "func_signal": "static void qe_uart_break_ctl(struct uart_port *port, int break_state)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tif (break_state)\n\t\tucc_slow_stop_tx(qe_port->us_private);\n\telse\n\t\tucc_slow_restart_tx(qe_port->us_private);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Start transmitting data\n *\n * This function will start transmitting any available data, if the port\n * isn't already transmitting data.\n */\n", "func_signal": "static void qe_uart_start_tx(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\t/* If we currently are transmitting, then just return */\n\tif (in_be16(&qe_port->uccp->uccm) & UCC_UART_UCCE_TX)\n\t\treturn;\n\n\t/* Otherwise, pump the port and start transmission */\n\tif (qe_uart_tx_pump(qe_port))\n\t\tsetbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * requst_firmware_nowait() callback function\n *\n * This function is called by the kernel when a firmware is made available,\n * or if it times out waiting for the firmware.\n */\n", "func_signal": "static void uart_firmware_cont(const struct firmware *fw, void *context)", "code": "{\n\tstruct qe_firmware *firmware;\n\tstruct device *dev = context;\n\tint ret;\n\n\tif (!fw) {\n\t\tdev_err(dev, \"firmware not found\\n\");\n\t\treturn;\n\t}\n\n\tfirmware = (struct qe_firmware *) fw->data;\n\n\tif (firmware->header.length != fw->size) {\n\t\tdev_err(dev, \"invalid firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tret = qe_upload_firmware(firmware);\n\tif (ret) {\n\t\tdev_err(dev, \"could not load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tfirmware_loaded = 1;\n out:\n\trelease_firmware(fw);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Set the serial port parameters.\n */\n", "func_signal": "static void qe_uart_set_termios(struct uart_port *port,\n\t\t\t\tstruct ktermios *termios, struct ktermios *old)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tunsigned int baud;\n\tunsigned long flags;\n\tu16 upsmr = in_be16(&uccp->upsmr);\n\tstruct ucc_uart_pram __iomem *uccup = qe_port->uccup;\n\tu16 supsmr = in_be16(&uccup->supsmr);\n\tu8 char_length = 2; /* 1 + CL + PEN + 1 + SL */\n\n\t/* Character length programmed into the mode register is the\n\t * sum of: 1 start bit, number of data bits, 0 or 1 parity bit,\n\t * 1 or 2 stop bits, minus 1.\n\t * The value 'bits' counts this for us.\n\t */\n\n\t/* byte size */\n\tupsmr &= UCC_UART_UPSMR_CL_MASK;\n\tsupsmr &= UCC_UART_SUPSMR_CL_MASK;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\tcase CS5:\n\t\tupsmr |= UCC_UART_UPSMR_CL_5;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_5;\n\t\tchar_length += 5;\n\t\tbreak;\n\tcase CS6:\n\t\tupsmr |= UCC_UART_UPSMR_CL_6;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_6;\n\t\tchar_length += 6;\n\t\tbreak;\n\tcase CS7:\n\t\tupsmr |= UCC_UART_UPSMR_CL_7;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_7;\n\t\tchar_length += 7;\n\t\tbreak;\n\tdefault:\t/* case CS8 */\n\t\tupsmr |= UCC_UART_UPSMR_CL_8;\n\t\tsupsmr |= UCC_UART_SUPSMR_CL_8;\n\t\tchar_length += 8;\n\t\tbreak;\n\t}\n\n\t/* If CSTOPB is set, we want two stop bits */\n\tif (termios->c_cflag & CSTOPB) {\n\t\tupsmr |= UCC_UART_UPSMR_SL;\n\t\tsupsmr |= UCC_UART_SUPSMR_SL;\n\t\tchar_length++;  /* + SL */\n\t}\n\n\tif (termios->c_cflag & PARENB) {\n\t\tupsmr |= UCC_UART_UPSMR_PEN;\n\t\tsupsmr |= UCC_UART_SUPSMR_PEN;\n\t\tchar_length++;  /* + PEN */\n\n\t\tif (!(termios->c_cflag & PARODD)) {\n\t\t\tupsmr &= ~(UCC_UART_UPSMR_RPM_MASK |\n\t\t\t\t   UCC_UART_UPSMR_TPM_MASK);\n\t\t\tupsmr |= UCC_UART_UPSMR_RPM_EVEN |\n\t\t\t\tUCC_UART_UPSMR_TPM_EVEN;\n\t\t\tsupsmr &= ~(UCC_UART_SUPSMR_RPM_MASK |\n\t\t\t\t    UCC_UART_SUPSMR_TPM_MASK);\n\t\t\tsupsmr |= UCC_UART_SUPSMR_RPM_EVEN |\n\t\t\t\tUCC_UART_SUPSMR_TPM_EVEN;\n\t\t}\n\t}\n\n\t/*\n\t * Set up parity check flag\n\t */\n\tport->read_status_mask = BD_SC_EMPTY | BD_SC_OV;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= BD_SC_FR | BD_SC_PR;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tport->read_status_mask |= BD_SC_BR;\n\n\t/*\n\t * Characters to ignore\n\t */\n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= BD_SC_BR;\n\t\t/*\n\t\t * If we're ignore parity and break indicators, ignore\n\t\t * overruns too.  (For real raw support).\n\t\t */\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= BD_SC_OV;\n\t}\n\t/*\n\t * !!! ignore all characters if CREAD is not set\n\t */\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->read_status_mask &= ~BD_SC_EMPTY;\n\n\tbaud = uart_get_baud_rate(port, termios, old, 0, 115200);\n\n\t/* Do we really need a spinlock here? */\n\tspin_lock_irqsave(&port->lock, flags);\n\n\tout_be16(&uccp->upsmr, upsmr);\n\tif (soft_uart) {\n\t\tout_be16(&uccup->supsmr, supsmr);\n\t\tout_8(&uccup->rx_length, char_length);\n\n\t\t/* Soft-UART requires a 1X multiplier for TX */\n\t\tqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\n\t\tqe_setbrg(qe_port->us_info.tx_clock, baud, 1);\n\t} else {\n\t\tqe_setbrg(qe_port->us_info.rx_clock, baud, 16);\n\t\tqe_setbrg(qe_port->us_info.tx_clock, baud, 16);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Initialize the port.\n */\n", "func_signal": "static int qe_uart_startup(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tint ret;\n\n\t/*\n\t * If we're using Soft-UART mode, then we need to make sure the\n\t * firmware has been uploaded first.\n\t */\n\tif (soft_uart && !firmware_loaded) {\n\t\tdev_err(port->dev, \"Soft-UART firmware not uploaded\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqe_uart_initbd(qe_port);\n\tqe_uart_init_ucc(qe_port);\n\n\t/* Install interrupt handler. */\n\tret = request_irq(port->irq, qe_uart_int, IRQF_SHARED, \"ucc-uart\",\n\t\tqe_port);\n\tif (ret) {\n\t\tdev_err(port->dev, \"could not claim IRQ %u\\n\", port->irq);\n\t\treturn ret;\n\t}\n\n\t/* Startup rx-int */\n\tsetbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\n\tucc_slow_enable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\n\treturn 0;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Stop transmitting data\n */\n", "func_signal": "static void qe_uart_stop_rx(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tclrbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_RX);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Configure the port.\n *\n * We say we're a CPM-type port because that's mostly true.  Once the device\n * is configured, this driver operates almost identically to the CPM serial\n * driver.\n */\n", "func_signal": "static void qe_uart_config_port(struct uart_port *port, int flags)", "code": "{\n\tif (flags & UART_CONFIG_TYPE) {\n\t\tport->type = PORT_CPM;\n\t\tqe_uart_request_port(port);\n\t}\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Shutdown the port.\n */\n", "func_signal": "static void qe_uart_shutdown(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tunsigned int timeout = 20;\n\n\t/* Disable RX and TX */\n\n\t/* Wait for all the BDs marked sent */\n\twhile (!qe_uart_tx_empty(port)) {\n\t\tif (!--timeout) {\n\t\t\tdev_warn(port->dev, \"shutdown timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(2);\n\t}\n\n\tif (qe_port->wait_closing) {\n\t\t/* Wait a bit longer */\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(qe_port->wait_closing);\n\t}\n\n\t/* Stop uarts */\n\tucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\tclrbits16(&uccp->uccm, UCC_UART_UCCE_TX | UCC_UART_UCCE_RX);\n\n\t/* Shut them really down and reinit buffer descriptors */\n\tucc_slow_graceful_stop_tx(qe_port->us_private);\n\tqe_uart_initbd(qe_port);\n\n\tfree_irq(port->irq, qe_port);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Physical to virtual address translation.\n *\n * Given the physical (DMA) address for a character buffer, this function\n * returns the virtual equivalent.\n */\n", "func_signal": "static inline void *qe2cpu_addr(dma_addr_t addr, struct uart_qe_port *qe_port)", "code": "{\n\t/* sanity check */\n\tif (likely((addr >= qe_port->bd_dma_addr) &&\n\t\t   (addr < (qe_port->bd_dma_addr + qe_port->bd_size))))\n\t\treturn qe_port->bd_virt + (addr - qe_port->bd_dma_addr);\n\n\t/* something nasty happened */\n\tprintk(KERN_ERR \"%s: addr=%x\\n\", __func__, addr);\n\tBUG();\n\treturn NULL;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Return 1 if the QE is done transmitting all buffers for this port\n *\n * This function scans each BD in sequence.  If we find a BD that is not\n * ready (READY=1), then we return 0 indicating that the QE is still sending\n * data.  If we reach the last BD (WRAP=1), then we know we've scanned\n * the entire list, and all BDs are done.\n */\n", "func_signal": "static unsigned int qe_uart_tx_empty(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\tstruct qe_bd *bdp = qe_port->tx_bd_base;\n\n\twhile (1) {\n\t\tif (in_be16(&bdp->status) & BD_SC_READY)\n\t\t\t/* This BD is not done, so return \"not done\" */\n\t\t\treturn 0;\n\n\t\tif (in_be16(&bdp->status) & BD_SC_WRAP)\n\t\t\t/*\n\t\t\t * This BD is done and it's the last one, so return\n\t\t\t * \"done\"\n\t\t\t */\n\t\t\treturn 1;\n\n\t\tbdp++;\n\t};\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Initialize a UCC for UART.\n *\n * This function configures a given UCC to be used as a UART device. Basic\n * UCC initialization is handled in qe_uart_request_port().  This function\n * does all the UART-specific stuff.\n */\n", "func_signal": "static void qe_uart_init_ucc(struct uart_qe_port *qe_port)", "code": "{\n\tu32 cecr_subblock;\n\tstruct ucc_slow __iomem *uccp = qe_port->uccp;\n\tstruct ucc_uart_pram *uccup = qe_port->uccup;\n\n\tunsigned int i;\n\n\t/* First, disable TX and RX in the UCC */\n\tucc_slow_disable(qe_port->us_private, COMM_DIR_RX_AND_TX);\n\n\t/* Program the UCC UART parameter RAM */\n\tout_8(&uccup->common.rbmr, UCC_BMR_GBL | UCC_BMR_BO_BE);\n\tout_8(&uccup->common.tbmr, UCC_BMR_GBL | UCC_BMR_BO_BE);\n\tout_be16(&uccup->common.mrblr, qe_port->rx_fifosize);\n\tout_be16(&uccup->maxidl, 0x10);\n\tout_be16(&uccup->brkcr, 1);\n\tout_be16(&uccup->parec, 0);\n\tout_be16(&uccup->frmec, 0);\n\tout_be16(&uccup->nosec, 0);\n\tout_be16(&uccup->brkec, 0);\n\tout_be16(&uccup->uaddr[0], 0);\n\tout_be16(&uccup->uaddr[1], 0);\n\tout_be16(&uccup->toseq, 0);\n\tfor (i = 0; i < 8; i++)\n\t\tout_be16(&uccup->cchars[i], 0xC000);\n\tout_be16(&uccup->rccm, 0xc0ff);\n\n\t/* Configure the GUMR registers for UART */\n\tif (soft_uart) {\n\t\t/* Soft-UART requires a 1X multiplier for TX */\n\t\tclrsetbits_be32(&uccp->gumr_l,\n\t\t\tUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\tUCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_1 |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tclrsetbits_be32(&uccp->gumr_h, UCC_SLOW_GUMR_H_RFW,\n\t\t\tUCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX);\n\t} else {\n\t\tclrsetbits_be32(&uccp->gumr_l,\n\t\t\tUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\tUCC_SLOW_GUMR_L_MODE_UART | UCC_SLOW_GUMR_L_TDCR_16 |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tclrsetbits_be32(&uccp->gumr_h,\n\t\t\tUCC_SLOW_GUMR_H_TRX | UCC_SLOW_GUMR_H_TTX,\n\t\t\tUCC_SLOW_GUMR_H_RFW);\n\t}\n\n#ifdef LOOPBACK\n\tclrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\n\t\tUCC_SLOW_GUMR_L_DIAG_LOOP);\n\tclrsetbits_be32(&uccp->gumr_h,\n\t\tUCC_SLOW_GUMR_H_CTSP | UCC_SLOW_GUMR_H_RSYN,\n\t\tUCC_SLOW_GUMR_H_CDS);\n#endif\n\n\t/* Disable rx interrupts  and clear all pending events.  */\n\tout_be16(&uccp->uccm, 0);\n\tout_be16(&uccp->ucce, 0xffff);\n\tout_be16(&uccp->udsr, 0x7e7e);\n\n\t/* Initialize UPSMR */\n\tout_be16(&uccp->upsmr, 0);\n\n\tif (soft_uart) {\n\t\tout_be16(&uccup->supsmr, 0x30);\n\t\tout_be16(&uccup->res92, 0);\n\t\tout_be32(&uccup->rx_state, 0);\n\t\tout_be32(&uccup->rx_cnt, 0);\n\t\tout_8(&uccup->rx_bitmark, 0);\n\t\tout_8(&uccup->rx_length, 10);\n\t\tout_be32(&uccup->dump_ptr, 0x4000);\n\t\tout_8(&uccup->rx_temp_dlst_qe, 0);\n\t\tout_be32(&uccup->rx_frame_rem, 0);\n\t\tout_8(&uccup->rx_frame_rem_size, 0);\n\t\t/* Soft-UART requires TX to be 1X */\n\t\tout_8(&uccup->tx_mode,\n\t\t\tUCC_UART_TX_STATE_UART | UCC_UART_TX_STATE_X1);\n\t\tout_be16(&uccup->tx_state, 0);\n\t\tout_8(&uccup->resD4, 0);\n\t\tout_be16(&uccup->resD5, 0);\n\n\t\t/* Set UART mode.\n\t\t * Enable receive and transmit.\n\t\t */\n\n\t\t/* From the microcode errata:\n\t\t * 1.GUMR_L register, set mode=0010 (QMC).\n\t\t * 2.Set GUMR_H[17] bit. (UART/AHDLC mode).\n\t\t * 3.Set GUMR_H[19:20] (Transparent mode)\n\t\t * 4.Clear GUMR_H[26] (RFW)\n\t\t * ...\n\t\t * 6.Receiver must use 16x over sampling\n\t\t */\n\t\tclrsetbits_be32(&uccp->gumr_l,\n\t\t\tUCC_SLOW_GUMR_L_MODE_MASK | UCC_SLOW_GUMR_L_TDCR_MASK |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_MASK,\n\t\t\tUCC_SLOW_GUMR_L_MODE_QMC | UCC_SLOW_GUMR_L_TDCR_16 |\n\t\t\tUCC_SLOW_GUMR_L_RDCR_16);\n\n\t\tclrsetbits_be32(&uccp->gumr_h,\n\t\t\tUCC_SLOW_GUMR_H_RFW | UCC_SLOW_GUMR_H_RSYN,\n\t\t\tUCC_SLOW_GUMR_H_SUART | UCC_SLOW_GUMR_H_TRX |\n\t\t\tUCC_SLOW_GUMR_H_TTX | UCC_SLOW_GUMR_H_TFL);\n\n#ifdef LOOPBACK\n\t\tclrsetbits_be32(&uccp->gumr_l, UCC_SLOW_GUMR_L_DIAG_MASK,\n\t\t\t\tUCC_SLOW_GUMR_L_DIAG_LOOP);\n\t\tclrbits32(&uccp->gumr_h, UCC_SLOW_GUMR_H_CTSP |\n\t\t\t  UCC_SLOW_GUMR_H_CDS);\n#endif\n\n\t\tcecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\n\t\tqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\n\t\t\tQE_CR_PROTOCOL_UNSPECIFIED, 0);\n\t} else {\n\t\tcecr_subblock = ucc_slow_get_qe_cr_subblock(qe_port->ucc_num);\n\t\tqe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,\n\t\t\tQE_CR_PROTOCOL_UART, 0);\n\t}\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/* ISR helper function for receiving character.\n *\n * This function is called by the ISR to handling receiving characters\n */\n", "func_signal": "static void qe_uart_int_rx(struct uart_qe_port *qe_port)", "code": "{\n\tint i;\n\tunsigned char ch, *cp;\n\tstruct uart_port *port = &qe_port->port;\n\tstruct tty_struct *tty = port->state->port.tty;\n\tstruct qe_bd *bdp;\n\tu16 status;\n\tunsigned int flg;\n\n\t/* Just loop through the closed BDs and copy the characters into\n\t * the buffer.\n\t */\n\tbdp = qe_port->rx_cur;\n\twhile (1) {\n\t\tstatus = in_be16(&bdp->status);\n\n\t\t/* If this one is empty, then we assume we've read them all */\n\t\tif (status & BD_SC_EMPTY)\n\t\t\tbreak;\n\n\t\t/* get number of characters, and check space in RX buffer */\n\t\ti = in_be16(&bdp->length);\n\n\t\t/* If we don't have enough room in RX buffer for the entire BD,\n\t\t * then we try later, which will be the next RX interrupt.\n\t\t */\n\t\tif (tty_buffer_request_room(tty, i) < i) {\n\t\t\tdev_dbg(port->dev, \"ucc-uart: no room in RX buffer\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* get pointer */\n\t\tcp = qe2cpu_addr(bdp->buf, qe_port);\n\n\t\t/* loop through the buffer */\n\t\twhile (i-- > 0) {\n\t\t\tch = *cp++;\n\t\t\tport->icount.rx++;\n\t\t\tflg = TTY_NORMAL;\n\n\t\t\tif (!i && status &\n\t\t\t    (BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV))\n\t\t\t\tgoto handle_error;\n\t\t\tif (uart_handle_sysrq_char(port, ch))\n\t\t\t\tcontinue;\n\nerror_return:\n\t\t\ttty_insert_flip_char(tty, ch, flg);\n\n\t\t}\n\n\t\t/* This BD is ready to be used again. Clear status. get next */\n\t\tclrsetbits_be16(&bdp->status, BD_SC_BR | BD_SC_FR | BD_SC_PR |\n\t\t\tBD_SC_OV | BD_SC_ID, BD_SC_EMPTY);\n\t\tif (in_be16(&bdp->status) & BD_SC_WRAP)\n\t\t\tbdp = qe_port->rx_bd_base;\n\t\telse\n\t\t\tbdp++;\n\n\t}\n\n\t/* Write back buffer pointer */\n\tqe_port->rx_cur = bdp;\n\n\t/* Activate BH processing */\n\ttty_flip_buffer_push(tty);\n\n\treturn;\n\n\t/* Error processing */\n\nhandle_error:\n\t/* Statistics */\n\tif (status & BD_SC_BR)\n\t\tport->icount.brk++;\n\tif (status & BD_SC_PR)\n\t\tport->icount.parity++;\n\tif (status & BD_SC_FR)\n\t\tport->icount.frame++;\n\tif (status & BD_SC_OV)\n\t\tport->icount.overrun++;\n\n\t/* Mask out ignored conditions */\n\tstatus &= port->read_status_mask;\n\n\t/* Handle the remaining ones */\n\tif (status & BD_SC_BR)\n\t\tflg = TTY_BREAK;\n\telse if (status & BD_SC_PR)\n\t\tflg = TTY_PARITY;\n\telse if (status & BD_SC_FR)\n\t\tflg = TTY_FRAME;\n\n\t/* Overrun does not affect the current character ! */\n\tif (status & BD_SC_OV)\n\t\ttty_insert_flip_char(tty, 0, TTY_OVERRUN);\n#ifdef SUPPORT_SYSRQ\n\tport->sysrq = 0;\n#endif\n\tgoto error_return;\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/*\n * Disable the transmit interrupt.\n *\n * Although this function is called \"stop_tx\", it does not actually stop\n * transmission of data.  Instead, it tells the QE to not generate an\n * interrupt when the UCC is finished sending characters.\n */\n", "func_signal": "static void qe_uart_stop_tx(struct uart_port *port)", "code": "{\n\tstruct uart_qe_port *qe_port =\n\t\tcontainer_of(port, struct uart_qe_port, port);\n\n\tclrbits16(&qe_port->uccp->uccm, UCC_UART_UCCE_TX);\n}", "path": "drivers\\serial\\ucc_uart.c", "repo_name": "CyanogenMod/lge-kernel-msm7x27", "stars": 28, "license": "other", "language": "c", "size": 361968}
{"docstring": "/* records user -targa switch */\n", "func_signal": "LOCAL(cjpeg_source_ptr)\nselect_file_type (j_compress_ptr cinfo, FILE * infile)", "code": "{\n  int c;\n\n  if (is_targa) {\n#ifdef TARGA_SUPPORTED\n    return jinit_read_targa(cinfo);\n#else\n    ERREXIT(cinfo, JERR_TGA_NOTCOMP);\n#endif\n  }\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n  if (ungetc(c, infile) == EOF)\n    ERREXIT(cinfo, JERR_UNGETC_FAILED);\n\n  switch (c) {\n#ifdef BMP_SUPPORTED\n  case 'B':\n    return jinit_read_bmp(cinfo);\n#endif\n#ifdef GIF_SUPPORTED\n  case 'G':\n    return jinit_read_gif(cinfo);\n#endif\n#ifdef PPM_SUPPORTED\n  case 'P':\n    return jinit_read_ppm(cinfo);\n#endif\n#ifdef RLE_SUPPORTED\n  case 'R':\n    return jinit_read_rle(cinfo);\n#endif\n#ifdef TARGA_SUPPORTED\n  case 0x00:\n    return jinit_read_targa(cinfo);\n#endif\n  default:\n    ERREXIT(cinfo, JERR_UNKNOWN_FORMAT);\n    break;\n  }\n\n  return NULL;\t\t\t/* suppress compiler warnings */\n}", "path": "tess-two\\external\\libjpeg\\cjpeg.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_setDataTwoBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xffff)\n *      Return: void\n */\n", "func_signal": "void\nl_setDataTwoBytes(void    *line,\n                  l_int32  n,\n                  l_int32  val)", "code": "{\n#ifdef  L_BIG_ENDIAN\n    *((l_uint16 *)line + n) = val;\n#else  /* L_LITTLE_ENDIAN */\n    *(l_uint16 *)((l_uintptr_t)((l_uint16 *)line + n) ^ 2) = val;\n#endif  /* L_BIG_ENDIAN */\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  pixRotate180()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a 180 rotation of the image about the center,\n *          which is equivalent to a left-right flip about a vertical\n *          line through the image center, followed by a top-bottom\n *          flip about a horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixRotate180(NULL, pixs);\n *          (b) pixRotate180(pixs, pixs);\n *          (c) pixRotate180(pixd, pixs);\n */\n", "func_signal": "PIX *\npixRotate180(PIX  *pixd,\n             PIX  *pixs)", "code": "{\nl_int32  d;\n\n    PROCNAME(\"pixRotate180\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 1 && d != 2 && d != 4 && d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not in {1,2,4,8,16,32} bpp\",\n                                procName, NULL);\n\n        /* Prepare pixd for in-place operation */\n    if ((pixd = pixCopy(pixd, pixs)) == NULL)\n\treturn (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n    pixFlipLR(pixd, pixd);\n    pixFlipTB(pixd, pixd);\n    return pixd;\n}", "path": "tess-two\\external\\leptonica-1.68\\src\\rotateorth.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_getDataTwoBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: value of the n-th (2-byte) pixel\n */\n", "func_signal": "l_int32\nl_getDataTwoBytes(void    *line,\n                  l_int32  n)", "code": "{\n#ifdef  L_BIG_ENDIAN\n    return *((l_uint16 *)line + n);\n#else  /* L_LITTLE_ENDIAN */\n    return *(l_uint16 *)((l_uintptr_t)((l_uint16 *)line + n) ^ 2);\n#endif  /* L_BIG_ENDIAN */\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_setDataBitVal()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 or 1)\n *      Return: void\n *\n *  Notes:\n *      (1) This is an accessor for a 1 bpp pix.\n *      (2) It is actually a little slower than using:\n *            if (val == 0)\n *                l_ClearDataBit(line, n);\n *            else\n *                l_SetDataBit(line, n);\n */\n", "func_signal": "void\nl_setDataBitVal(void    *line,\n                l_int32  n,\n                l_int32  val)", "code": "{\nl_uint32    *pword;\n\n    pword = (l_uint32 *)line + (n >> 5);\n    *pword &= ~(0x80000000 >> (n & 31));  /* clear */\n    *pword |= val << (31 - (n & 31));   /* set */\n    return;\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  pixFlipLR()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a left-right flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          vertical line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixFlipLR(NULL, pixs);\n *          (b) pixFlipLR(pixs, pixs);\n *          (c) pixFlipLR(pixd, pixs);\n *      (4) If an existing pixd is not the same size as pixs, the\n *          image data will be reallocated.\n */\n", "func_signal": "PIX *\npixFlipLR(PIX  *pixd,\n          PIX  *pixs)", "code": "{\nl_uint8   *tab;\nl_int32    w, h, d, wpld;\nl_uint32  *datad, *buffer;\n\n    PROCNAME(\"pixFlipLR\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1 && d != 2 && d != 4 && d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not in {1,2,4,8,16,32} bpp\",\n                                procName, NULL);\n\n        /* Prepare pixd for in-place operation */\n    if ((pixd = pixCopy(pixd, pixs)) == NULL)\n\treturn (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    switch (d)\n    {\n    case 1:\n        tab = makeReverseByteTab1();\n        break;\n    case 2:\n        tab = makeReverseByteTab2();\n        break;\n    case 4:\n        tab = makeReverseByteTab4();\n        break;\n    default:\n        tab = NULL;\n        break;\n    }\n\n    if ((buffer = (l_uint32 *)CALLOC(wpld, sizeof(l_uint32))) == NULL)\n        return (PIX *)ERROR_PTR(\"buffer not made\", procName, NULL);\n\n    flipLRLow(datad, w, h, d, wpld, tab, buffer);\n\n    FREE(buffer);\n    if (tab) FREE(tab);\n    return pixd;\n}", "path": "tess-two\\external\\leptonica-1.68\\src\\rotateorth.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  pixRotate90()\n *\n *      Input:  pixs (all depths)\n *              direction (1 = clockwise,  -1 = counter-clockwise)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a 90 degree rotation of the image about the center,\n *          either cw or ccw, returning a new pix.\n *      (2) The direction must be either 1 (cw) or -1 (ccw).\n */\n", "func_signal": "PIX *\npixRotate90(PIX     *pixs,\n            l_int32  direction)", "code": "{\nl_int32    wd, hd, d, wpls, wpld;\nl_uint32  *datas, *datad;\nPIX       *pixd;\n\n    PROCNAME(\"pixRotate90\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 1 && d != 2 && d != 4 && d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not in {1,2,4,8,16,32} bpp\",\n                                procName, NULL);\n    if (direction != 1 && direction != -1)\n        return (PIX *)ERROR_PTR(\"invalid direction\", procName, NULL);\n\n    hd = pixGetWidth(pixs);\n    wd = pixGetHeight(pixs);\n    if ((pixd = pixCreate(wd, hd, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixCopyColormap(pixd, pixs);\n    pixCopyResolution(pixd, pixs);\n    pixCopyInputFormat(pixd, pixs);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n\n    rotate90Low(datad, wd, hd, d, wpld, datas, wpls, direction);\n\n    return pixd;\n}", "path": "tess-two\\external\\leptonica-1.68\\src\\rotateorth.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_getDataByte()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: value of the n-th (byte) pixel\n */\n", "func_signal": "l_int32\nl_getDataByte(void    *line,\n              l_int32  n)", "code": "{\n#ifdef  L_BIG_ENDIAN\n    return *((l_uint8 *)line + n);\n#else  /* L_LITTLE_ENDIAN */\n    return *(l_uint8 *)((l_uintptr_t)((l_uint8 *)line + n) ^ 3);\n#endif  /* L_BIG_ENDIAN */\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * These routines take care of any system-dependent initialization and\n * cleanup required.\n */\n", "func_signal": "GLOBAL(long)\njpeg_mem_init (j_common_ptr cinfo)", "code": "{\n  next_file_num = 0;\n\n  /* max_memory_to_use will be initialized to FreeMem()'s result;\n   * the calling application might later reduce it, for example\n   * to leave room to invoke multiple JPEG objects.\n   * Note that FreeMem returns the total number of free bytes;\n   * it may not be possible to allocate a single block of this size.\n   */\n  return FreeMem();\n}", "path": "tess-two\\external\\libjpeg\\jmemmac.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_setDataDibit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 3)\n *      Return: void\n */\n", "func_signal": "void\nl_setDataDibit(void    *line,\n               l_int32  n,\n               l_int32  val)", "code": "{\nl_uint32    *pword;\n\n    pword = (l_uint32 *)line + (n >> 4);\n    *pword &= ~(0xc0000000 >> (2 * (n & 15)));  /* clear */\n    *pword |= (val & 3) << (30 - 2 * (n & 15));   /* set */\n    return;\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/* set to 1 for symmetric b.c.;\n                                     otherwise, it tests asymmetric b.c. */\n", "func_signal": "main(int    argc,\n     char **argv)", "code": "{\nl_int32      i, n, rsize, fact1, fact2, extra;\nl_int32      size, lastsize;\nl_int32      dwasize[256];\nl_int32      ropsize[256];\nPIX         *pixs, *pixt0, *pixt1, *pixt2, *pixt3, *pixt4, *pixt5, *pixt6;\nstatic char  mainName[] = \"binmorph5_reg\";\n\n    pixs = pixRead(\"feyn.tif\");\n\n#if TEST_SYMMETRIC\n        /* This works properly if there's an added border */\n    resetMorphBoundaryCondition(SYMMETRIC_MORPH_BC);\n#if 1\n    pixt1 = pixAddBorder(pixs, 64, 0);\n    pixTransferAllData(pixs, &pixt1, 0, 0);\n#endif\n#endif  /* TEST_SYMMETRIC */\n\n    pixt1 = pixCreateTemplateNoInit(pixs);\n    pixt2 = pixCreateTemplateNoInit(pixs);\n    pixt3 = pixCreateTemplateNoInit(pixs);\n    pixt4 = pixCreateTemplateNoInit(pixs);\n    pixt5 = pixCreateTemplateNoInit(pixs);\n    pixt6 = pixCreateTemplateNoInit(pixs);\n    \n\n    /* ---------------------------------------------------------------- *\n     *                  Faster test; testing fewer sizes                *\n     * ---------------------------------------------------------------- */\n#if  FASTER_TEST \n        /* Compute the actual sizes used for each input size 'i' */\n    for (i = 0; i < 256; i++) {\n        dwasize[i] = 0;\n        ropsize[i] = 0;\n    }\n    for (i = 65; i < 256; i++) {\n        selectComposableSizes(i, &fact1, &fact2);\n        rsize = fact1 * fact2;\n        ropsize[i] = rsize;\n        getExtendedCompositeParameters(i, &n, &extra, &dwasize[i]);\n    }\n\n        /* Use only values where the resulting sizes are equal */\n    for (i = 65; i < 240; i++) {\n        n = 1 + (l_int32)((i - 63) / 62);\n        extra = i - 63 - (n - 1) * 62 + 1;\n        if (extra == 2) continue;  /* don't use this one (e.g., i == 126) */\n        if (ropsize[i] == dwasize[i])\n            DoComparisonDwa1(pixs, pixt1, pixt2, pixt3, pixt4,\n                             pixt5, pixt6, i);\n    }\n#endif  /* FASTER_TEST */\n\n    /* ---------------------------------------------------------------- *\n     *          Slower test; testing maximum number of sizes            *\n     * ---------------------------------------------------------------- */\n#if  SLOWER_TEST \n    lastsize = 0;\n    for (i = 65; i < 199; i++) {\n        getExtendedCompositeParameters(i, &n, &extra, &size);\n        if (size == lastsize) continue;\n        if (size == 126 || size == 188) continue;  /* deliberately off by one */\n        lastsize = size;\n        DoComparisonDwa2(pixs, pixt1, pixt2, pixt3, pixt4,\n                         pixt5, pixt6, size);\n    }\n#endif  /* SLOWER_TEST */\n\n    pixDestroy(&pixs);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixDestroy(&pixt3);\n    pixDestroy(&pixt4);\n    pixDestroy(&pixt5);\n    pixDestroy(&pixt6);\n    return 0;\n}", "path": "tess-two\\external\\leptonica-1.68\\prog\\binmorph5_reg.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * This routine computes the total memory space available for allocation.\n */\n", "func_signal": "GLOBAL(long)\njpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,\n\t\t    long max_bytes_needed, long already_allocated)", "code": "{\n  long limit = cinfo->mem->max_memory_to_use - already_allocated;\n  long slop, mem;\n\n  /* Don't ask for more than what application has told us we may use */\n  if (max_bytes_needed > limit && limit > 0)\n    max_bytes_needed = limit;\n  /* Find whether there's a big enough free block in the heap.\n   * CompactMem tries to create a contiguous block of the requested size,\n   * and then returns the size of the largest free block (which could be\n   * much more or much less than we asked for).\n   * We add some slop to ensure we don't use up all available memory.\n   */\n  slop = max_bytes_needed / 16 + 32768L;\n  mem = CompactMem(max_bytes_needed + slop) - slop;\n  if (mem < 0)\n    mem = 0;\t\t\t/* sigh, couldn't even get the slop */\n  /* Don't take more than the application says we can have */\n  if (mem > limit && limit > 0)\n    mem = limit;\n  return mem;\n}", "path": "tess-two\\external\\libjpeg\\jmemmac.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * Perform the forward DCT on one block of samples.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_float (FAST_FLOAT * data)", "code": "{\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\n  FAST_FLOAT z1, z2, z3, z4, z5, z11, z13;\n  FAST_FLOAT *dataptr;\n  int ctr;\n\n  /* Pass 1: process rows. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n    \n    /* Even part */\n    \n    tmp10 = tmp0 + tmp3;\t/* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[4] = tmp10 - tmp11;\n    \n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */\n    dataptr[2] = tmp13 + z1;\t/* phase 5 */\n    dataptr[6] = tmp13 - z1;\n    \n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;\t/* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;\t\t/* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[5] = z13 + z2;\t/* phase 6 */\n    dataptr[3] = z13 - z2;\n    dataptr[1] = z11 + z4;\n    dataptr[7] = z11 - z4;\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];\n    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];\n    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];\n    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];\n    \n    /* Even part */\n    \n    tmp10 = tmp0 + tmp3;\t/* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    dataptr[DCTSIZE*0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[DCTSIZE*4] = tmp10 - tmp11;\n    \n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT) 0.707106781); /* c4 */\n    dataptr[DCTSIZE*2] = tmp13 + z1; /* phase 5 */\n    dataptr[DCTSIZE*6] = tmp13 - z1;\n    \n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;\t/* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT) 1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT) 0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;\t\t/* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[DCTSIZE*5] = z13 + z2; /* phase 6 */\n    dataptr[DCTSIZE*3] = z13 - z2;\n    dataptr[DCTSIZE*1] = z11 + z4;\n    dataptr[DCTSIZE*7] = z11 - z4;\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "tess-two\\external\\libjpeg\\jfdctflt.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_setDataByte()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xff)\n *      Return: void\n */\n", "func_signal": "void\nl_setDataByte(void    *line,\n              l_int32  n,\n              l_int32  val)", "code": "{\n#ifdef  L_BIG_ENDIAN\n    *((l_uint8 *)line + n) = val;\n#else  /* L_LITTLE_ENDIAN */\n    *(l_uint8 *)((l_uintptr_t)((l_uint8 *)line + n) ^ 3) = val;\n#endif  /* L_BIG_ENDIAN */\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * The main program.\n */\n", "func_signal": "int\nmain (int argc, char **argv)", "code": "{\n  struct jpeg_compress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n#ifdef PROGRESS_REPORT\n  struct cdjpeg_progress_mgr progress;\n#endif\n  int file_index;\n  cjpeg_source_ptr src_mgr;\n  FILE * input_file;\n  FILE * output_file;\n  JDIMENSION num_scanlines;\n\n  /* On Mac, fetch a command line. */\n#ifdef USE_CCOMMAND\n  argc = ccommand(&argv);\n#endif\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"cjpeg\";\t\t/* in case C library doesn't provide it */\n\n  /* Initialize the JPEG compression object with default error handling. */\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_compress(&cinfo);\n  /* Add some application-specific error messages (from cderror.h) */\n  jerr.addon_message_table = cdjpeg_message_table;\n  jerr.first_addon_message = JMSG_FIRSTADDONCODE;\n  jerr.last_addon_message = JMSG_LASTADDONCODE;\n\n  /* Now safe to enable signal catcher. */\n#ifdef NEED_SIGNAL_CATCHER\n  enable_signal_catcher((j_common_ptr) &cinfo);\n#endif\n\n  /* Initialize JPEG parameters.\n   * Much of this may be overridden later.\n   * In particular, we don't yet know the input file's color space,\n   * but we need to provide some value for jpeg_set_defaults() to work.\n   */\n\n  cinfo.in_color_space = JCS_RGB; /* arbitrary guess */\n  jpeg_set_defaults(&cinfo);\n\n  /* Scan command line to find file names.\n   * It is convenient to use just one switch-parsing routine, but the switch\n   * values read here are ignored; we will rescan the switches after opening\n   * the input file.\n   */\n\n  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);\n\n#ifdef TWO_FILE_COMMANDLINE\n  /* Must have either -outfile switch or explicit output file name */\n  if (outfilename == NULL) {\n    if (file_index != argc-2) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n\t      progname);\n      usage();\n    }\n    outfilename = argv[file_index+1];\n  } else {\n    if (file_index != argc-1) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n\t      progname);\n      usage();\n    }\n  }\n#else\n  /* Unix style: expect zero or one file name */\n  if (file_index < argc-1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n#endif /* TWO_FILE_COMMANDLINE */\n\n  /* Open the input file. */\n  if (file_index < argc) {\n    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[file_index]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n    input_file = read_stdin();\n  }\n\n  /* Open the output file. */\n  if (outfilename != NULL) {\n    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, outfilename);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default output file is stdout */\n    output_file = write_stdout();\n  }\n\n#ifdef PROGRESS_REPORT\n  start_progress_monitor((j_common_ptr) &cinfo, &progress);\n#endif\n\n  /* Figure out the input file format, and set up to read it. */\n  src_mgr = select_file_type(&cinfo, input_file);\n  src_mgr->input_file = input_file;\n\n  /* Read the input file header to obtain file size & colorspace. */\n  (*src_mgr->start_input) (&cinfo, src_mgr);\n\n  /* Now that we know input colorspace, fix colorspace-dependent defaults */\n  jpeg_default_colorspace(&cinfo);\n\n  /* Adjust default compression parameters by re-parsing the options */\n  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);\n\n  /* Specify data destination for compression */\n  jpeg_stdio_dest(&cinfo, output_file);\n\n  /* Start compressor */\n  jpeg_start_compress(&cinfo, TRUE);\n\n  /* Process data */\n  while (cinfo.next_scanline < cinfo.image_height) {\n    num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);\n    (void) jpeg_write_scanlines(&cinfo, src_mgr->buffer, num_scanlines);\n  }\n\n  /* Finish compression and release memory */\n  (*src_mgr->finish_input) (&cinfo, src_mgr);\n  jpeg_finish_compress(&cinfo);\n  jpeg_destroy_compress(&cinfo);\n\n  /* Close files, if we opened them */\n  if (input_file != stdin)\n    fclose(input_file);\n  if (output_file != stdout)\n    fclose(output_file);\n\n#ifdef PROGRESS_REPORT\n  end_progress_monitor((j_common_ptr) &cinfo);\n#endif\n\n  /* All done. */\n  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);\n  return 0;\t\t\t/* suppress no-return-value warnings */\n}", "path": "tess-two\\external\\libjpeg\\cjpeg.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * Initial opening of a backing-store object.\n *\n * This version uses FindFolder to find the Temporary Items folder,\n * and puts the temporary file in there.\n */\n", "func_signal": "GLOBAL(void)\njpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,\n\t\t\t long total_bytes_needed)", "code": "{\n  short         tmpRef, vRefNum;\n  long          dirID;\n  FInfo         finderInfo;\n  FSSpec        theSpec;\n  Str255        fName;\n  OSErr         osErr;\n  long          gestaltResponse = 0;\n\n  /* Check that FSSpec calls are available. */\n  osErr = Gestalt( gestaltFSAttr, &gestaltResponse );\n  if ( ( osErr != noErr )\n       || !( gestaltResponse & (1<<gestaltHasFSSpecCalls) ) )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- System 7.0 or later required\");\n  /* TO DO: add a proper error message to jerror.h. */\n\n  /* Check that FindFolder is available. */\n  osErr = Gestalt( gestaltFindFolderAttr, &gestaltResponse );\n  if ( ( osErr != noErr )\n       || !( gestaltResponse & (1<<gestaltFindFolderPresent) ) )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- System 7.0 or later required.\");\n  /* TO DO: add a proper error message to jerror.h. */\n\n  osErr = FindFolder ( kOnSystemDisk, kTemporaryFolderType, kCreateFolder,\n                       &vRefNum, &dirID );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, \"- temporary items folder unavailable\");\n  /* TO DO: Try putting the temp files somewhere else. */\n\n  /* Keep generating file names till we find one that's not in use */\n  for (;;) {\n    next_file_num++;\t\t/* advance counter */\n\n    sprintf(info->temp_name, TEMP_FILE_NAME, next_file_num);\n    strcpy ( (Ptr)fName+1, info->temp_name );\n    *fName = strlen (info->temp_name);\n    osErr = FSMakeFSSpec ( vRefNum, dirID, fName, &theSpec );\n\n    if ( (osErr = FSpGetFInfo ( &theSpec, &finderInfo ) ) != noErr )\n      break;\n  }\n\n  osErr = FSpCreate ( &theSpec, '????', '????', smSystemScript );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, info->temp_name);\n\n  osErr = FSpOpenDF ( &theSpec, fsRdWrPerm, &(info->temp_file) );\n  if ( osErr != noErr )\n    ERREXITS(cinfo, JERR_TFILE_CREATE, info->temp_name);\n\n  info->tempSpec = theSpec;\n\n  info->read_backing_store = read_backing_store;\n  info->write_backing_store = write_backing_store;\n  info->close_backing_store = close_backing_store;\n  TRACEMSS(cinfo, 1, JTRC_TFILE_OPEN, info->temp_name);\n}", "path": "tess-two\\external\\libjpeg\\jmemmac.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  l_setDataQbit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xf)\n *      Return: void\n */\n", "func_signal": "void\nl_setDataQbit(void    *line,\n              l_int32  n,\n              l_int32  val)", "code": "{\nl_uint32    *pword;\n\n    pword = (l_uint32 *)line + (n >> 3);\n    *pword &= ~(0xf0000000 >> (4 * (n & 7)));  /* clear */\n    *pword |= (val & 15) << (28 - 4 * (n & 7));   /* set */\n    return;\n}", "path": "tesseract-android-tools\\external\\leptonlib-1.66\\src\\arrayaccess.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  pixRotateOrth()\n *\n *      Input:  pixs (all depths)\n *              quads (0-3; number of 90 degree cw rotations)\n *      Return: pixd, or null on error\n */\n", "func_signal": "PIX *\npixRotateOrth(PIX     *pixs,\n              l_int32  quads)", "code": "{\n    PROCNAME(\"pixRotateOrth\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (quads < 0 || quads > 4)\n        return (PIX *)ERROR_PTR(\"quads not in {0,1,2,3,4}\", procName, NULL);\n\n    if (quads == 0 || quads == 4)\n        return pixCopy(NULL, pixs);\n    else if (quads == 1)\n        return pixRotate90(pixs, 1);\n    else if (quads == 2)\n        return pixRotate180(NULL, pixs);\n    else /* quads == 3 */\n        return pixRotate90(pixs, -1);\n}", "path": "tess-two\\external\\leptonica-1.68\\src\\rotateorth.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*\n * Backing store (temporary file) management.\n * Backing store objects are only used when the value returned by\n * jpeg_mem_available is less than the total space needed.  You can dispense\n * with these routines if you have plenty of virtual memory; see jmemnobs.c.\n */\n", "func_signal": "METHODDEF(void)\nread_backing_store (j_common_ptr cinfo, backing_store_ptr info,\n\t\t    void FAR * buffer_address,\n\t\t    long file_offset, long byte_count)", "code": "{\n  long bytes = byte_count;\n  long retVal;\n\n  if ( SetFPos ( info->temp_file, fsFromStart, file_offset ) != noErr )\n    ERREXIT(cinfo, JERR_TFILE_SEEK);\n\n  retVal = FSRead ( info->temp_file, &bytes,\n\t\t    (unsigned char *) buffer_address );\n  if ( retVal != noErr || bytes != byte_count )\n    ERREXIT(cinfo, JERR_TFILE_READ);\n}", "path": "tess-two\\external\\libjpeg\\jmemmac.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/*!\n *  pixFlipTB()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a top-bottom flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixFlipTB(NULL, pixs);\n *          (b) pixFlipTB(pixs, pixs);\n *          (c) pixFlipTB(pixd, pixs);\n *      (4) If an existing pixd is not the same size as pixs, the\n *          image data will be reallocated.\n */\n", "func_signal": "PIX *\npixFlipTB(PIX  *pixd,\n          PIX  *pixs)", "code": "{\nl_int32    h, d, wpld;\nl_uint32  *datad, *buffer;\n\n    PROCNAME(\"pixFlipTB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, NULL, &h, &d);\n    if (d != 1 && d != 2 && d != 4 && d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not in {1,2,4,8,16,32} bpp\",\n                                procName, NULL);\n\n        /* Prepare pixd for in-place operation */\n    if ((pixd = pixCopy(pixd, pixs)) == NULL)\n\treturn (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    if ((buffer = (l_uint32 *)CALLOC(wpld, sizeof(l_uint32))) == NULL)\n        return (PIX *)ERROR_PTR(\"buffer not made\", procName, NULL);\n\n    flipTBLow(datad, h, wpld, buffer);\n\n    FREE(buffer);\n    return pixd;\n}", "path": "tess-two\\external\\leptonica-1.68\\src\\rotateorth.c", "repo_name": "aurofable/18551_Project", "stars": 16, "license": "None", "language": "c", "size": 482782}
{"docstring": "/* Open foo.gz, verify the header, and load the extra field contents, after\n   first creating the foo.lock file to gain exclusive access to the foo.*\n   files.  If foo.gz does not exist or is empty, then write the initial header,\n   extra, and body content of an empty foo.gz log file.  If there is an error\n   creating the lock file due to access restrictions, or an error reading or\n   writing the foo.gz file, or if the foo.gz file is not a proper log file for\n   this object (e.g. not a gzip file or does not contain the expected extra\n   field), then return true.  If there is an error, the lock is released.\n   Otherwise, the lock is left in place. */\n", "func_signal": "local int log_open(struct log *log)", "code": "{\n    int op;\n\n    /* release open file resource if left over -- can occur if lock lost\n       between gzlog_open() and gzlog_write() */\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n\n    /* negotiate exclusive access */\n    if (log_lock(log) < 0)\n        return -1;\n\n    /* open the log file, foo.gz */\n    strcpy(log->end, \".gz\");\n    log->fd = open(log->path, O_RDWR | O_CREAT, 0644);\n    if (log->fd < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* if new, initialize foo.gz with an empty log, delete old dictionary */\n    if (lseek(log->fd, 0, SEEK_END) == 0) {\n        if (write(log->fd, log_gzhead, HEAD) != HEAD ||\n            write(log->fd, log_gzext, EXTRA) != EXTRA ||\n            write(log->fd, log_gzbody, BODY) != BODY) {\n            log_close(log);\n            return -1;\n        }\n        strcpy(log->end, \".dict\");\n        unlink(log->path);\n    }\n\n    /* verify log file and load extra field information */\n    if ((op = log_head(log)) < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* check for interrupted process and if so, recover */\n    if (op != NO_OP && log_recover(log, op)) {\n        log_close(log);\n        return -1;\n    }\n\n    /* touch the lock file to prevent another process from grabbing it */\n    log_touch(log);\n    return 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Unlock a previously acquired lock, but only if it's ours. */\n", "func_signal": "local void log_unlock(struct log *log)", "code": "{\n    if (log_check(log))\n        return;\n    strcpy(log->end, \".lock\");\n    unlink(log->path);\n    log->lock = 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* gzlog_close() return values:\n    0: ok\n   -3: invalid log pointer argument */\n", "func_signal": "int gzlog_close(gzlog *logd)", "code": "{\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n\n    /* close the log file and release the lock */\n    log_close(log);\n\n    /* free structure and return */\n    if (log->path != NULL)\n        free(log->path);\n    strcpy(log->id, \"bad\");\n    free(log);\n    return 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* gzlog_compress() return values:\n    0: all good\n   -1: file i/o error (usually access issue)\n   -2: memory allocation failure\n   -3: invalid log pointer argument */\n", "func_signal": "int gzlog_compress(gzlog *logd)", "code": "{\n    int fd, ret;\n    uint block;\n    size_t len, next;\n    unsigned char *data, buf[5];\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID) || len < 0)\n        return -3;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create space for uncompressed data */\n    len = ((size_t)(log->last - log->first) & ~(((size_t)1 << 10) - 1)) +\n          log->stored;\n    if ((data = malloc(len)) == NULL)\n        return -2;\n\n    /* do statement here is just a cheap trick for error handling */\n    do {\n        /* read in the uncompressed data */\n        if (lseek(log->fd, log->first - 1, SEEK_SET) < 0)\n            break;\n        next = 0;\n        while (next < len) {\n            if (read(log->fd, buf, 5) != 5)\n                break;\n            block = PULL2(buf + 1);\n            if (next + block > len ||\n                read(log->fd, (char *)data + next, block) != block)\n                break;\n            next += block;\n        }\n        if (lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored)\n            break;\n        log_touch(log);\n\n        /* write the uncompressed data to the .add file */\n        strcpy(log->end, \".add\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        ret = write(fd, data, len) != len;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* write the dictionary for the next compress to the .temp file */\n        strcpy(log->end, \".temp\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        next = DICT > len ? len : DICT;\n        ret = write(fd, (char *)data + len - next, next) != next;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* roll back to compressed data, mark the compress in progress */\n        log->last = log->first;\n        log->stored = 0;\n        if (log_mark(log, COMPRESS_OP))\n            break;\n        BAIL(7);\n\n        /* compress and append the data (clears mark) */\n        ret = log_compress(log, data, len);\n        free(data);\n        return ret;\n    } while (0);\n\n    /* broke out of do above on i/o error */\n    free(data);\n    return -1;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* log a repair record to the .repairs file */\n", "func_signal": "local void log_log(struct log *log, int op, char *record)", "code": "{\n    time_t now;\n    FILE *rec;\n\n    now = time(NULL);\n    strcpy(log->end, \".repairs\");\n    rec = fopen(log->path, \"a\");\n    if (rec == NULL)\n        return;\n    fprintf(rec, \"%.24s %s recovery: %s\\n\", ctime(&now), op == APPEND_OP ?\n            \"append\" : (op == COMPRESS_OP ? \"compress\" : \"replace\"), record);\n    fclose(rec);\n    return;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Recover the interrupted operation op.  First read foo.add for recovering an\n   append or compress operation.  Return -1 if there was an error reading or\n   writing foo.gz or reading an existing foo.add, or -2 if there was a memory\n   allocation failure. */\n", "func_signal": "local int log_recover(struct log *log, int op)", "code": "{\n    int fd, ret = 0;\n    unsigned char *data = NULL;\n    size_t len = 0;\n    struct stat st;\n\n    /* log recovery */\n    log_log(log, op, \"start\");\n\n    /* load foo.add file if expected and present */\n    if (op == APPEND_OP || op == COMPRESS_OP) {\n        strcpy(log->end, \".add\");\n        if (stat(log->path, &st) == 0 && st.st_size) {\n            len = (size_t)(st.st_size);\n            if (len != st.st_size || (data = malloc(st.st_size)) == NULL) {\n                log_log(log, op, \"allocation failure\");\n                return -2;\n            }\n            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            ret = read(fd, data, len) != len;\n            close(fd);\n            if (ret) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            log_log(log, op, \"loaded .add file\");\n        }\n        else\n            log_log(log, op, \"missing .add file!\");\n    }\n\n    /* recover the interrupted operation */\n    switch (op) {\n    case APPEND_OP:\n        ret = log_append(log, data, len);\n        break;\n    case COMPRESS_OP:\n        ret = log_compress(log, data, len);\n        break;\n    case REPLACE_OP:\n        ret = log_replace(log);\n    }\n\n    /* log status */\n    log_log(log, op, ret ? \"failure\" : \"complete\");\n\n    /* clean up */\n    if (data != NULL)\n        free(data);\n    return ret;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Rewrite the last block header bits and subsequent zero bits to get to a byte\n   boundary, setting the last block bit if last is true, and then write the\n   remainder of the stored block header (length and one's complement).  Leave\n   the file pointer after the end of the last stored block data.  Return -1 if\n   there is a read or write failure on the foo.gz file */\n", "func_signal": "local int log_last(struct log *log, int last)", "code": "{\n    int back, len, mask;\n    unsigned char buf[6];\n\n    /* determine the locations of the bytes and bits to modify */\n    back = log->last == log->first ? log->back : 8;\n    len = back > 8 ? 2 : 1;                 /* bytes back from log->last */\n    mask = 0x80 >> ((back - 1) & 7);        /* mask for block last-bit */\n\n    /* get the byte to modify (one or two back) into buf[0] -- don't need to\n       read the byte if the last-bit is eight bits back, since in that case\n       the entire byte will be modified */\n    buf[0] = 0;\n    if (back != 8 && (lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n                      read(log->fd, buf, 1) != 1))\n        return -1;\n\n    /* change the last-bit of the last stored block as requested -- note\n       that all bits above the last-bit are set to zero, per the type bits\n       of a stored block being 00 and per the convention that the bits to\n       bring the stream to a byte boundary are also zeros */\n    buf[1] = 0;\n    buf[2 - len] = (*buf & (mask - 1)) + (last ? mask : 0);\n\n    /* write the modified stored block header and lengths, move the file\n       pointer to after the last stored block data */\n    PUT2(buf + 2, log->stored);\n    PUT2(buf + 4, log->stored ^ 0xffff);\n    return lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n           write(log->fd, buf + 2 - len, len + 4) != len + 4 ||\n           lseek(log->fd, log->stored, SEEK_CUR) < 0 ? -1 : 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Deallocate an index built by build_index() */\n", "func_signal": "local void free_index(struct access *index)", "code": "{\n    if (index != NULL) {\n        free(index->list);\n        free(index);\n    }\n}", "path": "zlib\\examples\\zran.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* gzlog_write() return values:\n    0: all good\n   -1: file i/o error (usually access issue)\n   -2: memory allocation failure\n   -3: invalid log pointer argument */\n", "func_signal": "int gzlog_write(gzlog *logd, void *data, size_t len)", "code": "{\n    int fd, ret;\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID) || len < 0)\n        return -3;\n    if (data == NULL || len == 0)\n        return 0;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create and write .add file */\n    strcpy(log->end, \".add\");\n    fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0)\n        return -1;\n    ret = write(fd, data, len) != len;\n    if (ret | close(fd))\n        return -1;\n    log_touch(log);\n\n    /* mark log file with append in progress */\n    if (log_mark(log, APPEND_OP))\n        return -1;\n    BAIL(8);\n\n    /* append data (clears mark) */\n    if (log_append(log, data, len))\n        return -1;\n\n    /* check to see if it's time to compress -- if not, then done */\n    if (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)\n        return 0;\n\n    /* time to compress */\n    return gzlog_compress(log);\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Check the gzip header and read in the extra field, filling in the values in\n   the log structure.  Return op on success or -1 if the gzip header was not as\n   expected.  op is the current operation in progress last written to the extra\n   field.  This assumes that the gzip file has already been opened, with the\n   file descriptor log->fd. */\n", "func_signal": "local int log_head(struct log *log)", "code": "{\n    int op;\n    unsigned char buf[HEAD + EXTRA];\n\n    if (lseek(log->fd, 0, SEEK_SET) < 0 ||\n        read(log->fd, buf, HEAD + EXTRA) != HEAD + EXTRA ||\n        memcmp(buf, log_gzhead, HEAD)) {\n        return -1;\n    }\n    log->first = PULL8(buf + HEAD);\n    log->last = PULL8(buf + HEAD + 8);\n    log->ccrc = PULL4(buf + HEAD + 16);\n    log->clen = PULL4(buf + HEAD + 20);\n    log->tcrc = PULL4(buf + HEAD + 24);\n    log->tlen = PULL4(buf + HEAD + 28);\n    log->stored = PULL2(buf + HEAD + 32);\n    log->back = 3 + (buf[HEAD + 34] & 7);\n    op = (buf[HEAD + 34] >> 3) & 3;\n    return op;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Append len bytes from data to the locked and open log file.  len may be zero\n   if recovering and no .add file was found.  In that case, the previous state\n   of the foo.gz file is restored.  The data is appended uncompressed in\n   deflate stored blocks.  Return -1 if there was an error reading or writing\n   the foo.gz file. */\n", "func_signal": "local int log_append(struct log *log, unsigned char *data, size_t len)", "code": "{\n    uint put;\n    off_t end;\n    unsigned char buf[8];\n\n    /* set the last block last-bit and length, in case recovering an\n       interrupted append, then position the file pointer to append to the\n       block */\n    if (log_last(log, 1))\n        return -1;\n\n    /* append, adding stored blocks and updating the offset of the last stored\n       block as needed, and update the total crc and length */\n    while (len) {\n        /* append as much as we can to the last block */\n        put = (MAX_STORE << 10) - log->stored;\n        if (put > len)\n            put = (uint)len;\n        if (put) {\n            if (write(log->fd, data, put) != put)\n                return -1;\n            BAIL(1);\n            log->tcrc = crc32(log->tcrc, data, put);\n            log->tlen += put;\n            log->stored += put;\n            data += put;\n            len -= put;\n        }\n\n        /* if we need to, add a new empty stored block */\n        if (len) {\n            /* mark current block as not last */\n            if (log_last(log, 0))\n                return -1;\n\n            /* point to new, empty stored block */\n            log->last += 4 + log->stored + 1;\n            log->stored = 0;\n        }\n\n        /* mark last block as last, update its length */\n        if (log_last(log, 1))\n            return -1;\n        BAIL(2);\n    }\n\n    /* write the new crc and length trailer, and truncate just in case (could\n       be recovering from partial append with a missing foo.add file) */\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n\n    /* write the extra field, marking the log file as done, delete .add file */\n    if (log_mark(log, NO_OP))\n        return -1;\n    strcpy(log->end, \".add\");\n    unlink(log->path);          /* ignore error, since may not exist */\n    return 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Demonstrate the use of build_index() and extract() by processing the file\n   provided on the command line, and the extracting 16K from about 2/3rds of\n   the way through the uncompressed output, and writing that to stdout. */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int len;\n    off_t offset;\n    FILE *in;\n    struct access *index = NULL;\n    unsigned char buf[CHUNK];\n\n    /* open input file */\n    if (argc != 2) {\n        fprintf(stderr, \"usage: zran file.gz\\n\");\n        return 1;\n    }\n    in = fopen(argv[1], \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    /* build index */\n    len = build_index(in, SPAN, &index);\n    if (len < 0) {\n        fclose(in);\n        switch (len) {\n        case Z_MEM_ERROR:\n            fprintf(stderr, \"zran: out of memory\\n\");\n            break;\n        case Z_DATA_ERROR:\n            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n            break;\n        case Z_ERRNO:\n            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n            break;\n        default:\n            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n        }\n        return 1;\n    }\n    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n\n    /* use index by reading some bytes from an arbitrary offset */\n    offset = (index->list[index->have - 1].out << 1) / 3;\n    len = extract(in, index, offset, buf, CHUNK);\n    if (len < 0)\n        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n                len == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n    else {\n        fwrite(buf, 1, len, stdout);\n        fprintf(stderr, \"zran: extracted %d bytes at %llu\\n\", len, offset);\n    }\n\n    /* clean up and exit */\n    free_index(index);\n    fclose(in);\n    return 0;\n}", "path": "zlib\\examples\\zran.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Replace the foo.dict file with the foo.temp file.  Also delete the foo.add\n   file, since the compress operation may have been interrupted before that was\n   done.  Returns 1 if memory could not be allocated, or -1 if reading or\n   writing foo.gz fails, or if the rename fails for some reason other than\n   foo.temp not existing.  foo.temp not existing is a permitted error, since\n   the replace operation may have been interrupted after the rename is done,\n   but before foo.gz is marked as complete. */\n", "func_signal": "local int log_replace(struct log *log)", "code": "{\n    int ret;\n    char *dest;\n\n    /* delete foo.add file */\n    strcpy(log->end, \".add\");\n    unlink(log->path);         /* ignore error, since may not exist */\n    BAIL(3);\n\n    /* rename foo.name to foo.dict, replacing foo.dict if it exists */\n    strcpy(log->end, \".dict\");\n    dest = malloc(strlen(log->path) + 1);\n    if (dest == NULL)\n        return -2;\n    strcpy(dest, log->path);\n    strcpy(log->end, \".temp\");\n    ret = rename(log->path, dest);\n    free(dest);\n    if (ret && errno != ENOENT)\n        return -1;\n    BAIL(4);\n\n    /* mark the foo.gz file as done */\n    return log_mark(log, NO_OP);\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Check the log file modify time against what is expected.  Return true if\n   this is not our lock.  If it is our lock, touch it to keep it. */\n", "func_signal": "local int log_check(struct log *log)", "code": "{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    if (stat(log->path, &st) || st.st_mtime != log->lock)\n        return 1;\n    log_touch(log);\n    return 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* See gzlog.h for the description of the external methods below */\n", "func_signal": "gzlog *gzlog_open(char *path)", "code": "{\n    size_t n;\n    struct log *log;\n\n    /* check arguments */\n    if (path == NULL || *path == 0)\n        return NULL;\n\n    /* allocate and initialize log structure */\n    log = malloc(sizeof(struct log));\n    if (log == NULL)\n        return NULL;\n    strcpy(log->id, LOGID);\n    log->fd = -1;\n\n    /* save path and end of path for name construction */\n    n = strlen(path);\n    log->path = malloc(n + 9);              /* allow for \".repairs\" */\n    if (log->path == NULL) {\n        free(log);\n        return NULL;\n    }\n    strcpy(log->path, path);\n    log->end = log->path + n;\n\n    /* gain exclusive access and verify log file -- may perform a\n       recovery operation if needed */\n    if (log_open(log)) {\n        free(log->path);\n        free(log);\n        return NULL;\n    }\n\n    /* return pointer to log structure */\n    return log;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Write over the extra field contents, marking the operation as op.  Use fsync\n   to assure that the device is written to, and in the requested order.  This\n   operation, and only this operation, is assumed to be atomic in order to\n   assure that the log is recoverable in the event of an interruption at any\n   point in the process.  Return -1 if the write to foo.gz failed. */\n", "func_signal": "local int log_mark(struct log *log, int op)", "code": "{\n    int ret;\n    unsigned char ext[EXTRA];\n\n    PUT8(ext, log->first);\n    PUT8(ext + 8, log->last);\n    PUT4(ext + 16, log->ccrc);\n    PUT4(ext + 20, log->clen);\n    PUT4(ext + 24, log->tcrc);\n    PUT4(ext + 28, log->tlen);\n    PUT2(ext + 32, log->stored);\n    ext[34] = log->back - 3 + (op << 3);\n    fsync(log->fd);\n    ret = lseek(log->fd, HEAD, SEEK_SET) < 0 ||\n          write(log->fd, ext, EXTRA) != EXTRA ? -1 : 0;\n    fsync(log->fd);\n    return ret;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Update the modify time of the lock file to now, in order to prevent another\n   task from thinking that the lock is stale.  Save the lock file modify time\n   for verification of ownership. */\n", "func_signal": "local void log_touch(struct log *log)", "code": "{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    utimes(log->path, NULL);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Close the foo.gz file (if open) and release the lock. */\n", "func_signal": "local void log_close(struct log *log)", "code": "{\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n    log_unlock(log);\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Exclusively create foo.lock in order to negotiate exclusive access to the\n   foo.* files.  If the modify time of an existing lock file is greater than\n   PATIENCE seconds in the past, then consider the lock file to have been\n   abandoned, delete it, and try the exclusive create again.  Save the lock\n   file modify time for verification of ownership.  Return 0 on success, or -1\n   on failure, usually due to an access restriction or invalid path.  Note that\n   if stat() or unlink() fails, it may be due to another process noticing the\n   abandoned lock file a smidge sooner and deleting it, so those are not\n   flagged as an error. */\n", "func_signal": "local int log_lock(struct log *log)", "code": "{\n    int fd;\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    while ((fd = open(log->path, O_CREAT | O_EXCL, 0644)) < 0) {\n        if (errno != EEXIST)\n            return -1;\n        if (stat(log->path, &st) == 0 && time(NULL) - st.st_mtime > PATIENCE) {\n            unlink(log->path);\n            continue;\n        }\n        sleep(2);       /* relinquish the CPU for two seconds while waiting */\n    }\n    close(fd);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n    return 0;\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* Compress the len bytes at data and append the compressed data to the\n   foo.gz deflate data immediately after the previous compressed data.  This\n   overwrites the previous uncompressed data, which was stored in foo.add\n   and is the data provided in data[0..len-1].  If this operation is\n   interrupted, it picks up at the start of this routine, with the foo.add\n   file read in again.  If there is no data to compress (len == 0), then we\n   simply terminate the foo.gz file after the previously compressed data,\n   appending a final empty stored block and the gzip trailer.  Return -1 if\n   reading or writing the log.gz file failed, or -2 if there was a memory\n   allocation failure. */\n", "func_signal": "local int log_compress(struct log *log, unsigned char *data, size_t len)", "code": "{\n    int fd;\n    uint got, max;\n    ssize_t dict;\n    off_t end;\n    z_stream strm;\n    unsigned char buf[DICT];\n\n    /* compress and append compressed data */\n    if (len) {\n        /* set up for deflate, allocating memory */\n        strm.zalloc = Z_NULL;\n        strm.zfree = Z_NULL;\n        strm.opaque = Z_NULL;\n        if (deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,\n                         Z_DEFAULT_STRATEGY) != Z_OK)\n            return -2;\n\n        /* read in dictionary (last 32K of data that was compressed) */\n        strcpy(log->end, \".dict\");\n        fd = open(log->path, O_RDONLY, 0);\n        if (fd >= 0) {\n            dict = read(fd, buf, DICT);\n            close(fd);\n            if (dict < 0) {\n                deflateEnd(&strm);\n                return -1;\n            }\n            if (dict)\n                deflateSetDictionary(&strm, buf, (uint)dict);\n        }\n        log_touch(log);\n\n        /* prime deflate with last bits of previous block, position write\n           pointer to write those bits and overwrite what follows */\n        if (lseek(log->fd, log->first - (log->back > 8 ? 2 : 1),\n                SEEK_SET) < 0 ||\n            read(log->fd, buf, 1) != 1 || lseek(log->fd, -1, SEEK_CUR) < 0) {\n            deflateEnd(&strm);\n            return -1;\n        }\n        deflatePrime(&strm, (8 - log->back) & 7, *buf);\n\n        /* compress, finishing with a partial non-last empty static block */\n        strm.next_in = data;\n        max = (((uint)0 - 1) >> 1) + 1; /* in case int smaller than size_t */\n        do {\n            strm.avail_in = len > max ? max : (uint)len;\n            len -= strm.avail_in;\n            do {\n                strm.avail_out = DICT;\n                strm.next_out = buf;\n                deflate(&strm, len ? Z_NO_FLUSH : Z_PARTIAL_FLUSH);\n                got = DICT - strm.avail_out;\n                if (got && write(log->fd, buf, got) != got) {\n                    deflateEnd(&strm);\n                    return -1;\n                }\n                log_touch(log);\n            } while (strm.avail_out == 0);\n        } while (len);\n        deflateEnd(&strm);\n        BAIL(5);\n\n        /* find start of empty static block -- scanning backwards the first one\n           bit is the second bit of the block, if the last byte is zero, then\n           we know the byte before that has a one in the top bit, since an\n           empty static block is ten bits long */\n        if ((log->first = lseek(log->fd, -1, SEEK_CUR)) < 0 ||\n            read(log->fd, buf, 1) != 1)\n            return -1;\n        log->first++;\n        if (*buf) {\n            log->back = 1;\n            while ((*buf & ((uint)1 << (8 - log->back++))) == 0)\n                ;       /* guaranteed to terminate, since *buf != 0 */\n        }\n        else\n            log->back = 10;\n\n        /* update compressed crc and length */\n        log->ccrc = log->tcrc;\n        log->clen = log->tlen;\n    }\n    else {\n        /* no data to compress -- fix up existing gzip stream */\n        log->tcrc = log->ccrc;\n        log->tlen = log->clen;\n    }\n\n    /* complete and truncate gzip stream */\n    log->last = log->first;\n    log->stored = 0;\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (log_last(log, 1) || write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n    BAIL(6);\n\n    /* mark as being in the replace operation */\n    if (log_mark(log, REPLACE_OP))\n        return -1;\n\n    /* execute the replace operation and mark the file as done */\n    return log_replace(log);\n}", "path": "zlib\\examples\\gzlog.c", "repo_name": "jgottula/WinBtrfs", "stars": 19, "license": "None", "language": "c", "size": 1290}
{"docstring": "/* This is an internally used function to create pixmaps. */\n", "func_signal": "GtkWidget*\ncreate_pixmap                          (GtkWidget       *widget,\n                                        const gchar     *filename)", "code": "{\n  gchar *pathname = NULL;\n  GtkWidget *pixmap;\n\n  if (!filename || !filename[0])\n      return gtk_image_new ();\n\n  pathname = find_pixmap_file (filename);\n\n  if (!pathname)\n    {\n      g_warning (_(\"Couldn't find pixmap file: %s\"), filename);\n      return gtk_image_new ();\n    }\n\n  pixmap = gtk_image_new_from_file (pathname);\n  g_free (pathname);\n  return pixmap;\n}", "path": "src\\tspi\\gtk\\support.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* return a unicode string to the Tspi_GetAttribData function */\n", "func_signal": "TSS_RESULT\nobj_policy_get_string(TSS_HPOLICY hPolicy, UINT32 *size, BYTE **data)", "code": "{\n\tTSS_RESULT result = TSS_SUCCESS;\n\tBYTE *utf_string;\n\tUINT32 utf_size;\n\tstruct tsp_object *obj;\n\tstruct tr_policy_obj *policy;\n\n\tif ((obj = obj_list_get_obj(&policy_list, hPolicy)) == NULL)\n\t\treturn TSPERR(TSS_E_INVALID_HANDLE);\n\n\tpolicy = (struct tr_policy_obj *)obj->data;\n\n\t*size = policy->popupStringLength;\n\tif (policy->popupStringLength == 0) {\n\t\t*data = NULL;\n\t} else {\n\t\tutf_size = policy->popupStringLength;\n\t\tutf_string = Trspi_Native_To_UNICODE(policy->popupString,\n\t\t\t\t\t\t     &utf_size);\n\t\tif (utf_string == NULL) {\n\t\t\tresult = TSPERR(TSS_E_INTERNAL_ERROR);\n\t\t\tgoto done;\n\t\t}\n\n\t\t*data = calloc_tspi(obj->tspContext, utf_size);\n\t\tif (*data == NULL) {\n\t\t\tfree(utf_string);\n\t\t\tLogError(\"malloc of %d bytes failed.\", utf_size);\n\t\t\tresult = TSPERR(TSS_E_OUTOFMEMORY);\n\t\t\tgoto done;\n\t\t}\n\n\t\t*size = utf_size;\n\t\tmemcpy(*data, utf_string, utf_size);\n\t\tfree(utf_string);\n\t}\n\ndone:\n\tobj_list_put(&policy_list);\n\n\treturn result;\n}", "path": "src\\tspi\\obj_policy.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "// A3 A4 A5\n", "func_signal": "int print_usage(char *cmd)", "code": "{\n\tfprintf(stderr, \"usage: %s\\n\", cmd);\n\tfprintf(stderr, \"\t\\t-npa,\\t--nb_platform_attr\\tnumber of attributes that the\\\n Platform can choose and which will not be visible to the Issuer (default: %d)\\n\",\n\t\t\tDEFAULT_ISSUER_ATTRIBUTES);\n\tfprintf(stderr, \"\t\\t-nia,\\t--nb_issuer_attr\\tnumber of attributes that the issuer\\\n can choose and which will be visible to both the Platform and the Issuer(default: %d)\\n\",\n\t\t\tDEFAULT_RECEIVER_ATTRIBUTES);\n\tfprintf(stderr, \"\t\\t-if,\\t--issuer_file\\tthe file that will contain all key pair\\\n and proof to be used by the issuer (default: %s)\\n\",\n\t\t\tDEFAULT_FILENAME);\n\tfprintf(stderr, \"\t\\t-i,\\t--issuer\\tissuer identity (default: %s)\\n\",\n\t\t\tDEFAULT_ISSUER);\n\treturn -1;\n}", "path": "src\\tspi\\daa\\daa_issuer\\issuer_setup.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* This method generates small prime numbers up to a specified bounds using the Sieve of\n * Eratosthenes algorithm.\n *\n * prime_bound: the upper bound for the primes to be generated\n * starting_prime: the first prime in the list of primes that is returned\n * return: list of primes up to the specified bound. Each prime is of type bi_ptr\n */\n", "func_signal": "void\ngenerate_small_primes(int prime_bound, int starting_prime)", "code": "{\n\tlist_ptr res;\n\tint length;\n\tint *is_primes;\n\tint i;\n\tint k;\n\tint prime;\n\tnode_t *current;\n\n\tprimes_length = 0;\n\tres = list_new();\n\tif (allocs == NULL) {\n\t\tLogError(\"malloc of list failed\");\n\t\treturn;\n\t}\n\tif ((prime_bound <= 1) || (starting_prime > prime_bound))\n\t\treturn;\n\n\tif (starting_prime <= 2) {\n\t\tstarting_prime = 2;\n\t\tlist_add(res, bi_2);\n\t}\n\tlength = (prime_bound - 1) >> 1; // length = (prime_bound -1) / 2;\n\tis_primes = (int *)malloc(sizeof(int)*length);\n\tif (is_primes == NULL) {\n\t\tLogError(\"malloc of %zd bytes failed\", sizeof(int) * length);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < length; i++)\n\t\tis_primes[i] = 1;\n\n\tfor (i = 0; i < length; i++) {\n\t\tif (is_primes[i] == 1) {\n\t\t\tprime = 2 * i + 3;\n\t\t\tfor (k = i + prime; k < length; k+= prime)\n\t\t\t\tis_primes[k] = 0;\n\n\t\t\tif (prime >= starting_prime) {\n\t\t\t\tlist_add(res, (void *)prime);\n\t\t\t\tprimes_length++;\n\t\t\t}\n\t\t}\n\t}\n\t// converti the list to a table\n\tcurrent = res->head; // go to first node\n\tprimes  = (unsigned long *)malloc(sizeof(unsigned long) * primes_length);\n\tif (primes == NULL) {\n\t\tLogError(\"malloc of %d bytes failed\",\n\t\t\tsizeof(unsigned long)*primes_length);\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (current != NULL) {\n\t\tprimes[i++] = (unsigned long)current->obj;\n\t\tcurrent = current->next; // traverse through the list\n\t}\n\n\tfree(is_primes);\n\tlist_freeall(res);\n}", "path": "src\\tspi\\daa\\daa_issuer\\prime_gen.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* Test whether the provided pDash or p = 2*pDash + 1 are divisible by any of the small primes\n * saved in the listOfSmallPrimes. A limit for the largest prime to be tested against can be\n * specified, but it will be ignored if it exeeds the number of precalculated primes.\n *\n * p_dash: the number to be tested (p_dash)\n * prime_bound: the limit for the small primes to be tested against.\n */\n", "func_signal": "static int\ntest_small_prime_factors(const bi_ptr p_dash, const unsigned long prime_bound)", "code": "{\n\tint sievePassed = 1;\n\tunsigned long r;\n\tunsigned long small_prime;\n\tbi_t temp; bi_new(temp);\n\n\tsmall_prime = 1;\n\tint i = 0;\n\twhile (i < primes_length && small_prime < prime_bound ) {\n\t\tsmall_prime = primes[i++];\n\t\t// r = p_dash % small_prime\n\t\tbi_mod_si(temp, p_dash, small_prime);\n\t\tr = bi_get_si(temp);\n\t\t// test if pDash = 0 (mod smallPrime)\n\t\tif (r == 0) {\n\t\t\tsievePassed = 0;\n\t\t\tbreak;\n\t\t}\n\t\t// test if p = 0 (mod smallPrime) (or r == smallPrime - r - 1)\n\t\tif (r == (small_prime - r - 1)) {\n\t\t\tsievePassed = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbi_free(temp);\n\n\treturn sievePassed;\n}", "path": "src\\tspi\\daa\\daa_issuer\\prime_gen.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/*\nCramer-Shoup EncryptionProof\nfrom com.ibm.zurich.tcg.daa.anonymityrevocation.CSEncryptionProof\n */\n", "func_signal": "CS_ENCRYPTION_RESULT_RANDOMNESS *compute_ecryption_proof(\n\tconst bi_ptr msg,\n\tconst bi_ptr delta1,\n\tconst bi_ptr delta2,\n\tconst bi_ptr delta3,\n\tconst bi_ptr randomness,\n\tconst CS_PUBLIC_KEY *key,\n\tconst struct tdTSS_DAA_PK_internal *daa_key,\n\tconst BYTE *condition,\n\tconst int conditionLength,\n\tconst EVP_MD *digest\n)", "code": "{\n\tif( delta1 == NULL || delta2 == NULL || delta3 == NULL) {\n\t\tLogError(\"Illegal Argument: deltas (delta1:%ld delta2:%ld delta3:%ld)\",\n\t\t\t\t(long)delta1, (long)delta2, (long)delta3);\n\t\treturn NULL;\n\t}\n\tif( bi_cmp( randomness, daa_key->rho) >=0 || bi_cmp_si( randomness, 0) < 0) {\n\t\tLogError(\"randomness >= rho || randomness < 0 \\n\\trandomness:%s\\n\\trho:%s\\n\",\n\t\t\t\tbi_2_dec_char( randomness), bi_2_dec_char( daa_key->rho));\n\t\treturn NULL;\n\t}\n\treturn internal_compute_encryption_proof( msg,\n\t\t\t\t\t\tdelta1,\n\t\t\t\t\t\tdelta2,\n\t\t\t\t\t\tdelta3,\n\t\t\t\t\t\trandomness,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tdaa_key,\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\tconditionLength,\n\t\t\t\t\t\tdigest);\n}", "path": "src\\tspi\\daa\\daa_anonymityrevocation\\csencryption_result.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/*\n * DisplayPINWindow()\n *\n * Popup the dialog to collect an existing password.\n *\n * string - buffer that the password will be passed back to caller in\n * popup - UTF-8 string to be displayed in the title bar of the dialog box\n *\n */\n", "func_signal": "TSS_RESULT\nDisplayPINWindow(BYTE *string, UINT32 *string_len, BYTE *popup)", "code": "{\n  GtkWidget *dialog1;\n  struct userdata ud;\n\n  ud.string_len = 0;\n\n#ifdef ENABLE_NLS\n  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);\n  bind_textdomain_codeset (GETTEXT_PACKAGE, \"UTF-8\");\n  textdomain (GETTEXT_PACKAGE);\n#endif\n\n  gtk_set_locale();\n  gtk_init_check((int *)NULL, (char ***)NULL);\n\n  LogDebug(\"address of string_len: %p\", &ud.string_len);\n  dialog1 = create_password_dialog(&ud, (char *)popup);\n  gtk_widget_show(dialog1);\n\n  gtk_main();\n\n  if (ud.string_len) {\n\t  memcpy(string, ud.string, ud.string_len);\n\t  memset(ud.string, 0, ud.string_len);\n\t  free(ud.string);\n  }\n  *string_len = ud.string_len;\n\n  return TSS_SUCCESS;\n}", "path": "src\\tspi\\gtk\\main.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* This is an internally used function to create pixmaps. */\n", "func_signal": "GdkPixbuf*\ncreate_pixbuf                          (const gchar     *filename)", "code": "{\n  gchar *pathname = NULL;\n  GdkPixbuf *pixbuf;\n  GError *error = NULL;\n\n  if (!filename || !filename[0])\n      return NULL;\n\n  pathname = find_pixmap_file (filename);\n\n  if (!pathname)\n    {\n      g_warning (_(\"Couldn't find pixmap file: %s\"), filename);\n      return NULL;\n    }\n\n  pixbuf = gdk_pixbuf_new_from_file (pathname, &error);\n  if (!pixbuf)\n    {\n      LogError (\"Failed to load pixbuf file: %s: %s\\n\",\n               pathname, error->message);\n      g_error_free (error);\n    }\n  g_free (pathname);\n  return pixbuf;\n}", "path": "src\\tspi\\gtk\\support.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/**\nUsed by RSA_generate_key\nFrom RSA_generate_key documentation:\n-> callback(2, n, cb_arg) is called when n-th randomly generated prime is rejected\n-> callback(3, 0, cb_arg) is called when p is found with p-1 more or less prime to e\n-> callback(3, 1, cb_arg) repeatedly called for prime q\n*/\n", "func_signal": "void callback(int step, int number, void *arg)", "code": "{\n#ifdef DAA_DEBUG\n\tputc( '.', stdout); fflush( stdout);\n#endif\n}", "path": "src\\tspi\\daa\\daa_platform\\test_join.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* Generates a random number of bit_length bit length. The first two bits and the last bit of this\n * number are always set, therefore the number is odd and >= (2^(bit_length-1)+2^(bit_length-2)+1)\n *\n * bit_length: The length of the number to be generated, in bits\n * return: a random number of bitLength bit length with first and last bits set\n */\n", "func_signal": "void\nrandom_odd_bi(bi_ptr bi, int bit_length)", "code": "{\n\tif (bit_length > 0) {\n\t\tbi_urandom(bi, bit_length);\n\t\t//bi_generate_prime(bi, bit_length);\n\t\tbi_setbit(bi, 0);\n\t\tbi_setbit(bi, bit_length - 1);\n\t\tbi_setbit(bi, bit_length - 2);\n\t}\n}", "path": "src\\tspi\\daa\\daa_issuer\\prime_gen.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/*\nVerifies if the parameters Z,R0,R1,RReceiver and RIssuer of the public key\nwere correctly computed.\npk: the public key, which one wants to verfy.\n*/\n", "func_signal": "TSS_RESULT\nis_pk_correct( TSS_DAA_PK_internal *public_key,\n\t\tTSS_DAA_PK_PROOF_internal *proof,\n\t\tint *isCorrect\n)", "code": "{\n\tint bit_size_message_digest = DAA_PARAM_SIZE_MESSAGE_DIGEST;\n\tbi_ptr n = public_key->modulus;\n\tint num_of_variables;\n\tint i,j;\n\tTSS_RESULT result = TSS_SUCCESS;\n\tBYTE verifiable_challenge[EVP_MAX_MD_SIZE];\n\tint length_challenge;\n\tbi_array_ptr verifiable_numbers;\n\tbi_array_ptr *verification_commitments = NULL;\n\tbi_array_ptr generators = NULL;\n\tbi_t tmp;\n\tbi_t tmp1;\n#ifdef DAA_DEBUG\n\tFILE *f;\n\tbi_array_ptr *commitments;\n#endif\n\n\tbi_new( tmp);\n\tbi_new( tmp1);\n\t*isCorrect = 0;\n#ifdef DAA_DEBUG\n\tf=fopen(\"/tmp/commits\", \"r\");\n\tcommitments = (bi_array_ptr *)malloc( sizeof(bi_array_ptr) * num_of_variables);\n\tif (commitments == NULL) {\n\t\tLogError(\"malloc of %d bytes failed\", sizeof(bi_array_ptr) * num_of_variables);\n\t\tresult = TSPERR(TSS_E_OUTOFMEMORY);\n\t\tgoto close;\n\t}\n\tfor( i=0; i<num_of_variables; i++) {\n\t\tcommitments[i] = ALLOC_BI_ARRAY();\n\t\tBI_LOAD_ARRAY( commitments[i], f);\n\t}\n\tfclose(f);\n\tDUMP_BI( n);\n#endif\n\tLogDebug(\"STEP 1 ( Tspi_DAA_IssuerKeyVerification spec.)\");\n\tif( !bi_is_probable_prime( public_key->capitalGamma)) {\n\t\tLogError( \"pk->capitalGamma not prime\\ncapitalGamma=\\n%s\",\n\t\t\t\tbi_2_hex_char( public_key->capitalGamma));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( !bi_is_probable_prime( public_key->rho)) {\n\t\tLogError( \"pk->rho not prime\\nrho=\\n%s\",\n\t\t\t\tbi_2_hex_char( public_key->rho));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\t// (capitalGamma - 1) %  rho should be equal to 0\n\tif( !bi_equals( bi_mod( tmp1, bi_sub( tmp1, public_key->capitalGamma, bi_1),\n\t\t\t\tpublic_key->rho),\n\t\t\tbi_0)) {\n\t\tLogError( \"(capitalGamma - 1) %%  rho != 0\\nActual value:\\n%s\",\n\t\t\t\tbi_2_hex_char( tmp1));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t}\n\t// (gamma ^ rho) % capitalGamma should be equals to 1\n\tif ( !bi_equals( bi_mod_exp( tmp1, public_key->gamma,\n\t\t\t\t\t\tpublic_key->rho,\n\t\t\t\t\t\tpublic_key->capitalGamma),\n\t\t\t\tbi_1) ) {\n\t\tLogError( \"(gamma ^ rho) %% capitalGamma != 1\\nActual value:\\n%s\",\n\t\t\t\tbi_2_hex_char( tmp1));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\t// (gamma ^ rho) % capitalGamma should be equal to 1\n\tif ( !bi_equals( bi_mod_exp( tmp1,\n\t\t\t\t\t\tpublic_key->gamma,\n\t\t\t\t\t\tpublic_key->rho,\n\t\t\t\t\t\tpublic_key->capitalGamma),\n\t\t\t\tbi_1) ) {\n\t\tLogError( \"(gamma ^ rho) %% capitalGamma != 1\\nActual value:\\n%s\",\n\t\t\t\tbi_2_hex_char( tmp1));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tLogDebug(\"STEP 2 check whether all public key parameters have the required length\");\n\tif( bi_nbin_size( n) != DAA_PARAM_SIZE_RSA_MODULUS / 8) {\n\t\tLogError( \"size( n)[%ld] != DAA_PARAM_SIZE_RSA_MODULUS[%d]\",\n\t\t\tbi_nbin_size( n),\n\t\t\tDAA_PARAM_SIZE_RSA_MODULUS / 8);\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( bi_cmp( n, bi_shift_left( tmp1, bi_1, DAA_PARAM_SIZE_RSA_MODULUS))\n\t\t>= 0) {\n\t\tLogError( \"n[%ld] != DAA_PARAM_SIZE_RSA_MODULUS[%d]\",\n\t\t\tbi_nbin_size( n),\n\t\t\tDAA_PARAM_SIZE_RSA_MODULUS);\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( bi_cmp( n, bi_shift_left( tmp1, bi_1, DAA_PARAM_SIZE_RSA_MODULUS - 1 ))\n\t\t<= 0) {\n\t\tLogError( \"n[%ld] != DAA_PARAM_SIZE_RSA_MODULUS[%d]\",\n\t\t\tbi_nbin_size( n),\n\t\t\tDAA_PARAM_SIZE_RSA_MODULUS);\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\t// rho\n\tif( bi_nbin_size( public_key->rho) * 8 != DAA_PARAM_SIZE_RHO) {\n\t\tLogError( \"size( rho)[%ld] != DAA_PARAM_SIZE_RHO[%d]\",\n\t\t\tbi_nbin_size( public_key->rho) * 8,\n\t\t\tDAA_PARAM_SIZE_RHO);\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\t// Gamma\n\tif( bi_nbin_size( public_key->capitalGamma) * 8 != DAA_PARAM_SIZE_MODULUS_GAMMA) {\n\t\tLogError( \"size( rho)[%ld] != DAA_PARAM_SIZE_MODULUS_GAMMA[%d]\",\n\t\t\tbi_nbin_size( public_key->capitalGamma) * 8,\n\t\t\tDAA_PARAM_SIZE_MODULUS_GAMMA);\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( is_range_correct( public_key->capitalS, n) == 0) {\n\t\tLogError( \"range not correct( pk->capitalS)\\ncapitalS=\\n%s\\nn=\\n%s\",\n\t\t\tbi_2_hex_char( public_key->capitalS),\n\t\t\tbi_2_hex_char( n));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( is_range_correct( public_key->capitalZ, n) == 0) {\n\t\tLogError( \"range not correct( pk->capitalZ)\\ncapitalZ=\\n%s\\nn=\\n%s\",\n\t\t\tbi_2_hex_char( public_key->capitalZ),\n\t\t\tbi_2_hex_char( n));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( is_range_correct( public_key->capitalR0, n) == 0) {\n\t\tLogError( \"range not correct( pk->capitalR0)\\ncapitalR0=\\n%s\\nn=\\n%s\",\n\t\t\tbi_2_hex_char( public_key->capitalR0),\n\t\t\tbi_2_hex_char( n));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tif( is_range_correct( public_key->capitalR1, n) == 0) {\n\t\tLogError( \"range not correct( pk->capitalR1)\\ncapitalR1=\\n%s\\nn=\\n%s\",\n\t\t\tbi_2_hex_char( public_key->capitalR1),\n\t\t\tbi_2_hex_char( n));\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tfor( i=0; i<public_key->capitalY->length; i++) {\n\t\tif( is_range_correct( public_key->capitalY->array[i], n) == 0) {\n\t\t\tLogError( \"range not correct(pk->capitalY[%d])\\ncapitalY[%d]=\\n%s\\nn=\\n%s\",\n\t\t\t\ti, i,\n\t\t\t\tbi_2_hex_char( public_key->capitalY->array[i]),\n\t\t\t\tbi_2_hex_char( n));\n\t\t\tresult = TSS_E_BAD_PARAMETER;\n\t\t\tgoto close;\n\t\t}\n\t}\n\tLogDebug(\"STEP 3 - compute verification commitments\");\n\t// only the array is allocated, but all refs are  pointing to public_key numbers\n\tgenerators = get_generators( public_key);\n\tverifiable_numbers = get_verifiable_numbers( public_key);\n\tnum_of_variables = verifiable_numbers->length;\n\tverification_commitments = (bi_array_ptr *)malloc( sizeof(bi_array_ptr)*num_of_variables);\n\tif (verification_commitments == NULL) {\n\t\tLogError(\"malloc of %d bytes failed\", sizeof(bi_array_ptr)*num_of_variables);\n\t\tresult = TSPERR(TSS_E_OUTOFMEMORY);\n\t\tgoto close;\n\t}\n\tfor( i = 0; i<num_of_variables; i++) {\n\t\tverification_commitments[i] = ALLOC_BI_ARRAY();\n\t\tbi_new_array( verification_commitments[i], bit_size_message_digest);\n\t\tfor( j = 0; j<bit_size_message_digest; j++) {\n#ifdef DAA_DEBUG\n\t\t\tprintf( \"[# i=%d j=%d test_bit:%d]\",\n\t\t\t\ti, j, test_bit( j, proof->challenge, proof->length_challenge));\n#endif\n\t\t\tbi_mod_exp( verification_commitments[i]->array[j],\n\t\t\t\tgenerators->array[i],\n\t\t\t\tproof->response[i]->array[j], n);\n\t\t\tif( test_bit( j, proof->challenge, proof->length_challenge)) {\n\t\t\t\tbi_mul( verification_commitments[i]->array[j],\n\t\t\t\t\tverification_commitments[i]->array[j],\n\t\t\t\t\tverifiable_numbers->array[i]);\n#ifdef DAA_DEBUG\n\t\t\t\tDUMP_BI( verification_commitments[i]->array[j]);\n#endif\n\t\t\t\tbi_mod( verification_commitments[i]->array[j],\n\t\t\t\t\tverification_commitments[i]->array[j],\n\t\t\t\t\tn);\n\t\t\t}\n#ifdef DAA_DEBUG\n\t\t\tif( commitments != NULL &&\n\t\t\t\tbi_equals( verification_commitments[i]->array[j],\n\t\t\t\t\t\tcommitments[i]->array[j]) ==0) {\n\t\t\t\tLogError( \"!! ERROR i=%d j=%d\\n\", i, j);\n\t\t\t\tDUMP_BI( commitments[i]->array[j]);\n\t\t\t\tDUMP_BI( verification_commitments[i]->array[j]);\n\t\t\t\tDUMP_BI( generators->array[i]);\n\t\t\t\tDUMP_BI( proof->response[i]->array[j]);\n\t\t\t\tDUMP_BI( verifiable_numbers->array[i]);\n\t\t\t}\n\t\t\tprintf( \"o\"); fflush( stdout);\n#endif\n\t\t}\n\t}\n\t// STEP 3 - d\n\tgenerateMessageDigest( verifiable_challenge,\n\t\t\t\t\t\t&length_challenge,\n\t\t\t\t\t\tpublic_key,\n\t\t\t\t\t\tverification_commitments,\n\t\t\t\t\t\tnum_of_variables);\n\tLogDebug(\"verifiable challenge=%s\",\n\t\t\tdump_byte_array( length_challenge, verifiable_challenge));\n\tLogDebug(\"           challenge=%s\",\n\t\t\tdump_byte_array( proof->length_challenge, proof->challenge));\n\tif( length_challenge != proof->length_challenge) {\n\t\tresult = TSS_E_BAD_PARAMETER;\n\t\tgoto close;\n\t}\n\tfor( i=0; i<length_challenge; i++) {\n\t\tif( verifiable_challenge[i] != proof->challenge[i]) {\n\t\t\tresult = TSS_E_BAD_PARAMETER;\n\t\t\tgoto close;\n\t\t}\n\t}\n\t*isCorrect = ( memcmp( verifiable_challenge, proof->challenge, length_challenge) == 0);\nclose:\n\tif( verification_commitments != NULL) {\n\t\tfor( i = 0; i<num_of_variables; i++) {\n\t\t\tbi_free_array( verification_commitments[i]);\n\t\t}\n\t\tfree( verification_commitments);\n\t}\n\tif( generators != NULL) free( generators);\n\tbi_free( tmp1);\n\tbi_free( tmp);\n\treturn result;\n}", "path": "src\\tspi\\daa\\daa_issuer\\key_correctness_proof.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* This is an internally used function to find pixmap files. */\n", "func_signal": "static gchar*\nfind_pixmap_file                       (const gchar     *filename)", "code": "{\n  GList *elem;\n\n  /* We step through each of the pixmaps directory to find it. */\n  elem = pixmaps_directories;\n  while (elem)\n    {\n      gchar *pathname = g_strdup_printf (\"%s%s%s\", (gchar*)elem->data,\n                                         G_DIR_SEPARATOR_S, filename);\n      if (g_file_test (pathname, G_FILE_TEST_EXISTS))\n        return pathname;\n      g_free (pathname);\n      elem = elem->next;\n    }\n  return NULL;\n}", "path": "src\\tspi\\gtk\\support.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* Use this function to set the directory containing installed pixmaps. */\n", "func_signal": "void\n__tspi_add_pixmap_directory                   (const gchar     *directory)", "code": "{\n  pixmaps_directories = g_list_prepend (pixmaps_directories,\n                                        g_strdup (directory));\n}", "path": "src\\tspi\\gtk\\support.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/*\n * DisplayNewPINWindow()\n *\n * Popup the dialog to collect a new password.\n *\n * string - buffer that the password will be passed back to caller in\n * popup - UTF-8 string to be displayed in the title bar of the dialog box\n *\n */\n", "func_signal": "TSS_RESULT\nDisplayNewPINWindow(BYTE *string, UINT32 *string_len, BYTE *popup)", "code": "{\n  GtkWidget *dialog1;\n  struct userdata ud;\n\n  ud.string_len = 0;\n\n#ifdef ENABLE_NLS\n  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);\n  bind_textdomain_codeset (GETTEXT_PACKAGE, \"UTF-8\");\n  textdomain (GETTEXT_PACKAGE);\n#endif\n\n  gtk_set_locale();\n  gtk_init_check((int *)NULL, (char ***)NULL);\n\n  LogDebug(\"address of string_len: %p\", &ud.string_len);\n  dialog1 = create_new_password_dialog(&ud, (char *)popup);\n  gtk_widget_show(dialog1);\n\n  gtk_main();\n\n  if (ud.string_len) {\n\t  memcpy(string, ud.string, ud.string_len);\n\t  memset(ud.string, 0, ud.string_len);\n\t  free(ud.string);\n  }\n  *string_len = ud.string_len;\n\n  return TSS_SUCCESS;\n}", "path": "src\\tspi\\gtk\\main.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* computes an array of random numbers in the range of [1,element] */\n", "func_signal": "void compute_random_numbers( bi_array_ptr result, int quantity, const bi_ptr element)", "code": "{\n\tint i=0;\n\n\tfor( i=0; i<quantity; i++) {\n\t\tcompute_random_number( result->array[i], element);\n\t\tbi_inc( result->array[i]);\t\t\t\t\t\t\t// array[i]++\n\t}\n}", "path": "src\\tspi\\daa\\daa_issuer\\key_correctness_proof.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* This is used to set ATK action descriptions. */\n", "func_signal": "void\nglade_set_atk_action_description       (AtkAction       *action,\n                                        const gchar     *action_name,\n                                        const gchar     *description)", "code": "{\n  gint n_actions, i;\n\n  n_actions = atk_action_get_n_actions (action);\n  for (i = 0; i < n_actions; i++)\n    {\n      if (!strcmp (atk_action_get_name (action, i), action_name))\n        atk_action_set_description (action, i, description);\n    }\n}", "path": "src\\tspi\\gtk\\support.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* The main method to compute a random safe prime of the specified bit length.\n * IMPORTANT: The computer prime will have two first bits and the last bit set to 1 !!\n * i.e. > (2^(bitLength-1)+2^(bitLength-2)+1). This is done to be sure that if two primes of\n * bitLength n are multiplied, the result will have the bitLenght of 2*n exactly This\n * implementation uses the algorithm proposed by Ronald Cramer and Victor Shoup in \"Signature\n * Schemes Based on the strong RSA Assumption\" May 9, 2000.\n *\n * bitLength: the bit length of the safe prime to be computed.\n * return: a number which is considered to be safe prime\n */\n", "func_signal": "bi_ptr\ncompute_safe_prime(bi_ptr p, int bit_length)", "code": "{\n\tbi_ptr p_dash;\n\tbi_ptr temp_p;\n\tbi_ptr p_minus_1;\n\tint stop;\n\tunsigned long prime_bound;\n\n\tLogDebug(\"compute Safe Prime: length: %d bits\\n\", bit_length);\n\n\tp_dash = bi_new_ptr();\n\ttemp_p = bi_new_ptr();\n\tp_minus_1 = bi_new_ptr();\n\n\t/* some heuristic checks to limit the number of small primes to check against and the\n\t * number of Miller-Rabin primality tests at the end */\n\tif (bit_length <= 256) {\n\t\tprime_bound = 768;\n\t} else if (bit_length <= 512) {\n\t\tprime_bound = 3072;\n\t} else if (bit_length <= 768) {\n\t\tprime_bound = 6144;\n\t} else if (bit_length <= 1024) {\n\t\tprime_bound = 1024;\n\t} else {\n\t\tprime_bound = 16384;\n\t}\n\n\tdo {\n\t\tstop = 0;\n\t\t/* p_dash = generated random with basic bit settings (odd) */\n\t\trandom_odd_bi(p_dash, bit_length - 1);\n\n\t\tif (test_small_prime_factors(p_dash, prime_bound) == 0)  {\n\t\t\tLogDebugFn(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* test if p_dash or p are divisible by some small primes */\n\t\tif (is_miller_rabin_witness(bi_2, p_dash)) {\n\t\t\tLogDebugFn(\"2\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* test if 2^(pDash) = +1/-1 (mod p)\n\t\t * bi can not handle negative operation, we compare to (p-1) instead of -1\n\t\t * calculate p = 2*pDash+1 -> (pDash << 1) + 1\n\t\t */\n\t\tbi_shift_left(p, p_dash, 1);\n\t\tbi_add(p, p, bi_1);\n\n\t\t// p_minus_1:= p - 1\n\t\tbi_sub(p_minus_1, p, bi_1);\n\n\t\t//  temp_p := ( 2 ^ p_dash ) mod p\n\t\tbi_mod_exp(temp_p, bi_2, p_dash, p);\n\t\tif (!bi_equals_si(temp_p, 1)  && !bi_equals(temp_p, p_minus_1) ) {\n\t\t\tLogDebugFn(\"3\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t// test if pDash or p are divisible by some small primes\n\t\tif (is_miller_rabin_witness(bi_2, p_dash)) {\n\t\t\tLogDebugFn(\"4\");\n\t\t\tcontinue;\n\t\t}\n\t\t// test the library dependent probable_prime\n\t\tif (bi_is_probable_prime(p_dash))\n\t\t\tstop = 1;\n\t} while (stop == 0);\n\n\tbi_free(p_minus_1);\n\tbi_free(temp_p);\n\tbi_free(p_dash);\n\n\tLogDebug(\"found Safe Prime: %s bits\", bi_2_hex_char(p));\n\n\treturn p;\n}", "path": "src\\tspi\\daa\\daa_issuer\\prime_gen.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* Tests if a is a Miller-Rabin witness for n\n *\n * a: number which is supposed to be the witness\n * n: number to be tested against\n * return: true if a is Miller-Rabin witness for n, false otherwise\n */\n", "func_signal": "int\nis_miller_rabin_witness(const bi_ptr a, const bi_ptr n)", "code": "{\n\tbi_t n_1;\n\tbi_t temp;\n\tbi_t _2_power_t;\n\tbi_t u;\n\tbi_t x0;\n\tbi_t x1;\n\tint t = -1;\n\tint i;\n\n\tbi_new(n_1);\n\tbi_new(temp);\n\tbi_new(_2_power_t);\n\tbi_new(u);\n\n\t// n1 = n - 1\n\tbi_sub_si(n_1, n, 1);\n\n\t// test if n-1 = 2^t*u with t >= 1 && u even\n\tdo {\n\t\tt++;\n\t\t// _2_power_t = bi_1 << t  ( ==  2 ^ t)\n\t\tbi_shift_left(_2_power_t, bi_1, t);\n\t\t// u = n_1 / (2 ^ t)\n\t\tbi_div(u, n_1, _2_power_t);\n\t} while (bi_equals_si(bi_mod(temp, u, bi_2), 0));\n\n\tbi_new(x0);\n\tbi_new(x1);\n\n\t// x1 = (a ^ u ) % n\n\tbi_mod_exp(x1, a, u, n);\n\n\t// finished to use u, _2_power_t and temp\n\tbi_free(u);\n\tbi_free(_2_power_t);\n\tbi_free(temp);\n\tfor (i = 0; i < t; i++) {\n\t\tbi_set(x0, x1);\n\n\t\t// x1 = (x0 ^ 2) % n\n\t\tbi_mod_exp(x1, x0, bi_2, n);\n\t\tif (bi_equals_si(x1, 1) && !bi_equals_si(x0, 1) && !bi_equals(x0, n_1) != 0) {\n\t\t\tbi_free(x0);\n\t\t\tbi_free(x1);\n\t\t\tbi_free(n_1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tbi_free(x0);\n\tbi_free(x1);\n\tbi_free(n_1);\n\n\tif (!bi_equals(x1, bi_1))\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "src\\tspi\\daa\\daa_issuer\\prime_gen.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* encrypt some data with the RSA public key of 'key', using the padding appropriate for the key */\n", "func_signal": "TSS_RESULT\n__tspi_rsa_encrypt(TSS_HKEY key,\n\t    UINT32   inDataLen,\n\t    BYTE*    inData,\n\t    UINT32*  outDataLen,\n\t    BYTE*    outData)", "code": "{\n\tBYTE *blob;\n\tUINT32 blobLen;\n\tUINT64 offset;\n\tTSS_RESULT result;\n\tTSS_HCONTEXT tspContext;\n\tTPM_PUBKEY pubKey;\n\n\tif (!inData || !outDataLen || !outData)\n\t\treturn TSPERR(TSS_E_INTERNAL_ERROR);\n\n\tif ((result = obj_rsakey_get_tsp_context(key, &tspContext)))\n\t\treturn result;\n\n\tif ((result = obj_rsakey_get_pub_blob(key, &blobLen, &blob)))\n\t\treturn result;\n\n\toffset = 0;\n\tif ((result = Trspi_UnloadBlob_PUBKEY(&offset, blob, &pubKey))) {\n\t\tfree_tspi(tspContext, blob);\n\t\treturn result;\n\t}\n\tfree_tspi(tspContext, blob);\n\n\tif (pubKey.pubKey.keyLength < inDataLen) {\n\t\tresult = TSPERR(TSS_E_ENC_INVALID_LENGTH);\n\t\tgoto done;\n\t}\n\n\tif (pubKey.algorithmParms.encScheme == TPM_ES_RSAESPKCSv15 ||\n\t    pubKey.algorithmParms.encScheme == TSS_ES_RSAESPKCSV15) {\n\t\tif ((result = Trspi_RSA_PKCS15_Encrypt(inData, inDataLen, outData, outDataLen,\n\t\t\t\t\t\t       pubKey.pubKey.key, pubKey.pubKey.keyLength)))\n\t\t\tgoto done;\n\t} else {\n\t\tif ((result = Trspi_TPM_RSA_OAEP_Encrypt(inData, inDataLen, outData, outDataLen,\n\t\t\t\t\t\t\t pubKey.pubKey.key,\n\t\t\t\t\t\t\t pubKey.pubKey.keyLength)))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tfree(pubKey.pubKey.key);\n\tfree(pubKey.algorithmParms.parms);\n\treturn result;\n}", "path": "src\\tspi\\tsp_asym.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* Compute key chain. */\n", "func_signal": "static int init_key_chain(int length_key_chain, Issuer *issuer)", "code": "{\n\tBYTE *signature;\n\tint i, len_sign, ret;\n\tBYTE *modulus;\n\tBYTE *message;\n\t// generate RSA key of length  DAA_PARAM_KEY_SIZE with exponent\n\t// 65537 (java.security.spec.RSAKeyGenParameterSpec.F4)\n\tunsigned long e = 65537;\n\tRSA *rsa;\n\tbi_ptr bi;\n\tEVP_MD_CTX ctx;\n\tint len_message = EVP_MD_size( EVP_sha1());\n\tint current_len_message;\n\n\tEVP_MD_CTX_init(&ctx);\n\tmessage = (BYTE *)malloc(len_message);\n\tif( length_key_chain < 1) {\n\t\tfree( message);\n\t\treturn -1;\n\t}\n\tissuer->length_key_chain = length_key_chain;\n\tissuer->key_chain = (RSA **)malloc(sizeof(RSA *) * length_key_chain);\n\tissuer->pk_signatures = (BYTE **)malloc(sizeof(BYTE *) * length_key_chain);\n\tfor(i = 0; i<length_key_chain; i++) {\n\t\trsa = RSA_generate_key( DAA_PARAM_KEY_SIZE, e, &callback, NULL);\n\t\tif( (BN_num_bits(rsa->n) + 7) / 8 != (DAA_PARAM_KEY_SIZE + 7) / 8) {\n\t\t\tLogError(\"BN_num_bits(rsa->n) + 7) / 8 != (DAA_PARAM_KEY_SIZE + 7) / 8)\");\n\t\t\treturn -1;\n\t\t}\n\t\tissuer->key_chain[i] = rsa;\n\t\tif( i > 0) {\n\t\t\tsignature = (BYTE *)malloc( RSA_size(rsa));\n\t\t\tmodulus = (BYTE *)malloc( DAA_PARAM_KEY_SIZE / 8);\n\t\t\t// signature algorithm from Issuer.java -  \"SHA1withRSA\"\n\t\t\t// sign the modulus (n) of the RSA key with the previous RSA key (chain)\n\t\t\t// \tsign rsa(i)->n with auth_key_pairs[i-1]\n\t\t\tLogDebug(\"modulus=%s\\n\", dump_byte_array(256, modulus));\n\t\t\tLogDebug(\"signature=%s\\n\", dump_byte_array(256, signature));\n\t\t\tbi = bi_new_ptr();\n\t\t\tbi_set_as_hex( bi, BN_bn2hex( rsa->n));\n\t\t\tbi_2_byte_array( modulus, DAA_PARAM_KEY_SIZE / 8, bi);\n\t\t\tLogDebug(\"bi=%s\", bi_2_hex_char( bi));\n\t\t\tbi_free_ptr(  bi);\n\t\t\tEVP_DigestInit_ex(&ctx, EVP_sha1(), NULL);\n\t\t\tEVP_DigestUpdate(&ctx, modulus, DAA_PARAM_KEY_SIZE / 8);\n\t\t\tEVP_DigestFinal_ex(&ctx, message, &current_len_message);\n\t\t\tret = RSA_sign( NID_sha1, message, current_len_message,\n\t\t\t\t\tsignature, &len_sign, issuer->key_chain[i-1]);\n\t\t\tif( ret == 0) {\n\t\t\t\tLogError(\"Error in RSA_sign: %s\",\n\t\t\t\t\tERR_error_string( ERR_get_error(), NULL));\n\t\t\t}\n\t\t\tLogDebug(\"Sign rsa->n (length=%d) with signature (length=%d,\\\n truelength=%d message_len=%d) ret = %d ERROR?=%s\",\n\t\t\t\tRSA_size(rsa),\n\t\t\t\tDAA_PARAM_KEY_SIZE / 8,\n\t\t\t\tlen_sign,\n\t\t\t\tcurrent_len_message,\n\t\t\t\tret,\n\t\t\t\tERR_error_string( ERR_get_error(),\n\t\t\t\tNULL) );\n\t\t\tLogDebug(\"message=%s\\n\", dump_byte_array(256, message));\n\t\t\tLogDebug(\"signature=%s\\n\",dump_byte_array(256, signature));\n\t\t\tissuer->pk_signatures[i-1] = signature;\n\t\t}\n\t}\n\tfree( message);\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn 0;\n}", "path": "src\\tspi\\daa\\daa_platform\\test_join.c", "repo_name": "srajiv/trousers", "stars": 21, "license": "other", "language": "c", "size": 3684}
{"docstring": "/* readdir */\n", "func_signal": "__private_extern__\nint\nfuse_internal_readdir(vnode_t                 vp,\n                      uio_t                   uio,\n                      vfs_context_t           context,\n                      struct fuse_filehandle *fufh,\n                      struct fuse_iov        *cookediov,\n                      int                    *numdirent)", "code": "{\n    int err = 0;\n    struct fuse_dispatcher fdi;\n    struct fuse_read_in   *fri;\n    struct fuse_data      *data;\n\n    if (uio_resid(uio) == 0) {\n        return 0;\n    }\n\n    fuse_dispatcher_init(&fdi, 0);\n\n    /* Note that we DO NOT have a UIO_SYSSPACE here (so no need for p2p I/O). */\n\n    while (uio_resid(uio) > 0) {\n\n        fdi.iosize = sizeof(*fri);\n        fuse_dispatcher_make_vp(&fdi, FUSE_READDIR, vp, context);\n\n        fri = fdi.indata;\n        fri->fh = fufh->fh_id;\n        fri->offset = uio_offset(uio);\n        data = fuse_get_mpdata(vnode_mount(vp));\n        fri->size = (typeof(fri->size))min((size_t)uio_resid(uio), data->iosize);\n\n        if ((err = fuse_dispatcher_wait_answer(&fdi))) {\n            goto out;\n        }\n\n        if ((err = fuse_internal_readdir_processdata(vp,\n                                                     uio,\n                                                     fri->size,\n                                                     fdi.answer,\n                                                     fdi.iosize,\n                                                     cookediov,\n                                                     numdirent))) {\n            break;\n        }\n    }\n\n/* done: */\n\n    fuse_ticket_drop(fdi.ticket);\n\nout:\n    return ((err == -1) ? 0 : err);\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Unlock a pair of fusenodes.\n */\n", "func_signal": "__private_extern__\nvoid\nfusefs_unlockpair(fusenode_t cp1, fusenode_t cp2)", "code": "{\n    fusefs_unlock(cp1);\n    if (cp2 != cp1) {\n        fusefs_unlock(cp2);\n    }\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* other */\n", "func_signal": "static int\nfuse_internal_print_vnodes_callback(vnode_t vp, __unused void *cargs)", "code": "{\n    struct fuse_vnode_data *fvdat = VTOFUD(vp);\n    const char *vname = vnode_getname(vp);\n\n    if (vname) {\n        log(\"fuse4x: vp=%p ino=%lld parent=%lld inuse=%d %s\\n\",\n              vp, fvdat->nodeid, fvdat->parent_nodeid,\n              vnode_isinuse(vp, 0), vname);\n    } else {\n        if (fvdat->nodeid == FUSE_ROOT_ID) {\n            log(\"fuse4x: vp=%p ino=%lld parent=%lld inuse=%d /\\n\",\n                  vp, fvdat->nodeid, fvdat->parent_nodeid,\n                  vnode_isinuse(vp, 0));\n        } else {\n            log(\"fuse4x: vp=%p ino=%lld parent=%lld inuse=%d\\n\",\n                  vp, fvdat->nodeid, fvdat->parent_nodeid,\n                  vnode_isinuse(vp, 0));\n        }\n    }\n\n    if (vname) {\n        vnode_putname(vname);\n    }\n\n    return VNODE_RETURNED;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Acquire 4 fusenode locks.\n *   - locked in fusenode parent-child order (if there is a relationship)\n *     otherwise lock in fusenode address order (lesser address first).\n *   - all or none of the locks are taken\n *   - only one lock taken per fusenode (dup fusenodes are skipped)\n *   - some of the fusenode pointers may be null\n */\n", "func_signal": "__private_extern__\nint\nfusefs_lockfour(fusenode_t cp1, fusenode_t cp2, fusenode_t cp3, fusenode_t cp4,\n                enum fusefslocktype locktype)", "code": "{\n    fusenode_t a[3];\n    fusenode_t b[3];\n    fusenode_t list[4];\n    fusenode_t tmp;\n    int i, j, k;\n    int error;\n\n    if (fusefs_isordered(cp1, cp2)) {\n        a[0] = cp1; a[1] = cp2;\n    } else {\n        a[0] = cp2; a[1] = cp1;\n    }\n\n    if (fusefs_isordered(cp3, cp4)) {\n        b[0] = cp3; b[1] = cp4;\n    } else {\n        b[0] = cp4; b[1] = cp3;\n    }\n\n    a[2] = (fusenode_t)0xffffffff;  /* sentinel value */\n    b[2] = (fusenode_t)0xffffffff;  /* sentinel value */\n\n    /*\n     * Build the lock list, skipping over duplicates\n     */\n    for (i = 0, j = 0, k = 0; (i < 2 || j < 2); ) {\n        tmp = fusefs_isordered(a[i], b[j]) ? a[i++] : b[j++];\n        if (k == 0 || tmp != list[k-1])\n            list[k++] = tmp;\n    }\n\n    /*\n     * Now we can lock using list[0 - k].\n     * Skip over NULL entries.\n     */\n    for (i = 0; i < k; ++i) {\n        if (list[i])\n            if ((error = fusefs_lock(list[i], locktype))) {\n                /* Drop any locks we acquired. */\n                while (--i >= 0) {\n                    if (list[i])\n                        fusefs_unlock(list[i]);\n                }\n                return error;\n            }\n    }\n\n    return 0;\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Lock a fusenode.\n */\n", "func_signal": "__private_extern__\nint\nfusefs_lock(fusenode_t cp, enum fusefslocktype locktype)", "code": "{\n    void *thread = current_thread();\n\n    if (locktype == FUSEFS_SHARED_LOCK) {\n        lck_rw_lock_shared(cp->nodelock);\n        cp->nodelockowner = FUSEFS_SHARED_OWNER;\n    } else {\n        lck_rw_lock_exclusive(cp->nodelock);\n        cp->nodelockowner = thread;\n    }\n\n    /*\n     * Skip nodes that no longer exist (were deleted).\n     */\n    if ((locktype != FUSEFS_FORCE_LOCK) && (cp->c_flag & C_NOEXISTS)) {\n        fusefs_unlock(cp);\n        return ENOENT;\n    }\n\n    return 0;\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* rename */\n", "func_signal": "__private_extern__\nint\nfuse_internal_rename(vnode_t               fdvp,\n            __unused vnode_t               fvp,\n                     struct componentname *fcnp,\n                     vnode_t               tdvp,\n            __unused vnode_t               tvp,\n                     struct componentname *tcnp,\n                     vfs_context_t         context)", "code": "{\n    struct fuse_dispatcher fdi;\n    struct fuse_rename_in *fri;\n    int err = 0;\n\n    fuse_dispatcher_init(&fdi, sizeof(*fri) + fcnp->cn_namelen + tcnp->cn_namelen + 2);\n    fuse_dispatcher_make_vp(&fdi, FUSE_RENAME, fdvp, context);\n\n    fri = fdi.indata;\n    fri->newdir = VTOI(tdvp);\n    memcpy((char *)fdi.indata + sizeof(*fri), fcnp->cn_nameptr,\n           fcnp->cn_namelen);\n    ((char *)fdi.indata)[sizeof(*fri) + fcnp->cn_namelen] = '\\0';\n    memcpy((char *)fdi.indata + sizeof(*fri) + fcnp->cn_namelen + 1,\n           tcnp->cn_nameptr, tcnp->cn_namelen);\n    ((char *)fdi.indata)[sizeof(*fri) + fcnp->cn_namelen +\n                         tcnp->cn_namelen + 1] = '\\0';\n\n    if (!(err = fuse_dispatcher_wait_answer(&fdi))) {\n        fuse_ticket_drop(fdi.ticket);\n    }\n\n    if (err == 0) {\n        fuse_invalidate_attr(fdvp);\n        if (tdvp != fdvp) {\n            fuse_invalidate_attr(tdvp);\n        }\n    }\n\n    return err;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Check ordering of two fusenodes. Return true if they are are in-order.\n */\n", "func_signal": "static int\nfusefs_isordered(fusenode_t cp1, fusenode_t cp2)", "code": "{\n    if (cp1 == cp2) {\n        return 0;\n    }\n\n    if (cp1 == NULL || cp2 == (fusenode_t)0xffffffff) {\n        return 1;\n    }\n\n    if (cp2 == NULL || cp1 == (fusenode_t)0xffffffff) {\n        return 0;\n    }\n\n    if (cp1->nodeid == cp2->parent_nodeid) {\n        return 1;  /* cp1 is the parent and should go first */\n    }\n\n    if (cp2->nodeid == cp1->parent_nodeid) {\n        return 0;  /* cp1 is the child and should go last */\n    }\n\n    return (cp1 < cp2);  /* fall-back is to use address order */\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* access */\n", "func_signal": "__private_extern__\nint\nfuse_internal_access(vnode_t                   vp,\n                     int                       action,\n                     vfs_context_t             context)", "code": "{\n    int err = 0;\n    uint32_t mask = 0;\n    int dataflags;\n    mount_t mp;\n    struct fuse_dispatcher fdi;\n    struct fuse_access_in *fai;\n    struct fuse_data      *data;\n\n    fuse_trace_printf_func();\n\n    mp = vnode_mount(vp);\n\n    data = fuse_get_mpdata(mp);\n    dataflags = data->dataflags;\n\n    /* Allow for now; let checks be handled inline later. */\n    if (fuse_isdeferpermissions_mp(mp)) {\n        return 0;\n    }\n\n    /*\n     * (action & KAUTH_VNODE_GENERIC_WRITE_BITS) on a read-only file system\n     * would have been handled by higher layers.\n     */\n\n    if (!fuse_implemented(data, FSESS_NOIMPLBIT(ACCESS))) {\n        return ENOTSUP;\n    }\n\n    if (!vnode_isvroot(vp)) {\n        CHECK_BLANKET_DENIAL(vp, context, EPERM);\n    }\n\n    if (vnode_isdir(vp)) {\n        if (action & (KAUTH_VNODE_LIST_DIRECTORY   |\n                      KAUTH_VNODE_READ_EXTATTRIBUTES)) {\n            mask |= R_OK;\n        }\n        if (action & (KAUTH_VNODE_ADD_FILE         |\n                      KAUTH_VNODE_ADD_SUBDIRECTORY |\n                      KAUTH_VNODE_DELETE_CHILD)) {\n            mask |= W_OK;\n        }\n        if (action & KAUTH_VNODE_SEARCH) {\n            mask |= X_OK;\n        }\n    } else {\n        if (action & (KAUTH_VNODE_READ_DATA | KAUTH_VNODE_READ_EXTATTRIBUTES)) {\n            mask |= R_OK;\n        }\n        if (action & (KAUTH_VNODE_WRITE_DATA | KAUTH_VNODE_APPEND_DATA)) {\n            mask |= W_OK;\n        }\n        if (action & KAUTH_VNODE_EXECUTE) {\n            mask |= X_OK;\n        }\n    }\n\n    if (action & (KAUTH_VNODE_WRITE_ATTRIBUTES    |\n                  KAUTH_VNODE_WRITE_EXTATTRIBUTES |\n                  KAUTH_VNODE_WRITE_SECURITY)) {\n        mask |= W_OK;\n    }\n\n    bzero(&fdi, sizeof(fdi));\n\n    fuse_dispatcher_init(&fdi, sizeof(*fai));\n    fuse_dispatcher_make_vp(&fdi, FUSE_ACCESS, vp, context);\n\n    fai = fdi.indata;\n    fai->mask = F_OK;\n    fai->mask |= mask;\n\n    if (!(err = fuse_dispatcher_wait_answer(&fdi))) {\n        fuse_ticket_drop(fdi.ticket);\n    }\n\n    if (err == ENOSYS) {\n        /*\n         * Make sure we don't come in here again.\n         */\n        vfs_clearauthopaque(mp);\n        fuse_clear_implemented(data, FSESS_NOIMPLBIT(ACCESS));\n        err = ENOTSUP;\n    }\n\n    if (err == ENOENT) {\n        const char *vname = vnode_getname(vp);\n\n        log(\"fuse4x: disappearing vnode %p (name=%s type=%d action=%x)\\n\",\n            vp, (vname) ? vname : \"?\", vnode_vtype(vp), action);\n\n        if (vname) {\n            vnode_putname(vname);\n        }\n\n#ifdef FUSE4X_ENABLE_BIGLOCK\n        fuse_biglock_unlock(data->biglock);\n#endif\n       fuse_vncache_purge(vp); \n#ifdef FUSE4X_ENABLE_BIGLOCK\n        fuse_biglock_lock(data->biglock);\n#endif\n    }\n\n    return err;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* getattr sidekicks */\n", "func_signal": "__private_extern__\nint\nfuse_internal_loadxtimes(vnode_t vp, struct vnode_attr *out_vap,\n                         vfs_context_t context)", "code": "{\n    struct vnode_attr *in_vap = VTOVA(vp);\n    struct fuse_data *data = fuse_get_mpdata(vnode_mount(vp));\n    struct fuse_dispatcher fdi;\n    struct fuse_getxtimes_out *fgxo = NULL;\n    int isvroot = vnode_isvroot(vp);\n    struct timespec t = { 0, 0 };\n    const struct timespec kZeroTime = { 0, 0 };\n    int err = 0;\n\n    if (!(data->dataflags & FSESS_XTIMES)) {\n        /* We don't return anything. */\n        goto out;\n    }\n\n    if (VTOFUD(vp)->c_flag & C_XTIMES_VALID) {\n        VATTR_RETURN(out_vap, va_backup_time, in_vap->va_backup_time);\n        VATTR_RETURN(out_vap, va_create_time, in_vap->va_create_time);\n        goto out;\n    }\n\n    if (!fuse_implemented(data, FSESS_NOIMPLBIT(GETXTIMES))) {\n        goto fake;\n    }\n\n    if (fuse_isdeadfs(vp) && isvroot) {\n        goto fake;\n    }\n\n    if (!data->inited && isvroot) {\n        goto fake;\n    }\n\n    err = fuse_dispatcher_simple_putget_vp(&fdi, FUSE_GETXTIMES, vp, context);\n    if (err) {\n        /* We don't ever treat this as a hard error. */\n        err = 0;\n        goto fake;\n    }\n\n    fgxo = (struct fuse_getxtimes_out *)fdi.answer;\n\n    t.tv_sec = (time_t)fgxo->bkuptime; /* XXX: truncation */\n    t.tv_nsec = fgxo->bkuptimensec;\n    VATTR_RETURN(in_vap, va_backup_time, t);\n    VATTR_RETURN(out_vap, va_backup_time, t);\n\n    t.tv_sec = (time_t)fgxo->crtime; /* XXX: truncation */\n    t.tv_nsec = fgxo->crtimensec;\n    VATTR_RETURN(in_vap, va_create_time, t);\n    VATTR_RETURN(out_vap, va_create_time, t);\n\n    fuse_ticket_drop(fdi.ticket);\n\n    VTOFUD(vp)->c_flag |= C_XTIMES_VALID;\n\n    goto out;\n\nfake:\n    VATTR_RETURN(out_vap, va_backup_time, kZeroTime);\n    VATTR_RETURN(out_vap, va_create_time, kZeroTime);\n\nout:\n    return err;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* entity destruction */\n", "func_signal": "__private_extern__\nint\nfuse_internal_forget_callback(struct fuse_ticket *ticket, __unused uio_t uio)", "code": "{\n    struct fuse_dispatcher fdi;\n\n    fdi.ticket = ticket;\n\n    fuse_internal_forget_send(ticket->data->mp, NULL,\n        ((struct fuse_in_header *)ticket->ms_fiov.base)->nodeid, 1, &fdi);\n\n    return 0;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Lock a pair of fusenodes.\n */\n", "func_signal": "__private_extern__\nint\nfusefs_lockpair(fusenode_t cp1, fusenode_t cp2, enum fusefslocktype locktype)", "code": "{\n    fusenode_t first, last;\n    int error;\n\n    /*\n     * If cnodes match then just lock one.\n     */\n    if (cp1 == cp2) {\n        return fusefs_lock(cp1, locktype);\n    }\n\n    /*\n     * Lock in cnode parent-child order (if there is a relationship);\n     * otherwise lock in cnode address order.\n     */\n    if ((cp1->vtype == VDIR) && (cp1->nodeid == cp2->parent_nodeid)) {\n        first = cp1;\n        last = cp2;\n    } else if (cp1 < cp2) {\n        first = cp1;\n        last = cp2;\n    } else {\n        first = cp2;\n        last = cp1;\n    }\n\n    if ( (error = fusefs_lock(first, locktype))) {\n        return error;\n    }\n\n    if ( (error = fusefs_lock(last, locktype))) {\n        fusefs_unlock(first);\n        return error;\n    }\n\n    return 0;\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* exchange */\n", "func_signal": "__private_extern__\nint\nfuse_internal_exchange(vnode_t       fvp,\n                       const char   *fname,\n                       size_t        flen,\n                       vnode_t       tvp,\n                       const char   *tname,\n                       size_t        tlen,\n                       int           options,\n                       vfs_context_t context)", "code": "{\n    struct fuse_dispatcher fdi;\n    struct fuse_exchange_in *fei;\n    struct fuse_vnode_data *ffud = VTOFUD(fvp);\n    struct fuse_vnode_data *tfud = VTOFUD(tvp);\n    vnode_t fdvp = ffud->parentvp;\n    vnode_t tdvp = tfud->parentvp;\n    int err = 0;\n\n    fuse_dispatcher_init(&fdi, sizeof(*fei) + flen + tlen + 2);\n    fuse_dispatcher_make_vp(&fdi, FUSE_EXCHANGE, fvp, context);\n\n    fei = fdi.indata;\n    fei->olddir = VTOI(fdvp);\n    fei->newdir = VTOI(tdvp);\n    fei->options = (uint64_t)options;\n\n    memcpy((char *)fdi.indata + sizeof(*fei), fname, flen);\n    ((char *)fdi.indata)[sizeof(*fei) + flen] = '\\0';\n\n    memcpy((char *)fdi.indata + sizeof(*fei) + flen + 1, tname, tlen);\n    ((char *)fdi.indata)[sizeof(*fei) + flen + tlen + 1] = '\\0';\n\n    ubc_msync(fvp, (off_t)0, (off_t)ffud->filesize, NULL,\n              UBC_PUSHALL | UBC_INVALIDATE | UBC_SYNC);\n    ubc_msync(tvp, (off_t)0, (off_t)tfud->filesize, NULL,\n              UBC_PUSHALL | UBC_INVALIDATE | UBC_SYNC);\n\n    if (!(err = fuse_dispatcher_wait_answer(&fdi))) {\n        fuse_ticket_drop(fdi.ticket);\n    }\n\n    if (err == 0) {\n        if (fdvp) {\n            fuse_invalidate_attr(fdvp);\n        }\n        if (tdvp && (tdvp != fdvp)) {\n            fuse_invalidate_attr(tdvp);\n        }\n\n        fuse_invalidate_attr(fvp);\n        fuse_invalidate_attr(tvp);\n\n        cache_purge(fvp);\n        cache_purge(tvp);\n\n        /* Swap sizes */\n        off_t tmpfilesize = ffud->filesize;\n        ffud->filesize = tfud->filesize;\n        tfud->filesize = tmpfilesize;\n        ubc_setsize(fvp, (off_t)ffud->filesize);\n        ubc_setsize(tvp, (off_t)tfud->filesize);\n\n        fuse_compat_exchange(fvp, tvp);\n\n        /*\n         * Another approach (will need additional kernel support to work):\n         *\n        vnode_t tmpvp = ffud->vp;\n        ffud->vp = tfud->vp;\n        tfud->vp = tmpvp;\n\n        vnode_t tmpparentvp = ffud->parentvp;\n        ffud->parentvp = tfud->parentvp;\n        tfud->parentvp = tmpparentvp;\n\n        off_t tmpfilesize = ffud->filesize;\n        ffud->filesize = tfud->filesize;\n        tfud->filesize = tmpfilesize;\n\n        struct fuse_vnode_data tmpfud;\n        memcpy(&tmpfud, ffud, sizeof(struct fuse_vnode_data));\n        memcpy(ffud, tfud, sizeof(struct fuse_vnode_data));\n        memcpy(tfud, &tmpfud, sizeof(struct fuse_vnode_data));\n\n        HNodeExchangeFromFSNode(ffud, tfud);\n        *\n        */\n    }\n\n    return err;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* fsync */\n", "func_signal": "__private_extern__\nint\nfuse_internal_fsync_callback(struct fuse_ticket *ticket, __unused uio_t uio)", "code": "{\n    fuse_trace_printf_func();\n\n    if (ticket->aw_ohead.error == ENOSYS) {\n        if (fuse_ticket_opcode(ticket) == FUSE_FSYNC) {\n            fuse_clear_implemented(ticket->data, FSESS_NOIMPLBIT(FSYNC));\n        } else if (fuse_ticket_opcode(ticket) == FUSE_FSYNCDIR) {\n            fuse_clear_implemented(ticket->data, FSESS_NOIMPLBIT(FSYNCDIR));\n        } else {\n            log(\"fuse4x: unexpected opcode in sync handling\\n\");\n        }\n    }\n\n    fuse_ticket_drop(ticket);\n\n    return 0;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Unlock a fusenode.\n */\n", "func_signal": "__private_extern__\nvoid\nfusefs_unlock(fusenode_t cp)", "code": "{\n    u_int32_t c_flag;\n    vnode_t vp = NULLVP;\n\n    c_flag = cp->c_flag;\n    cp->c_flag &= ~(C_NEED_DVNODE_PUT | C_NEED_DATA_SETSIZE);\n\n    if (c_flag & (C_NEED_DVNODE_PUT | C_NEED_DATA_SETSIZE)) {\n        vp = cp->vp;\n    }\n\n    cp->nodelockowner = NULL;\n    fusefs_lck_rw_done(cp->nodelock);\n\n    /* Perform any vnode post processing after fusenode lock is dropped. */\n    if (vp) {\n        if (c_flag & C_NEED_DATA_SETSIZE) {\n            ubc_setsize(vp, 0);\n        }\n        if (c_flag & C_NEED_DVNODE_PUT) {\n            vnode_put(vp);\n        }\n    }\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* setattr sidekicks */\n", "func_signal": "__private_extern__\nint\nfuse_internal_attr_vat2fsai(mount_t                 mp,\n                            vnode_t                 vp,\n                            struct vnode_attr      *vap,\n                            struct fuse_setattr_in *fsai,\n                            uint64_t               *newsize)", "code": "{\n    /*\n     * XXX: Locking\n     *\n     * We need to worry about the file size changing in setattr(). If the call\n     * is indeed altering the size, then:\n     *\n     * lock_exclusive(truncatelock)\n     *   lock(nodelock)\n     *     set the new size\n     *   unlock(nodelock)\n     *   adjust ubc\n     *   lock(nodelock)\n     *     do cleanup\n     *   unlock(nodelock)\n     * unlock(truncatelock)\n     * ...\n     */\n\n    int sizechanged = 0;\n    uid_t nuid;\n    gid_t ngid;\n\n    fsai->valid = 0;\n\n    if (newsize) {\n        *newsize = 0;\n    }\n\n    nuid = VATTR_IS_ACTIVE(vap, va_uid) ? vap->va_uid : (uid_t)VNOVAL;\n    if (nuid != (uid_t)VNOVAL) {\n        fsai->uid = nuid;\n        fsai->valid |= FATTR_UID;\n    }\n    VATTR_SET_SUPPORTED(vap, va_uid);\n\n    ngid = VATTR_IS_ACTIVE(vap, va_gid) ? vap->va_gid : (gid_t)VNOVAL;\n    if (ngid != (gid_t)VNOVAL) {\n        fsai->gid = ngid;\n        fsai->valid |= FATTR_GID;\n    }\n    VATTR_SET_SUPPORTED(vap, va_gid);\n\n    if (VATTR_IS_ACTIVE(vap, va_data_size)) {\n\n        // Truncate to a new value.\n        fsai->size = vap->va_data_size;\n        sizechanged = 1;\n        if (newsize) {\n            *newsize = vap->va_data_size;\n        }\n        fsai->valid |= FATTR_SIZE;\n\n        if (vp) {\n            struct fuse_filehandle *fufh = NULL;\n            struct fuse_vnode_data *fvdat = VTOFUD(vp);\n\n            fufh = &(fvdat->fufh[FUFH_WRONLY]);\n\n            if (!FUFH_IS_VALID(fufh)) {\n                fufh = &(fvdat->fufh[FUFH_RDWR]);\n                if (!FUFH_IS_VALID(fufh)) {\n                    fufh = NULL;\n                }\n            }\n\n            if (fufh) {\n                fsai->fh = fufh->fh_id;\n                fsai->valid |= FATTR_FH;\n            }\n        }\n    }\n    VATTR_SET_SUPPORTED(vap, va_data_size);\n\n    /*\n     * Possible timestamps:\n     *\n     * Mac OS X                                          Linux  FUSE API\n     *\n     * va_access_time    last access time                atime  atime\n     * va_backup_time    last backup time                -      -\n     * va_change_time    last metadata change time       ctime* -\n     * va_create_time    creation time                   -      -\n     * va_modify_time    last data modification time     mtime  mtime\n     *\n     */\n\n    if (VATTR_IS_ACTIVE(vap, va_access_time)) {\n        fsai->atime = vap->va_access_time.tv_sec;\n        /* XXX: truncation */\n        fsai->atimensec = (uint32_t)vap->va_access_time.tv_nsec;\n        fsai->valid |=  FATTR_ATIME;\n    }\n    VATTR_SET_SUPPORTED(vap, va_access_time);\n\n    if (VATTR_IS_ACTIVE(vap, va_modify_time)) {\n        fsai->mtime = vap->va_modify_time.tv_sec;\n        /* XXX: truncation */\n        fsai->mtimensec = (uint32_t)vap->va_modify_time.tv_nsec;\n        fsai->valid |=  FATTR_MTIME;\n    }\n    VATTR_SET_SUPPORTED(vap, va_modify_time);\n\n    if (VATTR_IS_ACTIVE(vap, va_backup_time) && fuse_isxtimes_mp(mp)) {\n        fsai->bkuptime = vap->va_backup_time.tv_sec;\n        /* XXX: truncation */\n        fsai->bkuptimensec = (uint32_t)vap->va_backup_time.tv_nsec;\n        fsai->valid |= FATTR_BKUPTIME;\n        VATTR_SET_SUPPORTED(vap, va_backup_time);\n    }\n\n    if (VATTR_IS_ACTIVE(vap, va_change_time)) {\n        if (fuse_isxtimes_mp(mp)) {\n            fsai->chgtime = vap->va_change_time.tv_sec;\n            /* XXX: truncation */\n            fsai->chgtimensec = (uint32_t)vap->va_change_time.tv_nsec;\n            fsai->valid |=  FATTR_CHGTIME;\n            VATTR_SET_SUPPORTED(vap, va_change_time);\n        }\n    }\n\n    if (VATTR_IS_ACTIVE(vap, va_create_time) && fuse_isxtimes_mp(mp)) {\n        fsai->crtime = vap->va_create_time.tv_sec;\n        /* XXX: truncation */\n        fsai->crtimensec = (uint32_t)vap->va_create_time.tv_nsec;\n        fsai->valid |= FATTR_CRTIME;\n        VATTR_SET_SUPPORTED(vap, va_create_time);\n    }\n\n    if (VATTR_IS_ACTIVE(vap, va_mode)) {\n        fsai->mode = vap->va_mode & ALLPERMS;\n        fsai->mode |= VTTOIF(vnode_vtype(vp));\n        fsai->valid |= FATTR_MODE;\n    }\n    VATTR_SET_SUPPORTED(vap, va_mode);\n\n    if (VATTR_IS_ACTIVE(vap, va_flags)) {\n        fsai->flags = vap->va_flags;\n        fsai->valid |= FATTR_FLAGS;\n    }\n    VATTR_SET_SUPPORTED(vap, va_flags);\n\n    /*\n     * We /are/ OK with va_acl, va_guuid, and va_uuuid passing through here.\n     */\n\n    return sizechanged;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* strategy */\n", "func_signal": "__private_extern__\nint\nfuse_internal_strategy(vnode_t vp, buf_t bp)", "code": "{\n    size_t biosize;\n    size_t chunksize;\n    size_t respsize;\n\n    bool mapped = false;\n    int mode;\n    int op;\n    int vtype = vnode_vtype(vp);\n\n    int err = 0;\n\n    caddr_t bufdat;\n    off_t   left;\n    off_t   offset;\n    int32_t bflags = buf_flags(bp);\n\n    fufh_type_t             fufh_type;\n    struct fuse_dispatcher  fdi;\n    struct fuse_data       *data;\n    struct fuse_vnode_data *fvdat = VTOFUD(vp);\n    struct fuse_filehandle *fufh = NULL;\n    mount_t mp = vnode_mount(vp);\n\n    data = fuse_get_mpdata(mp);\n\n    biosize = data->blocksize;\n\n    if (!(vtype == VREG || vtype == VDIR)) {\n        return ENOTSUP;\n    }\n\n    if (bflags & B_READ) {\n        mode = FREAD;\n        fufh_type = FUFH_RDONLY; /* FUFH_RDWR will also do */\n    } else {\n        mode = FWRITE;\n        fufh_type = FUFH_WRONLY; /* FUFH_RDWR will also do */\n    }\n\n    fufh = &(fvdat->fufh[fufh_type]);\n\n    if (!FUFH_IS_VALID(fufh)) {\n        fufh_type = FUFH_RDWR;\n        fufh = &(fvdat->fufh[fufh_type]);\n        if (!FUFH_IS_VALID(fufh)) {\n            fufh = NULL;\n        } else {\n            /* We've successfully fallen back to FUFH_RDWR. */\n        }\n    }\n\n    if (!fufh) {\n\n        if (mode == FREAD) {\n            fufh_type = FUFH_RDONLY;\n        } else {\n            fufh_type = FUFH_RDWR;\n        }\n\n        /*\n         * Lets NOT do the filehandle preflight check here.\n         */\n\n        err = fuse_filehandle_get(vp, NULL, fufh_type, 0 /* mode */);\n\n        if (!err) {\n            fufh = &(fvdat->fufh[fufh_type]);\n            /* We've created a NEW fufh of type fufh_type. open_count is 1. */\n        }\n\n    } else { /* good fufh */\n\n        OSIncrementAtomic((SInt32 *)&fuse_fh_reuse_count);\n\n        /* We're using an existing fufh of type fufh_type. */\n    }\n\n    if (err) {\n\n         /* A more typical error case. */\n         if ((err == ENOTCONN) || fuse_isdeadfs(vp)) {\n             buf_seterror(bp, EIO);\n             buf_biodone(bp);\n             return EIO;\n         }\n\n         log(\"fuse4x: strategy failed to get fh \"\n               \"(vtype=%d, fufh_type=%d, err=%d)\\n\", vtype, fufh_type, err);\n\n         if (!vfs_issynchronous(mp)) {\n             log(\"fuse4x: asynchronous write failed!\\n\");\n         }\n\n         buf_seterror(bp, EIO);\n         buf_biodone(bp);\n         return EIO;\n    }\n\n    if (!fufh) {\n        panic(\"fuse4x: tried everything but still no fufh\");\n        /* NOTREACHED */\n    }\n\n#define B_INVAL 0x00040000 /* Does not contain valid info. */\n#define B_ERROR 0x00080000 /* I/O error occurred. */\n\n    if (bflags & B_INVAL) {\n        log(\"fuse4x: buffer does not contain valid information\\n\");\n    }\n\n    if (bflags & B_ERROR) {\n        log(\"fuse4x: an I/O error has occured\\n\");\n    }\n\n    if (buf_count(bp) == 0) {\n        return 0;\n    }\n\n    fuse_dispatcher_init(&fdi, 0);\n\n    if (mode == FREAD) {\n\n        struct fuse_read_in *fri;\n\n        buf_setresid(bp, buf_count(bp));\n        offset = (off_t)((off_t)buf_blkno(bp) * biosize);\n\n        if (offset >= fvdat->filesize) {\n            /* Trying to read at/after EOF? */\n            if (offset != fvdat->filesize) {\n                /* Trying to read after EOF? */\n                buf_seterror(bp, EINVAL);\n            }\n            buf_biodone(bp);\n            return 0;\n        }\n\n        /* Note that we just made sure that offset < fvdat->filesize. */\n        if ((offset + buf_count(bp)) > fvdat->filesize) {\n            /* Trimming read */\n            buf_setcount(bp, (uint32_t)(fvdat->filesize - offset));\n        }\n\n        if (buf_map(bp, &bufdat)) {\n            log(\"fuse4x: failed to map buffer in strategy\\n\");\n            return EFAULT;\n        } else {\n            mapped = true;\n        }\n\n        while (buf_resid(bp) > 0) {\n\n            chunksize = min((size_t)buf_resid(bp), data->iosize);\n\n            fdi.iosize = sizeof(*fri);\n\n            op = FUSE_READ;\n            if (vtype == VDIR) {\n                op = FUSE_READDIR;\n            }\n            fuse_dispatcher_make_vp(&fdi, op, vp, NULL);\n\n            fri = fdi.indata;\n            fri->fh = fufh->fh_id;\n\n            /*\n             * Historical note:\n             *\n             * fri->offset = ((off_t)(buf_blkno(bp))) * biosize;\n             *\n             * This wasn't being incremented!?\n             */\n\n            fri->offset = offset;\n            fri->size = (typeof(fri->size))chunksize;\n            fdi.ticket->aw_type = FT_A_BUF;\n            fdi.ticket->aw_bufdata = bufdat;\n\n            if ((err = fuse_dispatcher_wait_answer(&fdi))) {\n                /* There was a problem with reading. */\n                goto out;\n            }\n\n            respsize = fdi.ticket->aw_bufsize;\n\n            buf_setresid(bp, (uint32_t)(buf_resid(bp) - respsize));\n            bufdat += respsize;\n            offset += respsize;\n\n            /* Did we hit EOF before being done? */\n            if ((respsize == 0) && (buf_resid(bp) > 0)) {\n                 /*\n                  * Historical note:\n                  * If we don't get enough data, just fill the rest with zeros.\n                  * In NFS context, this would mean a hole in the file.\n                  */\n\n                 /* Zero-pad the incomplete buffer. */\n                 bzero(bufdat, buf_resid(bp));\n                 buf_setresid(bp, 0);\n                 break;\n            }\n        } /* while (buf_resid(bp) > 0) */\n    } else {\n        /* write */\n        struct fuse_write_in  *fwi;\n        struct fuse_write_out *fwo;\n        int merr = 0;\n        off_t diff;\n\n        if (buf_map(bp, &bufdat)) {\n            log(\"fuse4x: failed to map buffer in strategy\\n\");\n            return EFAULT;\n        } else {\n            mapped = true;\n        }\n\n        /* Write begin */\n\n        buf_setresid(bp, buf_count(bp));\n        offset = (off_t)((off_t)buf_blkno(bp) * biosize);\n\n        /* XXX: TBD -- Check here for extension (writing past end) */\n\n        left = buf_count(bp);\n\n        while (left) {\n\n            fdi.iosize = sizeof(*fwi);\n            op = FUSE_WRITE;\n\n            fuse_dispatcher_make_vp(&fdi, op, vp, NULL);\n            chunksize = min((size_t)left, data->iosize);\n            \n            /* Take the size of the write buffer into account */\n            fdi.finh->len += (typeof(fdi.finh->len))chunksize;\n\n            fwi = fdi.indata;\n            fwi->fh = fufh->fh_id;\n            fwi->offset = offset;\n            fwi->size = (typeof(fwi->size))chunksize;\n\n            fdi.ticket->ms_type = FT_M_BUF;\n            fdi.ticket->ms_bufdata = bufdat;\n            fdi.ticket->ms_bufsize = chunksize;\n\n            /* About to write <chunksize> at <offset> */\n\n            if ((err = fuse_dispatcher_wait_answer(&fdi))) {\n                merr = 1;\n                break;\n            }\n\n            fwo = fdi.answer;\n            diff = chunksize - fwo->size;\n            if (diff < 0) {\n                err = EINVAL;\n                break;\n            }\n\n            left -= fwo->size;\n            bufdat += fwo->size;\n            offset += fwo->size;\n            buf_setresid(bp, buf_resid(bp) - fwo->size);\n        }\n\n        if (merr) {\n            goto out;\n        }\n    }\n\n    if (fdi.ticket) {\n        fuse_ticket_drop(fdi.ticket);\n    } else {\n        /* No ticket upon leaving */\n    }\n\nout:\n\n    if (err) {\n        buf_seterror(bp, err);\n    }\n\n    if (mapped) {\n        buf_unmap(bp);\n    }\n\n    buf_biodone(bp);\n\n    return err;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* remove */\n", "func_signal": "static int\nfuse_internal_remove_callback(vnode_t vp, void *cargs)", "code": "{\n    struct vnode_attr *vap;\n    uint64_t target_nlink;\n\n    vap = VTOVA(vp);\n\n    target_nlink = *(uint64_t *)cargs;\n\n    /* somewhat lame \"heuristics\", but you got better ideas? */\n    if ((vap->va_nlink == target_nlink) && vnode_isreg(vp)) {\n        fuse_invalidate_attr(vp);\n    }\n\n    return VNODE_RETURNED;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* entity creation */\n", "func_signal": "__private_extern__\nvoid\nfuse_internal_newentry_makerequest(mount_t                 mp,\n                                   uint64_t                dnid,\n                                   struct componentname   *cnp,\n                                   enum fuse_opcode        op,\n                                   void                   *buf,\n                                   size_t                  bufsize,\n                                   struct fuse_dispatcher *dispatcher,\n                                   vfs_context_t           context)", "code": "{\n    fuse_dispatcher_init(dispatcher, bufsize + cnp->cn_namelen + 1);\n\n    fuse_dispatcher_make(dispatcher, op, mp, dnid, context);\n    memcpy(dispatcher->indata, buf, bufsize);\n    memcpy((char *)dispatcher->indata + bufsize, cnp->cn_nameptr, cnp->cn_namelen);\n    ((char *)dispatcher->indata)[bufsize + cnp->cn_namelen] = '\\0';\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/*\n * Unlock a group of fusenodes.\n */\n", "func_signal": "__private_extern__\nvoid\nfusefs_unlockfour(fusenode_t cp1, fusenode_t cp2,\n                  fusenode_t cp3, fusenode_t cp4)", "code": "{\n    fusenode_t list[4];\n    int i, k = 0;\n\n    if (cp1) {\n        fusefs_unlock(cp1);\n        list[k++] = cp1;\n    }\n\n    if (cp2) {\n        for (i = 0; i < k; ++i) {\n            if (list[i] == cp2)\n                goto skip1;\n        }\n        fusefs_unlock(cp2);\n        list[k++] = cp2;\n    }\n\nskip1:\n    if (cp3) {\n        for (i = 0; i < k; ++i) {\n            if (list[i] == cp3)\n                goto skip2;\n        }\n        fusefs_unlock(cp3);\n        list[k++] = cp3;\n    }\n\nskip2:\n    if (cp4) {\n        for (i = 0; i < k; ++i) {\n            if (list[i] == cp4)\n                return;\n        }\n        fusefs_unlock(cp4);\n    }\n}", "path": "fuse_locking.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* fuse start/stop */\n", "func_signal": "__private_extern__\nint\nfuse_internal_init_callback(struct fuse_ticket *ticket, __unused uio_t uio)", "code": "{\n    int err = 0;\n    struct fuse_init_out *fiio;\n    struct fuse_data *data = ticket->data;\n\n    fuse_trace_printf_func();\n\n    if ((err = ticket->aw_ohead.error)) {\n        log(\"fuse4x: user-space initialization failed (%d)\\n\", err);\n        goto out;\n    }\n\n    err = fuse_ticket_pull(ticket, uio);\n    if (err) {\n        log(\"fuse4x: cannot pull ticket\\n\");\n        goto out;\n    }\n\n    fiio = ticket->aw_fiov.base;\n\n    if ((fiio->major < FUSE_KERNEL_VERSION) ||\n        (fiio->minor < FUSE_KERNEL_MINOR_VERSION)) {\n        log(\"fuse4x: user-space library has outdated protocol version. Required(%d.%d), user returned (%d.%d)\\n\",\n              FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION,\n              fiio->major, fiio->minor);\n        err = EPROTONOSUPPORT;\n        goto out;\n    }\n\n    if (ticket->aw_fiov.len == sizeof(struct fuse_init_out)) {\n        data->max_write = fiio->max_write;\n    } else {\n        err = EINVAL;\n    }\n\n    if (fiio->flags & FUSE_CASE_INSENSITIVE) {\n        data->dataflags |= FSESS_CASE_INSENSITIVE;\n    }\n\n    if (fiio->flags & FUSE_VOL_RENAME) {\n        data->dataflags |= FSESS_VOL_RENAME;\n    }\n\n    if (fiio->flags & FUSE_XTIMES) {\n        data->dataflags |= FSESS_XTIMES;\n    }\n\n    if (fiio->flags & FUSE_ATOMIC_O_TRUNC) {\n        data->dataflags |= FSESS_ATOMIC_O_TRUNC;\n    }\n\nout:\n    fuse_ticket_drop(ticket);\n\n    if (err) {\n        fuse_data_kill(data);\n    }\n\n    fuse_lck_mtx_lock(data->ticket_mtx);\n    data->inited = true;\n    fuse_wakeup(&data->ticketer);\n    fuse_lck_mtx_unlock(data->ticket_mtx);\n\n    return 0;\n}", "path": "fuse_internal.c", "repo_name": "fuse4x/kext", "stars": 22, "license": "None", "language": "c", "size": 511}
{"docstring": "/* Search through the array of SAs to find the one with the required ID.\n *\n * @return array index where found or -1 if not found\n */\n", "func_signal": "static ssize_t aes_find_sa( const transop_aes_t * priv, const n2n_sa_t req_id )", "code": "{\n    size_t i;\n    \n    for (i=0; i < priv->num_sa; ++i)\n    {\n        const sa_aes_t * sa=NULL;\n\n        sa = &(priv->sa[i]);\n        if (req_id == sa->sa_id)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}", "path": "transform_aes.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Create the argv vector */\n", "func_signal": "static char ** buildargv(int * effectiveargc, char * const linebuffer)", "code": "{\n  const int  INITIAL_MAXARGC = 16;\t/* Number of args + NULL in initial argv */\n  int     maxargc;\n  int     argc=0;\n  char ** argv;\n  char *  buffer, * buff;\n\n  *effectiveargc = 0;\n  buffer = (char *)calloc(1, strlen(linebuffer)+2);\n  if (!buffer) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return NULL;\n  }\n  strncpy(buffer, linebuffer,strlen(linebuffer));\n\n  maxargc = INITIAL_MAXARGC;\n  argv = (char **)malloc(maxargc * sizeof(char*));\n  if (argv == NULL) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return NULL;\n  }\n  buff = buffer;\n  while(buff) {\n    char * p = strchr(buff,' ');\n    if (p) {\n      *p='\\0';\n      argv[argc++] = strdup(buff);\n      while(*++p == ' ' && *p != '\\0');\n      buff=p;\n      if (argc >= maxargc) {\n\tmaxargc *= 2;\n\targv = (char **)realloc(argv, maxargc * sizeof(char*));\n\tif (argv == NULL) {\n\t  traceEvent(TRACE_ERROR, \"Unable to re-allocate memory\");\n\t  free(buffer);\n\t  return NULL;\n\t}\n      }\n    } else {\n      argv[argc++] = strdup(buff);\n      break;\n    }\n  }\n  free(buffer);\n  *effectiveargc = argc;\n  return argv;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* parse the configuration file */\n", "func_signal": "static int readConfFile(const char * filename, char * const linebuffer)", "code": "{\n  struct stat stats;\n  FILE    *   fd;\n  char    *   buffer = NULL;\n\n  buffer = (char *)malloc(MAX_CONFFILE_LINE_LENGTH);\n  if (!buffer) {\n    traceEvent( TRACE_ERROR, \"Unable to allocate memory\");\n    return -1;\n  }\n\n  if (stat(filename, &stats)) {\n    if (errno == ENOENT)\n      traceEvent(TRACE_ERROR, \"parameter file %s not found/unable to access\\n\", filename);\n    else\n      traceEvent(TRACE_ERROR, \"cannot stat file %s, errno=%d\\n\",filename, errno);\n    free(buffer);\n    return -1;\n  }\n\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    traceEvent(TRACE_ERROR, \"Unable to open parameter file '%s' (%d)...\\n\",filename,errno);\n    free(buffer);\n    return -1;\n  }\n  while(fgets(buffer, MAX_CONFFILE_LINE_LENGTH,fd)) {\n    char    *   p = NULL;\n\n    /* strip out comments */\n    p = strchr(buffer, '#');\n    if (p) *p ='\\0';\n\n    /* remove \\n */\n    p = strchr(buffer, '\\n');\n    if (p) *p ='\\0';\n\n    /* strip out heading spaces */\n    p = buffer;\n    while(*p == ' ' && *p != '\\0') ++p;\n    if (p != buffer) strncpy(buffer,p,strlen(p)+1);\n\n    /* strip out trailing spaces */\n    while(strlen(buffer) && buffer[strlen(buffer)-1]==' ')\n      buffer[strlen(buffer)-1]= '\\0';\n\n    /* check for nested @file option */\n    if (strchr(buffer, '@')) {\n      traceEvent(TRACE_ERROR, \"@file in file nesting is not supported\\n\");\n      free(buffer);\n      return -1;\n    }\n    if ((strlen(linebuffer)+strlen(buffer)+2)< MAX_CMDLINE_BUFFER_LENGTH) {\n      strncat(linebuffer, \" \", 1);\n      strncat(linebuffer, buffer, strlen(buffer));\n    } else {\n      traceEvent(TRACE_ERROR, \"too many argument\");\n      free(buffer);\n      return -1;\n    }\n  }\n\n  free(buffer);\n  fclose(fd);\n\n  return 0;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Send a REGISTER_SUPER packet to the current supernode. */\n", "func_signal": "static void send_register_super( n2n_edge_t * eee,\n                                 const n2n_sock_t * supernode)", "code": "{\n    uint8_t pktbuf[N2N_PKT_BUF_SIZE];\n    size_t idx;\n    ssize_t sent;\n    n2n_common_t cmn;\n    n2n_REGISTER_SUPER_t reg;\n    n2n_sock_str_t sockbuf;\n\n    memset(&cmn, 0, sizeof(cmn) );\n    memset(&reg, 0, sizeof(reg) );\n    cmn.ttl=N2N_DEFAULT_TTL;\n    cmn.pc = n2n_register_super;\n    cmn.flags = 0;\n    memcpy( cmn.community, eee->community_name, N2N_COMMUNITY_SIZE );\n\n    for( idx=0; idx < N2N_COOKIE_SIZE; ++idx )\n    {\n        eee->last_cookie[idx] = rand() % 0xff;\n    }\n\n    memcpy( reg.cookie, eee->last_cookie, N2N_COOKIE_SIZE );\n    reg.auth.scheme=0; /* No auth yet */\n\n    idx=0;\n    encode_mac( reg.edgeMac, &idx, eee->device.mac_addr );\n\n    idx=0;\n    encode_REGISTER_SUPER( pktbuf, &idx, &cmn, &reg );\n\n    traceEvent( TRACE_INFO, \"send REGISTER_SUPER to %s\",\n                sock_to_cstr( sockbuf, supernode ) );\n\n\n    sent = sendto_sock( eee->udp_sock, pktbuf, idx, supernode );\n\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Destination 01:00:5E:00:00:00 - 01:00:5E:7F:FF:FF is multicast ethernet.\n */\n", "func_signal": "static int is_ethMulticast( const void * buf, size_t bufsize )", "code": "{\n    int retval = 0;\n\n    /* Match 01:00:5E:00:00:00 - 01:00:5E:7F:FF:FF */\n    if ( bufsize >= sizeof(ether_hdr_t) )\n    {\n        /* copy to aligned memory */\n        ether_hdr_t eh;\n        memcpy( &eh, buf, sizeof(ether_hdr_t) );\n\n        if ( (0x01 == eh.dhost[0]) &&\n             (0x00 == eh.dhost[1]) &&\n             (0x5E == eh.dhost[2]) &&\n             (0 == (0x80 & eh.dhost[3])) )\n        {\n            retval = 1; /* This is an ethernet multicast packet [RFC1112]. */\n        }\n    }\n    return retval;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** A layer-2 packet was received at the tunnel and needs to be sent via UDP. */\n", "func_signal": "static void send_packet2net(n2n_edge_t * eee,\n                            uint8_t *tap_pkt, size_t len)", "code": "{\n    ipstr_t ip_buf;\n    n2n_mac_t destMac;\n\n    n2n_common_t cmn;\n    n2n_PACKET_t pkt;\n\n    uint8_t pktbuf[N2N_PKT_BUF_SIZE];\n    size_t idx=0;\n    size_t tx_transop_idx=0;\n\n    ether_hdr_t eh;\n\n    /* tap_pkt is not aligned so we have to copy to aligned memory */\n    memcpy( &eh, tap_pkt, sizeof(ether_hdr_t) );\n\n    /* Discard IP packets that are not originated by this hosts */\n    if(!(eee->allow_routing)) {\n        if(ntohs(eh.type) == 0x0800) {\n            /* This is an IP packet from the local source address - not forwarded. */\n#define ETH_FRAMESIZE 14\n#define IP4_SRCOFFSET 12\n            uint32_t *dst = (uint32_t*)&tap_pkt[ETH_FRAMESIZE + IP4_SRCOFFSET];\n\n            /* Note: all elements of the_ip are in network order */\n            if( *dst != eee->device.ip_addr) {\n\t\t/* This is a packet that needs to be routed */\n\t\ttraceEvent(TRACE_INFO, \"Discarding routed packet [%s]\",\n                           intoa(ntohl(*dst), ip_buf, sizeof(ip_buf)));\n\t\treturn;\n            } else {\n                /* This packet is originated by us */\n                /* traceEvent(TRACE_INFO, \"Sending non-routed packet\"); */\n            }\n        }\n    }\n\n    /* Optionally compress then apply transforms, eg encryption. */\n\n    /* Once processed, send to destination in PACKET */\n\n    memcpy( destMac, tap_pkt, N2N_MAC_SIZE ); /* dest MAC is first in ethernet header */\n\n    memset( &cmn, 0, sizeof(cmn) );\n    cmn.ttl = N2N_DEFAULT_TTL;\n    cmn.pc = n2n_packet;\n    cmn.flags=0; /* no options, not from supernode, no socket */\n    memcpy( cmn.community, eee->community_name, N2N_COMMUNITY_SIZE );\n\n    memset( &pkt, 0, sizeof(pkt) );\n    memcpy( pkt.srcMac, eee->device.mac_addr, N2N_MAC_SIZE);\n    memcpy( pkt.dstMac, destMac, N2N_MAC_SIZE);\n\n    tx_transop_idx = edge_choose_tx_transop( eee );\n\n    pkt.sock.family=0; /* do not encode sock */\n    pkt.transform = eee->transop[tx_transop_idx].transform_id;\n\n    idx=0;\n    encode_PACKET( pktbuf, &idx, &cmn, &pkt );\n    traceEvent( TRACE_DEBUG, \"encoded PACKET header of size=%u transform %u (idx=%u)\", \n                (unsigned int)idx, (unsigned int)pkt.transform, (unsigned int)tx_transop_idx );\n\n    idx += eee->transop[tx_transop_idx].fwd( &(eee->transop[tx_transop_idx]),\n                                             pktbuf+idx, N2N_PKT_BUF_SIZE-idx,\n                                             tap_pkt, len );\n    ++(eee->transop[tx_transop_idx].tx_cnt); /* stats */\n\n    send_PACKET( eee, destMac, pktbuf, idx ); /* to peer or supernode */\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Send a REGISTER packet to another edge. */\n", "func_signal": "static void send_register( n2n_edge_t * eee,\n                           const n2n_sock_t * remote_peer)", "code": "{\n    uint8_t pktbuf[N2N_PKT_BUF_SIZE];\n    size_t idx;\n    ssize_t sent;\n    n2n_common_t cmn;\n    n2n_REGISTER_t reg;\n    n2n_sock_str_t sockbuf;\n\n    memset(&cmn, 0, sizeof(cmn) );\n    memset(&reg, 0, sizeof(reg) );\n    cmn.ttl=N2N_DEFAULT_TTL;\n    cmn.pc = n2n_register;\n    cmn.flags = 0;\n    memcpy( cmn.community, eee->community_name, N2N_COMMUNITY_SIZE );\n\n    idx=0;\n    encode_uint32( reg.cookie, &idx, 123456789 );\n    idx=0;\n    encode_mac( reg.srcMac, &idx, eee->device.mac_addr );\n\n    idx=0;\n    encode_REGISTER( pktbuf, &idx, &cmn, &reg );\n\n    traceEvent( TRACE_INFO, \"send REGISTER %s\",\n                sock_to_cstr( sockbuf, remote_peer ) );\n\n\n    sent = sendto_sock( eee->udp_sock, pktbuf, idx, remote_peer );\n\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Move the peer from the pending_peers list to the known_peers lists.\n *\n * peer must be a pointer to an element of the pending_peers list.\n *\n * Called by main loop when Rx a REGISTER_ACK.\n */\n", "func_signal": "void set_peer_operational( n2n_edge_t * eee,\n                        const n2n_mac_t mac,\n                        const n2n_sock_t * peer )", "code": "{\n    struct peer_info * prev = NULL;\n    struct peer_info * scan;\n    macstr_t mac_buf;\n    n2n_sock_str_t sockbuf;\n\n    traceEvent( TRACE_INFO, \"set_peer_operational: %s -> %s\",\n                macaddr_str( mac_buf, mac),\n                sock_to_cstr( sockbuf, peer ) );\n\n    scan=eee->pending_peers;\n\n    while ( NULL != scan )\n    {\n        if ( 0 == memcmp( scan->mac_addr, mac, N2N_MAC_SIZE ) )\n        {\n            break; /* found. */\n        }\n\n        prev = scan;\n        scan = scan->next;\n    }\n\n    if ( scan )\n    {\n\n\n        /* Remove scan from pending_peers. */\n        if ( prev )\n        {\n            prev->next = scan->next;\n        }\n        else\n        {\n            eee->pending_peers = scan->next;\n        }\n\n        /* Add scan to known_peers. */\n        scan->next = eee->known_peers;\n        eee->known_peers = scan;\n\n        scan->sock = *peer;\n\n        traceEvent( TRACE_DEBUG, \"=== new peer %s -> %s\",\n                    macaddr_str( mac_buf, scan->mac_addr),\n                    sock_to_cstr( sockbuf, &(scan->sock) ) );\n\n        traceEvent( TRACE_INFO, \"Pending peers list size=%u\",\n                    (unsigned int)peer_list_size( eee->pending_peers ) );\n\n        traceEvent( TRACE_INFO, \"Operational peers list size=%u\",\n                    (unsigned int)peer_list_size( eee->known_peers ) );\n\n\n        scan->last_seen = time(NULL);\n    }\n    else\n    {\n        traceEvent( TRACE_DEBUG, \"Failed to find sender in pending_peers.\" );\n    }\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Fill out the ip_addr value from the interface. Called to pick up dynamic\n * address changes. */\n", "func_signal": "void tuntap_get_address(struct tuntap_dev *tuntap)", "code": "{\n    FILE * fp=NULL;\n    ssize_t nread=0;\n    char buf[N2N_LINUX_SYSTEMCMD_SIZE];\n\n    /* Would rather have a more direct way to get the inet address but a netlink\n     * socket is overkill and probably less portable than ifconfig and sed. */\n\n    /* If the interface has no address (0.0.0.0) there will be no inet addr\n     * line and the returned string will be empty. */\n    snprintf( buf, sizeof(buf), \"/sbin/ifconfig %s | /bin/sed -e '/inet addr:/!d' -e 's/^.*inet addr://' -e 's/ .*$//'\",\n              tuntap->dev_name );\n    fp=popen(buf, \"r\");\n    if (fp )\n    {\n        memset(buf,0,N2N_LINUX_SYSTEMCMD_SIZE); /* make sure buf is NULL terminated. */\n        nread=fread(buf, 1, 15, fp);\n        fclose(fp);\n        fp=NULL;\n\n        traceEvent(TRACE_INFO, \"ifconfig address = %s\", buf);\n\n        tuntap->ip_addr = inet_addr(buf);\n    }\n}", "path": "tuntap_linux.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Return the best acceptable AES key size (in bytes) given an input keysize. \n *\n * The value returned will be one of AES128_KEY_BYTES, AES192_KEY_BYTES or\n * AES256_KEY_BYTES.\n */\n", "func_signal": "static size_t aes_best_keysize(size_t numBytes)", "code": "{\n    if (numBytes >= AES256_KEY_BYTES )\n    {\n        return AES256_KEY_BYTES;\n    }\n    else if (numBytes >= AES192_KEY_BYTES)\n    {\n        return AES192_KEY_BYTES;\n    }\n    else\n    {\n        return AES128_KEY_BYTES;\n    }\n}", "path": "transform_aes.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Destination MAC 33:33:0:00:00:00 - 33:33:FF:FF:FF:FF is reserved for IPv6\n *  neighbour discovery.\n */\n", "func_signal": "static int is_ip6_discovery( const void * buf, size_t bufsize )", "code": "{\n    int retval = 0;\n\n    if ( bufsize >= sizeof(ether_hdr_t) )\n    {\n        /* copy to aligned memory */\n        ether_hdr_t eh;\n        memcpy( &eh, buf, sizeof(ether_hdr_t) );\n\n        if ( (0x33 == eh.dhost[0]) &&\n             (0x33 == eh.dhost[1]) )\n        {\n            retval = 1; /* This is an IPv6 multicast packet [RFC2464]. */\n        }\n    }\n    return retval;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* @return 1 if destination is a peer, 0 if destination is supernode */\n", "func_signal": "static int find_peer_destination(n2n_edge_t * eee,\n                                 n2n_mac_t mac_address,\n                                 n2n_sock_t * destination)", "code": "{\n    const struct peer_info *scan = eee->known_peers;\n    macstr_t mac_buf;\n    n2n_sock_str_t sockbuf;\n    int retval=0;\n\n    traceEvent(TRACE_DEBUG, \"Searching destination peer for MAC %02X:%02X:%02X:%02X:%02X:%02X\",\n               mac_address[0] & 0xFF, mac_address[1] & 0xFF, mac_address[2] & 0xFF,\n               mac_address[3] & 0xFF, mac_address[4] & 0xFF, mac_address[5] & 0xFF);\n\n    while(scan != NULL) {\n        traceEvent(TRACE_DEBUG, \"Evaluating peer [MAC=%02X:%02X:%02X:%02X:%02X:%02X]\",\n                   scan->mac_addr[0] & 0xFF, scan->mac_addr[1] & 0xFF, scan->mac_addr[2] & 0xFF,\n                   scan->mac_addr[3] & 0xFF, scan->mac_addr[4] & 0xFF, scan->mac_addr[5] & 0xFF\n            );\n\n        if((scan->last_seen > 0) &&\n           (memcmp(mac_address, scan->mac_addr, N2N_MAC_SIZE) == 0))\n        {\n            memcpy(destination, &scan->sock, sizeof(n2n_sock_t));\n            retval=1;\n            break;\n        }\n        scan = scan->next;\n    }\n\n    if ( 0 == retval )\n    {\n        memcpy(destination, &(eee->supernode), sizeof(struct sockaddr_in));\n    }\n\n    traceEvent(TRACE_DEBUG, \"find_peer_address (%s) -> [%s]\",\n               macaddr_str( mac_buf, mac_address ),\n               sock_to_cstr( sockbuf, destination ) );\n\n    return retval;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** The aes packet format consists of:\n *\n *  - a 8-bit aes encoding version in clear text\n *  - a 32-bit SA number in clear text\n *  - ciphertext encrypted from a 32-bit nonce followed by the payload.\n *\n *  [V|SSSS|nnnnDDDDDDDDDDDDDDDDDDDDD]\n *         |<------ encrypted ------>|\n */\n", "func_signal": "static int transop_encode_aes( n2n_trans_op_t * arg,\n                                   uint8_t * outbuf,\n                                   size_t out_len,\n                                   const uint8_t * inbuf,\n                                   size_t in_len )", "code": "{\n    int len2=-1;\n    transop_aes_t * priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n    uint32_t * pnonce;\n\n    if ( (in_len + TRANSOP_AES_NONCE_SIZE) <= N2N_PKT_BUF_SIZE )\n    {\n        if ( (in_len + TRANSOP_AES_NONCE_SIZE + TRANSOP_AES_SA_SIZE + TRANSOP_AES_VER_SIZE) <= out_len )\n        {\n            int len=-1;\n            size_t idx=0;\n            sa_aes_t * sa;\n            size_t tx_sa_num = 0;\n\n            /* The transmit sa is periodically updated */\n            tx_sa_num = aes_choose_tx_sa( priv );\n\n            sa = &(priv->sa[tx_sa_num]); /* Proper Tx SA index */\n        \n            traceEvent( TRACE_DEBUG, \"encode_aes %lu with SA %lu.\", in_len, sa->sa_id );\n            \n            /* Encode the aes format version. */\n            encode_uint8( outbuf, &idx, N2N_AES_TRANSFORM_VERSION );\n\n            /* Encode the security association (SA) number */\n            encode_uint32( outbuf, &idx, sa->sa_id );\n\n            /* Encrypt the assembly contents and write the ciphertext after the SA. */\n            len = in_len + TRANSOP_AES_NONCE_SIZE;\n\n            /* The assembly buffer is a source for encrypting data. The nonce is\n             * written in first followed by the packet payload. The whole\n             * contents of assembly are encrypted. */\n            pnonce = (uint32_t *)assembly;\n            *pnonce = rand();\n            memcpy( assembly + TRANSOP_AES_NONCE_SIZE, inbuf, in_len );\n\n            /* Need at least one encrypted byte at the end for the padding. */\n            len2 = ( (len / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE; /* Round up to next whole AES adding at least one byte. */\n            assembly[ len2-1 ]=(len2-len);\n            traceEvent( TRACE_DEBUG, \"padding = %u\", assembly[ len2-1 ] );\n\n            memset( &(sa->enc_ivec), 0, sizeof(N2N_AES_IVEC_SIZE) );\n            AES_cbc_encrypt( assembly, /* source */\n                             outbuf + TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE, /* dest */\n                             len2, /* enc size */\n                             &(sa->enc_key), sa->enc_ivec, 1 /* encrypt */ );\n\n            len2 += TRANSOP_AES_VER_SIZE + TRANSOP_AES_SA_SIZE; /* size of data carried in UDP. */\n        }\n        else\n        {\n            traceEvent( TRACE_ERROR, \"encode_aes outbuf too small.\" );\n        }\n    }\n    else\n    {\n        traceEvent( TRACE_ERROR, \"encode_aes inbuf too big to encrypt.\" );\n    }\n\n    return len2;\n}", "path": "transform_aes.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Keep the known_peers list straight.\n *\n *  Ignore broadcast L2 packets, and packets with invalid public_ip.\n *  If the dst_mac is in known_peers make sure the entry is correct:\n *  - if the public_ip socket has changed, erase the entry\n *  - if the same, update its last_seen = when\n */\n", "func_signal": "static void update_peer_address(n2n_edge_t * eee,\n                                uint8_t from_supernode,\n                                const n2n_mac_t mac,\n                                const n2n_sock_t * peer,\n                                time_t when)", "code": "{\n    struct peer_info *scan = eee->known_peers;\n    struct peer_info *prev = NULL; /* use to remove bad registrations. */\n    n2n_sock_str_t sockbuf1;\n    n2n_sock_str_t sockbuf2; /* don't clobber sockbuf1 if writing two addresses to trace */\n    macstr_t mac_buf;\n\n    if ( is_empty_ip_address( peer ) )\n    {\n        /* Not to be registered. */\n        return;\n    }\n\n    if ( 0 == memcmp( mac, broadcast_mac, N2N_MAC_SIZE ) )\n    {\n        /* Not to be registered. */\n        return;\n    }\n\n\n    while(scan != NULL)\n    {\n        if(memcmp(mac, scan->mac_addr, N2N_MAC_SIZE) == 0)\n        {\n            break;\n        }\n\n        prev = scan;\n        scan = scan->next;\n    }\n\n    if ( NULL == scan )\n    {\n        /* Not in known_peers. */\n        return;\n    }\n\n    if ( 0 != sock_equal( &(scan->sock), peer))\n    {\n        if ( 0 == from_supernode )\n        {\n            traceEvent( TRACE_NORMAL, \"Peer changed %s: %s -> %s\",\n                        macaddr_str( mac_buf, scan->mac_addr ),\n                        sock_to_cstr(sockbuf1, &(scan->sock)),\n                        sock_to_cstr(sockbuf2, peer) );\n\n            /* The peer has changed public socket. It can no longer be assumed to be reachable. */\n            /* Remove the peer. */\n            if ( NULL == prev )\n            {\n                /* scan was head of list */\n                eee->known_peers = scan->next;\n            }\n            else\n            {\n                prev->next = scan->next;\n            }\n            free(scan);\n\n            try_send_register( eee, from_supernode, mac, peer );\n        }\n        else\n        {\n            /* Don't worry about what the supernode reports, it could be seeing a different socket. */\n        }\n    }\n    else\n    {\n        /* Found and unchanged. */\n        scan->last_seen = when;\n    }\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Choose the transop for Tx. This should be based on the newest valid\n * cipherspec in the key schedule. \n *\n * Never fall back to NULL tranform unless no key sources were specified. It is\n * better to render edge inoperative than to expose user data in the clear. In\n * the case where all SAs are expired an arbitrary transform will be chosen for\n * Tx. It will fail having no valid SAs but one must be selected.\n */\n", "func_signal": "static size_t edge_choose_tx_transop( const n2n_edge_t * eee )", "code": "{\n    if ( eee->null_transop)\n    {\n        return N2N_TRANSOP_NULL_IDX;\n    }\n\n    return eee->tx_transop_idx;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Start a second thread in Windows because TUNTAP interfaces do not expose\n *  file descriptors. */\n", "func_signal": "static void startTunReadThread(n2n_edge_t *eee)", "code": "{\n    HANDLE hThread;\n    DWORD dwThreadId;\n\n    hThread = CreateThread(NULL,         /* security attributes */\n                           0,            /* use default stack size */\n                           (LPTHREAD_START_ROUTINE)tunReadThread, /* thread function */\n                           (void*)eee,   /* argument to thread function */\n                           0,            /* thread creation flags */\n                           &dwThreadId); /* thread id out */\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Send an ecapsulated ethernet PACKET to a destination edge or broadcast MAC\n *  address. */\n", "func_signal": "static int send_PACKET( n2n_edge_t * eee,\n                        n2n_mac_t dstMac,\n                        const uint8_t * pktbuf,\n                        size_t pktlen )", "code": "{\n    int dest;\n    ssize_t s;\n    n2n_sock_str_t sockbuf;\n    n2n_sock_t destination;\n\n    /* hexdump( pktbuf, pktlen ); */\n\n    dest = find_peer_destination(eee, dstMac, &destination);\n\n    if ( dest )\n    {\n        ++(eee->tx_p2p);\n    }\n    else\n    {\n        ++(eee->tx_sup);\n    }\n\n    traceEvent( TRACE_INFO, \"send_PACKET to %s\", sock_to_cstr( sockbuf, &destination ) );\n\n    s = sendto_sock( eee->udp_sock, pktbuf, pktlen, &destination );\n\n    return 0;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** A PACKET has arrived containing an encapsulated ethernet datagram - usually\n *  encrypted. */\n", "func_signal": "static int handle_PACKET( n2n_edge_t * eee,\n                          const n2n_common_t * cmn,\n                          const n2n_PACKET_t * pkt,\n                          const n2n_sock_t * orig_sender,\n                          uint8_t * payload,\n                          size_t psize )", "code": "{\n    ssize_t             data_sent_len;\n    uint8_t             from_supernode;\n    uint8_t *           eth_payload=NULL;\n    int                 retval = -1;\n    time_t              now;\n\n    now = time(NULL);\n\n    traceEvent( TRACE_DEBUG, \"handle_PACKET size %u transform %u\", \n                (unsigned int)psize, (unsigned int)pkt->transform );\n    /* hexdump( payload, psize ); */\n\n    from_supernode= cmn->flags & N2N_FLAGS_FROM_SUPERNODE;\n\n    if ( from_supernode )\n    {\n        ++(eee->rx_sup);\n        eee->last_sup=now;\n    }\n    else\n    {\n        ++(eee->rx_p2p);\n        eee->last_p2p=now;\n    }\n\n    /* Update the sender in peer table entry */\n    check_peer( eee, from_supernode, pkt->srcMac, orig_sender );\n\n    /* Handle transform. */\n    {\n        uint8_t decodebuf[N2N_PKT_BUF_SIZE];\n        size_t eth_size;\n        size_t rx_transop_idx=0;\n\n        rx_transop_idx = transop_enum_to_index(pkt->transform);\n\n        if ( rx_transop_idx >=0 )\n        {\n            eth_payload = decodebuf;\n            eth_size = eee->transop[rx_transop_idx].rev( &(eee->transop[rx_transop_idx]),\n                                                         eth_payload, N2N_PKT_BUF_SIZE,\n                                                         payload, psize );\n            ++(eee->transop[rx_transop_idx].rx_cnt); /* stats */\n\n            /* Write ethernet packet to tap device. */\n            traceEvent( TRACE_INFO, \"sending to TAP %u\", (unsigned int)eth_size );\n            data_sent_len = tuntap_write(&(eee->device), eth_payload, eth_size);\n\n            if (data_sent_len == eth_size)\n            {\n                retval = 0;\n            }\n        }\n        else\n        {\n            traceEvent( TRACE_ERROR, \"handle_PACKET dropped unknown transform enum %u\", \n                        (unsigned int)pkt->transform );\n        }\n    }\n\n    return retval;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Send a datagram to a socket defined by a n2n_sock_t */\n", "func_signal": "static ssize_t sendto_sock( int fd, const void * buf, size_t len, const n2n_sock_t * dest )", "code": "{\n    struct sockaddr_in peer_addr;\n    ssize_t sent;\n\n    fill_sockaddr( (struct sockaddr *) &peer_addr,\n                   sizeof(peer_addr),\n                   dest );\n\n    sent = sendto( fd, buf, len, 0/*flags*/,\n                   (struct sockaddr *)&peer_addr, sizeof(struct sockaddr_in) );\n    if ( sent < 0 )\n    {\n        char * c = strerror(errno);\n        traceEvent( TRACE_ERROR, \"sendto failed (%d) %s\", errno, c );\n    }\n    else\n    {\n        traceEvent( TRACE_DEBUG, \"sendto sent=%d to \", (signed int)sent );\n    }\n\n    return sent;\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/** Called from update_supernode_reg to periodically send gratuitous ARP\n *  broadcasts. */\n", "func_signal": "static void send_grat_arps(n2n_edge_t * eee,)", "code": "{\n  char buffer[48];\n  size_t len;\n\n  traceEvent(TRACE_NORMAL, \"Sending gratuitous ARP...\");\n  len = build_gratuitous_arp(buffer, sizeof(buffer));\n  send_packet2net(eee, buffer, len);\n  send_packet2net(eee, buffer, len); /* Two is better than one :-) */\n}", "path": "edge.c", "repo_name": "fishman/n2n", "stars": 25, "license": "gpl-3.0", "language": "c", "size": 489}
{"docstring": "/* Attempts to resize OLD_BLOCK to NEW_SIZE bytes, possibly\n   moving it in the process.\n   If successful, returns the new block; on failure, returns a\n   null pointer.\n   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).\n   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */\n", "func_signal": "void *\nrealloc (void *old_block, size_t new_size)", "code": "{\n  if (new_size == 0) \n    {\n      free (old_block);\n      return NULL;\n    }\n  else \n    {\n      void *new_block = malloc (new_size);\n      if (old_block != NULL && new_block != NULL)\n        {\n          size_t old_size = block_size (old_block);\n          size_t min_size = new_size < old_size ? new_size : old_size;\n          memcpy (new_block, old_block, min_size);\n          free (old_block);\n        }\n      return new_block;\n    }\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Sets up a proper GDT.  The bootstrap loader's GDT didn't\n   include user-mode selectors or a TSS, but we need both now. */\n", "func_signal": "void\ngdt_init (void)", "code": "{\n  uint64_t gdtr_operand;\n\n  /* Initialize GDT. */\n  gdt[SEL_NULL / sizeof *gdt] = 0;\n  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);\n  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);\n  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);\n  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);\n  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());\n\n  /* Load GDTR, TR.  See [IA32-v3a] 2.4.1 \"Global Descriptor\n     Table Register (GDTR)\", 2.4.4 \"Task Register (TR)\", and\n     6.2.4 \"Task Register\".  */\n  gdtr_operand = make_gdtr_operand (sizeof gdt - 1, gdt);\n  asm volatile (\"lgdt %0\" : : \"m\" (gdtr_operand));\n  asm volatile (\"ltr %w0\" : : \"q\" (SEL_TSS));\n}", "path": "userprog\\gdt.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Frees block P, which must have been previously allocated with\n   malloc(), calloc(), or realloc(). */\n", "func_signal": "void\nfree (void *p)", "code": "{\n  if (p != NULL)\n    {\n      struct block *b = p;\n      struct arena *a = block_to_arena (b);\n      struct desc *d = a->desc;\n      \n      if (d != NULL) \n        {\n          /* It's a normal block.  We handle it here. */\n\n#ifndef NDEBUG\n          /* Clear the block to help detect use-after-free bugs. */\n          memset (b, 0xcc, d->block_size);\n#endif\n  \n          lock_acquire (&d->lock);\n\n          /* Add block to free list. */\n          list_push_front (&d->free_list, &b->free_elem);\n\n          /* If the arena is now entirely unused, free it. */\n          if (++a->free_cnt >= d->blocks_per_arena) \n            {\n              size_t i;\n\n              ASSERT (a->free_cnt == d->blocks_per_arena);\n              for (i = 0; i < d->blocks_per_arena; i++) \n                {\n                  struct block *b = arena_to_block (a, i);\n                  list_remove (&b->free_elem);\n                }\n              palloc_free_page (a);\n            }\n\n          lock_release (&d->lock);\n        }\n      else\n        {\n          /* It's a big block.  Free its pages. */\n          palloc_free_multiple (a, a->free_cnt);\n          return;\n        }\n    }\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Partitions ARRAY in-place in an initial run of bytes all less\n   than PIVOT, followed by a run of bytes all greater than or\n   equal to PIVOT.  Returns the length of the initial run. */\n", "func_signal": "static size_t\npartition (unsigned char *array, size_t size, int pivot)", "code": "{\n  size_t left_size = size;\n  unsigned char *first = array;\n  unsigned char *last = first + left_size;\n\n  for (;;)\n    {\n      /* Move FIRST forward to point to first element greater than\n         PIVOT. */\n      for (;;)\n        {\n          if (first == last)\n            {\n              ASSERT (is_partitioned (array, size, pivot, left_size));\n              return left_size;\n            }\n          else if (*first >= pivot)\n            break;\n\n          first++;\n        }\n      left_size--;\n\n      /* Move LAST backward to point to last element no bigger\n         than PIVOT. */\n      for (;;)\n        {\n          last--;\n\n          if (first == last)\n            {\n              ASSERT (is_partitioned (array, size, pivot, left_size));\n              return left_size;\n            }\n          else if (*last < pivot)\n            break;\n          else\n            left_size--;\n        }\n\n      /* By swapping FIRST and LAST we extend the starting and\n         ending sequences that pass and fail, respectively,\n         PREDICATE. */\n      swap (first, last);\n      first++;\n    }\n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Checks whether the SIZE bytes in ARRAY are divided into an\n   initial LEFT_SIZE elements all less than PIVOT followed by\n   SIZE - LEFT_SIZE elements all greater than or equal to\n   PIVOT. */\n", "func_signal": "static bool\nis_partitioned (const unsigned char *array, size_t size,\n                unsigned char pivot, size_t left_size)", "code": "{\n  size_t i;\n  \n  for (i = 0; i < left_size; i++)\n    if (array[i] >= pivot)\n      return false;\n\n  for (; i < size; i++)\n    if (array[i] < pivot)\n      return false;\n\n  return true;\n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Divides signed 64-bit N by signed 64-bit D and returns the\n   quotient. */\n", "func_signal": "static int64_t\nsdiv64 (int64_t n, int64_t d)", "code": "{\n  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;\n  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;\n  uint64_t q_abs = udiv64 (n_abs, d_abs);\n  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;\n}", "path": "lib\\arithmetic.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* If *POS is past the beginning of LINE, backs up one character\n   position.  Returns true if successful, false if nothing was\n   done. */\n", "func_signal": "static bool\nbackspace (char **pos, char line[])", "code": "{\n  if (*pos > line)\n    {\n      /* Back up cursor, overwrite character, back up\n         again. */\n      printf (\"\\b \\b\");\n      (*pos)--;\n      return true;\n    }\n  else\n    return false;\n}", "path": "examples\\shell.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Returns true if the SIZE bytes in BUF are in nondecreasing\n   order, false otherwise. */\n", "func_signal": "static bool\nis_sorted (const unsigned char *buf, size_t size)", "code": "{\n  size_t i;\n\n  for (i = 1; i < size; i++)\n    if (buf[i - 1] > buf[i])\n      return false;\n\n  return true;\n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the\n   quotient. */\n", "func_signal": "static uint64_t\nudiv64 (uint64_t n, uint64_t d)", "code": "{\n  if ((d >> 32) == 0) \n    {\n      /* Proof of correctness:\n\n         Let n, d, b, n1, and n0 be defined as in this function.\n         Let [x] be the \"floor\" of x.  Let T = b[n1/d].  Assume d\n         nonzero.  Then:\n             [n/d] = [n/d] - T + T\n                   = [n/d - T] + T                         by (1) below\n                   = [(b*n1 + n0)/d - T] + T               by definition of n\n                   = [(b*n1 + n0)/d - dT/d] + T\n                   = [(b(n1 - d[n1/d]) + n0)/d] + T\n                   = [(b[n1 % d] + n0)/d] + T,             by definition of %\n         which is the expression calculated below.\n\n         (1) Note that for any real x, integer i: [x] + i = [x + i].\n\n         To prevent divl() from trapping, [(b[n1 % d] + n0)/d] must\n         be less than b.  Assume that [n1 % d] and n0 take their\n         respective maximum values of d - 1 and b - 1:\n                 [(b(d - 1) + (b - 1))/d] < b\n             <=> [(bd - 1)/d] < b\n             <=> [b - 1/d] < b\n         which is a tautology.\n\n         Therefore, this code is correct and will not trap. */\n      uint64_t b = 1ULL << 32;\n      uint32_t n1 = n >> 32;\n      uint32_t n0 = n; \n      uint32_t d0 = d;\n\n      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); \n    }\n  else \n    {\n      /* Based on the algorithm and proof available from\n         http://www.hackersdelight.org/revisions.pdf. */\n      if (n < d)\n        return 0;\n      else \n        {\n          uint32_t d1 = d >> 32;\n          int s = nlz (d1);\n          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);\n          return n - (q - 1) * d < d ? q - 1 : q; \n        }\n    }\n}", "path": "lib\\arithmetic.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Swaps the bytes at *A and *B. */\n", "func_signal": "static void\nswap (unsigned char *a, unsigned char *b)", "code": "{\n  unsigned char t = *a;\n  *a = *b;\n  *b = t;\n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Picks a pivot for the quicksort from the SIZE bytes in BUF. */\n", "func_signal": "static unsigned char\npick_pivot (unsigned char *buf, size_t size)", "code": "{\n  ASSERT (size >= 1);\n  return buf[random_ulong () % size];\n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Reads a line of input from the user into LINE, which has room\n   for SIZE bytes.  Handles backspace and Ctrl+U in the ways\n   expected by Unix users.  On return, LINE will always be\n   null-terminated and will not end in a new-line character. */\n", "func_signal": "static void\nread_line (char line[], size_t size)", "code": "{\n  char *pos = line;\n  for (;;)\n    {\n      char c;\n      read (STDIN_FILENO, &c, 1);\n\n      switch (c) \n        {\n        case '\\r':\n          *pos = '\\0';\n          putchar ('\\n');\n          return;\n\n        case '\\b':\n          backspace (&pos, line);\n          break;\n\n        case ('U' - 'A') + 1:       /* Ctrl+U. */\n          while (backspace (&pos, line))\n            continue;\n          break;\n\n        default:\n          /* Add character to line. */\n          if (pos < line + size - 1) \n            {\n              putchar (c);\n              *pos++ = c;\n            }\n          break;\n        }\n    }\n}", "path": "examples\\shell.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Allocates and return A times B bytes initialized to zeroes.\n   Returns a null pointer if memory is not available. */\n", "func_signal": "void *\ncalloc (size_t a, size_t b)", "code": "{\n  void *p;\n  size_t size;\n\n  /* Calculate block size and make sure it fits in size_t. */\n  size = a * b;\n  if (size < a || size < b)\n    return NULL;\n\n  /* Allocate and zero memory. */\n  p = malloc (size);\n  if (p != NULL)\n    memset (p, 0, size);\n\n  return p;\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Returns the (IDX - 1)'th block within arena A. */\n", "func_signal": "static struct block *\narena_to_block (struct arena *a, size_t idx)", "code": "{\n  ASSERT (a != NULL);\n  ASSERT (a->magic == ARENA_MAGIC);\n  ASSERT (idx < a->desc->blocks_per_arena);\n  return (struct block *) ((uint8_t *) a\n                           + sizeof *a\n                           + idx * a->desc->block_size);\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Sorts the SIZE bytes in BUF into nondecreasing order, using\n   the quick-sort algorithm. */\n", "func_signal": "void\nqsort_bytes (unsigned char *buf, size_t size)", "code": "{\n  if (!is_sorted (buf, size)) \n    {\n      int pivot = pick_pivot (buf, size);\n\n      unsigned char *left_half = buf;\n      size_t left_size = partition (buf, size, pivot);\n      unsigned char *right_half = left_half + left_size;\n      size_t right_size = size - left_size;\n  \n      if (left_size <= right_size) \n        {\n          qsort_bytes (left_half, left_size);\n          qsort_bytes (right_half, right_size); \n        }\n      else\n        {\n          qsort_bytes (right_half, right_size); \n          qsort_bytes (left_half, left_size);\n        }\n    } \n}", "path": "tests\\vm\\qsort.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Returns the arena that block B is inside. */\n", "func_signal": "static struct arena *\nblock_to_arena (struct block *b)", "code": "{\n  struct arena *a = pg_round_down (b);\n\n  /* Check that the arena is valid. */\n  ASSERT (a != NULL);\n  ASSERT (a->magic == ARENA_MAGIC);\n\n  /* Check that the block is properly aligned for the arena. */\n  ASSERT (a->desc == NULL\n          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);\n  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);\n\n  return a;\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Returns the number of leading zero bits in X,\n   which must be nonzero. */\n", "func_signal": "static int\nnlz (uint32_t x)", "code": "{\n  /* This technique is portable, but there are better ways to do\n     it on particular systems.  With sufficiently new enough GCC,\n     you can use __builtin_clz() to take advantage of GCC's\n     knowledge of how to do it.  Or you can use the x86 BSR\n     instruction directly. */\n  int n = 0;\n  if (x <= 0x0000FFFF)\n    {\n      n += 16;\n      x <<= 16; \n    }\n  if (x <= 0x00FFFFFF)\n    {\n      n += 8;\n      x <<= 8; \n    }\n  if (x <= 0x0FFFFFFF)\n    {\n      n += 4;\n      x <<= 4;\n    }\n  if (x <= 0x3FFFFFFF)\n    {\n      n += 2;\n      x <<= 2; \n    }\n  if (x <= 0x7FFFFFFF)\n    n++;\n  return n;\n}", "path": "lib\\arithmetic.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Returns the number of bytes allocated for BLOCK. */\n", "func_signal": "static size_t\nblock_size (void *block)", "code": "{\n  struct block *b = block;\n  struct arena *a = block_to_arena (b);\n  struct desc *d = a->desc;\n\n  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Uses x86 DIVL instruction to divide 64-bit N by 32-bit D to\n   yield a 32-bit quotient.  Returns the quotient.\n   Traps with a divide error (#DE) if the quotient does not fit\n   in 32 bits. */\n", "func_signal": "static inline uint32_t\ndivl (uint64_t n, uint32_t d)", "code": "{\n  uint32_t n1 = n >> 32;\n  uint32_t n0 = n;\n  uint32_t q, r;\n\n  asm (\"divl %4\"\n       : \"=d\" (r), \"=a\" (q)\n       : \"0\" (n1), \"1\" (n0), \"rm\" (d));\n\n  return q;\n}", "path": "lib\\arithmetic.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/* Obtains and returns a new block of at least SIZE bytes.\n   Returns a null pointer if memory is not available. */\n", "func_signal": "void *\nmalloc (size_t size)", "code": "{\n  struct desc *d;\n  struct block *b;\n  struct arena *a;\n\n  /* A null pointer satisfies a request for 0 bytes. */\n  if (size == 0)\n    return NULL;\n\n  /* Find the smallest descriptor that satisfies a SIZE-byte\n     request. */\n  for (d = descs; d < descs + desc_cnt; d++)\n    if (d->block_size >= size)\n      break;\n  if (d == descs + desc_cnt) \n    {\n      /* SIZE is too big for any descriptor.\n         Allocate enough pages to hold SIZE plus an arena. */\n      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);\n      a = palloc_get_multiple (0, page_cnt);\n      if (a == NULL)\n        return NULL;\n\n      /* Initialize the arena to indicate a big block of PAGE_CNT\n         pages, and return it. */\n      a->magic = ARENA_MAGIC;\n      a->desc = NULL;\n      a->free_cnt = page_cnt;\n      return a + 1;\n    }\n\n  lock_acquire (&d->lock);\n\n  /* If the free list is empty, create a new arena. */\n  if (list_empty (&d->free_list))\n    {\n      size_t i;\n\n      /* Allocate a page. */\n      a = palloc_get_page (0);\n      if (a == NULL) \n        {\n          lock_release (&d->lock);\n          return NULL; \n        }\n\n      /* Initialize arena and add its blocks to the free list. */\n      a->magic = ARENA_MAGIC;\n      a->desc = d;\n      a->free_cnt = d->blocks_per_arena;\n      for (i = 0; i < d->blocks_per_arena; i++) \n        {\n          struct block *b = arena_to_block (a, i);\n          list_push_back (&d->free_list, &b->free_elem);\n        }\n    }\n\n  /* Get a block from free list and return it. */\n  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);\n  a = block_to_arena (b);\n  a->free_cnt--;\n  lock_release (&d->lock);\n  return b;\n}", "path": "threads\\malloc.c", "repo_name": "yuwumichcn223/pintos", "stars": 31, "license": "other", "language": "c", "size": 453}
{"docstring": "/*\n * Returns a connection from the freelist, if any.\n */\n", "func_signal": "conn *conn_from_freelist()", "code": "{\n    conn *c;\n\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr > 0) {\n        c = freeconns[--freecurr];\n    } else {\n        c = NULL;\n    }\n    pthread_mutex_unlock(&conn_lock);\n\n    return c;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n", "func_signal": "static int add_iov(conn *c, const void *buf, int len)", "code": "{\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\n", "func_signal": "static int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file)", "code": "{\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM)\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        else\n          perror(\"getaddrinfo()\");\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == -1) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            if (errno == EMFILE) {\n                /* ...unless we're out of fds */\n                perror(\"server_socket\");\n                exit(EX_OSERR);\n            }\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                perror(\"setsockopt\");\n                close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {\n            if (errno != EADDRINUSE) {\n                perror(\"bind()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {\n                perror(\"listen()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base))) {\n                fprintf(stderr, \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* Note: this isn't an assoc_update.  The key must not already exist to call this */\n", "func_signal": "int assoc_insert(item *it, const uint32_t hv)", "code": "{\n    unsigned int oldbucket;\n\n//    assert(assoc_find(ITEM_key(it), it->nkey) == 0);  /* shouldn't have duplicately named things defined */\n\n    if (expanding &&\n        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)\n    {\n        it->h_next = old_hashtable[oldbucket];\n        old_hashtable[oldbucket] = it;\n    } else {\n        it->h_next = primary_hashtable[hv & hashmask(hashpower)];\n        primary_hashtable[hv & hashmask(hashpower)] = it;\n    }\n\n    hash_items++;\n    if (! expanding && hash_items > (hashsize(hashpower) * 3) / 2) {\n        assoc_expand();\n    }\n\n    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it->nkey, hash_items);\n    return 1;\n}", "path": "assoc.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\n", "func_signal": "static enum transmit_result transmit(conn *c)", "code": "{\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_written += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0)\n            perror(\"Failed to write, and not due to blocking\");\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* grows the hashtable to the next power of 2. */\n", "func_signal": "static void assoc_expand(void)", "code": "{\n    old_hashtable = primary_hashtable;\n\n    primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *));\n    if (primary_hashtable) {\n        if (settings.verbose > 1)\n            fprintf(stderr, \"Hash table expansion starting\\n\");\n        hashpower++;\n        expanding = true;\n        expand_bucket = 0;\n        STATS_LOCK();\n        stats.hash_power_level = hashpower;\n        stats.hash_bytes += hashsize(hashpower) * sizeof(void *);\n        stats.hash_is_expanding = 1;\n        STATS_UNLOCK();\n        pthread_cond_signal(&maintenance_cond);\n    } else {\n        primary_hashtable = old_hashtable;\n        /* Bad news, but we can keep running. */\n    }\n}", "path": "assoc.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Adds a connection to the freelist. 0 = success.\n */\n", "func_signal": "bool conn_add_to_freelist(conn *c)", "code": "{\n    bool ret = true;\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr < freetotal) {\n        freeconns[freecurr++] = c;\n        ret = false;\n    } else {\n        /* try to enlarge free connections array */\n        size_t newsize = freetotal * 2;\n        conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);\n        if (new_freeconns) {\n            freetotal = newsize;\n            freeconns = new_freeconns;\n            freeconns[freecurr++] = c;\n            ret = false;\n        }\n    }\n    pthread_mutex_unlock(&conn_lock);\n    return ret;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* Form and send a response to a command over the binary protocol */\n", "func_signal": "static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen)", "code": "{\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* return server specific stats only */\n", "func_signal": "static void server_stats(ADD_STAT add_stats, conn *c)", "code": "{\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef WIN32\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif /* !WIN32 */\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef WIN32\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif /* !WIN32 */\n\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns - 1);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    if (settings.maxconns_fast) {\n        APPEND_STAT(\"rejected_connections\", \"%llu\", (unsigned long long)stats.rejected_conns);\n    }\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"reserved_fds\", \"%u\", stats.reserved_fds);\n    APPEND_STAT(\"cmd_get\", \"%llu\", (unsigned long long)thread_stats.get_cmds);\n    APPEND_STAT(\"cmd_set\", \"%llu\", (unsigned long long)slab_stats.set_cmds);\n    APPEND_STAT(\"cmd_flush\", \"%llu\", (unsigned long long)thread_stats.flush_cmds);\n    APPEND_STAT(\"cmd_touch\", \"%llu\", (unsigned long long)thread_stats.touch_cmds);\n    APPEND_STAT(\"get_hits\", \"%llu\", (unsigned long long)slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%llu\", (unsigned long long)thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%llu\", (unsigned long long)thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%llu\", (unsigned long long)slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%llu\", (unsigned long long)thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%llu\", (unsigned long long)slab_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%llu\", (unsigned long long)thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%llu\", (unsigned long long)slab_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%llu\", (unsigned long long)thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%llu\", (unsigned long long)slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%llu\", (unsigned long long)slab_stats.cas_badval);\n    APPEND_STAT(\"touch_hits\", \"%llu\", (unsigned long long)slab_stats.touch_hits);\n    APPEND_STAT(\"touch_misses\", \"%llu\", (unsigned long long)thread_stats.touch_misses);\n    APPEND_STAT(\"auth_cmds\", \"%llu\", (unsigned long long)thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%llu\", (unsigned long long)thread_stats.auth_errors);\n    APPEND_STAT(\"bytes_read\", \"%llu\", (unsigned long long)thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%llu\", (unsigned long long)thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\", stats.accepting_conns);\n    APPEND_STAT(\"listen_disabled_num\", \"%llu\", (unsigned long long)stats.listen_disabled_num);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%llu\", (unsigned long long)thread_stats.conn_yields);\n    APPEND_STAT(\"hash_power_level\", \"%u\", stats.hash_power_level);\n    APPEND_STAT(\"hash_bytes\", \"%llu\", (unsigned long long)stats.hash_bytes);\n    APPEND_STAT(\"hash_is_expanding\", \"%u\", stats.hash_is_expanding);\n    APPEND_STAT(\"expired_unfetched\", \"%llu\", stats.expired_unfetched);\n    APPEND_STAT(\"evicted_unfetched\", \"%llu\", stats.evicted_unfetched);\n#ifdef USE_REPLICATION\n    APPEND_STAT(\"replication\", \"MASTER\", 0);\n    APPEND_STAT(\"repcached_version\", \"%s\", REPCACHED_VERSION);\n    APPEND_STAT(\"repcached_qi_free\", \"%u\", settings.rep_qmax - get_qi_count());\n#endif /*USE_REPLICATION*/\n    if (settings.slab_reassign) {\n        APPEND_STAT(\"slab_reassign_running\", \"%u\", stats.slab_reassign_running);\n        APPEND_STAT(\"slabs_moved\", \"%llu\", stats.slabs_moved);\n    }\n    STATS_UNLOCK();\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * given time value that's either unix time or delta from current unix time, return\n * unix time. Use the fact that delta can't exceed one month (and real time value can't\n * be that low).\n */\n", "func_signal": "static rel_time_t realtime(const time_t exptime)", "code": "{\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* refcount == 0 is safe since nobody can incr while cache_lock is held.\n * refcount != 0 is impossible since flags/etc can be modified in other\n * threads. instead, note we found a busy one and bail. logic in do_item_get\n * will prevent busy items from continuing to be busy\n */\n", "func_signal": "static int slab_rebalance_move(void)", "code": "{\n    slabclass_t *s_cls;\n    int x;\n    int was_busy = 0;\n    int refcount = 0;\n    enum move_status status = MOVE_PASS;\n\n    pthread_mutex_lock(&cache_lock);\n    pthread_mutex_lock(&slabs_lock);\n\n    s_cls = &slabclass[slab_rebal.s_clsid];\n\n    for (x = 0; x < slab_bulk_check; x++) {\n        item *it = slab_rebal.slab_pos;\n        status = MOVE_PASS;\n        if (it->slabs_clsid != 255) {\n            refcount = refcount_incr(&it->refcount);\n            if (refcount == 1) { /* item is unlinked, unused */\n                if (it->it_flags & ITEM_SLABBED) {\n                    /* remove from slab freelist */\n                    if (s_cls->slots == it) {\n                        s_cls->slots = it->next;\n                    }\n                    if (it->next) it->next->prev = it->prev;\n                    if (it->prev) it->prev->next = it->next;\n                    s_cls->sl_curr--;\n                    status = MOVE_DONE;\n                } else {\n                    status = MOVE_BUSY;\n                }\n            } else if (refcount == 2) { /* item is linked but not busy */\n                if ((it->it_flags & ITEM_LINKED) != 0) {\n                    do_item_unlink_nolock(it, hash(ITEM_key(it), it->nkey, 0));\n                    status = MOVE_DONE;\n                } else {\n                    /* refcount == 1 + !ITEM_LINKED means the item is being\n                     * uploaded to, or was just unlinked but hasn't been freed\n                     * yet. Let it bleed off on its own and try again later */\n                    status = MOVE_BUSY;\n                }\n            } else {\n                if (settings.verbose > 2) {\n                    fprintf(stderr, \"Slab reassign hit a busy item: refcount: %d (%d -> %d)\\n\",\n                        it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);\n                }\n                status = MOVE_BUSY;\n            }\n        }\n\n        switch (status) {\n            case MOVE_DONE:\n                it->refcount = 0;\n                it->it_flags = 0;\n                it->slabs_clsid = 255;\n                break;\n            case MOVE_BUSY:\n                slab_rebal.busy_items++;\n                was_busy++;\n                refcount_decr(&it->refcount);\n                break;\n            case MOVE_PASS:\n                break;\n        }\n\n        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;\n        if (slab_rebal.slab_pos >= slab_rebal.slab_end)\n            break;\n    }\n\n    if (slab_rebal.slab_pos >= slab_rebal.slab_end) {\n        /* Some items were busy, start again from the top */\n        if (slab_rebal.busy_items) {\n            slab_rebal.slab_pos = slab_rebal.slab_start;\n            slab_rebal.busy_items = 0;\n        } else {\n            slab_rebal.done++;\n        }\n    }\n\n    pthread_mutex_unlock(&slabs_lock);\n    pthread_mutex_unlock(&cache_lock);\n\n    return was_busy;\n}", "path": "slabs.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* ntokens is overwritten here... shrug.. */\n", "func_signal": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas)", "code": "{\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            it = item_get(key, nkey);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    item_remove(it);\n                    return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                            \" %llu\\r\\n\",\n                                            (unsigned long long)ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, ITEM_data(it), it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1)\n                    fprintf(stderr, \">%d sending key %s\\n\", c->sfd, ITEM_key(it));\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                item_update(it);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* returns the address of the item pointer before the key.  if *item == 0,\n   the item wasn't found */\n", "func_signal": "static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv)", "code": "{\n    item **pos;\n    unsigned int oldbucket;\n\n    if (expanding &&\n        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)\n    {\n        pos = &old_hashtable[oldbucket];\n    } else {\n        pos = &primary_hashtable[hv & hashmask(hashpower)];\n    }\n\n    while (*pos && ((nkey != (*pos)->nkey) || memcmp(key, ITEM_key(*pos), nkey))) {\n        pos = &(*pos)->h_next;\n    }\n    return pos;\n}", "path": "assoc.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/**\n * Function to start the server and let it listen on a random port\n *\n * @param port_out where to store the TCP port number the server is\n *                 listening on\n * @param daemon set to true if you want to run the memcached server\n *               as a daemon process\n * @return the pid of the memcached server\n */\n", "func_signal": "static pid_t start_server(in_port_t *port_out, bool daemon, int timeout)", "code": "{\n    char environment[80];\n    snprintf(environment, sizeof(environment),\n             \"MEMCACHED_PORT_FILENAME=/tmp/ports.%lu\", (long)getpid());\n    char *filename= environment + strlen(\"MEMCACHED_PORT_FILENAME=\");\n    char pid_file[80];\n    snprintf(pid_file, sizeof(pid_file), \"/tmp/pid.%lu\", (long)getpid());\n\n    remove(filename);\n    remove(pid_file);\n\n#ifdef __sun\n    /* I want to name the corefiles differently so that they don't\n       overwrite each other\n    */\n    char coreadm[128];\n    snprintf(coreadm, sizeof(coreadm),\n             \"coreadm -p core.%%f.%%p %lu\", (unsigned long)getpid());\n    system(coreadm);\n#endif\n\n    pid_t pid = fork();\n    assert(pid != -1);\n\n    if (pid == 0) {\n        /* Child */\n        char *argv[20];\n        int arg = 0;\n        char tmo[24];\n        snprintf(tmo, sizeof(tmo), \"%u\", timeout);\n\n        putenv(environment);\n#ifdef __sun\n        putenv(\"LD_PRELOAD=watchmalloc.so.1\");\n        putenv(\"MALLOC_DEBUG=WATCH\");\n#endif\n\n        if (!daemon) {\n            argv[arg++] = \"./timedrun\";\n            argv[arg++] = tmo;\n        }\n        argv[arg++] = \"./memcached-debug\";\n        argv[arg++] = \"-p\";\n        argv[arg++] = \"-1\";\n        argv[arg++] = \"-U\";\n        argv[arg++] = \"0\";\n#ifdef USE_REPLICATION\n        argv[arg++] = \"-X\";\n        argv[arg++] = \"0\";\n#endif\n        /* Handle rpmbuild and the like doing this as root */\n        if (getuid() == 0) {\n            argv[arg++] = \"-u\";\n            argv[arg++] = \"root\";\n        }\n        if (daemon) {\n            argv[arg++] = \"-d\";\n            argv[arg++] = \"-P\";\n            argv[arg++] = pid_file;\n        }\n#ifdef MESSAGE_DEBUG\n         argv[arg++] = \"-vvv\";\n#endif\n        argv[arg++] = NULL;\n        assert(execv(argv[0], argv) != -1);\n    }\n\n    /* Yeah just let us \"busy-wait\" for the file to be created ;-) */\n    while (access(filename, F_OK) == -1) {\n        usleep(10);\n    }\n\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        fprintf(stderr, \"Failed to open the file containing port numbers: %s\\n\",\n                strerror(errno));\n        assert(false);\n    }\n\n    *port_out = (in_port_t)-1;\n    char buffer[80];\n    while ((fgets(buffer, sizeof(buffer), fp)) != NULL) {\n        if (strncmp(buffer, \"TCP INET: \", 10) == 0) {\n            int32_t val;\n            assert(safe_strtol(buffer + 10, &val));\n            *port_out = (in_port_t)val;\n        }\n    }\n    fclose(fp);\n    assert(remove(filename) == 0);\n\n    if (daemon) {\n        /* loop and wait for the pid file.. There is a potential race\n         * condition that the server just created the file but isn't\n         * finished writing the content, but I'll take the chance....\n         */\n        while (access(pid_file, F_OK) == -1) {\n            usleep(10);\n        }\n\n        fp = fopen(pid_file, \"r\");\n        if (fp == NULL) {\n            fprintf(stderr, \"Failed to open pid file: %s\\n\",\n                    strerror(errno));\n            assert(false);\n        }\n        assert(fgets(buffer, sizeof(buffer), fp) != NULL);\n        fclose(fp);\n\n        int32_t val;\n        assert(safe_strtol(buffer, &val));\n        pid = (pid_t)val;\n    }\n\n    return pid;\n}", "path": "testapp.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\n", "func_signal": "static void maximize_sndbuf(const int sfd)", "code": "{\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * read a UDP request.\n */\n", "func_signal": "static enum try_read_result try_read_udp(conn *c)", "code": "{\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, &c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_read += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes = res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* Just write an error message and disconnect the client */\n", "func_signal": "static void handle_binary_protocol_error(conn *c)", "code": "{\n    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        fprintf(stderr, \"Protocol error (opcode %02x), close connection %d\\n\",\n                c->binary_header.request.opcode, c->sfd);\n    }\n    c->write_and_go = conn_closing;\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Frees a connection.\n */\n", "func_signal": "void conn_free(conn *c)", "code": "{\n    if (c) {\n        MEMCACHED_CONN_DESTROY(c);\n        if (c->hdrbuf)\n            free(c->hdrbuf);\n        if (c->msglist)\n            free(c->msglist);\n        if (c->rbuf)\n            free(c->rbuf);\n        if (c->wbuf)\n            free(c->wbuf);\n        if (c->ilist)\n            free(c->ilist);\n        if (c->suffixlist)\n            free(c->suffixlist);\n        if (c->iov)\n            free(c->iov);\n        free(c);\n    }\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*@null@*/\n", "func_signal": "static void do_slabs_stats(ADD_STAT add_stats, void *c)", "code": "{\n    int i, total;\n    /* Get the per-thread stats which contain some interesting aggregates */\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n\n    total = 0;\n    for(i = POWER_SMALLEST; i <= power_largest; i++) {\n        slabclass_t *p = &slabclass[i];\n        if (p->slabs != 0) {\n            uint32_t perslab, slabs;\n            slabs = p->slabs;\n            perslab = p->perslab;\n\n            char key_str[STAT_KEY_LEN];\n            char val_str[STAT_VAL_LEN];\n            int klen = 0, vlen = 0;\n\n            APPEND_NUM_STAT(i, \"chunk_size\", \"%u\", p->size);\n            APPEND_NUM_STAT(i, \"chunks_per_page\", \"%u\", perslab);\n            APPEND_NUM_STAT(i, \"total_pages\", \"%u\", slabs);\n            APPEND_NUM_STAT(i, \"total_chunks\", \"%u\", slabs * perslab);\n            APPEND_NUM_STAT(i, \"used_chunks\", \"%u\",\n                            slabs*perslab - p->sl_curr - p->end_page_free);\n            APPEND_NUM_STAT(i, \"free_chunks\", \"%u\", p->sl_curr);\n            APPEND_NUM_STAT(i, \"free_chunks_end\", \"%u\", p->end_page_free);\n            APPEND_NUM_STAT(i, \"mem_requested\", \"%llu\",\n                            (unsigned long long)p->requested);\n            APPEND_NUM_STAT(i, \"get_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].get_hits);\n            APPEND_NUM_STAT(i, \"cmd_set\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].set_cmds);\n            APPEND_NUM_STAT(i, \"delete_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].delete_hits);\n            APPEND_NUM_STAT(i, \"incr_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].incr_hits);\n            APPEND_NUM_STAT(i, \"decr_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].decr_hits);\n            APPEND_NUM_STAT(i, \"cas_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].cas_hits);\n            APPEND_NUM_STAT(i, \"cas_badval\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].cas_badval);\n            APPEND_NUM_STAT(i, \"touch_hits\", \"%llu\",\n                    (unsigned long long)thread_stats.slab_stats[i].touch_hits);\n            total++;\n        }\n    }\n\n    /* add overall slab stats and append terminator */\n\n    APPEND_STAT(\"active_slabs\", \"%d\", total);\n    APPEND_STAT(\"total_malloced\", \"%llu\", (unsigned long long)mem_malloced);\n    add_stats(NULL, 0, NULL, 0, c);\n}", "path": "slabs.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/* set up a connection to write a buffer then free it, used for stats */\n", "func_signal": "static void write_and_free(conn *c, char *buf, int bytes)", "code": "{\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}", "path": "memcached.c", "repo_name": "kspe/repcached", "stars": 31, "license": "bsd-3-clause", "language": "c", "size": 570}
{"docstring": "/*\n * Free the bxxpmInternAttrib pointers which have been allocated\n */\n", "func_signal": "static void xpmFreeInternAttrib\nARGLIST((attrib))\nGRA(bxxpmInternAttrib *, attrib)", "code": "{\n    unsigned int a;\n\n    if (attrib->colorTable)\n        xpmFreeColorTable(attrib->colorTable, attrib->ncolors);\n    if (attrib->pixelindex)\n        free((char *)attrib->pixelindex);\n    if (attrib->xcolors)\n        free((char *)attrib->xcolors);\n    if (attrib->colorStrings) {\n        for (a = 0; a < attrib->ncolors; a++)\n            if (attrib->colorStrings[a])\n                free((char *)attrib->colorStrings[a]);\n        free((char *)attrib->colorStrings);\n    }\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      copyWcsToMbs(mbs, wcs, len);\n * Description:\n *      Create a mbs string from an input wcs. This function allocates\n *\ta buffer if necessary.\n * Input:\n *\tmbs - char* : destination for the converted/copied output\n *\twcs - wchar_t* : pointer to wcs to copy/convert\n *\tlen - int : the number of wchar_t' to convert\n *\tprocess_it - Boolean : True if processing of quoted charcters,\n *\t\t\tFalse if blind.\n * Output:\n *      None\n */\n", "func_signal": "static void copyWcsToMbs\n    ARGLIST((mbs, wcs, len, process_it))\n        ARG(char *, mbs)\n        ARG(wchar_t *, wcs)\n        ARG(int, len)\n        GRA(Boolean, process_it)", "code": "{\n    static\twchar_t\t*tbuf = NULL;\n    static\tint\ttbufSize = 0;\n    \n    int\t\tnumCvt;\n    int\t\tlenToConvert;\n    wchar_t\t*fromP = wcs;\n    wchar_t\t*x = &fromP[len];\n    wchar_t\t*toP;\n    wchar_t\t*commonWChars = CStrCommonWideCharsGet();\n    wchar_t\ttmp;\n    \n    /*\n     * Make sure there's room in the buffer\n     */\n    if (tbufSize < len)\n    {\n\ttbuf = (wchar_t*)XtRealloc((char*)tbuf, (len + 1) * sizeof(wchar_t));\n\ttbufSize = len;\n    }\n    \n    /*\n     * Now copy and process\n     */\n    toP = tbuf;\n    lenToConvert = 0;\n    while (fromP < x)\n    {\n\t/*\n\t * Check for quoted characters\n\t */\n\tif ((*fromP == commonWChars[WBackSlash]) && process_it)\n\t{\n\t    fromP++;\t\t/* Skip quote */\n\t    if (fromP == x)\t/* Hanging quote? */\n\t    {\n\t\t*toP++ = commonWChars[WBackSlash];\n\t\tlenToConvert++;\n\t\tbreak;\n\t    }\n\t    tmp = *fromP++;\n\t    if (tmp == commonWChars[WideN])\n\t    {\n\t\t*toP++ = commonWChars[WNewLine];\n\t    }\n\t    else if (tmp == commonWChars[WideT])\n\t    {\n\t\t*toP++ = commonWChars[WTab];\n\t    }\n\t    else if (tmp == commonWChars[WideR])\n\t    {\n\t\t*toP++ = commonWChars[WCarriageReturn];\n\t    }\n\t    else if (tmp == commonWChars[WideF])\n\t    {\n\t\t*toP++ = commonWChars[WFormFeed];\n\t    }\n\t    else if (tmp == commonWChars[WideV])\n\t    {\n\t\t*toP++ = commonWChars[WVerticalTab];\n\t    }\n\t    else if (tmp == commonWChars[WBackSlash])\n\t    {\n\t\t*toP++ = commonWChars[WBackSlash];\n\t    }\n\t    else\n\t    {\n                /*\n\t\t * No special translation needed\n\t\t */\n\t\t*toP++ = tmp;\n\t    }\n\t}\n\telse\n\t{\n\t    *toP++ = *fromP++;\n\t}\n\tlenToConvert++;\n    }\n\n    tmp = tbuf[lenToConvert];\n    tbuf[lenToConvert] = (wchar_t) NULL;\n    numCvt = doWcstombs(mbs, tbuf, lenToConvert);\n    tbuf[lenToConvert] = tmp;\n    \n    mbs[numCvt] = '\\0';\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      bytesConv = doMbstowcs(wcs, mbs, n);\n * Description:\n *      Create a wcs string from an input mbs. \n * Input:\n *\twcs - wchar_t* : pointer to result buffer of wcs\n *      mbs - char* : pointer to the source mbs\n *\tn - size_t : the number of characters to convert\n * Output:\n *      bytesConv - size_t : number of bytes converted\n */\n", "func_signal": "static size_t doMbstowcs\n    ARGLIST((wcs, mbs, n))\n        ARG(wchar_t *,wcs)\n        ARG(char *, mbs)\n        GRA(size_t, n)", "code": "{\n#ifndef SUPPORTS_WCHARS\n    int i;\n    \n    for (i = 0; i < n && mbs[i] != 0; ++i)\n    {\n\twcs[i] = mbs[i];\n    }\n    wcs[i++] = 0;\n    return(i);\n#else\n    return(mbstowcs(wcs, mbs, n));\n#endif\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *\tCONVERTER CvtStringToXmString\n *\n * Description:\n *\tConvert a string to an XmString. This allows a string contained in\n *\tresource file to contain multiple fonts. The syntax for the string\n *\tis:\n *\t\t::[#[font-tag]]\"string\"[#[font-tag]\"string\"] ...\n *\n *\tnote that the # can be escaped (\\#).\n *\n * Input:\n * Output:\n *\tStandard.\n */\n", "func_signal": "static Boolean CvtStringToXmString\n    ARGLIST((d, args, num_args, fromVal, toVal, data))\n        ARG(Display *, d)\n        UARG(XrmValue *, args)\n        ARG(Cardinal *, num_args)\n        ARG(XrmValue *, fromVal)\n        ARG(XrmValue *, toVal)\n        GRAU(XtPointer, data)", "code": "{\n    static XmString\tresStr;\n    char\t\t*str;\n\n#if !defined(NeedFunctionPrototypes) || !defined(__cplusplus)\n    (void)args;  /* Makes compiler happy with unused parameters */\n    (void)data;\n#endif\n            \n    /*\n     * This converter takes no parameters\n     */\n    if (*num_args != 0)\n    {\n\tXtAppWarningMsg(XtDisplayToApplicationContext(d), \n\t\t\t\"cvtStringToXmString\",\n\t\t\t\"wrongParameters\",\n\t\t\t\"XtToolkitError\",\n\t\t\t\"String to XmString converter needs no extra arguments\",\n\t\t\t(String *)NULL,\n\t\t\t(Cardinal *)NULL);\n    }\n\n    /*\n     * See if this is a simple string\n     */\n    str = (char*)fromVal->addr;\n    if (strncmp(str, \"::\", 2))\n    {\n\tresStr = XmStringCreateLtoR(fromVal->addr, XmSTRING_DEFAULT_CHARSET);\n    }\n    else\n    {\n\t/*\n\t * Convert into internal format\n\t */\n\tresStr = StringToXmString(fromVal->addr + 2);\t/* skip :: */\n    }\n\n    /*\n     * Done, return result\n     */\n    if (toVal->addr == NULL)\n    {\n\ttoVal->addr = (XTPOINTER)&resStr;\n\ttoVal->size = sizeof(XmString);\n    }\n    else if (toVal->size < sizeof(XmString))\n    {\n\ttoVal->size = sizeof(XmString);\n\tXtDisplayStringConversionWarning(d, fromVal->addr, \"XmString\");\n\tXmStringFree(resStr);\n\treturn(False);\n    }\n    else \n    {\n\t*(XmString *)toVal->addr = resStr;\n\ttoVal->size = sizeof(XmString);\n    }\n    return(True);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *\txstr = StringToXmString(str);\n * Description:\n *\tParse a string into an XmString.\n * Inputs:\n *\tstr - char * : the string to parse\n * Outputs:\n *\txstr - XmString : the allocated return structure\n */\n", "func_signal": "static XmString StringToXmString\n    ARGLIST((str))\n        GRA(char *,str)", "code": "{\n    static char*\ttagBuf = NULL;\n    static Cardinal\ttagBufLen = 0;\n    static char*\ttextBuf = NULL;\n    static Cardinal\ttextBufLen = 0;\n\n    wchar_t\t\t*ctx;\n    wchar_t\t\t*tag;\n    int\t\t\ttagLen;\n    wchar_t\t\t*text;\n    int\t\t\ttextLen;\n    Boolean\t\tsep;\n    int\t\t\tdir;\n    \n    Boolean\t\tmore;\n    wchar_t\t\t*wcStr;\n    int\t\t\tcurDir;\n    XmString\t\txmStr;\n    XmString\t\ts1;\n    XmString\t\ts2;\n\n    if (!str) return(NULL);\n\n    /*\n     * For expediencies sake, we'll overallocate this buffer so that\n     * the wcs is guaranteed to fit (1 wc per byte in original string).\n     */\n    wcStr = (wchar_t*)XtMalloc((strlen(str) + 1) * sizeof(wchar_t));\n    doMbstowcs(wcStr, str, strlen(str) + 1);\n\n    /*\n     * Create the beginning segment\n     */\n    curDir = XmSTRING_DIRECTION_L_TO_R;\n    xmStr = XmStringDirectionCreate(curDir);\n\n    /*\n     * Convert the string.\n     */\n    more = True;\n    ctx = wcStr;\n    while (more)\n    {\n\tmore = extractSegment(&ctx, &tag, &tagLen,\n\t\t\t      &text, &textLen, &dir, &sep);\n\t/*\n\t * Pick up a direction change\n\t */\n\tif (dir != curDir)\n\t{\n#if defined(VMS) || (defined(__osf__) && defined(__alpha))\n#if XmVERSION > 1 || (XmVERSION == 1 && XmREVISION >= 2)\n\t    /*\n\t     * This is required on DEC Windows systems because they've\n\t     * added the REVERT direction.\n\t     */\n\t    s1 = XmStringDirectionCreate(XmSTRING_DIRECTION_REVERT);\n\t    s2 = xmStr;\n\t    xmStr = XmStringConcat(s2, s1);\n\t    XmStringFree(s1);\n\t    XmStringFree(s2);\n#endif\n#endif\n\t    curDir = dir;\n\t    s1 = XmStringDirectionCreate(curDir);\n\t    s2 = xmStr;\n\t    xmStr = XmStringConcat(s2, s1);\n\t    XmStringFree(s1);\n\t    XmStringFree(s2);\n\n\t}\n\n\t/*\n\t * Create the segment. Text and tag first.\n\t */\n\tif (textLen)\n\t{\n\t    if (textBufLen <= (textLen * sizeof(wchar_t)))\n\t    {\n\t\ttextBufLen = (textLen + 1) * sizeof(wchar_t);\n\t\ttextBuf = (char*)XtRealloc(textBuf, textBufLen);\n\t    }\n\t    copyWcsToMbs(textBuf, text, textLen, True);\n\n\t    if (tagLen)\n\t    {\n\t\tif (tagBufLen <= (tagLen * sizeof(wchar_t)))\n\t\t{\n\t\t    tagBufLen = (tagLen + 1) * sizeof(wchar_t);\n\t\t    tagBuf = (char*)XtRealloc(tagBuf, tagBufLen);\n\t\t}\n\t\tcopyWcsToMbs(tagBuf, tag, tagLen, False);\n\t    }\n\t    else\n\t    {\n\t\tif (!tagBuf)\n\t\t{\n\t\t    tagBufLen = strlen(XmSTRING_DEFAULT_CHARSET) + 1;\n\t\t    tagBuf = (char*)XtMalloc(tagBufLen);\n\t\t}\n\t\tstrcpy(tagBuf, XmSTRING_DEFAULT_CHARSET);\n\t    }\n\n\t    s1 = XmStringCreate(textBuf, tagBuf); \n\t    s2 = xmStr;\n\t    xmStr = XmStringConcat(s2, s1);\n\t    XmStringFree(s1);\n\t    XmStringFree(s2);\n\t}\n\n\t/*\n\t * Add in the separators.\n\t */\n\tif (sep)\n\t{\n\t    s1 = XmStringSeparatorCreate();\n\t    s2 = xmStr;\n\t    xmStr = XmStringConcat(s2, s1);\n\t    XmStringFree(s1);\n\t    XmStringFree(s2);\n\t}\n    }\n    \n    /*\n     * Free up memory and return\n     */\n    XtFree((char*)wcStr);\n    return(xmStr);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * skip to the end of the current string and the beginning of the next one\n */\n", "func_signal": "static void xpmNextString\nARGLIST((mdata))\nGRA(bxxpmData *, mdata)", "code": "{\n    int c;\n\n    switch (mdata->type) {\n    case BXXPMARRAY:\n        mdata->cptr = (mdata->stream.data)[++mdata->line];\n        break;\n    case BXXPMFILE:\n    case BXXPMPIPE:\n        if (mdata->Eos)\n            while ((c = xpmGetC(mdata)) != mdata->Eos && c != EOF);\n        if (mdata->Bos)                 /* if not natural XPM2 */\n            while ((c = xpmGetC(mdata)) != mdata->Bos && c != EOF);\n        break;\n    }\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * This method gets all the resources from the app-defaults file \n * (resource databse) and fills in the table (defs) if the app default \n * value exists.\n */\n", "func_signal": "void\nInitAppDefaults ARGLIST((parent, defs))\nARG(Widget, parent)\nGRA(UIAppDefault *, defs)", "code": "{\n    XrmQuark\t\tcQuark;\n    XrmQuark\t\trsc[10];\n    XrmRepresentation\trep;\n    XrmValue\t\tval;\n    XrmDatabase\t\trdb;\n    int\t\t\trscIdx;\n\n    /* Get the database */\n\n#if (XlibSpecificationRelease >= 5)\n    if ((rdb = XrmGetDatabase(XtDisplay(parent))) == NULL)\n    {\n\treturn;\t\t\t/*  Can't get the database */\n    }\n#else\n    Display *dpy = XtDisplay(parent);\n    if ((rdb = dpy->db) == NULL)\n    {\n\treturn;\n    }\n#endif\n\n    /* Look for each resource in the table */\n\n    while (defs->wName)\n    {\n\trscIdx = 0;\n\t\n\tcQuark = XrmStringToQuark(defs->cName);\t/* class quark */\n\trsc[rscIdx++] = cQuark;\n\tif (defs->wName[0] == '\\0')\n\t{\n\t    rsc[rscIdx++] = cQuark;\n\t}\n\telse\n\t{\n\t    if( strchr(defs->wName, '.') == NULL )\n\t    {\n\t\trsc[rscIdx++] = XrmStringToQuark(defs->wName);\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we found a '.' that means that this is not\n\t\t * a simple widget name, but a sub specification so\n\t\t * we need to split this into several quarks.\n\t\t */\n\t\tchar *copy = XtNewString(defs->wName), *ptr;\n\n\t\tfor( ptr = strtok(copy, \".\"); ptr != NULL;\n\t\t     ptr = strtok(NULL, \".\") )\n\t\t{\n\t\t    rsc[rscIdx++] = XrmStringToQuark(ptr);\n\t\t}\n\t\tXtFree(copy);\n\t    }\n\t}\n\n\tif (defs->cInstName && defs->cInstName[0] != '\\0')\n\t{\n\t    rsc[rscIdx++] = XrmStringToQuark(defs->cInstName);\n\t}\n\n\trsc[rscIdx++] = XrmStringToQuark(defs->wRsc);\n\trsc[rscIdx++] = NULLQUARK;\n\n\tif (XrmQGetResource(rdb, rsc, rsc, &rep, &val))\n\t{\n\t    defs->value = XtNewString((char*)val.addr);\n\t}\n\tdefs++;\n    }\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      CvtXmStringTableDestructor(app, converted, data, args, num_args)\n * Description:\n *      This destructor is called by the X Toolkit Intrinsics to delete\n *\tthe memory allocated in CvtStringToXmString.\n * Input:\n *      app\t\t- XtAppContext\t: The Xt application context\n *\tconverted\t- XrmValue *\t: The value allocated by \n *\t\t\t\t\t  CvtStringToXmStringTable\n *\tdata\t\t- XtPointer\t: The extra data originally passed\n *\t\t\t\t\t  to the converter\n *\targs\t\t- XrmValue *\t: The extra arguments originally\n *\t\t\t\t\t  passed to the converter\n *\tnum_args\t- Cardinal *\t: The number of args originally \n *\t\t\t\t\t  passed to the converter\n * Output:\n *      None\n */\n", "func_signal": "static void\nCvtXmStringTableDestructor\n    ARGLIST((app, converted, data, args, num_args))\n        UARG(XtAppContext, app)\n        ARG(XrmValue *, converted)\n        UARG(XtPointer, data)\n        UARG(XrmValue *, args)\n        GRAU(Cardinal *, num_args)", "code": "{\n    XmString\t*ptr = (XmString *)converted->addr;\n\n#if !defined(NeedFunctionPrototypes) || !defined(__cplusplus)\n    (void)app;  /* Makes compiler happy with unused parameters */\n    (void)data;\n    (void)args;\n    (void)num_args;\n#endif\n                \n    while ( *ptr != NULL )\n    {\n\tXmStringFree(*ptr);\n\tptr++;\n    }\n    XtFree((char*)converted->addr);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Intialize the bxxpmInternAttrib pointers to Null to know\n * which ones must be freed later on.\n */\n", "func_signal": "static void xpmInitInternAttrib\nARGLIST((attrib))\nGRA(bxxpmInternAttrib *,attrib)", "code": "{\n    attrib->ncolors = 0;\n    attrib->colorTable = NULL;\n    attrib->pixelindex = NULL;\n    attrib->xcolors = NULL;\n    attrib->colorStrings = NULL;\n    attrib->mask_pixel = BX_UNDEF_PIXEL;\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * skip whitespace and compute the following unsigned int,\n * returns 1 if one is found and 0 if not\n */\n", "func_signal": "static int xpmNextUI\nARGLIST((mdata, ui_return))\nARG(bxxpmData *, mdata)\nGRA(unsigned int *, ui_return)", "code": "{\n    char buf[BUFSIZ];\n    int l;\n\n    l = xpmNextWord(mdata, buf);\n    return atoui(buf, l, ui_return);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Default method to write pixels into a Z image data structure.\n * The algorithm used is:\n *\n *\tcopy the destination bitmap_unit or Zpixel to temp\n *\tnormalize temp if needed\n *\tcopy the pixel bits into the temp\n *\trenormalize temp if needed\n *\tcopy the temp back into the destination image data\n */\n", "func_signal": "static void SetImagePixels\nARGLIST((image, width, height, pixelindex, pixels))\nARG(XImage *, image)\nARG(unsigned int, width)\nARG(unsigned int, height)\nARG(unsigned int *, pixelindex)\nGRA(Pixel *, pixels)", "code": "{\n    Pixel pixel;\n    unsigned long px;\n    register char *src;\n    register char *dst;\n    int nbytes;\n    register unsigned int *iptr;\n    register unsigned int x, y, i;\n\n    iptr = pixelindex;\n    if (image->depth == 1) {\n\tfor (y = 0; y < height; y++)\n\t    for (x = 0; x < width; x++, iptr++) {\n\t\tpixel = pixels[*iptr];\n\t\tfor (i = 0, px = pixel;\n\t\t     i < sizeof(unsigned long); i++, px >>= 8)\n\t\t    ((unsigned char *) &pixel)[i] = (unsigned char)px;\n\t\tsrc = &image->data[BXXYINDEX(x, y, image)];\n\t\tdst = (char *) &px;\n\t\tpx = 0;\n\t\tnbytes = image->bitmap_unit >> 3;\n\t\tfor (i = nbytes; --i >= 0;)\n\t\t    *dst++ = *src++;\n\t\tBXXYNORMALIZE(&px, image);\n\t\ti = ((x + image->xoffset) % image->bitmap_unit);\n\t\t_putbits((char *) &pixel, i, 1, (char *) &px);\n\t\tBXXYNORMALIZE(&px, image);\n\t\tsrc = (char *) &px;\n\t\tdst = &image->data[BXXYINDEX(x, y, image)];\n\t\tfor (i = nbytes; --i >= 0;)\n\t\t    *dst++ = *src++;\n\t    }\n    } else {\n\tfor (y = 0; y < height; y++)\n\t    for (x = 0; x < width; x++, iptr++) {\n\t\tpixel = pixels[*iptr];\n\t\tif (image->depth == 4)\n\t\t    pixel &= 0xf;\n\t\tfor (i = 0, px = pixel;\n\t\t     i < sizeof(unsigned long); i++, px >>= 8)\n\t\t    ((unsigned char *) &pixel)[i] = (unsigned char)px;\n\t\tsrc = &image->data[BXZINDEX(x, y, image)];\n\t\tdst = (char *) &px;\n\t\tpx = 0;\n\t\tnbytes = (image->bits_per_pixel + 7) >> 3;\n\t\tfor (i = nbytes; --i >= 0;)\n\t\t    *dst++ = *src++;\n\t\tBXZNORMALIZE(&px, image);\n\t\t_putbits((char *) &pixel,\n\t\t\t (x * image->bits_per_pixel) & 7,\n\t\t\t image->bits_per_pixel, (char *) &px);\n\t\tBXZNORMALIZE(&px, image);\n\t\tsrc = (char *) &px;\n\t\tdst = &image->data[BXZINDEX(x, y, image)];\n\t\tfor (i = nbytes; --i >= 0;)\n\t\t    *dst++ = *src++;\n\t    }\n    }\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * This method applies the app defaults for the class to a specific\n * instance. All the widgets in the path are loosly coupled (use *).\n * To override a specific instance, use a tightly coupled app defaults\n * resource line (use .).\n */\n", "func_signal": "void\nSetAppDefaults ARGLIST((w, defs, inst_name, override_inst))\nARG(Widget,w)\nARG(UIAppDefault*, defs)\nARG(char*, inst_name)\nGRA(Boolean, override_inst)", "code": "{\n   Display*\t\tdpy = XtDisplay (w);\t/*  Retrieve the display */\n   XrmDatabase\t\trdb = NULL;\t\t/* A resource data base */\n   char\t\t\tbuf[1000];\n   char \t\t*appName, *appClass;\n\n   /*\n    * Protect ourselves\n    */\n   if ( inst_name == NULL ) return;\n\n   /*\n    * Create an empty resource database\n    */\n   rdb = XrmGetStringDatabase ((char *)\"\");\n   XtGetApplicationNameAndClass(XtDisplay(w), &appName, &appClass);\n\n   /*\n    * Add the Component resources, prepending the name of the component\n    */\n   while ( defs->wName != NULL )\n   {\n       int namelen;\n       /*\n        * We don't deal with the resource if it isn't found in the\n\t* Xrm database at class initializtion time (in initAppDefaults).\n\t* Special handling of class instances.\n\t*/\n       if ( strchr(defs->wName, '.') )\n       {\n\t   namelen = strlen(defs->wName) - strlen(strchr(defs->wName, '.'));\n       }\n       else\n       {\n\t   int\t\twnamelen = strlen(defs->wName);\n\t   int\t\tinamelen = strlen(inst_name);\n\t   namelen = (wnamelen > inamelen ? wnamelen : inamelen);\n       }\n       if ( defs->value == NULL ||\n\t    (override_inst && strncmp(inst_name, defs->wName, namelen)) ||\n\t    (!override_inst && defs->cInstName != NULL) )\n       {\n\t   defs++;\n\t   continue;\n       }\n\n       /*\n\t* Build up resource database string\n\t*/\n       if ( defs->cInstName != NULL )\n       {\n\t   /*\n\t    * Don't include class instance name if it is also\n\t    * the widget instance being worked on.\n\t    */\n\t   if ( *defs->cInstName != '\\0' )\n\t   {\n\t       sprintf(buf, \"%s*%s*%s.%s: %s\", appClass, defs->cInstName,\n\t\t       defs->wName, defs->wRsc, defs->value);\n\t   }\n\t   else\n\t   {\n\t       sprintf(buf, \"%s*%s.%s: %s\",\n\t\t       appClass, defs->wName, defs->wRsc, defs->value);\n\t   }\n       }\n       else if ( *defs->wName != '\\0' )\n       {\n\t   sprintf(buf, \"%s*%s*%s.%s: %s\",\n\t\t   appClass, inst_name, defs->wName, defs->wRsc, defs->value);\n       }\n       else\n       {\n\t   sprintf(buf, \"%s*%s.%s: %s\", \n\t\t   appClass, inst_name,defs->wRsc, defs->value);\n       }\n\n       XrmPutLineResource(&rdb, buf);\n       defs++;\n   }\n\n   /*\n    * Merge them into the Xt database, with lowest precendence\n    */\n   if ( rdb )\n   {\n       /*  DO NOT do an XrmDestroyDatabase(rdb) here.  This looks like a\n\t* program leak, but is really an X problem.\n\t*\n\t* XrmCombineDatabase() squirrels away a copy of the pointers in\n\t* rdb.  Either XrmCombineDatabase should save a duplicate, or else\n\t* XrmCombineDatabase needs to assume responsibility for destroying\n\t* rdb at the right time.  We do not know when the pointers are no \n\t* longer needed.\n\t*/\n#if (XlibSpecificationRelease >= 5)\n        XrmDatabase db = XtDatabase(dpy);\n\tXrmCombineDatabase(rdb, &db, FALSE);\n#else\n        XrmMergeDatabases ( dpy->db, &rdb );\n        dpy->db = rdb;\n#endif\n    }\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      CvtXmStringDestructor(app, converted, data, args, num_args)\n * Description:\n *      This destructor is called by the X Toolkit Intrinsics to delete\n *\tthe memory allocated in CvtStringToXmString.\n * Input:\n *      app\t\t- XtAppContext\t: The Xt application context\n *\tconverted\t- XrmValue *\t: The value allocated by \n *\t\t\t\t\t  CvtStringToXmString\n *\tdata\t\t- XtPointer\t: The extra data originally passed\n *\t\t\t\t\t  to the converter\n *\targs\t\t- XrmValue *\t: The extra arguments originally\n *\t\t\t\t\t  passed to the converter\n *\tnum_args\t- Cardinal *\t: The number of args originally \n *\t\t\t\t\t  passed to the converter\n * Output:\n *      None\n */\n", "func_signal": "static void\nCvtXmStringDestructor\n    ARGLIST((app, converted, data, args, num_args))\n        UARG(XtAppContext, app)\n        ARG(XrmValue *, converted)\n        UARG(XtPointer, data)\n        UARG(XrmValue *, args)\n        GRAU(Cardinal *, num_args)", "code": "{\n    XmString\tfreestr = (XmString)converted->addr;\n#if !defined(NeedFunctionPrototypes) || !defined(__cplusplus)\n    (void)app;  /* Makes compiler happy with unused parameters */\n    (void)data;\n    (void)args;\n    (void)num_args;\n#endif\n               \n    if ( freestr != NULL ) XmStringFree(freestr);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/* DEFINE_OLD_BXUTILS */\n", "func_signal": "XtPointer BX_DOUBLE\n    ARGLIST((val))\n    GRA(double, val)", "code": "{\n    XtPointer\tpointer;\n    \n    pointer = (XtPointer)XtMalloc(sizeof(double));\n    if ( pointer != NULL ) *((double *)pointer) = val;\n    return(pointer);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      bytesConv = doWcstombs(wcs, mbs, n);\n * Description:\n *      Create a mbs string from an input wcs.\n * Input:\n *\twcs - wchar_t* : pointer to the source wcs\n *      mbs - char* : pointer to result mbs buffer \n *\tn - size_t : the number of characters to convert\n * Output:\n *      bytesConv - size_t : number of bytes converted\n */\n", "func_signal": "static size_t doWcstombs\n    ARGLIST((mbs, wcs, n))\n        ARG(char *, mbs)\n        ARG(wchar_t *, wcs)\n        GRA(size_t, n)", "code": "{\n#ifndef SUPPORTS_WCHARS\n    int i;\n    \n    for (i = 0; i < n && wcs[i] != 0; ++i)\n    {\n\tmbs[i] = wcs[i];\n    }\n    mbs[i] = 0;\n    return(i);\n#else\n    size_t\tretval;\n\n    retval = wcstombs(mbs, wcs, (n * sizeof(wchar_t)));\n    if ( retval == (size_t)-1 ) return(0);\n    else return(retval);\n#endif\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Create an XImage\n */\n", "func_signal": "static int CreateXImage\nARGLIST((display, visual, depth, width, height, image_return))\nARG(Display *, display)\nARG(Visual *, visual)\nARG(unsigned int, depth)\nARG(unsigned int, width)\nARG(unsigned int, height)\nGRA(XImage **, image_return)", "code": "{\n    int bitmap_pad;\n\n    /* first get bitmap_pad */\n    if (depth > 16)\n\tbitmap_pad = 32;\n    else if (depth > 8)\n\tbitmap_pad = 16;\n    else\n\tbitmap_pad = 8;\n\n    /* then create the XImage with data = NULL and bytes_per_line = 0 */\n\n    *image_return = XCreateImage(display, visual, depth, ZPixmap, 0, 0,\n\t\t\t\t width, height, bitmap_pad, 0);\n    if (!*image_return)\n\treturn (BxXpmNoMemory);\n\n    /* now that bytes_per_line must have been set properly alloc data */\n\n    (*image_return)->data =\n\t(char *) malloc((*image_return)->bytes_per_line * height);\n\n    if (!(*image_return)->data) {\n\tXDestroyImage(*image_return);\n\t*image_return = NULL;\n\treturn (BxXpmNoMemory);\n    }\n    return (BxXpmSuccess);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * write pixels into a 8-bits Z image data structure\n */\n", "func_signal": "static void SetImagePixels8\nARGLIST((image, width, height, pixelindex, pixels))\nARG(XImage *, image)\nARG(unsigned int, width)\nARG(unsigned int, height)\nARG(unsigned int *, pixelindex)\nGRA(Pixel *, pixels)", "code": "{\n    register unsigned int *iptr;\n    register unsigned int x, y;\n\n    iptr = pixelindex;\n    for (y = 0; y < height; y++)\n\tfor (x = 0; x < width; x++, iptr++)\n\t    image->data[BXZINDEX8(x, y, image)] = (char)pixels[*iptr];\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      len = strlenWc(ptr);\n * Description:\n *      Return the number of characters in a wide character string (not\n *\tthe characters in the resultant mbs).\n * Input:\n *      ptr - wchar_t* : pointer to the wcs to count\n * Output:\n *      int : the number of characters found\n */\n", "func_signal": "static int strlenWc\n    ARGLIST((ptr))\n        GRA(wchar_t *,ptr)", "code": "{\n    register wchar_t\t*p = ptr;\n    register int\tx = 0;\n    \n    if (!ptr) return(0);\n    \n    while (*p++) x++;\n    return (x);\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      RegisterBxConverters(appContext);\n * Description:\n *      This globally available function installs all the converters necessary\n *\tto run BuilderXcessory generated interfaces that use compound\n *\tstrings. This is necessary since Motif has not supplied very smart\n *\tconverters.\n * Input:\n *      appContext - XtAppContext : the application context\n * Output:\n *      None\n */\n", "func_signal": "void RegisterBxConverters\n    ARGLIST((appContext))\n        GRA(XtAppContext, appContext)", "code": "{\n    if ( REGBXCONVERTERS != True )\n\t{\n    \t    XtAppSetTypeConverter(appContext, XmRString, XmRXmString,\n\t\t\t          (XtTypeConverter)&CvtStringToXmString,\n\t\t\t          NULL, 0, XtCacheNone,\n                                  (XtDestructor)&CvtXmStringDestructor);\n            XtAppSetTypeConverter(appContext, XmRString, XmRXmStringTable,\n\t\t\t          (XtTypeConverter)&CvtStringToXmStringTable,\n\t\t\t          NULL, 0, XtCacheNone, \n\t\t\t          (XtDestructor)&CvtXmStringTableDestructor);\n   \t    REGBXCONVERTERS = True;\n\t} \n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*\n * Function:\n *      SET_BACKGROUND_COLOR(w, args, argcnt, bg_color);\n * Description:\n *      Sets the background color and shadows of a widget.\n * Input:\n *      w - The widget to set the background color on.\n *      args, argcnt - The argument list so far.\n *      bg_color - The new background color as a pixel.\n * Output:\n *      none\n *\n *  NOTES:  This assumes that args later in the argument list\n *          override those already in the list.  Therfore i f\n *          there are shadow colors later in the list they will win.\n *        \n *          There is no need to use this function when creating a widget\n *          only when doing a set values, shadow colors are automatically\n *          calculated at creation time.\n */\n", "func_signal": "void BX_SET_BACKGROUND_COLOR\n    ARGLIST((w, args, argcnt, bg_color))\n        ARG(Widget, w)\n        ARG(ArgList, args)\n        ARG(Cardinal *, argcnt)\n        GRA(Pixel, bg_color)", "code": "{\n    Cardinal\ti;\n    int\t\ttopShadowLoc;\n    int\t\tbottomShadowLoc;\n    int\t\tselectLoc;\n    int\t\tfgLoc = 0;\n\n#if (((XmVERSION == 1) && (XmREVISION > 0)) || (XmVERSION > 1))\n\n    /*\n     * Walk through the arglist to see if the user set the top or\n     * bottom shadow colors.\n     */\n    selectLoc = topShadowLoc =  bottomShadowLoc = fgLoc = UNSET;\n    for (i = 0; i < *argcnt; i++)\n    {\n\tif ((strcmp(args[i].name, XmNtopShadowColor) == 0) ||\n\t    (strcmp(args[i].name, XmNtopShadowPixmap) == 0))\n\t{\n\t    topShadowLoc = i;\n\t}\n\telse if ((strcmp(args[i].name, XmNbottomShadowColor) == 0) ||\n\t\t (strcmp(args[i].name, XmNbottomShadowPixmap) == 0))\n\t{\n\t    bottomShadowLoc = i;\n\t}\n\telse if (strcmp(args[i].name, XmNarmColor) == 0)\n\t{\n\t    selectLoc = i;\n\t}\n\telse if (strcmp(args[i].name, XmNforeground) == 0)\n\t{\n\t    fgLoc = i;\n\t}\n    }\n\n    /*\n     * If either the top or bottom shadow are not set then we\n     * need to use XmGetColors to get the shadow colors from the backgound\n     * color and add those that are not already in the arglist to the\n     * arglist.\n     * \n     */\n    if ((bottomShadowLoc == UNSET) ||\n\t(topShadowLoc == UNSET) ||\n\t(selectLoc == UNSET) ||\n\t(fgLoc == UNSET))\n    {\n\tArg\t\tlarg[1];\n\tColormap\tcmap;\n\tPixel\t\ttopShadow;\n\tPixel\t\tbottomShadow;\n\tPixel\t\tselect;\n\tPixel\t\tfgColor;\n\n\tXtSetArg(larg[0], XmNcolormap, &cmap);\n\tXtGetValues(w, larg, 1);\n\tXmGetColors(XtScreen(w), cmap, bg_color, \n\t\t    &fgColor, &topShadow, &bottomShadow, &select);\n\n\tif (topShadowLoc == UNSET)\n\t{\n\t    XtSetArg(args[*argcnt], XmNtopShadowColor, topShadow); \n\t    (*argcnt)++;\n\t}\n\t\n\tif (bottomShadowLoc == UNSET)\n\t{\n\t    XtSetArg(args[*argcnt], XmNbottomShadowColor, bottomShadow); \n\t    (*argcnt)++;\n\t}\n\n\tif (selectLoc == UNSET)\n\t{\n\t    XtSetArg(args[*argcnt], XmNarmColor, select); \n\t    (*argcnt)++;\n\t}\n\n\tif (fgLoc == UNSET)\n\t{\n\t    XtSetArg(args[*argcnt], XmNforeground, fgColor); \n\t    (*argcnt)++;\n\t}\n    }\n#endif\n\n    XtSetArg(args[*argcnt], XmNbackground, bg_color); (*argcnt)++;\n}", "path": "src\\dtpad\\bxutils.c", "repo_name": "OpenCDE/opencde", "stars": 16, "license": "other", "language": "c", "size": 3357}
{"docstring": "/*****************************************************************************\n * OpenDecoder: probe the decoder and return score\n *****************************************************************************/\n", "func_signal": "static int OpenDecoder( vlc_object_t *p_this )", "code": "{\n    decoder_t *p_dec = (decoder_t*)p_this;\n    decoder_sys_t *p_sys;\n\n    if( p_dec->fmt_in.i_codec != VLC_CODEC_SPEEX )\n        return VLC_EGENERIC;\n\n    /* Allocate the memory needed to store the decoder's structure */\n    if( ( p_dec->p_sys = p_sys = malloc(sizeof(decoder_sys_t)) ) == NULL )\n        return VLC_ENOMEM;\n    p_dec->p_sys->bits.buf_size = 0;\n    p_dec->p_sys->b_packetizer = false;\n    p_dec->p_sys->rtp_rate = p_dec->fmt_in.audio.i_rate;\n    p_dec->p_sys->b_has_headers = false;\n\n    date_Set( &p_sys->end_date, 0 );\n\n    /* Set output properties */\n    p_dec->fmt_out.i_cat = AUDIO_ES;\n    p_dec->fmt_out.i_codec = VLC_CODEC_S16N;\n\n    /*\n      Set callbacks\n      If the codec is spxr then this decoder is \n      being invoked on a Speex stream arriving via RTP. \n      A special decoder callback is used.\n    */\n    if (p_dec->fmt_in.i_original_fourcc == VLC_FOURCC('s', 'p', 'x', 'r'))\n    {\n        msg_Dbg( p_dec, \"Using RTP version of Speex decoder @ rate %d.\", \n\t    p_dec->fmt_in.audio.i_rate );\n        p_dec->pf_decode_audio = (aout_buffer_t *(*)(decoder_t *, block_t **))\n            DecodeRtpSpeexPacket;\n    }\n    else\n    {\n        p_dec->pf_decode_audio = (aout_buffer_t *(*)(decoder_t *, block_t **))\n            DecodeBlock;\n    }\n    p_dec->pf_packetize    = (block_t *(*)(decoder_t *, block_t **))\n        DecodeBlock;\n\n    p_sys->p_state = NULL;\n    p_sys->p_header = NULL;\n    p_sys->i_frame_in_packet = 0;\n\n    return VLC_SUCCESS;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/**\n * Decode an uncompressed coefficient.\n * @param gb GetBitContext\n * @return the decoded coefficient\n */\n", "func_signal": "unsigned int ff_wma_get_large_val(GetBitContext* gb)", "code": "{\n    /** consumes up to 34 bits */\n    int n_bits = 8;\n    /** decode length */\n    if (get_bits1(gb)) {\n        n_bits += 8;\n        if (get_bits1(gb)) {\n            n_bits += 8;\n            if (get_bits1(gb)) {\n                n_bits += 7;\n            }\n        }\n    }\n    return get_bits_long(gb, n_bits);\n}", "path": "jni\\ext\\ffmpeg\\libavcodec\\wma.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/****************************************************************************\n * Encode: the whole thing\n ****************************************************************************\n * This function spits out ogg packets.\n ****************************************************************************/\n", "func_signal": "static block_t *Encode( encoder_t *p_enc, aout_buffer_t *p_aout_buf )", "code": "{\n    encoder_sys_t *p_sys = p_enc->p_sys;\n    block_t *p_block, *p_chain = NULL;\n\n    unsigned char *p_buffer = p_aout_buf->p_buffer;\n    int i_samples = p_aout_buf->i_nb_samples;\n    int i_samples_delay = p_sys->i_samples_delay;\n\n    mtime_t i_pts = p_aout_buf->i_pts -\n                (mtime_t)1000000 * (mtime_t)p_sys->i_samples_delay /\n                (mtime_t)p_enc->fmt_in.audio.i_rate;\n\n    p_sys->i_samples_delay += i_samples;\n\n    while( p_sys->i_samples_delay >= p_sys->i_frame_length )\n    {\n        int16_t *p_samples;\n        int i_out;\n\n        if( i_samples_delay )\n        {\n            /* Take care of the left-over from last time */\n            int i_delay_size = i_samples_delay * 2 *\n                                 p_enc->fmt_in.audio.i_channels;\n            int i_size = p_sys->i_frame_size - i_delay_size;\n\n            p_samples = (int16_t *)p_sys->p_buffer;\n            memcpy( p_sys->p_buffer + i_delay_size, p_buffer, i_size );\n            p_buffer -= i_delay_size;\n            i_samples += i_samples_delay;\n            i_samples_delay = 0;\n        }\n        else\n        {\n            p_samples = (int16_t *)p_buffer;\n        }\n\n        /* Encode current frame */\n        if( p_enc->fmt_in.audio.i_channels == 2 )\n            speex_encode_stereo_int( p_samples, p_sys->i_frame_length,\n                                     &p_sys->bits );\n\n#if 0\n        if( p_sys->preprocess )\n            speex_preprocess( p_sys->preprocess, p_samples, NULL );\n#endif\n\n        speex_encode_int( p_sys->p_state, p_samples, &p_sys->bits );\n\n        p_buffer += p_sys->i_frame_size;\n        p_sys->i_samples_delay -= p_sys->i_frame_length;\n        i_samples -= p_sys->i_frame_length;\n\n        p_sys->i_frames_in_packet++;\n\n        if( p_sys->i_frames_in_packet < p_sys->header.frames_per_packet )\n            continue;\n\n        p_sys->i_frames_in_packet = 0;\n\n        speex_bits_insert_terminator( &p_sys->bits );\n        i_out = speex_bits_write( &p_sys->bits, p_sys->p_buffer_out,\n                                  MAX_FRAME_BYTES );\n        speex_bits_reset( &p_sys->bits );\n\n        p_block = block_New( p_enc, i_out );\n        memcpy( p_block->p_buffer, p_sys->p_buffer_out, i_out );\n\n        p_block->i_length = (mtime_t)1000000 *\n            (mtime_t)p_sys->i_frame_length * p_sys->header.frames_per_packet /\n            (mtime_t)p_enc->fmt_in.audio.i_rate;\n\n        p_block->i_dts = p_block->i_pts = i_pts;\n\n        /* Update pts */\n        i_pts += p_block->i_length;\n        block_ChainAppend( &p_chain, p_block );\n\n    }\n\n    /* Backup the remaining raw samples */\n    if( i_samples )\n    {\n        memcpy( p_sys->p_buffer + i_samples_delay * 2 *\n                p_enc->fmt_in.audio.i_channels, p_buffer,\n                i_samples * 2 * p_enc->fmt_in.audio.i_channels );\n    }\n\n    return p_chain;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * DecodePacket: decodes a Speex packet.\n *****************************************************************************/\n", "func_signal": "static aout_buffer_t *DecodePacket( decoder_t *p_dec, ogg_packet *p_oggpacket )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    if( p_oggpacket->bytes )\n    {\n        /* Copy Ogg packet to Speex bitstream */\n        speex_bits_read_from( &p_sys->bits, (char *)p_oggpacket->packet,\n                              p_oggpacket->bytes );\n        p_sys->i_frame_in_packet = 0;\n    }\n\n    /* Decode one frame at a time */\n    if( p_sys->i_frame_in_packet < p_sys->p_header->frames_per_packet )\n    {\n        aout_buffer_t *p_aout_buffer;\n        if( p_sys->p_header->frame_size == 0 )\n            return NULL;\n\n        p_aout_buffer =\n            decoder_NewAudioBuffer( p_dec, p_sys->p_header->frame_size );\n        if( !p_aout_buffer )\n        {\n            return NULL;\n        }\n\n        switch( speex_decode_int( p_sys->p_state, &p_sys->bits,\n                                  (int16_t *)p_aout_buffer->p_buffer ) )\n        {\n            case -2:\n                msg_Err( p_dec, \"decoding error: corrupted stream?\" );\n            case -1: /* End of stream */\n                return NULL;\n        }\n\n        if( speex_bits_remaining( &p_sys->bits ) < 0 )\n        {\n            msg_Err( p_dec, \"decoding overflow: corrupted stream?\" );\n        }\n\n        if( p_sys->p_header->nb_channels == 2 )\n            speex_decode_stereo_int( (int16_t *)p_aout_buffer->p_buffer,\n                                     p_sys->p_header->frame_size,\n                                     &p_sys->stereo );\n\n        /* Date management */\n        p_aout_buffer->i_pts = date_Get( &p_sys->end_date );\n        p_aout_buffer->i_length =\n            date_Increment( &p_sys->end_date, p_sys->p_header->frame_size )\n            - p_aout_buffer->i_pts;\n\n        p_sys->i_frame_in_packet++;\n\n        return p_aout_buffer;\n    }\n    else\n    {\n        return NULL;\n    }\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/**\n * Decode run level compressed coefficients.\n * @param avctx codec context\n * @param gb bitstream reader context\n * @param vlc vlc table for get_vlc2\n * @param level_table level codes\n * @param run_table run codes\n * @param version 0 for wma1,2 1 for wmapro\n * @param ptr output buffer\n * @param offset offset in the output buffer\n * @param num_coefs number of input coefficents\n * @param block_len input buffer length (2^n)\n * @param frame_len_bits number of bits for escaped run codes\n * @param coef_nb_bits number of bits for escaped level codes\n * @return 0 on success, -1 otherwise\n */\n", "func_signal": "int ff_wma_run_level_decode(AVCodecContext* avctx, GetBitContext* gb,\n                            VLC *vlc,\n                            const float *level_table, const uint16_t *run_table,\n                            int version, WMACoef *ptr, int offset,\n                            int num_coefs, int block_len, int frame_len_bits,\n                            int coef_nb_bits)", "code": "{\n    int code, level, sign;\n    const uint32_t *ilvl = (const uint32_t*)level_table;\n    uint32_t *iptr = (uint32_t*)ptr;\n    const unsigned int coef_mask = block_len - 1;\n    for (; offset < num_coefs; offset++) {\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n        if (code > 1) {\n            /** normal code */\n            offset += run_table[code];\n            sign = get_bits1(gb) - 1;\n            iptr[offset & coef_mask] = ilvl[code] ^ sign<<31;\n        } else if (code == 1) {\n            /** EOB */\n            break;\n        } else {\n            /** escape */\n            if (!version) {\n                level = get_bits(gb, coef_nb_bits);\n                /** NOTE: this is rather suboptimal. reading\n                    block_len_bits would be better */\n                offset += get_bits(gb, frame_len_bits);\n            } else {\n                level = ff_wma_get_large_val(gb);\n                /** escape decode */\n                if (get_bits1(gb)) {\n                    if (get_bits1(gb)) {\n                        if (get_bits1(gb)) {\n                            av_log(avctx,AV_LOG_ERROR,\n                                \"broken escape sequence\\n\");\n                            return -1;\n                        } else\n                            offset += get_bits(gb, frame_len_bits) + 4;\n                    } else\n                        offset += get_bits(gb, 2) + 1;\n                }\n            }\n            sign = get_bits1(gb) - 1;\n            ptr[offset & coef_mask] = (level^sign) - sign;\n        }\n    }\n    /** NOTE: EOB can be omitted */\n    if (offset > num_coefs) {\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n        return -1;\n    }\n\n    return 0;\n}", "path": "jni\\ext\\ffmpeg\\libavcodec\\wma.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * ProcessPacket: processes a Speex packet.\n *****************************************************************************/\n", "func_signal": "static void *ProcessPacket( decoder_t *p_dec, ogg_packet *p_oggpacket,\n                            block_t **pp_block )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n    block_t *p_block = *pp_block;\n\n    /* Date management */\n    if( p_block && p_block->i_pts > VLC_TS_INVALID &&\n        p_block->i_pts != date_Get( &p_sys->end_date ) )\n    {\n        date_Set( &p_sys->end_date, p_block->i_pts );\n    }\n\n    if( !date_Get( &p_sys->end_date ) )\n    {\n        /* We've just started the stream, wait for the first PTS. */\n        if( p_block ) block_Release( p_block );\n        return NULL;\n    }\n\n    *pp_block = NULL; /* To avoid being fed the same packet again */\n\n    if( p_sys->b_packetizer )\n    {\n\tif ( p_sys->p_header->frames_per_packet > 1 )\n\t{\n\t    short *p_frame_holder = NULL;\n\t    int i_bits_before = 0, i_bits_after = 0, i_bytes_in_speex_frame = 0,\n\t        i_pcm_output_size = 0, i_bits_in_speex_frame = 0;\n\t    block_t *p_new_block = NULL;\n\n\t    i_pcm_output_size = p_sys->p_header->frame_size;\n\t    p_frame_holder = (short*)xmalloc( sizeof(short)*i_pcm_output_size );\n\n            speex_bits_read_from( &p_sys->bits, (char*)p_oggpacket->packet,\n\t        p_oggpacket->bytes);\n            i_bits_before = speex_bits_remaining( &p_sys->bits );\n\t    speex_decode_int(p_sys->p_state, &p_sys->bits, p_frame_holder);\n\t    i_bits_after = speex_bits_remaining( &p_sys->bits );\n\n            i_bits_in_speex_frame = i_bits_before - i_bits_after;\n\t    i_bytes_in_speex_frame = ( i_bits_in_speex_frame + \n\t        (8 - (i_bits_in_speex_frame % 8)) )\n                / 8;\n\n            p_new_block = block_New( p_dec, i_bytes_in_speex_frame );\n\t    memset( p_new_block->p_buffer, 0xff, i_bytes_in_speex_frame );\n\n\t    /*\n\t     * Copy the first frame in this packet to a new packet.\n\t     */\n\t    speex_bits_rewind( &p_sys->bits );\n\t    speex_bits_write( &p_sys->bits, \n\t        (char*)p_new_block->p_buffer, \n\t\t    (int)i_bytes_in_speex_frame );\n\n\t    /*\n\t     * Move the remaining part of the original packet (subsequent\n\t     * frames, if there are any) into the beginning \n\t     * of the original packet so\n\t     * they are preserved following the realloc. \n\t     * Note: Any bits that\n\t     * remain in the initial packet\n\t     * are \"filler\" if they do not constitute\n\t     * an entire byte. \n\t     */\n\t    if ( i_bits_after > 7 )\n\t    {\n\t        /* round-down since we rounded-up earlier (to include\n\t\t * the speex terminator code. \n\t\t */\n\t        i_bytes_in_speex_frame--;\n\t        speex_bits_write( &p_sys->bits, \n\t\t        (char*)p_block->p_buffer, \n\t\t        p_block->i_buffer - i_bytes_in_speex_frame );\n            p_block = block_Realloc( p_block, \n\t            0, \n\t\t        p_block->i_buffer-i_bytes_in_speex_frame );\n\t        *pp_block = p_block;\n\t    }\n\t    else\n\t    {\n\t        speex_bits_reset( &p_sys->bits );\n\t    }\n\n\t    free( p_frame_holder );\n\t    return SendPacket( p_dec, p_new_block);\n\t}\n\telse\n\t{\n            return SendPacket( p_dec, p_block );\n\t}\n    }\n    else\n    {\n        aout_buffer_t *p_aout_buffer = DecodePacket( p_dec, p_oggpacket );\n\n        if( p_block )\n            block_Release( p_block );\n        return p_aout_buffer;\n    }\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/* XXX: use same run/length optimization as mpeg decoders */\n//FIXME maybe split decode / encode or pass flag\n", "func_signal": "static void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n                          float **plevel_table, uint16_t **pint_table,\n                          const CoefVLCTable *vlc_table)", "code": "{\n    int n = vlc_table->n;\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n    const uint16_t *levels_table = vlc_table->levels;\n    uint16_t *run_table, *level_table, *int_table;\n    float *flevel_table;\n    int i, l, j, k, level;\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n    run_table   = av_malloc(n * sizeof(uint16_t));\n    level_table = av_malloc(n * sizeof(uint16_t));\n    flevel_table= av_malloc(n * sizeof(*flevel_table));\n    int_table   = av_malloc(n * sizeof(uint16_t));\n    i = 2;\n    level = 1;\n    k = 0;\n    while (i < n) {\n        int_table[k] = i;\n        l = levels_table[k++];\n        for (j = 0; j < l; j++) {\n            run_table[i]   = j;\n            level_table[i] = level;\n            flevel_table[i]= level;\n            i++;\n        }\n        level++;\n    }\n    *prun_table   = run_table;\n    *plevel_table = flevel_table;\n    *pint_table   = int_table;\n    av_free(level_table);\n}", "path": "jni\\ext\\ffmpeg\\libavcodec\\wma.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * ProcessHeaders: process Speex headers.\n *****************************************************************************/\n", "func_signal": "static int ProcessHeaders( decoder_t *p_dec )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n    ogg_packet oggpacket;\n\n    unsigned pi_size[XIPH_MAX_HEADER_COUNT];\n    void     *pp_data[XIPH_MAX_HEADER_COUNT];\n    unsigned i_count;\n    if( xiph_SplitHeaders( pi_size, pp_data, &i_count,\n                           p_dec->fmt_in.i_extra, p_dec->fmt_in.p_extra) )\n        return VLC_EGENERIC;\n    if( i_count < 2 )\n        goto error;\n\n    oggpacket.granulepos = -1;\n    oggpacket.e_o_s = 0;\n    oggpacket.packetno = 0;\n\n    /* Take care of the initial Vorbis header */\n    oggpacket.b_o_s = 1; /* yes this actually is a b_o_s packet :) */\n    oggpacket.bytes  = pi_size[0];\n    oggpacket.packet = pp_data[0];\n    if( ProcessInitialHeader( p_dec, &oggpacket ) != VLC_SUCCESS )\n    {\n        msg_Err( p_dec, \"initial Speex header is corrupted\" );\n        goto error;\n    }\n\n    /* The next packet in order is the comments header */\n    oggpacket.b_o_s = 0;\n    oggpacket.bytes  = pi_size[1];\n    oggpacket.packet = pp_data[1];\n    ParseSpeexComments( p_dec, &oggpacket );\n\n    if( p_sys->b_packetizer )\n    {\n        p_dec->fmt_out.i_extra = p_dec->fmt_in.i_extra;\n        p_dec->fmt_out.p_extra = xrealloc( p_dec->fmt_out.p_extra,\n                                                  p_dec->fmt_out.i_extra );\n        memcpy( p_dec->fmt_out.p_extra,\n                p_dec->fmt_in.p_extra, p_dec->fmt_out.i_extra );\n    }\n\n    for( unsigned i = 0; i < i_count; i++ )\n        free( pp_data[i] );\n    return VLC_SUCCESS;\n\nerror:\n    for( unsigned i = 0; i < i_count; i++ )\n        free( pp_data[i] );\n    return VLC_EGENERIC;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/**\n *@brief Get the samples per frame for this stream.\n *@param sample_rate output sample_rate\n *@param version wma version\n *@param decode_flags codec compression features\n *@return log2 of the number of output samples per frame\n */\n", "func_signal": "int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version,\n                                      unsigned int decode_flags)", "code": "{\n\n    int frame_len_bits;\n\n    if (sample_rate <= 16000) {\n        frame_len_bits = 9;\n    } else if (sample_rate <= 22050 ||\n             (sample_rate <= 32000 && version == 1)) {\n        frame_len_bits = 10;\n    } else if (sample_rate <= 48000) {\n        frame_len_bits = 11;\n    } else if (sample_rate <= 96000) {\n        frame_len_bits = 12;\n    } else {\n        frame_len_bits = 13;\n    }\n\n    if (version == 3) {\n        int tmp = decode_flags & 0x6;\n        if (tmp == 0x2) {\n            ++frame_len_bits;\n        } else if (tmp == 0x4) {\n            --frame_len_bits;\n        } else if (tmp == 0x6) {\n            frame_len_bits -= 2;\n        }\n    }\n\n    return frame_len_bits;\n}", "path": "jni\\ext\\ffmpeg\\libavcodec\\wma.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * Create: initialize and set pf_video_filter()\n *****************************************************************************/\n", "func_signal": "static int Create( vlc_object_t *p_this )", "code": "{\n    filter_t *p_filter = (filter_t *)p_this;\n    filter_sys_t *p_sys;\n\n    config_ChainParse( p_filter, CFG_PREFIX, ppsz_vfilter_options,\n                       p_filter->p_cfg );\n\n    p_filter->p_sys = p_sys = calloc( 1, sizeof( filter_sys_t ) );\n    if( p_filter->p_sys == NULL )\n        return VLC_ENOMEM;\n\n    p_sys->p_image = image_HandlerCreate( p_this );\n    if( !p_sys->p_image )\n    {\n        msg_Err( p_this, \"Couldn't get handle to image conversion routines.\" );\n        free( p_sys );\n        return VLC_EGENERIC;\n    }\n\n    p_sys->psz_format = var_CreateGetString( p_this, CFG_PREFIX \"format\" );\n    p_sys->i_format = image_Type2Fourcc( p_sys->psz_format );\n    if( !p_sys->i_format )\n    {\n        msg_Err( p_filter, \"Could not find FOURCC for image type '%s'\",\n                 p_sys->psz_format );\n        image_HandlerDelete( p_sys->p_image );\n        free( p_sys->psz_format );\n        free( p_sys );\n        return VLC_EGENERIC;\n    }\n    p_sys->i_width = var_CreateGetInteger( p_this, CFG_PREFIX \"width\" );\n    p_sys->i_height = var_CreateGetInteger( p_this, CFG_PREFIX \"height\" );\n    p_sys->i_ratio = var_CreateGetInteger( p_this, CFG_PREFIX \"ratio\" );\n    p_sys->b_replace = var_CreateGetBool( p_this, CFG_PREFIX \"replace\" );\n    p_sys->psz_prefix = var_CreateGetString( p_this, CFG_PREFIX \"prefix\" );\n    p_sys->psz_path = var_GetNonEmptyString( p_this, CFG_PREFIX \"path\" );\n    if( p_sys->psz_path == NULL )\n        p_sys->psz_path = config_GetUserDir( VLC_PICTURES_DIR );\n\n    p_filter->pf_video_filter = Filter;\n\n    return VLC_SUCCESS;\n}", "path": "jni\\vlc\\modules\\video_filter\\scene.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * OpenEncoder: probe the encoder and return score\n *****************************************************************************/\n", "func_signal": "static int OpenEncoder( vlc_object_t *p_this )", "code": "{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys;\n    const SpeexMode *p_speex_mode = &speex_nb_mode;\n    int i_tmp, i;\n    const char *pp_header[2];\n    int pi_header[2];\n    uint8_t *p_extra;\n\n    if( p_enc->fmt_out.i_codec != VLC_CODEC_SPEEX &&\n        !p_enc->b_force )\n    {\n        return VLC_EGENERIC;\n    }\n\n    config_ChainParse( p_enc, ENC_CFG_PREFIX, ppsz_enc_options, p_enc->p_cfg );\n    switch( var_GetInteger( p_enc, ENC_CFG_PREFIX \"mode\" ) )\n    {\n    case 1:\n        msg_Dbg( p_enc, \"Using wideband\" );\n        p_speex_mode = &speex_wb_mode;\n        break;\n    case 2:\n        msg_Dbg( p_enc, \"Using ultra-wideband\" );\n        p_speex_mode = &speex_uwb_mode;\n        break;\n    default:\n        msg_Dbg( p_enc, \"Using narrowband\" );\n        p_speex_mode = &speex_nb_mode;\n        break;\n    }\n\n    /* Allocate the memory needed to store the decoder's structure */\n    if( ( p_sys = (encoder_sys_t *)malloc(sizeof(encoder_sys_t)) ) == NULL )\n        return VLC_ENOMEM;\n    p_enc->p_sys = p_sys;\n    p_enc->pf_encode_audio = Encode;\n    p_enc->fmt_in.i_codec = VLC_CODEC_S16N;\n    p_enc->fmt_out.i_codec = VLC_CODEC_SPEEX;\n\n    speex_init_header( &p_sys->header, p_enc->fmt_in.audio.i_rate,\n                       1, p_speex_mode );\n\n    p_sys->header.frames_per_packet = 1;\n    p_sys->header.vbr = var_GetBool( p_enc, ENC_CFG_PREFIX \"cbr\" ) ? 0 : 1;\n    p_sys->header.nb_channels = p_enc->fmt_in.audio.i_channels;\n\n    /* Create a new encoder state in narrowband mode */\n    p_sys->p_state = speex_encoder_init( p_speex_mode );\n\n    /* Parameters */\n    i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX \"complexity\" );\n    speex_encoder_ctl( p_sys->p_state, SPEEX_SET_COMPLEXITY, &i_tmp );\n\n    i_tmp = var_GetBool( p_enc, ENC_CFG_PREFIX \"cbr\" ) ? 0 : 1;\n    speex_encoder_ctl( p_sys->p_state, SPEEX_SET_VBR, &i_tmp );\n\n    if( i_tmp == 0 ) /* CBR */\n    {\n        i_tmp = var_GetFloat( p_enc, ENC_CFG_PREFIX \"quality\" );\n        speex_encoder_ctl( p_sys->p_state, SPEEX_SET_QUALITY, &i_tmp );\n\n        i_tmp = var_GetBool( p_enc, ENC_CFG_PREFIX \"vad\" ) ? 1 : 0;\n        speex_encoder_ctl( p_sys->p_state, SPEEX_SET_VAD, &i_tmp );\n    }\n    else\n    {\n        float f_tmp;\n\n        f_tmp = var_GetFloat( p_enc, ENC_CFG_PREFIX \"quality\" );\n        speex_encoder_ctl( p_sys->p_state, SPEEX_SET_VBR_QUALITY, &f_tmp );\n\n        i_tmp = var_GetInteger( p_enc, ENC_CFG_PREFIX \"max-bitrate\" );\n        if( i_tmp > 0 )\n#ifdef SPEEX_SET_VBR_MAX_BITRATE\n            speex_encoder_ctl( p_sys->p_state, SPEEX_SET_VBR_MAX_BITRATE, &i_tmp );\n#else\n            msg_Dbg( p_enc, \"max-bitrate cannot be set in this version of libspeex\");\n#endif\n    }\n\n    i_tmp = var_GetBool( p_enc, ENC_CFG_PREFIX \"dtx\" ) ? 1 : 0;\n    speex_encoder_ctl( p_sys->p_state, SPEEX_SET_DTX, &i_tmp );\n\n\n    /*Initialization of the structure that holds the bits*/\n    speex_bits_init( &p_sys->bits );\n\n    p_sys->i_frames_in_packet = 0;\n    p_sys->i_samples_delay = 0;\n\n    speex_encoder_ctl( p_sys->p_state, SPEEX_GET_FRAME_SIZE,\n                       &p_sys->i_frame_length );\n\n    p_sys->i_frame_size = p_sys->i_frame_length *\n        sizeof(int16_t) * p_enc->fmt_in.audio.i_channels;\n    p_sys->p_buffer = xmalloc( p_sys->i_frame_size );\n\n    /* Create and store headers */\n    pp_header[0] = speex_header_to_packet( &p_sys->header, &pi_header[0] );\n    pp_header[1] = \"ENCODER=VLC media player\";\n    pi_header[1] = sizeof(\"ENCODER=VLC media player\");\n\n    p_enc->fmt_out.i_extra = 3 * 2 + pi_header[0] + pi_header[1];\n    p_extra = p_enc->fmt_out.p_extra = xmalloc( p_enc->fmt_out.i_extra );\n    for( i = 0; i < 2; i++ )\n    {\n        *(p_extra++) = pi_header[i] >> 8;\n        *(p_extra++) = pi_header[i] & 0xFF;\n        memcpy( p_extra, pp_header[i], pi_header[i] );\n        p_extra += pi_header[i];\n    }\n\n    msg_Dbg( p_enc, \"encoding: frame size:%d, channels:%d, samplerate:%d\",\n             p_sys->i_frame_size, p_enc->fmt_in.audio.i_channels,\n             p_enc->fmt_in.audio.i_rate );\n\n    return VLC_SUCCESS;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * SendPacket: send an ogg packet to the stream output.\n *****************************************************************************/\n", "func_signal": "static block_t *SendPacket( decoder_t *p_dec, block_t *p_block )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    /* Date management */\n    p_block->i_dts = p_block->i_pts = date_Get( &p_sys->end_date );\n\n    p_block->i_length =\n        date_Increment( &p_sys->end_date,\n                            p_sys->p_header->frame_size ) -\n        p_block->i_pts;\n\n    return p_block;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * CloseEncoder: encoder destruction\n *****************************************************************************/\n", "func_signal": "static void CloseEncoder( vlc_object_t *p_this )", "code": "{\n    encoder_t *p_enc = (encoder_t *)p_this;\n    encoder_sys_t *p_sys = p_enc->p_sys;\n\n    speex_encoder_destroy( p_sys->p_state );\n    speex_bits_destroy( &p_sys->bits );\n\n    free( p_sys->p_buffer );\n    free( p_sys );\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/* isn't this function nicer than the one in the libjpeg ? */\n", "func_signal": "void ff_mjpeg_build_huffman_codes(uint8_t *huff_size, uint16_t *huff_code,\n                                  const uint8_t *bits_table,\n                                  const uint8_t *val_table)", "code": "{\n    int i, j, k,nb, code, sym;\n\n    code = 0;\n    k = 0;\n    for(i=1;i<=16;i++) {\n        nb = bits_table[i];\n        for(j=0;j<nb;j++) {\n            sym = val_table[k++];\n            huff_size[sym] = i;\n            huff_code[sym] = code;\n            code++;\n        }\n        code <<= 1;\n    }\n}", "path": "jni\\ext\\ffmpeg\\libavcodec\\mjpeg.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * Destroy: destroy video filter method\n *****************************************************************************/\n", "func_signal": "static void Destroy( vlc_object_t *p_this )", "code": "{\n    filter_t *p_filter = (filter_t *)p_this;\n    filter_sys_t *p_sys = (filter_sys_t *) p_filter->p_sys;\n\n    image_HandlerDelete( p_sys->p_image );\n\n    if( p_sys->scene.p_pic )\n        picture_Release( p_sys->scene.p_pic );\n    free( p_sys->psz_format );\n    free( p_sys->psz_prefix );\n    free( p_sys->psz_path );\n    free( p_sys );\n}", "path": "jni\\vlc\\modules\\video_filter\\scene.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/****************************************************************************\n * DecodeBlock: the whole thing\n ****************************************************************************\n * This function must be fed with ogg packets.\n ****************************************************************************/\n", "func_signal": "static void *DecodeBlock( decoder_t *p_dec, block_t **pp_block )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n    ogg_packet oggpacket;\n\n    if( !pp_block ) return NULL;\n\n    if( *pp_block )\n    {\n        /* Block to Ogg packet */\n        oggpacket.packet = (*pp_block)->p_buffer;\n        oggpacket.bytes = (*pp_block)->i_buffer;\n    }\n    else\n    {\n        if( p_sys->b_packetizer ) return NULL;\n\n        /* Block to Ogg packet */\n        oggpacket.packet = NULL;\n        oggpacket.bytes = 0;\n    }\n\n    oggpacket.granulepos = -1;\n    oggpacket.b_o_s = 0;\n    oggpacket.e_o_s = 0;\n    oggpacket.packetno = 0;\n\n    /* Check for headers */\n    if( !p_sys->b_has_headers )\n    {\n        if( ProcessHeaders( p_dec ) )\n        {\n            block_Release( *pp_block );\n            return NULL;\n        }\n        p_sys->b_has_headers = true;\n    }\n\n    return ProcessPacket( p_dec, &oggpacket, pp_block );\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * ProcessInitialHeader: processes the inital Speex header packet.\n *****************************************************************************/\n", "func_signal": "static int ProcessInitialHeader( decoder_t *p_dec, ogg_packet *p_oggpacket )", "code": "{\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    void *p_state;\n    SpeexHeader *p_header;\n    const SpeexMode *p_mode;\n    SpeexCallback callback;\n\n    p_sys->p_header = p_header =\n        speex_packet_to_header( (char *)p_oggpacket->packet,\n                                p_oggpacket->bytes );\n    if( !p_header )\n    {\n        msg_Err( p_dec, \"cannot read Speex header\" );\n        return VLC_EGENERIC;\n    }\n    if( p_header->mode >= SPEEX_NB_MODES || p_header->mode < 0 )\n    {\n        msg_Err( p_dec, \"mode number %d does not (yet/any longer) exist in \"\n                 \"this version of libspeex.\", p_header->mode );\n        return VLC_EGENERIC;\n    }\n\n    p_mode = speex_mode_list[p_header->mode];\n    if( p_mode == NULL )\n        return VLC_EGENERIC;\n\n    if( p_header->speex_version_id > 1 )\n    {\n        msg_Err( p_dec, \"this file was encoded with Speex bit-stream \"\n                 \"version %d which is not supported by this decoder.\",\n                 p_header->speex_version_id );\n        return VLC_EGENERIC;\n    }\n\n    if( p_mode->bitstream_version < p_header->mode_bitstream_version )\n    {\n        msg_Err( p_dec, \"file encoded with a newer version of Speex.\" );\n        return VLC_EGENERIC;\n    }\n    if( p_mode->bitstream_version > p_header->mode_bitstream_version )\n    {\n        msg_Err( p_dec, \"file encoded with an older version of Speex.\" );\n        return VLC_EGENERIC;\n    }\n\n    msg_Dbg( p_dec, \"Speex %d Hz audio using %s mode %s%s\",\n             p_header->rate, p_mode->modeName,\n             ( p_header->nb_channels == 1 ) ? \" (mono\" : \" (stereo\",\n             p_header->vbr ? \", VBR)\" : \")\" );\n\n    /* Take care of speex decoder init */\n    speex_bits_init( &p_sys->bits );\n    p_sys->p_state = p_state = speex_decoder_init( p_mode );\n    if( !p_state )\n    {\n        msg_Err( p_dec, \"decoder initialization failed\" );\n        return VLC_EGENERIC;\n    }\n\n    if( p_header->nb_channels == 2 )\n    {\n        SpeexStereoState stereo = SPEEX_STEREO_STATE_INIT;\n        p_sys->stereo = stereo;\n        callback.callback_id = SPEEX_INBAND_STEREO;\n        callback.func = speex_std_stereo_request_handler;\n        callback.data = &p_sys->stereo;\n        speex_decoder_ctl( p_state, SPEEX_SET_HANDLER, &callback );\n    }\n    if( p_header->nb_channels <= 0 ||\n        p_header->nb_channels > 5 )\n    {\n        msg_Err( p_dec, \"invalid number of channels (not between 1 and 5): %i\",\n                 p_header->nb_channels );\n        return VLC_EGENERIC;\n    }\n\n    /* Setup the format */\n    p_dec->fmt_out.audio.i_physical_channels =\n        p_dec->fmt_out.audio.i_original_channels =\n            pi_channels_maps[p_header->nb_channels];\n    p_dec->fmt_out.audio.i_channels = p_header->nb_channels;\n    p_dec->fmt_out.audio.i_rate = p_header->rate;\n\n    date_Init( &p_sys->end_date, p_header->rate, 1 );\n\n    return VLC_SUCCESS;\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * Filter: Apply filtering logic to picture.\n *****************************************************************************/\n", "func_signal": "static picture_t *Filter( filter_t *p_filter, picture_t *p_pic )", "code": "{\n    /* TODO: think of some funky algorithm to detect scene changes. */\n    SnapshotRatio( p_filter, p_pic );\n    return p_pic;\n}", "path": "jni\\vlc\\modules\\video_filter\\scene.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * CloseDecoder: speex decoder destruction\n *****************************************************************************/\n", "func_signal": "static void CloseDecoder( vlc_object_t *p_this )", "code": "{\n    decoder_t * p_dec = (decoder_t *)p_this;\n    decoder_sys_t *p_sys = p_dec->p_sys;\n\n    if( p_sys->p_state )\n    {\n        speex_decoder_destroy( p_sys->p_state );\n        speex_bits_destroy( &p_sys->bits );\n    }\n\n    free( p_sys->p_header );\n    free( p_sys );\n}", "path": "jni\\vlc\\modules\\codec\\speex.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/*****************************************************************************\n * Save Picture to disk\n *****************************************************************************/\n", "func_signal": "static void SavePicture( filter_t *p_filter, picture_t *p_pic )", "code": "{\n    filter_sys_t *p_sys = (filter_sys_t *)p_filter->p_sys;\n    video_format_t fmt_in, fmt_out;\n    char *psz_filename = NULL;\n    char *psz_temp = NULL;\n    int i_ret;\n\n    memset( &fmt_in, 0, sizeof(video_format_t) );\n    memset( &fmt_out, 0, sizeof(video_format_t) );\n\n    /* Save snapshot psz_format to a memory zone */\n    fmt_in = p_pic->format;\n    fmt_out.i_sar_num = fmt_out.i_sar_den = 1;\n    fmt_out.i_width = p_sys->i_width;\n    fmt_out.i_height = p_sys->i_height;\n    fmt_out.i_chroma = p_sys->i_format;\n\n    /*\n     * Save the snapshot to a temporary file and\n     * switch it to the real name afterwards.\n     */\n    if( p_sys->b_replace )\n        i_ret = asprintf( &psz_filename, \"%s\" DIR_SEP \"%s.%s\",\n                          p_sys->psz_path, p_sys->psz_prefix,\n                          p_sys->psz_format );\n    else\n        i_ret = asprintf( &psz_filename, \"%s\" DIR_SEP \"%s%05d.%s\",\n                          p_sys->psz_path, p_sys->psz_prefix,\n                          p_sys->i_frames, p_sys->psz_format );\n\n    if( i_ret == -1 )\n    {\n        msg_Err( p_filter, \"could not create snapshot %s\", psz_filename );\n        goto error;\n    }\n    path_sanitize( psz_filename );\n\n    i_ret = asprintf( &psz_temp, \"%s.swp\", psz_filename );\n    if( i_ret == -1 )\n    {\n        msg_Err( p_filter, \"could not create snapshot temporarily file %s\", psz_temp );\n        goto error;\n    }\n    path_sanitize( psz_temp );\n\n    /* Save the image */\n    i_ret = image_WriteUrl( p_sys->p_image, p_pic, &fmt_in, &fmt_out,\n                            psz_temp );\n    if( i_ret != VLC_SUCCESS )\n    {\n        msg_Err( p_filter, \"could not create snapshot %s\", psz_temp );\n    }\n    else\n    {\n        /* switch to the final destination */\n#if defined (WIN32)\n        vlc_unlink( psz_filename );\n#endif\n        i_ret = vlc_rename( psz_temp, psz_filename );\n        if( i_ret == -1 )\n        {\n            msg_Err( p_filter, \"could not rename snapshot %s %m\", psz_filename );\n            goto error;\n        }\n    }\n\nerror:\n    free( psz_temp );\n    free( psz_filename );\n}", "path": "jni\\vlc\\modules\\video_filter\\scene.c", "repo_name": "shaobin0604/faplayer", "stars": 21, "license": "None", "language": "c", "size": 119400}
{"docstring": "/**\n * Thread-safety: FIXME.\n */\n", "func_signal": "void teredo_set_recv_callback (teredo_tunnel *restrict t, teredo_recv_cb cb)", "code": "{\n\tassert (t != NULL);\n\tt->recv_cb = (cb != NULL) ? cb : teredo_dummy_recv_cb;\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Encapsulates an IPv6 packet, forward it to a Teredo peer and release the\n * Teredo peers list. It is (obviously) assumed that the peers list lock is\n * held upon entry.\n *\n * @return 0 on success, -1 in case of UDP/IPv4 network error.\n */\n", "func_signal": "static\nint teredo_encap (teredo_tunnel *restrict tunnel, teredo_peer *restrict peer,\n                  const void *restrict data, size_t len, teredo_clock_t now)", "code": "{\n\tuint32_t ipv4 = peer->mapped_addr;\n\tuint16_t port = peer->mapped_port;\n\tTouchTransmit (peer, now);\n\tteredo_list_release (tunnel->list);\n\n\treturn (teredo_send (tunnel->fd,\n\t                     data, len, ipv4, port) == (int)len) ? 0 : -1;\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Receives a packet coming from the Teredo tunnel (as specified per\n * paragraph 5.4.2). That's called \u201cPacket reception\u201d.\n *\n * This function will NOT block if no packet are pending processing; it\n * will return immediatly.\n *\n * Thread-safety: This function is thread-safe.\n */\n", "func_signal": "static void\nteredo_run_inner (teredo_tunnel *restrict tunnel,\n                  const struct teredo_packet *restrict packet)", "code": "{\n\tassert (tunnel != NULL);\n\tassert (packet != NULL);\n\n#ifndef NDEBUG\n\tchar b[INET6_ADDRSTRLEN];\n#endif\n\tstruct ip6_hdr *ip6 = packet->ip6;\n\n\t// Checks packet\n\tif (packet->ip6_len < sizeof (*ip6))\n     \t{\n\t\tdebug (\"Packet size invalid: %zu bytes.\", packet->ip6_len);\n\t\treturn; // invalid packet\n\t}\n\n\tsize_t length = sizeof (*ip6) + ntohs (ip6->ip6_plen);\n\tif (((ip6->ip6_vfc >> 4) != 6)\n\t || (length > packet->ip6_len))\n     \t{\n\t   \tdebug (\"Received malformed IPv6 packet.\");\n\t\treturn; // malformatted IPv6 packet\n\t}\n\n\tpthread_rwlock_rdlock (&tunnel->state_lock);\n\tteredo_state s = tunnel->state;\n#ifdef MIREDO_TEREDO_CLIENT\n\tbool islocal = teredo_islocal (tunnel, packet);\n#endif\n\t/*\n\t * We can afford to use a slightly outdated state, but we cannot afford to\n\t * use an inconsistent state, hence this lock. Also, we cannot call\n\t * teredo_maintenance_process() while holding the lock, as that would\n\t * cause a deadlock at StateChange().\n\t */\n\tpthread_rwlock_unlock (&tunnel->state_lock);\n\n#ifdef MIREDO_TEREDO_CLIENT\n\t/* Maintenance */\n\tif (IsClient (tunnel))\n\t{\n\t\tif (teredo_maintenance_process (tunnel->maintenance, packet) == 0)\n\t\t{\n\t\t\tdebug (\" packet passed to maintenance procedure\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!s.up)\n\t\t{\n\t\t\tdebug (\" packet dropped because tunnel down\");\n\t\t\treturn; /* Not qualified -> do not accept incoming packets */\n\t\t}\n\n\t\tif ((packet->source_ipv4 == s.addr.teredo.server_ip)\n\t\t && (packet->source_port == htons (IPPORT_TEREDO)))\n\t\t{\n\t\t\tuint32_t ipv4 = packet->orig_ipv4;\n\t\t\tuint16_t port = packet->orig_port;\n\n\t\t\tif ((ipv4 == 0) && IsBubble (ip6)\n\t\t\t && (IN6_TEREDO_PREFIX (&ip6->ip6_src) == s.addr.teredo.prefix))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Some servers do not insert an origin indication.\n\t\t\t\t * When the source IPv6 address is a Teredo address,\n\t\t\t\t * we can guess the mapping. Otherwise, we're stuck.\n\t\t\t\t */\n\t\t\t\tipv4 = IN6_TEREDO_IPV4 (&ip6->ip6_src);\n\t\t\t\tport = IN6_TEREDO_PORT (&ip6->ip6_src);\n\t\t\t}\n\n\t\t\tif (ipv4)\n\t\t\t{\n\t\t\t\t/* TODO: record sending of bubble, create a peer, etc ? */\n\t\t\t\tteredo_reply_bubble (tunnel->fd, ipv4, port, ip6);\n\t\t\t\tdebug (\" bubble sent\");\n\t\t\t\tif (IsBubble (ip6))\n\t\t\t\t\treturn; // don't pass bubble to kernel\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Normal reception of packet must only occur if it does not\n\t\t * come from the server, as specified. However, it is not\n\t\t * unlikely that our server is a relay too. Hence, we must\n\t\t * further process packets from it.\n\t\t * At the moment, we only drop bubble (see above).\n\t\t */\n\n\t\t/*\n\t\t * Packets with a link-local source address are purposedly dropped to\n\t\t * prevent the kernel from receiving faked Router Advertisement which\n\t\t * could break IPv6 routing completely. Router advertisements MUST\n\t\t * have a link-local source address (RFC 2461).\n\t\t *\n\t\t * This is not supposed to occur except from the Teredo server for\n\t\t * Teredo maintenance (done above), and in hole punching packets\n\t\t * (bubbles). Direct bubbles can safely be ignored, so long as the\n\t\t * indirect ones are processed (and they are processed above).\n\t\t *\n\t\t * This check is not part of the Teredo specification, but I really\n\t\t * don't feel like letting link-local packets come in through the\n\t\t * virtual network interface.\n\t\t *\n\t\t * Only Linux defines s6_addr16, so we don't use it.\n\t\t */\n\t\tif (ntohs ((ip6->ip6_src.s6_addr16[0]) & 0xffc0) == 0xfe80)\n\t\t\treturn;\n\t}\n\telse\n#endif /* MIREDO_TEREDO_CLIENT */\n\t/* Relays only accept packets from Teredo clients */\n\tif (IN6_TEREDO_PREFIX (&ip6->ip6_src) != s.addr.teredo.prefix)\n\t{\n\t\tdebug (\"Source %s is not a teredo address.\",\n\t\t       inet_ntop (AF_INET6, &ip6->ip6_src.s6_addr, b, sizeof b));\n\t\treturn;\n\t}\n\n\t/* Actual packet reception, either as a relay or a client */\n\n\tteredo_clock_t now = teredo_clock ();\n\n\t// Checks source IPv6 address / looks up peer in the list:\n\tstruct teredo_peerlist *list = tunnel->list;\n\tteredo_peer *p = teredo_list_lookup (list, &ip6->ip6_src, NULL);\n\n#ifdef MIREDO_TEREDO_CLIENT\n\t/*\n\t * Client case 4 (local discovery bubble)\n\t *\n\t * NOTE: In addition to their announcement role, local discovery\n\t * bubbles are used in a way similar to indirect bubbles: when\n\t * transmitting to an untrusted local peer, a client sends both a\n\t * direct unicast bubble and a local discovery bubble, then waits for\n\t * the unicast reply we send below. (client tx case 3 and rx case 5)\n\t *\n\t * So we must check discovery bubbles right now, before case 1 gets a\n\t * chance to discard them, otherwise a trusted local peer will never\n\t * get a chance to trust us as well.\n\t */\n\tif (islocal && IsDiscoveryBubble (packet))\n\t{\n\t\tif (p == NULL)\n\t\t{\n\t\t\tp = teredo_list_lookup (list, &ip6->ip6_src, &(bool){ false });\n\t\t\tif (p == NULL) {\n\t\t\t\tdebug (\"Out of memory.\");\n\t\t\t\treturn; // memory error\n\t\t\t}\n\t\t\tp->trusted = 0;\n\t\t\tp->local = 0;\n\t\t}\n\n\t\t/* reset the number of bubbles when a peer becomes local */\n\t\tif (!p->local)\n\t\t\tp->bubbles = 0;\n\n\t\tSetMappingFromPacket (p, packet);\n\t\tp->local = 1;\n\t\tTouchReceive (p, now);\n\t\tteredo_list_release (list);\n\n\t\tif (CountBubble (p, now) != 0)\n\t\t\treturn;\n\n\t\tdebug (\"Replying to discovery bubble\");\n\t\tteredo_send_bubble_anyway (tunnel->fd,\n\t\t\t\t\t   packet->source_ipv4,\n\t\t\t\t\t   packet->source_port,\n\t\t\t\t\t   &s.addr.ip6, &ip6->ip6_src);\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * NOTE:\n\t * Clients are supposed to check that the destination is their Teredo IPv6\n\t * address; this is done by the IPv6 stack. When IPv6 forwarding is enabled,\n\t * Teredo clients behave like Teredo non-host-specific relays.\n\t *\n\t * Teredo relays are advised to accept only packets whose IPv6 destination\n\t * is served by them (i.e. egress filtering from Teredo to native IPv6).\n\t * The IPv6 stack firewall should be used to that end.\n\t *\n\t * With the exception of local client discovery bubbles, multicast\n\t * destinations are not supposed to occur, not even for hole punching.\n\t * We drop them as a precautionary measure.\n\t *\n\t * We purposedly don't drop packets on the basis of link-local destination\n\t * as it breaks hole punching: we send Teredo bubbles with a link-local\n\t * source, and get replies with a link-local destination. Indeed, the\n\t * specification specifies that relays MUST look up the peer in the list\n\t * and update last reception date regardless of the destination.\n\t *\n\t */\n\tif (ip6->ip6_dst.s6_addr[0] == 0xff)\n\t{\n\t\tif (p != NULL)\n\t\t\tteredo_list_release (list);\n\t\tdebug (\"Multicast destination %s not supported.\",\n\t\t       inet_ntop (AF_INET6, &ip6->ip6_dst.s6_addr, b, sizeof b));\n\t\treturn;\n\t}\n\n\tif (p != NULL)\n\t{\n\n\t\t// Client case 1 (trusted node or (trusted) Teredo client):\n\t\tif (p->trusted\n\t\t && (packet->source_ipv4 == p->mapped_addr)\n\t\t && (packet->source_port == p->mapped_port))\n\t\t{\n\t\t\tteredo_predecap (tunnel, p, now);\n\t\t\ttunnel->recv_cb (tunnel->opaque, ip6, length);\n\t\t\treturn;\n\t\t}\n\n#ifdef MIREDO_TEREDO_CLIENT\n\t\t/*\n\t\t * Client case 2 (untrusted non-Teredo node):\n\t\t * Mismatching trusted non-Teredo nodes are also accepted to recover\n\t\t * faster from a Teredo relay change. This is legal (client case 6).\n\t\t */\n\t\tif (IsClient (tunnel) && (CheckPing (packet) == 0))\n\t\t{\n\t\t\tp->trusted = 1;\n\t\t\tSetMappingFromPacket (p, packet);\n\n\t\t\tteredo_predecap (tunnel, p, now);\n\t\t\treturn; /* don't pass ping to kernel */\n\t\t}\n#endif /* ifdef MIREDO_TEREDO_CLIENT */\n\t}\n\n\t/*\n\t * At this point, we have either a trusted mapping mismatch,\n\t * an unlisted peer, or an un-trusted client peer.\n\t */\n\tif (IN6_TEREDO_PREFIX (&ip6->ip6_src) == s.addr.teredo.prefix)\n\t{\n\t\t// Client case 3 (unknown or untrusted matching Teredo client):\n\t\tif (IN6_MATCHES_TEREDO_CLIENT (&ip6->ip6_src, packet->source_ipv4,\n\t\t                               packet->source_port)\n#ifdef MIREDO_TEREDO_CLIENT\n\t\t// Client case 5 (untrusted local peer)\n\t\t || (p != NULL && p->local\n\t\t     && (packet->source_ipv4 == p->mapped_addr)\n\t\t     && (packet->source_port == p->mapped_port))\n\t\t// Extension: packet from unknown local peer (faster discovery)\n\t\t || (p == NULL && islocal)\n#endif\n\t\t// Extension: allow mismatch (i.e. clients behind symmetric NATs)\n\t\t || (IsBubble (ip6) && (CheckBubble (packet) == 0)))\n\t\t{\n#ifdef MIREDO_TEREDO_CLIENT\n\t\t\tif (IsClient (tunnel) && (p == NULL))\n\t\t\t{\n\t\t\t\tp = teredo_list_lookup (list, &ip6->ip6_src, &(bool){ false });\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tdebug (\"Out of memory.\");\n\t\t\t\t\treturn; // memory error\n\t\t\t\t}\n\t\t\t\tp->local = islocal;\n\t\t\t}\n#endif\n\t\t\t/*\n\t\t\t * Relays are explicitly allowed to drop packets from\n\t\t\t * unknown peers. It makes it a little more difficult to route\n\t\t\t * packets through the wrong relay. The specification leaves\n\t\t\t * us a choice here. It is arguable whether accepting these\n\t\t\t * packets would make it easier to DoS the peer list.\n\t\t\t */\n\t\t\tif (p == NULL)\n\t\t     \t{\n\t\t\t\tdebug (\"No peer for %s found. Dropping packet.\",\n\t\t\t\t       inet_ntop (AF_INET6, &ip6->ip6_src.s6_addr, b,\n\t\t\t\t                  sizeof b));\n\t\t\t\treturn; // list not locked (p = NULL)\n\t\t\t}\n\n\t\t\tSetMappingFromPacket (p, packet);\n\t\t\tp->trusted = 1;\n\t\t\tteredo_predecap (tunnel, p, now);\n\n\t\t\tif (!IsBubble (ip6)) // discard Teredo bubble\n\t\t\t\ttunnel->recv_cb (tunnel->opaque, ip6, length);\n\t\t\treturn;\n\t\t}\n\t}\n#ifdef MIREDO_TEREDO_CLIENT\n\telse\n\t{\n\t\tassert (IN6_TEREDO_PREFIX (&ip6->ip6_src) != s.addr.teredo.prefix);\n\t\tassert (IsClient (tunnel));\n\n\t\t/*\n\t\t * Default: Client case 6:\n\t\t * (unknown non-Teredo node or Tereco client with incorrect mapping):\n\t\t * We should be cautious when accepting packets there, all the\n\t\t * more as we don't know if we are a really client or just a\n\t\t * qualified relay (ie. whether the host's default route is\n\t\t * actually the Teredo tunnel).\n\t\t */\n\t\n\t\t// TODO: avoid code duplication (direct IPv6 connectivity test)\n\t\tif (p == NULL)\n\t\t{\n\t\t\tbool create;\n\t\t\tp = teredo_list_lookup (list, &ip6->ip6_src, &create);\n\t\t\tif (p == NULL)\n\t\t     \t{\n\t\t\t\tdebug (\"Out of memory.\");\n\t\t\t\treturn; // memory error\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to check \"create\": there is a race condition whereby\n\t\t\t * another thread could have created the peer in between the two\n\t\t\t * lookups of this function, since we did not lock the list\n\t\t\t * in between.\n\t\t\t */\n\t\t\tif (create)\n\t\t\t{\n\t\t\t\tp->mapped_port = 0;\n\t\t\t\tp->mapped_addr = 0;\n\t\t\t\tp->trusted = p->local = 0;\n\t\t\t\tp->bubbles = p->pings = 0;\n\t\t\t}\n\t\t}\n\n\t\tteredo_enqueue_in (p, ip6, length,\n\t\t                   packet->source_ipv4, packet->source_port);\n\t\tTouchReceive (p, now);\n\n\t\tint res = CountPing (p, now);\n\t\tteredo_list_release (list);\n\n\t\tif (res == 0)\n\t\t\tSendPing (tunnel->fd, &s.addr, &ip6->ip6_src);\n\n\t\treturn;\n\t}\n#endif /* ifdef MIREDO_TEREDO_CLIENT */\n\n\tdebug (\"Dropping packet.\");\n\t// Rejected packet\n\tif (p != NULL)\n\t\tteredo_list_release (list);\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * @return 0 if a ping may be sent. 1 if one was sent recently\n * -1 if the peer seems unreachable.\n */\n", "func_signal": "static int CountPing (teredo_peer *peer, teredo_clock_t now)", "code": "{\n\tint res;\n\n\tif (peer->pings == 0)\n\t\tres = 0;\n\t// don't test more than 4 times (once + 3 repeats)\n\telse if (peer->pings >= 4)\n\t\tres = -1;\n\t// test must be separated by at least 2 seconds\n\telse\n\tif (now - peer->last_ping <= 2)\n\t\tres = 1;\n\telse\n\t\tres = 0; // can test again!\n\n\tif (res == 0)\n\t{\n\t\tpeer->last_ping = now;\n\t\tpeer->pings++;\n\t}\n\n\treturn res;\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Adds a setting.\n * @return false if memory is missing.\n */\n", "func_signal": "static bool\nmiredo_conf_set (miredo_conf *conf, const char *name, const char *value,\n                 unsigned line)", "code": "{\n\tassert (conf != NULL);\n\tassert (name != NULL);\n\tassert (value != NULL);\n\n\tstruct setting *parm =\n\t\t(struct setting *)malloc (sizeof (struct setting));\n\n\tif (parm != NULL)\n\t{\n\t\tparm->name = strdup (name);\n\t\tif (parm->name != NULL)\n\t\t{\n\t\t\tparm->value = strdup (value);\n\t\t\tif (parm->value != NULL)\n\t\t\t{\n\t\t\t\tparm->line = line;\n\t\t\t\tparm->next = NULL;\n\n\t\t\t\t/* lock here */\n\t\t\t\tif (conf->head == NULL)\n\t\t\t\t\tconf->head = parm;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tassert (conf->tail != NULL);\n\t\t\t\t\tconf->tail->next = parm;\n\t\t\t\t}\n\t\t\t\tconf->tail = parm;\n\t\t\t\t/* unlock here */\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfree (parm->name);\n\t\t}\n\t\tfree (parm);\n\t}\n\n\tLogError (conf, _(\"Error (%s): %s\"), \"strdup\", strerror (errno));\n\treturn false;\n}", "path": "src\\conf.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/*\n * Looks up a setting by name.\n * @return NULL if not found.\n * Otherwise, return value must be free()d by caller.\n */\n", "func_signal": "char *miredo_conf_get (miredo_conf *conf, const char *name, unsigned *line)", "code": "{\n\tfor (struct setting *p = conf->head, *prev = NULL; p != NULL; p = p->next)\n\t{\n\t\tif (strcasecmp (p->name, name) == 0)\n\t\t{\n\t\t\tchar *buf = p->value;\n\n\t\t\tif (line != NULL)\n\t\t\t\t*line = p->line;\n\n\t\t\tif (prev != NULL)\n\t\t\t\tprev->next = p->next;\n\t\t\telse\n\t\t\t\tconf->head = p->next;\n\n\t\t\tfree (p->name);\n\t\t\tfree (p);\n\t\t\treturn buf;\n\t\t}\n\t\tprev = p;\n\t}\n\n\treturn NULL;\n}", "path": "src\\conf.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Looks up an IPv4 address (network byte order) associated with hostname.\n */\n", "func_signal": "int GetIPv4ByName (const char *hostname, uint32_t *ipv4)", "code": "{\n\tstruct addrinfo help =\n\t{\n\t\t.ai_family = AF_INET,\n\t\t.ai_socktype = SOCK_DGRAM,\n\t\t.ai_protocol = IPPROTO_UDP\n\t}, *res;\n\n\tint check = getaddrinfo (hostname, NULL, &help, &res);\n\tif (check)\n\t\treturn check;\n\n\t*ipv4 = ((const struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;\n\tfreeaddrinfo (res);\n\treturn 0;\n}", "path": "src\\conf.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Thread to encapsulate IPv6 packets into UDP.\n * Cancellation safe.\n */\n", "func_signal": "static LIBTEREDO_NORETURN void *miredo_encap_thread (void *d)", "code": "{\n\tteredo_tunnel *relay = ((miredo_tunnel *)d)->relay;\n\ttun6 *tunnel = ((miredo_tunnel *)d)->tunnel;\n\n\tfor (;;)\n\t{\n\t\t/* Handle incoming data */\n\t\tstruct\n\t\t{\n\t\t\tstruct ip6_hdr ip6;\n\t\t\tuint8_t fill[65467];\n\t\t} pbuf;\n\n\t\t/* Forwards IPv6 packet to Teredo\n\t\t * (Packet transmission) */\n\t\tint val = tun6_wait_recv (tunnel, &pbuf.ip6, sizeof (pbuf));\n\t\tif (val >= 40)\n\t\t{\n\t\t\tpthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);\n\t\t\tteredo_transmit (relay, &pbuf.ip6, val);\n\t\t\tpthread_setcancelstate (PTHREAD_CANCEL_ENABLE, NULL);\n\t\t}\n\t\telse\n\t\t\tpthread_testcancel ();\n\t}\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/*\n * Configuration and respawning stuff\n */\n", "func_signal": "static void logger (void *dummy, bool error, const char *fmt, va_list ap)", "code": "{\n\t(void)dummy;\n\n\tvsyslog (error ? LOG_ERR : LOG_WARNING, fmt, ap);\n}", "path": "src\\miredo.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Callback to emit an ICMPv6 error message through a raw ICMPv6 socket.\n */\n", "func_signal": "static void\nmiredo_icmp6_callback (void *data, const void *packet, size_t length,\n                        const struct in6_addr *dst)", "code": "{\n\t(void)data;\n\tassert (icmp6_fd != -1);\n\n\tstruct sockaddr_in6 addr =\n\t{\n\t\t.sin6_family = AF_INET6,\n#ifdef HAVE_SA_LEN\n\t\t.sin6_len = sizeof (struct sockaddr_in6),\n#endif\n\t\t.sin6_addr = *dst\n\t};\n\n\t/* TODO: use sendmsg and don't memcpy in BuildICMPv6Error */\n\t(void)sendto (icmp6_fd, packet, length, 0,\n\t              (struct sockaddr *)&addr, sizeof (addr));\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Callback to transmit decapsulated Teredo IPv6 packets to the kernel.\n */\n", "func_signal": "static void\nmiredo_recv_callback (void *data, const void *packet, size_t length)", "code": "{\n\tassert (data != NULL);\n\n\t(void)tun6_send (((miredo_tunnel *)data)->tunnel, packet, length);\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Callback to deconfigure a Teredo tunneling interface.\n */\n", "func_signal": "static void\nmiredo_down_callback (void *data)", "code": "{\n\tassert (data != NULL);\n\n\tconfigure_tunnel (((miredo_tunnel *)data)->priv_fd, &in6addr_any,\n\t                         1280);\n\tsyslog (LOG_NOTICE, _(\"Teredo pseudo-tunnel stopped\"));\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Peer list garbage collector entry point.\n *\n * @return never ever.\n */\n", "func_signal": "static LIBTEREDO_NORETURN void *garbage_collector (void *data)", "code": "{\n\tstruct teredo_peerlist *l = (struct teredo_peerlist *)data;\n\n\tfor (;;)\n\t{\n\t\tstruct timespec delay = { .tv_sec = l->expiration };\n\t\twhile (clock_nanosleep (CLOCK_REALTIME, 0, &delay, &delay));\n\n\t\tint state;\n\t\tpthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);\n\t\t/* cancel-unsafe section starts */\n\t\tpthread_mutex_lock (&l->lock);\n\n\t\t// remove expired peers from hash table\n\t\tfor (teredo_listitem *p = l->old; p != NULL; p = p->next)\n\t\t{\n#ifdef HAVE_LIBJUDY\n\t\t\tint Rc_int;\n\t\t\tJHSD (Rc_int, l->PJHSArray, (uint8_t *)&p->key, 16);\n\t\t\tassert (Rc_int);\n#endif\n\t\t\tl->left++;\n\t\t}\n\n\t\t// unlinks old peers\n\t\tteredo_listitem *old = l->old;\n\n\t\t// moves recent peers to old peers area\n\t\tl->old = l->recent;\n\t\tl->recent = NULL;\n\t\tif (l->old != NULL)\n\t\t\tl->old->pprev = &l->old;\n\n\t\tpthread_mutex_unlock (&l->lock);\n\n\t\t// Perform possibly expensive memory release without the lock\n\t\tsched_yield ();\n\t\tlistitem_recdestroy (old);\n\n\t\t/* cancel-unsafe section ends */\n\t\tpthread_setcancelstate (state, NULL);\n\t\tsched_yield ();\n\t}\n}", "path": "libteredo\\peerlist.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Looks up an unsigned 16-bits integer. Returns false if the\n * setting was found but incorrectly formatted.\n *\n * If the setting was not found value, returns true and leave\n * *value unchanged.\n */\n", "func_signal": "bool miredo_conf_get_int16 (miredo_conf *conf, const char *name,\n                            uint16_t *value, unsigned *line)", "code": "{\n\tchar *val = miredo_conf_get (conf, name, line);\n\n\tif (val == NULL)\n\t\treturn true;\n\n\tchar *end;\n\tunsigned long l;\n\n\tl = strtoul (val, &end, 0);\n\t\n\tif ((*end) || (l > 65535))\n\t{\n\t\tLogError (conf, _(\"Invalid integer value \\\"%s\\\" for %s: %s\"),\n\t\t          val, name, strerror (errno));\n\t\tfree (val);\n\t\treturn false;\n\t}\n\t*value = (uint16_t)l;\n\tfree (val);\n\treturn true;\n}", "path": "src\\conf.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/*\n * Sends an ICMPv6 Destination Unreachable error to the IPv6 Internet.\n * Unfortunately, this will use a local-scope address as source, which is not\n * quite good.\n */\n", "func_signal": "void\nTeredoRelay::EmitICMPv6Error (const void *packet, size_t length,\n\t\t\t\t\t\t\t  const struct in6_addr *dst)", "code": "{\n\t/* TODO should be implemented with BuildIPv6Error() */\n\t/* that is currently dead code */\n\n\t/* F-I-X-M-E: using state implies locking */\n\tsize_t outlen = BuildIPv6Error (&buf.hdr, &state.addr.ip6,\n\t                                ICMP6_DST_UNREACH, code, in, inlen);\n\ttunnel->recv_cb (tunnel->opaque, &buf, outlen);\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/* Parses a file.\n *\n * @return false on I/O error, true on success.\n */\n", "func_signal": "bool miredo_conf_read_file (miredo_conf *conf, const char *path)", "code": "{\n\tassert (path != NULL);\n\n\tFILE *stream = fopen (path, \"r\");\n\tif (stream != NULL)\n\t{\n\t\tbool ret = miredo_conf_read_FILE (conf, stream);\n\t\tfclose (stream);\n\t\treturn ret;\n\t}\n\n\tLogError (conf, _(\"Error opening configuration file %s: %s\"), path,\n\t          strerror (errno));\n\treturn false;\n}", "path": "src\\conf.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Callback to configure a Teredo tunneling interface.\n */\n", "func_signal": "static void\nmiredo_up_callback (void *data, const struct in6_addr *addr, uint16_t mtu)", "code": "{\n\tchar str[INET6_ADDRSTRLEN];\n\n\tsyslog (LOG_NOTICE, _(\"Teredo pseudo-tunnel started\"));\n\tif (inet_ntop (AF_INET6, addr, str, sizeof (str)) != NULL)\n\t\tsyslog (LOG_INFO, _(\" (address: %s, MTU: %\"PRIu16\")\"),\n\t\t        str, mtu);\n\n\tassert (data != NULL);\n\n\tconfigure_tunnel (((miredo_tunnel *)data)->priv_fd, addr, mtu);\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Rate limiter around ICMPv6 unreachable error packet emission callback.\n *\n * @param code ICMPv6 unreachable error code.\n * @param in IPv6 packet that caused the error.\n * @param len byte length of the IPv6 packet at <in>.\n */\n", "func_signal": "static void\nteredo_send_unreach (teredo_tunnel *restrict tunnel, uint8_t code,\n                     const struct ip6_hdr *restrict in, size_t len)", "code": "{\n\tstruct\n\t{\n\t\tstruct icmp6_hdr hdr;\n\t\tchar fill[1280 - sizeof (struct ip6_hdr) - sizeof (struct icmp6_hdr)];\n\t} buf;\n\tteredo_clock_t now = teredo_clock ();\n\n\t/* ICMPv6 rate limit */\n\tpthread_mutex_lock (&tunnel->ratelimit.lock);\n\tif (now != tunnel->ratelimit.last)\n\t{\n\t\ttunnel->ratelimit.last = now;\n\t\ttunnel->ratelimit.count =\n\t\t\tICMP_RATE_LIMIT_MS ? (int)(1000 / ICMP_RATE_LIMIT_MS) : -1;\n\t}\n\n\tif (tunnel->ratelimit.count == 0)\n\t{\n\t\t/* rate limit exceeded */\n\t\tpthread_mutex_unlock (&tunnel->ratelimit.lock);\n\t\treturn;\n\t}\n\tif (tunnel->ratelimit.count > 0)\n\t\ttunnel->ratelimit.count--;\n\tpthread_mutex_unlock (&tunnel->ratelimit.lock);\n\n\tlen = BuildICMPv6Error (&buf.hdr, ICMP6_DST_UNREACH, code, in, len);\n\ttunnel->icmpv6_cb (tunnel->opaque, &buf.hdr, len, &in->ip6_src);\n}", "path": "libteredo\\relay.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Checks if libtun6 should be able to tun on system.\n *\n * @param errbuf a buffer of at least LIBTUN6_ERRBUF_SIZE bytes\n * to hold an error message suitable for the user attention.\n * Also set on success.\n *\n * @return 0 on success, -1 if the system seems inadequate.\n */\n", "func_signal": "int tun6_driver_diagnose (char *errbuf)", "code": "{\n\t(void)bindtextdomain (PACKAGE_NAME, LOCALEDIR);\n\n\tint fd = socket (AF_INET6, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t{\n\t\tstrlcpy (errbuf, \"Error: IPv6 stack not available.\\n\",\n\t\t         LIBTUN6_ERRBUF_SIZE - 1);\n\t\terrbuf[LIBTUN6_ERRBUF_SIZE - 1] = '\\0';\n\t\treturn -1;\n\t}\n\t(void)close (fd);\n\n#if defined (__linux__)\n\tconst char tundev[] = \"/dev/net/tun\";\n\n\tfd = open (tundev, O_RDWR);\n\tif (fd != -1)\n\t{\n\t\t(void)close (fd);\n\t\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t          \"%s tunneling driver found.\", os_driver);\n\t\treturn 0;\n\t}\n\n\tswitch (errno)\n\t{\n\t\tcase ENOENT:\n\t\t\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t\t          _(\"Error: %s character device \"\n\t\t\t            \"not found or unavailable.\\n%s\"), tundev,\n\t\t\t          _(\"You might try to run this command to load it:\\n\"\n\t\t\t            \"$ modprobe tun\\n\"\n\t\t\t            \"(you must be root to do that).\\n\"));\n\t\t\treturn -1;\n\t\tcase ENXIO:\n\t\tcase ENODEV: /* Linux returns ENODEV instead of ENXIO */\n\t\t\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t\t          _(\"Error: your operating system does not \"\n\t\t\t            \"seem to provide a network tunneling\\n\"\n\t\t\t            \"device driver, which is required.\\n%s\"),\n\t\t\t          _(\"Make sure your Linux kernel includes \"\n\t\t\t            \"the \\\"Universal TUNTAP driver\\\"\\n\"\n\t\t\t            \"(CONFIG_TUN option), possibly as a module.\\n\"));\n\t\t\treturn -1;\n\t}\n#else\n#if 1\t/* BSD creates a tunnel even on stat() - skip diagnostics */\n\treturn 0;\n#else\n\tconst char tundev[] = \"/dev/tun0\";\n\tstruct stat st;\n\n\tif (stat (tundev, &st) == 0)\n\t{\n\t\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t          \"%s tunneling driver found.\", os_driver);\n\t\treturn 0;\n\t}\n\n\tif (errno == ENOENT)\n\t{\n\t\tconst char *specific;\n\n# if defined (__APPLE__)\n\t\tspecific = N_(\"You can obtain a tunnel driver for the \"\n\t\t\t\"Darwin kernel (Mac OS X) from:\\n\"\n\t\t\t\"http://www-user.rhrk.uni-kl.de/~nissler/tuntap/\\n\");\n# elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)\n\t\tspecific = N_(\"You might try to run this command to load it:\\n\"\n\t\t\t\"$ kldload if_tun\\n\"\n\t\t\t\"(you must be root to do that).\\n\");\n# else\n\t\tspecific = NULL;\n# endif\n\n\t\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t\t_(\"Error: %s character device \"\n\t\t\t\"not found or unavailable.\\n%s\"), tundev,\n\t\t\tspecific != NULL ? dgettext (PACKAGE_NAME, specific) : \"\");\n\t\treturn -1;\n\t}\n#endif\n#endif\n\n#ifdef __linux__\n\t/* FIXME: use strerror_l() instead? */\n\tchar buf[256]; /* Hopefully big enough... :-/ */\n\tstrerror_r (errno, buf, sizeof (buf));\n\tsnprintf (errbuf, LIBTUN6_ERRBUF_SIZE,\n\t\t_(\"Error: cannot open device file %s (%s)\\n\"\n\t\t\"IPv6 tunneling will not work.\\n\"), tundev, buf);\n\treturn -1;\n#endif\n}", "path": "libtun6\\diag.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/**\n * Miredo main daemon function, with UDP datagrams and IPv6 packets\n * receive loop.\n */\n", "func_signal": "static int\nrun_tunnel (miredo_tunnel *tunnel)", "code": "{\n\tpthread_t encap_th;\n\tif (teredo_run_async (tunnel->relay)\n\t || pthread_create (&encap_th, NULL, miredo_encap_thread, tunnel))\n\t\treturn -1;\n\n\tsigset_t dummyset, set;\n\tsigemptyset (&dummyset);\n\tpthread_sigmask (SIG_BLOCK, &dummyset, &set);\n\twhile (sigwait (&set, &(int){ 0 }));\n\n\tpthread_cancel (encap_th);\n\tpthread_join (encap_th, NULL);\n\treturn 0;\n}", "path": "src\\relayd.c", "repo_name": "darconeous/miredo", "stars": 18, "license": "gpl-2.0", "language": "c", "size": 2515}
{"docstring": "/*\n * See C:ARM p.197 6.3.3 The Usual Unary Conversions.\n */\n", "func_signal": "static Var *unary_conv(ReadContext *ctx, Var *var)", "code": "{\n    var = rv(ctx, var);\n    if (var->ctype->type == CTYPE_ARRAY) {\n        Var *r = make_var(make_ctype_ptr(var->ctype->ptr));\n        emit(ctx, make_inst2(OP_ADDRESS, r, var));\n        return r;\n    }\n    if (ctype_sizeof(var->ctype) >= 4)\n        return var;\n    Var *r = make_var(make_ctype(CTYPE_INT));\n    emit(ctx, make_inst2(OP_ASSIGN, r, var));\n    return r;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * Operator-precedence parser.\n */\n", "func_signal": "static Var *read_expr1(ReadContext *ctx, Var *v0, int prec0)", "code": "{\n    for (;;) {\n        Token *tok = read_token(ctx);\n        int prec1 = prec(tok);\n        if (prec1 < 0 || prec0 < prec1) {\n            unget_token(ctx, tok);\n            return v0;\n        }\n        if (is_keyword(tok, '?')) {\n            v0 = read_cond_expr(ctx, v0);\n            v0 = unary_conv(ctx, v0);\n            continue;\n        }\n        if (is_keyword(tok, KEYWORD_LOG_AND) || is_keyword(tok, KEYWORD_LOG_OR)) {\n            push_block(ctx, make_block());\n        }\n        Var *v1 = read_unary_expr(ctx);\n        for (;;) {\n            Token *tok1 = peek_token(ctx);\n            int prec2 = prec(tok1);\n            if (prec2 < 0 || prec1 < prec2 || (prec1 == prec2 && !is_rassoc(tok1))) {\n                break;\n            }\n            v1 = read_expr1(ctx, v1, prec2);\n        }\n        if (is_keyword(tok, '=')) {\n            emit_assign(ctx, v0, v1);\n            continue;\n        }\n\n        v0 = unary_conv(ctx, v0);\n        v1 = unary_conv(ctx, v1);\n        int op;\n        switch (tok->val.i) {\n        case ',':\n            v0 = v1;\n            break;\n        case '+': case '-':\n            v0 = emit_arith(ctx, tok->val.i, v0, v1);\n            break;\n        case '*':\n        case '/': {\n            v0 = emit_arith_inst3(ctx, tok->val.i, v0, v1);\n            break;\n        }\n        case '^':\n        case '&':\n        case '|': {\n            Var *tmp = make_var(binary_type_conv(v0, v1));\n            if (is_flonum(tmp->ctype))\n                error_token(tok, \"invalid operand to binary '%c'\", tok->val.i);\n            emit(ctx, make_inst3(tok->val.i, tmp, v0, v1));\n            v0 = tmp;\n            break;\n        }\n        case KEYWORD_EQ:\n            op = OP_EQ; goto cmp;\n        case KEYWORD_NE:\n            op = OP_NE; goto cmp;\n        case '>':\n            SWAP(Var *, v0, v1);\n            // FALL THROUGH\n        case '<':\n            op = '<'; goto cmp;\n        case KEYWORD_GE:\n            SWAP(Var *, v0, v1);\n            // FALL THROUGH\n        case KEYWORD_LE:\n            op = OP_LE; goto cmp;\n        cmp:\n            v0 = emit_log_inst3(ctx, op, v0, v1);\n            break;\n        case KEYWORD_A_ADD:\n            op = '+'; goto assign_arith_op;\n        case KEYWORD_A_SUB:\n            op = '-'; goto assign_arith_op;\n        assign_arith_op:\n            ensure_lvalue(ctx, v0);\n            emit_assign(ctx, v0, emit_arith(ctx, op, v0, v1));\n            break;\n        case KEYWORD_A_MUL:\n            op = '*'; goto assign_op;\n        case KEYWORD_A_DIV:\n            op = '/'; goto assign_op;\n        case KEYWORD_A_AND:\n            op = '&'; goto assign_op;\n        case KEYWORD_A_OR:\n            op = '|'; goto assign_op;\n        case KEYWORD_A_XOR:\n            op = '^'; goto assign_op;\n        case KEYWORD_A_LSH:\n            op = OP_SHL; goto assign_op;\n        case KEYWORD_A_RSH:\n            op = OP_SHR; goto assign_op;\n        assign_op:\n            ensure_lvalue(ctx, v0);\n            emit(ctx, make_inst3(op, v0, v0, v1));\n            break;\n        case KEYWORD_LOG_AND:\n            v0 = emit_log_and(ctx, v0, v1);\n            break;\n        case KEYWORD_LOG_OR:\n            v0 = emit_log_or(ctx, v0, v1);\n            break;\n        case KEYWORD_LSH:\n            v0 = emit_arith_inst3(ctx, OP_SHL, v0, v1);\n            break;\n        case KEYWORD_RSH:\n            v0 = emit_arith_inst3(ctx, OP_SHR, v0, v1);\n            break;\n        default:\n            error_token(tok, \"unsupported operator: %s\", token_to_string(tok));\n        }\n    }\n    return v0;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * for-statement:\n *     \"for\" for-expressions statement\n *\n * for-expressions:\n *     \"(\" initial-clause? \";\" expression? \";\" expression? \")\"\n *\n * initial-clause:\n *     expression\n *     declaration\n */\n", "func_signal": "static void read_for_stmt(ReadContext *ctx)", "code": "{\n    Block *cond = make_block();\n    Block *mod = make_block();\n    Block *body = make_block();\n    Block *cont = make_block();\n    push_scope(ctx);\n\n    expect(ctx, '(');\n    if (!next_token_is(ctx, ';'))\n        read_decl_or_stmt(ctx);\n\n    emit(ctx, make_inst1(OP_JMP, cond));\n\n    push_block(ctx, cond);\n    Var *condvar = read_comma_expr(ctx);\n    emit(ctx, make_inst4(OP_IF, condvar, body, NULL, cont));\n    pop_block(ctx);\n    expect(ctx, ';');\n\n    push_block(ctx, mod);\n    read_comma_expr(ctx);\n    emit(ctx, make_inst1(OP_JMP, cond));\n    pop_block(ctx);\n    expect(ctx, ')');\n\n    Block *orig_onbreak = ctx->onbreak;\n    Block *orig_oncontinue = ctx->oncontinue;\n    ctx->onbreak = cont;\n    ctx->oncontinue = mod;\n    push_block(ctx, body);\n    push_scope(ctx);\n    read_stmt(ctx);\n    pop_scope(ctx);\n    emit(ctx, make_inst1(OP_JMP, mod));\n    pop_block(ctx);\n    ctx->oncontinue = orig_oncontinue;\n    ctx->onbreak = orig_onbreak;\n\n    pop_scope(ctx);\n    replace_block(ctx, cont);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * primary-expression:\n *     identifier\n *     constant\n *     parenthesized-expression\n *\n * constant:\n *     integer-constant\n *     floating-constant\n *     character-constant\n *     string-constant\n */\n", "func_signal": "static Var *read_primary_expr(ReadContext *ctx)", "code": "{\n    Token *tok = read_token(ctx);\n    switch (tok->toktype) {\n    case TOKTYPE_CHAR:\n        return make_imm(CTYPE_CHAR, (Cvalue)tok->val.i);\n    case TOKTYPE_INT:\n        return make_imm(CTYPE_INT, (Cvalue)tok->val.i);\n    case TOKTYPE_FLOAT:\n        return make_imm(CTYPE_FLOAT, (Cvalue)tok->val.f);\n    case TOKTYPE_STRING: {\n        String *b;\n        Token *tok1 = read_token(ctx);\n        if (tok1->toktype == TOKTYPE_STRING) {\n            b = make_string();\n            out(b, STRING_BODY(tok->val.str), STRING_LEN(tok->val.str) - 1);\n            do {\n                out(b, STRING_BODY(tok1->val.str), STRING_LEN(tok1->val.str) - 1);\n                tok1 = read_token(ctx);\n            } while (tok1->toktype == TOKTYPE_STRING);\n            unget_token(ctx, tok1);\n            o1(b, 0);\n        } else {\n            unget_token(ctx, tok1);\n            b = tok->val.str;\n        }\n        Ctype *type = make_ctype_array(make_ctype(CTYPE_CHAR), STRING_LEN(b));\n        return make_imm1(type, (Cvalue)b);\n    }\n    case TOKTYPE_IDENT: {\n        Token *tok1 = read_token(ctx);\n        if (is_keyword(tok1, '('))\n            return read_func_call(ctx, tok);\n        unget_token(ctx, tok1);\n        Var *var = find_var(ctx, tok->val.str);\n        if (!var) {\n            warn(\"'%s' is not defined\", STRING_BODY(tok->val.str));\n            var = make_var(make_ctype(CTYPE_INT));\n            var->name = tok->val.str;\n            add_local_var(ctx, tok->val.str, var);\n        }\n        return var;\n    }\n    default:\n        error(\"Line %d: not supported yet\", __LINE__);\n    }\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * while-statement:\n *     \"while\" \"(\" expression \")\" statement\n */\n", "func_signal": "static void read_while_stmt(ReadContext *ctx)", "code": "{\n    Block *cond = make_block();\n    Block *body = make_block();\n    Block *cont = make_block();\n\n    emit(ctx, make_inst1(OP_JMP, cond));\n\n    expect(ctx, '(');\n    push_block(ctx, cond);\n    Var *condvar = read_comma_expr(ctx);\n    emit(ctx, make_inst4(OP_IF, condvar, body, NULL, cont));\n    pop_block(ctx);\n    expect(ctx, ')');\n\n    Block *orig_onbreak = ctx->onbreak;\n    Block *orig_oncontinue = ctx->oncontinue;\n    ctx->oncontinue = cond;\n    ctx->onbreak = cont;\n    push_block(ctx, body);\n    push_scope(ctx);\n    read_stmt(ctx);\n    pop_scope(ctx);\n    emit(ctx, make_inst1(OP_JMP, cond));\n    pop_block(ctx);\n    ctx->oncontinue = orig_oncontinue;\n    ctx->onbreak = orig_onbreak;\n\n    replace_block(ctx, cont);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * declaration-specifiers:\n *     storage-class-specifier declaration-specifiers?\n *     type-specifier declaration-specifiers?\n *     type-qualifier declaration-specifiers?\n *     function-specifier declaration-specifiers?\n *\n * storage-class-specifier:\n *     one of: auto extern register static typedef\n *\n * type-specifier:\n *     enumeration-type-specifier\n *     floating-point-type-specifier\n *     integer-type-type-specifier\n *     structure-type-type-specifier\n *     typedef-name\n *     union-type-specifier\n *     void-type-specifier\n *\n * type-qualifier:\n *     one of: const volatile restrict\n *\n * function-specifier:\n *     \"inline\"\n */\n", "func_signal": "static Ctype *read_declaration_spec(ReadContext *ctx)", "code": "{\n    Ctype *r = NULL;\n    Token *tok;\n    enum { NONE, SIGNED, UNSIGNED } sign = NONE;\n    for (;;) {\n        tok = read_token(ctx);\n        if (tok->toktype != TOKTYPE_KEYWORD)\n            goto end;\n        switch (tok->val.i) {\n        case KEYWORD_CONST:\n            // ignore the type specifier for now.\n            break;\n        case KEYWORD_SIGNED:\n            if (sign == SIGNED)\n                error_token(tok, \"'signed' specified twice\");\n            if (sign == UNSIGNED)\n                goto sign_error;\n            sign = UNSIGNED;\n            break;\n        case KEYWORD_UNSIGNED:\n            if (sign == UNSIGNED)\n                error_token(tok, \"'unsigned' specified twice\");\n            if (sign == SIGNED)\n                goto sign_error;\n            sign = UNSIGNED;\n            break;\n#define CHECK_DUP()                                                     \\\n            if (r) error_token(tok, \"two or more data types in declaration specifiers\");\n        case KEYWORD_CHAR:\n            CHECK_DUP();\n            r = make_ctype(CTYPE_CHAR);\n            break;\n        case KEYWORD_SHORT:\n            CHECK_DUP();\n            r = make_ctype(CTYPE_SHORT);\n            break;\n        case KEYWORD_INT:\n            CHECK_DUP();\n            r = make_ctype(CTYPE_INT);\n            break;\n        case KEYWORD_LONG:\n            CHECK_DUP();\n            r = make_ctype(CTYPE_LONG);\n            break;\n        case KEYWORD_FLOAT:\n            CHECK_DUP();\n            if (sign != NONE)\n                error_token(tok, \"float cannot be signed nor unsigned\");\n            r = make_ctype(CTYPE_FLOAT);\n            break;\n#undef CHECK_DUP\n        default:\n            goto end;\n        }\n    }\n end:\n    if (r)\n        r->signedp = (sign != UNSIGNED);\n    unget_token(ctx, tok);\n    return r ? r : make_ctype(CTYPE_INT);\n sign_error:\n    error_token(tok, \"both 'signed' and 'unsigned' in declaration specifiers\");\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*============================================================\n * Basic block\n */\n", "func_signal": "static Block *make_block()", "code": "{\n    Block *r = malloc(sizeof(Block));\n    r->pos = -1;\n    r->code = make_list();\n    return r;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * do-statement:\n *     \"do\" statmenet \"(\" expression \")\" \";\"\n */\n", "func_signal": "static void read_do_stmt(ReadContext *ctx)", "code": "{\n    Block *body = make_block();\n\n    Block *cond = make_block();\n    Block *cont = make_block();\n\n    emit(ctx, make_inst1(OP_JMP, body));\n\n    Block *orig_onbreak = ctx->onbreak;\n    Block *orig_oncontinue = ctx->oncontinue;\n    ctx->oncontinue = body;\n    ctx->onbreak = cont;\n    push_block(ctx, body);\n    push_scope(ctx);\n    read_stmt(ctx);\n    pop_scope(ctx);\n    emit(ctx, make_inst1(OP_JMP, cond));\n    pop_block(ctx);\n    ctx->oncontinue = orig_oncontinue;\n    ctx->onbreak = orig_onbreak;\n\n    expect(ctx, KEYWORD_WHILE);\n    expect(ctx, '(');\n    push_block(ctx, cond);\n    Var *condvar = read_comma_expr(ctx);\n    emit(ctx, make_inst4(OP_IF, condvar, body, NULL, cont));\n    pop_block(ctx);\n    expect(ctx, ')');\n    expect(ctx, ';');\n\n    replace_block(ctx, cont);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * Returns operators precedence.  There are 15 precedences in C as\n * shown below.\n *\n * 1       () [] -> .                      left\n * 2       ! ~ ++ -- - (type) * & sizeof   right\n * 3       * / %                           left\n * 4       + -                             left\n * 5       >> <<                           left\n * 6       < <= > >=                       left\n * 7       == !=                           left\n * 8       &                               left\n * 9       ^                               left\n * 10      |                               left\n * 11      &&                              left\n * 12      ||                              left\n * 13      ?:                              right\n * 14      = op=                           right\n * 15      ,                               left\n */\n", "func_signal": "static int prec(Token *tok)", "code": "{\n    if (!tok || tok->toktype != TOKTYPE_KEYWORD)\n        return -1;\n    switch (tok->val.i) {\n    case '[':\n        return 1;\n    case KEYWORD_INC: case KEYWORD_DEC: case '~':\n        return 2;\n    case '*': case '/': case '%': case KEYWORD_SIZEOF:\n        return 3;\n    case '+': case '-':\n        return 4;\n    case KEYWORD_LSH: case KEYWORD_RSH:\n        return 5;\n    case '<': case '>': case KEYWORD_GE: case KEYWORD_LE:\n        return 6;\n    case KEYWORD_EQ: case KEYWORD_NE:\n        return 7;\n    case '&':\n        return 8;\n    case '^':\n        return 9;\n    case '|':\n        return 10;\n    case KEYWORD_LOG_AND:\n        return 11;\n    case KEYWORD_LOG_OR:\n        return 12;\n    case '?':\n        return 13;\n    case KEYWORD_A_ADD: case KEYWORD_A_SUB: case KEYWORD_A_MUL:\n    case KEYWORD_A_DIV: case KEYWORD_A_MOD: case KEYWORD_A_AND:\n    case KEYWORD_A_OR:  case KEYWORD_A_XOR: case KEYWORD_A_LSH:\n    case KEYWORD_A_RSH: case '=':\n        return 14;\n    case ',':\n        return 15;\n    default:\n        return -1;\n    }\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * declarator:\n *     pointer-declarator\n *     direct-declarator\n */\n", "func_signal": "static Var *read_declarator(ReadContext *ctx, Ctype *ctype)", "code": "{\n    if (next_token_is(ctx, '*')) {\n        return read_pointer_declarator(ctx, ctype);\n    }\n    return read_direct_declarator(ctx, ctype);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * conditional-statement:\n *     if-statement:\n *     if-else-statement:\n *\n * if-statement:\n *     \"if\" \"(\" expression \")\" statement\n *\n * if-else-statement:\n *     \"if\" \"(\" expression \")\" statement \"else\" statement\n */\n", "func_signal": "static void read_if_stmt(ReadContext *ctx)", "code": "{\n    Block *then = make_block();\n    Block *els = make_block();\n    Block *cont = make_block();\n    expect(ctx, '(');\n    Var *cond = read_comma_expr(ctx);\n    expect(ctx, ')');\n\n    emit(ctx, make_inst4(OP_IF, unary_conv(ctx, cond), then, els, cont));\n\n    push_block(ctx, then);\n    read_stmt(ctx);\n    pop_block(ctx);\n\n    if (next_token_is(ctx, KEYWORD_ELSE)) {\n        push_block(ctx, els);\n        read_stmt(ctx);\n        pop_block(ctx);\n    }\n    replace_block(ctx, cont);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * direct-declarator:\n *     simple-declarator\n *     \"(\" declarator \")\"\n *     function-declarator\n *     array-declarator\n *\n * array-declarator:\n *     direct-declarator \"[\" constant-expression? \"]\"\n *     direct-declarator \"[\" array-qualifier* array-size-expression? \"]\"\n *     direct-declarator \"[\" array-qualifier* \"*\" \"]\"\n *\n * array-qualifier:\n *     one of: static restrict const volatile\n *\n * simple-declarator:\n *     identifier\n */\n", "func_signal": "static Var *read_direct_declarator(ReadContext *ctx, Ctype *ctype)", "code": "{\n    Var *r = make_var(ctype);\n    Token *tok = read_ident(ctx);\n    r->name = tok->val.str;\n    if (next_token_is(ctx, '['))\n        r->ctype = read_array_dimensions(ctx, r->ctype);\n    return r;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * unary-expression:\n *     postfix-expression\n *     sizeof-expression\n *     unary-minus-expression\n *     unary-plus-expression\n *     logical-negation-expression\n *     bitwise-negation-expression\n *     address-expression\n *     indirection-expression\n *     preincrement-expression\n *     postincrement-expression\n */\n", "func_signal": "static Var *read_unary_expr(ReadContext *ctx)", "code": "{\n    Token *tok = read_token(ctx);\n    if (tok->toktype != TOKTYPE_KEYWORD) {\n        unget_token(ctx, tok);\n        return read_postfix_expr(ctx);\n    }\n    switch (tok->val.i) {\n    case '(': {\n        Var *r = read_comma_expr(ctx);\n        expect(ctx, ')');\n        return r;\n    }\n    case '+':\n    case '-': {\n        Var *v = read_cast_expr(ctx);\n        Var *tmp = unary_conv(ctx, v);\n        Var *zero = is_flonum(tmp->ctype)\n            ? make_imm(CTYPE_FLOAT, (Cvalue)0.0f)\n            : make_imm(CTYPE_INT, (Cvalue)0);\n        Var *r = make_var(binary_type_conv(zero, tmp));\n        emit(ctx, make_inst3(tok->val.i, r, zero, tmp));\n        return r;\n    }\n    case '*': {\n        Var *pointed = unary_conv(ctx, read_cast_expr(ctx));\n        return make_deref_var(pointed);\n    }\n    case '&': {\n        Var *v = read_cast_expr(ctx);\n        Var *ptr = make_var(make_ctype_ptr(v->ctype));\n        emit(ctx, make_inst2(OP_ADDRESS, ptr, rv(ctx, v)));\n        return ptr;\n    }\n    case '~':\n    case '!': {\n        Var *v = read_cast_expr(ctx);\n        Var *tmp = unary_conv(ctx, v);\n        Var *r = make_var(tmp->ctype);\n        emit(ctx, make_inst2(tok->val.i, r, tmp));\n        return r;\n    }\n    case KEYWORD_INC:\n    case KEYWORD_DEC: {\n        Var *v = read_cast_expr(ctx);\n        ensure_lvalue(ctx, v);\n        char op = tok->val.i == KEYWORD_INC ? '+' : '-';\n        Var *tmp = unary_conv(ctx, v);\n        tmp = emit_arith(ctx, op, tmp, make_imm(CTYPE_INT, (Cvalue)1));\n        emit_assign(ctx, v, tmp);\n        return v;\n    }\n    case KEYWORD_SIZEOF: {\n        Var *v = read_unary_expr(ctx);\n        return make_imm(CTYPE_INT, (Cvalue)ctype_sizeof(v->ctype));\n    }\n    default:\n        error_token(tok, \"expected unary, but got '%s'\", token_to_string(tok));\n    }\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*============================================================\n * Entry function\n */\n", "func_signal": "List *parse(File *file, Elf *elf)", "code": "{\n    List *r = make_list();\n    CppContext *cppctx = make_cpp_context(file);\n    for (;;) {\n        ReadContext *ctx = make_read_context(file, elf, cppctx);\n        if (!peek_token(ctx))\n            break;\n        Function *f = read_func_declaration(ctx);\n        check_context(ctx);\n        list_push(r, f);\n    }\n    return r;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * goto-statement:\n *     \"goto\" identifier \";\"\n */\n", "func_signal": "static void read_goto_stmt(ReadContext *ctx)", "code": "{\n    Token *tok = read_ident(ctx);\n    expect(ctx, ';');\n    String *label = tok->val.str;\n\n    Block *dst = dict_get(ctx->label, label);\n    if (dst) {\n        emit(ctx, make_inst1(OP_JMP, dst));\n        return;\n    }\n    List *blocks = dict_get(ctx->label_tbf, label);\n    if (!blocks) {\n        blocks = make_list();\n        dict_put(ctx->label_tbf, label, blocks);\n    }\n    Block *cur = replace_block(ctx, make_block());\n    list_push(blocks, cur);\n    list_push(blocks, tok);\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*============================================================\n * Variables\n */\n", "func_signal": "static Ctype *make_ctype(int type)", "code": "{\n    Ctype *r = malloc(sizeof(Ctype));\n    r->type = type;\n    r->ptr = NULL;\n    r->size = 1;\n    r->signedp = true;\n    return r;\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * parameter-type-list:\n *     parameter-list\n *     parameter-list \",\" \"...\"\n *\n * parameter-list:\n *     parameter-declaration\n *     parameter-list \",\" parameter-declaration\n *\n * parameter-declaration:\n *     declaration-specifiers declarator\n *     declaration-specifiers abstract-declarator?\n */\n", "func_signal": "static List *read_param_type_list(ReadContext *ctx)", "code": "{\n    List *params = make_list();\n    if (next_token_is(ctx, ')'))\n        return params;\n    for (;;) {\n        Ctype *type = read_declaration_spec(ctx);\n        Var *param = read_declarator(ctx, type);\n        if (param->ctype->type == CTYPE_ARRAY)\n            param->ctype = make_ctype_ptr(param->ctype->ptr);\n        add_local_var(ctx, param->name, param);\n        list_push(params, param);\n        if (next_token_is(ctx, ')'))\n            return params;\n        expect(ctx, ',');\n    }\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * declaration-or-statemnet:\n *     declaration\n *     statement\n */\n", "func_signal": "static void read_decl_or_stmt(ReadContext *ctx)", "code": "{\n    Token *tok = peek_token(ctx);\n    if (is_type_keyword(tok)) {\n        read_declaration(ctx);\n    } else {\n        read_stmt(ctx);\n    }\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * subscript-expression:\n *     postfix-expression \"[\" expression \"]\"\n */\n", "func_signal": "static Var *read_subscript_expr(ReadContext *ctx, Var *a)", "code": "{\n    // a[i] is equivalent to *((a) + (i))\n    Var *i = read_comma_expr(ctx);\n    expect(ctx, ']');\n    Var *var = emit_arith(ctx, '+', unary_conv(ctx, a), unary_conv(ctx, i));\n    return make_deref_var(unary_conv(ctx, var));\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/*\n * initialized-declarator:\n *     declarator\n *     declarator \"=\" initializer\n */\n", "func_signal": "static void read_initialized_declarator(ReadContext *ctx, Ctype *ctype)", "code": "{\n    Var *var = read_declarator(ctx, ctype);\n    add_local_var(ctx, var->name, var);\n    if (next_token_is(ctx, '=')) {\n        Var *val = unary_conv(ctx, read_initializer(ctx));\n        emit_assign(ctx, var, val);\n        return;\n    }\n    emit(ctx, make_inst1(OP_ALLOC, var));\n}", "path": "parse.c", "repo_name": "rui314/8cc-old", "stars": 21, "license": "bsd-2-clause", "language": "c", "size": 504}
{"docstring": "/** Event handler for the USB_Connect event. This indicates that the device is enumerating via the status LEDs. */\n", "func_signal": "void EVENT_USB_Device_Connect(void)", "code": "{\n\t/* Indicate USB enumerating */\n\tLEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);\n\n\t/* Reset the MSReset flag upon connection */\n\tIsMassStoreReset = false;\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Retrieves a pointer to the value of the given Attribute ID from the given Attribute table.\n *\n *  \\param[in] AttributeTable  Pointer to the Attribute table to search in\n *  \\param[in] AttributeID     Attribute ID to search for within the table\n *\n *  \\return Pointer to the start of the Attribute's value if found within the table, NULL otherwise\n */\n", "func_signal": "static void* SDP_GetAttributeValue(const ServiceAttributeTable_t* AttributeTable,\n                                   const uint16_t AttributeID)", "code": "{\n\tvoid* CurrTableItemData;\n\n\t/* Search through the current Attribute table, abort when the terminator item has been reached */\n\twhile ((CurrTableItemData = pgm_read_ptr(&AttributeTable->Data)) != NULL)\n\t{\n\t\t/* Check if the current Attribute ID matches the search ID - if so return a pointer to it */\n\t\tif (pgm_read_word(&AttributeTable->AttributeID) == AttributeID)\n\t\t  return CurrTableItemData;\n\n\t\tAttributeTable++;\n\t}\n\n\treturn NULL;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Task to manage the Mass Storage interface, reading in Command Block Wrappers from the host, processing the SCSI commands they\n *  contain, and returning Command Status Wrappers back to the host to indicate the success or failure of the last issued command.\n */\n", "func_signal": "void MassStorage_Task(void)", "code": "{\n\t/* Device must be connected and configured for the task to run */\n\tif (USB_DeviceState != DEVICE_STATE_Configured)\n\t  return;\n\n\t/* Process sent command block from the host if one has been sent */\n\tif (ReadInCommandBlock())\n\t{\n\t\t/* Indicate busy */\n\t\tLEDs_SetAllLEDs(LEDMASK_USB_BUSY);\n\n\t\t/* Check direction of command, select Data IN endpoint if data is from the device */\n\t\tif (CommandBlock.Flags & COMMAND_DIRECTION_DATA_IN)\n\t\t  Endpoint_SelectEndpoint(MASS_STORAGE_IN_EPNUM);\n\n\t\t/* Decode the received SCSI command, set returned status code */\n\t\tCommandStatus.Status = SCSI_DecodeSCSICommand() ? Command_Pass : Command_Fail;\n\n\t\t/* Load in the CBW tag into the CSW to link them together */\n\t\tCommandStatus.Tag = CommandBlock.Tag;\n\n\t\t/* Load in the data residue counter into the CSW */\n\t\tCommandStatus.DataTransferResidue = CommandBlock.DataTransferLength;\n\n\t\t/* Stall the selected data pipe if command failed (if data is still to be transferred) */\n\t\tif ((CommandStatus.Status == Command_Fail) && (CommandStatus.DataTransferResidue))\n\t\t  Endpoint_StallTransaction();\n\n\t\t/* Return command status block to the host */\n\t\tReturnCommandStatus();\n\n\t\t/* Indicate ready */\n\t\tLEDs_SetAllLEDs(LEDMASK_USB_READY);\n\t}\n\n\t/* Check if a Mass Storage Reset occurred */\n\tif (IsMassStoreReset)\n\t{\n\t\t/* Reset the data endpoint banks */\n\t\tEndpoint_ResetFIFO(MASS_STORAGE_OUT_EPNUM);\n\t\tEndpoint_ResetFIFO(MASS_STORAGE_IN_EPNUM);\n\n\t\tEndpoint_SelectEndpoint(MASS_STORAGE_OUT_EPNUM);\n\t\tEndpoint_ClearStall();\n\t\tEndpoint_ResetDataToggle();\n\t\tEndpoint_SelectEndpoint(MASS_STORAGE_IN_EPNUM);\n\t\tEndpoint_ClearStall();\n\t\tEndpoint_ResetDataToggle();\n\n\t\t/* Clear the abort transfer flag */\n\t\tIsMassStoreReset = false;\n\t}\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Function to read in a command block from the host, via the bulk data OUT endpoint. This function reads in the next command block\n *  if one has been issued, and performs validation to ensure that the block command is valid.\n *\n *  \\return Boolean true if a valid command block has been read in from the endpoint, false otherwise\n */\n", "func_signal": "static bool ReadInCommandBlock(void)", "code": "{\n\t/* Select the Data Out endpoint */\n\tEndpoint_SelectEndpoint(MASS_STORAGE_OUT_EPNUM);\n\n\t/* Abort if no command has been sent from the host */\n\tif (!(Endpoint_IsOUTReceived()))\n\t  return false;\n\n\t/* Read in command block header */\n\tEndpoint_Read_Stream_LE(&CommandBlock, (sizeof(CommandBlock) - sizeof(CommandBlock.SCSICommandData)),\n\t                        StreamCallback_AbortOnMassStoreReset);\n\n\t/* Check if the current command is being aborted by the host */\n\tif (IsMassStoreReset)\n\t  return false;\n\n\t/* Verify the command block - abort if invalid */\n\tif ((CommandBlock.Signature         != CBW_SIGNATURE) ||\n\t    (CommandBlock.LUN               >= TOTAL_LUNS)    ||\n\t\t(CommandBlock.Flags              & 0x1F)          ||\n\t\t(CommandBlock.SCSICommandLength == 0)             ||\n\t\t(CommandBlock.SCSICommandLength >  MAX_SCSI_COMMAND_LENGTH))\n\t{\n\t\t/* Stall both data pipes until reset by host */\n\t\tEndpoint_StallTransaction();\n\t\tEndpoint_SelectEndpoint(MASS_STORAGE_IN_EPNUM);\n\t\tEndpoint_StallTransaction();\n\n\t\treturn false;\n\t}\n\n\t/* Read in command block command data */\n\tEndpoint_Read_Stream_LE(&CommandBlock.SCSICommandData,\n\t                        CommandBlock.SCSICommandLength,\n\t                        StreamCallback_AbortOnMassStoreReset);\n\n\t/* Check if the current command is being aborted by the host */\n\tif (IsMassStoreReset)\n\t  return false;\n\n\t/* Finalize the stream transfer to send the last packet */\n\tEndpoint_ClearOUT();\n\n\treturn true;\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Reads in the collection of Attribute ranges from the input buffer's Data Element Sequence container, into the given\n *  Attribute list for later use. Once complete, the input buffer pointer is advanced to the end of the Attribute container.\n *\n *  \\param[out] AttributeList     Pointer to a buffer where the list of Attribute ranges are to be stored\n *  \\param[in]  CurrentParameter  Pointer to a Buffer containing a Data Element Sequence of Attribute and Attribute Range elements\n *\n *  \\return Total number of Attribute ranges stored in the Data Element Sequence\n */\n", "func_signal": "static uint8_t SDP_GetAttributeList(uint16_t AttributeList[][2],\n                                    const void** const CurrentParameter)", "code": "{\n\tuint8_t ElementHeaderSize;\n\tuint8_t TotalAttributes = 0;\n\n\t/* Retrieve the total size of the Attribute container, and unwrap the outer Data Element Sequence container */\n\tuint16_t AttributeIDListLength = SDP_GetDataElementSize(CurrentParameter, &ElementHeaderSize);\n\tBT_SDP_DEBUG(2, \"-- Total Attribute Length: 0x%04X\", AttributeIDListLength);\n\twhile (AttributeIDListLength)\n\t{\n\t\t/* Retrieve the size of the next Attribute in the container and get a pointer to the next free Attribute element in the list */\n\t\tuint16_t* CurrentAttributeRange = AttributeList[TotalAttributes++];\n\t\tuint8_t   AttributeLength       = SDP_GetDataElementSize(CurrentParameter, &ElementHeaderSize);\n\n\t\t/* Copy over the starting Attribute ID and (if it the current element is a range) the ending Attribute ID */\n\t\tmemcpy(&CurrentAttributeRange[0], *CurrentParameter, AttributeLength);\n\n\t\t/* If the element is not an Attribute Range, copy over the starting ID to the ending ID to make a range of 1 */\n\t\tif (AttributeLength == 2)\n\t\t  CurrentAttributeRange[1] = CurrentAttributeRange[0];\n\n\t\t/* Swap the endianness of the attribute range values */\n\t\tCurrentAttributeRange[0] = SwapEndian_16(CurrentAttributeRange[0]);\n\t\tCurrentAttributeRange[1] = SwapEndian_16(CurrentAttributeRange[1]);\n\n\t\tBT_SDP_DEBUG(2, \"-- Attribute: 0x%04X-0x%04X\", CurrentAttributeRange[0], CurrentAttributeRange[1]);\n\n\t\tAttributeIDListLength -= (AttributeLength + ElementHeaderSize);\n\t\t*CurrentParameter     += AttributeLength;\n\t}\n\n\treturn TotalAttributes;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tLEDs_Init();\n\tSPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_ORDER_MSB_FIRST | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);\n\tDataflash_Init();\n\tUSB_Init();\n\n\t/* Clear Dataflash sector protections, if enabled */\n\tDataflashManager_ResetDataflashProtections();\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Internal processing routine for SDP Service Search Attribute Requests.\n *\n *  \\param[in] SDPHeader  Pointer to the start of the issued SDP request\n *  \\param[in] Channel    Pointer to the Bluetooth channel structure the request was issued to\n */\n", "func_signal": "static void SDP_ProcessServiceSearchAttribute(const SDP_PDUHeader_t* const SDPHeader,\n                                              Bluetooth_Channel_t* const Channel)", "code": "{\n\tconst void* CurrentParameter = ((const void*)SDPHeader + sizeof(SDP_PDUHeader_t));\n\n\tBT_SDP_DEBUG(1, \"<< Service Search Attribute\");\n\n\t/* Retrieve the list of search UUIDs from the request */\n\tuint8_t UUIDList[12][UUID_SIZE_BYTES];\n\tuint8_t TotalUUIDs = SDP_GetUUIDList(UUIDList, &CurrentParameter);\n\tBT_SDP_DEBUG(2, \"-- Total UUIDs: %d\", TotalUUIDs);\n\n\t/* Retrieve the maximum Attribute response size from the request */\n\tuint16_t MaxAttributeSize = SDP_ReadData16(&CurrentParameter);\n\tBT_SDP_DEBUG(2, \"-- Max Return Attribute Bytes: 0x%04X\", MaxAttributeSize);\n\n\t/* Retrieve the list of Attributes from the request */\n\tuint16_t AttributeList[8][2];\n\tuint8_t  TotalAttributes = SDP_GetAttributeList(AttributeList, &CurrentParameter);\n\tBT_SDP_DEBUG(2, \"-- Total Attributes: %d\", TotalAttributes);\n\n\tstruct\n\t{\n\t\tSDP_PDUHeader_t SDPHeader;\n\t\tuint16_t        AttributeListByteCount;\n\t\tuint8_t         ResponseData[100];\n\t} ResponsePacket;\n\n\t/* Create a pointer to the buffer to indicate the current location for response data to be added */\n\tvoid* CurrResponsePos = ResponsePacket.ResponseData;\n\n\t/* Clamp the maximum attribute size to the size of the allocated buffer */\n\tif (MaxAttributeSize > sizeof(ResponsePacket.ResponseData))\n\t  MaxAttributeSize = sizeof(ResponsePacket.ResponseData);\n\n\t/* Add the outer Data Element Sequence header for all of the retrieved Attributes */\n\tuint16_t* TotalResponseSize = SDP_AddSequence16(&CurrResponsePos);\n\n\t/* Search through the global service list an item at a time */\n\tfor (uint8_t CurrTableItem = 0; CurrTableItem < (sizeof(SDP_Services_Table) / sizeof(void*)); CurrTableItem++)\n\t{\n\t\t/* Read in a pointer to the current UUID table entry's Attribute table */\n\t\tServiceAttributeTable_t* CurrAttributeTable = pgm_read_ptr(&SDP_Services_Table[CurrTableItem]);\n\n\t\tif (!(SDP_SearchServiceTable(UUIDList, TotalUUIDs, CurrAttributeTable)))\n\t\t  continue;\n\n\t\tBT_SDP_DEBUG(2, \" -- Found search match in table\");\n\n\t\t/* Add the listed attributes for the found UUID to the response */\n\t\t*TotalResponseSize += SDP_AddListedAttributesToResponse(CurrAttributeTable, AttributeList, TotalAttributes,\n\t\t                                                        &CurrResponsePos);\n\t}\n\n\t/* Continuation state - always zero */\n\tSDP_WriteData8(&CurrResponsePos, 0);\n\n\t/* Set the total response list size to the size of the outer container plus its header size and continuation state */\n\tResponsePacket.AttributeListByteCount    = SwapEndian_16(3 + *TotalResponseSize);\n\n\t/* Calculate the total parameter length that is to be sent, including the fixed return parameters, the created attribute\n\t   value list and the SDP continuation state */\n\tuint16_t ParamLength = (sizeof(ResponsePacket.AttributeListByteCount) +\n\t                        (3 + *TotalResponseSize) +\n\t                        sizeof(uint8_t));\n\n\t/* Flip the endianness of the container's size */\n\t*TotalResponseSize = SwapEndian_16(*TotalResponseSize);\n\n\t/* Fill in the response packet's header */\n\tResponsePacket.SDPHeader.PDU             = SDP_PDU_SERVICESEARCHATTRIBUTERESPONSE;\n\tResponsePacket.SDPHeader.TransactionID   = SDPHeader->TransactionID;\n\tResponsePacket.SDPHeader.ParameterLength = SwapEndian_16(ParamLength);\n\n\tBT_SDP_DEBUG(1, \">> Service Search Attribute Response\");\n\tBT_SDP_DEBUG(2, \"-- Param Len 0x%04X\", ParamLength);\n\n\t/* Send the completed response packet to the sender */\n\tBluetooth_SendPacket(&ResponsePacket, (sizeof(ResponsePacket.SDPHeader) + ParamLength), Channel);\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Retrieves the total size of the given locally stored (in PROGMEM) attribute Data Element container.\n *\n *  \\param[in]  AttributeData  Pointer to the start of the Attribute container, located in PROGMEM\n *  \\param[out] HeaderSize     Pointer to a location where the header size of the data element is to be stored\n *\n *  \\return Size in bytes of the entire attribute container, including the header\n */\n", "func_signal": "static uint32_t SDP_GetLocalAttributeContainerSize(const void* const AttributeData,\n                                                   uint8_t* const HeaderSize)", "code": "{\n\t/* Fetch the size of the Data Element structure from the header */\n\tuint8_t SizeIndex = (pgm_read_byte(AttributeData) & 0x07);\n\n\tuint32_t ElementValueSize;\n\n\t/* Convert the Data Element size index into a size in bytes */\n\tswitch (SizeIndex)\n\t{\n\t\tcase SDP_DATASIZE_Variable8Bit:\n\t\t\t*HeaderSize = (1 + sizeof(uint8_t));\n\t\t\tElementValueSize = pgm_read_byte(AttributeData + 1);\n\t\t\tbreak;\n\t\tcase SDP_DATASIZE_Variable16Bit:\n\t\t\t*HeaderSize = (1 + sizeof(uint16_t));\n\t\t\tElementValueSize = SwapEndian_16(pgm_read_word(AttributeData + 1));\n\t\t\tbreak;\n\t\tcase SDP_DATASIZE_Variable32Bit:\n\t\t\t*HeaderSize = (1 + sizeof(uint32_t));\n\t\t\tElementValueSize = SwapEndian_32(pgm_read_dword(AttributeData + 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*HeaderSize = 1;\n\t\t\tElementValueSize = (1 << SizeIndex);\n\t\t\tbreak;\n\t}\n\n\treturn ElementValueSize;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Interface descriptor of the correct CDC data Class, Subclass and Protocol values.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextCDCDataInterface(void* CurrentDescriptor)", "code": "{\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Check the CDC descriptor class, subclass and protocol, break out if correct data interface found */\n\t\tif ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == CDC_DATA_CLASS)    &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).SubClass == CDC_DATA_SUBCLASS) &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Protocol == CDC_DATA_PROTOCOL))\n\t\t{\n\t\t\treturn DESCRIPTOR_SEARCH_Found;\n\t\t}\n\t}\n\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\LowLevel\\RNDISEthernetHost\\ConfigDescriptor.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Retrieves the Attribute table for the given UUID list if it exists.\n *\n *  \\param[in] UUIDList            List of UUIDs which must be matched within the service attribute table\n *  \\param[in] TotalUUIDs          Total number of UUIDs stored in the UUID list\n *  \\param[in] CurrAttributeTable  Pointer to the service attribute table to search through\n *\n *  \\return True if all the UUIDs given in the UUID list appear in the given attribute table, false otherwise\n */\n", "func_signal": "static bool SDP_SearchServiceTable(uint8_t UUIDList[][UUID_SIZE_BYTES],\n                                   const uint8_t TotalUUIDs,\n\t\t\t                       const ServiceAttributeTable_t* CurrAttributeTable)", "code": "{\n\tconst void* CurrAttribute;\n\tuint16_t    UUIDMatchFlags = 0;\n\n\t/* Search through the current attribute table, checking each attribute value for UUID matches */\n\twhile ((CurrAttribute = pgm_read_ptr(&CurrAttributeTable->Data)) != NULL)\n\t{\n\t\tSDP_CheckUUIDMatch(UUIDList, TotalUUIDs, &UUIDMatchFlags, CurrAttribute);\n\t\tCurrAttributeTable++;\n\t}\n\n\t/* Determine how many UUID matches in the list we have found */\n\tuint8_t UUIDMatches;\n\tfor (UUIDMatches = 0; UUIDMatchFlags; UUIDMatches++)\n\t  UUIDMatchFlags &= (UUIDMatchFlags - 1);\n\n\t/* If all UUIDs have been matched to the current service, return true */\n\treturn (UUIDMatches == TotalUUIDs);\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Internal processing routine for SDP Service Search Requests.\n *\n *  \\param[in] SDPHeader  Pointer to the start of the issued SDP request\n *  \\param[in] Channel    Pointer to the Bluetooth channel structure the request was issued to\n */\n", "func_signal": "static void SDP_ProcessServiceSearch(const SDP_PDUHeader_t* const SDPHeader,\n                                     Bluetooth_Channel_t* const Channel)", "code": "{\n\tconst void* CurrentParameter = ((const void*)SDPHeader + sizeof(SDP_PDUHeader_t));\n\n\tBT_SDP_DEBUG(1, \"<< Service Search\");\n\n\t/* Retrieve the list of search UUIDs from the request */\n\tuint8_t UUIDList[12][UUID_SIZE_BYTES];\n\tuint8_t TotalUUIDs = SDP_GetUUIDList(UUIDList, &CurrentParameter);\n\tBT_SDP_DEBUG(2, \"-- Total UUIDs: %d\", TotalUUIDs);\n\n\t/* Retrieve the maximum service record response count from the request */\n\tuint16_t MaxServiceRecordCount = SDP_ReadData16(&CurrentParameter);\n\tBT_SDP_DEBUG(2, \"-- Max Return Service Count: 0x%04X\", MaxServiceRecordCount);\n\n\tstruct\n\t{\n\t\tSDP_PDUHeader_t SDPHeader;\n\t\tuint16_t        TotalServiceRecordCount;\n\t\tuint16_t        CurrentServiceRecordCount;\n\t\tuint8_t         ResponseData[100];\n\t} ResponsePacket;\n\n\tuint8_t AddedServiceHandles = 0;\n\n\t/* Create a pointer to the buffer to indicate the current location for response data to be added */\n\tvoid* CurrResponsePos = ResponsePacket.ResponseData;\n\n\t/* Search through the global service list an item at a time */\n\tfor (uint8_t CurrTableItem = 0; CurrTableItem < (sizeof(SDP_Services_Table) / sizeof(void*)); CurrTableItem++)\n\t{\n\t\t/* Read in a pointer to the current UUID table entry's Attribute table */\n\t\tServiceAttributeTable_t* CurrAttributeTable = pgm_read_ptr(&SDP_Services_Table[CurrTableItem]);\n\n\t\tif (!(SDP_SearchServiceTable(UUIDList, TotalUUIDs, CurrAttributeTable)))\n\t\t  continue;\n\n\t\tBT_SDP_DEBUG(2, \" -- Found search match in table\");\n\n\t\t/* Retrieve a PROGMEM pointer to the value of the service's record handle */\n\t\tconst void* AttributeValue = SDP_GetAttributeValue(CurrAttributeTable, SDP_ATTRIBUTE_ID_SERVICERECORDHANDLE);\n\n\t\t/* Copy over the service record handle to the response list */\n\t\tuint8_t AttrHeaderSize;\n\t\tuint8_t AttrSize = SDP_GetLocalAttributeContainerSize(AttributeValue, &AttrHeaderSize);\n\t\tmemcpy_P(CurrResponsePos, AttributeValue + AttrHeaderSize, AttrSize);\n\t\tCurrResponsePos += AttrHeaderSize + AttrSize;\n\n\t\tAddedServiceHandles++;\n\t}\n\n\t/* Continuation state - always zero */\n\tSDP_WriteData8(&CurrResponsePos, 0);\n\n\t/* Fill out the service record count values in the returned packet */\n\tResponsePacket.TotalServiceRecordCount   = SwapEndian_16(AddedServiceHandles);\n\tResponsePacket.CurrentServiceRecordCount = ResponsePacket.TotalServiceRecordCount;\n\n\t/* Calculate the total parameter length that is to be sent, including the fixed return parameters, the created service\n\t   handle list and the SDP continuation state */\n\tuint16_t ParamLength = (ResponsePacket.CurrentServiceRecordCount << 2) +\n\t                        sizeof(ResponsePacket.CurrentServiceRecordCount) +\n\t                        sizeof(ResponsePacket.TotalServiceRecordCount) +\n\t                        sizeof(uint8_t);\n\n\t/* Fill in the response packet's header */\n\tResponsePacket.SDPHeader.PDU             = SDP_PDU_SERVICESEARCHRESPONSE;\n\tResponsePacket.SDPHeader.TransactionID   = SDPHeader->TransactionID;\n\tResponsePacket.SDPHeader.ParameterLength = SwapEndian_16(ParamLength);\n\n\tBT_SDP_DEBUG(1, \">> Service Search Response\");\n\n\t/* Send the completed response packet to the sender */\n\tBluetooth_SendPacket(&ResponsePacket, (sizeof(ResponsePacket.SDPHeader) + ParamLength), Channel);\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Event handler for the USB_ConfigurationChanged event. This is fired when the host set the current configuration\n *  of the USB device after enumeration - the device endpoints are configured and the Mass Storage management task started.\n */\n", "func_signal": "void EVENT_USB_Device_ConfigurationChanged(void)", "code": "{\n\tbool ConfigSuccess = true;\n\n\t/* Setup Mass Storage Data Endpoints */\n\tConfigSuccess &= Endpoint_ConfigureEndpoint(MASS_STORAGE_IN_EPNUM,  EP_TYPE_BULK, ENDPOINT_DIR_IN,\n\t                                            MASS_STORAGE_IO_EPSIZE, ENDPOINT_BANK_SINGLE);\n\tConfigSuccess &= Endpoint_ConfigureEndpoint(MASS_STORAGE_OUT_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_OUT,\n\t                                            MASS_STORAGE_IO_EPSIZE, ENDPOINT_BANK_SINGLE);\n\n\t/* Indicate endpoint configuration success or failure */\n\tLEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Returns the filled Command Status Wrapper back to the host via the bulk data IN endpoint, waiting for the host to clear any\n *  stalled data endpoints as needed.\n */\n", "func_signal": "static void ReturnCommandStatus(void)", "code": "{\n\t/* Select the Data Out endpoint */\n\tEndpoint_SelectEndpoint(MASS_STORAGE_OUT_EPNUM);\n\n\t/* While data pipe is stalled, wait until the host issues a control request to clear the stall */\n\twhile (Endpoint_IsStalled())\n\t{\n\t\t/* Check if the current command is being aborted by the host */\n\t\tif (IsMassStoreReset)\n\t\t  return;\n\t}\n\n\t/* Select the Data In endpoint */\n\tEndpoint_SelectEndpoint(MASS_STORAGE_IN_EPNUM);\n\n\t/* While data pipe is stalled, wait until the host issues a control request to clear the stall */\n\twhile (Endpoint_IsStalled())\n\t{\n\t\t/* Check if the current command is being aborted by the host */\n\t\tif (IsMassStoreReset)\n\t\t  return;\n\t}\n\n\t/* Write the CSW to the endpoint */\n\tEndpoint_Write_Stream_LE(&CommandStatus, sizeof(CommandStatus),\n\t                          StreamCallback_AbortOnMassStoreReset);\n\n\t/* Check if the current command is being aborted by the host */\n\tif (IsMassStoreReset)\n\t  return;\n\n\t/* Finalize the stream transfer to send the last packet */\n\tEndpoint_ClearIN();\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next Interface descriptor of the correct CDC control Class, Subclass and Protocol values.\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextCDCControlInterface(void* CurrentDescriptor)", "code": "{\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\t/* Check the CDC descriptor class, subclass and protocol, break out if correct control interface found */\n\t\tif ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == CDC_CONTROL_CLASS)    &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).SubClass == CDC_CONTROL_SUBCLASS) &&\n\t\t    (DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Protocol == CDC_CONTROL_PROTOCOL))\n\t\t{\n\t\t\treturn DESCRIPTOR_SEARCH_Found;\n\t\t}\n\t}\n\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\LowLevel\\RNDISEthernetHost\\ConfigDescriptor.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Retrieves the size of a Data Element container from the current input buffer, and advances the input buffer\n *  pointer to the start of the Data Element's contents.\n *\n *  \\param[in, out] DataElementHeader  Pointer to the start of a Data Element header\n *  \\param[out]     ElementHeaderSize  Size in bytes of the header that was skipped\n *\n *  \\return Size in bytes of the Data Element container's contents, minus the header\n */\n", "func_signal": "static uint32_t SDP_GetDataElementSize(const void** const DataElementHeader,\n                                       uint8_t* const ElementHeaderSize)", "code": "{\n\t/* Fetch the size of the Data Element structure from the header, increment the current buffer pos */\n\tuint8_t  SizeIndex = (SDP_ReadData8(DataElementHeader) & 0x07);\n\n\tuint32_t ElementValueSize;\n\n\t/* Convert the Data Element size index into a size in bytes */\n\tswitch (SizeIndex)\n\t{\n\t\tcase SDP_DATASIZE_Variable8Bit:\n\t\t\t*ElementHeaderSize  = (1 + sizeof(uint8_t));\n\t\t\tElementValueSize    = SDP_ReadData8(DataElementHeader);\n\t\t\tbreak;\n\t\tcase SDP_DATASIZE_Variable16Bit:\n\t\t\t*ElementHeaderSize  = (1 + sizeof(uint16_t));\n\t\t\tElementValueSize    = SDP_ReadData16(DataElementHeader);\n\t\t\tbreak;\n\t\tcase SDP_DATASIZE_Variable32Bit:\n\t\t\t*ElementHeaderSize  = (1 + sizeof(uint32_t));\n\t\t\tElementValueSize    = SDP_ReadData32(DataElementHeader);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ElementHeaderSize  = 1;\n\t\t\tElementValueSize    = (1 << SizeIndex);\n\t\t\tbreak;\n\t}\n\n\treturn ElementValueSize;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Reads and processes an attached device's descriptors, to determine compatibility and pipe configurations. This\n *  routine will read in the entire configuration descriptor, and configure the hosts pipes to correctly communicate\n *  with compatible devices.\n *\n *  This routine searches for a RNDIS interface descriptor containing bulk data IN and OUT endpoints, and an interrupt event endpoint.\n *\n *  \\return An error code from the \\ref RNDISHost_GetConfigDescriptorDataCodes_t enum.\n */\n", "func_signal": "uint8_t ProcessConfigurationDescriptor(void)", "code": "{\n\tuint8_t  ConfigDescriptorData[512];\n\tvoid*    CurrConfigLocation = ConfigDescriptorData;\n\tuint16_t CurrConfigBytesRem;\n\n\tUSB_Descriptor_Interface_t* RNDISControlInterface  = NULL;\n\tUSB_Descriptor_Endpoint_t*  DataINEndpoint         = NULL;\n\tUSB_Descriptor_Endpoint_t*  DataOUTEndpoint        = NULL;\n\tUSB_Descriptor_Endpoint_t*  NotificationEndpoint   = NULL;\n\n\t/* Retrieve the entire configuration descriptor into the allocated buffer */\n\tswitch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(ConfigDescriptorData)))\n\t{\n\t\tcase HOST_GETCONFIG_Successful:\n\t\t\tbreak;\n\t\tcase HOST_GETCONFIG_InvalidData:\n\t\t\treturn InvalidConfigDataReturned;\n\t\tcase HOST_GETCONFIG_BuffOverflow:\n\t\t\treturn DescriptorTooLarge;\n\t\tdefault:\n\t\t\treturn ControlError;\n\t}\n\n\twhile (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))\n\t{\n\t\t/* See if we've found a likely compatible interface, and if there is an endpoint within that interface */\n\t\tif (!(RNDISControlInterface) ||\n\t\t    USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t\t                              DComp_NextCDCDataInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)\n\t\t{\n\t\t\t/* Check if we have already found the control interface's notification endpoint or not */\n\t\t\tif (NotificationEndpoint)\n\t\t\t{\n\t\t\t\t/* Get the next RNDIS data interface from the configuration descriptor */\n\t\t\t\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t\t\t\t\t\t\t\t\t\t\t  DComp_NextCDCDataInterface) != DESCRIPTOR_SEARCH_COMP_Found)\n\t\t\t\t{\n\t\t\t\t\t/* Descriptor not found, error out */\n\t\t\t\t\treturn NoCompatibleInterfaceFound;\n\t\t\t\t}\n\n\t\t\t\t/* Clear any found endpoints */\n\t\t\t\tDataINEndpoint       = NULL;\n\t\t\t\tDataOUTEndpoint      = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Get the next RNDIS control interface from the configuration descriptor */\n\t\t\t\tif (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,\n\t\t\t\t\t\t\t\t\t\t\t  DComp_NextCDCControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)\n\t\t\t\t{\n\t\t\t\t\t/* Descriptor not found, error out */\n\t\t\t\t\treturn NoCompatibleInterfaceFound;\n\t\t\t\t}\n\n\t\t\t\t/* Save the interface in case we need to refer back to it later */\n\t\t\t\tRNDISControlInterface = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Interface_t);\n\n\t\t\t\t/* Clear any found endpoints */\n\t\t\t\tNotificationEndpoint = NULL;\n\t\t\t}\n\n\t\t\t/* Skip the remainder of the loop as we have not found an endpoint yet */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Retrieve the endpoint address from the endpoint descriptor */\n\t\tUSB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Endpoint_t);\n\n\t\t/* If the endpoint is a IN type endpoint */\n\t\tif (EndpointData->EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)\n\t\t{\n\t\t\t/* Check if the found endpoint is a interrupt or bulk type descriptor */\n\t\t\tif ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)\n\t\t\t  NotificationEndpoint = EndpointData;\n\t\t\telse\n\t\t\t  DataINEndpoint = EndpointData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDataOUTEndpoint = EndpointData;\n\t\t}\n\t}\n\n\t/* Configure the RNDIS data IN pipe */\n\tPipe_ConfigurePipe(RNDIS_DATA_IN_PIPE, EP_TYPE_BULK, PIPE_TOKEN_IN,\n\t                   DataINEndpoint->EndpointAddress, DataINEndpoint->EndpointSize, PIPE_BANK_SINGLE);\n\n\t/* Configure the RNDIS data OUT pipe */\n\tPipe_ConfigurePipe(RNDIS_DATA_OUT_PIPE, EP_TYPE_BULK, PIPE_TOKEN_OUT,\n\t\t\t\t\t   DataOUTEndpoint->EndpointAddress, DataOUTEndpoint->EndpointSize, PIPE_BANK_SINGLE);\n\n\t/* Configure the RNDIS notification pipe */\n\tPipe_ConfigurePipe(RNDIS_NOTIFICATION_PIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,\n\t\t\t\t\t   NotificationEndpoint->EndpointAddress, NotificationEndpoint->EndpointSize, PIPE_BANK_SINGLE);\n\tPipe_SetInterruptPeriod(NotificationEndpoint->PollingIntervalMS);\n\n\t/* Valid data found, return success */\n\treturn SuccessfulConfigRead;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\LowLevel\\RNDISEthernetHost\\ConfigDescriptor.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Adds all the Attributes in the given service table to the response that appear in the Attribute table.\n *\n *  \\param[in]  AttributeTable   Pointer to an Attribute table for the service to examine\n *  \\param[in]  AttributeList    Pointer to a list of Attribute ranges\n *  \\param[in]  TotalAttributes  Number of Attributes stored in the Attribute list\n *  \\param[out] BufferPos       Pointer to the output buffer position where the retrieved attributes are to be stored\n *\n *  \\return Number of bytes added to the output buffer\n */\n", "func_signal": "static uint16_t SDP_AddListedAttributesToResponse(const ServiceAttributeTable_t* AttributeTable,\n                                                  uint16_t AttributeList[][2],\n                                                  const uint8_t TotalAttributes,\n                                                  void** const BufferPos)", "code": "{\n\tuint16_t TotalResponseSize;\n\n\t/* Add an inner Data Element Sequence header for the current services's found Attributes */\n\tuint16_t* AttributeListSize = SDP_AddSequence16(BufferPos);\n\n\t/* Search through the list of Attributes one at a time looking for values in the current UUID's Attribute table */\n\tfor (uint8_t CurrAttribute = 0; CurrAttribute < TotalAttributes; CurrAttribute++)\n\t{\n\t\tuint16_t* AttributeIDRange = AttributeList[CurrAttribute];\n\t\tvoid*     AttributeValue;\n\n\t\t/* Look through the current service's attribute list, examining all the attributes */\n\t\twhile ((AttributeValue = pgm_read_ptr(&AttributeTable->Data)) != NULL)\n\t\t{\n\t\t\t/* Get the current Attribute's ID from the current attribute table entry */\n\t\t\tuint16_t CurrAttributeID = pgm_read_word(&AttributeTable->AttributeID);\n\n\t\t\t/* Check if the current Attribute's ID is within the current Attribute range */\n\t\t\tif ((CurrAttributeID >= AttributeIDRange[0]) && (CurrAttributeID <= AttributeIDRange[1]))\n\t\t\t{\n\t\t\t\t/* Increment the current UUID's returned Attribute container size by the number of added bytes */\n\t\t\t\t*AttributeListSize += SDP_AddAttributeToResponse(CurrAttributeID, AttributeValue, BufferPos);\n\t\t\t}\n\n\t\t\tAttributeTable++;\n\t\t}\n\t}\n\n\t/* Record the total number of added bytes to the buffer */\n\tTotalResponseSize = 3 + *AttributeListSize;\n\n\t/* Fix endianness of the added attribute data element sequence */\n\t*AttributeListSize = SwapEndian_16(*AttributeListSize);\n\n\treturn TotalResponseSize;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Event handler for the USB_UnhandledControlPacket event. This is used to catch standard and class specific\n *  control requests that are not handled internally by the USB library (including the Mass Storage class-specific\n *  requests) so that they can be handled appropriately for the application.\n */\n", "func_signal": "void EVENT_USB_Device_UnhandledControlRequest(void)", "code": "{\n\t/* Process UFI specific control requests */\n\tswitch (USB_ControlRequest.bRequest)\n\t{\n\t\tcase REQ_MassStorageReset:\n\t\t\tif (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))\n\t\t\t{\n\t\t\t\tEndpoint_ClearSETUP();\n\t\t\t\tEndpoint_ClearStatusStage();\n\n\t\t\t\t/* Indicate that the current transfer should be aborted */\n\t\t\t\tIsMassStoreReset = true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REQ_GetMaxLUN:\n\t\t\tif (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))\n\t\t\t{\n\t\t\t\tEndpoint_ClearSETUP();\n\n\t\t\t\t/* Indicate to the host the number of supported LUNs (virtual disks) on the device */\n\t\t\t\tEndpoint_Write_Byte(TOTAL_LUNS - 1);\n\n\t\t\t\tEndpoint_ClearIN();\n\t\t\t\tEndpoint_ClearStatusStage();\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n}", "path": "lufa-lib\\trunk\\Demos\\Device\\LowLevel\\MassStorage\\MassStorage.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Descriptor comparator function. This comparator function is can be called while processing an attached USB device's\n *  configuration descriptor, to search for a specific sub descriptor. It can also be used to abort the configuration\n *  descriptor processing if an incompatible descriptor configuration is found.\n *\n *  This comparator searches for the next bulk IN or OUT endpoint, or interrupt IN endpoint within the current interface,\n *  aborting the search if another interface descriptor is found before the required endpoint (so that it may be compared\n *  using a different comparator to determine if it is another CDC class interface).\n *\n *  \\return A value from the DSEARCH_Return_ErrorCodes_t enum\n */\n", "func_signal": "uint8_t DComp_NextCDCDataInterfaceEndpoint(void* CurrentDescriptor)", "code": "{\n\tif (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Endpoint)\n\t{\n\t\tuint8_t EndpointType = (DESCRIPTOR_CAST(CurrentDescriptor,\n\t\t                                        USB_Descriptor_Endpoint_t).Attributes & EP_TYPE_MASK);\n\n\t\tif ((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT))\n\t\t  return DESCRIPTOR_SEARCH_Found;\n\t}\n\telse if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)\n\t{\n\t\treturn DESCRIPTOR_SEARCH_Fail;\n\t}\n\n\treturn DESCRIPTOR_SEARCH_NotFound;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\LowLevel\\RNDISEthernetHost\\ConfigDescriptor.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/** Reads in the collection of UUIDs from the input buffer's Data Element Sequence container, into the given\n *  UUID list for later use. Once complete, the input buffer pointer is advanced to the end of the UUID container.\n *\n *  \\param[out] UUIDList          Pointer to a buffer where the list of UUIDs are to be stored\n *  \\param[in]  CurrentParameter  Pointer to a Buffer containing a Data Element Sequence of UUID elements\n *\n *  \\return Total number of UUIDs stored in the Data Element Sequence\n */\n", "func_signal": "static uint8_t SDP_GetUUIDList(uint8_t UUIDList[][UUID_SIZE_BYTES],\n                               const void** const CurrentParameter)", "code": "{\n\tuint8_t ElementHeaderSize;\n\tuint8_t TotalUUIDs = 0;\n\n\t/* Retrieve the total size of the UUID container, and unwrap the outer Data Element Sequence container */\n\tuint16_t ServicePatternLength = SDP_GetDataElementSize(CurrentParameter, &ElementHeaderSize);\n\tBT_SDP_DEBUG(2, \"-- Total UUID Length: 0x%04X\", ServicePatternLength);\n\twhile (ServicePatternLength)\n\t{\n\t\t/* Retrieve the size of the next UUID in the container and get a pointer to the next free UUID element in the list */\n\t\tuint8_t* CurrentUUID = UUIDList[TotalUUIDs++];\n\t\tuint8_t  UUIDLength  = SDP_GetDataElementSize(CurrentParameter, &ElementHeaderSize);\n\n\t\t/* Copy over UUID from the container to the free slot */\n\t\tif (UUIDLength <= 4)\n\t\t{\n\t\t\t/* Copy over the base UUID value to the free UUID slot in the list */\n\t\t\tmemcpy_P(CurrentUUID, &BaseUUID, sizeof(BaseUUID));\n\n\t\t\t/* Copy over short UUID */\n\t\t\tmemcpy(CurrentUUID + (4 - UUIDLength), *CurrentParameter, UUIDLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Copy over full UUID */\n\t\t\tmemcpy(CurrentUUID, *CurrentParameter, UUIDLength);\n\t\t}\n\n\t\tBT_SDP_DEBUG(2, \"-- UUID (%d): %02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n\t\t                UUIDLength,\n\t\t                CurrentUUID[0], CurrentUUID[1], CurrentUUID[2], CurrentUUID[3],\n\t\t                CurrentUUID[4], CurrentUUID[5],\n\t\t\t\t\t\tCurrentUUID[6], CurrentUUID[7],\n\t\t                CurrentUUID[8], CurrentUUID[9],\n\t\t\t\t\t\tCurrentUUID[10], CurrentUUID[11], CurrentUUID[12],  CurrentUUID[13],  CurrentUUID[14],  CurrentUUID[15]);\n\n\t\tServicePatternLength -= (UUIDLength + ElementHeaderSize);\n\t\t*CurrentParameter    += UUIDLength;\n\t}\n\n\treturn TotalUUIDs;\n}", "path": "lufa-lib\\trunk\\Demos\\Host\\Incomplete\\BluetoothHost\\Lib\\SDP.c", "repo_name": "zAxis/PSGrade", "stars": 31, "license": "None", "language": "c", "size": 1206}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_system_wait_mutex\n *\n * PARAMETERS:  Mutex           - Mutex to wait on\n *              Timeout         - Max time to wait\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Implements a mutex wait with a check to see if the\n *              mutex is available immediately.  If it is not, the\n *              interpreter is released before waiting.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_ex_system_wait_mutex(acpi_mutex mutex, u16 timeout)", "code": "{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ex_system_wait_mutex);\n\n\tstatus = acpi_os_acquire_mutex(mutex, ACPI_DO_NOT_WAIT);\n\tif (ACPI_SUCCESS(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\tif (status == AE_TIME) {\n\n\t\t/* We must wait, so unlock the interpreter */\n\n\t\tacpi_ex_relinquish_interpreter();\n\n\t\tstatus = acpi_os_acquire_mutex(mutex, timeout);\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_EXEC,\n\t\t\t\t  \"*** Thread awake after blocking, %s\\n\",\n\t\t\t\t  acpi_format_exception(status)));\n\n\t\t/* Reacquire the interpreter */\n\n\t\tacpi_ex_reacquire_interpreter();\n\t}\n\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\exsystem.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* return a generic set of huffman tables */\n", "func_signal": "static u16 *jpeg_huffman_tables(int *length)", "code": "{\n\tstatic u16 tables[] = {\n\t\t0xC4FF, 0xB500, 0x0010, 0x0102, 0x0303, 0x0402, 0x0503, 0x0405,\n\t\t0x0004, 0x0100, 0x017D, 0x0302, 0x0400, 0x0511, 0x2112, 0x4131,\n\t\t0x1306, 0x6151, 0x2207, 0x1471, 0x8132, 0xA191, 0x2308, 0xB142,\n\t\t0x15C1, 0xD152, 0x24F0, 0x6233, 0x8272, 0x0A09, 0x1716, 0x1918,\n\t\t0x251A, 0x2726, 0x2928, 0x342A, 0x3635, 0x3837, 0x3A39, 0x4443,\n\t\t0x4645, 0x4847, 0x4A49, 0x5453, 0x5655, 0x5857, 0x5A59, 0x6463,\n\t\t0x6665, 0x6867, 0x6A69, 0x7473, 0x7675, 0x7877, 0x7A79, 0x8483,\n\t\t0x8685, 0x8887, 0x8A89, 0x9392, 0x9594, 0x9796, 0x9998, 0xA29A,\n\t\t0xA4A3, 0xA6A5, 0xA8A7, 0xAAA9, 0xB3B2, 0xB5B4, 0xB7B6, 0xB9B8,\n\t\t0xC2BA, 0xC4C3, 0xC6C5, 0xC8C7, 0xCAC9, 0xD3D2, 0xD5D4, 0xD7D6,\n\t\t0xD9D8, 0xE1DA, 0xE3E2, 0xE5E4, 0xE7E6, 0xE9E8, 0xF1EA, 0xF3F2,\n\t\t0xF5F4, 0xF7F6, 0xF9F8, 0xFFFA,\n\t\t0xC4FF, 0xB500, 0x0011, 0x0102, 0x0402, 0x0304, 0x0704, 0x0405,\n\t\t0x0004, 0x0201, 0x0077, 0x0201, 0x1103, 0x0504, 0x3121, 0x1206,\n\t\t0x5141, 0x6107, 0x1371, 0x3222, 0x0881, 0x4214, 0xA191, 0xC1B1,\n\t\t0x2309, 0x5233, 0x15F0, 0x7262, 0x0AD1, 0x2416, 0xE134, 0xF125,\n\t\t0x1817, 0x1A19, 0x2726, 0x2928, 0x352A, 0x3736, 0x3938, 0x433A,\n\t\t0x4544, 0x4746, 0x4948, 0x534A, 0x5554, 0x5756, 0x5958, 0x635A,\n\t\t0x6564, 0x6766, 0x6968, 0x736A, 0x7574, 0x7776, 0x7978, 0x827A,\n\t\t0x8483, 0x8685, 0x8887, 0x8A89, 0x9392, 0x9594, 0x9796, 0x9998,\n\t\t0xA29A, 0xA4A3, 0xA6A5, 0xA8A7, 0xAAA9, 0xB3B2, 0xB5B4, 0xB7B6,\n\t\t0xB9B8, 0xC2BA, 0xC4C3, 0xC6C5, 0xC8C7, 0xCAC9, 0xD3D2, 0xD5D4,\n\t\t0xD7D6, 0xD9D8, 0xE2DA, 0xE4E3, 0xE6E5, 0xE8E7, 0xEAE9, 0xF3F2,\n\t\t0xF5F4, 0xF7F6, 0xF9F8, 0xFFFA,\n\t\t0xC4FF, 0x1F00, 0x0000, 0x0501, 0x0101, 0x0101, 0x0101, 0x0000,\n\t\t0x0000, 0x0000, 0x0000, 0x0201, 0x0403, 0x0605, 0x0807, 0x0A09,\n\t\t0xFF0B,\n\t\t0xC4FF, 0x1F00, 0x0001, 0x0103, 0x0101, 0x0101, 0x0101, 0x0101,\n\t\t0x0000, 0x0000, 0x0000, 0x0201, 0x0403, 0x0605, 0x0807, 0x0A09,\n\t\t0xFF0B\n\t};\n\n\t*length = ARRAY_SIZE(tables);\n\treturn tables;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_system_wait_event\n *\n * PARAMETERS:  time_desc       - The 'time to delay' object descriptor\n *              obj_desc        - The object descriptor for this op\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Provides an access point to perform synchronization operations\n *              within the AML.  This operation is a request to wait for an\n *              event.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status\nacpi_ex_system_wait_event(union acpi_operand_object *time_desc,\n\t\t\t  union acpi_operand_object *obj_desc)", "code": "{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_TRACE(ex_system_wait_event);\n\n\tif (obj_desc) {\n\t\tstatus =\n\t\t    acpi_ex_system_wait_semaphore(obj_desc->event.os_semaphore,\n\t\t\t\t\t\t  (u16) time_desc->integer.\n\t\t\t\t\t\t  value);\n\t}\n\n\treturn_ACPI_STATUS(status);\n}", "path": "drivers\\acpi\\acpica\\exsystem.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_system_do_stall\n *\n * PARAMETERS:  how_long        - The amount of time to stall,\n *                                in microseconds\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Suspend running thread for specified amount of time.\n *              Note: ACPI specification requires that Stall() does not\n *              relinquish the processor, and delays longer than 100 usec\n *              should use Sleep() instead.  We allow stalls up to 255 usec\n *              for compatibility with other interpreters and existing BIOSs.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_ex_system_do_stall(u32 how_long)", "code": "{\n\tacpi_status status = AE_OK;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tif (how_long > 255) {\t/* 255 microseconds */\n\t\t/*\n\t\t * Longer than 255 usec, this is an error\n\t\t *\n\t\t * (ACPI specifies 100 usec as max, but this gives some slack in\n\t\t * order to support existing BIOSs)\n\t\t */\n\t\tACPI_ERROR((AE_INFO, \"Time parameter is too large (%d)\",\n\t\t\t    how_long));\n\t\tstatus = AE_AML_OPERAND_VALUE;\n\t} else {\n\t\tacpi_os_stall(how_long);\n\t}\n\n\treturn (status);\n}", "path": "drivers\\acpi\\acpica\\exsystem.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*\n * handle the conditional loop part of the move-and-loop instructions\n */\n", "func_signal": "static void misalignment_MOV_Lcc(struct pt_regs *regs, uint32_t opcode)", "code": "{\n\tunsigned long epsw = regs->epsw;\n\tunsigned long NxorV;\n\n\tkdebug(\"MOV_Lcc %x [flags=%lx]\", opcode, epsw & 0xf);\n\n\t/* calculate N^V and shift onto the same bit position as Z */\n\tNxorV = ((epsw >> 3) ^ epsw >> 1) & 1;\n\n\tswitch (opcode & 0xf) {\n\tcase 0x0: /* MOV_LLT: N^V */\n\t\tif (NxorV)\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x1: /* MOV_LGT: ~(Z or (N^V))*/\n\t\tif (!((epsw & EPSW_FLAG_Z) | NxorV))\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x2: /* MOV_LGE: ~(N^V) */\n\t\tif (!NxorV)\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x3: /* MOV_LLE: Z or (N^V) */\n\t\tif ((epsw & EPSW_FLAG_Z) | NxorV)\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\n\tcase 0x4: /* MOV_LCS: C */\n\t\tif (epsw & EPSW_FLAG_C)\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x5: /* MOV_LHI: ~(C or Z) */\n\t\tif (!(epsw & (EPSW_FLAG_C | EPSW_FLAG_Z)))\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x6: /* MOV_LCC: ~C */\n\t\tif (!(epsw & EPSW_FLAG_C))\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x7: /* MOV_LLS: C or Z */\n\t\tif (epsw & (EPSW_FLAG_C | EPSW_FLAG_Z))\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\n\tcase 0x8: /* MOV_LEQ: Z */\n\t\tif (epsw & EPSW_FLAG_Z)\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0x9: /* MOV_LNE: ~Z */\n\t\tif (!(epsw & EPSW_FLAG_Z))\n\t\t\tgoto take_the_loop;\n\t\treturn;\n\tcase 0xa: /* MOV_LRA: always */\n\t\tgoto take_the_loop;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ntake_the_loop:\n\t/* wind the PC back to just after the SETLB insn */\n\tkdebug(\"loop LAR=%lx\", regs->lar);\n\tregs->pc = regs->lar - 4;\n}", "path": "arch\\mn10300\\mm\\misalignment.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*******************************************************************************\n *\n * FUNCTION:    acpi_ex_system_do_suspend\n *\n * PARAMETERS:  how_long        - The amount of time to suspend,\n *                                in milliseconds\n *\n * RETURN:      None\n *\n * DESCRIPTION: Suspend running thread for specified amount of time.\n *\n ******************************************************************************/\n", "func_signal": "acpi_status acpi_ex_system_do_suspend(acpi_integer how_long)", "code": "{\n\tACPI_FUNCTION_ENTRY();\n\n\t/* Since this thread will sleep, we must release the interpreter */\n\n\tacpi_ex_relinquish_interpreter();\n\n\tacpi_os_sleep(how_long);\n\n\t/* And now we must get the interpreter again */\n\n\tacpi_ex_reacquire_interpreter();\n\treturn (AE_OK);\n}", "path": "drivers\\acpi\\acpica\\exsystem.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*\n * determine the register that is acting as source/dest\n */\n", "func_signal": "static int misalignment_reg(unsigned long *registers, unsigned params,\n\t\t\t    unsigned opcode, unsigned long disp,\n\t\t\t    unsigned long **_register)", "code": "{\n\tparams &= 0x7fffffff;\n\n\tif (params & 0xffffff00)\n\t\treturn 0;\n\n\tswitch (params & 0xff) {\n\tcase DM0:\n\t\t*_register = &registers[Dreg_index[opcode & 0x03]];\n\t\tbreak;\n\tcase DM1:\n\t\t*_register = &registers[Dreg_index[opcode >> 2 & 0x03]];\n\t\tbreak;\n\tcase DM2:\n\t\t*_register = &registers[Dreg_index[opcode >> 4 & 0x03]];\n\t\tbreak;\n\tcase AM0:\n\t\t*_register = &registers[Areg_index[opcode & 0x03]];\n\t\tbreak;\n\tcase AM1:\n\t\t*_register = &registers[Areg_index[opcode >> 2 & 0x03]];\n\t\tbreak;\n\tcase AM2:\n\t\t*_register = &registers[Areg_index[opcode >> 4 & 0x03]];\n\t\tbreak;\n\tcase RM0:\n\t\t*_register = &registers[Rreg_index[opcode & 0x0f]];\n\t\tbreak;\n\tcase RM1:\n\t\t*_register = &registers[Rreg_index[opcode >> 2 & 0x0f]];\n\t\tbreak;\n\tcase RM2:\n\t\t*_register = &registers[Rreg_index[opcode >> 4 & 0x0f]];\n\t\tbreak;\n\tcase RM4:\n\t\t*_register = &registers[Rreg_index[opcode >> 8 & 0x0f]];\n\t\tbreak;\n\tcase RM6:\n\t\t*_register = &registers[Rreg_index[opcode >> 12 & 0x0f]];\n\t\tbreak;\n\tcase RD0:\n\t\t*_register = &registers[Rreg_index[disp & 0x0f]];\n\t\tbreak;\n\tcase RD2:\n\t\t*_register = &registers[Rreg_index[disp >> 4 & 0x0f]];\n\t\tbreak;\n\tcase SP:\n\t\t*_register = &registers[REG_SP >> 2];\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "arch\\mn10300\\mm\\misalignment.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*\n * General outline: remap really low stuff [eventually] to SuperIO,\n * stuff in PCI IO space (at or above window at pci.h:PCIBIOS_MIN_IO)\n * is mapped through the PCI IO window.  Stuff with high bits (PXSEG)\n * should be way beyond the window, and is used  w/o translation for\n * compatibility.\n */\n", "func_signal": "unsigned char sh7751systemh_inb(unsigned long port)", "code": "{\n\tif (PXSEG(port))\n\t\treturn *(volatile unsigned char *)port;\n\telse if (port <= 0x3F1)\n\t\treturn *(volatile unsigned char *)ETHER_IOMAP(port);\n\telse\n\t\treturn (*port2adr(port))&0xff;\n}", "path": "arch\\sh\\boards\\mach-systemh\\io.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* uncompress one image into a buffer */\n", "func_signal": "static int mchip_uncompress_frame(u8 *img, int imgsize, u8 *buf, int bufsize)", "code": "{\n\tmchip_vrj_setup(0x3f);\n\tudelay(50);\n\n\tmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_STILL_DECOMP);\n\tmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\n\n\tmchip_delay(MCHIP_HIC_CMD, 0);\n\n\treturn mchip_comp_read_frame(buf, bufsize);\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* get the register value */\n", "func_signal": "static inline u32 mchip_read(int reg)", "code": "{\n\tmchip_sync(reg);\n\treturn readl(meye.mchip_mmregs + reg);\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*\n  isdnhdlc_encode - encodes HDLC frames to a transparent bit stream.\n\n  The bit stream starts with a beginning flag (01111110). After\n  that each byte is added to the bit stream with bit stuffing added\n  (0 after 5 1's).\n  When the last byte has been removed from the source buffer, the\n  CRC (2 bytes is added) and the frame terminates with the ending flag.\n  For the dchannel, the idle character (all 1's) is also added at the end.\n  If this function is called with empty source buffer (slen=0), flags or\n  idle character will be generated.\n\n  src - source buffer\n  slen - source buffer length\n  count - number of bytes removed (encoded) from source buffer\n  dst _ destination buffer\n  dsize - destination buffer size\n  returns - number of encoded bytes in the destination buffer\n*/\n", "func_signal": "int isdnhdlc_encode(struct isdnhdlc_vars *hdlc, const u8 *src, u16 slen,\n\tint *count, u8 *dst, int dsize)", "code": "{\n\tstatic const unsigned char xfast_flag_value[] = {\n\t\t0x7e, 0x3f, 0x9f, 0xcf, 0xe7, 0xf3, 0xf9, 0xfc, 0x7e\n\t};\n\n\tint len = 0;\n\n\t*count = slen;\n\n\t/* special handling for one byte frames */\n\tif ((slen == 1) && (hdlc->state == HDLC_SEND_FAST_FLAG))\n\t\thdlc->state = HDLC_SENDFLAG_ONE;\n\twhile (dsize > 0) {\n\t\tif (hdlc->bit_shift == 0) {\n\t\t\tif (slen && !hdlc->do_closing) {\n\t\t\t\thdlc->shift_reg = *src++;\n\t\t\t\tslen--;\n\t\t\t\tif (slen == 0)\n\t\t\t\t\t/* closing sequence, CRC + flag(s) */\n\t\t\t\t\thdlc->do_closing = 1;\n\t\t\t\thdlc->bit_shift = 8;\n\t\t\t} else {\n\t\t\t\tif (hdlc->state == HDLC_SEND_DATA) {\n\t\t\t\t\tif (hdlc->data_received) {\n\t\t\t\t\t\thdlc->state = HDLC_SEND_CRC1;\n\t\t\t\t\t\thdlc->crc ^= 0xffff;\n\t\t\t\t\t\thdlc->bit_shift = 8;\n\t\t\t\t\t\thdlc->shift_reg =\n\t\t\t\t\t\t\thdlc->crc & 0xff;\n\t\t\t\t\t} else if (!hdlc->do_adapt56)\n\t\t\t\t\t\thdlc->state =\n\t\t\t\t\t\t\tHDLC_SEND_FAST_FLAG;\n\t\t\t\t\telse\n\t\t\t\t\t\thdlc->state =\n\t\t\t\t\t\t\tHDLC_SENDFLAG_B0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tswitch (hdlc->state) {\n\t\tcase STOPPED:\n\t\t\twhile (dsize--)\n\t\t\t\t*dst++ = 0xff;\n\t\t\treturn dsize;\n\t\tcase HDLC_SEND_FAST_FLAG:\n\t\t\thdlc->do_closing = 0;\n\t\t\tif (slen == 0) {\n\t\t\t\t/* the code is for bitreverse streams */\n\t\t\t\tif (hdlc->do_bitreverse == 0)\n\t\t\t\t\t*dst++ = bitrev8(hdlc->ffvalue);\n\t\t\t\telse\n\t\t\t\t\t*dst++ = hdlc->ffvalue;\n\t\t\t\tlen++;\n\t\t\t\tdsize--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase HDLC_SENDFLAG_ONE:\n\t\t\tif (hdlc->bit_shift == 8) {\n\t\t\t\thdlc->cbin = hdlc->ffvalue >>\n\t\t\t\t\t(8 - hdlc->data_bits);\n\t\t\t\thdlc->state = HDLC_SEND_DATA;\n\t\t\t\thdlc->crc = 0xffff;\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\thdlc->data_received = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SENDFLAG_B0:\n\t\t\thdlc->do_closing = 0;\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\thdlc->state = HDLC_SENDFLAG_B1A6;\n\t\t\tbreak;\n\t\tcase HDLC_SENDFLAG_B1A6:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\thdlc->cbin++;\n\t\t\tif (++hdlc->hdlc_bits1 == 6)\n\t\t\t\thdlc->state = HDLC_SENDFLAG_B7;\n\t\t\tbreak;\n\t\tcase HDLC_SENDFLAG_B7:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (slen == 0) {\n\t\t\t\thdlc->state = HDLC_SENDFLAG_B0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdlc->bit_shift == 8) {\n\t\t\t\thdlc->state = HDLC_SEND_DATA;\n\t\t\t\thdlc->crc = 0xffff;\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\thdlc->data_received = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_FIRST_FLAG:\n\t\t\thdlc->data_received = 1;\n\t\t\tif (hdlc->data_bits == 8) {\n\t\t\t\thdlc->state = HDLC_SEND_DATA;\n\t\t\t\thdlc->crc = 0xffff;\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (hdlc->shift_reg & 0x01)\n\t\t\t\thdlc->cbin++;\n\t\t\thdlc->shift_reg >>= 1;\n\t\t\thdlc->bit_shift--;\n\t\t\tif (hdlc->bit_shift == 0) {\n\t\t\t\thdlc->state = HDLC_SEND_DATA;\n\t\t\t\thdlc->crc = 0xffff;\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_DATA:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (hdlc->hdlc_bits1 == 5) {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdlc->bit_shift == 8)\n\t\t\t\thdlc->crc = crc_ccitt_byte(hdlc->crc,\n\t\t\t\t\thdlc->shift_reg);\n\t\t\tif (hdlc->shift_reg & 0x01) {\n\t\t\t\thdlc->hdlc_bits1++;\n\t\t\t\thdlc->cbin++;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t} else {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_CRC1:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (hdlc->hdlc_bits1 == 5) {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdlc->shift_reg & 0x01) {\n\t\t\t\thdlc->hdlc_bits1++;\n\t\t\t\thdlc->cbin++;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t} else {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t}\n\t\t\tif (hdlc->bit_shift == 0) {\n\t\t\t\thdlc->shift_reg = (hdlc->crc >> 8);\n\t\t\t\thdlc->state = HDLC_SEND_CRC2;\n\t\t\t\thdlc->bit_shift = 8;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_CRC2:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (hdlc->hdlc_bits1 == 5) {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdlc->shift_reg & 0x01) {\n\t\t\t\thdlc->hdlc_bits1++;\n\t\t\t\thdlc->cbin++;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t} else {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\thdlc->shift_reg >>= 1;\n\t\t\t\thdlc->bit_shift--;\n\t\t\t}\n\t\t\tif (hdlc->bit_shift == 0) {\n\t\t\t\thdlc->shift_reg = 0x7e;\n\t\t\t\thdlc->state = HDLC_SEND_CLOSING_FLAG;\n\t\t\t\thdlc->bit_shift = 8;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_CLOSING_FLAG:\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->data_bits++;\n\t\t\tif (hdlc->hdlc_bits1 == 5) {\n\t\t\t\thdlc->hdlc_bits1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdlc->shift_reg & 0x01)\n\t\t\t\thdlc->cbin++;\n\t\t\thdlc->shift_reg >>= 1;\n\t\t\thdlc->bit_shift--;\n\t\t\tif (hdlc->bit_shift == 0) {\n\t\t\t\thdlc->ffvalue =\n\t\t\t\t\txfast_flag_value[hdlc->data_bits];\n\t\t\t\tif (hdlc->dchannel) {\n\t\t\t\t\thdlc->ffvalue = 0x7e;\n\t\t\t\t\thdlc->state = HDLC_SEND_IDLE1;\n\t\t\t\t\thdlc->bit_shift = 8-hdlc->data_bits;\n\t\t\t\t\tif (hdlc->bit_shift == 0)\n\t\t\t\t\t\thdlc->state =\n\t\t\t\t\t\t\tHDLC_SEND_FAST_IDLE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!hdlc->do_adapt56) {\n\t\t\t\t\t\thdlc->state =\n\t\t\t\t\t\t\tHDLC_SEND_FAST_FLAG;\n\t\t\t\t\t\thdlc->data_received = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thdlc->state = HDLC_SENDFLAG_B0;\n\t\t\t\t\t\thdlc->data_received = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Finished this frame, send flags */\n\t\t\t\t\tif (dsize > 1)\n\t\t\t\t\t\tdsize = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_IDLE1:\n\t\t\thdlc->do_closing = 0;\n\t\t\thdlc->cbin <<= 1;\n\t\t\thdlc->cbin++;\n\t\t\thdlc->data_bits++;\n\t\t\thdlc->bit_shift--;\n\t\t\tif (hdlc->bit_shift == 0) {\n\t\t\t\thdlc->state = HDLC_SEND_FAST_IDLE;\n\t\t\t\thdlc->bit_shift = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HDLC_SEND_FAST_IDLE:\n\t\t\thdlc->do_closing = 0;\n\t\t\thdlc->cbin = 0xff;\n\t\t\thdlc->data_bits = 8;\n\t\t\tif (hdlc->bit_shift == 8) {\n\t\t\t\thdlc->cbin = 0x7e;\n\t\t\t\thdlc->state = HDLC_SEND_FIRST_FLAG;\n\t\t\t} else {\n\t\t\t\t/* the code is for bitreverse streams */\n\t\t\t\tif (hdlc->do_bitreverse == 0)\n\t\t\t\t\t*dst++ = bitrev8(hdlc->cbin);\n\t\t\t\telse\n\t\t\t\t\t*dst++ = hdlc->cbin;\n\t\t\t\thdlc->bit_shift = 0;\n\t\t\t\thdlc->data_bits = 0;\n\t\t\t\tlen++;\n\t\t\t\tdsize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (hdlc->do_adapt56) {\n\t\t\tif (hdlc->data_bits == 7) {\n\t\t\t\thdlc->cbin <<= 1;\n\t\t\t\thdlc->cbin++;\n\t\t\t\thdlc->data_bits++;\n\t\t\t}\n\t\t}\n\t\tif (hdlc->data_bits == 8) {\n\t\t\t/* the code is for bitreverse streams */\n\t\t\tif (hdlc->do_bitreverse == 0)\n\t\t\t\t*dst++ = bitrev8(hdlc->cbin);\n\t\t\telse\n\t\t\t\t*dst++ = hdlc->cbin;\n\t\t\thdlc->data_bits = 0;\n\t\t\tlen++;\n\t\t\tdsize--;\n\t\t}\n\t}\n\t*count -= slen;\n\n\treturn len;\n}", "path": "drivers\\isdn\\i4l\\isdnhdlc.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/****************************************************************************/\n/* Interrupt handling                                                       */\n/****************************************************************************/\n", "func_signal": "static irqreturn_t meye_irq(int irq, void *dev_id)", "code": "{\n\tu32 v;\n\tint reqnr;\n\tstatic int sequence;\n\n\tv = mchip_read(MCHIP_MM_INTA);\n\n\tif (meye.mchip_mode != MCHIP_HIC_MODE_CONT_OUT &&\n\t    meye.mchip_mode != MCHIP_HIC_MODE_CONT_COMP)\n\t\treturn IRQ_NONE;\n\nagain:\n\tv = mchip_get_frame();\n\tif (!(v & MCHIP_MM_FIR_RDY))\n\t\treturn IRQ_HANDLED;\n\n\tif (meye.mchip_mode == MCHIP_HIC_MODE_CONT_OUT) {\n\t\tif (kfifo_get(meye.grabq, (unsigned char *)&reqnr,\n\t\t\t      sizeof(int)) != sizeof(int)) {\n\t\t\tmchip_free_frame();\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tmchip_cont_read_frame(v, meye.grab_fbuffer + gbufsize * reqnr,\n\t\t\t\t      mchip_hsize() * mchip_vsize() * 2);\n\t\tmeye.grab_buffer[reqnr].size = mchip_hsize() * mchip_vsize() * 2;\n\t\tmeye.grab_buffer[reqnr].state = MEYE_BUF_DONE;\n\t\tdo_gettimeofday(&meye.grab_buffer[reqnr].timestamp);\n\t\tmeye.grab_buffer[reqnr].sequence = sequence++;\n\t\tkfifo_put(meye.doneq, (unsigned char *)&reqnr, sizeof(int));\n\t\twake_up_interruptible(&meye.proc_list);\n\t} else {\n\t\tint size;\n\t\tsize = mchip_comp_read_frame(v, meye.grab_temp, gbufsize);\n\t\tif (size == -1) {\n\t\t\tmchip_free_frame();\n\t\t\tgoto again;\n\t\t}\n\t\tif (kfifo_get(meye.grabq, (unsigned char *)&reqnr,\n\t\t\t      sizeof(int)) != sizeof(int)) {\n\t\t\tmchip_free_frame();\n\t\t\tgoto again;\n\t\t}\n\t\tmemcpy(meye.grab_fbuffer + gbufsize * reqnr, meye.grab_temp,\n\t\t       size);\n\t\tmeye.grab_buffer[reqnr].size = size;\n\t\tmeye.grab_buffer[reqnr].state = MEYE_BUF_DONE;\n\t\tdo_gettimeofday(&meye.grab_buffer[reqnr].timestamp);\n\t\tmeye.grab_buffer[reqnr].sequence = sequence++;\n\t\tkfifo_put(meye.doneq, (unsigned char *)&reqnr, sizeof(int));\n\t\twake_up_interruptible(&meye.proc_list);\n\t}\n\tmchip_free_frame();\n\tgoto again;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/*\n * determine the address that was being accessed\n */\n", "func_signal": "static int misalignment_addr(unsigned long *registers, unsigned long sp,\n\t\t\t     unsigned params, unsigned opcode,\n\t\t\t     unsigned long disp,\n\t\t\t     void **_address, unsigned long **_postinc,\n\t\t\t     unsigned long *_inc)", "code": "{\n\tunsigned long *postinc = NULL, address = 0, tmp;\n\n\tif (!(params & 0x1000000)) {\n\t\tkdebug(\"noinc\");\n\t\t*_inc = 0;\n\t\t_inc = NULL;\n\t}\n\n\tparams &= 0x00ffffff;\n\n\tdo {\n\t\tswitch (params & 0xff) {\n\t\tcase DM0:\n\t\t\tpostinc = &registers[Dreg_index[opcode & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase DM1:\n\t\t\tpostinc = &registers[Dreg_index[opcode >> 2 & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase DM2:\n\t\t\tpostinc = &registers[Dreg_index[opcode >> 4 & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase AM0:\n\t\t\tpostinc = &registers[Areg_index[opcode & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase AM1:\n\t\t\tpostinc = &registers[Areg_index[opcode >> 2 & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase AM2:\n\t\t\tpostinc = &registers[Areg_index[opcode >> 4 & 0x03]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RM0:\n\t\t\tpostinc = &registers[Rreg_index[opcode & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RM1:\n\t\t\tpostinc = &registers[Rreg_index[opcode >> 2 & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RM2:\n\t\t\tpostinc = &registers[Rreg_index[opcode >> 4 & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RM4:\n\t\t\tpostinc = &registers[Rreg_index[opcode >> 8 & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RM6:\n\t\t\tpostinc = &registers[Rreg_index[opcode >> 12 & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RD0:\n\t\t\tpostinc = &registers[Rreg_index[disp & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase RD2:\n\t\t\tpostinc = &registers[Rreg_index[disp >> 4 & 0x0f]];\n\t\t\taddress += *postinc;\n\t\t\tbreak;\n\t\tcase SP:\n\t\t\taddress += sp;\n\t\t\tbreak;\n\n\t\t\t/* displacements are either to be added to the address\n\t\t\t * before use, or, in the case of post-inc addressing,\n\t\t\t * to be added into the base register after use */\n\t\tcase SD8:\n\t\tcase SIMM8:\n\t\t\tdisp = (long) (int8_t) (disp & 0xff);\n\t\t\tgoto displace_or_inc;\n\t\tcase SD16:\n\t\t\tdisp = (long) (int16_t) (disp & 0xffff);\n\t\t\tgoto displace_or_inc;\n\t\tcase SD24:\n\t\t\ttmp = disp << 8;\n\t\t\tasm(\"asr 8,%0\" : \"=r\"(tmp) : \"0\"(tmp));\n\t\t\tdisp = (long) tmp;\n\t\t\tgoto displace_or_inc;\n\t\tcase SIMM4_2:\n\t\t\ttmp = opcode >> 4 & 0x0f;\n\t\t\ttmp <<= 28;\n\t\t\tasm(\"asr 28,%0\" : \"=r\"(tmp) : \"0\"(tmp));\n\t\t\tdisp = (long) tmp;\n\t\t\tgoto displace_or_inc;\n\t\tcase IMM8:\n\t\t\tdisp &= 0x000000ff;\n\t\t\tgoto displace_or_inc;\n\t\tcase IMM16:\n\t\t\tdisp &= 0x0000ffff;\n\t\t\tgoto displace_or_inc;\n\t\tcase IMM24:\n\t\t\tdisp &= 0x00ffffff;\n\t\t\tgoto displace_or_inc;\n\t\tcase IMM32:\n\t\tcase IMM32_MEM:\n\t\tcase IMM32_HIGH8:\n\t\tcase IMM32_HIGH8_MEM:\n\t\tdisplace_or_inc:\n\t\t\tkdebug(\"%s %lx\", _inc ? \"incr\" : \"disp\", disp);\n\t\t\tif (!_inc)\n\t\t\t\taddress += disp;\n\t\t\telse\n\t\t\t\t*_inc = disp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t} while ((params >>= 8));\n\n\t*_address = (void *) address;\n\t*_postinc = postinc;\n\treturn 1;\n}", "path": "arch\\mn10300\\mm\\misalignment.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* waits for a register to be available */\n", "func_signal": "static void mchip_sync(int reg)", "code": "{\n\tu32 status;\n\tint i;\n\n\tif (reg == MCHIP_MM_FIFO_DATA) {\n\t\tfor (i = 0; i < MCHIP_REG_TIMEOUT; i++) {\n\t\t\tstatus = readl(meye.mchip_mmregs +\n\t\t\t\t       MCHIP_MM_FIFO_STATUS);\n\t\t\tif (!(status & MCHIP_MM_FIFO_WAIT)) {\n\t\t\t\tprintk(KERN_WARNING \"meye: fifo not ready\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (status & MCHIP_MM_FIFO_READY)\n\t\t\t\treturn;\n\t\t\tudelay(1);\n\t\t}\n\t} else if (reg > 0x80) {\n\t\tu32 mask = (reg < 0x100) ? MCHIP_HIC_STATUS_MCC_RDY\n\t\t\t\t\t : MCHIP_HIC_STATUS_VRJ_RDY;\n\t\tfor (i = 0; i < MCHIP_REG_TIMEOUT; i++) {\n\t\t\tstatus = readl(meye.mchip_mmregs + MCHIP_HIC_STATUS);\n\t\t\tif (status & mask)\n\t\t\t\treturn;\n\t\t\tudelay(1);\n\t\t}\n\t} else\n\t\treturn;\n\tprintk(KERN_WARNING\n\t       \"meye: mchip_sync() timeout on reg 0x%x status=0x%x\\n\",\n\t       reg, status);\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* take a picture into SDRAM */\n", "func_signal": "static void mchip_take_picture(void)", "code": "{\n\tint i;\n\n\tmchip_hic_stop();\n\tmchip_subsample();\n\tmchip_dma_setup(meye.mchip_dmahandle);\n\n\tmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_STILL_CAP);\n\tmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\n\n\tmchip_delay(MCHIP_HIC_CMD, 0);\n\n\tfor (i = 0; i < 100; ++i) {\n\t\tif (mchip_delay(MCHIP_HIC_STATUS, MCHIP_HIC_STATUS_IDLE))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* read a compressed frame from the framebuffer */\n", "func_signal": "static int mchip_comp_read_frame(u32 v, u8 *buf, int size)", "code": "{\n\tint pt_start, pt_end, trailer;\n\tint fsize;\n\tint i;\n\n\tpt_start = (v >> 19) & 0xFF;\n\tpt_end = (v >> 11) & 0xFF;\n\ttrailer = (v >> 1) & 0x3FF;\n\n\tif (pt_end < pt_start)\n\t\tfsize = (MCHIP_NB_PAGES_MJPEG - pt_start) * PAGE_SIZE +\n\t\t\tpt_end * PAGE_SIZE + trailer * 4;\n\telse\n\t\tfsize = (pt_end - pt_start) * PAGE_SIZE + trailer * 4;\n\n\tif (fsize > size) {\n\t\tprintk(KERN_WARNING \"meye: oversized compressed frame %d\\n\",\n\t\t       fsize);\n\t\treturn -1;\n\t}\n\n\tptable_copy(buf, pt_start, fsize, MCHIP_NB_PAGES_MJPEG);\n\n#ifdef MEYE_JPEG_CORRECTION\n\n\t/* Some mchip generated jpeg frames are incorrect. In most\n\t * (all ?) of those cases, the final EOI (0xff 0xd9) marker\n\t * is not present at the end of the frame.\n\t *\n\t * Since adding the final marker is not enough to restore\n\t * the jpeg integrity, we drop the frame.\n\t */\n\n\tfor (i = fsize - 1; i > 0 && buf[i] == 0xff; i--) ;\n\n\tif (i < 2 || buf[i - 1] != 0xff || buf[i] != 0xd9)\n\t\treturn -1;\n\n#endif\n\n\treturn fsize;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* sets the DMA parameters into the chip */\n", "func_signal": "static void mchip_dma_setup(dma_addr_t dma_addr)", "code": "{\n\tint i;\n\n\tmchip_set(MCHIP_MM_PT_ADDR, (u32)dma_addr);\n\tfor (i = 0; i < 4; i++)\n\t\tmchip_set(MCHIP_MM_FIR(i), 0);\n\tmeye.mchip_fnum = 0;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* frees the current frame from the dma engine */\n", "func_signal": "static void mchip_free_frame(void)", "code": "{\n\tmchip_set(MCHIP_MM_FIR(meye.mchip_fnum), 0);\n\tmeye.mchip_fnum++;\n\tmeye.mchip_fnum %= 4;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/* setup for DMA transfers - also zeros the framebuffer */\n", "func_signal": "static int mchip_dma_alloc(void)", "code": "{\n\tif (!meye.mchip_dmahandle)\n\t\tif (ptable_alloc())\n\t\t\treturn -1;\n\treturn 0;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "/****************************************************************************/\n/* video4linux integration                                                  */\n/****************************************************************************/\n", "func_signal": "static int meye_open(struct file *file)", "code": "{\n\tint i;\n\n\tif (test_and_set_bit(0, &meye.in_use))\n\t\treturn -EBUSY;\n\n\tmchip_hic_stop();\n\n\tif (mchip_dma_alloc()) {\n\t\tprintk(KERN_ERR \"meye: mchip framebuffer allocation failed\\n\");\n\t\tclear_bit(0, &meye.in_use);\n\t\treturn -ENOBUFS;\n\t}\n\n\tfor (i = 0; i < MEYE_MAX_BUFNBRS; i++)\n\t\tmeye.grab_buffer[i].state = MEYE_BUF_UNUSED;\n\tkfifo_reset(meye.grabq);\n\tkfifo_reset(meye.doneq);\n\treturn 0;\n}", "path": "drivers\\media\\video\\meye.c", "repo_name": "pershoot/gtab-2632", "stars": 21, "license": "other", "language": "c", "size": 319721}
{"docstring": "// Left samples are top[-5 .. -2], top_left is top[-1], top are\n// located at top[0..3], and top right is top[4..7]\n", "func_signal": "static void Intra4Preds(uint8_t* dst, const uint8_t* top)", "code": "{\n  DC4(I4DC4 + dst, top);\n  TM4(I4TM4 + dst, top);\n  VE4(I4VE4 + dst, top);\n  HE4(I4HE4 + dst, top);\n  RD4(I4RD4 + dst, top);\n  VR4(I4VR4 + dst, top);\n  LD4(I4LD4 + dst, top);\n  VL4(I4VL4 + dst, top);\n  HD4(I4HD4 + dst, top);\n  HU4(I4HU4 + dst, top);\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Performs: difference, transform, quantize, back-transform, add\n// all at once. Output is the reconstructed block in *yuv_out, and the\n// quantized levels in *levels.\n", "func_signal": "static int ReconstructIntra16(VP8EncIterator* const it,\n                              VP8ModeScore* const rd,\n                              uint8_t* const yuv_out,\n                              int mode)", "code": "{\n  const VP8Encoder* const enc = it->enc_;\n  const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];\n  const uint8_t* const src = it->yuv_in_ + Y_OFF;\n  const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];\n  int nz = 0;\n  int n;\n  int16_t tmp[16][16], dc_tmp[16];\n\n  for (n = 0; n < 16; ++n) {\n    VP8FTransform(src + VP8Scan[n], ref + VP8Scan[n], tmp[n]);\n  }\n  VP8FTransformWHT(tmp[0], dc_tmp);\n  nz |= VP8EncQuantizeBlock(dc_tmp, rd->y_dc_levels, 0, &dqm->y2_) << 24;\n\n  if (DO_TRELLIS_I16 && it->do_trellis_) {\n    int x, y;\n    VP8IteratorNzToBytes(it);\n    for (y = 0, n = 0; y < 4; ++y) {\n      for (x = 0; x < 4; ++x, ++n) {\n        const int ctx = it->top_nz_[x] + it->left_nz_[y];\n        const int non_zero =\n           TrellisQuantizeBlock(it, tmp[n], rd->y_ac_levels[n], ctx, 0,\n                                &dqm->y1_, dqm->lambda_trellis_i16_);\n        it->top_nz_[x] = it->left_nz_[y] = non_zero;\n        nz |= non_zero << n;\n      }\n    }\n  } else {\n    for (n = 0; n < 16; ++n) {\n      nz |= VP8EncQuantizeBlock(tmp[n], rd->y_ac_levels[n], 1, &dqm->y1_) << n;\n    }\n  }\n\n  // Transform back\n  VP8ITransformWHT(dc_tmp, tmp[0]);\n  for (n = 0; n < 16; ++n) {\n    VP8ITransform(ref + VP8Scan[n], tmp[n], yuv_out + VP8Scan[n]);\n  }\n\n  return nz;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// Returns the average quantizer\n", "func_signal": "static int ExpandMatrix(VP8Matrix* const m, int type)", "code": "{\n  int i;\n  int sum = 0;\n  for (i = 2; i < 16; ++i) {\n    m->q_[i] = m->q_[1];\n  }\n  for (i = 0; i < 16; ++i) {\n    const int j = VP8Zigzag[i];\n    const int bias = kBiasMatrices[type][j];\n    m->iq_[j] = (1 << QFIX) / m->q_[j];\n    m->bias_[j] = BIAS(bias);\n    // TODO(skal): tune kCoeffThresh[]\n    m->zthresh_[j] = ((256 /*+ kCoeffThresh[j]*/ - bias) * m->q_[j] + 127) >> 8;\n    m->sharpen_[j] = (kFreqSharpening[j] * m->q_[j]) >> 11;\n    sum += m->q_[j];\n  }\n  return (sum + 8) >> 4;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Entry point\n", "func_signal": "int VP8Decimate(VP8EncIterator* const it, VP8ModeScore* const rd, int rd_opt)", "code": "{\n  int is_skipped;\n\n  InitScore(rd);\n\n  // We can perform predictions for Luma16x16 and Chroma8x8 already.\n  // Luma4x4 predictions needs to be done as-we-go.\n  VP8MakeLuma16Preds(it);\n  VP8MakeChroma8Preds(it);\n\n  // for rd_opt = 2, we perform trellis-quant on the final decision only.\n  // for rd_opt > 2, we use it for every scoring (=much slower).\n  if (rd_opt > 0) {\n    it->do_trellis_ = (rd_opt > 2);\n    PickBestIntra16(it, rd);\n    if (it->enc_->method_ >= 2) {\n      PickBestIntra4(it, rd);\n    }\n    PickBestUV(it, rd);\n    if (rd_opt == 2) {\n      it->do_trellis_ = 1;\n      SimpleQuantize(it, rd);\n    }\n  } else {\n    // TODO: for method_ == 2, pick the best intra4/intra16 based on SSE\n    it->do_trellis_ = (it->enc_->method_ == 2);\n    SimpleQuantize(it, rd);\n  }\n  is_skipped = (rd->nz == 0);\n  VP8SetSkip(it, is_skipped);\n  return is_skipped;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n", "func_signal": "static void PickBestUV(VP8EncIterator* const it, VP8ModeScore* const rd)", "code": "{\n  VP8Encoder* const enc = it->enc_;\n  const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];\n  const int lambda = dqm->lambda_uv_;\n  const uint8_t* const src = it->yuv_in_ + U_OFF;\n  uint8_t* const tmp_dst = it->yuv_out2_ + U_OFF;  // scratch buffer\n  uint8_t* const dst0 = it->yuv_out_ + U_OFF;\n  VP8ModeScore rd_best;\n  int mode;\n\n  rd->mode_uv = -1;\n  InitScore(&rd_best);\n  for (mode = 0; mode < 4; ++mode) {\n    VP8ModeScore rd_uv;\n\n    // Reconstruct\n    rd_uv.nz = ReconstructUV(it, &rd_uv, tmp_dst, mode);\n\n    // Compute RD-score\n    rd_uv.D  = VP8SSE16x8(src, tmp_dst);\n    rd_uv.SD = 0;    // TODO: should we call TDisto? it tends to flatten areas.\n    rd_uv.R  = VP8GetCostUV(it, &rd_uv);\n    rd_uv.R += VP8FixedCostsUV[mode];\n\n    SetRDScore(lambda, &rd_uv);\n    if (mode == 0 || rd_uv.score < rd_best.score) {\n      CopyScore(&rd_best, &rd_uv);\n      rd->mode_uv = mode;\n      memcpy(rd->uv_levels, rd_uv.uv_levels, sizeof(rd->uv_levels));\n      memcpy(dst0, tmp_dst, UV_SIZE);   //  TODO: SwapUVOut() ?\n    }\n  }\n  VP8SetIntraUVMode(it, rd->mode_uv);\n  AddScore(rd, &rd_best);\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// Map configured quality level to coding tools used.\n//-------------+---+---+---+---+---+---+\n//   Quality   | 0 | 1 | 2 | 3 | 4 | 5 +\n//-------------+---+---+---+---+---+---+\n// dynamic prob| ~ | x | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// rd-opt modes|   |   | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// fast i4/i16 | x | x |   |   |   |   |\n//-------------+---+---+---+---+---+---+\n// rd-opt i4/16|   |   | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// Trellis     |   | x |   |   | x | x |\n//-------------+---+---+---+---+---+---+\n// full-SNS    |   |   |   |   |   | x |\n//-------------+---+---+---+---+---+---+\n", "func_signal": "static void MapConfigToTools(VP8Encoder* const enc)", "code": "{\n  const int method = enc->config_->method;\n  enc->method_ = method;\n  enc->rd_opt_level_ = (method >= 6) ? 3\n                     : (method >= 5) ? 2\n                     : (method >= 3) ? 1\n                     : 0;\n}", "path": "jni\\webpenc.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Chroma 8x8 prediction (paragraph 12.2)\n", "func_signal": "static void IntraChromaPreds(uint8_t* dst, const uint8_t* left,\n                             const uint8_t* top)", "code": "{\n  // U block\n  DCMode(C8DC8 + dst, left, top, 8, 8, 4);\n  VerticalPred(C8VE8 + dst, top, 8);\n  HorizontalPred(C8HE8 + dst, left, 8);\n  TrueMotion(C8TM8 + dst, left, top, 8);\n  // V block\n  dst += 8;\n  if (top) top += 8;\n  if (left) left += 16;\n  DCMode(C8DC8 + dst, left, top, 8, 8, 4);\n  VerticalPred(C8VE8 + dst, top, 8);\n  HorizontalPred(C8HE8 + dst, left, 8);\n  TrueMotion(C8TM8 + dst, left, top, 8);\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Metric\n", "func_signal": "static inline int GetSSE(const uint8_t* a, const uint8_t* b, int w, int h)", "code": "{\n  int count = 0;\n  int y, x;\n  for (y = 0; y < h; ++y) {\n    for (x = 0; x < w; ++x) {\n      const int diff = (int)a[x] - b[x];\n      count += diff * diff;\n    }\n    a += BPS;\n    b += BPS;\n  }\n  return count;\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// Init/Copy the common fields in score.\n", "func_signal": "static void InitScore(VP8ModeScore* const rd)", "code": "{\n  rd->D  = 0;\n  rd->SD = 0;\n  rd->R  = 0;\n  rd->nz = 0;\n  rd->score = MAX_COST;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// luma 16x16 prediction (paragraph 12.3)\n", "func_signal": "static void Intra16Preds(uint8_t* dst,\n                         const uint8_t* left, const uint8_t* top)", "code": "{\n  DCMode(I16DC16 + dst, left, top, 16, 16, 5);\n  VerticalPred(I16VE16 + dst, top, 16);\n  HorizontalPred(I16HE16 + dst, left, 16);\n  TrueMotion(I16TM16 + dst, left, top, 16);\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n", "func_signal": "int WebPEncode(const WebPConfig* const config, WebPPicture* const pic)", "code": "{\n  VP8Encoder* enc;\n  int ok;\n\n  if (config == NULL || pic == NULL)\n    return 0;   // bad params\n  if (!WebPValidateConfig(config))\n    return 0;   // invalid config.\n  if (pic->width <= 0 || pic->height <= 0)\n    return 0;   // invalid parameters\n  if (pic->y == NULL || pic->u == NULL || pic->v == NULL)\n    return 0;   // invalid parameters\n  if (pic->width >= MAX_DIMENSION || pic->height >= MAX_DIMENSION)\n    return 0;   // image is too big\n\n  enc = InitEncoder(config, pic);\n  if (enc == NULL) return 0;\n  ok = VP8EncAnalyze(enc)\n    && VP8StatLoop(enc)\n    && VP8EncLoop(enc)\n    && VP8EncWrite(enc);\n  StoreStats(enc);\n  DeleteEncoder(enc);\n  return ok;\n}", "path": "jni\\webpenc.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// return the cost array corresponding to the surrounding prediction modes.\n", "func_signal": "static const uint16_t* GetCostModeI4(VP8EncIterator* const it,\n                                     const int modes[16])", "code": "{\n  const int preds_w = it->enc_->preds_w_;\n  const int x = (it->i4_ & 3), y = it->i4_ >> 2;\n  const int left = (x == 0) ? it->preds_[y * preds_w - 1] : modes[it->i4_ - 1];\n  const int top = (y == 0) ? it->preds_[-preds_w + x] : modes[it->i4_ - 4];\n  return VP8FixedCostsI4[top][left];\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Final reconstruction and quantization.\n", "func_signal": "static void SimpleQuantize(VP8EncIterator* const it, VP8ModeScore* const rd)", "code": "{\n  const VP8Encoder* const enc = it->enc_;\n  const int i16 = (it->mb_->type_ == 1);\n  int nz = 0;\n\n  if (i16) {\n    nz = ReconstructIntra16(it, rd, it->yuv_out_ + Y_OFF, it->preds_[0]);\n  } else {\n    VP8IteratorStartI4(it);\n    do {\n      const int mode =\n          it->preds_[(it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_];\n      const uint8_t* const src = it->yuv_in_ + Y_OFF + VP8Scan[it->i4_];\n      uint8_t* const dst = it->yuv_out_ + Y_OFF + VP8Scan[it->i4_];\n      VP8MakeIntra4Preds(it);\n      nz |= ReconstructIntra4(it, rd->y_ac_levels[it->i4_],\n                              src, dst, mode) << it->i4_;\n    } while (VP8IteratorRotateI4(it, it->yuv_out_ + Y_OFF));\n  }\n\n  nz |= ReconstructUV(it, rd, it->yuv_out_ + U_OFF, it->mb_->uv_mode_);\n  rd->nz = nz;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// We want to emulate jpeg-like behaviour where the expected \"good\" quality\n// is around q=75. Internally, our \"good\" middle is around c=50. So we\n// map accordingly using linear piece-wise function\n", "func_signal": "static double QualityToCompression(double q)", "code": "{\n  const double c = q / 100.;\n  return (c < 0.75) ? c * (2. / 3.) : 2. * c - 1.;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// WebPPicture\n//-----------------------------------------------------------------------------\n", "func_signal": "static int DummyWriter(const uint8_t* data, size_t data_size,\n                       const WebPPicture* const picture)", "code": "{\n  // The following are to prevent 'unused variable' error message.\n  (void)data;\n  (void)data_size;\n  (void)picture;\n  return 1;\n}", "path": "jni\\webpenc.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// Memory scaling with dimensions:\n//  memory (bytes) ~= 2.25 * w + 0.0625 * w * h\n//\n// Typical memory footprint (768x510 picture)\n// Memory used:\n//              encoder: 33919\n//          block cache: 2880\n//                 info: 3072\n//                preds: 24897\n//          top samples: 1623\n//             non-zero: 196\n//             lf-stats: 2048\n//                total: 68635\n// Transcient object sizes:\n//       VP8EncIterator: 352\n//         VP8ModeScore: 912\n//       VP8SegmentInfo: 532\n//             VP8Proba: 31032\n//              LFStats: 2048\n// Picture size (yuv): 589824\n", "func_signal": "static VP8Encoder* InitEncoder(const WebPConfig* const config,\n                               WebPPicture* const picture)", "code": "{\n  const int use_filter =\n      (config->filter_strength > 0) || (config->autofilter > 0);\n  const int mb_w = (picture->width + 15) >> 4;\n  const int mb_h = (picture->height + 15) >> 4;\n  const int preds_w = 4 * mb_w + 1;\n  const int preds_h = 4 * mb_h + 1;\n  const size_t preds_size = preds_w * preds_h * sizeof(uint8_t);\n  const int top_stride = mb_w * 16;\n  const size_t nz_size = (mb_w + 1) * sizeof(uint32_t);\n  const size_t cache_size = (3 * YUV_SIZE + PRED_SIZE) * sizeof(uint8_t);\n  const size_t info_size = mb_w * mb_h * sizeof(VP8MBInfo);\n  const size_t samples_size = (2 * top_stride +         // top-luma/u/v\n                               16 + 16 + 16 + 8 + 1 +   // left y/u/v\n                               2 * ALIGN_CST)           // align all\n                               * sizeof(uint8_t);\n  const size_t lf_stats_size = config->autofilter ? sizeof(LFStats) : 0;\n  VP8Encoder* enc;\n  uint8_t* mem;\n  size_t size = sizeof(VP8Encoder) + ALIGN_CST  // main struct\n              + cache_size                      // working caches\n              + info_size                       // modes info\n              + preds_size                      // prediction modes\n              + samples_size                    // top/left samples\n              + nz_size                         // coeff context bits\n              + lf_stats_size;                  // autofilter stats\n\n#ifdef PRINT_MEMORY_INFO\n  printf(\"===================================\\n\");\n  printf(\"Memory used:\\n\"\n         \"             encoder: %ld\\n\"\n         \"         block cache: %ld\\n\"\n         \"                info: %ld\\n\"\n         \"               preds: %ld\\n\"\n         \"         top samples: %ld\\n\"\n         \"            non-zero: %ld\\n\"\n         \"            lf-stats: %ld\\n\"\n         \"               total: %ld\\n\",\n         sizeof(VP8Encoder) + ALIGN_CST, cache_size, info_size,\n         preds_size, samples_size, nz_size, lf_stats_size, size);\n  printf(\"Transcient object sizes:\\n\"\n         \"      VP8EncIterator: %ld\\n\"\n         \"        VP8ModeScore: %ld\\n\"\n         \"      VP8SegmentInfo: %ld\\n\"\n         \"            VP8Proba: %ld\\n\"\n         \"             LFStats: %ld\\n\",\n         sizeof(VP8EncIterator), sizeof(VP8ModeScore),\n         sizeof(VP8SegmentInfo), sizeof(VP8Proba),\n         sizeof(LFStats));\n  printf(\"Picture size (yuv): %ld\\n\",\n         mb_w * mb_h * 384 * sizeof(uint8_t));\n  printf(\"===================================\\n\");\n#endif\n  mem = (uint8_t*)malloc(size);\n  if (mem == NULL) return NULL;\n  enc = (VP8Encoder*)mem;\n  mem = (uint8_t*)DO_ALIGN(mem + sizeof(*enc));\n  memset(enc, 0, sizeof(*enc));\n  enc->num_parts_ = 1 << config->partitions;\n  enc->mb_w_ = mb_w;\n  enc->mb_h_ = mb_h;\n  enc->preds_w_ = preds_w;\n  enc->yuv_in_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_out_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_out2_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_p_ = (uint8_t*)mem;\n  mem += PRED_SIZE;\n  enc->mb_info_ = (VP8MBInfo*)mem;\n  mem += info_size;\n  enc->preds_ = ((uint8_t*)mem) + 1 + enc->preds_w_;\n  mem += preds_w * preds_h * sizeof(uint8_t);\n  enc->nz_ = 1 + (uint32_t*)mem;\n  mem += nz_size;\n  enc->lf_stats_ = lf_stats_size ? (LFStats*)mem : NULL;\n  mem += lf_stats_size;\n\n  // top samples (all 16-aligned)\n  mem = (uint8_t*)DO_ALIGN(mem);\n  enc->y_top_ = (uint8_t*)mem;\n  enc->uv_top_ = enc->y_top_ + top_stride;\n  mem += 2 * top_stride;\n  mem = (uint8_t*)DO_ALIGN(mem + 1);\n  enc->y_left_ = (uint8_t*)mem;\n  mem += 16 + 16;\n  enc->u_left_ = (uint8_t*)mem;\n  mem += 16;\n  enc->v_left_ = (uint8_t*)mem;\n  mem += 8;\n\n  enc->config_ = config;\n  enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;\n  enc->pic_ = picture;\n\n  MapConfigToTools(enc);\n  VP8EncDspInit();\n  VP8DefaultProbas(enc);\n  ResetSegmentHeader(enc);\n  ResetFilterHeader(enc);\n  ResetBoundaryPredictions(enc);\n\n  return enc;\n}", "path": "jni\\webpenc.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// RD-opt decision. Reconstruct each modes, evalue distortion and bit-cost.\n// Pick the mode is lower RD-cost = Rate + lamba * Distortion.\n", "func_signal": "static void SwapPtr(uint8_t** a, uint8_t** b)", "code": "{\n  uint8_t* const tmp = *a;\n  *a = *b;\n  *b = tmp;\n}", "path": "jni\\quant.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// Block copy\n", "func_signal": "static inline void Copy(const uint8_t* src, uint8_t* dst, int size)", "code": "{\n  int y;\n  for (y = 0; y < size; ++y) {\n    memcpy(dst, src, size);\n    src += BPS;\n    dst += BPS;\n  }\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "//-----------------------------------------------------------------------------\n// VP8Encoder\n//-----------------------------------------------------------------------------\n", "func_signal": "static void ResetSegmentHeader(VP8Encoder* const enc)", "code": "{\n  VP8SegmentHeader* const hdr = &enc->segment_hdr_;\n  hdr->num_segments_ = enc->config_->segments;\n  hdr->update_map_  = (hdr->num_segments_ > 1);\n  hdr->size_ = 0;\n}", "path": "jni\\webpenc.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "// Hadamard transform\n", "func_signal": "static void TTransform(const uint8_t* in, int16_t* out)", "code": "{\n  int tmp[16];\n  int i;\n  for (i = 0; i < 4; ++i, in += BPS) {\n    const int a0 = (in[0] + in[2]) << 2;\n    const int a1 = (in[1] + in[3]) << 2;\n    const int a2 = (in[1] - in[3]) << 2;\n    const int a3 = (in[0] - in[2]) << 2;\n    tmp[0 + i * 4] = a0 + a1 + (a0 != 0);\n    tmp[1 + i * 4] = a3 + a2;\n    tmp[2 + i * 4] = a3 - a2;\n    tmp[3 + i * 4] = a0 - a1;\n  }\n  for (i = 0; i < 4; ++i) {\n    const int a0 = (tmp[0 + i] + tmp[8 + i]);\n    const int a1 = (tmp[4 + i] + tmp[12+ i]);\n    const int a2 = (tmp[4 + i] - tmp[12+ i]);\n    const int a3 = (tmp[0 + i] - tmp[8 + i]);\n    const int b0 = a0 + a1;\n    const int b1 = a3 + a2;\n    const int b2 = a3 - a2;\n    const int b3 = a0 - a1;\n    out[ 0 + i] = (b0 + (b0 < 0) + 3) >> 3;\n    out[ 4 + i] = (b1 + (b1 < 0) + 3) >> 3;\n    out[ 8 + i] = (b2 + (b2 < 0) + 3) >> 3;\n    out[12 + i] = (b3 + (b3 < 0) + 3) >> 3;\n  }\n}", "path": "jni\\dsp.c", "repo_name": "cboshuizen/AXCS", "stars": 19, "license": "None", "language": "c", "size": 420}
{"docstring": "/**************************************** c3arcball_init_center() ****/\n/* A constructor that accepts the screen center and arcball radius*/\n", "func_signal": "void\nc3arcball_init_center(\n\t\tc3arcballp a,\n\t\tconst c3vec2 center,\n\t\tc3f radius )", "code": "{\n    c3arcball_init(a);\n    c3arcball_set_params(a, center, radius);\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/****************************************************************\n *                                                              *\n *         2D functions and 3D functions                        *\n *                                                              *\n ****************************************************************/\n", "func_signal": "c3mat3 identity2D()", "code": "{\n    return c3mat3_vec3(\n        c3vec3f(1.0, 0.0, 0.0),\n        c3vec3f(0.0, 1.0, 0.0),\n        c3vec3f(0.0, 0.0, 1.0));\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/**************************************** c3arcball_init_mat4() ****/\n/* Takes as argument a c3mat4 to use instead of the internal rot  */\n", "func_signal": "void\nc3arcball_init_mat4(\n\t\tc3arcballp a,\n\t\tc3mat4p mtx )", "code": "{\n    c3arcball_init(a);\n    a->rot_ptr = mtx;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/************************************** c3arcball_set_params() ****/\n", "func_signal": "void\nc3arcball_set_params(\n\t\tc3arcballp a,\n\t\tconst c3vec2 center,\n\t\tc3f radius)", "code": "{\n    a->center      = center;\n    a->radius      = radius;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "// CONSTRUCTORS\n", "func_signal": "c3vec3 c3vec3_zero()", "code": "{\n\tc3vec3 n;// = { .x = 0, .y = 0, .z = 0 };// older gcc <4.6 doesn't like this\n\tn.x = n.y = n.z = 0;\n    return n;\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/*\n * This id the meta function that draws a c3geometry. It looks for normals,\n * indices, textures and so on and call the glDrawArrays\n */\n", "func_signal": "static void\n_c3_geometry_draw(\n\t\tc3context_p c,\n\t\tconst struct c3driver_context_t *d,\n\t\tc3geometry_p g )", "code": "{\n\tc3mat4 eye = c3mat4_mul(\n\t\t\t&c3context_view_get(g->object->context)->cam.mtx,\n\t\t\t&g->object->world );\n\tglLoadMatrixf(eye.n);\n\n#if 0\n\tif (g->name)\n\t\tprintf(\"%s draw %s\\n\", __func__, g->name->str);\n\telse\n\t\tprintf(\"%s draw %p\\n\", __func__, g);\n#endif\n\tglMaterialfv(GL_FRONT, GL_SHININESS, &g->mat.shininess);\n\n\tswitch(g->type.type) {\n\t\tcase C3_LIGHT_TYPE: {\n\t\t\tc3light_p l = (c3light_p)g;\n\t\t\tGLuint lid = GL_LIGHT0 + C3APIO_INT(l->light_id);\n\t\t\tglLightfv(lid, GL_POSITION, l->position.n);\n\t\t\tif (c3context_view_get(c)->type != C3_CONTEXT_VIEW_LIGHT)\n\t\t\t\tglEnable(lid);\n\t\t\telse\n\t\t\t\tglDisable(lid);\n\t\t}\tbreak;\n\t}\n\tif (!g->bid) {\n\t\tC3_DRIVER_INHERITED(c, d, geometry_draw, g);\n\t\treturn;\n\t}\n\tglColor4fv(g->mat.color.n);\n\tdumpError(\"glColor\");\n\n\tGLCHECK(glBindVertexArray(C3APIO_INT(g->bid)));\n\n\t//glDisable(GL_TEXTURE_2D);\n\tif (g->mat.texture) {\n\t\tGLuint mode = g->mat.texture->rectangle ? GL_TEXTURE_RECTANGLE_ARB : GL_TEXTURE_2D;\n\t\tglEnable(mode);\n\t\tif (g->mat.texture->trace)\n\t\t\tprintf(\"%s view %d uses texture %s(%d) (%d tex)\\n\",\n\t\t\t\t\t__func__, c->current, g->mat.texture->name->str,\n\t\t\t\t\tC3APIO_INT(g->mat.texture->texture),\n\t\t\t\t\tg->textures.count);\n\t//\tprintf(\"tex mode %d texture %d\\n\", g->mat.mode, g->mat.texture);\n\t\tdumpError(\"glEnable texture\");\n\t\tglBindTexture(mode, C3APIO_INT(g->mat.texture->texture));\n\t\tdumpError(\"glBindTexture\");\n\t}\n\tif (g->mat.program)\n\t\tGLCHECK(glUseProgram(C3APIO_INT(g->mat.program->pid)));\n\n\tif (g->indices.buffer.bid) {\n\t\tGLCHECK(glDrawElements(C3APIO_INT(g->type.subtype),\n\t\t\t\tg->indices.count, GL_UNSIGNED_SHORT,\n\t\t\t\t(void*)NULL /*g->indices.e*/));\n\t} else {\n\t\tglDrawArrays(C3APIO_INT(g->type.subtype), 0, g->vertice.count);\n\t}\n\tglBindVertexArray(0);\n\n\tif (g->mat.texture)\n\t\tglDisable(g->mat.texture->rectangle ? GL_TEXTURE_RECTANGLE_ARB : GL_TEXTURE_2D);\n\tif (g->mat.program)\n\t\tglUseProgram(0);\n\n\tif (g->debug) {\n\t\tif (g->normals.count) {\n\t\t\tfor (int i = 0; i < g->vertice.count; i++) {\n\t\t\t\tc3vec3 o = g->vertice.e[i];\n\t\t\t\tglBegin(GL_LINES);\n\t\t\t\tglColor4f(0.0,0.0,1.0,1.0);\n\t\t\t\tglVertex3fv(o.n);\n\t\t\t\to = c3vec3_add(o, g->normals.e[i]);\n\t\t\t\tglColor4f(1.0,0.0,0.0,1.0);\n\t\t\t\tglVertex3fv(o.n);\n\t\t\t\tglEnd();\n\t\t\t}\n\t\t}\n\t}\n\tif (0) {\t// debug bounding boxes\n\t\tc3vec3\tv[8];\n\t\tc3_bbox_vertices(&g->bbox, v);\n\t\tglColor4f(0.0,0.0,1.0,1.0);\n\t\tglPointSize(5);\n\t\tglBegin(GL_POINTS);\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tglVertex3fv(v[i].n);\n\t\t}\n\t\tglEnd();\n\t}\n\tC3_DRIVER_INHERITED(c, d, geometry_draw, g);\n}", "path": "srcgl\\c3gl.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/***************************** c3arcball_set_constraints() **********/\n", "func_signal": "void\nc3arcball_set_constraints(\n\t\tc3arcballp a,\n\t\tbool _constraint_x,\n\t\tbool _constraint_y)", "code": "{\n    a->constraint_x = _constraint_x;\n    a->constraint_y = _constraint_y;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "// SPECIAL FUNCTIONS;\n", "func_signal": "c3mat4 c3mat4_transpose(const c3mat4p a)", "code": "{\n    return c3mat4_vec4(\n        c3vec4f(a->v[0].n[0], a->v[1].n[0], a->v[2].n[0], a->v[3].n[0]),\n        c3vec4f(a->v[0].n[1], a->v[1].n[1], a->v[2].n[1], a->v[3].n[1]),\n        c3vec4f(a->v[0].n[2], a->v[1].n[2], a->v[2].n[2], a->v[3].n[2]),\n        c3vec4f(a->v[0].n[3], a->v[1].n[3], a->v[2].n[3], a->v[3].n[3]));\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/*************************************** c3arcball_init() **********/\n", "func_signal": "void\nc3arcball_init(\n\t\tc3arcballp a )", "code": "{\n    a->center = c3vec2f( 0.0, 0.0 );\n    a->radius         = 1.0;\n    a->q_now          = c3quat_identity();\n    a->rot_ptr\t\t= &a->rot;\n    a->rot   \t\t= identity3D();\n    a->q_increment    = c3quat_identity();\n    a->rot_increment  = identity3D();\n    a->is_mouse_down  = false;\n    a->is_spinning    = false;\n    a->damp_factor    = 0.0;\n    a->zero_increment = true;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/********************************************* get_axis() **************/\n", "func_signal": "c3vec3\nc3quat_get_axis(\n\t\tc3quatp a)", "code": "{\n    c3f scale = (c3f) sin( acos( a->s ) );\n\n    if ( scale < FUDGE && scale > -FUDGE )\n        return c3vec3f( 0.0, 0.0, 0.0 );\n    else\n        return  c3vec3_divf(a->v, scale);\n}", "path": "src\\c3quaternion.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/***************************** c3arcball_idle() *********************/\n", "func_signal": "void\nc3arcball_idle(\n\t\tc3arcballp a)", "code": "{\n\tif (a->is_mouse_down) {\n\t\ta->is_spinning = false;\n\t\ta->zero_increment = true;\n\t}\n\n\tif (a->damp_factor < 1.0f)\n\t\tc3quat_scale_angle(&a->q_increment, 1.0f - a->damp_factor);\n\n\ta->rot_increment = c3quat_to_mat4(a->q_increment);\n\n\tif (a->q_increment.s >= .999999f) {\n\t\ta->is_spinning = false;\n\t\ta->zero_increment = true;\n\t}\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/************************************ c3arcball_mouse_down() **********/\n", "func_signal": "void\nc3arcball_mouse_down(\n\t\tc3arcballp a,\n\t\tint x,\n\t\tint y)", "code": "{\n    a->down_pt = c3vec2f( (c3f)x, (c3f) y );\n    a->is_mouse_down = true;\n\n    a->q_increment   = c3quat_identity();\n    a->rot_increment = identity3D();\n    a->zero_increment = true;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/*********************************** c3arcball_mouse_to_sphere() ****/\n", "func_signal": "c3vec3\nc3arcball_mouse_to_sphere(\n\t\tc3arcballp a,\n\t\tconst c3vec2 p)", "code": "{\n    c3f mag;\n    c3vec2  v2 = c3vec2_divf(c3vec2_sub(p, a->center), a->radius);\n    c3vec3  v3 = c3vec3f( v2.n[0], v2.n[1], 0.0 );\n\n    mag = c3vec2_dot(v2, v2);\n\n    if ( mag > 1.0 )\n        v3 = c3vec3_normalize(v3);\n    else\n        v3.n[VZ] = (c3f) sqrt( 1.0 - mag );\n\n    /* Now we add constraints - X takes precedence over Y */\n    if ( a->constraint_x ) {\n        v3 = c3arcball_constrain_vector( v3, c3vec3f( 1.0, 0.0, 0.0 ));\n    } else if ( a->constraint_y ) {\n    \tv3 = c3arcball_constrain_vector( v3, c3vec3f( 0.0, 1.0, 0.0 ));\n\t}\n\n    return v3;\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/********************************** c3arcball_mouse_motion() **********/\n", "func_signal": "void\nc3arcball_mouse_motion(\n\t\tc3arcballp a,\n\t\tint x,\n\t\tint y,\n\t\tint shift,\n\t\tint ctrl,\n\t\tint alt)", "code": "{\n    /* Set the X constraint if CONTROL key is pressed, Y if ALT key */\n\tc3arcball_set_constraints(a, ctrl != 0, alt != 0 );\n\n    c3vec2 new_pt = c3vec2f( (c3f)x, (c3f) y );\n    c3vec3 v0 = c3arcball_mouse_to_sphere(a, a->down_pt );\n    c3vec3 v1 = c3arcball_mouse_to_sphere(a, new_pt );\n\n    c3vec3 cross = c3vec3_cross(v0, v1);\n\n    a->q_drag = c3quat_vec3(cross, c3vec3_dot(v0, v1));\n\n    //    *rot_ptr = (q_drag * q_now).to_mat4();\n    c3mat4 temp = c3quat_to_mat4(a->q_drag);\n    *a->rot_ptr = c3mat4_mul(a->rot_ptr, &temp);\n\n    a->down_pt = new_pt;\n\n    /* We keep a copy of the current incremental rotation (= q_drag) */\n    a->q_increment   = a->q_drag;\n    a->rot_increment = c3quat_to_mat4(a->q_increment);\n\n    c3arcball_set_constraints(a, false, false);\n\n\tif (a->q_increment.s < .999999) {\n\t\ta->is_spinning = true;\n\t\ta->zero_increment = false;\n\t} else {\n\t\ta->is_spinning = false;\n\t\ta->zero_increment = true;\n\t}\n}", "path": "src\\c3arcball.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "// FRIENDS\n", "func_signal": "c3mat4 c3mat4_minus(const c3mat4p a)", "code": "{\n    return c3mat4_vec4(\n    \t\tc3vec4_minus(a->v[0]),\n    \t\tc3vec4_minus(a->v[1]),\n    \t\tc3vec4_minus(a->v[2]),\n    \t\tc3vec4_minus(a->v[3]));\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "// CONSTRUCTORS\n", "func_signal": "c3vec4 c3vec4_zero()", "code": "{\n\tc3vec4 n ;//= { .x = 0, .y = 0, .z = 0, .w = 1.0 }; // older gcc <4.6 doesn't like this\n\tn.x = n.y = n.z = 0; n.w = 1.0;\n    return n;\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/*\n * Same as previous, but this one is screen aligned, with 0,0 being top,left\n * instead of bottom,left\n */\n", "func_signal": "c3mat4\tscreen_ortho3D(\n\t\tc3f left, c3f right, c3f bottom, c3f top,\n\t\tc3f near, c3f far)", "code": "{\n\tc3f a = 2.0f / (right - left);\n\tc3f b = 2.0f / (top - bottom);\n\tc3f c = -2.0f / (far - near);\n\n\tc3f tx = - (right + left)/(right - left);\n\tc3f ty = - (top + bottom)/(top - bottom);\n\tc3f tz = - (far + near)/(far - near);\n\n\tfloat ortho[16] = {\n\t\ta, 0, 0, 0,\n\t\t0, -b, 0, 0,\n\t\t0, 0, c, 0,\n\t\ttx, -ty, tz, 1\n\t};\n    return *((c3mat4p)ortho);\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/******************** c3vec2 CONSTRUCTORS ********************/\n", "func_signal": "c3vec2 c3vec2_zero()", "code": "{\n\tc3vec2 n;// = { .x = 0, .y = 0 };// older gcc <4.6 doesn't like this\n\tn.x = n.y = 0;\n    return n;\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "// ASSIGNMENT OPERATORS\n", "func_signal": "c3vec4 c3vec4_add(c3vec4 a, const c3vec4 v)", "code": "{\n    a.n[VX] += v.n[VX];\n    a.n[VY] += v.n[VY];\n    a.n[VZ] += v.n[VZ];\n    a.n[VW] += v.n[VW];\n    return a;\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/******************** c3vec2 ASSIGNMENT OPERATORS ******************/\n", "func_signal": "c3vec2  c3vec2_add(c3vec2 a, const c3vec2 v)", "code": "{\n    a.n[VX] += v.n[VX];\n    a.n[VY] += v.n[VY];\n    return a;\n}", "path": "src\\c3algebra.c", "repo_name": "buserror/libc3", "stars": 24, "license": "lgpl-3.0", "language": "c", "size": 236}
{"docstring": "/* Start a new root trace for down-recursion. */\n", "func_signal": "static int trace_downrec(jit_State *J)", "code": "{\n  /* Restart recording at the return instruction. */\n  lua_assert(J->pt != NULL);\n  lua_assert(bc_isret(bc_op(*J->pc)));\n  if (bc_op(*J->pc) == BC_RETM)\n    return 0;  /* NYI: down-recursion with RETM. */\n  J->parent = 0;\n  J->exitno = 0;\n  J->state = LJ_TRACE_RECORD;\n  trace_start(J);\n  return 1;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* A hotcount triggered. Start recording a root trace. */\n", "func_signal": "void LJ_FASTCALL lj_trace_hot(jit_State *J, const BCIns *pc)", "code": "{\n  /* Note: pc is the interpreter bytecode PC here. It's offset by 1. */\n  ERRNO_SAVE\n  /* Reset hotcount. */\n  hotcount_set(J2GG(J), pc, J->param[JIT_P_hotloop]*HOTCOUNT_LOOP);\n  /* Only start a new trace if not recording or inside __gc call or vmevent. */\n  if (J->state == LJ_TRACE_IDLE &&\n      !(J2G(J)->hookmask & (HOOK_GC|HOOK_VMEVENT))) {\n    J->parent = 0;  /* Root trace. */\n    J->exitno = 0;\n    J->state = LJ_TRACE_START;\n    lj_trace_ins(J, pc-1);\n  }\n  ERRNO_RESTORE\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Flush all traces. */\n", "func_signal": "int lj_trace_flushall(lua_State *L)", "code": "{\n  jit_State *J = L2J(L);\n  ptrdiff_t i;\n  if ((J2G(J)->hookmask & HOOK_GC))\n    return 1;\n  for (i = (ptrdiff_t)J->sizetrace-1; i > 0; i--) {\n    GCtrace *T = traceref(J, i);\n    if (T) {\n      if (T->root == 0)\n\ttrace_flushroot(J, T);\n      lj_gdbjit_deltrace(J, T);\n      T->traceno = 0;\n      setgcrefnull(J->trace[i]);\n    }\n  }\n  J->cur.traceno = 0;\n  J->freetrace = 0;\n  /* Clear penalty cache. */\n  memset(J->penalty, 0, sizeof(J->penalty));\n  /* Free the whole machine code and invalidate all exit stub groups. */\n  lj_mcode_free(J);\n  memset(J->exitstubgroup, 0, sizeof(J->exitstubgroup));\n  lj_vmevent_send(L, TRACE,\n    setstrV(L, L->top++, lj_str_newlit(L, \"flush\"));\n  );\n  return 0;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* A trace exited. Restore interpreter state. */\n", "func_signal": "int LJ_FASTCALL lj_trace_exit(jit_State *J, void *exptr)", "code": "{\n  ERRNO_SAVE\n  lua_State *L = J->L;\n  ExitState *ex = (ExitState *)exptr;\n  ExitDataCP exd;\n  int errcode;\n  const BCIns *pc;\n  void *cf;\n  GCtrace *T;\n#ifdef EXITSTATE_PCREG\n  J->parent = trace_exit_find(J, (MCode *)(intptr_t)ex->gpr[EXITSTATE_PCREG]);\n#endif\n  T = traceref(J, J->parent); UNUSED(T);\n#ifdef EXITSTATE_CHECKEXIT\n  if (J->exitno == T->nsnap) {  /* Treat stack check like a parent exit. */\n    lua_assert(T->root != 0);\n    J->exitno = T->ir[REF_BASE].op2;\n    J->parent = T->ir[REF_BASE].op1;\n    T = traceref(J, J->parent);\n  }\n#endif\n  lua_assert(T != NULL && J->exitno < T->nsnap);\n  exd.J = J;\n  exd.exptr = exptr;\n  errcode = lj_vm_cpcall(L, NULL, &exd, trace_exit_cp);\n  if (errcode)\n    return -errcode;  /* Return negated error code. */\n\n  lj_vmevent_send(L, TEXIT,\n    lj_state_checkstack(L, 4+RID_NUM_GPR+RID_NUM_FPR+LUA_MINSTACK);\n    setintV(L->top++, J->parent);\n    setintV(L->top++, J->exitno);\n    trace_exit_regs(L, ex);\n  );\n\n  pc = exd.pc;\n  cf = cframe_raw(L->cframe);\n  setcframe_pc(cf, pc);\n  if (G(L)->gc.state == GCSatomic || G(L)->gc.state == GCSfinalize) {\n    if (!(G(L)->hookmask & HOOK_GC))\n      lj_gc_step(L);  /* Exited because of GC: drive GC forward. */\n  } else {\n    trace_hotside(J, pc);\n  }\n  if (bc_op(*pc) == BC_JLOOP) {\n    BCIns *retpc = &traceref(J, bc_d(*pc))->startins;\n    if (bc_isret(bc_op(*retpc))) {\n      if (J->state == LJ_TRACE_RECORD) {\n\tJ->patchins = *pc;\n\tJ->patchpc = (BCIns *)pc;\n\t*J->patchpc = *retpc;\n\tJ->bcskip = 1;\n      } else {\n\tpc = retpc;\n\tsetcframe_pc(cf, pc);\n      }\n    }\n  }\n  /* Return MULTRES or 0. */\n  ERRNO_RESTORE\n  switch (bc_op(*pc)) {\n  case BC_CALLM: case BC_CALLMT:\n    return (int)((BCReg)(L->top - L->base) - bc_a(*pc) - bc_c(*pc));\n  case BC_RETM:\n    return (int)((BCReg)(L->top - L->base) + 1 - bc_a(*pc) - bc_d(*pc));\n  case BC_TSETM:\n    return (int)((BCReg)(L->top - L->base) + 1 - bc_a(*pc));\n  default:\n    if (bc_op(*pc) >= BC_FUNCF)\n      return (int)((BCReg)(L->top - L->base) + 1);\n    return 0;\n  }\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Find a free trace number. */\n", "func_signal": "static TraceNo trace_findfree(jit_State *J)", "code": "{\n  MSize osz, lim;\n  if (J->freetrace == 0)\n    J->freetrace = 1;\n  for (; J->freetrace < J->sizetrace; J->freetrace++)\n    if (traceref(J, J->freetrace) == NULL)\n      return J->freetrace++;\n  /* Need to grow trace array. */\n  lim = (MSize)J->param[JIT_P_maxtrace] + 1;\n  if (lim < 2) lim = 2; else if (lim > 65535) lim = 65535;\n  osz = J->sizetrace;\n  if (osz >= lim)\n    return 0;  /* Too many traces. */\n  lj_mem_growvec(J->L, J->trace, J->sizetrace, lim, GCRef);\n  for (; osz < J->sizetrace; osz++)\n    setgcrefnull(J->trace[osz]);\n  return J->freetrace;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Determine trace number from pc of exit instruction. */\n", "func_signal": "static TraceNo trace_exit_find(jit_State *J, MCode *pc)", "code": "{\n  TraceNo traceno;\n  for (traceno = 1; traceno < J->sizetrace; traceno++) {\n    GCtrace *T = traceref(J, traceno);\n    if (T && pc >= T->mcode && pc < (MCode *)((char *)T->mcode + T->szmcode))\n      return traceno;\n  }\n  lua_assert(0);\n  return 0;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Start tracing. */\n", "func_signal": "static void trace_start(jit_State *J)", "code": "{\n  lua_State *L;\n  TraceNo traceno;\n\n  if ((J->pt->flags & PROTO_NOJIT)) {  /* JIT disabled for this proto? */\n    if (J->parent == 0) {\n      /* Lazy bytecode patching to disable hotcount events. */\n      lua_assert(bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL ||\n\t\t bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF);\n      setbc_op(J->pc, (int)bc_op(*J->pc)+(int)BC_ILOOP-(int)BC_LOOP);\n      J->pt->flags |= PROTO_ILOOP;\n    }\n    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */\n    return;\n  }\n\n  /* Get a new trace number. */\n  traceno = trace_findfree(J);\n  if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */\n    lua_assert((J2G(J)->hookmask & HOOK_GC) == 0);\n    lj_trace_flushall(J->L);\n    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */\n    return;\n  }\n  setgcrefp(J->trace[traceno], &J->cur);\n\n  /* Setup enough of the current trace to be able to send the vmevent. */\n  memset(&J->cur, 0, sizeof(GCtrace));\n  J->cur.traceno = traceno;\n  J->cur.nins = J->cur.nk = REF_BASE;\n  J->cur.ir = J->irbuf;\n  J->cur.snap = J->snapbuf;\n  J->cur.snapmap = J->snapmapbuf;\n  J->mergesnap = 0;\n  J->needsnap = 0;\n  J->bcskip = 0;\n  J->guardemit.irt = 0;\n  J->postproc = LJ_POST_NONE;\n  lj_resetsplit(J);\n  setgcref(J->cur.startpt, obj2gco(J->pt));\n\n  L = J->L;\n  lj_vmevent_send(L, TRACE,\n    setstrV(L, L->top++, lj_str_newlit(L, \"start\"));\n    setintV(L->top++, traceno);\n    setfuncV(L, L->top++, J->fn);\n    setintV(L->top++, proto_bcpos(J->pt, J->pc));\n    if (J->parent) {\n      setintV(L->top++, J->parent);\n      setintV(L->top++, J->exitno);\n    }\n  );\n  lj_record_setup(J);\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Save current trace by copying and compacting it. */\n", "func_signal": "static void trace_save(jit_State *J)", "code": "{\n  size_t sztr = ((sizeof(GCtrace)+7)&~7);\n  size_t szins = (J->cur.nins-J->cur.nk)*sizeof(IRIns);\n  size_t sz = sztr + szins +\n\t      J->cur.nsnap*sizeof(SnapShot) +\n\t      J->cur.nsnapmap*sizeof(SnapEntry);\n  GCtrace *T = lj_mem_newt(J->L, (MSize)sz, GCtrace);\n  char *p = (char *)T + sztr;\n  memcpy(T, &J->cur, sizeof(GCtrace));\n  setgcrefr(T->nextgc, J2G(J)->gc.root);\n  setgcrefp(J2G(J)->gc.root, T);\n  newwhite(J2G(J), T);\n  T->gct = ~LJ_TTRACE;\n  T->ir = (IRIns *)p - J->cur.nk;\n  memcpy(p, J->cur.ir+J->cur.nk, szins);\n  p += szins;\n  TRACE_APPENDVEC(snap, nsnap, SnapShot)\n  TRACE_APPENDVEC(snapmap, nsnapmap, SnapEntry)\n  J->cur.traceno = 0;\n  setgcrefp(J->trace[T->traceno], T);\n  lj_gc_barriertrace(J2G(J), T->traceno);\n  lj_gdbjit_addtrace(J, T);\n#ifdef LUAJIT_USE_PERFTOOLS\n  perftools_addtrace(T);\n#endif\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Synchronous abort with error message and error info. */\n", "func_signal": "void lj_trace_err_info(jit_State *J, TraceError e)", "code": "{\n  setintV(J->L->top++, (int32_t)e);\n  lj_err_throw(J->L, LUA_ERRRUN);\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Flush a trace. Only root traces are considered. */\n", "func_signal": "void lj_trace_flush(jit_State *J, TraceNo traceno)", "code": "{\n  if (traceno > 0 && traceno < J->sizetrace) {\n    GCtrace *T = traceref(J, traceno);\n    if (T && T->root == 0)\n      trace_flushroot(J, T);\n  }\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Blacklist a bytecode instruction. */\n", "func_signal": "static void blacklist_pc(GCproto *pt, BCIns *pc)", "code": "{\n  setbc_op(pc, (int)bc_op(*pc)+(int)BC_ILOOP-(int)BC_LOOP);\n  pt->flags |= PROTO_ILOOP;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Penalize a bytecode instruction. */\n", "func_signal": "static void penalty_pc(jit_State *J, GCproto *pt, BCIns *pc, TraceError e)", "code": "{\n  uint32_t i, val = PENALTY_MIN;\n  for (i = 0; i < PENALTY_SLOTS; i++)\n    if (mref(J->penalty[i].pc, const BCIns) == pc) {  /* Cache slot found? */\n      /* First try to bump its hotcount several times. */\n      val = ((uint32_t)J->penalty[i].val << 1) +\n\t    LJ_PRNG_BITS(J, PENALTY_RNDBITS);\n      if (val > PENALTY_MAX) {\n\tblacklist_pc(pt, pc);  /* Blacklist it, if that didn't help. */\n\treturn;\n      }\n      goto setpenalty;\n    }\n  /* Assign a new penalty cache slot. */\n  i = J->penaltyslot;\n  J->penaltyslot = (J->penaltyslot + 1) & (PENALTY_SLOTS-1);\n  setmref(J->penalty[i].pc, pc);\nsetpenalty:\n  J->penalty[i].val = (uint16_t)val;\n  J->penalty[i].reason = e;\n  hotcount_set(J2GG(J), pc+1, val);\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/**\n * Wrapper of nginx log functionality. Take a log level param and varargs of\n * log message params.\n *\n * @param L Lua state pointer\n * @retval always 0 (don't return values to Lua)\n * */\n", "func_signal": "int\nngx_http_lua_ngx_log(lua_State *L)", "code": "{\n    ngx_log_t                   *log;\n    ngx_http_request_t          *r;\n    const char                  *msg;\n    int level = luaL_checkint(L, 1);\n    \n    lua_pushlightuserdata(L, &ngx_http_lua_request_key);\n    lua_rawget(L, LUA_GLOBALSINDEX);\n    r = lua_touserdata(L, -1);\n    lua_pop(L, 1);\n\n    if (r && r->connection && r->connection->log) {\n        log = r->connection->log;\n\n    } else {\n        lua_pushlightuserdata(L, &ngx_http_lua_cf_log_key);\n        lua_rawget(L, LUA_REGISTRYINDEX);\n        log = lua_touserdata(L, -1);\n        lua_pop(L, 1);\n    }\n\n    if (level < NGX_LOG_STDERR || level > NGX_LOG_DEBUG) {\n        msg = lua_pushfstring(L, \"bad log level: %d\", level);\n        return luaL_argerror(L, 1, msg);\n    }\n\n    /* remove log-level param from stack */\n    lua_remove(L, 1);\n\n    return log_wrapper(log, \"[lua] \", (ngx_uint_t) level, L);\n}", "path": "ngx_lua-0.5.14\\src\\ngx_http_lua_log.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Re-enable compiling a prototype by unpatching any modified bytecode. */\n", "func_signal": "void lj_trace_reenableproto(GCproto *pt)", "code": "{\n  if ((pt->flags & PROTO_ILOOP)) {\n    BCIns *bc = proto_bc(pt);\n    BCPos i, sizebc = pt->sizebc;;\n    pt->flags &= ~PROTO_ILOOP;\n    if (bc_op(bc[0]) == BC_IFUNCF)\n      setbc_op(&bc[0], BC_FUNCF);\n    for (i = 1; i < sizebc; i++) {\n      BCOp op = bc_op(bc[i]);\n      if (op == BC_IFORL || op == BC_IITERL || op == BC_ILOOP)\n\tsetbc_op(&bc[i], (int)op+(int)BC_LOOP-(int)BC_ILOOP);\n    }\n  }\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* State machine for the trace compiler. Protected callback. */\n", "func_signal": "static TValue *trace_state(lua_State *L, lua_CFunction dummy, void *ud)", "code": "{\n  jit_State *J = (jit_State *)ud;\n  UNUSED(dummy);\n  do {\n  retry:\n    switch (J->state) {\n    case LJ_TRACE_START:\n      J->state = LJ_TRACE_RECORD;  /* trace_start() may change state. */\n      trace_start(J);\n      lj_dispatch_update(J2G(J));\n      break;\n\n    case LJ_TRACE_RECORD:\n      trace_pendpatch(J, 0);\n      setvmstate(J2G(J), RECORD);\n      lj_vmevent_send_(L, RECORD,\n\t/* Save/restore tmptv state for trace recorder. */\n\tTValue savetv = J2G(J)->tmptv;\n\tTValue savetv2 = J2G(J)->tmptv2;\n\tsetintV(L->top++, J->cur.traceno);\n\tsetfuncV(L, L->top++, J->fn);\n\tsetintV(L->top++, J->pt ? (int32_t)proto_bcpos(J->pt, J->pc) : -1);\n\tsetintV(L->top++, J->framedepth);\n      ,\n\tJ2G(J)->tmptv = savetv;\n\tJ2G(J)->tmptv2 = savetv2;\n      );\n      lj_record_ins(J);\n      break;\n\n    case LJ_TRACE_END:\n      trace_pendpatch(J, 1);\n      J->loopref = 0;\n      if ((J->flags & JIT_F_OPT_LOOP) &&\n\t  J->cur.link == J->cur.traceno && J->framedepth + J->retdepth == 0) {\n\tsetvmstate(J2G(J), OPT);\n\tlj_opt_dce(J);\n\tif (lj_opt_loop(J)) {  /* Loop optimization failed? */\n\t  J->cur.link = 0;\n\t  J->cur.linktype = LJ_TRLINK_NONE;\n\t  J->loopref = J->cur.nins;\n\t  J->state = LJ_TRACE_RECORD;  /* Try to continue recording. */\n\t  break;\n\t}\n\tJ->loopref = J->chain[IR_LOOP];  /* Needed by assembler. */\n      }\n      lj_opt_split(J);\n      J->state = LJ_TRACE_ASM;\n      break;\n\n    case LJ_TRACE_ASM:\n      setvmstate(J2G(J), ASM);\n      lj_asm_trace(J, &J->cur);\n      trace_stop(J);\n      setvmstate(J2G(J), INTERP);\n      J->state = LJ_TRACE_IDLE;\n      lj_dispatch_update(J2G(J));\n      return NULL;\n\n    default:  /* Trace aborted asynchronously. */\n      setintV(L->top++, (int32_t)LJ_TRERR_RECERR);\n      /* fallthrough */\n    case LJ_TRACE_ERR:\n      trace_pendpatch(J, 1);\n      if (trace_abort(J))\n\tgoto retry;\n      setvmstate(J2G(J), INTERP);\n      J->state = LJ_TRACE_IDLE;\n      lj_dispatch_update(J2G(J));\n      return NULL;\n    }\n  } while (J->state > LJ_TRACE_RECORD);\n  return NULL;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/**\n * Override Lua print function, output message to nginx error logs. Equal to\n * ngx.log(ngx.ERR, ...).\n *\n * @param L Lua state pointer\n * @retval always 0 (don't return values to Lua)\n * */\n", "func_signal": "int\nngx_http_lua_print(lua_State *L)", "code": "{\n    ngx_log_t                   *log;\n    ngx_http_request_t          *r;\n\n    lua_pushlightuserdata(L, &ngx_http_lua_request_key);\n    lua_rawget(L, LUA_GLOBALSINDEX);\n    r = lua_touserdata(L, -1);\n    lua_pop(L, 1);\n\n    if (r && r->connection && r->connection->log) {\n        log = r->connection->log;\n\n    } else {\n        lua_pushlightuserdata(L, &ngx_http_lua_cf_log_key);\n        lua_rawget(L, LUA_REGISTRYINDEX);\n        log = lua_touserdata(L, -1);\n        lua_pop(L, 1);\n    }\n\n    return log_wrapper(log, \"[lua] \", NGX_LOG_NOTICE, L);\n}", "path": "ngx_lua-0.5.14\\src\\ngx_http_lua_log.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Abort tracing. */\n", "func_signal": "static int trace_abort(jit_State *J)", "code": "{\n  lua_State *L = J->L;\n  TraceError e = LJ_TRERR_RECERR;\n  TraceNo traceno;\n\n  J->postproc = LJ_POST_NONE;\n  lj_mcode_abort(J);\n  if (tvisnumber(L->top-1))\n    e = (TraceError)numberVint(L->top-1);\n  if (e == LJ_TRERR_MCODELM) {\n    L->top--;  /* Remove error object */\n    J->state = LJ_TRACE_ASM;\n    return 1;  /* Retry ASM with new MCode area. */\n  }\n  /* Penalize or blacklist starting bytecode instruction. */\n  if (J->parent == 0 && !bc_isret(bc_op(J->cur.startins)))\n    penalty_pc(J, &gcref(J->cur.startpt)->pt, mref(J->cur.startpc, BCIns), e);\n\n  /* Is there anything to abort? */\n  traceno = J->cur.traceno;\n  if (traceno) {\n    ptrdiff_t errobj = savestack(L, L->top-1);  /* Stack may be resized. */\n    J->cur.link = 0;\n    J->cur.linktype = LJ_TRLINK_NONE;\n    lj_vmevent_send(L, TRACE,\n      TValue *frame;\n      const BCIns *pc;\n      GCfunc *fn;\n      setstrV(L, L->top++, lj_str_newlit(L, \"abort\"));\n      setintV(L->top++, traceno);\n      /* Find original Lua function call to generate a better error message. */\n      frame = J->L->base-1;\n      pc = J->pc;\n      while (!isluafunc(frame_func(frame))) {\n\tpc = (frame_iscont(frame) ? frame_contpc(frame) : frame_pc(frame)) - 1;\n\tframe = frame_prev(frame);\n      }\n      fn = frame_func(frame);\n      setfuncV(L, L->top++, fn);\n      setintV(L->top++, proto_bcpos(funcproto(fn), pc));\n      copyTV(L, L->top++, restorestack(L, errobj));\n      copyTV(L, L->top++, &J->errinfo);\n    );\n    /* Drop aborted trace after the vmevent (which may still access it). */\n    setgcrefnull(J->trace[traceno]);\n    if (traceno < J->freetrace)\n      J->freetrace = traceno;\n    J->cur.traceno = 0;\n  }\n  L->top--;  /* Remove error object */\n  if (e == LJ_TRERR_DOWNREC)\n    return trace_downrec(J);\n  else if (e == LJ_TRERR_MCODEAL)\n    lj_trace_flushall(L);\n  return 0;\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Push all registers from exit state. */\n", "func_signal": "static void trace_exit_regs(lua_State *L, ExitState *ex)", "code": "{\n  int32_t i;\n  setintV(L->top++, RID_NUM_GPR);\n  setintV(L->top++, RID_NUM_FPR);\n  for (i = 0; i < RID_NUM_GPR; i++) {\n    if (sizeof(ex->gpr[i]) == sizeof(int32_t))\n      setintV(L->top++, (int32_t)ex->gpr[i]);\n    else\n      setnumV(L->top++, (lua_Number)ex->gpr[i]);\n  }\n#if !LJ_SOFTFP\n  for (i = 0; i < RID_NUM_FPR; i++) {\n    setnumV(L->top, ex->fpr[i]);\n    if (LJ_UNLIKELY(tvisnan(L->top)))\n      setnanV(L->top);\n    L->top++;\n  }\n#endif\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Unpatch the bytecode modified by a root trace. */\n", "func_signal": "static void trace_unpatch(jit_State *J, GCtrace *T)", "code": "{\n  BCOp op = bc_op(T->startins);\n  BCIns *pc = mref(T->startpc, BCIns);\n  UNUSED(J);\n  if (op == BC_JMP)\n    return;  /* No need to unpatch branches in parent traces (yet). */\n  switch (bc_op(*pc)) {\n  case BC_JFORL:\n    lua_assert(traceref(J, bc_d(*pc)) == T);\n    *pc = T->startins;\n    pc += bc_j(T->startins);\n    lua_assert(bc_op(*pc) == BC_JFORI);\n    setbc_op(pc, BC_FORI);\n    break;\n  case BC_JITERL:\n  case BC_JLOOP:\n    lua_assert(op == BC_ITERL || op == BC_LOOP || bc_isret(op));\n    *pc = T->startins;\n    break;\n  case BC_JMP:\n    lua_assert(op == BC_ITERL);\n    pc += bc_j(*pc)+2;\n    if (bc_op(*pc) == BC_JITERL) {\n      lua_assert(traceref(J, bc_d(*pc)) == T);\n      *pc = T->startins;\n    }\n    break;\n  case BC_JFUNCF:\n    lua_assert(op == BC_FUNCF);\n    *pc = T->startins;\n    break;\n  default:  /* Already unpatched. */\n    break;\n  }\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* Check for a hot side exit. If yes, start recording a side trace. */\n", "func_signal": "static void trace_hotside(jit_State *J, const BCIns *pc)", "code": "{\n  SnapShot *snap = &traceref(J, J->parent)->snap[J->exitno];\n  if (!(J2G(J)->hookmask & (HOOK_GC|HOOK_VMEVENT)) &&\n      snap->count != SNAPCOUNT_DONE &&\n      ++snap->count >= J->param[JIT_P_hotexit]) {\n    lua_assert(J->state == LJ_TRACE_IDLE);\n    /* J->parent is non-zero for a side trace. */\n    J->state = LJ_TRACE_START;\n    lj_trace_ins(J, pc);\n  }\n}", "path": "LuaJIT-2.0.0-beta10\\src\\lj_trace.c", "repo_name": "moonbingbing/openresty_windows", "stars": 16, "license": "None", "language": "c", "size": 41012}
{"docstring": "/* This entity operation function generates secondary database closures. */\n", "func_signal": "static void\nclose_secondary_test_idxop(DB_INDEX *idx)", "code": "{\n\tpr_test(\n\"if (%s_dbp != NULL)                                                       \\n\\\n %s_dbp->close(%s_dbp, 0);                                                 \\n\\\n\t\t\t\t\t\t\t\t\t   \\n\\\n\",\n\t    idx->name, idx->name, idx->name);\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * This next group of entity and attribute operation functions are\n * called by the attribute iterator when generating retrieval test code\n */\n", "func_signal": "static void\nretrieval_test_enter_entop(ENTITY *e)", "code": "{\n\tpr_test(\"\\nprintf(\\\"Retrieval of %s record by key\\\\n\\\");\\n\", e->name);\n\tpr_test(\"ret = get_%s_data( %s_dbp, %s%s%s, &%s_record);\\n\\n\",\n\t    e->name, e->name,\n\t    e->transactional ? the_schema.environment.name : \"\",\n\t    e->transactional ? \"_txnp, \" : \"\",\n\t    data_value_for_type(e->primary_key->type), e->name);\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * usage --\n *\tDisplay the usage message.\n */\n", "func_signal": "int\nusage()", "code": "{\n\t(void)fprintf(stderr, \"usage: db_dump185 [-p] [-f file] db_file\\n\");\n\treturn (EXIT_FAILURE);\n}", "path": "deps\\db-5.1.25\\util\\db_dump185.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * This next group of index and attribute operation functions are\n * called by the attribute iterator when generating the iteration\n * callback function.\n */\n", "func_signal": "static void\ncallback_function_attrop(ENTITY *e, ATTRIBUTE *a, int first, int last)", "code": "{\n\tCOMPQUIET(first, 0);\n\tCOMPQUIET(last, 0);\n\n\tpr_test(\"printf(\\\"%s->%s: \", e->name, a->name);\n\n\tpr_test(\"%s\", format_string_for_type(a->type));\n\n\tif (is_array(a->type) && !is_string(a->type)) {\n\t\tpr_test(\"\\\\n\\\", compare_binary(%s_record->%s, %s));\\n\",\n\t\t    e->name, a->name, array_dim_name(e, a) );\n\t} else {\n\t\tpr_test(\"\\\\n\\\", %s_record->%s);\\n\", e->name, a->name);\n\t}\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * Return the appropriate printf format string for the given type.\n */\n", "func_signal": "static char *\nformat_string_for_type(ATTR_TYPE *t)", "code": "{\n\tchar *c_type = t->c_type;\n\n\tif (is_array(t)) {\n\t\treturn (\"%s\");\n\t} else if (strcmp(c_type, \"char\") == 0 ||\n\t    strcmp(c_type, \"short\") == 0 ||\n\t    strcmp(c_type, \"int\") == 0) {\n\t\treturn (\"%d\");\n\t} else  if (strcmp(c_type, \"long\") == 0) {\n\t\treturn (\"%ld\");\n\t} else if (strcmp(c_type, \"float\") == 0) {\n\t\treturn (\"%f\");\n\t} else if (strcmp(c_type, \"double\") == 0) {\n\t\treturn (\"%lf\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Unexpected C type in schema: %s\", c_type);\n\t\tassert(0);\n\t}\n\treturn NULL; /*NOTREACHED*/\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * tm_mutex_init --\n *\tInitialize the mutexes.\n */\n", "func_signal": "void\ntm_mutex_init()", "code": "{\n\tTM *mp;\n\tu_int i;\n\tint err;\n\n\tif (verbose)\n\t\tprintf(\"Allocate the global mutex: \");\n\tmp = (TM *)gm_addr;\n\tif ((err = dbenv->mutex_alloc(dbenv, 0, &mp->mutex)) != 0) {\n\t\tfprintf(stderr, \"%s: DB_ENV->mutex_alloc (global): %s\\n\",\n\t\t    progname, db_strerror(err));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (verbose)\n\t\tprintf(\"%lu\\n\", (u_long)mp->mutex);\n\n\tif (verbose)\n\t\tprintf(\n\t\t    \"Allocate %d per-thread, self-blocking mutexes: \",\n\t\t    nthreads * nprocs);\n\tfor (i = 0; i < nthreads * nprocs; ++i) {\n\t\tmp = (TM *)(tm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_alloc(\n\t\t    dbenv, DB_MUTEX_SELF_BLOCK, &mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_alloc (per-thread %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif ((err = dbenv->mutex_lock(dbenv, mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_lock (per-thread %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (verbose)\n\t\t\tprintf(\"%lu \", (u_long)mp->mutex);\n\t}\n\tif (verbose)\n\t\tprintf(\"\\n\");\n\n\tif (verbose)\n\t\tprintf(\"Allocate %d per-lock mutexes: \", maxlocks);\n\tfor (i = 0; i < maxlocks; ++i) {\n\t\tmp = (TM *)(lm_addr + i * sizeof(TM));\n\t\tif ((err = dbenv->mutex_alloc(dbenv, 0, &mp->mutex)) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: DB_ENV->mutex_alloc (per-lock: %d): %s\\n\",\n\t\t\t    progname, i, db_strerror(err));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (verbose)\n\t\t\tprintf(\"%lu \", (u_long)mp->mutex);\n\t}\n\tif (verbose)\n\t\tprintf(\"\\n\");\n}", "path": "deps\\db-5.1.25\\src\\mutex\\test_mutex.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * tm_env_init --\n *\tCreate the backing database environment.\n */\n", "func_signal": "int\ntm_env_init()", "code": "{\n\tu_int32_t flags;\n\tint ret;\n\tchar *home;\n\n\t/*\n\t * Create an environment object and initialize it for error\n\t * reporting.\n\t */\n\tif ((ret = db_env_create(&dbenv, 0)) != 0) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, db_strerror(ret));\n\t\treturn (1);\n\t}\n\tenv = dbenv->env;\n\tdbenv->set_errfile(dbenv, stderr);\n\tdbenv->set_errpfx(dbenv, progname);\n\n\t/* Allocate enough mutexes. */\n\tif ((ret = dbenv->mutex_set_increment(dbenv,\n\t    1 + nthreads * nprocs + maxlocks)) != 0) {\n\t\tdbenv->err(dbenv, ret, \"dbenv->mutex_set_increment\");\n\t\treturn (1);\n\t}\n\n\tflags = DB_CREATE;\n\tif (nprocs == 1) {\n\t\thome = NULL;\n\t\tflags |= DB_PRIVATE;\n\t} else\n\t\thome = TESTDIR;\n\tif (nthreads != 1)\n\t\tflags |= DB_THREAD;\n\tif ((ret = dbenv->open(dbenv, home, flags, 0)) != 0) {\n\t\tdbenv->err(dbenv, ret, \"environment open: %s\", home);\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}", "path": "deps\\db-5.1.25\\src\\mutex\\test_mutex.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/* This entity operation function generates primary database closures. */\n", "func_signal": "static void\nremove_primary_test_enter_entop(ENTITY *e)", "code": "{\n\tpr_test(\"remove_%s_database(%s_envp%s%s%s);\\n\", e->name,\n\t    the_schema.environment.name,\n\t    e->transactional ? \", \" : \"\",\n\t    e->transactional ? the_schema.environment.name : \"\",\n\t    e->transactional ? \"_txnp\" : \"\");\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * usage --\n *\n */\n", "func_signal": "int\nusage()", "code": "{\n\tfprintf(stderr, \"usage: %s %s\\n\\t%s\\n\", progname,\n\t    \"[-v] [-l maxlocks]\",\n\t    \"[-n locks] [-p procs] [-T locker=ID|wakeup=ID] [-t threads]\");\n\treturn (EXIT_FAILURE);\n}", "path": "deps\\db-5.1.25\\src\\mutex\\test_mutex.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * Return a data literal appropriate for the given type, to use as test data.\n */\n", "func_signal": "static char *\ndata_value_for_type(ATTR_TYPE *t)", "code": "{\n\tchar *c_type = t->c_type;\n\n\tif (is_string(t)) {\n\t\t/* If the field is really short, use a tiny string */\n\t\tif (t->array_dim < 12)\n\t\t\treturn (\"\\\"n\\\"\");\n\t\treturn (\"\\\"ninety-nine\\\"\");\n\t} else if (is_array(t)) {\n\t\treturn (\"binary_data\");\n\t} else if (strcmp(c_type, \"char\") == 0 ||\n\t    strcmp(c_type, \"short\") == 0 ||\n\t    strcmp(c_type, \"int\") == 0 ||\n\t    strcmp(c_type, \"long\") == 0) {\n\t\treturn (\"99\");\n\t} else if (strcmp(c_type, \"float\") == 0 ||\n\t    strcmp(c_type, \"double\") == 0) {\n\t\treturn (\"99.5\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Unexpected C type in schema: %s\", c_type);\n\t\tassert(0);\n\t}\n\treturn NULL; /*NOTREACHED*/\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * __env_struct_sig --\n *\tCompute signature of structures.\n *\n * PUBLIC: u_int32_t __env_struct_sig __P((void));\n */\n", "func_signal": "u_int32_t\n__env_struct_sig()", "code": "{\n\tu_short t[__STRUCTURE_COUNT + 5];\n\tu_int i;\n\n\ti = 0;\n#define\t__ADD(s)\t(t[i++] = sizeof(struct s))\n\n\t__ADD(__db_dbt);\n#ifdef\tHAVE_MUTEX_SUPPORT\n\t__ADD(__db_mutex_stat);\n#endif\n\t__ADD(__db_lock_stat);\n\t__ADD(__db_lock_hstat);\n\t__ADD(__db_lock_pstat);\n\t__ADD(__db_ilock);\n\t__ADD(__db_lock_u);\n\t__ADD(__db_lockreq);\n\t__ADD(__db_lsn);\n\t__ADD(__db_log_cursor);\n\t__ADD(__db_log_stat);\n\t__ADD(__log_rec_spec);\n\t__ADD(__db_mpoolfile);\n\t__ADD(__db_mpool_stat);\n\t__ADD(__db_mpool_fstat);\n\t__ADD(__db_txn);\n\t__ADD(__kids);\n\t__ADD(__my_cursors);\n\t__ADD(__femfs);\n\t__ADD(__db_preplist);\n\t__ADD(__db_txn_active);\n\t__ADD(__db_txn_stat);\n\t__ADD(__db_txn_token);\n\t__ADD(__db_repmgr_site);\n\t__ADD(__db_rep_stat);\n\t__ADD(__db_repmgr_stat);\n\t__ADD(__db_seq_record);\n\t__ADD(__db_sequence);\n\t__ADD(__db_seq_stat);\n\t__ADD(__db);\n\t__ADD(__cq_fq);\n\t__ADD(__cq_aq);\n\t__ADD(__cq_jq);\n\t__ADD(__dbc);\n\t__ADD(__key_range);\n\t__ADD(__db_bt_stat);\n\t__ADD(__db_compact);\n\t__ADD(__db_h_stat);\n\t__ADD(__db_qam_stat);\n\t__ADD(__db_env);\n\t__ADD(__db_distab);\n\t__ADD(__db_logvrfy_config);\n\t__ADD(__fn);\n\t__ADD(__db_msgbuf);\n\t__ADD(__pin_list);\n\t__ADD(__db_thread_info);\n\t__ADD(__env_thread_info);\n\t__ADD(__flag_map);\n\t__ADD(__env);\n\t__ADD(__dbc_internal);\n\t__ADD(__dbpginfo);\n\t__ADD(__epg);\n\t__ADD(__cursor);\n\t__ADD(__btree);\n\t__ADD(__db_cipher);\n\t__ADD(__db_foreign_info);\n\t__ADD(__db_txnhead);\n\t__ADD(__db_txnlist);\n\t__ADD(__join_cursor);\n\t__ADD(__pg_chksum);\n\t__ADD(__pg_crypto);\n\t__ADD(__pglist);\n\t__ADD(__vrfy_dbinfo);\n\t__ADD(__vrfy_pageinfo);\n\t__ADD(__vrfy_childinfo);\n\t__ADD(__db_globals);\n\t__ADD(__db_lockregion);\n\t__ADD(__sh_dbt);\n\t__ADD(__db_lockobj);\n\t__ADD(__db_locker);\n\t__ADD(__db_lockpart);\n\t__ADD(__db_locktab);\n\t__ADD(__db_lock);\n\t__ADD(__db_entry);\n\t__ADD(__fname);\n\t__ADD(__db_log);\n\t__ADD(__hdr);\n\t__ADD(__log_persist);\n\t__ADD(__log);\n\t__ADD(__db_commit);\n\t__ADD(__db_filestart);\n\t__ADD(__log_rec_hdr);\n\t__ADD(__db_log_verify_info);\n\t__ADD(__txn_verify_info);\n\t__ADD(__lv_filereg_info);\n\t__ADD(__lv_filelife);\n\t__ADD(__lv_ckp_info);\n\t__ADD(__lv_timestamp_info);\n\t__ADD(__lv_txnrange);\n\t__ADD(__add_recycle_params);\n\t__ADD(__ckp_verify_params);\n\t__ADD(__db_mpool);\n\t__ADD(__db_mpreg);\n\t__ADD(__mpool);\n\t__ADD(__db_mpool_hash);\n\t__ADD(__mpoolfile);\n\t__ADD(__bh);\n\t__ADD(__bh_frozen_p);\n\t__ADD(__bh_frozen_a);\n#ifdef\tHAVE_MUTEX_SUPPORT\n\t__ADD(__db_mutexmgr);\n#endif\n#ifdef\tHAVE_MUTEX_SUPPORT\n\t__ADD(__db_mutexregion);\n#endif\n#ifdef\tHAVE_MUTEX_SUPPORT\n\t__ADD(__db_mutex_t);\n#endif\n\t__ADD(__fh_t);\n\t__ADD(__db_partition);\n\t__ADD(__part_internal);\n\t__ADD(__qcursor);\n\t__ADD(__mpfarray);\n\t__ADD(__qmpf);\n\t__ADD(__queue);\n\t__ADD(__qam_filelist);\n\t__ADD(__db_reg_env_ref);\n\t__ADD(__db_reg_env);\n\t__ADD(__db_region);\n\t__ADD(__db_reginfo_t);\n\t__ADD(__rep);\n\t__ADD(__rep_waiter);\n\t__ADD(__db_rep);\n\t__ADD(__rep_lease_entry);\n\t__ADD(__txn_detail);\n\t__ADD(__db_txnmgr);\n\t__ADD(__db_txnregion);\n\t__ADD(__db_commit_info);\n\t__ADD(__txn_logrec);\n\n\treturn (__ham_func5(NULL, t, i * sizeof(t[0])));\n}", "path": "deps\\db-5.1.25\\src\\env\\env_sig.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * __os_get_syserr --\n *\tReturn the last system error or EAGAIN if the last error is zero.\n */\n", "func_signal": "int\n__os_get_syserr()", "code": "{\n\tint err;\n\n\t/* This routine must be able to return the same value repeatedly. */\n\terr = GetLastError();\n\tif (err == 0)\n\t\tSetLastError(err = ERROR_RETRY);\n\treturn (err);\n}", "path": "deps\\db-5.1.25\\src\\os_windows\\os_errno.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * This index operation function is called by the attribute iterator\n * when producing test code that creates the secondary databases.\n */\n", "func_signal": "static void\ninvoke_query_iteration_idxop(DB_INDEX *idx)", "code": "{\n\tATTR_TYPE *key_type = idx->attribute->type;\n\n\tpr_test(\"%s_query_iteration(%s_dbp, %s%s\",\n\t    idx->name, idx->name,\n\t    idx->primary->transactional ? the_schema.environment.name : \"\",\n\t    idx->primary->transactional ? \"_txnp, \" : \"\");\n\n\tpr_test(\"%s\", data_value_for_type(key_type));\n\n\tpr_test(\n\",\\n  &%s_iteration_callback_test,                                          \\n\\\n  \\\"retrieval of %s record through %s query\\\");\\n\",\n\t\t    idx->primary->name, idx->primary->name, idx->name);\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/* This entity operation function generates secondary database closures. */\n", "func_signal": "static void\nremove_secondary_test_idxop(DB_INDEX *idx)", "code": "{\n\tpr_test(\"remove_%s_index(%s_envp%s%s%s);\\n\", idx->name,\n\t    the_schema.environment.name,\n\t    idx->primary->transactional ? \", \" : \"\",\n\t    idx->primary->transactional ? the_schema.environment.name : \"\",\n\t    idx->primary->transactional ? \"_txnp\" : \"\");\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * This entity operation function is\n * called by the attribute iterator when generating deletion test code.\n */\n", "func_signal": "static void\ndeletion_test_enter_entop(ENTITY *e)", "code": "{\n\tpr_test(\"ret = delete_%s_key( %s_dbp, %s%s%s);\\n\",\n\t    e->name, e->name,\n\t    e->transactional ? the_schema.environment.name : \"\",\n\t    e->transactional ? \"_txnp, \" : \"\",\n\t    data_value_for_type(e->primary_key->type));\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * We've seen cases where system calls failed but errno was never set.  For\n * that reason, __os_get_errno() and __os_get_syserr set errno to EAGAIN if\n * it's not already set, to work around the problem.  For obvious reasons,\n * we can only call this function if we know an error has occurred, that\n * is, we can't test the return for a non-zero value after the get call.\n *\n * __os_get_errno --\n *\tReturn the last ANSI C \"errno\" value or EAGAIN if the last error\n *\tis zero.\n */\n", "func_signal": "int\n__os_get_errno()", "code": "{\n\t/* This routine must be able to return the same value repeatedly. */\n\tif (errno == 0)\n\t\t__os_set_errno(EAGAIN);\n\treturn (errno);\n}", "path": "deps\\db-5.1.25\\src\\os_windows\\os_errno.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * Emit a formatted comment into the test file.\n */\n", "func_signal": "static void\npr_test_comment(char *fmt, ...)", "code": "{\n\tva_list ap;\n\tchar *s;\n\n\ts = prepare_string(fmt, test_indent_level, 1);\n\n\tva_start(ap, fmt);\n\tvfprintf(test_file, s, ap);\n\tva_end(ap);\n}", "path": "deps\\db-5.1.25\\util\\db_sql_codegen\\generate_test.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * strncat --\n *\n * PUBLIC: #ifndef HAVE_STRNCAT\n * PUBLIC: char *strncat __P((char *, const char *, size_t));\n * PUBLIC: #endif\n */\n/*\n * Concatenate src on the end of dst.  At most strlen(dst)+n+1 bytes\n * are written at dst (at most n+1 bytes being appended).  Return dst.\n */\n", "func_signal": "char *\nstrncat(char *dst, const char *src, size_t n)", "code": "{\n\tif (n != 0) {\n\t\tchar *d = dst;\n\t\tconst char *s = src;\n\n\t\twhile (*d != 0)\n\t\t\td++;\n\t\tdo {\n\t\t\tif ((*d = *s++) == 0)\n\t\t\t\tbreak;\n\t\t\td++;\n\t\t} while (--n != 0);\n\t\t*d = 0;\n\t}\n\treturn (dst);\n}", "path": "deps\\db-5.1.25\\src\\clib\\strncat.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * __os_cpu_count --\n *\tReturn the number of CPUs.\n *\n * PUBLIC: u_int32_t __os_cpu_count __P((void));\n */\n", "func_signal": "u_int32_t\n__os_cpu_count()", "code": "{\n#if defined(HAVE_PSTAT_GETDYNAMIC)\n\t/*\n\t * HP/UX.\n\t */\n\tstruct pst_dynamic psd;\n\n\treturn ((u_int32_t)pstat_getdynamic(&psd,\n\t    sizeof(psd), (size_t)1, 0) == -1 ? 1 : psd.psd_proc_cnt);\n#elif defined(HAVE_SYSCONF) && defined(_SC_NPROCESSORS_ONLN)\n\t/*\n\t * Solaris, Linux.\n\t */\n\tlong nproc;\n\n\tnproc = sysconf(_SC_NPROCESSORS_ONLN);\n\treturn ((u_int32_t)(nproc > 1 ? nproc : 1));\n#else\n\treturn (1);\n#endif\n}", "path": "deps\\db-5.1.25\\src\\os\\os_cpu.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/*\n * __os_cpu_count --\n *\tReturn the number of CPUs.\n *\n * PUBLIC: u_int32_t __os_cpu_count __P((void));\n */\n", "func_signal": "u_int32_t\n__os_cpu_count()", "code": "{\n\tSYSTEM_INFO SystemInfo;\n\n\tGetSystemInfo(&SystemInfo);\n\n\treturn ((u_int32_t)SystemInfo.dwNumberOfProcessors);\n}", "path": "deps\\db-5.1.25\\src\\os_windows\\os_cpu.c", "repo_name": "mcavage/node-bdb", "stars": 31, "license": "other", "language": "c", "size": 3486}
{"docstring": "/* xar_opt_get\n * x: archive to get the option from\n * option: name of the option\n * Returns: a pointer to the value of the option\n */\n", "func_signal": "const char *xar_opt_get(xar_t x, const char *option)", "code": "{\n\txar_attr_t i;\n\tfor(i = XAR(x)->attrs; i && XAR_ATTR(i)->next; i = XAR_ATTR(i)->next) {\n\t\tif(strcmp(XAR_ATTR(i)->key, option)==0)\n\t\t\treturn XAR_ATTR(i)->value;\n\t}\n\tif( i && (strcmp(XAR_ATTR(i)->key, option)==0) )\n\t\treturn XAR_ATTR(i)->value;\n\treturn NULL;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_write_fd\n * Summary: Writes from a buffer to a file descriptor.  Like xar_read_fd it\n * also just handles certain retryable error situations.\n * Returs -1 when it fails fatally; the number of bytes written otherwise.\n */\n", "func_signal": "ssize_t xar_write_fd( int fd, void * buffer, size_t nbytes )", "code": "{\n\tssize_t rb;\n\tssize_t off = 0;\n\n\twhile ( off < nbytes ) {\n\t\trb = write(fd, buffer+off, nbytes-off);\n\t\tif( (rb < 1 ) && (errno != EINTR) && (errno != EAGAIN) )\n\t\t\treturn -1;\n\t\toff += rb;\n\t}\n\n\treturn off;\n}", "path": "OtherSources\\lib\\xar\\util.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_add_r\n * Summary: a recursive helper function for adding a node to the\n * tree.  This will search all children of node f, looking for\n * the path component.  If found, will recurse into it.  If not,\n * will add the path component to the tree, and recurse into it.\n * If f is NULL, will start with x->files.\n */\n", "func_signal": "static xar_file_t xar_add_r(xar_t x, xar_file_t f, const char *path, const char *prefix)", "code": "{\n\txar_file_t i = NULL, ret, ret2, start = NULL;\n\tchar *tmp1, *tmp2, *tmp3;\n\n\tif( path && (path[0] == '\\0') ) {\n\t\treturn f;\n\t}\n\n\ttmp1 = tmp2 = strdup(path);\n\ttmp3 = strsep(&tmp2, \"/\");\n\n\tif( tmp3 && tmp2 && (tmp3[0] == '\\0') ) {\n\t\tret2 = xar_add_r(x, f, tmp2, \"\");\n\t\tfree(tmp1);\n\t\treturn ret2;\n\t}\n\n\tif( strcmp(tmp3, \"..\") == 0 ) {\n\t\tchar *prefixstr;\n\t\tif( !XAR(x)->skipwarn ) {\n\t\t\txar_err_new(x);\n\t\t\txar_err_set_string(x, \"Skipping .. in path\");\n\t\t\txar_err_callback(x, XAR_SEVERITY_WARNING, XAR_ERR_ARCHIVE_CREATION);\n\t\t\tXAR(x)->skipwarn = 1;\n\t\t}\n\t\tasprintf(&prefixstr, \"%s../\", prefix);\n\t\tret2 = xar_add_r(x, f, tmp2, prefixstr);\n\t\tfree(prefixstr);\n\t\tfree(tmp1);\n\t\treturn ret2;\n\t}\n\n\tif( strcmp(tmp3, \".\") == 0 ) {\n\t\tif( tmp2 )\n\t\t\tret2 = xar_add_r(x, f, tmp2, prefix);\n\t\telse\n\t\t\tret2 = NULL;\n\t\tfree(tmp1);\n\t\treturn ret2;\n\t}\n\n\tif( !f ) {\n\t\tstart = XAR(x)->files;\n\t} else {\n\t\tstart = XAR_FILE(f)->children;\n\t}\n\n\t/* Search all the siblings */\n\tfor( i = start; i; i = XAR_FILE(i)->next ) {\n\t\tconst char *n;\n\t\txar_prop_get(i, \"name\", &n);\n\t\tif( strcmp(n, tmp3) == 0 ) {\n\t\t\tif( !tmp2 ) {\n\t\t\t\t/* Node already exists, and it is i */\n\t\t\t\tfree(tmp1);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tret2 = xar_add_r(x, i, tmp2, \"\");\n\t\t\tfree(tmp1);\n\t\t\treturn ret2;\n\t\t}\n\t}\n\n\t/* tmp3 was not found in children of start, so we add it */\n\tif( tmp2 ) {\n\t\t//ret = xar_add_node(x, f, tmp3, prefix, NULL,  1);\n\t\tret = xar_add_pseudodir(x, f, tmp3, prefix, NULL);\n\t} else {\n\t\tret = xar_add_node(x, f, tmp3, prefix, NULL,  0);\n\t}\n\n\tif( !ret ) {\n\t\tfree(tmp1);\n\t\treturn NULL;\n\t}\n\n\tif( !tmp2 ) {\n\t\t/* We've added the final piece, done, don't recurse */\n\t\tfree(tmp1);\n\t\treturn ret;\n\t}\n\n\t/* still more to add, recurse */\n\tret2 = xar_add_r(x, ret, tmp2, \"\");\n\tfree(tmp1);\n\treturn ret2;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_read_fd\n * Summary: Reads from a file descriptor a certain number of bytes to a specific\n * buffer.  This simple wrapper just handles certain retryable error situations.\n * Returns -1 when it fails fatally; the number of bytes read otherwise.\n */\n", "func_signal": "ssize_t xar_read_fd( int fd, void * buffer, size_t nbytes )", "code": "{\n\tssize_t rb;\n\tssize_t off = 0;\n\n\twhile ( off < nbytes ) {\n\t\trb = read(fd, buffer+off, nbytes-off);\n\t\tif( (rb < 1 ) && (errno != EINTR) && (errno != EAGAIN) )\n\t\t\treturn -1;\n\t\toff += rb;\n\t}\n\n\treturn off;\n}", "path": "OtherSources\\lib\\xar\\util.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_heap_to_archive\n * x: archive to operate on\n * Returns 0 on success, -1 on error\n * Summary: copies the heap into the archive.\n */\n", "func_signal": "int32_t xar_heap_to_archive(xar_t x)", "code": "{\n\tlong bsize;\n\tssize_t r;\n\tint off;\n\tconst char *opt;\n\tchar *b;\n\n\topt = xar_opt_get(x, \"rsize\");\n\tif( !opt ) {\n\t\tbsize = 4096;\n\t} else {\n\t\tbsize = strtol(opt, NULL, 0);\n\t\tif( ((bsize == LONG_MAX) || (bsize == LONG_MIN)) && (errno == ERANGE) ) {\n\t\t\tbsize = 4096;\n\t\t}\n\t}\n\n\tb = malloc(bsize);\n\tif( !b ) return -1;\n\n\twhile(1) {\n\t\tr = read(XAR(x)->heap_fd, b, bsize);\n\t\tif( r == 0 ) break;\n\t\tif( (r < 0) && (errno == EINTR) ) continue;\n\t\tif( r < 0 ) {\n\t\t\tfree(b);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff = 0;\n\t\tdo {\n\t\t\tr = write(XAR(x)->fd, b+off, bsize-off);\n\t\t\tif( (r < 0) && (errno != EINTR) )\n\t\t\t\treturn -1;\n\t\t\toff += r;\n\t\t} while( off < bsize );\n\t}\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\io.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_copy_from_heap\n * This is the arcmod extraction entry point for extracting the file's\n * data from the heap file.\n * It is assumed the heap_fd is already positioned appropriately.\n */\n", "func_signal": "int32_t xar_attrcopy_from_heap(xar_t x, xar_file_t f, xar_prop_t p, write_callback wcb, void *context)", "code": "{\n\tint modulecount = (sizeof(xar_datamods)/sizeof(struct datamod));\n\tvoid\t*modulecontext[modulecount];\n\tint r, i;\n\tsize_t bsize, def_bsize;\n\tint64_t fsize, inc = 0, seekoff;\n\tvoid *inbuf;\n\tconst char *opt;\n\txar_prop_t tmpp;\n\n\tmemset(modulecontext, 0, sizeof(void*)*modulecount);\n\n\topt = xar_opt_get(x, \"rsize\");\n\tif( !opt ) {\n\t\tdef_bsize = 4096;\n\t} else {\n\t\tdef_bsize = strtol(opt, NULL, 0);\n\t\tif( ((def_bsize == LONG_MAX) || (def_bsize == LONG_MIN)) && (errno == ERANGE) ) {\n\t\t\tdef_bsize = 4096;\n\t\t}\n\t}\n\n\topt = NULL;\n\ttmpp = xar_prop_pget(p, \"offset\");\n\tif( tmpp )\n\t\topt = xar_prop_getvalue(tmpp);\n\tif( !opt ) {\n\t\twcb(x, f, NULL, 0, context);\n\t\treturn 0;\n\t} else {\n\t\tseekoff = strtoll(opt, NULL, 0);\n\t\tif( ((seekoff == LLONG_MAX) || (seekoff == LLONG_MIN)) && (errno == ERANGE) ) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tseekoff += XAR(x)->toc_count + sizeof(xar_header_t);\n\tif( XAR(x)->fd > 1 ) {\n\t\tr = lseek(XAR(x)->fd, seekoff, SEEK_SET);\n\t\tif( r == -1 ) {\n\t\t\tif( errno == ESPIPE ) {\n\t\t\t\tssize_t rr;\n\t\t\t\tchar *buf;\n\t\t\t\tunsigned int len;\n\n\t\t\t\tlen = seekoff - XAR(x)->toc_count;\n\t\t\t\tlen -= sizeof(xar_header_t);\n\t\t\t\tif( XAR(x)->heap_offset > len ) {\n\t\t\t\t\txar_err_new(x);\n\t\t\t\t\txar_err_set_file(x, f);\n\t\t\t\t\txar_err_set_string(x, \"Unable to seek\");\n\t\t\t\t\txar_err_callback(x, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t\t} else {\n\t\t\t\t\tlen -= XAR(x)->heap_offset;\n\t\t\t\t\tbuf = malloc(len);\n\t\t\t\t\tassert(buf);\n\t\t\t\t\trr = read(XAR(x)->fd, buf, len);\n\t\t\t\t\tif( rr < len ) {\n\t\t\t\t\t\txar_err_new(x);\n\t\t\t\t\t\txar_err_set_file(x, f);\n\t\t\t\t\t\txar_err_set_string(x, \"Unable to seek\");\n\t\t\t\t\t\txar_err_callback(x, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txar_err_new(x);\n\t\t\t\txar_err_set_file(x, f);\n\t\t\t\txar_err_set_string(x, \"Unable to seek\");\n\t\t\t\txar_err_callback(x, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t}\n\t\t}\n\t}\n\n\topt = NULL;\n\ttmpp = xar_prop_pget(p, \"length\");\n\tif( tmpp )\n\t\topt = xar_prop_getvalue(tmpp);\n\tif( !opt ) {\n\t\treturn 0;\n\t} else {\n\t\tfsize = strtoll(opt, NULL, 10);\n\t\tif( ((fsize == LLONG_MAX) || (fsize == LLONG_MIN)) && (errno == ERANGE) ) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbsize = def_bsize;\n\tinbuf = malloc(bsize);\n\tif( !inbuf ) {\n\t\treturn -1;\n\t}\n\n\twhile(1) {\n\t\t/* Size has been reached */\n\t\tif( fsize == inc )\n\t\t\tbreak;\n\t\tif( (fsize - inc) < bsize )\n\t\t\tbsize = fsize - inc;\n\t\tr = read(XAR(x)->fd, inbuf, bsize);\n\t\tif( r == 0 )\n\t\t\tbreak;\n\t\tif( (r < 0) && (errno == EINTR) )\n\t\t\tcontinue;\n\t\tif( r < 0 ) {\n\t\t\tfree(inbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tXAR(x)->heap_offset += r;\n\t\tinc += r;\n\t\tbsize = r;\n\n\t\t/* filter the data through the in modules */\n\t\tfor( i = 0; i < modulecount; i++) {\n\t\t\tif( xar_datamods[i].fh_in ) {\n\t\t\t\tint32_t ret;\n\t\t\t\tret = xar_datamods[i].fh_in(x, f, p, &inbuf, &bsize, &(modulecontext[i]));\n\t\t\t\tif( ret < 0 )\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Only due the write phase, if there is a write function to call */\n\t\tif(wcb){\n\t\t\n\t\t\t/* filter the data through the out modules */\n\t\t\tfor( i = 0; i < modulecount; i++) {\n\t\t\t\tif( xar_datamods[i].fh_out ) {\n\t\t\t\t\tint32_t ret;\n\t\t\t\t\tret = xar_datamods[i].fh_out(x, f, p, inbuf, bsize, &(modulecontext[i]));\n\t\t\t\t\tif( ret < 0 )\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twcb(x, f, inbuf, bsize, context);\n\t\t}\n\t\t\n\t\tfree(inbuf);\n\t\tbsize = def_bsize;\n\t\tinbuf = malloc(bsize);\n\t}\n\n\tfree(inbuf);\n\t/* finish up anything that still needs doing */\n\tfor( i = 0; i < modulecount; i++) {\n\t\tif( xar_datamods[i].fh_done ) {\n\t\t\tint32_t ret;\n\t\t\tret = xar_datamods[i].fh_done(x, f, p, &(modulecontext[i]));\n\t\t\tif( ret < 0 )\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\io.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_attrcopy_from_heap_to_heap\n* This does a simple copy of the heap data from one head (read-only) to another heap (write only). \n* This does not set any properties or attributes of the file, so this should not be used alone.\n*/\n", "func_signal": "int32_t xar_attrcopy_from_heap_to_heap(xar_t xsource, xar_file_t fsource, xar_prop_t p, xar_t xdest, xar_file_t fdest)", "code": "{\n\tint r, off;\n\tsize_t bsize;\n\tint64_t fsize, inc = 0, seekoff, writesize=0;\n\toff_t orig_heap_offset = XAR(xdest)->heap_offset;\n\tvoid *inbuf;\n\tconst char *opt;\n\tchar *tmpstr = NULL;\n\txar_prop_t tmpp;\n\t\n\topt = xar_opt_get(xsource, \"rsize\");\n\tif( !opt ) {\n\t\tbsize = 4096;\n\t} else {\n\t\tbsize = strtol(opt, NULL, 0);\n\t\tif( ((bsize == LONG_MAX) || (bsize == LONG_MIN)) && (errno == ERANGE) ) {\n\t\t\tbsize = 4096;\n\t\t}\n\t}\n\t\n\ttmpp = xar_prop_pget(p, \"offset\");\n\tif( tmpp )\n\t\topt = xar_prop_getvalue(tmpp);\n\t\n\tseekoff = strtoll(opt, NULL, 0);\n\t\t\n\tif( ((seekoff == LLONG_MAX) || (seekoff == LLONG_MIN)) && (errno == ERANGE) ) {\n\t\treturn -1;\n\t}\n\t\n\tseekoff += XAR(xsource)->toc_count + sizeof(xar_header_t);\n\t\n\tif( XAR(xsource)->fd > 1 ) {\n\t\tr = lseek(XAR(xsource)->fd, seekoff, SEEK_SET);\n\t\tif( r == -1 ) {\n\t\t\tif( errno == ESPIPE ) {\n\t\t\t\tssize_t rr;\n\t\t\t\tchar *buf;\n\t\t\t\tunsigned int len;\n\t\t\t\t\n\t\t\t\tlen = seekoff - XAR(xsource)->toc_count;\n\t\t\t\tlen -= sizeof(xar_header_t);\n\t\t\t\tif( XAR(xsource)->heap_offset > len ) {\n\t\t\t\t\txar_err_new(xsource);\n\t\t\t\t\txar_err_set_file(xsource, fsource);\n\t\t\t\t\txar_err_set_string(xsource, \"Unable to seek\");\n\t\t\t\t\txar_err_callback(xsource, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t\t} else {\n\t\t\t\t\tlen -= XAR(xsource)->heap_offset;\n\t\t\t\t\tbuf = malloc(len);\n\t\t\t\t\tassert(buf);\n\t\t\t\t\trr = read(XAR(xsource)->fd, buf, len);\n\t\t\t\t\tif( rr < len ) {\n\t\t\t\t\t\txar_err_new(xsource);\n\t\t\t\t\t\txar_err_set_file(xsource, fsource);\n\t\t\t\t\t\txar_err_set_string(xsource, \"Unable to seek\");\n\t\t\t\t\t\txar_err_callback(xsource, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txar_err_new(xsource);\n\t\t\t\txar_err_set_file(xsource, fsource);\n\t\t\t\txar_err_set_string(xsource, \"Unable to seek\");\n\t\t\t\txar_err_callback(xsource, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\t}\n\t\t}\n\t}\n\t\n\topt = NULL;\n\ttmpp = xar_prop_pget(p, \"length\");\n\tif( tmpp )\n\t\topt = xar_prop_getvalue(tmpp);\n\tif( !opt ) {\n\t\treturn 0;\n\t} else {\n\t\tfsize = strtoll(opt, NULL, 10);\n\t\tif( ((fsize == LLONG_MAX) || (fsize == LLONG_MIN)) && (errno == ERANGE) ) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tinbuf = malloc(bsize);\n\tif( !inbuf ) {\n\t\treturn -1;\n\t}\n\t\n\t\n\twhile(1) {\n\t\t/* Size has been reached */\n\t\tif( fsize == inc )\n\t\t\tbreak;\n\t\tif( (fsize - inc) < bsize )\n\t\t\tbsize = fsize - inc;\n\t\tr = read(XAR(xsource)->fd, inbuf, bsize);\n\t\tif( r == 0 )\n\t\t\tbreak;\n\t\tif( (r < 0) && (errno == EINTR) )\n\t\t\tcontinue;\n\t\tif( r < 0 ) {\n\t\t\tfree(inbuf);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tXAR(xsource)->heap_offset += r;\n\t\tinc += r;\n\t\tbsize = r;\n\t\t\n\t\toff = 0;\n\t\t\n\t\tdo {\n\t\t\tr = write(XAR(xdest)->heap_fd, inbuf+off, r-off );\n\t\t\toff += r;\n\t\t\twritesize += r;\n\t\t} while( off < r );\n\t\tXAR(xdest)->heap_offset += off;\n\t\tXAR(xdest)->heap_len += off;\n\t}\n\t\n\tasprintf(&tmpstr, \"%\"PRIu64, (uint64_t)orig_heap_offset);\n\topt = xar_prop_getkey(p);\n\ttmpp = xar_prop_pfirst(fdest);\n\tif( tmpp )\n\t\ttmpp = xar_prop_find(tmpp, opt);\n\tif( tmpp )\n\t\txar_prop_pset(fdest, tmpp, \"offset\", tmpstr);\n\tfree(tmpstr);\n\t\n\t\n\tfree(inbuf);\n\t\n\t/* It is the caller's responsibility to copy the attributes of the file, etc, this only copies the data in the heap */\n\t\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\io.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_add_pseudodir\n * Summary: Adds a placeholder directory when archiving a file prior\n * to archiving its path.\n */\n", "func_signal": "static xar_file_t xar_add_pseudodir(xar_t x, xar_file_t f, const char *name, const char *prefix, const char *realpath)", "code": "{\n\txar_file_t ret;\n\tconst char *path; \n\tchar *tmp;\n\tchar idstr[32];\n\n\tif( !f ) {\n\t\tif( realpath )\n\t\t\tasprintf(&tmp, \"%s\", realpath);\n\t\telse\n\t\t\tasprintf(&tmp, \"%s%s%s\", XAR(x)->path_prefix, prefix, name);\n\n\t\tif( lstat(tmp, &XAR(x)->sbcache) != 0 ) {\n\t\t\tfree(tmp);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = xar_file_new(NULL);\n\t\tif( !ret )\n\t\t\treturn NULL;\n\t\tmemset(idstr, 0, sizeof(idstr));\n\t\tsnprintf(idstr, sizeof(idstr)-1, \"%\"PRIu64, ++XAR(x)->last_fileid);\n\t\txar_attr_set(ret, NULL, \"id\", idstr);\n\t\tXAR_FILE(ret)->parent = NULL;\n\t\tXAR_FILE(ret)->fspath = tmp;\n\t\tif( XAR(x)->files == NULL )\n\t\t\tXAR(x)->files = ret;\n\t\telse {\n\t\t\tXAR_FILE(ret)->next = XAR(x)->files;\n\t\t\tXAR(x)->files = ret;\n\t\t}\n\t} else {\n\t\tpath = XAR_FILE(f)->fspath;\n\t\tif( strcmp(prefix, \"../\") == 0 ) {\n\t\t\tint len1, len2;\n\t\t\tlen1 = strlen(path);\n\t\t\tlen2 = strlen(name);\n\t\t\tif( (len1>=len2) && (strcmp(path+(len1-len2), name) == 0) ) {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif( realpath ){\n\t\t\tasprintf(&tmp, \"%s\", realpath);\n\t\t}else\n\t\t\tasprintf(&tmp, \"%s/%s%s\", path, prefix, name);\n\t\t\n\t\tif( lstat(tmp, &XAR(x)->sbcache) != 0 ) {\n\t\t\tfree(tmp);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = xar_file_new(f);\n\t\tif( !ret )\n\t\t\treturn NULL;\n\t\tmemset(idstr, 0, sizeof(idstr));\n\t\tsnprintf(idstr, sizeof(idstr)-1, \"%\"PRIu64, ++XAR(x)->last_fileid);\n\t\txar_attr_set(ret, NULL, \"id\", idstr);\n\t\tXAR_FILE(ret)->fspath = tmp;\n\t}\n\txar_prop_set(ret, \"name\", name);\n\txar_prop_set(ret, \"type\", \"directory\");\n\n\treturn ret;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_parse_header\n * x: archive to operate on.\n * Returns: 0 on success, -1 on failure\n * Summary: internal helper function to read in the xar header.\n */\n", "func_signal": "static int32_t xar_parse_header(xar_t x)", "code": "{\n\tssize_t r;\n\tint off = 0;\n\tint sz2read = 0;\n\n\t/* read just the magic, verify it, read the header length,\n\t * then read in the size of the header according to the\n\t * recorded header length, or the length of the structure\n\t * we expect, whichever is smaller.  Then seek forward\n\t * if the recorded header length is greater than the \n\t * expected header length.\n\t */\n\tr = xar_read_fd(XAR(x)->fd, (char *)&XAR(x)->header.magic+off, sizeof(XAR(x)->header.magic)-off);\n\tif ( r == -1 )\n\t\treturn r;\n\n\t/* Verify the header.  If the header doesn't match, exit without\n\t * attempting to read any more.\n\t */\n\tXAR(x)->header.magic = ntohl(XAR(x)->header.magic);\n\n\tif( XAR(x)->header.magic != XAR_HEADER_MAGIC ) {\n\t\treturn -1;\n\t}\n\n\tr = xar_read_fd(XAR(x)->fd, (char *)&XAR(x)->header.size+off, sizeof(XAR(x)->header.size)-off);\n\tif ( r == -1 )\n\t\treturn r;\n\n\tXAR(x)->header.size = ntohs(XAR(x)->header.size);\n\n\tif( XAR(x)->header.size > sizeof(xar_header_t) )\n\t\tsz2read = sizeof(xar_header_t);\n\telse\n\t\tsz2read = XAR(x)->header.size;\n\n\toff = sizeof(XAR(x)->header.magic) + sizeof(XAR(x)->header.size);\n\tr = xar_read_fd(XAR(x)->fd, ((char *)&XAR(x)->header)+off, sizeof(xar_header_t)-off);\n\tif ( r == -1 )\n\t\treturn r;\n\n\tXAR(x)->header.version = ntohs(XAR(x)->header.version);\n\tXAR(x)->header.toc_length_compressed = xar_ntoh64(XAR(x)->header.toc_length_compressed);\n\tXAR(x)->header.toc_length_uncompressed = xar_ntoh64(XAR(x)->header.toc_length_uncompressed);\n\tXAR(x)->header.cksum_alg = ntohl(XAR(x)->header.cksum_alg);\n\n\toff = XAR(x)->header.size - sz2read;\n\tif( off > 0 )\n\t\tr = lseek(XAR(x)->fd, (off_t)off, SEEK_CUR);\n\n\tif ( (r == -1) && (errno != ESPIPE) )\n\t\tprintf(\"fatal error\"); /* Some fatal error here perhaps? */\n\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_serialize\n * x: xar to serialize\n * file: file to serialize to\n * Summary: serializes the archive out to xml.\n */\n", "func_signal": "void xar_serialize(xar_t x, const char *file)", "code": "{\n\txmlTextWriterPtr writer;\n\txar_subdoc_t i;\n\n\twriter = xmlNewTextWriterFilename(file, 0);\n\txmlTextWriterStartDocument(writer, \"1.0\", \"UTF-8\", NULL);\n\txmlTextWriterSetIndent(writer, 4);\n\txmlTextWriterStartElement(writer, BAD_CAST(\"xar\"));\n\n\tfor( i = XAR(x)->subdocs; i; i = xar_subdoc_next(i) )\n\t\txar_subdoc_serialize(i, writer, 1);\n\n\txmlTextWriterStartElement(writer, BAD_CAST(\"toc\"));\n\t\t\t\n\tif( XAR(x)->props )\n\t\txar_prop_serialize(XAR(x)->props, writer);\n\n\tif( XAR(x)->signatures )\n\t\txar_signature_serialize(XAR(x)->signatures,writer);\n\n\tif( XAR(x)->files )\n\t\txar_file_serialize(XAR(x)->files, writer);\n\n\txmlTextWriterEndDocument(writer);\n\txmlFreeTextWriter(writer);\n\treturn;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_subdoc_serialize\n * s: a subdoc structure allocated and initialized by xar_subdoc_new()\n * writer: and xmlTextWriterPtr that has already been opend and initialized\n * and is pointing to the place where the subdocument will be serialized.\n * wrap: an integer describing whether the subdocument is to be wrapped\n * for placement in the xml header of an archive, or if we are trying to\n * reconstruct the original document.  1 for wrapping, 0 for original.\n */\n", "func_signal": "void xar_subdoc_serialize(xar_subdoc_t s, xmlTextWriterPtr writer, int wrap)", "code": "{\n\tif( !s ) return;\n\tif( wrap ) {\n\t\txmlTextWriterStartElementNS(writer, BAD_CAST(XAR_SUBDOC(s)->prefix), BAD_CAST(\"subdoc\"), BAD_CAST(XAR_SUBDOC(s)->ns));\n\t\txmlTextWriterWriteAttribute(writer, BAD_CAST(\"subdoc_name\"), BAD_CAST(XAR_SUBDOC(s)->name));\n\t\tif( XAR_SUBDOC(s)->value )\n\t\t\txmlTextWriterWriteString(writer, BAD_CAST(XAR_SUBDOC(s)->value));\n\t}\n\txar_prop_serialize(XAR_SUBDOC(s)->props, writer);\n\txmlTextWriterEndElement(writer);\n}", "path": "OtherSources\\lib\\xar\\subdoc.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_add\n * x: archive to add the file to\n * path: path to file\n * Returns: allocated an populated xar_file_t representing the \n * specified file.\n * Summary: if a full path \"foo/bar/blah\" is specified, then any\n * directories not already existing in the archive will be added\n * automagically.  The returned xar_file_t represents the file\n * specified, not the parent of the directory tree.\n * For instance, if \"foo/bar/blah\" is specified, the xar_file_t\n * representing \"blah\" will be returned.\n */\n", "func_signal": "xar_file_t xar_add(xar_t x, const char *path)", "code": "{\n#ifdef __APPLE__\n\txar_file_t ret;\n\tif( (ret = xar_underbar_check(x, NULL, path)) )\n\t\treturn ret;\n#endif\n\n\tif( path[0] == '/' ) {\n\t\tXAR(x)->path_prefix = \"/\";\n\t\tpath++;\n\t} else\n\t\tXAR(x)->path_prefix = \"\";\n\treturn xar_add_r(x, NULL, path, \"\");\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* Returns number of bytes consumed during the parsing process */\n", "func_signal": "static int32_t macho_parse(xar_file_t f, void *in, size_t inlen, struct _macho_context *context)", "code": "{\n\tint32_t consumed = 0;\n\n\tswitch( context->state ) {\n\tcase(lf_fatheader):\n\t\tif( inlen >= sizeof(struct fat_header) ) {\n\t\t\tstruct fat_header *fh = (struct fat_header *)in;\n\t\t\tif( fh->magic == 0xcafebabe ) {\n\t\t\t\tcontext->fath.magic = fh->magic;\n\t\t\t\tcontext->fath.nfat_arch = fh->nfat_arch;\n\t\t\t\tcontext->arches = calloc(1,sizeof(struct fat_arch) * fh->nfat_arch);\n\t\t\t\tcontext->me = calloc(1,sizeof(struct machexecutables) * fh->nfat_arch);\n\t\t\t\tcontext->state = lf_archheader;\n\t\t\t\tcontext->byteswapped = 0;\n\t\t\t\tcontext->curarch = 0;\n\t\t\t\tconsumed = 8;\n\t\t\t\txar_prop_set(f, \"contents/type\", \"Mach-O Fat File\");\n\t\t\t} else if( fh->magic == 0xbebafeca ) {\n\t\t\t\tcontext->fath.magic = xar_swap32(fh->magic);\n\t\t\t\tcontext->fath.nfat_arch = xar_swap32(fh->nfat_arch);\n\t\t\t\tcontext->arches = calloc(1,sizeof(struct fat_arch) * context->fath.nfat_arch);\n\t\t\t\tcontext->me = calloc(1,sizeof(struct machexecutables) * context->fath.nfat_arch);\n\t\t\t\tcontext->state = lf_archheader;\n\t\t\t\tcontext->byteswapped = 1;\n\t\t\t\tcontext->curarch = 0;\n\t\t\t\tconsumed = 8;\n\t\t\t\txar_prop_set(f, \"contents/type\", \"Mach-O Fat File\");\n\t\t\t} else {\n\t\t\t\tcontext->me = calloc(1,sizeof(struct machexecutables));\n\t\t\t\tcontext->curme = 0;\n\t\t\t\tcontext->state = lf_machheader;\n\t\t\t}\n\t\t} else {\n\t\t\tuint32_t *tmp = in;\n\t\t\tif( (*tmp == 0xcafebabe) || (*tmp == 0xbebafeca) ) {\n\t\t\t\tmemcpy(context->buffer, in, inlen);\n\t\t\t\tcontext->buffersz = inlen;\n\t\t\t\tconsumed = (int32_t)inlen;\n\t\t\t\tcontext->state = lf_inc_fatheader;\n\t\t\t} else {\n\t\t\t\tcontext->me = calloc(1,sizeof(struct machexecutables));\n\t\t\t\tcontext->curme = 0;\n\t\t\t\tcontext->state = lf_machheader;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase lf_archheader:\n\t\tif( inlen >= sizeof(struct fat_arch) ) {\n\t\t\tstruct fat_arch *fa = in;\n\t\t\tif( context->byteswapped ) {\n\t\t\t\tcontext->arches[context->curarch].cputype = xar_swap32(fa->cputype);\n\t\t\t\tcontext->arches[context->curarch].cpusubtype = xar_swap32(fa->cpusubtype);\n\t\t\t\tcontext->arches[context->curarch].offset = xar_swap32(fa->offset);\n\t\t\t\tcontext->arches[context->curarch].size = xar_swap32(fa->size);\n\t\t\t\tcontext->arches[context->curarch].alighn = xar_swap32(fa->alighn);\n\t\t\t} else {\n\t\t\t\tmemcpy(&context->arches[context->curarch], in, sizeof(struct fat_arch));\n\t\t\t}\n\t\t\tcontext->curarch++;\n\t\t\tif( context->curarch >=context->fath.nfat_arch ) {\n\t\t\t\tcontext->nextme = context->arches[0].offset;\n\t\t\t\tcontext->state = lf_machheader;\n\t\t\t}\n\t\t\tconsumed = sizeof(struct fat_arch);\n\t\t} else {\n\t\t\tmemcpy(context->buffer, in, inlen);\n\t\t\tcontext->buffersz = inlen;\n\t\t\tconsumed = (int32_t)inlen;\n\t\t\tcontext->state = lf_inc_archheader;\n\t\t}\n\t\tbreak;\n\tcase lf_machheader:\n\t\tif( (context->curroffset+inlen) <= context->nextme )\n\t\t\tconsumed = inlen;\n\t\telse {\n\t\t\tuint64_t off;\n\t\t\tunsigned char *tmpin = in;\n\t\t\toff = context->nextme - context->curroffset;\n\t\t\ttmpin += off;\n\t\t\tif( (inlen-off) >= sizeof(struct mach_header) ) {\n\t\t\t\tconst char *cpustr;\n\t\t\t\tchar *typestr, *typestr2;\n\t\t\t\tstruct mach_header *mh = (struct mach_header *)tmpin;\n\t\t\t\tswitch(mh->magic) {\n\t\t\t\tcase 0xcffaedfe:\n\t\t\t\t\tcontext->me[context->curme].bits = 64;\n\t\t\t\t\tcontext->me[context->curme].byteswapped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xcefaedfe:\n\t\t\t\t\tcontext->me[context->curme].bits = 32;\n\t\t\t\t\tcontext->me[context->curme].byteswapped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xfeedface:\n\t\t\t\t\tcontext->me[context->curme].bits = 32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xfeedfacf:\n\t\t\t\t\tcontext->me[context->curme].bits = 64;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontext->state = lf_none;\n\t\t\t\t\treturn inlen;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif( context->me[context->curme].byteswapped ) {\n\t\t\t\t\tcontext->me[context->curme].mh.magic = xar_swap32(mh->magic);\n\t\t\t\t\tcontext->me[context->curme].mh.cputype = xar_swap32(mh->cputype);\n\t\t\t\t\tcontext->me[context->curme].mh.cpusubtype = xar_swap32(mh->cpusubtype);\n\t\t\t\t\tcontext->me[context->curme].mh.filetype = xar_swap32(mh->filetype);\n\t\t\t\t\tcontext->me[context->curme].mh.ncmds = xar_swap32(mh->ncmds);\n\t\t\t\t\tcontext->me[context->curme].mh.sizeofcmds = xar_swap32(mh->sizeofcmds);\n\t\t\t\t\tcontext->me[context->curme].mh.flags = xar_swap32(mh->flags);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(&context->me[context->curme].mh, tmpin, sizeof(struct mach_header));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcpustr = macho_cpustr(context->me[context->curme].mh.cputype);\n\n\t\t\t\tswitch(context->me[context->curme].mh.filetype) {\n\t\t\t\tcase 0x01: typestr = \"Mach-O Object\"; break;\n\t\t\t\tcase 0x02: typestr = \"Mach-O Executable\"; break;\n\t\t\t\tcase 0x03: typestr = \"Mach-O Fixed VM Library\"; break;\n\t\t\t\tcase 0x04: typestr = \"Mach-O core\"; break;\n\t\t\t\tcase 0x05: typestr = \"Mach-O Preloaded Executable\"; break;\n\t\t\t\tcase 0x06: typestr = \"Mach-O Dylib\"; break;\n\t\t\t\tcase 0x07: typestr = \"Mach-O Dylinker\"; break;\n\t\t\t\tcase 0x08: typestr = \"Mach-O Bundle\"; break;\n\t\t\t\tcase 0x09: typestr = \"Mach-O Stub\"; break;\n\t\t\t\tdefault: typestr = \"Unknown\"; break;\n\t\t\t\t};\n\n\t\t\t\tif( xar_prop_get(f, \"contents/type\", (const char **)&typestr2) ) {\n\t\t\t\t\txar_prop_set(f, \"contents/type\", typestr);\n\t\t\t\t}\t\t\t\n\t\t\t\tasprintf(&typestr2, \"contents/%s/type\", cpustr);\n\t\t\t\txar_prop_set(f, typestr2, typestr);\n\t\t\t\tfree(typestr2);\n\n\t\t\t\tcontext->me[context->curme].lc = malloc(sizeof(struct lc) * context->me[context->curme].mh.ncmds);\n\t\t\t\tcontext->me[context->curme].strings = malloc(sizeof(char *) * context->me[context->curme].mh.ncmds);\n\t\t\t\tcontext->me[context->curme].curlc = 0;\n\t\t\t\tconsumed = off + sizeof(struct mach_header);\n\t\t\t\tif( context->me[context->curme].bits == 64 )\n\t\t\t\t\tconsumed += 4;\n\t\t\t\tcontext->me[context->curme].nextlc = context->curroffset + consumed;\n\t\t\t\tcontext->state = lf_loadcommand;\n\t\t\t} else {\n\t\t\t\tmemcpy(context->buffer, tmpin, inlen-off);\n\t\t\t\tcontext->buffersz = inlen-off;\n\t\t\t\tconsumed = (int32_t)inlen;\n\t\t\t\tcontext->state = lf_inc_machheader;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase lf_loadcommand:\n\t\tif( (context->curroffset+inlen) <= context->me[context->curme].nextlc )\n\t\t\tconsumed = inlen;\n\t\telse {\n\t\t\tuint64_t off;\n\t\t\tunsigned char *tmpin = in;\n\t\t\toff = context->me[context->curme].nextlc - context->curroffset;\n\t\t\ttmpin += off;\n\t\t\tif( (inlen-off) >= sizeof(struct lc) ) {\n\t\t\t\tif( context->me[context->curme].byteswapped ) {\n\t\t\t\t\tstruct lc *lc = (struct lc *)tmpin;\n\t\t\t\t\tcontext->me[context->curme].lc[context->me[context->curme].curlc].cmd = xar_swap32(lc->cmd);\n\t\t\t\t\tcontext->me[context->curme].lc[context->me[context->curme].curlc].cmdsize = xar_swap32(lc->cmdsize);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(&context->me[context->curme].lc[context->me[context->curme].curlc], tmpin, sizeof(struct lc));\n\t\t\t\t}\n\t\t\t\tconsumed = off + sizeof(struct lc);\n\t\t\t\tcontext->me[context->curme].nextlc += context->me[context->curme].lc[context->me[context->curme].curlc].cmdsize;\n\t\t\t\tif( (context->me[context->curme].lc[context->me[context->curme].curlc].cmd == 0xc) || (context->me[context->curme].lc[context->me[context->curme].curlc].cmd == 0xd) ) {\n\t\t\t\t\tcontext->state = lf_lcstr;\n\t\t\t\t} else {\n\t\t\t\t\tcontext->me[context->curme].curlc++;\n\t\t\t\t\tif( context->me[context->curme].curlc >= context->me[context->curme].mh.ncmds ) {\n\t\t\t\t\t\tcontext->curme++;\n\t\t\t\t\t\tif( context->fath.nfat_arch ) {\n\t\t\t\t\t\t\tif( context->curme >= context->fath.nfat_arch ) {\n\t\t\t\t\t\t\t\tcontext->state = lf_none;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontext->nextme = context->arches[context->curme].offset;\n\t\t\t\t\t\t\t\tcontext->state = lf_machheader;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext->state = lf_none;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemcpy(context->buffer, in+off, inlen-off);\n\t\t\t\tcontext->buffersz = inlen-off;\n\t\t\t\tconsumed = inlen;\n\t\t\t\tcontext->state = lf_inc_loadcommand;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase lf_lcstr:\n\t\tif( inlen >= (context->me[context->curme].lc[context->me[context->curme].curlc].cmdsize-8) ) {\n\t\t\tconst char *tmpstr;\n\t\t\tuint32_t cmdsize = context->me[context->curme].lc[context->me[context->curme].curlc].cmdsize;\n\t\t\tuint32_t *offsetp, offset;\n\t\t\tchar *lib, *propstr;\n\t\t\toffsetp = in;\n\t\t\tif( context->me[context->curme].byteswapped )\n\t\t\t\toffset = xar_swap32(*offsetp);\n\t\t\telse\n\t\t\t\toffset = *offsetp;\n\t\t\tlib = calloc(1,(cmdsize - offset)+1);\n\t\t\tmemcpy(lib, in+(offset - 8), cmdsize - offset);\n\t\t\ttmpstr = macho_cpustr(context->me[context->curme].mh.cputype);\n\t\t\tasprintf(&propstr, \"contents/%s/library\", tmpstr);\n\t\t\txar_prop_create(f, propstr, lib);\n\t\t\tfree(lib);\n\t\t\tfree(propstr);\n\n\t\t\tconsumed = cmdsize-8;\n\t\t\tcontext->state = lf_loadcommand;\n\t\t\tcontext->me[context->curme].curlc++;\n\t\t\tif( context->me[context->curme].curlc >= context->me[context->curme].mh.ncmds ) {\n\t\t\t\tcontext->curme++;\n\t\t\t\tif( context->fath.nfat_arch ) {\n\t\t\t\t\tif( context->curme >= context->fath.nfat_arch ) {\n\t\t\t\t\t\tcontext->state = lf_none;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext->nextme = context->arches[context->curme].offset;\n\t\t\t\t\t\tcontext->state = lf_machheader;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext->state = lf_none;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(context->buffer, in, inlen);\n\t\t\tcontext->buffersz = inlen;\n\t\t\tconsumed = inlen;\n\t\t\tcontext->state = lf_inc_lcstr;\n\t\t}\n\t\tbreak;\n\tcase lf_none:\n\tdefault:\n\t\tconsumed = inlen;\n\t\tbreak;\n\t};\n\treturn consumed;\n}", "path": "OtherSources\\lib\\xar\\macho.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_extract\n * x: archive to extract from\n * path: path to file to extract\n * Returns 0 on success, -1 on failure.\n * Summary: This is the entry point for extraction.  This will find\n * the file node described by path, extract any directories needed\n * to extract the node, and finally extract the file.\n * Example: xar_extract(x, \"foo/bar/blah\")\n * If foo does not exist, xar_extract will extract foo from the\n * archive, extract bar from the archive, and then extract blah.\n * Total extractions will be \"foo\", \"foo/bar\", and \"foo/bar/blah\".\n */\n", "func_signal": "int32_t xar_extract(xar_t x, xar_file_t f)", "code": "{\n\tstruct stat sb;\n\tchar *tmp1, *dname;\n\txar_file_t tmpf;\n\t\n\tif( (strstr(XAR_FILE(f)->fspath, \"/\") != NULL) && (stat(XAR_FILE(f)->fspath, &sb)) && (XAR_FILE(f)->parent_extracted == 0) ) {\n\t\ttmp1 = strdup(XAR_FILE(f)->fspath);\n\t\tdname = dirname(tmp1);\n\t\ttmpf = xar_file_find(XAR(x)->files, dname);\n\t\tif( !tmpf ) {\n\t\t\txar_err_set_string(x, \"Unable to find file\");\n\t\t\txar_err_callback(x, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_EXTRACTION);\n\t\t\treturn -1;\n\t\t}\n\t\tfree(tmp1);\n\t\tXAR_FILE(f)->parent_extracted++;\n\t\txar_extract(x, tmpf);\n\t}\n\t\n\treturn xar_extract_tofile(x, f, XAR_FILE(f)->fspath);\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_add_frombuffer\n* x: archive to add the file to\n* parent: parent node, possibly NULL\n* name: name of file\n* buffer: buffer for file contents\n* length: length of buffer\n* Returns: allocated an populated xar_file_t representing the \n* specified file.\n* Summary: Use this to add chunks of named data to a xar without\n* using the filesystem.\n*/\n", "func_signal": "xar_file_t xar_add_frombuffer(xar_t x, xar_file_t parent, const char *name, char *buffer, size_t length)", "code": "{\n\txar_file_t ret;\n\tchar idstr[32];\n\t\n\tif( !parent ) {\n\t\tret = xar_file_new(NULL);\n\t\tif( !ret )\n\t\t\treturn NULL;\n\t\tmemset(idstr, 0, sizeof(idstr));\n\t\tsnprintf(idstr, sizeof(idstr)-1, \"%\"PRIu64, ++XAR(x)->last_fileid);\n\t\txar_attr_set(ret, NULL, \"id\", idstr);\n\t\tXAR_FILE(ret)->parent = NULL;\n\t\tif( XAR(x)->files == NULL )\n\t\t\tXAR(x)->files = ret;\n\t\telse {\n\t\t\tXAR_FILE(ret)->next = XAR(x)->files;\n\t\t\tXAR(x)->files = ret;\n\t\t}\n\t} else {\n\t\tret = xar_file_new(parent);\n\t\tif( !ret )\n\t\t\treturn NULL;\n\t\tmemset(idstr, 0, sizeof(idstr));\n\t\tsnprintf(idstr, sizeof(idstr)-1, \"%\"PRIu64, ++XAR(x)->last_fileid);\n\t\txar_attr_set(ret, NULL, \"id\", idstr);\n\t\tXAR_FILE(ret)->fspath = NULL;\n\t}\n\t\n\txar_prop_set(ret, \"name\", name);\n\t\t\n\t//int32_t xar_arcmod_archive(xar_t x, xar_file_t f, const char *file, const char *buffer, size_t len) \n\tif( xar_arcmod_archive(x, ret, NULL , buffer , length) < 0 ) {\n\t\txar_file_t i;\n\t\tif( parent ) {\n\t\t\tfor( i = XAR_FILE(parent)->children; i && (XAR_FILE(i)->next != ret); i = XAR_FILE(i)->next );\n\t\t} else {\n\t\t\tfor( i = XAR(x)->files; i && (XAR_FILE(i)->next != ret); i = XAR_FILE(i)->next );\n\t\t}\n\t\tif( i )\n\t\t\tXAR_FILE(i)->next = XAR_FILE(ret)->next;\n\t\txar_file_free(ret);\n\t\treturn NULL;\n\t}\n\t\n\treturn ret;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_unserialize\n * x: xar archive to unserialize to.  Must have been allocated with xar_open\n * file: the xml filename to unserialize from\n * Summary: Takes the TOC representation from file and creates the\n * corresponding in-memory representation.\n */\n", "func_signal": "static int32_t xar_unserialize(xar_t x)", "code": "{\n\txmlTextReaderPtr reader;\n\txar_file_t f = NULL;\n\tconst xmlChar *name, *prefix, *uri;\n\tint type, noattr, ret;\n\n\treader = xmlReaderForIO(toc_read_callback, close_callback, XAR(x), NULL, NULL, 0);\n\tif( !reader ) return -1;\n\n\twhile( (ret = xmlTextReaderRead(reader)) == 1 ) {\n\t\ttype = xmlTextReaderNodeType(reader);\n\t\tnoattr = xmlTextReaderAttributeCount(reader);\n\t\tname = xmlTextReaderConstLocalName(reader);\n\t\tif( type != XML_READER_TYPE_ELEMENT )\n\t\t\tcontinue;\n\t\tif(strcmp((const char*)name, \"xar\") != 0)\n\t\t\tcontinue;\n\t\twhile( (ret = xmlTextReaderRead(reader)) == 1 ) {\n\t\t\ttype = xmlTextReaderNodeType(reader);\n\t\t\tnoattr = xmlTextReaderAttributeCount(reader);\n\t\t\tname = xmlTextReaderConstLocalName(reader);\n\t\t\tif( type == XML_READER_TYPE_ELEMENT ) {\n\t\t\t\tif(strcmp((const char*)name, \"toc\") == 0) {\n\t\t\t\t\twhile( (ret = xmlTextReaderRead(reader)) == 1 ) {\n\t\t\t\t\t\ttype = xmlTextReaderNodeType(reader);\n\t\t\t\t\t\tnoattr = xmlTextReaderAttributeCount(reader);\n\t\t\t\t\t\tname = xmlTextReaderConstLocalName(reader);\n\t\t\t\t\t\tif( type == XML_READER_TYPE_ELEMENT ) {\n\t\t\t\t\t\t\tif(strcmp((const char*)name, \"file\") == 0) {\n\t\t\t\t\t\t\t\tf = xar_file_unserialize(x, NULL, reader);\n\t\t\t\t\t\t\t\tXAR_FILE(f)->next = XAR(x)->files;\n\t\t\t\t\t\t\t\tXAR(x)->files = f;\n\t\t\t\t\t\t\t} else if( strcmp((const char*)name, \"signature\") == 0 ){\n\t\t\t\t\t\t\t\txar_signature_t sig = NULL;\t\t\t\n\t\t\t\t\t\t\t\tsig = xar_signature_unserialize(x, reader );\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif( !sig ) {\n\t\t\t\t\t\t\t\t\txmlFreeTextReader(reader);\n\t\t\t\t\t\t\t\t\txmlDictCleanup();\n\t\t\t\t\t\t\t\t\txmlCleanupCharEncodingHandlers();\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif( XAR(x)->signatures )\n\t\t\t\t\t\t\t\t\tXAR_SIGNATURE(XAR(x)->signatures)->next = XAR_SIGNATURE(sig);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tXAR(x)->signatures = sig;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\txar_prop_unserialize(XAR_FILE(x), NULL, reader);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ret == -1 ) {\n\t\t\t\t\t\txmlFreeTextReader(reader);\n\t\t\t\t\t\txmlDictCleanup();\n\t\t\t\t\t\txmlCleanupCharEncodingHandlers();\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\txar_subdoc_t s;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tprefix = xmlTextReaderPrefix(reader);\n\t\t\t\t\turi = xmlTextReaderNamespaceUri(reader);\n\n\t\t\t\t\ti = xmlTextReaderAttributeCount(reader);\n\t\t\t\t\tif( i > 0 ) {\n\t\t\t\t\t\tfor(i = xmlTextReaderMoveToFirstAttribute(reader); i == 1; i = xmlTextReaderMoveToNextAttribute(reader)) {\n\t\t\t\t\t\t\txar_attr_t a;\n\t\t\t\t\t\t\tconst char *aname = (const char *)xmlTextReaderConstLocalName(reader);\n\t\t\t\t\t\t\tconst char *avalue = (const char *)xmlTextReaderConstValue(reader);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( aname && (strcmp(\"subdoc_name\", aname) == 0) ) {\n\t\t\t\t\t\t\t\tname = (const unsigned char *)avalue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ta = xar_attr_new();\n\t\t\t\t\t\t\t\tXAR_ATTR(a)->key = strdup(aname);\n\t\t\t\t\t\t\t\tXAR_ATTR(a)->value = strdup(avalue);\n\t\t\t\t\t\t\t\tXAR_ATTR(a)->next = XAR_SUBDOC(s)->attrs;\n\t\t\t\t\t\t\t\tXAR_SUBDOC(s)->attrs = XAR_ATTR(a);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ts = xar_subdoc_new(x, (const char *)name);\n\t\t\t\t\txar_subdoc_unserialize(s, reader);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( (type == XML_READER_TYPE_END_ELEMENT) && (strcmp((const char *)name, \"toc\")==0) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( ret == -1 ) {\n\t\t\txmlFreeTextReader(reader);\n\t\t\txmlDictCleanup();\n\t\t\txmlCleanupCharEncodingHandlers();\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif( ret == -1 ) {\n\t\txmlFreeTextReader(reader);\n\t\txmlDictCleanup();\n\t\txmlCleanupCharEncodingHandlers();\n\t\treturn -1;\n\t}\n\t\t\n\txmlFreeTextReader(reader);\n\txmlDictCleanup();\n\txmlCleanupCharEncodingHandlers();\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* toc_read_callback\n * context: context passed through from the reader\n * buffer: buffer to read into\n * len: size of buffer\n * Returns: number of bytes read or -1 in case of error\n * Summary: internal callback for xmlReaderForIO.\n */\n", "func_signal": "static int toc_read_callback(void *context, char *buffer, int len)", "code": "{\n\txar_t x = (xar_t)context;\n\tint ret, off = 0;\n\n\tif ( ((!XAR(x)->offset) || (XAR(x)->offset == XAR(x)->readbuf_len)) && (XAR(x)->toc_count != XAR(x)->header.toc_length_compressed) ) {\n\t\tXAR(x)->offset = 0;\n\t\tif( (XAR(x)->readbuf_len - off) + XAR(x)->toc_count > XAR(x)->header.toc_length_compressed )\n\t\t\tret = xar_read_fd(XAR(x)->fd, XAR(x)->readbuf, XAR(x)->header.toc_length_compressed - XAR(x)->toc_count);\n\t\telse\n\t\t\tret = read(XAR(x)->fd, XAR(x)->readbuf, XAR(x)->readbuf_len);\n\t\tif ( ret == -1 )\n\t\t\treturn ret;\n\n\t\tif ( XAR(x)->docksum )\n\t\t\tEVP_DigestUpdate(&XAR(x)->toc_ctx, XAR(x)->readbuf, ret);\n\n\t\tXAR(x)->toc_count += ret;\n\t\toff += ret;\n\t}\n\n\tif( off && (off < XAR(x)->readbuf_len) )\n\t\tXAR(x)->readbuf_len = off;\n\tXAR(x)->zs.next_in = XAR(x)->readbuf + XAR(x)->offset;\n\tXAR(x)->zs.avail_in = XAR(x)->readbuf_len - XAR(x)->offset;\n\tXAR(x)->zs.next_out = (void *)buffer;\n\tXAR(x)->zs.avail_out = len;\n\n\tret = inflate(&XAR(x)->zs, Z_SYNC_FLUSH);\n\tif( ret < 0 )\n\t\treturn -1;\n\n\tXAR(x)->offset = XAR(x)->readbuf_len - XAR(x)->zs.avail_in;\n\n\treturn len - XAR(x)->zs.avail_out;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_opt_set\n * x: the archive to set the option of\n * option: the name of the option to set the value of\n * value: the value to set the option to\n * Returns: 0 for sucess, -1 for failure\n */\n", "func_signal": "int32_t xar_opt_set(xar_t x, const char *option, const char *value)", "code": "{\n\txar_attr_t i, a;\n\n\tif( (strcmp(option, XAR_OPT_TOCCKSUM) == 0) ) {\n\t\tif( strcmp(value, XAR_OPT_VAL_NONE) == 0 ) {\n\t\t\tXAR(x)->heap_offset = 0;\n\t\t}\n\t\tif( strcmp(value, XAR_OPT_VAL_SHA1) == 0 ) {\n\t\t\tXAR(x)->heap_offset = 20;\n\t\t}\n\t\tif( strcmp(value, XAR_OPT_VAL_MD5) == 0 ) {\n\t\t\tXAR(x)->heap_offset = 16;\n\t\t}\n\t}\n\tfor(i = XAR(x)->attrs; i ; i = XAR_ATTR(i)->next) {\n\t\tif(strcmp(XAR_ATTR(i)->key, option)==0) {\n\t\t\tfree((char*)XAR_ATTR(i)->value);\n\t\t\tXAR_ATTR(i)->value = strdup(value);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ta = xar_attr_new();\n\tXAR_ATTR(a)->key = strdup(option);\n\tXAR_ATTR(a)->value = strdup(value);\n\tXAR_ATTR(a)->next = XAR(x)->attrs;\n\tXAR(x)->attrs = a;\n\treturn 0;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_open\n * file: filename to open\n * flags: flags on how to open the file.  0 for readonly, !0 for read/write\n * Returns: allocated and initialized xar structure with an open\n * file descriptor to the target xar file.  If the xarchive is opened\n * for writing, the file is created, and a heap file is opened.\n */\n", "func_signal": "xar_t xar_open(const char *file, int32_t flags)", "code": "{\n\txar_t ret;\n\n\tret = xar_new();\n\tif( !ret ) return NULL;\n\tif( !file )\n\t\tfile = \"-\";\n\tXAR(ret)->filename = strdup(file);\n\tOpenSSL_add_all_digests();\n\tif( flags ) {\n\t\tchar *tmp1, *tmp2, *tmp3, *tmp4;\n\t\ttmp1 = tmp2 = strdup(file);\n\t\ttmp3 = dirname(tmp2);\n\t\tXAR(ret)->dirname = strdup(tmp3);\n\t\t/* Create the heap file in the directory which will contain\n\t\t * the target archive.  /tmp or elsewhere may fill up.\n\t\t */\n\t\tasprintf(&tmp4, \"%s/xar.heap.XXXXXX\", tmp3);\n\t\tfree(tmp1);\n\t\tif( strcmp(file, \"-\") == 0 )\n\t\t\tXAR(ret)->fd = 1;\n\t\telse{\n\t\t\tXAR(ret)->fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_EXLOCK, 0644);\n\t\t\tif( (-1 == XAR(ret)->fd ) && (ENOTSUP == errno) ){\n\t\t\t\tXAR(ret)->fd = open(file, O_WRONLY | O_CREAT | O_TRUNC , 0644);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tXAR(ret)->heap_fd = mkstemp(tmp4);\n\t\tif( XAR(ret)->heap_fd < 0 ) {\n\t\t\tclose(XAR(ret)->fd);\n\t\t\tfree(XAR(ret));\n\t\t\treturn NULL;\n\t\t}\n\t\tunlink(tmp4);\n\t\tfree(tmp4);\n\n\t\tdeflateInit(&XAR(ret)->zs, Z_BEST_COMPRESSION);\n\n\t\tif( XAR(ret)->fd < 0 ) {\n\t\t\txar_close(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* default to using sha1, if nothing else is\n\t\t * specified.\n\t\t */\n\t\tXAR(ret)->heap_offset += 20;\n\t\tXAR(ret)->heap_len += 20;\n\t\t\n\t\txar_opt_set(ret, XAR_OPT_COMPRESSION, XAR_OPT_VAL_GZIP);\n\t\txar_opt_set(ret, XAR_OPT_FILECKSUM, XAR_OPT_VAL_SHA1);\n\t} else {\n\t\tunsigned char toccksum[EVP_MAX_MD_SIZE];\n\t\tunsigned char cval[EVP_MAX_MD_SIZE];\n\t\tunsigned int tlen;\n\t\tconst EVP_MD *md;\n\n\t\tif( strcmp(file, \"-\") == 0 )\n\t\t\tXAR(ret)->fd = 0;\n\t\telse{\n\t\t\tXAR(ret)->fd = open(file, O_RDONLY | O_SHLOCK);\n\t\t\t\n\t\t\tif( (-1 == XAR(ret)->fd ) && (ENOTSUP == errno) ){\n\t\t\t\tXAR(ret)->fd = open(file, O_RDONLY);\n\t\t\t}\n\n\t\t}\n\t\tXAR(ret)->heap_fd = -1;\n\t\tinflateInit(&XAR(ret)->zs);\n\t\tif( XAR(ret)->fd < 0 ) {\n\t\t\txar_close(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif( xar_parse_header(ret) != 0 ) {\n\t\t\txar_close(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch(XAR(ret)->header.cksum_alg) {\n\t\tcase XAR_CKSUM_NONE:\n\t\t\tbreak;\n\t\tcase XAR_CKSUM_SHA1:\n\t\t\tXAR(ret)->docksum = 1;\n\t\t\tmd = EVP_get_digestbyname(\"sha1\");\n\t\t\tEVP_DigestInit(&XAR(ret)->toc_ctx, md);\n\t\t\tbreak;\n\t\tcase XAR_CKSUM_MD5:\n\t\t\tXAR(ret)->docksum = 1;\n\t\t\tmd = EVP_get_digestbyname(\"md5\");\n\t\t\tEVP_DigestInit(&XAR(ret)->toc_ctx, md);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown hashing algorithm, skipping\\n\");\n\t\t\tbreak;\n\t\t};\n\n\t\tif( xar_unserialize(ret) != 0 ) {\n\t\t\txar_close(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif( !XAR(ret)->docksum )\n\t\t\treturn ret;\n\n\t\tEVP_DigestFinal(&XAR(ret)->toc_ctx, toccksum, &tlen);\n\n\t\txar_read_fd(XAR(ret)->fd, cval, tlen);\n\t\tXAR(ret)->heap_offset += tlen;\n\t\tif( memcmp(cval, toccksum, tlen) != 0 ) {\n\t\t\tfprintf(stderr, \"Checksums do not match!\\n\");\n\t\t\txar_close(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}", "path": "OtherSources\\lib\\xar\\archive.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* xar_data_archive\n * This is the arcmod archival entry point for archiving the file's\n * data into the heap file.\n */\n", "func_signal": "int32_t xar_data_archive(xar_t x, xar_file_t f, const char *file, const char *buffer, size_t len)", "code": "{\n\tconst char *opt;\n\tint32_t retval = 0;\n\tstruct _data_context context;\n\txar_prop_t tmpp;\n\t\n\tmemset(&context,0,sizeof(struct _data_context));\n\n\txar_prop_get(f, \"type\", &opt);\n\tif(!opt) return 0;\n\tif( strcmp(opt, \"file\") != 0 ) {\n\t\tif( strcmp(opt, \"hardlink\") == 0 ) {\n\t\t\topt = xar_attr_get(f, \"type\", \"link\");\n\t\t\tif( !opt )\n\t\t\t\treturn 0;\n\t\t\tif( strcmp(opt, \"original\") != 0 )\n\t\t\t\treturn 0;\n\t\t\t/* else, we're an original hardlink, so keep going */\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\tif( 0 == len ){\n\t\tcontext.fd = open(file, O_RDONLY);\n\t\tif( context.fd < 0 ) {\n\t\t\txar_err_new(x);\n\t\t\txar_err_set_file(x, f);\n\t\t\txar_err_set_string(x, \"io: Could not open file\");\n\t\t\txar_err_callback(x, XAR_SEVERITY_NONFATAL, XAR_ERR_ARCHIVE_CREATION);\n\t\t\treturn -1;\n\t\t}\t\t\n\t}else{\n\t\tcontext.buffer = (void *)buffer;\n\t\tcontext.length = len;\n\t\tcontext.offset = 0;\n\t}\n\n#ifdef F_NOCACHE\n\tfcntl(context.fd, F_NOCACHE, 1);\n#endif\n\n\ttmpp = xar_prop_pset(f, NULL, \"data\", NULL);\n\tretval = xar_attrcopy_to_heap(x, f, tmpp, xar_data_read,(void *)(&context));\n\tif( context.total == 0 )\n\t\txar_prop_unset(f, \"data\");\n\n\tif(context.fd > 0){\n\t\tclose(context.fd);\n\t\tcontext.fd = -1;\n\t}\n\t\n\treturn retval;\n}", "path": "OtherSources\\lib\\xar\\data.c", "repo_name": "aral/DocSets-for-iOS", "stars": 26, "license": "None", "language": "c", "size": 6820}
{"docstring": "/* GObject */\n", "func_signal": "static void\nvim_editor_instance_init (GObject *object)", "code": "{\n\tVimEditor *editor = VIM_EDITOR (object);\n\teditor->priv = g_new0 (VimEditorPrivate, 1);\n\teditor->priv->widget = g_object_new (VIM_TYPE_WIDGET, NULL);\n}", "path": "src\\vim-editor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* TODO: Incomplete */\n", "func_signal": "static IAnjutaEditorAttribute\nicell_get_attribute (IAnjutaEditorCell *icell, GError **err)", "code": "{\n\tVimEditorCell* cell = VIM_CELL(icell);\n\treturn IANJUTA_EDITOR_TEXT;\n}", "path": "src\\vim-cell.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Complete the document addition process */\n", "func_signal": "void\nvim_widget_add_document_complete (VimWidget *widget, VimEditor *editor)", "code": "{\n    IAnjutaDocumentManager *docman;\n    if (g_ptr_array_find (widget->priv->unloaded, editor) != -1)\n        g_ptr_array_remove (widget->priv->unloaded, editor);\n\n    g_ptr_array_add (widget->priv->documents, editor);\n    editor->priv->loaded = TRUE;\n\tvim_editor_update_variables (editor);\n    docman = anjuta_shell_get_interface (ANJUTA_PLUGIN(widget->priv->plugin)->shell, \n            IAnjutaDocumentManager, NULL);\n    ianjuta_document_manager_add_document (docman, IANJUTA_DOCUMENT(editor), NULL);\n}", "path": "src\\vim-widget.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/**\n * vim_queue_exec : Executes the list of commands. Removes them\n * from the command list as it does so.\n *\n * @widget: The instance that holds the DBus Session\n *\n * Returns: \n *\n */\n", "func_signal": "static void \nvim_queue_exec (VimWidget* widget)", "code": "{\n\tGList* node;\n\tfor (node=cmd_list; node != NULL; node = g_list_next (node))\n\t\tvim_dbus_exec_without_reply (widget, (gchar*) node->data, NULL);\n\tg_list_foreach (cmd_list, (GFunc)g_free, NULL);\n\tg_list_free (cmd_list);\n\tcmd_list = NULL;\n}", "path": "src\\vim-dbus.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* IAnjutaEditorMultiple */\n", "func_signal": "static IAnjutaEditorMaster*\nimultiple_get_master (IAnjutaEditorMultiple *imultiple, GError **err)", "code": "{\n\tVimEditor* editor = VIM_EDITOR (imultiple);\n\treturn IANJUTA_EDITOR_MASTER (editor->priv->widget);\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Change the string to a message */\n", "func_signal": "static guint\nvim_comm_gen_message (VimWidget *widget, gchar **cmd, gboolean isexpr)", "code": "{\n    static guint serial = 0;\n\tGdkWindow *window = gtk_widget_get_root_window (GTK_WIDGET(widget));\n\tXID xid = GDK_WINDOW_XID(window);\n    gchar *tmp, *cmd_str;\n    gint len;\n    serial++;\n\tlen = 1+(1+1)+(3+strlen(widget->priv->servername)+1)+(3+strlen(*cmd)+1)+(3+8+8+1);\n    cmd_str = tmp = (gchar*) malloc (sizeof(gchar)*len);\n    tmp += sprintf (tmp,\"\") + 1;\n    tmp += sprintf (tmp,\"%c\", (isexpr)?'c':'k') + 1;\n    tmp += sprintf (tmp,\"-n %s\", widget->priv->servername) + 1;\n    tmp += sprintf (tmp,\"-s %s\", *cmd) + 1;\n    tmp += sprintf (tmp,\"-r %x %d\", xid, len) + 1;\n    //tmp += sprintf (tmp,\"-r %x %d\", xid, serial);\n    *cmd = cmd_str;\n    len = tmp - cmd_str;\n    return len;\n}", "path": "src\\vim-comm.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Filename may have changed */\n", "func_signal": "void \nvim_signal_buf_file_post_cb (DBusGProxy *proxy, const guint bufno, \n\t\tconst gchar* filename, VimWidget *widget)", "code": "{\n\tVimEditor *editor = vim_widget_get_document_bufno (widget, bufno, NULL);\n\tif (!editor) return;\n\tGFile *file = g_file_new_for_path (filename);\n\tif (g_file_equal(editor->priv->file, file))\n\t{\n\t\tg_object_unref (editor->priv->file);\n\t\teditor->priv->file = file;\n\t}\n}", "path": "src\\vim-widget.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Signal Callbacks */\n", "func_signal": "void \nvim_signal_buf_new_file_cb (DBusGProxy *proxy, const guint bufno, \n\t\tVimWidget *widget)", "code": "{\n\tGFile *file = g_file_new_for_path (UNTITLED_FILE);\n\tVimEditor *editor;\n\tif (!(editor = vim_widget_get_document_file (widget, file, NULL)))\n        editor = vim_editor_new (NULL, file);\n\teditor->priv->bufno = bufno;\n\tif (!vim_widget_has_editor (widget, editor))\n\t\tvim_widget_add_document_complete (widget, editor);\n}", "path": "src\\vim-widget.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Class Implementation */\n", "func_signal": "VimEditorCell*\nvim_cell_new (VimEditor* editor, gint position)", "code": "{\n\tVimEditorCell *cell;\n\t\n\tg_return_val_if_fail (VIM_IS_EDITOR (editor), NULL);\n\tg_return_val_if_fail (position >= 0, NULL);\n\tif (position == 0)\n\t\tposition = 1;\n\t\n\tcell = VIM_CELL (g_object_new(VIM_TYPE_CELL, NULL));\n\t\n\tg_object_ref (editor);\n\tcell->priv->editor = editor;\n\tvim_cell_set_position (cell, position);\n\treturn cell;\n}", "path": "src\\vim-cell.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* IAnjutaFileSavable Interface */\n", "func_signal": "static gboolean\nisave_is_dirty (IAnjutaFileSavable *obj, GError **err)", "code": "{\n\tVimEditor* editor = VIM_EDITOR (obj);\n\treturn vim_dbus_int_query (editor->priv->widget, \"&modified\", err);\n}", "path": "src\\vim-ifile.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Convert from position to line */\n", "func_signal": "static gint \nieditor_get_line_from_position(IAnjutaEditor *ieditor, \n\t\t\t\t\t\t\t\t\t\t   IAnjutaIterable* icell, GError **err)", "code": "{\n\tVimEditor *editor = (VimEditor*) ieditor;\n\tgchar* query = NULL;\n\n\tg_assert (err == NULL);\n\t// Create query string\n\tquery = g_strdup_printf (\"byte2line(%d)\", ianjuta_iterable_get_position (icell, err));\n\treturn vim_dbus_int_query (editor->priv->widget, query, err);\n\t\n\t// TODO: Error Handling...\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* TODO: Multibyte support */\n", "func_signal": "static gchar\nicell_get_char (IAnjutaEditorCell *icell, gint char_index, GError **err)", "code": "{\n\tVimEditorCell* cell = VIM_CELL(icell);\n\tgchar chr;\n\tgchar* result ;\n\t// FIXME: Seems highly sub-optimal\n\n\tif (!cell->priv->line || cell->priv->begin > cell->priv->position || cell->priv->end < cell->priv->position)\n\t{\n\t\tgint len;\n\t\tgchar* tmp_str;\n\t\tgchar** str_array;\n\t\tif (cell->priv->line)\n\t\t{\n\t\t\tg_free (cell->priv->line);\n\t\t\tcell->priv->line = NULL;\n\t\t}\n\t\tgchar* cmd = g_strdup_printf (\"AnjutaGetLine(%d,%d)\", cell->priv->editor->priv->bufno, \n\t\t\t\tcell->priv->position);\n\t\t/* result is in the format [begin, end, 'line'] */\n\t\tresult = vim_dbus_query (cell->priv->editor->priv->widget, cmd, err);\n\t\tif (!result) \n\t\t{\n\t\t\tg_free (cmd);\n\t\t\tg_free (result);\n\t\t\treturn 0;\n\t\t}\n\t\tparse_vim_arr (result, &cell->priv->begin, &cell->priv->end, &cell->priv->line);\n\t\t\n\t\tg_free (cmd);\n\t\tg_free (result);\n\t}\n\n\tchr = cell->priv->line [cell->priv->position - cell->priv->begin];\n\n\treturn chr;\n}", "path": "src\\vim-cell.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Return the length of the text in the buffer */\n/* FIXME: Returns the bytes in file. Doesn't match with the number of\n * characters in a multibyte file */\n", "func_signal": "static gint \nieditor_get_length(IAnjutaEditor *ieditor, GError **err)", "code": "{\n\tVimEditor *editor = (VimEditor*) ieditor;\n\treturn vim_dbus_int_query (editor->priv->widget, \"AnjutaPos('$')\", err);\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Insert text at position */\n", "func_signal": "static void \nieditor_insert(IAnjutaEditor *ieditor, IAnjutaIterable* icell,\n\t\t\t\t\t\t\t   const gchar* text, gint length, GError **err)", "code": "{\n\tVimEditor *editor = (VimEditor*) ieditor;\n\tgchar* query = NULL;\n\tgint position = ianjuta_iterable_get_position (icell, err);\n\n\tg_assert (err == NULL);\n    query = g_strdup_printf (\"call AnjutaInsert (%d, \\\"%s\\\", %d)\", \n\t\t\teditor->priv->bufno,\n\t\t\ttext, \n\t\t\tposition-1); /* the default insert is infact an append */\n\n\tvim_dbus_exec_without_reply (editor->priv->widget, query, err);\n\tg_free (query);\n\t\n\t// TODO: Error Handling...\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Return line of cursor */\n", "func_signal": "static gint\nieditor_get_lineno(IAnjutaEditor *ieditor, GError **err)", "code": "{\n\tVimEditor *editor = (VimEditor*) ieditor;\n\treturn vim_dbus_int_query (editor->priv->widget, \"line ('.')\", err);\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Scroll to position */\n", "func_signal": "static void \nieditor_goto_position(IAnjutaEditor *ieditor, IAnjutaIterable* icell,\n\t\t\t\t\t\t\t\t  GError **err)", "code": "{\n\tVimEditor *editor = VIM_EDITOR (ieditor);\n\tgchar* query = NULL;\n\n\tg_assert (err == NULL);\n\t// Create query string\n\tquery = g_strdup_printf (\":goto %d\", ianjuta_iterable_get_position (icell, err));\n\tvim_dbus_exec_without_reply (editor->priv->widget, query, err);\n\tg_free (query);\n\t\n\tvim_widget_grab_focus (editor->priv->widget);\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Complete the document removal process */\n", "func_signal": "void\nvim_widget_remove_document_complete (VimWidget *widget, VimEditor *editor)", "code": "{\n    IAnjutaDocumentManager *docman;\n\tGFile *file = g_file_new_for_path (UNTITLED_FILE);\n\t/* The phantom \"Untitled document\" */\n\tVimEditor *null_editor = vim_widget_get_document_file (widget, file, NULL);\n\tVimEditor *next_editor = NULL;\n\n\tg_return_if_fail (editor != NULL);\n\n\t/* Check for the phantom \"Untitled\" document */\n    g_ptr_array_remove (widget->priv->documents, editor);\n    if (null_editor && widget->priv->documents->len == 1)\n        g_ptr_array_remove (widget->priv->documents, null_editor);\n\n\t/* Set this to null until vim signals the change */\n    if (widget->priv->documents->len == 0)\n        widget->priv->current_editor = NULL;\n    else\n        widget->priv->current_editor = g_ptr_array_index (widget->priv->documents, 0);\n\n    docman = anjuta_shell_get_interface (ANJUTA_PLUGIN(widget->priv->plugin)->shell, \n            IAnjutaDocumentManager, NULL);\n    ianjuta_document_manager_remove_document (docman, IANJUTA_DOCUMENT(editor), TRUE, NULL);\n\tgtk_object_destroy (GTK_OBJECT(editor));\n\n\t/*\n\tg_signal_emit_by_name (editor,\n\t\t\t\"destroy\");\n\t*/\n\n\tg_object_unref (file);\n    /* One for the master's reference */\n\tg_object_unref (editor);\n}", "path": "src\\vim-widget.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* Get cursor position */\n", "func_signal": "static IAnjutaIterable*\nieditor_get_position (IAnjutaEditor* ieditor, GError **err)", "code": "{\n\tVimEditor *editor = (VimEditor*) ieditor;\n\tVimEditorCell *cell;\n\tgchar* reply = NULL;\n\tgint position;\n\n\tg_assert (err == NULL);\n\tposition = vim_dbus_int_query(editor->priv->widget, \"AnjutaPos('.')\", err);\n\n\tcell = vim_cell_new (editor, position);\n\t// TODO: Error Handling...\n\n\treturn IANJUTA_ITERABLE (cell);\n}", "path": "src\\vim-ieditor.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* TODO: Send more data */\n", "func_signal": "void vim_signal_insert_leave_cb (DBusGProxy *proxy, const guint bufno, \n\t\tVimWidget *widget)", "code": "{\n\tVimEditor *editor = vim_widget_get_document_bufno (widget, bufno, NULL);\n\tvim_editor_update_variables (editor);\n}", "path": "src\\vim-widget.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/* IAnjutaIterable implementation */\n", "func_signal": "static gboolean\niiter_first (IAnjutaIterable* iter, GError** e)", "code": "{\n\tVimEditorCell* cell = VIM_CELL(iter);\n\tcell->priv->position = 1;\n\treturn TRUE;\n}", "path": "src\\vim-cell.c", "repo_name": "arunchaganty/vimjuta", "stars": 17, "license": "other", "language": "c", "size": 1236}
{"docstring": "/*\n * We have to take care about parsing because the headers may be split\n * into multiple fragments.  They may contain unknown headers with arbitrary\n * argument lengths.  So, we parse using a single-character at a time state\n * machine that is completely independent of packet size.\n */\n", "func_signal": "int\nlibwebsocket_read(struct libwebsocket_context *context,\n\t\t     struct libwebsocket *wsi, unsigned char * buf, size_t len)", "code": "{\n\tsize_t n;\n\n\tswitch (wsi->state) {\n\tcase WSI_STATE_HTTP:\n\t\twsi->state = WSI_STATE_HTTP_HEADERS;\n\t\twsi->parser_state = WSI_TOKEN_NAME_PART;\n\t\t/* fallthru */\n\tcase WSI_STATE_HTTP_HEADERS:\n\n\t\tdebug(\"issuing %d bytes to parser\\n\", (int)len);\n#ifdef DEBUG\n\t\tfwrite(buf, 1, len, stderr);\n#endif\n\n\t\tswitch (wsi->mode) {\n\t\tcase LWS_CONNMODE_WS_CLIENT_WAITING_PROXY_REPLY:\n\t\tcase LWS_CONNMODE_WS_CLIENT_ISSUE_HANDSHAKE:\n\t\tcase LWS_CONNMODE_WS_CLIENT_WAITING_SERVER_REPLY:\n\t\tcase LWS_CONNMODE_WS_CLIENT_WAITING_EXTENSION_CONNECT:\n\t\tcase LWS_CONNMODE_WS_CLIENT:\n\t\t\tfor (n = 0; n < len; n++)\n\t\t\t\tlibwebsocket_client_rx_sm(wsi, *buf++);\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* LWS_CONNMODE_WS_SERVING */\n\n\t\tfor (n = 0; n < len; n++)\n\t\t\tlibwebsocket_parse(wsi, *buf++);\n\n\t\tif (wsi->parser_state != WSI_PARSING_COMPLETE)\n\t\t\tbreak;\n\n\t\tdebug(\"seem to be serving, mode is %d\\n\", wsi->mode);\n\n\t\tdebug(\"libwebsocket_parse sees parsing complete\\n\");\n\n\t\t/* is this websocket protocol or normal http 1.0? */\n\n\t\tif (!wsi->utf8_token[WSI_TOKEN_UPGRADE].token_len ||\n\t\t\t     !wsi->utf8_token[WSI_TOKEN_CONNECTION].token_len) {\n\t\t\twsi->state = WSI_STATE_HTTP;\n\t\t\tif (wsi->protocol->callback)\n\t\t\t\t(wsi->protocol->callback)(context, wsi,\n\t\t\t\t   LWS_CALLBACK_HTTP, wsi->user_space,\n\t\t\t\t   wsi->utf8_token[WSI_TOKEN_GET_URI].token, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!wsi->protocol)\n\t\t\tfprintf(stderr, \"NULL protocol at libwebsocket_read\\n\");\n\n\t\t/*\n\t\t * It's websocket\n\t\t *\n\t\t * Make sure user side is happy about protocol\n\t\t */\n\n\t\twhile (wsi->protocol->callback) {\n\n\t\t\tif (wsi->utf8_token[WSI_TOKEN_PROTOCOL].token == NULL) {\n\t\t\t\tif (wsi->protocol->name == NULL)\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tif (wsi->protocol->name && strcmp(\n\t\t\t\t     wsi->utf8_token[WSI_TOKEN_PROTOCOL].token,\n\t\t\t\t\t\t      wsi->protocol->name) == 0)\n\t\t\t\t\tbreak;\n\n\t\t\twsi->protocol++;\n\t\t}\n\n\t\t/* we didn't find a protocol he wanted? */\n\n\t\tif (wsi->protocol->callback == NULL) {\n\t\t\tif (wsi->utf8_token[WSI_TOKEN_PROTOCOL].token == NULL)\n\t\t\t\tfprintf(stderr, \"[no protocol] \"\n\t\t\t\t\t\"not supported (use NULL .name)\\n\");\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Requested protocol %s \"\n\t\t\t\t\t\t\"not supported\\n\",\n\t\t\t\t     wsi->utf8_token[WSI_TOKEN_PROTOCOL].token);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/*\n\t\t * find out which spec version the client is using\n\t\t * if this header is not given, we default to 00 (aka 76)\n\t\t */\n\n\t\tif (wsi->utf8_token[WSI_TOKEN_VERSION].token_len)\n\t\t\twsi->ietf_spec_revision =\n\t\t\t\t atoi(wsi->utf8_token[WSI_TOKEN_VERSION].token);\n\n\t\t/*\n\t\t * Give the user code a chance to study the request and\n\t\t * have the opportunity to deny it\n\t\t */\n\n\t\tif ((wsi->protocol->callback)(wsi->protocol->owning_server, wsi,\n\t\t\t\tLWS_CALLBACK_FILTER_PROTOCOL_CONNECTION,\n\t\t\t\t\t\t&wsi->utf8_token[0], NULL, 0)) {\n\t\t\tfprintf(stderr, \"User code denied connection\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\n\t\t/*\n\t\t * Perform the handshake according to the protocol version the\n\t\t * client announced\n\t\t */\n\n\t\tswitch (wsi->ietf_spec_revision) {\n\t\tcase 0: /* applies to 76 and 00 */\n\t\t\twsi->xor_mask = xor_no_mask;\n\t\t\tif (handshake_00(context, wsi))\n\t\t\t\tgoto bail;\n\t\t\tbreak;\n\t\tcase 4: /* 04 */\n\t\t\twsi->xor_mask = xor_mask_04;\n\t\t\tdebug(\"libwebsocket_parse calling handshake_04\\n\");\n\t\t\tif (handshake_0405(context, wsi))\n\t\t\t\tgoto bail;\n\t\t\tbreak;\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\n\t\tcase 13:\n\t\t\twsi->xor_mask = xor_mask_05;\n\t\t\tdebug(\"libwebsocket_parse calling handshake_04\\n\");\n\t\t\tif (handshake_0405(context, wsi))\n\t\t\t\tgoto bail;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown client spec version %d\\n\",\n\t\t\t\t\t\t       wsi->ietf_spec_revision);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tdebug(\"accepted v%02d connection\\n\",\n\t\t\t\t\t\t       wsi->ietf_spec_revision);\n\n\t\tbreak;\n\n\tcase WSI_STATE_AWAITING_CLOSE_ACK:\n\tcase WSI_STATE_ESTABLISHED:\n\t\tswitch (wsi->mode) {\n\t\tcase LWS_CONNMODE_WS_CLIENT:\n\t\t\tfor (n = 0; n < len; n++)\n\t\t\t\tif (libwebsocket_client_rx_sm(wsi, *buf++) < 0)\n\t\t\t\t\tgoto bail;\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* LWS_CONNMODE_WS_SERVING */\n\n\t\tif (libwebsocket_interpret_incoming_packet(wsi, buf, len) < 0)\n\t\t\tgoto bail;\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nbail:\n\tlibwebsocket_close_and_free_session(context, wsi,\n\t\t\t\t\t\t     LWS_CLOSE_STATUS_NOSTATUS);\n\n\treturn -1;\n}", "path": "src\\wvServer\\handshake.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsockets_get_peer_addresses() - Get client address information\n * @fd:\t\tConnection socket descriptor\n * @name:\tBuffer to take client address name\n * @name_len:\tLength of client address name buffer\n * @rip:\tBuffer to take client address IP qotted quad\n * @rip_len:\tLength of client address IP buffer\n *\n *\tThis function fills in @name and @rip with the name and IP of\n *\tthe client connected with socket descriptor @fd.  Names may be\n *\ttruncated if there is not enough room.  If either cannot be\n *\tdetermined, they will be returned as valid zero-length strings.\n */\n", "func_signal": "void\nlibwebsockets_get_peer_addresses(int fd, char *name, int name_len,\n\t\t\t\t\tchar *rip, int rip_len)", "code": "{\n\tunsigned int len;\n\tstruct sockaddr_in sin;\n\tstruct hostent *host;\n\tstruct hostent *host1;\n\tchar ip[128];\n\tunsigned char *p;\n\tint n;\n\tstruct sockaddr_un *un;\n\n\trip[0] = '\\0';\n\tname[0] = '\\0';\n\n\tlen = sizeof sin;\n\tif (getpeername(fd, (struct sockaddr *) &sin, &len) < 0) {\n\t\tperror(\"getpeername\");\n\t\treturn;\n\t}\n\n\thost = gethostbyaddr((char *) &sin.sin_addr, sizeof sin.sin_addr,\n\t\t\t\t\t\t\t\t       AF_INET);\n\tif (host == NULL) {\n\t\tperror(\"gethostbyaddr\");\n\t\treturn;\n\t}\n\n\tstrncpy(name, host->h_name, name_len);\n\tname[name_len - 1] = '\\0';\n\n\thost1 = gethostbyname(host->h_name);\n\tif (host1 == NULL)\n\t\treturn;\n\tp = (unsigned char *)host1;\n\tn = 0;\n\twhile (p != NULL) {\n\t\tp = (unsigned char *)host1->h_addr_list[n++];\n\t\tif (p == NULL)\n\t\t\tcontinue;\n\t\tif ((host1->h_addrtype != AF_INET)\n#ifdef AF_LOCAL\n\t\t\t&& (host1->h_addrtype != AF_LOCAL)\n#endif\n\t\t\t)\n\t\t\tcontinue;\n\n\t\tif (host1->h_addrtype == AF_INET)\n\t\t\tsprintf(ip, \"%u.%u.%u.%u\", p[0], p[1], p[2], p[3]);\n#ifdef AF_LOCAL\n\t\telse {\n\t\t\tun = (struct sockaddr_un *)p;\n\t\t\tstrncpy(ip, un->sun_path, sizeof(ip) - 1);\n\t\t\tip[sizeof(ip) - 1] = '\\0';\n\t\t}\n#endif\n\t\tp = NULL;\n\t\tstrncpy(rip, ip, rip_len);\n\t\trip[rip_len - 1] = '\\0';\n\t}\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   buildApplied - implement OCSM_APPLIEDs for ocsmBuild               *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "static int\nbuildApplied(modl_T *modl,\n             int    ibrch,\n             int    *nstack,\n             int    stack[],\n             int    npatn,\n             patn_T patn[])", "code": "{\n    int       status = SUCCESS;         /* (out) return status */\n\n    modl_T    *MODL = (modl_T*)modl;\n\n    int        nelist, *ielist = NULL;\n    int        itype, nlist, type, i, j, iedge, iface, nface, nedge;\n    int        iford1, iford2, jford1, jford2, ibody, ibodyl, iprnt, jbrch, ipmtr, jpmtr;\n    CINT       *tempIlist;\n    double     args[10];\n    CDOUBLE    *tempRlist;\n    CCHAR      *tempClist;\n\n    #if   defined(GEOM_CAPRI)\n        int        ivol, ivoll, nnode, nbound, imodel, ibeg, mfile;\n        double     matrix[3][4];\n        char       *name, *mdum;\n    #elif defined(GEOM_EGADS)\n        int        nremove, nf;\n        ego        ebody, ebodyl, *eedges, *efaces, eremove[10];\n        ego        *eelist = NULL, *eflist = NULL;\n    #endif\n\n    ROUTINE(buildApplied);\n    DPRINT2(\"%s(ibrch=%d) {\",\n            routine, ibrch);\n\n    /* --------------------------------------------------------------- */\n\n    type = MODL->brch[ibrch].type;\n\n    /* get the values for the arguments */\n    if (MODL->brch[ibrch].narg >= 1) {\n        status = str2val(MODL->brch[ibrch].arg1, MODL, &args[1]);\n        CHECK_STATUS(str2val:val1);\n    } else {\n        args[1] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 2) {\n        status = str2val(MODL->brch[ibrch].arg2, MODL, &args[2]);\n        CHECK_STATUS(str2val:val2);\n    } else {\n        args[2] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 3) {\n        status = str2val(MODL->brch[ibrch].arg3, MODL, &args[3]);\n        CHECK_STATUS(str2val:val3);\n    } else {\n        args[3] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 4) {\n        status = str2val(MODL->brch[ibrch].arg4, MODL, &args[4]);\n        CHECK_STATUS(str2val:val4);\n    } else {\n        args[4] = 0;\n    }\n    args[5] = 0;\n    args[6] = 0;\n    args[7] = 0;\n    args[8] = 0;\n    args[9] = 0;\n\n    /* execute: \"fillet radius edgeList\" */\n    if (type == OCSM_FILLET) {\n        SPRINT3(1, \"    executing [%4d] fillet:     %11.5f    %s\",\n                ibrch, args[1], &(MODL->brch[ibrch].arg2[1]));\n\n        /* check for a positive radius */\n        if (args[1] <= 0) {\n            status = OCSM_ILLEGAL_ARGUMENT;\n            CHECK_STATUS(fillet);\n        }\n\n        /* pop a Body from the stack */\n        if ((*nstack) < 1) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(fillet);\n        } else {\n            ibodyl = stack[--(*nstack)];\n        }\n\n        /* check that ibodyl is not a Sketch */\n        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(fillet);\n        }\n\n        /* cycle back from ibodyl to find the closest left parent Body that\n           was either a PRIMITIVE, GROWN, or BOOLEAN */\n        iprnt = ibodyl;\n        while (iprnt != 0) {\n            jbrch = MODL->body[iprnt].ibrch;\n            if (MODL->brch[jbrch].class == OCSM_PRIMITIVE ||\n                MODL->brch[jbrch].class == OCSM_GROWN     ||\n                MODL->brch[jbrch].class == OCSM_BOOLEAN     ) break;\n            iprnt = MODL->body[iprnt].ileft;\n        }\n\n        /* initialize the list of Edges to which fillets should be applied */\n        nelist = 0;\n        MALLOC(ielist, int, MODL->body[ibodyl].nedge);\n\n        /* apply fillet to all Edges if edgeList=0 OR iprnt is a Boolean */\n        if (strcmp(MODL->brch[ibrch].arg2, \"$0\") == 0  ||\n            MODL->body[iprnt].brtype == OCSM_INTERSECT ||\n            MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||\n            MODL->body[iprnt].brtype == OCSM_UNION       ) {\n\n            #if   defined(GEOM_CAPRI)\n                for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                    ivoll  = MODL->body[ibodyl].ivol;\n                    status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                 &itype, &nlist,\n                                                 &tempIlist, &tempRlist, &tempClist);\n                    CHECK_STATUS(gi_dGetEntAttribute);\n\n                    if (tempIlist[0] == iprnt) {\n                        ielist[nelist++] = iedge;\n                    }\n                }\n            #elif defined(GEOM_EGADS)\n                ebodyl = MODL->body[ibodyl].ebody;\n\n                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                for (iedge = 1; iedge <= nedge; iedge++) {\n                    status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                             &itype, &nlist,\n                                             &tempIlist, &tempRlist, &tempClist);\n                    CHECK_STATUS(EG_attributeRet);\n\n                    if (tempIlist[0] == iprnt) {\n                        ielist[nelist++] = iedge;\n                    }\n                }\n\n                EG_free(eedges);\n            #endif\n\n        /* otherwise, process the edgeList (in order) */\n        } else {\n            jpmtr = 0;\n            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {\n                if (strcmp(MODL->pmtr[ipmtr].name, &(MODL->brch[ibrch].arg2[1])) == 0) {\n                    jpmtr = ipmtr;\n                    break;\n                }\n            }\n            if (jpmtr == 0) {\n                status = OCSM_ILLEGAL_PMTR_NAME;\n                CHECK_STATUS(fillet);\n            }\n\n            for (i = 0; i < MODL->pmtr[jpmtr].nrow; i++) {\n                iford1 = MODL->pmtr[jpmtr].value[2*i  ];\n                iford2 = MODL->pmtr[jpmtr].value[2*i+1];\n\n                /* add all Edges to ielist */\n                if (iford1 == 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            if (tempIlist[0] == iprnt) {\n                                ielist[nelist++] = iedge;\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            if (tempIlist[0] == iprnt) {\n                                ielist[nelist++] = iedge;\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* add Edges adjacent to +iford1 */\n                } else if (iford1 > 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == iford1 || jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == iford1 || jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* remove all Edges adjacent to -iford1 */\n                } else if (iford1 < 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == -iford1 || jford2 == -iford1) {\n                                    ielist[nelist++] = 0;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == -iford1 || jford2 == -iford1) {\n                                    for (j = 0; j < nelist; j++) {\n                                        if (ielist[j] == iedge) {\n                                            ielist[j] = 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* add Edges adjacent to +iford1 and +iford2 */\n                } else if (iford1 > 0 && iford2 > 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if        (jford1 == iford1 && jford2 == iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == iford2 && jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                   #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if        (jford1 == iford1 && jford2 == iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == iford2 && jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* remove Edges adjacent to -iford1 and -iford2 */\n                } else if (iford1 < 0 && iford2 < 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == 0) {\n                                if        (jford1 == -iford1 && jford2 == -iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == -iford2 && jford2 == -iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == 0) {\n                                if ((jford1 == -iford1 && jford2 == -iford2) ||\n                                    (jford1 == -iford2 && jford2 == -iford1)   ) {\n                                    for (j = 0; j < nelist; j++) {\n                                        if (ielist[j] == iedge) {\n                                            ielist[j] = 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n                }\n            }\n        }\n\n        /* remove deleted entries from the ielist */\n        for (j = 0; j < nelist; j++) {\n            if (ielist[j] == 0) {\n                ielist[j] = ielist[nelist-1];\n                nelist--;\n                j--;\n            }\n        }\n\n        for (i = 0; i < nelist; i++) {\n            DPRINT2(\"ielist[%3d] = %4d\", i, ielist[i]);\n        }\n        DPRINT1(\"radius      = %10.5f\", args[1]);\n\n        /* create the fillets */\n        if (nelist > 0) {\n\n            /* create the new Body */\n            status = newBody(MODL, ibrch, OCSM_FILLET, ibodyl, -1,\n                             args, OCSM_SOLID_BODY, &ibody);\n            CHECK_STATUS(newBody);\n\n            #if   defined(GEOM_CAPRI)\n                ivoll  = MODL->body[ibodyl].ivol;\n\n                status = gi_iGetDisplace(ivoll, &(matrix[0][0]));\n                CHECK_STATUS(gi_iGetDisplace);\n\n                status = gi_fAddFillet(ivoll, nelist, ielist, args[1]);\n                if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n                CHECK_STATUS(gi_gAddFillet);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n\n                status = gi_iSetDisplace(ivol, &(matrix[0][0]));\n                CHECK_STATUS(gi_iSetDisplace);\n\n                FREE(ielist);\n\n                MODL->body[ibody].ivol = ivol;\n            #elif defined(GEOM_EGADS)\n                ebodyl = MODL->body[ibodyl].ebody;\n\n                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                MALLOC(eelist, ego, nelist);\n\n                for (i = 0; i < nelist; i++) {\n                    SPRINT1(2, \"        fillet with iedge=%d\", ielist[i]);\n                    eelist[i] = eedges[ielist[i]-1];\n                }\n\n                EG_free(eedges);\n\n                status = EG_filletBody(ebodyl, nelist, eelist, args[1], &ebody);\n                CHECK_STATUS(EG_filletBody);\n\n                FREE(ielist);\n                FREE(eelist);\n\n                MODL->body[ibody].ebody = ebody;\n            #endif\n\n            /* mark the new Faces with the current Body */\n            #if   defined(GEOM_CAPRI)\n                status = gi_dGetVolume(ivol, &nnode, &nedge, &nface, &nbound, &name);\n                CHECK_STATUS(gi_dGetVolume);\n\n                for (iface = 1; iface <= nface; iface++) {\n                    status = gi_dGetEntAttribute(ivol, CAPRI_FACE, iface, \"body\", 0,\n                                                 &itype, &nlist,\n                                                 &tempIlist, &tempRlist, &tempClist);\n                    if (status == CAPRI_NOTFOUND) {\n                        status = setFaceAttribute(MODL, ibody, iface, iface, npatn, patn);\n                        CHECK_STATUS(setFaceAttribute);\n                    } else {\n                        CHECK_STATUS(gi_dGetEntAttribute);\n                    }\n                }\n            #elif defined(GEOM_EGADS)\n                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                for (iface = 1; iface <= nface; iface++) {\n                    status = EG_attributeRet(efaces[iface-1], \"body\",\n                                             &itype, &nlist,\n                                             &tempIlist, &tempRlist, &tempClist);\n                    if (status == EGADS_NOTFOUND) {\n                        status = setFaceAttribute(MODL, ibody, iface, iface, npatn, patn);\n                        CHECK_STATUS(setFaceAttribute);\n                    } else {\n                        CHECK_STATUS(EG_attributeRet);\n                    }\n                }\n\n                EG_free(efaces);\n            #endif\n\n            /* finish the Body */\n            status = finishBody(MODL, ibody);\n            CHECK_STATUS(finishBody);\n        } else {\n            SPRINT0(0, \"WARNING:: no edges for fillet\");\n            ibody = ibodyl;\n        }\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n\n    /* execute: \"chamfer radius edgeList\" */\n    } else if (type == OCSM_CHAMFER) {\n        SPRINT3(1, \"    executing [%4d] chamfer:    %11.5f   %s\",\n                ibrch, args[1], &(MODL->brch[ibrch].arg2[1]));\n\n        /* check for a positive radius */\n        if (args[1] <= 0) {\n            status = OCSM_ILLEGAL_ARGUMENT;\n            CHECK_STATUS(chamfer);\n        }\n\n        /* pop a Body from the stack */\n        if ((*nstack) < 1) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(chamfer);\n        } else {\n            ibodyl = stack[--(*nstack)];\n        }\n\n        /* check that ibodyl is not a Sketch */\n        if (MODL->body[ibodyl].botype != OCSM_SOLID_BODY) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(chamfer);\n        }\n\n        /* cycle back from ibodyl to find the closest left parent Body that\n           was either a PRIMITIVE, GROWN, or BOOLEAN */\n        iprnt = ibodyl;\n        while (iprnt != 0) {\n            jbrch = MODL->body[iprnt].ibrch;\n            if (MODL->brch[jbrch].class == OCSM_PRIMITIVE ||\n                MODL->brch[jbrch].class == OCSM_GROWN     ||\n                MODL->brch[jbrch].class == OCSM_BOOLEAN     ) break;\n            iprnt = MODL->body[iprnt].ileft;\n        }\n\n        /* initialize the list of Edges to which chamfers should be applied */\n        nelist = 0;\n        MALLOC(ielist, int, MODL->body[ibodyl].nedge);\n\n        /* apply chamfer to all Edges if edgeList=0 OR iprnt is a Boolean */\n        if (strcmp(MODL->brch[ibrch].arg2, \"$0\") == 0  ||\n            MODL->body[iprnt].brtype == OCSM_INTERSECT ||\n            MODL->body[iprnt].brtype == OCSM_SUBTRACT  ||\n            MODL->body[iprnt].brtype == OCSM_UNION       ) {\n\n            #if   defined(GEOM_CAPRI)\n                for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                    ivoll  = MODL->body[ibodyl].ivol;\n                    status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                 &itype, &nlist,\n                                                 &tempIlist, &tempRlist, &tempClist);\n                    CHECK_STATUS(gi_dGetEntAttribute);\n\n                    if (tempIlist[0] == iprnt) {\n                        ielist[nelist++] = iedge;\n                    }\n                }\n            #elif defined(GEOM_EGADS)\n                ebodyl = MODL->body[ibodyl].ebody;\n\n                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                for (iedge = 1; iedge <= nedge; iedge++) {\n                    status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                             &itype, &nlist,\n                                             &tempIlist, &tempRlist, &tempClist);\n                    CHECK_STATUS(EG_attributeRet);\n\n                    if (tempIlist[0] == iprnt) {\n                        ielist[nelist++] = iedge;\n                    }\n                }\n\n                EG_free(eedges);\n            #endif\n\n        /* otherwise, process the edgeList (in order) */\n        } else {\n            jpmtr = 0;\n            for (ipmtr = 1; ipmtr <= MODL->npmtr; ipmtr++) {\n                if (strcmp(MODL->pmtr[ipmtr].name, &(MODL->brch[ibrch].arg2[1])) == 0) {\n                    jpmtr = ipmtr;\n                    break;\n                }\n            }\n            if (jpmtr == 0) {\n                status = OCSM_ILLEGAL_PMTR_NAME;\n                CHECK_STATUS(chanfer);\n            }\n\n            for (i = 0; i < MODL->pmtr[jpmtr].nrow; i++) {\n                iford1 = MODL->pmtr[jpmtr].value[2*i  ];\n                iford2 = MODL->pmtr[jpmtr].value[2*i+1];\n\n                /* add all Edges to ielist */\n                if (iford1 == 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            if (tempIlist[0] == iprnt) {\n                                ielist[nelist++] = iedge;\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            if (tempIlist[0] == iprnt) {\n                                ielist[nelist++] = iedge;\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* add Edges adjacent to +iford1 */\n                } else if (iford1 > 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == iford1 || jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == iford1 || jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* remove all Edges adjacent to -iford1 */\n                } else if (iford1 < 0 && iford2 == 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == -iford1 || jford2 == -iford1) {\n                                    ielist[nelist++] = 0;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if (jford1 == -iford1 || jford2 == -iford1) {\n                                    for (j = 0; j < nelist; j++) {\n                                        if (ielist[j] == iedge) {\n                                            ielist[j] = 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* add Edges adjacent to +iford1 and +iford2 */\n                } else if (iford1 > 0 && iford2 > 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if        (jford1 == iford1 && jford2 == iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == iford2 && jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                   #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == iprnt) {\n                                if        (jford1 == iford1 && jford2 == iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == iford2 && jford2 == iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n\n                /* remove Edges adjacent to -iford1 and -iford2 */\n                } else if (iford1 < 0 && iford2 < 0) {\n                    #if   defined(GEOM_CAPRI)\n                        ivoll = MODL->body[ibodyl].ivol;\n\n                        for (iedge = 1; iedge <= MODL->body[ibodyl].nedge; iedge++) {\n                            status = gi_dGetEntAttribute(ivoll, CAPRI_EDGE, iedge, \"body\", 0,\n                                                         &itype, &nlist,\n                                                         &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(gi_dGetEntAttribute);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == 0) {\n                                if        (jford1 == -iford1 && jford2 == -iford2) {\n                                    ielist[nelist++] = iedge;\n                                } else if (jford1 == -iford2 && jford2 == -iford1) {\n                                    ielist[nelist++] = iedge;\n                                }\n                            }\n                        }\n                    #elif defined(GEOM_EGADS)\n                        ebodyl = MODL->body[ibodyl].ebody;\n\n                        status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        for (iedge = 1; iedge <= nedge; iedge++) {\n                            status = EG_attributeRet(eedges[iedge-1], \"body\",\n                                                     &itype, &nlist,\n                                                     &tempIlist, &tempRlist, &tempClist);\n                            CHECK_STATUS(EG_attributeRet);\n\n                            jford1 = tempIlist[1] % 100;\n                            jford2 = tempIlist[1] / 100;\n\n                            if (tempIlist[0] == 0) {\n                                if ((jford1 == -iford1 && jford2 == -iford2) ||\n                                    (jford1 == -iford2 && jford2 == -iford1)   ) {\n                                    for (j = 0; j < nelist; j++) {\n                                        if (ielist[j] == iedge) {\n                                            ielist[j] = 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        EG_free(eedges);\n                    #endif\n                }\n            }\n        }\n\n        /* remove deleted entries from the ielist */\n        for (j = 0; j < nelist; j++) {\n            if (ielist[j] == 0) {\n                ielist[j] = ielist[nelist-1];\n                nelist--;\n                j--;\n            }\n        }\n\n        for (i = 0; i < nelist; i++) {\n            DPRINT2(\"ielist[%3d] = %4d\", i, ielist[i]);\n        }\n        DPRINT1(\"radius      = %10.5f\", args[1]);\n\n        /* create the chamfers */\n        if (nelist > 0) {\n\n            /* create the new Body */\n            status = newBody(MODL, ibrch, OCSM_CHAMFER, ibodyl, -1,\n                             args, OCSM_SOLID_BODY, &ibody);\n            CHECK_STATUS(newBody);\n\n            #if   defined(GEOM_CAPRI)\n                ivoll  = MODL->body[ibodyl].ivol;\n\n                status = gi_iGetDisplace(ivoll, &(matrix[0][0]));\n                CHECK_STATUS(gi_iGetDisplace);\n\n                status = gi_fAddChamfer(ivoll, nelist, ielist, args[1], 45.0);\n                if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n                CHECK_STATUS(gi_gAddChamfer);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n\n                status = gi_iSetDisplace(ivol, &(matrix[0][0]));\n                CHECK_STATUS(gi_iSetDisplace);\n\n                FREE(ielist);\n\n                MODL->body[ibody].ivol = ivol;\n            #elif defined(GEOM_EGADS)\n                ebodyl = MODL->body[ibodyl].ebody;\n\n                status = EG_getBodyTopos(ebodyl, NULL, EDGE, &nedge, &eedges);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                MALLOC(eelist, ego, nelist);\n                MALLOC(eflist, ego, nelist);\n\n                for (i = 0; i < nelist; i++) {\n                    SPRINT1(2, \"        chamfer with iedge=%d\", ielist[i]);\n                    eelist[i] = eedges[ielist[i]-1];\n\n                    status = EG_getBodyTopos(ebodyl, eelist[i], FACE, &nf, &efaces);\n                    CHECK_STATUS(EG_getBodyTopos);\n\n                    eflist[i] = efaces[0];\n                    EG_free(efaces);\n                }\n\n                EG_free(eedges);\n\n                status = EG_chamferBody(ebodyl, nelist, eelist, eflist, args[1], args[1], &ebody);\n                CHECK_STATUS(EG_chamferBody);\n\n                FREE(ielist);\n                FREE(eelist);\n                FREE(eflist);\n\n                MODL->body[ibody].ebody = ebody;\n            #endif\n\n            /* mark the new Faces with the current Body */\n            #if   defined(GEOM_CAPRI)\n                status = gi_dGetVolume(ivol, &nnode, &nedge, &nface, &nbound, &name);\n                CHECK_STATUS(gi_dGetVolume);\n\n                for (iface = 1; iface <= nface; iface++) {\n                    status = gi_dGetEntAttribute(ivol, CAPRI_FACE, iface, \"body\", 0,\n                                                 &itype, &nlist,\n                                                 &tempIlist, &tempRlist, &tempClist);\n                    if (status == CAPRI_NOTFOUND) {\n                        status = setFaceAttribute(MODL, ibody, iface, iface, npatn, patn);\n                        CHECK_STATUS(setFaceAttribute);\n                    } else {\n                        CHECK_STATUS(gi_dGetEntAttribute);\n                    }\n                }\n            #elif defined(GEOM_EGADS)\n                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                for (iface = 1; iface <= nface; iface++) {\n                    status = EG_attributeRet(efaces[iface-1], \"body\",\n                                             &itype, &nlist,\n                                             &tempIlist, &tempRlist, &tempClist);\n                    if (status == EGADS_NOTFOUND) {\n                        status = setFaceAttribute(MODL, ibody, iface, iface, npatn, patn);\n                        CHECK_STATUS(setFaceAttribute);\n                    } else {\n                        CHECK_STATUS(EG_attributeRet);\n                    }\n                }\n\n                EG_free(efaces);\n            #endif\n\n            /* finish the Body */\n            status = finishBody(MODL, ibody);\n            CHECK_STATUS(finishBody);\n        } else {\n            SPRINT0(0, \"WARNING:: no edges for chamfer\");\n            ibody = ibodyl;\n        }\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n\n    /* execute: \"hollow thick iface1 iface2 iface3 iface4 iface5 iface6\" */\n    } else if (type == OCSM_HOLLOW) {\n        SPRINT8(1, \"    executing [%4d] hollow:     %11.5f %11.5f %11.5f %11.5f %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n\n        /* pop an Body from the stack */\n        if ((*nstack) < 1) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(hollow);\n        } else {\n            ibodyl = stack[--(*nstack)];\n        }\n\n        /* create the Body */\n        status = newBody(MODL, ibrch, OCSM_HOLLOW, ibodyl, -1,\n                         args, OCSM_SOLID_BODY, &ibody);\n        CHECK_STATUS(newBody);\n\n        /* generate the hollow */\n        #if   defined(GEOM_CAPRI)\n            status = OCSM_UNSUPPORTED;\n            CHECK_STATUS(hollow);\n        #elif defined(GEOM_EGADS)\n            ebodyl = MODL->body[ibodyl].ebody;\n\n            status = EG_getBodyTopos(ebodyl, NULL, FACE, &nface, &efaces);\n            CHECK_STATUS(EG_getBodyTopos);\n\n            nremove = 0;\n            if (NINT(args[2]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[2])-1];\n            }\n            if (NINT(args[3]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[3])-1];\n            }\n            if (NINT(args[4]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[4])-1];\n            }\n            if (NINT(args[5]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[5])-1];\n            }\n            if (NINT(args[6]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[6])-1];\n            }\n            if (NINT(args[7]) > 0) {\n                eremove[nremove++] = efaces[NINT(args[7])-1];\n            }\n\n            EG_free(efaces);\n\n            status = EG_hollowBody(ebodyl, nremove, eremove, args[1], 1, &ebody);\n            CHECK_STATUS(EG_hollowBody);\n\n            MODL->body[ibody].ebody = ebody;\n        #endif\n\n        /* mark the new Faces with the current Branch */\n        #if   defined(GEOM_CAPRI)\n        #elif defined(GEOM_EGADS)\n            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n            CHECK_STATUS(EG_getBodyTopos);\n\n            iford1 = 0;\n            for (iface = 1; iface <= nface; iface++) {\n                status = EG_attributeRet(efaces[iface-1], \"body\",\n                                         &itype, &nlist,\n                                         &tempIlist, &tempRlist, &tempClist);\n\n                if (status == EGADS_NOTFOUND) {\n                    iford1++;\n                    status = setFaceAttribute(MODL, ibody, iface, iford1, npatn, patn);\n                    CHECK_STATUS(setFaceAttribute);\n                } else {\n                    CHECK_STATUS(EG_attributeRet);\n                }\n            }\n\n            EG_free(efaces);\n        #endif\n\n        /* finish the Body */\n        status = finishBody(MODL, ibody);\n        CHECK_STATUS(finishBody);\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n    }\n\ncleanup:\n    FREE(ielist);\n\n    DPRINT2(\"%s --> status=%d}\", routine, status);\n    return status;\n}", "path": "src\\OpenCSM\\OpenCSM.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   udpMesh - return mesh associated with primitive                    *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "int\nudpMesh(ego    ebody,\n        int    iMesh,\n        int    *imax,\n        int    *jmax,\n        int    *kmax,\n        double **mesh)", "code": "{\n    int    iudp, judp, i2d, j2d, i3d, j3d, k3d;\n    double *Mesh=NULL;\n\n    *imax = 0;\n    *jmax = 0;\n    *kmax = 0;\n    *mesh = Mesh;\n\n    /* check that ebody matches one of the ebodys */\n    iudp = 0;\n    for (judp = 1; judp <= numUdp; judp++) {\n        if (ebody == ebodys[judp]) {\n            iudp = judp;\n            break;\n        }\n    }\n    if (iudp <= 0) {\n        return EGADS_NOTMODEL;\n    }\n\n    /* if a FaceBody, return the mesh */\n    if (Imax[iudp] > 1 && Jmax[iudp] > 1 && Kmax[iudp] == 1) {\n\n        /* mesh 1: i3d = i2d; j3d = j2d; k3d = 0 */\n        if (iMesh == 1) {\n            Mesh = (double *) EG_alloc(3*Imax[iudp]*Jmax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n\n            *imax = Imax[iudp];\n            *jmax = Jmax[iudp];\n            *kmax = Kmax[iudp];\n            *mesh = Mesh;\n\n            for (j3d = 0; j3d < Jmax[iudp]; j3d++) {\n                for (i3d = 0; i3d < Imax[iudp]; i3d++) {\n                    i2d = i3d;\n                    j2d = j3d;\n\n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*j3d];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*j3d];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*j3d];\n                }\n            }\n        } else {\n            *imax = 0;\n            *jmax = 0;\n            *kmax = 0;\n            *mesh = NULL;\n            \n            return EGADS_INDEXERR;\n        }\n\n    /* if a SolidBody, return one of the meshes */\n    } else if (Imax[iudp] > 1 && Jmax[iudp] > 1 && Kmax[iudp] > 1) {\n\n        /* mesh 1: i3d = 0; j3d = j2d; k3d = i2d */\n        if        (iMesh == 1) {\n            Mesh = (double *) EG_alloc(3*Jmax[iudp]*Kmax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Kmax[iudp];\n            *jmax = Jmax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n\n            for (k3d = 0; k3d < Kmax[iudp]; k3d++) {\n                for (j3d = 0; j3d < Jmax[iudp]; j3d++) {\n                    i3d = 0;\n\n                    i2d = k3d;\n                    j2d = j3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n\n        /* mesh 2: i3d = Imax-1; j3d = i2d; k3d = j2d */\n        } else if (iMesh == 2) {\n            Mesh = (double *) EG_alloc(3*Jmax[iudp]*Kmax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Jmax[iudp];\n            *jmax = Kmax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n            \n            for (k3d = 0; k3d < Kmax[iudp]; k3d++) {\n                for (j3d = 0; j3d < Jmax[iudp]; j3d++) {\n                    i3d = Imax[iudp] - 1;\n\n                    i2d = j3d;\n                    j2d = k3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n\n        /* mesh 3: i3d = i2d; j3d = 0; k3d = j2d */\n        } else if (iMesh == 3) {\n            Mesh = (double *) EG_alloc(3*Kmax[iudp]*Imax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Imax[iudp];\n            *jmax = Kmax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n            \n            for (i3d = 0; i3d < Imax[iudp]; i3d++) {\n                for (k3d = 0; k3d < Kmax[iudp]; k3d++) {\n                    j3d = 0;\n\n                    i2d = i3d;\n                    j2d = k3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n\n        /* mesh 4: i3d = j2d; j3d = Jmax-1; k3d = i2d */\n        } else if (iMesh == 4) {\n            Mesh = (double *) EG_alloc(3*Kmax[iudp]*Imax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Kmax[iudp];\n            *jmax = Imax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n            \n            for (i3d = 0; i3d < Imax[iudp]; i3d++) {\n                for (k3d = 0; k3d < Kmax[iudp]; k3d++) {\n                    j3d = Jmax[iudp] - 1;\n\n                    i2d = k3d;\n                    j2d = i3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n\n        /* mesh 5: i3d = j2d; j3d = i2d; k3d = 0 */\n        } else if (iMesh == 5) {\n            Mesh = (double *) EG_alloc(3*Imax[iudp]*Jmax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Jmax[iudp];\n            *jmax = Imax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n            \n            for (j3d = 0; j3d < Jmax[iudp]; j3d++) {\n                for (i3d = 0; i3d < Imax[iudp]; i3d++) {\n                    k3d = 0;\n\n                    i2d = j3d;\n                    j2d = i3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n\n        /* mesh 6: i3d = i2d; j3d = j2d; k3d = Kmax-1 */\n        } else if (iMesh == 6) {\n            Mesh = (double *) EG_alloc(3*Imax[iudp]*Jmax[iudp]*sizeof(double));\n            if (Mesh == NULL) return EGADS_MALLOC;\n            \n            *imax = Imax[iudp];\n            *jmax = Jmax[iudp];\n            *kmax = 1;\n            *mesh = Mesh;\n            \n            for (j3d = 0; j3d < Jmax[iudp]; j3d++) {\n                for (i3d = 0; i3d < Imax[iudp]; i3d++) {\n                    k3d = Kmax[iudp] - 1;\n\n                    i2d = i3d;\n                    j2d = j3d;\n                    \n                    Mesh[3*(i2d+j2d*(*imax))  ] = X[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+1] = Y[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                    Mesh[3*(i2d+j2d*(*imax))+2] = Z[iudp][i3d+Imax[iudp]*(j3d+Jmax[iudp]*k3d)];\n                }\n            }\n        } else {\n            *imax = 0;\n            *jmax = 0;\n            *kmax = 0;\n            *mesh = NULL;\n            \n            return EGADS_INDEXERR;\n        }\n\n    /* neither FaceBody nor SolidBody were loaded */\n    } else {\n        *imax = 0;\n        *jmax = 0;\n        *kmax = 0;\n        *mesh = NULL;\n            \n        return EGADS_NOTBODY;\n    }\n\n    return EGADS_SUCCESS;\n}", "path": "src\\OpenCSM\\udpFreeform.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsockets_fork_service_loop() - Optional helper function forks off\n *\t\t\t\t  a process for the websocket server loop.\n *\t\t\t\tYou don't have to use this but if not, you\n *\t\t\t\thave to make sure you are calling\n *\t\t\t\tlibwebsocket_service periodically to service\n *\t\t\t\tthe websocket traffic\n * @context:\tserver context returned by creation function\n */\n", "func_signal": "int\nlibwebsockets_fork_service_loop(struct libwebsocket_context *context)", "code": "{\n\tint fd;\n\tstruct sockaddr_in cli_addr;\n\tint n;\n\tint p;\n\n\tn = fork();\n\tif (n < 0)\n\t\treturn n;\n\n\tif (!n) {\n\n\t\t/* main process context */\n\n\t\t/*\n\t\t * set up the proxy sockets to allow broadcast from\n\t\t * service process context\n\t\t */\n\n\t\tfor (p = 0; p < context->count_protocols; p++) {\n\t\t\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\t\t\tif (fd < 0) {\n\t\t\t\tfprintf(stderr, \"Unable to create socket\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcli_addr.sin_family = AF_INET;\n\t\t\tcli_addr.sin_port = htons(\n\t\t\t     context->protocols[p].broadcast_socket_port);\n\t\t\tcli_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\t\tn = connect(fd, (struct sockaddr *)&cli_addr,\n\t\t\t\t\t\t\t       sizeof cli_addr);\n\t\t\tif (n < 0) {\n\t\t\t\tfprintf(stderr, \"Unable to connect to \"\n\t\t\t\t\t\t\"broadcast socket %d, %s\\n\",\n\t\t\t\t\t\tn, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcontext->protocols[p].broadcast_socket_user_fd = fd;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* we want a SIGHUP when our parent goes down */\n\tprctl(PR_SET_PDEATHSIG, SIGHUP);\n\n\t/* in this forked process, sit and service websocket connections */\n\n\twhile (1)\n\t\tif (libwebsocket_service(context, 1000))\n\t\t\treturn -1;\n\n\treturn 0;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsocket_set_timeout() - marks the wsi as subject to a timeout\n *\n * You will not need this unless you are doing something special\n *\n * @wsi:\tWebsocket connection instance\n * @reason:\ttimeout reason\n * @secs:\thow many seconds\n */\n", "func_signal": "void\nlibwebsocket_set_timeout(struct libwebsocket *wsi,\n\t\t\t\t\t  enum pending_timeout reason, int secs)", "code": "{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\n\twsi->pending_timeout_limit = tv.tv_sec + secs;\n\twsi->pending_timeout = reason;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsocket_callback_on_writable() - Request a callback when this socket\n *\t\t\t\t\t becomes able to be written to without\n *\t\t\t\t\t blocking\n *\n * @context:\tlibwebsockets context\n * @wsi:\tWebsocket connection instance to get callback for\n */\n", "func_signal": "int\nlibwebsocket_callback_on_writable(struct libwebsocket_context *context,\n\t\t\t\t\t\t      struct libwebsocket *wsi)", "code": "{\n\tint n;\n\tint handled = 0;\n\n\t/* maybe an extension will take care of it for us */\n\n\tfor (n = 0; n < wsi->count_active_extensions; n++) {\n\t\tif (!wsi->active_extensions[n]->callback)\n\t\t\tcontinue;\n\n\t\thandled |= wsi->active_extensions[n]->callback(context,\n\t\t\twsi->active_extensions[n], wsi,\n\t\t\tLWS_EXT_CALLBACK_REQUEST_ON_WRITEABLE,\n\t\t\t\t       wsi->active_extensions_user[n], NULL, 0);\n\t}\n\n\tif (handled)\n\t\treturn 1;\n\n\tfor (n = 0; n < context->fds_count; n++)\n\t\tif (context->fds[n].fd == wsi->sock) {\n\t\t\tcontext->fds[n].events |= POLLOUT;\n\t\t\tn = context->fds_count + 1;\n\t\t}\n\n\tif (n == context->fds_count)\n\t\tfprintf(stderr, \"libwebsocket_callback_on_writable: \"\n\t\t\t\t      \"failed to find socket %d\\n\", wsi->sock);\n\n\t/* external POLL support via protocol 0 */\n\tcontext->protocols[0].callback(context, wsi,\n\t\tLWS_CALLBACK_SET_MODE_POLL_FD,\n\t\t(void *)(long)wsi->sock, NULL, POLLOUT);\n\n\treturn 1;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   buildSketch - implement OCSM_SKETCHs for ocsmBuild                 *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "static int\nbuildSketch(modl_T *modl,\n            int    ibrch,\n            int    *nstack,\n            int    stack[],\n            int    npatn,\n            patn_T patn[],\n            int    *nskpt,\n            skpt_T skpt[])", "code": "{\n    int       status = SUCCESS;         /* (out) return status */\n\n    modl_T    *MODL = (modl_T*)modl;\n\n    int       type, i, n, nspln=0, ibody, iopen;\n    double    args[10], xlast, ylast, zlast;\n    double    xmin, xmax, ymin, ymax, zmin, zmax, pts[3*MAX_SKETCH_SIZE];\n    double    dx1, dy1, dz1, ds1, dx2, dy2, dz2, ds2, dot;\n\n    #if   defined(GEOM_CAPRI)\n        int        nsketch=0;\n        double     orig[3], xaxis[3], yaxis[3];\n    #elif defined(GEOM_EGADS)\n        int        iseg, nseg, sense[MAX_SKETCH_SIZE], header[4], ii, jj;\n        int        iface, nface, iter, niter;\n        double     data[20], tdata[2], *cp=NULL, result[3], du, dx, dy, dz;\n        double     scent, xcent, ycent, zcent, dxyzmax;\n        ego        ebody, *efaces, ecurve, eflip, eloop;\n        ego        Enodes[MAX_SKETCH_SIZE+1], Eedges[MAX_SKETCH_SIZE], Efaces[1];\n    #endif\n\n    ROUTINE(buildSketch);\n    DPRINT2(\"%s(ibrch=%d) {\",\n            routine, ibrch);\n\n    /* --------------------------------------------------------------- */\n\n    type = MODL->brch[ibrch].type;\n\n    /* get the values for the arguments */\n    if (MODL->brch[ibrch].narg >= 1) {\n        status = str2val(MODL->brch[ibrch].arg1, MODL, &args[1]);\n        CHECK_STATUS(str2val:val1);\n    } else {\n        args[1] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 2) {\n        status = str2val(MODL->brch[ibrch].arg2, MODL, &args[2]);\n        CHECK_STATUS(str2val:val2);\n    } else {\n        args[2] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 3) {\n        status = str2val(MODL->brch[ibrch].arg3, MODL, &args[3]);\n        CHECK_STATUS(str2val:val3);\n    } else {\n        args[3] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 4) {\n        status = str2val(MODL->brch[ibrch].arg4, MODL, &args[4]);\n        CHECK_STATUS(str2val:val4);\n    } else {\n        args[4] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 5) {\n        status = str2val(MODL->brch[ibrch].arg5, MODL, &args[5]);\n        CHECK_STATUS(str2val:val5);\n    } else {\n        args[5] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 6) {\n        status = str2val(MODL->brch[ibrch].arg6, MODL, &args[6]);\n        CHECK_STATUS(str2val:val6);\n    } else {\n        args[6] = 0;\n    }\n    args[7] = 0;\n    args[8] = 0;\n    args[9] = 0;\n\n    /* execute: \"skbeg x y z\" */\n    if (type == OCSM_SKBEG) {\n        SPRINT4(1, \"    executing [%4d] skbeg:      %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3]);\n\n        /* add the point to the sketch */\n        skpt[(*nskpt)].itype = OCSM_SKBEG;\n        skpt[(*nskpt)].ibrch = ibrch;\n        skpt[(*nskpt)].x     = args[1];\n        skpt[(*nskpt)].y     = args[2];\n        skpt[(*nskpt)].z     = args[3];\n        (*nskpt)++;\n\n        status = newBody(MODL, ibrch, OCSM_SKBEG, -1, -1,\n                         args, OCSM_SKETCH, &ibody);\n        CHECK_STATUS(newBody);\n\n    /* execute: \"linseg x y z\" */\n    } else if (type == OCSM_LINSEG) {\n        SPRINT4(1, \"    executing [%4d] linseg:     %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3]);\n\n        /* add the linseg to the sketch */\n        skpt[(*nskpt)].itype = OCSM_LINSEG;\n        skpt[(*nskpt)].ibrch = ibrch;\n        skpt[(*nskpt)].x     = args[1];\n        skpt[(*nskpt)].y     = args[2];\n        skpt[(*nskpt)].z     = args[3];\n        (*nskpt)++;\n\n        status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,\n                         args, OCSM_SKETCH, &ibody);\n        CHECK_STATUS(newBody);\n\n    /* execute: \"cirarc xon yon zon xend yend zend\" */\n    } else if (type == OCSM_CIRARC) {\n        SPRINT7(1, \"    executing [%4d] cirarc:     %11.5f %11.5f %11.5f %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3], args[4],\n                       args[5], args[6]);\n\n        /* check for the colinearity of the 3 points */\n        dx1 = args[1] - skpt[(*nskpt)-1].x;\n        dy1 = args[2] - skpt[(*nskpt)-1].y;\n        dz1 = args[3] - skpt[(*nskpt)-1].z;\n        ds1 = sqrt(dx1*dx1 + dy1*dy1 + dz1*dz1);\n\n        dx2 = args[4] - args[1];\n        dy2 = args[5] - args[2];\n        dz2 = args[6] - args[3];\n        ds2 = sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);\n\n        dot = (dx1*dx2 + dy1*dy2 + dz1*dz2) / ds1 / ds2;\n\n        /* if points are co-linear, convert to a linseg */\n        if (fabs(dot) > 0.9999) {\n            SPRINT0(0, \"WARNING:: converting to linseg since points are colinear\");\n\n            skpt[(*nskpt)].itype = OCSM_LINSEG;\n            skpt[(*nskpt)].ibrch = ibrch;\n            skpt[(*nskpt)].x     = args[4];\n            skpt[(*nskpt)].y     = args[5];\n            skpt[(*nskpt)].z     = args[6];\n            (*nskpt)++;\n\n            status = newBody(MODL, ibrch, OCSM_LINSEG, MODL->nbody, -1,\n                             &(args[3]), OCSM_SKETCH, &ibody);\n            CHECK_STATUS(newBody);\n\n        /* add the cirarc to the sketch (as two entries) */\n        } else {\n            skpt[(*nskpt)].itype = OCSM_CIRARC;\n            skpt[(*nskpt)].ibrch = ibrch;\n            skpt[(*nskpt)].x     = args[1];\n            skpt[(*nskpt)].y     = args[2];\n            skpt[(*nskpt)].z     = args[3];\n            (*nskpt)++;\n\n            skpt[(*nskpt)].itype = OCSM_CIRARC;\n            skpt[(*nskpt)].ibrch = ibrch;\n            skpt[(*nskpt)].x     = args[4];\n            skpt[(*nskpt)].y     = args[5];\n            skpt[(*nskpt)].z     = args[6];\n            (*nskpt)++;\n\n            status = newBody(MODL, ibrch, OCSM_CIRARC, MODL->nbody, -1,\n                             args, OCSM_SKETCH, &ibody);\n            CHECK_STATUS(newBody);\n        }\n\n    /* execute: \"spline x y z\" */\n    } else if (type == OCSM_SPLINE) {\n        SPRINT4(1, \"    executing [%4d] spline:     %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3]);\n\n        /* add the spline to the sketch */\n        skpt[(*nskpt)].itype = OCSM_SPLINE;\n        skpt[(*nskpt)].ibrch = ibrch;\n        skpt[(*nskpt)].x     = args[1];\n        skpt[(*nskpt)].y     = args[2];\n        skpt[(*nskpt)].z     = args[3];\n        (*nskpt)++;\n\n        status = newBody(MODL, ibrch, OCSM_SPLINE, MODL->nbody, -1,\n                         args, OCSM_SKETCH, &ibody);\n        CHECK_STATUS(newBody);\n\n    /* execute: \"skend\" */\n    } else if (type == OCSM_SKEND) {\n        SPRINT1(1, \"    executing [%4d] skend:\",\n                ibrch);\n\n        /* add the skend to the sketch */\n        skpt[(*nskpt)].itype = OCSM_SKEND;\n        skpt[(*nskpt)].ibrch = ibrch;\n        skpt[(*nskpt)].x     = skpt[(*nskpt)-1].x;\n        skpt[(*nskpt)].y     = skpt[(*nskpt)-1].y;\n        skpt[(*nskpt)].z     = skpt[(*nskpt)-1].z;\n        (*nskpt)++;\n\n        /* if we have only one Sketch point, the we are creating a OCSM_NODE_BODY */\n        if ((*nskpt) == 2) {\n            /* close the sketcher */\n            (*nskpt) = 0;\n\n            /* create the Body */\n            status = newBody(MODL, ibrch, OCSM_SKEND, -1, -1,\n                             args, OCSM_NODE_BODY, &ibody);\n            CHECK_STATUS(newBody);\n\n            #if   defined(GEOM_CAPRI)\n                status = OCSM_UNSUPPORTED;\n                CHECK_STATUS(skend);\n            #elif defined(GEOM_EGADS)\n                pts[0] = skpt[0].x;\n                pts[1] = skpt[0].y;\n                pts[2] = skpt[0].z;\n\n                status = EG_makeTopology(MODL->context, NULL, NODE, 0, pts, 0, NULL, NULL, &ebody);\n                CHECK_STATUS(EG_makeTopology);\n\n                MODL->body[ibody].ebody = ebody;\n            #endif\n\n            /* push the Body onto the stack */\n            stack[(*nstack)++] = ibody;\n\n            SPRINT1(1, \"                          Node   %4d created\", ibody);\n\n        } else {\n\n            /* find the extrema of the sketch points */\n            xmin = skpt[0].x;\n            xmax = skpt[0].x;\n            ymin = skpt[0].y;\n            ymax = skpt[0].y;\n            zmin = skpt[0].z;\n            zmax = skpt[0].z;\n            DPRINT5(\"skpnt[%3d] %3d %10.5f %10.5f %10.5f\",\n                    0, skpt[0].itype, skpt[0].x, skpt[0].y, skpt[0].z);\n\n            for (i = 1; i < (*nskpt); i++) {\n                if (skpt[i].x < xmin) xmin = skpt[i].x;\n                if (skpt[i].x > xmax) xmax = skpt[i].x;\n                if (skpt[i].y < ymin) ymin = skpt[i].y;\n                if (skpt[i].y > ymax) ymax = skpt[i].y;\n                if (skpt[i].z < zmin) zmin = skpt[i].z;\n                if (skpt[i].z > zmax) zmax = skpt[i].z;\n\n                DPRINT5(\"skpnt[%3d] %3d %10.5f %10.5f %10.5f\",\n                        i, skpt[i].itype, skpt[i].x, skpt[i].y, skpt[i].z);\n            }\n\n//$$$                if        (xmin == xmax && ymin == ymax) {\n//$$$                    SPRINT4(0, \"xmin=%11.5f, xmax=%11.5f, ymin=%11.5f, ymax=%11.5f\", xmin, xmax, ymin, ymax);\n//$$$                    status = OCSM_COLINEAR_SKETCH_POINTS;\n//$$$                    CHECK_STATUS(skend);\n//$$$                } else if (ymin == ymax && zmin == zmax) {\n//$$$                    SPRINT4(0, \"ymin=%11.5f, ymax=%11.5f, zmin=%11.5f, zmax=%11.5f\", ymin, ymax, zmin, zmax);\n//$$$                    status = OCSM_COLINEAR_SKETCH_POINTS;\n//$$$                    CHECK_STATUS(skend);\n//$$$                } else if (zmin == zmax && xmin == xmax) {\n//$$$                    SPRINT4(0, \"zmin=%11.5f, zmax=%11.5f, xmin=%11.5f, xmax=%11.5f\", zmin, zmax, xmin, xmax);\n//$$$                    status = OCSM_COLINEAR_SKETCH_POINTS;\n//$$$                    CHECK_STATUS(skend);\n//$$$                }\n\n            /* create the sketch plane */\n            #if   defined(GEOM_CAPRI)\n                if        (xmin == xmax) {\n                    orig[ 0] = xmin; orig[ 1] = 0.0;  orig[ 2] = 0.0;\n                    xaxis[0] = 0.0;  xaxis[1] = 1.0;  xaxis[2] = 0.0;\n                    yaxis[0] = 0.0;  yaxis[1] = 0.0;  yaxis[2] = 1.0;\n                } else if (ymin == ymax) {\n                    orig[ 0] = 0.0;  orig[ 1] = ymin; orig[ 2] = 0.0;\n                    xaxis[0] = 0.0;  xaxis[1] = 0.0;  xaxis[2] = 1.0;\n                    yaxis[0] = 1.0;  yaxis[1] = 0.0;  yaxis[2] = 0.0;\n                } else if (zmin == zmax) {\n                    orig[ 0] = 0.0;  orig[ 1] = 0.0;  orig[ 2] = zmin;\n                    xaxis[0] = 1.0;  xaxis[1] = 0.0;  xaxis[2] = 0.0;\n                    yaxis[0] = 0.0,  yaxis[1] = 1.0,  yaxis[2] = 0.0;\n                } else {\n                    status = OCSM_NON_COPLANAR_SKETCH_POINTS;\n                    CHECK_STATUS(skend);\n                }\n\n                DPRINT3(\"orig  = %10.5f %10.5f %10.5f\",  orig[0],  orig[1],  orig[2]);\n                DPRINT3(\"xaxis = %10.5f %10.5f %10.5f\", xaxis[0], xaxis[1], xaxis[2]);\n                DPRINT3(\"yaxis = %10.5f %10.5f %10.5f\", yaxis[0], yaxis[1], yaxis[2]);\n\n                status = gi_sCreate(orig, xaxis, yaxis, NULL);\n                CHECK_STATUS(gi_sCreate);\n            #elif defined(GEOM_EGADS)\n            #endif\n\n            /* determine if the sketch is open or closed */\n            if (fabs(skpt[(*nskpt)-2].x-skpt[0].x) < EPS06 &&\n                fabs(skpt[(*nskpt)-2].y-skpt[0].y) < EPS06 &&\n                fabs(skpt[(*nskpt)-2].z-skpt[0].z) < EPS06   ) {\n                iopen = 0;\n            } else {\n                iopen = 1;\n\n                #if   defined(GEOM_CAPRI)\n                    status = OCSM_SKETCH_DOES_NOT_CLOSE;\n                    CHECK_STATUS(skend);\n                #elif defined(GEOM_EGADS)\n                #endif\n            }\n            DPRINT1(\"iopen=%d\", iopen);\n\n            /* create the beginning node */\n            #if   defined(GEOM_CAPRI)\n            #elif defined(GEOM_EGADS)\n                nseg = 0;\n                pts[0] = skpt[0].x;\n                pts[1] = skpt[0].y;\n                pts[2] = skpt[0].z;\n                status = EG_makeTopology(MODL->context, NULL, NODE, 0,\n                                         pts, 0, NULL, NULL, &(Enodes[0]));\n                CHECK_STATUS(EG_makeTopology);\n            #endif\n\n            /* save \"last\" point */\n            xlast = skpt[0].x;\n            ylast = skpt[0].y;\n            zlast = skpt[0].z;\n\n            /* no points in spline so far */\n            nspln = 0;\n\n            /* add the lines, circular-arcs, and splines to the sketch plane */\n            for (i = 1; i < (*nskpt); i++) {\n\n                /* if we were defining a spline but the new segment is not\n                   a spline, generate the spline now */\n                if (nspln > 0 && skpt[i].itype != OCSM_SPLINE) {\n                    if (nspln < 3) {\n                        status = OCSM_TOO_FEW_SPLINE_POINTS;\n                        CHECK_STATUS(skend);\n                    }\n\n                    DPRINT1(\"spline (w/%d points):\", nspln);\n                    #if   defined(GEOM_CAPRI)\n                        for (n = 0; n < nspln; n++) {\n                            DPRINT3(\"%5d %11.5f %11.5f\", n, pts[2*n], pts[2*n+1]);\n                        }\n\n                        status = gi_sAddEntity(4, nspln, pts);\n                        CHECK_STATUS(gi_sAddEntity);\n                    #elif defined(GEOM_EGADS)\n                        for (n = 0; n < nspln; n++) {\n                            DPRINT4(\"%5d %11.5f %11.5f %11.5f\",   n, pts[3*n], pts[3*n+1], pts[3*n+2]);\n                        }\n\n                        if (i < (*nskpt)-1 || iopen == 1) {\n                            data[0] = pts[3*nspln-3];\n                            data[1] = pts[3*nspln-2];\n                            data[2] = pts[3*nspln-1];\n                            status = EG_makeTopology(MODL->context, NULL, NODE, 0,\n                                                     data, 0, NULL, NULL, &(Enodes[nseg+1]));\n                            CHECK_STATUS(EG_makeTopology);\n                        } else {\n                            Enodes[nseg+1] = Enodes[0];\n                        }\n\n                        header[0] = 0;\n                        header[1] = 3;\n                        header[2] = nspln + 2;\n                        header[3] = nspln + 6;\n\n                        MALLOC(cp, double, header[3]+3*header[2]);\n\n                        /* knots (spaced according to pseudo-arc-length) */\n                        jj = 0;\n                        cp[jj] = 0; jj++;\n                        cp[jj] = 0; jj++;\n                        cp[jj] = 0; jj++;\n                        cp[jj] = 0; jj++;\n\n                        for (ii = 1; ii < nspln; ii++) {\n                            cp[jj] = cp[jj-1] + sqrt(pow(pts[3*ii  ]-pts[3*ii-3],2)\n                                                    +pow(pts[3*ii+1]-pts[3*ii-2],2)\n                                                    +pow(pts[3*ii+2]-pts[3*ii-1],2));\n                            jj++;\n                        }\n\n                        cp[jj] = cp[jj-1]; jj++;\n                        cp[jj] = cp[jj-1]; jj++;\n                        cp[jj] = cp[jj-1]; jj++;\n\n                        for (ii = 0; ii < header[3]; ii++) {\n                            cp[ii] /= cp[header[3]-1];\n                        }\n\n                        /* initial point */\n                        cp[jj] = pts[0]; jj++;\n                        cp[jj] = pts[1]; jj++;\n                        cp[jj] = pts[2]; jj++;\n\n                        /* initial interior point (for slope) */\n                        cp[jj] = (3 * pts[0] + pts[3]) / 4; jj++;\n                        cp[jj] = (3 * pts[1] + pts[4]) / 4; jj++;\n                        cp[jj] = (3 * pts[2] + pts[5]) / 4; jj++;\n\n                        /* interior points */\n                        for (ii = 1; ii < nspln-1; ii++) {\n                            cp[jj] = pts[3*ii  ]; jj++;\n                            cp[jj] = pts[3*ii+1]; jj++;\n                            cp[jj] = pts[3*ii+2]; jj++;\n                        }\n\n                        /* penultimate interior point (for slope) */\n                        cp[jj] = (3 * pts[3*nspln-3] + pts[3*nspln-6]) / 4; jj++;\n                        cp[jj] = (3 * pts[3*nspln-2] + pts[3*nspln-5]) / 4; jj++;\n                        cp[jj] = (3 * pts[3*nspln-1] + pts[3*nspln-4]) / 4; jj++;\n\n                        /* final point */\n                        cp[jj] = pts[3*nspln-3]; jj++;\n                        cp[jj] = pts[3*nspln-2]; jj++;\n                        cp[jj] = pts[3*nspln-1]; jj++;\n\n                        /* make the original BSPLINE (based upon the assumed control points) */\n                        status = EG_makeGeometry(MODL->context, CURVE, BSPLINE, NULL, header, cp, &ecurve);\n                        CHECK_STATUS(EG_makeGeometry);\n\n                        /* iterate to have knot evaluations match data points */\n                        niter = 100;\n                        for (iter = 0; iter < niter; iter++) {\n                            dxyzmax = 0;\n\n                            /* natural end condition at beginning */\n                            status = EG_evaluate(ecurve, &(cp[0]), data);\n                            CHECK_STATUS(EG_evaluate);\n\n                            /* note: the 0.01 is needed to make this work, buts its\n                               \"theoreical justification\" is unknown (perhap under-relaxation?) */\n                            du = cp[4] - cp[3];\n                            dx = 0.01 * du * du * data[6];\n                            dy = 0.01 * du * du * data[7];\n                            dz = 0.01 * du * du * data[8];\n\n                            if (fabs(dx/du) > dxyzmax) dxyzmax = fabs(dx/du);\n                            if (fabs(dy/du) > dxyzmax) dxyzmax = fabs(dy/du);\n                            if (fabs(dz/du) > dxyzmax) dxyzmax = fabs(dz/du);\n\n                            cp[header[3]+3] += dx;\n                            cp[header[3]+4] += dy;\n                            cp[header[3]+5] += dz;\n\n                            /* match interior spline points */\n                            for (ii = 1; ii < nspln-1; ii++) {\n                                status = EG_evaluate(ecurve, &(cp[ii+3]), data);\n                                CHECK_STATUS(EG_evaluate);\n\n                                dx = pts[3*ii  ] - data[0];\n                                dy = pts[3*ii+1] - data[1];\n                                dz = pts[3*ii+2] - data[2];\n\n                                if (fabs(dx) > dxyzmax) dxyzmax = fabs(dx);\n                                if (fabs(dy) > dxyzmax) dxyzmax = fabs(dy);\n                                if (fabs(dz) > dxyzmax) dxyzmax = fabs(dz);\n\n                                cp[header[3]+3*ii+3] += dx;\n                                cp[header[3]+3*ii+4] += dy;\n                                cp[header[3]+3*ii+5] += dz;\n                            }\n\n                            /* natural end condition at end */\n                            status = EG_evaluate(ecurve, &(cp[nspln+3]), data);\n                            CHECK_STATUS(EG_evaluate);\n\n                            du = cp[nspln+2] - cp[nspln+1];\n                            dx = 0.01 * du * du * data[6];\n                            dy = 0.01 * du * du * data[7];\n                            dz = 0.01 * du * du * data[8];\n\n                            if (fabs(dx/du) > dxyzmax) dxyzmax = fabs(dx/du);\n                            if (fabs(dy/du) > dxyzmax) dxyzmax = fabs(dy/du);\n                            if (fabs(dz/du) > dxyzmax) dxyzmax = fabs(dz/du);\n\n                            cp[header[3]+3*nspln  ] += dx;\n                            cp[header[3]+3*nspln+1] += dy;\n                            cp[header[3]+3*nspln+2] += dz;\n\n                            if (dxyzmax < EPS06) {\n                                niter = iter;\n                                break;\n                            }\n\n                            /* make the new curve */\n                            status = EG_deleteObject(ecurve);\n                            CHECK_STATUS(EG_deleteObject);\n\n                            status = EG_makeGeometry(MODL->context, CURVE, BSPLINE, NULL, header, cp, &ecurve);\n                            CHECK_STATUS(EG_makeGeometry);\n                        }\n\n                        status = EG_invEvaluate(ecurve, &(pts[0]),         &(tdata[0]), result);\n                        CHECK_STATUS(EG_invEvaluate);\n\n                        status = EG_invEvaluate(ecurve, &(pts[3*nspln-3]), &(tdata[1]), result);\n                        CHECK_STATUS(EG_invEvaluate);\n\n                        #ifdef SHOW_SPLINES\n                        {\n                            int    io_kbd=5, io_scr=6, indgr=1+4+16+64;\n                            int    i, nline=9, ilin[9], isym[9], nper[9];\n                            float  xplot[9000], yplot[9000];\n                            double uu, xyz3[9];\n\n                            for (i = 0; i < nline; i++) {\n                                ilin[i] = +i;\n                                isym[i] = -i;\n                                nper[i] = 1000;\n                            }\n\n                            for (i = 0; i < 1000; i++) {\n                                uu = tdata[0] + (double)i/999 * (tdata[1] - tdata[0]);\n\n                                EG_evaluate(ecurve, &uu, xyz3);\n\n                                xplot[      i] = uu;   yplot[      i] = xyz3[0];   //   x\n                                xplot[ 1000+i] = uu;   yplot[ 1000+i] = xyz3[1];   //   y\n                                xplot[ 2000+i] = uu;   yplot[ 2000+i] = xyz3[2];   //   z\n                                xplot[ 3000+i] = uu;   yplot[ 3000+i] = xyz3[3];   //  dx/du\n                                xplot[ 4000+i] = uu;   yplot[ 4000+i] = xyz3[4];   //  dy/du\n                                xplot[ 5000+i] = uu;   yplot[ 5000+i] = xyz3[5];   //  dz/du\n                                xplot[ 6000+i] = uu;   yplot[ 6000+i] = xyz3[6];   // d2x/du2\n                                xplot[ 7000+i] = uu;   yplot[ 7000+i] = xyz3[7];   // d2y/du2\n                                xplot[ 8000+i] = uu;   yplot[ 8000+i] = xyz3[8];   // d2z/du2\n                            }\n\n                            grinit_(&io_kbd, &io_scr, \"generation of spline in ocsmBuild\",\n                                               strlen(\"generation of spline in ocsmBuild\"));\n                            grline_(ilin, isym, &nline,                \"~x~y~spline data\",\n                                    &indgr, xplot, yplot, nper, strlen(\"~x~y~spline data\"));\n                        }\n                        #endif\n\n                        FREE(cp);\n\n                        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,\n                                                 tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));\n                        CHECK_STATUS(EG_makeTopology);\n\n                        nseg++;\n                    #endif\n\n                    nspln = 0;\n\n                    xlast = skpt[i-1].x;\n                    ylast = skpt[i-1].y;\n                    zlast = skpt[i-1].z;\n                }\n\n                /* if the new segment is a skend, stop now */\n                if (skpt[i].itype == OCSM_SKEND) {\n                    break;\n\n                /* add a linseg */\n                } else if (skpt[i].itype == OCSM_LINSEG) {\n                    if (fabs(xlast-skpt[i].x) < EPS06 &&\n                        fabs(ylast-skpt[i].y) < EPS06 &&\n                        fabs(zlast-skpt[i].z) < EPS06   ) {\n                        DPRINT0(\"skipped (zero length linseg)\");\n                    } else {\n                        #if   defined(GEOM_CAPRI)\n                            if        (xmin == xmax) {\n                                pts[0] = ylast;     pts[1] = zlast;\n                                pts[2] = skpt[i].y; pts[3] = skpt[i].z;\n                            } else if (ymin == ymax) {\n                                pts[0] = zlast;     pts[1] = xlast;\n                                pts[2] = skpt[i].z; pts[3] = skpt[i].x;\n                            } else {\n                                pts[0] = xlast;     pts[1] = ylast;\n                                pts[2] = skpt[i].x; pts[3] = skpt[i].y;\n                            }\n\n                            DPRINT0(\"linseg:\");\n                            DPRINT3(\"%5d %11.5f %11.5f\", 0, pts[0], pts[1]);\n                            DPRINT3(\"%5d %11.5f %11.5f\", 1, pts[2], pts[3]);\n\n                            status = gi_sAddEntity(2, 2, pts);\n                            CHECK_STATUS(gi_sAddEntity);\n                        #elif defined(GEOM_EGADS)\n                            DPRINT0(\"linseg:\");\n                            DPRINT4(\"%5d %11.5f %11.5f %11.5f\", 0, xlast,     ylast,     zlast    );\n                            DPRINT4(\"%5d %11.5f %11.5f %11.5f\", i, skpt[i].x, skpt[i].y, skpt[i].z);\n\n                            if (i < (*nskpt)-2 || iopen == 1) {\n                                pts[0] = skpt[i].x;\n                                pts[1] = skpt[i].y;\n                                pts[2] = skpt[i].z;\n                                status = EG_makeTopology(MODL->context, NULL, NODE, 0,\n                                                         pts, 0, NULL, NULL, &(Enodes[nseg+1]));\n                                CHECK_STATUS(EG_makeTopology);\n                            } else {\n                                Enodes[nseg+1] = Enodes[0];\n                            }\n\n                            pts[0] = xlast;\n                            pts[1] = ylast;\n                            pts[2] = zlast;\n                            pts[3] = skpt[i].x - xlast;\n                            pts[4] = skpt[i].y - ylast;\n                            pts[5] = skpt[i].z - zlast;\n                            status = EG_makeGeometry(MODL->context, CURVE, LINE, NULL, NULL, pts, &ecurve);\n                            CHECK_STATUS(EG_makeGeometry);\n\n                            status = EG_invEvaluate(ecurve, pts, &(tdata[0]), result);\n                            CHECK_STATUS(EG_invEvaluate);\n\n                            pts[0] = skpt[i].x;\n                            pts[1] = skpt[i].y;\n                            pts[2] = skpt[i].z;\n                            status = EG_invEvaluate(ecurve, pts, &(tdata[1]), result);\n                            CHECK_STATUS(EG_invEvaluate);\n\n                            status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,\n                                                     tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));\n                            CHECK_STATUS(EG_makeTopology);\n\n                            nseg++;\n                        #endif\n                    }\n\n                    xlast = skpt[i].x;\n                    ylast = skpt[i].y;\n                    zlast = skpt[i].z;\n\n                /* add a cirarc */\n                } else if (skpt[i].itype == OCSM_CIRARC) {\n                    #if   defined(GEOM_CAPRI)\n                        if        (xmin == xmax) {\n                            pts[0] = ylast;       pts[1] = zlast;\n                            pts[2] = skpt[i  ].y; pts[3] = skpt[i  ].z;\n                            pts[4] = skpt[i+1].y; pts[5] = skpt[i+1].z;\n                        } else if (ymin == ymax) {\n                            pts[0] = zlast;       pts[1] = xlast;\n                            pts[2] = skpt[i  ].z; pts[3] = skpt[i  ].x;\n                            pts[4] = skpt[i+1].z; pts[5] = skpt[i+1].x;\n                        } else {\n                            pts[0] = xlast;       pts[1] = ylast;\n                            pts[2] = skpt[i  ].x; pts[3] = skpt[i  ].y;\n                            pts[4] = skpt[i+1].x; pts[5] = skpt[i+1].y;\n                        }\n\n                        DPRINT0(\"cirarc:\");\n                        DPRINT3(\"%5d %11.5f %11.5f\", 0, pts[0], pts[1]);\n                        DPRINT3(\"%5d %11.5f %11.5f\", 1, pts[2], pts[3]);\n                        DPRINT3(\"%5d %11.5f %11.5f\", 2, pts[4], pts[5]);\n\n                        status = gi_sAddEntity(3, 3, pts);\n                        CHECK_STATUS(gi_sAddEntity);\n                    #elif defined(GEOM_EGADS)\n                        DPRINT0(\"cirarc:\");\n                        DPRINT4(\"%5d %11.5f %11.5f %11.5f\", 0,   xlast,       ylast,       zlast      );\n                        DPRINT4(\"%5d %11.5f %11.5f %11.5f\", i,   skpt[i  ].x, skpt[i  ].y, skpt[i  ].z);\n                        DPRINT4(\"%5d %11.5f %11.5f %11.5f\", i+1, skpt[i+1].x, skpt[i+1].y, skpt[i+1].z);\n\n                        if (i < (*nskpt)-3 || iopen == 1) {\n                            pts[0] = skpt[i+1].x;\n                            pts[1] = skpt[i+1].y;\n                            pts[2] = skpt[i+1].z;\n                            status = EG_makeTopology(MODL->context, NULL, NODE, 0,\n                                                     pts, 0, NULL, NULL, &(Enodes[nseg+1]));\n                            CHECK_STATUS(EG_makeTopology);\n                        } else {\n                            Enodes[nseg+1] = Enodes[0];\n                        }\n\n                        if        (xmin == xmax) {\n                            scent = ((skpt[i+1].y - ylast    ) * (skpt[i  ].y - skpt[i+1].y)\n                                    -(skpt[i+1].z - zlast    ) * (skpt[i+1].z - skpt[i  ].z))\n                                   /((zlast       - skpt[i].z) * (skpt[i  ].y - skpt[i+1].y)\n                                   - (skpt[i].y   - ylast    ) * (skpt[i+1].z - skpt[i  ].z));\n                            ycent = (ylast + skpt[i].y + scent * (zlast     - skpt[i].z)) / 2;\n                            zcent = (zlast + skpt[i].z + scent * (skpt[i].y - ylast    )) / 2;\n\n                            data[0] = xmin;\n                            data[1] = ycent;\n                            data[2] = zcent;\n                            data[3] = 0;\n                            data[4] = ylast - ycent;\n                            data[5] = zlast - zcent;\n                            data[6] = 0;\n                            data[7] = -data[5];\n                            data[8] = +data[4];\n                            data[9] = sqrt(pow(ylast-ycent,2) + pow(zlast-zcent,2));\n\n                        } else if (ymin == ymax) {\n                            scent = ((skpt[i+1].z - zlast    ) * (skpt[i  ].z - skpt[i+1].z)\n                                    -(skpt[i+1].x - xlast    ) * (skpt[i+1].x - skpt[i  ].x))\n                                   /((xlast       - skpt[i].x) * (skpt[i  ].z - skpt[i+1].z)\n                                   - (skpt[i].z   - zlast    ) * (skpt[i+1].x - skpt[i  ].x));\n                            zcent = (zlast + skpt[i].z + scent * (xlast     - skpt[i].x)) / 2;\n                            xcent = (xlast + skpt[i].x + scent * (skpt[i].z - zlast    )) / 2;\n\n                            data[0] = xcent;\n                            data[1] = ymin;\n                            data[2] = zcent;\n                            data[3] = xlast - xcent;\n                            data[4] = 0;\n                            data[5] = zlast - zcent;\n                            data[6] = +data[5];\n                            data[7] = 0;\n                            data[8] = -data[3];\n                            data[9] = sqrt(pow(zlast-zcent,2) + pow(xlast-xcent,2));\n                        } else {\n                            scent = ((skpt[i+1].x - xlast    ) * (skpt[i  ].x - skpt[i+1].x)\n                                    -(skpt[i+1].y - ylast    ) * (skpt[i+1].y - skpt[i  ].y))\n                                   /((ylast       - skpt[i].y) * (skpt[i  ].x - skpt[i+1].x)\n                                   - (skpt[i].x   - xlast    ) * (skpt[i+1].y - skpt[i  ].y));\n                            xcent = (xlast + skpt[i].x + scent * (ylast     - skpt[i].y)) / 2;\n                            ycent = (ylast + skpt[i].y + scent * (skpt[i].x - xlast    )) / 2;\n\n                            data[0] = xcent;\n                            data[1] = ycent;\n                            data[2] = zmin;\n                            data[3] = xlast - xcent;\n                            data[4] = ylast - ycent;\n                            data[5] = 0;\n                            data[6] = -data[4];\n                            data[7] = +data[3];\n                            data[8] = 0;\n                            data[9] = sqrt(pow(xlast-xcent,2) + pow(ylast-ycent,2));\n                        }\n\n                        if (scent > 0) {\n                            status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &ecurve);\n                            CHECK_STATUS(EG_makeGeometry);\n                        } else {\n                            status = EG_makeGeometry(MODL->context, CURVE, CIRCLE, NULL, NULL, data, &eflip);\n                            CHECK_STATUS(EG_makeGeometry);\n\n                            status = EG_flipObject(eflip, &ecurve);\n                            CHECK_STATUS(EG_flipObject);\n                        }\n\n                        data[0] = xlast;\n                        data[1] = ylast;\n                        data[2] = zlast;\n                        status = EG_invEvaluate(ecurve, data, &(tdata[0]), result);\n                        CHECK_STATUS(EG_invEvaluate);\n\n                        data[0] = skpt[i+1].x;\n                        data[1] = skpt[i+1].y;\n                        data[2] = skpt[i+1].z;\n                        status = EG_invEvaluate(ecurve, data, &(tdata[1]), result);\n                        CHECK_STATUS(EG_invEvaluate);\n\n                        status = EG_makeTopology(MODL->context, ecurve, EDGE, TWONODE,\n                                                 tdata, 2, &(Enodes[nseg]), NULL, &(Eedges[nseg]));\n                        CHECK_STATUS(EG_makeTopology);\n\n                        nseg++;\n                    #endif\n\n                    i++;   /* this is because cirarc show up in pairs in iskpnt */\n\n                    xlast = skpt[i].x;\n                    ylast = skpt[i].y;\n                    zlast = skpt[i].z;\n\n                /* intiaize or add points to a spline (to be processed above in future\n                   trip through this for loop) */\n                } else if (skpt[i].itype == OCSM_SPLINE) {\n                    if (nspln == 0) {\n                        #if   defined(GEOM_CAPRI)\n                            if (xmin == xmax) {\n                                pts[0] = ylast;\n                                pts[1] = zlast;\n                            } else if (ymin == ymax) {\n                                pts[0] = zlast;\n                                pts[1] = xlast;\n                            } else {\n                                pts[0] = xlast;\n                                pts[1] = ylast;\n                            }\n                        #elif defined(GEOM_EGADS)\n                            pts[0] = xlast;\n                            pts[1] = ylast;\n                            pts[2] = zlast;\n                        #endif\n\n                        nspln = 1;\n                    }\n\n                    #if  defined(GEOM_CAPRI)\n                        if        (xmin == xmax) {\n                            pts[2*nspln  ] = skpt[i].y;\n                            pts[2*nspln+1] = skpt[i].z;\n                        } else if (ymin == ymax) {\n                            pts[2*nspln  ] = skpt[i].z;\n                            pts[2*nspln+1] = skpt[i].x;\n                        } else {\n                            pts[2*nspln  ] = skpt[i].x;\n                            pts[2*nspln+1] = skpt[i].y;\n                        }\n                    #elif defined(GEOM_EGADS)\n                        pts[3*nspln  ] = skpt[i].x;\n                        pts[3*nspln+1] = skpt[i].y;\n                        pts[3*nspln+2] = skpt[i].z;\n                    #endif\n\n                    nspln++;\n                }\n            }\n\n            /* close the sketch */\n            #if   defined(GEOM_CAPRI)\n                status = -gi_sIsComplete();\n                CHECK_STATUS(gi_sIsComplete);\n\n                status = gi_sClose();\n                CHECK_STATUS(gi_sClose);\n            #elif defined(GEOM_EGADS)\n                for (iseg = 0; iseg < nseg; iseg++) {\n                    sense[iseg] = SFORWARD;\n                }\n\n                if (iopen == 0) {\n                    status = EG_makeTopology(MODL->context, NULL, LOOP, CLOSED,\n                                             NULL, nseg, Eedges, sense, &eloop);\n                    CHECK_STATUS(EG_makeTopology);\n\n                    status = EG_makeFace(eloop, SFORWARD, NULL, Efaces);\n                    CHECK_STATUS(EG_makeFace);\n\n                    status = EG_makeTopology(MODL->context, NULL, BODY, FACEBODY,\n                                             NULL, 1, Efaces, sense, &ebody);\n                    CHECK_STATUS(EG_makeTopology);\n                } else {\n                    status = EG_makeTopology(MODL->context, NULL, LOOP, OPEN,\n                                             NULL, nseg, Eedges, sense, &eloop);\n                    CHECK_STATUS(EG_makeTopology);\n\n                    status = EG_makeTopology(MODL->context, NULL, BODY, WIREBODY,\n                                             NULL, 1, &eloop, NULL, &ebody);\n                    CHECK_STATUS(EG_makeTopology);\n                }\n            #endif\n\n            /* remember the sketch number just created */\n            #if   defined(GEOM_CAPRI)\n                nsketch = status;\n            #elif defined(GEOM_EGADS)\n            #endif\n\n            #if   defined(SHOW_SPLINES)\n            {\n                #define NPER          251\n                #define MAX_PLOT_PTS 9999\n\n                int    nplot, nline, ilin[MAX_SKETCH_SIZE+1], isym[MAX_SKETCH_SIZE+1], nper[MAX_SKETCH_SIZE+1];\n                int    io_kbd=5, io_scr=6, indgr=1+2+4+16+64;\n                float  xplot[MAX_PLOT_PTS], yplot[MAX_PLOT_PTS];\n                char   pltitl[30], title[] = \"Spline  (skbeg=^, linseg=+, cirarc=o, spline=x)\";\n\n                #if   defined(GEOM_CAPRI)\n                #elif defined(GEOM_EGADS)\n                    int    j, periodic;\n                    double trange[4], tt;\n                #endif\n\n                if        (xmin == xmax) {\n                    sprintf(title, \"~y~z~Sketch at x=%10.5f\", xmin);\n                } else if (ymin == ymax) {\n                    sprintf(title, \"~z~x~Sketch at y=%10.5f\", ymin);\n                } else {\n                    sprintf(title, \"~x~y~Sketch at z=%10.5f\", zmin);\n                }\n\n                /* put sketch points onto plot */\n                nline = 0;\n                nplot = 0;\n                for (i = 0; i < (*nskpt); i++) {\n                    ilin[nline] = 0;\n                    nper[nline] = 1;\n\n                    if        (skpt[i].itype == OCSM_SKBEG) {\n                        isym[nline] = GR_TRIANGLE;\n                    } else if (skpt[i].itype == OCSM_LINSEG) {\n                        isym[nline] = GR_PLUS;\n                    } else if (skpt[i].itype == OCSM_CIRARC) {\n                        isym[nline] = GR_CIRCLE;\n                    } else if (skpt[i].itype == OCSM_SPLINE) {\n                        isym[nline] = GR_X;\n                    }\n                    nline++;\n\n                    if        (xmin == xmax) {\n                        xplot[nplot] = skpt[i].y;\n                        yplot[nplot] = skpt[i].z;\n                        nplot++;\n                    } else if (ymin == ymax) {\n                        xplot[nplot] = skpt[i].z;\n                        yplot[nplot] = skpt[i].x;\n                        nplot++;\n                    } else {\n                        xplot[nplot] = skpt[i].x;\n                        yplot[nplot] = skpt[i].y;\n                        nplot++;\n                    }\n                }\n\n                /* put sketch evaluations onto plot */\n                #if   defined(GEOM_CAPRI)\n                    SPRINT0(0, \"WARNING:: dotted line is not actual spline evaluation\");\n\n                    ilin[nline] = +3;\n                    isym[nline] =  0;\n                    nper[nline] = (*nskpt);\n                    nline++;\n\n                    for (i = 0; i < (*nskpt); i++) {\n                        if        (xmin == xmax) {\n                            xplot[nplot] = skpt[i].y;\n                            yplot[nplot] = skpt[i].z;\n                            nplot++;\n                        } else if (ymin == ymax) {\n                            xplot[nplot] = skpt[i].z;\n                            yplot[nplot] = skpt[i].x;\n                            nplot++;\n                        } else {\n                            xplot[nplot] = skpt[i].x;\n                            yplot[nplot] = skpt[i].y;\n                            nplot++;\n                        }\n                    }\n                #elif defined(GEOM_EGADS)\n                    status = EG_getTopology(eloop, &eref, &oclass, &mtype,\n                                            data, &nchild, &ebodys, &senses);\n                    CHECK_STATUS(EG_getTopology);\n\n                    if (nplot+nchild*NPER > MAX_PLOT_PTS) {\n                        SPRINT4(0, \"nplot=%d, nchild=%d, NPER=%d, MAX_PLOT_PTS=%d\",\n                                nplot, nchild, NPER, MAX_PLOT_PTS);\n                        status = OCSM_INTERNAL_ERROR;\n                        CHECK_STATUS(ShowSketch);\n                    }\n\n                    for (j = 0; j < nchild; j++) {\n                        status = EG_getRange(ebodys[j], trange, &periodic);\n                        CHECK_STATUS(EG_getRange);\n\n                        for (i = 0; i < NPER; i++) {\n                            tt = trange[0] + (double)(i) / (double)(NPER-1) * (trange[1] - trange[0]);\n\n                            status = EG_evaluate(ebodys[j], &tt, data);\n                            CHECK_STATUS(EG_evaluate);\n\n                            if        (xmin == xmax) {\n                                xplot[nplot] = data[1];\n                                yplot[nplot] = data[2];\n                                nplot++;\n                            } else if (ymin == ymax) {\n                                xplot[nplot] = data[2];\n                                yplot[nplot] = data[0];\n                                nplot++;\n                            } else {\n                                xplot[nplot] = data[0];\n                                yplot[nplot] = data[1];\n                                nplot++;\n                            }\n                        }\n\n                        ilin[nline] =  +1;\n                        isym[nline] =  -1;\n                        nper[nline] = NPER;\n                        nline++;\n                    }\n                #endif\n\n                /* plot */\n                grinit_(&io_kbd, &io_scr, title, strlen(title));\n                grline_(ilin, isym, &nline, pltitl, &indgr, xplot, yplot, nper, strlen(pltitl));\n            }\n            #endif\n\n            /* close the sketcher */\n            (*nskpt) = 0;\n\n            /* make a new wire Body */\n            if (iopen == 0) {\n                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,\n                                 args, OCSM_SHEET_BODY, &ibody);\n                CHECK_STATUS(newBody);\n            } else {\n                status = newBody(MODL, ibrch, OCSM_SKEND, MODL->nbody, -1,\n                                 args, OCSM_WIRE_BODY, &ibody);\n                CHECK_STATUS(newBody);\n            }\n\n            #if   defined(GEOM_CAPRI)\n                MODL->body[ibody].ivol = -nsketch;\n            #elif defined(GEOM_EGADS)\n                MODL->body[ibody].ebody = ebody;\n            #endif\n\n            /* mark the new Faces (if any) with the current Body */\n            #if   defined(GEOM_CAPRI)\n                /* this does not actually do anything but is used to avoid compiler warnings */\n                status = setFaceAttribute(MODL, 0, 0, 0, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            #elif defined(GEOM_EGADS)\n                status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n                CHECK_STATUS(EG_getBodyTopos);\n\n                for (iface = 1; iface <= nface; iface++) {\n                    status = setFaceAttribute(MODL, ibody, iface, 0, npatn, patn);\n                    CHECK_STATUS(setFaceAttribute);\n                }\n\n                EG_free(efaces);\n            #endif\n\n            /* finish the Body */\n            status = finishBody(MODL, ibody);\n            CHECK_STATUS(finishBody);\n\n            /* push the Sketch onto the stack */\n            stack[(*nstack)++] = ibody;\n\n            SPRINT1(1, \"                          Sketch %4d created\", ibody);\n        }\n    }\n\ncleanup:\n    #if   defined(GEOM_CAPRI)\n    #elif defined(GEOM_EGADS)\n        FREE(cp);\n    #endif\n\n    DPRINT2(\"%s --> status=%d}\", routine, status);\n    return status;\n}", "path": "src\\OpenCSM\\OpenCSM.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   buildSolver - implement OCSM_SOLVERs for ocsmBuild                 *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "static int\nbuildSolver(modl_T *modl,\n            int    ibrch,\n            int    *ncon,\n            int    solcons[])", "code": "{\n    int       status = SUCCESS;         /* (out) return status */\n\n    modl_T    *MODL = (modl_T*)modl;\n\n    int       jbrch, type, iter, niter, ipmtr, jpmtr, i, j, ivar, icon;\n    double    neg_f0[MAX_SOLVER_SIZE], dfdx[MAX_SOLVER_SIZE*MAX_SOLVER_SIZE];\n    double    delx[MAX_SOLVER_SIZE], f0max, f0last, save_value, omega;\n    double    args[10], value;\n    char      name[MAX_EXPR_LEN];\n\n    static int nvar;\n    static int solvars[MAX_SOLVER_SIZE];\n\n    ROUTINE(buildSolver);\n    DPRINT2(\"%s(ibrch=%d) {\",\n            routine, ibrch);\n\n    /* --------------------------------------------------------------- */\n\n    type = MODL->brch[ibrch].type;\n\n    /* get the values for the arguments */\n    if (MODL->brch[ibrch].narg >= 1) {\n        status = str2val(MODL->brch[ibrch].arg1, MODL, &args[1]);\n        CHECK_STATUS(str2val:val1);\n    } else {\n        args[1] = 0;\n    }\n    args[2] = 0;\n    args[3] = 0;\n    args[4] = 0;\n    args[5] = 0;\n    args[6] = 0;\n    args[7] = 0;\n    args[8] = 0;\n    args[9] = 0;\n\n    /* execute: \"solbeg\" */\n    if (type == OCSM_SOLBEG) {\n        SPRINT2(1, \"    executing [%4d] solbeg:         %s\",\n                ibrch, &(MODL->brch[ibrch].arg1[1]));\n\n        /* initialize the number of solver constraints and variables */\n        *ncon = 0;\n        nvar  = 0;\n\n        /* make a list of the solver variables by parsing arg1 */\n        name[j=0] = '\\0';\n        for (i = 1; i < strlen(MODL->brch[ibrch].arg1); i++) {\n            if (MODL->brch[ibrch].arg1[i] != ';') {\n                name[j  ] = MODL->brch[ibrch].arg1[i];\n                name[j+1] = '\\0';\n                j++;\n            } else {\n                ipmtr = 0;\n                for (jpmtr = 1; jpmtr <= MODL->npmtr; jpmtr++) {\n                    if (strcmp(MODL->pmtr[jpmtr].name, name) == 0            &&\n                               MODL->pmtr[jpmtr].type        == OCSM_INTERNAL   ) {\n                        ipmtr = jpmtr;\n                        break;\n                    }\n                }\n\n                if (ipmtr == 0) {\n                    SPRINT1(0, \"WARNING:: name \\\"%s\\\" not an INTERNAL parameter\", name);\n                    status = OCSM_NAME_NOT_FOUND;\n                    goto cleanup;\n                }\n\n                solvars[nvar++] = ipmtr;\n\n                if (nvar > MAX_SOLVER_SIZE) {\n                    status = OCSM_TOO_MANY_SOLVER_VARS;\n                    CHECK_STATUS(solbeg);\n                }\n\n                name[j=0] = '\\0';\n            }\n        }\n\n    /* execute: \"solcon expr\" */\n    } else if (type == OCSM_SOLCON) {\n        SPRINT2(1, \"    executing [%4d] solcon:         %s\",\n                ibrch, &(MODL->brch[ibrch].arg1[1]));\n\n        solcons[(*ncon)++] = ibrch;\n\n        if (*ncon > MAX_SOLVER_SIZE) {\n            status = OCSM_TOO_MANY_SOLVER_VARS;\n            CHECK_STATUS(solcon);\n        }\n\n    /* execute: \"solend\" */\n    } else if (type == OCSM_SOLEND) {\n        SPRINT1(1, \"    executing [%4d] solend:\",\n                ibrch);\n\n        for (ivar = 0; ivar < nvar; ivar++) {\n            jpmtr = solvars[ivar];\n            SPRINT3(2, \"        var[%2d] = %3d [%s]\",\n                    ivar, jpmtr, MODL->pmtr[jpmtr].name);\n        }\n        for (icon = 0; icon < *ncon; icon++) {\n            jbrch = solcons[icon];\n            SPRINT3(2, \"        con[%2d] = %3d [%s]\",\n                    icon, jbrch, &(MODL->brch[jbrch].arg1[1]));\n        }\n\n        /* if the number of constraints does not match the number of\n           sketch Parameters, return an error */\n        if        (*ncon < nvar) {\n            status = OCSM_UNDERCONSTRAINED;\n            CHECK_STATUS(solend);\n        } else if (*ncon > nvar) {\n            status = OCSM_OVERCONSTRAINED;\n            CHECK_STATUS(solend);\n        }\n\n        /* if there were no constraints, simply return */\n        if (*ncon == 0) {\n            goto cleanup;\n        }\n\n        /* Newton iteration to change the solver variables until\n           the constraints are satisfied */\n        niter  = 100;\n        omega  = 0.50;\n        f0last = 0;\n        for (iter = 0; iter < niter; iter++) {\n\n            /* evaluate the constraints */\n            f0max = 0;\n            for (icon = 0; icon < *ncon; icon++) {\n                jbrch  = solcons[icon];\n                status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value);\n                CHECK_STATUS(str2val);\n\n                neg_f0[icon] = -value;\n                SPRINT2(2,\"        f0[%4d] = %11.5f\", jbrch, value);\n\n                if (fabs(value) > f0max) {\n                    f0max = fabs(value);\n                }\n            }\n            SPRINT2(1, \"    -> solving sketch: iter = %3d,   f0max = %12.4e\", iter, f0max);\n\n            /* if we have converged, stop the Newton iterations */\n            if (f0max < EPS06) {\n                DPRINT0(\"converged\");\n                break;\n            }\n\n            /* f0max < f0last, we are converging, so increase omega */\n            if (f0max < f0last) {\n                omega = MIN(1.2*omega, 1);\n            }\n            f0last = f0max;\n\n            /* build up the Jacobian matrix by perturbing the solver variables\n               one at a time */\n            for (ivar = 0; ivar < nvar; ivar++) {\n                jpmtr = solvars[ivar];\n\n                save_value = MODL->pmtr[jpmtr].value[0];\n                MODL->pmtr[jpmtr].value[0] += EPS06;\n\n                for (icon = 0; icon < *ncon; icon++) {\n                    jbrch = solcons[icon];\n                    status = str2val(&(MODL->brch[jbrch].arg1[1]), MODL, &value);\n                    CHECK_STATUS(str2val);\n\n                    dfdx[icon*(*ncon)+ivar] = (value + neg_f0[icon]) / EPS06;\n                }\n\n                MODL->pmtr[jpmtr].value[0] = save_value;\n            }\n\n            /* print out the Jacobian matrix */\n            DPRINT0(\"Jacobian matrix\");\n            for (icon = 0; icon < *ncon; icon++) {\n                DPRINT1x(\"%3d: \", icon);\n\n                for (ivar = 0; ivar < nvar; ivar++) {\n                    DPRINT1x(\"%8.4f \", dfdx[icon*(*ncon)+ivar]);\n                }\n                DPRINT0(\" \");\n            }\n\n            /* take the Newton step */\n            status = matsol(dfdx, neg_f0, *ncon, delx);\n            CHECK_STATUS(matsol);\n\n            for (ivar = 0; ivar < nvar; ivar++) {\n                jpmtr = solvars[ivar];\n                MODL->pmtr[jpmtr].value[0] += omega * delx[ivar];\n            }\n        }\n\n        /* now that we have run out of iterations, check for convergence */\n        if (f0max > EPS06) {\n            status = OCSM_NOT_CONVERGED;\n            goto cleanup;\n        }\n\n        /* initialize variables for next solver */\n        nvar  = 0;\n        *ncon = 0;\n    }\n\ncleanup:\n    DPRINT2(\"%s --> status=%d}\", routine, status);\n    return status;\n}", "path": "src\\OpenCSM\\OpenCSM.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsocket_callback_on_writable_all_protocol() - Request a callback for\n *\t\t\tall connections using the given protocol when it\n *\t\t\tbecomes possible to write to each socket without\n *\t\t\tblocking in turn.\n *\n * @protocol:\tProtocol whose connections will get callbacks\n */\n", "func_signal": "int\nlibwebsocket_callback_on_writable_all_protocol(\n\t\t\t\t  const struct libwebsocket_protocols *protocol)", "code": "{\n\tstruct libwebsocket_context *context = protocol->owning_server;\n\tint n;\n\tint m;\n\tstruct libwebsocket *wsi;\n\n\tfor (n = 0; n < FD_HASHTABLE_MODULUS; n++) {\n\n\t\tfor (m = 0; m < context->fd_hashtable[n].length; m++) {\n\n\t\t\twsi = context->fd_hashtable[n].wsi[m];\n\n\t\t\tif (wsi->protocol == protocol)\n\t\t\t\tlibwebsocket_callback_on_writable(context, wsi);\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   udpReset - reset the arguments to their defaults                   *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "int\nudpReset(int flag)", "code": "{\n    int   iudp;\n\n    if (FileName != NULL) {\n        EG_free(FileName);\n        FileName = NULL;\n    }\n\n    /* reset the \"current\" settings */\n    if (flag == 0) {\n        Imax[0] = 1;\n        Jmax[0] = 1;\n        Kmax[0] = 1;\n\n        if (X[0] != NULL) {\n            EG_free(X[0]);\n            X[0] = NULL;\n        }\n        if (Y[0] != NULL) {\n            EG_free(Y[0]);\n            Y[0] = NULL;\n        }\n        if (Z[0] != NULL) {\n            EG_free(Z[0]);\n            Z[0] = NULL;\n        }\n\n    /* called when closing up */\n    } else {\n        for (iudp = 0; iudp <= numUdp; iudp++) {\n            if (ebodys[iudp] != NULL) {\n                EG_deleteObject(ebodys[iudp]);\n                ebodys[iudp] = NULL;\n            }\n            if (X[iudp] != NULL) {\n                EG_free(X[iudp]);\n                X[iudp] = NULL;\n            }\n            if (Y[iudp] != NULL) {\n                EG_free(Y[iudp]);\n                Y[iudp] = NULL;\n            }\n            if (Z[iudp] != NULL) {\n                EG_free(Z[iudp]);\n                Z[iudp] = NULL;\n            }\n        }\n\n        EG_free(ebodys);  ebodys = NULL;\n        EG_free(Imax  );  Imax   = NULL;\n        EG_free(Jmax  );  Jmax   = NULL;\n        EG_free(Kmax  );  Kmax   = NULL;\n        EG_free(X     );  *X     = NULL;\n        EG_free(Y     );  *Y     = NULL;\n        EG_free(Z     );  *Z     = NULL;\n\n        numUdp = 0;\n    }\n\n    return EGADS_SUCCESS;\n}", "path": "src\\OpenCSM\\udpFreeform.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   udpExecute - execute the primitive                                 *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "int\nudpExecute(ego  context,\n           ego  *ebody,\n           int  *nMesh,\n           char **string)", "code": "{\n    int     status = EGADS_SUCCESS;\n\n    int     imax, jmax, kmax, i, j, k, ijk, senses[8], periodic;\n    double  *x2d=NULL, *y2d=NULL, *z2d=NULL;\n    double  data[18], tdata[2];\n    FILE    *fp;\n    ego                ecurvs[12], esurfs[6];\n    ego     enodes[8], eedges[12], efaces[6], etemp[8], eloop, eshell;\n\n    /* default return values */\n    *ebody  = NULL;\n    *nMesh  = 0;\n    *string = NULL;\n\n    /* increment number of UDPs */\n    numUdp++;\n\n    /* increase the arrays to make room for the new UDP */\n    ebodys = (ego    *) EG_reall(ebodys, (numUdp+1)*sizeof(ego    ));\n    Imax   = (int    *) EG_reall(Imax,   (numUdp+1)*sizeof(int    ));\n    Jmax   = (int    *) EG_reall(Jmax,   (numUdp+1)*sizeof(int    ));\n    Kmax   = (int    *) EG_reall(Kmax,   (numUdp+1)*sizeof(int    ));\n    X      = (double**) EG_reall(X,      (numUdp+1)*sizeof(double*));\n    Y      = (double**) EG_reall(Y,      (numUdp+1)*sizeof(double*));\n    Z      = (double**) EG_reall(Z,      (numUdp+1)*sizeof(double*));\n\n    if (ebodys == NULL || Imax == NULL || Jmax == NULL || Kmax == NULL ||\n                          X    == NULL || Y    == NULL || Z    == NULL   ) {\n        return EGADS_MALLOC;\n    }\n\n    ebodys[numUdp] = NULL;\n\n    /* data is in a file */\n    if (FileName != NULL) {\n\n        /* open the file */\n        fp = fopen(FileName, \"r\");\n        if (fp == NULL) {\n            status = EGADS_NOTFOUND;\n            goto cleanup;\n        }\n\n        /* read the size of the configuration */\n        fscanf(fp, \"%d %d %d\", &imax, &jmax, &kmax);\n\n        /* save the array size from the file */\n        Imax[numUdp] = imax;\n        Jmax[numUdp] = jmax;\n        Kmax[numUdp] = kmax;\n\n        /* allocate necessary arrays */\n        X[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n        Y[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n        Z[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n\n        if (X[numUdp] == NULL || Y[numUdp] == NULL || Z[numUdp] == NULL) {\n            status = EGADS_MALLOC;\n            goto cleanup;\n        }\n\n        /* read the data.  if 3d, only the outside points are read */\n        for (k = 0; k < kmax; k++) {\n            for (j = 0; j < jmax; j++) {\n                for (i = 0; i < imax; i++) {\n                    if (i == 0 || i == imax-1 ||\n                        j == 0 || j == jmax-1 ||\n                        k == 0 || k == kmax-1   ) {\n                        ijk = (i) + imax * ((j) + jmax * (k));\n                        fscanf(fp, \"%lf %lf %lf\", &(X[numUdp][ijk]),\n                                                  &(Y[numUdp][ijk]),\n                                                  &(Z[numUdp][ijk]));\n                    }\n                }\n            }\n        }\n\n        /* close the file */\n        fclose(fp);\n\n    /* data came in XYZ */\n    } else if (X[0] != NULL && Y[0] != NULL && Z[0] != NULL) {\n        imax = Imax[0];\n        jmax = Jmax[0];\n        kmax = Kmax[0];\n\n        Imax[numUdp] = imax;\n        Jmax[numUdp] = jmax;\n        Kmax[numUdp] = kmax;\n\n        /* allocate necessary arrays */\n        X[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n        Y[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n        Z[numUdp] = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n\n        if (X[numUdp] == NULL || Y[numUdp] == NULL || Z[numUdp] == NULL) {\n            status = EGADS_MALLOC;\n            goto cleanup;\n        }\n\n        /* copy the data */\n        for (ijk = 0; ijk < imax*jmax*kmax; ijk++) {\n            X[numUdp][ijk] = X[0][ijk];\n            Y[numUdp][ijk] = Y[0][ijk];\n            Z[numUdp][ijk] = Z[0][ijk];\n        }\n\n        EG_free(X[0]);  X[0] = NULL;\n        EG_free(Y[0]);  Y[0] = NULL;\n        EG_free(Z[0]);  Z[0] = NULL;\n\n    /* no data specified */\n    } else {\n        printf(\" udpExecute: filename and xyz both null\\n\");\n        return EGADS_NODATA;\n    }\n\n    /* allocate necessary (oversized) 2D arrays */\n    x2d = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n    y2d = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n    z2d = (double*) EG_alloc(imax*jmax*kmax*sizeof(double));\n\n    if (x2d == NULL || y2d == NULL || z2d == NULL) {\n        status = EGADS_MALLOC;\n        goto cleanup;\n    }\n\n    /* create WireBody (since jmax<=1) */\n    if (jmax <= 1) {\n        printf(\"    WireBody: (%d)\\n\", imax);\n\n        /* create the 2 Nodes */\n        CREATE_NODE(0, 0,      0, 0);\n        CREATE_NODE(1, imax-1, 0, 0);\n\n        /* create the Curve and Edge */\n        for (i = 0; i < imax; i++) {\n            x2d[i] = X[numUdp][(i)+imax*((0)+jmax*(0))];\n            y2d[i] = Y[numUdp][(i)+imax*((0)+jmax*(0))];\n            z2d[i] = Z[numUdp][(i)+imax*((0)+jmax*(0))];\n        }\n        CREATE_EDGE(0, 0, 1, imax);\n\n        /* make a Loop */\n        senses[0] = SFORWARD;\n        status = EG_makeTopology(context, NULL, LOOP, OPEN,\n                                 NULL, 1, eedges, senses, &eloop);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* make a WireBody */\n        status = EG_makeTopology(context, NULL, BODY, WIREBODY,\n                                 NULL, 1, &eloop, NULL, ebody);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* remember this model (body) */\n        ebodys[numUdp] = *ebody;\n\n    /* create FaceBody (since kmax<=1) */\n    } else if (kmax <= 1) {\n        printf(\"    FaceBody: (%d*%d)\\n\", imax, jmax);\n\n        /* make the cubic spline */\n        status = spline2d(context, imax, jmax, X[numUdp], Y[numUdp], Z[numUdp], &(esurfs[0]));\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* make a Face */\n        status = EG_getRange(esurfs[0], data, &periodic);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        status = EG_makeFace(esurfs[0], SFORWARD, data, &(efaces[0]));\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* make a FaceBody */\n        senses[0] = SFORWARD;\n        status = EG_makeTopology(context, NULL, BODY, FACEBODY,\n                                 NULL, 1, efaces, senses, ebody);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* inform the user that there is 1 surface meshes */\n        *nMesh = 1;\n\n        /* remember this model (body) */\n        ebodys[numUdp] = *ebody;\n\n    /* create a SolidBody */\n    } else {\n        printf(\"    SolidBody: (%d*%d*%d)\\n\", imax, jmax, kmax);\n\n        /* create the 8 Nodes */\n        CREATE_NODE(0, 0,      0,      0     );\n        CREATE_NODE(1, imax-1, 0,      0     );\n        CREATE_NODE(2, 0,      jmax-1, 0     );\n        CREATE_NODE(3, imax-1, jmax-1, 0     );\n        CREATE_NODE(4, 0,      0,      kmax-1);\n        CREATE_NODE(5, imax-1, 0,      kmax-1);\n        CREATE_NODE(6, 0,      jmax-1, kmax-1);\n        CREATE_NODE(7, imax-1, jmax-1, kmax-1);\n\n        /* create the 12 Curves and Edges */\n        for (i = 0; i < imax; i++) {\n            x2d[i] = X[numUdp][(i     )+imax*((0     )+jmax*(0     ))];\n            y2d[i] = Y[numUdp][(i     )+imax*((0     )+jmax*(0     ))];\n            z2d[i] = Z[numUdp][(i     )+imax*((0     )+jmax*(0     ))];\n        }\n        CREATE_EDGE( 0, 0, 1, imax);\n\n        for (i = 0; i < imax; i++) {\n            x2d[i] = X[numUdp][(i     )+imax*((jmax-1)+jmax*(0     ))];\n            y2d[i] = Y[numUdp][(i     )+imax*((jmax-1)+jmax*(0     ))];\n            z2d[i] = Z[numUdp][(i     )+imax*((jmax-1)+jmax*(0     ))];\n        }\n        CREATE_EDGE( 1, 2, 3, imax);\n\n        for (i = 0; i < imax; i++) {\n            x2d[i] = X[numUdp][(i     )+imax*((0     )+jmax*(kmax-1))];\n            y2d[i] = Y[numUdp][(i     )+imax*((0     )+jmax*(kmax-1))];\n            z2d[i] = Z[numUdp][(i     )+imax*((0     )+jmax*(kmax-1))];\n        }\n        CREATE_EDGE( 2, 4, 5, imax);\n\n        for (i = 0; i < imax; i++) {\n            x2d[i] = X[numUdp][(i     )+imax*((jmax-1)+jmax*(kmax-1))];\n            y2d[i] = Y[numUdp][(i     )+imax*((jmax-1)+jmax*(kmax-1))];\n            z2d[i] = Z[numUdp][(i     )+imax*((jmax-1)+jmax*(kmax-1))];\n        }\n        CREATE_EDGE( 3, 6, 7, imax);\n\n        for (j = 0; j < jmax; j++) {\n            x2d[j] = X[numUdp][(0     )+imax*((j     )+jmax*(0     ))];\n            y2d[j] = Y[numUdp][(0     )+imax*((j     )+jmax*(0     ))];\n            z2d[j] = Z[numUdp][(0     )+imax*((j     )+jmax*(0     ))];\n        }\n        CREATE_EDGE( 4, 0, 2, jmax);\n\n        for (j = 0; j < jmax; j++) {\n            x2d[j] = X[numUdp][(0     )+imax*((j     )+jmax*(kmax-1))];\n            y2d[j] = Y[numUdp][(0     )+imax*((j     )+jmax*(kmax-1))];\n            z2d[j] = Z[numUdp][(0     )+imax*((j     )+jmax*(kmax-1))];\n        }\n        CREATE_EDGE( 5, 4, 6, jmax);\n\n        for (j = 0; j < jmax; j++) {\n            x2d[j] = X[numUdp][(imax-1)+imax*((j     )+jmax*(0     ))];\n            y2d[j] = Y[numUdp][(imax-1)+imax*((j     )+jmax*(0     ))];\n            z2d[j] = Z[numUdp][(imax-1)+imax*((j     )+jmax*(0     ))];\n        }\n        CREATE_EDGE( 6, 1, 3, jmax);\n\n        for (j = 0; j < jmax; j++) {\n            x2d[j] = X[numUdp][(imax-1)+imax*((j     )+jmax*(kmax-1))];\n            y2d[j] = Y[numUdp][(imax-1)+imax*((j     )+jmax*(kmax-1))];\n            z2d[j] = Z[numUdp][(imax-1)+imax*((j     )+jmax*(kmax-1))];\n        }\n        CREATE_EDGE( 7, 5, 7, jmax);\n\n        for (k = 0; k < kmax; k++) {\n            x2d[k] = X[numUdp][(0     )+imax*((0     )+jmax*(k     ))];\n            y2d[k] = Y[numUdp][(0     )+imax*((0     )+jmax*(k     ))];\n            z2d[k] = Z[numUdp][(0     )+imax*((0     )+jmax*(k     ))];\n        }\n        CREATE_EDGE( 8, 0, 4, kmax);\n\n        for (k = 0; k < kmax; k++) {\n            x2d[k] = X[numUdp][(imax-1)+imax*((0     )+jmax*(k     ))];\n            y2d[k] = Y[numUdp][(imax-1)+imax*((0     )+jmax*(k     ))];\n            z2d[k] = Z[numUdp][(imax-1)+imax*((0     )+jmax*(k     ))];\n        }\n        CREATE_EDGE( 9, 1, 5, kmax);\n\n        for (k = 0; k < kmax; k++) {\n            x2d[k] = X[numUdp][(0     )+imax*((jmax-1)+jmax*(k     ))];\n            y2d[k] = Y[numUdp][(0     )+imax*((jmax-1)+jmax*(k     ))];\n            z2d[k] = Z[numUdp][(0     )+imax*((jmax-1)+jmax*(k     ))];\n        }\n        CREATE_EDGE(10, 2, 6, kmax);\n\n        for (k = 0; k < kmax; k++) {\n            x2d[k] = X[numUdp][(imax-1)+imax*((jmax-1)+jmax*(k     ))];\n            y2d[k] = Y[numUdp][(imax-1)+imax*((jmax-1)+jmax*(k     ))];\n            z2d[k] = Z[numUdp][(imax-1)+imax*((jmax-1)+jmax*(k     ))];\n        }\n        CREATE_EDGE(11, 3, 7, kmax);\n\n        /* create the 6 Surfaces, Pcurves, Loops, and Edges */\n        for (j = 0; j < jmax; j++) {\n            for (k = 0; k < kmax; k++) {\n                x2d[k+j*kmax] = X[numUdp][(0     )+imax*((j     )+jmax*(k     ))];\n                y2d[k+j*kmax] = Y[numUdp][(0     )+imax*((j     )+jmax*(k     ))];\n                z2d[k+j*kmax] = Z[numUdp][(0     )+imax*((j     )+jmax*(k     ))];\n            }\n        }\n        CREATE_FACE(0,  8,  5, 10,  4, jmax, kmax);\n\n        for (k = 0; k < kmax; k++) {\n            for (j = 0; j < jmax; j++) {\n                x2d[j+k*jmax] = X[numUdp][(imax-1)+imax*((j     )+jmax*(k     ))];\n                y2d[j+k*jmax] = Y[numUdp][(imax-1)+imax*((j     )+jmax*(k     ))];\n                z2d[j+k*jmax] = Z[numUdp][(imax-1)+imax*((j     )+jmax*(k     ))];\n            }\n        }\n        CREATE_FACE(1,  6, 11,  7,  9, kmax, jmax);\n\n        for (k = 0; k < kmax; k++) {\n            for (i = 0; i < imax; i++) {\n                x2d[i+k*imax] = X[numUdp][(i     )+imax*((0     )+jmax*(k     ))];\n                y2d[i+k*imax] = Y[numUdp][(i     )+imax*((0     )+jmax*(k     ))];\n                z2d[i+k*imax] = Z[numUdp][(i     )+imax*((0     )+jmax*(k     ))];\n            }\n        }\n        CREATE_FACE(2,  0,  9,  2,  8, kmax, imax);\n\n        for (i = 0; i < imax; i++) {\n            for (k = 0; k < kmax; k++) {\n                x2d[k+i*kmax] = X[numUdp][(i     )+imax*((jmax-1)+jmax*(k     ))];\n                y2d[k+i*kmax] = Y[numUdp][(i     )+imax*((jmax-1)+jmax*(k     ))];\n                z2d[k+i*kmax] = Z[numUdp][(i     )+imax*((jmax-1)+jmax*(k     ))];\n            }\n        }\n        CREATE_FACE(3, 10,  3, 11,  1, imax, kmax);\n\n        for (i = 0; i < imax; i++) {\n            for (j = 0; j < jmax; j++) {\n                x2d[j+i*jmax] = X[numUdp][(i     )+imax*((j     )+jmax*(0     ))];\n                y2d[j+i*jmax] = Y[numUdp][(i     )+imax*((j     )+jmax*(0     ))];\n                z2d[j+i*jmax] = Z[numUdp][(i     )+imax*((j     )+jmax*(0     ))];\n            }\n        }\n        CREATE_FACE(4,  4,  1,  6,  0, imax, jmax);\n\n        for (j = 0; j < jmax; j++) {\n            for (i = 0; i < imax; i++) {\n                x2d[i+j*imax] = X[numUdp][(i     )+imax*((j     )+jmax*(kmax-1))];\n                y2d[i+j*imax] = Y[numUdp][(i     )+imax*((j     )+jmax*(kmax-1))];\n                z2d[i+j*imax] = Z[numUdp][(i     )+imax*((j     )+jmax*(kmax-1))];\n            }\n        }\n        CREATE_FACE(5,  2,  7,  3,  5, jmax, imax);\n\n        /* make the Shell and SolidBody */\n        printf(\"        creating Shell\\n\");\n        status = EG_makeTopology(context, NULL, SHELL, CLOSED,\n                                 NULL, 6, efaces, NULL, &eshell);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        printf(\"        creating SolidBody\\n\");\n        status = EG_makeTopology(context, NULL, BODY, SOLIDBODY,\n                                 NULL, 1, &eshell, NULL, ebody);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        /* inform the user that there are 6 surface meshes */\n        *nMesh = 6;\n\n        /* remember this model (body) */\n        ebodys[numUdp] = *ebody;\n    }\n\ncleanup:\n    if (z2d != NULL) EG_free(z2d);\n    if (y2d != NULL) EG_free(y2d);\n    if (z2d != NULL) EG_free(x2d);\n\n    if (status != EGADS_SUCCESS) {\n        *string = udpErrorStr(status);\n    }\n\n    return status;\n}", "path": "src\\OpenCSM\\udpFreeform.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/* file descriptor hash management */\n", "func_signal": "struct libwebsocket *\nwsi_from_fd(struct libwebsocket_context *context, int fd)", "code": "{\n\tint h = LWS_FD_HASH(fd);\n\tint n = 0;\n\n\tfor (n = 0; n < context->fd_hashtable[h].length; n++)\n\t\tif (context->fd_hashtable[h].wsi[n]->sock == fd)\n\t\t\treturn context->fd_hashtable[h].wsi[n];\n\n\treturn NULL;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsocket_context_destroy() - Destroy the websocket context\n * @context:\tWebsocket context\n *\n *\tThis function closes any active connections and then frees the\n *\tcontext.  After calling this, any further use of the context is\n *\tundefined.\n */\n", "func_signal": "void\nlibwebsocket_context_destroy(struct libwebsocket_context *context)", "code": "{\n\tint n;\n\tint m;\n\tstruct libwebsocket *wsi;\n\tstruct libwebsocket_extension *ext;\n\n\tfor (n = 0; n < FD_HASHTABLE_MODULUS; n++)\n\t\tfor (m = 0; m < context->fd_hashtable[n].length; m++) {\n\t\t\twsi = context->fd_hashtable[n].wsi[m];\n\t\t\tlibwebsocket_close_and_free_session(context, wsi,\n\t\t\t\t\t\t    LWS_CLOSE_STATUS_GOINGAWAY);\n\t\t}\n\n\t/*\n\t * give all extensions a chance to clean up any per-context\n\t * allocations they might have made\n\t */\n\n\text = context->extensions;\n\tm = LWS_EXT_CALLBACK_CLIENT_CONTEXT_DESTRUCT;\n\tif (context->listen_port)\n\t\tm = LWS_EXT_CALLBACK_SERVER_CONTEXT_DESTRUCT;\n\twhile (ext->callback) {\n\t\text->callback(context, ext, NULL, m, NULL, NULL, 0);\n\t\text++;\n\t}\n\n#ifdef WIN32\n#else\n\tclose(context->fd_random);\n#endif\n\n#ifdef LWS_OPENSSL_SUPPORT\n\tif (context->ssl_ctx)\n\t\tSSL_CTX_free(context->ssl_ctx);\n\tif (context->ssl_client_ctx)\n\t\tSSL_CTX_free(context->ssl_client_ctx);\n#endif\n\n\tfree(context);\n\n#ifdef WIN32\n\tWSACleanup();\n#endif\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   buildGrown - implement OCSM_GROWNs for ocsmBuild                   *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "static int\nbuildGrown(modl_T *modl,\n           int    ibrch,\n           int    *nstack,\n           int    stack[],\n           int    npatn,\n           patn_T patn[])", "code": "{\n    int       status = SUCCESS;         /* (out) return status */\n\n    modl_T    *MODL = (modl_T*)modl;\n\n    int       type, iface, nface, loftOpts;\n    int       numSketches, ibody, ibodyl;\n    double    args[10], dirn[3], alen;\n\n    #if   defined(GEOM_CAPRI)\n        int       ivol, ivoll, ivolr, sketches[MAX_NUM_SKETCHES], *errs;\n        int       itype, nnode, nbound, imodel, ibeg, mfile, nedge;\n        double    dot, orig[3], xaxis[3], yaxis[3];\n        char      *name, *mdum;\n\n        char       *server      = NULL;\n        char       modeller[10] = \"Parasolid\";\n    #elif defined(GEOM_EGADS)\n        int        nloops, iford1;\n        ego        ebody, ebodyl, *efaces, *echildren, esketches[MAX_NUM_SKETCHES];\n    #endif\n\n    ROUTINE(buildGrown);\n    DPRINT2(\"%s(ibrch=%d) {\",\n            routine, ibrch);\n\n    /* --------------------------------------------------------------- */\n\n    type = MODL->brch[ibrch].type;\n\n    /* get the values for the arguments */\n    if (MODL->brch[ibrch].narg >= 1) {\n        status = str2val(MODL->brch[ibrch].arg1, MODL, &args[1]);\n        CHECK_STATUS(str2val:val1);\n    } else {\n        args[1] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 2) {\n        status = str2val(MODL->brch[ibrch].arg2, MODL, &args[2]);\n        CHECK_STATUS(str2val:val2);\n    } else {\n        args[2] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 3) {\n        status = str2val(MODL->brch[ibrch].arg3, MODL, &args[3]);\n        CHECK_STATUS(str2val:val3);\n    } else {\n        args[3] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 4) {\n        status = str2val(MODL->brch[ibrch].arg4, MODL, &args[4]);\n        CHECK_STATUS(str2val:val4);\n    } else {\n        args[4] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 5) {\n        status = str2val(MODL->brch[ibrch].arg5, MODL, &args[5]);\n        CHECK_STATUS(str2val:val5);\n    } else {\n        args[5] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 6) {\n        status = str2val(MODL->brch[ibrch].arg6, MODL, &args[6]);\n        CHECK_STATUS(str2val:val6);\n    } else {\n        args[6] = 0;\n    }\n    if (MODL->brch[ibrch].narg >= 7) {\n        status = str2val(MODL->brch[ibrch].arg7, MODL, &args[7]);\n        CHECK_STATUS(str2val:val7);\n    } else {\n        args[7] = 0;\n    }\n    args[8] = 0;\n    args[9] = 0;\n\n    /* execute: \"extrude dx dy dz\" */\n    if (type == OCSM_EXTRUDE) {\n        SPRINT4(1, \"    executing [%4d] extrude:    %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3]);\n\n        /* pop a Sketch from the stack */\n        if ((*nstack) < 1) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(extrude);\n        } else {\n                ibodyl = stack[--(*nstack)];\n        }\n\n        alen = sqrt(SQR(args[1]) + SQR(args[2]) + SQR(args[3]));\n        dirn[0] = args[1] / alen;\n        dirn[1] = args[2] / alen;\n        dirn[2] = args[3] / alen;\n\n        /* check that ibodyl is a Sketch */\n        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY &&\n            MODL->body[ibodyl].botype != OCSM_WIRE_BODY    ) {\n            status = OCSM_EXPECTING_ONE_SKETCH;\n            CHECK_STATUS(extrude);\n        }\n\n        /* create the Body */\n        status = newBody(MODL, ibrch, OCSM_EXTRUDE, ibodyl, -1,\n                         args, OCSM_SOLID_BODY, &ibody);\n        CHECK_STATUS(newBody);\n\n        #if   defined(GEOM_CAPRI)\n            sketches[0] = -(MODL->body[ibodyl].ivol);\n\n            status = gi_gExtrude(server, modeller, 0, 0, sketches[0], alen, dirn);\n            if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n            CHECK_STATUS(gi_gExtrude);\n\n            imodel = status;\n            status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n            CHECK_STATUS(gi_dGetModel);\n\n            MODL->body[ibody].ivol = ivol;\n        #elif defined(GEOM_EGADS)\n            ebodyl = MODL->body[ibodyl].ebody;\n\n            status = EG_extrude(ebodyl, alen, dirn, &ebody);\n            CHECK_STATUS(EG_extrude);\n\n            MODL->body[ibody].ebody = ebody;\n        #endif\n\n        /* mark the new Faces with the current Branch */\n        #if   defined(GEOM_CAPRI)\n            status = gi_dGetVolume(ivol, &nnode, &nedge, &nface, &nbound, &name);\n            CHECK_STATUS(gi_dGetVolume);\n\n            status = gi_qBegin();\n            CHECK_STATUS(gi_qBegin);\n\n            for (iface = 1; iface <= nface-2; iface++) {\n                status = setFaceAttribute(MODL, ibody, iface, iface+2, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            status = setFaceAttribute(MODL, ibody, nface-1, 2, npatn, patn);\n            CHECK_STATUS(setFaceAttribute);\n\n            status = setFaceAttribute(MODL, ibody, nface, 1, npatn, patn);\n            CHECK_STATUS(setFaceAttribute);\n\n            status = gi_qEnd(&errs);\n            CHECK_STATUS(gi_qEnd);\n\n            gi_free(errs);\n        #elif defined(GEOM_EGADS)\n            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n            CHECK_STATUS(EG_getBodyTopos);\n\n            for (iface = 1; iface <= nface; iface++) {\n                if        (iface == nface-1) {\n                    iford1 = 1;\n                } else if (iface == nface  ) {\n                    iford1 = 2;\n                } else {\n                    iford1 = iface + 2;\n                    }\n                status = setFaceAttribute(MODL, ibody, iface, iford1, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            EG_free(efaces);\n        #endif\n\n        /* finish the Body */\n        status = finishBody(MODL, ibody);\n        CHECK_STATUS(finishBody);\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n\n    /* execute: \"loft smooth\" */\n    } else if (type == OCSM_LOFT) {\n        SPRINT2(1, \"    executing [%4d] loft:       %11.5f\",\n                ibrch, args[1]);\n\n        /* pop Sketches from the stack (until the Mark) */\n        numSketches = 0;\n        ibodyl      = 0;\n        loftOpts    = -1;\n        while ((*nstack) > 0) {\n            ibodyl = stack[--(*nstack)];\n\n            if (ibodyl == 0) {\n                break;\n            } else {\n                if (loftOpts >= 0) {\n                } else if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {\n                    status = newBody(MODL, ibrch, OCSM_LOFT, ibodyl, ibodyl,\n                                     args, OCSM_SOLID_BODY, &ibody);\n                    CHECK_STATUS(newBody);\n\n                    loftOpts = 1;\n                } else if (MODL->body[ibodyl].botype == OCSM_SHEET_BODY) {\n                    status = newBody(MODL, ibrch, OCSM_LOFT, ibodyl, ibodyl,\n                                     args, OCSM_SOLID_BODY, &ibody);\n                    CHECK_STATUS(newBody);\n\n                    loftOpts = 1;\n                } else if (MODL->body[ibodyl].botype == OCSM_WIRE_BODY) {\n                    status = newBody(MODL, ibrch, OCSM_LOFT, ibodyl, ibodyl,\n                                     args, OCSM_SHEET_BODY, &ibody);\n                    CHECK_STATUS(newBody);\n\n                    loftOpts = 0;\n                }\n\n                #if   defined(GEOM_CAPRI)\n                    sketches[numSketches++] = -(MODL->body[ibodyl].ivol);\n                #elif defined(GEOM_EGADS)\n                    ebodyl = MODL->body[ibodyl].ebody;\n\n                    if (MODL->body[ibodyl].botype == OCSM_NODE_BODY) {\n                        esketches[numSketches++] = ebodyl;\n                    } else {\n                        status = EG_getBodyTopos(ebodyl, NULL, LOOP, &nloops, &echildren);\n                        CHECK_STATUS(EG_getBodyTopos);\n\n                        esketches[numSketches++] = echildren[0];\n\n                        EG_free(echildren);\n                    }\n                #endif\n\n                MODL->body[ibody ].ileft = ibodyl;\n                MODL->body[ibodyl].ichld = ibody;\n            }\n        }\n\n        if (numSketches < 2) {\n            status = OCSM_EXPECTING_NLOFT_SKETCHES;\n            CHECK_STATUS(loft);\n        } else {\n            SPRINT1(1, \"                          lofting %d Sketches...\", numSketches);\n        }\n\n        if (NINT(args[1]) != 1) {\n            loftOpts += 2;\n        }\n\n        /* create the Body */\n        #if   defined(GEOM_CAPRI)\n            /* itype=0 for solid-body, itype=1 for sheet-body */\n            /* do not forget \"setenv CAPRIshell ON\" if you want to create shells */\n            itype = 0;\n            status = gi_gLoft(server, modeller, 0, itype, numSketches, sketches);\n            if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n            CHECK_STATUS(gi_gLoft);\n\n            imodel = status;\n            status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n            CHECK_STATUS(gi_dGetModel);\n\n            MODL->body[ibody].ivol = ivol;\n        #elif defined(GEOM_EGADS)\n            status = EG_loft(numSketches, esketches, loftOpts, &ebody);\n            CHECK_STATUS(EG_loft);\n\n            MODL->body[ibody].ebody = ebody;\n        #endif\n\n        /* mark the new Faces with the current Branch */\n        #if   defined(GEOM_CAPRI)\n            status = gi_dGetVolume(ivol, &nnode, &nedge, &nface, &nbound, &name);\n            CHECK_STATUS(gi_dGetVolume);\n\n            status = gi_qBegin();\n            CHECK_STATUS(gi_qBegin);\n\n            for (iface = 1; iface <= nface; iface++) {\n                status = setFaceAttribute(MODL, ibody, iface, iface, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            status = gi_qEnd(&errs);\n            CHECK_STATUS(gi_qEnd);\n\n            gi_free(errs);\n        #elif defined(GEOM_EGADS)\n            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n            CHECK_STATUS(EG_getBodyTopos);\n\n            for (iface = 1; iface <= nface; iface++) {\n                if        (iface == nface-1) {\n                    iford1 = 1;\n                } else if (iface == nface  ) {\n                    iford1 = 2;\n                } else {\n                    iford1 = iface + 2;\n                }\n                status = setFaceAttribute(MODL, ibody, iface, iford1, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            EG_free(efaces);\n        #endif\n\n        /* finish the Body */\n        status = finishBody(MODL, ibody);\n        CHECK_STATUS(finishBody);\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n\n    /* execute: \"revolve xorig yorig zorig dxaxis dyaxis dzaxis angDeg\" */\n    } else if (type == OCSM_REVOLVE) {\n        SPRINT8(1, \"    executing [%4d] revolve:    %11.5f %11.5f %11.5f %11.5f %11.5f %11.5f %11.5f\",\n                ibrch, args[1], args[2], args[3], args[4],\n                       args[5], args[6], args[7]);\n\n        /* pop a Sketch from the stack */\n        if ((*nstack) < 1) {\n            status = OCSM_EXPECTING_ONE_BODY;\n            CHECK_STATUS(revolve);\n        } else {\n            ibodyl = stack[--(*nstack)];\n        }\n\n        /* check that ibodyl is a Sketch */\n        if (MODL->body[ibodyl].botype != OCSM_SHEET_BODY) {\n            status = OCSM_EXPECTING_ONE_SKETCH;\n            CHECK_STATUS(revolve);\n        }\n\n        /* create the Body */\n        status = newBody(MODL, ibrch, OCSM_REVOLVE, ibodyl, -1,\n                         args, OCSM_SOLID_BODY, &ibody);\n        CHECK_STATUS(newBody);\n\n        #if   defined(GEOM_CAPRI)\n            sketches[0] = -(MODL->body[ibodyl].ivol);\n            if (args[7] < 359.9) {\n                status = gi_gRevolve(server, modeller, 0, 0, sketches[0], &(args[1]), &(args[4]), args[7]);\n                if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n                CHECK_STATUS(gi_gRevolve);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n            } else {\n                status = gi_gRevolve(server, modeller, 0, 0, sketches[0], &(args[1]), &(args[4]), +180.0);\n                if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n                CHECK_STATUS(gi_gRevolve);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivoll, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n\n                status = gi_gRevolve(server, modeller, 0, 0, sketches[0], &(args[1]), &(args[4]), -180.0);\n                if (status == 0) status = OCSM_DID_NOT_CREATE_BODY;\n                CHECK_STATUS(gi_gRevolve);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivolr, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n\n                status = gi_gUnionVolume(ivoll, ivolr);\n                CHECK_STATUS(gi_gUnionVolume);\n\n                imodel = status;\n                status = gi_dGetModel(imodel, &ibeg, &ivol, &mfile, &mdum);\n                CHECK_STATUS(gi_dGetModel);\n            }\n\n            MODL->body[ibody].ivol = ivol;\n        #elif defined(GEOM_EGADS)\n            ebodyl = MODL->body[ibodyl].ebody;\n\n            status = EG_rotate(ebodyl, args[7], &(args[1]), &ebody);\n            CHECK_STATUS(EG_rotate);\n\n            MODL->body[ibody].ebody = ebody;\n        #endif\n\n        /* mark the new Faces with the current Branch */\n        #if   defined(GEOM_CAPRI)\n            /* find the dot product of the sketches' x-axis and the rotation axis\n               (to be used to set iford=1 and iford=2 below) */\n            status = gi_sOpen(0, sketches[0], orig, xaxis, yaxis);\n            CHECK_STATUS(gi_sOpen);\n\n            status = gi_sClose();\n            CHECK_STATUS(gi_sClose);\n\n            dot = xaxis[0] * args[4] + xaxis[1] * args[5] + xaxis[2] * args[6];\n\n            status = gi_dGetVolume(ivol, &nnode, &nedge, &nface, &nbound, &name);\n            CHECK_STATUS(gi_dGetVolume);\n\n            status = gi_qBegin();\n            CHECK_STATUS(gi_qBegin);\n\n            for (iface = 1; iface <= nface-2; iface++) {\n                status = setFaceAttribute(MODL, ibody, iface, iface+2, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            if (dot > 0.5) {\n                status = setFaceAttribute(MODL, ibody, nface-1, 2, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n\n                status = setFaceAttribute(MODL, ibody, nface, 1, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            } else {\n                status = setFaceAttribute(MODL, ibody, nface-1, 1, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n\n                status = setFaceAttribute(MODL, ibody, nface, 2, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            status = gi_qEnd(&errs);\n            CHECK_STATUS(gi_qEnd);\n\n            gi_free(errs);\n        #elif defined(GEOM_EGADS)\n            status = EG_getBodyTopos(ebody, NULL, FACE, &nface, &efaces);\n            CHECK_STATUS(EG_getBodyTopos);\n\n            for (iface = 1; iface <= nface; iface++) {\n                if        (iface == nface-1) {\n                    iford1 = 1;\n                } else if (iface == nface  ) {\n                    iford1 = 2;\n                } else {\n                    iford1 = iface + 2;\n                }\n                status = setFaceAttribute(MODL, ibody, iface, iford1, npatn, patn);\n                CHECK_STATUS(setFaceAttribute);\n            }\n\n            EG_free(efaces);\n        #endif\n\n        /* finish the Body */\n        status = finishBody(MODL, ibody);\n        CHECK_STATUS(finishBody);\n\n        /* push the Body onto the stack */\n        stack[(*nstack)++] = ibody;\n\n        SPRINT1(1, \"                          Body   %4d created\", ibody);\n    }\n\ncleanup:\n    DPRINT2(\"%s --> status=%d}\", routine, status);\n    return status;\n}", "path": "src\\OpenCSM\\OpenCSM.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsocket_rx_flow_control() - Enable and disable socket servicing for\n *\t\t\t\treceieved packets.\n *\n * If the output side of a server process becomes choked, this allows flow\n * control for the input side.\n *\n * @wsi:\tWebsocket connection instance to get callback for\n * @enable:\t0 = disable read servicing for this connection, 1 = enable\n */\n", "func_signal": "int\nlibwebsocket_rx_flow_control(struct libwebsocket *wsi, int enable)", "code": "{\n\tstruct libwebsocket_context *context = wsi->protocol->owning_server;\n\tint n;\n\n\tfor (n = 0; n < context->fds_count; n++)\n\t\tif (context->fds[n].fd == wsi->sock) {\n\t\t\tif (enable)\n\t\t\t\tcontext->fds[n].events |= POLLIN;\n\t\t\telse\n\t\t\t\tcontext->fds[n].events &= ~POLLIN;\n\n\t\t\treturn 0;\n\t\t}\n\n\tif (enable)\n\t\t/* external POLL support via protocol 0 */\n\t\tcontext->protocols[0].callback(context, wsi,\n\t\t\tLWS_CALLBACK_SET_MODE_POLL_FD,\n\t\t\t(void *)(long)wsi->sock, NULL, POLLIN);\n\telse\n\t\t/* external POLL support via protocol 0 */\n\t\tcontext->protocols[0].callback(context, wsi,\n\t\t\tLWS_CALLBACK_CLEAR_MODE_POLL_FD,\n\t\t\t(void *)(long)wsi->sock, NULL, POLLIN);\n\n#if 0\n\tfprintf(stderr, \"libwebsocket_rx_flow_control \"\n\t\t\t\t\t\t     \"unable to find socket\\n\");\n#endif\n\treturn 1;\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n * Perform the newer BASE64-encoded handshake scheme\n */\n", "func_signal": "static int\nhandshake_0405(struct libwebsocket_context *context, struct libwebsocket *wsi)", "code": "{\n\tstatic const char *websocket_magic_guid_04 =\n\t\t\t\t\t \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\tstatic const char *websocket_magic_guid_04_masking =\n\t\t\t\t\t \"61AC5F19-FBBA-4540-B96F-6561F1AB40A8\";\n\tchar accept_buf[MAX_WEBSOCKET_04_KEY_LEN + 37];\n\tchar nonce_buf[256];\n\tchar mask_summing_buf[256 + MAX_WEBSOCKET_04_KEY_LEN + 37];\n\tunsigned char hash[20];\n\tint n;\n\tchar *response;\n\tchar *p;\n\tchar *m = mask_summing_buf;\n\tint nonce_len = 0;\n\tint accept_len;\n\tchar *c;\n\tchar ext_name[128];\n\tstruct libwebsocket_extension *ext;\n\tint ext_count = 0;\n\tint more = 1;\n\n\tif (!wsi->utf8_token[WSI_TOKEN_HOST].token_len ||\n\t    !wsi->utf8_token[WSI_TOKEN_KEY].token_len) {\n\t\tdebug(\"handshake_04 missing pieces\\n\");\n\t\t/* completed header processing, but missing some bits */\n\t\tgoto bail;\n\t}\n\n\tif (wsi->utf8_token[WSI_TOKEN_KEY].token_len >=\n\t\t\t\t\t\t     MAX_WEBSOCKET_04_KEY_LEN) {\n\t\tfprintf(stderr, \"Client sent handshake key longer \"\n\t\t\t   \"than max supported %d\\n\", MAX_WEBSOCKET_04_KEY_LEN);\n\t\tgoto bail;\n\t}\n\n\tstrcpy(accept_buf, wsi->utf8_token[WSI_TOKEN_KEY].token);\n\tstrcpy(accept_buf + wsi->utf8_token[WSI_TOKEN_KEY].token_len,\n\t\t\t\t\t\t       websocket_magic_guid_04);\n\n\tSHA1((unsigned char *)accept_buf,\n\t\t\twsi->utf8_token[WSI_TOKEN_KEY].token_len +\n\t\t\t\t\t strlen(websocket_magic_guid_04), hash);\n\n\taccept_len = lws_b64_encode_string((char *)hash, 20, accept_buf,\n\t\t\t\t\t\t\t     sizeof accept_buf);\n\tif (accept_len < 0) {\n\t\tfprintf(stderr, \"Base64 encoded hash too long\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* allocate the per-connection user memory (if any) */\n\tif (wsi->protocol->per_session_data_size &&\n\t\t\t\t\t  !libwebsocket_ensure_user_space(wsi))\n\t\tgoto bail;\n\n\t/* create the response packet */\n\n\t/* make a buffer big enough for everything */\n\n\tresponse = malloc(256 +\n\t\twsi->utf8_token[WSI_TOKEN_UPGRADE].token_len +\n\t\twsi->utf8_token[WSI_TOKEN_CONNECTION].token_len +\n\t\twsi->utf8_token[WSI_TOKEN_PROTOCOL].token_len);\n\tif (!response) {\n\t\tfprintf(stderr, \"Out of memory for response buffer\\n\");\n\t\tgoto bail;\n\t}\n\n\tp = response;\n\tLWS_CPYAPP(p, \"HTTP/1.1 101 Switching Protocols\\x0d\\x0a\"\n\t\t      \"Upgrade: WebSocket\\x0d\\x0a\"\n\t\t      \"Connection: Upgrade\\x0d\\x0a\"\n\t\t      \"Sec-WebSocket-Accept: \");\n\tstrcpy(p, accept_buf);\n\tp += accept_len;\n\n\tif (wsi->ietf_spec_revision == 4) {\n\t\tLWS_CPYAPP(p, \"\\x0d\\x0aSec-WebSocket-Nonce: \");\n\n\t\t/* select the nonce */\n\n\t\tn = libwebsockets_get_random(wsi->protocol->owning_server,\n\t\t\t\t\t\t\t\t      hash, 16);\n\t\tif (n != 16) {\n\t\t\tfprintf(stderr, \"Unable to read random device %s %d\\n\",\n\t\t\t\t\t\t     SYSTEM_RANDOM_FILEPATH, n);\n\t\t\tif (wsi->user_space)\n\t\t\t\tfree(wsi->user_space);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* encode the nonce */\n\n\t\tnonce_len = lws_b64_encode_string((const char *)hash, 16,\n\t\t\t\t\t\t   nonce_buf, sizeof nonce_buf);\n\t\tif (nonce_len < 0) {\n\t\t\tfprintf(stderr, \"Failed to base 64 encode the nonce\\n\");\n\t\t\tif (wsi->user_space)\n\t\t\t\tfree(wsi->user_space);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* apply the nonce */\n\n\t\tstrcpy(p, nonce_buf);\n\t\tp += nonce_len;\n\t}\n\n\tif (wsi->utf8_token[WSI_TOKEN_PROTOCOL].token) {\n\t\tLWS_CPYAPP(p, \"\\x0d\\x0aSec-WebSocket-Protocol: \");\n\t\tLWS_CPYAPP_TOKEN(p, WSI_TOKEN_PROTOCOL);\n\t}\n\n\t/*\n\t * Figure out which extensions the client has that we want to\n\t * enable on this connection, and give him back the list\n\t */\n\n\tif (wsi->utf8_token[WSI_TOKEN_EXTENSIONS].token_len) {\n\n\t\t/*\n\t\t * break down the list of client extensions\n\t\t * and go through them\n\t\t */\n\n\t\tc = wsi->utf8_token[WSI_TOKEN_EXTENSIONS].token;\n\t\tdebug(\"wsi->utf8_token[WSI_TOKEN_EXTENSIONS].token = %s\\n\",\n\t\t\t\t  wsi->utf8_token[WSI_TOKEN_EXTENSIONS].token);\n\t\twsi->count_active_extensions = 0;\n\t\tn = 0;\n\t\twhile (more) {\n\n\t\t\tif (*c && (*c != ',' && *c != ' ' && *c != '\\t')) {\n\t\t\t\text_name[n] = *c++;\n\t\t\t\tif (n < sizeof(ext_name) - 1)\n\t\t\t\t\tn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\text_name[n] = '\\0';\n\t\t\tif (!*c)\n\t\t\t\tmore = 0;\n\t\t\telse {\n\t\t\t\tc++;\n\t\t\t\tif (!n)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check a client's extension against our support */\n\n\t\t\text = wsi->protocol->owning_server->extensions;\n\n\t\t\twhile (ext && ext->callback) {\n\n\t\t\t\tif (strcmp(ext_name, ext->name)) {\n\t\t\t\t\text++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * oh, we do support this one he\n\t\t\t\t * asked for... but let's ask user\n\t\t\t\t * code if it's OK to apply it on this\n\t\t\t\t * particular connection + protocol\n\t\t\t\t */\n\n\t\t\t\tn = wsi->protocol->owning_server->\n\t\t\t\t\tprotocols[0].callback(\n\t\t\t\t\t\twsi->protocol->owning_server,\n\t\t\t\t\t\twsi,\n\t\t\t\t\t  LWS_CALLBACK_CONFIRM_EXTENSION_OKAY,\n\t\t\t\t\t\t  wsi->user_space, ext_name, 0);\n\n\t\t\t\t/*\n\t\t\t\t * zero return from callback means\n\t\t\t\t * go ahead and allow the extension,\n\t\t\t\t * it's what we get if the callback is\n\t\t\t\t * unhandled\n\t\t\t\t */\n\n\t\t\t\tif (n) {\n\t\t\t\t\text++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* apply it */\n\n\t\t\t\tif (ext_count)\n\t\t\t\t\t*p++ = ',';\n\t\t\t\telse\n\t\t\t\t\tLWS_CPYAPP(p,\n\t\t\t\t\t \"\\x0d\\x0aSec-WebSocket-Extensions: \");\n\t\t\t\tp += sprintf(p, \"%s\", ext_name);\n\t\t\t\text_count++;\n\n\t\t\t\t/* instantiate the extension on this conn */\n\n\t\t\t\twsi->active_extensions_user[\n\t\t\t\t\twsi->count_active_extensions] =\n\t\t\t\t\t     malloc(ext->per_session_data_size);\n\t\t\t\tmemset(wsi->active_extensions_user[\n\t\t\t\t\twsi->count_active_extensions], 0,\n\t\t\t\t\t\t    ext->per_session_data_size);\n\n\t\t\t\twsi->active_extensions[\n\t\t\t\t\t  wsi->count_active_extensions] = ext;\n\n\t\t\t\t/* allow him to construct his context */\n\n\t\t\t\text->callback(wsi->protocol->owning_server,\n\t\t\t\t\t\text, wsi,\n\t\t\t\t\t\tLWS_EXT_CALLBACK_CONSTRUCT,\n\t\t\t\t\t\twsi->active_extensions_user[\n\t\t\t\t\twsi->count_active_extensions], NULL, 0);\n\n\t\t\t\twsi->count_active_extensions++;\n\t\t\t\tdebug(\"wsi->count_active_extensions <- %d\",\n\t\t\t\t\t\t  wsi->count_active_extensions);\n\n\t\t\t\text++;\n\t\t\t}\n\n\t\t\tn = 0;\n\t\t}\n\t}\n\n\t/* end of response packet */\n\n\tLWS_CPYAPP(p, \"\\x0d\\x0a\\x0d\\x0a\");\n\n\tif (wsi->ietf_spec_revision == 4) {\n\n\t\t/*\n\t\t * precompute the masking key the client will use from the SHA1\n\t\t * hash of ( base 64 client key we were sent, concatenated with\n\t\t * the bse 64 nonce we sent, concatenated with a magic constant\n\t\t * guid specified by the 04 standard )\n\t\t *\n\t\t * We store the hash in the connection's wsi ready to use with\n\t\t * undoing the masking the client has done on framed data it\n\t\t * sends (we send our data to the client in clear).\n\t\t */\n\n\t\tstrcpy(mask_summing_buf, wsi->utf8_token[WSI_TOKEN_KEY].token);\n\t\tm += wsi->utf8_token[WSI_TOKEN_KEY].token_len;\n\t\tstrcpy(m, nonce_buf);\n\t\tm += nonce_len;\n\t\tstrcpy(m, websocket_magic_guid_04_masking);\n\t\tm += strlen(websocket_magic_guid_04_masking);\n\n\t\tSHA1((unsigned char *)mask_summing_buf, m - mask_summing_buf,\n\t\t\t\t\t\t\t   wsi->masking_key_04);\n\t}\n\n\tif (!lws_any_extension_handled(context, wsi,\n\t\t\tLWS_EXT_CALLBACK_HANDSHAKE_REPLY_TX,\n\t\t\t\t\t\t     response, p - response)) {\n\n\t\t/* okay send the handshake response accepting the connection */\n\n\t\tdebug(\"issuing response packet %d len\\n\", (int)(p - response));\n\t#ifdef DEBUG\n\t\tfwrite(response, 1,  p - response, stderr);\n\t#endif\n\t\tn = libwebsocket_write(wsi, (unsigned char *)response,\n\t\t\t\t\t\t  p - response, LWS_WRITE_HTTP);\n\t\tif (n < 0) {\n\t\t\tfprintf(stderr, \"ERROR writing to socket\");\n\t\t\tgoto bail;\n\t\t}\n\n\t}\n\n\t/* alright clean up and set ourselves into established state */\n\n\tfree(response);\n\twsi->state = WSI_STATE_ESTABLISHED;\n\twsi->lws_rx_parse_state = LWS_RXPS_NEW;\n\twsi->rx_packet_length = 0;\n\n\t/* notify user code that we're ready to roll */\n\n\tif (wsi->protocol->callback)\n\t\twsi->protocol->callback(wsi->protocol->owning_server,\n\t\t\t\twsi, LWS_CALLBACK_ESTABLISHED,\n\t\t\t\t\t  wsi->user_space, NULL, 0);\n\n\treturn 0;\n\n\nbail:\n\treturn -1;\n}", "path": "src\\wvServer\\handshake.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/* =========================================================================\n * This function can be used by asm versions of crc32()\n */\n", "func_signal": "const unsigned long FAR * ZEXPORT get_crc_table()", "code": "{\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n        make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const unsigned long FAR *)crc_table;\n}", "path": "src\\wvServer\\zlib\\crc32.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/**\n * libwebsockets_hangup_on_client() - Server calls to terminate client\n *\t\t\t\t\tconnection\n * @context:\tlibwebsockets context\n * @fd:\t\tConnection socket descriptor\n */\n", "func_signal": "void\nlibwebsockets_hangup_on_client(struct libwebsocket_context *context, int fd)", "code": "{\n\tstruct libwebsocket *wsi = wsi_from_fd(context, fd);\n\n\tif (wsi == NULL)\n\t\treturn;\n\n\tlibwebsocket_close_and_free_session(context, wsi,\n\t\t\t\t\t\t     LWS_CLOSE_STATUS_NOSTATUS);\n}", "path": "src\\wvServer\\libwebsockets_orig.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/*\n ************************************************************************\n *                                                                      *\n *   spline1d - create 1d cubic spline (uniform spacing, fixed ends)    *\n *                                                                      *\n ************************************************************************\n */\n", "func_signal": "static int\nspline1d(ego    context,\n         int    imax,\n         double *x,\n         double *y,\n         double *z,\n         ego    *ecurv)", "code": "{\n    int    status = EGADS_SUCCESS;\n\n    int    i, kk, iknot, icp, iter, niter, header[4];\n    double *cp=NULL, dx, dy, dz, data[18], dxyzmax;\n    double dxyztol = 1.0e-7;\n\n    icp   = imax + 2;\n    iknot = imax + 6;\n\n    cp     = (double*) EG_alloc((iknot+3*icp)*sizeof(double));\n\n    if (cp == NULL) {\n        status = EGADS_MALLOC;\n        goto cleanup;\n    }\n\n    /* create spline curve */\n    header[0] = 0;\n    header[1] = 3;\n    header[2] = icp;\n    header[3] = iknot;\n\n    kk = 0;\n\n    /* knots (equally spaced) */\n    cp[kk++] = 0;\n    cp[kk++] = 0;\n    cp[kk++] = 0;\n    cp[kk++] = 0;\n\n    for (i = 1; i < imax; i++) {\n        cp[kk++] = i;\n    }\n\n    cp[kk] = cp[kk-1]; kk++;\n    cp[kk] = cp[kk-1]; kk++;\n    cp[kk] = cp[kk-1]; kk++;\n\n    /* initial control point */\n    cp[kk++] = x[0];\n    cp[kk++] = y[0];\n    cp[kk++] = z[0];\n\n    /* initial interior control point (for slope) */\n    cp[kk++] = (3 * x[0] + x[1]) / 4;\n    cp[kk++] = (3 * y[0] + y[1]) / 4;\n    cp[kk++] = (3 * z[0] + z[1]) / 4;\n\n    /* interior control points */\n    for (i = 1; i < imax-1; i++) {\n        cp[kk++] = x[i];\n        cp[kk++] = y[i];\n        cp[kk++] = z[i];\n    }\n\n    /* penultimate interior control point (for slope) */\n    cp[kk++] = (3 * x[imax-1] + x[imax-2]) / 4;\n    cp[kk++] = (3 * y[imax-1] + y[imax-2]) / 4;\n    cp[kk++] = (3 * z[imax-1] + z[imax-2]) / 4;\n\n    /* final control point */\n    cp[kk++] = x[imax-1];\n    cp[kk++] = y[imax-1];\n    cp[kk++] = z[imax-1];\n\n    /* make the original BSPLINE (based upon the assumed control points) */\n    status = EG_makeGeometry(context, CURVE, BSPLINE, NULL,\n                             header, cp, ecurv);\n    if (status != EGADS_SUCCESS) goto cleanup;\n\n    /* iterate to have knot evaluations match data points */\n    niter = 10000;\n    for (iter = 0; iter < niter; iter++) {\n        dxyzmax = 0;\n\n        /* match interior spline points */\n        for (i = 1; i < imax-1; i++) {\n            status = EG_evaluate(*ecurv, &(cp[i+3]), data);\n            if (status != EGADS_SUCCESS) goto cleanup;\n\n            dx = x[i] - data[0];\n            dy = y[i] - data[1];\n            dz = z[i] - data[2];\n\n            if (fabs(dx) > dxyzmax) dxyzmax = fabs(dx);\n            if (fabs(dy) > dxyzmax) dxyzmax = fabs(dy);\n            if (fabs(dz) > dxyzmax) dxyzmax = fabs(dz);\n\n            cp[iknot+3*i+3] += dx;\n            cp[iknot+3*i+4] += dy;\n            cp[iknot+3*i+5] += dz;\n        }\n\n        /* convergence check */\n        if (dxyzmax < dxyztol) break;\n\n        /* make the new curve (after deleting old one) */\n        status = EG_deleteObject(*ecurv);\n        if (status != EGADS_SUCCESS) goto cleanup;\n\n        status = EG_makeGeometry(context, CURVE, BSPLINE, NULL,\n                                 header, cp, ecurv);\n        if (status != EGADS_SUCCESS) goto cleanup;\n    }\n\ncleanup:\n        EG_free(cp);\n\n        return status;\n}", "path": "src\\OpenCSM\\udpFreeform.c", "repo_name": "OpenMDAO/EngSketchPad", "stars": 16, "license": "None", "language": "c", "size": 13835}
{"docstring": "/****************************************************************************\n*                                                                           *\n* Command Received - process it                                             *\n*                                                                           *\n****************************************************************************/\n", "func_signal": "void process_gcode_command()", "code": "{\n\tuint32_t\tbackup_f;\n\t\n\t// convert relative to absolute\n\tif (next_target.option_relative) {\n\t\tnext_target.target.X += startpoint.X;\n\t\tnext_target.target.Y += startpoint.Y;\n\t\tnext_target.target.Z += startpoint.Z;\n\t}\n\t// E ALWAYS relative, otherwise we overflow our registers after only a few layers\n\t// \tnext_target.target.E += startpoint.E;\n\t// easier way to do this\n\t// \tstartpoint.E = 0;\n\t// moved to dda.c, end of dda_create() and dda_queue.c, next_move()\n\n\t// implement axis limits\n\t#ifdef\tX_MIN\n\t\tif (next_target.target.X < (X_MIN * STEPS_PER_MM_X))\n\t\t\tnext_target.target.X = X_MIN;\n\t#endif\n\t#ifdef\tX_MAX\n\t\tif (next_target.target.X > (X_MAX * STEPS_PER_MM_X))\n\t\t\tnext_target.target.X = X_MAX;\n\t#endif\n\t#ifdef\tY_MIN\n\t\tif (next_target.target.Y < (Y_MIN * STEPS_PER_MM_Y))\n\t\t\tnext_target.target.Y = Y_MIN;\n\t#endif\n\t#ifdef\tY_MAX\n\t\tif (next_target.target.Y > (Y_MAX * STEPS_PER_MM_Y))\n\t\t\tnext_target.target.Y = Y_MAX;\n\t#endif\n\t#ifdef\tZ_MIN\n\t\tif (next_target.target.Z < (Z_MIN * STEPS_PER_MM_Z))\n\t\t\tnext_target.target.Z = Z_MIN;\n\t#endif\n\t#ifdef\tZ_MAX\n\t\tif (next_target.target.Z > (Z_MAX * STEPS_PER_MM_Z))\n\t\t\tnext_target.target.Z = Z_MAX;\n\t#endif\n\n\n\tif (next_target.seen_T) {\n\t\tnext_tool = next_target.T;\n\t}\n\n\tif (next_target.seen_G) {\n\t\tuint8_t axisSelected = 0;\n\t\tswitch (next_target.G) {\n\t\t\t// \tG0 - rapid, unsynchronised motion\n\t\t\t// since it would be a major hassle to force the dda to not synchronise, just provide a fast feedrate and hope it's close enough to what host expects\n\t\t\tcase 0:\n\t\t\t\tbackup_f = next_target.target.F;\n\t\t\t\tnext_target.target.F = MAXIMUM_FEEDRATE_X * 2;\n\t\t\t\tenqueue(&next_target.target);\n\t\t\t\tnext_target.target.F = backup_f;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG1 - synchronised motion\n\t\t\tcase 1:\n\t\t\t\tenqueue(&next_target.target);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG2 - Arc Clockwise\n\t\t\t\t// unimplemented\n\t\t\t\t\n\t\t\t\t//\tG3 - Arc Counter-clockwise\n\t\t\t\t// unimplemented\n\t\t\t\t\n\t\t\t\t//\tG4 - Dwell\n\t\t\tcase 4:\n\t\t\t\t// wait for all moves to complete\n\t\t\t\tqueue_wait();\n\t\t\t\t// delay\n\t\t\t\tfor (;next_target.P > 0;next_target.P--) {\n\t\t\t\t\tifclock(CLOCK_FLAG_10MS) {\n\t\t\t\t\t\tclock_10ms();\n\t\t\t\t\t}\n\t\t\t\t\tdelay_ms(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG20 - inches as units\n\t\t\tcase 20:\n\t\t\t\tnext_target.option_inches = 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG21 - mm as units\n\t\t\tcase 21:\n\t\t\t\tnext_target.option_inches = 0;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG30 - go home via point\n\t\t\tcase 30:\n\t\t\t\tenqueue(&next_target.target);\n\t\t\t\t// no break here, G30 is move and then go home\n\t\t\t\t\n\t\t\t\t//\tG28 - go home\n\t\t\tcase 28:\n\t\t\t\tqueue_wait();\n\t\t\t\t\n\t\t\t\tif (next_target.seen_X) {\n\t\t\t\t\tzero_x();\n\t\t\t\t\taxisSelected = 1;\n\t\t\t\t}\n\t\t\t\tif (next_target.seen_Y) {\n\t\t\t\t\tzero_y();\n\t\t\t\t\taxisSelected = 1;\n\t\t\t\t}\n\t\t\t\tif (next_target.seen_Z) {\n\t\t\t\t\tzero_z();\n\t\t\t\t\taxisSelected = 1;\n\t\t\t\t}\n\t\t\t\tif (next_target.seen_E) {\n\t\t\t\t\tzero_e();\n\t\t\t\t\taxisSelected = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!axisSelected) {\n\t\t\t\t\tzero_x();\n\t\t\t\t\tzero_y();\n\t\t\t\t\tzero_z();\n\t\t\t\t\tzero_e();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t//\tG90 - absolute positioning\n\t\t\t\tcase 90:\n\t\t\t\t\tnext_target.option_relative = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t//\tG91 - relative positioning\n\t\t\t\tcase 91:\n\t\t\t\t\tnext_target.option_relative = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t//\tG92 - set home\n\t\t\t\tcase 92:\n\t\t\t\t\t// wait for queue to empty\n\t\t\t\t\tqueue_wait();\n\n\t\t\t\t\tif (next_target.seen_X) {\n\t\t\t\t\t\tstartpoint.X = current_position.X = next_target.target.X;\n\t\t\t\t\t\taxisSelected = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (next_target.seen_Y) {\n\t\t\t\t\t\tstartpoint.Y = current_position.Y = next_target.target.Y;\n\t\t\t\t\t\taxisSelected = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (next_target.seen_Z) {\n\t\t\t\t\t\tstartpoint.Z = current_position.Z = next_target.target.Z;\n\t\t\t\t\t\taxisSelected = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (next_target.seen_E) {\n\t\t\t\t\t\tstartpoint.E = current_position.E = next_target.target.E;\n\t\t\t\t\t\taxisSelected = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (axisSelected == 0) {\n\t\t\t\t\t\tstartpoint.X = current_position.X =\n\t\t\t\t\t\tstartpoint.Y = current_position.Y =\n\t\t\t\t\t\tstartpoint.Z = current_position.Z =\n\t\t\t\t\t\tstartpoint.E = current_position.E = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// G161 - Home negative\n\t\t\t\tcase 161:\n\t\t\t\t\tif (next_target.seen_X)\n\t\t\t\t\t\thome_x_negative();\n\t\t\t\t\tif (next_target.seen_Y)\n\t\t\t\t\t\thome_y_negative();\n\t\t\t\t\tif (next_target.seen_Z)\n\t\t\t\t\t\thome_z_negative();\n\t\t\t\t\tbreak;\n\t\t\t\t// G162 - Home positive\n\t\t\t\tcase 162:\n\t\t\t\t\tif (next_target.seen_X)\n\t\t\t\t\t\thome_x_positive();\n\t\t\t\t\tif (next_target.seen_Y)\n\t\t\t\t\t\thome_y_positive();\n\t\t\t\t\tif (next_target.seen_Z)\n\t\t\t\t\t\thome_z_positive();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t// unknown gcode: spit an error\n\t\t\t\tdefault:\n\t\t\t\t\tsersendf_P(PSTR(\"E: Bad G-code %d\"), next_target.G);\n\t\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\t\treturn;\n\t\t}\n\t\t#ifdef\tDEBUG\n\t\t\tprint_queue();\n\t\t#endif\n\t}\n\telse if (next_target.seen_M) {\n\t\tswitch (next_target.M) {\n\t\t\t// M2- program end\n\t\t\tcase 2:\n\t\t\t\ttimer_stop();\n\t\t\t\tqueue_flush();\n\t\t\t\tx_disable();\n\t\t\t\ty_disable();\n\t\t\t\tz_disable();\n\t\t\t\tpower_off();\n\t\t\t\tfor (;;)\n\t\t\t\t\twd_reset();\n\t\t\t\tbreak;\n\n\t\t\t// M6- tool change\n\t\t\tcase 6:\n\t\t\t\ttool = next_tool;\n\t\t\t\tbreak;\n\t\t\t// M3/M101- extruder on\n\t\t\tcase 3:\n\t\t\tcase 101:\n\t\t\t\tif (temp_achieved() == 0) {\n\t\t\t\t\tenqueue(NULL);\n\t\t\t\t}\n\t\t\t\t#ifdef DC_EXTRUDER\n\t\t\t\t\theater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);\n\t\t\t\t#elif E_STARTSTOP_STEPS > 0\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// backup feedrate, move E very quickly then restore feedrate\n\t\t\t\t\t\tbackup_f = startpoint.F;\n\t\t\t\t\t\tstartpoint.F = MAXIMUM_FEEDRATE_E;\n\t\t\t\t\t\tSpecialMoveE(E_STARTSTOP_STEPS, MAXIMUM_FEEDRATE_E);\n\t\t\t\t\t\tstartpoint.F = backup_f;\n\t\t\t\t\t} while (0);\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M102- extruder reverse\n\t\t\t\t\n\t\t\t// M5/M103- extruder off\n\t\t\tcase 5:\n\t\t\tcase 103:\n\t\t\t\t#ifdef DC_EXTRUDER\n\t\t\t\t\theater_set(DC_EXTRUDER, 0);\n\t\t\t\t#elif E_STARTSTOP_STEPS > 0\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// backup feedrate, move E very quickly then restore feedrate\n\t\t\t\t\t\tbackup_f = startpoint.F;\n\t\t\t\t\t\tstartpoint.F = MAXIMUM_FEEDRATE_E;\n\t\t\t\t\t\tSpecialMoveE(-E_STARTSTOP_STEPS, MAXIMUM_FEEDRATE_E);\n\t\t\t\t\t\tstartpoint.F = backup_f;\n\t\t\t\t\t} while (0);\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M104- set temperature\n\t\t\tcase 104:\n\t\t\t\ttemp_set(next_target.P, next_target.S);\n\t\t\t\tif (next_target.S)\n\t\t\t\t\tpower_on();\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M105- get temperature\n\t\t\tcase 105:\n\t\t\t\ttemp_print(next_target.P);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M7/M106- fan on\n\t\t\tcase 7:\n\t\t\tcase 106:\n\t\t\t\t#ifdef HEATER_FAN\n\t\t\t\t\theater_set(HEATER_FAN, 255);\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t// M107- fan off\n\t\t\tcase 9:\n\t\t\tcase 107:\n\t\t\t\t#ifdef HEATER_FAN\n\t\t\t\t\theater_set(HEATER_FAN, 0);\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M109- set temp and wait\n\t\t\tcase 109:\n\t\t\t\ttemp_set(next_target.P, next_target.S);\n\t\t\t\tif (next_target.S) {\n\t\t\t\t\tpower_on();\n\t\t\t\t\tenable_heater();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdisable_heater();\n\t\t\t\t}\n\t\t\t\tenqueue(NULL);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M110- set line number\n\t\t\tcase 110:\n\t\t\t\tnext_target.N_expected = next_target.S - 1;\n\t\t\t\tbreak;\n\t\t\t// M111- set debug level\n\t\t\t#ifdef\tDEBUG\n\t\t\tcase 111:\n\t\t\t\tdebug_flags = next_target.S;\n\t\t\t\tbreak;\n\t\t\t#endif\n\t\t\t// M112- immediate stop\n\t\t\tcase 112:\n\t\t\t\ttimer_stop();\n\t\t\t\tqueue_flush();\n\t\t\t\tpower_off();\n\t\t\t\tbreak;\n\t\t\t\t// M113- extruder PWM\n\t\t\t// M114- report XYZEF to host\n\t\t\tcase 114:\n\t\t\t\tsersendf_P(PSTR(\"X:%ld,Y:%ld,Z:%ld,E:%ld,F:%ld\"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\t\t\t// M115- capabilities string\n\t\t\tcase 115:\n\t\t\t\tsersendf_P(PSTR(\"FIRMWARE_NAME:FiveD_on_Arduino FIRMWARE_URL:http%%3A//github.com/triffid/FiveD_on_Arduino/ PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:%d TEMP_SENSOR_COUNT:%d HEATER_COUNT:%d\"), 1, NUM_TEMP_SENSORS, NUM_HEATERS);\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\n\t\t\t// M130- heater P factor\n\t\t\tcase 130:\n\t\t\t\tif (next_target.seen_S)\n\t\t\t\t\tpid_set_p(next_target.P, next_target.S);\n\t\t\t\tbreak;\n\t\t\t// M131- heater I factor\n\t\t\tcase 131:\n\t\t\t\tif (next_target.seen_S)\n\t\t\t\t\tpid_set_i(next_target.P, next_target.S);\n\t\t\t\tbreak;\n\t\t\t// M132- heater D factor\n\t\t\tcase 132:\n\t\t\t\tif (next_target.seen_S)\n\t\t\t\t\tpid_set_d(next_target.P, next_target.S);\n\t\t\t\tbreak;\n\t\t\t// M133- heater I limit\n\t\t\tcase 133:\n\t\t\t\tif (next_target.seen_S)\n\t\t\t\t\tpid_set_i_limit(next_target.P, next_target.S);\n\t\t\t\tbreak;\n\t\t\t// M134- save PID settings to eeprom\n\t\t\tcase 134:\n\t\t\t\theater_save_settings();\n\t\t\t\tbreak;\n\t\t\t// M135- set heater output\n\t\t\tcase 135:\n\t\t\t\tif (next_target.seen_S) {\n\t\t\t\t\theater_set(next_target.P, next_target.S);\n\t\t\t\t\tpower_on();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t#ifdef\tDEBUG\n\t\t\t// M136- PRINT PID settings to host\n\t\t\tcase 136:\n\t\t\t\theater_print(next_target.P);\n\t\t\t\tbreak;\n\t\t\t#endif\n\n\t\t\tcase 140: //Set heated bed temperature\n\t\t\t\t#ifdef\tHEATER_BED\n\t\t\t\t\ttemp_set(HEATER_BED, next_target.S);\n\t\t\t\t\tif (next_target.S)\n\t\t\t\t\t\tpower_on();\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// M190- power on\n\t\t\tcase 190:\n\t\t\t\tpower_on();\n\t\t\t\tx_enable();\n\t\t\t\ty_enable();\n\t\t\t\tz_enable();\n\t\t\t\tsteptimeout = 0;\n\t\t\t\tbreak;\n\t\t\t// M191- power off\n\t\t\tcase 191:\n\t\t\t\tx_disable();\n\t\t\t\ty_disable();\n\t\t\t\tz_disable();\n\t\t\t\tpower_off();\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t#ifdef\tDEBUG\n\t\t\t// M240- echo off\n\t\t\tcase 240:\n\t\t\t\tdebug_flags &= ~DEBUG_ECHO;\n\t\t\t\tserial_writestr_P(PSTR(\"Echo off\"));\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\t\t\t\t// M241- echo on\n\t\t\tcase 241:\n\t\t\t\tdebug_flags |= DEBUG_ECHO;\n\t\t\t\tserial_writestr_P(PSTR(\"Echo on\"));\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// DEBUG: return current position, end position, queue\n\t\t\tcase 250:\n\t\t\t\tsersendf_P(PSTR(\"{X:%ld,Y:%ld,Z:%ld,E:%ld,F:%lu,c:%lu}\\t{X:%ld,Y:%ld,Z:%ld,E:%ld,F:%lu,c:%lu}\\t\"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F, movebuffer[mb_tail].c, movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F,\n\t\t\t\t\t#ifdef ACCELERATION_REPRAP\n\t\t\t\t\t\tmovebuffer[mb_tail].end_c\n\t\t\t\t\t#else\n\t\t\t\t\t\tmovebuffer[mb_tail].c\n\t\t\t\t\t#endif\n\t\t\t\t\t);\n\n\t\t\t\tprint_queue();\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// DEBUG: read arbitrary memory location\n\t\t\tcase 253:\n\t\t\t\tif (next_target.seen_P == 0)\n\t\t\t\t\tnext_target.P = 1;\n\t\t\t\tfor (; next_target.P; next_target.P--) {\n\t\t\t\t\tserwrite_hex8(*(volatile uint8_t *)(next_target.S));\n\t\t\t\t\tnext_target.S++;\n\t\t\t\t}\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t// DEBUG: write arbitrary memory locatiom\n\t\t\tcase 254:\n\t\t\t\tsersendf_P(PSTR(\"%x:%x->%x\"), next_target.S, *(volatile uint8_t *)(next_target.S), next_target.P);\n\t\t\t\t(*(volatile uint8_t *)(next_target.S)) = next_target.P;\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t\t\tbreak;\n\t\t\t#endif /* DEBUG */\n\t\t\t\t// unknown mcode: spit an error\n\t\t\tdefault:\n\t\t\t\tsersendf_P(PSTR(\"E: Bad M-code %d\"), next_target.M);\n\t\t\t\t// newline is sent from gcode_parse after we return\n\t\t} // switch (next_target.M)\n\t} // else if (next_target.seen_M)\n}", "path": "gcode_process.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\n\tStart a prepared DDA\n*/\n", "func_signal": "void dda_start(DDA *dda)", "code": "{\n\t// called from interrupt context: keep it simple!\n\tif (dda->nullmove) {\n\t\t// just change speed?\n\t\tcurrent_position.F = dda->endpoint.F;\n\t\t// keep dda->live = 0\n\t}\n\telse {\n/*\t\tif (dda->waitfor_temp) {\n\t\t\t#ifndef\tREPRAP_HOST_COMPATIBILITY\n\t\t\t\tserial_writestr_P(PSTR(\"Waiting for target temp\\n\"));\n\t\t\t#endif\n\t\t}\n\t\telse {*/\n\t\t// ensure steppers are ready to go\n\t\tsteptimeout = 0;\n\t\tpower_on();\n\t\tx_enable();\n\t\ty_enable();\n\t\tif (dda->z_delta)\n\t\t\tz_enable();\n\n\t\t// set direction outputs\n\t\tx_direction(dda->x_direction);\n\t\ty_direction(dda->y_direction);\n\t\tz_direction(dda->z_direction);\n\t\te_direction(dda->e_direction);\n\n\t\t#ifdef\tDC_EXTRUDER\n\t\tif (dda->e_delta)\n\t\t\theater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);\n\t\t#endif\n\n// \t\t}\n\n\t\t// ensure this dda starts\n\t\tdda->live = 1;\n\n\t\t// set timeout for first step\n\t\tsetTimer(dda->c >> 8);\n\t}\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// comparator B is the \"clock\", happens every TICK_TIME\n", "func_signal": "ISR(TIMER1_COMPB_vect)", "code": "{\n\t// set output compare register to the next clock tick\n\tOCR1B = (OCR1B + TICK_TIME) & 0xFFFF;\n\t\n\t/*\n\tclock stuff\n\t*/\n\tclock_counter_10ms += TICK_TIME_MS;\n\tif (clock_counter_10ms >= 10) {\n\t\tclock_counter_10ms -= 10;\n\t\tclock_flag |= CLOCK_FLAG_10MS;\n\t\t\n\t\tclock_counter_250ms += 1;\n\t\tif (clock_counter_250ms >= 25) {\n\t\t\tclock_counter_250ms -= 25;\n\t\t\tclock_flag |= CLOCK_FLAG_250MS;\n\t\t\t\n\t\t\tclock_counter_1s += 1;\n\t\t\tif (clock_counter_1s >= 4) {\n\t\t\t\tclock_counter_1s -= 4;\n\t\t\t\tclock_flag |= CLOCK_FLAG_1S;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "timer.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/****************************************************************************\n*                                                                           *\n* Character Received - add it to our command                                *\n*                                                                           *\n****************************************************************************/\n", "func_signal": "void gcode_parse_char(uint8_t c)", "code": "{\n\t#ifdef ASTERISK_IN_CHECKSUM_INCLUDED\n\tif (next_target.seen_checksum == 0)\n\t\tnext_target.checksum_calculated = crc(next_target.checksum_calculated, c);\n\t#endif\n\n\t// uppercase\n\tif (c >= 'a' && c <= 'z')\n\t\tc &= ~32;\n\n\t// process previous field\n\tif (last_field) {\n\t\t// check if we're seeing a new field or end of line\n\t\t// any character will start a new field, even invalid/unknown ones\n\t\tif ((c >= 'A' && c <= 'Z') || c == '*' || (c == 10) || (c == 13)) {\n\t\t\tswitch (last_field) {\n\t\t\t\tcase 'G':\n\t\t\t\t\tnext_target.G = read_digit.mantissa;\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint8(next_target.G);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tnext_target.M = read_digit.mantissa;\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint8(next_target.M);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'X':\n\t\t\t\t\tif (next_target.option_inches)\n\t\t\t\t\t\tnext_target.target.X = decfloat_to_int(&read_digit, STEPS_PER_IN_X, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.target.X = decfloat_to_int(&read_digit, STEPS_PER_M_X, 1000);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_int32(next_target.target.X);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\t\tif (next_target.option_inches)\n\t\t\t\t\t\tnext_target.target.Y = decfloat_to_int(&read_digit, STEPS_PER_IN_Y, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.target.Y = decfloat_to_int(&read_digit, STEPS_PER_M_Y, 1000);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_int32(next_target.target.Y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Z':\n\t\t\t\t\tif (next_target.option_inches)\n\t\t\t\t\t\tnext_target.target.Z = decfloat_to_int(&read_digit, STEPS_PER_IN_Z, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.target.Z = decfloat_to_int(&read_digit, STEPS_PER_M_Z, 1000);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_int32(next_target.target.Z);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tif (next_target.option_inches)\n\t\t\t\t\t\tnext_target.target.E = decfloat_to_int(&read_digit, STEPS_PER_IN_E, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.target.E = decfloat_to_int(&read_digit, STEPS_PER_M_E, 1000);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint32(next_target.target.E);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\t// just use raw integer, we need move distance and n_steps to convert it to a useful value, so wait until we have those to convert it\n\t\t\t\t\tif (next_target.option_inches)\n\t\t\t\t\t\tnext_target.target.F = decfloat_to_int(&read_digit, 254, 10);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.target.F = decfloat_to_int(&read_digit, 1, 1);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint32(next_target.target.F);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\t// if this is temperature, multiply by 4 to convert to quarter-degree units\n\t\t\t\t\t// cosmetically this should be done in the temperature section,\n\t\t\t\t\t// but it takes less code, less memory and loses no precision if we do it here instead\n\t\t\t\t\tif ((next_target.M == 104) || (next_target.M == 109) || (next_target.M == 140))\n\t\t\t\t\t\tnext_target.S = decfloat_to_int(&read_digit, 4, 1);\n\t\t\t\t\t// if this is heater PID stuff, multiply by PID_SCALE because we divide by PID_SCALE later on\n\t\t\t\t\telse if ((next_target.M >= 130) && (next_target.M <= 132))\n\t\t\t\t\t\tnext_target.S = decfloat_to_int(&read_digit, PID_SCALE, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_target.S = decfloat_to_int(&read_digit, 1, 1);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint16(next_target.S);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tnext_target.P = decfloat_to_int(&read_digit, 1, 1);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint16(next_target.P);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tnext_target.T = read_digit.mantissa;\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint8(next_target.T);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tnext_target.N = decfloat_to_int(&read_digit, 1, 1);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint32(next_target.N);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tnext_target.checksum_read = decfloat_to_int(&read_digit, 1, 1);\n\t\t\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\t\t\tserwrite_uint8(next_target.checksum_read);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// reset for next field\n\t\t\tlast_field = 0;\n\t\t\tread_digit.sign = read_digit.mantissa = read_digit.exponent = 0;\n\t\t}\n\t}\n\n\t// skip comments\n\tif (next_target.seen_semi_comment == 0 && next_target.seen_parens_comment == 0) {\n\t\t// new field?\n\t\tif ((c >= 'A' && c <= 'Z') || c == '*') {\n\t\t\tlast_field = c;\n\t\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\t\tserial_writechar(c);\n\t\t}\n\n\t\t// process character\n\t\tswitch (c) {\n\t\t\t// each currently known command is either G or M, so preserve previous G/M unless a new one has appeared\n\t\t\t// FIXME: same for T command\n\t\t\tcase 'G':\n\t\t\t\tnext_target.seen_G = 1;\n\t\t\t\tnext_target.seen_M = 0;\n\t\t\t\tnext_target.M = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tnext_target.seen_M = 1;\n\t\t\t\tnext_target.seen_G = 0;\n\t\t\t\tnext_target.G = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tnext_target.seen_X = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\tnext_target.seen_Y = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'Z':\n\t\t\t\tnext_target.seen_Z = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tnext_target.seen_E = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tnext_target.seen_F = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tnext_target.seen_S = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tnext_target.seen_P = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tnext_target.seen_T = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tnext_target.seen_N = 1;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tnext_target.seen_checksum = 1;\n\t\t\t\tbreak;\n\n\t\t\t// comments\n\t\t\tcase ';':\n\t\t\t\tnext_target.seen_semi_comment = 1;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tnext_target.seen_parens_comment = 1;\n\t\t\t\tbreak;\n\n\t\t\t// now for some numeracy\n\t\t\tcase '-':\n\t\t\t\tread_digit.sign = 1;\n\t\t\t\t// force sign to be at start of number, so 1-2 = -2 instead of -12\n\t\t\t\tread_digit.exponent = 0;\n\t\t\t\tread_digit.mantissa = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (read_digit.exponent == 0)\n\t\t\t\t\tread_digit.exponent = 1;\n\t\t\t\tbreak;\n\t\t\t#ifdef\tDEBUG\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase 10:\n\t\t\tcase 13:\n\t\t\t\t// ignore\n\t\t\t\tbreak;\n\t\t\t#endif\n\n\t\t\tdefault:\n\t\t\t\t// can't do ranges in switch..case, so process actual digits here.\n\t\t\t\tif (c >= '0' && c <= '9' &&\n\t\t\t\t    read_digit.exponent < DECFLOAT_EXP_MAX &&\n\t\t\t\t    ((next_target.option_inches == 0 &&\n\t\t\t\t      read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||\n\t\t\t\t     (next_target.option_inches &&\n\t\t\t\t      read_digit.mantissa < DECFLOAT_MANT_IN_MAX))){\n\t\t\t\t\t// this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes\n\t\t\t\t\tread_digit.mantissa = (read_digit.mantissa << 3) + (read_digit.mantissa << 1) + (c - '0');\n\t\t\t\t\tif (read_digit.exponent)\n\t\t\t\t\t\tread_digit.exponent++;\n\t\t\t\t}\n\t\t\t\t#ifdef\tDEBUG\n\t\t\t\telse {\n\t\t\t\t\t// invalid\n\t\t\t\t\tserial_writechar('?');\n\t\t\t\t\tserial_writechar(c);\n\t\t\t\t\tserial_writechar('?');\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t}\n\t} else if ( next_target.seen_parens_comment == 1 && c == ')')\n\t\tnext_target.seen_parens_comment = 0; // recognize stuff after a (comment)\n\n\n\t#ifndef ASTERISK_IN_CHECKSUM_INCLUDED\n\tif (next_target.seen_checksum == 0)\n\t\tnext_target.checksum_calculated = crc(next_target.checksum_calculated, c);\n\t#endif\n\n\t// end of line\n\tif ((c == 10) || (c == 13)) {\n\t\tif (debug_flags & DEBUG_ECHO)\n\t\t\tserial_writechar(c);\n\n\t\tif (\n\t\t#ifdef\tREQUIRE_LINENUMBER\n\t\t\t(next_target.N >= next_target.N_expected) && (next_target.seen_N == 1)\n\t\t#else\n\t\t\t1\n\t\t#endif\n\t\t\t) {\n\t\t\tif (\n\t\t\t\t#ifdef\tREQUIRE_CHECKSUM\n\t\t\t\t((next_target.checksum_calculated == next_target.checksum_read) && (next_target.seen_checksum == 1))\n\t\t\t\t#else\n\t\t\t\t((next_target.checksum_calculated == next_target.checksum_read) || (next_target.seen_checksum == 0))\n\t\t\t\t#endif\n\t\t\t\t) {\n\t\t\t\t// process\n\t\t\t\tserial_writestr_P(PSTR(\"ok \"));\n\t\t\t\tprocess_gcode_command();\n\t\t\t\tserial_writestr_P(PSTR(\"\\n\"));\n\n\t\t\t\t// expect next line number\n\t\t\t\tif (next_target.seen_N == 1)\n\t\t\t\t\tnext_target.N_expected = next_target.N + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsersendf_P(PSTR(\"rs N%ld Expected checksum %d\\n\"), next_target.N_expected, next_target.checksum_calculated);\n\t\t\t\trequest_resend();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsersendf_P(PSTR(\"rs N%ld Expected line number %ld\\n\"), next_target.N_expected, next_target.N_expected);\n\t\t\trequest_resend();\n\t\t}\n\n\t\t// reset variables\n\t\tnext_target.seen_X = next_target.seen_Y = next_target.seen_Z = \\\n\t\t\tnext_target.seen_E = next_target.seen_F = next_target.seen_S = \\\n\t\t\tnext_target.seen_P = next_target.seen_T = next_target.seen_N = \\\n\t\t\tnext_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \\\n\t\t\tnext_target.seen_parens_comment = next_target.checksum_read = \\\n\t\t\tnext_target.checksum_calculated = 0;\n\t\tlast_field = 0;\n\t\tread_digit.sign = read_digit.mantissa = read_digit.exponent = 0;\n\n\t\t// assume a G1 by default\n\t\tnext_target.seen_G = 1;\n\t\tnext_target.G = 1;\n\n\t\tif (next_target.option_relative) {\n\t\t\tnext_target.target.X = next_target.target.Y = next_target.target.Z = 0;\n\t\t}\n\t\t// E always relative\n\t\tnext_target.target.E = 0;\n\t}\n}", "path": "gcode_parse.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// courtesy of http://www.oroboro.com/rafael/docserv.php/index/programming/article/distance\n", "func_signal": "uint32_t approx_distance_3( uint32_t dx, uint32_t dy, uint32_t dz )", "code": "{\n\tuint32_t min, med, max, approx;\n\n\tif ( dx < dy )\n\t{\n\t\tmin = dy;\n\t\tmed = dx;\n\t} else {\n\t\tmin = dx;\n\t\tmed = dy;\n\t}\n\n\tif ( dz < min )\n\t{\n\t\tmax = med;\n\t\tmed = min;\n\t\tmin = dz;\n\t} else if ( dz < med ) {\n\t\tmax = med;\n\t\tmed = dz;\n\t} else {\n\t\tmax = dz;\n\t}\n\n\tapprox = ( max * 860 ) + ( med * 851 ) + ( min * 520 );\n\tif ( max < ( med << 1 )) approx -= ( max * 294 );\n\tif ( max < ( min << 2 )) approx -= ( max * 113 );\n\tif ( med < ( min << 2 )) approx -= ( med *  40 );\n\n\t// add 512 for proper rounding\n\treturn (( approx + 512 ) >> 10 );\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// delay( microseconds )\n", "func_signal": "void delay(uint32_t delay)", "code": "{\n\twd_reset();\n\twhile (delay > 65535) {\n\t\tdelayMicrosecondsInterruptible(65533);\n\t\tdelay -= 65535;\n\t\twd_reset();\n\t}\n\tdelayMicrosecondsInterruptible(delay & 0xFFFF);\n\twd_reset();\n}", "path": "extruder\\delay.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\n\tCREATE a dda given current_position and a target, save to passed location so we can write directly into the queue\n*/\n", "func_signal": "void dda_create(DDA *dda, TARGET *target)", "code": "{\n\tuint32_t\tdistance, c_limit, c_limit_calc;\n\n\t// initialise DDA to a known state\n\tdda->allflags = 0;\n\n\tif (debug_flags & DEBUG_DDA)\n\t\tserial_writestr_P(PSTR(\"\\n{DDA_CREATE: [\"));\n\n\t// we end at the passed target\n\tmemcpy(&(dda->endpoint), target, sizeof(TARGET));\n\n\tdda->x_delta = labs(target->X - startpoint.X);\n\tdda->y_delta = labs(target->Y - startpoint.Y);\n\tdda->z_delta = labs(target->Z - startpoint.Z);\n\tdda->e_delta = labs(target->E - startpoint.E);\n\n\tdda->x_direction = (target->X >= startpoint.X)?1:0;\n\tdda->y_direction = (target->Y >= startpoint.Y)?1:0;\n\tdda->z_direction = (target->Z >= startpoint.Z)?1:0;\n\tdda->e_direction = (target->E >= startpoint.E)?1:0;\n\n\tif (debug_flags & DEBUG_DDA)\n\t\tsersendf_P(PSTR(\"%ld,%ld,%ld,%ld] [\"), target->X - startpoint.X, target->Y - startpoint.Y, target->Z - startpoint.Z, target->E - startpoint.E);\n\n\tdda->total_steps = dda->x_delta;\n\tif (dda->y_delta > dda->total_steps)\n\t\tdda->total_steps = dda->y_delta;\n\tif (dda->z_delta > dda->total_steps)\n\t\tdda->total_steps = dda->z_delta;\n\tif (dda->e_delta > dda->total_steps)\n\t\tdda->total_steps = dda->e_delta;\n\n\tif (debug_flags & DEBUG_DDA)\n\t\tsersendf_P(PSTR(\"ts:%lu\"), dda->total_steps);\n\n\tif (dda->total_steps == 0) {\n\t\tdda->nullmove = 1;\n\t}\n\telse {\n\t\t// get steppers ready to go\n\t\tsteptimeout = 0;\n\t\tpower_on();\n\t\tx_enable();\n\t\ty_enable();\n\t\tif (dda->z_delta)\n\t\t\tz_enable();\n\n\t\t// since it's unusual to combine X, Y and Z changes in a single move on reprap, check if we can use simpler approximations before trying the full 3d approximation.\n\t\tif (dda->z_delta == 0)\n\t\t\tdistance = approx_distance(dda->x_delta * UM_PER_STEP_X, dda->y_delta * UM_PER_STEP_Y);\n\t\telse if (dda->x_delta == 0 && dda->y_delta == 0)\n\t\t\tdistance = dda->z_delta * UM_PER_STEP_Z;\n\t\telse\n\t\t\tdistance = approx_distance_3(dda->x_delta * UM_PER_STEP_X, dda->y_delta * UM_PER_STEP_Y, dda->z_delta * UM_PER_STEP_Z);\n\t\t\n\t\tif (distance < 2)\n\t\t\tdistance = dda->e_delta * UM_PER_STEP_E;\n\t\t\n\t\tif (debug_flags & DEBUG_DDA)\n\t\t\tsersendf_P(PSTR(\",ds:%lu\"), distance);\n\t\t\n\t\t#ifdef\tACCELERATION_TEMPORAL\n\t\t\t// bracket part of this equation in an attempt to avoid overflow: 60 * 16MHz * 5mm is >32 bits\n\t\t\tuint32_t move_duration = distance * (60 * F_CPU / startpoint.F);\n\t\t#else\n\t\t\tdda->x_counter = dda->y_counter = dda->z_counter = dda->e_counter =\n\t\t\t\t-(dda->total_steps >> 1);\n\n\t\t\t// pre-calculate move speed in millimeter microseconds per step minute for less math in interrupt context\n\t\t\t// mm (distance) * 60000000 us/min / step (total_steps) = mm.us per step.min\n\t\t\t//   note: um (distance) * 60000 == mm * 60000000\n\t\t\t// so in the interrupt we must simply calculate\n\t\t\t// mm.us per step.min / mm per min (F) = us per step\n\n\t\t\t// break this calculation up a bit and lose some precision because 300,000um * 60000 is too big for a uint32\n\t\t\t// calculate this with a uint64 if you need the precision, but it'll take longer so routines with lots of short moves may suffer\n\t\t\t// 2^32/6000 is about 715mm which should be plenty\n\n\t\t\t// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.\n\t\t\t// timer.c setTimer() routine altered for same reason\n\n\t\t\t// changed distance * 6000 .. * F_CPU / 100000 to\n\t\t\t//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing\n\t\t\tuint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);\n\t\t#endif\n\t\t\n\t\t// similarly, find out how fast we can run our axes.\n\t\t// do this for each axis individually, as the combined speed of two or more axes can be higher than the capabilities of a single one.\n\t\tc_limit = 0;\n\t\t// check X axis\n\t\tc_limit_calc = ( (dda->x_delta * (UM_PER_STEP_X * 2400L)) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_X) << 8;\n\t\tif (c_limit_calc > c_limit)\n\t\t\tc_limit = c_limit_calc;\n\t\t// check Y axis\n\t\tc_limit_calc = ( (dda->y_delta * (UM_PER_STEP_Y * 2400L)) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Y) << 8;\n\t\tif (c_limit_calc > c_limit)\n\t\t\tc_limit = c_limit_calc;\n\t\t// check Z axis\n\t\tc_limit_calc = ( (dda->z_delta * (UM_PER_STEP_Z * 2400L)) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Z) << 8;\n\t\tif (c_limit_calc > c_limit)\n\t\t\tc_limit = c_limit_calc;\n\t\t// check E axis\n\t\tc_limit_calc = ( (dda->e_delta * (UM_PER_STEP_E * 2400L)) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_E) << 8;\n\t\tif (c_limit_calc > c_limit)\n\t\t\tc_limit = c_limit_calc;\n\n\t\t#ifdef ACCELERATION_REPRAP\n\t\t// c is initial step time in IOclk ticks\n\t\tdda->c = (move_duration / startpoint.F) << 8;\n\t\tif (dda->c < c_limit)\n\t\t\tdda->c = c_limit;\n\t\tdda->end_c = (move_duration / target->F) << 8;\n\t\tif (dda->end_c < c_limit)\n\t\t\tdda->end_c = c_limit;\n\n\t\tif (debug_flags & DEBUG_DDA)\n\t\t\tsersendf_P(PSTR(\",md:%lu,c:%lu\"), move_duration, dda->c >> 8);\n\n\t\tif (dda->c != dda->end_c) {\n\t\t\tuint32_t stF = startpoint.F / 4;\n\t\t\tuint32_t enF = target->F / 4;\n\t\t\t// now some constant acceleration stuff, courtesy of http://www.embedded.com/columns/technicalinsights/56800129?printable=true\n\t\t\tuint32_t ssq = (stF * stF);\n\t\t\tuint32_t esq = (enF * enF);\n\t\t\tint32_t dsq = (int32_t) (esq - ssq) / 4;\n\n\t\t\tuint8_t msb_ssq = msbloc(ssq);\n\t\t\tuint8_t msb_tot = msbloc(dda->total_steps);\n\n\t\t\t// the raw equation WILL overflow at high step rates, but 64 bit math routines take waay too much space\n\t\t\t// at 65536 mm/min (1092mm/s), ssq/esq overflows, and dsq is also close to overflowing if esq/ssq is small\n\t\t\t// but if ssq-esq is small, ssq/dsq is only a few bits\n\t\t\t// we'll have to do it a few different ways depending on the msb locations of each\n\t\t\tif ((msb_tot + msb_ssq) <= 30) {\n\t\t\t\t// we have room to do all the multiplies first\n\t\t\t\tif (debug_flags & DEBUG_DDA)\n\t\t\t\t\tserial_writechar('A');\n\t\t\t\tdda->n = ((int32_t) (dda->total_steps * ssq) / dsq) + 1;\n\t\t\t}\n\t\t\telse if (msb_tot >= msb_ssq) {\n\t\t\t\t// total steps has more precision\n\t\t\t\tif (debug_flags & DEBUG_DDA)\n\t\t\t\t\tserial_writechar('B');\n\t\t\t\tdda->n = (((int32_t) dda->total_steps / dsq) * (int32_t) ssq) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// otherwise\n\t\t\t\tif (debug_flags & DEBUG_DDA)\n\t\t\t\t\tserial_writechar('C');\n\t\t\t\tdda->n = (((int32_t) ssq / dsq) * (int32_t) dda->total_steps) + 1;\n\t\t\t}\n\n\t\t\tif (debug_flags & DEBUG_DDA)\n\t\t\t\tsersendf_P(PSTR(\"\\n{DDA:CA end_c:%lu, n:%ld, md:%lu, ssq:%lu, esq:%lu, dsq:%lu, msbssq:%u, msbtot:%u}\\n\"), dda->end_c >> 8, dda->n, move_duration, ssq, esq, dsq, msb_ssq, msb_tot);\n\n\t\t\tdda->accel = 1;\n\t\t}\n\t\telse\n\t\t\tdda->accel = 0;\n\t\t#elif defined ACCELERATION_RAMPING\n\t\t// add the last bit of dda->total_steps to always round up\n\t\t\tdda->ramp_steps = dda->total_steps / 2 + (dda->total_steps & 1);\n\t\t\tdda->step_no = 0;\n\t\t\t// c is initial step time in IOclk ticks\n\t\t\tdda->c = ACCELERATION_STEEPNESS << 8;\n\t\t\tdda->c_min = (move_duration / target->F) << 8;\n\t\t\tif (dda->c_min < c_limit)\n\t\t\t\tdda->c_min = c_limit;\n\t\t\tdda->n = 1;\n\t\t\tdda->ramp_state = RAMP_UP;\n\t\t#elif defined ACCELERATION_TEMPORAL\n\t\t\tdda->x_counter = dda->x_step_interval = move_duration / dda->x_delta;\n\t\t\tdda->y_counter = dda->y_step_interval = move_duration / dda->y_delta;\n\t\t\tdda->z_counter = dda->z_step_interval = move_duration / dda->z_delta;\n\t\t\tdda->e_counter = dda->e_step_interval = move_duration / dda->e_delta;\n\n\t\t\tdda->c = dda->x_step_interval;\n\t\t\tif (dda->y_step_interval < dda->c)\n\t\t\t\tdda->c = dda->y_step_interval;\n\t\t\tif (dda->z_step_interval < dda->c)\n\t\t\t\tdda->c = dda->z_step_interval;\n\t\t\tif (dda->e_step_interval < dda->c)\n\t\t\t\tdda->c = dda->e_step_interval;\n\n\t\t\tdda->c <<= 8;\n\t\t#else\n\t\t\tdda->c = (move_duration / target->F) << 8;\n\t\t\tif (dda->c < c_limit)\n\t\t\t\tdda->c = c_limit;\n\t\t#endif\n\t}\n\n\tif (debug_flags & DEBUG_DDA)\n\t\tserial_writestr_P(PSTR(\"] }\\n\"));\n\n\t// next dda starts where we finish\n\tmemcpy(&startpoint, target, sizeof(TARGET));\n\t// E is always relative, reset it here\n\tstartpoint.E = 0;\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\n\tWrite from FLASH\n\n\tExtensions to output flash memory pointers. This prevents the data to\n\tbecome part of the .data segment instead of the .code segment. That means\n\tless memory is consumed for multi-character writes.\n\n\tFor single character writes (i.e. '\\n' instead of \"\\n\"), using\n\tserial_writechar() directly is the better choice.\n*/\n", "func_signal": "void serial_writeblock_P(PGM_P data, int datalen)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < datalen; i++)\n\t\tserial_writechar(pgm_read_byte(&data[i]));\n}", "path": "serial.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\n\tSTEP\n*/\n", "func_signal": "void dda_step(DDA *dda)", "code": "{\n\t// called from interrupt context! keep it as simple as possible\n\tuint8_t\tdid_step = 0;\n\n\t#ifdef ACCELERATION_TEMPORAL\n\t\tif (dda->x_counter <= 0) {\n\t\t\tif ((current_position.X != dda->endpoint.X) /* &&\n\t\t\t\t(x_max() != dda->x_direction) && (x_min() == dda->x_direction) */) {\n\t\t\t\tx_step();\n\t\t\tif (dda->x_direction)\n\t\t\t\tcurrent_position.X++;\n\t\t\telse\n\t\t\t\tcurrent_position.X--;\n\t\t\t}\n\t\t\tdda->x_counter += dda->x_step_interval;\n\t\t\tdda->x_delta--;\n\t\t}\n\t\tif (dda->y_counter <= 0) {\n\t\t\tif ((current_position.Y != dda->endpoint.Y) /* &&\n\t\t\t\t(y_max() != dda->y_direction) && (y_min() == dda->y_direction) */) {\n\t\t\t\ty_step();\n\t\t\tif (dda->y_direction)\n\t\t\t\tcurrent_position.Y++;\n\t\t\telse\n\t\t\t\tcurrent_position.Y--;\n\t\t\t}\n\t\t\tdda->y_counter += dda->y_step_interval;\n\t\t\tdda->y_delta--;\n\t\t}\n\t\tif (dda->z_counter <= 0) {\n\t\t\tif ((current_position.Z != dda->endpoint.Z) /* &&\n\t\t\t\t(z_max() != dda->z_direction) && (z_min() == dda->z_direction) */) {\n\t\t\t\tz_step();\n\t\t\tif (dda->z_direction)\n\t\t\t\tcurrent_position.Z++;\n\t\t\telse\n\t\t\t\tcurrent_position.Z--;\n\t\t\t}\n\t\t\tdda->z_counter += dda->z_step_interval;\n\t\t\tdda->z_delta--;\n\t\t}\n\t\tif (dda->e_counter <= 0) {\n\t\t\tif ((current_position.E != dda->endpoint.E) /* &&\n\t\t\t\t(e_max() != dda->e_direction) && (e_min() == dda->e_direction) */) {\n\t\t\t\te_step();\n\t\t\tif (dda->e_direction)\n\t\t\t\tcurrent_position.E++;\n\t\t\telse\n\t\t\t\tcurrent_position.E--;\n\t\t\t}\n\t\t\tdda->e_counter += dda->e_step_interval;\n\t\t\tdda->e_delta--;\n\t\t}\n\t#else\n\t\tif ((current_position.X != dda->endpoint.X) /* &&\n\t\t\t\t(x_max() != dda->x_direction) && (x_min() == dda->x_direction) */) {\n\t\t\tdda->x_counter -= dda->x_delta;\n\t\t\tif (dda->x_counter < 0) {\n\t\t\t\tx_step();\n\t\t\t\tdid_step = 1;\n\t\t\t\tif (dda->x_direction)\n\t\t\t\t\tcurrent_position.X++;\n\t\t\t\telse\n\t\t\t\t\tcurrent_position.X--;\n\n\t\t\t\tdda->x_counter += dda->total_steps;\n\t\t\t}\n\t\t}\n\n\t\tif ((current_position.Y != dda->endpoint.Y) /* &&\n\t\t\t\t(y_max() != dda->y_direction) && (y_min() == dda->y_direction) */) {\n\t\t\tdda->y_counter -= dda->y_delta;\n\t\t\tif (dda->y_counter < 0) {\n\t\t\t\ty_step();\n\t\t\t\tdid_step = 1;\n\t\t\t\tif (dda->y_direction)\n\t\t\t\t\tcurrent_position.Y++;\n\t\t\t\telse\n\t\t\t\t\tcurrent_position.Y--;\n\n\t\t\t\tdda->y_counter += dda->total_steps;\n\t\t\t}\n\t\t}\n\n\t\tif ((current_position.Z != dda->endpoint.Z) /* &&\n\t\t\t\t(z_max() != dda->z_direction) && (z_min() == dda->z_direction) */) {\n\t\t\tdda->z_counter -= dda->z_delta;\n\t\t\tif (dda->z_counter < 0) {\n\t\t\t\tz_step();\n\t\t\t\tdid_step = 1;\n\t\t\t\tif (dda->z_direction)\n\t\t\t\t\tcurrent_position.Z++;\n\t\t\t\telse\n\t\t\t\t\tcurrent_position.Z--;\n\n\t\t\t\tdda->z_counter += dda->total_steps;\n\t\t\t}\n\t\t}\n\n\t\tif (current_position.E != dda->endpoint.E) {\n\t\t\tdda->e_counter -= dda->e_delta;\n\t\t\tif (dda->e_counter < 0) {\n\t\t\t\te_step();\n\t\t\t\tdid_step = 1;\n\t\t\t\tif (dda->e_direction)\n\t\t\t\t\tcurrent_position.E++;\n\t\t\t\telse\n\t\t\t\t\tcurrent_position.E--;\n\n\t\t\t\tdda->e_counter += dda->total_steps;\n\t\t\t}\n\t\t}\n\t#endif\n\n\t#if STEP_INTERRUPT_INTERRUPTIBLE\n\t\t// since we have sent steps to all the motors that will be stepping and the rest of this function isn't so time critical,\n\t\t// this interrupt can now be interruptible\n\t\t// however we must ensure that we don't step again while computing the below, so disable *this* interrupt but allow others to fire\n// \t\tdisableTimerInterrupt();\n\t\tsei();\n\t#endif\n\n\t#ifdef ACCELERATION_REPRAP\n\t\t// linear acceleration magic, courtesy of http://www.embedded.com/columns/technicalinsights/56800129?printable=true\n\t\tif (dda->accel) {\n\t\t\tif (\n\t\t\t\t\t((dda->n > 0) && (dda->c > dda->end_c)) ||\n\t\t\t\t\t((dda->n < 0) && (dda->c < dda->end_c))\n\t\t\t\t) {\n\t\t\t\tdda->c = (int32_t) dda->c - ((int32_t) (dda->c * 2) / dda->n);\n\t\t\t\tdda->n += 4;\n\t\t\t}\n\t\t\telse if (dda->c != dda->end_c) {\n\t\t\t\tdda->c = dda->end_c;\n\t\t\t}\n\t\t\t// else we are already at target speed\n\t\t}\n\t#endif\n\t#ifdef ACCELERATION_RAMPING\n\t\t// - algorithm courtesy of http://www.embedded.com/columns/technicalinsights/56800129?printable=true\n\t\t// - for simplicity, taking even/uneven number of steps into account dropped\n\t\t// - number of steps moved is always accurate, speed might be one step off\n\t\tswitch (dda->ramp_state) {\n\t\t\tcase RAMP_UP:\n\t\t\tcase RAMP_MAX:\n\t\t\t\tif (dda->step_no >= dda->ramp_steps) {\n\t\t\t\t\t// RAMP_UP: time to decelerate before reaching maximum speed\n\t\t\t\t\t// RAMP_MAX: time to decelerate\n\t\t\t\t\tdda->ramp_state = RAMP_DOWN;\n\t\t\t\t\tdda->n = -((int32_t)2) - dda->n;\n\t\t\t\t}\n\t\t\t\tif (dda->ramp_state == RAMP_MAX)\n\t\t\t\t\tbreak;\n\t\t\tcase RAMP_DOWN:\n\t\t\t\tdda->n += 4;\n\t\t\t\t// be careful of signedness!\n\t\t\t\tdda->c = (int32_t)dda->c - ((int32_t)(dda->c * 2) / dda->n);\n\t\t\t\tif (dda->c <= dda->c_min) {\n\t\t\t\t\t// maximum speed reached\n\t\t\t\t\tdda->c = dda->c_min;\n\t\t\t\t\tdda->ramp_state = RAMP_MAX;\n\t\t\t\t\tdda->ramp_steps = dda->total_steps - dda->step_no;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tdda->step_no++;\n\t#endif\n\t#ifdef ACCELERATION_TEMPORAL\n\t\tdda->c = dda->x_counter;\n\t\tif (dda->y_counter < dda->c)\n\t\t\tdda->c = dda->y_counter;\n\t\tif (dda->z_counter < dda->c)\n\t\t\tdda->c = dda->z_counter;\n\t\tif (dda->e_counter < dda->c)\n\t\t\tdda->c = dda->e_counter;\n\n\t\tif (dda->x_delta)\n\t\t\tdda->x_counter -= dda->c;\n\t\tif (dda->y_delta)\n\t\t\tdda->y_counter -= dda->c;\n\t\tif (dda->z_delta)\n\t\t\tdda->z_counter -= dda->c;\n\t\tif (dda->e_delta)\n\t\t\tdda->e_counter -= dda->c;\n\t\tif (\n\t\t\t(dda->x_delta > 0) ||\n\t\t\t(dda->y_delta > 0) ||\n\t\t\t(dda->z_delta > 0) ||\n\t\t\t(dda->e_delta > 0))\n\t\t\tdid_step = 1;\n\n\t\tdda->c <<= 8;\n\t#endif\n\t\n\tif (did_step) {\n\t\t// we stepped, reset timeout\n\t\tsteptimeout = 0;\n\n\t\t// if we could do anything at all, we're still running\n\t\t// otherwise, must have finished\n\t}\n\telse {\n\t\tdda->live = 0;\n\t\t// reset E- always relative\n\t\tcurrent_position.E = 0;\n\t\t// linear acceleration code doesn't alter F during a move, so we must update it here\n\t\t// in theory, we *could* update F every step, but that would require a divide in interrupt context which should be avoided if at all possible\n\t\tcurrent_position.F = dda->endpoint.F;\n\t\t#ifdef\tDC_EXTRUDER\n\t\t\theater_set(DC_EXTRUDER, 0);\n\t\t#endif\n\t}\n\t\n\tsetTimer(dda->c >> 8);\n\t\n\t// turn off step outputs, hopefully they've been on long enough by now to register with the drivers\n\t// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.\n\t// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.\n\tunstep();\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// this is an ultra-crude pseudo-logarithm routine, such that:\n// 2 ^ msbloc(v) >= v\n", "func_signal": "const uint8_t\tmsbloc (uint32_t v)", "code": "{\n\tuint8_t i;\n\tuint32_t c;\n\tfor (i = 31, c = 0x80000000; i; i--) {\n\t\tif (v & c)\n\t\t\treturn i;\n\t\tc >>= 1;\n\t}\n\treturn 0;\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// sometimes called from normal program execution, sometimes from interrupt context\n", "func_signal": "void next_move()", "code": "{\n\tif (queue_empty() == 0) {\n\t\t// next item\n\t\tuint8_t t = mb_tail + 1;\n\t\tt &= (MOVEBUFFER_SIZE - 1);\n\t\tif (movebuffer[t].waitfor_temp) {\n\t\t\t#ifndef\tREPRAP_HOST_COMPATIBILITY\n\t\t\t\tserial_writestr_P(PSTR(\"Waiting for target temp\\n\"));\n\t\t\t#endif\n\t\t\tmovebuffer[t].live = 1;\n\t\t\tsetTimer(movebuffer[t].c >> 8);\n\t\t}\n\t\telse {\n\t\t\tdda_start(&movebuffer[t]);\n\t\t}\n\t\tmb_tail = t;\n\t}\n\telse\n\t\tsetTimer(0);\n}", "path": "dda_queue.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// -------------------------------------------------------\n// This is the one function called by the timer interrupt.\n// It calls a few other functions, though.\n// -------------------------------------------------------\n", "func_signal": "void queue_step()", "code": "{\n\t// do our next step\n\tif (movebuffer[mb_tail].live) {\n\t\tif (movebuffer[mb_tail].waitfor_temp) {\n\t\t\tsetTimer(movebuffer[mb_tail].c >> 8);\n\t\t\tif (temp_achieved()) {\n\t\t\t\tmovebuffer[mb_tail].live = movebuffer[mb_tail].waitfor_temp = 0;\n\t\t\t\tserial_writestr_P(PSTR(\"Temp achieved\\n\"));\n\t\t\t}\n\n\t\t\t#if STEP_INTERRUPT_INTERRUPTIBLE\n\t\t\t\tsei();\n\t\t\t#endif\n\t\t}\n\t\telse {\n\t\t\t// NOTE: dda_step makes this interrupt interruptible after steps have been sent but before new speed is calculated.\n\t\t\tdda_step(&(movebuffer[mb_tail]));\n\t\t}\n\t}\n\n\t// fall directly into dda_start instead of waiting for another step\n\t// the dda dies not directly after its last step, but when the timer fires and there's no steps to do\n\tif (movebuffer[mb_tail].live == 0)\n\t\tnext_move();\n}", "path": "dda_queue.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\npublic functions\n*/\n", "func_signal": "void zero_x(void)", "code": "{\n\tTARGET t = startpoint;\n\tt.X = 0;\n\tt.F = SEARCH_FEEDRATE_X;\n\tenqueue(&t);\n}", "path": "gcode_process.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// delay_ms( milliseconds )\n", "func_signal": "void delay_ms(uint32_t delay)", "code": "{\n\twd_reset();\n\twhile (delay > 65) {\n\t\tdelayMicrosecondsInterruptible(64999);\n\t\tdelay -= 65;\n\t\twd_reset();\n\t}\n\tdelayMicrosecondsInterruptible(delay * 1000);\n\twd_reset();\n}", "path": "extruder\\delay.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// courtesy of http://www.flipcode.com/archives/Fast_Approximate_Distance_Functions.shtml\n", "func_signal": "uint32_t approx_distance( uint32_t dx, uint32_t dy )", "code": "{\n\tuint32_t min, max, approx;\n\n\tif ( dx < dy )\n\t{\n\t\tmin = dx;\n\t\tmax = dy;\n\t} else {\n\t\tmin = dy;\n\t\tmax = dx;\n\t}\n\n\tapprox = ( max * 1007 ) + ( min * 441 );\n\tif ( max < ( min << 4 ))\n\t\tapprox -= ( max * 40 );\n\n\t// add 512 for proper rounding\n\treturn (( approx + 512 ) >> 10 );\n}", "path": "dda.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/***************************************************************************\\\n*                                                                           *\n* Request a resend of the current line - used from various places.          *\n*                                                                           *\n* Relies on the global variable next_target.N being valid.                  *\n*                                                                           *\n\\***************************************************************************/\n", "func_signal": "void request_resend(void)", "code": "{\n\tserial_writestr_P(PSTR(\"rs \"));\n\tserwrite_uint8(next_target.N);\n\tserial_writechar('\\n');\n}", "path": "gcode_parse.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// delay_ms( milliseconds )\n", "func_signal": "void delay_ms(uint32_t delay)", "code": "{\n\twd_reset();\n\twhile (delay > 65) {\n\t\tdelayMicrosecondsInterruptible(64999);\n\t\tdelay -= 65;\n\t\twd_reset();\n\t}\n\tdelayMicrosecondsInterruptible(delay * 1000);\n\twd_reset();\n}", "path": "delay.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// delay( microseconds )\n", "func_signal": "void delay(uint32_t delay)", "code": "{\n\twd_reset();\n\twhile (delay > 65535) {\n\t\tdelayMicrosecondsInterruptible(65533);\n\t\tdelay -= 65535;\n\t\twd_reset();\n\t}\n\tdelayMicrosecondsInterruptible(delay & 0xFFFF);\n\twd_reset();\n}", "path": "delay.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "// comparator A is the step timer. It has higher priority then B.\n", "func_signal": "ISR(TIMER1_COMPA_vect)", "code": "{\n\t// Check if this is a real step, or just a next_step_time \"overflow\"\n\tif (next_step_time < 65536) {\n\t\tnext_step_time = 0;\n\t\t// step!\n\t\ttimer1_compa_isr();\n\t\treturn;\n\t}\n\t\n\tnext_step_time -= 65536;\n\n\t// similar algorithm as described in setTimer below.\n\tif (next_step_time < 65536) {\n\t\tOCR1A = (OCR1A + next_step_time) & 0xFFFF;\n\t} else if(next_step_time < 75536){\n\t\tOCR1A = (OCR1A - 10000) & 0xFFFF;\n\t\tnext_step_time += 10000;\n\t}\n\t// leave OCR1A as it was\n}", "path": "timer.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/*\n\tWrite\n*/\n", "func_signal": "void serial_writechar(uint8_t data)", "code": "{\n\t// check if interrupts are enabled\n\tif (SREG & MASK(SREG_I)) {\n\t\t// if they are, we should be ok to block since the tx buffer is emptied from an interrupt\n\t\tfor (;buf_canwrite(tx) == 0;);\n\t\tbuf_push(tx, data);\n\t}\n\telse {\n\t\t// interrupts are disabled- maybe we're in one?\n\t\t// anyway, instead of blocking, only write if we have room\n\t\tif (buf_canwrite(tx))\n\t\t\tbuf_push(tx, data);\n\t}\n\t// enable TX interrupt so we can send this character\n\tUCSR0B |= MASK(UDRIE0);\n}", "path": "serial.c", "repo_name": "triffid/FiveD_on_Arduino", "stars": 31, "license": "gpl-2.0", "language": "c", "size": 4029}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      LuaJava API Functin\n************************************************************************/\n", "func_signal": "JNIEXPORT jobject JNICALL Java_org_keplerproject_luajava_LuaState__1getObjectFromUserdata\n  (JNIEnv * env , jobject jobj , jobject cptr , jint index )", "code": "{\n   /* Get luastate */\n   lua_State * L = getStateFromCPtr( env , cptr );\n   jobject *   obj;\n\n   if ( !isJavaObject( L , index ) )\n   {\n      ( *env )->ThrowNew( env , ( *env )->FindClass( env , \"java/lang/Exception\" ) ,\n                          \"Index is not a java object\" );\n      return NULL;\n   }\n\n   obj = ( jobject * ) lua_touserdata( L , index );\n\n   return *obj;\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaopen_os (lua_State *L)", "code": "{\n  luaL_register(L, LUA_OSLIBNAME, syslib);\n  return 1;\n}", "path": "LuaAndroid\\jni\\lua\\loslib.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jobject JNICALL Java_org_keplerproject_luajava_LuaState__1newthread\n  (JNIEnv * env , jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n   lua_State * newThread;\n   \n   jobject obj;\n   jclass tempClass;\n    \n   newThread = lua_newthread( L );\n\n   tempClass = ( *env )->FindClass( env , \"org/keplerproject/luajava/CPtr\" );\n   obj = ( *env )->AllocObject( env , tempClass );\n   if ( obj )\n   {\n      ( *env )->SetLongField( env , obj , ( *env )->GetFieldID( env , tempClass ,\n                                                        \"peer\" , \"J\" ), ( jlong ) L );\n   }\n\n   return obj;\n\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1isNil\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_isnil( L , ( int ) idx );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1LsetN\n  (JNIEnv * env , jobject jobj , jobject cptr , jint t , jint n)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   luaL_setn( L , ( int ) t , ( int ) n );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1getGcCount\n  (JNIEnv * env , jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_getgccount( L );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1close\n  (JNIEnv * env , jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_close( L );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/*\n** When creating file handles, always creates a `closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** file is not left opened.\n*/\n", "func_signal": "static FILE **newfile (lua_State *L)", "code": "{\n  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));\n  *pf = NULL;  /* file handle is currently `closed' */\n  luaL_getmetatable(L, LUA_FILEHANDLE);\n  lua_setmetatable(L, -2);\n  return pf;\n}", "path": "LuaAndroid\\jni\\lua\\liolib.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1getField\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx , jstring k)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   const char * uniStr;\n   uniStr =  ( *env )->GetStringUTFChars( env , k , NULL );\n\n   lua_getfield( L , ( int ) idx , uniStr );\n   \n   ( *env )->ReleaseStringUTFChars( env , k , uniStr );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1insert\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_insert( L , ( int ) idx );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1openDebug\n  (JNIEnv * env, jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   //luaopen_debug( L );\n   lua_pushcfunction( L , luaopen_debug );\n   lua_pushstring( L , LUA_DBLIBNAME );\n   lua_call(L , 1 , 0 );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1LargError\n  (JNIEnv * env , jobject jobj , jobject cptr , jint numArg , jstring extraMsg)", "code": "{\n   lua_State * L    = getStateFromCPtr( env , cptr );\n   const char * msg = ( *env )->GetStringUTFChars( env , extraMsg , NULL );\n   int ret;\n\n   ret = luaL_argerror( L , ( int ) numArg , msg );\n\n   ( *env )->ReleaseStringUTFChars( env , extraMsg , msg );\n\n   return ( jint ) ret;;\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1pushBoolean\n  (JNIEnv * env , jobject jobj , jobject cptr , jint jbool)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_pushboolean( L , ( int ) jbool );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/* }====================================================== */\n", "func_signal": "static int os_setlocale (lua_State *L)", "code": "{\n  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,\n                      LC_NUMERIC, LC_TIME};\n  static const char *const catnames[] = {\"all\", \"collate\", \"ctype\", \"monetary\",\n     \"numeric\", \"time\", NULL};\n  const char *l = luaL_optstring(L, 1, NULL);\n  int op = luaL_checkoption(L, 2, \"all\", catnames);\n  lua_pushstring(L, setlocale(cat[op], l));\n  return 1;\n}", "path": "LuaAndroid\\jni\\lua\\loslib.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1LloadBuffer\n  (JNIEnv * env , jobject jobj , jobject cptr , jbyteArray buff , jlong sz , jstring n)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n   jbyte * cBuff = ( *env )->GetByteArrayElements( env , buff, NULL );\n   const char * name = ( * env )->GetStringUTFChars( env , n , NULL );\n   int ret;\n\n   ret = luaL_loadbuffer( L , ( const char * ) cBuff, ( int ) sz, name );\n\n   ( *env )->ReleaseStringUTFChars( env , n , name );\n\n   ( *env )->ReleaseByteArrayElements( env , buff , cBuff , 0 );\n\n   return ( jint ) ret;\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/*\n** function to close 'popen' files\n*/\n", "func_signal": "static int io_pclose (lua_State *L)", "code": "{\n  FILE **p = tofilep(L);\n  int ok = lua_pclose(L, *p);\n  *p = NULL;\n  return pushresult(L, ok, NULL);\n}", "path": "LuaAndroid\\jni\\lua\\liolib.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1rawSet\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_rawset( L , (int)idx );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      LuaJava API Functin\n************************************************************************/\n", "func_signal": "JNIEXPORT jboolean JNICALL Java_org_keplerproject_luajava_LuaState__1isObject\n  (JNIEnv * env , jobject jobj , jobject cptr , jint index )", "code": "{\n   /* Get luastate */\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return (isJavaObject( L , index ) ? JNI_TRUE : JNI_FALSE );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1setFEnv\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return lua_setfenv( L , idx );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1setField\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx , jstring k)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   const char * uniStr;\n   uniStr =  ( *env )->GetStringUTFChars( env , k , NULL );\n\n   lua_setfield( L , ( int ) idx , uniStr );\n   \n   ( *env )->ReleaseStringUTFChars( env , k , uniStr );\n}", "path": "FirstLuaJitApp\\jni\\luajava\\luajava.c", "repo_name": "long-nguyen/LuaForAndroid", "stars": 21, "license": "None", "language": "c", "size": 1357}
{"docstring": "/* Compute the size of device tree in xnu format. */\n", "func_signal": "static grub_size_t\ngrub_xnu_writetree_get_size (struct grub_xnu_devtree_key *start, char *name)", "code": "{\n  grub_size_t ret;\n  struct grub_xnu_devtree_key *cur;\n\n  /* Key header. */\n  ret = 2 * sizeof (grub_uint32_t);\n\n  /* \"name\" value. */\n  ret += 32 + sizeof (grub_uint32_t)\n    + grub_strlen (name) + 4\n    - (grub_strlen (name) % 4);\n\n  for (cur = start; cur; cur = cur->next)\n    if (cur->datasize != -1)\n      {\n\tint align_overhead;\n\n\talign_overhead = 4 - (cur->datasize % 4);\n\tif (align_overhead == 4)\n\t  align_overhead = 0;\n\tret += 32 + sizeof (grub_uint32_t) + cur->datasize + align_overhead;\n      }\n    else\n      ret += grub_xnu_writetree_get_size (cur->first_child, cur->name);\n  return ret;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Register a memory in a memory map under name PREFIXSUFFIX\n   and increment SUFFIX. */\n", "func_signal": "static grub_err_t\ngrub_xnu_register_memory (char *prefix, int *suffix,\n\t\t\t  grub_addr_t addr, grub_size_t size)", "code": "{\n  struct grub_xnu_devtree_key *chosen;\n  struct grub_xnu_devtree_key *memorymap;\n  struct grub_xnu_devtree_key *driverkey;\n  struct grub_xnu_extdesc *extdesc;\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  chosen = grub_xnu_create_key (&grub_xnu_devtree_root, \"chosen\");\n  if (! chosen)\n    return grub_errno;\n  memorymap = grub_xnu_create_key (&(chosen->first_child), \"memory-map\");\n  if (! memorymap)\n    return grub_errno;\n\n  driverkey = (struct grub_xnu_devtree_key *) grub_malloc (sizeof (*driverkey));\n  if (! driverkey)\n    return grub_error (GRUB_ERR_OUT_OF_MEMORY, \"can't register memory\");\n  if (suffix)\n    {\n      driverkey->name = grub_xasprintf (\"%s%d\", prefix, (*suffix)++);\n      if (!driverkey->name)\n\treturn grub_error (GRUB_ERR_OUT_OF_MEMORY, \"can't register memory\");\n    }\n  else\n    driverkey->name = grub_strdup (prefix);\n  if (! driverkey->name)\n    return grub_error (GRUB_ERR_OUT_OF_MEMORY, \"can't register extension\");\n  driverkey->datasize = sizeof (*extdesc);\n  driverkey->next = memorymap->first_child;\n  memorymap->first_child = driverkey;\n  driverkey->data = extdesc\n    = (struct grub_xnu_extdesc *) grub_malloc (sizeof (*extdesc));\n  if (! driverkey->data)\n    return grub_error (GRUB_ERR_OUT_OF_MEMORY, \"can't register extension\");\n  extdesc->addr = addr;\n  extdesc->size = (grub_uint32_t) size;\n  return GRUB_ERR_NONE;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Find a key or value in parent key. */\n", "func_signal": "struct grub_xnu_devtree_key *\ngrub_xnu_find_key (struct grub_xnu_devtree_key *parent, char *name)", "code": "{\n  struct grub_xnu_devtree_key *cur;\n  for (cur = parent; cur; cur = cur->next)\n    if (grub_strcmp (cur->name, name) == 0)\n      return cur;\n  return 0;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Return the hash representation of the string S.  */\n", "func_signal": "static unsigned int\ngrub_env_hashval (const char *s)", "code": "{\n  unsigned int i = 0;\n\n  /* XXX: This can be done much more efficiently.  */\n  while (*s)\n    i += 5 * *(s++);\n\n  return i % HASHSZ;\n}", "path": "grub-core\\kern\\env.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load all loadable kexts placed under DIRNAME and matching OSBUNDLEREQUIRED */\n", "func_signal": "grub_err_t\ngrub_xnu_scan_dir_for_kexts (char *dirname, char *osbundlerequired,\n\t\t\t     int maxrecursion)", "code": "{\n  grub_device_t dev;\n  char *device_name;\n  grub_fs_t fs;\n  const char *path;\n\n  auto int load_hook (const char *filename,\n\t\t      const struct grub_dirhook_info *info);\n  int load_hook (const char *filename, const struct grub_dirhook_info *info)\n  {\n    char *newdirname;\n    if (! info->dir)\n      return 0;\n    if (filename[0] == '.')\n      return 0;\n\n    if (grub_strlen (filename) < 5 ||\n\tgrub_memcmp (filename + grub_strlen (filename) - 5, \".kext\", 5) != 0)\n      return 0;\n\n    newdirname\n      = grub_malloc (grub_strlen (dirname) + grub_strlen (filename) + 2);\n\n    /* It's a .kext. Try to load it. */\n    if (newdirname)\n      {\n\tgrub_strcpy (newdirname, dirname);\n\tnewdirname[grub_strlen (newdirname) + 1] = 0;\n\tnewdirname[grub_strlen (newdirname)] = '/';\n\tgrub_strcpy (newdirname + grub_strlen (newdirname), filename);\n\tgrub_xnu_load_kext_from_dir (newdirname, osbundlerequired,\n\t\t\t\t     maxrecursion);\n\tif (grub_errno == GRUB_ERR_BAD_OS)\n\t  grub_errno = GRUB_ERR_NONE;\n\tgrub_free (newdirname);\n      }\n    return 0;\n  }\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  device_name = grub_file_get_device_name (dirname);\n  dev = grub_device_open (device_name);\n  if (dev)\n    {\n      fs = grub_fs_probe (dev);\n      path = grub_strchr (dirname, ')');\n      if (! path)\n\tpath = dirname;\n      else\n\tpath++;\n\n      if (fs)\n\t(fs->dir) (dev, path, load_hook);\n      grub_device_close (dev);\n    }\n  grub_free (device_name);\n\n  return GRUB_ERR_NONE;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Puts the specified mapping into the table, replacing an existing mapping\n   for newdrive or adding a new one if required.  */\n", "func_signal": "static grub_err_t\ndrivemap_set (grub_uint8_t newdrive, grub_uint8_t redirto)", "code": "{\n  drivemap_node_t *mapping = 0;\n  drivemap_node_t *search = map_head;\n  while (search)\n    {\n      if (search->newdrive == newdrive)\n\t{\n\t  mapping = search;\n\t  break;\n\t}\n      search = search->next;\n    }\n\n  /* Check for pre-existing mappings to modify before creating a new one.  */\n  if (mapping)\n    mapping->redirto = redirto;\n  else\n    {\n      mapping = grub_malloc (sizeof (drivemap_node_t));\n      if (! mapping)\n\treturn grub_error (GRUB_ERR_OUT_OF_MEMORY,\n\t\t\t   \"cannot allocate map entry, not enough memory\");\n      mapping->newdrive = newdrive;\n      mapping->redirto = redirto;\n      mapping->next = map_head;\n      map_head = mapping;\n    }\n  return GRUB_ERR_NONE;\n}", "path": "grub-core\\commands\\i386\\pc\\drivemap.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Set start address.  */\n", "func_signal": "static void\nset_start_address (unsigned int start)", "code": "{\n  grub_vga_cr_write (start & 0xFF, GRUB_VGA_CR_START_ADDR_LOW_REGISTER);\n  grub_vga_cr_write (start >> 8, GRUB_VGA_CR_START_ADDR_HIGH_REGISTER);\n}", "path": "grub-core\\video\\i386\\pc\\vga.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load mkext. */\n", "func_signal": "static grub_err_t\ngrub_cmd_xnu_mkext (grub_command_t cmd __attribute__ ((unused)),\n\t\t    int argc, char *args[])", "code": "{\n  grub_file_t file;\n  void *loadto;\n  grub_addr_t loadto_target;\n  grub_err_t err;\n  grub_off_t readoff = 0;\n  grub_ssize_t readlen = -1;\n  struct grub_macho_fat_header head;\n  struct grub_macho_fat_arch *archs;\n  int narchs, i;\n\n  if (argc != 1)\n    return grub_error (GRUB_ERR_BAD_ARGUMENT, \"file name required\");\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  file = grub_file_open (args[0]);\n  if (! file)\n    return grub_error (GRUB_ERR_FILE_NOT_FOUND,\n\t\t       \"couldn't load driver package\");\n\n  /* Sometimes caches are fat binary. Errgh. */\n  if (grub_file_read (file, &head, sizeof (head))\n      != (grub_ssize_t) (sizeof (head)))\n    {\n      /* I don't know the internal structure of package but\n\t can hardly imagine a valid package shorter than 20 bytes. */\n      grub_file_close (file);\n      grub_error_push ();\n      return grub_error (GRUB_ERR_BAD_OS, \"couldn't read file %s\", args[0]);\n    }\n\n  /* Find the corresponding architecture. */\n  if (grub_be_to_cpu32 (head.magic) == GRUB_MACHO_FAT_MAGIC)\n    {\n      narchs = grub_be_to_cpu32 (head.nfat_arch);\n      archs = grub_malloc (sizeof (struct grub_macho_fat_arch) * narchs);\n      if (! archs)\n\t{\n\t  grub_file_close (file);\n\t  grub_error_push ();\n\t  return grub_error (GRUB_ERR_OUT_OF_MEMORY,\n\t\t\t     \"couldn't read file %s\", args[0]);\n\n\t}\n      if (grub_file_read (file, archs,\n\t\t\t  sizeof (struct grub_macho_fat_arch) * narchs)\n\t  != (grub_ssize_t) sizeof(struct grub_macho_fat_arch) * narchs)\n\t{\n\t  grub_free (archs);\n\t  grub_error_push ();\n\t  return grub_error (GRUB_ERR_READ_ERROR, \"cannot read fat header\");\n\t}\n      for (i = 0; i < narchs; i++)\n\t{\n\t  if (!grub_xnu_is_64bit && GRUB_MACHO_CPUTYPE_IS_HOST32\n\t      (grub_be_to_cpu32 (archs[i].cputype)))\n\t    {\n\t      readoff = grub_be_to_cpu32 (archs[i].offset);\n\t      readlen = grub_be_to_cpu32 (archs[i].size);\n\t    }\n\t  if (grub_xnu_is_64bit && GRUB_MACHO_CPUTYPE_IS_HOST64\n\t      (grub_be_to_cpu32 (archs[i].cputype)))\n\t    {\n\t      readoff = grub_be_to_cpu32 (archs[i].offset);\n\t      readlen = grub_be_to_cpu32 (archs[i].size);\n\t    }\n\t}\n      grub_free (archs);\n    }\n  else\n    {\n      /* It's a flat file. Some sane people still exist. */\n      readoff = 0;\n      readlen = grub_file_size (file);\n    }\n\n  if (readlen == -1)\n    {\n      grub_file_close (file);\n      return grub_error (GRUB_ERR_BAD_OS, \"no suitable architecture is found\");\n    }\n\n  /* Allocate space. */\n  err = grub_xnu_align_heap (GRUB_XNU_PAGESIZE);\n  if (err)\n    {\n      grub_file_close (file);\n      return err;\n    }\n\n  err = grub_xnu_heap_malloc (readlen, &loadto, &loadto_target);\n  if (err)\n    {\n      grub_file_close (file);\n      return err;\n    }\n\n  /* Read the file. */\n  grub_file_seek (file, readoff);\n  if (grub_file_read (file, loadto, readlen) != (grub_ssize_t) (readlen))\n    {\n      grub_file_close (file);\n      grub_error_push ();\n      return grub_error (GRUB_ERR_BAD_OS, \"couldn't read file %s\", args[0]);\n    }\n  grub_file_close (file);\n\n  /* Pass it to kernel. */\n  return grub_xnu_register_memory (\"DriversPackage-\", &driverspackagenum,\n\t\t\t\t   loadto_target, readlen);\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Fill previously allocated Multiboot mmap.  */\n", "func_signal": "static void\ngrub_fill_multiboot_mmap (struct multiboot_tag_mmap *tag)", "code": "{\n  struct multiboot_mmap_entry *mmap_entry = tag->entries;\n\n  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t,\n\t\t\t\t  grub_memory_type_t);\n  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,\n\t\t\t     grub_memory_type_t type)\n    {\n      mmap_entry->addr = addr;\n      mmap_entry->len = size;\n      switch (type)\n\t{\n\tcase GRUB_MEMORY_AVAILABLE:\n \t  mmap_entry->type = MULTIBOOT_MEMORY_AVAILABLE;\n \t  break;\n\n\tcase GRUB_MEMORY_ACPI:\n \t  mmap_entry->type = MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;\n \t  break;\n\n\tcase GRUB_MEMORY_NVS:\n \t  mmap_entry->type = MULTIBOOT_MEMORY_NVS;\n \t  break;\n\n\tcase GRUB_MEMORY_BADRAM:\n \t  mmap_entry->type = MULTIBOOT_MEMORY_BADRAM;\n \t  break;\n\n \tdefault:\n \t  mmap_entry->type = MULTIBOOT_MEMORY_RESERVED;\n \t  break;\n \t}\n      mmap_entry++;\n\n      return 0;\n    }\n\n  tag->type = MULTIBOOT_TAG_TYPE_MMAP;\n  tag->size = sizeof (struct multiboot_tag_mmap)\n    + sizeof (struct multiboot_mmap_entry) * grub_get_multiboot_mmap_count (); \n  tag->entry_size = sizeof (struct multiboot_mmap_entry);\n  tag->entry_version = 0;\n\n  grub_mmap_iterate (hook);\n}", "path": "grub-core\\loader\\multiboot_mbi2.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load the kext. */\n", "func_signal": "static grub_err_t\ngrub_cmd_xnu_kext (grub_command_t cmd __attribute__ ((unused)),\n\t\t   int argc, char *args[])", "code": "{\n  grub_file_t binfile = 0;\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  if (argc == 2)\n    {\n      /* User explicitly specified plist and binary. */\n      if (grub_strcmp (args[1], \"-\") != 0)\n\t{\n\t  binfile = grub_file_open (args[1]);\n\t  if (! binfile)\n\t    {\n\t      grub_error (GRUB_ERR_BAD_OS, \"can't open file\");\n\t      return GRUB_ERR_NONE;\n\t    }\n\t}\n      return grub_xnu_load_driver (grub_strcmp (args[0], \"-\") ? args[0] : 0,\n\t\t\t\t   binfile);\n    }\n\n  /* load kext normally. */\n  if (argc == 1)\n    return grub_xnu_load_kext_from_dir (args[0], 0, 10);\n\n  return grub_error (GRUB_ERR_BAD_ARGUMENT, \"file name required\");\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load a directory containing kexts. */\n", "func_signal": "static grub_err_t\ngrub_cmd_xnu_kextdir (grub_command_t cmd __attribute__ ((unused)),\n\t\t      int argc, char *args[])", "code": "{\n  if (argc != 1 && argc != 2)\n    return grub_error (GRUB_ERR_BAD_ARGUMENT, \"directory name required\");\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  if (argc == 1)\n    return grub_xnu_scan_dir_for_kexts (args[0],\n\t\t\t\t\t\"console,root,local-root,network-root\",\n\t\t\t\t\t10);\n  else\n    {\n      char *osbundlerequired = grub_strdup (args[1]), *ptr;\n      grub_err_t err;\n      if (! osbundlerequired)\n\treturn grub_error (GRUB_ERR_OUT_OF_MEMORY,\n\t\t\t   \"couldn't allocate string temporary space\");\n      for (ptr = osbundlerequired; *ptr; ptr++)\n\t*ptr = grub_tolower (*ptr);\n      err = grub_xnu_scan_dir_for_kexts (args[0], osbundlerequired, 10);\n      grub_free (osbundlerequired);\n      return err;\n    }\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load extension DIRNAME. (extensions are directories in xnu) */\n", "func_signal": "grub_err_t\ngrub_xnu_load_kext_from_dir (char *dirname, char *osbundlerequired,\n\t\t\t     int maxrecursion)", "code": "{\n  grub_device_t dev;\n  char *plistname = 0;\n  char *newdirname;\n  char *newpath;\n  char *device_name;\n  grub_fs_t fs;\n  const char *path;\n  char *binsuffix;\n  int usemacos = 0;\n  grub_file_t binfile;\n\n  auto int load_hook (const char *filename,\n\t\t      const struct grub_dirhook_info *info);\n\n  int load_hook (const char *filename, const struct grub_dirhook_info *info)\n  {\n    if (grub_strlen (filename) > 15)\n      return 0;\n    grub_strcpy (newdirname + grub_strlen (dirname) + 1, filename);\n\n    /* If the kext contains directory \"Contents\" all real stuff is in\n       this directory. */\n    if (info->dir && grub_strcasecmp (filename, \"Contents\") == 0)\n      grub_xnu_load_kext_from_dir (newdirname, osbundlerequired,\n\t\t\t\t   maxrecursion - 1);\n\n    /* Directory \"Plugins\" contains nested kexts. */\n    if (info->dir && grub_strcasecmp (filename, \"Plugins\") == 0)\n      grub_xnu_scan_dir_for_kexts (newdirname, osbundlerequired,\n\t\t\t\t   maxrecursion - 1);\n\n    /* Directory \"MacOS\" contains executable, otherwise executable is\n       on the top. */\n    if (info->dir && grub_strcasecmp (filename, \"MacOS\") == 0)\n      usemacos = 1;\n\n    /* Info.plist is the file which governs our future actions. */\n    if (! info->dir && grub_strcasecmp (filename, \"Info.plist\") == 0\n\t&& ! plistname)\n      plistname = grub_strdup (newdirname);\n    return 0;\n  }\n\n  newdirname = grub_malloc (grub_strlen (dirname) + 20);\n  if (! newdirname)\n    return grub_error (GRUB_ERR_OUT_OF_MEMORY, \"couldn't allocate buffer\");\n  grub_strcpy (newdirname, dirname);\n  newdirname[grub_strlen (dirname)] = '/';\n  newdirname[grub_strlen (dirname) + 1] = 0;\n  device_name = grub_file_get_device_name (dirname);\n  dev = grub_device_open (device_name);\n  if (dev)\n    {\n      fs = grub_fs_probe (dev);\n      path = grub_strchr (dirname, ')');\n      if (! path)\n\tpath = dirname;\n      else\n\tpath++;\n\n      newpath = grub_strchr (newdirname, ')');\n      if (! newpath)\n\tnewpath = newdirname;\n      else\n\tnewpath++;\n\n      /* Look at the directory. */\n      if (fs)\n\t(fs->dir) (dev, path, load_hook);\n\n      if (plistname && grub_xnu_check_os_bundle_required\n\t  (plistname, osbundlerequired, &binsuffix))\n\t{\n\t  if (binsuffix)\n\t    {\n\t      /* Open the binary. */\n\t      char *binname = grub_malloc (grub_strlen (dirname)\n\t\t\t\t\t   + grub_strlen (binsuffix)\n\t\t\t\t\t   + sizeof (\"/MacOS/\"));\n\t      grub_strcpy (binname, dirname);\n\t      if (usemacos)\n\t\tgrub_strcpy (binname + grub_strlen (binname), \"/MacOS/\");\n\t      else\n\t\tgrub_strcpy (binname + grub_strlen (binname), \"/\");\n\t      grub_strcpy (binname + grub_strlen (binname), binsuffix);\n\t      grub_dprintf (\"xnu\", \"%s:%s\\n\", plistname, binname);\n\t      binfile = grub_file_open (binname);\n\t      if (! binfile)\n\t\tgrub_errno = GRUB_ERR_NONE;\n\n\t      /* Load the extension. */\n\t      grub_xnu_load_driver (plistname, binfile);\n\t      grub_free (binname);\n\t      grub_free (binsuffix);\n\t    }\n\t  else\n\t    {\n\t      grub_dprintf (\"xnu\", \"%s:0\\n\", plistname);\n\t      grub_xnu_load_driver (plistname, 0);\n\t    }\n\t}\n      grub_free (plistname);\n      grub_device_close (dev);\n    }\n  grub_free (device_name);\n\n  return GRUB_ERR_NONE;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Set the root device according to the dl prefix.  */\n", "func_signal": "static void\ngrub_set_root_dev (void)", "code": "{\n  const char *prefix;\n\n  grub_register_variable_hook (\"root\", 0, grub_env_write_root);\n\n  prefix = grub_env_get (\"prefix\");\n\n  if (prefix)\n    {\n      char *dev;\n\n      dev = grub_file_get_device_name (prefix);\n      if (dev)\n\t{\n\t  grub_env_set (\"root\", dev);\n\t  grub_free (dev);\n\t}\n    }\n}", "path": "grub-core\\kern\\main.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load .kext. */\n", "func_signal": "static grub_err_t\ngrub_xnu_load_driver (char *infoplistname, grub_file_t binaryfile)", "code": "{\n  grub_macho_t macho;\n  grub_err_t err;\n  grub_file_t infoplist;\n  struct grub_xnu_extheader *exthead;\n  int neededspace = sizeof (*exthead);\n  grub_uint8_t *buf;\n  void *buf0;\n  grub_addr_t buf_target;\n  grub_size_t infoplistsize = 0, machosize = 0;\n  char *name, *nameend;\n  int namelen;\n\n  name = get_name_ptr (infoplistname);\n  nameend = grub_strchr (name, '/');\n\n  if (nameend)\n    namelen = nameend - name;\n  else\n    namelen = grub_strlen (name);\n\n  neededspace += namelen + 1;\n\n  if (! grub_xnu_heap_size)\n    return grub_error (GRUB_ERR_BAD_OS, \"no xnu kernel loaded\");\n\n  /* Compute the needed space. */\n  if (binaryfile)\n    {\n      macho = grub_macho_file (binaryfile);\n      if (! macho || ! grub_macho_contains_macho32 (macho))\n\t{\n\t  if (macho)\n\t    grub_macho_close (macho);\n\t  return grub_error (GRUB_ERR_BAD_OS,\n\t\t\t     \"extension doesn't contain suitable architecture\");\n\t}\n      if (grub_xnu_is_64bit)\n\tmachosize = grub_macho_filesize64 (macho);\n      else\n\tmachosize = grub_macho_filesize32 (macho);\n      neededspace += machosize;\n    }\n  else\n    macho = 0;\n\n  if (infoplistname)\n    infoplist = grub_file_open (infoplistname);\n  else\n    infoplist = 0;\n  grub_errno = GRUB_ERR_NONE;\n  if (infoplist)\n    {\n      infoplistsize = grub_file_size (infoplist);\n      neededspace += infoplistsize + 1;\n    }\n  else\n    infoplistsize = 0;\n\n  /* Allocate the space. */\n  err = grub_xnu_align_heap (GRUB_XNU_PAGESIZE);\n  if (err)\n    return err;\n  err = grub_xnu_heap_malloc (neededspace, &buf0, &buf_target);\n  if (err)\n    return err;\n  buf = buf0;\n\n  exthead = (struct grub_xnu_extheader *) buf;\n  grub_memset (exthead, 0, sizeof (*exthead));\n  buf += sizeof (*exthead);\n\n  /* Load the binary. */\n  if (macho)\n    {\n      exthead->binaryaddr = buf_target + (buf - (grub_uint8_t *) buf0);\n      exthead->binarysize = machosize;\n      if (grub_xnu_is_64bit)\n\terr = grub_macho_readfile64 (macho, buf);\n      else\n\terr = grub_macho_readfile32 (macho, buf);\n      if (err)\n\t{\n\t  grub_macho_close (macho);\n\t  return err;\n\t}\n      grub_macho_close (macho);\n      buf += machosize;\n    }\n  grub_errno = GRUB_ERR_NONE;\n\n  /* Load the plist. */\n  if (infoplist)\n    {\n      exthead->infoplistaddr = buf_target + (buf - (grub_uint8_t *) buf0);\n      exthead->infoplistsize = infoplistsize + 1;\n      if (grub_file_read (infoplist, buf, infoplistsize)\n\t  != (grub_ssize_t) (infoplistsize))\n\t{\n\t  grub_file_close (infoplist);\n\t  grub_error_push ();\n\t  return grub_error (GRUB_ERR_BAD_OS, \"couldn't read file %s: \",\n\t\t\t     infoplistname);\n\t}\n      grub_file_close (infoplist);\n      buf[infoplistsize] = 0;\n      buf += infoplistsize + 1;\n    }\n  grub_errno = GRUB_ERR_NONE;\n\n  exthead->nameaddr = (buf - (grub_uint8_t *) buf0) + buf_target;\n  exthead->namesize = namelen + 1;\n  grub_memcpy (buf, name, namelen);\n  buf[namelen] = 0;\n  buf += namelen + 1;\n\n  /* Announce to kernel */\n  return grub_xnu_register_memory (\"Driver-\", &driversnum, buf_target,\n\t\t\t\t   neededspace);\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Given a GRUB-like device name and a convenient location, stores the\n   related BIOS disk number.  Accepts devices like \\((f|h)dN\\), with\n   0 <= N < 128.  */\n", "func_signal": "static grub_err_t\ntryparse_diskstring (const char *str, grub_uint8_t *output)", "code": "{\n  /* Skip opening paren in order to allow both (hd0) and hd0.  */\n  if (*str == '(')\n    str++;\n  if ((str[0] == 'f' || str[0] == 'h') && str[1] == 'd')\n    {\n      grub_uint8_t bios_num = (str[0] == 'h') ? 0x80 : 0x00;\n      unsigned long drivenum = grub_strtoul (str + 2, 0, 0);\n      if (grub_errno == GRUB_ERR_NONE && drivenum < 128)\n\t{\n\t  bios_num |= drivenum;\n\t  if (output)\n\t    *output = bios_num;\n\t  return GRUB_ERR_NONE;\n\t}\n    }\n  return grub_error (GRUB_ERR_BAD_ARGUMENT, \"device format \\\"%s\\\" \"\n\t\t     \"invalid: must be (f|h)dN, with 0 <= N < 128\", str);\n}", "path": "grub-core\\commands\\i386\\pc\\drivemap.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Write devtree in XNU format at curptr assuming the head is named NAME.*/\n", "func_signal": "static void *\ngrub_xnu_writetree_toheap_real (void *curptr,\n\t\t\t\tstruct grub_xnu_devtree_key *start, char *name)", "code": "{\n  struct grub_xnu_devtree_key *cur;\n  int nkeys = 0, nvals = 0;\n  for (cur = start; cur; cur = cur->next)\n    {\n      if (cur->datasize == -1)\n\tnkeys++;\n      else\n\tnvals++;\n    }\n  /* For the name. */\n  nvals++;\n\n  *((grub_uint32_t *) curptr) = nvals;\n  curptr = ((grub_uint32_t *) curptr) + 1;\n  *((grub_uint32_t *) curptr) = nkeys;\n  curptr = ((grub_uint32_t *) curptr) + 1;\n\n  /* First comes \"name\" value. */\n  grub_memset (curptr, 0, 32);\n  grub_memcpy (curptr, \"name\", 4);\n  curptr = ((grub_uint8_t *) curptr) + 32;\n  *((grub_uint32_t *)curptr) = grub_strlen (name) + 1;\n  curptr = ((grub_uint32_t *) curptr) + 1;\n  grub_memcpy (curptr, name, grub_strlen (name));\n  curptr = ((grub_uint8_t *) curptr) + grub_strlen (name);\n  grub_memset (curptr, 0, 4 - (grub_strlen (name) % 4));\n  curptr = ((grub_uint8_t *) curptr) + (4 - (grub_strlen (name) % 4));\n\n  /* Then the other values. */\n  for (cur = start; cur; cur = cur->next)\n    if (cur->datasize != -1)\n      {\n\tint align_overhead;\n\n\talign_overhead = 4 - (cur->datasize % 4);\n\tif (align_overhead == 4)\n\t  align_overhead = 0;\n\tgrub_memset (curptr, 0, 32);\n\tgrub_strncpy (curptr, cur->name, 31);\n\tcurptr = ((grub_uint8_t *) curptr) + 32;\n\t*((grub_uint32_t *) curptr) = cur->datasize;\n\tcurptr = ((grub_uint32_t *) curptr) + 1;\n\tgrub_memcpy (curptr, cur->data, cur->datasize);\n\tcurptr = ((grub_uint8_t *) curptr) + cur->datasize;\n\tgrub_memset (curptr, 0, align_overhead);\n\tcurptr = ((grub_uint8_t *) curptr) + align_overhead;\n      }\n\n  /* And then the keys. Recursively use this function. */\n  for (cur = start; cur; cur = cur->next)\n    if (cur->datasize == -1)\n      if (!(curptr = grub_xnu_writetree_toheap_real (curptr,\n\t\t\t\t\t\t     cur->first_child,\n\t\t\t\t\t\t     cur->name)))\n\treturn 0;\n  return curptr;\n}", "path": "grub-core\\loader\\xnu.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load the normal mode module and execute the normal mode if possible.  */\n", "func_signal": "static void\ngrub_load_normal_mode (void)", "code": "{\n  /* Load the module.  */\n  grub_dl_load (\"normal\");\n\n  /* Something went wrong.  Print errors here to let user know why we're entering rescue mode.  */\n  grub_print_error ();\n  grub_errno = 0;\n\n  grub_command_execute (\"normal\", 0, 0);\n}", "path": "grub-core\\kern\\main.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Load all modules in core.  */\n", "func_signal": "static void\ngrub_load_modules (void)", "code": "{\n  auto int hook (struct grub_module_header *);\n  int hook (struct grub_module_header *header)\n    {\n      /* Not an ELF module, skip.  */\n      if (header->type != OBJ_TYPE_ELF)\n        return 0;\n\n      if (! grub_dl_load_core ((char *) header + sizeof (struct grub_module_header),\n\t\t\t       (header->size - sizeof (struct grub_module_header))))\n\tgrub_fatal (\"%s\", grub_errmsg);\n\n      if (grub_errno)\n\tgrub_print_error ();\n\n      return 0;\n    }\n\n  grub_module_iterate (hook);\n}", "path": "grub-core\\kern\\main.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Removes the mapping for newdrive from the table.  If there is no mapping,\n   then this function behaves like a no-op on the map.  */\n", "func_signal": "static void\ndrivemap_remove (grub_uint8_t newdrive)", "code": "{\n  drivemap_node_t *mapping = 0;\n  drivemap_node_t *search = map_head;\n  drivemap_node_t *previous = 0;\n\n  while (search)\n    {\n      if (search->newdrive == newdrive)\n\t{\n\t  mapping = search;\n\t  break;\n\t}\n      previous = search;\n      search = search->next;\n    }\n\n  if (mapping)\n    {\n      if (previous)\n\tprevious->next = mapping->next;\n      else\n\tmap_head = mapping->next;\n      grub_free (mapping);\n    }\n}", "path": "grub-core\\commands\\i386\\pc\\drivemap.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/* Int13h handler installer - reserves conventional memory for the handler,\n   copies it over and sets the IVT entry for int13h.\n   This code rests on the assumption that GRUB does not activate any kind\n   of memory mapping apart from identity paging, since it accesses\n   realmode structures by their absolute addresses, like the IVT at 0;\n   and transforms a pmode pointer into a rmode seg:off far ptr.  */\n", "func_signal": "static grub_err_t\ninstall_int13_handler (int noret __attribute__ ((unused)))", "code": "{\n  /* Size of the full int13 handler \"bundle\", including code and map.  */\n  grub_uint32_t total_size;\n  /* Base address of the space reserved for the handler bundle.  */\n  grub_uint8_t *handler_base = 0;\n  /* Address of the map within the deployed bundle.  */\n  int13map_node_t *handler_map;\n\n  int i;\n  int entries = 0;\n  drivemap_node_t *curentry = map_head;\n\n  /* Count entries to prepare a contiguous map block.  */\n  while (curentry)\n    {\n      entries++;\n      curentry = curentry->next;\n    }\n  if (entries == 0)\n    {\n      /* No need to install the int13h handler.  */\n      grub_dprintf (\"drivemap\", \"No drives marked as remapped, not installing \"\n\t\t    \"our int13h handler.\\n\");\n      return GRUB_ERR_NONE;\n    }\n\n  grub_dprintf (\"drivemap\", \"Installing our int13h handler\\n\");\n\n  /* Save the pointer to the old handler.  */\n  grub_drivemap_oldhandler = *int13slot;\n  grub_dprintf (\"drivemap\", \"Original int13 handler: %04x:%04x\\n\",\n\t\t(grub_drivemap_oldhandler >> 16) & 0x0ffff,\n\t\tgrub_drivemap_oldhandler & 0x0ffff);\n\n  /* Find a rmode-segment-aligned zone in conventional memory big\n     enough to hold the handler and its data.  */\n  total_size = INT13H_OFFSET (&grub_drivemap_mapstart)\n    + (entries + 1) * sizeof (int13map_node_t);\n  grub_dprintf (\"drivemap\", \"Payload is %u bytes long\\n\", total_size);\n  handler_base = grub_mmap_malign_and_register (16, total_size,\n\t\t\t\t\t\t&drivemap_mmap,\n\t\t\t\t\t\tGRUB_MEMORY_RESERVED,\n\t\t\t\t\t\tGRUB_MMAP_MALLOC_LOW);\n  if (! handler_base)\n    return grub_error (GRUB_ERR_OUT_OF_MEMORY, \"couldn't reserve \"\n\t\t       \"memory for the int13h handler\");\n\n  /* Copy int13h handler bundle to reserved area.  */\n  grub_dprintf (\"drivemap\", \"Reserved memory at %p, copying handler\\n\",\n\t\thandler_base);\n  grub_memcpy (handler_base, &grub_drivemap_handler,\n\t       INT13H_OFFSET (&grub_drivemap_mapstart));\n\n  /* Copy the mappings to the reserved area.  */\n  curentry = map_head;\n  handler_map = (int13map_node_t *) (handler_base +\n\t\t\t\t     INT13H_OFFSET (&grub_drivemap_mapstart));\n  grub_dprintf (\"drivemap\", \"Target map at %p, copying mappings\\n\", handler_map);\n  for (i = 0; i < entries; ++i, curentry = curentry->next)\n    {\n      handler_map[i].disknum = curentry->newdrive;\n      handler_map[i].mapto = curentry->redirto;\n      grub_dprintf (\"drivemap\", \"\\t#%d: 0x%02x <- 0x%02x\\n\", i,\n\t\t    handler_map[i].disknum, handler_map[i].mapto);\n    }\n  /* Signal end-of-map.  */\n  handler_map[i].disknum = 0;\n  handler_map[i].mapto = 0;\n  grub_dprintf (\"drivemap\", \"\\t#%d: 0x00 <- 0x00 (end)\\n\", i);\n\n  /* Install our function as the int13h handler in the IVT.  */\n  *int13slot = ((grub_uint32_t) handler_base) << 12;\t/* Segment address.  */\n  grub_dprintf (\"drivemap\", \"New int13 handler: %04x:%04x\\n\",\n\t\t(*int13slot >> 16) & 0x0ffff, *int13slot & 0x0ffff);\n\n  return GRUB_ERR_NONE;\n}", "path": "grub-core\\commands\\i386\\pc\\drivemap.c", "repo_name": "albertz/grub-fuse", "stars": 26, "license": "gpl-3.0", "language": "c", "size": 66265}
{"docstring": "/**\n * Stage 3: Set new user account data\n */\n", "func_signal": "static NTSTATUS usermod_modify(struct composite_context *c,\n\t\t\t       struct usermod_state *s)", "code": "{\n\t/* receive samr_SetUserInfo result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\tNT_STATUS_NOT_OK_RETURN(s->setuser.out.result);\n\n\tif (s->change.fields == 0) {\n\t\t/* all fields have been set - we're done */\n\t\tc->state = COMPOSITE_STATE_DONE;\n\t} else {\n\t\t/* something's still not changed - repeat the procedure */\n\t\treturn usermod_change(c, s);\n\t}\n\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 1 (and the only one for now): Create user account.\n */\n", "func_signal": "static NTSTATUS useradd_create(struct composite_context *c,\n\t\t\t       struct useradd_state *s)", "code": "{\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\t\n\tc->state = COMPOSITE_STATE_DONE;\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Step 1: Lookup user name\n */\n", "func_signal": "static NTSTATUS usermod_lookup(struct composite_context *c,\n\t\t\t       struct usermod_state *s)", "code": "{\n\t/* receive samr_LookupNames result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\t/* what to do when there's no user account to delete\n\t   and what if there's more than one rid resolved */\n\tif (!s->lookupname.out.rids.count) {\n\t\tc->status = NT_STATUS_NO_SUCH_USER;\n\t\tc->state  = COMPOSITE_STATE_ERROR;\n\t\treturn c->status;\n\n\t} else if (!s->lookupname.out.rids.count > 1) {\n\t\tc->status = NT_STATUS_INVALID_ACCOUNT_NAME;\n\t\tc->state  = COMPOSITE_STATE_ERROR;\n\t\treturn c->status;\n\t}\n\n\t/* prepare the next rpc call */\n\ts->openuser.in.domain_handle = &s->domain_handle;\n\ts->openuser.in.rid           = s->lookupname.out.rids.ids[0];\n\ts->openuser.in.access_mask   = SEC_FLAG_MAXIMUM_ALLOWED;\n\ts->openuser.out.user_handle  = &s->user_handle;\n\n\t/* send the rpc request */\n\ts->req = dcerpc_samr_OpenUser_send(s->pipe, c, &s->openuser);\n\n\t/* callback handler setup */\n\ts->req->async.callback = usermod_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERMOD_OPEN;\n\t\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Synchronous version of useradd call\n *\n * @param pipe dce/rpc call pipe\n * @param mem_ctx memory context for the call\n * @param io arguments and results of the call\n * @return nt status code of execution\n */\n", "func_signal": "NTSTATUS libnet_rpc_useradd(struct dcerpc_pipe *p,\n\t\t\t    TALLOC_CTX *mem_ctx,\n\t\t\t    struct libnet_rpc_useradd *io)", "code": "{\n\tstruct composite_context *c = libnet_rpc_useradd_send(p, io, NULL);\n\treturn libnet_rpc_useradd_recv(c, mem_ctx, io);\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Waits for and receives result of asynchronous useradd call\n * \n * @param c composite context returned by asynchronous useradd call\n * @param mem_ctx memory context of the call\n * @param io pointer to results (and arguments) of the call\n * @return nt status code of execution\n */\n", "func_signal": "NTSTATUS libnet_rpc_useradd_recv(struct composite_context *c, TALLOC_CTX *mem_ctx,\n\t\t\t\t struct libnet_rpc_useradd *io)", "code": "{\n\tNTSTATUS status;\n\tstruct useradd_state *s;\n\t\n\tstatus = composite_wait(c);\n\t\n\tif (NT_STATUS_IS_OK(status) && io) {\n\t\t/* get and return result of the call */\n\t\ts = talloc_get_type(c->private_data, struct useradd_state);\n\t\tio->out.user_handle = s->user_handle;\n\t}\n\n\ttalloc_free(c);\n\treturn status;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 2a (optional): Query the user information\n */\n", "func_signal": "static NTSTATUS usermod_query(struct composite_context *c,\n\t\t\t      struct usermod_state *s)", "code": "{\n\tunion samr_UserInfo *i = &s->info;\n\tuint16_t level;\n\n\t/* receive samr_QueryUserInfo result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\t/* get returned user data and make a change (potentially one\n\t   of many) */\n\ts->info = *s->queryuser.out.info;\n\n\ts->change.fields = usermod_setfields(s, &level, i);\n\n\t/* prepare rpc call arguments */\n\ts->setuser.in.user_handle  = &s->user_handle;\n\ts->setuser.in.level        = level;\n\ts->setuser.in.info         = i;\n\n\t/* send the rpc request */\n\ts->req = dcerpc_samr_SetUserInfo_send(s->pipe, c, &s->setuser);\n\n\t/* callback handler setup */\n\ts->req->async.callback = usermod_handler;\n\ts->req->async.private  = c;\n\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Sends asynchronous usermod request\n *\n * @param p dce/rpc call pipe\n * @param io arguments and results of the call\n * @param monitor monitor function for providing information about the progress\n */\n", "func_signal": "struct composite_context *libnet_rpc_usermod_send(struct dcerpc_pipe *p,\n\t\t\t\t\t\t  struct libnet_rpc_usermod *io,\n\t\t\t\t\t\t  void (*monitor)(struct monitor_msg*))", "code": "{\n\tstruct composite_context *c;\n\tstruct usermod_state *s;\n\n\t/* composite context allocation and setup */\n\tc = talloc_zero(p, struct composite_context);\n\tif (c == NULL) return NULL;\n\n\ts = talloc_zero(c, struct usermod_state);\n\tif (composite_nomem(s, c)) return c;\n\n\tc->state        = COMPOSITE_STATE_IN_PROGRESS;\n\tc->private_data = s;\n\tc->event_ctx    = dcerpc_event_context(p);\n\n\t/* store parameters in the call structure */\n\ts->pipe          = p;\n\ts->domain_handle = io->in.domain_handle;\n\ts->change        = io->in.change;\n\ts->monitor_fn    = monitor;\n\t\n\t/* prepare rpc call arguments */\n\ts->lookupname.in.domain_handle = &io->in.domain_handle;\n\ts->lookupname.in.num_names     = 1;\n\ts->lookupname.in.names         = talloc_zero(s, struct lsa_String);\n\ts->lookupname.in.names->string = io->in.username;\n\n\t/* send the rpc request */\n\ts->req = dcerpc_samr_LookupNames_send(p, c, &s->lookupname);\n\t\n\t/* callback handler setup */\n\ts->req->async.callback = usermod_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERMOD_LOOKUP;\n\n\treturn c;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Event handler for asynchronous request. Handles transition through\n * intermediate stages of the call.\n *\n * @param req rpc call context\n */\n", "func_signal": "static void useradd_handler(struct rpc_request *req)", "code": "{\n\tstruct composite_context *c = req->async.private;\n\tstruct useradd_state *s = talloc_get_type(c->private_data, struct useradd_state);\n\tstruct monitor_msg msg;\n\tstruct msg_rpc_create_user *rpc_create;\n\t\n\tswitch (s->stage) {\n\tcase USERADD_CREATE:\n\t\tc->status = useradd_create(c, s);\n\t\t\n\t\t/* prepare a message to pass to monitor function */\n\t\tmsg.type = rpc_create_user;\n\t\trpc_create = talloc(s, struct msg_rpc_create_user);\n\t\trpc_create->rid = *s->createuser.out.rid;\n\t\tmsg.data = (void*)rpc_create;\n\t\tmsg.data_size = sizeof(*rpc_create);\n\t\tbreak;\n\t}\n\n\t/* are we ok so far ? */\n\tif (!NT_STATUS_IS_OK(c->status)) {\n\t\tc->state = COMPOSITE_STATE_ERROR;\n\t}\n\n\t/* call monitor function provided the pointer has been passed */\n\tif (s->monitor_fn) {\n\t\ts->monitor_fn(&msg);\n\t}\n\n\t/* are we done yet ? */\n\tif (c->state >= COMPOSITE_STATE_DONE &&\n\t    c->async.fn) {\n\t\tc->async.fn(c);\n\t}\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Sends asynchronous useradd request\n *\n * @param p dce/rpc call pipe \n * @param io arguments and results of the call\n * @param monitor monitor function for providing information about the progress\n */\n", "func_signal": "struct composite_context *libnet_rpc_useradd_send(struct dcerpc_pipe *p,\n\t\t\t\t\t\t  struct libnet_rpc_useradd *io,\n\t\t\t\t\t\t  void (*monitor)(struct monitor_msg*))", "code": "{\n\tstruct composite_context *c;\n\tstruct useradd_state *s;\n\n\t/* composite allocation and setup */\n\tc = talloc_zero(p, struct composite_context);\n\tif (c == NULL) return NULL;\n\t\n\ts = talloc_zero(c, struct useradd_state);\n\tif (composite_nomem(s, c)) return c;\n\t\n\tc->state        = COMPOSITE_STATE_IN_PROGRESS;\n\tc->private_data = s;\n\tc->event_ctx    = dcerpc_event_context(p);\n\n\t/* put passed arguments to the state structure */\n\ts->domain_handle = io->in.domain_handle;\n\ts->pipe          = p;\n\ts->monitor_fn    = monitor;\n\t\n\t/* preparing parameters to send rpc request */\n\ts->createuser.in.domain_handle         = &io->in.domain_handle;\n\ts->createuser.in.account_name          = talloc_zero(c, struct lsa_String);\n\ts->createuser.in.account_name->string  = talloc_strdup(c, io->in.username);\n\ts->createuser.out.user_handle          = &s->user_handle;\n\ts->createuser.out.rid                  = &s->user_rid;\n\n\t/* send the request */\n\ts->req = dcerpc_samr_CreateUser_send(p, c, &s->createuser);\n\tif (composite_nomem(s->req, c)) return c;\n\n\t/* callback handler for continuation */\n\ts->req->async.callback = useradd_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERADD_CREATE;\n\n\treturn c;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 2: Open user account\n */\n", "func_signal": "static NTSTATUS usermod_open(struct composite_context *c,\n\t\t\t     struct usermod_state *s)", "code": "{\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\t\n\treturn usermod_change(c, s);\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Synchronous version of usermod call\n *\n * @param pipe dce/rpc call pipe\n * @param mem_ctx memory context for the call\n * @param io arguments and results of the call\n * @return nt status code of execution\n */\n", "func_signal": "NTSTATUS libnet_rpc_usermod(struct dcerpc_pipe *p,\n\t\t\t    TALLOC_CTX *mem_ctx,\n\t\t\t    struct libnet_rpc_usermod *io)", "code": "{\n\tstruct composite_context *c = libnet_rpc_usermod_send(p, io, NULL);\n\treturn libnet_rpc_usermod_recv(c, mem_ctx, io);\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Event handler for asynchronous request. Handles transition through\n * intermediate stages of the call.\n *\n * @param req rpc call context\n */\n", "func_signal": "static void usermod_handler(struct rpc_request *req)", "code": "{\n\tstruct composite_context *c;\n\tstruct usermod_state *s;\n\tstruct monitor_msg msg;\n\tstruct msg_rpc_lookup_name *msg_lookup;\n\tstruct msg_rpc_open_user *msg_open;\n\n\tc = talloc_get_type(req->async.private, struct composite_context);\n\ts = talloc_get_type(c->private_data, struct usermod_state);\n\n\tswitch (s->stage) {\n\tcase USERMOD_LOOKUP:\n\t\tc->status = usermod_lookup(c, s);\n\t\t\n\t\tif (NT_STATUS_IS_OK(c->status)) {\n\t\t\t/* monitor message */\n\t\t\tmsg.type = rpc_lookup_name;\n\t\t\tmsg_lookup = talloc(s, struct msg_rpc_lookup_name);\n\t\t\t\n\t\t\tmsg_lookup->rid   = s->lookupname.out.rids.ids;\n\t\t\tmsg_lookup->count = s->lookupname.out.rids.count;\n\t\t\tmsg.data = (void*)msg_lookup;\n\t\t\tmsg.data_size = sizeof(*msg_lookup);\n\t\t}\n\t\tbreak;\n\n\tcase USERMOD_OPEN:\n\t\tc->status = usermod_open(c, s);\n\n\t\tif (NT_STATUS_IS_OK(c->status)) {\n\t\t\t/* monitor message */\n\t\t\tmsg.type = rpc_open_user;\n\t\t\tmsg_open = talloc(s, struct msg_rpc_open_user);\n\t\t\t\n\t\t\tmsg_open->rid         = s->openuser.in.rid;\n\t\t\tmsg_open->access_mask = s->openuser.in.rid;\n\t\t\tmsg.data = (void*)msg_open;\n\t\t\tmsg.data_size = sizeof(*msg_open);\n\t\t}\n\t\tbreak;\n\n\tcase USERMOD_QUERY:\n\t\tc->status = usermod_query(c, s);\n\n\t\tif (NT_STATUS_IS_OK(c->status)) {\n\t\t\t/* monitor message */\n\t\t\tmsg.type = rpc_query_user;\n\t\t\tmsg.data = NULL;\n\t\t\tmsg.data_size = 0;\n\t\t}\n\t\tbreak;\n\n\tcase USERMOD_MODIFY:\n\t\tc->status = usermod_modify(c, s);\n\t\t\n\t\tif (NT_STATUS_IS_OK(c->status)) {\n\t\t\t/* monitor message */\n\t\t\tmsg.type = rpc_set_user;\n\t\t\tmsg.data = NULL;\n\t\t\tmsg.data_size = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* are we ok, so far ? */\n\tif (!NT_STATUS_IS_OK(c->status)) {\n\t\tc->state = COMPOSITE_STATE_ERROR;\n\t}\n\n\t/* call monitor function provided the pointer has been passed */\n\tif (s->monitor_fn) {\n\t\ts->monitor_fn(&msg);\n\t}\n\n\t/* are we done yet ? */\n\tif (c->state >= COMPOSITE_STATE_DONE &&\n\t    c->async.fn) {\n\t\tc->async.fn(c);\n\t}\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Waits for and receives results of asynchronous userdel call\n *\n * @param c composite context returned by asynchronous userdel call\n * @param mem_ctx memory context of the call\n * @param io pointer to results (and arguments) of the call\n * @return nt status code of execution\n */\n", "func_signal": "NTSTATUS libnet_rpc_userdel_recv(struct composite_context *c, TALLOC_CTX *mem_ctx,\n\t\t\t\t struct libnet_rpc_userdel *io)", "code": "{\n\tNTSTATUS status;\n\tstruct userdel_state *s;\n\t\n\tstatus = composite_wait(c);\n\n\tif (NT_STATUS_IS_OK(status) && io) {\n\t\ts  = talloc_get_type(c->private_data, struct userdel_state);\n\t\tio->out.user_handle = s->user_handle;\n\t}\n\n\ttalloc_free(c);\n\treturn status;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Synchronous version of userdel call\n *\n * @param pipe dce/rpc call pipe\n * @param mem_ctx memory context for the call\n * @param io arguments and results of the call\n * @return nt status code of execution\n */\n", "func_signal": "NTSTATUS libnet_rpc_userdel(struct dcerpc_pipe *p,\n\t\t\t    TALLOC_CTX *mem_ctx,\n\t\t\t    struct libnet_rpc_userdel *io)", "code": "{\n\tstruct composite_context *c = libnet_rpc_userdel_send(p, io, NULL);\n\treturn libnet_rpc_userdel_recv(c, mem_ctx, io);\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 3: Delete user account\n */\n", "func_signal": "static NTSTATUS userdel_delete(struct composite_context *c,\n\t\t\t       struct userdel_state *s)", "code": "{\n\t/* receive samr_DeleteUser result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\tc->state = COMPOSITE_STATE_DONE;\n\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Choose a proper level of samr_UserInfo structure depending on required\n * change specified by means of flags field. Subsequent calls of this\n * function are made until there's no flags set meaning that all of the\n * changes have been made.\n */\n", "func_signal": "static uint32_t usermod_setfields(struct usermod_state *s, uint16_t *level,\n\t\t\t\t  union samr_UserInfo *i)", "code": "{\n\tif (s->change.fields == 0) return s->change.fields;\n\n\t*level = 0;\n\n\tif ((s->change.fields & USERMOD_FIELD_ACCOUNT_NAME) &&\n\t    (*level == 0 || *level == 7)) {\n\t\t*level = 7;\n\t\ti->info7.account_name.string = s->change.account_name;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_ACCOUNT_NAME;\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_FULL_NAME) &&\n\t    (*level == 0 || *level == 8)) {\n\t\t*level = 8;\n\t\ti->info8.full_name.string = s->change.full_name;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_FULL_NAME;\n\t}\n\t\n\tif ((s->change.fields & USERMOD_FIELD_DESCRIPTION) &&\n\t    (*level == 0 || *level == 13)) {\n\t\t*level = 13;\n\t\ti->info13.description.string = s->change.description;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_DESCRIPTION;\t\t\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_COMMENT) &&\n\t    (*level == 0 || *level == 2)) {\n\t\t*level = 2;\n\t\t\n\t\tif (s->stage == USERMOD_QUERY) {\n\t\t\t/* the user info is obtained, so now set the required field */\n\t\t\ti->info2.comment.string = s->change.comment;\n\t\t\ts->change.fields ^= USERMOD_FIELD_COMMENT;\n\t\t\t\n\t\t} else {\n\t\t\t/* we need to query the user info before setting one field in it */\n\t\t\ts->stage = USERMOD_QUERY;\n\t\t\treturn s->change.fields;\n\t\t}\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_LOGON_SCRIPT) &&\n\t    (*level == 0 || *level == 11)) {\n\t\t*level = 11;\n\t\ti->info11.logon_script.string = s->change.logon_script;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_LOGON_SCRIPT;\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_PROFILE_PATH) &&\n\t    (*level == 0 || *level == 12)) {\n\t\t*level = 12;\n\t\ti->info12.profile_path.string = s->change.profile_path;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_PROFILE_PATH;\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_HOME_DIRECTORY) &&\n\t    (*level == 0 || *level == 10)) {\n\t\t*level = 10;\n\t\t\n\t\tif (s->stage == USERMOD_QUERY) {\n\t\t\ti->info10.home_directory.string = s->change.home_directory;\n\t\t\ts->change.fields ^= USERMOD_FIELD_HOME_DIRECTORY;\n\t\t} else {\n\t\t\ts->stage = USERMOD_QUERY;\n\t\t\treturn s->change.fields;\n\t\t}\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_HOME_DRIVE) &&\n\t    (*level == 0 || *level == 10)) {\n\t\t*level = 10;\n\t\t\n\t\tif (s->stage == USERMOD_QUERY) {\n\t\t\ti->info10.home_drive.string = s->change.home_drive;\n\t\t\ts->change.fields ^= USERMOD_FIELD_HOME_DRIVE;\n\t\t} else {\n\t\t\ts->stage = USERMOD_QUERY;\n\t\t\treturn s->change.fields;\n\t\t}\n\t}\n\t\n\tif ((s->change.fields & USERMOD_FIELD_ACCT_EXPIRY) &&\n\t    (*level == 0 || *level == 17)) {\n\t\t*level = 17;\n\t\ti->info17.acct_expiry = timeval_to_nttime(s->change.acct_expiry);\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_ACCT_EXPIRY;\n\t}\n\n\tif ((s->change.fields & USERMOD_FIELD_ACCT_FLAGS) &&\n\t    (*level == 0 || *level == 16)) {\n\t\t*level = 16;\n\t\ti->info16.acct_flags = s->change.acct_flags;\n\t\t\n\t\ts->change.fields ^= USERMOD_FIELD_ACCT_FLAGS;\n\t}\n\n\t/* We're going to be here back again soon unless all fields have been set */\n\tif (s->change.fields) {\n\t\ts->stage = USERMOD_OPEN;\n\t} else {\n\t\ts->stage = USERMOD_MODIFY;\n\t}\n\n\treturn s->change.fields;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Event handler for asynchronous request. Handles transition through\n * intermediate stages of the call.\n *\n * @param req rpc call context\n */\n", "func_signal": "static void userdel_handler(struct rpc_request *req)", "code": "{\n\tstruct composite_context *c;\n\tstruct userdel_state *s;\n\tstruct monitor_msg msg;\n\tstruct msg_rpc_lookup_name *msg_lookup;\n\tstruct msg_rpc_open_user *msg_open;\n\n\tc = talloc_get_type(req->async.private, struct composite_context);\n\ts = talloc_get_type(c->private_data, struct userdel_state);\n\t\n\tswitch (s->stage) {\n\tcase USERDEL_LOOKUP:\n\t\tc->status = userdel_lookup(c, s);\n\n\t\t/* monitor message */\n\t\tmsg.type = rpc_lookup_name;\n\t\tmsg_lookup = talloc(s, struct msg_rpc_lookup_name);\n\n\t\tmsg_lookup->rid   = s->lookupname.out.rids.ids;\n\t\tmsg_lookup->count = s->lookupname.out.rids.count;\n\t\tmsg.data = (void*)msg_lookup;\n\t\tmsg.data_size = sizeof(*msg_lookup);\n\t\tbreak;\n\n\tcase USERDEL_OPEN:\n\t\tc->status = userdel_open(c, s);\n\n\t\t/* monitor message */\n\t\tmsg.type = rpc_open_user;\n\t\tmsg_open = talloc(s, struct msg_rpc_open_user);\n\n\t\tmsg_open->rid         = s->openuser.in.rid;\n\t\tmsg_open->access_mask = s->openuser.in.rid;\n\t\tmsg.data = (void*)msg_open;\n\t\tmsg.data_size = sizeof(*msg_open);\n\t\tbreak;\n\n\tcase USERDEL_DELETE:\n\t\tc->status = userdel_delete(c, s);\n\t\t\n\t\t/* monitor message */\n\t\tmsg.type = rpc_delete_user;\n\t\tmsg.data = NULL;\n\t\tmsg.data_size = 0;\n\t\tbreak;\n\t}\n\n\t/* are we ok, so far ? */\n\tif (!NT_STATUS_IS_OK(c->status)) {\n\t\tc->state = COMPOSITE_STATE_ERROR;\n\t}\n\n\t/* call monitor function provided the pointer has been passed */\n\tif (s->monitor_fn) {\n\t\ts->monitor_fn(&msg);\n\t}\n\n\t/* are we done yet */\n\tif (c->state >= COMPOSITE_STATE_DONE &&\n\t    c->async.fn) {\n\t\tc->async.fn(c);\n\t}\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 1: Lookup the user name and resolve it to rid\n */\n", "func_signal": "static NTSTATUS userdel_lookup(struct composite_context *c,\n\t\t\t       struct userdel_state *s)", "code": "{\n\t/* receive samr_LookupNames result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\t/* what to do when there's no user account to delete\n\t   and what if there's more than one rid resolved */\n\tif (!s->lookupname.out.rids.count) {\n\t\tc->status = NT_STATUS_NO_SUCH_USER;\n\t\tcomposite_error(c, c->status);\n\n\t} else if (!s->lookupname.out.rids.count > 1) {\n\t\tc->status = NT_STATUS_INVALID_ACCOUNT_NAME;\n\t\tcomposite_error(c, c->status);\n\t}\n\n\t/* prepare the next rpc call arguments */\n\ts->openuser.in.domain_handle = &s->domain_handle;\n\ts->openuser.in.rid           = s->lookupname.out.rids.ids[0];\n\ts->openuser.in.access_mask   = SEC_FLAG_MAXIMUM_ALLOWED;\n\ts->openuser.out.user_handle  = &s->user_handle;\n\n\t/* send rpc request */\n\ts->req = dcerpc_samr_OpenUser_send(s->pipe, c, &s->openuser);\n\tif (s->req == NULL) return NT_STATUS_NO_MEMORY;\n\n\t/* callback handler setup */\n\ts->req->async.callback = userdel_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERDEL_OPEN;\n\t\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Stage 2: Open user account.\n */\n", "func_signal": "static NTSTATUS userdel_open(struct composite_context *c,\n\t\t\t     struct userdel_state *s)", "code": "{\n\t/* receive samr_OpenUser result */\n\tc->status = dcerpc_ndr_request_recv(s->req);\n\tNT_STATUS_NOT_OK_RETURN(c->status);\n\n\t/* prepare the final rpc call arguments */\n\ts->deleteuser.in.user_handle   = &s->user_handle;\n\ts->deleteuser.out.user_handle  = &s->user_handle;\n\t\n\t/* send rpc request */\n\ts->req = dcerpc_samr_DeleteUser_send(s->pipe, c, &s->deleteuser);\n\tif (s->req == NULL) return NT_STATUS_NO_MEMORY;\n\n\t/* callback handler setup */\n\ts->req->async.callback = userdel_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERDEL_DELETE;\n\t\n\treturn NT_STATUS_OK;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/**\n * Sends asynchronous userdel request\n *\n * @param p dce/rpc call pipe\n * @param io arguments and results of the call\n * @param monitor monitor function for providing information about the progress\n */\n", "func_signal": "struct composite_context *libnet_rpc_userdel_send(struct dcerpc_pipe *p,\n\t\t\t\t\t\t  struct libnet_rpc_userdel *io,\n\t\t\t\t\t\t  void (*monitor)(struct monitor_msg*))", "code": "{\n\tstruct composite_context *c;\n\tstruct userdel_state *s;\n\n\t/* composite context allocation and setup */\n\tc = talloc_zero(p, struct composite_context);\n\tif (c == NULL) return NULL;\n\n\ts = talloc_zero(c, struct userdel_state);\n\tif (composite_nomem(s, c)) return c;\n\n\tc->state         = COMPOSITE_STATE_IN_PROGRESS;\n\tc->private_data  = s;\n\tc->event_ctx     = dcerpc_event_context(p);\n\n\t/* store function parameters in the state structure */\n\ts->pipe          = p;\n\ts->domain_handle = io->in.domain_handle;\n\ts->monitor_fn    = monitor;\n\t\n\t/* preparing parameters to send rpc request */\n\ts->lookupname.in.domain_handle = &io->in.domain_handle;\n\ts->lookupname.in.num_names     = 1;\n\ts->lookupname.in.names         = talloc_zero(s, struct lsa_String);\n\ts->lookupname.in.names->string = io->in.username;\n\n\t/* send the request */\n\ts->req = dcerpc_samr_LookupNames_send(p, c, &s->lookupname);\n\n\t/* callback handler setup */\n\ts->req->async.callback = userdel_handler;\n\ts->req->async.private  = c;\n\ts->stage = USERDEL_LOOKUP;\n\n\treturn c;\n}", "path": "Samba\\source\\libnet\\userman.c", "repo_name": "skmcclure/WMI_cmd", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 4872}
{"docstring": "/*\n * _inaddr   (pa,dip,di)\n */\n", "func_signal": "static adns_status pa_inaddr(const parseinfo *pai, int cbyte,\n\t\t\t     int max, void *datap)", "code": "{\n  struct in_addr *storeto= datap;\n  \n  if (max-cbyte != 4) return adns_s_invaliddata;\n  memcpy(storeto, pai->dgram + cbyte, 4);\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _flat   (mf)\n */\n", "func_signal": "static void mf_flat(adns_query qu, void *data)", "code": "{ }\n\n/*\n * Now the table.\n */\n\n#define TYPESZ_M(member)           (sizeof(*((adns_answer*)0)->rrs.member))\n\n#define DEEP_MEMB(memb) TYPESZ_M(memb), mf_##memb, cs_##memb\n#define FLAT_MEMB(memb) TYPESZ_M(memb), mf_flat, cs_##memb\n\n#define DEEP_TYPE(code,rrt,fmt,memb,parser,comparer,printer)\t\\\n { adns_r_##code, rrt,fmt,TYPESZ_M(memb), mf_##memb,\t\t\\\n      printer,parser,comparer, adns__qdpl_normal,0 }\n#define FLAT_TYPE(code,rrt,fmt,memb,parser,comparer,printer)\t\\\n { adns_r_##code, rrt,fmt,TYPESZ_M(memb), mf_flat,\t\t\\\n     printer,parser,comparer, adns__qdpl_normal,0 }\n#define XTRA_TYPE(code,rrt,fmt,memb,parser,comparer,printer,qdpl,postsort) \\\n { adns_r_##code, rrt,fmt,TYPESZ_M(memb), mf_##memb,\t\t\t   \\\n    printer,parser,comparer,qdpl,postsort }\n\nstatic const typeinfo typeinfos[] = {\n/* Must be in ascending order of rrtype ! */\n/* mem-mgmt code  rrt     fmt   member   parser      comparer  printer */\n\nFLAT_TYPE(a,      \"A\",     0,   inaddr,  pa_inaddr,  di_inaddr,cs_inaddr     ),\nDEEP_TYPE(ns_raw, \"NS\",   \"raw\",str,     pa_host_raw,0,        cs_domain     ),\nDEEP_TYPE(cname,  \"CNAME\", 0,   str,     pa_dom_raw, 0,        cs_domain     ),\nDEEP_TYPE(soa_raw,\"SOA\",  \"raw\",soa,     pa_soa,     0,        cs_soa        ),\nDEEP_TYPE(ptr_raw,\"PTR\",  \"raw\",str,     pa_host_raw,0,        cs_domain     ),\nDEEP_TYPE(hinfo,  \"HINFO\", 0, intstrpair,pa_hinfo,   0,        cs_hinfo      ),\nDEEP_TYPE(mx_raw, \"MX\",   \"raw\",intstr,  pa_mx_raw,  di_mx_raw,cs_inthost    ),\nDEEP_TYPE(txt,    \"TXT\",   0,   manyistr,pa_txt,     0,        cs_txt        ),\nDEEP_TYPE(rp_raw, \"RP\",   \"raw\",strpair, pa_rp,      0,        cs_rp         ),\nXTRA_TYPE(srv_raw,\"SRV\",  \"raw\",srvraw , pa_srvraw,  di_srv,   cs_srvraw,\n\t                                               qdpl_srv, postsort_srv),\n\nFLAT_TYPE(addr,   \"A\",  \"addr\", addr,    pa_addr,    di_addr,  cs_addr       ),\nDEEP_TYPE(ns,     \"NS\", \"+addr\",hostaddr,pa_hostaddr,di_hostaddr,cs_hostaddr ),\nDEEP_TYPE(ptr,    \"PTR\",\"checked\",str,   pa_ptr,     0,        cs_domain     ),\nDEEP_TYPE(mx,     \"MX\", \"+addr\",inthostaddr,pa_mx,   di_mx,    cs_inthostaddr),\nXTRA_TYPE(srv,    \"SRV\",\"+addr\",srvha,   pa_srvha,   di_srv,   cs_srvha,\n          \t                                       qdpl_srv, postsort_srv),\n\nDEEP_TYPE(soa,    \"SOA\",\"822\",  soa,     pa_soa,     0,        cs_soa        ),\nDEEP_TYPE(rp,     \"RP\", \"822\",  strpair, pa_rp,      0,        cs_rp         ),\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _strpair   (mf)\n */\n", "func_signal": "static void mf_strpair(adns_query qu, void *datap)", "code": "{\n  adns_rr_strpair *rrp= datap;\n\n  adns__makefinal_str(qu,&rrp->array[0]);\n  adns__makefinal_str(qu,&rrp->array[1]);\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/* SIGPIPE protection. */\n", "func_signal": "void adns__sigpipe_protect(adns_state ads)", "code": "{\n  sigset_t toblock;\n  struct sigaction sa;\n  int r;\n\n  if (ads->iflags & adns_if_nosigpipe) return;\n\n  sigfillset(&toblock);\n  sigdelset(&toblock,SIGPIPE);\n\n  sa.sa_handler= SIG_IGN;\n  sigfillset(&sa.sa_mask);\n  sa.sa_flags= 0;\n  \n  r= sigprocmask(SIG_SETMASK,&toblock,&ads->stdsigmask); assert(!r);\n  r= sigaction(SIGPIPE,&sa,&ads->stdsigpipe); assert(!r);\n}", "path": "src\\general.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _hinfo   (pa)\n */\n", "func_signal": "static adns_status pa_hinfo(const parseinfo *pai, int cbyte,\n\t\t\t    int max, void *datap)", "code": "{\n  adns_rr_intstrpair *rrp= datap;\n  adns_status st;\n  int i;\n\n  for (i=0; i<2; i++) {\n    st= pap_qstring(pai, &cbyte, max, &rrp->array[i].i, &rrp->array[i].str);\n    if (st) return st;\n  }\n\n  if (cbyte != max) return adns_s_invaliddata;\n  \n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _inthostaddr  (mf,cs)\n */\n", "func_signal": "static void mf_inthostaddr(adns_query qu, void *datap)", "code": "{\n  adns_rr_inthostaddr *rrp= datap;\n\n  mfp_hostaddr(qu,&rrp->ha);\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _byteblock   (mf)\n */\n", "func_signal": "static void mf_byteblock(adns_query qu, void *datap)", "code": "{\n  adns_rr_byteblock *rrp= datap;\n  void *bytes= rrp->data;\n  adns__makefinal_block(qu,&bytes,rrp->len);\n  rrp->data= bytes;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _txt   (pa,cs)\n */\n", "func_signal": "static adns_status pa_txt(const parseinfo *pai, int cbyte,\n\t\t\t  int max, void *datap)", "code": "{\n  adns_rr_intstr **rrp= datap, *table, *te;\n  const byte *dgram= pai->dgram;\n  int ti, tc, l, startbyte;\n  adns_status st;\n\n  startbyte= cbyte;\n  if (cbyte >= max) return adns_s_invaliddata;\n  tc= 0;\n  while (cbyte < max) {\n    GET_B(cbyte,l);\n    cbyte+= l;\n    tc++;\n  }\n  if (cbyte != max || !tc) return adns_s_invaliddata;\n\n  table= adns__alloc_interim(pai->qu,sizeof(*table)*(tc+1));\n  if (!table) R_NOMEM;\n\n  for (cbyte=startbyte, ti=0, te=table; ti<tc; ti++, te++) {\n    st= pap_qstring(pai, &cbyte, max, &te->i, &te->str);\n    if (st) return st;\n  }\n  assert(cbyte == max);\n\n  te->i= -1;\n  te->str= 0;\n  \n  *rrp= table;\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _ptr   (pa, +icb_ptr)\n */\n", "func_signal": "static void icb_ptr(adns_query parent, adns_query child)", "code": "{\n  adns_answer *cans= child->answer;\n  const adns_rr_addr *queried, *found;\n  adns_state ads= parent->ads;\n  int i;\n\n  if (cans->status == adns_s_nxdomain || cans->status == adns_s_nodata) {\n    adns__query_fail(parent,adns_s_inconsistent);\n    return;\n  } else if (cans->status) {\n    adns__query_fail(parent,cans->status);\n    return;\n  }\n\n  queried= &parent->ctx.info.ptr_parent_addr;\n  for (i=0, found=cans->rrs.addr; i<cans->nrrs; i++, found++) {\n    if (queried->len == found->len &&\n\t!memcmp(&queried->addr,&found->addr,queried->len)) {\n      if (!parent->children.head) {\n\tadns__query_done(parent);\n\treturn;\n      } else {\n\tLIST_LINK_TAIL(ads->childw,parent);\n\treturn;\n      }\n    }\n  }\n\n  adns__query_fail(parent,adns_s_inconsistent);\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _manyistr   (mf)\n */\n", "func_signal": "static void mf_manyistr(adns_query qu, void *datap)", "code": "{\n  adns_rr_intstr **rrp= datap;\n  adns_rr_intstr *te, *table;\n  void *tablev;\n  int tc;\n\n  for (tc=0, te= *rrp; te->i >= 0; te++, tc++);\n  tablev= *rrp;\n  adns__makefinal_block(qu,&tablev,sizeof(*te)*(tc+1));\n  *rrp= table= tablev;\n  for (te= *rrp; te->i >= 0; te++)\n    adns__makefinal_str(qu,&te->str);\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _srv*  (pa*2,di,cs*2,qdpl,postsort)\n */\n", "func_signal": "static adns_status qdpl_srv(adns_state ads,\n\t\t\t    const char **p_io, const char *pe, int labelnum,\n\t\t\t    char label_r[DNS_MAXDOMAIN], int *ll_io,\n\t\t\t    adns_queryflags flags,\n\t\t\t    const typeinfo *typei)", "code": "{\n  int useflags;\n  const char *p_orig;\n  adns_status st;\n\n  if (labelnum < 2 && !(flags & adns_qf_quoteok_query)) {\n    useflags= adns_qf_quoteok_query;\n    p_orig= *p_io;\n  } else {\n    useflags= flags;\n    p_orig= 0;\n  }\n  st= adns__qdpl_normal(ads, p_io,pe, labelnum,label_r, ll_io, useflags,typei);\n  if (st) return st;\n\n  if (p_orig) {\n    int ll= *ll_io;\n    if (!ll || label_r[0]!='_')\n      return adns_s_querydomaininvalid;\n    if (memchr(p_orig+1, '\\\\', pe - (p_orig+1)))\n      return adns_s_querydomaininvalid;\n  }\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _intstrpair   (mf)\n */\n", "func_signal": "static void mf_intstrpair(adns_query qu, void *datap)", "code": "{\n  adns_rr_intstrpair *rrp= datap;\n\n  adns__makefinal_str(qu,&rrp->array[0].str);\n  adns__makefinal_str(qu,&rrp->array[1].str);\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/* Additional diagnostic functions */\n", "func_signal": "const char *adns__diag_domain(adns_state ads, int serv, adns_query qu,\n\t\t\t      vbuf *vb, const byte *dgram,\n\t\t\t      int dglen, int cbyte)", "code": "{\n  adns_status st;\n\n  st= adns__parse_domain(ads,serv,qu,vb, pdf_quoteok,\n\t\t\t dgram,dglen,&cbyte,dglen);\n  if (st == adns_s_nomemory) {\n    return \"<cannot report domain... out of memory>\";\n  }\n  if (st) {\n    vb->used= 0;\n    if (!(adns__vbuf_appendstr(vb,\"<bad format... \") &&\n\t  adns__vbuf_appendstr(vb,adns_strerror(st)) &&\n\t  adns__vbuf_appendstr(vb,\">\") &&\n\t  adns__vbuf_append(vb,\"\",1))) {\n      return \"<cannot report bad format... out of memory>\";\n    }\n  }\n  if (!vb->used) {\n    adns__vbuf_appendstr(vb,\"<truncated ...>\");\n    adns__vbuf_append(vb,\"\",1);\n  }\n  return vb->buf;\n}", "path": "src\\general.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/* General helpful functions. */\n", "func_signal": "void adns_globalsystemfailure(adns_state ads)", "code": "{\n  adns__consistency(ads,0,cc_entex);\n\n  while (ads->udpw.head) adns__query_fail(ads->udpw.head, adns_s_systemfail);\n  while (ads->tcpw.head) adns__query_fail(ads->tcpw.head, adns_s_systemfail);\n  \n  switch (ads->tcpstate) {\n  case server_connecting:\n  case server_ok:\n    adns__tcp_broken(ads,0,0);\n    break;\n  case server_disconnected:\n  case server_broken:\n    break;\n  default:\n    abort();\n  }\n  adns__consistency(ads,0,cc_entex);\n}", "path": "src\\event.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _mx_raw   (pa,di)\n */\n", "func_signal": "static adns_status pa_mx_raw(const parseinfo *pai, int cbyte,\n\t\t\t     int max, void *datap)", "code": "{\n  const byte *dgram= pai->dgram;\n  adns_rr_intstr *rrp= datap;\n  adns_status st;\n  int pref;\n\n  if (cbyte+2 > max) return adns_s_invaliddata;\n  GET_W(cbyte,pref);\n  rrp->i= pref;\n  st= pap_domain(pai, &cbyte, max, &rrp->str,\n\t\t pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);\n  if (st) return st;\n  \n  if (cbyte != max) return adns_s_invaliddata;\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _mailbox   (pap,cs)\n */\n", "func_signal": "static adns_status pap_mailbox822(const parseinfo *pai,\n\t\t\t\t  int *cbyte_io, int max, char **mb_r)", "code": "{\n  int lablen, labstart, i, needquote, c, r, neednorm;\n  const unsigned char *p;\n  char *str;\n  findlabel_state fls;\n  adns_status st;\n  vbuf *vb;\n\n  vb= &pai->qu->vb;\n  vb->used= 0;\n  adns__findlabel_start(&fls, pai->ads,\n\t\t\t-1, pai->qu,\n\t\t\tpai->dgram, pai->dglen, max,\n\t\t\t*cbyte_io, cbyte_io);\n  st= adns__findlabel_next(&fls,&lablen,&labstart);\n  if (!lablen) {\n    adns__vbuf_appendstr(vb,\".\");\n    goto x_ok;\n  }\n\n  neednorm= 1;\n  for (i=0, needquote=0, p= pai->dgram+labstart; i<lablen; i++) {\n    c= *p++;\n    if ((c&~128) < 32 || (c&~128) == 127) return adns_s_invaliddata;\n    if (c == '.' && !neednorm) neednorm= 1;\n    else if (c==' ' || c>=127 || ctype_822special(c)) needquote++;\n    else neednorm= 0;\n  }\n\n  if (needquote || neednorm) {\n    r= adns__vbuf_ensure(vb, lablen+needquote+4); if (!r) R_NOMEM;\n    adns__vbuf_appendq(vb,\"\\\"\",1);\n    for (i=0, needquote=0, p= pai->dgram+labstart; i<lablen; i++, p++) {\n      c= *p;\n      if (c == '\"' || c=='\\\\') adns__vbuf_appendq(vb,\"\\\\\",1);\n      adns__vbuf_appendq(vb,p,1);\n    }\n    adns__vbuf_appendq(vb,\"\\\"\",1);\n  } else {\n    r= adns__vbuf_append(vb, pai->dgram+labstart, lablen); if (!r) R_NOMEM;\n  }\n\n  r= adns__vbuf_appendstr(vb,\"@\"); if (!r) R_NOMEM;\n\n  st= adns__parse_domain_more(&fls,pai->ads, pai->qu,vb,0, pai->dgram);\n  if (st) return st;\n\n x_ok:\n  str= adns__alloc_interim(pai->qu, vb->used+1); if (!str) R_NOMEM;\n  memcpy(str,vb->buf,vb->used);\n  str[vb->used]= 0;\n  *mb_r= str;\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _hostaddr   (pap,pa,dip,di,mfp,mf,csp,cs +icb_hostaddr, pap_findaddrs)\n */\n", "func_signal": "static adns_status pap_findaddrs(const parseinfo *pai, adns_rr_hostaddr *ha,\n\t\t\t\t int *cbyte_io, int count, int dmstart)", "code": "{\n  int rri, naddrs;\n  int type, class, rdlen, rdstart, ownermatched;\n  unsigned long ttl;\n  adns_status st;\n  \n  for (rri=0, naddrs=-1; rri<count; rri++) {\n    st= adns__findrr_anychk(pai->qu, pai->serv, pai->dgram,\n\t\t\t    pai->dglen, cbyte_io,\n\t\t\t    &type, &class, &ttl, &rdlen, &rdstart,\n\t\t\t    pai->dgram, pai->dglen, dmstart, &ownermatched);\n    if (st) return st;\n    if (!ownermatched || class != DNS_CLASS_IN || type != adns_r_a) {\n      if (naddrs>0) break; else continue;\n    }\n    if (naddrs == -1) {\n      naddrs= 0;\n    }\n    if (!adns__vbuf_ensure(&pai->qu->vb, (naddrs+1)*sizeof(adns_rr_addr)))\n      R_NOMEM;\n    adns__update_expires(pai->qu,ttl,pai->now);\n    st= pa_addr(pai, rdstart,rdstart+rdlen,\n\t\tpai->qu->vb.buf + naddrs*sizeof(adns_rr_addr));\n    if (st) return st;\n    naddrs++;\n  }\n  if (naddrs >= 0) {\n    ha->addrs= adns__alloc_interim(pai->qu, naddrs*sizeof(adns_rr_addr));\n    if (!ha->addrs) R_NOMEM;\n    memcpy(ha->addrs, pai->qu->vb.buf, naddrs*sizeof(adns_rr_addr));\n    ha->naddrs= naddrs;\n    ha->astatus= adns_s_ok;\n\n    adns__isort(ha->addrs, naddrs, sizeof(adns_rr_addr), pai->qu->vb.buf,\n\t\tdiv_addr, pai->ads);\n  }\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _host_raw   (pa)\n */\n", "func_signal": "static adns_status pa_host_raw(const parseinfo *pai, int cbyte,\n\t\t\t       int max, void *datap)", "code": "{\n  char **rrp= datap;\n  adns_status st;\n\n  st= pap_domain(pai, &cbyte, max, rrp,\n\t\t pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);\n  if (st) return st;\n  \n  if (cbyte != max) return adns_s_invaliddata;\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/*\n * _hinfo   (cs)\n */\n", "func_signal": "static adns_status cs_hinfo(vbuf *vb, const void *datap)", "code": "{\n  const adns_rr_intstrpair *rrp= datap;\n  adns_status st;\n\n  st= csp_qstring(vb,rrp->array[0].str,rrp->array[0].i);  if (st) return st;\n  CSP_ADDSTR(\" \");\n  st= csp_qstring(vb,rrp->array[1].str,rrp->array[1].i);  if (st) return st;\n  return adns_s_ok;\n}", "path": "src\\types.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/* Wrappers for select(2). */\n", "func_signal": "void adns_beforeselect(adns_state ads, int *maxfd_io, fd_set *readfds_io,\n\t\t       fd_set *writefds_io, fd_set *exceptfds_io,\n\t\t       struct timeval **tv_mod, struct timeval *tv_tobuf,\n\t\t       const struct timeval *now)", "code": "{\n  struct timeval tv_nowbuf;\n  struct pollfd pollfds[MAX_POLLFDS];\n  int i, fd, maxfd, npollfds;\n  \n  adns__consistency(ads,0,cc_entex);\n\n  if (tv_mod && (!*tv_mod || (*tv_mod)->tv_sec || (*tv_mod)->tv_usec)) {\n    /* The caller is planning to sleep. */\n    adns__must_gettimeofday(ads,&now,&tv_nowbuf);\n    if (!now) { inter_immed(tv_mod,tv_tobuf); goto xit; }\n    adns__timeouts(ads, 0, tv_mod,tv_tobuf, *now);\n  }\n\n  npollfds= adns__pollfds(ads,pollfds);\n  maxfd= *maxfd_io;\n  for (i=0; i<npollfds; i++) {\n    fd= pollfds[i].fd;\n    if (fd >= maxfd) maxfd= fd+1;\n    if (pollfds[i].events & POLLIN) FD_SET(fd,readfds_io);\n    if (pollfds[i].events & POLLOUT) FD_SET(fd,writefds_io);\n    if (pollfds[i].events & POLLPRI) FD_SET(fd,exceptfds_io);\n  }\n  *maxfd_io= maxfd;\n\nxit:\n  adns__consistency(ads,0,cc_entex);\n}", "path": "src\\event.c", "repo_name": "lucab/adns", "stars": 17, "license": "gpl-2.0", "language": "c", "size": 632}
{"docstring": "/* create a ogg_packet from a fishead_packet structure */\n", "func_signal": "ogg_packet ogg_from_fishead(fishead_packet *fp)", "code": "{\n\n    ogg_packet op;\n\n    memset(&op, 0, sizeof(op));\n    op.packet = _ogg_calloc(FISHEAD_SIZE, sizeof(unsigned char));\n    memset(op.packet, 0, FISHEAD_SIZE);\n\n    memcpy (op.packet, FISHEAD_IDENTIFIER, 8); /* identifier */\n    *((ogg_uint16_t*)(op.packet+8)) = SKELETON_VERSION_MAJOR; /* version major */\n    *((ogg_uint16_t*)(op.packet+10)) = SKELETON_VERSION_MINOR; /* version minor */\n    *((ogg_int64_t*)(op.packet+12)) = (ogg_int64_t)fp->ptime_n; /* presentationtime numerator */\n    *((ogg_int64_t*)(op.packet+20)) = (ogg_int64_t)fp->ptime_d; /* presentationtime denominator */\n    *((ogg_int64_t*)(op.packet+28)) = (ogg_int64_t)fp->btime_n; /* basetime numerator */\n    *((ogg_int64_t*)(op.packet+36)) = (ogg_int64_t)fp->btime_d; /* basetime denominator */\n    /* TODO: UTC time, set to zero for now */\n\n    op.b_o_s = 1;   /* its the first packet of the stream */\n    op.e_o_s = 0;   /* its not the last packet of the stream */\n    op.bytes = FISHEAD_SIZE;  /* length of the packet in bytes */\n\n    return op;\n}", "path": "src\\skeleton.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* fills up a fisbone_packet from a fisbone ogg_packet of a skeleton bitstream */\n", "func_signal": "fisbone_packet fisbone_from_ogg(ogg_packet *op)", "code": "{\n\n    fisbone_packet fp;\n    \n    if (memcmp(op->packet, FISBONE_IDENTIFIER, 8))\n\t; /* invalid value, what do we do? */\n    fp.serial_no = *((ogg_uint32_t*)(op->packet+12)); /* serialno of the stream represented by this fisbone packet */\n    fp.nr_header_packet = *((ogg_uint32_t*)(op->packet+16)); /* number of header packets */\n    fp.granule_rate_n = *((ogg_int64_t*)(op->packet+20)); /* granulrate numerator */\n    fp.granule_rate_d = *((ogg_int64_t*)(op->packet+28)); /* granulrate denominator */\n    fp.start_granule = *((ogg_int64_t*)(op->packet+36)); /* start granule */\n    fp.preroll = *((ogg_uint32_t*)(op->packet+44)); /* preroll, for theora its 0 */\n    fp.granule_shift = *(op->packet+48); /* granule shift */\n    fp.current_header_size = op->bytes - FISBONE_SIZE;\n    fp.message_header_fields = _ogg_calloc(fp.current_header_size+1, sizeof(char));\n    memcpy(fp.message_header_fields, op->packet+FISBONE_SIZE, fp.current_header_size);\n\n    return fp;\n}", "path": "src\\skeleton.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "static int _jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   spx_int16_t opt = compute_opt_delay(jitter);\n   /*fprintf(stderr, \"opt adjustment is %d \", opt);*/\n   \n   if (opt < 0)\n   {\n      shift_timings(jitter, -opt);\n      \n      jitter->pointer_timestamp += opt;\n      jitter->interp_requested = -opt;\n      /*fprintf (stderr, \"Decision to interpolate %d samples\\n\", -opt);*/\n   } else if (opt > 0)\n   {\n      shift_timings(jitter, -opt);\n      jitter->pointer_timestamp += opt;\n      /*fprintf (stderr, \"Decision to drop %d samples\\n\", opt);*/\n   }\n   \n   return opt;\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n   Input in Q11 format, output in Q15\n*/\n", "func_signal": "static inline spx_word32_t hypergeom_gain(spx_word32_t xx)", "code": "{\n   int ind;\n   spx_word16_t frac;\n   /* Q13 table */\n   static const spx_word16_t table[21] = {\n       6730,  8357,  9868, 11267, 12563, 13770, 14898,\n      15959, 16961, 17911, 18816, 19682, 20512, 21311,\n      22082, 22827, 23549, 24250, 24931, 25594, 26241};\n      ind = SHR32(xx,10);\n      if (ind<0)\n         return Q15_ONE;\n      if (ind>19)\n         return ADD32(EXTEND32(Q15_ONE),EXTEND32(DIV32_16(QCONST32(.1296,23), SHR32(xx,EXPIN_SHIFT-SNR_SHIFT))));\n      frac = SHL32(xx-SHL32(ind,10),5);\n      return SHL32(DIV32_16(PSHR32(MULT16_16(Q15_ONE-frac,table[ind]) + MULT16_16(frac,table[ind+1]),7),(spx_sqrt(SHL32(xx,15)+6711))),7);\n}", "path": "libspeex\\preprocess.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* fills up a fishead_packet from a fishead ogg_packet of a skeleton bistream */\n", "func_signal": "fishead_packet fishead_from_ogg(ogg_packet *op)", "code": "{\n\t\n    fishead_packet fp;\n\n    if (memcmp(op->packet, FISHEAD_IDENTIFIER, 8))\n\t; /* invalid packet what do we do? */\n\n    fp.version_major = *((ogg_uint16_t*)(op->packet+8)); /* version major */\n    fp.version_minor = *((ogg_uint16_t*)(op->packet+10)); /* version minor */\n    fp.ptime_n = *((ogg_int64_t*)(op->packet+12)); /* presentationtime numerator */\n    fp.ptime_d = *((ogg_int64_t*)(op->packet+20)); /* presentationtime denominator */\n    fp.btime_n = *((ogg_int64_t*)(op->packet+28)); /* basetime numerator */\n    fp.btime_d = *((ogg_int64_t*)(op->packet+36)); /* basetime denominator */\n    memcpy(fp.UTC, op->packet+44, 20);\n\n    return fp;\n}", "path": "src\\skeleton.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* Add the timing of a new packet to the TimingBuffer */\n", "func_signal": "static void tb_add(struct TimingBuffer *tb, spx_int16_t timing)", "code": "{\n   int pos;\n   /* Discard packet that won't make it into the list because they're too early */\n   if (tb->filled >= MAX_TIMINGS && timing >= tb->timing[tb->filled-1])\n   {\n      tb->curr_count++;\n      return;\n   }\n   \n   /* Find where the timing info goes in the sorted list */\n   pos = 0;\n   /* FIXME: Do bisection instead of linear search */\n   while (pos<tb->filled && timing >= tb->timing[pos])\n   {\n      pos++;\n   }\n   \n   speex_assert(pos <= tb->filled && pos < MAX_TIMINGS);\n   \n   /* Shift everything so we can perform the insertion */\n   if (pos < tb->filled)\n   {\n      int move_size = tb->filled-pos;\n      if (tb->filled == MAX_TIMINGS)\n         move_size -= 1;\n      SPEEX_MOVE(&tb->timing[pos+1], &tb->timing[pos], move_size);\n      SPEEX_MOVE(&tb->counts[pos+1], &tb->counts[pos], move_size);\n   }\n   /* Insert */\n   tb->timing[pos] = timing;\n   tb->counts[pos] = tb->curr_count;\n   \n   tb->curr_count++;\n   if (tb->filled<MAX_TIMINGS)\n      tb->filled++;\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* Let the jitter buffer know it's the right time to adjust the buffering delay to the network conditions */\n", "func_signal": "EXPORT int jitter_buffer_update_delay(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t *start_offset)", "code": "{\n   /* If the programmer calls jitter_buffer_update_delay() directly, \n      automatically disable auto-adjustment */\n   jitter->auto_adjust = 0;\n\n   return _jitter_buffer_update_delay(jitter, packet, start_offset);\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Initialise jitter buffer */\n", "func_signal": "EXPORT JitterBuffer *jitter_buffer_init(int step_size)", "code": "{\n   JitterBuffer *jitter = (JitterBuffer*)speex_alloc(sizeof(JitterBuffer));\n   if (jitter)\n   {\n      int i;\n      spx_int32_t tmp;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         jitter->packets[i].data=NULL;\n      jitter->delay_step = step_size;\n      jitter->concealment_size = step_size;\n      /*FIXME: Should this be 0 or 1?*/\n      jitter->buffer_margin = 0;\n      jitter->late_cutoff = 50;\n      jitter->destroy = NULL;\n      jitter->latency_tradeoff = 0;\n      jitter->auto_adjust = 1;\n      tmp = 4;\n      jitter_buffer_ctl(jitter, JITTER_BUFFER_SET_MAX_LATE_RATE, &tmp);\n      jitter_buffer_reset(jitter);\n   }\n   return jitter;\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* Used like the ioctl function to control the jitter buffer parameters */\n", "func_signal": "EXPORT int jitter_buffer_ctl(JitterBuffer *jitter, int request, void *ptr)", "code": "{\n   int count, i;\n   switch(request)\n   {\n      case JITTER_BUFFER_SET_MARGIN:\n         jitter->buffer_margin = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_MARGIN:\n         *(spx_int32_t*)ptr = jitter->buffer_margin;\n         break;\n      case JITTER_BUFFER_GET_AVALIABLE_COUNT:\n         count = 0;\n         for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n         {\n            if (jitter->packets[i].data && LE32(jitter->pointer_timestamp, jitter->packets[i].timestamp))\n            {\n               count++;\n            }\n         }\n         *(spx_int32_t*)ptr = count;\n         break;\n      case JITTER_BUFFER_SET_DESTROY_CALLBACK:\n         jitter->destroy = (void (*) (void *))ptr;\n         break;\n      case JITTER_BUFFER_GET_DESTROY_CALLBACK:\n         *(void (**) (void *))ptr = jitter->destroy;\n         break;\n      case JITTER_BUFFER_SET_DELAY_STEP:\n         jitter->delay_step = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_DELAY_STEP:\n         *(spx_int32_t*)ptr = jitter->delay_step;\n         break;\n      case JITTER_BUFFER_SET_CONCEALMENT_SIZE:\n         jitter->concealment_size = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_CONCEALMENT_SIZE:\n         *(spx_int32_t*)ptr = jitter->concealment_size;\n         break;\n      case JITTER_BUFFER_SET_MAX_LATE_RATE:\n         jitter->max_late_rate = *(spx_int32_t*)ptr;\n         jitter->window_size = 100*TOP_DELAY/jitter->max_late_rate;\n         jitter->subwindow_size = jitter->window_size/MAX_BUFFERS;\n         break;\n      case JITTER_BUFFER_GET_MAX_LATE_RATE:\n         *(spx_int32_t*)ptr = jitter->max_late_rate;\n         break;\n      case JITTER_BUFFER_SET_LATE_COST:\n         jitter->latency_tradeoff = *(spx_int32_t*)ptr;\n         break;\n      case JITTER_BUFFER_GET_LATE_COST:\n         *(spx_int32_t*)ptr = jitter->latency_tradeoff;\n         break;\n      default:\n         speex_warning_int(\"Unknown jitter_buffer_ctl request: \", request);\n         return -1;\n   }\n   return 0;\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Take the following timing into consideration for future calculations */\n", "func_signal": "static void update_timings(JitterBuffer *jitter, spx_int32_t timing)", "code": "{\n   if (timing < -32767)\n      timing = -32767;\n   if (timing > 32767)\n      timing = 32767;\n   /* If the current sub-window is full, perform a rotation and discard oldest sub-widow */\n   if (jitter->timeBuffers[0]->curr_count >= jitter->subwindow_size)\n   {\n      int i;\n      /*fprintf(stderr, \"Rotate buffer\\n\");*/\n      struct TimingBuffer *tmp = jitter->timeBuffers[MAX_BUFFERS-1];\n      for (i=MAX_BUFFERS-1;i>=1;i--)\n         jitter->timeBuffers[i] = jitter->timeBuffers[i-1];\n      jitter->timeBuffers[0] = tmp;\n      tb_init(jitter->timeBuffers[0]);\n   }\n   tb_add(jitter->timeBuffers[0], timing);\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Put one packet into the jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_put(JitterBuffer *jitter, const JitterBufferPacket *packet)", "code": "{\n   int i,j;\n   int late;\n   /*fprintf (stderr, \"put packet %d %d\\n\", timestamp, span);*/\n   \n   /* Cleanup buffer (remove old packets that weren't played) */\n   if (!jitter->reset_state)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* Make sure we don't discard a \"just-late\" packet in case we want to play it next (if we interpolate). */\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp + jitter->packets[i].span, jitter->pointer_timestamp))\n         {\n            /*fprintf (stderr, \"cleaned (not played)\\n\");*/\n            if (jitter->destroy)\n               jitter->destroy(jitter->packets[i].data);\n            else\n               speex_free(jitter->packets[i].data);\n            jitter->packets[i].data = NULL;\n         }\n      }\n   }\n   \n   /*fprintf(stderr, \"arrival: %d %d %d\\n\", packet->timestamp, jitter->next_stop, jitter->pointer_timestamp);*/\n   /* Check if packet is late (could still be useful though) */\n   if (!jitter->reset_state && LT32(packet->timestamp, jitter->next_stop))\n   {\n      update_timings(jitter, ((spx_int32_t)packet->timestamp) - ((spx_int32_t)jitter->next_stop) - jitter->buffer_margin);\n      late = 1;\n   } else {\n      late = 0;\n   }\n\n   /* For some reason, the consumer has failed the last 20 fetches. Make sure this packet is\n    * used to resync. */\n   if (jitter->lost_count>20)\n   {\n      jitter_buffer_reset(jitter);\n   }\n   \n   /* Only insert the packet if it's not hopelessly late (i.e. totally useless) */\n   if (jitter->reset_state || GE32(packet->timestamp+packet->span+jitter->delay_step, jitter->pointer_timestamp))\n   {\n\n      /*Find an empty slot in the buffer*/\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data==NULL)\n            break;\n      }\n      \n      /*No place left in the buffer, need to make room for it by discarding the oldest packet */\n      if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n      {\n         int earliest=jitter->packets[0].timestamp;\n         i=0;\n         for (j=1;j<SPEEX_JITTER_MAX_BUFFER_SIZE;j++)\n         {\n            if (!jitter->packets[i].data || LT32(jitter->packets[j].timestamp,earliest))\n            {\n               earliest = jitter->packets[j].timestamp;\n               i=j;\n            }\n         }\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data=NULL;\n         /*fprintf (stderr, \"Buffer is full, discarding earliest frame %d (currently at %d)\\n\", timestamp, jitter->pointer_timestamp);*/      \n      }\n   \n      /* Copy packet in buffer */\n      if (jitter->destroy)\n      {\n         jitter->packets[i].data = packet->data;\n      } else {\n         jitter->packets[i].data=(char*)speex_alloc(packet->len);\n         for (j=0;j<packet->len;j++)\n            jitter->packets[i].data[j]=packet->data[j];\n      }\n      jitter->packets[i].timestamp=packet->timestamp;\n      jitter->packets[i].span=packet->span;\n      jitter->packets[i].len=packet->len;\n      jitter->packets[i].sequence=packet->sequence;\n      jitter->packets[i].user_data=packet->user_data;\n      if (jitter->reset_state || late)\n         jitter->arrival[i] = 0;\n      else\n         jitter->arrival[i] = jitter->next_stop;\n   }\n   \n   \n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Get one packet from the jitter buffer */\n", "func_signal": "EXPORT int jitter_buffer_get(JitterBuffer *jitter, JitterBufferPacket *packet, spx_int32_t desired_span, spx_int32_t *start_offset)", "code": "{\n   int i;\n   unsigned int j;\n   int incomplete = 0;\n   spx_int16_t opt;\n   \n   if (start_offset != NULL)\n      *start_offset = 0;\n\n   /* Syncing on the first call */\n   if (jitter->reset_state)\n   {\n      int found = 0;\n      /* Find the oldest packet */\n      spx_uint32_t oldest=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && (!found || LT32(jitter->packets[i].timestamp,oldest)))\n         {\n            oldest = jitter->packets[i].timestamp;\n            found = 1;\n         }\n      }\n      if (found)\n      {\n         jitter->reset_state=0;         \n         jitter->pointer_timestamp = oldest;\n         jitter->next_stop = oldest;\n      } else {\n         packet->timestamp = 0;\n         packet->span = jitter->interp_requested;\n         return JITTER_BUFFER_MISSING;\n      }\n   }\n   \n\n   jitter->last_returned_timestamp = jitter->pointer_timestamp;\n         \n   if (jitter->interp_requested != 0)\n   {\n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = jitter->interp_requested;\n      \n      /* Increment the pointer because it got decremented in the delay update */\n      jitter->pointer_timestamp += jitter->interp_requested;\n      packet->len = 0;\n      /*fprintf (stderr, \"Deferred interpolate\\n\");*/\n      \n      jitter->interp_requested = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n\n      return JITTER_BUFFER_INSERTION;\n   }\n   \n   /* Searching for the packet that fits best */\n   \n   /* Search the buffer for a packet with the right timestamp and spanning the whole current chunk */\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data && jitter->packets[i].timestamp==jitter->pointer_timestamp && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n         break;\n   }\n   \n   /* If no match, try for an \"older\" packet that still spans (fully) the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GE32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp+desired_span))\n            break;\n      }\n   }\n   \n   /* If still no match, try for an \"older\" packet that spans part of the current chunk */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         if (jitter->packets[i].data && LE32(jitter->packets[i].timestamp, jitter->pointer_timestamp) && GT32(jitter->packets[i].timestamp+jitter->packets[i].span,jitter->pointer_timestamp))\n            break;\n      }\n   }\n   \n   /* If still no match, try for earliest packet possible */\n   if (i==SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      int found = 0;\n      spx_uint32_t best_time=0;\n      int best_span=0;\n      int besti=0;\n      for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n      {\n         /* check if packet starts within current chunk */\n         if (jitter->packets[i].data && LT32(jitter->packets[i].timestamp,jitter->pointer_timestamp+desired_span) && GE32(jitter->packets[i].timestamp,jitter->pointer_timestamp))\n         {\n            if (!found || LT32(jitter->packets[i].timestamp,best_time) || (jitter->packets[i].timestamp==best_time && GT32(jitter->packets[i].span,best_span)))\n            {\n               best_time = jitter->packets[i].timestamp;\n               best_span = jitter->packets[i].span;\n               besti = i;\n               found = 1;\n            }\n         }\n      }\n      if (found)\n      {\n         i=besti;\n         incomplete = 1;\n         /*fprintf (stderr, \"incomplete: %d %d %d %d\\n\", jitter->packets[i].timestamp, jitter->pointer_timestamp, chunk_size, jitter->packets[i].span);*/\n      }\n   }\n\n   /* If we find something */\n   if (i!=SPEEX_JITTER_MAX_BUFFER_SIZE)\n   {\n      spx_int32_t offset;\n      \n      /* We (obviously) haven't lost this packet */\n      jitter->lost_count = 0;\n      \n      /* In this case, 0 isn't as a valid timestamp */\n      if (jitter->arrival[i] != 0)\n      {\n         update_timings(jitter, ((spx_int32_t)jitter->packets[i].timestamp) - ((spx_int32_t)jitter->arrival[i]) - jitter->buffer_margin);\n      }\n      \n      \n      /* Copy packet */\n      if (jitter->destroy)\n      {\n         packet->data = jitter->packets[i].data;\n         packet->len = jitter->packets[i].len;\n      } else {\n         if (jitter->packets[i].len > packet->len)\n         {\n            speex_warning_int(\"jitter_buffer_get(): packet too large to fit. Size is\", jitter->packets[i].len);\n         } else {\n            packet->len = jitter->packets[i].len;\n         }\n         for (j=0;j<packet->len;j++)\n            packet->data[j] = jitter->packets[i].data[j];\n         /* Remove packet */\n         speex_free(jitter->packets[i].data);\n      }\n      jitter->packets[i].data = NULL;\n      /* Set timestamp and span (if requested) */\n      offset = (spx_int32_t)jitter->packets[i].timestamp-(spx_int32_t)jitter->pointer_timestamp;\n      if (start_offset != NULL)\n         *start_offset = offset;\n      else if (offset != 0)\n         speex_warning_int(\"jitter_buffer_get() discarding non-zero start_offset\", offset);\n      \n      packet->timestamp = jitter->packets[i].timestamp;\n      jitter->last_returned_timestamp = packet->timestamp;\n      \n      packet->span = jitter->packets[i].span;\n      packet->sequence = jitter->packets[i].sequence;\n      packet->user_data = jitter->packets[i].user_data;\n      /* Point to the end of the current packet */\n      jitter->pointer_timestamp = jitter->packets[i].timestamp+jitter->packets[i].span;\n\n      jitter->buffered = packet->span - desired_span;\n      \n      if (start_offset != NULL)\n         jitter->buffered += *start_offset;\n      \n      return JITTER_BUFFER_OK;\n   }\n   \n   \n   /* If we haven't found anything worth returning */\n   \n   /*fprintf (stderr, \"not found\\n\");*/\n   jitter->lost_count++;\n   /*fprintf (stderr, \"m\");*/\n   /*fprintf (stderr, \"lost_count = %d\\n\", jitter->lost_count);*/\n   \n   opt = compute_opt_delay(jitter);\n   \n   /* Should we force an increase in the buffer or just do normal interpolation? */   \n   if (opt < 0)\n   {\n      /* Need to increase buffering */\n      \n      /* Shift histogram to compensate */\n      shift_timings(jitter, -opt);\n      \n      packet->timestamp = jitter->pointer_timestamp;\n      packet->span = -opt;\n      /* Don't move the pointer_timestamp forward */\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_INSERTION;\n      /*jitter->pointer_timestamp -= jitter->delay_step;*/\n      /*fprintf (stderr, \"Forced to interpolate\\n\");*/\n   } else {\n      /* Normal packet loss */\n      packet->timestamp = jitter->pointer_timestamp;\n      \n      desired_span = ROUND_DOWN(desired_span, jitter->concealment_size);\n      packet->span = desired_span;\n      jitter->pointer_timestamp += desired_span;\n      packet->len = 0;\n      \n      jitter->buffered = packet->span - desired_span;\n      return JITTER_BUFFER_MISSING;\n      /*fprintf (stderr, \"Normal loss\\n\");*/\n   }\n\n\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* create a ogg_packet from a fisbone_packet structure. \n * call this method after the fisbone_packet is filled and all message header fields are added\n * by calling add_message_header_field method.\n */\n", "func_signal": "ogg_packet ogg_from_fisbone(fisbone_packet *fp)", "code": "{\n    \n    ogg_packet op;\n    int packet_size = FISBONE_SIZE + fp->current_header_size;\n\n    memset (&op, 0, sizeof (op));       \n    op.packet = _ogg_calloc (packet_size, sizeof(unsigned char));\n    memset (op.packet, 0, packet_size);\n    memcpy (op.packet, FISBONE_IDENTIFIER, 8); /* identifier */\n    *((ogg_uint32_t*)(op.packet+8)) = FISBONE_MESSAGE_HEADER_OFFSET; /* offset of the message header fields */\n    *((ogg_uint32_t*)(op.packet+12)) = fp->serial_no; /* serialno of the respective stream */\n    *((ogg_uint32_t*)(op.packet+16)) = fp->nr_header_packet; /* number of header packets */\n    *((ogg_int64_t*)(op.packet+20)) = fp->granule_rate_n; /* granulrate numerator */\n    *((ogg_int64_t*)(op.packet+28)) = fp->granule_rate_d; /* granulrate denominator */\n    *((ogg_int64_t*)(op.packet+36)) = fp->start_granule; /* start granule */\n    *((ogg_uint32_t*)(op.packet+44)) = fp->preroll; /* preroll, for theora its 0 */\n    *(op.packet+48) = fp->granule_shift; /* granule shift */\n    memcpy((op.packet+FISBONE_SIZE), fp->message_header_fields, fp->current_header_size);\n\n    op.b_o_s = 0;\n    op.e_o_s = 0;\n    op.bytes = packet_size; /* size of the packet in bytes */\n\n    return op;\n}", "path": "src\\skeleton.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Reset jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_reset(JitterBuffer *jitter)", "code": "{\n   int i;\n   for (i=0;i<SPEEX_JITTER_MAX_BUFFER_SIZE;i++)\n   {\n      if (jitter->packets[i].data)\n      {\n         if (jitter->destroy)\n            jitter->destroy(jitter->packets[i].data);\n         else\n            speex_free(jitter->packets[i].data);\n         jitter->packets[i].data = NULL;\n      }\n   }\n   /* Timestamp is actually undefined at this point */\n   jitter->pointer_timestamp = 0;\n   jitter->next_stop = 0;\n   jitter->reset_state = 1;\n   jitter->lost_count = 0;\n   jitter->buffered = 0;\n   jitter->auto_tradeoff = 32000;\n   \n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      tb_init(&jitter->_tb[i]);\n      jitter->timeBuffers[i] = &jitter->_tb[i];\n   }\n   /*fprintf (stderr, \"reset\\n\");*/\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Based on available data, this computes the optimal delay for the jitter buffer. \n   The optimised function is in timestamp units and is:\n   cost = delay + late_factor*[number of frames that would be late if we used that delay]\n   @param tb Array of buffers\n   @param late_factor Equivalent cost of a late frame (in timestamp units) \n */\n", "func_signal": "static spx_int16_t compute_opt_delay(JitterBuffer *jitter)", "code": "{\n   int i;\n   spx_int16_t opt=0;\n   spx_int32_t best_cost=0x7fffffff;\n   int late = 0;\n   int pos[MAX_BUFFERS];\n   int tot_count;\n   float late_factor;\n   int penalty_taken = 0;\n   int best = 0;\n   int worst = 0;\n   spx_int32_t deltaT;\n   struct TimingBuffer *tb;\n   \n   tb = jitter->_tb;\n   \n   /* Number of packet timings we have received (including those we didn't keep) */\n   tot_count = 0;\n   for (i=0;i<MAX_BUFFERS;i++)\n      tot_count += tb[i].curr_count;\n   if (tot_count==0)\n      return 0;\n   \n   /* Compute cost for one lost packet */\n   if (jitter->latency_tradeoff != 0)\n      late_factor = jitter->latency_tradeoff * 100.0f / tot_count;\n   else\n      late_factor = jitter->auto_tradeoff * jitter->window_size/tot_count;\n   \n   /*fprintf(stderr, \"late_factor = %f\\n\", late_factor);*/\n   for (i=0;i<MAX_BUFFERS;i++)\n      pos[i] = 0;\n   \n   /* Pick the TOP_DELAY \"latest\" packets (doesn't need to actually be late \n      for the current settings) */\n   for (i=0;i<TOP_DELAY;i++)\n   {\n      int j;\n      int next=-1;\n      int latest = 32767;\n      /* Pick latest amoung all sub-windows */\n      for (j=0;j<MAX_BUFFERS;j++)\n      {\n         if (pos[j] < tb[j].filled && tb[j].timing[pos[j]] < latest)\n         {\n            next = j;\n            latest = tb[j].timing[pos[j]];\n         }\n      }\n      if (next != -1)\n      {\n         spx_int32_t cost;\n         \n         if (i==0)\n            worst = latest;\n         best = latest;\n         latest = ROUND_DOWN(latest, jitter->delay_step);\n         pos[next]++;\n         \n         /* Actual cost function that tells us how bad using this delay would be */\n         cost = -latest + late_factor*late;\n         /*fprintf(stderr, \"cost %d = %d + %f * %d\\n\", cost, -latest, late_factor, late);*/\n         if (cost < best_cost)\n         {\n            best_cost = cost;\n            opt = latest;\n         }\n      } else {\n         break;\n      }\n      \n      /* For the next timing we will consider, there will be one more late packet to count */\n      late++;\n      /* Two-frame penalty if we're going to increase the amount of late frames (hysteresis) */\n      if (latest >= 0 && !penalty_taken)\n      {\n         penalty_taken = 1;\n         late+=4;\n      }\n   }\n   \n   deltaT = best-worst;\n   /* This is a default \"automatic latency tradeoff\" when none is provided */\n   jitter->auto_tradeoff = 1 + deltaT/TOP_DELAY;\n   /*fprintf(stderr, \"auto_tradeoff = %d (%d %d %d)\\n\", jitter->auto_tradeoff, best, worst, i);*/\n   \n   /* FIXME: Compute a short-term estimate too and combine with the long-term one */\n   \n   /* Prevents reducing the buffer size when we haven't really had much data */\n   if (tot_count < TOP_DELAY && opt > 0)\n      return 0;\n   return opt;\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Destroy jitter buffer */\n", "func_signal": "EXPORT void jitter_buffer_destroy(JitterBuffer *jitter)", "code": "{\n   jitter_buffer_reset(jitter);\n   speex_free(jitter);\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/** Compensate all timings when we do an adjustment of the buffering */\n", "func_signal": "static void shift_timings(JitterBuffer *jitter, spx_int16_t amount)", "code": "{\n   int i, j;\n   for (i=0;i<MAX_BUFFERS;i++)\n   {\n      for (j=0;j<jitter->timeBuffers[i]->filled;j++)\n         jitter->timeBuffers[i]->timing[j] += amount;\n   }\n}", "path": "libspeex\\jitter.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* Compute the gain floor based on different floors for the background noise and residual echo */\n", "func_signal": "static void compute_gain_floor(int noise_suppress, int effective_echo_suppress, spx_word32_t *noise, spx_word32_t *echo, spx_word16_t *gain_floor, int len)", "code": "{\n   int i;\n   \n   if (noise_suppress > effective_echo_suppress)\n   {\n      spx_word16_t noise_gain, gain_ratio;\n      noise_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),noise_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),effective_echo_suppress-noise_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(noise_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(PSHR32(noise[i],NOISE_SHIFT) + MULT16_32_Q15(gain_ratio,echo[i]),\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   } else {\n      spx_word16_t echo_gain, gain_ratio;\n      echo_gain = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(0.11513,11),effective_echo_suppress)),1)));\n      gain_ratio = EXTRACT16(MIN32(Q15_ONE,SHR32(spx_exp(MULT16_16(QCONST16(.2302585f,11),noise_suppress-effective_echo_suppress)),1)));\n\n      /* gain_floor = sqrt [ (noise*noise_floor + echo*echo_floor) / (noise+echo) ] */\n      for (i=0;i<len;i++)\n         gain_floor[i] = MULT16_16_Q15(echo_gain,\n                                       spx_sqrt(SHL32(EXTEND32(DIV32_16_Q15(MULT16_32_Q15(gain_ratio,PSHR32(noise[i],NOISE_SHIFT)) + echo[i],\n                                             (1+PSHR32(noise[i],NOISE_SHIFT) + echo[i]) )),15)));\n   }\n}", "path": "libspeex\\preprocess.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* write an ogg_page to a file pointer */\n", "func_signal": "int write_ogg_page_to_file(ogg_page *og, FILE *out)", "code": "{\n   int written;\n   \n   written = fwrite(og->header,1, og->header_len, out);\n   written += fwrite(og->body,1, og->body_len, out);\n\n   return written;\n}", "path": "src\\skeleton.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n*/\n", "func_signal": "static inline spx_word32_t hypergeom_gain(spx_word32_t xx)", "code": "{\n   int ind;\n   float integer, frac;\n   float x;\n   static const float table[21] = {\n      0.82157f, 1.02017f, 1.20461f, 1.37534f, 1.53363f, 1.68092f, 1.81865f,\n      1.94811f, 2.07038f, 2.18638f, 2.29688f, 2.40255f, 2.50391f, 2.60144f,\n      2.69551f, 2.78647f, 2.87458f, 2.96015f, 3.04333f, 3.12431f, 3.20326f};\n      x = EXPIN_SCALING_1*xx;\n      integer = floor(2*x);\n      ind = (int)integer;\n      if (ind<0)\n         return FRAC_SCALING;\n      if (ind>19)\n         return FRAC_SCALING*(1+.1296/x);\n      frac = 2*x-integer;\n      return FRAC_SCALING*((1-frac)*table[ind] + frac*table[ind+1])/sqrt(x+.0001f);\n}", "path": "libspeex\\preprocess.c", "repo_name": "QXIP/Speex-with-header-bytes", "stars": 19, "license": "other", "language": "c", "size": 2501}
{"docstring": "/* copies the NUL-terminated C-string 'from' to '*to', leaving '*to'\n * unchanged if malloc fails, free()ing the original '*to' if it\n * succeeds and the original '*to' was not NULL\n */\n", "func_signal": "static FLAC__bool copy_cstring_(char **to, const char *from)", "code": "{\n\tchar *copy = strdup(from);\n\tFLAC__ASSERT(to);\n\tif(copy) {\n\t\tif(*to)\n\t\t\tfree(*to);\n\t\t*to = copy;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}", "path": "lib\\flac121\\libFLAC\\metadata_object.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* UNUSED */\n/* like copy_bytes_(), but free()s the original '*to' if the copy succeeds and the original '*to' is non-NULL */\n", "func_signal": "static FLAC__bool free_copy_bytes_(FLAC__byte **to, const FLAC__byte *from, unsigned bytes)", "code": "{\n\tFLAC__byte *copy;\n\tFLAC__ASSERT(0 != to);\n\tif(copy_bytes_(&copy, from, bytes)) {\n\t\tif(*to)\n\t\t\tfree(*to);\n\t\t*to = copy;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}", "path": "lib\\flac121\\libFLAC\\metadata_object.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */\n", "func_signal": "void update_ogg_metadata_(FLAC__StreamEncoder *encoder)", "code": "{\n\t/* the # of bytes in the 1st packet that precede the STREAMINFO */\n\tstatic const unsigned FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH =\n\t\tFLAC__OGG_MAPPING_PACKET_TYPE_LENGTH +\n\t\tFLAC__OGG_MAPPING_MAGIC_LENGTH +\n\t\tFLAC__OGG_MAPPING_VERSION_MAJOR_LENGTH +\n\t\tFLAC__OGG_MAPPING_VERSION_MINOR_LENGTH +\n\t\tFLAC__OGG_MAPPING_NUM_HEADERS_LENGTH +\n\t\tFLAC__STREAM_SYNC_LENGTH\n\t;\n\tFLAC__byte b[max(6, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];\n\tconst FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;\n\tconst FLAC__uint64 samples = metadata->data.stream_info.total_samples;\n\tconst unsigned min_framesize = metadata->data.stream_info.min_framesize;\n\tconst unsigned max_framesize = metadata->data.stream_info.max_framesize;\n\togg_page page;\n\n\tFLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);\n\tFLAC__ASSERT(0 != encoder->private_->seek_callback);\n\n\t/* Pre-check that client supports seeking, since we don't want the\n\t * ogg_helper code to ever have to deal with this condition.\n\t */\n\tif(encoder->private_->seek_callback(encoder, 0, encoder->private_->client_data) == FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED)\n\t\treturn;\n\n\t/* All this is based on intimate knowledge of the stream header\n\t * layout, but a change to the header format that would break this\n\t * would also break all streams encoded in the previous format.\n\t */\n\n\t/**\n\t ** Write STREAMINFO stats\n\t **/\n\tsimple_ogg_page__init(&page);\n\tif(!simple_ogg_page__get_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {\n\t\tsimple_ogg_page__clear(&page);\n\t\treturn; /* state already set */\n\t}\n\n\t/*\n\t * Write MD5 signature\n\t */\n\t{\n\t\tconst unsigned md5_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN\n\t\t\t) / 8;\n\n\t\tif(md5_offset + 16 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(page.body + md5_offset, metadata->data.stream_info.md5sum, 16);\n\t}\n\n\t/*\n\t * Write total samples\n\t */\n\t{\n\t\tconst unsigned total_samples_byte_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN\n\t\t\t\t- 4\n\t\t\t) / 8;\n\n\t\tif(total_samples_byte_offset + 5 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tb[0] = (FLAC__byte)page.body[total_samples_byte_offset] & 0xF0;\n\t\tb[0] |= (FLAC__byte)((samples >> 32) & 0x0F);\n\t\tb[1] = (FLAC__byte)((samples >> 24) & 0xFF);\n\t\tb[2] = (FLAC__byte)((samples >> 16) & 0xFF);\n\t\tb[3] = (FLAC__byte)((samples >> 8) & 0xFF);\n\t\tb[4] = (FLAC__byte)(samples & 0xFF);\n\t\tmemcpy(page.body + total_samples_byte_offset, b, 5);\n\t}\n\n\t/*\n\t * Write min/max framesize\n\t */\n\t{\n\t\tconst unsigned min_framesize_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN\n\t\t\t) / 8;\n\n\t\tif(min_framesize_offset + 6 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tb[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);\n\t\tb[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);\n\t\tb[2] = (FLAC__byte)(min_framesize & 0xFF);\n\t\tb[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);\n\t\tb[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);\n\t\tb[5] = (FLAC__byte)(max_framesize & 0xFF);\n\t\tmemcpy(page.body + min_framesize_offset, b, 6);\n\t}\n\tif(!simple_ogg_page__set_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {\n\t\tsimple_ogg_page__clear(&page);\n\t\treturn; /* state already set */\n\t}\n\tsimple_ogg_page__clear(&page);\n\n\t/*\n\t * Write seektable\n\t */\n\tif(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {\n\t\tunsigned i;\n\t\tFLAC__byte *p;\n\n\t\tFLAC__format_seektable_sort(encoder->private_->seek_table);\n\n\t\tFLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));\n\n\t\tsimple_ogg_page__init(&page);\n\t\tif(!simple_ogg_page__get_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn; /* state already set */\n\t\t}\n\n\t\tif((FLAC__STREAM_METADATA_HEADER_LENGTH + 18*encoder->private_->seek_table->num_points) != (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(i = 0, p = page.body + FLAC__STREAM_METADATA_HEADER_LENGTH; i < encoder->private_->seek_table->num_points; i++, p += 18) {\n\t\t\tFLAC__uint64 xx;\n\t\t\tunsigned x;\n\t\t\txx = encoder->private_->seek_table->points[i].sample_number;\n\t\t\tb[7] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[6] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[5] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[4] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[3] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[2] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[1] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[0] = (FLAC__byte)xx; xx >>= 8;\n\t\t\txx = encoder->private_->seek_table->points[i].stream_offset;\n\t\t\tb[15] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[14] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[13] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[12] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[11] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[10] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[9] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[8] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tx = encoder->private_->seek_table->points[i].frame_samples;\n\t\t\tb[17] = (FLAC__byte)x; x >>= 8;\n\t\t\tb[16] = (FLAC__byte)x; x >>= 8;\n\t\t\tmemcpy(p, b, 18);\n\t\t}\n\n\t\tif(!simple_ogg_page__set_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn; /* state already set */\n\t\t}\n\t\tsimple_ogg_page__clear(&page);\n\t}\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/*@@@@add to tests*/\n", "func_signal": "FLAC_API FLAC__uint32 FLAC__metadata_object_cuesheet_calculate_cddb_id(const FLAC__StreamMetadata *object)", "code": "{\n\tconst FLAC__StreamMetadata_CueSheet *cs;\n\n\tFLAC__ASSERT(0 != object);\n\tFLAC__ASSERT(object->type == FLAC__METADATA_TYPE_CUESHEET);\n\n\tcs = &object->data.cue_sheet;\n\n\tif (cs->num_tracks < 2) /* need at least one real track and the lead-out track */\n\t\treturn 0;\n\n\t{\n\t\tFLAC__uint32 i, length, sum = 0;\n\t\tfor (i = 0; i < (cs->num_tracks-1); i++) /* -1 to avoid counting the lead-out */\n\t\t\tsum += cddb_add_digits_((FLAC__uint32)(get_index_01_offset_(cs, i) / 44100));\n\t\tlength = (FLAC__uint32)((cs->tracks[cs->num_tracks-1].offset+cs->lead_in) / 44100) - (FLAC__uint32)(get_index_01_offset_(cs, 0) / 44100);\n\n\t\treturn (sum % 0xFF) << 24 | length << 8 | (FLAC__uint32)(cs->num_tracks-1);\n\t}\n}", "path": "lib\\flac121\\libFLAC\\metadata_object.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/*\n * These three functions are not static, but not publically exposed in\n * include/FLAC/ either.  They are used by the test suite.\n */\n", "func_signal": "FLAC_API FLAC__bool FLAC__stream_encoder_disable_constant_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)", "code": "{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->private_->disable_constant_subframes = value;\n\treturn true;\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* An example of what FLAC__bitmath_ilog2() computes:\n *\n * ilog2( 0) = assertion failure\n * ilog2( 1) = 0\n * ilog2( 2) = 1\n * ilog2( 3) = 1\n * ilog2( 4) = 2\n * ilog2( 5) = 2\n * ilog2( 6) = 2\n * ilog2( 7) = 2\n * ilog2( 8) = 3\n * ilog2( 9) = 3\n * ilog2(10) = 3\n * ilog2(11) = 3\n * ilog2(12) = 3\n * ilog2(13) = 3\n * ilog2(14) = 3\n * ilog2(15) = 3\n * ilog2(16) = 4\n * ilog2(17) = 4\n * ilog2(18) = 4\n */\n", "func_signal": "unsigned FLAC__bitmath_ilog2(FLAC__uint32 v)", "code": "{\n\tunsigned l = 0;\n\tFLAC__ASSERT(v > 0);\n\twhile(v >>= 1)\n\t\tl++;\n\treturn l;\n}", "path": "lib\\flac121\\libFLAC\\bitmath.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* rbps stands for residual bits per sample\n *\n *             (ln(2) * err)\n * rbps = log  (-----------)\n *           2 (     n     )\n */\n", "func_signal": "static FLAC__fixedpoint local__compute_rbps_integerized(FLAC__uint32 err, FLAC__uint32 n)", "code": "{\n\tFLAC__uint32 rbps;\n\tunsigned bits; /* the number of bits required to represent a number */\n\tint fracbits; /* the number of bits of rbps that comprise the fractional part */\n\n\tFLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));\n\tFLAC__ASSERT(err > 0);\n\tFLAC__ASSERT(n > 0);\n\n\tFLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);\n\tif(err <= n)\n\t\treturn 0;\n\t/*\n\t * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.\n\t * These allow us later to know we won't lose too much precision in the\n\t * fixed-point division (err<<fracbits)/n.\n\t */\n\n\tfracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2(err)+1);\n\n\terr <<= fracbits;\n\terr /= n;\n\t/* err now holds err/n with fracbits fractional bits */\n\n\t/*\n\t * Whittle err down to 16 bits max.  16 significant bits is enough for\n\t * our purposes.\n\t */\n\tFLAC__ASSERT(err > 0);\n\tbits = FLAC__bitmath_ilog2(err)+1;\n\tif(bits > 16) {\n\t\terr >>= (bits-16);\n\t\tfracbits -= (bits-16);\n\t}\n\trbps = (FLAC__uint32)err;\n\n\t/* Multiply by fixed-point version of ln(2), with 16 fractional bits */\n\trbps *= FLAC__FP_LN2;\n\tfracbits += 16;\n\tFLAC__ASSERT(fracbits >= 0);\n\n\t/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */\n\t{\n\t\tconst int f = fracbits & 3;\n\t\tif(f) {\n\t\t\trbps >>= f;\n\t\t\tfracbits -= f;\n\t\t}\n\t}\n\n\trbps = FLAC__fixedpoint_log2(rbps, fracbits, (unsigned)(-1));\n\n\tif(rbps == 0)\n\t\treturn 0;\n\n\t/*\n\t * The return value must have 16 fractional bits.  Since the whole part\n\t * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits\n\t * must be >= -3, these assertion allows us to be able to shift rbps\n\t * left if necessary to get 16 fracbits without losing any bits of the\n\t * whole part of rbps.\n\t *\n\t * There is a slight chance due to accumulated error that the whole part\n\t * will require 6 bits, so we use 6 in the assertion.  Really though as\n\t * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.\n\t */\n\tFLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);\n\tFLAC__ASSERT(fracbits >= -3);\n\n\t/* now shift the decimal point into place */\n\tif(fracbits < 16)\n\t\treturn rbps << (16-fracbits);\n\telse if(fracbits > 16)\n\t\treturn rbps >> (fracbits-16);\n\telse\n\t\treturn rbps;\n}", "path": "lib\\flac121\\libFLAC\\fixed.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/*@@@@add to tests*/\n", "func_signal": "FLAC_API FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification)", "code": "{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(0 != specification);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#ifdef FLAC__INTEGER_ONLY_LIBRARY\n\t(void)specification; /* silently ignore since we haven't integerized; will always use a rectangular window */\n#else\n\tencoder->protected_->num_apodizations = 0;\n\twhile(1) {\n\t\tconst char *s = strchr(specification, ';');\n\t\tconst size_t n = s? (size_t)(s - specification) : strlen(specification);\n\t\tif     (n==8  && 0 == strncmp(\"bartlett\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT;\n\t\telse if(n==13 && 0 == strncmp(\"bartlett_hann\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT_HANN;\n\t\telse if(n==8  && 0 == strncmp(\"blackman\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN;\n\t\telse if(n==26 && 0 == strncmp(\"blackman_harris_4term_92db\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE;\n\t\telse if(n==6  && 0 == strncmp(\"connes\"       , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_CONNES;\n\t\telse if(n==7  && 0 == strncmp(\"flattop\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_FLATTOP;\n\t\telse if(n>7   && 0 == strncmp(\"gauss(\"       , specification, 6)) {\n\t\t\tFLAC__real stddev = (FLAC__real)strtod(specification+6, 0);\n\t\t\tif (stddev > 0.0 && stddev <= 0.5) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.gauss.stddev = stddev;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_GAUSS;\n\t\t\t}\n\t\t}\n\t\telse if(n==7  && 0 == strncmp(\"hamming\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HAMMING;\n\t\telse if(n==4  && 0 == strncmp(\"hann\"         , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HANN;\n\t\telse if(n==13 && 0 == strncmp(\"kaiser_bessel\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_KAISER_BESSEL;\n\t\telse if(n==7  && 0 == strncmp(\"nuttall\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_NUTTALL;\n\t\telse if(n==9  && 0 == strncmp(\"rectangle\"    , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_RECTANGLE;\n\t\telse if(n==8  && 0 == strncmp(\"triangle\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TRIANGLE;\n\t\telse if(n>7   && 0 == strncmp(\"tukey(\"       , specification, 6)) {\n\t\t\tFLAC__real p = (FLAC__real)strtod(specification+6, 0);\n\t\t\tif (p >= 0.0 && p <= 1.0) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = p;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;\n\t\t\t}\n\t\t}\n\t\telse if(n==5  && 0 == strncmp(\"welch\"        , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_WELCH;\n\t\tif (encoder->protected_->num_apodizations == 32)\n\t\t\tbreak;\n\t\tif (s)\n\t\t\tspecification = s+1;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif(encoder->protected_->num_apodizations == 0) {\n\t\tencoder->protected_->num_apodizations = 1;\n\t\tencoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;\n\t\tencoder->protected_->apodizations[0].parameters.tukey.p = 0.5;\n\t}\n#endif\n\treturn true;\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\n", "func_signal": "FLAC_API unsigned FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table)", "code": "{\n\tunsigned i, j;\n\tFLAC__bool first;\n\n\tFLAC__ASSERT(0 != seek_table);\n\n\t/* sort the seekpoints */\n\tqsort(seek_table->points, seek_table->num_points, sizeof(FLAC__StreamMetadata_SeekPoint), (int (*)(const void *, const void *))seekpoint_compare_);\n\n\t/* uniquify the seekpoints */\n\tfirst = true;\n\tfor(i = j = 0; i < seek_table->num_points; i++) {\n\t\tif(seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER) {\n\t\t\tif(!first) {\n\t\t\t\tif(seek_table->points[i].sample_number == seek_table->points[j-1].sample_number)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfirst = false;\n\t\tseek_table->points[j++] = seek_table->points[i];\n\t}\n\n\tfor(i = j; i < seek_table->num_points; i++) {\n\t\tseek_table->points[i].sample_number = FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER;\n\t\tseek_table->points[i].stream_offset = 0;\n\t\tseek_table->points[i].frame_samples = 0;\n\t}\n\n\treturn j;\n}", "path": "lib\\flac121\\libFLAC\\format.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */\n", "func_signal": "void update_metadata_(const FLAC__StreamEncoder *encoder)", "code": "{\n\tFLAC__byte b[max(6, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];\n\tconst FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;\n\tconst FLAC__uint64 samples = metadata->data.stream_info.total_samples;\n\tconst unsigned min_framesize = metadata->data.stream_info.min_framesize;\n\tconst unsigned max_framesize = metadata->data.stream_info.max_framesize;\n\tconst unsigned bps = metadata->data.stream_info.bits_per_sample;\n\tFLAC__StreamEncoderSeekStatus seek_status;\n\n\tFLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);\n\n\t/* All this is based on intimate knowledge of the stream header\n\t * layout, but a change to the header format that would break this\n\t * would also break all streams encoded in the previous format.\n\t */\n\n\t/*\n\t * Write MD5 signature\n\t */\n\t{\n\t\tconst unsigned md5_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN\n\t\t\t) / 8;\n\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + md5_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, metadata->data.stream_info.md5sum, 16, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write total samples\n\t */\n\t{\n\t\tconst unsigned total_samples_byte_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN\n\t\t\t\t- 4\n\t\t\t) / 8;\n\n\t\tb[0] = ((FLAC__byte)(bps-1) << 4) | (FLAC__byte)((samples >> 32) & 0x0F);\n\t\tb[1] = (FLAC__byte)((samples >> 24) & 0xFF);\n\t\tb[2] = (FLAC__byte)((samples >> 16) & 0xFF);\n\t\tb[3] = (FLAC__byte)((samples >> 8) & 0xFF);\n\t\tb[4] = (FLAC__byte)(samples & 0xFF);\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + total_samples_byte_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, b, 5, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write min/max framesize\n\t */\n\t{\n\t\tconst unsigned min_framesize_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN\n\t\t\t) / 8;\n\n\t\tb[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);\n\t\tb[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);\n\t\tb[2] = (FLAC__byte)(min_framesize & 0xFF);\n\t\tb[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);\n\t\tb[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);\n\t\tb[5] = (FLAC__byte)(max_framesize & 0xFF);\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + min_framesize_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, b, 6, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write seektable\n\t */\n\tif(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {\n\t\tunsigned i;\n\n\t\tFLAC__format_seektable_sort(encoder->private_->seek_table);\n\n\t\tFLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));\n\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->seektable_offset + FLAC__STREAM_METADATA_HEADER_LENGTH, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\n\t\tfor(i = 0; i < encoder->private_->seek_table->num_points; i++) {\n\t\t\tFLAC__uint64 xx;\n\t\t\tunsigned x;\n\t\t\txx = encoder->private_->seek_table->points[i].sample_number;\n\t\t\tb[7] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[6] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[5] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[4] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[3] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[2] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[1] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[0] = (FLAC__byte)xx; xx >>= 8;\n\t\t\txx = encoder->private_->seek_table->points[i].stream_offset;\n\t\t\tb[15] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[14] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[13] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[12] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[11] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[10] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[9] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[8] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tx = encoder->private_->seek_table->points[i].frame_samples;\n\t\t\tb[17] = (FLAC__byte)x; x >>= 8;\n\t\t\tb[16] = (FLAC__byte)x; x >>= 8;\n\t\t\tif(encoder->private_->write_callback(encoder, b, 18, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* used as the sort predicate for qsort() */\n", "func_signal": "static int seekpoint_compare_(const FLAC__StreamMetadata_SeekPoint *l, const FLAC__StreamMetadata_SeekPoint *r)", "code": "{\n\t/* we don't just 'return l->sample_number - r->sample_number' since the result (FLAC__int64) might overflow an 'int' */\n\tif(l->sample_number == r->sample_number)\n\t\treturn 0;\n\telse if(l->sample_number < r->sample_number)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}", "path": "lib\\flac121\\libFLAC\\format.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* copy bytes:\n *  from = NULL  && bytes = 0\n *       to <- NULL\n *  from != NULL && bytes > 0\n *       to <- copy of from\n *  else ASSERT\n * malloc error leaves 'to' unchanged\n */\n", "func_signal": "static FLAC__bool copy_bytes_(FLAC__byte **to, const FLAC__byte *from, unsigned bytes)", "code": "{\n\tFLAC__ASSERT(0 != to);\n\tif(bytes > 0 && 0 != from) {\n\t\tFLAC__byte *x;\n\t\tif(0 == (x = (FLAC__byte*)safe_malloc_(bytes)))\n\t\t\treturn false;\n\t\tmemcpy(x, from, bytes);\n\t\t*to = x;\n\t}\n\telse {\n\t\tFLAC__ASSERT(0 == from);\n\t\tFLAC__ASSERT(bytes == 0);\n\t\t*to = 0;\n\t}\n\treturn true;\n}", "path": "lib\\flac121\\libFLAC\\metadata_object.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\n", "func_signal": "FLAC_API FLAC__bool FLAC__format_cuesheet_is_legal(const FLAC__StreamMetadata_CueSheet *cue_sheet, FLAC__bool check_cd_da_subset, const char **violation)", "code": "{\n\tunsigned i, j;\n\n\tif(check_cd_da_subset) {\n\t\tif(cue_sheet->lead_in < 2 * 44100) {\n\t\t\tif(violation) *violation = \"CD-DA cue sheet must have a lead-in length of at least 2 seconds\";\n\t\t\treturn false;\n\t\t}\n\t\tif(cue_sheet->lead_in % 588 != 0) {\n\t\t\tif(violation) *violation = \"CD-DA cue sheet lead-in length must be evenly divisible by 588 samples\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif(cue_sheet->num_tracks == 0) {\n\t\tif(violation) *violation = \"cue sheet must have at least one track (the lead-out)\";\n\t\treturn false;\n\t}\n\n\tif(check_cd_da_subset && cue_sheet->tracks[cue_sheet->num_tracks-1].number != 170) {\n\t\tif(violation) *violation = \"CD-DA cue sheet must have a lead-out track number 170 (0xAA)\";\n\t\treturn false;\n\t}\n\n\tfor(i = 0; i < cue_sheet->num_tracks; i++) {\n\t\tif(cue_sheet->tracks[i].number == 0) {\n\t\t\tif(violation) *violation = \"cue sheet may not have a track number 0\";\n\t\t\treturn false;\n\t\t}\n\n\t\tif(check_cd_da_subset) {\n\t\t\tif(!((cue_sheet->tracks[i].number >= 1 && cue_sheet->tracks[i].number <= 99) || cue_sheet->tracks[i].number == 170)) {\n\t\t\t\tif(violation) *violation = \"CD-DA cue sheet track number must be 1-99 or 170\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif(check_cd_da_subset && cue_sheet->tracks[i].offset % 588 != 0) {\n\t\t\tif(violation) {\n\t\t\t\tif(i == cue_sheet->num_tracks-1) /* the lead-out track... */\n\t\t\t\t\t*violation = \"CD-DA cue sheet lead-out offset must be evenly divisible by 588 samples\";\n\t\t\t\telse\n\t\t\t\t\t*violation = \"CD-DA cue sheet track offset must be evenly divisible by 588 samples\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif(i < cue_sheet->num_tracks - 1) {\n\t\t\tif(cue_sheet->tracks[i].num_indices == 0) {\n\t\t\t\tif(violation) *violation = \"cue sheet track must have at least one index point\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(cue_sheet->tracks[i].indices[0].number > 1) {\n\t\t\t\tif(violation) *violation = \"cue sheet track's first index number must be 0 or 1\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor(j = 0; j < cue_sheet->tracks[i].num_indices; j++) {\n\t\t\tif(check_cd_da_subset && cue_sheet->tracks[i].indices[j].offset % 588 != 0) {\n\t\t\t\tif(violation) *violation = \"CD-DA cue sheet track index offset must be evenly divisible by 588 samples\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(j > 0) {\n\t\t\t\tif(cue_sheet->tracks[i].indices[j].number != cue_sheet->tracks[i].indices[j-1].number + 1) {\n\t\t\t\t\tif(violation) *violation = \"cue sheet track index numbers must increase by 1\";\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "path": "lib\\flac121\\libFLAC\\format.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/****************************************************************************\n *\n * Metadata object routines\n *\n ***************************************************************************/\n", "func_signal": "FLAC_API FLAC__StreamMetadata *FLAC__metadata_object_new(FLAC__MetadataType type)", "code": "{\n\tFLAC__StreamMetadata *object;\n\n\tif(type > FLAC__MAX_METADATA_TYPE_CODE)\n\t\treturn 0;\n\n\tobject = (FLAC__StreamMetadata*)calloc(1, sizeof(FLAC__StreamMetadata));\n\tif(0 != object) {\n\t\tobject->is_last = false;\n\t\tobject->type = type;\n\t\tswitch(type) {\n\t\t\tcase FLAC__METADATA_TYPE_STREAMINFO:\n\t\t\t\tobject->length = FLAC__STREAM_METADATA_STREAMINFO_LENGTH;\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_PADDING:\n\t\t\t\t/* calloc() took care of this for us:\n\t\t\t\tobject->length = 0;\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_APPLICATION:\n\t\t\t\tobject->length = FLAC__STREAM_METADATA_APPLICATION_ID_LEN / 8;\n\t\t\t\t/* calloc() took care of this for us:\n\t\t\t\tobject->data.application.data = 0;\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_SEEKTABLE:\n\t\t\t\t/* calloc() took care of this for us:\n\t\t\t\tobject->length = 0;\n\t\t\t\tobject->data.seek_table.num_points = 0;\n\t\t\t\tobject->data.seek_table.points = 0;\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT:\n\t\t\t\tobject->data.vorbis_comment.vendor_string.length = (unsigned)strlen(FLAC__VENDOR_STRING);\n\t\t\t\tif(!copy_bytes_(&object->data.vorbis_comment.vendor_string.entry, (const FLAC__byte*)FLAC__VENDOR_STRING, object->data.vorbis_comment.vendor_string.length+1)) {\n\t\t\t\t\tfree(object);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tvorbiscomment_calculate_length_(object);\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_CUESHEET:\n\t\t\t\tcuesheet_calculate_length_(object);\n\t\t\t\tbreak;\n\t\t\tcase FLAC__METADATA_TYPE_PICTURE:\n\t\t\t\tobject->length = (\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_TYPE_LEN +\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN + /* empty mime_type string */\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN + /* empty description string */\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_WIDTH_LEN +\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN +\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_DEPTH_LEN +\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_COLORS_LEN +\n\t\t\t\t\tFLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN +\n\t\t\t\t\t0 /* no data */\n\t\t\t\t) / 8;\n\t\t\t\tobject->data.picture.type = FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER;\n\t\t\t\tobject->data.picture.mime_type = 0;\n\t\t\t\tobject->data.picture.description = 0;\n\t\t\t\t/* calloc() took care of this for us:\n\t\t\t\tobject->data.picture.width = 0;\n\t\t\t\tobject->data.picture.height = 0;\n\t\t\t\tobject->data.picture.depth = 0;\n\t\t\t\tobject->data.picture.colors = 0;\n\t\t\t\tobject->data.picture.data_length = 0;\n\t\t\t\tobject->data.picture.data = 0;\n\t\t\t\t*/\n\t\t\t\t/* now initialize mime_type and description with empty strings to make things easier on the client */\n\t\t\t\tif(!copy_cstring_(&object->data.picture.mime_type, \"\")) {\n\t\t\t\t\tfree(object);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(!copy_cstring_((char**)(&object->data.picture.description), \"\")) {\n\t\t\t\t\tif(object->data.picture.mime_type)\n\t\t\t\t\t\tfree(object->data.picture.mime_type);\n\t\t\t\t\tfree(object);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* calloc() took care of this for us:\n\t\t\t\tobject->length = 0;\n\t\t\t\tobject->data.unknown.data = 0;\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn object;\n}", "path": "lib\\flac121\\libFLAC\\metadata_object.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n", "func_signal": "static FLAC__StreamEncoderInitStatus init_stream_internal_(\n\tFLAC__StreamEncoder *encoder,\n\tFLAC__StreamEncoderReadCallback read_callback,\n\tFLAC__StreamEncoderWriteCallback write_callback,\n\tFLAC__StreamEncoderSeekCallback seek_callback,\n\tFLAC__StreamEncoderTellCallback tell_callback,\n\tFLAC__StreamEncoderMetadataCallback metadata_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)", "code": "{\n\tunsigned i;\n\tFLAC__bool metadata_has_seektable, metadata_has_vorbis_comment, metadata_picture_has_type1, metadata_picture_has_type2;\n\n\tFLAC__ASSERT(0 != encoder);\n\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n#if !FLAC__HAS_OGG\n\tif(is_ogg)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER;\n#endif\n\n\tif(0 == write_callback || (seek_callback && 0 == tell_callback))\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS;\n\n\tif(encoder->protected_->channels == 0 || encoder->protected_->channels > FLAC__MAX_CHANNELS)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS;\n\n\tif(encoder->protected_->channels != 2) {\n\t\tencoder->protected_->do_mid_side_stereo = false;\n\t\tencoder->protected_->loose_mid_side_stereo = false;\n\t}\n\telse if(!encoder->protected_->do_mid_side_stereo)\n\t\tencoder->protected_->loose_mid_side_stereo = false;\n\n\tif(encoder->protected_->bits_per_sample >= 32)\n\t\tencoder->protected_->do_mid_side_stereo = false; /* since we currenty do 32-bit math, the side channel would have 33 bps and overflow */\n\n\tif(encoder->protected_->bits_per_sample < FLAC__MIN_BITS_PER_SAMPLE || encoder->protected_->bits_per_sample > FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE;\n\n\tif(!FLAC__format_sample_rate_is_valid(encoder->protected_->sample_rate))\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE;\n\n\tif(encoder->protected_->blocksize == 0) {\n\t\tif(encoder->protected_->max_lpc_order == 0)\n\t\t\tencoder->protected_->blocksize = 1152;\n\t\telse\n\t\t\tencoder->protected_->blocksize = 4096;\n\t}\n\n\tif(encoder->protected_->blocksize < FLAC__MIN_BLOCK_SIZE || encoder->protected_->blocksize > FLAC__MAX_BLOCK_SIZE)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE;\n\n\tif(encoder->protected_->max_lpc_order > FLAC__MAX_LPC_ORDER)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER;\n\n\tif(encoder->protected_->blocksize < encoder->protected_->max_lpc_order)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER;\n\n\tif(encoder->protected_->qlp_coeff_precision == 0) {\n\t\tif(encoder->protected_->bits_per_sample < 16) {\n\t\t\t/* @@@ need some data about how to set this here w.r.t. blocksize and sample rate */\n\t\t\t/* @@@ until then we'll make a guess */\n\t\t\tencoder->protected_->qlp_coeff_precision = max(FLAC__MIN_QLP_COEFF_PRECISION, 2 + encoder->protected_->bits_per_sample / 2);\n\t\t}\n\t\telse if(encoder->protected_->bits_per_sample == 16) {\n\t\t\tif(encoder->protected_->blocksize <= 192)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 7;\n\t\t\telse if(encoder->protected_->blocksize <= 384)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 8;\n\t\t\telse if(encoder->protected_->blocksize <= 576)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 9;\n\t\t\telse if(encoder->protected_->blocksize <= 1152)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 10;\n\t\t\telse if(encoder->protected_->blocksize <= 2304)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 11;\n\t\t\telse if(encoder->protected_->blocksize <= 4608)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 12;\n\t\t\telse\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 13;\n\t\t}\n\t\telse {\n\t\t\tif(encoder->protected_->blocksize <= 384)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-2;\n\t\t\telse if(encoder->protected_->blocksize <= 1152)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-1;\n\t\t\telse\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION;\n\t\t}\n\t\tFLAC__ASSERT(encoder->protected_->qlp_coeff_precision <= FLAC__MAX_QLP_COEFF_PRECISION);\n\t}\n\telse if(encoder->protected_->qlp_coeff_precision < FLAC__MIN_QLP_COEFF_PRECISION || encoder->protected_->qlp_coeff_precision > FLAC__MAX_QLP_COEFF_PRECISION)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION;\n\n\tif(encoder->protected_->streamable_subset) {\n\t\tif(\n\t\t\tencoder->protected_->blocksize != 192 &&\n\t\t\tencoder->protected_->blocksize != 576 &&\n\t\t\tencoder->protected_->blocksize != 1152 &&\n\t\t\tencoder->protected_->blocksize != 2304 &&\n\t\t\tencoder->protected_->blocksize != 4608 &&\n\t\t\tencoder->protected_->blocksize != 256 &&\n\t\t\tencoder->protected_->blocksize != 512 &&\n\t\t\tencoder->protected_->blocksize != 1024 &&\n\t\t\tencoder->protected_->blocksize != 2048 &&\n\t\t\tencoder->protected_->blocksize != 4096 &&\n\t\t\tencoder->protected_->blocksize != 8192 &&\n\t\t\tencoder->protected_->blocksize != 16384\n\t\t)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(!FLAC__format_sample_rate_is_subset(encoder->protected_->sample_rate))\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(\n\t\t\tencoder->protected_->bits_per_sample != 8 &&\n\t\t\tencoder->protected_->bits_per_sample != 12 &&\n\t\t\tencoder->protected_->bits_per_sample != 16 &&\n\t\t\tencoder->protected_->bits_per_sample != 20 &&\n\t\t\tencoder->protected_->bits_per_sample != 24\n\t\t)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(encoder->protected_->max_residual_partition_order > FLAC__SUBSET_MAX_RICE_PARTITION_ORDER)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(\n\t\t\tencoder->protected_->sample_rate <= 48000 &&\n\t\t\t(\n\t\t\t\tencoder->protected_->blocksize > FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ ||\n\t\t\t\tencoder->protected_->max_lpc_order > FLAC__SUBSET_MAX_LPC_ORDER_48000HZ\n\t\t\t)\n\t\t) {\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\t}\n\t}\n\n\tif(encoder->protected_->max_residual_partition_order >= (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))\n\t\tencoder->protected_->max_residual_partition_order = (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN) - 1;\n\tif(encoder->protected_->min_residual_partition_order >= encoder->protected_->max_residual_partition_order)\n\t\tencoder->protected_->min_residual_partition_order = encoder->protected_->max_residual_partition_order;\n\n#if FLAC__HAS_OGG\n\t/* reorder metadata if necessary to ensure that any VORBIS_COMMENT is the first, according to the mapping spec */\n\tif(is_ogg && 0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 1) {\n\t\tunsigned i;\n\t\tfor(i = 1; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\t\tif(0 != encoder->protected_->metadata[i] && encoder->protected_->metadata[i]->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {\n\t\t\t\tFLAC__StreamMetadata *vc = encoder->protected_->metadata[i];\n\t\t\t\tfor( ; i > 0; i--)\n\t\t\t\t\tencoder->protected_->metadata[i] = encoder->protected_->metadata[i-1];\n\t\t\t\tencoder->protected_->metadata[0] = vc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/* keep track of any SEEKTABLE block */\n\tif(0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0) {\n\t\tunsigned i;\n\t\tfor(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\t\tif(0 != encoder->protected_->metadata[i] && encoder->protected_->metadata[i]->type == FLAC__METADATA_TYPE_SEEKTABLE) {\n\t\t\t\tencoder->private_->seek_table = &encoder->protected_->metadata[i]->data.seek_table;\n\t\t\t\tbreak; /* take only the first one */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* validate metadata */\n\tif(0 == encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\tmetadata_has_seektable = false;\n\tmetadata_has_vorbis_comment = false;\n\tmetadata_picture_has_type1 = false;\n\tmetadata_picture_has_type2 = false;\n\tfor(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\tconst FLAC__StreamMetadata *m = encoder->protected_->metadata[i];\n\t\tif(m->type == FLAC__METADATA_TYPE_STREAMINFO)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\telse if(m->type == FLAC__METADATA_TYPE_SEEKTABLE) {\n\t\t\tif(metadata_has_seektable) /* only one is allowed */\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tmetadata_has_seektable = true;\n\t\t\tif(!FLAC__format_seektable_is_legal(&m->data.seek_table))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {\n\t\t\tif(metadata_has_vorbis_comment) /* only one is allowed */\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tmetadata_has_vorbis_comment = true;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_CUESHEET) {\n\t\t\tif(!FLAC__format_cuesheet_is_legal(&m->data.cue_sheet, m->data.cue_sheet.is_cd, /*violation=*/0))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_PICTURE) {\n\t\t\tif(!FLAC__format_picture_is_legal(&m->data.picture, /*violation=*/0))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tif(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD) {\n\t\t\t\tif(metadata_picture_has_type1) /* there should only be 1 per stream */\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t\tmetadata_picture_has_type1 = true;\n\t\t\t\t/* standard icon must be 32x32 pixel PNG */\n\t\t\t\tif(\n\t\t\t\t\tm->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD && \n\t\t\t\t\t(\n\t\t\t\t\t\t(strcmp(m->data.picture.mime_type, \"image/png\") && strcmp(m->data.picture.mime_type, \"-->\")) ||\n\t\t\t\t\t\tm->data.picture.width != 32 ||\n\t\t\t\t\t\tm->data.picture.height != 32\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t}\n\t\t\telse if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON) {\n\t\t\t\tif(metadata_picture_has_type2) /* there should only be 1 per stream */\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t\tmetadata_picture_has_type2 = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tencoder->private_->input_capacity = 0;\n\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\tencoder->private_->integer_signal_unaligned[i] = encoder->private_->integer_signal[i] = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tencoder->private_->real_signal_unaligned[i] = encoder->private_->real_signal[i] = 0;\n#endif\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->integer_signal_mid_side_unaligned[i] = encoder->private_->integer_signal_mid_side[i] = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tencoder->private_->real_signal_mid_side_unaligned[i] = encoder->private_->real_signal_mid_side[i] = 0;\n#endif\n\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tfor(i = 0; i < encoder->protected_->num_apodizations; i++)\n\t\tencoder->private_->window_unaligned[i] = encoder->private_->window[i] = 0;\n\tencoder->private_->windowed_signal_unaligned = encoder->private_->windowed_signal = 0;\n#endif\n\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\tencoder->private_->residual_workspace_unaligned[i][0] = encoder->private_->residual_workspace[i][0] = 0;\n\t\tencoder->private_->residual_workspace_unaligned[i][1] = encoder->private_->residual_workspace[i][1] = 0;\n\t\tencoder->private_->best_subframe[i] = 0;\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->residual_workspace_mid_side_unaligned[i][0] = encoder->private_->residual_workspace_mid_side[i][0] = 0;\n\t\tencoder->private_->residual_workspace_mid_side_unaligned[i][1] = encoder->private_->residual_workspace_mid_side[i][1] = 0;\n\t\tencoder->private_->best_subframe_mid_side[i] = 0;\n\t}\n\tencoder->private_->abs_residual_partition_sums_unaligned = encoder->private_->abs_residual_partition_sums = 0;\n\tencoder->private_->raw_bits_per_partition_unaligned = encoder->private_->raw_bits_per_partition = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->loose_mid_side_stereo_frames = (unsigned)((FLAC__double)encoder->protected_->sample_rate * 0.4 / (FLAC__double)encoder->protected_->blocksize + 0.5);\n#else\n\t/* 26214 is the approximate fixed-point equivalent to 0.4 (0.4 * 2^16) */\n\t/* sample rate can be up to 655350 Hz, and thus use 20 bits, so we do the multiply&divide by hand */\n\tFLAC__ASSERT(FLAC__MAX_SAMPLE_RATE <= 655350);\n\tFLAC__ASSERT(FLAC__MAX_BLOCK_SIZE <= 65535);\n\tFLAC__ASSERT(encoder->protected_->sample_rate <= 655350);\n\tFLAC__ASSERT(encoder->protected_->blocksize <= 65535);\n\tencoder->private_->loose_mid_side_stereo_frames = (unsigned)FLAC__fixedpoint_trunc((((FLAC__uint64)(encoder->protected_->sample_rate) * (FLAC__uint64)(26214)) << 16) / (encoder->protected_->blocksize<<16) + FLAC__FP_ONE_HALF);\n#endif\n\tif(encoder->private_->loose_mid_side_stereo_frames == 0)\n\t\tencoder->private_->loose_mid_side_stereo_frames = 1;\n\tencoder->private_->loose_mid_side_stereo_frame_count = 0;\n\tencoder->private_->current_sample_number = 0;\n\tencoder->private_->current_frame_number = 0;\n\n\tencoder->private_->use_wide_by_block = (encoder->protected_->bits_per_sample + FLAC__bitmath_ilog2(encoder->protected_->blocksize)+1 > 30);\n\tencoder->private_->use_wide_by_order = (encoder->protected_->bits_per_sample + FLAC__bitmath_ilog2(max(encoder->protected_->max_lpc_order, FLAC__MAX_FIXED_ORDER))+1 > 30); /*@@@ need to use this? */\n\tencoder->private_->use_wide_by_partition = (false); /*@@@ need to set this */\n\n\t/*\n\t * get the CPU info and set the function pointers\n\t */\n\tFLAC__cpu_info(&encoder->private_->cpuinfo);\n\t/* first default to the non-asm routines */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;\n#endif\n\tencoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients;\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide;\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients;\n#endif\n\t/* now override with asm where appropriate */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n# ifndef FLAC__NO_ASM\n\tif(encoder->private_->cpuinfo.use_asm) {\n#  ifdef FLAC__CPU_IA32\n\t\tFLAC__ASSERT(encoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_IA32);\n#   ifdef FLAC__HAS_NASM\n\t\tif(encoder->private_->cpuinfo.data.ia32.sse) {\n\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_4;\n\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_8;\n\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_12;\n\t\t\telse\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;\n\t\t}\n\t\telse if(encoder->private_->cpuinfo.data.ia32._3dnow)\n\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_3dnow;\n\t\telse\n\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;\n\t\tif(encoder->private_->cpuinfo.data.ia32.mmx) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx;\n\t\t}\n\t\telse {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t}\n\t\tif(encoder->private_->cpuinfo.data.ia32.mmx && encoder->private_->cpuinfo.data.ia32.cmov)\n\t\t\tencoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor_asm_ia32_mmx_cmov;\n#   endif /* FLAC__HAS_NASM */\n#  endif /* FLAC__CPU_IA32 */\n\t}\n# endif /* !FLAC__NO_ASM */\n#endif /* !FLAC__INTEGER_ONLY_LIBRARY */\n\t/* finally override based on wide-ness if necessary */\n\tif(encoder->private_->use_wide_by_block) {\n\t\tencoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor_wide;\n\t}\n\n\t/* set state to OK; from here on, errors are fatal and we'll override the state then */\n\tencoder->protected_->state = FLAC__STREAM_ENCODER_OK;\n\n#if FLAC__HAS_OGG\n\tencoder->private_->is_ogg = is_ogg;\n\tif(is_ogg && !FLAC__ogg_encoder_aspect_init(&encoder->protected_->ogg_encoder_aspect)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n#endif\n\n\tencoder->private_->read_callback = read_callback;\n\tencoder->private_->write_callback = write_callback;\n\tencoder->private_->seek_callback = seek_callback;\n\tencoder->private_->tell_callback = tell_callback;\n\tencoder->private_->metadata_callback = metadata_callback;\n\tencoder->private_->client_data = client_data;\n\n\tif(!resize_buffers_(encoder, encoder->protected_->blocksize)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\tif(!FLAC__bitwriter_init(encoder->private_->frame)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * Set up the verify stuff if necessary\n\t */\n\tif(encoder->protected_->verify) {\n\t\t/*\n\t\t * First, set up the fifo which will hold the\n\t\t * original signal to compare against\n\t\t */\n\t\tencoder->private_->verify.input_fifo.size = encoder->protected_->blocksize+OVERREAD_;\n\t\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\t\tif(0 == (encoder->private_->verify.input_fifo.data[i] = (FLAC__int32*)safe_malloc_mul_2op_(sizeof(FLAC__int32), /*times*/encoder->private_->verify.input_fifo.size))) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t\t}\n\t\t}\n\t\tencoder->private_->verify.input_fifo.tail = 0;\n\n\t\t/*\n\t\t * Now set up a stream decoder for verification\n\t\t */\n\t\tencoder->private_->verify.decoder = FLAC__stream_decoder_new();\n\t\tif(0 == encoder->private_->verify.decoder) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\n\t\tif(FLAC__stream_decoder_init_stream(encoder->private_->verify.decoder, verify_read_callback_, /*seek_callback=*/0, /*tell_callback=*/0, /*length_callback=*/0, /*eof_callback=*/0, verify_write_callback_, verify_metadata_callback_, verify_error_callback_, /*client_data=*/encoder) != FLAC__STREAM_DECODER_INIT_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\tencoder->private_->verify.error_stats.absolute_sample = 0;\n\tencoder->private_->verify.error_stats.frame_number = 0;\n\tencoder->private_->verify.error_stats.channel = 0;\n\tencoder->private_->verify.error_stats.sample = 0;\n\tencoder->private_->verify.error_stats.expected = 0;\n\tencoder->private_->verify.error_stats.got = 0;\n\n\t/*\n\t * These must be done before we write any metadata, because that\n\t * calls the write_callback, which uses these values.\n\t */\n\tencoder->private_->first_seekpoint_to_check = 0;\n\tencoder->private_->samples_written = 0;\n\tencoder->protected_->streaminfo_offset = 0;\n\tencoder->protected_->seektable_offset = 0;\n\tencoder->protected_->audio_offset = 0;\n\n\t/*\n\t * write the stream header\n\t */\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_MAGIC;\n\tif(!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, FLAC__STREAM_SYNC, FLAC__STREAM_SYNC_LEN)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * write the STREAMINFO metadata block\n\t */\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_METADATA;\n\tencoder->private_->streaminfo.type = FLAC__METADATA_TYPE_STREAMINFO;\n\tencoder->private_->streaminfo.is_last = false; /* we will have at a minimum a VORBIS_COMMENT afterwards */\n\tencoder->private_->streaminfo.length = FLAC__STREAM_METADATA_STREAMINFO_LENGTH;\n\tencoder->private_->streaminfo.data.stream_info.min_blocksize = encoder->protected_->blocksize; /* this encoder uses the same blocksize for the whole stream */\n\tencoder->private_->streaminfo.data.stream_info.max_blocksize = encoder->protected_->blocksize;\n\tencoder->private_->streaminfo.data.stream_info.min_framesize = 0; /* we don't know this yet; have to fill it in later */\n\tencoder->private_->streaminfo.data.stream_info.max_framesize = 0; /* we don't know this yet; have to fill it in later */\n\tencoder->private_->streaminfo.data.stream_info.sample_rate = encoder->protected_->sample_rate;\n\tencoder->private_->streaminfo.data.stream_info.channels = encoder->protected_->channels;\n\tencoder->private_->streaminfo.data.stream_info.bits_per_sample = encoder->protected_->bits_per_sample;\n\tencoder->private_->streaminfo.data.stream_info.total_samples = encoder->protected_->total_samples_estimate; /* we will replace this later with the real total */\n\tmemset(encoder->private_->streaminfo.data.stream_info.md5sum, 0, 16); /* we don't know this yet; have to fill it in later */\n\tif(encoder->protected_->do_md5)\n\t\tFLAC__MD5Init(&encoder->private_->md5context);\n\tif(!FLAC__add_metadata_block(&encoder->private_->streaminfo, encoder->private_->frame)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * Now that the STREAMINFO block is written, we can init this to an\n\t * absurdly-high value...\n\t */\n\tencoder->private_->streaminfo.data.stream_info.min_framesize = (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN) - 1;\n\t/* ... and clear this to 0 */\n\tencoder->private_->streaminfo.data.stream_info.total_samples = 0;\n\n\t/*\n\t * Check to see if the supplied metadata contains a VORBIS_COMMENT;\n\t * if not, we will write an empty one (FLAC__add_metadata_block()\n\t * automatically supplies the vendor string).\n\t *\n\t * WATCHOUT: the Ogg FLAC mapping requires us to write this block after\n\t * the STREAMINFO.  (In the case that metadata_has_vorbis_comment is\n\t * true it will have already insured that the metadata list is properly\n\t * ordered.)\n\t */\n\tif(!metadata_has_vorbis_comment) {\n\t\tFLAC__StreamMetadata vorbis_comment;\n\t\tvorbis_comment.type = FLAC__METADATA_TYPE_VORBIS_COMMENT;\n\t\tvorbis_comment.is_last = (encoder->protected_->num_metadata_blocks == 0);\n\t\tvorbis_comment.length = 4 + 4; /* MAGIC NUMBER */\n\t\tvorbis_comment.data.vorbis_comment.vendor_string.length = 0;\n\t\tvorbis_comment.data.vorbis_comment.vendor_string.entry = 0;\n\t\tvorbis_comment.data.vorbis_comment.num_comments = 0;\n\t\tvorbis_comment.data.vorbis_comment.comments = 0;\n\t\tif(!FLAC__add_metadata_block(&vorbis_comment, encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t\t/* the above function sets the state for us in case of an error */\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * write the user's metadata blocks\n\t */\n\tfor(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\tencoder->protected_->metadata[i]->is_last = (i == encoder->protected_->num_metadata_blocks - 1);\n\t\tif(!FLAC__add_metadata_block(encoder->protected_->metadata[i], encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t\t/* the above function sets the state for us in case of an error */\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\n\t/* now that all the metadata is written, we save the stream offset */\n\tif(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &encoder->protected_->audio_offset, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) { /* FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED just means we didn't get the offset; no error */\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_AUDIO;\n\n\treturn FLAC__STREAM_ENCODER_INIT_STATUS_OK;\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/*\n * also disallows non-shortest-form encodings, c.f.\n *   http://www.unicode.org/versions/corrigendum1.html\n * and a more clear explanation at the end of this section:\n *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n */\n", "func_signal": "static FLaC__INLINE unsigned utf8len_(const FLAC__byte *utf8)", "code": "{\n\tFLAC__ASSERT(0 != utf8);\n\tif ((utf8[0] & 0x80) == 0) {\n\t\treturn 1;\n\t}\n\telse if ((utf8[0] & 0xE0) == 0xC0 && (utf8[1] & 0xC0) == 0x80) {\n\t\tif ((utf8[0] & 0xFE) == 0xC0) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 2;\n\t}\n\telse if ((utf8[0] & 0xF0) == 0xE0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xE0 && (utf8[1] & 0xE0) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\t/* illegal surrogates check (U+D800...U+DFFF and U+FFFE...U+FFFF) */\n\t\tif (utf8[0] == 0xED && (utf8[1] & 0xE0) == 0xA0) /* D800-DFFF */\n\t\t\treturn 0;\n\t\tif (utf8[0] == 0xEF && utf8[1] == 0xBF && (utf8[2] & 0xFE) == 0xBE) /* FFFE-FFFF */\n\t\t\treturn 0;\n\t\treturn 3;\n\t}\n\telse if ((utf8[0] & 0xF8) == 0xF0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xF0 && (utf8[1] & 0xF0) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 4;\n\t}\n\telse if ((utf8[0] & 0xFC) == 0xF8 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xF8 && (utf8[1] & 0xF8) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 5;\n\t}\n\telse if ((utf8[0] & 0xFE) == 0xFC && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80 && (utf8[5] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xFC && (utf8[1] & 0xFC) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 6;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "path": "lib\\flac121\\libFLAC\\format.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/*\n * These routines are private to libFLAC\n */\n", "func_signal": "unsigned FLAC__format_get_max_rice_partition_order(unsigned blocksize, unsigned predictor_order)", "code": "{\n\treturn\n\t\tFLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(\n\t\t\tFLAC__format_get_max_rice_partition_order_from_blocksize(blocksize),\n\t\t\tblocksize,\n\t\t\tpredictor_order\n\t\t);\n}", "path": "lib\\flac121\\libFLAC\\format.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/***********************************************************************\n *\n * Private class methods\n *\n ***********************************************************************/\n", "func_signal": "void set_defaults_(FLAC__StreamEncoder *encoder)", "code": "{\n\tFLAC__ASSERT(0 != encoder);\n\n#ifdef FLAC__MANDATORY_VERIFY_WHILE_ENCODING\n\tencoder->protected_->verify = true;\n#else\n\tencoder->protected_->verify = false;\n#endif\n\tencoder->protected_->streamable_subset = true;\n\tencoder->protected_->do_md5 = true;\n\tencoder->protected_->do_mid_side_stereo = false;\n\tencoder->protected_->loose_mid_side_stereo = false;\n\tencoder->protected_->channels = 2;\n\tencoder->protected_->bits_per_sample = 16;\n\tencoder->protected_->sample_rate = 44100;\n\tencoder->protected_->blocksize = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->protected_->num_apodizations = 1;\n\tencoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;\n\tencoder->protected_->apodizations[0].parameters.tukey.p = 0.5;\n#endif\n\tencoder->protected_->max_lpc_order = 0;\n\tencoder->protected_->qlp_coeff_precision = 0;\n\tencoder->protected_->do_qlp_coeff_prec_search = false;\n\tencoder->protected_->do_exhaustive_model_search = false;\n\tencoder->protected_->do_escape_coding = false;\n\tencoder->protected_->min_residual_partition_order = 0;\n\tencoder->protected_->max_residual_partition_order = 0;\n\tencoder->protected_->rice_parameter_search_dist = 0;\n\tencoder->protected_->total_samples_estimate = 0;\n\tencoder->protected_->metadata = 0;\n\tencoder->protected_->num_metadata_blocks = 0;\n\n\tencoder->private_->seek_table = 0;\n\tencoder->private_->disable_constant_subframes = false;\n\tencoder->private_->disable_fixed_subframes = false;\n\tencoder->private_->disable_verbatim_subframes = false;\n#if FLAC__HAS_OGG\n\tencoder->private_->is_ogg = false;\n#endif\n\tencoder->private_->read_callback = 0;\n\tencoder->private_->write_callback = 0;\n\tencoder->private_->seek_callback = 0;\n\tencoder->private_->tell_callback = 0;\n\tencoder->private_->metadata_callback = 0;\n\tencoder->private_->progress_callback = 0;\n\tencoder->private_->client_data = 0;\n\n#if FLAC__HAS_OGG\n\tFLAC__ogg_encoder_aspect_set_defaults(&encoder->protected_->ogg_encoder_aspect);\n#endif\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* An example of what FLAC__bitmath_silog2() computes:\n *\n * silog2(-10) = 5\n * silog2(- 9) = 5\n * silog2(- 8) = 4\n * silog2(- 7) = 4\n * silog2(- 6) = 4\n * silog2(- 5) = 4\n * silog2(- 4) = 3\n * silog2(- 3) = 3\n * silog2(- 2) = 2\n * silog2(- 1) = 2\n * silog2(  0) = 0\n * silog2(  1) = 2\n * silog2(  2) = 3\n * silog2(  3) = 3\n * silog2(  4) = 4\n * silog2(  5) = 4\n * silog2(  6) = 4\n * silog2(  7) = 4\n * silog2(  8) = 5\n * silog2(  9) = 5\n * silog2( 10) = 5\n */\n", "func_signal": "unsigned FLAC__bitmath_silog2(int v)", "code": "{\n\twhile(1) {\n\t\tif(v == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if(v > 0) {\n\t\t\tunsigned l = 0;\n\t\t\twhile(v) {\n\t\t\t\tl++;\n\t\t\t\tv >>= 1;\n\t\t\t}\n\t\t\treturn l+1;\n\t\t}\n\t\telse if(v == -1) {\n\t\t\treturn 2;\n\t\t}\n\t\telse {\n\t\t\tv++;\n\t\t\tv = -v;\n\t\t}\n\t}\n}", "path": "lib\\flac121\\libFLAC\\bitmath.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/***********************************************************************\n *\n * Class constructor/destructor\n *\n */\n", "func_signal": "FLAC_API FLAC__StreamEncoder *FLAC__stream_encoder_new(void)", "code": "{\n\tFLAC__StreamEncoder *encoder;\n\tunsigned i;\n\n\tFLAC__ASSERT(sizeof(int) >= 4); /* we want to die right away if this is not true */\n\n\tencoder = (FLAC__StreamEncoder*)calloc(1, sizeof(FLAC__StreamEncoder));\n\tif(encoder == 0) {\n\t\treturn 0;\n\t}\n\n\tencoder->protected_ = (FLAC__StreamEncoderProtected*)calloc(1, sizeof(FLAC__StreamEncoderProtected));\n\tif(encoder->protected_ == 0) {\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_ = (FLAC__StreamEncoderPrivate*)calloc(1, sizeof(FLAC__StreamEncoderPrivate));\n\tif(encoder->private_ == 0) {\n\t\tfree(encoder->protected_);\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_->frame = FLAC__bitwriter_new();\n\tif(encoder->private_->frame == 0) {\n\t\tfree(encoder->private_);\n\t\tfree(encoder->protected_);\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_->file = 0;\n\n\tset_defaults_(encoder);\n\n\tencoder->private_->is_being_deleted = false;\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tencoder->private_->subframe_workspace_ptr[i][0] = &encoder->private_->subframe_workspace[i][0];\n\t\tencoder->private_->subframe_workspace_ptr[i][1] = &encoder->private_->subframe_workspace[i][1];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->subframe_workspace_ptr_mid_side[i][0] = &encoder->private_->subframe_workspace_mid_side[i][0];\n\t\tencoder->private_->subframe_workspace_ptr_mid_side[i][1] = &encoder->private_->subframe_workspace_mid_side[i][1];\n\t}\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr[i][0] = &encoder->private_->partitioned_rice_contents_workspace[i][0];\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr[i][1] = &encoder->private_->partitioned_rice_contents_workspace[i][1];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][0] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0];\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][1] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1];\n\t}\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++)\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_extra[i]);\n\n\tencoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;\n\n\treturn encoder;\n}", "path": "lib\\flac121\\libFLAC\\stream_encoder.c", "repo_name": "lukeweber/flac-as3-alchemy-wrapper", "stars": 19, "license": "bsd-3-clause", "language": "c", "size": 3896}
{"docstring": "/* Process all change ranges.*/\n", "func_signal": "static void gtk_mate_parser_process_changes (GtkMateParser* self)", "code": "{\n\tgint this_parsed_upto;\n\tg_return_if_fail (self != NULL);\n\tthis_parsed_upto = -1;\n\t/* stdout.printf(\"process_changes (last_visible_line: %d)\\n\", last_visible_line);*/\n\t{\n\t\tGeeIterator* _range_it;\n\t\t/* stdout.printf(\"process_changes (last_visible_line: %d)\\n\", last_visible_line);*/\n\t\t_range_it = gee_iterable_iterator ((GeeIterable*) self->changes);\n\t\t/* stdout.printf(\"process_changes (last_visible_line: %d)\\n\", last_visible_line);*/\n\t\twhile (gee_iterator_next (_range_it)) {\n\t\t\tRangeSetRange* range;\n\t\t\tgboolean _tmp0_;\n\t\t\t/* stdout.printf(\"process_changes (last_visible_line: %d)\\n\", last_visible_line);*/\n\t\t\trange = (RangeSetRange*) gee_iterator_get (_range_it);\n\t\t\t_tmp0_ = FALSE;\n\t\t\tif (range->b > this_parsed_upto) {\n\t\t\t\t_tmp0_ = range->a <= (self->last_visible_line + self->priv->_look_ahead);\n\t\t\t} else {\n\t\t\t\t_tmp0_ = FALSE;\n\t\t\t}\n\t\t\tif (_tmp0_) {\n\t\t\t\tgint range_end;\n\t\t\t\trange_end = MIN (self->last_visible_line + self->priv->_look_ahead, range->b);\n\t\t\t\tthis_parsed_upto = gtk_mate_parser_parse_range (self, range->a, range_end);\n\t\t\t}\n\t\t\t(range == NULL) ? NULL : (range = (g_object_unref (range), NULL));\n\t\t}\n\t\t(_range_it == NULL) ? NULL : (_range_it = (g_object_unref (_range_it), NULL));\n\t}\n\t/*//stdout.printf(\"%s\\n\", root.pretty(0));*/\n\tgee_collection_clear ((GeeCollection*) self->changes->ranges);\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* stdout.printf(\"parser.change_theme(%s):out\\n\", theme.name);*/\n", "func_signal": "void gtk_mate_parser_recolour_children (GtkMateParser* self, GtkMateScope* scope)", "code": "{\n\tGSequenceIter* iter;\n\tg_return_if_fail (self != NULL);\n\tg_return_if_fail (scope != NULL);\n\titer = g_sequence_get_begin_iter (gtk_mate_scope_get_children (scope));\n\twhile (!g_sequence_iter_is_end (iter)) {\n\t\tGtkMateScope* _tmp0_;\n\t\tGtkMateScope* child;\n\t\tgboolean _tmp1_;\n\t\tgboolean _tmp2_;\n\t\t_tmp0_ = NULL;\n\t\tchild = (_tmp0_ = (GtkMateScope*) g_sequence_get (iter), (_tmp0_ == NULL) ? NULL : g_object_ref (_tmp0_));\n\t\tgtk_mate_colourer_colour_scope (self->priv->_colourer, child, FALSE, TRUE);\n\t\t_tmp1_ = FALSE;\n\t\t_tmp2_ = FALSE;\n\t\tif (GTK_MATE_IS_DOUBLE_PATTERN (child->pattern)) {\n\t\t\t_tmp2_ = GTK_MATE_DOUBLE_PATTERN (child->pattern)->content_name != NULL;\n\t\t} else {\n\t\t\t_tmp2_ = FALSE;\n\t\t}\n\t\tif (_tmp2_) {\n\t\t\t_tmp1_ = child->is_capture == FALSE;\n\t\t} else {\n\t\t\t_tmp1_ = FALSE;\n\t\t}\n\t\tif (_tmp1_) {\n\t\t\tgtk_mate_colourer_colour_scope (self->priv->_colourer, child, TRUE, TRUE);\n\t\t}\n\t\tgtk_mate_parser_recolour_children (self, child);\n\t\titer = g_sequence_iter_next (iter);\n\t\t(child == NULL) ? NULL : (child = (g_object_unref (child), NULL));\n\t}\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Return a list of bundle names like \"Ruby.tmbundle\"*/\n", "func_signal": "GeeArrayList* gtk_mate_bundle_dirs (void)", "code": "{\n\tGError * _inner_error_;\n\tchar* name;\n\tchar* share_dir;\n\tGeeArrayList* names;\n\tGeeArrayList* _tmp6_;\n\t_inner_error_ = NULL;\n\tname = NULL;\n\tshare_dir = gtk_mate_textmate_share_dir ();\n\tnames = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);\n\t{\n\t\tchar* _tmp0_;\n\t\tGDir* _tmp1_;\n\t\tGDir* d;\n\t\tchar* _tmp3_;\n\t\tconst char* _tmp2_;\n\t\tGeeArrayList* _tmp4_;\n\t\t_tmp0_ = NULL;\n\t\t_tmp1_ = NULL;\n\t\td = (_tmp1_ = g_dir_open (_tmp0_ = g_strconcat (share_dir, \"/Bundles\", NULL), 0, &_inner_error_), _tmp0_ = (g_free (_tmp0_), NULL), _tmp1_);\n\t\tif (_inner_error_ != NULL) {\n\t\t\tif (_inner_error_->domain == G_FILE_ERROR) {\n\t\t\t\tgoto __catch3_g_file_error;\n\t\t\t}\n\t\t\tgoto __finally3;\n\t\t}\n\t\t_tmp3_ = NULL;\n\t\t_tmp2_ = NULL;\n\t\twhile ((name = (_tmp3_ = (_tmp2_ = g_dir_read_name (d), (_tmp2_ == NULL) ? NULL : g_strdup (_tmp2_)), name = (g_free (name), NULL), _tmp3_)) != NULL) {\n\t\t\tif (g_str_has_suffix (name, \".tmbundle\")) {\n\t\t\t\tgee_collection_add ((GeeCollection*) names, name);\n\t\t\t}\n\t\t}\n\t\t_tmp4_ = NULL;\n\t\treturn (_tmp4_ = names, (d == NULL) ? NULL : (d = (g_dir_close (d), NULL)), name = (g_free (name), NULL), share_dir = (g_free (share_dir), NULL), _tmp4_);\n\t}\n\tgoto __finally3;\n\t__catch3_g_file_error:\n\t{\n\t\tGError * e;\n\t\te = _inner_error_;\n\t\t_inner_error_ = NULL;\n\t\t{\n\t\t\tchar* _tmp5_;\n\t\t\t_tmp5_ = NULL;\n\t\t\tfprintf (stdout, \"couldn't open: %s\\n\", _tmp5_ = g_strconcat (share_dir, \"/Bundles\", NULL));\n\t\t\t_tmp5_ = (g_free (_tmp5_), NULL);\n\t\t\t(e == NULL) ? NULL : (e = (g_error_free (e), NULL));\n\t\t}\n\t}\n\t__finally3:\n\tif (_inner_error_ != NULL) {\n\t\tname = (g_free (name), NULL);\n\t\tshare_dir = (g_free (share_dir), NULL);\n\t\t(names == NULL) ? NULL : (names = (g_object_unref (names), NULL));\n\t\tg_critical (\"file %s: line %d: uncaught error: %s\", __FILE__, __LINE__, _inner_error_->message);\n\t\tg_clear_error (&_inner_error_);\n\t\treturn NULL;\n\t}\n\t_tmp6_ = NULL;\n\treturn (_tmp6_ = NULL, name = (g_free (name), NULL), share_dir = (g_free (share_dir), NULL), (names == NULL) ? NULL : (names = (g_object_unref (names), NULL)), _tmp6_);\n}", "path": "dist\\gtkmateview.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Parse from from_line to *at least* to_line. Will parse\n more if necessary. Returns the index of the last line\n parsed.*/\n", "func_signal": "static gint gtk_mate_parser_parse_range (GtkMateParser* self, gint from_line, gint to_line)", "code": "{\n\tgint line_ix;\n\tgboolean scope_changed;\n\tgboolean scope_ever_changed;\n\tgint end_line;\n\tg_return_val_if_fail (self != NULL, 0);\n\t/* stdout.printf(\"parse_range(%d, %d)\\n\", from_line, to_line);*/\n\tline_ix = from_line;\n\tscope_changed = FALSE;\n\tscope_ever_changed = FALSE;\n\tend_line = MIN (self->last_visible_line + 100, gtk_text_buffer_get_line_count ((GtkTextBuffer*) self->priv->_buffer) - 1);\n\twhile (TRUE) {\n\t\tgboolean _tmp0_;\n\t\t_tmp0_ = FALSE;\n\t\tif (line_ix <= to_line) {\n\t\t\t_tmp0_ = TRUE;\n\t\t} else {\n\t\t\tgboolean _tmp1_;\n\t\t\t_tmp1_ = FALSE;\n\t\t\tif (scope_ever_changed) {\n\t\t\t\t_tmp1_ = line_ix <= end_line;\n\t\t\t} else {\n\t\t\t\t_tmp1_ = FALSE;\n\t\t\t}\n\t\t\t_tmp0_ = _tmp1_;\n\t\t}\n\t\tif (!_tmp0_) {\n\t\t\tbreak;\n\t\t}\n\t\tscope_changed = gtk_mate_parser_parse_line (self, line_ix++);\n\t\tif (scope_changed) {\n\t\t\tscope_ever_changed = TRUE;\n\t\t\t/* In the old scheme this wasn't necessary because \n\t\t\t the scope_at used a simple scan from the front. The GSequences\n\t\t\t on the other hand can get confused if the later scopes\n\t\t\t are inconsistent with earler ones. So we have to clear everything.\n\t\t\t TODO: figure out a way to OPTIMIZE this again.*/\n\t\t\tgtk_mate_scope_clear_after (self->root, line_ix, -1);\n\t\t\tgtk_mate_parser_remove_colour_after (self, line_ix, 0);\n\t\t\tself->parsed_upto = line_ix;\n\t\t}\n\t}\n\t/* stdout.printf(\"parse_line returned: %s\\n\", scope_changed ? \"true\" : \"false\");\n\tstdout.printf(\"pretty:\\n%s\\n\", root.pretty(2));*/\n\treturn to_line;\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Started: 30 Aug 08*/\n", "func_signal": "StringHelper* string_helper_construct (GType object_type)", "code": "{\n\tStringHelper * self;\n\tself = g_object_newv (object_type, 0, NULL);\n\treturn self;\n}", "path": "dist\\string_helper.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Opens scopes for captures AND creates closing regexp from\n captures if necessary.*/\n", "func_signal": "void gtk_mate_parser_handle_captures (GtkMateParser* self, gint line_ix, gint length, const char* line, GtkMateScope* scope, GtkMateMarker* m, GeeArrayList* all_scopes, GeeArrayList* closed_scopes)", "code": "{\n\tOnigRx* _tmp0_;\n\tg_return_if_fail (self != NULL);\n\tg_return_if_fail (line != NULL);\n\tg_return_if_fail (scope != NULL);\n\tg_return_if_fail (m != NULL);\n\tg_return_if_fail (all_scopes != NULL);\n\tg_return_if_fail (closed_scopes != NULL);\n\t_tmp0_ = NULL;\n\t_tmp0_ = gtk_mate_parser_make_closing_regex (self, line, scope, m);\n\t(_tmp0_ == NULL) ? NULL : (_tmp0_ = (g_object_unref (_tmp0_), NULL));\n\tgtk_mate_parser_collect_child_captures (self, line_ix, length, scope, m, all_scopes, closed_scopes);\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Loads themes from /usr/share/textmate/Themes/. */\n", "func_signal": "void gtk_mate_load_themes (void)", "code": "{\n\tGError * _inner_error_;\n\tGeeArrayList* _tmp0_;\n\t_inner_error_ = NULL;\n\tif (gtk_mate_theme__themes != NULL) {\n\t\treturn;\n\t}\n\t_tmp0_ = NULL;\n\tgtk_mate_theme__themes = (_tmp0_ = gee_array_list_new (GTK_MATE_TYPE_THEME, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), (gtk_mate_theme__themes == NULL) ? NULL : (gtk_mate_theme__themes = (g_object_unref (gtk_mate_theme__themes), NULL)), _tmp0_);\n\t{\n\t\tGeeArrayList* _tmp1_;\n\t\tGeeIterator* _tmp2_;\n\t\tGeeIterator* _fn_it;\n\t\t_tmp1_ = NULL;\n\t\t_tmp2_ = NULL;\n\t\t_fn_it = (_tmp2_ = gee_iterable_iterator ((GeeIterable*) (_tmp1_ = gtk_mate_theme_theme_filenames ())), (_tmp1_ == NULL) ? NULL : (_tmp1_ = (g_object_unref (_tmp1_), NULL)), _tmp2_);\n\t\twhile (gee_iterator_next (_fn_it)) {\n\t\t\tchar* fn;\n\t\t\tfn = (char*) gee_iterator_get (_fn_it);\n\t\t\t{\n\t\t\t\tPListDict* plist;\n\t\t\t\tGtkMateTheme* theme;\n\t\t\t\tplist = plist_parse (fn, &_inner_error_);\n\t\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\t\tif (_inner_error_->domain == XML_ERROR) {\n\t\t\t\t\t\tgoto __catch2_xml_error;\n\t\t\t\t\t}\n\t\t\t\t\tgoto __finally2;\n\t\t\t\t}\n\t\t\t\ttheme = gtk_mate_theme_create_from_plist (PLIST_DICT (plist));\n\t\t\t\tif (theme != NULL) {\n\t\t\t\t\tgee_collection_add ((GeeCollection*) gtk_mate_theme__themes, theme);\n\t\t\t\t}\n\t\t\t\t(plist == NULL) ? NULL : (plist = (g_object_unref (plist), NULL));\n\t\t\t\t(theme == NULL) ? NULL : (theme = (g_object_unref (theme), NULL));\n\t\t\t}\n\t\t\tgoto __finally2;\n\t\t\t__catch2_xml_error:\n\t\t\t{\n\t\t\t\tGError * e;\n\t\t\t\te = _inner_error_;\n\t\t\t\t_inner_error_ = NULL;\n\t\t\t\t{\n\t\t\t\t\tfprintf (stdout, \"error opening %s\\n\", fn);\n\t\t\t\t\t(e == NULL) ? NULL : (e = (g_error_free (e), NULL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t__finally2:\n\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\tfn = (g_free (fn), NULL);\n\t\t\t\t(_fn_it == NULL) ? NULL : (_fn_it = (g_object_unref (_fn_it), NULL));\n\t\t\t\tg_critical (\"file %s: line %d: uncaught error: %s\", __FILE__, __LINE__, _inner_error_->message);\n\t\t\t\tg_clear_error (&_inner_error_);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfn = (g_free (fn), NULL);\n\t\t}\n\t\t(_fn_it == NULL) ? NULL : (_fn_it = (g_object_unref (_fn_it), NULL));\n\t}\n}", "path": "dist\\gtkmateview.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Loads bundles (in particular, grammars) from \n /usr/share/textmate/Bundles or from the location in\n textmate_dir*/\n", "func_signal": "gint gtk_mate_load_bundles (void)", "code": "{\n\tGError * _inner_error_;\n\tGeeArrayList* _tmp1_;\n\tGeeArrayList* _tmp2_;\n\tchar* syntax_dir;\n\tchar* name;\n\tGtkMateBundle* bundle;\n\tGtkMateGrammar* grammar;\n\tPListDict* plist;\n\tgint _tmp24_;\n\t_inner_error_ = NULL;\n\tif (gtk_mate_buffer_bundles != NULL) {\n\t\treturn 1;\n\t}\n\t_tmp1_ = NULL;\n\tgtk_mate_buffer_bundles = (_tmp1_ = gee_array_list_new (GTK_MATE_TYPE_BUNDLE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), (gtk_mate_buffer_bundles == NULL) ? NULL : (gtk_mate_buffer_bundles = (g_object_unref (gtk_mate_buffer_bundles), NULL)), _tmp1_);\n\t_tmp2_ = NULL;\n\tgtk_mate_buffer_themes = (_tmp2_ = gee_array_list_new (GTK_MATE_TYPE_THEME, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), (gtk_mate_buffer_themes == NULL) ? NULL : (gtk_mate_buffer_themes = (g_object_unref (gtk_mate_buffer_themes), NULL)), _tmp2_);\n\tsyntax_dir = NULL;\n\tname = NULL;\n\tbundle = NULL;\n\tgrammar = NULL;\n\tplist = NULL;\n\t{\n\t\tGeeArrayList* _tmp3_;\n\t\tGeeIterator* _tmp4_;\n\t\tGeeIterator* _bundle_dir_it;\n\t\t_tmp3_ = NULL;\n\t\t_tmp4_ = NULL;\n\t\t_bundle_dir_it = (_tmp4_ = gee_iterable_iterator ((GeeIterable*) (_tmp3_ = gtk_mate_bundle_dirs ())), (_tmp3_ == NULL) ? NULL : (_tmp3_ = (g_object_unref (_tmp3_), NULL)), _tmp4_);\n\t\twhile (gee_iterator_next (_bundle_dir_it)) {\n\t\t\tchar* bundle_dir;\n\t\t\tGtkMateBundle* _tmp7_;\n\t\t\tgint _tmp6__length1;\n\t\t\tchar** _tmp6_;\n\t\t\tchar** _tmp5_;\n\t\t\tchar* _tmp11_;\n\t\t\tchar* _tmp10_;\n\t\t\tchar* _tmp9_;\n\t\t\tchar* _tmp8_;\n\t\t\tbundle_dir = (char*) gee_iterator_get (_bundle_dir_it);\n\t\t\t_tmp7_ = NULL;\n\t\t\t_tmp6_ = NULL;\n\t\t\t_tmp5_ = NULL;\n\t\t\tbundle = (_tmp7_ = g_object_ref_sink (gtk_mate_bundle_new ((_tmp6_ = _tmp5_ = g_strsplit (bundle_dir, \".\", 0), _tmp6__length1 = _vala_array_length (_tmp5_), _tmp6_)[0])), (bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL)), _tmp7_);\n\t\t\t_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);\n\t\t\tgee_collection_add ((GeeCollection*) gtk_mate_buffer_bundles, bundle);\n\t\t\t_tmp11_ = NULL;\n\t\t\t_tmp10_ = NULL;\n\t\t\t_tmp9_ = NULL;\n\t\t\t_tmp8_ = NULL;\n\t\t\tsyntax_dir = (_tmp11_ = g_strconcat (_tmp10_ = g_strconcat (_tmp9_ = g_strconcat (_tmp8_ = gtk_mate_textmate_share_dir (), \"/Bundles/\", NULL), bundle_dir, NULL), \"/Syntaxes\", NULL), syntax_dir = (g_free (syntax_dir), NULL), _tmp11_);\n\t\t\t_tmp10_ = (g_free (_tmp10_), NULL);\n\t\t\t_tmp9_ = (g_free (_tmp9_), NULL);\n\t\t\t_tmp8_ = (g_free (_tmp8_), NULL);\n\t\t\tif (g_file_test (syntax_dir, G_FILE_TEST_EXISTS)) {\n\t\t\t\t{\n\t\t\t\t\tGDir* d;\n\t\t\t\t\tchar* _tmp13_;\n\t\t\t\t\tconst char* _tmp12_;\n\t\t\t\t\td = g_dir_open (syntax_dir, 0, &_inner_error_);\n\t\t\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\t\t\tif (_inner_error_->domain == G_FILE_ERROR) {\n\t\t\t\t\t\t\tgoto __catch0_g_file_error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto __finally0;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp13_ = NULL;\n\t\t\t\t\t_tmp12_ = NULL;\n\t\t\t\t\twhile ((name = (_tmp13_ = (_tmp12_ = g_dir_read_name (d), (_tmp12_ == NULL) ? NULL : g_strdup (_tmp12_)), name = (g_free (name), NULL), _tmp13_)) != NULL) {\n\t\t\t\t\t\tgboolean _tmp14_;\n\t\t\t\t\t\t_tmp14_ = FALSE;\n\t\t\t\t\t\tif (_vala_strcmp0 (name, \".svn\") != 0) {\n\t\t\t\t\t\t\tgboolean _tmp15_;\n\t\t\t\t\t\t\t_tmp15_ = FALSE;\n\t\t\t\t\t\t\tif (g_str_has_suffix (name, \".tmLanguage\")) {\n\t\t\t\t\t\t\t\t_tmp15_ = TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_tmp15_ = g_str_has_suffix (name, \".plist\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_tmp14_ = _tmp15_;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_tmp14_ = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_tmp14_) {\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar* _tmp17_;\n\t\t\t\t\t\t\t\tchar* _tmp16_;\n\t\t\t\t\t\t\t\tPListDict* _tmp18_;\n\t\t\t\t\t\t\t\tPListDict* _tmp19_;\n\t\t\t\t\t\t\t\tPListDict* _tmp20_;\n\t\t\t\t\t\t\t\t_tmp17_ = NULL;\n\t\t\t\t\t\t\t\t_tmp16_ = NULL;\n\t\t\t\t\t\t\t\t_tmp18_ = NULL;\n\t\t\t\t\t\t\t\t_tmp19_ = (_tmp18_ = plist_parse (_tmp17_ = g_strconcat (_tmp16_ = g_strconcat (syntax_dir, \"/\", NULL), name, NULL), &_inner_error_), _tmp17_ = (g_free (_tmp17_), NULL), _tmp16_ = (g_free (_tmp16_), NULL), _tmp18_);\n\t\t\t\t\t\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\t\t\t\t\t\tif (_inner_error_->domain == XML_ERROR) {\n\t\t\t\t\t\t\t\t\t\tgoto __catch1_xml_error;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgoto __finally1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_tmp20_ = NULL;\n\t\t\t\t\t\t\t\tplist = (_tmp20_ = _tmp19_, (plist == NULL) ? NULL : (plist = (g_object_unref (plist), NULL)), _tmp20_);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto __finally1;\n\t\t\t\t\t\t\t__catch1_xml_error:\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGError * e;\n\t\t\t\t\t\t\t\te = _inner_error_;\n\t\t\t\t\t\t\t\t_inner_error_ = NULL;\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar* _tmp22_;\n\t\t\t\t\t\t\t\t\tchar* _tmp21_;\n\t\t\t\t\t\t\t\t\t_tmp22_ = NULL;\n\t\t\t\t\t\t\t\t\t_tmp21_ = NULL;\n\t\t\t\t\t\t\t\t\tfprintf (stdout, \"error opening %s\\n\", _tmp22_ = g_strconcat (_tmp21_ = g_strconcat (syntax_dir, \"/\", NULL), name, NULL));\n\t\t\t\t\t\t\t\t\t_tmp22_ = (g_free (_tmp22_), NULL);\n\t\t\t\t\t\t\t\t\t_tmp21_ = (g_free (_tmp21_), NULL);\n\t\t\t\t\t\t\t\t\t(e == NULL) ? NULL : (e = (g_error_free (e), NULL));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t__finally1:\n\t\t\t\t\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\t\t\t\t\t(d == NULL) ? NULL : (d = (g_dir_close (d), NULL));\n\t\t\t\t\t\t\t\tif (_inner_error_->domain == G_FILE_ERROR) {\n\t\t\t\t\t\t\t\t\tgoto __catch0_g_file_error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgoto __finally0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (plist != NULL) {\n\t\t\t\t\t\t\t\tGtkMateGrammar* _tmp23_;\n\t\t\t\t\t\t\t\t_tmp23_ = NULL;\n\t\t\t\t\t\t\t\tgrammar = (_tmp23_ = g_object_ref_sink (gtk_mate_grammar_new (plist)), (grammar == NULL) ? NULL : (grammar = (g_object_unref (grammar), NULL)), _tmp23_);\n\t\t\t\t\t\t\t\tgtk_mate_grammar_set_filename (grammar, name);\n\t\t\t\t\t\t\t\tgee_collection_add ((GeeCollection*) bundle->grammars, grammar);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t(d == NULL) ? NULL : (d = (g_dir_close (d), NULL));\n\t\t\t\t}\n\t\t\t\tgoto __finally0;\n\t\t\t\t__catch0_g_file_error:\n\t\t\t\t{\n\t\t\t\t\tGError * e;\n\t\t\t\t\te = _inner_error_;\n\t\t\t\t\t_inner_error_ = NULL;\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf (stdout, \"error opening %s\\n\", syntax_dir);\n\t\t\t\t\t\t(e == NULL) ? NULL : (e = (g_error_free (e), NULL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t__finally0:\n\t\t\t\tif (_inner_error_ != NULL) {\n\t\t\t\t\tbundle_dir = (g_free (bundle_dir), NULL);\n\t\t\t\t\t(_bundle_dir_it == NULL) ? NULL : (_bundle_dir_it = (g_object_unref (_bundle_dir_it), NULL));\n\t\t\t\t\tsyntax_dir = (g_free (syntax_dir), NULL);\n\t\t\t\t\tname = (g_free (name), NULL);\n\t\t\t\t\t(bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL));\n\t\t\t\t\t(grammar == NULL) ? NULL : (grammar = (g_object_unref (grammar), NULL));\n\t\t\t\t\t(plist == NULL) ? NULL : (plist = (g_object_unref (plist), NULL));\n\t\t\t\t\tg_critical (\"file %s: line %d: uncaught error: %s\", __FILE__, __LINE__, _inner_error_->message);\n\t\t\t\t\tg_clear_error (&_inner_error_);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbundle_dir = (g_free (bundle_dir), NULL);\n\t\t}\n\t\t(_bundle_dir_it == NULL) ? NULL : (_bundle_dir_it = (g_object_unref (_bundle_dir_it), NULL));\n\t}\n\t{\n\t\tGeeIterator* _b_it;\n\t\t_b_it = gee_iterable_iterator ((GeeIterable*) gtk_mate_buffer_bundles);\n\t\twhile (gee_iterator_next (_b_it)) {\n\t\t\tGtkMateBundle* b;\n\t\t\tb = (GtkMateBundle*) gee_iterator_get (_b_it);\n\t\t\t{\n\t\t\t\tGeeIterator* _g_it;\n\t\t\t\t_g_it = gee_iterable_iterator ((GeeIterable*) b->grammars);\n\t\t\t\twhile (gee_iterator_next (_g_it)) {\n\t\t\t\t\tGtkMateGrammar* g;\n\t\t\t\t\tg = (GtkMateGrammar*) gee_iterator_get (_g_it);\n\t\t\t\t\tgtk_mate_grammar_init_for_reference (g);\n\t\t\t\t\t(g == NULL) ? NULL : (g = (g_object_unref (g), NULL));\n\t\t\t\t}\n\t\t\t\t(_g_it == NULL) ? NULL : (_g_it = (g_object_unref (_g_it), NULL));\n\t\t\t}\n\t\t\t(b == NULL) ? NULL : (b = (g_object_unref (b), NULL));\n\t\t}\n\t\t(_b_it == NULL) ? NULL : (_b_it = (g_object_unref (_b_it), NULL));\n\t}\n\treturn (_tmp24_ = -1, syntax_dir = (g_free (syntax_dir), NULL), name = (g_free (name), NULL), (bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL)), (grammar == NULL) ? NULL : (grammar = (g_object_unref (grammar), NULL)), (plist == NULL) ? NULL : (plist = (g_object_unref (plist), NULL)), _tmp24_);\n}", "path": "dist\\gtkmateview.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Loads the properties that are needed whether or not \n the grammar ever used.*/\n", "func_signal": "void gtk_mate_grammar_init_for_reference (GtkMateGrammar* self)", "code": "{\n\tPListNode* nm;\n\tPListNode* flm;\n\tPListNode* ke;\n\tPListNode* sn;\n\tPListNode* cm;\n\tPListNode* filetypes;\n\tg_return_if_fail (self != NULL);\n\tnm = plist_dict_get (self->priv->_plist, \"name\");\n\tif (nm != NULL) {\n\t\tgtk_mate_grammar_set_name (self, PLIST_STRING (nm)->str);\n\t}\n\tflm = plist_dict_get (self->priv->_plist, \"firstLineMatch\");\n\tif (flm != NULL) {\n\t\tOnigRx* _tmp0_;\n\t\t_tmp0_ = NULL;\n\t\tself->first_line_match = (_tmp0_ = onig_rx_make1 (PLIST_STRING (flm)->str), (self->first_line_match == NULL) ? NULL : (self->first_line_match = (g_object_unref (self->first_line_match), NULL)), _tmp0_);\n\t}\n\tke = plist_dict_get (self->priv->_plist, \"keyEquivalent\");\n\tif (ke != NULL) {\n\t\tchar* _tmp2_;\n\t\tconst char* _tmp1_;\n\t\t_tmp2_ = NULL;\n\t\t_tmp1_ = NULL;\n\t\tself->key_equivalent = (_tmp2_ = (_tmp1_ = PLIST_STRING (ke)->str, (_tmp1_ == NULL) ? NULL : g_strdup (_tmp1_)), self->key_equivalent = (g_free (self->key_equivalent), NULL), _tmp2_);\n\t}\n\tsn = plist_dict_get (self->priv->_plist, \"scopeName\");\n\tif (sn != NULL) {\n\t\tchar* _tmp4_;\n\t\tconst char* _tmp3_;\n\t\t_tmp4_ = NULL;\n\t\t_tmp3_ = NULL;\n\t\tself->scope_name = (_tmp4_ = (_tmp3_ = PLIST_STRING (sn)->str, (_tmp3_ == NULL) ? NULL : g_strdup (_tmp3_)), self->scope_name = (g_free (self->scope_name), NULL), _tmp4_);\n\t}\n\tcm = plist_dict_get (self->priv->_plist, \"comment\");\n\tif (cm != NULL) {\n\t\tchar* _tmp6_;\n\t\tconst char* _tmp5_;\n\t\t_tmp6_ = NULL;\n\t\t_tmp5_ = NULL;\n\t\tself->comment = (_tmp6_ = (_tmp5_ = PLIST_STRING (cm)->str, (_tmp5_ == NULL) ? NULL : g_strdup (_tmp5_)), self->comment = (g_free (self->comment), NULL), _tmp6_);\n\t}\n\tfiletypes = plist_dict_get (self->priv->_plist, \"fileTypes\");\n\tif (filetypes != NULL) {\n\t\tPListArray* _tmp7_;\n\t\tPListArray* fts;\n\t\tchar** _tmp9_;\n\t\tgint _tmp8_;\n\t\tgint i;\n\t\t_tmp7_ = NULL;\n\t\tfts = (_tmp7_ = PLIST_ARRAY (filetypes), (_tmp7_ == NULL) ? NULL : g_object_ref (_tmp7_));\n\t\t_tmp9_ = NULL;\n\t\tself->file_types = (_tmp9_ = g_new0 (char*, (_tmp8_ = gee_collection_get_size ((GeeCollection*) fts->array)) + 1), self->file_types = (_vala_array_free (self->file_types, self->file_types_length1, (GDestroyNotify) g_free), NULL), self->file_types_length1 = _tmp8_, _tmp9_);\n\t\ti = 0;\n\t\t{\n\t\t\tGeeIterator* _n_it;\n\t\t\t_n_it = gee_iterable_iterator ((GeeIterable*) fts->array);\n\t\t\twhile (gee_iterator_next (_n_it)) {\n\t\t\t\tPListNode* n;\n\t\t\t\tchar* _tmp12_;\n\t\t\t\tchar* *_tmp11_;\n\t\t\t\tconst char* _tmp10_;\n\t\t\t\tn = (PListNode*) gee_iterator_get (_n_it);\n\t\t\t\t_tmp12_ = NULL;\n\t\t\t\t_tmp10_ = NULL;\n\t\t\t\t_tmp11_ = &self->file_types[i++];\n\t\t\t\t(*_tmp11_) = (_tmp12_ = (_tmp10_ = PLIST_STRING (n)->str, (_tmp10_ == NULL) ? NULL : g_strdup (_tmp10_)), (*_tmp11_) = (g_free ((*_tmp11_)), NULL), _tmp12_);\n\t\t\t\t(n == NULL) ? NULL : (n = (g_object_unref (n), NULL));\n\t\t\t}\n\t\t\t(_n_it == NULL) ? NULL : (_n_it = (g_object_unref (_n_it), NULL));\n\t\t}\n\t\t(fts == NULL) ? NULL : (fts = (g_object_unref (fts), NULL));\n\t}\n\t(nm == NULL) ? NULL : (nm = (g_object_unref (nm), NULL));\n\t(flm == NULL) ? NULL : (flm = (g_object_unref (flm), NULL));\n\t(ke == NULL) ? NULL : (ke = (g_object_unref (ke), NULL));\n\t(sn == NULL) ? NULL : (sn = (g_object_unref (sn), NULL));\n\t(cm == NULL) ? NULL : (cm = (g_object_unref (cm), NULL));\n\t(filetypes == NULL) ? NULL : (filetypes = (g_object_unref (filetypes), NULL));\n}", "path": "dist\\grammar.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Return the textmate assets directory path,\n e.g. /usr/share/textmate*/\n", "func_signal": "char* gtk_mate_textmate_share_dir (void)", "code": "{\n\tchar* share_dir;\n\tchar* _tmp3_;\n\tchar* _tmp5_;\n\tif (gtk_mate_textmate_dir != NULL) {\n\t\tconst char* _tmp0_;\n\t\t_tmp0_ = NULL;\n\t\treturn (_tmp0_ = gtk_mate_textmate_dir, (_tmp0_ == NULL) ? NULL : g_strdup (_tmp0_));\n\t}\n\tshare_dir = g_strdup (\"/usr/local/share/textmate\");\n\tif (g_file_test (share_dir, G_FILE_TEST_EXISTS)) {\n\t\treturn share_dir;\n\t}\n\t_tmp3_ = NULL;\n\tshare_dir = (_tmp3_ = g_strdup (\"/usr/share/textmate\"), share_dir = (g_free (share_dir), NULL), _tmp3_);\n\tif (g_file_test (share_dir, G_FILE_TEST_EXISTS)) {\n\t\treturn share_dir;\n\t}\n\tfprintf (stdout, \"couldn't find /usr/share/textmate or /usr/local/share/textmate\\n\");\n\t_tmp5_ = NULL;\n\treturn (_tmp5_ = NULL, share_dir = (g_free (share_dir), NULL), _tmp5_);\n}", "path": "dist\\gtkmateview.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* compare two Scope's. Returns 1 if a is later than b,\n -1 if a is before b and 0 if b is overlapping with a*/\n", "func_signal": "gint gtk_mate_scope_compare (GtkMateScope* a, GtkMateScope* b, void* data)", "code": "{\n\tGtkTextIter _tmp1_ = {0};\n\tGtkTextIter _tmp0_ = {0};\n\tg_return_val_if_fail (a != NULL, 0);\n\tg_return_val_if_fail (b != NULL, 0);\n\treturn gtk_text_iter_compare ((_tmp0_ = gtk_mate_scope_start_iter (a), &_tmp0_), (_tmp1_ = gtk_mate_scope_start_iter (b), &_tmp1_));\n}", "path": "dist\\scope.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Sets the grammar by examining the first line. If unable to find\n a grammar, sets the grammar to null. Returns the grammar\n name or null.*/\n", "func_signal": "char* gtk_mate_buffer_set_grammar_by_first_line (GtkMateBuffer* self, const char* first_line)", "code": "{\n\tOnigRx* re;\n\tchar* _tmp6_;\n\tg_return_val_if_fail (self != NULL, NULL);\n\tg_return_val_if_fail (first_line != NULL, NULL);\n\tre = NULL;\n\t{\n\t\tGeeIterator* _bundle_it;\n\t\t_bundle_it = gee_iterable_iterator ((GeeIterable*) gtk_mate_buffer_bundles);\n\t\twhile (gee_iterator_next (_bundle_it)) {\n\t\t\tGtkMateBundle* bundle;\n\t\t\tbundle = (GtkMateBundle*) gee_iterator_get (_bundle_it);\n\t\t\t{\n\t\t\t\tGeeIterator* _gr_it;\n\t\t\t\t_gr_it = gee_iterable_iterator ((GeeIterable*) bundle->grammars);\n\t\t\t\twhile (gee_iterator_next (_gr_it)) {\n\t\t\t\t\tGtkMateGrammar* gr;\n\t\t\t\t\tOnigRx* _tmp1_;\n\t\t\t\t\tOnigRx* _tmp0_;\n\t\t\t\t\tgr = (GtkMateGrammar*) gee_iterator_get (_gr_it);\n\t\t\t\t\t_tmp1_ = NULL;\n\t\t\t\t\t_tmp0_ = NULL;\n\t\t\t\t\tif ((re = (_tmp1_ = (_tmp0_ = gr->first_line_match, (_tmp0_ == NULL) ? NULL : g_object_ref (_tmp0_)), (re == NULL) ? NULL : (re = (g_object_unref (re), NULL)), _tmp1_)) != NULL) {\n\t\t\t\t\t\tOnigMatch* _tmp2_;\n\t\t\t\t\t\tgboolean _tmp3_;\n\t\t\t\t\t\t_tmp2_ = NULL;\n\t\t\t\t\t\tif ((_tmp3_ = (_tmp2_ = onig_rx_search (re, first_line, 0, (gint) strlen (first_line))) != NULL, (_tmp2_ == NULL) ? NULL : (_tmp2_ = (g_object_unref (_tmp2_), NULL)), _tmp3_)) {\n\t\t\t\t\t\t\tconst char* _tmp4_;\n\t\t\t\t\t\t\tchar* _tmp5_;\n\t\t\t\t\t\t\tgtk_mate_buffer_set_grammar_by_name (self, gtk_mate_grammar_get_name (gr));\n\t\t\t\t\t\t\t_tmp4_ = NULL;\n\t\t\t\t\t\t\t_tmp5_ = NULL;\n\t\t\t\t\t\t\treturn (_tmp5_ = (_tmp4_ = gtk_mate_grammar_get_name (gr), (_tmp4_ == NULL) ? NULL : g_strdup (_tmp4_)), (gr == NULL) ? NULL : (gr = (g_object_unref (gr), NULL)), (_gr_it == NULL) ? NULL : (_gr_it = (g_object_unref (_gr_it), NULL)), (bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL)), (_bundle_it == NULL) ? NULL : (_bundle_it = (g_object_unref (_bundle_it), NULL)), (re == NULL) ? NULL : (re = (g_object_unref (re), NULL)), _tmp5_);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t(gr == NULL) ? NULL : (gr = (g_object_unref (gr), NULL));\n\t\t\t\t}\n\t\t\t\t(_gr_it == NULL) ? NULL : (_gr_it = (g_object_unref (_gr_it), NULL));\n\t\t\t}\n\t\t\t(bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL));\n\t\t}\n\t\t(_bundle_it == NULL) ? NULL : (_bundle_it = (g_object_unref (_bundle_it), NULL));\n\t}\n\t_tmp6_ = NULL;\n\treturn (_tmp6_ = NULL, (re == NULL) ? NULL : (re = (g_object_unref (re), NULL)), _tmp6_);\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Get text of line, including the \"\\n\" if present. Returns null if line \n does not exist.*/\n", "func_signal": "char* gtk_mate_buffer_get_line (GtkMateBuffer* self, gint line)", "code": "{\n\tGtkTextIter ei = {0};\n\tconst char* _tmp3_;\n\tGtkTextIter _tmp2_ = {0};\n\tg_return_val_if_fail (self != NULL, NULL);\n\tif (line == (gtk_text_buffer_get_line_count ((GtkTextBuffer*) self) - 1)) {\n\t\tei = gtk_mate_buffer_end_iter (self);\n\t} else {\n\t\tgboolean _tmp0_;\n\t\t_tmp0_ = FALSE;\n\t\tif (line > (gtk_text_buffer_get_line_count ((GtkTextBuffer*) self) - 1)) {\n\t\t\t_tmp0_ = TRUE;\n\t\t} else {\n\t\t\t_tmp0_ = line < 0;\n\t\t}\n\t\tif (_tmp0_) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tei = gtk_mate_buffer_line_start_iter (self, line + 1);\n\t\t}\n\t}\n\t_tmp3_ = NULL;\n\treturn (_tmp3_ = gtk_text_buffer_get_slice ((GtkTextBuffer*) self, (_tmp2_ = gtk_mate_buffer_line_start_iter (self, line), &_tmp2_), &ei, TRUE), (_tmp3_ == NULL) ? NULL : g_strdup (_tmp3_));\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Iter at end of line, after the \"\\n\" (if present).*/\n", "func_signal": "GtkTextIter gtk_mate_buffer_line_end_iter (GtkMateBuffer* self, gint line)", "code": "{\n\tif (line >= (gtk_text_buffer_get_line_count ((GtkTextBuffer*) self) - 1)) {\n\t\treturn gtk_mate_buffer_end_iter (self);\n\t} else {\n\t\treturn gtk_mate_buffer_line_start_iter (self, line + 1);\n\t}\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Iter at end of line, before the \"\\n\" (if present).*/\n", "func_signal": "GtkTextIter gtk_mate_buffer_line_end_iter1 (GtkMateBuffer* self, gint line)", "code": "{\n\tif (line >= (gtk_text_buffer_get_line_count ((GtkTextBuffer*) self) - 1)) {\n\t\treturn gtk_mate_buffer_end_iter (self);\n\t} else {\n\t\tGtkTextIter i;\n\t\ti = gtk_mate_buffer_line_start_iter (self, line + 1);\n\t\tgtk_text_iter_backward_char (&i);\n\t\treturn i;\n\t}\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* this method is mainly for testing in the Ruby specs*/\n", "func_signal": "char* gtk_mate_matcher_test_rank (const char* selector_a, const char* selector_b, const char* scope_string)", "code": "{\n\tOnigMatch* m1;\n\tOnigMatch* m2;\n\tOnigMatch* _tmp2_;\n\tgboolean _tmp1_;\n\tOnigMatch* _tmp0_;\n\tOnigMatch* _tmp5_;\n\tgboolean _tmp4_;\n\tOnigMatch* _tmp3_;\n\tgint r;\n\tg_return_val_if_fail (selector_a != NULL, NULL);\n\tg_return_val_if_fail (selector_b != NULL, NULL);\n\tg_return_val_if_fail (scope_string != NULL, NULL);\n\tm1 = NULL;\n\tm2 = NULL;\n\t_tmp2_ = NULL;\n\t_tmp0_ = NULL;\n\t_tmp1_ = gtk_mate_matcher_match (selector_a, scope_string, &_tmp0_);\n\tm1 = (_tmp2_ = _tmp0_, (m1 == NULL) ? NULL : (m1 = (g_object_unref (m1), NULL)), _tmp2_);\n\t_tmp1_;\n\t_tmp5_ = NULL;\n\t_tmp3_ = NULL;\n\t_tmp4_ = gtk_mate_matcher_match (selector_b, scope_string, &_tmp3_);\n\tm2 = (_tmp5_ = _tmp3_, (m2 == NULL) ? NULL : (m2 = (g_object_unref (m2), NULL)), _tmp5_);\n\t_tmp4_;\n\tr = gtk_mate_matcher_compare_match (scope_string, m1, m2);\n\tif (r > 0) {\n\t\tconst char* _tmp6_;\n\t\tchar* _tmp7_;\n\t\t_tmp6_ = NULL;\n\t\t_tmp7_ = NULL;\n\t\treturn (_tmp7_ = (_tmp6_ = selector_a, (_tmp6_ == NULL) ? NULL : g_strdup (_tmp6_)), (m1 == NULL) ? NULL : (m1 = (g_object_unref (m1), NULL)), (m2 == NULL) ? NULL : (m2 = (g_object_unref (m2), NULL)), _tmp7_);\n\t} else {\n\t\tif (r == 0) {\n\t\t\tchar* _tmp8_;\n\t\t\tchar* _tmp9_;\n\t\t\tchar* _tmp10_;\n\t\t\t_tmp8_ = NULL;\n\t\t\t_tmp9_ = NULL;\n\t\t\t_tmp10_ = NULL;\n\t\t\treturn (_tmp10_ = (_tmp9_ = g_strconcat (_tmp8_ = g_strconcat (selector_a, \" == \", NULL), selector_b, NULL), _tmp8_ = (g_free (_tmp8_), NULL), _tmp9_), (m1 == NULL) ? NULL : (m1 = (g_object_unref (m1), NULL)), (m2 == NULL) ? NULL : (m2 = (g_object_unref (m2), NULL)), _tmp10_);\n\t\t} else {\n\t\t\tconst char* _tmp11_;\n\t\t\tchar* _tmp12_;\n\t\t\t_tmp11_ = NULL;\n\t\t\t_tmp12_ = NULL;\n\t\t\treturn (_tmp12_ = (_tmp11_ = selector_b, (_tmp11_ == NULL) ? NULL : g_strdup (_tmp11_)), (m1 == NULL) ? NULL : (m1 = (g_object_unref (m1), NULL)), (m2 == NULL) ? NULL : (m2 = (g_object_unref (m2), NULL)), _tmp12_);\n\t\t}\n\t}\n\t(m1 == NULL) ? NULL : (m1 = (g_object_unref (m1), NULL));\n\t(m2 == NULL) ? NULL : (m2 = (g_object_unref (m2), NULL));\n}", "path": "dist\\matcher.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Signal.connect_after(buffer.get_tag_table(), \"tag_added\", \n  (GLib.Callback) Parser.static_tag_added_after_handler, null);*/\n", "func_signal": "void gtk_mate_parser_insert_text_handler (GtkMateParser* self, GtkMateBuffer* bf, const GtkTextIter* pos, const char* text, gint length)", "code": "{\n\tchar** _tmp1_;\n\tgint ss_size;\n\tgint ss_length1;\n\tchar** _tmp0_;\n\tchar** ss;\n\tgint num_lines;\n\tg_return_if_fail (self != NULL);\n\tg_return_if_fail (bf != NULL);\n\tg_return_if_fail (text != NULL);\n\t/*//stdout.printf(\"insert_text(pos, \\\"%s\\\", %d)\\n\", text, length);*/\n\t_tmp1_ = NULL;\n\t_tmp0_ = NULL;\n\tss = (_tmp1_ = _tmp0_ = g_strsplit (text, \"\\n\", 0), ss_length1 = _vala_array_length (_tmp0_), ss_size = ss_length1, _tmp1_);\n\tnum_lines = -1;\n\t{\n\t\tchar** s_collection;\n\t\tint s_collection_length1;\n\t\tint s_it;\n\t\ts_collection = ss;\n\t\ts_collection_length1 = ss_length1;\n\t\tfor (s_it = 0; s_it < ss_length1; s_it = s_it + 1) {\n\t\t\tconst char* _tmp2_;\n\t\t\tchar* s;\n\t\t\t_tmp2_ = NULL;\n\t\t\ts = (_tmp2_ = s_collection[s_it], (_tmp2_ == NULL) ? NULL : g_strdup (_tmp2_));\n\t\t\t{\n\t\t\t\tnum_lines++;\n\t\t\t\ts = (g_free (s), NULL);\n\t\t\t}\n\t\t}\n\t}\n\t/*//stdout.printf(\"add_change(%d, %d)\\n\", pos.get_line(), pos.get_line() + num_lines);*/\n\trange_set_add (self->changes, gtk_text_iter_get_line (&(*pos)), gtk_text_iter_get_line (&(*pos)) + num_lines);\n\tss = (_vala_array_free (ss, ss_length1, (GDestroyNotify) g_free), NULL);\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Sets the grammar explicitly by name.*/\n", "func_signal": "gboolean gtk_mate_buffer_set_grammar_by_name (GtkMateBuffer* self, const char* name)", "code": "{\n\tgboolean _tmp0_;\n\tg_return_val_if_fail (self != NULL, FALSE);\n\tg_return_val_if_fail (name != NULL, FALSE);\n\t_tmp0_ = FALSE;\n\tif (self->parser != NULL) {\n\t\t_tmp0_ = _vala_strcmp0 (gtk_mate_grammar_get_name (gtk_mate_parser_get_grammar (self->parser)), name) == 0;\n\t} else {\n\t\t_tmp0_ = FALSE;\n\t}\n\tif (_tmp0_) {\n\t\treturn TRUE;\n\t}\n\t{\n\t\tGeeIterator* _bundle_it;\n\t\t_bundle_it = gee_iterable_iterator ((GeeIterable*) gtk_mate_buffer_bundles);\n\t\twhile (gee_iterator_next (_bundle_it)) {\n\t\t\tGtkMateBundle* bundle;\n\t\t\tbundle = (GtkMateBundle*) gee_iterator_get (_bundle_it);\n\t\t\t{\n\t\t\t\tGeeIterator* _gr_it;\n\t\t\t\t_gr_it = gee_iterable_iterator ((GeeIterable*) bundle->grammars);\n\t\t\t\twhile (gee_iterator_next (_gr_it)) {\n\t\t\t\t\tGtkMateGrammar* gr;\n\t\t\t\t\tgr = (GtkMateGrammar*) gee_iterator_get (_gr_it);\n\t\t\t\t\tif (_vala_strcmp0 (gtk_mate_grammar_get_name (gr), name) == 0) {\n\t\t\t\t\t\tgint parsed_upto;\n\t\t\t\t\t\tGtkMateTheme* theme;\n\t\t\t\t\t\tGtkMateParser* _tmp4_;\n\t\t\t\t\t\tgboolean _tmp5_;\n\t\t\t\t\t\tparsed_upto = 150;\n\t\t\t\t\t\ttheme = NULL;\n\t\t\t\t\t\tif (self->parser != NULL) {\n\t\t\t\t\t\t\tGtkMateTheme* _tmp3_;\n\t\t\t\t\t\t\tGtkMateTheme* _tmp2_;\n\t\t\t\t\t\t\t_tmp3_ = NULL;\n\t\t\t\t\t\t\t_tmp2_ = NULL;\n\t\t\t\t\t\t\ttheme = (_tmp3_ = (_tmp2_ = gtk_mate_colourer_get_theme (gtk_mate_parser_get_colourer (self->parser)), (_tmp2_ == NULL) ? NULL : g_object_ref (_tmp2_)), (theme == NULL) ? NULL : (theme = (g_object_unref (theme), NULL)), _tmp3_);\n\t\t\t\t\t\t\tgtk_mate_colourer_uncolour_scope (gtk_mate_parser_get_colourer (self->parser), self->parser->root, TRUE);\n\t\t\t\t\t\t\tparsed_upto = self->parser->parsed_upto;\n\t\t\t\t\t\t\tgtk_mate_parser_close (self->parser);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp4_ = NULL;\n\t\t\t\t\t\tself->parser = (_tmp4_ = gtk_mate_parser_create (gr, self), (self->parser == NULL) ? NULL : (self->parser = (g_object_unref (self->parser), NULL)), _tmp4_);\n\t\t\t\t\t\tgtk_mate_parser_last_visible_line_changed (self->parser, parsed_upto);\n\t\t\t\t\t\tg_signal_emit_by_name (self, \"grammar_changed\", gtk_mate_grammar_get_name (gr), NULL);\n\t\t\t\t\t\tif (theme != NULL) {\n\t\t\t\t\t\t\tgtk_mate_parser_change_theme (self->parser, theme);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (_tmp5_ = TRUE, (theme == NULL) ? NULL : (theme = (g_object_unref (theme), NULL)), (gr == NULL) ? NULL : (gr = (g_object_unref (gr), NULL)), (_gr_it == NULL) ? NULL : (_gr_it = (g_object_unref (_gr_it), NULL)), (bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL)), (_bundle_it == NULL) ? NULL : (_bundle_it = (g_object_unref (_bundle_it), NULL)), _tmp5_);\n\t\t\t\t\t}\n\t\t\t\t\t(gr == NULL) ? NULL : (gr = (g_object_unref (gr), NULL));\n\t\t\t\t}\n\t\t\t\t(_gr_it == NULL) ? NULL : (_gr_it = (g_object_unref (_gr_it), NULL));\n\t\t\t}\n\t\t\t(bundle == NULL) ? NULL : (bundle = (g_object_unref (bundle), NULL));\n\t\t}\n\t\t(_bundle_it == NULL) ? NULL : (_bundle_it = (g_object_unref (_bundle_it), NULL));\n\t}\n\treturn FALSE;\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* Parse line line_ix. Returns true if the ending\n scope of the line has changed.*/\n", "func_signal": "static gboolean gtk_mate_parser_parse_line (GtkMateParser* self, gint line_ix)", "code": "{\n\tchar* line;\n\tgint length;\n\tGtkMateScope* start_scope;\n\tGtkMateScope* end_scope1;\n\tGtkMateScanner* scanner;\n\tGeeArrayList* all_scopes;\n\tGeeArrayList* closed_scopes;\n\tGeeArrayList* removed_scopes;\n\tGtkMateScope* end_scope2;\n\tgboolean _tmp3_;\n\tg_return_val_if_fail (self != NULL, FALSE);\n\tline = gtk_mate_buffer_get_line (self->priv->_buffer, line_ix);\n\tlength = (gint) strlen (line);\n\t/*buffer.get_line_length(line_ix);\n\t stdout.printf(\"p%d, \", line_ix);\n\t stdout.flush();*/\n\tif (line_ix > self->parsed_upto) {\n\t\tself->parsed_upto = line_ix;\n\t}\n\t/* stdout.flush();*/\n\tstart_scope = gtk_mate_scope_scope_at (self->root, line_ix, 0);\n\tif (start_scope != NULL) {\n\t\tGtkMateScope* _tmp0_;\n\t\t/* stdout.printf(\"start_scope is: %s\\n\", start_scope.name);*/\n\t\t_tmp0_ = NULL;\n\t\tstart_scope = (_tmp0_ = gtk_mate_scope_containing_double_scope (start_scope, line_ix), (start_scope == NULL) ? NULL : (start_scope = (g_object_unref (start_scope), NULL)), _tmp0_);\n\t}\n\t/* stdout.printf(\"start_scope is: %s\\n\", start_scope.name);*/\n\tend_scope1 = gtk_mate_scope_scope_at (self->root, line_ix, G_MAXINT);\n\tif (end_scope1 != NULL) {\n\t\tGtkMateScope* _tmp1_;\n\t\t_tmp1_ = NULL;\n\t\tend_scope1 = (_tmp1_ = gtk_mate_scope_containing_double_scope (end_scope1, line_ix), (end_scope1 == NULL) ? NULL : (end_scope1 = (g_object_unref (end_scope1), NULL)), _tmp1_);\n\t}\n\t/* stdout.printf(\"end_scope1: %s\\n\", end_scope1.name);*/\n\tscanner = g_object_ref_sink (gtk_mate_scanner_new (start_scope, line, length));\n\tall_scopes = gee_array_list_new (GTK_MATE_TYPE_SCOPE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);\n\tgee_collection_add ((GeeCollection*) all_scopes, start_scope);\n\tclosed_scopes = gee_array_list_new (GTK_MATE_TYPE_SCOPE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);\n\tremoved_scopes = gee_array_list_new (GTK_MATE_TYPE_SCOPE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);\n\tgee_collection_add ((GeeCollection*) all_scopes, start_scope);\n\t{\n\t\tGeeIterator* _m_it;\n\t\t_m_it = gee_iterable_iterator ((GeeIterable*) scanner);\n\t\twhile (gee_iterator_next (_m_it)) {\n\t\t\tGtkMateMarker* m;\n\t\t\tGtkMateScope* expected_scope;\n\t\t\tm = (GtkMateMarker*) gee_iterator_get (_m_it);\n\t\t\texpected_scope = gtk_mate_parser_get_expected_scope (self, gtk_mate_scanner_get_current_scope (scanner), line_ix, scanner->position);\n\t\t\t/* if (expected_scope != null)\n\t\t\t stdout.printf(\"expected_scope: %s (%d, %d)\\n\", expected_scope.name, expected_scope.start_loc().line, \n\t\t\t  expected_scope.start_loc().line_offset);\n\t\t\t else\n\t\t\t stdout.printf(\"no expected scope\\n\");\n\t\t\t stdout.printf(\"  scope: %s (%d, %d) (line length: %d)\\n\", m.pattern.name, m.from, m.match.end(0), length);*/\n\t\t\tif (m->is_close_scope) {\n\t\t\t\t/* stdout.printf(\"     (closing)\\n\");*/\n\t\t\t\tgtk_mate_parser_close_scope (self, scanner, expected_scope, line_ix, line, length, m, all_scopes, closed_scopes, removed_scopes);\n\t\t\t} else {\n\t\t\t\tif (GTK_MATE_IS_DOUBLE_PATTERN (m->pattern)) {\n\t\t\t\t\t/* stdout.printf(\"     (opening)\\n\");*/\n\t\t\t\t\tgtk_mate_parser_open_scope (self, scanner, expected_scope, line_ix, line, length, m, all_scopes, closed_scopes, removed_scopes);\n\t\t\t\t} else {\n\t\t\t\t\t/* stdout.printf(\"     (single)\\n\");*/\n\t\t\t\t\tgtk_mate_parser_single_scope (self, scanner, expected_scope, line_ix, line, length, m, all_scopes, closed_scopes, removed_scopes);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*stdout.printf(\"pretty:\\n%s\\n\", root.pretty(2));*/\n\t\t\tscanner->position = onig_match_end (m->match, 0);\n\t\t\t(m == NULL) ? NULL : (m = (g_object_unref (m), NULL));\n\t\t\t(expected_scope == NULL) ? NULL : (expected_scope = (g_object_unref (expected_scope), NULL));\n\t\t}\n\t\t(_m_it == NULL) ? NULL : (_m_it = (g_object_unref (_m_it), NULL));\n\t}\n\tgtk_mate_parser_clear_line (self, line_ix, start_scope, all_scopes, closed_scopes, removed_scopes);\n\tend_scope2 = gtk_mate_scope_scope_at (self->root, line_ix, G_MAXINT);\n\tif (end_scope2 != NULL) {\n\t\tGtkMateScope* _tmp2_;\n\t\t_tmp2_ = NULL;\n\t\tend_scope2 = (_tmp2_ = gtk_mate_scope_containing_double_scope (end_scope2, line_ix), (end_scope2 == NULL) ? NULL : (end_scope2 = (g_object_unref (end_scope2), NULL)), _tmp2_);\n\t}\n\t/* stdout.printf(\"end_scope2: %s\\n\", end_scope2.name);\n\t stdout.printf(\"%s\\n\", this.root.pretty(0));*/\n\tif (self->priv->_colourer != NULL) {\n\t\t/*stdout.printf(\"before_uncolour_scopes\\n\");*/\n\t\tgtk_mate_colourer_uncolour_scopes (self->priv->_colourer, removed_scopes);\n\t\t/*stdout.printf(\"before_colour_line_with_scopes\\n\");*/\n\t\tgtk_mate_colourer_colour_line_with_scopes (self->priv->_colourer, all_scopes);\n\t} else {\n\t}\n\t/*stdout.printf(\"after_colour_line_with_scopes\\n\");\n\t stdout.printf(\"no colourer\");*/\n\treturn (_tmp3_ = end_scope1 != end_scope2, line = (g_free (line), NULL), (start_scope == NULL) ? NULL : (start_scope = (g_object_unref (start_scope), NULL)), (end_scope1 == NULL) ? NULL : (end_scope1 = (g_object_unref (end_scope1), NULL)), (scanner == NULL) ? NULL : (scanner = (g_object_unref (scanner), NULL)), (all_scopes == NULL) ? NULL : (all_scopes = (g_object_unref (all_scopes), NULL)), (closed_scopes == NULL) ? NULL : (closed_scopes = (g_object_unref (closed_scopes), NULL)), (removed_scopes == NULL) ? NULL : (removed_scopes = (g_object_unref (removed_scopes), NULL)), (end_scope2 == NULL) ? NULL : (end_scope2 = (g_object_unref (end_scope2), NULL)), _tmp3_);\n}", "path": "dist\\parser.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/* HELPER METHODS\n Offset from start of document -> Iter*/\n", "func_signal": "GtkTextIter gtk_mate_buffer_iter_ (GtkMateBuffer* self, gint offset)", "code": "{\n\tGtkTextIter i = {0};\n\tgtk_text_buffer_get_iter_at_offset ((GtkTextBuffer*) self, &i, offset);\n\treturn i;\n}", "path": "dist\\buffer.c", "repo_name": "danlucraft/gtkmateview", "stars": 18, "license": "None", "language": "c", "size": 2342}
{"docstring": "/****************************************************************************\nline strncpy but always null terminates. Make sure there is room!\n****************************************************************************/\n", "func_signal": "static char *\nStrnCpy(char *dest, char *src, int n)", "code": "{\n    char *d = dest;\n    if (!dest)\n        return (NULL);\n    if (!src) {\n        *dest = 0;\n        return (dest);\n    }\n    while (n-- && (*d++ = *src++)) ;\n    *d = 0;\n    return (dest);\n}", "path": "smbval\\smbencrypt.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Disconnect the TCP connection to the server */\n", "func_signal": "static int \nRFCNB_Close(int socket)", "code": "{\n    close(socket);\n    /* If we want to do error recovery, here is where we put it */\n    return 0;\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Set up a session with a remote name. We are passed Called_Name as a\n * string which we convert to a NetBIOS name, ie space terminated, up to\n * 16 characters only if we need to. If Called_Address is not empty, then\n * we use it to connect to the remote end, but put in Called_Name ...\n * Called  Address can be a DNS based name, or a TCP/IP address ... */\n", "func_signal": "static void *\nRFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,\n           int port)", "code": "{\n    struct RFCNB_Con *con;\n    struct in_addr Dest_IP;\n    int Client;\n    BOOL redirect;\n    struct redirect_addr *redir_addr;\n    char *Service_Address;\n#ifdef LOG\n\t\tslog(APLOG_DEBUG,\"RFCNB_Call: start\");\n#endif\n\n    /* Now, we really should look up the port in /etc/services ... */\n    if (port == 0)\n        port = RFCNB_Default_Port;\n\n    /* Create a connection structure first */\n    if ((con = (struct RFCNB_Con *) malloc(\n                                    sizeof(struct RFCNB_Con))) == NULL) {\n        /* Error in size */\n        RFCNB_errno = RFCNBE_NoSpace;\n        RFCNB_saved_errno = errno;\n        return NULL;\n    }\n    con->fd = -0;               /* no descriptor yet */\n    con->rfc_errno = 0;         /* no error yet */\n    con->timeout = 0;           /* no timeout   */\n    con->redirects = 0;\n    con->redirect_list = NULL;  /* Fix bug still in version 0.50 */\n\n    /* Resolve that name into an IP address */\n    Service_Address = Called_Name;\n    if (strcmp(Called_Address, \"\") != 0)\n        Service_Address = Called_Address;\n\n#ifdef LOG\n\t\tslog(APLOG_DEBUG,\"RFCNB_Call: Called_Name: %s Service_Address: %s\", Called_Name, Service_Address);\n#endif\n    if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) {\n        /* Error */\n        /* No need to modify RFCNB_errno as it was done by\n         * RFCNB_Name_To_IP */\n\t\t   \tslog(APLOG_ERR,\"RFCNB_Name_To_IP failed:  Service Address - %s\", Service_Address);\n        return NULL;\n    }\n#ifdef LOG\n\t\tslog(APLOG_DEBUG,\"RFCNB_Call: Dest IP - %s, Port - %d\", inet_ntoa(Dest_IP), port);\n#endif\n\n    /* Now connect to the remote end */\n    redirect = TRUE;            /* Fudge this one so we go once through */\n    while (redirect) {          /* Connect and get session info etc */\n        redirect = FALSE;       /* Assume all OK */\n        /* Build the redirect info. First one is first addr called */\n        /* And tack it onto the list of addresses we called        */\n        if ((redir_addr = (struct redirect_addr *) malloc(\n                                    sizeof(struct redirect_addr))) == NULL) {\n            /* Could not get space */\n            RFCNB_errno = RFCNBE_NoSpace;\n            RFCNB_saved_errno = errno;\n            return (NULL);\n        }\n        memcpy((char *) &(redir_addr->ip_addr),\n               (char *) &Dest_IP, sizeof(Dest_IP));\n        redir_addr->port = port;\n        redir_addr->next = NULL;\n\n        if (con->redirect_list == NULL) {       /* Stick on head */\n            con->redirect_list = con->last_addr = redir_addr;\n        } else {\n            con->last_addr->next = redir_addr;\n            con->last_addr = redir_addr;\n        }\n\n        /* Now, make that connection */\n        if ((Client = RFCNB_IP_Connect(Dest_IP, port)) < 0) {   /* Error */\n            /* No need to modify RFCNB_errno as it was done by\n             * RFCNB_IP_Connect */\n\t\t    \t\tslog(APLOG_ERR,\"RFCNB_Call: RFCNB_IP_Connect to %s and port %d failed\", inet_ntoa(Dest_IP), port);\n            return NULL;\n        }\n#ifdef LOG\n\t\t    slog(APLOG_DEBUG,\"RFCNB_Call: After RFCNB_IP_Connect %d\", Client);\n#endif\n        con->fd = Client;\n\n        /* Now send and handle the RFCNB session request              */\n        /* If we get a redirect, we will comeback with redirect true  and\n         * a new IP address in DEST_IP                            */\n        if ((errno = RFCNB_Session_Req(con,\n                                       Called_Name,\n                                       Calling_Name,\n                                       &redirect, &Dest_IP, &port)) < 0) {\n            /* No need to modify RFCNB_errno as it was done by\n             * RFCNB_Session.. */\n\t\t    \t\tslog(APLOG_ERR,\"RFCNB_Call: RFCNB_Session_Req failed with errno %d - Called_Name %s Calling_Name %s\", errno, Called_Name, Calling_Name);\n            return NULL;\n        }\n        if (redirect) {\n            /* We have to close the connection, and then try again */\n            (con->redirects)++;\n            RFCNB_Close(con->fd);       /* Close it */\n        }\n    }\n    return con;\n}", "path": "smbval\\session.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* SMB_Connect_Server: Connect to a server, but don't negotiate protocol */\n/* or anything else ...                                                  */\n", "func_signal": "static SMB_Handle_Type \nSMB_Connect_Server(SMB_Handle_Type Con_Handle,\n                   char *server, char *NTdomain)", "code": "{\n    SMB_Handle_Type con;\n    char called[80], calling[80], *address;\n    int i;\n\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Connect_Server: server - %s, domain - %s \", server, NTdomain);\n#endif\n    /* Get a connection structure if one does not exist */\n    con = Con_Handle;\n    if (Con_Handle == NULL) {\n        if ((con = (struct SMB_Connect_Def *) malloc(\n                                   sizeof(struct SMB_Connect_Def))) == NULL) {\n            SMBlib_errno = SMBlibE_NoSpace;\n            return NULL;\n        }\n    }\n    /* Init some things ... */\n\n    strcpy(con->service, \"\");\n    strcpy(con->username, \"\");\n    strcpy(con->password, \"\");\n    strcpy(con->sock_options, \"\");\n    strcpy(con->address, \"\");\n    strcpy(con->desthost, server);\n    strcpy(con->PDomain, NTdomain);\n    strcpy(con->OSName, SMBLIB_DEFAULT_OSNAME);\n    strcpy(con->LMType, SMBLIB_DEFAULT_LMTYPE);\n    con->first_tree = con->last_tree = NULL;\n\n    SMB_Get_My_Name(con->myname, sizeof(con->myname));\n\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Connect_Server: my name - %s\", con->myname);\n#endif\n    con->port = 0;              /* No port selected */\n\n    /* Get some things we need for the SMB Header */\n    con->pid = getpid();\n    con->mid = con->pid;        /* This will do for now ... */\n    con->uid = 0;               /* Until we have done a logon, no uid ... */\n    con->gid = getgid();\n\n    /* Now connect to the remote end, but first upper case the name of\n     * the service we are going to call, sine some servers want it in\n     * uppercase */\n    for (i = 0; i < strlen(server); i++) {\n\t\t\t\tif( server[i] == '.') break;  /* Only copy the NetBios Name, first part before . */\n        called[i] = toupper(server[i]);\n\t\t}\n\n    called[i] = 0; /* Make it a string */\n\n    for (i = 0; i < strlen(con->myname); i++)\n        calling[i] = toupper(con->myname[i]);\n\n    calling[strlen(con->myname)] = 0;   /* Make it a string */\n\n    if (strcmp(con->address, \"\") == 0)\n        address = con->desthost;\n    else\n        address = con->address;\n\n#ifdef LOG\n    slog(APLOG_DEBUG,\"SMB_Connect_Server: address - %s\", address);\n#endif\n\n    con->Trans_Connect = RFCNB_Call(called,\n                                    calling,\n                                    address,    /* Protocol specific */\n                                    con->port);\n#ifdef LOG\n    slog(APLOG_DEBUG,\"SMB_Connect_Server: after RFCNB_Call con->Trans_Connect = %d\",  con->Trans_Connect != NULL ? 1 : 0 );\n#endif\n\n    /* Did we get one? */\n    if (con->Trans_Connect == NULL) {\n        if (Con_Handle == NULL) {\n            Con_Handle = NULL;\n            free(con);\n        }\n        SMBlib_errno = -SMBlibE_CallFailed;\n        return NULL;\n    }\n    return (con);\n}", "path": "smbval\\smblib.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Negotiate the protocol we will use from the list passed in Prots we\n * return the index of the accepted protocol in NegProt, -1 *indicates\n * none acceptible, and our return value is 0 if ok, <0 if problems */\n", "func_signal": "static int \nSMB_Negotiate(SMB_Handle_Type Con_Handle, char *Prots[])", "code": "{\n    struct RFCNB_Pkt *pkt;\n    int prots_len, i, pkt_len, prot, alloc_len;\n    char *p;\n\n    /* Figure out how long the prot list will be and allocate space\n     * for it */\n    prots_len = 0;\n\n    for (i = 0; Prots[i] != NULL; i++) {\n        prots_len = prots_len + strlen(Prots[i]) + 2;   /* Account for\n                                                         * null etc */\n    }\n\n    /* The -1 accounts for the one byte smb_buf we have because some\n     * systems don't like char msg_buf[] */\n    pkt_len = SMB_negp_len + prots_len;\n\n    /* Make sure that the pkt len is long enough for the max\n     * response...  Which is a problem, because the encryption key len\n     * eec may be long */\n    if (pkt_len < (SMB_hdr_wct_offset + (19 * 2) + 40))\n        alloc_len = SMB_hdr_wct_offset + (19 * 2) + 40;\n    else\n        alloc_len = pkt_len;\n\n    pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(alloc_len);\n    if (pkt == NULL) {\n        SMBlib_errno = SMBlibE_NoSpace;\n        return (SMBlibE_BAD);\n    }\n    /* Now plug in the bits we need */\n    bzero(SMB_Hdr(pkt), SMB_negp_len);\n    SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF); /* Plunk in IDF */\n    *(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBnegprot;\n    SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);\n    SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);\n    SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);\n    SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);\n    *(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 0;\n\n    SSVAL(SMB_Hdr(pkt), SMB_negp_bcc_offset, prots_len);\n\n    /* Now copy the prot strings in with the right stuff */\n    p = (char *) (SMB_Hdr(pkt) + SMB_negp_buf_offset);\n\n    for (i = 0; Prots[i] != NULL; i++) {\n        *p = SMBdialectID;\n        strcpy(p + 1, Prots[i]);\n        p = p + strlen(Prots[i]) + 2;   /* Adjust len of p for null\n                                         * plus dialectID */\n    }\n\n    /* Now send the packet and sit back ... */\n    if (RFCNB_Send(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"Error sending negotiate protocol\\n\");\n#endif\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = -SMBlibE_SendFailed;     /* Failed, check lower\n                                                 * layer errno */\n        return (SMBlibE_BAD);\n    }\n    /* Now get the response ... */\n    if (RFCNB_Recv(Con_Handle->Trans_Connect, pkt, alloc_len) < 0) {\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"Error receiving response to negotiate\\n\");\n#endif\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = -SMBlibE_RecvFailed;     /* Failed, check lower\n                                                 * layer errno */\n        return (SMBlibE_BAD);\n    }\n    if (CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset) != SMBC_SUCCESS) {\n        /* Process error */\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"SMB_Negotiate failed with errorclass = %i, Error Code = %i\\n\",\n                CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),\n                SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));\n#endif\n        SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_Remote;\n        return SMBlibE_BAD;\n    }\n    if (SVAL(SMB_Hdr(pkt), SMB_negrCP_idx_offset) == 0xFFFF) {\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"None of our protocols was accepted ... \");\n#endif\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_NegNoProt;\n        return (SMBlibE_BAD);\n    }\n    /* Now, unpack the info from the response, if any and evaluate the\n     * proto selected. We must make sure it is one we like... */\n    Con_Handle->prot_IDX = prot = SVAL(SMB_Hdr(pkt), SMB_negrCP_idx_offset);\n    Con_Handle->protocol = SMB_Figure_Protocol(Prots, prot);\n\n    if (Con_Handle->protocol == SMB_P_Unknown) {        /* No good ... */\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_ProtUnknown;\n        return SMBlibE_BAD;\n    }\n    switch (CVAL(SMB_Hdr(pkt), SMB_hdr_wct_offset)) {\n      case 0x01:                /* No more info ... */\n          break;\n\n      case 13:                  /* Up to and including LanMan 2.1 */\n          Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrLM_sec_offset);\n          Con_Handle->encrypt_passwords\n              = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);\n          Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;\n\n          Con_Handle->max_xmit = SVAL(SMB_Hdr(pkt), SMB_negrLM_mbs_offset);\n          Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrLM_mmc_offset);\n          Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrLM_mnv_offset);\n          Con_Handle->Raw_Support = SVAL(SMB_Hdr(pkt), SMB_negrLM_rm_offset);\n          Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrLM_sk_offset);\n          Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrLM_stz_offset);\n          Con_Handle->Encrypt_Key_Len\n              = SVAL(SMB_Hdr(pkt), SMB_negrLM_ekl_offset);\n\n          p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset);\n#ifdef SMB_DEBUG\n          fprintf(stderr, \"%s\",\n                  (char *) (SMB_Hdr(pkt) + SMB_negrLM_buf_offset));\n#endif\n          memcpy(Con_Handle->Encrypt_Key, p, 8);\n\n          p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset\n                            + Con_Handle->Encrypt_Key_Len);\n\n          strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);\n          break;\n\n      case 17:                  /* NT LM 0.12 and LN LM 1.0 */\n          Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_sec_offset);\n          Con_Handle->encrypt_passwords\n              = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);\n          Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;\n\n          Con_Handle->max_xmit = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mbs_offset);\n          Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mmc_offset);\n          Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mnv_offset);\n          Con_Handle->MaxRaw = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mrs_offset);\n          Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_sk_offset);\n          Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_stz_offset);\n          Con_Handle->Encrypt_Key_Len = CVAL(SMB_Hdr(pkt),\n                                             SMB_negrNTLM_ekl_offset);\n\n          p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset);\n          memcpy(Con_Handle->Encrypt_Key, p, 8);\n          p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset\n                            + Con_Handle->Encrypt_Key_Len);\n\n          strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);\n          break;\n\n      default:\n#ifdef SMB_DEBUG\n          fprintf(stderr, \"Unknown NegProt response format ... Ignored\\n\");\n          fprintf(stderr, \"  wct = %i\\n\", CVAL(SMB_Hdr(pkt), SMB_hdr_wct_offset));\n#endif\n          break;\n    }\n\n#ifdef SMB_DEBUG\n    fprintf(stderr, \"Protocol selected is: %i:%s\\n\", prot, Prots[prot]);\n#endif\n\n    RFCNB_Free_Pkt(pkt);\n    return 0;\n}", "path": "smbval\\smblib-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* We just disconnect from the other end, as there is nothing in the\n * RFCNB protocol that specifies any exchange as far as I can see*/\n", "func_signal": "static int \nRFCNB_Hangup(struct RFCNB_Con *con_Handle)", "code": "{\n    if (con_Handle != NULL) {\n        RFCNB_Close(con_Handle->fd);    /* Could this fail? */\n        free(con_Handle);\n    }\n    return 0;\n}", "path": "smbval\\session.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Logon to the server. That is, do a session setup if we can. We do\n * not do Unicode yet! */\n", "func_signal": "static int \nSMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,\n                 char *PassWord, int precrypted, char* domain)", "code": "{\n    struct RFCNB_Pkt *pkt;\n    int param_len, pkt_len, pass_len;\n    char *p, pword[128];\n\t\tchar* pdomain;\n\n\t\tif(domain && domain[0] )\n\t\t\t\t\t\tpdomain = domain;\n\t\telse\n\t\t\t\t\t\tpdomain = Con_Handle->PDomain;\n\n    /* First we need a packet etc ... but we need to know what\n     * protocol has been negotiated to figure out if we can do it and\n     * what SMB format to use ... */\n    if (Con_Handle->protocol < SMB_P_LanMan1) {\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: bad protocol\");\n#endif\n        SMBlib_errno = SMBlibE_ProtLow;\n        return (SMBlibE_BAD);\n    }\n    if (precrypted) {\n        pass_len = 24;\n        memcpy(pword, PassWord, 24);\n    } else {\n        strcpy(pword, PassWord);\n        if (Con_Handle->encrypt_passwords) {\n            pass_len = 24;\n            SMBencrypt((uchar *) PassWord,\n                       (uchar *) Con_Handle->Encrypt_Key, (uchar *) pword);\n        } else\n            pass_len = strlen(pword);\n    }\n\n    /* Now build the correct structure */\n    if (Con_Handle->protocol < SMB_P_NT1) {\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Logon_Server: type is LM (%d)\", Con_Handle->protocol);\n#endif\n        param_len = strlen(UserName) + 1 + pass_len + 1 +\n            strlen(pdomain) + 1 +\n            strlen(Con_Handle->OSName) + 1;\n\n        pkt_len = SMB_ssetpLM_len + param_len;\n\n        pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);\n\n        if (pkt == NULL) {\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: pkt == NULL\");\n#endif\n            SMBlib_errno = SMBlibE_NoSpace;\n            return (SMBlibE_BAD);       /* Should handle the error */\n        }\n        bzero(SMB_Hdr(pkt), SMB_ssetpLM_len);\n        SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);   /* Plunk\n                                                                 * in IDF */\n        *(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);\n        *(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 10;\n        *(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;    /* No extra\n                                                         * command */\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);\n\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mbs_offset, SMBLIB_MAX_XMIT);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mmc_offset, 2);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_vcn_offset, Con_Handle->pid);\n        SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_snk_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_pwl_offset, pass_len + 1);\n        SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_res_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_bcc_offset, param_len);\n\n        /* Now copy the param strings in with the right stuff */\n        p = (char *) (SMB_Hdr(pkt) + SMB_ssetpLM_buf_offset);\n\n        /* Copy in password, then the rest. Password has a null at end */\n        memcpy(p, pword, pass_len);\n\n        p = p + pass_len + 1;\n\n        strcpy(p, UserName);\n        p = p + strlen(UserName);\n        *p = 0;\n\n        p = p + 1;\n\n        strcpy(p, pdomain);\n        p = p + strlen(pdomain);\n        *p = 0;\n        p = p + 1;\n\n        strcpy(p, Con_Handle->OSName);\n        p = p + strlen(Con_Handle->OSName);\n        *p = 0;\n    } else {\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Logon_Server: type is NTLM (%d)\", Con_Handle->protocol);\n#endif\n        /* We don't admit to UNICODE support ... */\n        param_len = strlen(UserName) + 1 + pass_len +\n            strlen(pdomain) + 1 +\n            strlen(Con_Handle->OSName) + 1 +\n            strlen(Con_Handle->LMType) + 1;\n\n        pkt_len = SMB_ssetpNTLM_len + param_len;\n\n        pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);\n\n        if (pkt == NULL) {\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: pkt == NULL, second check\");\n#endif\n            SMBlib_errno = SMBlibE_NoSpace;\n            return (-1);        /* Should handle the error */\n        }\n        bzero(SMB_Hdr(pkt), SMB_ssetpNTLM_len);\n        SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);   /* Plunk\n                                                                 * in IDF */\n        *(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);\n        *(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 13;\n        *(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;    /* No extra\n                                                         * command */\n        SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);\n\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mbs_offset, SMBLIB_MAX_XMIT);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mmc_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_vcn_offset, 0);\n        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_snk_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cipl_offset, pass_len);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cspl_offset, 0);\n        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_res_offset, 0);\n        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cap_offset, 0);\n        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_bcc_offset, param_len);\n\n        /* Now copy the param strings in with the right stuff */\n        p = (char *) (SMB_Hdr(pkt) + SMB_ssetpNTLM_buf_offset);\n\n        /* Copy  in password, then the rest. Password has no null at end */\n        memcpy(p, pword, pass_len);\n\n        p = p + pass_len;\n\n        strcpy(p, UserName);\n        p = p + strlen(UserName);\n        *p = 0;\n\n        p = p + 1;\n\n        strcpy(p, pdomain);\n        p = p + strlen(pdomain);\n        *p = 0;\n        p = p + 1;\n\n        strcpy(p, Con_Handle->OSName);\n        p = p + strlen(Con_Handle->OSName);\n        *p = 0;\n        p = p + 1;\n\n        strcpy(p, Con_Handle->LMType);\n        p = p + strlen(Con_Handle->LMType);\n        *p = 0;\n    }\n\n    /* Now send it and get a response */\n    if (RFCNB_Send(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: Error sending SessSetupX request\");\n#endif\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"Error sending SessSetupX request\\n\");\n#endif\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_SendFailed;\n        return (SMBlibE_BAD);\n    }\n\n    /* Now get the response ... */\n    if (RFCNB_Recv(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: Error receiving response to SessSetupAndX\");\n#endif\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"Error receiving response to SessSetupAndX\\n\");\n#endif\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_RecvFailed;\n        return (SMBlibE_BAD);\n    }\n    /* Check out the response type ... */\n\n    if (CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset) != SMBC_SUCCESS) {\n        /* Process error */\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: SMB_SessSetupAndX failed; errorclass = %i, Error Code = %i\\n\",\n         CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),\n         SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));\n#endif\n#ifdef SMB_DEBUG\n        fprintf(stderr,\n                \"SMB_SessSetupAndX failed; errorclass = %i, Error Code = %i\\n\",\n                CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),\n                SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));\n#endif\n        SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);\n        RFCNB_Free_Pkt(pkt);\n        SMBlib_errno = SMBlibE_Remote;\n        return (SMBlibE_BAD);\n    }\n/** @@@ mdz: check for guest login { **/\n    if (SVAL(SMB_Hdr(pkt), SMB_ssetpr_act_offset) & 0x1) {\n        /* do we allow guest login? NO! */\n#ifdef LOG\n    slog(APLOG_ERR,\"SMB_Logon_Server: no guest login\");\n#endif\n        return (SMBlibE_BAD);\n    }\n/** @@@ mdz: } **/\n\n#ifdef SMB_DEBUG\n    fprintf(stderr, \"SessSetupAndX response. Action = %i\\n\",\n            SVAL(SMB_Hdr(pkt), SMB_ssetpr_act_offset));\n#endif\n\n    /* Now pick up the UID for future reference ... */\n    Con_Handle->uid = SVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset);\n    RFCNB_Free_Pkt(pkt);\n\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Logon_Server: login OK\");\n#endif\n    return 0;\n}", "path": "smbval\\smblib.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* We pick up a message from the internet ... We have to worry about \n * non-message packets ...                                           */\n", "func_signal": "static int \nRFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)", "code": "{\n    struct RFCNB_Pkt *pkt;\n    int ret_len;\n\n    if (con_Handle == NULL) {\n        RFCNB_errno = RFCNBE_BadHandle;\n        RFCNB_saved_errno = errno;\n        return (RFCNBE_Bad);\n    }\n    /* Now get a packet from below. We allocate a header first */\n    /* Plug in the header and send the data */\n    pkt = RFCNB_Alloc_Pkt(RFCNB_Pkt_Hdr_Len);\n\n    if (pkt == NULL) {\n        RFCNB_errno = RFCNBE_NoSpace;\n        RFCNB_saved_errno = errno;\n        return (RFCNBE_Bad);\n    }\n    pkt->next = Data;           /* Plug in the data portion */\n\n    if ((ret_len = RFCNB_Get_Pkt(con_Handle, pkt,\n                                 Length + RFCNB_Pkt_Hdr_Len)) < 0) {\n#ifdef RFCNB_DEBUG\n        fprintf(stderr, \"Bad packet return in RFCNB_Recv... \\n\");\n#endif\n        return RFCNBE_Bad;\n    }\n    /* We should check that we go a message and not a keep alive */\n    pkt->next = NULL;\n    RFCNB_Free_Pkt(pkt);\n    return ret_len;\n}", "path": "smbval\\session.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* We send a packet to the other end ... for the moment, we treat the \n * data as a series of pointers to blocks of data ... we should check the\n * length ... */\n", "func_signal": "static int \nRFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)", "code": "{\n    struct RFCNB_Pkt *pkt;\n    char *hdr;\n    int len;\n\n    /* Plug in the header and send the data */\n    pkt = RFCNB_Alloc_Pkt(RFCNB_Pkt_Hdr_Len);\n    if (pkt == NULL) {\n        RFCNB_errno = RFCNBE_NoSpace;\n        RFCNB_saved_errno = errno;\n        return (RFCNBE_Bad);\n    }\n    pkt->next = udata;          /* The user data we want to send */\n    hdr = pkt->data;\n\n    /* Following crap is for portability across multiple UNIX machines */\n    *(hdr + RFCNB_Pkt_Type_Offset) = RFCNB_SESSION_MESSAGE;\n    RFCNB_Put_Pkt_Len(hdr, Length);\n\n#ifdef RFCNB_DEBUG\n    fprintf(stderr, \"Sending packet: \");\n#endif\n\n    if ((len = RFCNB_Put_Pkt(Con_Handle, pkt,\n                             Length + RFCNB_Pkt_Hdr_Len)) < 0) {\n        /* No need to change RFCNB_errno as it was done by put_pkt ... */\n        return RFCNBE_Bad;      /* Should be able to write that lot ... */\n    }\n    /* Now we have sent that lot, let's get rid of the RFCNB Header\n     * and return */\n    pkt->next = NULL;\n\n    RFCNB_Free_Pkt(pkt);\n    return len;\n}", "path": "smbval\\session.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* \n * This implements the X/Open SMB password encryption It takes a password, \n * a 8 byte \"crypt key\" and puts 24 bytes of  encrypted password into p24 */\n", "func_signal": "static void \nSMBencrypt(uchar * passwd, uchar * c8, uchar * p24)", "code": "{\n    uchar p14[15], p21[21];\n\n    memset(p21, '\\0', 21);\n    memset(p14, '\\0', 14);\n    StrnCpy((char *) p14, (char *) passwd, 14);\n\n    strupper((char *) p14);\n    E_P16(p14, p21);\n    E_P24(p21, c8, p24);\n}", "path": "smbval\\smbencrypt.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* handle the details of establishing the RFCNB session with remote end */\n", "func_signal": "static int \nRFCNB_Session_Req(struct RFCNB_Con *con,\n                  char *Called_Name,\n                  char *Calling_Name,\n                  BOOL * redirect,\n                  struct in_addr *Dest_IP,\n                  int *port)", "code": "{\n    char *sess_pkt;\n\n    /* Response packet should be no more than 9 bytes, make 16 jic */\n    char resp[16];\n    int len;\n    struct RFCNB_Pkt *pkt, res_pkt;\n\n    /* We build and send the session request, then read the response */\n    pkt = RFCNB_Alloc_Pkt(RFCNB_Pkt_Sess_Len);\n    if (pkt == NULL) {\n        return RFCNBE_Bad; /* Leave the error that RFCNB_Alloc_Pkt gives) */\n    }\n    sess_pkt = pkt->data;       /* Get pointer to packet proper */\n\n    sess_pkt[RFCNB_Pkt_Type_Offset] = RFCNB_SESSION_REQUEST;\n    RFCNB_Put_Pkt_Len(sess_pkt, RFCNB_Pkt_Sess_Len - RFCNB_Pkt_Hdr_Len);\n    sess_pkt[RFCNB_Pkt_N1Len_Offset] = 32;\n    sess_pkt[RFCNB_Pkt_N2Len_Offset] = 32;\n\n    RFCNB_CvtPad_Name(Called_Name, (sess_pkt + RFCNB_Pkt_Called_Offset));\n    RFCNB_CvtPad_Name(Calling_Name, (sess_pkt + RFCNB_Pkt_Calling_Offset));\n\n    /* Now send the packet */\n#ifdef RFCNB_DEBUG\n    fprintf(stderr, \"Sending packet: \");\n#endif\n    if ((len = RFCNB_Put_Pkt(con, pkt, RFCNB_Pkt_Sess_Len)) < 0)\n        return RFCNBE_Bad;      /* Should be able to write that lot ... */\n#ifdef RFCNB_DEBUG\n    fprintf(stderr, \"Getting packet.\\n\");\n#endif\n\n    res_pkt.data = resp;\n    res_pkt.len = sizeof(resp);\n    res_pkt.next = NULL;\n\n    if ((len = RFCNB_Get_Pkt(con, &res_pkt, sizeof(resp))) < 0)\n        return RFCNBE_Bad;\n\n    /* Now analyze the packet ... */\n    switch (RFCNB_Pkt_Type(resp)) {\n      case RFCNB_SESSION_REJ:   /* Didnt like us ... too bad */\n          /* Why did we get rejected ? */\n          switch (CVAL(resp, RFCNB_Pkt_Error_Offset)) {\n            case 0x80:\n                RFCNB_errno = RFCNBE_CallRejNLOCN;\n                break;\n            case 0x81:\n                RFCNB_errno = RFCNBE_CallRejNLFCN;\n                break;\n            case 0x82:\n                RFCNB_errno = RFCNBE_CallRejCNNP;\n                break;\n            case 0x83:\n                RFCNB_errno = RFCNBE_CallRejInfRes;\n                break;\n            case 0x8F:\n                RFCNB_errno = RFCNBE_CallRejUnSpec;\n                break;\n            default:\n                RFCNB_errno = RFCNBE_ProtErr;\n                break;\n          }\n          return (RFCNBE_Bad);\n          break;\n\n      case RFCNB_SESSION_ACK:   /* Got what we wanted ...      */\n          return (0);\n          break;\n\n      case RFCNB_SESSION_RETARGET:      /* Go elsewhere                */\n          *redirect = TRUE;     /* Copy port and ip addr       */\n          memcpy(Dest_IP, (resp + RFCNB_Pkt_IP_Offset),\n                 sizeof(struct in_addr));\n          *port = SVAL(resp, RFCNB_Pkt_Port_Offset);\n          return 0;\n          break;\n      default:                  /* A protocol error */\n          RFCNB_errno = RFCNBE_ProtErr;\n          return (RFCNBE_Bad);\n          break;\n    }\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Read an RFCNB packet off the connection.  We read the first 4\n * bytes, that tells us the length, then read the rest. We should\n * implement a timeout, but we don't just yet */\n", "func_signal": "static int \nRFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)", "code": "{\n    int read_len, pkt_len;\n    char hdr[RFCNB_Pkt_Hdr_Len];        /* Local space for the header */\n    struct RFCNB_Pkt *pkt_frag;\n    int more, this_time, offset, frag_len, this_len;\n    BOOL seen_keep_alive = TRUE;\n\n    /* Read that header straight into the buffer */\n    if (len < RFCNB_Pkt_Hdr_Len) {      /* What a bozo */\n#ifdef RFCNB_DEBUG\n        fprintf(stderr, \"Trying to read less than a packet:\");\n        perror(\"\");\n#endif\n        RFCNB_errno = RFCNBE_BadParam;\n        return (RFCNBE_Bad);\n    }\n    /* We discard keep alives here ... */\n    if (RFCNB_Timeout > 0)\n        alarm(RFCNB_Timeout);\n\n    while (seen_keep_alive) {\n        if ((read_len = read(con->fd, hdr, sizeof(hdr))) < 0) { /* Problems */\n#ifdef RFCNB_DEBUG\n            fprintf(stderr, \"Reading the packet, we got:\");\n            perror(\"\");\n#endif\n            if (errno == EINTR)\n                RFCNB_errno = RFCNBE_Timeout;\n            else\n                RFCNB_errno = RFCNBE_BadRead;\n            RFCNB_saved_errno = errno;\n            return (RFCNBE_Bad);\n        }\n        /* Now we check out what we got */\n        if (read_len == 0) {    /* Connection closed, send back eof?  */\n#ifdef RFCNB_DEBUG\n            fprintf(stderr, \"Connection closed reading\\n\");\n#endif\n            if (errno == EINTR)\n                RFCNB_errno = RFCNBE_Timeout;\n            else\n                RFCNB_errno = RFCNBE_ConGone;\n            RFCNB_saved_errno = errno;\n            return (RFCNBE_Bad);\n        }\n        if (RFCNB_Pkt_Type(hdr) == RFCNB_SESSION_KEEP_ALIVE) {\n#ifdef RFCNB_DEBUG\n            fprintf(stderr, \"RFCNB KEEP ALIVE received\\n\");\n#endif\n        } else {\n            seen_keep_alive = FALSE;\n        }\n    }\n\n    /* What if we got less than or equal to a hdr size in bytes? */\n    if (read_len < sizeof(hdr)) {       /* We got a small packet */\n        /* Now we need to copy the hdr portion we got into the\n         * supplied packet */\n        memcpy(pkt->data, hdr, read_len);       /* Copy data */\n#ifdef RFCNB_DEBUG\n#endif\n        return read_len;\n    }\n    /* Now, if we got at least a hdr size, alloc space for rest, if we\n     * need it */\n    pkt_len = RFCNB_Pkt_Len(hdr);\n\n#ifdef RFCNB_DEBUG\n    fprintf(stderr, \"Reading Pkt: Length = %i\\n\", pkt_len);\n#endif\n\n    /* Now copy in the hdr */\n    memcpy(pkt->data, hdr, sizeof(hdr));\n\n    /* Get the rest of the packet ... first figure out how big our buf\n     * is? And make sure that we handle the fragments properly\n     * ... Sure should use an iovec ... */\n    if (len < pkt_len)          /* Only get as much as we have space for */\n        more = len - RFCNB_Pkt_Hdr_Len;\n    else\n        more = pkt_len;\n\n    this_time = 0;\n\n    /* We read for each fragment ... */\n    if (pkt->len == read_len) { /* If this frag was exact size */\n        pkt_frag = pkt->next;   /* Stick next lot in next frag */\n        offset = 0;             /* then we start at 0 in next  */\n    } else {\n        pkt_frag = pkt;         /* Otherwise use rest of this frag */\n        offset = RFCNB_Pkt_Hdr_Len;     /* Otherwise skip the header */\n    }\n\n    frag_len = pkt_frag->len;\n    if (more <= frag_len)       /* If len left to get less than frag space */\n        this_len = more;        /* Get the rest ... */\n    else\n        this_len = frag_len - offset;\n\n    while (more > 0) {\n        if ((this_time = read(con->fd, (pkt_frag->data) + offset,\n                              this_len)) <= 0) { /* Problems */\n            if (errno == EINTR) {\n                RFCNB_errno = RFCNB_Timeout;\n            } else {\n                if (this_time < 0)\n                    RFCNB_errno = RFCNBE_BadRead;\n                else\n                    RFCNB_errno = RFCNBE_ConGone;\n            }\n            RFCNB_saved_errno = errno;\n            return (RFCNBE_Bad);\n\n        }\n#ifdef RFCNB_DEBUG\n        fprintf(stderr, \"Frag_Len = %i, this_time = %i, this_len = %i, more = %i\\n\", frag_len,\n                this_time, this_len, more);\n#endif\n\n        read_len = read_len + this_time; /* How much have we read... */\n        /* Now set up the next part */\n        if (pkt_frag->next == NULL)\n            break;              /* That's it here */\n\n        pkt_frag = pkt_frag->next;\n        this_len = pkt_frag->len;\n        offset = 0;\n\n        more = more - this_time;\n    }\n\n#ifdef RFCNB_DEBUG\n    fprintf(stderr, \"Pkt Len = %i, read_len = %i\\n\", pkt_len, read_len);\n#endif\n\n    if (read_len < (pkt_len + sizeof(hdr))) {   /* Discard the rest */\n        return (RFCNB_Discard_Rest(con, (pkt_len + sizeof(hdr)) - read_len));\n    }\n    if (RFCNB_Timeout > 0)\n        alarm(0);               /* Reset that sucker */\n\n    return (read_len + sizeof(RFCNB_Hdr));\n}", "path": "smbval\\rfcnb-io.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Disconnect from the server, and disconnect all tree connects */\n", "func_signal": "static int \nSMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle)", "code": "{\n#ifdef LOG\n    slog(APLOG_INFO,\"SMB_Discon\");\n#endif\n    /* We just disconnect the connection for now ... */\n    RFCNB_Hangup(Con_Handle->Trans_Connect);\n\n    if (!KeepHandle)\n        free(Con_Handle);\n\n    return 0;\n}", "path": "smbval\\smblib.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Get our hostname */\n", "func_signal": "static void \nSMB_Get_My_Name(char *name, int len)", "code": "{\n    if (gethostname(name, len) < 0) {   /* Error getting name */\n        strncpy(name, \"unknown\", len);\n\n        /* Should check the error */\n#ifdef SMB_DEBUG\n        fprintf(stderr, \"gethostname in SMB_Get_My_Name returned error:\");\n        perror(\"\");\n#endif\n    }\n    /* only keep the portion up to the first \".\" */\n}", "path": "smbval\\smblib-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Connect to the server specified in the IP address. Not sure how to\n * handle socket options etc.  */\n", "func_signal": "static int \nRFCNB_IP_Connect(struct in_addr Dest_IP, int port)", "code": "{\n    struct sockaddr_in Socket;\n    int fd;\n\n    /* Create a socket */\n    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) { /* Handle the error */\n        RFCNB_errno = RFCNBE_BadSocket;\n        RFCNB_saved_errno = errno;\n        return (RFCNBE_Bad);\n    }\n    bzero((char *) &Socket, sizeof(Socket));\n    memcpy((char *) &Socket.sin_addr, (char *) &Dest_IP, sizeof(Dest_IP));\n\n    Socket.sin_port = htons(port);\n    Socket.sin_family = PF_INET;\n\n    /* Now connect to the destination */\n    if (connect(fd, (struct sockaddr *) &Socket, sizeof(Socket)) < 0) {\n        /* Error */\n        close(fd);\n        RFCNB_errno = RFCNBE_ConnectFailed;\n        RFCNB_saved_errno = errno;\n        return (RFCNBE_Bad);\n    }\n    return fd;\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Get a packet of size n */\n", "func_signal": "static struct RFCNB_Pkt *\nRFCNB_Alloc_Pkt(int n)", "code": "{\n    RFCNB_Pkt *pkt;\n\n    if ((pkt = (struct RFCNB_Pkt *) malloc(\n                            sizeof(struct RFCNB_Pkt))) == NULL) {\n        RFCNB_errno = RFCNBE_NoSpace;\n        RFCNB_saved_errno = errno;\n        return NULL;\n    }\n    pkt->next = NULL;\n    pkt->len = n;\n\n    if (n == 0)\n        return pkt;\n\n    if ((pkt->data = (char *) malloc(n)) == NULL) {\n        RFCNB_errno = RFCNBE_NoSpace;\n        RFCNB_saved_errno = errno;\n        free(pkt);\n        return (NULL);\n    }\n    return pkt;\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Resolve a name into an address */\n", "func_signal": "static int \nRFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP)", "code": "{\n    int addr;                   /* Assumes IP4, 32 bit network addresses */\n    struct hostent *hp;\n\n    /* Use inet_addr to try to convert the address */\n    if ((addr = inet_addr(host)) == INADDR_NONE) { /* a good try :-) */\n        /* Now try a name look up with gethostbyname */\n        if ((hp = gethostbyname(host)) == NULL) { /* Not in DNS */\n            /* Try NetBIOS name lookup, how the hell do we do that? */\n            RFCNB_errno = RFCNBE_BadName;         /* Is this right? */\n            RFCNB_saved_errno = errno;\n            return (RFCNBE_Bad);\n        } else {                /* We got a name */\n            memcpy((void *) Dest_IP, (void *) hp->h_addr_list[0],\n                   sizeof(struct in_addr));\n        }\n    } else {                    /* It was an IP address */\n        memcpy((void *) Dest_IP, (void *) &addr, sizeof(struct in_addr));\n    }\n    return 0;\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Convert name and pad to 16 chars as needed.  Name 1 is a C string\n * with null termination, name 2 may not be.  If SysName is true, then\n * put a <00> on end, else space> */\n", "func_signal": "static void \nRFCNB_CvtPad_Name(char *name1, char *name2)", "code": "{\n    char c, c1, c2;\n    int i, len;\n\n    len = strlen(name1);\n    for (i = 0; i < 16; i++) {\n        if (i >= len) {\n            c1 = 'C';\n            c2 = 'A';           /* CA is a space */\n        } else {\n            c = name1[i];\n            c1 = (char) ((int) c / 16 + (int) 'A');\n            c2 = (char) ((int) c % 16 + (int) 'A');\n        }\n        name2[i * 2] = c1;\n        name2[i * 2 + 1] = c2;\n    }\n    name2[32] = 0;              /* Put in the nll ... */\n}", "path": "smbval\\rfcnb-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Figure out what protocol was accepted, given the list of dialect\n * strings.  We offered, and the index back from the server. We allow\n * for a user supplied list, and assume that it is a subset of our\n * list */\n", "func_signal": "static int \nSMB_Figure_Protocol(char *dialects[], int prot_index)", "code": "{\n    int i;\n\n    if (dialects == SMB_Prots) { /* The jobs is easy, just index\n                                  * into table */\n        return SMB_Types[prot_index];\n    } else {                    /* Search through SMB_Prots looking\n                                 * for a match */\n        for (i = 0; SMB_Prots[i] != NULL; i++) {\n            if (strcmp(dialects[prot_index], SMB_Prots[i]) == 0) {\n                /* A match */\n                return SMB_Types[i];\n            }\n        }\n\n        /* If we got here, then we are in trouble, because the\n         * protocol was not one we understand ... */\n        return SMB_P_Unknown;\n    }\n}", "path": "smbval\\smblib-util.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* Initialize the SMBlib package     */\n", "func_signal": "static int \nSMB_Init()", "code": "{\n    SMBlib_State = SMB_State_Started;\n    signal(SIGPIPE, SIG_IGN);   /* Ignore these ... */\n\n/* If SMBLIB_Instrument is defines, turn on the instrumentation stuff */\n#ifdef SMBLIB_INSTRUMENT\n    SMBlib_Instrument_Init();\n#endif\n\n    return 0;\n}", "path": "smbval\\smblib.inc.c", "repo_name": "rsim/mod_ntlm", "stars": 21, "license": "None", "language": "c", "size": 260}
{"docstring": "/* This will flush remaining packets into a page (returning nonzero),\n   even if there is not enough data to trigger a flush normally\n   (undersized page). If there are no packets or partial packets to\n   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will\n   try to flush a normal sized page like ogg_stream_pageout; a call to\n   ogg_stream_flush does not guarantee that all packets have flushed.\n   Only a return value of 0 from ogg_stream_flush indicates all packet\n   data is flushed into pages.\n\n   since ogg_stream_flush will flush the last page in a stream even if\n   it's undersized, you almost certainly want to use ogg_stream_pageout\n   (and *not* ogg_stream_flush) unless you specifically need to flush \n   an page regardless of size in the middle of a stream. */\n", "func_signal": "int ogg_stream_flush(ogg_stream_state *os,ogg_page *og)", "code": "{\n  int i;\n  int vals=0;\n  int maxvals=(os->lacing_fill>255?255:os->lacing_fill);\n  int bytes=0;\n  long acc=0;\n  ogg_int64_t granule_pos=-1;\n\n  if(maxvals==0)return(0);\n  \n  /* construct a page */\n  /* decide how many segments to include */\n  \n  /* If this is the initial header case, the first page must only include\n     the initial header packet */\n  if(os->b_o_s==0){  /* 'initial header page' case */\n    granule_pos=0;\n    for(vals=0;vals<maxvals;vals++){\n      if((os->lacing_vals[vals]&0x0ff)<255){\n\tvals++;\n\tbreak;\n      }\n    }\n  }else{\n    for(vals=0;vals<maxvals;vals++){\n      if(acc>4096)break;\n      acc+=os->lacing_vals[vals]&0x0ff;\n      if((os->lacing_vals[vals]&0xff)<255)\n        granule_pos=os->granule_vals[vals];\n    }\n  }\n  \n  /* construct the header in temp storage */\n  memcpy(os->header,\"OggS\",4);\n  \n  /* stream structure version */\n  os->header[4]=0x00;\n  \n  /* continued packet flag? */\n  os->header[5]=0x00;\n  if((os->lacing_vals[0]&0x100)==0)os->header[5]|=0x01;\n  /* first page flag? */\n  if(os->b_o_s==0)os->header[5]|=0x02;\n  /* last page flag? */\n  if(os->e_o_s && os->lacing_fill==vals)os->header[5]|=0x04;\n  os->b_o_s=1;\n\n  /* 64 bits of PCM position */\n  for(i=6;i<14;i++){\n    os->header[i]=(unsigned char)(granule_pos&0xff);\n    granule_pos>>=8;\n  }\n\n  /* 32 bits of stream serial number */\n  {\n    long serialno=os->serialno;\n    for(i=14;i<18;i++){\n      os->header[i]=(unsigned char)(serialno&0xff);\n      serialno>>=8;\n    }\n  }\n\n  /* 32 bits of page counter (we have both counter and page header\n     because this val can roll over) */\n  if(os->pageno==-1)os->pageno=0; /* because someone called\n\t\t\t\t     stream_reset; this would be a\n\t\t\t\t     strange thing to do in an\n\t\t\t\t     encode stream, but it has\n\t\t\t\t     plausible uses */\n  {\n    long pageno=os->pageno++;\n    for(i=18;i<22;i++){\n      os->header[i]=(unsigned char)(pageno&0xff);\n      pageno>>=8;\n    }\n  }\n  \n  /* zero for computation; filled in later */\n  os->header[22]=0;\n  os->header[23]=0;\n  os->header[24]=0;\n  os->header[25]=0;\n  \n  /* segment table */\n  os->header[26]=(unsigned char)(vals&0xff);\n  for(i=0;i<vals;i++)\n    bytes+=os->header[i+27]=(unsigned char)(os->lacing_vals[i]&0xff);\n  \n  /* set pointers in the ogg_page struct */\n  og->header=os->header;\n  og->header_len=os->header_fill=vals+27;\n  og->body=os->body_data+os->body_returned;\n  og->body_len=bytes;\n  \n  /* advance the lacing data and set the body_returned pointer */\n  \n  os->lacing_fill-=vals;\n  memmove(os->lacing_vals,os->lacing_vals+vals,os->lacing_fill*sizeof(*os->lacing_vals));\n  memmove(os->granule_vals,os->granule_vals+vals,os->lacing_fill*sizeof(*os->granule_vals));\n  os->body_returned+=bytes;\n  \n  /* calculate the checksum */\n  \n  ogg_page_checksum_set(og);\n\n  /* done */\n  return(1);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* checksum the page */\n/* Direct table CRC; note that this will be faster in the future if we\n   perform the checksum silmultaneously with other copies */\n", "func_signal": "void ogg_page_checksum_set(ogg_page *og)", "code": "{\n  if(og){\n    ogg_uint32_t crc_reg=0;\n    int i;\n\n    /* safety; needed for API behavior, but not framing code */\n    og->header[22]=0;\n    og->header[23]=0;\n    og->header[24]=0;\n    og->header[25]=0;\n    \n    for(i=0;i<og->header_len;i++)\n      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->header[i]];\n    for(i=0;i<og->body_len;i++)\n      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->body[i]];\n    \n    og->header[22]=(unsigned char)(crc_reg&0xff);\n    og->header[23]=(unsigned char)((crc_reg>>8)&0xff);\n    og->header[24]=(unsigned char)((crc_reg>>16)&0xff);\n    og->header[25]=(unsigned char)((crc_reg>>24)&0xff);\n  }\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* This constructs pages from buffered packet segments.  The pointers\nreturned are to static buffers; do not free. The returned buffers are\ngood only until the next call (using the same ogg_stream_state) */\n", "func_signal": "int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og)", "code": "{\n\n  if((os->e_o_s&&os->lacing_fill) ||          /* 'were done, now flush' case */\n     os->body_fill-os->body_returned > 4096 ||/* 'page nominal size' case */\n     os->lacing_fill>=255 ||                  /* 'segment table full' case */\n     (os->lacing_fill&&!os->b_o_s)){          /* 'initial header page' case */\n        \n    return(ogg_stream_flush(os,og));\n  }\n  \n  /* not enough data to construct a page and not end of stream */\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* sync the stream and get a page.  Keep trying until we find a page.\n   Supress 'sync errors' after reporting the first.\n\n   return values:\n   -1) recapture (hole in data)\n    0) need more data\n    1) page returned\n\n   Returns pointers into buffered data; invalidated by next call to\n   _stream, _clear, _init, or _buffer */\n", "func_signal": "int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og)", "code": "{\n\n  /* all we need to do is verify a page at the head of the stream\n     buffer.  If it doesn't verify, we look for the next potential\n     frame */\n\n  for(;;){\n    long ret=ogg_sync_pageseek(oy,og);\n    if(ret>0){\n      /* have a page */\n      return(1);\n    }\n    if(ret==0){\n      /* need more data */\n      return(0);\n    }\n    \n    /* head did not start a synced page... skipped some bytes */\n    if(!oy->unsynced){\n      oy->unsynced=1;\n      return(-1);\n    }\n\n    /* loop. keep looking */\n\n  }\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* clear things to an initial state.  Good to call, eg, before seeking */\n", "func_signal": "int ogg_sync_reset(ogg_sync_state *oy)", "code": "{\n  oy->fill=0;\n  oy->returned=0;\n  oy->unsynced=0;\n  oy->headerbytes=0;\n  oy->bodybytes=0;\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/***********************************************/\n", "func_signal": "static void floor1_free_info(vorbis_info_floor *i)", "code": "{\n  vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;\n  if(info){\n    memset(info,0,sizeof(*info));\n    _ogg_free(info);\n  }\n}", "path": "Source\\Engine\\oggsdk\\libvorbis\\lib\\floor1.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* clear non-flat storage within */\n", "func_signal": "int ogg_sync_clear(ogg_sync_state *oy)", "code": "{\n  if(oy){\n    if(oy->data)_ogg_free(oy->data);\n    ogg_sync_init(oy);\n  }\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n", "func_signal": "voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)", "code": "{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}", "path": "Source\\Engine\\freetype\\src\\gzip\\zutil.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* helper to initialize lookup for direct-table CRC (illustrative; we\n   use the static init below) */\n", "func_signal": "static ogg_uint32_t _ogg_crc_entry(unsigned long index)", "code": "{\n  int           i;\n  unsigned long r;\n\n  r = index << 24;\n  for (i=0; i<8; i++)\n    if (r & 0x80000000UL)\n      r = (r << 1) ^ 0x04c11db7; /* The same as the ethernet generator\n\t\t\t\t    polynomial, although we use an\n\t\t\t\t    unreflected alg and an init/final\n\t\t\t\t    of 0, not 0xffffffff */\n    else\n       r<<=1;\n return (r & 0xffffffffUL);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* initialize Bark scale and normalization lookups.  We could do this\n   with static tables, but Vorbis allows a number of possible\n   combinations, so it's best to do it computationally.\n\n   The below is authoritative in terms of defining scale mapping.\n   Note that the scale depends on the sampling rate as well as the\n   linear block and mapping sizes */\n", "func_signal": "static void floor0_map_lazy_init(vorbis_block      *vb,\n\t\t\t\t vorbis_info_floor *infoX,\n\t\t\t\t vorbis_look_floor0 *look)", "code": "{\n  if(!look->linearmap[vb->W]){\n    vorbis_dsp_state   *vd=vb->vd;\n    vorbis_info        *vi=vd->vi;\n    codec_setup_info   *ci=vi->codec_setup;\n    vorbis_info_floor0 *info=(vorbis_info_floor0 *)infoX;\n    int W=vb->W;\n    int n=ci->blocksizes[W]/2,j;\n\n    /* we choose a scaling constant so that:\n       floor(bark(rate/2-1)*C)=mapped-1\n     floor(bark(rate/2)*C)=mapped */\n    float scale=look->ln/toBARK(info->rate/2.f);\n    \n    /* the mapping from a linear scale to a smaller bark scale is\n       straightforward.  We do *not* make sure that the linear mapping\n       does not skip bark-scale bins; the decoder simply skips them and\n       the encoder may do what it wishes in filling them.  They're\n       necessary in some mapping combinations to keep the scale spacing\n       accurate */\n    look->linearmap[W]=_ogg_malloc((n+1)*sizeof(**look->linearmap));\n    for(j=0;j<n;j++){\n      int val=floor( toBARK((info->rate/2.f)/n*j) \n\t\t     *scale); /* bark numbers represent band edges */\n      if(val>=look->ln)val=look->ln-1; /* guard against the approximation */\n      look->linearmap[W][j]=val;\n    }\n    look->linearmap[W][j]=-1;\n    look->n[W]=n;\n  }\n}", "path": "Source\\Engine\\oggsdk\\libvorbis\\lib\\floor0.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* add the incoming page to the stream state; we decompose the page\n   into packet segments here as well. */\n", "func_signal": "int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)", "code": "{\n  unsigned char *header=og->header;\n  unsigned char *body=og->body;\n  long           bodysize=og->body_len;\n  int            segptr=0;\n\n  int version=ogg_page_version(og);\n  int continued=ogg_page_continued(og);\n  int bos=ogg_page_bos(og);\n  int eos=ogg_page_eos(og);\n  ogg_int64_t granulepos=ogg_page_granulepos(og);\n  int serialno=ogg_page_serialno(og);\n  long pageno=ogg_page_pageno(og);\n  int segments=header[26];\n  \n  /* clean up 'returned data' */\n  {\n    long lr=os->lacing_returned;\n    long br=os->body_returned;\n\n    /* body data */\n    if(br){\n      os->body_fill-=br;\n      if(os->body_fill)\n\tmemmove(os->body_data,os->body_data+br,os->body_fill);\n      os->body_returned=0;\n    }\n\n    if(lr){\n      /* segment table */\n      if(os->lacing_fill-lr){\n\tmemmove(os->lacing_vals,os->lacing_vals+lr,\n\t\t(os->lacing_fill-lr)*sizeof(*os->lacing_vals));\n\tmemmove(os->granule_vals,os->granule_vals+lr,\n\t\t(os->lacing_fill-lr)*sizeof(*os->granule_vals));\n      }\n      os->lacing_fill-=lr;\n      os->lacing_packet-=lr;\n      os->lacing_returned=0;\n    }\n  }\n\n  /* check the serial number */\n  if(serialno!=os->serialno)return(-1);\n  if(version>0)return(-1);\n\n  _os_lacing_expand(os,segments+1);\n\n  /* are we in sequence? */\n  if(pageno!=os->pageno){\n    int i;\n\n    /* unroll previous partial packet (if any) */\n    for(i=os->lacing_packet;i<os->lacing_fill;i++)\n      os->body_fill-=os->lacing_vals[i]&0xff;\n    os->lacing_fill=os->lacing_packet;\n\n    /* make a note of dropped data in segment table */\n    if(os->pageno!=-1){\n      os->lacing_vals[os->lacing_fill++]=0x400;\n      os->lacing_packet++;\n    }\n  }\n\n  /* are we a 'continued packet' page?  If so, we may need to skip\n     some segments */\n  if(continued){\n    if(os->lacing_fill<1 || \n       os->lacing_vals[os->lacing_fill-1]==0x400){\n      bos=0;\n      for(;segptr<segments;segptr++){\n\tint val=header[27+segptr];\n\tbody+=val;\n\tbodysize-=val;\n\tif(val<255){\n\t  segptr++;\n\t  break;\n\t}\n      }\n    }\n  }\n  \n  if(bodysize){\n    _os_body_expand(os,bodysize);\n    memcpy(os->body_data+os->body_fill,body,bodysize);\n    os->body_fill+=bodysize;\n  }\n\n  {\n    int saved=-1;\n    while(segptr<segments){\n      int val=header[27+segptr];\n      os->lacing_vals[os->lacing_fill]=val;\n      os->granule_vals[os->lacing_fill]=-1;\n      \n      if(bos){\n\tos->lacing_vals[os->lacing_fill]|=0x100;\n\tbos=0;\n      }\n      \n      if(val<255)saved=os->lacing_fill;\n      \n      os->lacing_fill++;\n      segptr++;\n      \n      if(val<255)os->lacing_packet=os->lacing_fill;\n    }\n  \n    /* set the granulepos on the last granuleval of the last full packet */\n    if(saved!=-1){\n      os->granule_vals[saved]=granulepos;\n    }\n\n  }\n\n  if(eos){\n    os->e_o_s=1;\n    if(os->lacing_fill>0)\n      os->lacing_vals[os->lacing_fill-1]|=0x200;\n  }\n\n  os->pageno=pageno+1;\n\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* sync the stream.  This is meant to be useful for finding page\n   boundaries.\n\n   return values for this:\n  -n) skipped n bytes\n   0) page not ready; more data (no bytes skipped)\n   n) page synced at current location; page length n bytes\n   \n*/\n", "func_signal": "long ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og)", "code": "{\n  unsigned char *page=oy->data+oy->returned;\n  unsigned char *next;\n  long bytes=oy->fill-oy->returned;\n  \n  if(oy->headerbytes==0){\n    int headerbytes,i;\n    if(bytes<27)return(0); /* not enough for a header */\n    \n    /* verify capture pattern */\n    if(memcmp(page,\"OggS\",4))goto sync_fail;\n    \n    headerbytes=page[26]+27;\n    if(bytes<headerbytes)return(0); /* not enough for header + seg table */\n    \n    /* count up body length in the segment table */\n    \n    for(i=0;i<page[26];i++)\n      oy->bodybytes+=page[27+i];\n    oy->headerbytes=headerbytes;\n  }\n  \n  if(oy->bodybytes+oy->headerbytes>bytes)return(0);\n  \n  /* The whole test page is buffered.  Verify the checksum */\n  {\n    /* Grab the checksum bytes, set the header field to zero */\n    char chksum[4];\n    ogg_page log;\n    \n    memcpy(chksum,page+22,4);\n    memset(page+22,0,4);\n    \n    /* set up a temp page struct and recompute the checksum */\n    log.header=page;\n    log.header_len=oy->headerbytes;\n    log.body=page+oy->headerbytes;\n    log.body_len=oy->bodybytes;\n    ogg_page_checksum_set(&log);\n    \n    /* Compare */\n    if(memcmp(chksum,page+22,4)){\n      /* D'oh.  Mismatch! Corrupt page (or miscapture and not a page\n\t at all) */\n      /* replace the computed checksum with the one actually read in */\n      memcpy(page+22,chksum,4);\n      \n      /* Bad checksum. Lose sync */\n      goto sync_fail;\n    }\n  }\n  \n  /* yes, have a whole page all ready to go */\n  {\n    unsigned char *page=oy->data+oy->returned;\n    long bytes;\n\n    if(og){\n      og->header=page;\n      og->header_len=oy->headerbytes;\n      og->body=page+oy->headerbytes;\n      og->body_len=oy->bodybytes;\n    }\n\n    oy->unsynced=0;\n    oy->returned+=(bytes=oy->headerbytes+oy->bodybytes);\n    oy->headerbytes=0;\n    oy->bodybytes=0;\n    return(bytes);\n  }\n  \n sync_fail:\n  \n  oy->headerbytes=0;\n  oy->bodybytes=0;\n  \n  /* search for possible capture */\n  next=memchr(page+1,'O',bytes-1);\n  if(!next)\n    next=oy->data+oy->fill;\n\n  oy->returned=next-oy->data;\n  return(-(next-page));\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* NOTE:\nIf a page consists of a packet begun on a previous page, and a new\npacket begun (but not completed) on this page, the return will be:\n  ogg_page_packets(page)   ==1, \n  ogg_page_continued(page) !=0\n\nIf a page happens to be a single packet that was begun on a\nprevious page, and spans to the next page (in the case of a three or\nmore page packet), the return will be: \n  ogg_page_packets(page)   ==0, \n  ogg_page_continued(page) !=0\n*/\n", "func_signal": "int ogg_page_packets(ogg_page *og)", "code": "{\n  int i,n=og->header[26],count=0;\n  for(i=0;i<n;i++)\n    if(og->header[27+i]<255)count++;\n  return(count);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* initialize the struct to a known state */\n", "func_signal": "int ogg_sync_init(ogg_sync_state *oy)", "code": "{\n  if(oy){\n    memset(oy,0,sizeof(*oy));\n  }\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* Helpers for ogg_stream_encode; this keeps the structure and\n   what's happening fairly clear */\n", "func_signal": "static void _os_body_expand(ogg_stream_state *os,int needed)", "code": "{\n  if(os->body_storage<=os->body_fill+needed){\n    os->body_storage+=(needed+1024);\n    os->body_data=_ogg_realloc(os->body_data,os->body_storage*sizeof(*os->body_data));\n  }\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* submit data to the internal buffer of the framing engine */\n", "func_signal": "int ogg_stream_packetin(ogg_stream_state *os,ogg_packet *op)", "code": "{\n  int lacing_vals=op->bytes/255+1,i;\n\n  if(os->body_returned){\n    /* advance packet data according to the body_returned pointer. We\n       had to keep it around to return a pointer into the buffer last\n       call */\n    \n    os->body_fill-=os->body_returned;\n    if(os->body_fill)\n      memmove(os->body_data,os->body_data+os->body_returned,\n\t      os->body_fill);\n    os->body_returned=0;\n  }\n \n  /* make sure we have the buffer storage */\n  _os_body_expand(os,op->bytes);\n  _os_lacing_expand(os,lacing_vals);\n\n  /* Copy in the submitted packet.  Yes, the copy is a waste; this is\n     the liability of overly clean abstraction for the time being.  It\n     will actually be fairly easy to eliminate the extra copy in the\n     future */\n\n  memcpy(os->body_data+os->body_fill,op->packet,op->bytes);\n  os->body_fill+=op->bytes;\n\n  /* Store lacing vals for this packet */\n  for(i=0;i<lacing_vals-1;i++){\n    os->lacing_vals[os->lacing_fill+i]=255;\n    os->granule_vals[os->lacing_fill+i]=os->granulepos;\n  }\n  os->lacing_vals[os->lacing_fill+i]=(op->bytes)%255;\n  os->granulepos=os->granule_vals[os->lacing_fill+i]=op->granulepos;\n\n  /* flag the first segment as the beginning of the packet */\n  os->lacing_vals[os->lacing_fill]|= 0x100;\n\n  os->lacing_fill+=lacing_vals;\n\n  /* for the sake of completeness */\n  os->packetno++;\n\n  if(op->e_o_s)os->e_o_s=1;\n\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* the floor has already been filtered to only include relevant sections */\n", "func_signal": "static int accumulate_fit(const float *flr,const float *mdct,\n\t\t\t  int x0, int x1,lsfit_acc *a,\n\t\t\t  int n,vorbis_info_floor1 *info)", "code": "{\n  long i;\n  int quantized=vorbis_dBquant(flr+x0);\n\n  long xa=0,ya=0,x2a=0,y2a=0,xya=0,na=0, xb=0,yb=0,x2b=0,y2b=0,xyb=0,nb=0;\n\n  memset(a,0,sizeof(*a));\n  a->x0=x0;\n  a->x1=x1;\n  if(x1>=n)x1=n-1;\n\n  for(i=x0;i<=x1;i++){\n    int quantized=vorbis_dBquant(flr+i);\n    if(quantized){\n      if(mdct[i]+info->twofitatten>=flr[i]){\n\txa  += i;\n\tya  += quantized;\n\tx2a += i*i;\n\ty2a += quantized*quantized;\n\txya += i*quantized;\n\tna++;\n      }else{\n\txb  += i;\n\tyb  += quantized;\n\tx2b += i*i;\n\ty2b += quantized*quantized;\n\txyb += i*quantized;\n\tnb++;\n      }\n    }\n  }\n\n  xb+=xa;\n  yb+=ya;\n  x2b+=x2a;\n  y2b+=y2a;\n  xyb+=xya;\n  nb+=na;\n\n  /* weight toward the actually used frequencies if we meet the threshhold */\n  {\n    int weight=nb*info->twofitweight/(na+1);\n\n    a->xa=xa*weight+xb;\n    a->ya=ya*weight+yb;\n    a->x2a=x2a*weight+x2b;\n    a->y2a=y2a*weight+y2b;\n    a->xya=xya*weight+xyb;\n    a->an=na*weight+nb;\n  }\n\n  return(na);\n}", "path": "Source\\Engine\\oggsdk\\libvorbis\\lib\\floor1.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* This util takes a training-collected file listing codewords used in\n   LSP fitting, then generates new codeword lengths for maximally\n   efficient integer-bits entropy encoding.\n\n   command line:\n   latticetune book.vqh input.vqd [unused_entriesp]\n\n   latticetune produces book.vqh on stdout */\n", "func_signal": "int main(int argc,char *argv[])", "code": "{\n  codebook *b;\n  static_codebook *c;\n  long *lengths;\n  long *hits;\n\n  int entries=-1,dim=-1,guard=1;\n  FILE *in=NULL;\n  char *line,*name;\n  long j;\n\n  if(argv[1]==NULL){\n    fprintf(stderr,\"Need a lattice codebook on the command line.\\n\");\n    exit(1);\n  }\n  if(argv[2]==NULL){\n    fprintf(stderr,\"Need a codeword data file on the command line.\\n\");\n    exit(1);\n  }\n  if(argv[3]!=NULL)guard=0;\n\n  {\n    char *ptr;\n    char *filename=strdup(argv[1]);\n\n    b=codebook_load(filename);\n    c=(static_codebook *)(b->c);\n    \n    ptr=strrchr(filename,'.');\n    if(ptr){\n      *ptr='\\0';\n      name=strdup(filename);\n    }else{\n      name=strdup(filename);\n    }\n  }\n\n  if(c->maptype!=1){\n    fprintf(stderr,\"Provided book is not a latticebook.\\n\");\n    exit(1);\n  }\n\n  entries=b->entries;\n  dim=b->dim;\n\n  hits=_ogg_malloc(entries*sizeof(long));\n  lengths=_ogg_calloc(entries,sizeof(long));\n  for(j=0;j<entries;j++)hits[j]=guard;\n\n  in=fopen(argv[2],\"r\");\n  if(!in){\n    fprintf(stderr,\"Could not open input file %s\\n\",argv[2]);\n    exit(1);\n  }\n\n  if(!strrcmp_i(argv[0],\"latticetune\")){\n    long lines=0;\n    line=setup_line(in);\n    while(line){      \n      long code;\n      lines++;\n      if(!(lines&0xfff))spinnit(\"codewords so far...\",lines);\n      \n      if(sscanf(line,\"%ld\",&code)==1)\n\thits[code]++;\n\n      line=setup_line(in);\n    }\n  }\n\n  /* now we simply count already collated by-entry data */\n  if(!strrcmp_i(argv[0],\"res0tune\") || !strrcmp_i(argv[0],\"res1tune\")){\n\n    line=setup_line(in);\n    while(line){\n\n      /* code:hits\\n */\n      /* likely to have multiple listing for each code entry; must\n         accumulate */\n\n      char *pos=strchr(line,':');\n      if(pos){\n\tlong code=atol(line);\n\tlong val=atol(pos+1); \n\thits[code]+=val;\n      }\n\n      line=setup_line(in);\n    }\n  }\n\n  fclose(in);\n\n  /* build the codeword lengths */\n  build_tree_from_lengths0(entries,hits,lengths);\n\n  c->lengthlist=lengths;\n  write_codebook(stdout,name,c); \n\n  {\n    long bins=_book_maptype1_quantvals(c);\n    long i,k,base=c->lengthlist[0];\n    for(i=0;i<entries;i++)\n      if(c->lengthlist[i]>base)base=c->lengthlist[i];\n    \n    for(j=0;j<entries;j++){\n      if(c->lengthlist[j]){\n\tint indexdiv=1;\n\tfprintf(stderr,\"%4ld: \",j);\n\tfor(k=0;k<c->dim;k++){      \n\t  int index= (j/indexdiv)%bins;\n\t  fprintf(stderr,\"%+3.1f,\", c->quantlist[index]*_float32_unpack(c->q_delta)+\n\t\t _float32_unpack(c->q_min));\n\t  indexdiv*=bins;\n\t}\n\tfprintf(stderr,\"\\t|\");\n\tfor(k=0;k<base-c->lengthlist[j];k++)fprintf(stderr,\"*\");\n\tfprintf(stderr,\"\\n\");\n      }\n    }\n  }\n  \n  fprintf(stderr,\"\\r                                                     \"\n\t  \"\\nDone.\\n\");\n  exit(0);\n}", "path": "Source\\Engine\\oggsdk\\libvorbis\\vq\\latticetune.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/***********************************************/\n", "func_signal": "static void floor0_free_info(vorbis_info_floor *i)", "code": "{\n  vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;\n  if(info){\n    memset(info,0,sizeof(*info));\n    _ogg_free(info);\n  }\n}", "path": "Source\\Engine\\oggsdk\\libvorbis\\lib\\floor0.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/* _clear does not free os, only the non-flat storage within */\n", "func_signal": "int ogg_stream_clear(ogg_stream_state *os)", "code": "{\n  if(os){\n    if(os->body_data)_ogg_free(os->body_data);\n    if(os->lacing_vals)_ogg_free(os->lacing_vals);\n    if(os->granule_vals)_ogg_free(os->granule_vals);\n\n    memset(os,0,sizeof(*os));    \n  }\n  return(0);\n}", "path": "Source\\Engine\\oggsdk\\libogg\\src\\framing.c", "repo_name": "jp9000/JimEngine", "stars": 16, "license": "None", "language": "c", "size": 8848}
{"docstring": "/**\n * Read CONFIG_DATA by register 0x2c to get its sub system data.\n * @param reg it should be set bus, device, function and so forth.\n * @return sub system.\n */\n", "func_signal": "static inline u_int32_t read_pci_sub_system(struct pci_configuration_register *reg)", "code": "{\n\treg->reg_num = 0x2c;\n\n\treturn read_pci_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Read CONFIG_DATA by register 0x04.\n * @param reg it should be set bus, device, function and so forth.\n * @return status.\n */\n", "func_signal": "static inline u_int32_t read_pci_command_register(struct pci_configuration_register *reg)", "code": "{\n\treg->reg_num = 0x4;\n\n\treturn read_pci_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Printing out all PCI devices which kernel found.\n */\n", "func_signal": "void show_all_pci_device(void)", "code": "{\n\tstruct pci_device_list *p;\n\n\tfor (p = pci_device_head.next; p != &pci_device_head; p = p->next)\n\t\tprintk(\"Found Device: Bus %d:Devfn %d:Vender 0x%x:Device 0x%x:func %d:header 0x%x:Class 0x%lx-0x%lx:Multi %d\\n\", \n\t\t       p->data.bus, p->data.devfn, \n\t\t       p->data.vender, p->data.devid, \n\t\t       p->data.func, p->data.header_type,\n\t\t       p->data.base_class, p->data.sub_class,\n\t\t       p->data.multi);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Set ENABLE bit to 0 and write data to CONFIG_ADDRESS.\n */\n", "func_signal": "static inline void finish_access_to_config_data(struct pci_configuration_register *reg)", "code": "{\n\treg->enable_bit = 0;\n\twrite_pci_config_address(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Initialize interrupt service routine.\n */\n", "func_signal": "void setup_inir(void)", "code": "{\n\tint i;\n\n\tremap_irq();\n\n\tset_interrupt_handler();\n\n\t// set dummy handler function.\n\tfor (i = 0; i < INTERRUPT_HANDLER_NUM; i++)\n\t\tset_handler_func(i, NULL);\n\n\tlidt();\n\n\t// we are able to enable interrput.\n\tsti();\n\n}", "path": "kernel\\interrupt.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Read pci class.\n * @param reg it should be set bus, device, function and so forth.\n * @return PCI class.\n */\n", "func_signal": "static inline u_int32_t read_pci_class(struct pci_configuration_register *reg)", "code": "{\n\treg->reg_num = 0x8;\n\n\treturn read_pci_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Find PCI device by bus number and device number.\n * @param bus bus numer.\n * @param dev device number.\n * @return always 0.\n */\n", "func_signal": "static u_int32_t find_pci_data(u_int8_t bus, u_int8_t dev)", "code": "{\n\tu_int32_t data;\n\tu_int32_t status;\n\tu_int32_t class;\n\tu_int32_t header;\n\tu_int32_t subsystem;\n\n\tint i;\n\tstruct pci_configuration_register reg;\n\tbool b;\n\n\t// At first, check function number zero.\n\tmemset(&reg, 0, sizeof(reg));\n\treg.bus_num = bus;\n\treg.dev_num = dev;\n\n\t// Check all function numbers.\n\tfor (i = 0; i < PCI_FUNCTION_MAX; i++) {\n\t\treg.func_num = i;\t\t\n\t\tdata = read_pci_reg00(&reg);\n\t\tif (data != 0xffffffff) {\n\n\t\t\tclass = read_pci_class(&reg);\n\t\t\theader = read_pci_header_type(&reg);\n\t\t\tsubsystem = read_pci_sub_system(&reg);\n\t\t\tstatus = read_pci_command_register(&reg);\n\n\t\t\tb = store_pci_device_to_list(bus, dev, data, i, class, header, subsystem);\n\t\t\tif (!b)\n\t\t\t\tKERN_ABORT(\"kmalloc failed\");\n\n\t\t\t// if it's not a multi function, we need to search other function.\n\t\t\tif (i == 0 && !is_multi_function(header))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Convert decimal number to string.\n * @param n is what you want to convert to string.\n * @param buf is store converting result.\n */\n", "func_signal": "void itoa(long n, char *buf)", "code": "{\n\tint i, len, sign;\n        char tmp[BUF_SIZE] = { 0 };\n        i = len = sign = 0;\n\n        if (n < 0) {\n\t\tsign = 1;\n                n = -n;\n        }\n\n        do {\n                tmp[len++] = n % 10 + '0';\n\t}  while ((n /= 10) > 0 && len < BUF_SIZE - 2);\n\n\tif (sign)\n                tmp[len++] = '-';\n\n\tfor (i = 0; i < len; i++)\n                buf[i] = tmp[len - 1 - i];\n        buf[i] = 0x0;\n}", "path": "klibs\\stdlib.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Setup interrupt handler to Interrupt descriptor table.\n */\n", "func_signal": "static void set_interrupt_handler(void)", "code": "{\n\tint i;\n\tint size = sizeof(handler_info) / sizeof(handler_info[0]);\n\tstruct handler_define *p = &handler_info[0];\n\n\tfor (i = 0; i < size; i++, p++)\n\t\tset_handler(i, p->base, p->selector, p->type);\n\n}", "path": "kernel\\interrupt.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Check PCI device.\n * @param vender id.\n * @param device number.\n * @param function number.\n * @return if found it returns pci device information structure.\n */\n", "func_signal": "struct pci_device *get_pci_device(u_int16_t vender, u_int16_t device, u_int8_t function)", "code": "{\n\tstruct pci_device_list *p;\n\n\tfor (p = pci_device_head.next; p != &pci_device_head; p = p->next) {\n\t\tif (p->data.vender == vender &&\n\t\t    p->data.devid == device &&\n\t\t    p->data.func == function)\n\t\t\treturn &p->data;\n\t}\n\n\treturn NULL;\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * IRQ interrupt  routine.\n * @param regs is register.\n */\n", "func_signal": "void irq_handler(u_int32_t int_no, struct registers regs)", "code": "{\n\tif (int_no >= 40)\n\t\toutb(0xA0, 0x20);\n       \n\toutb(0x20, 0x20);\n\n\tif (handlers[int_no].func != NULL)\n\t\thandlers[int_no].func(&regs);\n}", "path": "kernel\\interrupt.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Do lidt instruction.\n */\n", "func_signal": "static void lidt(void)", "code": "{\n\tidtr.limit = sizeof(intr_table) - 1;\n\tidtr.base = (u_int32_t) intr_table;\n\n\t// load the idtr.\n\t__asm__ __volatile__ (\"lidt %0;\\n\\t\" ::\"m\"(idtr));\n\n}", "path": "kernel\\interrupt.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Write to CONFIG_DATA.\n * @param reg it should be set bus, device, function and so forth.\n * @param data should be write to CONFIG_DATA\n * @return data from CONFIG_DATA.\n */\n", "func_signal": "static void write_pci_data(struct pci_configuration_register *reg, u_int32_t data)", "code": "{\n\t// Enable bit should be 1 before read PCI_DATA.\n\treg->enable_bit = 1;\n\n\t// write data to CONFIG_ADDRESS.\n\twrite_pci_config_address(reg);\n\t\n\toutl(CONFIG_DATA_1, data);\n\tfinish_access_to_config_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Read CONFIG_DATA by register 0x00.\n * @param reg it should be set bus, device, function and so forth.\n * @return vendor id and device id.\n */\n", "func_signal": "static inline u_int32_t read_pci_reg00(struct pci_configuration_register *reg)", "code": "{\n\treg->reg_num = 0;\n\n\treturn read_pci_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Convert decimal number to hex string.\n * @param n is what you want to convert to hex string.\n * @param buf is store converting result.\n */\n", "func_signal": "void itox(unsigned long n, char *buf)", "code": "{\n        int i, len;\n        char tmp[BUF_SIZE] = { 0 };\n        i = len = 0;\n        static const char hex[] = {\n                '0', '1', '2', '3', '4', '5',\n                '6', '7', '8', '9', 'a', 'b',\n                'c', 'd', 'e', 'f' };\n\n        do {\n                tmp[len++] = hex[n % 16];\n        }  while ((n /= 16) > 0 && len < BUF_SIZE - 1);\n\n        for (i = 0; i < len; i++)\n                buf[i] = tmp[len - 1 - i];\n        buf[i] = 0x0;\n}", "path": "klibs\\stdlib.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Write data to CONFIG_ADDRESS.\n * @param reg it should be set bus, device, function and so forth.\n */\n", "func_signal": "static inline void write_pci_config_address(const struct pci_configuration_register *reg)", "code": "{\n\tu_int32_t data = 0;\n\n\tdata = (reg->enable_bit << 31) |\n\t\t(reg->reserved << 24) | \n\t\t(reg->bus_num << 16) | \n\t\t(reg->dev_num << 11) | \n\t\t(reg->func_num << 8) |\n\t\treg->reg_num;\n\n\toutl(PCI_CONFIG_ADDRESS, data);\t\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Interrupt service routine.\n * @param regs is register.\n */\n", "func_signal": "void isr_handler(u_int32_t int_no, struct registers regs)", "code": "{\n\tif (handlers[int_no].func != NULL)\n\t\thandlers[int_no].func(&regs);\n}", "path": "kernel\\interrupt.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Write data to PCI_DATA.\n * @param pci\n * @param reg_num which register you want to write.\n * @param data.\n */\n", "func_signal": "void pci_data_write(struct pci_device *pci, u_int8_t reg_num, u_int32_t data)", "code": "{\n\tstruct pci_configuration_register reg;\n\n\tmemset(&reg, 0, sizeof(reg));\n\n\treg.reg_num = reg_num;\n\treg.func_num = pci->func;\n\treg.dev_num = pci->devfn;\n\treg.bus_num = pci->bus;\n\t\n\twrite_pci_data(&reg, data);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Read CONFIG_DATA by register 0x0c to check if it's PCI brigdge or not.\n * @param reg it should be set bus, device, function and so forth.\n * @return vendor id and device id.\n */\n", "func_signal": "static inline u_int32_t read_pci_header_type(struct pci_configuration_register *reg)", "code": "{\n\treg->reg_num = 0xc;\n\n\treturn read_pci_data(reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/**\n * Read data from PCI_DATA.\n * @param pci\n * @param reg_num which register you want to read.\n * @return data from PCI_DATA.\n */\n", "func_signal": "u_int32_t pci_data_read(struct pci_device *pci, u_int8_t reg_num)", "code": "{\n\tstruct pci_configuration_register reg;\n\n\tmemset(&reg, 0, sizeof(reg));\n\n\treg.reg_num = reg_num;\n\treg.func_num = pci->func;\n\treg.dev_num = pci->devfn;\n\treg.bus_num = pci->bus;\n\n\treturn read_pci_data(&reg);\n}", "path": "drivers\\pci\\pci.c", "repo_name": "masami256/miko", "stars": 16, "license": "gpl-2.0", "language": "c", "size": 707}
{"docstring": "/* Regression test for SF bug #824420.\n   Checks that an xmlns:prefix attribute set in an attribute's default\n   value isn't misinterpreted.\n*/\n", "func_signal": "START_TEST(test_ns_in_attribute_default_without_namespaces)", "code": "{\n    char *text =\n        \"<!DOCTYPE e:element [\\n\"\n        \"  <!ATTLIST e:element\\n\"\n        \"    xmlns:e CDATA 'http://example.com/'>\\n\"\n        \"      ]>\\n\"\n        \"<e:element/>\";\n\n    if (XML_Parse(parser, text, strlen(text), XML_TRUE) == XML_STATUS_ERROR)\n        xml_failure(parser);\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Dummy handlers for when we need to set a handler to tickle a bug,\n   but it doesn't need to do anything.\n*/\n", "func_signal": "static void XMLCALL\ndummy_start_doctype_handler(void           *userData,\n                            const XML_Char *doctypeName,\n                            const XML_Char *sysid,\n                            const XML_Char *pubid,\n                            int            has_internal_subset)", "code": "{}\n\nstatic void XMLCALL\ndummy_end_doctype_handler(void *userData)\n{}\n\nstatic void XMLCALL\ndummy_entity_decl_handler(void           *userData,\n                          const XML_Char *entityName,\n                          int            is_parameter_entity,\n                          const XML_Char *value,\n                          int            value_length,\n                          const XML_Char *base,\n                          const XML_Char *systemId,\n                          const XML_Char *publicId,\n                          const XML_Char *notationName)\n{}\n\nstatic void XMLCALL\ndummy_notation_decl_handler(void *userData,\n                            const XML_Char *notationName,\n                            const XML_Char *base,\n                            const XML_Char *systemId,\n                            const XML_Char *publicId)\n{}\n\nstatic void XMLCALL\ndummy_element_decl_handler(void *userData,\n                           const XML_Char *name,\n                           XML_Content *model)\n{}\n\nstatic void XMLCALL\ndummy_attlist_decl_handler(void           *userData,\n                           const XML_Char *elname,\n                           const XML_Char *attname,\n                           const XML_Char *att_type,\n                           const XML_Char *dflt,\n                           int            isrequired)\n{}\n\nstatic void XMLCALL\ndummy_comment_handler(void *userData, const XML_Char *data)\n{}\n\nstatic void XMLCALL\ndummy_pi_handler(void *userData, const XML_Char *target, const XML_Char *data)\n{}\n\nstatic void XMLCALL\ndummy_start_element(void *userData,\n                    const XML_Char *name, const XML_Char **atts)\n{}\n\n\n/*\n * Character & encoding tests.\n */\n\nSTART_TEST(test_nul_byte)\n{\n    char text[] = \"<doc>\\0</doc>\";\n\n    /* test that a NUL byte (in US-ASCII data) is an error */\n    if (XML_Parse(parser, text, sizeof(text) - 1, XML_TRUE) == XML_STATUS_OK)\n        fail(\"Parser did not report error on NUL-byte.\");\n    if (XML_GetErrorCode(parser) != XML_ERROR_INVALID_TOKEN)\n        xml_failure(parser);\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #620106. */\n", "func_signal": "static int XMLCALL\nexternal_entity_loader_set_encoding(XML_Parser parser,\n                                    const XML_Char *context,\n                                    const XML_Char *base,\n                                    const XML_Char *systemId,\n                                    const XML_Char *publicId)", "code": "{\n    /* This text says it's an unsupported encoding, but it's really\n       UTF-8, which we tell Expat using XML_SetEncoding().\n    */\n    char *text =\n        \"<?xml encoding='iso-8859-3'?>\"\n        \"\\xC3\\xA9\";\n    XML_Parser extparser;\n\n    extparser = XML_ExternalEntityParserCreate(parser, context, NULL);\n    if (extparser == NULL)\n        fail(\"Could not create external entity parser.\");\n    if (!XML_SetEncoding(extparser, \"utf-8\"))\n        fail(\"XML_SetEncoding() ignored for external entity\");\n    if (  XML_Parse(extparser, text, strlen(text), XML_TRUE)\n          == XML_STATUS_ERROR) {\n        xml_failure(parser);\n        return 0;\n    }\n    return 1;\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Test that no error is reported for unknown entities if we have read\n   an external subset, and standalone is false.\n*/\n", "func_signal": "START_TEST(test_wfc_undeclared_entity_with_external_subset)", "code": "{\n    char *text =\n        \"<?xml version='1.0' encoding='us-ascii'?>\\n\"\n        \"<!DOCTYPE doc SYSTEM 'foo'>\\n\"\n        \"<doc>&entity;</doc>\";\n    char *foo_text =\n        \"<!ELEMENT doc (#PCDATA)*>\";\n\n    XML_SetParamEntityParsing(parser, XML_PARAM_ENTITY_PARSING_ALWAYS);\n    XML_SetUserData(parser, foo_text);\n    XML_SetExternalEntityRefHandler(parser, external_entity_loader);\n    if (XML_Parse(parser, text, strlen(text), XML_TRUE) == XML_STATUS_ERROR)\n        xml_failure(parser);\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #477667.\n   This test assures that any 8-bit character followed by a 7-bit\n   character will not be mistakenly interpreted as a valid UTF-8\n   sequence.\n*/\n", "func_signal": "START_TEST(test_illegal_utf8)", "code": "{\n    char text[100];\n    int i;\n\n    for (i = 128; i <= 255; ++i) {\n        sprintf(text, \"<e>%ccd</e>\", i);\n        if (XML_Parse(parser, text, strlen(text), XML_TRUE) == XML_STATUS_OK) {\n            sprintf(text,\n                    \"expected token error for '%c' (ordinal %d) in UTF-8 text\",\n                    i, i);\n            fail(text);\n        }\n        else if (XML_GetErrorCode(parser) != XML_ERROR_INVALID_TOKEN)\n            xml_failure(parser);\n        /* Reset the parser since we use the same parser repeatedly. */\n        XML_ParserReset(parser, NULL);\n    }\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Test that no error is reported for unknown entities if we don't\n   read an external subset.  This was fixed in Expat 1.95.5.\n*/\n", "func_signal": "START_TEST(test_wfc_undeclared_entity_unread_external_subset)", "code": "{\n    char *text =\n        \"<!DOCTYPE doc SYSTEM 'foo'>\\n\"\n        \"<doc>&entity;</doc>\";\n\n    if (XML_Parse(parser, text, strlen(text), XML_TRUE) == XML_STATUS_ERROR)\n        xml_failure(parser);\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #5 for SF bug #653180. */\n", "func_signal": "START_TEST(test_column_number_after_error)", "code": "{\n    char *text =\n        \"<a>\\n\"\n        \"  <b>\\n\"\n        \"  </a>\";  /* missing </b> */\n    int colno;\n    if (XML_Parse(parser, text, strlen(text), XML_FALSE) != XML_STATUS_ERROR)\n        fail(\"Expected a parse error\");\n\n    colno = XML_GetCurrentColumnNumber(parser);\n    if (colno != 4) { \n        char buffer[100];\n        sprintf(buffer, \"expected 4 columns, saw %d\", colno);\n        fail(buffer);\n    }\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #4 for SF bug #653180. */\n", "func_signal": "START_TEST(test_line_number_after_error)", "code": "{\n    char *text =\n        \"<a>\\n\"\n        \"  <b>\\n\"\n        \"  </a>\";  /* missing </b> */\n    int lineno;\n    if (XML_Parse(parser, text, strlen(text), XML_FALSE) != XML_STATUS_ERROR)\n        fail(\"Expected a parse error\");\n\n    lineno = XML_GetCurrentLineNumber(parser);\n    if (lineno != 3) {\n        char buffer[100];\n        sprintf(buffer, \"expected 3 lines, saw %d\", lineno);\n        fail(buffer);\n    }\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/*\n * Element event tests.\n */\n", "func_signal": "static void XMLCALL\nend_element_event_handler(void *userData, const XML_Char *name)", "code": "{\n    CharData *storage = (CharData *) userData;\n    CharData_AppendString(storage, \"/\");\n    CharData_AppendXMLChars(storage, name, -1);\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #584832. */\n", "func_signal": "static int XMLCALL\nUnknownEncodingHandler(void *data,const XML_Char *encoding,XML_Encoding *info)", "code": "{\n    if (strcmp(encoding,\"unsupported-encoding\") == 0) {\n        int i;\n        for (i = 0; i < 256; ++i)\n            info->map[i] = i;\n        info->data = NULL;\n        info->convert = NULL;\n        info->release = NULL;\n        return XML_STATUS_OK;\n    }\n    return XML_STATUS_ERROR;\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Test that an error is reported for unknown entities if we have read\n   an external subset, and standalone is true.\n*/\n", "func_signal": "START_TEST(test_wfc_undeclared_entity_with_external_subset_standalone)", "code": "{\n    char *text =\n        \"<?xml version='1.0' encoding='us-ascii' standalone='yes'?>\\n\"\n        \"<!DOCTYPE doc SYSTEM 'foo'>\\n\"\n        \"<doc>&entity;</doc>\";\n    char *foo_text =\n        \"<!ELEMENT doc (#PCDATA)*>\";\n\n    XML_SetParamEntityParsing(parser, XML_PARAM_ENTITY_PARSING_ALWAYS);\n    XML_SetUserData(parser, foo_text);\n    XML_SetExternalEntityRefHandler(parser, external_entity_loader);\n    expect_failure(text,\n                   XML_ERROR_UNDEFINED_ENTITY,\n                   \"Parser did not report undefined entity (external DTD).\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #491986. */\n", "func_signal": "START_TEST(test_danish_latin1)", "code": "{\n    char *text =\n        \"<?xml version='1.0' encoding='iso-8859-1'?>\\n\"\n        \"<e>Jrgen </e>\";\n    run_character_check(text,\n             \"J\\xC3\\xB8rgen \\xC3\\xA6\\xC3\\xB8\\xC3\\xA5\\xC3\\x86\\xC3\\x98\\xC3\\x85\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #3 for SF bug #653180. */\n", "func_signal": "START_TEST(test_line_and_column_numbers_inside_handlers)", "code": "{\n    char *text =\n        \"<a>\\n\"        /* Unix end-of-line */\n        \"  <b>\\r\\n\"    /* Windows end-of-line */\n        \"    <c/>\\r\"   /* Mac OS end-of-line */\n        \"  </b>\\n\"\n        \"  <d>\\n\"\n        \"    <f/>\\n\"\n        \"  </d>\\n\"\n        \"</a>\";\n    char *expected =\n        \"<a> at col:0 line:1\\n\"\n        \"<b> at col:2 line:2\\n\"\n        \"<c> at col:4 line:3\\n\"\n        \"</c> at col:8 line:3\\n\"\n        \"</b> at col:2 line:4\\n\"\n        \"<d> at col:2 line:5\\n\"\n        \"<f> at col:4 line:6\\n\"\n        \"</f> at col:8 line:6\\n\"\n        \"</d> at col:2 line:7\\n\"\n        \"</a> at col:0 line:8\\n\";\n    CharData storage;\n\n    CharData_Init(&storage);\n    XML_SetUserData(parser, &storage);\n    XML_SetStartElementHandler(parser, start_element_event_handler2);\n    XML_SetEndElementHandler(parser, end_element_event_handler2);\n    if (XML_Parse(parser, text, strlen(text), XML_TRUE) == XML_STATUS_ERROR)\n        xml_failure(parser);\n\n    CharData_CheckString(&storage, expected); \n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #695401: unbound prefix. */\n", "func_signal": "START_TEST(test_ns_unbound_prefix_on_element)", "code": "{\n    char *text = \"<a:doc/>\";\n    expect_failure(text,\n                   XML_ERROR_UNBOUND_PREFIX,\n                   \"did not report unbound prefix on element\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #1 for SF bug #673791. */\n", "func_signal": "START_TEST(test_ns_prefix_with_empty_uri_1)", "code": "{\n    char *text =\n        \"<doc xmlns:prefix='http://xml.libexpat.org/'>\\n\"\n        \"  <e xmlns:prefix=''/>\\n\"\n        \"</doc>\";\n\n    expect_failure(text,\n                   XML_ERROR_UNDECLARING_PREFIX,\n                   \"Did not report re-setting namespace\"\n                   \" URI with prefix to ''.\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #3 for SF bug #673791. */\n", "func_signal": "START_TEST(test_ns_prefix_with_empty_uri_3)", "code": "{\n    char *text =\n        \"<!DOCTYPE doc [\\n\"\n        \"  <!ELEMENT doc EMPTY>\\n\"\n        \"  <!ATTLIST doc\\n\"\n        \"    xmlns:prefix CDATA ''>\\n\"\n        \"]>\\n\"\n        \"<doc/>\";\n\n    expect_failure(text,\n                   XML_ERROR_UNDECLARING_PREFIX,\n                   \"Didn't report attr default setting NS w/ prefix to ''.\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/*\n * Namespaces tests.\n */\n", "func_signal": "static void\nnamespace_setup(void)", "code": "{\n    parser = XML_ParserCreateNS(NULL, ' ');\n    if (parser == NULL)\n        fail(\"Parser not created.\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Test that an error is reported for unknown entities if we don't\n   read an external subset, but have been declared standalone.\n*/\n", "func_signal": "START_TEST(test_wfc_undeclared_entity_standalone)", "code": "{\n    char *text =\n        \"<?xml version='1.0' encoding='us-ascii' standalone='yes'?>\\n\"\n        \"<!DOCTYPE doc SYSTEM 'foo'>\\n\"\n        \"<doc>&entity;</doc>\";\n\n    expect_failure(text,\n                   XML_ERROR_UNDEFINED_ENTITY,\n                   \"Parser did not report undefined entity (standalone).\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test for SF bug #695401: unbound prefix. */\n", "func_signal": "START_TEST(test_ns_unbound_prefix_on_attribute)", "code": "{\n    char *text = \"<doc a:attr=''/>\";\n    expect_failure(text,\n                   XML_ERROR_UNBOUND_PREFIX,\n                   \"did not report unbound prefix on attribute\");\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
{"docstring": "/* Regression test #2 for SF bug #653180. */\n", "func_signal": "START_TEST(test_column_number_after_parse)", "code": "{\n    char *text = \"<tag></tag>\";\n    int colno;\n\n    if (XML_Parse(parser, text, strlen(text), XML_FALSE) == XML_STATUS_ERROR)\n        xml_failure(parser);\n    colno = XML_GetCurrentColumnNumber(parser);\n    if (colno != 11) {\n        char buffer[100];\n        sprintf(buffer, \"expected 11 columns, saw %d\", colno);\n        fail(buffer);\n    }\n}", "path": "libs\\cocos2dx\\platform\\third_party\\airplay\\expat\\tests\\runtests.c", "repo_name": "alinradut/SimpleGameCocos2D-x", "stars": 22, "license": "other", "language": "c", "size": 29286}
